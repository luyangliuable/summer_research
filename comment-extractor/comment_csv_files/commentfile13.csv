/*

 * linux/fs/nls/mac-greek.c

 *

 * Charset macgreek translation tables.

 * Generated automatically from the Unicode and charset

 * tables from the Unicode Organization (www.unicode.org).

 * The Unicode to charset table has only exact mappings.

/*

 * COPYRIGHT AND PERMISSION NOTICE

 *

 * Copyright 1991-2012 Unicode, Inc.  All rights reserved.  Distributed under

 * the Terms of Use in http://www.unicode.org/copyright.html.

 *

 * Permission is hereby granted, free of charge, to any person obtaining a

 * copy of the Unicode data files and any associated documentation (the "Data

 * Files") or Unicode software and any associated documentation (the

 * "Software") to deal in the Data Files or Software without restriction,

 * including without limitation the rights to use, copy, modify, merge,

 * publish, distribute, and/or sell copies of the Data Files or Software, and

 * to permit persons to whom the Data Files or Software are furnished to do

 * so, provided that (a) the above copyright notice(s) and this permission

 * notice appear with all copies of the Data Files or Software, (b) both the

 * above copyright notice(s) and this permission notice appear in associated

 * documentation, and (c) there is clear notice in each modified Data File or

 * in the Software as well as in the documentation associated with the Data

 * File(s) or Software that the data or software has been modified.

 *

 * THE DATA FILES AND SOFTWARE ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY

 * KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF

 * THIRD PARTY RIGHTS.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS

 * INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT

 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF

 * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR

 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR

 * PERFORMANCE OF THE DATA FILES OR SOFTWARE.

 *

 * Except as contained in this notice, the name of a copyright holder shall

 * not be used in advertising or otherwise to promote the sale, use or other

 * dealings in these Data Files or Software without prior written

 * authorization of the copyright holder.

 0x00 */

 0x10 */

 0x20 */

 0x30 */

 0x40 */

 0x50 */

 0x60 */

 0x70 */

 0x80 */

 0x90 */

 0xa0 */

 0xb0 */

 0xc0 */

 0xd0 */

 0xe0 */

 0xf0 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * linux/fs/nls/nls_iso8859-13.c

 *

 * Charset iso8859-13 translation tables.

 * The Unicode to charset table has only exact mappings.

 0x00*/

 0x10*/

 0x20*/

 0x30*/

 0x40*/

 0x50*/

 0x60*/

 0x70*/

 0x80*/

 0x90*/

 0xa0*/

 0xb0*/

 0xc0*/

 0xd0*/

 0xe0*/

 0xf0*/

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * linux/fs/nls/nls_cp1250.c

 *

 * Charset cp1250 translation tables.

 * Generated automatically from the Unicode and charset

 * tables from the Unicode Organization (www.unicode.org).

 * The Unicode to charset table has only exact mappings.

 0x00*/

 0x10*/

 0x20*/

 0x30*/

 0x40*/

 0x50*/

 0x60*/

 0x70*/

 0x80*/

 0x90*/

 0xa0*/

 0xb0*/

 0xc0*/

 0xd0*/

 0xe0*/

 0xf0*/

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * linux/fs/nls/nls_koi8-u.c

 *

 * Charset koi8-u translation tables.

 * The Unicode to charset table has only exact mappings.

 0x00*/

 0x10*/

 0x20*/

 0x30*/

 0x40*/

 0x50*/

 0x60*/

 0x70*/

 0x80*/

 0x90*/

 0xa0*/

 0xb0*/

 0xc0*/

 0xd0*/

 0xe0*/

 0xf0*/

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * linux/fs/nls/nls_iso8859-6.c

 *

 * Charset iso8859-6 translation tables.

 * Generated automatically from the Unicode and charset

 * tables from the Unicode Organization (www.unicode.org).

 * The Unicode to charset table has only exact mappings.

 0x00*/

 0x10*/

 0x20*/

 0x30*/

 0x40*/

 0x50*/

 0x60*/

 0x70*/

 0x80*/

 0x90*/

 0xa0*/

 0xb0*/

 0xc0*/

 0xd0*/

 0xe0*/

 0xf0*/

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

/*

 * linux/fs/nls/nls_cp855.c

 *

 * Charset cp855 translation tables.

 * Generated automatically from the Unicode and charset

 * tables from the Unicode Organization (www.unicode.org).

 * The Unicode to charset table has only exact mappings.

 0x00*/

 0x10*/

 0x20*/

 0x30*/

 0x40*/

 0x50*/

 0x60*/

 0x70*/

 0x80*/

 0x90*/

 0xa0*/

 0xb0*/

 0xc0*/

 0xd0*/

 0xe0*/

 0xf0*/

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * linux/fs/nls/mac-inuit.c

 *

 * Charset macinuit translation tables.

 * Generated automatically from the Unicode and charset

 * tables from the Unicode Organization (www.unicode.org).

 * The Unicode to charset table has only exact mappings.

/*

 * COPYRIGHT AND PERMISSION NOTICE

 *

 * Copyright 1991-2012 Unicode, Inc.  All rights reserved.  Distributed under

 * the Terms of Use in http://www.unicode.org/copyright.html.

 *

 * Permission is hereby granted, free of charge, to any person obtaining a

 * copy of the Unicode data files and any associated documentation (the "Data

 * Files") or Unicode software and any associated documentation (the

 * "Software") to deal in the Data Files or Software without restriction,

 * including without limitation the rights to use, copy, modify, merge,

 * publish, distribute, and/or sell copies of the Data Files or Software, and

 * to permit persons to whom the Data Files or Software are furnished to do

 * so, provided that (a) the above copyright notice(s) and this permission

 * notice appear with all copies of the Data Files or Software, (b) both the

 * above copyright notice(s) and this permission notice appear in associated

 * documentation, and (c) there is clear notice in each modified Data File or

 * in the Software as well as in the documentation associated with the Data

 * File(s) or Software that the data or software has been modified.

 *

 * THE DATA FILES AND SOFTWARE ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY

 * KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF

 * THIRD PARTY RIGHTS.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS

 * INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT

 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF

 * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR

 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR

 * PERFORMANCE OF THE DATA FILES OR SOFTWARE.

 *

 * Except as contained in this notice, the name of a copyright holder shall

 * not be used in advertising or otherwise to promote the sale, use or other

 * dealings in these Data Files or Software without prior written

 * authorization of the copyright holder.

 0x00 */

 0x10 */

 0x20 */

 0x30 */

 0x40 */

 0x50 */

 0x60 */

 0x70 */

 0x80 */

 0x90 */

 0xa0 */

 0xb0 */

 0xc0 */

 0xd0 */

 0xe0 */

 0xf0 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * linux/fs/nls/nls_cp850.c

 *

 * Charset cp850 translation tables.

 * Generated automatically from the Unicode and charset

 * tables from the Unicode Organization (www.unicode.org).

 * The Unicode to charset table has only exact mappings.

 0x00*/

 0x10*/

 0x20*/

 0x30*/

 0x40*/

 0x50*/

 0x60*/

 0x70*/

 0x80*/

 0x90*/

 0xa0*/

 0xb0*/

 0xc0*/

 0xd0*/

 0xe0*/

 0xf0*/

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * linux/fs/nls/mac-romanian.c

 *

 * Charset macromanian translation tables.

 * Generated automatically from the Unicode and charset

 * tables from the Unicode Organization (www.unicode.org).

 * The Unicode to charset table has only exact mappings.

/*

 * COPYRIGHT AND PERMISSION NOTICE

 *

 * Copyright 1991-2012 Unicode, Inc.  All rights reserved.  Distributed under

 * the Terms of Use in http://www.unicode.org/copyright.html.

 *

 * Permission is hereby granted, free of charge, to any person obtaining a

 * copy of the Unicode data files and any associated documentation (the "Data

 * Files") or Unicode software and any associated documentation (the

 * "Software") to deal in the Data Files or Software without restriction,

 * including without limitation the rights to use, copy, modify, merge,

 * publish, distribute, and/or sell copies of the Data Files or Software, and

 * to permit persons to whom the Data Files or Software are furnished to do

 * so, provided that (a) the above copyright notice(s) and this permission

 * notice appear with all copies of the Data Files or Software, (b) both the

 * above copyright notice(s) and this permission notice appear in associated

 * documentation, and (c) there is clear notice in each modified Data File or

 * in the Software as well as in the documentation associated with the Data

 * File(s) or Software that the data or software has been modified.

 *

 * THE DATA FILES AND SOFTWARE ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY

 * KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF

 * THIRD PARTY RIGHTS.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS

 * INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT

 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF

 * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR

 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR

 * PERFORMANCE OF THE DATA FILES OR SOFTWARE.

 *

 * Except as contained in this notice, the name of a copyright holder shall

 * not be used in advertising or otherwise to promote the sale, use or other

 * dealings in these Data Files or Software without prior written

 * authorization of the copyright holder.

 0x00 */

 0x10 */

 0x20 */

 0x30 */

 0x40 */

 0x50 */

 0x60 */

 0x70 */

 0x80 */

 0x90 */

 0xa0 */

 0xb0 */

 0xc0 */

 0xd0 */

 0xe0 */

 0xf0 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * linux/fs/nls/nls_cp950.c

 *

 * Charset cp950 translation tables.

 * This translation table was generated automatically, the

 * original table can be download from the Microsoft website.

 * (http://www.microsoft.com/typography/unicode/unicodecp.htm)

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x07 */

 0x08-0x0F */

 0x10-0x17 */

 0x18-0x1F */

 0x20-0x27 */

 0x28-0x2F */

 0x30-0x37 */

 0x38-0x3F */

 0x40-0x47 */

 0x48-0x4F */

 0x50-0x57 */

 0x58-0x5F */

 0x60-0x67 */

 0x68-0x6F */

 0x70-0x77 */

 0x78-0x7F */

 0x80-0x87 */

 0x88-0x8F */

 0x90-0x97 */

 0x98-0x9F */

 0xA0-0xA7 */

 0xA8-0xAF */

 0xB0-0xB7 */

 0xB8-0xBF */

 0xC0-0xC7 */

 0xC8-0xCF */

 0xD0-0xD7 */

 0xD8-0xDF */

 0xE0-0xE7 */

 0xE8-0xEF */

 0xF0-0xF7 */

 0xF8-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0x00-0x03 */

 0x04-0x07 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0x00-0x03 */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0xE8-0xEB */

 0xEC-0xEF */

 0xF0-0xF3 */

 0xF4-0xF7 */

 0xF8-0xFB */

 0xFC-0xFF */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x00-0x03 */

 0x04-0x07 */

 0x08-0x0B */

 0x0C-0x0F */

 0x10-0x13 */

 0x14-0x17 */

 0x18-0x1B */

 0x1C-0x1F */

 0x20-0x23 */

 0x24-0x27 */

 0x28-0x2B */

 0x2C-0x2F */

 0x30-0x33 */

 0x34-0x37 */

 0x38-0x3B */

 0x3C-0x3F */

 0x40-0x43 */

 0x44-0x47 */

 0x48-0x4B */

 0x4C-0x4F */

 0x50-0x53 */

 0x54-0x57 */

 0x58-0x5B */

 0x5C-0x5F */

 0x60-0x63 */

 0x64-0x67 */

 0x68-0x6B */

 0x6C-0x6F */

 0x70-0x73 */

 0x74-0x77 */

 0x78-0x7B */

 0x7C-0x7F */

 0x80-0x83 */

 0x84-0x87 */

 0x88-0x8B */

 0x8C-0x8F */

 0x90-0x93 */

 0x94-0x97 */

 0x98-0x9B */

 0x9C-0x9F */

 0xA0-0xA3 */

 0xA4-0xA7 */

 0xA8-0xAB */

 0xAC-0xAF */

 0xB0-0xB3 */

 0xB4-0xB7 */

 0xB8-0xBB */

 0xBC-0xBF */

 0xC0-0xC3 */

 0xC4-0xC7 */

 0xC8-0xCB */

 0xCC-0xCF */

 0xD0-0xD3 */

 0xD4-0xD7 */

 0xD8-0xDB */

 0xDC-0xDF */

 0xE0-0xE3 */

 0xE4-0xE7 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * linux/fs/nls/nls_cp860.c

 *

 * Charset cp860 translation tables.

 * Generated automatically from the Unicode and charset

 * tables from the Unicode Organization (www.unicode.org).

 * The Unicode to charset table has only exact mappings.

 0x00*/

 0x10*/

 0x20*/

 0x30*/

 0x40*/

 0x50*/

 0x60*/

 0x70*/

 0x80*/

 0x90*/

 0xa0*/

 0xb0*/

 0xc0*/

 0xd0*/

 0xe0*/

 0xf0*/

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * linux/fs/nls/nls_cp775.c

 *

 * Charset cp775 translation tables.

 * Generated automatically from the Unicode and charset

 * tables from the Unicode Organization (www.unicode.org).

 * The Unicode to charset table has only exact mappings.

 0x00*/

 0x10*/

 0x20*/

 0x30*/

 0x40*/

 0x50*/

 0x60*/

 0x70*/

 0x80*/

 0x90*/

 0xa0*/

 0xb0*/

 0xc0*/

 0xd0*/

 0xe0*/

 0xf0*/

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * linux/fs/nls/nls_cp864.c

 *

 * Charset cp864 translation tables.

 * Generated automatically from the Unicode and charset

 * tables from the Unicode Organization (www.unicode.org).

 * The Unicode to charset table has only exact mappings.

 0x00*/

 0x10*/

 0x20*/

 0x30*/

 0x40*/

 0x50*/

 0x60*/

 0x70*/

 0x80*/

 0x90*/

 0xa0*/

 0xb0*/

 0xc0*/

 0xd0*/

 0xe0*/

 0xf0*/

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * linux/fs/nls/mac-croatian.c

 *

 * Charset maccroatian translation tables.

 * Generated automatically from the Unicode and charset

 * tables from the Unicode Organization (www.unicode.org).

 * The Unicode to charset table has only exact mappings.

/*

 * COPYRIGHT AND PERMISSION NOTICE

 *

 * Copyright 1991-2012 Unicode, Inc.  All rights reserved.  Distributed under

 * the Terms of Use in http://www.unicode.org/copyright.html.

 *

 * Permission is hereby granted, free of charge, to any person obtaining a

 * copy of the Unicode data files and any associated documentation (the "Data

 * Files") or Unicode software and any associated documentation (the

 * "Software") to deal in the Data Files or Software without restriction,

 * including without limitation the rights to use, copy, modify, merge,

 * publish, distribute, and/or sell copies of the Data Files or Software, and

 * to permit persons to whom the Data Files or Software are furnished to do

 * so, provided that (a) the above copyright notice(s) and this permission

 * notice appear with all copies of the Data Files or Software, (b) both the

 * above copyright notice(s) and this permission notice appear in associated

 * documentation, and (c) there is clear notice in each modified Data File or

 * in the Software as well as in the documentation associated with the Data

 * File(s) or Software that the data or software has been modified.

 *

 * THE DATA FILES AND SOFTWARE ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY

 * KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF

 * THIRD PARTY RIGHTS.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS

 * INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT

 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF

 * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR

 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR

 * PERFORMANCE OF THE DATA FILES OR SOFTWARE.

 *

 * Except as contained in this notice, the name of a copyright holder shall

 * not be used in advertising or otherwise to promote the sale, use or other

 * dealings in these Data Files or Software without prior written

 * authorization of the copyright holder.

 0x00 */

 0x10 */

 0x20 */

 0x30 */

 0x40 */

 0x50 */

 0x60 */

 0x70 */

 0x80 */

 0x90 */

 0xa0 */

 0xb0 */

 0xc0 */

 0xd0 */

 0xe0 */

 0xf0 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * linux/fs/nls/nls_euc-jp.c

 *

 * Added `OSF/JVC Recommended Code Set Conversion Specification

 * between Japanese EUC and Shift-JIS' support: <hirofumi@mail.parknet.co.jp>

 * (http://www.opengroup.or.jp/jvc/cde/sjis-euc-e.html)

 JIS X 0208 (include NEC spesial characters) */

 Single Shift 2 */

 Single Shift 3 */

 G3 block */

 SJIS IBM extended characters to EUC map */

 EUC to SJIS IBM extended characters map (G3 JIS X 0212 block) */

 EUC to SJIS IBM extended characters map (G3 Upper block) */

 SJIS IBM extended characters to EUC */

 EUC to SJIS IBM extended characters (G3 JIS X 0212 block) */

 EUC to SJIS IBM extended characters (G3 Upper block) */

 EUC to SJIS IBM extended characters (G3 block) */

 NEC/IBM extended characters to IBM extended characters */

 translate SJIS into EUC-JP */

 JIS X 0201 KANA */

 NEC/IBM extended characters to IBM extended characters */

 User defined characters half low */

 User defined characters half high */

 IBM extended characters */

 JIS X 0208 (include NEC special characters) */

 Invalid characters */

 translate EUC-JP into SJIS */

 User defined characters half high */

 IBM extended characters */

 JIS X 0212 and Invalid characters*/

 'GETA' with SJIS coding */

 sjis_temp[0] = 0x81; */

 sjis_temp[1] = 0xAC; */

 JIS X 0201 KANA */

 User defined characters half low */

 JIS X 0208 (include NEC spesial characters) */

 Invalid characters */

 JIS X 0201 ROMAJI */

/*

 * linux/fs/nls/nls_iso8859-4.c

 *

 * Charset iso8859-4 translation tables.

 * Generated automatically from the Unicode and charset

 * tables from the Unicode Organization (www.unicode.org).

 * The Unicode to charset table has only exact mappings.

 0x00*/

 0x10*/

 0x20*/

 0x30*/

 0x40*/

 0x50*/

 0x60*/

 0x70*/

 0x80*/

 0x90*/

 0xa0*/

 0xb0*/

 0xc0*/

 0xd0*/

 0xe0*/

 0xf0*/

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * linux/fs/nls/nls_cp863.c

 *

 * Charset cp863 translation tables.

 * Generated automatically from the Unicode and charset

 * tables from the Unicode Organization (www.unicode.org).

 * The Unicode to charset table has only exact mappings.

 0x00*/

 0x10*/

 0x20*/

 0x30*/

 0x40*/

 0x50*/

 0x60*/

 0x70*/

 0x80*/

 0x90*/

 0xa0*/

 0xb0*/

 0xc0*/

 0xd0*/

 0xe0*/

 0xf0*/

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * linux/fs/nls/nls_iso8859-9.c

 *

 * Charset iso8859-9 translation tables.

 * Generated automatically from the Unicode and charset

 * tables from the Unicode Organization (www.unicode.org).

 * The Unicode to charset table has only exact mappings.

 0x00*/

 0x10*/

 0x20*/

 0x30*/

 0x40*/

 0x50*/

 0x60*/

 0x70*/

 0x80*/

 0x90*/

 0xa0*/

 0xb0*/

 0xc0*/

 0xd0*/

 0xe0*/

 0xf0*/

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * linux/fs/nls/nls_cp1255.c

 *

 * Charset cp1255 translation tables.

 * The Unicode to charset table has only exact mappings.

 0x00*/

 0x10*/

 0x20*/

 0x30*/

 0x40*/

 0x50*/

 0x60*/

 0x70*/

 0x80*/

 0x90*/

 0xa0*/

 0xb0*/

 0xc0*/

 0xd0*/

 0xe0*/

 0xf0*/

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * linux/fs/nls/nls_cp437.c

 *

 * Charset cp437 translation tables.

 * Generated automatically from the Unicode and charset

 * tables from the Unicode Organization (www.unicode.org).

 * The Unicode to charset table has only exact mappings.

 0x00*/

 0x10*/

 0x20*/

 0x30*/

 0x40*/

 0x50*/

 0x60*/

 0x70*/

 0x80*/

 0x90*/

 0xa0*/

 0xb0*/

 0xc0*/

 0xd0*/

 0xe0*/

 0xf0*/

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * linux/fs/nls/nls_iso8859-1.c

 *

 * Charset iso8859-1 translation tables.

 * Generated automatically from the Unicode and charset

 * tables from the Unicode Organization (www.unicode.org).

 * The Unicode to charset table has only exact mappings.

 0x00*/

 0x10*/

 0x20*/

 0x30*/

 0x40*/

 0x50*/

 0x60*/

 0x70*/

 0x80*/

 0x90*/

 0xa0*/

 0xb0*/

 0xc0*/

 0xd0*/

 0xe0*/

 0xf0*/

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * linux/fs/nls/nls_cp737.c

 *

 * Charset cp737 translation tables.

 * Generated automatically from the Unicode and charset

 * tables from the Unicode Organization (www.unicode.org).

 * The Unicode to charset table has only exact mappings.

 0x00*/

 0x10*/

 0x20*/

 0x30*/

 0x40*/

 0x50*/

 0x60*/

 0x70*/

 0x80*/

 0x90*/

 0xa0*/

 0xb0*/

 0xc0*/

 0xd0*/

 0xe0*/

 0xf0*/

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * linux/fs/nls/nls_cp869.c

 *

 * Charset cp869 translation tables.

 * Generated automatically from the Unicode and charset

 * tables from the Unicode Organization (www.unicode.org).

 * The Unicode to charset table has only exact mappings.

 0x00*/

 0x10*/

 0x20*/

 0x30*/

 0x40*/

 0x50*/

 0x60*/

 0x70*/

 0x80*/

 0x90*/

 0xa0*/

 0xb0*/

 0xc0*/

 0xd0*/

 0xe0*/

 0xf0*/

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * Module for handling utf8 just like any other charset.

 * By Urban Widmark 2000

 ? */

 no conversion */

/*

 * linux/fs/nls/nls_cp865.c

 *

 * Charset cp865 translation tables.

 * Generated automatically from the Unicode and charset

 * tables from the Unicode Organization (www.unicode.org).

 * The Unicode to charset table has only exact mappings.

 0x00*/

 0x10*/

 0x20*/

 0x30*/

 0x40*/

 0x50*/

 0x60*/

 0x70*/

 0x80*/

 0x90*/

 0xa0*/

 0xb0*/

 0xc0*/

 0xd0*/

 0xe0*/

 0xf0*/

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * linux/fs/nls/nls_koi8-r.c

 *

 * Charset koi8-r translation tables.

 * Generated automatically from the Unicode and charset

 * tables from the Unicode Organization (www.unicode.org).

 * The Unicode to charset table has only exact mappings.

 0x00*/

 0x10*/

 0x20*/

 0x30*/

 0x40*/

 0x50*/

 0x60*/

 0x70*/

 0x80*/

 0x90*/

 0xa0*/

 0xb0*/

 0xc0*/

 0xd0*/

 0xe0*/

 0xf0*/

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * linux/fs/nls/mac-gaelic.c

 *

 * Charset macgaelic translation tables.

 * Generated automatically from the Unicode and charset

 * tables from the Unicode Organization (www.unicode.org).

 * The Unicode to charset table has only exact mappings.

/*

 * COPYRIGHT AND PERMISSION NOTICE

 *

 * Copyright 1991-2012 Unicode, Inc.  All rights reserved.  Distributed under

 * the Terms of Use in http://www.unicode.org/copyright.html.

 *

 * Permission is hereby granted, free of charge, to any person obtaining a

 * copy of the Unicode data files and any associated documentation (the "Data

 * Files") or Unicode software and any associated documentation (the

 * "Software") to deal in the Data Files or Software without restriction,

 * including without limitation the rights to use, copy, modify, merge,

 * publish, distribute, and/or sell copies of the Data Files or Software, and

 * to permit persons to whom the Data Files or Software are furnished to do

 * so, provided that (a) the above copyright notice(s) and this permission

 * notice appear with all copies of the Data Files or Software, (b) both the

 * above copyright notice(s) and this permission notice appear in associated

 * documentation, and (c) there is clear notice in each modified Data File or

 * in the Software as well as in the documentation associated with the Data

 * File(s) or Software that the data or software has been modified.

 *

 * THE DATA FILES AND SOFTWARE ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY

 * KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF

 * THIRD PARTY RIGHTS.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS

 * INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT

 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF

 * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR

 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR

 * PERFORMANCE OF THE DATA FILES OR SOFTWARE.

 *

 * Except as contained in this notice, the name of a copyright holder shall

 * not be used in advertising or otherwise to promote the sale, use or other

 * dealings in these Data Files or Software without prior written

 * authorization of the copyright holder.

 0x00 */

 0x10 */

 0x20 */

 0x30 */

 0x40 */

 0x50 */

 0x60 */

 0x70 */

 0x80 */

 0x90 */

 0xa0 */

 0xb0 */

 0xc0 */

 0xd0 */

 0xe0 */

 0xf0 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * linux/fs/nls/mac-turkish.c

 *

 * Charset macturkish translation tables.

 * Generated automatically from the Unicode and charset

 * tables from the Unicode Organization (www.unicode.org).

 * The Unicode to charset table has only exact mappings.

/*

 * COPYRIGHT AND PERMISSION NOTICE

 *

 * Copyright 1991-2012 Unicode, Inc.  All rights reserved.  Distributed under

 * the Terms of Use in http://www.unicode.org/copyright.html.

 *

 * Permission is hereby granted, free of charge, to any person obtaining a

 * copy of the Unicode data files and any associated documentation (the "Data

 * Files") or Unicode software and any associated documentation (the

 * "Software") to deal in the Data Files or Software without restriction,

 * including without limitation the rights to use, copy, modify, merge,

 * publish, distribute, and/or sell copies of the Data Files or Software, and

 * to permit persons to whom the Data Files or Software are furnished to do

 * so, provided that (a) the above copyright notice(s) and this permission

 * notice appear with all copies of the Data Files or Software, (b) both the

 * above copyright notice(s) and this permission notice appear in associated

 * documentation, and (c) there is clear notice in each modified Data File or

 * in the Software as well as in the documentation associated with the Data

 * File(s) or Software that the data or software has been modified.

 *

 * THE DATA FILES AND SOFTWARE ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY

 * KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF

 * THIRD PARTY RIGHTS.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS

 * INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT

 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF

 * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR

 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR

 * PERFORMANCE OF THE DATA FILES OR SOFTWARE.

 *

 * Except as contained in this notice, the name of a copyright holder shall

 * not be used in advertising or otherwise to promote the sale, use or other

 * dealings in these Data Files or Software without prior written

 * authorization of the copyright holder.

 0x00 */

 0x10 */

 0x20 */

 0x30 */

 0x40 */

 0x50 */

 0x60 */

 0x70 */

 0x80 */

 0x90 */

 0xa0 */

 0xb0 */

 0xc0 */

 0xd0 */

 0xe0 */

 0xf0 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * linux/fs/nls/nls_iso8859-3.c

 *

 * Charset iso8859-3 translation tables.

 * Generated automatically from the Unicode and charset

 * tables from the Unicode Organization (www.unicode.org).

 * The Unicode to charset table has only exact mappings.

 0x00*/

 0x10*/

 0x20*/

 0x30*/

 0x40*/

 0x50*/

 0x60*/

 0x70*/

 0x80*/

 0x90*/

 0xa0*/

 0xb0*/

 0xc0*/

 0xd0*/

 0xe0*/

 0xf0*/

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * linux/fs/nls/nls_iso8859-14.c

 *

 * Charset iso8859-14 translation tables.

 *

 * Generated automatically from the Unicode and charset table

 * provided by the Unicode Organisation at

 * http://www.unicode.org/

 * The Unicode to charset table has only exact mappings.

 *

 * Rhys Jones, Swansea University Computer Society

 * rhys@sucs.swan.ac.uk

 0x00*/

 0x10*/

 0x20*/

 0x30*/

 0x40*/

 0x50*/

 0x60*/

 0x70*/

 0x80*/

 0x90*/

 0xa0*/

 0xb0*/

 0xc0*/

 0xd0*/

 0xe0*/

 0xf0*/

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * linux/fs/nls/mac-roman.c

 *

 * Charset macroman translation tables.

 * Generated automatically from the Unicode and charset

 * tables from the Unicode Organization (www.unicode.org).

 * The Unicode to charset table has only exact mappings.

/*

 * COPYRIGHT AND PERMISSION NOTICE

 *

 * Copyright 1991-2012 Unicode, Inc.  All rights reserved.  Distributed under

 * the Terms of Use in http://www.unicode.org/copyright.html.

 *

 * Permission is hereby granted, free of charge, to any person obtaining a

 * copy of the Unicode data files and any associated documentation (the "Data

 * Files") or Unicode software and any associated documentation (the

 * "Software") to deal in the Data Files or Software without restriction,

 * including without limitation the rights to use, copy, modify, merge,

 * publish, distribute, and/or sell copies of the Data Files or Software, and

 * to permit persons to whom the Data Files or Software are furnished to do

 * so, provided that (a) the above copyright notice(s) and this permission

 * notice appear with all copies of the Data Files or Software, (b) both the

 * above copyright notice(s) and this permission notice appear in associated

 * documentation, and (c) there is clear notice in each modified Data File or

 * in the Software as well as in the documentation associated with the Data

 * File(s) or Software that the data or software has been modified.

 *

 * THE DATA FILES AND SOFTWARE ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY

 * KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF

 * THIRD PARTY RIGHTS.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS

 * INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT

 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF

 * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR

 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR

 * PERFORMANCE OF THE DATA FILES OR SOFTWARE.

 *

 * Except as contained in this notice, the name of a copyright holder shall

 * not be used in advertising or otherwise to promote the sale, use or other

 * dealings in these Data Files or Software without prior written

 * authorization of the copyright holder.

 0x00 */

 0x10 */

 0x20 */

 0x30 */

 0x40 */

 0x50 */

 0x60 */

 0x70 */

 0x80 */

 0x90 */

 0xa0 */

 0xb0 */

 0xc0 */

 0xd0 */

 0xe0 */

 0xf0 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * linux/fs/nls/mac-centeuro.c

 *

 * Charset maccenteuro translation tables.

 * Generated automatically from the Unicode and charset

 * tables from the Unicode Organization (www.unicode.org).

 * The Unicode to charset table has only exact mappings.

/*

 * COPYRIGHT AND PERMISSION NOTICE

 *

 * Copyright 1991-2012 Unicode, Inc.  All rights reserved.  Distributed under

 * the Terms of Use in http://www.unicode.org/copyright.html.

 *

 * Permission is hereby granted, free of charge, to any person obtaining a

 * copy of the Unicode data files and any associated documentation (the "Data

 * Files") or Unicode software and any associated documentation (the

 * "Software") to deal in the Data Files or Software without restriction,

 * including without limitation the rights to use, copy, modify, merge,

 * publish, distribute, and/or sell copies of the Data Files or Software, and

 * to permit persons to whom the Data Files or Software are furnished to do

 * so, provided that (a) the above copyright notice(s) and this permission

 * notice appear with all copies of the Data Files or Software, (b) both the

 * above copyright notice(s) and this permission notice appear in associated

 * documentation, and (c) there is clear notice in each modified Data File or

 * in the Software as well as in the documentation associated with the Data

 * File(s) or Software that the data or software has been modified.

 *

 * THE DATA FILES AND SOFTWARE ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY

 * KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF

 * THIRD PARTY RIGHTS.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS

 * INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT

 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF

 * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR

 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR

 * PERFORMANCE OF THE DATA FILES OR SOFTWARE.

 *

 * Except as contained in this notice, the name of a copyright holder shall

 * not be used in advertising or otherwise to promote the sale, use or other

 * dealings in these Data Files or Software without prior written

 * authorization of the copyright holder.

 0x00 */

 0x10 */

 0x20 */

 0x30 */

 0x40 */

 0x50 */

 0x60 */

 0x70 */

 0x80 */

 0x90 */

 0xa0 */

 0xb0 */

 0xc0 */

 0xd0 */

 0xe0 */

 0xf0 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * linux/fs/nls/mac-celtic.c

 *

 * Charset macceltic translation tables.

 * Generated automatically from the Unicode and charset

 * tables from the Unicode Organization (www.unicode.org).

 * The Unicode to charset table has only exact mappings.

/*

 * COPYRIGHT AND PERMISSION NOTICE

 *

 * Copyright 1991-2012 Unicode, Inc.  All rights reserved.  Distributed under

 * the Terms of Use in http://www.unicode.org/copyright.html.

 *

 * Permission is hereby granted, free of charge, to any person obtaining a

 * copy of the Unicode data files and any associated documentation (the "Data

 * Files") or Unicode software and any associated documentation (the

 * "Software") to deal in the Data Files or Software without restriction,

 * including without limitation the rights to use, copy, modify, merge,

 * publish, distribute, and/or sell copies of the Data Files or Software, and

 * to permit persons to whom the Data Files or Software are furnished to do

 * so, provided that (a) the above copyright notice(s) and this permission

 * notice appear with all copies of the Data Files or Software, (b) both the

 * above copyright notice(s) and this permission notice appear in associated

 * documentation, and (c) there is clear notice in each modified Data File or

 * in the Software as well as in the documentation associated with the Data

 * File(s) or Software that the data or software has been modified.

 *

 * THE DATA FILES AND SOFTWARE ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY

 * KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF

 * THIRD PARTY RIGHTS.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS

 * INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT

 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF

 * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR

 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR

 * PERFORMANCE OF THE DATA FILES OR SOFTWARE.

 *

 * Except as contained in this notice, the name of a copyright holder shall

 * not be used in advertising or otherwise to promote the sale, use or other

 * dealings in these Data Files or Software without prior written

 * authorization of the copyright holder.

 0x00 */

 0x10 */

 0x20 */

 0x30 */

 0x40 */

 0x50 */

 0x60 */

 0x70 */

 0x80 */

 0x90 */

 0xa0 */

 0xb0 */

 0xc0 */

 0xd0 */

 0xe0 */

 0xf0 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

/*

 * linux/fs/nls/mac-cyrillic.c

 *

 * Charset maccyrillic translation tables.

 * Generated automatically from the Unicode and charset

 * tables from the Unicode Organization (www.unicode.org).

 * The Unicode to charset table has only exact mappings.

/*

 * COPYRIGHT AND PERMISSION NOTICE

 *

 * Copyright 1991-2012 Unicode, Inc.  All rights reserved.  Distributed under

 * the Terms of Use in http://www.unicode.org/copyright.html.

 *

 * Permission is hereby granted, free of charge, to any person obtaining a

 * copy of the Unicode data files and any associated documentation (the "Data

 * Files") or Unicode software and any associated documentation (the

 * "Software") to deal in the Data Files or Software without restriction,

 * including without limitation the rights to use, copy, modify, merge,

 * publish, distribute, and/or sell copies of the Data Files or Software, and

 * to permit persons to whom the Data Files or Software are furnished to do

 * so, provided that (a) the above copyright notice(s) and this permission

 * notice appear with all copies of the Data Files or Software, (b) both the

 * above copyright notice(s) and this permission notice appear in associated

 * documentation, and (c) there is clear notice in each modified Data File or

 * in the Software as well as in the documentation associated with the Data

 * File(s) or Software that the data or software has been modified.

 *

 * THE DATA FILES AND SOFTWARE ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY

 * KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF

 * THIRD PARTY RIGHTS.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS

 * INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT

 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF

 * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR

 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR

 * PERFORMANCE OF THE DATA FILES OR SOFTWARE.

 *

 * Except as contained in this notice, the name of a copyright holder shall

 * not be used in advertising or otherwise to promote the sale, use or other

 * dealings in these Data Files or Software without prior written

 * authorization of the copyright holder.

 0x00 */

 0x10 */

 0x20 */

 0x30 */

 0x40 */

 0x50 */

 0x60 */

 0x70 */

 0x80 */

 0x90 */

 0xa0 */

 0xb0 */

 0xc0 */

 0xd0 */

 0xe0 */

 0xf0 */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 0x00-0x07 */

 0x08-0x0f */

 0x10-0x17 */

 0x18-0x1f */

 0x20-0x27 */

 0x28-0x2f */

 0x30-0x37 */

 0x38-0x3f */

 0x40-0x47 */

 0x48-0x4f */

 0x50-0x57 */

 0x58-0x5f */

 0x60-0x67 */

 0x68-0x6f */

 0x70-0x77 */

 0x78-0x7f */

 0x80-0x87 */

 0x88-0x8f */

 0x90-0x97 */

 0x98-0x9f */

 0xa0-0xa7 */

 0xa8-0xaf */

 0xb0-0xb7 */

 0xb8-0xbf */

 0xc0-0xc7 */

 0xc8-0xcf */

 0xd0-0xd7 */

 0xd8-0xdf */

 0xe0-0xe7 */

 0xe8-0xef */

 0xf0-0xf7 */

 0xf8-0xff */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright (C) 2008 Red Hat, Inc., Eric Paris <eparis@redhat.com>

/*

 * fsnotify inode mark locking/lifetime/and refcnting

 *

 * REFCNT:

 * The group->recnt and mark->refcnt tell how many "things" in the kernel

 * currently are referencing the objects. Both kind of objects typically will

 * live inside the kernel with a refcnt of 2, one for its creation and one for

 * the reference a group and a mark hold to each other.

 * If you are holding the appropriate locks, you can take a reference and the

 * object itself is guaranteed to survive until the reference is dropped.

 *

 * LOCKING:

 * There are 3 locks involved with fsnotify inode marks and they MUST be taken

 * in order as follows:

 *

 * group->mark_mutex

 * mark->lock

 * mark->connector->lock

 *

 * group->mark_mutex protects the marks_list anchored inside a given group and

 * each mark is hooked via the g_list.  It also protects the groups private

 * data (i.e group limits).



 * mark->lock protects the marks attributes like its masks and flags.

 * Furthermore it protects the access to a reference of the group that the mark

 * is assigned to as well as the access to a reference of the inode/vfsmount

 * that is being watched by the mark.

 *

 * mark->connector->lock protects the list of marks anchored inside an

 * inode / vfsmount and each mark is hooked via the i_list.

 *

 * A list of notification marks relating to inode / mnt is contained in

 * fsnotify_mark_connector. That structure is alive as long as there are any

 * marks in the list and is also protected by fsnotify_mark_srcu. A mark gets

 * detached from fsnotify_mark_connector when last reference to the mark is

 * dropped.  Thus having mark reference is enough to protect mark->connector

 * pointer and to make sure fsnotify_mark_connector cannot disappear. Also

 * because we remove mark from g_list before dropping mark reference associated

 * with that, any mark found through g_list is guaranteed to have

 * mark->connector set until we drop group->mark_mutex.

 *

 * LIFETIME:

 * Inode marks survive between when they are added to an inode and when their

 * refcnt==0. Marks are also protected by fsnotify_mark_srcu.

 *

 * The inode mark can be cleared for a number of different reasons including:

 * - The inode is unlinked for the last time.  (fsnotify_inode_remove)

 * - The inode is being evicted from cache. (fsnotify_inode_delete)

 * - The fs the inode is on is unmounted.  (fsnotify_inode_delete/fsnotify_unmount_inodes)

 * - Something explicitly requests that it be removed.  (fsnotify_destroy_mark)

 * - The fsnotify_group associated with the mark is going away and all such marks

 *   need to be cleaned up. (fsnotify_clear_marks_by_group)

 *

 * This has the very interesting property of being able to run concurrently with

 * any (or all) other directions.

 1 jiffy */

 We can get detached connector here when inode is getting unlinked. */

/*

 * Calculate mask of events for a list of marks. The caller must make sure

 * connector and connector->obj cannot disappear under us.  Callers achieve

 * this by holding a mark->lock or mark->group->mark_mutex for a mark on this

 * list.

 Free all connectors queued for freeing once SRCU period ends */

 Drop object reference originally held by a connector */

 Currently only inode references are passed to be dropped */

 Catch marks that were actually never attached to object */

	/*

	 * We have to be careful so that traversals of obj_list under lock can

	 * safely grab mark reference.

	/*

	 * Note that we didn't update flags telling whether inode cares about

	 * what's happening with children. We update these flags from

	 * __fsnotify_parent() lazily when next event happens on one of our

	 * children.

/*

 * Get mark reference when we found the mark via lockless traversal of object

 * list. Mark can be already removed from the list by now and on its way to be

 * destroyed once SRCU period ends.

 *

 * Also pin the group so it doesn't disappear under us.

 mark is attached, group is still alive then */

/*

 * Puts marks and wakes up group destruction if necessary.

 *

 * Pairs with fsnotify_get_mark_safe()

		/*

		 * We abuse notification_waitq on group shutdown for waiting for

		 * all marks pinned when waiting for userspace.

 This can fail if mark is being removed */

	/*

	 * Now that both marks are pinned by refcount in the inode / vfsmount

	 * lists, we can drop SRCU lock, and safely resume the list iteration

	 * once userspace returns.

/*

 * Mark mark as detached, remove it from group list. Mark still stays in object

 * list until its last reference is dropped. Note that we rely on mark being

 * removed from group list before corresponding reference to it is dropped. In

 * particular we rely on mark->connector being valid while we hold

 * group->mark_mutex if we found the mark through g_list.

 *

 * Must be called with group->mark_mutex held. The caller must either hold

 * reference to the mark or be protected by fsnotify_mark_srcu.

 something else already called this function on this mark */

 Drop mark reference acquired in fsnotify_add_mark_locked() */

/*

 * Free fsnotify mark. The mark is actually only marked as being freed.  The

 * freeing is actually happening only once last reference to the mark is

 * dropped from a workqueue which first waits for srcu period end.

 *

 * Caller must have a reference to the mark or be protected by

 * fsnotify_mark_srcu.

 something else already called this function on this mark */

	/*

	 * Some groups like to know that marks are being freed.  This is a

	 * callback to the group function to let it know that this mark

	 * is being freed.

/*

 * Sorting function for lists of fsnotify marks.

 *

 * Fanotify supports different notification classes (reflected as priority of

 * notification group). Events shall be passed to notification groups in

 * decreasing priority order. To achieve this marks in notification lists for

 * inodes and vfsmounts are sorted so that priorities of corresponding groups

 * are descending.

 *

 * Furthermore correct handling of the ignore mask requires processing inode

 * and vfsmount marks of each group together. Using the group address as

 * further sort criterion provides a unique sorting order and thus we can

 * merge inode and vfsmount lists of marks in linear time and find groups

 * present in both lists.

 *

 * A return value of 1 signifies that b has priority over a.

 * A return value of 0 signifies that the two marks have to be handled together.

 * A return value of -1 signifies that a has priority over b.

 Cache fsid of filesystem containing the object */

	/*

	 * cmpxchg() provides the barrier so that readers of *connp can see

	 * only initialized structure

 Someone else created list structure for us */

/*

 * Get mark connector, make sure it is alive and return with its lock held.

 * This is for users that get connector pointer from inode or mount. Users that

 * hold reference to a mark on the list may directly lock connector->lock as

 * they are sure list cannot go away under them.

/*

 * Add mark into proper place in given list of marks. These marks may be used

 * for the fsnotify backend to determine which event types should be delivered

 * to which group and for which inodes. These marks are ordered according to

 * priority, highest number first, and then by the group's location in memory.

 Backend is expected to check for zero fsid (e.g. tmpfs) */

 Pairs with smp_rmb() in fanotify_get_fsid() */

		/*

		 * Backend is expected to check for non uniform fsid

		 * (e.g. btrfs), but maybe we missed something?

		 * Only allow setting conn->fsid once to non zero fsid.

		 * inotify and non-fid fanotify groups do not set nor test

		 * conn->fsid.

 is mark the first mark? */

 should mark be in the middle of the current list? */

 mark should be the last entry.  last is the current last entry */

	/*

	 * Since connector is attached to object using cmpxchg() we are

	 * guaranteed that connector initialization is fully visible by anyone

	 * seeing mark->connector set.

/*

 * Attach an initialized mark to a given group and fs object.

 * These marks may be used for the fsnotify backend to determine which

 * event types should be delivered to which group.

	/*

	 * LOCKING ORDER!!!!

	 * group->mark_mutex

	 * mark->lock

	 * mark->connector->lock

 for g_list */

/*

 * Given a list of marks, find the mark associated with given group. If found

 * take a reference to that mark and return it, else return NULL.

 Clear any marks in a group with given type mask */

 Skip selection step if we want to clear all marks. */

	/*

	 * We have to be really careful here. Anytime we drop mark_mutex, e.g.

	 * fsnotify_clear_marks_by_inode() can come and free marks. Even in our

	 * to_free list so we have to use mark_mutex even when accessing that

	 * list. And freeing mark requires us to drop mark_mutex. So we can

	 * reliably free only the first mark in the list. That's why we first

	 * move marks to free to to_free list in one go and then free marks in

	 * to_free list one by one.

 Destroy all marks attached to an object via connector */

	/*

	 * We have to be careful since we can race with e.g.

	 * fsnotify_clear_marks_by_group() and once we drop the conn->lock, the

	 * list can get modified. However we are holding mark reference and

	 * thus our mark cannot be removed from obj_list so we can continue

	 * iteration after regaining conn->lock.

	/*

	 * Detach list from object now so that we don't pin inode until all

	 * mark references get dropped. It would lead to strange results such

	 * as delaying inode deletion or blocking unmount.

/*

 * Nothing fancy, just initialize lists and locks and counters.

/*

 * Destroy all marks in destroy_list, waits for SRCU period to finish before

 * actually freeing marks.

 exchange the list head */

 Wait for all marks queued for destruction to be actually destroyed */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright (C) 2008 Red Hat, Inc., Eric Paris <eparis@redhat.com>

/*

 * Clear all of the marks on an inode when it is being evicted from core

/**

 * fsnotify_unmount_inodes - an sb is unmounting.  handle any watched inodes.

 * @sb: superblock being unmounted.

 *

 * Called during unmount with no locks held, so needs to be safe against

 * concurrent modifiers. We temporarily drop sb->s_inode_list_lock and CAN block.

		/*

		 * We cannot __iget() an inode in state I_FREEING,

		 * I_WILL_FREE, or I_NEW which is fine because by that point

		 * the inode cannot have any associated watches.

		/*

		 * If i_count is zero, the inode cannot have any watches and

		 * doing an __iget/iput with SB_ACTIVE clear would actually

		 * evict all inodes with zero i_count from icache which is

		 * unnecessarily violent and may in fact be illegal to do.

		 * However, we should have been called /after/ evict_inodes

		 * removed all zero refcount inodes, in any case.  Test to

		 * be sure.

 for each watch, send FS_UNMOUNT and then remove it */

 Wait for outstanding object references from connectors */

/*

 * Given an inode, first check if we care what happens to our children.  Inotify

 * and dnotify both tell their parents about events.  If we care about any event

 * on a child we run all of our children and set a dentry flag saying that the

 * parent cares.  Thus when an event happens on a child it can quickly tell if

 * if there is a need to find a parent and send the event to the parent.

 determine if the children should tell inode about their events */

	/* run all of the dentries associated with this inode.  Since this is a

		/* run all of the children of the original inode and fix their

		 * d_flags to indicate parental interest (their parent is the

 Are inode/sb/mount interested in parent and name info with this event? */

 We only send parent/name to inode/sb/mount for events on non-dir */

	/*

	 * All events that are possible on child can also may be reported with

	 * parent/name info to inode/sb/mount.  Otherwise, a watching parent

	 * could result in events reported with unexpected name info to sb/mount.

 Did either inode/sb/mount subscribe for events with parent/name? */

 Did they subscribe for this event with parent/name info? */

/*

 * Notify this dentry's parent about a child's events with child name info

 * if parent is watching or if inode/sb/mount are interested in events with

 * parent and name info.

 *

 * Notify only the child without name info if parent is not watching and

 * inode/sb/mount are not interested in events with parent and name info.

	/*

	 * Do inode/sb/mount care about parent and name info on non-dir?

	 * Do they care about any event at all?

 Does parent inode care about events on children? */

	/*

	 * Include parent/name in notification either if some notification

	 * groups require parent info or the parent is interested in this event.

 When notifying parent, child should be passed as data */

 Notify both parent and child with child name info */

 Check interest of this mark in case event was sent with two marks */

		/*

		 * parent_mark indicates that the parent inode is watching

		 * children and interested in this event, which is an event

		 * possible on child. But is *this mark* watching children and

		 * interested in this event?

		/*

		 * Some events can be sent on both parent dir and child marks

		 * (e.g. FS_ATTRIB).  If both parent dir and child are

		 * watching, report the event once to parent dir with name (if

		 * interested) and once to child without name (if interested).

		 * The child watcher is expecting an event without a file name

		 * and without the FS_EVENT_ON_CHILD flag.

 clear ignored on inode modification */

 does the object mark tell us to do something? */

/*

 * iter_info is a multi head priority queue of marks.

 * Pick a subset of marks from queue heads, all with the

 * same group and set the report_mask for selected subset.

 * Returns the report_mask of the selected subset.

 Choose max prio group among groups of all queue heads */

 Set the report mask for marks from same group as max prio group */

/*

 * Pop from iter_info multi head queue, the marks that were iterated in the

 * current iteration step.

/*

 * fsnotify - This is the main call to fsnotify.

 *

 * The VFS calls into hook specific functions in linux/fsnotify.h.

 * Those functions then in turn call here.  Here will call out to all of the

 * registered fsnotify_group.  Those groups can then use the notification event

 * in whatever means they feel necessary.

 *

 * @mask:	event type and flags

 * @data:	object that event happened on

 * @data_type:	type of object for fanotify_data_XXX() accessors

 * @dir:	optional directory associated with event -

 *		if @file_name is not NULL, this is the directory that

 *		@file_name is relative to

 * @file_name:	optional file name associated with event

 * @inode:	optional inode associated with event -

 *		If @dir and @inode are both non-NULL, event may be

 *		reported to both.

 * @cookie:	inotify rename cookie

 Dirent event - report on TYPE_INODE to dir */

		/*

		 * Event on child - report on TYPE_PARENT to dir if it is

		 * watching children and on TYPE_INODE to child.

	/*

	 * Optimization: srcu_read_lock() has a memory barrier which can

	 * be expensive.  It protects walking the *_fsnotify_marks lists.

	 * However, if we do not walk the lists, we do not have to do

	 * SRCU because we have no references to any objects and do not

	 * need SRCU to keep them "alive".

	/*

	 * if this is a modify event we may need to clear the ignored masks

	 * otherwise return if none of the marks care about this type of event.

	/*

	 * We need to merge inode/vfsmount/sb mark lists so that e.g. inode mark

	 * ignore masks are properly reflected for mount/sb mark notifications.

	 * That's why this traversal is so complicated...

 SPDX-License-Identifier: GPL-2.0

		/*

		 * IN_ALL_EVENTS represents all of the mask bits

		 * that we expose to userspace.  There is at

		 * least one bit (FS_EVENT_ON_CHILD) which is

		 * used only internally to the kernel.

 CONFIG_INOTIFY_USER */

 CONFIG_FANOTIFY */

 CONFIG_INOTIFY_USER || CONFIG_FANOTIFY */

 CONFIG_PROC_FS */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright (C) 2008 Red Hat, Inc., Eric Paris <eparis@redhat.com>

/*

 * Basic idea behind the notification queue: An fsnotify group (like inotify)

 * sends the userspace notification about events asynchronously some time after

 * the event happened.  When inotify gets an event it will need to add that

 * event to the group notify queue.  Since a single event might need to be on

 * multiple group's notification queues we can't add the event directly to each

 * queue and instead add a small "event_holder" to each queue.  This event_holder

 * has a pointer back to the original event.  Since the majority of events are

 * going to end up on one, and only one, notification queue we embed one

 * event_holder into each event.  This means we have a single allocation instead

 * of always needing two.  If the embedded event_holder is already in use by

 * another group a new event_holder (from fsnotify_event_holder_cachep) will be

 * allocated and used.

/**

 * fsnotify_get_cookie - return a unique cookie for use in synchronizing events.

 * Called from fsnotify_move, which is inlined into filesystem modules.

 Overflow events are per-group and we don't want to free them */

	/*

	 * If the event is still queued, we have a problem... Do an unreliable

	 * lockless check first to avoid locking in the common case. The

	 * locking may be necessary for permission events which got removed

	 * from the list by a different CPU than the one freeing the event.

/*

 * Try to add an event to the notification queue.

 * The group can later pull this event off the queue to deal with.

 * The group can use the @merge hook to merge the event with a queued event.

 * The group can use the @insert hook to insert the event into hash table.

 * The function returns:

 * 0 if the event was added to a queue

 * 1 if the event was merged with some other queued event

 * 2 if the event was not queued - either the queue of events has overflown

 *   or the group is shutting down.

 Queue overflow event only if it isn't already queued */

	/*

	 * We need to init list head for the case of overflow event so that

	 * check in fsnotify_add_event() works

/*

 * Return the first event on the notification list without removing it.

 * Returns NULL if the list is empty.

/*

 * Remove and return the first event from the notification list.  It is the

 * responsibility of the caller to destroy the obtained event

/*

 * Called when a group is being torn down to clean up any outstanding

 * event notifications.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright (C) 2008 Red Hat, Inc., Eric Paris <eparis@redhat.com>

/*

 * Final freeing of a group

/*

 * Stop queueing new events for this group. Once this function returns

 * fsnotify_add_event() will not add any new events to the group's queue.

/*

 * Trying to get rid of a group. Remove all marks, flush all events and release

 * the group reference.

 * Note that another thread calling fsnotify_clear_marks_by_group() may still

 * hold a ref to the group.

	/*

	 * Stop queueing new events. The code below is careful enough to not

	 * require this but fanotify needs to stop queuing events even before

	 * fsnotify_destroy_group() is called and this makes the other callers

	 * of fsnotify_destroy_group() to see the same behavior.

 Clear all marks for this group and queue them for destruction */

	/*

	 * Some marks can still be pinned when waiting for response from

	 * userspace. Wait for those now. fsnotify_prepare_user_wait() will

	 * not succeed now so this wait is race-free.

	/*

	 * Wait until all marks get really destroyed. We could actually destroy

	 * them ourselves instead of waiting for worker to do it, however that

	 * would be racy as worker can already be processing some marks before

	 * we even entered fsnotify_destroy_group().

	/*

	 * Since we have waited for fsnotify_mark_srcu in

	 * fsnotify_mark_destroy_list() there can be no outstanding event

	 * notification against this group. So clearing the notification queue

	 * of all events is reliable now.

	/*

	 * Destroy overflow event (we cannot use fsnotify_destroy_event() as

	 * that deliberately ignores overflow events.

/*

 * Get reference to a group.

/*

 * Drop a reference to a group.  Free it if it's through.

 set to 0 when there a no external references to this group */

/*

 * Create a new fsnotify_group and hold a reference for the group returned.

/*

 * Create a new fsnotify_group and hold a reference for the group returned.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * fs/inotify_user.c - inotify support for userspace

 *

 * Authors:

 *	John McCutchan	<ttb@tentacle.dhs.org>

 *	Robert Love	<rml@novell.com>

 *

 * Copyright (C) 2005 John McCutchan

 * Copyright 2006 Hewlett-Packard Development Company, L.P.

 *

 * Copyright (C) 2009 Eric Paris <Red Hat Inc>

 * inotify was largely rewriten to make use of the fsnotify infrastructure

 d_unlinked */

 struct inode */

 struct path */

 kmem_* */

/*

 * Check if 2 events contain the same information.

	/*

	 * Whoever is interested in the event, pays for the allocation. Do not

	 * trigger OOM killer in the target monitoring memcg as it may have

	 * security repercussion.

		/*

		 * Treat lost event due to ENOMEM the same way as queue

		 * overflow to let userspace know event was lost.

	/*

	 * We now report FS_ISDIR flag with MOVE_SELF and DELETE_SELF events

	 * for fanotify. inotify never reported IN_ISDIR with those events.

	 * It looks like an oversight, but to avoid the risk of breaking

	 * existing inotify programs, mask the flag out from those events.

 Our event wasn't used in the end. Free it. */

/*

 * This is NEVER supposed to be called.  Inotify marks should either have been

 * removed from the idr when the watch was removed or in the

 * fsnotify_destroy_mark_by_group() call when the inotify instance was being

 * torn down.  This is only called if the idr is about to be freed but there

 * are still marks in it.

	/*

	 * I'm taking the liberty of assuming that the mark in question is a

	 * valid address and I'm dereferencing it.  This might help to figure

	 * out why we got here and the panic is no worse than the original

	 * BUG() that was here.

 ideally the idr is empty and we won't hit the BUG in the callback */

 ding dong the mark is dead */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * fs/inotify_user.c - inotify support for userspace

 *

 * Authors:

 *	John McCutchan	<ttb@tentacle.dhs.org>

 *	Robert Love	<rml@novell.com>

 *

 * Copyright (C) 2005 John McCutchan

 * Copyright 2006 Hewlett-Packard Development Company, L.P.

 *

 * Copyright (C) 2009 Eric Paris <Red Hat Inc>

 * inotify was largely rewriten to make use of the fsnotify infrastructure

 struct inode */

 fs_initcall */

 roundup() */

 LOOKUP_FOLLOW */

 struct kmem_cache */

/*

 * An inotify watch requires allocating an inotify_inode_mark structure as

 * well as pinning the watched inode. Doubling the size of a VFS inode

 * should be more than enough to cover the additional filesystem inode

 * size increase.

 configurable via /proc/sys/fs/inotify/ */

 CONFIG_SYSCTL */

	/*

	 * Everything should receive events when the inode is unmounted.

	 * All directories care about children.

 mask off the flags used to open the fd */

 intofiy userspace file descriptor functions */

/*

 * Get an inotify_kernel_event if one exists and is small

 * enough to fit in "count". Return an error pointer if

 * not large enough.

 *

 * Called with the group->notification_lock held.

	/* held the notification_lock the whole time, so this is the

/*

 * Copy an event to user space, returning how much we copied.

 *

 * We already checked that the event size is smaller than the

 * buffer we had in "get_one_event()" above.

	/*

	 * round up name length so it is a multiple of event_size

	 * plus an extra byte for the terminating '\0'.

 send the main event */

	/*

	 * fsnotify only stores the pathname, so here we have to send the pathname

	 * and then pad that pathname out to a multiple of sizeof(inotify_event)

	 * with zeros.

 copy the path name */

 fill userspace with 0's */

 free this group, matching get was inotify_init->fsnotify_obtain_group */

 CONFIG_CHECKPOINT_RESTORE */

/*

 * find_inode - resolve a user-given path to a specific inode

 you can only watch an inode if you have read permissions on it */

 we added the mark to the idr, take a reference */

 One ref for being in the idr, one ref we just took */

/*

 * Remove the mark from the idr (if present) and drop the reference

 * on the mark because it was in the idr.

	/*

	 * does this i_mark think it is in the idr?  we shouldn't get called

	 * if it wasn't....

 Lets look in the idr to see if we find it */

	/*

	 * We found an mark in the idr at the right wd, but it's

	 * not the mark we were told to remove.  eparis seriously

	 * fucked up somewhere.

	/*

	 * One ref for being in the idr

	 * one ref grabbed by inotify_idr_find

 we can't really recover with bad ref cnting.. */

 Removed from the idr, drop that ref. */

 match the ref taken by inotify_idr_find_locked() */

/*

 * Send IN_IGNORED for this wd, remove this wd from the idr.

 Queue ignore event for the watch */

 remove this mark from the idr */

 more bits in old than in new? */

 more bits in this fsn_mark than the inode's mask? */

 update the inode with this new fsn_mark */

 return the wd */

 match the get from fsnotify_find_mark() */

 increment the number of watches the user has */

 we are on the idr, now get on the inode */

 we failed to get on the inode, get off the idr */

 return the watch descriptor for this new mark */

 match the ref from fsnotify_init_mark() */

 try to update and existing watch with the new arg */

 no mark present, try to add a new one */

 inotify syscalls */

 Check the IN_* constants for consistency.  */

 fsnotify_obtain_group took a reference to group, we put this when we kill the file in the end */

	/*

	 * We share a lot of code with fs/dnotify.  We also share

	 * the bit layout between inotify's IN_* and the fsnotify

	 * FS_*.  This check ensures that only the inotify IN_*

	 * bits get passed in and set in watches/events.

	/*

	 * Require at least one valid bit set in the mask.

	 * Without _something_ set, we would have no events to

	 * watch for.

 IN_MASK_ADD and IN_MASK_CREATE don't make sense together */

 verify that this is indeed an inotify instance */

 inode held in place by reference to path; group by fget on fd */

 create/update an inode mark */

 verify that this is indeed an inotify instance */

 match ref taken by inotify_idr_find */

/*

 * inotify_user_setup - Our initialization function.  Note that we cannot return

 * error because we have compiled-in VFS hooks.  So an (unlikely) failure here

 * must result in panic().

	/*

	 * Allow up to 1% of addressable memory to be allocated for inotify

	 * watches (per user) limited to the range [8192, 1048576].

 SPDX-License-Identifier: GPL-2.0

 UINT_MAX */

	/*

	 * full_name_hash() works long by long, so it handles fh buf optimally.

 Do not merge fid events without object fh */

 Do not merge name events without dir fh */

 Error events against the same file system are always merged. */

	/*

	 * We want to merge many dirent events in the same dir (i.e.

	 * creates/unlinks/renames), but we do not want to merge dirent

	 * events referring to subdirs with dirent events referring to

	 * non subdirs, otherwise, user won't be able to tell from a

	 * mask FAN_CREATE|FAN_DELETE|FAN_ONDIR if it describes mkdir+

	 * unlink pair or rmdir+create pair of events.

 Limit event merges to limit CPU overhead per event */

 and the list better be locked by something too! */

	/*

	 * Don't merge a permission event with any other event so that we know

	 * the event structure we have created in fanotify_handle_event() is the

	 * one we should check for permission response.

/*

 * Wait for response to permission event. The function also takes care of

 * freeing the permission event (or offloads that in case the wait is canceled

 * by a signal). The function returns 0 in case access got allowed by userspace,

 * -EPERM in case userspace disallowed the access, and -ERESTARTSYS in case

 * the wait got interrupted by a signal.

 Signal pending? */

 Event reported to userspace and no answer yet? */

 Event will get freed once userspace answers to it */

 Event not yet reported? Just remove it. */

 Permission events are not supposed to be hashed */

		/*

		 * Event may be also answered in case signal delivery raced

		 * with wakeup. In that case we have nothing to do besides

		 * freeing the event and reporting error.

 userspace responded, convert to something usable */

 Check if the response should be audited */

/*

 * This function returns a mask for an event that only contains the flags

 * that have been specifically requested by the user. Flags that may have

 * been included within the event mask, but have not been explicitly

 * requested by the user, will not be present in the returned mask.

 Do we have path to open a file descriptor? */

 Path type events are only relevant for files and dirs */

 Do we have a directory inode to report? */

 Apply ignore mask regardless of ISDIR and ON_CHILD flags */

		/*

		 * If the event is on dir and this mark doesn't care about

		 * events on dir, don't send it!

		/*

		 * If the event is on a child and this mark is on a parent not

		 * watching children, don't send it!

	/*

	 * For dirent modification events (create/delete/move) that do not carry

	 * the child entry name information, we report FAN_ONDIR for mkdir/rmdir

	 * so user can differentiate them from creat/unlink.

	 *

	 * For backward compatibility and consistency, do not report FAN_ONDIR

	 * to user in legacy fanotify mode (reporting fd) and report FAN_ONDIR

	 * to user in fid mode for all event types.

	 *

	 * We never report FAN_EVENT_ON_CHILD to user, but we do pass it in to

	 * fanotify_alloc_event() when group is reporting fid as indication

	 * that event happened on child.

 Do not report event flags without any event */

/*

 * Check size needed to encode fanotify_fh.

 *

 * Return size of encoded fh without fanotify_fh header.

 * Return 0 on failure to encode.

	/*

	 * struct fanotify_error_event might be preallocated and is

	 * limited to MAX_HANDLE_SZ.  This should never happen, but

	 * safeguard by forcing an invalid file handle.

/*

 * Encode fanotify_fh.

 *

 * Return total size of encoded fh including fanotify_fh header.

 * Return 0 on failure to encode.

	/*

	 * Invalid FHs are used by FAN_FS_ERROR for errors not

	 * linked to any inode. The f_handle won't be reported

	 * back to userspace.

	/*

	 * !gpf means preallocated variable size fh, but fh_len could

	 * be zero in that case if encoding fh len failed.

 No external buffer in a variable size allocated fh */

 Treat failure to allocate fh as failure to encode fh */

	/*

	 * Mix fh into event merge key.  Hash might be NULL in case of

	 * unhashed FID events (i.e. FAN_FS_ERROR).

 Report the event without a file identifier on encode error */

/*

 * The inode to use as identifier when reporting fid depends on the event.

 * Report the modified directory inode on dirent modification events.

 * Report the "victim" inode otherwise.

 * For example:

 * FS_ATTRIB reports the child inode even if reported on a watched parent.

 * FS_CREATE reports the modified dir inode and not the created inode.

/*

 * The inode to use as identifier when reporting dir fid depends on the event.

 * Report the modified directory inode on dirent modification events.

 * Report the "victim" inode if "victim" is a directory.

 * Report the parent inode if "victim" is not a directory and event is

 * reported to parent.

 * Otherwise, do not report dir fid.

 Bad fh_len. Fallback to using an invalid fh. Should never happen. */

		/*

		 * With both flags FAN_REPORT_DIR_FID and FAN_REPORT_FID, we

		 * report the child fid for events reported on a non-dir child

		 * in addition to reporting the parent fid and maybe child name.

		/*

		 * We record file name only in a group with FAN_REPORT_NAME

		 * and when we have a directory inode to report.

		 *

		 * For directory entry modification event, we record the fid of

		 * the directory and the name of the modified entry.

		 *

		 * For event on non-directory that is reported to parent, we

		 * record the fid of the parent and the name of the child.

		 *

		 * Even if not reporting name, we need a variable length

		 * fanotify_name_event if reporting both parent and child fids.

	/*

	 * For queues with unlimited length lost events are not expected and

	 * can possibly have security implications. Avoid losing events when

	 * memory is short. For the limited size queues, avoid OOM killer in the

	 * target monitoring memcg as it may have security repercussion.

 Whoever is interested in the event, pays for the allocation. */

 Mix event info, FAN_ONDIR flag and pid into event merge key */

/*

 * Get cached fsid of the filesystem containing the object from any connector.

 * All connectors are supposed to have the same fsid, but we do not verify that

 * here.

 Mark is just getting destroyed or created? */

 Pairs with smp_wmb() in fsnotify_add_mark_list() */

/*

 * Add an event to hash table for faster merge.

		/*

		 * fsnotify_prepare_user_wait() fails if we race with mark

		 * deletion.  Just let the operation pass in that case.

 Racing with mark destruction or creation? */

		/*

		 * We don't queue overflow events for permission events as

		 * there the access is denied and so no event is in fact lost.

 Permission events shouldn't be merged */

 Our event wasn't used in the end. Free it. */

 SPDX-License-Identifier: GPL-2.0

/*

 * Legacy fanotify marks limits (8192) is per group and we introduced a tunable

 * limit of marks per user, similar to inotify.  Effectively, the legacy limit

 * of fanotify marks per user is <max marks per group> * <max groups per user>.

 * This default limit (1M) also happens to match the increased limit of inotify

 * max_user_watches since v5.10.

/*

 * Most of the memory cost of adding an inode mark is pinning the marked inode.

 * The size of the filesystem inode struct is not uniform across filesystems,

 * so double the size of a VFS inode is used as a conservative approximation.

 configurable via /proc/sys/fs/fanotify/ */

 CONFIG_SYSCTL */

/*

 * All flags that may be specified in parameter event_f_flags of fanotify_init.

 *

 * Internal and external open flags are stored together in field f_flags of

 * struct file. Only external open flags shall be allowed in event_f_flags.

 * Internal flags like FMODE_NONOTIFY, FMODE_EXEC, FMODE_NOCMTIME shall be

 * excluded.

		/*

		 * With group flag FAN_REPORT_NAME, if name was not recorded in

		 * event on a directory, we will report the name ".".

/*

 * Remove an hashed event from merge hash table.

/*

 * Get an fanotify notification event if one exists and is small

 * enough to fit in "count". Return an error pointer if the count

 * is not large enough. When permission event is dequeued, its state is

 * updated accordingly.

	/*

	 * Held the notification_lock the whole time, so this is the

	 * same event we peeked above.

	/*

	 * we need a new file handle for the userspace program so it can read even if it was

	 * originally opened O_WRONLY.

		/*

		 * we still send an event even if we can't open the file.  this

		 * can happen when say tasks are gone and we try to open their

		 * /proc files or we try to open a WRONLY file like in sysfs

		 * we just send the errno to userspace since there isn't much

		 * else we can do.

/*

 * Finish processing of permission event by setting it to ANSWERED state and

 * drop group->notification_lock.

	/*

	 * make sure the response is valid, if invalid we do nothing and either

	 * userspace can send a valid response or we will clean it up after the

	 * timeout

	/*

	 * Copy event info fid header followed by variable sized file handle

	 * and optionally followed by variable sized filename.

 Mangle handle_type for bad file_handle */

	/*

	 * For an inline fh and inline file name, copy through stack to exclude

	 * the copy from usercopy hardening protections.

 Copy the filename with terminating null */

 Pad with 0's */

	/*

	 * Event info records order is as follows: dir fid + name, child fid.

			/*

			 * With only group flag FAN_REPORT_FID only type FID is

			 * reported. Second info record type is always FID.

			/*

			 * With group flag FAN_REPORT_NAME, if name was not

			 * recorded in an event on a directory, report the name

			 * "." with info type DFID_NAME.

			/*

			 * With group flag FAN_REPORT_DIR_FID, a single info

			 * record has type DFID for directory entry modification

			 * event and for event on a directory.

			/*

			 * With group flags FAN_REPORT_DIR_FID|FAN_REPORT_FID,

			 * a single info record has type FID for event on a

			 * non-directory, when there is no directory to report.

			 * For example, on FAN_DELETE_SELF event.

	/*

	 * For an unprivileged listener, event->pid can be used to identify the

	 * events generated by the listener process itself, without disclosing

	 * the pids of other processes.

	/*

	 * For now, fid mode is required for an unprivileged listener and

	 * fid mode does not report fd in events.  Keep this check anyway

	 * for safety in case fid mode requirement is relaxed in the future

	 * to allow unprivileged listener to get events with no fd and no fid.

		/*

		 * Complain if the FAN_REPORT_PIDFD and FAN_REPORT_TID mutual

		 * exclusion is ever lifted. At the time of incoporating pidfd

		 * support within fanotify, the pidfd API only supported the

		 * creation of pidfds for thread-group leaders.

		/*

		 * The PIDTYPE_TGID check for an event->pid is performed

		 * preemptively in an attempt to catch out cases where the event

		 * listener reads events after the event generating process has

		 * already terminated. Report FAN_NOPIDFD to the event listener

		 * in those cases, with all other pidfd creation errors being

		 * reported as FAN_EPIDFD.

	/*

	 * Sanity check copy size in case get_one_event() and

	 * event_len sizes ever get out of sync.

 intofiy userspace file descriptor functions */

		/*

		 * User can supply arbitrarily large buffer. Avoid softlockups

		 * in case there are lots of available events.

			/*

			 * We cannot report events with stale fd so drop it.

			 * Setting ret to 0 will continue the event loop and

			 * do the right thing if there are no more events to

			 * read (i.e. return bytes read, -EAGAIN or wait).

		/*

		 * Permission events get queued to wait for response.  Other

		 * events can be destroyed now.

	/*

	 * Stop new events from arriving in the notification queue. since

	 * userspace cannot use fanotify fd anymore, no event can enter or

	 * leave access_list by now either.

	/*

	 * Process all permission events on access_list and notification queue

	 * and simulate reply from userspace.

	/*

	 * Destroy all non-permission events. For permission events just

	 * dequeue them and set the response. They will be freed once the

	 * response is consumed and fanotify_get_response() returns.

 Response for all permission events it set, wakeup waiters */

 matches the fanotify_init->fsnotify_alloc_group */

 you can only watch an inode if you have read permissions on it */

 umask bits cannot be removed by user */

	/*

	 * We need to keep the mark around even if remaining mask cannot

	 * result in any events (e.g. mask == FAN_ONDIR) to support incremenal

	 * changes to the mask.

	 * Destroy mark when only umask bits remain.

 matches the fsnotify_find_mark() */

	/*

	 * Enforce per user marks limits per user in all containing user ns.

	 * A group with FAN_UNLIMITED_MARKS does not contribute to mark count

	 * in the limited groups account.

	/*

	 * Error events are pre-allocated per group, only if strictly

	 * needed (i.e. FAN_FS_ERROR was requested).

	/*

	 * If some other task has this inode open for write we should not add

	 * an ignored mark, unless that ignored mark is supposed to survive

	 * modification changes anyway.

 fanotify syscalls */

		/*

		 * An unprivileged user can setup an fanotify group with

		 * limited functionality - an unprivileged group is limited to

		 * notification events with file handles and it cannot use

		 * unlimited queue/marks.

		/*

		 * Setting the internal flag FANOTIFY_UNPRIV on the group

		 * prevents setting mount/filesystem marks on this group and

		 * prevents reporting pid and open fd in events.

	/*

	 * A pidfd can only be returned for a thread-group leader; thus

	 * FAN_REPORT_PIDFD and FAN_REPORT_TID need to remain mutually

	 * exclusive.

	/*

	 * Child name is reported with parent fid so requires dir fid.

	 * We can report both child fid and dir fid with or without name.

 fsnotify_alloc_group takes a ref.  Dropped in fanotify_release */

 Enforce groups limits per user in all containing user ns */

	/*

	 * Make sure dentry is not of a filesystem with zero fsid (e.g. fuse).

	/*

	 * Make sure dentry is not of a filesystem subvolume (e.g. btrfs)

	 * which uses a different fsid than sb root.

 Check if filesystem can encode a unique fid */

	/*

	 * We need to make sure that the file system supports at least

	 * encoding a file handle so user can use name_to_handle_at() to

	 * compare fid returned with event to the file handle of watched

	 * objects. However, name_to_handle_at() requires that the

	 * filesystem also supports decoding file handles.

	/*

	 * Some filesystems such as 'proc' acquire unusual locks when opening

	 * files. For them fanotify permission events have high chances of

	 * deadlocking the system - open done when reporting fanotify event

	 * blocks on this "unusual" lock while another process holding the lock

	 * waits for fanotify permission event to be answered. Just disallow

	 * permission events for such filesystems.

 we only use the lower 32 bits as of right now. */

 Event flags (ONDIR, ON_CHILD) are meaningless in ignored mask */

 verify that this is indeed an fanotify instance */

	/*

	 * An unprivileged user is not allowed to setup mount nor filesystem

	 * marks.  This also includes setting up such marks by a group that

	 * was initialized by an unprivileged user.

	/*

	 * group->priority == FS_PRIO_0 == FAN_CLASS_NOTIF.  These are not

	 * allowed to set permissions events.

	/*

	 * Events that do not carry enough information to report

	 * event->fd require a group that supports reporting fid.  Those

	 * events are not supported on a mount mark, because they do not

	 * carry enough information (i.e. path) to be filtered by mount

	 * point.

 inode held in place by reference to path; group by fget on fd */

 Mask out FAN_EVENT_ON_CHILD flag for sb/mount/non-dir marks */

		/*

		 * If group needs to report parent fid, register for getting

		 * events with parent/name info for non-directory.

 create/update an inode mark */

/*

 * fanotify_user_setup - Our initialization function.  Note that we cannot return

 * error because we have compiled-in VFS hooks.  So an (unlikely) failure here

 * must result in panic().

	/*

	 * Allow up to 1% of addressable memory to be accounted for per user

	 * marks limited to the range [8192, 1048576]. mount and sb marks are

	 * a lot cheaper than inode marks, but there is no reason for a user

	 * to have many of those, so calculate by the cost of inode marks.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Directory notifications for Linux.

 *

 * Copyright (C) 2000,2001,2002 Stephen Rothwell

 *

 * Copyright (C) 2009 Eric Paris <Red Hat Inc>

 * dnotify was largly rewritten to use the new fsnotify infrastructure

/*

 * dnotify will attach one of these to each inode (i_fsnotify_marks) which

 * is being watched by dnotify.  If multiple userspace applications are watching

 * the same directory with dnotify their information is chained in dn

/*

 * When a process starts or stops watching an inode the set of events which

 * dnotify cares about for that inode may change.  This function runs the

 * list of everything receiving dnotify events about this directory and calculates

 * the set of all those events.  After it updates what dnotify is interested in

 * it calls the fsnotify function so it can update the set of all events relevant

 * to this inode.

/*

 * Mains fsnotify call where events are delivered to dnotify.

 * Find the dnotify mark on the relevant inode, run the list of dnotify structs

 * on that mark and determine which of them has expressed interest in receiving

 * events of this type.  When found send the correct process and signal and

 * destroy the dnotify struct if it was not registered to receive multiple

 * events.

 not a dir, dnotify doesn't care */

/*

 * Called every time a file is closed.  Looks first for a dnotify mark on the

 * inode.  If one is found run all of the ->dn structures attached to that

 * mark for one relevant to this process closing the file and remove that

 * dnotify_struct.  If that was the last dnotify_struct also remove the

 * fsnotify_mark.

	/* nothing else could have found us thanks to the dnotify_groups

 this conversion is done only at watch creation */

/*

 * If multiple processes watch the same inode with dnotify there is only one

 * dnotify mark in inode->i_fsnotify_marks but we chain a dnotify_struct

 * onto that mark.  This function either attaches the new dnotify_struct onto

 * that list, or it |= the mask onto an existing dnofiy_struct.

 adding more events to existing dnofiy_struct? */

/*

 * When a process calls fcntl to attach a dnotify watch to a directory it ends

 * up here.  Allocate both a mark for fsnotify to add and a dnotify_struct to be

 * attached to the fsnotify_mark.

 we use these to tell if we need to kfree */

 a 0 mask means we are explicitly removing the watch */

 dnotify only works on directories */

	/*

	 * convert the userspace DN_* "arg" to the internal FS_*

	 * defined in fsnotify

 expect most fcntl to add new rather than augment old */

 new fsnotify mark, we expect most fcntl calls to add a new mark */

 set up the new_fsn_mark and new_dn_mark */

 this is needed to prevent the fcntl/close race described below */

 add the new_fsn_mark or find an old one. */

 we used new_fsn_mark, so don't free it */

	/* if (f != filp) means that we lost a race and another task/thread

	 * actually closed the fd we are still playing with before we grabbed

	 * the dnotify_groups mark_mutex and fsn_mark->lock.  Since closing the

	 * fd is the only time we clean up the marks we need to get our mark

		/* if we added ourselves, shoot ourselves, it's possible that

		 * the flush actually did shoot this fsn_mark.  That's fine too

		 * since multiple calls to destroy_mark is perfectly safe, if

		 * we found a dn_mark already attached to the inode, just sod

		 * off silently as the flush at close time dealt with it.

 !error means that we attached the dn to the dn_mark, so don't free it */

	/* -EEXIST means that we didn't add this new dn and used an old one.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) Sistina Software, Inc.  1997-2003 All rights reserved.

 * Copyright (C) 2004-2006 Red Hat, Inc.  All rights reserved.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) Sistina Software, Inc.  1997-2003 All rights reserved.

 * Copyright (C) 2004-2008 Red Hat, Inc.  All rights reserved.

/**

 * __gfs2_ail_flush - remove all buffers for a given lock from the AIL

 * @gl: the glock

 * @fsync: set when called from fsync (not all buffers will be clean)

 * @nr_revokes: Number of buffers to revoke

 *

 * None of the buffers should be dirty, locked, or pinned.

		/*

		 * We have nothing on the ail, but there could be revokes on

		 * the sdp revoke queue, in which case, we still want to flush

		 * the log and wait for it to finish.

		 *

		 * If the sdp revoke list is empty too, we might still have an

		 * io outstanding for writing revokes, so we should wait for

		 * it before returning.

		 *

		 * If none of these conditions are true, our revokes are all

		 * flushed and we can return.

/**

 * gfs2_rgrp_metasync - sync out the metadata of a resource group

 * @gl: the glock protecting the resource group

 *

/**

 * rgrp_go_sync - sync out the metadata for this glock

 * @gl: the glock

 *

 * Called when demoting or unlocking an EX glock.  We must flush

 * to disk all dirty buffers/pages relating to this glock, and must not

 * return to caller to demote/unlock the glock until I/O is complete.

/**

 * rgrp_go_inval - invalidate the metadata for this glock

 * @gl: the glock

 * @flags:

 *

 * We never used LM_ST_DEFERRED with resource groups, so that we

 * should always see the metadata flag set here.

 *

/**

 * gfs2_inode_metasync - sync out the metadata of an inode

 * @gl: the glock protecting the inode

 *

/**

 * inode_go_sync - Sync the dirty metadata of an inode

 * @gl: the glock protecting the inode

 *

	/*

	 * Writeback of the data mapping may cause the dirty flag to be set

	 * so we have to clear it again here.

/**

 * inode_go_inval - prepare a inode glock to be released

 * @gl: the glock

 * @flags:

 *

 * Normally we invalidate everything, but if we are moving into

 * LM_ST_DEFERRED from LM_ST_SHARED or LM_ST_EXCLUSIVE then we

 * can keep hold of the metadata, since it won't have changed.

 *

/**

 * inode_go_demote_ok - Check to see if it's ok to unlock an inode glock

 * @gl: the glock

 *

 * Returns: 1 if it's ok

 i_diskflags and i_eattr must be set before gfs2_set_inode_flags() */

/**

 * gfs2_inode_refresh - Refresh the incore copy of the dinode

 * @ip: The GFS2 inode

 *

 * Returns: errno

/**

 * inode_go_instantiate - read in an inode if necessary

 * @gh: The glock holder

 *

 * Returns: errno

 no inode to populate - read it in later */

/**

 * inode_go_dump - print information about an inode

 * @seq: The iterator

 * @gl: The glock

 * @fs_id_buf: file system id (may be empty)

 *

/**

 * freeze_go_sync - promote/demote the freeze glock

 * @gl: the glock

	/*

	 * We need to check gl_state == LM_ST_SHARED here and not gl_req ==

	 * LM_ST_EXCLUSIVE. That's because when any node does a freeze,

	 * all the nodes should have the freeze glock in SH mode and they all

	 * call do_xmote: One for EX and the others for UN. They ALL must

	 * freeze locally, and they ALL must queue freeze work. The freeze_work

	 * calls freeze_func, which tries to reacquire the freeze glock in SH,

	 * effectively waiting for the thaw on the node who holds it in EX.

	 * Once thawed, the work func acquires the freeze glock in

	 * SH and everybody goes back to thawed.

 read-only mounts */

/**

 * freeze_go_xmote_bh - After promoting/demoting the freeze glock

 * @gl: the glock

/**

 * freeze_go_demote_ok

 * @gl: the glock

 *

 * Always returns 0

/**

 * iopen_go_callback - schedule the dcache entry for the inode to be deleted

 * @gl: the glock

 * @remote: true if this came from a different cluster node

 *

 * gl_lockref.lock lock is held while calling this

/**

 * inode_go_free - wake up anyone waiting for dlm's unlock ast to free it

 * @gl: glock being freed

 *

 * For now, this is only used for the journal inode glock. In withdraw

 * situations, we need to wait for the glock to be freed so that we know

 * other nodes may proceed with recovery / journal replay.

	/* Note that we cannot reference gl_object because it's already set

/**

 * nondisk_go_callback - used to signal when a node did a withdraw

 * @gl: the nondisk glock

 * @remote: true if this came from a different cluster node

 *

	/* Ignore the callback unless it's from another node, and it's the

	/* First order of business is to cancel the demote request. We don't

	 * really want to demote a nondisk glock. At best it's just to inform

 Ignore the unlock if we're withdrawn, unmounting, or in recovery. */

	/* We only care when a node wants us to unlock, because that means

	/*

	 * We can't call remote_withdraw directly here or gfs2_recover_journal

	 * because this is called from the glock unlock function and the

	 * remote_withdraw needs to enqueue and dequeue the same "live" glock

	 * we were called from. So we queue it to the control work queue in

	 * lock_dlm.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) Sistina Software, Inc.  1997-2003 All rights reserved.

 * Copyright (C) 2004-2006 Red Hat, Inc.  All rights reserved.

/*

 * lock_module. Originally from lock_dlm

 Wait for our primary journal to be initialized */

	/**

	 * If we're a spectator, we use journal0, but it's not really ours.

	 * So we need to wait for its recovery too. If we skip it we'd never

	 * queue work to the recovery workqueue, and so its completion would

	 * never clear the DFL_BLOCK_LOCKS flag, so all our locks would

	 * permanently stop working.

/*

 * get and set struct gfs2_tune fields

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) Sistina Software, Inc.  1997-2003 All rights reserved.

 * Copyright (C) 2004-2006 Red Hat, Inc.  All rights reserved.

/**

 * gfs2_pin - Pin a buffer in memory

 * @sdp: The superblock

 * @bh: The buffer to be pinned

 *

 * The log lock must be held when calling this function

	/* If this buffer is in the AIL and it has already been written

	 * to in-place disk block, remove it from the AIL.

/**

 * gfs2_unpin - Unpin a buffer

 * @sdp: the filesystem the buffer belongs to

 * @bh: The buffer to unpin

 * @tr: The system transaction being flushed

/**

 * gfs2_end_log_write_bh - end log write of pagecache data with buffers

 * @sdp: The superblock

 * @bvec: The bio_vec

 * @error: The i/o status

 *

 * This finds the relevant buffers and unlocks them and sets the

 * error flag according to the status of the i/o request. This is

 * used when the log is writing data which has an in-place version

 * that is pinned in the pagecache.

/**

 * gfs2_end_log_write - end of i/o to the log

 * @bio: The bio

 *

 * Each bio_vec contains either data from the pagecache or data

 * relating to the log itself. Here we iterate over the bio_vec

 * array, processing both kinds of data.

 *

 prevent more writes to the journal */

/**

 * gfs2_log_submit_bio - Submit any pending log bio

 * @biop: Address of the bio pointer

 * @opf: REQ_OP | op_flags

 *

 * Submit any pending part-built or full bio to the block device. If

 * there is no pending bio, then this is a no-op.

/**

 * gfs2_log_alloc_bio - Allocate a bio

 * @sdp: The super block

 * @blkno: The device block number we want to write to

 * @end_io: The bi_end_io callback

 *

 * Allocate a new bio, initialize it with the given parameters and return it.

 *

 * Returns: The newly allocated bio

/**

 * gfs2_log_get_bio - Get cached log bio, or allocate a new one

 * @sdp: The super block

 * @blkno: The device block number we want to write to

 * @biop: The bio to get or allocate

 * @op: REQ_OP

 * @end_io: The bi_end_io callback

 * @flush: Always flush the current bio and allocate a new one?

 *

 * If there is a cached bio, then if the next block number is sequential

 * with the previous one, return it, otherwise flush the bio to the

 * device. If there is no cached bio, or we just flushed it, then

 * allocate a new one.

 *

 * Returns: The bio to use for log writes

/**

 * gfs2_log_write - write to log

 * @sdp: the filesystem

 * @jd: The journal descriptor

 * @page: the page to write

 * @size: the size of the data to write

 * @offset: the offset within the page 

 * @blkno: block number of the log entry

 *

 * Try and add the page segment to the current bio. If that fails,

 * submit the current bio to the device and create a new one, and

 * then add the page segment to that.

/**

 * gfs2_log_write_bh - write a buffer's content to the log

 * @sdp: The super block

 * @bh: The buffer pointing to the in-place location

 * 

 * This writes the content of the buffer to the next available location

 * in the log. The buffer will be unlocked once the i/o to the log has

 * completed.

/**

 * gfs2_log_write_page - write one block stored in a page, into the log

 * @sdp: The superblock

 * @page: The struct page

 *

 * This writes the first block-sized part of the page into the log. Note

 * that the page must have been allocated from the gfs2_page_pool mempool

 * and that after this has been called, ownership has been transferred and

 * the page may be freed at any time.

/**

 * gfs2_end_log_read - end I/O callback for reads from the log

 * @bio: The bio

 *

 * Simply unlock the pages in the bio. The main thread will wait on them and

 * process them in order as necessary.

/**

 * gfs2_jhead_pg_srch - Look for the journal head in a given page.

 * @jd: The journal descriptor

 * @head: The journal head to start from

 * @page: The page to look in

 *

 * Returns: 1 if found, 0 otherwise.

/**

 * gfs2_jhead_process_page - Search/cleanup a page

 * @jd: The journal descriptor

 * @index: Index of the page to look into

 * @head: The journal head to start from

 * @done: If set, perform only cleanup, else search and set if found.

 *

 * Find the page with 'index' in the journal's mapping. Search the page for

 * the journal head if requested (cleanup == false). Release refs on the

 * page so the page cache can reclaim it (put_page() twice). We grabbed a

 * reference on this page two times, first when we did a find_or_create_page()

 * to obtain the page to add it to the bio and second when we do a

 * find_get_page() here to get the page to wait on while I/O on it is being

 * completed.

 * This function is also used to free up a page we might've grabbed but not

 * used. Maybe we added it to a bio, but not submitted it for I/O. Or we

 * submitted the I/O, but we already found the jhead so we only need to drop

 * our references to the page.

 Once for find_get_page */

 Once more for find_or_create_page */

/**

 * gfs2_find_jhead - find the head of a log

 * @jd: The journal descriptor

 * @head: The log descriptor for the head of the log is returned here

 * @keep_cache: If set inode pages will not be truncated

 *

 * Do a search of a journal by reading it in large chunks using bios and find

 * the valid log entry with the highest sequence number.  (i.e. the log head)

 *

 * Returns: 0 on success, errno otherwise

 Keep at least one bio in flight */

 found */

 503 for 4k blocks */

/**

 * databuf_lo_before_commit - Scan the data buffers, writing as we go

 * @sdp: The filesystem

 * @tr: The system transaction being flushed

 Unescape */

 FIXME: sort out accounting for log blocks etc. */

 data sync? */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) Sistina Software, Inc.  1997-2003 All rights reserved.

 * Copyright (C) 2004-2006 Red Hat, Inc.  All rights reserved.

		/*

		 * The reserved blocks are either used for data or metadata.

		 * We can have mixed data and metadata, each with its own log

		 * descriptor block; see calc_reserved().

	/*

	 * Try the reservations under sd_log_flush_lock to prevent log flushes

	 * from creating inconsistencies between the number of allocated and

	 * reserved revokes.  If that fails, do a full-block allocation outside

	 * of the lock to avoid stalling log flushes.  Then, allot the

	 * appropriate number of blocks to revokes, use as many revokes locally

	 * as needed, and "release" the surplus into the revokes pool.

/**

 * gfs2_trans_add_data - Add a databuf to the transaction.

 * @gl: The inode glock associated with the buffer

 * @bh: The buffer to add

 *

 * This is used in journaled data mode.

 * We need to journal the data block in the same way as metadata in

 * the functions above. The difference is that here we have a tag

 * which is two __be64's being the block number (as per meta data)

 * and a flag which says whether the data block needs escaping or

 * not. This means we need a new log entry for each 251 or so data

 * blocks, which isn't an enormous overhead but twice as much as

 * for normal metadata blocks.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) Sistina Software, Inc.  1997-2003 All rights reserved.

 * Copyright (C) 2004-2008 Red Hat, Inc.  All rights reserved.

/**

 * gfs2_tune_init - Fill a gfs2_tune structure with default values

 * @gt: tune

 *

/**

 * gfs2_check_sb - Check superblock

 * @sdp: the filesystem

 * @silent: Don't print a message if the check fails

 *

 * Checks the version code of the FS is one that we understand how to

 * read and that the sizes of the various on-disk structures have not

 * changed.

/**

 * gfs2_read_super - Read the gfs2 super block from disk

 * @sdp: The GFS2 super block

 * @sector: The location of the super block

 * @silent: Don't print a message if the check fails

 *

 * This uses the bio functions to read the super block from disk

 * because we want to be 100% sure that we never read cached data.

 * A super block is read twice only during each GFS2 mount and is

 * never written to by the filesystem. The first time its read no

 * locks are held, and the only details which are looked at are those

 * relating to the locking protocol. Once locking is up and working,

 * the sb is read again under the lock to establish the location of

 * the master directory (contains pointers to journals etc) and the

 * root directory.

 *

 * Returns: 0 on success or error

/**

 * gfs2_read_sb - Read super block

 * @sdp: The GFS2 superblock

 * @silent: Don't print message if mount fails

 *

 not the rgrp bitmap, subsequent bitmaps only */

	/*

	 * We always keep at least one block reserved for revokes in

	 * transactions.  This greatly simplifies allocating additional

	 * revoke blocks.

 Compute maximum reservation required to add a entry to a directory */

  Try to autodetect  */

 ignore */);

 Set up the buffer cache and SB for real */

 Get the root inode */

 Get the master inode */

/**

 * gfs2_jindex_hold - Grab a lock on the jindex

 * @sdp: The GFS2 superblock

 * @ji_gh: the holder for the jindex glock

 *

 * Returns: errno

/**

 * init_statfs - look up and initialize master and local (per node) statfs inodes

 * @sdp: The GFS2 superblock

 *

 * This should be called after the jindex is initialized in init_journal() and

 * before gfs2_journal_recovery() is called because we need to be able to write

 * to these inodes during recovery.

 *

 * Returns: errno

	/* For each jid, lookup the corresponding local statfs inode in the

 read in the local statfs buffer - other nodes don't change it. */

 Uninitialize and free up memory used by the list of statfs inodes */

 Load in the journal index special file */

 Map the extents for this journal's blocks */

 Lookup statfs inodes here so journal recovery can use them. */

 A withdraw may have done dq/uninit so now we need to check it */

 Read in the resource index inode */

 Read in the quota inode */

	/*

	 * i_rwsem on quota files is special. Since this inode is hidden system

	 * file, we are safe to define locking ourselves.

/**

 * gfs2_lm_mount - mount a locking protocol

 * @sdp: the filesystem

 * @silent: if 1, don't complain if the FS isn't a GFS2 fs

 *

 * Returns: errno

 Obsolete, but left for backward compat purposes */

/**

 * gfs2_fill_super - Read in superblock

 * @sb: The VFS superblock

 * @fc: Mount options and flags

 *

 * Returns: -errno

	/* Set up the buffer cache and fill in some fake block size values

 Turn rgrplvb on by default if fs format is recent enough */

	/*

	 * If user space has failed to join the cluster or some similar

	 * failure has occurred, then the journal id will contain a

	 * negative (error) number. This will then be returned to the

	 * caller (of the mount syscall). We do this even for spectator

	 * mounts (which just write a jid of 0 to indicate "ok" even though

	 * the jid is unused in the spectator case)

/**

 * gfs2_get_tree - Get the GFS2 superblock and root directory

 * @fc: The filesystem context

 *

 * Returns: 0 or -errno on error

 quota can be a flag or an enum so it gets special treatment */

 Parse a single mount parameter */

 Retained for backwards compat only */

 Retained for backwards compat only */

 Retained for backwards compat only */

 The uint_32 result maps directly to GFS2_DATA_* */

 Set up the filesystem mount context */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) Sistina Software, Inc.  1997-2003 All rights reserved.

 * Copyright (C) 2004-2006 Red Hat, Inc.  All rights reserved.

/**

 * gfs2_drevalidate - Check directory lookup consistency

 * @dentry: the mapping to check

 * @flags: lookup flags

 *

 * Check to make sure the lookup necessary to arrive at this inode from its

 * parent is still good.

 *

 * Returns: 1 if the dentry is ok, 0 if it isn't

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) Sistina Software, Inc.  1997-2003 All rights reserved.

 * Copyright (C) 2004-2007 Red Hat, Inc.  All rights reserved.

/**

 * gfs2_jindex_free - Clear all the journal index information

 * @sdp: The GFS2 superblock

 *

/**

 * gfs2_make_fs_rw - Turn a Read-Only FS into a Read-Write one

 * @sdp: the filesystem

 *

 * Returns: errno

  Initialize some head of the log stuff  */

/**

 * gfs2_lock_fs_check_clean - Stop all writes to the FS and check that all

 *                            journals are clean

 * @sdp: the file system

 *

 * Returns: errno

/**

 * gfs2_write_inode - Make sure the inode is stable on the disk

 * @inode: The inode

 * @wbc: The writeback control structure

 *

 * Returns: errno

/**

 * gfs2_dirty_inode - check for atime updates

 * @inode: The inode in question

 * @flags: The type of dirty

 *

 * Unfortunately it can be called under any combination of inode

 * glock and transaction lock, so we have to check carefully.

 *

 * At the moment this deals only with atime - it should be possible

 * to expand that role in future, once a review of the locking has

 * been carried out.

/**

 * gfs2_make_fs_ro - Turn a Read-Write FS into a Read-Only one

 * @sdp: the filesystem

 *

 * Returns: errno

/**

 * gfs2_put_super - Unmount the filesystem

 * @sb: The VFS superblock

 *

 No more recovery requests */

 Wait on outstanding recovery */

  At this point, we're through modifying the disk  */

  Release stuff  */

  Take apart glock structures and buffer lists  */

  Unmount the locking protocol  */

  At this point, we're through participating in the lockspace  */

/**

 * gfs2_sync_fs - sync the filesystem

 * @sb: the superblock

 * @wait: true to wait for completion

 *

 * Flushes the log to disk.

/**

 * gfs2_freeze - prevent further writes to the filesystem

 * @sb: the VFS structure for the filesystem

 *

/**

 * gfs2_unfreeze - reallow writes to the filesystem

 * @sb: the VFS structure for the filesystem

 *

/**

 * statfs_slow_fill - fill in the sg for a given RG

 * @rgd: the RG

 * @sc: the sc structure

 *

 * Returns: 0 on success, -ESTALE if the LVB is invalid

/**

 * gfs2_statfs_slow - Stat a filesystem using asynchronous locking

 * @sdp: the filesystem

 * @sc: the sc info that will be returned

 *

 * Any error (other than a signal) will cause this routine to fall back

 * to the synchronous version.

 *

 * FIXME: This really shouldn't busy wait like this.

 *

 * Returns: errno

/**

 * gfs2_statfs_i - Do a statfs

 * @sdp: the filesystem

 * @sc: the sc structure

 *

 * Returns: errno

/**

 * gfs2_statfs - Gather and return stats about the filesystem

 * @dentry: The name of the link

 * @buf: The buffer

 *

 * Returns: 0 on success or error code

/**

 * gfs2_drop_inode - Drop an inode (test for remote unlink)

 * @inode: The inode to drop

 *

 * If we've received a callback on an iopen lock then it's because a

 * remote node tried to deallocate the inode but failed due to this node

 * still having the inode open. Here we mark the link count zero

 * since we know that it must have reached zero if the GLF_DEMOTE flag

 * is set on the iopen glock. If we didn't do a disk read since the

 * remote node removed the final link then we might otherwise miss

 * this event. This check ensures that this node will deallocate the

 * inode's blocks, or alternatively pass the baton on to another

 * node for later deallocation.

	/*

	 * When under memory pressure when an inode's link count has dropped to

	 * zero, defer deleting the inode to the delete workqueue.  This avoids

	 * calling into DLM under memory pressure, which can deadlock.

/**

 * gfs2_show_options - Show mount options for /proc/mounts

 * @s: seq_file structure

 * @root: root of this (sub)tree

 *

 * Returns: 0 on success or error code

/**

 * gfs2_glock_put_eventually

 * @gl:	The glock to put

 *

 * When under memory pressure, trigger a deferred glock put to make sure we

 * won't call into DLM and deadlock.  Otherwise, put the glock directly.

	/*

	 * If there are no other lock holders, we'll get the lock immediately.

	 * Otherwise, the other nodes holding the lock will be notified about

	 * our locking request.  If they don't have the inode open, they'll

	 * evict the cached inode and release the lock.  Otherwise, if they

	 * poke the inode glock, we'll take this as an indication that they

	 * still need the iopen glock and that they'll take care of deleting

	 * the inode when they're done.  As a last resort, if another node

	 * keeps holding the iopen glock without showing any activity on the

	 * inode glock, we'll eventually time out.

	 *

	 * Note that we're passing the LM_FLAG_TRY_1CB flag to the first

	 * locking request as an optimization to notify lock holders as soon as

	 * possible.  Without that flag, they'd be notified implicitly by the

	 * second locking request.

/**

 * evict_should_delete - determine whether the inode is eligible for deletion

 * @inode: The inode to evict

 * @gh: The glock holder structure

 *

 * This function determines whether the evicted inode is eligible to be deleted

 * and locks the inode glock.

 *

 * Returns: the fate of the dinode

 Deletes should never happen under memory pressure anymore.  */

 Must not read inode block until block type has been verified */

	/*

	 * The inode may have been recreated in the meantime.

/**

 * evict_unlinked_inode - delete the pieces of an unlinked evicted inode

 * @inode: The inode to evict

	/* We're about to clear the bitmap for the dinode, but as soon as we

	   do, gfs2_create_inode can create another inode at the same block

	   location and try to set gl_object again. We clear gl_object here so

/*

 * evict_linked_inode - evict an inode whose dinode has not been unlinked

 * @inode: The inode to evict

 Needs to be done before glock release & also in a transaction */

/**

 * gfs2_evict_inode - Remove an inode from cache

 * @inode: The inode to evict

 *

 * There are three cases to consider:

 * 1. i_nlink == 0, we are final opener (and must deallocate)

 * 2. i_nlink == 0, we are not the final opener (and cannot deallocate)

 * 3. i_nlink > 0

 *

 * If the fs is read only, then we have to treat all cases as per #3

 * since we are unable to do any deallocation. The inode will be

 * deallocated by the next read/write node to attempt an allocation

 * in the same resource group

 *

 * We have to (at the moment) hold the inodes main lock to cover

 * the gap between unlocking the shared lock on the iopen lock and

 * taking the exclusive lock. I'd rather do a shared -> exclusive

 * conversion on the iopen lock, but we can change that later. This

 * is safe, just less efficient.

 Run through the statfs inodes list to iput and free memory */

 belongs to this node */

	/* Return the local (per node) statfs inode in the

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) Sistina Software, Inc.  1997-2003 All rights reserved.

 * Copyright (C) 2004-2008 Red Hat, Inc.  All rights reserved.

		/*

		 * If it's a fully non-blocking write attempt and we cannot

		 * lock the buffer then redirty the page.  Note that this can

		 * potentially cause a busy-wait loop from flusher thread and kswapd

		 * activity, but those code paths have their own higher-level

		 * throttling.

	/*

	 * The page and its buffers are protected by PageWriteback(), so we can

	 * drop the bh refcounts early.

/**

 * gfs2_getbuf - Get a buffer with a given address space

 * @gl: the glock

 * @blkno: the block number (filesystem scope)

 * @create: 1 if the buffer should be created

 *

 * Returns: the buffer

 convert block to page */

 block buf index within page */

 Locate header for our buffer within our page */

 Do nothing */;

/**

 * gfs2_meta_new - Get a block

 * @gl: The glock associated with this block

 * @blkno: The block number

 *

 * Returns: The buffer

/*

 * Submit several consecutive buffer head I/O requests as a single bio I/O

 * request.  (See submit_bh_wbc.)

/**

 * gfs2_meta_read - Read a block from disk

 * @gl: The glock covering the block

 * @blkno: The block number

 * @flags: flags

 * @rahead: Do read-ahead

 * @bhp: the place where the buffer is returned (NULL on failure)

 *

 * Returns: errno

/**

 * gfs2_meta_wait - Reread a block from disk

 * @sdp: the filesystem

 * @bh: The block to wait for

 *

 * Returns: errno

/**

 * gfs2_ail1_wipe - remove deleted/freed buffers from the ail1 list

 * @sdp: superblock

 * @bstart: starting block address of buffers to remove

 * @blen: length of buffers to be removed

 *

 * This function is called from gfs2_journal wipe, whose job is to remove

 * buffers, corresponding to deleted blocks, from the journal. If we find any

 * bufdata elements on the system ail1 list, they haven't been written to

 * the journal yet. So we remove them.

 convert block to page */

 Locate header for our buffer within our page */

 Do nothing */;

/**

 * gfs2_journal_wipe - make inode's buffers so they aren't dirty/pinned anymore

 * @ip: the inode who owns the buffers

 * @bstart: the first buffer in the run

 * @blen: the number of buffers in the run

 *

/**

 * gfs2_meta_buffer - Get a metadata buffer

 * @ip: The GFS2 inode

 * @mtype: The block type (GFS2_METATYPE_*)

 * @num: The block number (device relative) of the buffer

 * @bhp: the buffer is returned here

 *

 * Returns: errno

/**

 * gfs2_meta_ra - start readahead on an extent of a file

 * @gl: the glock the blocks belong to

 * @dblock: the starting disk block

 * @extlen: the number of blocks in the extent

 *

 * returns: the first buffer in the extent

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) Sistina Software, Inc.  1997-2003 All rights reserved.

 * Copyright (C) 2004-2006 Red Hat, Inc.  All rights reserved.

/*

 * ea_calc_size - returns the actual number of bytes the request will take up

 *                (not counting any unstuffed data blocks)

 *

 * Returns: 1 if the EA should be stuffed

 Stuffed */

 Unstuffed */

 This can only happen with 512 byte blocks */

/*

 * ea_dealloc_unstuffed

 *

 * Take advantage of the fact that all unstuffed blocks are

 * allocated from the same RG.  But watch, this may not always

 * be true.

 *

 * Returns: errno

/**

 * gfs2_listxattr - List gfs2 extended attributes

 * @dentry: The dentry whose inode we are interested in

 * @buffer: The buffer to write the results

 * @size: The size of the buffer

 *

 * Returns: actual size of data on success, -errno on error

/**

 * gfs2_iter_unstuffed - copies the unstuffed xattr data to/from the

 *                       request buffer

 * @ip: The GFS2 inode

 * @ea: The extended attribute header structure

 * @din: The data to be copied in

 * @dout: The data to be copied out (one of din,dout will be NULL)

 *

 * Returns: errno

/**

 * __gfs2_xattr_get - Get a GFS2 extended attribute

 * @inode: The inode

 * @name: The name of the extended attribute

 * @buffer: The buffer to write the result into

 * @size: The size of the buffer

 * @type: The type of extended attribute

 *

 * Returns: actual size of data on success, -errno on error

 During lookup, SELinux calls this function with the glock locked. */

/**

 * ea_alloc_blk - allocates a new block for extended attributes.

 * @ip: A pointer to the inode that's getting extended attributes

 * @bhp: Pointer to pointer to a struct buffer_head

 *

 * Returns: errno

/**

 * ea_write - writes the request info to an ea, creating new blocks if

 *            necessary

 * @ip: inode that is being modified

 * @ea: the location of the new ea in a block

 * @er: the write request

 *

 * Note: does not update ea_rec_len or the GFS2_EAFLAG_LAST bin of ea_flags

 *

 * returns : errno

/*

 * ea_init - initializes a new eattr block

 *

 * Returns: errno

/**

 * gfs2_xattr_remove - Remove a GFS2 extended attribute

 * @ip: The inode

 * @type: The type of the extended attribute

 * @name: The name of the extended attribute

 *

 * This is not called directly by the VFS since we use the (common)

 * scheme of making a "set with NULL data" mean a remove request. Note

 * that this is different from a set with zero length data.

 *

 * Returns: 0, or errno on failure

/**

 * __gfs2_xattr_set - Set (or remove) a GFS2 extended attribute

 * @inode: The inode

 * @name: The name of the extended attribute

 * @value: The value of the extended attribute (NULL for remove)

 * @size: The size of the @value argument

 * @flags: Create or Replace

 * @type: The type of the extended attribute

 *

 * See gfs2_xattr_remove() for details of the removal of xattrs.

 *

 * Returns: 0 or errno on failure

 May be called from gfs_setattr with the glock locked. */

/**

 * gfs2_ea_dealloc - deallocate the extended attribute fork

 * @ip: the inode

 *

 * Returns: errno

 GFS2_FS_FORMAT_MAX */

 GFS2_FS_FORMAT_MIN */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) Sistina Software, Inc.  1997-2003 All rights reserved.

 * Copyright 2004-2011 Red Hat, Inc.

/**

 * gfs2_update_stats - Update time based stats

 * @s: The stats to update (local or global)

 * @index: The index inside @s

 * @sample: New data to include

	/*

	 * @delta is the difference between the current rtt sample and the

	 * running average srtt. We add 1/8 of that to the srtt in order to

	 * update the current srtt estimate. The variance estimate is a bit

	 * more complicated. We subtract the current variance estimate from

	 * the abs value of the @delta and add 1/4 of that to the running

	 * total.  That's equivalent to 3/4 of the current variance

	 * estimate plus 1/4 of the abs of @delta.

	 *

	 * Note that the index points at the array entry containing the

	 * smoothed mean value, and the variance is always in the following

	 * entry

	 *

	 * Reference: TCP/IP Illustrated, vol 2, p. 831,832

	 * All times are in units of integer nanoseconds. Unlike the TCP/IP

	 * case, they are not scaled fixed point.

/**

 * gfs2_update_reply_times - Update locking statistics

 * @gl: The glock to update

 *

 * This assumes that gl->gl_dstamp has been set earlier.

 *

 * The rtt (lock round trip time) is an estimate of the time

 * taken to perform a dlm lock request. We update it on each

 * reply from the dlm.

 *

 * The blocking flag is set on the glock for all dlm requests

 * which may potentially block due to lock requests from other nodes.

 * DLM requests where the current lock state is exclusive, the

 * requested state is null (or unlocked) or where the TRY or

 * TRY_1CB flags are set are classified as non-blocking. All

 * other DLM requests are counted as (potentially) blocking.

 Local */

 Global */

/**

 * gfs2_update_request_times - Update locking statistics

 * @gl: The glock to update

 *

 * The irt (lock inter-request times) measures the average time

 * between requests to the dlm. It is updated immediately before

 * each dlm call.

 Local */

 Global */

 Unlocked, so glock can be freed */

 Cancel while getting lock */

 Try lock fails */

 Deadlock detected */

 Canceled due to timeout */

 Success */

 Something unexpected */

 convert gfs lock-state to dlm lock-mode */

	/*

	 * Submit the actual lock request.

 don't want to call dlm if we've unmounted the lock protocol */

 don't want to skip dlm_unlock writing the lvb when lock has one */

/*

 * dlm/gfs2 recovery coordination using dlm_recover callbacks

 *

 *  0. gfs2 checks for another cluster node withdraw, needing journal replay

 *  1. dlm_controld sees lockspace members change

 *  2. dlm_controld blocks dlm-kernel locking activity

 *  3. dlm_controld within dlm-kernel notifies gfs2 (recover_prep)

 *  4. dlm_controld starts and finishes its own user level recovery

 *  5. dlm_controld starts dlm-kernel dlm_recoverd to do kernel recovery

 *  6. dlm_recoverd notifies gfs2 of failed nodes (recover_slot)

 *  7. dlm_recoverd does its own lock recovery

 *  8. dlm_recoverd unblocks dlm-kernel locking activity

 *  9. dlm_recoverd notifies gfs2 when done (recover_done with new generation)

 * 10. gfs2_control updates control_lock lvb with new generation and jid bits

 * 11. gfs2_control enqueues journals for gfs2_recover to recover (maybe none)

 * 12. gfs2_recover dequeues and recovers journals of failed nodes

 * 13. gfs2_recover provides recovery results to gfs2_control (recovery_result)

 * 14. gfs2_control updates control_lock lvb jid bits for recovered journals

 * 15. gfs2_control unblocks normal locking when all journals are recovered

 *

 * - failures during recovery

 *

 * recover_prep() may set BLOCK_LOCKS (step 3) again before gfs2_control

 * clears BLOCK_LOCKS (step 15), e.g. another node fails while still

 * recovering for a prior failure.  gfs2_control needs a way to detect

 * this so it can leave BLOCK_LOCKS set in step 15.  This is managed using

 * the recover_block and recover_start values.

 *

 * recover_done() provides a new lockspace generation number each time it

 * is called (step 9).  This generation number is saved as recover_start.

 * When recover_prep() is called, it sets BLOCK_LOCKS and sets

 * recover_block = recover_start.  So, while recover_block is equal to

 * recover_start, BLOCK_LOCKS should remain set.  (recover_spin must

 * be held around the BLOCK_LOCKS/recover_block/recover_start logic.)

 *

 * - more specific gfs2 steps in sequence above

 *

 *  3. recover_prep sets BLOCK_LOCKS and sets recover_block = recover_start

 *  6. recover_slot records any failed jids (maybe none)

 *  9. recover_done sets recover_start = new generation number

 * 10. gfs2_control sets control_lock lvb = new gen + bits for failed jids

 * 12. gfs2_recover does journal recoveries for failed jids identified above

 * 14. gfs2_control clears control_lock lvb bits for recovered jids

 * 15. gfs2_control checks if recover_block == recover_start (step 3 occured

 *     again) then do nothing, otherwise if recover_start > recover_block

 *     then clear BLOCK_LOCKS.

 *

 * - parallel recovery steps across all nodes

 *

 * All nodes attempt to update the control_lock lvb with the new generation

 * number and jid bits, but only the first to get the control_lock EX will

 * do so; others will see that it's already done (lvb already contains new

 * generation number.)

 *

 * . All nodes get the same recover_prep/recover_slot/recover_done callbacks

 * . All nodes attempt to set control_lock lvb gen + bits for the new gen

 * . One node gets control_lock first and writes the lvb, others see it's done

 * . All nodes attempt to recover jids for which they see control_lock bits set

 * . One node succeeds for a jid, and that one clears the jid bit in the lvb

 * . All nodes will eventually see all lvb bits clear and unblock locks

 *

 * - is there a problem with clearing an lvb bit that should be set

 *   and missing a journal recovery?

 *

 * 1. jid fails

 * 2. lvb bit set for step 1

 * 3. jid recovered for step 1

 * 4. jid taken again (new mount)

 * 5. jid fails (for step 4)

 * 6. lvb bit set for step 5 (will already be set)

 * 7. lvb bit cleared for step 3

 *

 * This is not a problem because the failure in step 5 does not

 * require recovery, because the mount in step 4 could not have

 * progressed far enough to unblock locks and access the fs.  The

 * control_mount() function waits for all recoveries to be complete

 * for the latest lockspace generation before ever unblocking locks

 * and returning.  The mount in step 4 waits until the recovery in

 * step 1 is done.

 *

 * - special case of first mounter: first node to mount the fs

 *

 * The first node to mount a gfs2 fs needs to check all the journals

 * and recover any that need recovery before other nodes are allowed

 * to mount the fs.  (Others may begin mounting, but they must wait

 * for the first mounter to be done before taking locks on the fs

 * or accessing the fs.)  This has two parts:

 *

 * 1. The mounted_lock tells a node it's the first to mount the fs.

 * Each node holds the mounted_lock in PR while it's mounted.

 * Each node tries to acquire the mounted_lock in EX when it mounts.

 * If a node is granted the mounted_lock EX it means there are no

 * other mounted nodes (no PR locks exist), and it is the first mounter.

 * The mounted_lock is demoted to PR when first recovery is done, so

 * others will fail to get an EX lock, but will get a PR lock.

 *

 * 2. The control_lock blocks others in control_mount() while the first

 * mounter is doing first mount recovery of all journals.

 * A mounting node needs to acquire control_lock in EX mode before

 * it can proceed.  The first mounter holds control_lock in EX while doing

 * the first mount recovery, blocking mounts from other nodes, then demotes

 * control_lock to NL when it's done (others_may_mount/first_done),

 * allowing other nodes to continue mounting.

 *

 * first mounter:

 * control_lock EX/NOQUEUE success

 * mounted_lock EX/NOQUEUE success (no other PR, so no other mounters)

 * set first=1

 * do first mounter recovery

 * mounted_lock EX->PR

 * control_lock EX->NL, write lvb generation

 *

 * other mounter:

 * control_lock EX/NOQUEUE success (if fail -EAGAIN, retry)

 * mounted_lock EX/NOQUEUE fail -EAGAIN (expected due to other mounters PR)

 * mounted_lock PR/NOQUEUE success

 * read lvb generation

 * control_lock EX->NL

 * set first=0

 *

 * - mount during recovery

 *

 * If a node mounts while others are doing recovery (not first mounter),

 * the mounting node will get its initial recover_done() callback without

 * having seen any previous failures/callbacks.

 *

 * It must wait for all recoveries preceding its mount to be finished

 * before it unblocks locks.  It does this by repeating the "other mounter"

 * steps above until the lvb generation number is >= its mount generation

 * number (from initial recover_done) and all lvb bits are clear.

 *

 * - control_lock lvb format

 *

 * 4 bytes generation number: the latest dlm lockspace generation number

 * from recover_done callback.  Indicates the jid bitmap has been updated

 * to reflect all slot failures through that generation.

 * 4 bytes unused.

 * GDLM_LVB_SIZE-8 bytes of jid bit map. If bit N is set, it indicates

 * that jid N needs recovery.

 4 byte generation number + 4 byte unused */

/**

 * remote_withdraw - react to a node withdrawing from the file system

 * @sdp: The superblock

 Now drop the additional reference we acquired */

 First check for other nodes that may have done a withdraw. */

	/*

	 * No MOUNT_DONE means we're still mounting; control_mount()

	 * will set this flag, after which this thread will take over

	 * all further clearing of BLOCK_LOCKS.

	 *

	 * FIRST_MOUNT means this node is doing first mounter recovery,

	 * for which recovery control is handled by

	 * control_mount()/control_first_done(), not this thread.

	/*

	 * Equal block_gen and start_gen implies we are between

	 * recover_prep and recover_done callbacks, which means

	 * dlm recovery is in progress and dlm locking is blocked.

	 * There's no point trying to do any work until recover_done.

	/*

	 * Propagate recover_submit[] and recover_result[] to lvb:

	 * dlm_recoverd adds to recover_submit[] jids needing recovery

	 * gfs2_recover adds to recover_result[] journal recovery results

	 *

	 * set lvb bit for jids in recover_submit[] if the lvb has not

	 * yet been updated for the generation of the failure

	 *

	 * clear lvb bit for jids in recover_result[] if the result of

	 * the journal recovery is SUCCESS

		/*

		 * Clear lvb bits for jids we've successfully recovered.

		 * Because all nodes attempt to recover failed journals,

		 * a journal can be recovered multiple times successfully

		 * in succession.  Only the first will really do recovery,

		 * the others find it clean, but still report a successful

		 * recovery.  So, another node may have already recovered

		 * the jid and cleared the lvb bit for it.

		/*

		 * Failed slots before start_gen are already set in lvb.

		/*

		 * Failed slots before start_gen are not yet set in lvb.

		/* even if there are no bits to set, we need to write the

		/*

		 * we should be getting a recover_done() for lvb_gen soon

	/*

	 * Everyone will see jid bits set in the lvb, run gfs2_recover_set(),

	 * and clear a jid bit in the lvb if the recovery is a success.

	 * Eventually all journals will be recovered, all jid bits will

	 * be cleared in the lvb, and everyone will clear BLOCK_LOCKS.

	/*

	 * No more jid bits set in lvb, all recovery is done, unblock locks

	 * (unless a new recover_prep callback has occured blocking locks

	 * again while working above)

	/*

	 * We always start with both locks in NL. control_lock is

	 * demoted to NL below so we don't need to do it here.

	/*

	 * Other nodes need to do some work in dlm recovery and gfs2_control

	 * before the recover_done and control_lock will be ready for us below.

	 * A delay here is not required but often avoids having to retry.

	/*

	 * Acquire control_lock in EX and mounted_lock in either EX or PR.

	 * control_lock lvb keeps track of any pending journal recoveries.

	 * mounted_lock indicates if any other nodes have the fs mounted.

	/**

	 * If we're a spectator, we don't want to take the lock in EX because

	 * we cannot do the first-mount responsibility it implies: recovery.

 not even -EAGAIN should happen here */

	/*

	 * If we got both locks above in EX, then we're the first mounter.

	 * If not, then we need to wait for the control_lock lvb to be

	 * updated by other mounted nodes to reflect our mount generation.

	 *

	 * In simple first mounter cases, first mounter will see zero lvb_gen,

	 * but in cases where all existing nodes leave/fail before mounting

	 * nodes finish control_mount, then all nodes will be mounting and

	 * lvb_gen will be non-zero.

 special value to force mount attempts to fail */

 first mounter, keep both EX while doing first recovery */

	/*

	 * We are not first mounter, now we need to wait for the control_lock

	 * lvb generation to be >= the generation from our first recover_done

	 * and all lvb bits to be clear (no pending journal recoveries.)

 journals need recovery, wait until all are clear */

		/* wait for mounted nodes to update control_lock lvb to our

		/* wait for mounted nodes to update control_lock lvb to the

 dlm recovery in progress, wait for it to finish */

 sanity check, should not happen */

		/*

		 * Wait for the end of a dlm recovery cycle to switch from

		 * first mounter recovery.  We can ignore any recover_slot

		 * callbacks between the recover_prep and next recover_done

		 * because we are still the first mounter and any failed nodes

		 * have not fully mounted, so they don't need recovery.

/*

 * Expand static jid arrays if necessary (by increments of RECOVER_SIZE_INC)

 * to accomodate the largest slot number.  (NB dlm slot numbers start at 1,

 * gfs2 jids start at 0, so jid = slot - 1)

 dlm calls before it does lock recovery */

/* dlm calls after recover_prep has been completed on all lockspace members;

 dlm calls after recover_slot and after it completes lock recovery */

 ensure the ls jid arrays are large enough */

 gfs2_recover thread has a journal recovery result */

 don't care about the recovery of own journal during mount */

	/* GAVEUP means another node is recovering the journal; delay our

	   next attempt to recover it, to give the other node a chance to

	/*

	 * initialize everything

	/*

	 * prepare dlm_new_lockspace args

	/*

	 * create/join lockspace

		/*

		 * dlm does not support ops callbacks,

		 * old dlm_controld/gfs_controld are used, try without ops.

	/*

	 * control_mount() uses control_lock to determine first mounter,

	 * and for later mounts, waits for any recoveries to be cleared.

 wait for gfs2_control_wq to be done with this mount */

 mounted_lock and control_lock will be purged in dlm recovery */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) Sistina Software, Inc.  1997-2003 All rights reserved.

 * Copyright (C) 2004-2011 Red Hat, Inc.  All rights reserved.

/**

 * gfs2_set_iop - Sets inode operations

 * @inode: The inode with correct i_mode filled in

 *

 * GFS2 lookup code fills in vfs inode contents based on info obtained

 * from directory entry inside gfs2_inode_lookup().

/**

 * gfs2_inode_lookup - Lookup an inode

 * @sb: The super block

 * @type: The type of the inode

 * @no_addr: The inode number

 * @no_formal_ino: The inode generation number

 * @blktype: Requested block type (GFS2_BLKST_DINODE or GFS2_BLKST_UNLINKED;

 *           GFS2_BLKST_FREE to indicate not to verify)

 *

 * If @type is DT_UNKNOWN, the inode type is fetched from disk.

 *

 * If @blktype is anything other than GFS2_BLKST_FREE (which is used as a

 * placeholder because it doesn't otherwise make sense), the on-disk block type

 * is verified to be @blktype.

 *

 * When @no_formal_ino is non-zero, this function will return ERR_PTR(-ESTALE)

 * if it detects that @no_formal_ino doesn't match the actual inode generation

 * number.  However, it doesn't always know unless @type is DT_UNKNOWN.

 *

 * Returns: A VFS inode, or an error

			/*

			 * The GL_SKIP flag indicates to skip reading the inode

			 * block.  We read the inode with gfs2_inode_refresh

			 * after possibly checking the block type.

 Lowest possible timestamp; will be overwritten in gfs2_dinode_in. */

 Inode glock must be locked already */

/**

 * gfs2_lookup_by_inum - look up an inode by inode number

 * @sdp: The super block

 * @no_addr: The inode number

 * @no_formal_ino: The inode generation number (0 for any)

 * @blktype: Requested block type (see gfs2_inode_lookup)

	/* gfs2_lookupi has inconsistent callers: vfs

	 * related routines expect NULL for no entry found,

	 * gfs2_lookup_simple callers expect ENOENT

	 * and do not check for NULL.

/**

 * gfs2_lookupi - Look up a filename in a directory and return its inode

 * @dir: The inode of the directory containing the inode to look-up

 * @name: The name of the inode to look for

 * @is_root: If 1, ignore the caller's permissions

 *

 * This can be called via the VFS filldir function when NFS is doing

 * a readdirplus and the inode which its intending to stat isn't

 * already in cache. In this case we must not take the directory glock

 * again, since the readdir call will have already taken that lock.

 *

 * Returns: errno

/**

 * create_ok - OK to create a new on-disk inode here?

 * @dip:  Directory in which dinode is to be created

 * @name:  Name of new dinode

 * @mode:

 *

 * Returns: errno

  Don't create entries in an unlinked directory  */

 already GFS2 endian */

/**

 * gfs2_init_xattr - Initialise an xattr block for a new inode

 * @ip: The inode in question

 *

 * This sets up an empty xattr block for a new inode, ready to

 * take any ACLs, LSM xattrs, etc.

/**

 * init_dinode - Fill in a new dinode structure

 * @dip: The directory this inode is being created in

 * @ip: The inode

 * @symname: The symlink destination (if a symlink)

 *

/**

 * gfs2_trans_da_blks - Calculate number of blocks to link inode

 * @dip: The directory we are linking into

 * @da: The dir add information

 * @nr_inodes: The number of inodes involved

 *

 * This calculate the number of blocks we need to reserve in a

 * transaction to link @nr_inodes into a directory. In most cases

 * @nr_inodes will be 2 (the directory plus the inode being linked in)

 * but in case of rename, 4 may be required.

 *

 * Returns: Number of blocks

/**

 * gfs2_create_inode - Create a new inode

 * @dir: The parent directory

 * @dentry: The new dentry

 * @file: If non-NULL, the file which is being opened

 * @mode: The permissions on the new inode

 * @dev: For device nodes, this is the device number

 * @symname: For symlinks, this is the link destination

 * @size: The initial size of the inode (ignored for directories)

 * @excl: Force fail if inode exists

 *

 * Returns: 0 on success, or error code

 Temporarily zero until real addr is assigned */

 Force SYSTEM flag on all files and subdirs of a SYSTEM directory */

	free_vfs_inode = 0; /* After this point, the inode is no longer

			       considered free. Any failures need to undo

	/* After instantiate, errors should result in evict which will destroy

 else evict will do the put for us */

/**

 * gfs2_create - Create a file

 * @mnt_userns: User namespace of the mount the inode was found from

 * @dir: The directory in which to create the file

 * @dentry: The dentry of the new file

 * @mode: The mode of the new file

 * @excl: Force fail if inode exists

 *

 * Returns: errno

/**

 * __gfs2_lookup - Look up a filename in a directory and return its inode

 * @dir: The directory inode

 * @dentry: The dentry of the new inode

 * @file: File to be opened

 *

 *

 * Returns: errno

/**

 * gfs2_link - Link to a file

 * @old_dentry: The inode to link

 * @dir: Add link to this directory

 * @dentry: The name of the link

 *

 * Link the inode in "old_dentry" into the directory "dir" with the

 * name in "dentry".

 *

 * Returns: errno

 parent */

 child */

/*

 * gfs2_unlink_ok - check to see that a inode is still in a directory

 * @dip: the directory

 * @name: the name of the file

 * @ip: the inode

 *

 * Assumes that the lock on (at least) @dip is held.

 *

 * Returns: 0 if the parent/child relationship is correct, errno if it isn't

/**

 * gfs2_unlink_inode - Removes an inode from its parent dir and unlinks it

 * @dip: The parent directory

 * @dentry: The dentry to unlink

 *

 * Called with all the locks and in a transaction. This will only be

 * called for a directory after it has been checked to ensure it is empty.

 *

 * Returns: 0 on success, or an error

/**

 * gfs2_unlink - Unlink an inode (this does rmdir as well)

 * @dir: The inode of the directory containing the inode to unlink

 * @dentry: The file itself

 *

 * This routine uses the type of the inode as a flag to figure out

 * whether this is an unlink or an rmdir.

 *

 * Returns: errno

 parent */

 child */

 rgrp */

/**

 * gfs2_symlink - Create a symlink

 * @mnt_userns: User namespace of the mount the inode was found from

 * @dir: The directory to create the symlink in

 * @dentry: The dentry to put the symlink in

 * @symname: The thing which the link points to

 *

 * Returns: errno

/**

 * gfs2_mkdir - Make a directory

 * @mnt_userns: User namespace of the mount the inode was found from

 * @dir: The parent directory of the new one

 * @dentry: The dentry of the new directory

 * @mode: The mode of the new directory

 *

 * Returns: errno

/**

 * gfs2_mknod - Make a special file

 * @mnt_userns: User namespace of the mount the inode was found from

 * @dir: The directory in which the special file will reside

 * @dentry: The dentry of the special file

 * @mode: The mode of the special file

 * @dev: The device specification of the special file

 *

/**

 * gfs2_atomic_open - Atomically open a file

 * @dir: The directory

 * @dentry: The proposed new entry

 * @file: The proposed new struct file

 * @flags: open flags

 * @mode: File mode

 *

 * Returns: error code or 0 for success

/*

 * gfs2_ok_to_move - check if it's ok to move a directory to another directory

 * @this: move this

 * @to: to here

 *

 * Follow @to back to the root and make sure we don't encounter @this

 * Assumes we already hold the rename lock.

 *

 * Returns: errno

/**

 * update_moved_ino - Update an inode that's being moved

 * @ip: The inode being moved

 * @ndip: The parent directory of the new filename

 * @dir_rename: True of ip is a directory

 *

 * Returns: errno

/**

 * gfs2_rename - Rename a file

 * @odir: Parent directory of old file name

 * @odentry: The old dentry of the file

 * @ndir: Parent directory of new file name

 * @ndentry: The new dentry of the file

 *

 * Returns: errno

 don't move a directory into its subdir */

		/* Grab the resource group glock for unlink flag twiddling.

		 * This is the case where the target dinode already exists

		 * so we unlink before doing the rename.

 Check out the old directory */

 Check out the new directory */

 Check out the dir to be renamed */

 Remove the target file, if it exists */

/**

 * gfs2_exchange - exchange two files

 * @odir: Parent directory of old file name

 * @odentry: The old dentry of the file

 * @ndir: Parent directory of new file name

 * @ndentry: The new dentry of the file

 * @flags: The rename flags

 *

 * Returns: errno

 don't move a directory into its subdir */

 don't move a directory into its subdir */

/**

 * gfs2_get_link - Follow a symbolic link

 * @dentry: The dentry of the link

 * @inode: The inode of the link

 * @done: destructor for return value

 *

 * This can handle symlinks of any size.

 *

 * Returns: 0 on success or error code

/**

 * gfs2_permission

 * @mnt_userns: User namespace of the mount the inode was found from

 * @inode: The inode

 * @mask: The mask to be tested

 *

 * This may be called from the VFS directly, or from within GFS2 with the

 * inode locked, so we look to see if the glock is already locked and only

 * lock the glock if its not already been done.

 *

 * Returns: errno

/**

 * gfs2_setattr - Change attributes on an inode

 * @mnt_userns: User namespace of the mount the inode was found from

 * @dentry: The dentry which is changing

 * @attr: The structure describing the change

 *

 * The VFS layer wants to change one or more of an inodes attributes.  Write

 * that change out to disk.

 *

 * Returns: errno

/**

 * gfs2_getattr - Read out an inode's attributes

 * @mnt_userns:	user namespace of the mount the inode was found from

 * @path: Object to query

 * @stat: The inode's stats

 * @request_mask: Mask of STATX_xxx flags indicating the caller's interests

 * @flags: AT_STATX_xxx setting

 *

 * This may be called from the VFS directly, or from within GFS2 with the

 * inode locked, so we look to see if the glock is already locked and only

 * lock the glock if its not already been done. Note that its the NFS

 * readdirplus operation which causes this to be called (from filldir)

 * with the glock already held.

 *

 * Returns: errno

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) Sistina Software, Inc.  1997-2003 All rights reserved.

 * Copyright (C) 2004-2008 Red Hat, Inc.  All rights reserved.

 The offset is bitmap relative */

 Bitmap index */

/*

 * These routines are used by the resource group routines (rgrp.c)

 * to keep track of block allocation.  Each block is represented by two

 * bits.  So, each byte represents GFS2_NBBY (i.e. 4) blocks.

 *

 * 0 = Free

 * 1 = Used (not metadata)

 * 2 = Unlinked (still in use) inode

 * 3 = Used (metadata)

 current */

 n */ 0, 1, 1, 1,

 e */ 1, 0, 0, 0,

 w */ 0, 0, 0, 1,

/**

 * gfs2_setbit - Set a bit in the bitmaps

 * @rbm: The position of the bit to set

 * @do_clone: Also set the clone bitmap, if it exists

 * @new_state: the new state of the block

 *

/**

 * gfs2_testbit - test a bit in the bitmaps

 * @rbm: The bit to test

 * @use_clone: If true, test the clone bitmap, not the official bitmap.

 *

 * Some callers like gfs2_unaligned_extlen need to test the clone bitmaps,

 * not the "real" bitmaps, to avoid allocating recently freed blocks.

 *

 * Returns: The two bit block state of the requested bit

/**

 * gfs2_bit_search

 * @ptr: Pointer to bitmap data

 * @mask: Mask to use (normally 0x55555.... but adjusted for search start)

 * @state: The state we are searching for

 *

 * We xor the bitmap data with a patter which is the bitwise opposite

 * of what we are looking for, this gives rise to a pattern of ones

 * wherever there is a match. Since we have two bits per entry, we

 * take this pattern, shift it down by one place and then and it with

 * the original. All the even bit positions (0,2,4, etc) then represent

 * successful matches, so we mask with 0x55555..... to remove the unwanted

 * odd bit positions.

 *

 * This allows searching of a whole u64 at once (32 blocks) with a

 * single test (on 64 bit arches).

/**

 * rs_cmp - multi-block reservation range compare

 * @start: start of the new reservation

 * @len: number of blocks in the new reservation

 * @rs: existing reservation to compare against

 *

 * returns: 1 if the block range is beyond the reach of the reservation

 *         -1 if the block range is before the start of the reservation

 *          0 if the block range overlaps with the reservation

/**

 * gfs2_bitfit - Search an rgrp's bitmap buffer to find a bit-pair representing

 *       a block in a given allocation state.

 * @buf: the buffer that holds the bitmaps

 * @len: the length (in bytes) of the buffer

 * @goal: start search at this block's bit-pair (within @buffer)

 * @state: GFS2_BLKST_XXX the state of the block we're looking for.

 *

 * Scope of @goal and returned block number is only within this bitmap buffer,

 * not entire rgrp or filesystem.  @buffer will be offset from the actual

 * beginning of a bitmap block buffer, skipping any header structures, but

 * headers are always a multiple of 64 bits long so that the buffer is

 * always aligned to a 64 bit boundary.

 *

 * The size of the buffer is in bytes, but is it assumed that it is

 * always ok to read a complete multiple of 64 bits at the end

 * of the block in case the end is no aligned to a natural boundary.

 *

 * Return: the block number (bitmap buffer scope) that was found

 Mask off bits we don't care about at the start of the search */

 Mask off any bits which are more than len bytes from the start */

 Didn't find anything, so return */

 two bits per entry in the bitmap */

/**

 * gfs2_rbm_from_block - Set the rbm based upon rgd and block number

 * @rbm: The rbm with rgd already set correctly

 * @block: The block number (filesystem relative)

 *

 * This sets the bi and offset members of an rbm based on a

 * resource group and a filesystem relative block number. The

 * resource group must be set in the rbm on entry, the bi and

 * offset members will be set by this function.

 *

 * Returns: 0 on success, or an error code

 Check if the block is within the first block */

 Adjust for the size diff between gfs2_meta_header and gfs2_rgrp */

/**

 * gfs2_rbm_add - add a number of blocks to an rbm

 * @rbm: The rbm with rgd already set correctly

 * @blocks: The number of blocks to add to rpm

 *

 * This function takes an existing rbm structure and adds a number of blocks to

 * it.

 *

 * Returns: True if the new rbm would point past the end of the rgrp.

/**

 * gfs2_unaligned_extlen - Look for free blocks which are not byte aligned

 * @rbm: Position to search (value/result)

 * @n_unaligned: Number of unaligned blocks to check

 * @len: Decremented for each block found (terminate on zero)

 *

 * Returns: true if a non-free block is encountered or the end of the resource

 *	    group is reached.

/**

 * gfs2_free_extlen - Return extent length of free blocks

 * @rrbm: Starting position

 * @len: Max length to check

 *

 * Starting at the block specified by the rbm, see how many free blocks

 * there are, not reading more than len blocks ahead. This can be done

 * using memchr_inv when the blocks are byte aligned, but has to be done

 * on a block by block basis in case of unaligned blocks. Also this

 * function can cope with bitmap boundaries (although it must stop on

 * a resource group boundary)

 *

 * Returns: Number of free blocks in the extent

 Start is now byte aligned */

 Deal with any bits left over at the end */

/**

 * gfs2_bitcount - count the number of bits in a certain state

 * @rgd: the resource group descriptor

 * @buffer: the buffer that holds the bitmaps

 * @buflen: the length (in bytes) of the buffer

 * @state: the state of the block we're looking for

 *

 * Returns: The number of bits

/**

 * gfs2_rgrp_verify - Verify that a resource group is consistent

 * @rgd: the rgrp

 *

 Count # blocks in each of 4 possible allocation states */

/**

 * gfs2_blk2rgrpd - Find resource group for a given data/meta block number

 * @sdp: The GFS2 superblock

 * @blk: The data block number

 * @exact: True if this needs to be an exact match

 *

 * The @exact argument should be set to true by most callers. The exception

 * is when we need to match blocks which are not represented by the rgrp

 * bitmap, but which are part of the rgrp (i.e. padding blocks) which are

 * there for alignment purposes. Another way of looking at it is that @exact

 * matches only valid data/metadata blocks, but with @exact false, it will

 * match any block within the extent of the rgrp.

 *

 * Returns: The resource group, or NULL if not found

/**

 * gfs2_rgrpd_get_first - get the first Resource Group in the filesystem

 * @sdp: The GFS2 superblock

 *

 * Returns: The first rgrp in the filesystem

/**

 * gfs2_rgrpd_get_next - get the next RG

 * @rgd: the resource group descriptor

 *

 * Returns: The next rgrp

/**

 * __rs_deltree - remove a multi-block reservation from the rgd tree

 * @rs: The reservation to remove

 *

 return requested blocks to the rgrp */

		/* The rgrp extent failure point is likely not to increase;

		   it will only do so if the freed blocks are somehow

		   contiguous with a span of free blocks that follows. Still,

/**

 * gfs2_rs_deltree - remove a multi-block reservation from the rgd tree

 * @rs: The reservation to remove

 *

/**

 * gfs2_rs_delete - delete a multi-block reservation

 * @ip: The inode for this reservation

 * @wcount: The inode's write count, or NULL

 *

/**

 * return_all_reservations - return all reserved blocks back to the rgrp.

 * @rgd: the rgrp that needs its space back

 *

 * We previously reserved a bunch of blocks for allocation. Now we need to

 * give them back. This leave the reservation structures in tact, but removes

 * all of their corresponding "no-fly zones".

/**

 * compute_bitstructs - Compute the bitmap sizes

 * @rgd: The resource group descriptor

 *

 * Calculates bitmap descriptors, one for each block that contains bitmap data

 *

 * Returns: errno

 # blocks in hdr & bitmap */

 small rgrp; bitmap stored completely in header block */

 header block */

 last block */

 other blocks */

/**

 * gfs2_ri_total - Total up the file system space, according to the rindex.

 * @sdp: the filesystem

 *

 Figure out where to put new node */

/**

 * read_rindex_entry - Pull in a new resource index entry from the disk

 * @ip: Pointer to the rindex inode

 *

 * Returns: 0 on success, > 0 on EOF, error code otherwise

 someone else read in the rgrp; free it and ignore it */

/**

 * set_rgrp_preferences - Run all the rgrps, selecting some we prefer to use

 * @sdp: the GFS2 superblock

 *

 * The purpose of this function is to select a subset of the resource groups

 * and mark them as PREFERRED. We do it in such a way that each node prefers

 * to use a unique set of rgrps to minimize glock contention.

	/* Skip an initial number of rgrps, based on this node's journal ID.

/**

 * gfs2_ri_update - Pull in a new resource index from the disk

 * @ip: pointer to the rindex inode

 *

 * Returns: 0 on successful update, error code otherwise

/**

 * gfs2_rindex_update - Update the rindex if required

 * @sdp: The GFS2 superblock

 *

 * We grab a lock on the rindex inode to make sure that it doesn't

 * change whilst we are performing an operation. We keep this lock

 * for quite long periods of time compared to other locks. This

 * doesn't matter, since it is shared and it is very, very rarely

 * accessed in the exclusive mode (i.e. only when expanding the filesystem).

 *

 * This makes sure that we're using the latest copy of the resource index

 * special file, which might have been updated if someone expanded the

 * filesystem (via gfs2_grow utility), which adds new resource groups.

 *

 * Returns: 0 on succeess, error code otherwise

 Read new copy from disk if we don't have the latest */

 rd_data0, rd_data and rd_bitbytes already set from rindex */

/**

 * gfs2_rgrp_go_instantiate - Read in a RG's header and bitmaps

 * @gh: the glock holder representing the rgrpd to read in

 *

 * Read in all of a Resource Group's header and bitmap blocks.

 * Caller must eventually call gfs2_rgrp_brelse() to free the bitmaps.

 *

 * Returns: errno

 max out the rgrp allocation failure point */

 max out the rgrp allocation failure point */

/**

 * gfs2_rgrp_brelse - Release RG bitmaps read in with gfs2_rgrp_bh_get()

 * @rgd: The resource group

 *

/**

 * gfs2_fitrim - Generate discard requests for unused bits of the filesystem

 * @filp: Any file on the filesystem

 * @argp: Pointer to the arguments (also used to pass result)

 *

 * Returns: 0 on success, otherwise error code

 start is beyond the end of the fs */

 Trim each bitmap in the rgrp */

 Mark rgrp as having been trimmed */

/**

 * rs_insert - insert a new multi-block reservation into the rgrp's rb_tree

 * @ip: the inode structure

 *

 Do our rgrp accounting for the reservation */

 blocks requested */

/**

 * rgd_free - return the number of free blocks we can allocate

 * @rgd: the resource group

 * @rs: The reservation to free

 *

 * This function returns the number of free blocks for an rgrp.

 * That's the clone-free blocks (blocks that are free, not including those

 * still being used for unlinked files that haven't been deleted.)

 *

 * It also subtracts any blocks reserved by someone else, but does not

 * include free blocks that are still part of our current reservation,

 * because obviously we can (and will) allocate them.

/**

 * rg_mblk_search - find a group of multiple free blocks to form a reservation

 * @rgd: the resource group descriptor

 * @ip: pointer to the inode for which we're reserving blocks

 * @ap: the allocation parameters

 *

 Find bitmap block that contains bits for goal block */

/**

 * gfs2_next_unreserved_block - Return next block that is not reserved

 * @rgd: The resource group

 * @block: The starting block

 * @length: The required length

 * @ignore_rs: Reservation to ignore

 *

 * If the block does not appear in any reservation, then return the

 * block number unchanged. If it does appear in the reservation, then

 * keep looking through the tree of reservations in order to find the

 * first block number which is not reserved.

/**

 * gfs2_reservation_check_and_update - Check for reservations during block alloc

 * @rbm: The current position in the resource group

 * @rs: Our own reservation

 * @minext: The minimum extent length

 * @maxext: A pointer to the maximum extent structure

 *

 * This checks the current position in the rgrp to see whether there is

 * a reservation covering this block. If not then this function is a

 * no-op. If there is, then the position is moved to the end of the

 * contiguous reservation(s) so that we are pointing at the first

 * non-reserved block.

 *

 * Returns: 0 if no reservation, 1 if @rbm has changed, otherwise an error

	/*

	 * If we have a minimum extent length, then skip over any extent

	 * which is less than the min extent length in size.

	/*

	 * Check the extent which has been found against the reservations

	 * and skip if parts of it are already reserved

/**

 * gfs2_rbm_find - Look for blocks of a particular state

 * @rbm: Value/result starting position and final position

 * @state: The state which we want to find

 * @minext: Pointer to the requested extent length

 *          This is updated to be the actual reservation size.

 * @rs: Our own reservation (NULL to skip checking for reservations)

 * @nowrap: Stop looking at the end of the rgrp, rather than wrapping

 *          around until we've reached the starting point.

 *

 * Side effects:

 * - If looking for free blocks, we set GBF_FULL on each bitmap which

 *   has no free blocks in it.

 * - If looking for free blocks, we set rd_extfail_pt on each rgrp which

 *   has come up short on a free block search.

 *

 * Returns: 0 on success, -ENOSPC if there is no block of the requested state

	/*

	 * Determine the last bitmap to search.  If we're not starting at the

	 * beginning of a bitmap, we need to search that bitmap twice to scan

	 * the entire resource group.

 Find next bitmap in the rgrp */

 Have we scanned the entire resource group? */

	/* If the extent was too small, and it's smaller than the smallest

	   to have failed before, remember for future reference that it's

	/* If the maximum extent we found is big enough to fulfill the

/**

 * try_rgrp_unlink - Look for any unlinked, allocated, but unused inodes

 * @rgd: The rgrp

 * @last_unlinked: block address of the last dinode we unlinked

 * @skip: block address we should explicitly not unlink

 *

 * Returns: 0 if no error

 *          The inode, if one has been found, in inode.

		/* If the inode is already in cache, we can ignore it here

		 * because the existing inode disposal code will deal with

		 * it when all refs have gone away. Accessing gl_object like

		 * this is not safe in general. Here it is ok because we do

		 * not dereference the pointer, and we only need an approx

		 * answer to whether it is NULL or not.

 Limit reclaim to sensible number of tasks */

/**

 * gfs2_rgrp_congested - Use stats to figure out whether an rgrp is congested

 * @rgd: The rgrp in question

 * @loops: An indication of how picky we can be (0=very, 1=less so)

 *

 * This function uses the recently added glock statistics in order to

 * figure out whether a parciular resource group is suffering from

 * contention from multiple nodes. This is done purely on the basis

 * of timings, since this is the only data we have to work with and

 * our aim here is to reject a resource group which is highly contended

 * but (very important) not to do this too often in order to ensure that

 * we do not land up introducing fragmentation by changing resource

 * groups when not actually required.

 *

 * The calculation is fairly simple, we want to know whether the SRTTB

 * (i.e. smoothed round trip time for blocking operations) to acquire

 * the lock for this rgrp's glock is significantly greater than the

 * time taken for resource groups on average. We introduce a margin in

 * the form of the variable @var which is computed as the sum of the two

 * respective variences, and multiplied by a factor depending on @loops

 * and whether we have a lot of data to base the decision on. This is

 * then tested against the square difference of the means in order to

 * decide whether the result is statistically significant or not.

 *

 * Returns: A boolean verdict on the congestion status

/**

 * gfs2_rgrp_used_recently

 * @rs: The block reservation with the rgrp to test

 * @msecs: The time limit in milliseconds

 *

 * Returns: True if the rgrp glock has been used within the time limit

 If we didn't wrap */

/**

 * fast_to_acquire - determine if a resource group will be fast to acquire

 * @rgd: The rgrp

 *

 * If this is one of our preferred rgrps, it should be quicker to acquire,

 * because we tried to set ourselves up as dlm lock master.

/**

 * gfs2_inplace_reserve - Reserve space in the filesystem

 * @ip: the inode to reserve space for

 * @ap: the allocation parameters

 *

 * We try our best to find an rgrp that has at least ap->target blocks

 * available. After a couple of passes (loops == 2), the prospects of finding

 * such an rgrp diminish. At this stage, we return the first rgrp that has

 * at least ap->min_target blocks available.

 *

 * Returns: 0 on success,

 *          -ENOMEM if a suitable rgrp can't be found

 *          errno otherwise

 Skip unusable resource groups */

 Get a reservation if we don't already have one */

 Skip rgrps when we can't get a reservation on first pass */

 If rgrp has enough free space, use it */

 Check for unlinked inodes which can be reclaimed */

 Drop reservation, if we couldn't use reserved rgrp */

 Unlock rgrp if required */

 Find the next rgrp, and continue looking */

		/* If we've scanned all the rgrps, but found no free blocks

		 * then this checks for some less likely conditions before

		 * trying again.

 Check that fs hasn't grown if writing to rindex */

 Flushing the log may release space */

/**

 * gfs2_inplace_release - release an inplace reservation

 * @ip: the inode the reservation was taken out on

 *

 * Release a reservation made by gfs2_inplace_reserve().

/**

 * gfs2_alloc_extent - allocate an extent from a given bitmap

 * @rbm: the resource group information

 * @dinode: TRUE if the first block we allocate is for a dinode

 * @n: The extent length (value/result)

 *

 * Add the bitmap buffer to the transaction.

 * Set the found bits to @new_state to change block's allocation state.

/**

 * rgblk_free - Change alloc state of given block(s)

 * @sdp: the filesystem

 * @rgd: the resource group the blocks are in

 * @bstart: the start of a run of blocks to free

 * @blen: the length of the block run (all must lie within ONE RG!)

 * @new_state: GFS2_BLKST_XXX the after-allocation block state

/**

 * gfs2_rgrp_dump - print out an rgrp

 * @seq: The iterator

 * @rgd: The rgrp in question

 * @fs_id_buf: pointer to file system id (if requested)

 *

/**

 * gfs2_adjust_reservation - Adjust (or remove) a reservation after allocation

 * @ip: The inode we have just allocated blocks for

 * @rbm: The start of the allocated blocks

 * @len: The extent length

 *

 * Adjusts a reservation after an allocation has taken place. If the

 * reservation does not match the allocation, or if it is now empty

 * then it is removed.

			/* We used up our block reservation, so we should

/**

 * gfs2_set_alloc_start - Set starting point for block allocation

 * @rbm: The rbm which will be set to the required location

 * @ip: The gfs2 inode

 * @dinode: Flag to say if allocation includes a new inode

 *

 * This sets the starting point from the reservation if one is active

 * otherwise it falls back to guessing a start point based on the

 * inode's goal block or the last allocation point in the rgrp.

/**

 * gfs2_alloc_blocks - Allocate one or more blocks of data and/or a dinode

 * @ip: the inode to allocate the block for

 * @bn: Used to return the starting block number

 * @nblocks: requested number of blocks/extent length (value/result)

 * @dinode: 1 if we're allocating a dinode block, else 0

 * @generation: the generation number of the inode

 *

 * Returns: 0 or error

 block, within the file system scope */

 Since all blocks are reserved in advance, this shouldn't happen */

/**

 * __gfs2_free_blocks - free a contiguous run of block(s)

 * @ip: the inode these blocks are being freed from

 * @rgd: the resource group the blocks are in

 * @bstart: first block of a run of contiguous blocks

 * @blen: the length of the block run

 * @meta: 1 if the blocks represent metadata

 *

 Directories keep their data in the metadata address space */

/**

 * gfs2_free_meta - free a contiguous run of data block(s)

 * @ip: the inode these blocks are being freed from

 * @rgd: the resource group the blocks are in

 * @bstart: first block of a run of contiguous blocks

 * @blen: the length of the block run

 *

/**

 * gfs2_check_blk_type - Check the type of a block

 * @sdp: The superblock

 * @no_addr: The block number to check

 * @type: The block type we are looking for

 *

 * The inode glock of @no_addr must be held.  The @type to check for is either

 * GFS2_BLKST_DINODE or GFS2_BLKST_UNLINKED; checking for type GFS2_BLKST_FREE

 * or GFS2_BLKST_USED would make no sense.

 *

 * Returns: 0 if the block type matches the expected type

 *          -ESTALE if it doesn't match

 *          or -ve errno if something went wrong while checking

		/*

		 * No need to take the local resource group lock here; the

		 * inode glock of @no_addr provides the necessary

		 * synchronization in case the block is an inode.  (In case

		 * the block is not an inode, the block type will not match

		 * the @type we are looking for.)

/**

 * gfs2_rlist_add - add a RG to a list of RGs

 * @ip: the inode

 * @rlist: the list of resource groups

 * @block: the block

 *

 * Figure out what RG a block belongs to and add that RG to the list

 *

 * FIXME: Don't use NOFAIL

 *

	/*

	 * The resource group last accessed is kept in the last position.

/**

 * gfs2_rlist_alloc - all RGs have been added to the rlist, now allocate

 *      and initialize an array of glock holders for them

 * @rlist: the list of resource groups

 *

 * FIXME: Don't use NOFAIL

 *

/**

 * gfs2_rlist_free - free a resource group list

 * @rlist: the list of resource groups

 *

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) Sistina Software, Inc.  1997-2003 All rights reserved.

 * Copyright (C) 2004-2006 Red Hat, Inc.  All rights reserved.

/*

 * Implements Extendible Hashing as described in:

 *   "Extendible Hashing" by Fagin, et al in

 *     __ACM Trans. on Database Systems__, Sept 1979.

 *

 *

 * Here's the layout of dirents which is essentially the same as that of ext2

 * within a single block. The field de_name_len is the number of bytes

 * actually required for the name (no null terminator). The field de_rec_len

 * is the number of bytes allocated to the dirent. The offset of the next

 * dirent in the block is (dirent + dirent->de_rec_len). When a dirent is

 * deleted, the preceding dirent inherits its allocated space, ie

 * prev->de_rec_len += deleted->de_rec_len. Since the next dirent is obtained

 * by adding de_rec_len to the current dirent, this essentially causes the

 * deleted dirent to get jumped over when iterating through all the dirents.

 *

 * When deleting the first dirent in a block, there is no previous dirent so

 * the field de_ino is set to zero to designate it as deleted. When allocating

 * a dirent, gfs2_dirent_alloc iterates through the dirents in a block. If the

 * first dirent has (de_ino == 0) and de_rec_len is large enough, this first

 * dirent is allocated. Otherwise it must go through all the 'used' dirents

 * searching for one in which the amount of total space minus the amount of

 * used space will provide enough space for the new dirent.

 *

 * There are two types of blocks in which dirents reside. In a stuffed dinode,

 * the dirents begin at offset sizeof(struct gfs2_dinode) from the beginning of

 * the block.  In leaves, they begin at offset sizeof(struct gfs2_leaf) from the

 * beginning of the leaf block. The dirents reside in leaves when

 *

 * dip->i_diskflags & GFS2_DIF_EXHASH is true

 *

 * Otherwise, the dirents are "linear", within a single stuffed dinode block.

 *

 * When the dirents are in leaves, the actual contents of the directory file are

 * used as an array of 64-bit block pointers pointing to the leaf blocks. The

 * dirents are NOT in the directory file itself. There can be more than one

 * block pointer in the array that points to the same leaf. In fact, when a

 * directory is first converted from linear to exhash, all of the pointers

 * point to the same leaf.

 *

 * When a leaf is completely full, the size of the hash table can be

 * doubled unless it is already at the maximum size which is hard coded into

 * GFS2_DIR_MAX_DEPTH. After that, leaves are chained together in a linked list,

 * but never before the maximum hash table size has been reached.

 max read-ahead blocks */

/**

 * gfs2_dir_write_data - Write directory information to the inode

 * @ip: The GFS2 inode

 * @buf: The buffer containing information to be written

 * @offset: The file offset to start writing at

 * @size: The amount of data to write

 *

 * Returns: The number of bytes correctly written or error code

/**

 * gfs2_dir_read_data - Read a data from a directory inode

 * @ip: The GFS2 Inode

 * @buf: The buffer to place result into

 * @size: Amount of data to transfer

 *

 * Returns: The amount of data actually copied or the error

/**

 * gfs2_dir_get_hash_table - Get pointer to the dir hash table

 * @ip: The inode in question

 *

 * Returns: The hash table or an error

/**

 * gfs2_dir_hash_inval - Invalidate dir hash

 * @ip: The directory inode

 *

 * Must be called with an exclusive glock, or during glock invalidation.

/*

 * name->name holds ptr to start of block.

 * name->len holds size of block.

/* Look for the dirent that contains the offset specified in data. Once we

/*

 * Other possible things to check:

 * - Inode located within filesystem size (and on valid block)

 * - Valid directory entry type

 * Not sure how heavy-weight we want to make this... could also check

 * hash is correct for example, but that would take a lot of extra time.

 * For now the most important thing is to check that the various sizes

 * are correct.

/**

 * dirent_next - Next dirent

 * @dip: the directory

 * @bh: The buffer

 * @dent: Pointer to list of dirents

 *

 * Returns: 0 on success, error code otherwise

 Only the first dent could ever have de_inum.no_addr == 0 */

/**

 * dirent_del - Delete a dirent

 * @dip: The GFS2 inode

 * @bh: The buffer

 * @prev: The previous dirent

 * @cur: The current dirent

 *

	/* If there is no prev entry, this is the first entry in the block.

	   The de_rec_len is already as big as it needs to be.  Just zero

  Combine this dentry with the previous one.  */

/*

 * Takes a dent from which to grab space as an argument. Returns the

 * newly created dent.

 pr_info("block num=%llu\n", leaf_no); */

/**

 * get_leaf_nr - Get a leaf number associated with the index

 * @dip: The GFS2 inode

 * @index: hash table index of the targeted leaf

 * @leaf_out: Resulting leaf block number

 *

 * Returns: 0 on success, error code otherwise

/**

 * dir_make_exhash - Convert a stuffed directory into an ExHash directory

 * @inode: The directory inode to be converted to exhash

 *

 * Returns: 0 on success, error code otherwise

  Turn over a new leaf  */

  Copy dirents  */

  Find last entry  */

	/*  Adjust the last dirent's record length

	/*  We're done with the new leaf block, now setup the new

/**

 * dir_split_leaf - Split a leaf block into two

 * @inode: The directory inode to be split

 * @name: name of the dirent we're trying to insert

 *

 * Returns: 0 on success, error code on failure

  Get the old leaf block  */

 can't split */

  Compute the start and len of leaf pointers in the hash table.  */

	/* Change the pointers.

	   Don't bother distinguishing stuffed from non-stuffed.

  Change the pointers  */

  Compute the divider  */

  Copy the entries  */

 No endian worries */

 No endian worries */

/**

 * dir_double_exhash - Double size of ExHash table

 * @dip: The GFS2 dinode

 *

 * Returns: 0 on success, error code on failure

 Replace original hash table & size */

/**

 * compare_dents - compare directory entries by hash value

 * @a: first dent

 * @b: second dent

 *

 * When comparing the hash entries of @a to @b:

 *   gt: returns 1

 *   lt: returns -1

 *   eq: returns 0

/**

 * do_filldir_main - read out directory entries

 * @dip: The GFS2 inode

 * @ctx: what to feed the entries to

 * @darr: an array of struct gfs2_dirent pointers to read

 * @entries: the number of entries in darr

 * @sort_start: index of the directory array to start our sort

 * @copied: pointer to int that's non-zero if a entry has been copied out

 *

 * Jump through some hoops to make sure that if there are hash collsions,

 * they are read out at the beginning of a buffer.  We want to minimize

 * the possibility that they will fall into different readdir buffers or

 * that someone will want to seek to that location.

 *

 * Returns: errno, >0 if the actor tells you to stop

	/* Increment the ctx->pos by one, so the next time we come into the

	   do_filldir fxn, we get the next entry instead of the last one in the

	/*

	 * The extra 99 entries are not normally used, but are a buffer

	 * zone in case the number of entries in the leaf is corrupt.

	 * 99 is the maximum number of entries that can fit in a single

	 * leaf block.

/**

 * gfs2_dir_readahead - Issue read-ahead requests for leaf blocks.

 * @inode: the directory inode

 * @hsize: hash table size

 * @index: index into the hash table

 * @f_ra: read-ahead parameters

 *

 * Note: we can't calculate each index like dir_e_read can because we don't

 * have the leaf, and therefore we don't have the depth, and therefore we

 * don't have the length. So we have to just read enough ahead to make up

 * for the loss of information.

 First check if we've already read-ahead for the whole range. */

 if exceeded the hash table */

/**

 * dir_e_read - Reads the entries from a directory into a filldir buffer

 * @inode: the directory inode

 * @ctx: actor to feed the entries to

 * @f_ra: read-ahead parameters

 *

 * Returns: errno

 96 is max number of dirents which can be stuffed into an inode */

/**

 * gfs2_dir_search - Search a directory

 * @dir: The GFS2 directory inode

 * @name: The name we are looking up

 * @fail_on_exist: Fail if the name exists rather than looking it up

 *

 * This routine searches a directory for a file or another directory.

 * Assumes a glock is held on dip.

 *

 * Returns: errno

 ignore */);

/**

 * dir_new_leaf - Add a new leaf onto hash chain

 * @inode: The directory

 * @name: The name we are adding

 *

 * This adds a new dir leaf onto an existing leaf when there is not

 * enough space to add a new dir entry. This is a last resort after

 * we've expanded the hash table to max size and also split existing

 * leaf blocks, so it will only occur for very large directories.

 *

 * The dist parameter is set to 1 for leaf blocks directly attached

 * to the hash table, 2 for one layer of indirection, 3 for two layers

 * etc. We are thus able to tell the difference between an old leaf

 * with dist set to zero (i.e. "don't know") and a new one where we

 * set this information for debug/fsck purposes.

 *

 * Returns: 0 on success, or -ve on error

/**

 * gfs2_dir_add - Add new filename into directory

 * @inode: The directory inode

 * @name: The new name

 * @nip: The GFS2 inode to be linked in to the directory

 * @da: The directory addition info

 *

 * If the call to gfs2_diradd_alloc_required resulted in there being

 * no need to allocate any new directory blocks, then it will contain

 * a pointer to the directory entry and the bh in which it resides. We

 * can use that without having to repeat the search. If there was no

 * free space, then we must now create more space.

 *

 * Returns: 0 on success, error code on failure

/**

 * gfs2_dir_del - Delete a directory entry

 * @dip: The GFS2 inode

 * @dentry: The directory entry we want to delete

 *

 * Returns: 0 on success, error code on failure

	/* Returns _either_ the entry (if its first in block) or the

 If not first in block, adjust pointers accordingly */

/**

 * gfs2_dir_mvino - Change inode number of directory entry

 * @dip: The GFS2 directory inode

 * @filename: the filename to be moved

 * @nip: the new GFS2 inode

 * @new_type: the de_type of the new dirent

 *

 * This routine changes the inode number of a directory entry.  It's used

 * by rename to change ".." when a directory is moved.

 * Assumes a glock is held on dvp.

 *

 * Returns: errno

/**

 * leaf_dealloc - Deallocate a directory leaf

 * @dip: the directory

 * @index: the hash table offset in the directory

 * @len: the number of pointers to this leaf

 * @leaf_no: the leaf number

 * @leaf_bh: buffer_head for the starting leaf

 * @last_dealloc: 1 if this is the final dealloc for the leaf, else 0

 *

 * Returns: errno

  Count the number of leaves  */

	/* On the last dealloc, make this a regular file in case we crash.

/**

 * gfs2_dir_exhash_dealloc - free all the leaf blocks in a directory

 * @dip: the directory

 *

 * Dealloc all on-disk directory leaves to FREEMETA state

 * Change on-disk inode type to "regular file"

 *

 * Returns: errno

/**

 * gfs2_diradd_alloc_required - find if adding entry will require an allocation

 * @inode: the directory inode being written to

 * @name: the filename that's going to be added

 * @da: The structure to return dir alloc info

 *

 * Returns: 0 if ok, -ve on error

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) Sistina Software, Inc.  1997-2003 All rights reserved.

 * Copyright (C) 2004-2008 Red Hat, Inc.  All rights reserved.

 incore superblock           */

 rhashtable iterator         */

 current glock struct        */

 last position               */

/**

 * wake_up_glock  -  Wake up waiters on a glock

 * @gl: the glock

/**

 * glock_blocked_by_withdraw - determine if we can still use a glock

 * @gl: the glock

 *

 * We need to allow some glocks to be enqueued, dequeued, promoted, and demoted

 * when we're withdrawn. For example, to maintain metadata integrity, we should

 * disallow the use of inode and rgrp glocks when withdrawn. Other glocks, like

 * iopen or the transaction glocks may be safely used because none of their

 * metadata goes through the journal. So in general, we should disallow all

 * glocks that are journaled, and allow all the others. One exception is:

 * we need to allow our active journal to be promoted and demoted so others

 * may recover it and we can reacquire it when they're done.

/**

 * gfs2_glock_hold() - increment reference count on glock

 * @gl: The glock to hold

 *

/**

 * demote_ok - Check to see if it's ok to unlock a glock

 * @gl: the glock

 *

 * Returns: 1 if it's ok

	/*

	 * Note that demote_ok is used for the lru process of disposing of

	 * glocks. For this purpose, we don't care if the glock's holders

	 * have the HIF_MAY_DEMOTE flag set or not. If someone is using

	 * them, don't demote.

/*

 * Enqueue the glock on the work queue.  Passes one glock reference on to the

 * work queue.

		/*

		 * We are holding the lockref spinlock, and the work was still

		 * queued above.  The queued work (glock_work_func) takes that

		 * spinlock before dropping its glock reference(s), so it

		 * cannot have dropped them in the meantime.

/*

 * Cause the glock to be put in work queue context.

/**

 * gfs2_glock_put() - Decrement reference count on glock

 * @gl: The glock to put

 *

 last put could call sleepable dlm api */

/**

 * may_grant - check if it's ok to grant a new lock

 * @gl: The glock

 * @current_gh: One of the current holders of @gl

 * @gh: The lock request which we wish to grant

 *

 * With our current compatibility rules, if a glock has one or more active

 * holders (HIF_HOLDER flag set), any of those holders can be passed in as

 * @current_gh; they are all the same as far as compatibility with the new @gh

 * goes.

 *

 * Returns true if it's ok to grant the lock.

			/*

			 * Here we make a special exception to grant holders

			 * who agree to share the EX lock with other holders

			 * who also have the bit set. If the original holder

			 * has the LM_FLAG_NODE_SCOPE bit set, we grant more

			 * holders with the bit set.

/**

 * do_error - Something unexpected has happened during a lock request

 * @gl: The glock

 * @ret: The status from the DLM

/**

 * demote_incompat_holders - demote incompatible demoteable holders

 * @gl: the glock we want to promote

 * @new_gh: the new holder to be promoted

	/*

	 * Demote incompatible holders before we make ourselves eligible.

	 * (This holder may or may not allow auto-demoting, but we don't want

	 * to demote the new holder before it's even granted.)

		/*

		 * Since holders are at the front of the list, we stop when we

		 * find the first non-holder.

			/*

			 * We should not recurse into do_promote because

			 * __gfs2_glock_dq only calls handle_callback,

			 * gfs2_glock_add_to_lru and __gfs2_glock_queue_work.

/**

 * find_first_holder - find the first "holder" gh

 * @gl: the glock

/**

 * find_first_strong_holder - find the first non-demoteable holder

 * @gl: the glock

 *

 * Find the first holder that doesn't have the HIF_MAY_DEMOTE flag set.

/*

 * gfs2_instantiate - Call the glops instantiate function

 * @gl: The glock

 *

 * Returns: 0 if instantiate was successful, 2 if type specific operation is

 * underway, or error.

	/*

	 * Since we unlock the lockref lock, we set a flag to indicate

	 * instantiate is in progress.

		/*

		 * Here we just waited for a different instantiate to finish.

		 * But that may not have been successful, as when a process

		 * locks an inode glock _before_ it has an actual inode to

		 * instantiate into. So we check again. This process might

		 * have an inode to instantiate, so might be successful.

/**

 * do_promote - promote as many requests as possible on the current queue

 * @gl: The glock

 * 

 * Returns: 1 if there is a blocked holder at the head of the list, or 2

 *          if a type specific operation is underway.

			/*

			 * If we get here, it means we may not grant this holder for

			 * some reason. If this holder is the head of the list, it

			 * means we have a blocked holder at the head, so return 1.

		/*

		 * If we released the gl_lockref.lock the holders list may have

		 * changed. For that reason, we start again at the start of

		 * the holders queue.

/**

 * find_first_waiter - find the first gh that's waiting for the glock

 * @gl: the glock

/**

 * state_change - record that the glock is now in a different state

 * @gl: the glock

 * @new_state: the new state

 shorten our minimum hold time */

/**

 * finish_xmote - The DLM has replied to one of our lock requests

 * @gl: The glock

 * @ret: The status from the DLM

 *

 Demote to UN request arrived during demote to SH or DF */

 Check for state != intended state */

 move to back of queue and try next entry */

 Some error or failed "try lock" - report it */

 Unlocked due to conversion deadlock, try again */

 Conversion fails, unlock and try again */

 Everything else */

 Fast path - we got what we asked for */

/**

 * do_xmote - Calls the DLM to change the state of a lock

 * @gl: The lock state

 * @gh: The holder (only for promotes)

 * @target: The target lock state

 *

		/*

		 * If another process is already doing the invalidate, let that

		 * finish first.  The glock state machine will get back to this

		 * holder again later.

 Fail queued try locks */

		/* If we had a problem syncing (due to io errors or whatever,

		 * we should not invalidate the metadata or tell dlm to

		 * release the glock to other nodes.

		/*

		 * The call to go_sync should have cleared out the ail list.

		 * If there are still items, we have a problem. We ought to

		 * withdraw, but we can't because the withdraw code also uses

		 * glocks. Warn about the error, dump the glock, then fall

		 * through and wait for logd to do the withdraw for us.

	/*

	 * Check for an error encountered since we called go_sync and go_inval.

	 * If so, we can't withdraw from the glock code because the withdraw

	 * code itself uses glocks (see function signal_our_withdraw) to

	 * change the mount to read-only. Most importantly, we must not call

	 * dlm to unlock the glock until the journal is in a known good state

	 * (after journal replay) otherwise other nodes may use the object

	 * (rgrp or dinode) and then later, journal replay will corrupt the

	 * file system. The best we can do here is wait for the logd daemon

	 * to see sd_log_error and withdraw, and in the meantime, requeue the

	 * work for later.

	 *

	 * We make a special exception for some system glocks, such as the

	 * system statfs inode glock, which needs to be granted before the

	 * gfs2_quotad daemon can exit, and that exit needs to finish before

	 * we can unmount the withdrawn file system.

	 *

	 * However, if we're just unlocking the lock (say, for unmount, when

	 * gfs2_gl_hash_clear calls clear_glock) and recovery is complete

	 * then it's okay to tell dlm to unlock it.

 lock_dlm */

 lock_nolock */

/**

 * run_queue - do all outstanding tasks related to a glock

 * @gl: The glock in question

 * @nonblock: True if we must not block in run_queue

 *

 Fail queued try locks */

	/*

	 * If there is contention on the iopen glock and we have an inode, try

	 * to grab and release the inode so that it can be evicted.  This will

	 * allow the remote node to go ahead and delete the inode without us

	 * having to do it, which will avoid rgrp glock thrashing.

	 *

	 * The remote node is likely still holding the corresponding inode

	 * glock, so it will run before we get to verify that the delete has

	 * happened below.

 If the inode was evicted, gl->gl_object will now be NULL. */

		/*

		 * If we can evict the inode, give the remote node trying to

		 * delete the inode some time before verifying that the delete

		 * has happened.  Otherwise, if we cause contention on the inode glock

		 * immediately, the remote node will think that we still have

		 * the inode in use, and so it will give up waiting.

		 *

		 * If we can't evict the inode, signal to the remote node that

		 * the inode is still in use.  We'll later try to delete the

		 * inode locally in gfs2_evict_inode.

		 *

		 * FIXME: We only need to verify that the remote node has

		 * deleted the inode because nodes before this remote delete

		 * rework won't cooperate.  At a later time, when we no longer

		 * care about compatibility with such nodes, we can skip this

		 * step entirely.

 Keep one glock reference for the work we requeue. */

	/*

	 * Drop the remaining glock references manually here. (Mind that

	 * __gfs2_glock_queue_work depends on the lockref spinlock begin held

	 * here as well.)

/**

 * gfs2_glock_get() - Get a glock, or create one if one doesn't exist

 * @sdp: The GFS2 superblock

 * @number: the lock number

 * @glops: The glock_operations to use

 * @create: If 0, don't create the glock if it doesn't exist

 * @glp: the glock is returned here

 *

 * This does not lock a glock, just finds/creates structures for one.

 *

 * Returns: errno

 We use the global stats to estimate the initial per-glock stats */

/**

 * gfs2_holder_init - initialize a struct gfs2_holder in the default way

 * @gl: the glock

 * @state: the state we're requesting

 * @flags: the modifier flags

 * @gh: the holder structure

 *

/**

 * gfs2_holder_reinit - reinitialize a struct gfs2_holder so we can requeue it

 * @state: the state we're requesting

 * @flags: the modifier flags

 * @gh: the holder structure

 *

 * Don't mess with the glock.

 *

/**

 * gfs2_holder_uninit - uninitialize a holder structure (drop glock reference)

 * @gh: the holder structure

 *

 Have we waited longer that a second? */

 Lengthen the minimum hold time. */

/**

 * gfs2_glock_wait - wait on a glock acquisition

 * @gh: the glock holder

 *

 * Returns: 0 on success

/**

 * gfs2_glock_async_wait - wait on multiple asynchronous glock acquisitions

 * @num_gh: the number of holders in the array

 * @ghs: the glock holder array

 *

 * Returns: 0 on success, meaning all glocks have been granted and are held.

 *          -ESTALE if the request timed out, meaning all glocks were released,

 *          and the caller should retry the operation.

	/*

	 * Total up the (minimum hold time * 2) of all glocks and use that to

	 * determine the max amount of time we should wait.

 request timed out. */

	/*

	 * If dlm granted all our requests, we need to adjust the glock

	 * minimum hold time values according to how long we waited.

	 *

	 * If our request timed out, we need to repeatedly release any held

	 * glocks we acquired thus far to allow dlm to acquire the remaining

	 * glocks without deadlocking.  We cannot currently cancel outstanding

	 * glock acquisitions.

	 *

	 * The HIF_WAIT bit tells us which requests still need a response from

	 * dlm.

	 *

	 * If dlm sent us any errors, we return the first error we find.

 Skip holders we have already dequeued below. */

 Skip holders with a pending DLM response. */

	/*

	 * At this point, we've either acquired all locks or released them all.

/**

 * handle_callback - process a demote request

 * @gl: the glock

 * @state: the state the caller wants us to change to

 * @delay: zero to demote immediately; otherwise pending demote

 * @remote: true if this came from a different cluster node

 *

 * There are only two requests that we are going to see in actual

 * practise: LM_ST_SHARED and LM_ST_UNLOCKED

/**

 * add_to_queue - Add a holder to the wait queue (but look for recursion)

 * @gh: the holder structure to add

 *

 * Eventually we should move the recursive locking trap to a

 * debugging option or something like that. This is the fast

 * path and needs to have the minimum number of distractions.

 * 

/**

 * gfs2_glock_nq - enqueue a struct gfs2_holder onto a glock (acquire a glock)

 * @gh: the holder structure

 *

 * if (gh->gh_flags & GL_ASYNC), this never returns an error

 *

 * Returns: 0, GLR_TRYFAILED, or errno on failure

/**

 * gfs2_glock_poll - poll to see if an async request has been completed

 * @gh: the holder

 *

 * Returns: 1 if the request is ready to be gfs2_glock_wait()ed on

	/*

	 * This while loop is similar to function demote_incompat_holders:

	 * If the glock is due to be demoted (which may be from another node

	 * or even if this holder is GL_NOCACHE), the weak holders are

	 * demoted as well, allowing the glock to be demoted.

		/*

		 * If we're in the process of file system withdraw, we cannot

		 * just dequeue any glocks until our journal is recovered, lest

		 * we introduce file system corruption. We need two exceptions

		 * to this rule: We need to allow unlocking of nondisk glocks

		 * and the glock for our own journal that needs recovery.

		/*

		 * This holder should not be cached, so mark it for demote.

		 * Note: this should be done before the check for needs_demote

		 * below.

		/*

		 * If there hasn't been a demote request we are done.

		 * (Let the remaining holders, if any, keep holding it.)

		/*

		 * If we have another strong holder (we cannot auto-demote)

		 * we are done. It keeps holding it until it is done.

		/*

		 * If we have a weak holder at the head of the list, it

		 * (and all others like it) must be auto-demoted. If there

		 * are no more weak holders, we exit the while loop.

/**

 * gfs2_glock_dq - dequeue a struct gfs2_holder from a glock (release a glock)

 * @gh: the glock holder

 *

/**

 * gfs2_glock_dq_uninit - dequeue a holder from a glock and initialize it

 * @gh: the holder structure

 *

/**

 * gfs2_glock_nq_num - acquire a glock based on lock number

 * @sdp: the filesystem

 * @number: the lock number

 * @glops: the glock operations for the type of glock

 * @state: the state to acquire the glock in

 * @flags: modifier flags for the acquisition

 * @gh: the struct gfs2_holder

 *

 * Returns: errno

/**

 * glock_compare - Compare two struct gfs2_glock structures for sorting

 * @arg_a: the first structure

 * @arg_b: the second structure

 *

/**

 * nq_m_sync - synchonously acquire more than one glock in deadlock free order

 * @num_gh: the number of structures

 * @ghs: an array of struct gfs2_holder structures

 * @p: placeholder for the holder structure to pass back

 *

 * Returns: 0 on success (all glocks acquired),

 *          errno on failure (no glocks acquired)

/**

 * gfs2_glock_nq_m - acquire multiple glocks

 * @num_gh: the number of structures

 * @ghs: an array of struct gfs2_holder structures

 *

 *

 * Returns: 0 on success (all glocks acquired),

 *          errno on failure (no glocks acquired)

/**

 * gfs2_glock_dq_m - release multiple glocks

 * @num_gh: the number of structures

 * @ghs: an array of struct gfs2_holder structures

 *

	/*

	 * Note 1: We cannot call demote_incompat_holders from handle_callback

	 * or gfs2_set_demote due to recursion problems like: gfs2_glock_dq ->

	 * handle_callback -> demote_incompat_holders -> gfs2_glock_dq

	 * Plus, we only want to demote the holders if the request comes from

	 * a remote cluster node because local holder conflicts are resolved

	 * elsewhere.

	 *

	 * Note 2: if a remote node wants this glock in EX mode, lock_dlm will

	 * request that we set our state to UNLOCKED. Here we mock up a holder

	 * to make it look like someone wants the lock EX locally. Any SH

	 * and DF requests should be able to share the lock without demoting.

	 *

	 * Note 3: We only want to demote the demoteable holders when there

	 * are no more strong holders. The demoteable holders might as well

	 * keep the glock until the last strong holder is done with it.

/**

 * gfs2_should_freeze - Figure out if glock should be frozen

 * @gl: The glock in question

 *

 * Glocks are not frozen if (a) the result of the dlm operation is

 * an error, (b) the locking operation was an unlock operation or

 * (c) if there is a "noexp" flagged request anywhere in the queue

 *

 * Returns: 1 if freezing should occur, 0 otherwise

/**

 * gfs2_glock_complete - Callback used by locking

 * @gl: Pointer to the glock

 * @ret: The return value from the dlm

 *

 * The gl_reply field is under the gl_lockref.lock lock so that it is ok

 * to use a bitfield shared with other glock state fields.

/**

 * gfs2_dispose_glock_lru - Demote a list of glocks

 * @list: The list to dispose of

 *

 * Disposing of glocks may involve disk accesses, so that here we sort

 * the glocks by number (i.e. disk location of the inodes) so that if

 * there are any such accesses, they'll be sent in order (mostly).

 *

 * Must be called under the lru_lock, but may drop and retake this

 * lock. While the lru_lock is dropped, entries may vanish from the

 * list, but no new entries will appear on the list (since it is

 * private)

/**

 * gfs2_scan_glock_lru - Scan the LRU looking for locks to demote

 * @nr: The number of entries to scan

 *

 * This function selects the entries on the LRU which are able to

 * be demoted, and then kicks off the process by calling

 * gfs2_dispose_glock_lru() above.

 Test for being demotable */

/**

 * glock_hash_walk - Call a function for glock in a hash bucket

 * @examiner: the function

 * @sdp: the filesystem

 *

 * Note that the function can be called multiple times on the same

 * object.  So the user must ensure that the function can cope with

 * that.

/**

 * thaw_glock - thaw out a glock which has an unprocessed reply waiting

 * @gl: The glock to thaw

 *

/**

 * clear_glock - look at a glock and see if we can free it from glock cache

 * @gl: the glock to look at

 *

/**

 * gfs2_glock_thaw - Thaw any frozen glocks

 * @sdp: The super block

 *

/**

 * gfs2_gl_hash_clear - Empty out the glock hash table

 * @sdp: the filesystem

 *

 * Called when unmounting the filesystem.

/**

 * dump_holder - print information about a glock holder

 * @seq: the seq_file struct

 * @gh: the glock holder

 * @fs_id_buf: pointer to file system id (if requested)

 *

/**

 * gfs2_dump_glock - print information about a glock

 * @seq: The seq_file struct

 * @gl: the glock

 * @fsid: If true, also dump the file system id

 *

 * The file format is as follows:

 * One line per object, capital letters are used to indicate objects

 * G = glock, I = Inode, R = rgrp, H = holder. Glocks are not indented,

 * other objects are indented by a single space and follow the glock to

 * which they are related. Fields are indicated by lower case letters

 * followed by a colon and the field value, except for strings which are in

 * [] so that its possible to see if they are composed of spaces for

 * example. The field's are n = number (id of the object), f = flags,

 * t = type, s = state, r = refcount, e = error, p = pid.

 *

 safety precaution */

 demote time in uSec */

	/*

	 * We can either stay where we are, skip to the next hash table

	 * entry, or start from the beginning.

		/*

		 * Initially, we are "before" the first hash table entry; the

		 * first call to rhashtable_walk_next gets us the first entry.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) Sistina Software, Inc.  1997-2003 All rights reserved.

 * Copyright (C) 2004-2006 Red Hat, Inc.  All rights reserved.

/**

 * gfs2_llseek - seek to a location in a file

 * @file: the file

 * @offset: the offset

 * @whence: Where to seek from (SEEK_SET, SEEK_CUR, or SEEK_END)

 *

 * SEEK_END requires the glock for the file because it references the

 * file's size.

 *

 * Returns: The new offset, or errno

		/*

		 * These don't reference inode->i_size and don't depend on the

		 * block mapping, so we don't need the glock.

/**

 * gfs2_readdir - Iterator for a directory

 * @file: The directory to read from

 * @ctx: What to feed directory entries to

 *

 * Returns: errno

/*

 * struct fsflag_gfs2flag

 *

 * The FS_JOURNAL_DATA_FL flag maps to GFS2_DIF_INHERIT_JDATA for directories,

 * and to GFS2_DIF_JDATA for non-directories.

 Flags that can be set by user space */

/**

 * do_gfs2_set_flags - set flags on an inode

 * @inode: The inode

 * @reqflags: The flags to set

 * @mask: Indicates which flags are valid

 *

 The GFS2_DIF_TOPDIR flag is only valid for directories. */

 Keep this list in sync with gfs2_ioctl */

/**

 * gfs2_size_hint - Give a hint to the size of a write request

 * @filep: The struct file

 * @offset: The file offset of the write

 * @size: The length of the write

 *

 * When we are about to do a write, this function records the total

 * write size in order to provide a suitable hint to the lower layers

 * about how many blocks will be required.

 *

/**

 * gfs2_allocate_page_backing - Allocate blocks for a write fault

 * @page: The (locked) page to allocate backing for

 * @length: Size of the allocation

 *

 * We try to allocate all the blocks required for the page in one go.  This

 * might fail for various reasons, so we keep trying until all the blocks to

 * back this page are allocated.  If some of the blocks are already allocated,

 * that is ok too.

/**

 * gfs2_page_mkwrite - Make a shared, mmap()ed, page writable

 * @vmf: The virtual memory fault containing the page to become writable

 *

 * When the page becomes writable, we need to ensure that we have

 * blocks allocated on disk to back that page.

 Check page index against inode size */

 Update file times before taking page lock */

 page is wholly or partially inside EOF */

	/*

	 * iomap_writepage / iomap_writepages currently don't support inline

	 * files, so always unstuff here.

 Unstuff, if required, and allocate backing blocks for page */

	/* If truncated, we must retry the operation, we may have raced

	 * with the glock demotion code.

/**

 * gfs2_mmap

 * @file: The file to map

 * @vma: The VMA which described the mapping

 *

 * There is no need to get a lock here unless we should be updating

 * atime. We ignore any locking errors since the only consequence is

 * a missed atime update (which will just be deferred until later).

 *

 * Returns: 0

 grab lock to update inode */

/**

 * gfs2_open_common - This is common to open and atomic_open

 * @inode: The inode being opened

 * @file: The file being opened

 *

 * This maybe called under a glock or not depending upon how it has

 * been called. We must always be called under a glock for regular

 * files, however. For other file types, it does not matter whether

 * we hold the glock or not.

 *

 * Returns: Error code or 0 for success

/**

 * gfs2_open - open a file

 * @inode: the inode to open

 * @file: the struct file for this opening

 *

 * After atomic_open, this function is only used for opening files

 * which are already cached. We must still get the glock for regular

 * files to ensure that we have the file size uptodate for the large

 * file check which is in the common code. That is only an issue for

 * regular files though.

 *

 * Returns: errno

/**

 * gfs2_release - called to close a struct file

 * @inode: the inode the struct file belongs to

 * @file: the struct file being closed

 *

 * Returns: errno

/**

 * gfs2_fsync - sync the dirty data for a file (across the cluster)

 * @file: the file that points to the dentry

 * @start: the start position in the file to sync

 * @end: the end position in the file to sync

 * @datasync: set if we can ignore timestamp changes

 *

 * We split the data flushing here so that we don't wait for the data

 * until after we've also sent the metadata to disk. Note that for

 * data=ordered, we will write & wait for the data at the log flush

 * stage anyway, so this is unlikely to make much of a difference

 * except in the data=writeback case.

 *

 * If the fdatawrite fails due to any reason except -EIO, we will

 * continue the remainder of the fsync, although we'll still report

 * the error at the end. This is to match filemap_write_and_wait_range()

 * behaviour.

 *

 * Returns: errno

	/*

	 * In this function, we disable page faults when we're holding the

	 * inode glock while doing I/O.  If a page fault occurs, we indicate

	 * that the inode glock may be dropped, fault in the pages manually,

	 * and retry.

	 *

	 * Unlike generic_file_read_iter, for reads, iomap_dio_rw can trigger

	 * physical as well as manual page faults, and we need to disable both

	 * kinds.

	 *

	 * For direct I/O, gfs2 takes the inode glock in deferred mode.  This

	 * locking mode is compatible with other deferred holders, so multiple

	 * processes and nodes can do direct I/O to a file at the same time.

	 * There's no guarantee that reads or writes will be atomic.  Any

	 * coordination among readers and writers needs to happen externally.

 skip atime */

	/*

	 * In this function, we disable page faults when we're holding the

	 * inode glock while doing I/O.  If a page fault occurs, we indicate

	 * that the inode glock may be dropped, fault in the pages manually,

	 * and retry.

	 *

	 * For writes, iomap_dio_rw only triggers manual page faults, so we

	 * don't need to disable physical ones.

	/*

	 * Deferred lock, even if its a write, since we do no allocation on

	 * this path. All we need to change is the atime, and this lock mode

	 * ensures that other nodes have flushed their buffered read caches

	 * (i.e. their page cache entries for this inode). We do not,

	 * unfortunately, have the option of only flushing a range like the

	 * VFS does.

 Silently fall back to buffered I/O when writing beyond EOF */

	/*

	 * In this function, we disable page faults when we're holding the

	 * inode glock while doing I/O.  If a page fault occurs, we indicate

	 * that the inode glock may be dropped, fault in the pages manually,

	 * and retry.

	/*

	 * In this function, we disable page faults when we're holding the

	 * inode glock while doing I/O.  If a page fault occurs, we indicate

	 * that the inode glock may be dropped, fault in the pages manually,

	 * and retry.

/**

 * gfs2_file_write_iter - Perform a write to a file

 * @iocb: The io context

 * @from: The data to write

 *

 * We have to do a lock/unlock here to refresh the inode size for

 * O_APPEND writes, otherwise we can land up writing at the wrong

 * offset. There is still a race, but provided the app is using its

 * own file locking, this will make O_APPEND work as expected.

 *

		/*

		 * We need to ensure that the page cache pages are written to

		 * disk and invalidated to preserve the expected O_DIRECT

		 * semantics.  If the writeback or invalidate fails, only report

		 * the direct I/O range as we don't know if the buffered pages

		 * made it to disk.

/**

 * calc_max_reserv() - Reverse of write_calc_reserv. Given a number of

 *                     blocks, determine how many bytes can be written.

 * @ip:          The inode in question.

 * @len:         Max cap of bytes. What we return in *len must be <= this.

 * @data_blocks: Compute and return the number of data blocks needed

 * @ind_blocks:  Compute and return the number of indirect blocks needed

 * @max_blocks:  The total blocks available to work with.

 *

 * Returns: void, but @len, @data_blocks and @ind_blocks are filled in.

		/* We need to determine how many bytes we can actually

		 * fallocate without exceeding quota or going over the

		 * end of the fs. We start off optimistically by assuming

		/* Since max_bytes is most likely a theoretical max, we

		 * calculate a more realistic 'bytes' to serve as a good

		 * starting point for the number of bytes we may be able

		/* ap.allowed tells us how many blocks quota will allow

 check if the selected rgrp limits our max_blks further */

		/* Almost done. Calculate bytes that can be written using

		 * max_blks. We also recompute max_bytes, data_blocks and

 fallocate is needed by gfs2_grow to reserve space in the rindex */

/**

 * gfs2_lock - acquire/release a posix lock on a file

 * @file: the file pointer

 * @cmd: either modify or retrieve lock state, possibly wait

 * @fl: type and range of lock

 *

 * Returns: errno

 Hack: */

/**

 * gfs2_flock - acquire/release a flock lock on a file

 * @file: the file pointer

 * @cmd: either modify or retrieve lock state, possibly wait

 * @fl: type and range of lock

 *

 * Returns: errno

 CONFIG_GFS2_FS_LOCKING_DLM */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) Sistina Software, Inc.  1997-2003 All rights reserved.

 * Copyright (C) 2004-2006 Red Hat, Inc.  All rights reserved.

/**

 * check_journal_clean - Make sure a journal is clean for a spectator mount

 * @sdp: The GFS2 superblock

 * @jd: The journal descriptor

 * @verbose: Show more prints in the log

 *

 * Returns: 0 if the journal is clean or locked, else an error

/**

 * gfs2_freeze_lock - hold the freeze glock

 * @sdp: the superblock

 * @freeze_gh: pointer to the requested holder

 * @caller_flags: any additional flags needed by the caller

 frees all transactions */

 Prevent any glock dq until withdraw recovery is complete */

	/*

	 * Don't tell dlm we're bailing until we have no more buffers in the

	 * wind. If journal had an IO error, the log code should just purge

	 * the outstanding buffers rather than submitting new IO. Making the

	 * file system read-only will flush the journal, etc.

	 *

	 * During a normal unmount, gfs2_make_fs_ro calls gfs2_log_shutdown

	 * which clears SDF_JOURNAL_LIVE. In a withdraw, we must not write

	 * any UNMOUNT log header, so we can't call gfs2_log_shutdown, and

	 * therefore we need to clear SDF_JOURNAL_LIVE manually.

 lock_nolock */

	/*

	 * Drop the glock for our journal so another node can recover it.

 Make sure gfs2_unfreeze works if partially-frozen */

	/*

	 * holder_uninit to force glock_put, to force dlm to let go

	/*

	 * Note: We need to be careful here:

	 * Our iput of jd_inode will evict it. The evict will dequeue its

	 * glock, but the glock dq will wait for the withdraw unless we have

	 * exception code in glock_dq.

	/*

	 * Wait until the journal inode's glock is freed. This allows try locks

	 * on other nodes to be successful, otherwise we remain the owner of

	 * the glock as far as dlm is concerned.

	/*

	 * Dequeue the "live" glock, but keep a reference so it's never freed.

	/*

	 * We enqueue the "live" glock in EX so that all other nodes

	 * get a demote request and act on it. We don't really want the

	 * lock in EX, so we send a "try" lock with 1CB to produce a callback.

	/*

	 * This will likely fail in a cluster, but succeed standalone:

	/*

	 * If we actually got the "live" lock in EX mode, there are no other

	 * nodes available to replay our journal. So we try to replay it

	 * ourselves. We hold the "live" glock to prevent other mounters

	 * during recovery, then just dequeue it and reacquire it in our

	 * normal SH mode. Just in case the problem that caused us to

	 * withdraw prevents us from recovering our journal (e.g. io errors

	 * and such) we still check if the journal is clean before proceeding

	 * but we may wait forever until another mounter does the recovery.

 drop extra reference we acquired */

	/*

	 * At this point our journal is evicted, so we need to get a new inode

	 * for it. Once done, we need to call gfs2_find_jhead which

	 * calls gfs2_map_journal_extents to map it for us again.

	 *

	 * Note that we don't really want it to look up a FREE block. The

	 * GFS2_BLKST_FREE simply overrides a block check in gfs2_inode_lookup

	 * which would otherwise fail because it requires grabbing an rgrp

	 * glock, which would fail with -EIO because we're withdrawing.

	/*

	 * Now wait until recovery is complete.

/*

 * gfs2_assert_withdraw_i - Cause the machine to withdraw if @assertion is false

	/*

	 * If errors=panic was specified on mount, it won't help to delay the

	 * withdraw.

/*

 * gfs2_assert_warn_i - Print a message to the console if @assertion is false

/*

 * gfs2_consist_i - Flag a filesystem consistency error and withdraw

/*

 * gfs2_consist_inode_i - Flag an inode consistency error and withdraw

/*

 * gfs2_consist_rgrpd_i - Flag a RG consistency error and withdraw

/*

 * gfs2_meta_check_ii - Flag a magic number consistency error and withdraw

 * Returns: -1 if this call withdrew the machine,

 *          -2 if it was already withdrawn

/*

 * gfs2_metatype_check_ii - Flag a metadata type consistency error and withdraw

 * Returns: -1 if this call withdrew the machine,

 *          -2 if it was already withdrawn

/*

 * gfs2_io_error_i - Flag an I/O error and withdraw

 * Returns: -1 if this call withdrew the machine,

 *          0 if it was already withdrawn

/*

 * gfs2_io_error_bh_i - Flag a buffer I/O error

 * @withdraw: withdraw the filesystem

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) Sistina Software, Inc.  1997-2003 All rights reserved.

 * Copyright (C) 2004-2007 Red Hat, Inc.  All rights reserved.

/*

 * Quota change tags are associated with each transaction that allocates or

 * deallocates space.  Those changes are accumulated locally to each node (in a

 * per-node file) and then are periodically synced to the quota file.  This

 * avoids the bottleneck of constantly touching the quota file, but introduces

 * fuzziness in the current usage value of IDs that are being used on different

 * nodes in the cluster simultaneously.  So, it is possible for a user on

 * multiple nodes to overrun their quota, but that overrun is controlable.

 * Since quota tags are part of transactions, there is no need for a quota check

 * program to be run on node crashes or anything like that.

 *

 * There are couple of knobs that let the administrator manage the quota

 * fuzziness.  "quota_quantum" sets the maximum time a quota change can be

 * sitting on one node before being synced to the quota file.  (The default is

 * 60 seconds.)  Another knob, "quota_scale" controls how quickly the frequency

 * of quota file syncs increases as the user moves closer to their limit.  The

 * more frequent the syncs, the more accurate the quota enforcement, but that

 * means that there is more contention between the nodes for the quota file.

 * The default value is one.  This sets the maximum theoretical quota overrun

 * (with infinite node with infinite bandwidth) to twice the user's limit.  (In

 * practice, the maximum overrun you see should be much less.)  A "quota_scale"

 * number greater than one makes quota syncs more frequent and reduces the

 * maximum overrun.  Numbers less than one (but greater than zero) make quota

 * syncs less frequent.

 *

 * GFS quotas also use per-ID Lock Value Blocks (LVBs) to cache the contents of

 * the quota file, so it is not being constantly read.

 Lock order: qd_lock -> bucket lock -> qd->lockref.lock -> lru lock */

                     -> sd_bitmap_lock                              */

 Free from the filesystem-specific list */

 Delete it from the common reclaim list */

/**

 * gfs2_qa_get - make sure we have a quota allocations data structure,

 *               if necessary

 * @ip: the inode for this reservation

 Reset quiet flag if we freed some blocks */

 Find the beginning block within the page */

 If it's a newly allocated disk block, zero it */

 If we need to write to the next block as well */

 Write to the page, now that we have setup the buffer(s) */

 If the quota straddles a page boundary, split the write in two */

 If there's an overflow, write the remaining bytes to the next page */

/**

 * gfs2_adjust_quota - adjust record of current block usage

 * @ip: The quota inode

 * @loc: Offset of the entry in the quota file

 * @change: The amount of usage change to record

 * @qd: The quota data

 * @fdq: The updated limits to record

 *

 * This function was mostly borrowed from gfs2_block_truncate_page which was

 * in turn mostly borrowed from ext3

 *

 * Returns: 0 or -ve on error

 gfs2_internal_read would've advanced the loc ptr */

 Never go negative on quota usage */

	/* 

	 * 1 blk for unstuffing inode if stuffed. We add this extra

	 * block to the reservation unconditionally. If the inode

	 * doesn't need unstuffing, the block will be released to the 

	 * rgrp since it won't be allocated during the transaction

	/* +3 in the end for unstuffing block, inode size update block

	 * and another block in case quota straddles page boundary and 

/**

 * gfs2_quota_check - check if allocating new blocks will exceed quota

 * @ip:  The inode for which this check is being performed

 * @uid: The uid to check against

 * @gid: The gid to check against

 * @ap:  The allocation parameters. ap->target contains the requested

 *       blocks. ap->min_target, if set, contains the minimum blks

 *       requested.

 *

 * Returns: 0 on success.

 *                  min_req = ap->min_target ? ap->min_target : ap->target;

 *                  quota must allow at least min_req blks for success and

 *                  ap->allowed is set to the number of blocks allowed

 *

 *          -EDQUOT otherwise, quota violation. ap->allowed is set to number

 *                  of blocks available.

 Assume we are permitted a whole lot */

 If we can't meet the target */

			/* If no min_target specified or we don't meet

 Also remove if this qd exists in the reclaim list */

/**

 * gfs2_quotad - Write cached quota changes into the quota file

 * @data: Pointer to GFS2 superblock

 *

 Update the master statfs file */

 Update quota file */

 Check for & recover partially truncated inodes */

 unsupported */

 Crazy XFS error code */

 GFS2 only supports a subset of the XFS fields */

 Crazy XFS error code */

 Check for existing entry, if none then alloc new blocks */

 If nothing has changed, this is a no-op */

	/* Some quotas span block boundaries and can update two blocks,

 Apply changes */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) Sistina Software, Inc.  1997-2003 All rights reserved.

 * Copyright (C) 2004-2006 Red Hat, Inc.  All rights reserved.

 assume lh_hash is zero */

/**

 * get_log_header - read the log header for a given segment

 * @jd: the journal

 * @blk: the block to look at

 * @head: the log header to return

 *

 * Read the log header for a given segement in a given journal.  Do a few

 * sanity checks on it.

 *

 * Returns: 0 on success,

 *          1 if the header was invalid or incomplete,

 *          errno on error

/**

 * foreach_descriptor - go through the active part of the log

 * @jd: the journal

 * @start: the first log header in the active region

 * @end: the last log header (don't process the contents of this entry))

 * @pass: iteration number (foreach_descriptor() is called in a for() loop)

 *

 * Call a given function once for every log descriptor in the active

 * portion of the log.

 *

 * Returns: errno

/**

 * clean_journal - mark a dirty journal as being clean

 * @jd: the journal

 * @head: the head journal to start from

 *

 * Returns: errno

/**

 * update_statfs_inode - Update the master statfs inode or zero out the local

 *			 statfs inode for a given journal.

 * @jd: The journal

 * @head: If NULL, @inode is the local statfs inode and we need to zero it out.

 *	  Otherwise, it @head contains the statfs change info that needs to be

 *	  synced to the master statfs inode (pointed to by @inode).

 * @inode: statfs inode to update.

 Update the master statfs inode */

 Zero out the local statfs inode */

 If it's our own journal, reset any in-memory changes too */

/**

 * recover_local_statfs - Update the master and local statfs changes for this

 *			  journal.

 *

 * Previously, statfs updates would be read in from the local statfs inode and

 * synced to the master statfs inode during recovery.

 *

 * We now use the statfs updates in the journal head to update the master statfs

 * inode instead of reading in from the local statfs inode. To preserve backward

 * compatibility with kernels that can't do this, we still need to keep the

 * local statfs inode up to date by writing changes to it. At some point in the

 * future, we can do away with the local statfs inodes altogether and keep the

 * statfs changes solely in the journal.

 *

 * @jd: the journal

 * @head: the journal head

 *

 * Returns: errno

 No change */

	 /* First update the master statfs inode with the changes we

	/* Zero out the local statfs inode so any changes in there

 Acquire the journal lock so we can do recovery */

 Acquire a shared hold on the freeze lock */

 check if device itself is read-only */

		/* We take the sd_log_flush_lock here primarily to prevent log

		 * flushes and simultaneous journal replays from stomping on

 we have JDF_RECOVERY, queue should always succeed */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) Sistina Software, Inc.  1997-2003 All rights reserved.

 * Copyright (C) 2004-2006 Red Hat, Inc.  All rights reserved.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) Sistina Software, Inc.  1997-2003 All rights reserved.

 * Copyright (C) 2004-2006 Red Hat, Inc.  All rights reserved.

/* This doesn't need to be that large as max 64 bit pointers in a 4k

 * block is 512, so __u16 is fine for that. It saves stack space to

 * keep it small.

 find_metapath height */

 actual height (lookup height) */

/**

 * gfs2_unstuffer_page - unstuff a stuffed inode into a block cached by a page

 * @ip: the inode

 * @dibh: the dinode buffer

 * @block: the block number that was allocated

 * @page: The (optional) page. This is looked up if @page is NULL

 *

 * Returns: errno

		/* Get a free block, fill it with the stuffed data,

  Set up the pointer to the new block  */

/**

 * gfs2_unstuff_dinode - Unstuff a dinode when the data has grown too big

 * @ip: The GFS2 inode to unstuff

 *

 * This routine unstuffs a dinode and returns it to a "normal" state such

 * that the height can be grown in the traditional way.

 *

 * Returns: errno

/**

 * find_metapath - Find path through the metadata tree

 * @sdp: The superblock

 * @block: The disk block to look up

 * @mp: The metapath to return the result in

 * @height: The pre-calculated height of the metadata tree

 *

 *   This routine returns a struct metapath structure that defines a path

 *   through the metadata of inode "ip" to get to block "block".

 *

 *   Example:

 *   Given:  "ip" is a height 3 file, "offset" is 101342453, and this is a

 *   filesystem with a blocksize of 4096.

 *

 *   find_metapath() would return a struct metapath structure set to:

 *   mp_fheight = 3, mp_list[0] = 0, mp_list[1] = 48, and mp_list[2] = 165.

 *

 *   That means that in order to get to the block containing the byte at

 *   offset 101342453, we would load the indirect block pointed to by pointer

 *   0 in the dinode.  We would then load the indirect block pointed to by

 *   pointer 48 in that indirect block.  We would then load the data block

 *   pointed to by pointer 165 in that indirect block.

 *

 *             ----------------------------------------

 *             | Dinode |                             |

 *             |        |                            4|

 *             |        |0 1 2 3 4 5                 9|

 *             |        |                            6|

 *             ----------------------------------------

 *                       |

 *                       |

 *                       V

 *             ----------------------------------------

 *             | Indirect Block                       |

 *             |                                     5|

 *             |            4 4 4 4 4 5 5            1|

 *             |0           5 6 7 8 9 0 1            2|

 *             ----------------------------------------

 *                                |

 *                                |

 *                                V

 *             ----------------------------------------

 *             | Indirect Block                       |

 *             |                         1 1 1 1 1   5|

 *             |                         6 6 6 6 6   1|

 *             |0                        3 4 5 6 7   2|

 *             ----------------------------------------

 *                                           |

 *                                           |

 *                                           V

 *             ----------------------------------------

 *             | Data block containing offset         |

 *             |            101342453                 |

 *             |                                      |

 *             |                                      |

 *             ----------------------------------------

 *

/**

 * metaptr1 - Return the first possible metadata pointer in a metapath buffer

 * @height: The metadata height (0 = dinode)

 * @mp: The metapath

/**

 * metapointer - Return pointer to start of metadata in a buffer

 * @height: The metadata height (0 = dinode)

 * @mp: The metapath

 *

 * Return a pointer to the block number of the next height of the metadata

 * tree given a buffer containing the pointer to the current height of the

 * metadata tree.

/**

 * lookup_metapath - Walk the metadata tree to a specific point

 * @ip: The inode

 * @mp: The metapath

 *

 * Assumes that the inode's buffer has already been looked up and

 * hooked onto mp->mp_bh[0] and that the metapath has been initialised

 * by find_metapath().

 *

 * If this function encounters part of the tree which has not been

 * allocated, it returns the current height of the tree at the point

 * at which it found the unallocated block. Blocks which are found are

 * added to the mp->mp_bh[] list.

 *

 * Returns: error

/**

 * fillup_metapath - fill up buffers for the metadata path to a specific height

 * @ip: The inode

 * @mp: The metapath

 * @h: The height to which it should be mapped

 *

 * Similar to lookup_metapath, but does lookups for a range of heights

 *

 * Returns: error or the number of buffers filled

 find the first buffer we need to look up. */

/**

 * gfs2_extent_length - Returns length of an extent of blocks

 * @bh: The metadata block

 * @ptr: Current position in @bh

 * @limit: Max extent length to return

 * @eob: Set to 1 if we hit "end of block"

 *

 * Returns: The length of the extent (minimum of one block)

/*

 * gfs2_metadata_walker - walk an indirect block

 * @mp: Metapath to indirect block

 * @ptrs: Number of pointers to look at

 *

 * When returning WALK_FOLLOW, the walker must update @mp to point at the right

 * indirect block to follow.

/*

 * gfs2_walk_metadata - walk a tree of indirect blocks

 * @inode: The inode

 * @mp: Starting point of walk

 * @max_len: Maximum number of blocks to walk

 * @walker: Called during the walk

 *

 * Returns 1 if the walk was stopped by @walker, 0 if we went past @max_len or

 * past the end of metadata, and a negative error code otherwise.

	/*

	 * The walk starts in the lowest allocated indirect block, which may be

	 * before the position indicated by @mp.  Adjust @max_len accordingly

	 * to avoid a short walk.

 Walk indirect block. */

 Decrease height of metapath. */

 Advance in metadata tree. */

 Increase height of metapath. */

/**

 * gfs2_hole_size - figure out the size of a hole

 * @inode: The inode

 * @lblock: The logical starting block number

 * @len: How far to look (in blocks)

 * @mp: The metapath at lblock

 * @iomap: The iomap to store the hole size in

 *

 * This function modifies @mp.

 *

 * Returns: errno on error

 ALLOC_UNSTUFF = 3,   TBD and rather complicated */

/**

 * __gfs2_iomap_alloc - Build a metadata tree of the requested height

 * @inode: The GFS2 inode

 * @iomap: The iomap structure

 * @mp: The metapath, with proper height information calculated

 *

 * In this routine we may have to alloc:

 *   i) Indirect blocks to grow the metadata tree height

 *  ii) Indirect blocks to fill in lower part of the metadata tree

 * iii) Data blocks

 *

 * This function is called after __gfs2_iomap_get, which works out the

 * total number of blocks which we need via gfs2_alloc_size.

 *

 * We then do the actual allocation asking for an extent at a time (if

 * enough contiguous free blocks are available, there will only be one

 * allocation request per call) and uses the state machine to initialise

 * the blocks in order.

 *

 * Right now, this function will allocate at most one indirect block

 * worth of data -- with a default block size of 4K, that's slightly

 * less than 2M.  If this limitation is ever removed to allow huge

 * allocations, we would probably still want to limit the iomap size we

 * return to avoid stalling other tasks during huge writes; the next

 * iomap iteration would then find the blocks already allocated.

 *

 * Returns: errno on error

 Bottom indirect block exists */

 Need to allocate indirect blocks */

 Writing into existing tree, extend tree down */

 Building up tree height */

 start of the second part of the function (state machine) */

 Growing height of tree */

 To branching from existing tree */

 To tree complete, adding data blocks */

/**

 * gfs2_alloc_size - Compute the maximum allocation size

 * @inode: The inode

 * @mp: The metapath

 * @size: Requested size in blocks

 *

 * Compute the maximum size of the next allocation at @mp.

 *

 * Returns: size in blocks

	/*

	 * For writes to stuffed files, this function is called twice via

	 * __gfs2_iomap_get, before and after unstuffing. The size we return the

	 * first time needs to be large enough to get the reservation and

	 * allocation sizes right.  The size we return the second time must

	 * be exact or else __gfs2_iomap_alloc won't do the right thing.

/**

 * __gfs2_iomap_get - Map blocks from an inode to disk blocks

 * @inode: The inode

 * @pos: Starting position in bytes

 * @length: Length to map, in bytes

 * @flags: iomap flags

 * @iomap: The iomap structure

 * @mp: The metapath

 *

 * Returns: errno

 (see gfs2_file_direct_write) */

			/*

			 * Silently fall back to buffered I/O for stuffed files

			 * or if we've got a hole (see gfs2_file_direct_write).

 Deallocate blocks that were just allocated. */

/**

 * gfs2_block_map - Map one or more blocks of an inode to a disk block

 * @inode: The inode

 * @lblock: The logical block number

 * @bh_map: The bh to be mapped

 * @create: True if its ok to alloc blocks to satify the request

 *

 * The size of the requested mapping is defined in bh_map->b_size.

 *

 * Clears buffer_mapped(bh_map) and leaves bh_map->b_size unchanged

 * when @lblock is not mapped.  Sets buffer_mapped(bh_map) and

 * bh_map->b_size to indicate the size of the mapping when @lblock and

 * successive blocks are mapped, up to the requested size.

 *

 * Sets buffer_boundary() if a read of metadata will be required

 * before the next block can be mapped. Sets buffer_new() if new

 * blocks were allocated.

 *

 * Returns: errno

/*

 * NOTE: Never call gfs2_block_zero_range with an open transaction because it

 * uses iomap write to perform its actions, which begin their own transactions

 * (iomap_begin, page_prepare, etc.)

/**

 * gfs2_journaled_truncate - Wrapper for truncate_pagecache for jdata files

 * @inode: The inode being truncated

 * @oldsize: The original (larger) size

 * @newsize: The new smaller size

 *

 * With jdata files, we have to journal a revoke for each block which is

 * truncated. As a result, we need to split this into separate transactions

 * if the number of pages being truncated gets too large.

/**

 * sweep_bh_for_rgrps - find an rgrp in a meta buffer and free blocks therein

 * @ip: inode

 * @rd_gh: holder of resource group glock

 * @bh: buffer head to sweep

 * @start: starting point in bh

 * @end: end point in bh

 * @meta: true if bh points to metadata (rather than data)

 * @btotal: place to keep count of total blocks freed

 *

 * We sweep a metadata buffer (provided by the metapath) for blocks we need to

 * free, and free them all. However, we do it one rgrp at a time. If this

 * block has references to multiple rgrps, we break it into individual

 * transactions. This allows other processes to use the rgrps while we're

 * focused on a single one, for better concurrency / performance.

 * At every transaction boundary, we rewrite the inode into the journal.

 * That way the bitmaps are kept consistent with the inode and we can recover

 * if we're interrupted by power-outages.

 *

 * Returns: 0, or return code if an error occurred.

 *          *btotal has the total number of blocks freed

 needs to be s64 or gfs2_add_inode_blocks breaks */

 buffer was added to transaction */

 Must be done with the rgrp glock held: */

		/* The size of our transactions will be unknown until we

		   actually process all the metadata blocks that relate to

		   the rgrp. So we estimate. We know it can't be more than

		   the dinode's i_blocks and we don't want to exceed the

 check if we will exceed the transaction blocks requested */

			/* We set blks_outside_rgrp to ensure the loop will

			   be repeated for the same rgrp, but with a new

			/* This next part is tricky. If the buffer was added

			   to the transaction, we've already set some block

			   pointers to 0, so we better follow through and free

			   them, or we will introduce corruption (so break).

			   This may be impossible, or at least rare, but I

			   decided to cover the case regardless.



			   If the buffer was not added to the transaction

			   (this call), doing so would exceed our transaction

			   size, so we need to end the transaction and start a

	if (!ret && blks_outside_rgrp) { /* If buffer still has non-zero blocks

					    outside the rgrp we just processed,

			/* Every transaction boundary, we rewrite the dinode

/**

 * find_nonnull_ptr - find a non-null pointer given a metapath and height

 * @sdp: The superblock

 * @mp: starting metapath

 * @h: desired height to search

 * @end_list: See punch_hole().

 * @end_aligned: See punch_hole().

 *

 * Assumes the metapath is valid (with buffers) out to height h.

 * Returns: true if a non-null pointer was found in the metapath buffer

 *          false if all remaining pointers are NULL in the buffer

 if we have a non-null pointer */

 Strip a metapath with all buffers read in */

 lower the metapath strip height */

 Fill in the metapath to the given height. */

 process complete */

/**

 * punch_hole - deallocate blocks in a file

 * @ip: inode to truncate

 * @offset: the start of the hole

 * @length: the size of the hole (or 0 for truncate)

 *

 * Punch a hole into a file or truncate a file at a given position.  This

 * function operates in whole blocks (@offset and @length are rounded

 * accordingly); partially filled blocks must be cleared otherwise.

 *

 * This function works from the bottom up, and from the right to the left. In

 * other words, it strips off the highest layer (data) before stripping any of

 * the metadata. Doing it this way is best in case the operation is interrupted

 * by power failure, etc.  The dinode is rewritten in every transaction to

 * guarantee integrity.

 metapath buffers are read in to this height */

		/*

		 * The starting point lies beyond the allocated meta-data;

		 * there are no blocks do deallocate.

	/*

	 * The start position of the hole is defined by lblock, start_list, and

	 * start_aligned.  The end position of the hole is defined by lend,

	 * end_list, and end_aligned.

	 *

	 * start_aligned and end_aligned define down to which height the start

	 * and end positions are aligned to the metadata tree (i.e., the

	 * position is a multiple of the metadata granularity at the height

	 * above).  This determines at which heights additional meta pointers

	 * needs to be preserved for the remaining data.

		/*

		 * Clip the end at the maximum file size for the given height:

		 * that's how far the metadata goes; files bigger than that

		 * will have additional layers of indirection.

 issue read-ahead on metadata */

 We have a complete metapath */

 deal with partial metapath */

		/* Truncate a full metapath at the given strip height.

			/*

			 * Below, passing end_aligned as 0 gives us the

			 * metapointer range excluding the end point: the end

			 * point is the first metapath we must not deallocate!

 end_aligned */,

			/* If we hit an error or just swept dinode buffer,

 lower the metapath strip height */

			/* We're done with the current buffer, so release it,

			   unless it's the dinode buffer. Then back up to the

			/* If we can't get any lower in height, we've stripped

			   off all we can. Next step is to back up and start

 search one metadata height down */

			/* Here we've found a part of the metapath that is not

			 * allocated. We need to search at that height for the

			/* No more non-null pointers at this height. Back up

 loop around in the same state */

 Fill the metapath with buffers to the given height. */

 Fill the buffers out to the current height. */

 On the first pass, issue read-ahead on metadata. */

 No read-ahead for data blocks. */

 If buffers found for the entire strip height */

 We have a partial height */

			/* If we find a non-null block pointer, crawl a bit

			   higher up in the metapath and try again, otherwise

/**

 * do_shrink - make a file smaller

 * @inode: the inode

 * @newsize: the size to make the file

 *

 * Called with an exclusive lock on @inode. The @size must

 * be equal to or smaller than the current inode size.

 *

 * Returns: errno

/**

 * do_grow - Touch and update inode size

 * @inode: The inode

 * @size: The new size

 *

 * This function updates the timestamps on the inode and

 * may also increase the size of the inode. This function

 * must not be called with @size any smaller than the current

 * inode size.

 *

 * Although it is not strictly required to unstuff files here,

 * earlier versions of GFS2 have a bug in the stuffed file reading

 * code which will result in a buffer overrun if the size is larger

 * than the max stuffed file size. In order to prevent this from

 * occurring, such files are unstuffed, but in other cases we can

 * just update the inode size directly.

 *

 * Returns: 0 on success, or -ve on error

/**

 * gfs2_setattr_size - make a file a given size

 * @inode: the inode

 * @newsize: the size to make the file

 *

 * The file size can grow, shrink, or stay the same size. This

 * is called holding i_rwsem and an exclusive glock on the inode

 * in question.

 *

 * Returns: errno

/**

 * gfs2_free_journal_extents - Free cached journal bmap info

 * @jd: The journal

 *

/**

 * gfs2_add_jextent - Add or merge a new extent to extent cache

 * @jd: The journal descriptor

 * @lblock: The logical block at start of new extent

 * @dblock: The physical block at start of new extent

 * @blocks: Size of extent in fs blocks

 *

 * Returns: 0 on success or -ENOMEM

/**

 * gfs2_map_journal_extents - Cache journal bmap info

 * @sdp: The super block

 * @jd: The journal to map

 *

 * Create a reusable "extent" mapping from all logical

 * blocks to all physical blocks for the given journal.  This will save

 * us time when writing journal blocks.  Most journals will have only one

 * extent that maps all their logical blocks.  That's because gfs2.mkfs

 * arranges the journal blocks sequentially to maximize performance.

 * So the extent would map the first block for the entire file length.

 * However, gfs2_jadd can happen while file activity is happening, so

 * those journals may not be sequential.  Less likely is the case where

 * the users created their own journals by mounting the metafs and

 * laying it out.  But it's still possible.  These journals might have

 * several extents.

 *

 * Returns: 0 on success, or error on failure

/**

 * gfs2_write_alloc_required - figure out if a write will require an allocation

 * @ip: the file being written to

 * @offset: the offset to write to

 * @len: the number of bytes being written

 *

 * Returns: 1 if an alloc is required, 0 otherwise

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) Sistina Software, Inc.  1997-2003 All rights reserved.

 * Copyright (C) 2004-2008 Red Hat, Inc.  All rights reserved.

/**

 * gfs2_get_block_noalloc - Fills in a buffer head with details about a block

 * @inode: The inode

 * @lblock: The block number to look up

 * @bh_result: The buffer head to return the result in

 * @create: Non-zero if we may add block to the file

 *

 * Returns: errno

/**

 * gfs2_writepage - Write page for writeback mappings

 * @page: The page

 * @wbc: The writeback control

/**

 * gfs2_write_jdata_page - gfs2 jdata-specific version of block_write_full_page

 * @page: The page to write

 * @wbc: The writeback control

 *

 * This is the same as calling block_write_full_page, but it also

 * writes pages outside of i_size

	/*

	 * The page straddles i_size.  It must be zeroed out on each and every

	 * writepage invocation because it may be mmapped.  "A file is mapped

	 * in multiples of the page size.  For a file that is not a multiple of

	 * the  page size, the remaining memory is zeroed when mapped, and

	 * writes to that region are not written out to the file."

/**

 * __gfs2_jdata_writepage - The core of jdata writepage

 * @page: The page to write

 * @wbc: The writeback control

 *

 * This is shared between writepage and writepages and implements the

 * core of the writepage operation. If a transaction is required then

 * PageChecked will have been set and the transaction will have

 * already been started before this is called.

/**

 * gfs2_jdata_writepage - Write complete page

 * @page: Page to write

 * @wbc: The writeback control

 *

 * Returns: errno

 *

/**

 * gfs2_writepages - Write a bunch of dirty pages back to disk

 * @mapping: The mapping to write

 * @wbc: Write-back control

 *

 * Used for both ordered and writeback modes.

	/*

	 * Even if we didn't write any pages here, we might still be holding

	 * dirty pages in the ail. We forcibly flush the ail because we don't

	 * want balance_dirty_pages() to loop indefinitely trying to write out

	 * pages held in the ail that it can't find.

/**

 * gfs2_write_jdata_pagevec - Write back a pagevec's worth of pages

 * @mapping: The mapping

 * @wbc: The writeback control

 * @pvec: The vector of pages

 * @nr_pages: The number of pages to write

 * @done_index: Page index

 *

 * Returns: non-zero if loop should terminate, zero otherwise

 someone wrote it for us */

				/*

				 * done_index is set past this page,

				 * so media errors will not choke

				 * background writeout for the entire

				 * file. This has consequences for

				 * range_cyclic semantics (ie. it may

				 * not be suitable for data integrity

				 * writeout).

		/*

		 * We stop writing back only if we are not doing

		 * integrity sync. In case of integrity sync we have to

		 * keep going until we have written all the pages

		 * we tagged for writeback prior to entering this loop.

/**

 * gfs2_write_cache_jdata - Like write_cache_pages but different

 * @mapping: The mapping to write

 * @wbc: The writeback control

 *

 * The reason that we use our own function here is that we need to

 * start transactions before we grab page locks. This allows us

 * to get the ordering right.

 prev offset */

 ignore range_cyclic tests */

		/*

		 * range_cyclic:

		 * We hit the last page and there is more work to be done: wrap

		 * back to the start of the file

/**

 * gfs2_jdata_writepages - Write a bunch of dirty pages back to disk

 * @mapping: The mapping to write

 * @wbc: The writeback control

 * 

/**

 * stuffed_readpage - Fill in a Linux page with stuffed file data

 * @ip: the inode

 * @page: the page

 *

 * Returns: errno

	/*

	 * Due to the order of unstuffing files and ->fault(), we can be

	 * asked for a zero page in the case of a stuffed file being extended,

	 * so we need to supply one here. It doesn't happen often.

/**

 * gfs2_readpage - read a page of a file

 * @file: The file to read

 * @page: The page of the file

/**

 * gfs2_internal_read - read an internal file

 * @ip: The gfs2 inode

 * @buf: The buffer to fill

 * @pos: The file position

 * @size: The amount to read

 *

/**

 * gfs2_readahead - Read a bunch of pages at once

 * @rac: Read-ahead control structure

 *

 * Some notes:

 * 1. This is only for readahead, so we can simply ignore any things

 *    which are slightly inconvenient (such as locking conflicts between

 *    the page lock and the glock) and return having done no I/O. Its

 *    obviously not something we'd want to do on too regular a basis.

 *    Any I/O we ignore at this time will be done via readpage later.

 * 2. We don't handle stuffed files here we let readpage do the honours.

 * 3. mpage_readahead() does most of the heavy lifting in the common case.

 * 4. gfs2_block_map() is relied upon to set BH_Boundary in the right places.

/**

 * adjust_fs_space - Adjusts the free space available due to gfs2_grow

 * @inode: the rindex inode

 Total up the file system space, according to the latest rindex. */

/**

 * jdata_set_page_dirty - Page dirtying function

 * @page: The page to dirty

 *

 * Returns: 1 if it dirtyed the page, or 0 otherwise

/**

 * gfs2_bmap - Block map function

 * @mapping: Address space info

 * @lblock: The block to map

 *

 * Returns: The disk address for the block or 0 on hole or error

/**

 * gfs2_releasepage - free the metadata associated with a page

 * @page: the page that's being released

 * @gfp_mask: passed from Linux VFS, ignored by us

 *

 * Calls try_to_free_buffers() to free the buffers and put the page if the

 * buffers can be released.

 *

 * Returns: 1 if the page was put or else 0

	/*

	 * From xfs_vm_releasepage: mm accommodates an old ext3 case where

	 * clean pages might not have had the dirty bit cleared.  Thus, it can

	 * send actual dirty pages to ->releasepage() via shrink_active_list().

	 *

	 * As a workaround, we skip pages that contain dirty buffers below.

	 * Once ->releasepage isn't called on dirty pages anymore, we can warn

	 * on dirty buffers like we used to here again.

			/*

			 * The bd may still be queued as a revoke, in which

			 * case we must not dequeue nor free it.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) Sistina Software, Inc.  1997-2003 All rights reserved.

 * Copyright (C) 2004-2007 Red Hat, Inc.  All rights reserved.

/**

 * gfs2_struct2blk - compute stuff

 * @sdp: the filesystem

 * @nstruct: the number of structures

 *

 * Compute the number of log descriptor blocks needed to hold a certain number

 * of structures of a certain size.

 *

 * Returns: the number of blocks needed (minimum is always 1)

 The initial struct gfs2_log_descriptor block */

 Subsequent struct gfs2_meta_header blocks */

/**

 * gfs2_remove_from_ail - Remove an entry from the ail lists, updating counters

 * @bd: The gfs2_bufdata to remove

 *

 * The ail lock _must_ be held when calling this function

 *

/**

 * gfs2_ail1_start_one - Start I/O on a transaction

 * @sdp: The superblock

 * @wbc: The writeback control structure

 * @tr: The transaction to start I/O on

 * @plug: The block plug currently active

 if a jdata write into a new hole */

 ignore it */

/**

 * gfs2_ail1_flush - start writeback of some ail1 entries 

 * @sdp: The super block

 * @wbc: The writeback control structure

 *

 * Writes back some ail1 entries, according to the limits in the

 * writeback control structure

/**

 * gfs2_ail1_start - start writeback of all ail1 entries

 * @sdp: The superblock

/*

 * gfs2_ail_empty_tr - empty one of the ail lists of a transaction

/**

 * gfs2_ail1_empty_one - Check whether or not a trans in the AIL has been synced

 * @sdp: the filesystem

 * @tr: the transaction

 * @max_revokes: If nonzero, issue revokes for the bd items for written buffers

 *

 * returns: the transaction's count of remaining active items

		/*

		 * If another process flagged an io error, e.g. writing to the

		 * journal, error all other bhs and move them off the ail1 to

		 * prevent a tight loop when unmount tries to flush ail1,

		 * regardless of whether they're still busy. If no outside

		 * errors were found and the buffer is busy, move to the next.

		 * If the ail buffer is not busy and caught an error, flag it

		 * for others.

		/*

		 * If we have space for revokes and the bd is no longer on any

		 * buf list, we can just add a revoke for it immediately and

		 * avoid having to put it on the ail2 list, where it would need

		 * to be revoked later.

/**

 * gfs2_ail1_empty - Try to empty the ail1 lists

 * @sdp: The superblock

 * @max_revokes: If non-zero, add revokes where appropriate

 *

 * Tries to empty the ail1 lists, starting with the oldest first

/**

 * gfs2_log_is_empty - Check if the log is empty

 * @sdp: The GFS2 superblock

/**

 * gfs2_log_release_revokes - Release a given number of revokes

 * @sdp: The GFS2 superblock

 * @revokes: The number of revokes to release

 *

 * sdp->sd_log_flush_lock must be held.

/**

 * gfs2_log_release - Release a given number of log blocks

 * @sdp: The GFS2 superblock

 * @blks: The number of blocks

 *

/**

 * __gfs2_log_try_reserve - Try to make a log reservation

 * @sdp: The GFS2 superblock

 * @blks: The number of blocks to reserve

 * @taboo_blks: The number of blocks to leave free

 *

 * Try to do the same as __gfs2_log_reserve(), but fail if no more log

 * space is immediately available.

/**

 * __gfs2_log_reserve - Make a log reservation

 * @sdp: The GFS2 superblock

 * @blks: The number of blocks to reserve

 * @taboo_blks: The number of blocks to leave free

 *

 * @taboo_blks is set to 0 for logd, and to GFS2_LOG_FLUSH_MIN_BLOCKS

 * for all other processes.  This ensures that when the log is almost full,

 * logd will still be able to call gfs2_log_flush one more time  without

 * blocking, which will advance the tail and make some more log space

 * available.

 *

 * We no longer flush the log here, instead we wake up logd to do that

 * for us. To avoid the thundering herd and to ensure that we deal fairly

 * with queued waiters, we use an exclusive wait. This means that when we

 * get woken with enough journal space to get our reservation, we need to

 * wake the next waiter on the list.

/**

 * gfs2_log_try_reserve - Try to make a log reservation

 * @sdp: The GFS2 superblock

 * @tr: The transaction

 * @extra_revokes: The number of additional revokes reserved (output)

 *

 * This is similar to gfs2_log_reserve, but sdp->sd_log_flush_lock must be

 * held for correct revoke accounting.

/**

 * gfs2_log_reserve - Make a log reservation

 * @sdp: The GFS2 superblock

 * @tr: The transaction

 * @extra_revokes: The number of additional revokes reserved (output)

 *

 * sdp->sd_log_flush_lock must not be held.

/**

 * log_distance - Compute distance between two journal blocks

 * @sdp: The GFS2 superblock

 * @newer: The most recent journal block of the pair

 * @older: The older journal block of the pair

 *

 *   Compute the distance (in the journal direction) between two

 *   blocks in the journal

 *

 * Returns: the distance in blocks

/**

 * calc_reserved - Calculate the number of blocks to keep reserved

 * @sdp: The GFS2 superblock

 *

 * This is complex.  We need to reserve room for all our currently used

 * metadata blocks (e.g. normal file I/O rewriting file time stamps) and

 * all our journaled data blocks for journaled files (e.g. files in the

 * meta_fs like rindex, or files for which chattr +j was done.)

 * If we don't reserve enough space, corruption will follow.

 *

 * We can have metadata blocks and jdata blocks in the same journal.  Each

 * type gets its own log descriptor, for which we need to reserve a block.

 * In fact, each type has the potential for needing more than one log descriptor

 * in cases where we have more blocks than will fit in a log descriptor.

 * Metadata journal entries take up half the space of journaled buffer entries.

 *

 * Also, we need to reserve blocks for revoke journal entries and one for an

 * overall header for the lot.

 *

 * Returns: the number of blocks reserved

 drops ref on bh */

/**

 * gfs2_flush_revokes - Add as many revokes to the system transaction as we can

 * @sdp: The GFS2 superblock

 *

 * Our usual strategy is to defer writing revokes as much as we can in the hope

 * that we'll eventually overwrite the journal, which will make those revokes

 * go away.  This changes when we flush the log: at that point, there will

 * likely be some left-over space in the last revoke block of that transaction.

 * We can fill that space with additional revokes for blocks that have already

 * been written back.  This will basically come at no cost now, and will save

 * us from having to keep track of those blocks on the AIL2 list later.

 number of revokes we still have room for */

/**

 * gfs2_write_log_header - Write a journal log header buffer at lblock

 * @sdp: The GFS2 superblock

 * @jd: journal descriptor of the journal to which we are writing

 * @seq: sequence number

 * @tail: tail of the log

 * @lblock: value for lh_blkno (block number relative to start of journal)

 * @flags: log header flags GFS2_LOG_HEAD_*

 * @op_flags: flags to pass to the bio

 *

 * Returns: the initialized log buffer descriptor

	/* We may only write local statfs, quota, etc., when writing to our

	   own journal. The values are left 0 when recovering a journal

/**

 * log_write_header - Get and initialize a journal header buffer

 * @sdp: The GFS2 superblock

 * @flags: The log header flags, including log header origin

 *

 * Returns: the initialized log buffer descriptor

/**

 * gfs2_ail_drain - drain the ail lists after a withdraw

 * @sdp: Pointer to GFS2 superblock

	/*

	 * For transactions on the sd_ail1_list we need to drain both the

	 * ail1 and ail2 lists. That's because function gfs2_ail1_start_one

	 * (temporarily) moves items from its tr_ail1 list to tr_ail2 list

	 * before revokes are sent for that block. Items on the sd_ail2_list

	 * should have already gotten beyond that point, so no need.

/**

 * empty_ail1_list - try to start IO and empty the ail1 list

 * @sdp: Pointer to GFS2 superblock

/**

 * trans_drain - drain the buf and databuf queue for a failed transaction

 * @tr: the transaction to drain

 *

 * When this is called, we're taking an error exit for a log write that failed

 * but since we bypassed the after_commit functions, we need to remove the

 * items from the buf and databuf queue.

/**

 * gfs2_log_flush - flush incore transaction(s)

 * @sdp: The filesystem

 * @gl: The glock structure to flush.  If NULL, flush the whole incore log

 * @flags: The log header flags: GFS2_LOG_HEAD_FLUSH_* and debug flags

 *

	/*

	 * Do this check while holding the log_flush_lock to prevent new

	 * buffers from being added to the ail via gfs2_pin()

 Log might have been flushed while we waited for the flush lock */

	/**

	 * If the tr_list is empty, we're withdrawing during a log

	 * flush that targets a transaction, but the transaction was

	 * never queued onto any of the ail lists. Here we add it to

	 * ail1 just so that ail_drain() will find and free it.

/**

 * gfs2_merge_trans - Merge a new transaction into a cached transaction

 * @sdp: the filesystem

 * @new: New transaction to be merged

/**

 * gfs2_log_commit - Commit a transaction to the log

 * @sdp: the filesystem

 * @tr: the transaction

 *

 * We wake up gfs2_logd if the number of pinned blocks exceed thresh1

 * or the total number of used blocks (pinned blocks plus AIL blocks)

 * is greater than thresh2.

 *

 * At mount time thresh1 is 2/5ths of journal size, thresh2 is 4/5ths of

 * journal size.

 *

 * Returns: errno

/**

 * gfs2_log_shutdown - write a shutdown header into a journal

 * @sdp: the filesystem

 *

/**

 * gfs2_logd - Update log tail as Active Items get flushed to in-place blocks

 * @data: Pointer to GFS2 superblock

 *

 * Also, periodically check to make sure that we're using the most recent

 * journal index.

 Check for errors writing to the journal */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) Sistina Software, Inc.  1997-2003 All rights reserved.

 * Copyright (C) 2004-2006 Red Hat, Inc.  All rights reserved.

/**

 * init_gfs2_fs - Register GFS2 as a filesystem

 *

 * Returns: 0 on success, error code on failure

/**

 * exit_gfs2_fs - Unregister the file system

 *

 SPDX-License-Identifier: GPL-2.0

/*

 *

 * Copyright (C) 2019-2021 Paragon Software GmbH, All rights reserved.

 *

/*

 * fill_name_de - Format NTFS_DE in @buf.

 Convert input string to unicode. */

/*

 * ntfs_lookup - inode_operations::lookup

/*

 * ntfs_create - inode_operations::create

/*

 * ntfs_mknod

 *

 * inode_operations::mknod

/*

 * ntfs_link - inode_operations::link

/*

 * ntfs_unlink - inode_operations::unlink

/*

 * ntfs_symlink - inode_operations::symlink

/*

 * ntfs_mkdir- inode_operations::mkdir

/*

 * ntfs_rmdir - inode_operations::rm_dir

/*

 * ntfs_rename - inode_operations::rename

	/*

	 * de		- memory of PATH_MAX bytes:

	 * [0-1024)	- original name (dentry->d_name)

	 * [1024-2048)	- paired to original name, usually DOS variant of dentry->d_name

	 * [2048-3072)	- new name (new_dentry->d_name)

 Nothing to do. */

 Should we print an error? */

 Target name exists. Unlink it. */

 Allocate PATH_MAX bytes. */

 Translate dentry->d_name into unicode form. */

 Reuse 'de'. */

 Translate new_dentry->d_name into unicode form. */

 Restore after failed rename failed too. */

 clang-format off

 clang-format on

 SPDX-License-Identifier: GPL-2.0

/*

 *

 * Copyright (C) 2019-2021 Paragon Software GmbH, All rights reserved.

 *

/*

 * cmp_fnames - Compare two names in index.

 *

 * if l1 != 0

 *   Both names are little endian on-disk ATTR_FILE_NAME structs.

 * else

 *   key1 - cpu_str, key2 - ATTR_FILE_NAME

&& !sbi->options.nocase*/;

		/*

		 * If names are equal (case insensitive)

		 * try to compare it case sensitive.

/*

 * cmp_uint - $SII of $Secure and $Q of Quota

/*

 * cmp_sdh - $SDH of $Secure

 First value is a hash value itself. */

 Second value is security Id. */

/*

 * cmp_uints - $O of ObjId and "$R" for Reparse.

		/*

		 * ni_delete_all -> ntfs_remove_reparse ->

		 * delete all with this reference.

		 * k1, k2 - pointers to REPARSE_KEY

 Skip REPARSE_KEY.ReparseTag

 Skip REPARSE_KEY.ReparseTag

 Looks like filesystem error. */

/*

 * indx_mark_used - Mark the bit @bit as used.

/*

 * indx_mark_free - Mark the bit @bit as free.

/*

 * scan_nres_bitmap

 *

 * If ntfs_readdir calls this function (indx_used_bit -> scan_nres_bitmap),

 * inode is shared locked and no ni_lock.

 * Use rw_semaphore for read/write access to bitmap_run.

/*

 * indx_find_free - Look for free bit.

 *

 * Return: -1 if no free bits.

/*

 * indx_used_bit - Look for used bit.

 *

 * Return: MINUS_ONE_T if no used bits.

/*

 * hdr_find_split

 *

 * Find a point at which the index allocation buffer would like to be split.

 * NOTE: This function should never return 'END' entry NULL returns on error.

 We must not return END entry. */

/*

 * hdr_insert_head - Insert some entries at the beginning of the buffer.

 *

 * It is used to insert entries into a newly-created buffer.

 Now we just make room for the inserted entries and jam it in. */

/*

 * hdr_find_e - Locate an entry the index buffer.

 *

 * If no matching entry is found, it returns the first entry which is greater

 * than the desired entry If the search key is greater than all the entries the

 * buffer, it returns the 'end' entry. This function does a binary search of the

 * current index buffer, for the first entry that is <= to the search value.

 *

 * Return: NULL if error.

/*

 * hdr_insert_de - Insert an index entry into the buffer.

 *

 * 'before' should be a pointer previously returned from hdr_find_e.

 First, check to see if there's enough room. */

 We know there's enough space, so we know we'll succeed. */

 Check that before is inside Index. */

 No insert point is applied. Get it manually. */

 Now we just make room for the entry and jam it in. */

/*

 * hdr_delete_de - Remove an entry from the index buffer.

 Check root fields. */

 Check index record size. */

 Index record is smaller than a cluster, use 512 blocks. */

 Check alignment to a cluster. */

 Index record must be a multiple of cluster size. */

 Create header. */

 0x28

 9

/*

 * indx_read

 *

 * If ntfs_readdir calls this function

 * inode is shared locked and no ni_lock.

 * Use rw_semaphore for read/write access to alloc_run.

/*

 * indx_find - Scan NTFS directory for given entry.

 Check cache. */

 Soft finder reset. */

 Lookup entry that is <= to the search value. */

 Read next level. */

 Lookup entry that is <= to the search value. */

 Start find. */

 Just to avoid tree cycle. */

 Read next level. */

 Try next level. */

 Pop one level. */

 Use non sorted algorithm. */

 This is the first call. */

 The first call with setup of initial element. */

 Jump inside cycle 'for'. */

 Start enumeration from root. */

 Check if current entry can be used. */

 Continue to enumerate root. */

 Start to enumerate indexes from 0. */

 Continue to enumerate indexes. */

 Continue with next index. */

 Release current index. */

 Skip all free indexes. */

 No used indexes. */

 Read buffer into memory. */

 Return offset to restore enumerator if necessary. */

 'e' points in root, */

 'e' points in index, */

/*

 * indx_create_allocate - Create "Allocation + Bitmap" attributes.

/*

 * indx_add_allocate - Add clusters to index.

 Increase bitmap. */

 Increase allocation. */

 Ops. No space? */

/*

 * indx_insert_into_root - Attempt to insert an entry into the index root.

 *

 * @undo - True if we undoing previous remove.

 * If necessary, it will twiddle the index b-tree.

 Get the record this root placed in. */

	/*

	 * Try easy case:

	 * hdr_insert_de will succeed if there's

	 * room the root for the new entry.

 If 'undo' is set then reduce requirements. */

 Make a copy of root attribute to restore if error. */

	/*

	 * Copy all the non-end entries from

	 * the index root to the new buffer.

 Calculate the size to copy. */

 Make root external. */

 Fill first entry (vcn will be set later). */

 Create alloc and bitmap attributes (if not). */

 Layout of record may be changed, so rescan root. */

 Bug? */

 Restore root. */

 Bug? */

 Now we can create/format the new buffer and copy the entries into. */

 Copy root entries into new buffer. */

 Update bitmap attribute. */

 Check if we can insert new entry new index buffer. */

		/*

		 * This occurs if MFT record is the same or bigger than index

		 * buffer. Move all root new index and have no space to add

		 * new entry classic case when MFT record is 1K and index

		 * buffer 4K the problem should not occurs.

	/*

	 * Now root is a parent for new index buffer.

	 * Insert NewEntry a new buffer.

 Just write updates index into disk. */

/*

 * indx_insert_into_buffer

 *

 * Attempt to insert an entry into an Index Allocation Buffer.

 * If necessary, it will split the buffer.

 Try the most easy case. */

 Just write updated index into disk. */

	/*

	 * No space to insert into buffer. Split it.

	 * To split we:

	 *  - Save split point ('cause index buffers will be changed)

	 * - Allocate NewBuffer and copy all entries <= sp into new buffer

	 * - Remove all entries (sp including) from TargetBuffer

	 * - Insert NewEntry into left or right buffer (depending on sp <=>

	 *     NewEntry)

	 * - Insert sp into parent buffer (or root)

	 * - Make sp a parent for new buffer

 Allocate on disk a new index allocation buffer. */

 Allocate and format memory a new index buffer. */

 Make sp a parent for new buffer. */

 Copy all the entries <= sp into the new buffer. */

 Remove all entries (sp including) from hdr1. */

	/*

	 * Insert new entry into left or right buffer

	 * (depending on sp <=> new_de).

	/*

	 * We've finished splitting everybody, so we are ready to

	 * insert the promoted entry into the parent.

 Insert in root. */

		/*

		 * The target buffer's parent is another index buffer.

		 * TODO: Remove recursion.

/*

 * indx_insert_entry - Insert new entry into index.

 *

 * @undo - True if we undoing previous remove.

		/*

		 * Find the spot the tree where we want to

		 * insert the new entry.

		/*

		 * The root is also a leaf, so we'll insert the

		 * new entry into it.

		/*

		 * Found a leaf buffer, so we'll insert the new entry into it.

/*

 * indx_find_buffer - Locate a buffer from the tree.

 Step 1: Scan one level. */

 Step2: Do recursion. */

/*

 * indx_shrink - Deallocate unused tail indexes.

 First, recurse into the children, if any. */

	/*

	 * We've gotten rid of the children; add this buffer to the free list.

	/*

	 * If there are no used indexes after current free index

	 * then we can truncate allocation and bitmap.

	 * Use bitmap to estimate the case.

/*

 * indx_get_entry_to_replace

 *

 * Find a replacement entry for a deleted entry.

 * Always returns a node entry:

 * NTFS_IE_HAS_SUBNODES is set the flags and the size includes the sub_vcn.

 Find first leaf entry down from de_next. */

			/*

			 * This buffer is non-empty, so its first entry

			 * could be used as the replacement entry.

 This buffer is a node. Continue to go down. */

 Copy the candidate entry into the replacement entry buffer. */

		/*

		 * The replacement entry we found doesn't have a sub_vcn.

		 * increase its size to hold one.

		/*

		 * The replacement entry we found was a node entry, which

		 * means that all its child buffers are empty. Return them

		 * to the free pool.

	/*

	 * Expunge the replacement entry from its former location,

	 * and then write that buffer.

 Check to see if this action created an empty leaf. */

/*

 * indx_delete_entry - Delete an entry from the index.

 Locate the entry to remove. */

 The entry to delete is a leaf, so we can just rip it out. */

 Shrink resident root attribute. */

		/*

		 * Check to see if removing that entry made

		 * the leaf empty.

		/*

		 * The entry we wish to delete is a node buffer, so we

		 * have to find a replacement for it.

			/*

			 * There is no replacement for the current entry.

			 * This means that the subtree rooted at its node

			 * is empty, and can be deleted, which turn means

			 * that the node can just inherit the deleted

			 * entry sub_vcn.

 Shrink resident root attribute. */

 Delete a branch of tree. */

 Reinit root 'cause it can be changed. */

 Scan current level. */

 Do slow search from root. */

 Merge fnd2 -> fnd. */

			/*

			 * Didn't find the parent entry, although this buffer

			 * is the parent trail. Something is corrupt.

			/*

			 * Since we can't remove the end entry, we'll remove

			 * its predecessor instead. This means we have to

			 * transfer the predecessor's sub_vcn to the end entry.

			 * Note: This index block is not empty, so the

			 * predecessor must exist.

		/*

		 * Copy the current entry into a temporary buffer (stripping

		 * off its down-pointer, if any) and delete it from the current

		 * buffer or root, as appropriate.

 Shrink resident root attribute. */

 Mark unused buffers as free. */

fnd->root_de = NULL;*/

		/*

		 * Re-insert the entry into the tree.

		 * Find the spot the tree where we want to insert the new entry.

		/*

		 * This tree needs to be collapsed down to an empty root.

		 * Recreate the index root as an empty leaf and free all

		 * the bits the index allocation bitmap.

 Fill first entry. */

 0x02

/*

 * Update duplicated information in directory entry

 * 'dup' - info from MFT record

 Find entry in directory. */

		/*

		 * Nothing to update in index! Try to avoid this call.

 Directory entry in index. */

 Directory entry in directory MFT record. */

 SPDX-License-Identifier: GPL-2.0

/*

 *

 * Copyright (C) 2019-2021 Paragon Software GmbH, All rights reserved.

 *

/*

 * fill_mask[i] - first i bits are '1' , i = 0,1,2,3,4,5,6,7,8

 * fill_mask[i] = 0xFF >> (8-i)

/*

 * zero_mask[i] - first i bits are '0' , i = 0,1,2,3,4,5,6,7,8

 * zero_mask[i] = 0xFF << i

/*

 * are_bits_clear

 *

 * Return: True if all bits [bit, bit+nbits) are zeros "0".

/*

 * are_bits_set

 *

 * Return: True if all bits [bit, bit+nbits) are ones "1".

 SPDX-License-Identifier: GPL-2.0

/*

 *

 * Copyright (C) 2019-2021 Paragon Software GmbH, All rights reserved.

 *

 clang-format off

 Src buffer is zero. */

 clang-format on

 Compare two matches and select the best one. */

/*

 * compress_chunk

 *

 * Return:

 * * 0	- Ok, @cmpr contains @cmpr_chunk_size bytes of compressed data.

 * * 1	- Input buffer is full zero.

 * * -2 - The compressed buffer is too small to hold the compressed data.

 Control byte of 8-bit values: ( 0 - means byte as is, 1 - short pair ). */

 Find match. */

	/*

	 * Copy non cmpr data.

	 * 0x3FFF == ((LZNT_CHUNK_SIZE + 2 - 3) | 0x3000)

 Do decompression until pointers are inside range. */

 Correct index */

 Check the current flag for zero. */

 Just copy byte. */

 Check for boundary. */

 Read a short from little endian stream. */

 Translate packed information into offset and length. */

 Check offset for boundary. */

 Truncate the length if necessary. */

 Now we copy bytes. This is the heart of LZ algorithm. */

 Advance flag bit value. */

 Return the size of uncompressed data. */

/*

 * get_lznt_ctx

 * @level: 0 - Standard compression.

 *	   !0 - Best compression, requires a lot of cpu.

/*

 * compress_lznt - Compresses @unc into @cmpr

 *

 * Return:

 * * +x - Ok, @cmpr contains 'final_compressed_size' bytes of compressed data.

 * * 0 - Input buffer is full zero.

 Compression cycle. */

/*

 * decompress_lznt - Decompress @cmpr into @unc.

 Read chunk header. */

 Loop through decompressing chunks. */

 Check that the chunk actually fits the supplied buffer. */

 First make sure the chunk contains compressed data. */

 Decompress a chunk and return if we get an error. */

 This chunk does not contain compressed data. */

 Advance pointers. */

 Check for the end of unc buffer. */

 Proceed the next chunk. */

 Read chunk header. */

 Check the size of unc buffer. */

 'Zero' memory. */

 Check compression boundary. */

	/*

	 * The unc size is just a difference between current

	 * pointer and original one.

 SPDX-License-Identifier: GPL-2.0

/*

 *

 * Copyright (C) 2019-2021 Paragon Software GmbH, All rights reserved.

 *

/*

 * ni_find_mi - Find mft_inode by record number.

/*

 * ni_add_mi - Add new mft_inode into ntfs_inode.

/*

 * ni_remove_mi - Remove mft_inode from ntfs_inode.

/*

 * ni_std - Return: Pointer into std_info from primary record.

/*

 * ni_std5

 *

 * Return: Pointer into std_info from primary record.

/*

 * ni_clear - Clear resources allocated by ntfs_inode.

 Bad inode always has mode == S_IFREG. */

 On-demand allocated page for offsets. */

/*

 * ni_load_mi_ex - Find mft_inode by record number.

/*

 * ni_load_mi - Load mft_inode corresponded list_entry.

/*

 * ni_find_attr

 *

 * Return: Attribute and record this attribute belongs to.

 Look for required attribute in primary record. */

 First look for list entry of required type. */

 Load record that contains this attribute. */

 Look for required attribute. */

/*

 * ni_enum_attr_ex - Enumerates attributes in ntfs_inode.

 Do we have an attribute list? */

 Enum attributes in primary record. */

 Get next list entry. */

 Load record that contains the required attribute. */

 Find attribute in loaded record. */

/*

 * ni_load_attr - Load attribute that contains given VCN.

	/*

	 * Unfortunately ATTR_LIST_ENTRY contains only start VCN.

	 * So to find the ATTRIB segment that contains 'vcn' we should

	 * enumerate some entries.

/*

 * ni_load_all_mi - Load all subrecords.

/*

 * ni_add_subrecord - Allocate + format + attach a new subrecord.

/*

 * ni_remove_attr - Remove all attributes for the given type/name/id.

/*

 * ni_ins_new_attr - Insert the attribute into record.

 *

 * Return: Not full constructed attribute or NULL if not possible to create.

 No memory or no space. */

		/*

		 * al_add_le -> attr_set_size (list) -> ni_expand_list

		 * which moves some attributes out of primary record

		 * this means that name may point into moved memory

		 * reinit 'name' from le.

 Attr list is not in list entry array. */

 Update ATTRIB Id and record reference. */

/*

 * ni_repack

 *

 * Random write access to sparsed or compressed file may result to

 * not optimized packed runs.

 * Here is the place to optimize it.

 Do not try if not enogh free space. */

 Do not try if last attribute segment. */

		/*

		 * Run contains data from two records: mi_p and mi

		 * Try to pack in one.

 We can remove this attribute segment. */

 Pack loaded but not packed runs. */

/*

 * ni_try_remove_attr_list

 *

 * Can we remove attribute list?

 * Check the case when primary record contains enough space for all attributes.

 Free space in primary record without attribute list. */

 It seems that attribute list can be removed from primary record. */

	/*

	 * Repeat the cycle above and move all attributes to primary record.

	 * It should be success!

 Should never happened, 'cause already checked. */

 Should never happened, 'cause already checked. */

 Insert into primary record. */

			/*

			 * Internal error.

			 * Either no space in primary record (already checked).

			 * Either tried to insert another

			 * non indexed attribute (logic error).

 Copy all except id. */

 Remove from original record. */

/*

 * ni_create_attr_list - Generates an attribute list for this primary record.

	/*

	 * Skip estimating exact memory requirement.

	 * Looks like one record_size is always enough.

 Allocate child MFT. */

 Call mi_remove_attr() in reverse order to keep pointers 'arr_move' valid. */

 Copy all except id. */

 Remove from primary record. */

/*

 * ni_ins_attr_ext - Add an external attribute to the ntfs_inode.

	/*

	 * Standard information and attr_list cannot be made external.

	 * The Log File cannot have any external attributes.

 Create attribute list if it is not already existed. */

 Load all subrecords into memory. */

 Check each of loaded subrecord. */

 We can't accept this record 'cause MFT's bootstrapping. */

			/*

			 * This child record already has a ATTR_DATA.

			 * So it can't accept any other records.

 Only indexed attributes can share same record. */

		/*

		 * Do not try to insert this attribute

		 * if there is no room in record.

 Try to insert attribute into this subrecord. */

 We have to allocate a new child subrecord. */

/*

 * ni_insert_attr - Insert an attribute into the file.

 *

 * If the primary record has room, it will just insert the attribute.

 * If not, it may make the attribute external.

 * For $MFT::Data it may make room for the attribute by

 * making other attributes external.

 *

 * NOTE:

 * The ATTR_LIST and ATTR_STD cannot be made external.

 * This function does not fill new attribute full.

 * It only fills 'size'/'type'/'id'/'name_len' fields.

 Reserve space for the ATTRIB list. */

 This ATTRIB will be external. */

	/*

	 * Here we have: "is_mft && type == ATTR_DATA && !svcn"

	 *

	 * The first chunk of the $MFT::Data ATTRIB must be the base record.

	 * Evict as many other attributes as possible.

 Estimate the result of moving all possible attributes away. */

 Impossible to insert this attribute into primary record. */

 Start real attribute moving. */

 We should never be here 'cause we have already check this case. */

 Skip attributes that MUST be primary record. */

 Really this is a serious bug. */

 Remove from primary record. */

 attr now points to next attribute. */

 ni_expand_mft_list - Split ATTR_DATA of $MFT. */

 Find the nearest MFT. */

 Really this is not critical. */

	/*

	 * Split primary attribute [0 evcn] in two parts [0 svcn) + [svcn evcn].

	 *

	 * Update first part of ATTR_DATA in 'primary MFT.

 'done' - How many bytes of primary MFT becomes free. */

 Estimate the size of second part: run_buf=NULL. */

	/*

	 * This function may implicitly call expand attr_list.

	 * Insert second part of ATTR_DATA in 'mi_min'.

/*

 * ni_expand_list - Move all possible attributes out of primary record.

 Find attribute in primary record. */

 Always insert into new record to avoid collisions (deep recursive). */

 Remove from primary record. */

 Attr list is too big(?) */

 Split MFT data as much as possible. */

/*

 * ni_insert_nonresident - Insert new nonresident attribute.

/*

 * ni_insert_resident - Inserts new resident attribute.

 is_attr_indexed(attr)) == true */

/*

 * ni_remove_attr_le - Remove attribute from record.

/*

 * ni_delete_all - Remove all attributes and frees allocates space.

 *

 * ntfs_evict_inode->ntfs_clear_inode->ni_delete_all (if no links).

 run==1 means unpack and deallocate. */

 Free all subrecords. */

 Free base record. */

/* ni_fname_name

 *

 * Return: File name attribute by its value.

 Enumerate all names. */

/*

 * ni_fname_type

 *

 * Return: File name attribute with given type.

 Enumerate all names. */

/*

 * ni_new_attr_flags

 *

 * Process compressed/sparsed in special way.

 * NOTE: You need to set ni->std_fa = new_fa

 * after this function to keep internal structures in consistency.

 Resize nonresident empty attribute in-place only. */

 Windows uses 16 clusters per frame but supports one cluster per frame too. */

 The only allowed: 16 clusters per frame. */

 Normal files. */

/*

 * ni_parse_reparse

 *

 * buffer - memory for reparse buffer header

 Try to estimate reparse point. */

 Symbolic link. */

 Mount points and junctions. */

		/*

		 * WOF - Windows Overlay Filter - Used to compress files with

		 * LZX/Xpress.

		 *

		 * Unlike native NTFS file compression, the Windows

		 * Overlay Filter supports only read operations. This means

		 * that it doesn't need to sector-align each compressed chunk,

		 * so the compressed data can be packed more tightly together.

		 * If you open the file for writing, the WOF just decompresses

		 * the entire file, turning it back into a plain file.

		 *

		 * Ntfs3 driver decompresses the entire file only on write or

		 * change size requests.

 4k

 8k

 16k

 32k

 64k

 Looks like normal symlink. */

/*

 * ni_fiemap - Helper for file_fiemap().

 *

 * Assumed ni_lock.

 * TODO: Less aggressive locks.

 Unfortunately cp -r incorrectly treats compressed clusters. */

 ?

 vbo < valid && valid < vbo + bytes */

/*

 * ni_readpage_cmpr

 *

 * When decompressing, we typically obtain more than one page per reference.

 * We inject the additional pages into the page cache.

 Array of at most 16 pages. stack? */

 Xpress or LZX. */

 LZNT compression. */

 At this point, err contains 0 or -EIO depending on the "critical" page. */

/*

 * ni_decompress_file - Decompress LZX/Xpress compressed file.

 *

 * Remove ATTR_DATA::WofCompressedData.

 * Remove ATTR_REPARSE.

 Clusters for decompressed data. */

 Check in advance. */

	/*

	 * Step 1: Decompress data and copy to new allocated clusters.

	/*

	 * Step 2: Deallocate attributes ATTR_DATA::WofCompressedData

	 * and ATTR_REPARSE.

run==1  Means unpack and deallocate. */

	/*

	 * Step 3: Remove attribute ATTR_DATA::WofCompressedData.

	/*

	 * Step 4: Remove ATTR_REPARSE.

	/*

	 * Step 5: Remove sparse flag from data attribute.

 Sparsed attribute header is 8 bytes bigger than normal. */

 Clear cached flag. */

/*

 * decompress_lzx_xpress - External compression LZX/Xpress.

 Frame not compressed. */

 LZX: Frame compressed. */

 Lazy initialize LZX decompress context. */

 Treat all errors as "invalid argument". */

 XPRESS: Frame compressed. */

 Lazy initialize Xpress decompress context. */

 Treat all errors as "invalid argument". */

/*

 * ni_read_frame

 *

 * Pages - Array of locked pages.

	/*

	 * To simplify decompress algorithm do vmap for source

	 * and target pages.

 Unknown compression. */

 Load all runs to read [vbo_disk-vbo_to). */

 LZNT compression. */

 Frame is not compressed. */

 Read 'ondisk_size' bytes from disk. */

	/*

	 * To simplify decompress algorithm do vmap for source and target pages.

 Decompress: Frame_ondisk -> frame_mem. */

 LZX or XPRESS */

 LZNT - Native NTFS compression. */

/*

 * ni_write_frame

 *

 * Pages - Array of locked pages.

 To simplify compress algorithm do vmap for source and target pages. */

 Map in-memory frame for read-only. */

		/*

		 * LZNT implements two levels of compression:

		 * 0 - Standard compression

		 * 1 - Best compression, requires a lot of cpu

		 * use mount option?

 Compress: frame_mem -> frame_ondisk */

 Frame is not compressed. */

 Frame is compressed. */

 Frame is sparsed. */

/*

 * ni_remove_name - Removes name 'de' from MFT and from directory.

 * 'de2' and 'undo_step' are used to restore MFT/dir, if error occurs.

 Find name in record. */

 Mark ntfs as dirty. It will be cleared at umount. */

 Step 1: Remove name from directory. */

 Step 2: Remove name from MFT. */

 Get paired name. */

 Step 3: Remove paired name from directory. */

 Step 4: Remove paired name from MFT. */

/*

 * ni_remove_name_undo - Paired function for ni_remove_name.

 *

 * Return: True if ok

/*

 * ni_add_name - Add new name in MFT and in directory.

 Insert new name in MFT. */

 Insert new name in directory. */

/*

 * ni_rename - Remove one name and insert new name.

	/*

	 * There are two possible ways to rename:

	 * 1) Add new name and remove old name.

	 * 2) Remove old name and add new name.

	 *

	 * In most cases (not all!) adding new name in MFT and in directory can

	 * allocate additional cluster(s).

	 * Second way may result to bad inode if we can't add new name

	 * and then can't restore (add) old name.

	/*

	 * Way 1 - Add new + remove old.

	/*

	 * Way 2 - Remove old + add new.

	/*

	 *	err = ni_remove_name(dir_ni, ni, de, &de2, &undo);

	 *	if (!err) {

	 *		err = ni_add_name(new_dir_ni, ni, new_de);

	 *		if (err && !ni_remove_name_undo(dir_ni, ni, de, de2, undo))

	 *			*is_bad = true;

	 *	}

/*

 * ni_is_dirty - Return: True if 'ni' requires ni_write_inode.

/*

 * ni_update_parent

 *

 * Update duplicate info of ATTR_FILE_NAME in MFT and in parent directories.

 TODO: Fill reparse info. */

 If ATTR_EA_INFO exists 'info' can't be NULL. */

 ntfs_iget5 may sleep. */

/*

 * ni_write_inode - Write MFT base record and all subrecords to disk.

 'ni' is under modification, skip for now. */

 Update times in standard attribute. */

 Update the access times if they have changed. */

 Avoid __wait_on_freeing_inode(inode). */

 Not critical if this function fail. */

 Update attribute list. */

 SPDX-License-Identifier: GPL-2.0

/*

 *

 * Copyright (C) 2019-2021 Paragon Software GmbH, All rights reserved.

 *

 *

 *                 terminology

 *

 * cluster - allocation unit     - 512,1K,2K,4K,...,2M

 * vcn - virtual cluster number  - Offset inside the file in clusters.

 * vbo - virtual byte offset     - Offset inside the file in bytes.

 * lcn - logical cluster number  - 0 based cluster in clusters heap.

 * lbo - logical byte offset     - Absolute position inside volume.

 * run - maps VCN to LCN         - Stored in attributes in packed form.

 * attr - attribute segment      - std/name/data etc records inside MFT.

 * mi  - MFT inode               - One MFT record(usually 1024 bytes or 4K), consists of attributes.

 * ni  - NTFS inode              - Extends linux inode. consists of one or more mft inodes.

 * index - unit inside directory - 2K, 4K, <=page size, does not depend on cluster size.

 *

 * WSL - Windows Subsystem for Linux

 * https://docs.microsoft.com/en-us/windows/wsl/file-permissions

 * It stores uid/gid/mode/dev in xattr

 *

/*

 * ntfs_printk - Trace warnings/notices/errors.

 *

 * Thanks Joe Perches <joe@perches.com> for implementation

 Should we use different ratelimits for warnings/notices/errors? */

 1 means 'free s_name_buf'.

/*

 * ntfs_inode_printk

 *

 * Print warnings/notices/errors about inode using name or inode number.

 Use static allocated buffer, if possible. */

 To be sure. */

 Cocci warns if placed in branch "if (de)" */

/*

 * Shared memory struct.

 *

 * On-disk ntfs's upcase table is created by ntfs formatter.

 * 'upcase' table is 128K bytes of memory.

 * We should read it into memory when mounting.

 * Several ntfs volumes likely use the same 'upcase' table.

 * It is good idea to share in-memory 'upcase' table between different volumes.

 * Unfortunately winxp/vista/win7 use different upcase tables.

/*

 * ntfs_set_shared

 *

 * Return:

 * * @ptr - If pointer was saved in shared memory.

 * * NULL - If pointer was not shared.

/*

 * ntfs_put_shared

 *

 * Return:

 * * @ptr - If pointer is not shared anymore.

 * * NULL - If pointer is still shared.

/*

 * Load nls table or if @nls is utf8 then return NULL.

 Should not be here unless we forget add case. */

/*

 * put_ntfs - Noinline to reduce binary size.

 Mark rw ntfs as clear, if possible. */

/*

 * ntfs_sync_fs - super_operations::sync_fs

 TODO: == ntfs_sync_inode */

/*

 * format_size_gb - Return Gb,Mb to print with "%u.%02u Gb".

 Do simple right 30 bit shift of 64 bit value. */

/*

 * ntfs_init_from_boot - Init internal info from on-disk boot sector.

 0x55AA is not mandaroty. Thanks Maxim Suhanov*/

	/*if (0x55 != boot->boot_magic[0] || 0xAA != boot->boot_magic[1])

	 *	goto out;

 cluster size: 512, 1K, 2K, 4K, ... 2M */

 Check MFT record size. */

 Check index record size. */

	/*

	 * - Volume formatted and mounted with the same sector size.

	 * - Volume formatted 4K and mounted as 512.

	 * - Volume formatted 512 and mounted as 4K.

 Compare boot's cluster and sector. */

 Compare boot's cluster and media sector. */

 No way to use ntfs_get_block in this case. */

 ~320 bytes

 Warning if RAW volume. */

 32 bits per cluster. */

 Maximum size for normal files. */

 Maximum size for sparse file. */

/*

 * ntfs_fill_super - Try to mount.

 "ntfs"

 100 nsec

 Parse boot. */

	/*

	 * Load $Volume. This should be done before $LogFile

	 * 'cause 'sbi->volume.ni' is used 'ntfs_set_state'.

 Load and save label (not necessary). */

 It is ok if no ATTR_LABEL */

 $AttrDef allows labels to be up to 128 symbols. */

 Should we break mounting here? */

err = -EINVAL;

goto put_inode_out;

 Load $MFTMirr to estimate recs_mirr. */

 Load LogFile to replay. */

 Load $MFT. */

 Load $BadClus. */

 Load $Bitmap. */

 Check bitmap boundary. */

 Not necessary. */

 Compute the MFT zone. */

 Load $AttrDef. */

 default formatter value */

 Load $UpCase. */

 Load $Secure. */

 Load $Extend. */

 Load $Extend\$Reparse. */

 Load $Extend\$ObjId. */

 Load root. */

	/*

	 * Free resources here.

	 * ntfs_fs_free will be called with fc->s_fs_info = NULL

/*

 * ntfs_discard - Issue a discard request (trim for SSD).

 Align up 'start' on discard_granularity. */

 Align down 'end' on discard_granularity. */

/*

 * ntfs_fs_free - Free fs_context.

 *

 * Note that this will be called after fill_super and reconfigure

 * even when they pass. So they have to take pointers if they pass.

/*

 * ntfs_init_fs_context - Initialize spi and opts

 *

 * This will called when mount/remount. We will first initiliaze

 * options so that if remount we can use just that.

 Default options. */

 clang-format off

 clang-format on

 SPDX-License-Identifier: GPL-2.0

/*

 *

 * Copyright (C) 2019-2021 Paragon Software GmbH, All rights reserved.

 *

 * TODO: try to use extents tree (instead of array)

 runs_tree is a continues memory. Try to avoid big size. */

 Virtual cluster number. */

 Length in clusters. */

 Logical cluster number. */

/*

 * run_lookup - Lookup the index of a MCB entry that is first <= vcn.

 *

 * Case of success it will return non-zero value and set

 * @index parameter to index of entry been found.

 * Case of entry missing from list 'index' will be set to

 * point to insertion position for the entry question.

 Check boundary cases specially, 'cause they cover the often requests. */

/*

 * run_consolidate - Consolidate runs starting from a given one.

		/*

		 * I should merge current run with next

		 * if start of the next run lies inside one being tested.

 Stop if runs are not aligned one to another. */

		/*

		 * If range at index overlaps with next one

		 * then I will either adjust it's start position

		 * or (if completely matches) dust remove one from the list.

		/*

		 * Stop if sparse mode does not match

		 * both current and next runs.

		/*

		 * Check if volume block

		 * of a next run lcn does not match

		 * last volume block of the current run.

		/*

		 * Next and current are siblings.

		 * Eat/join.

/*

 * run_is_mapped_full

 *

 * Return: True if range [svcn - evcn] is mapped.

 Fail immediately if nrun was not touched yet. */

/*

 * run_truncate_head - Decommit the range before vcn.

/*

 * run_truncate - Decommit the range after vcn.

	/*

	 * If I hit the range then

	 * I have to truncate one.

	 * If range to be truncated is becoming empty

	 * then it will entirely be removed.

	/*

	 * At this point 'index' is set to position that

	 * should be thrown away (including index itself)

	 * Simple one - just set the limit.

 Do not reallocate array 'runs'. Only free if possible. */

/*

 * run_truncate_around - Trim head and tail if necessary.

/*

 * run_add_entry

 *

 * Sets location to known state.

 * Run to be added may overlap with existing location.

 *

 * Return: false if of memory.

	/*

	 * Lookup the insertion point.

	 *

	 * Execute bsearch for the entry containing

	 * start position question.

	/*

	 * Shortcut here would be case of

	 * range not been found but one been added

	 * continues previous run.

	 * This case I can directly make use of

	 * existing range as my start point.

	/*

	 * At this point 'index' either points to the range

	 * containing start position or to the insertion position

	 * for a new range.

	 * So first let's check if range I'm probing is here already.

		/*

		 * Range was not found.

		 * Insert at position 'index'

		/*

		 * Check allocated space.

		 * If one is not enough to get one more entry

		 * then it will be reallocated.

 Use power of 2 for 'bytes'. */

 memmove appears to be a bottle neck here... */

		/*

		 * If one of ranges was not allocated then we

		 * have to split location we just matched and

		 * insert current one.

		 * A common case this requires tail to be reinserted

		 * a recursive call.

 lcn should match one were going to add. */

		/*

		 * If existing range fits then were done.

		 * Otherwise extend found one and fall back to range jocode.

	/*

	 * And normalize it starting from insertion point.

	 * It's possible that no insertion needed case if

	 * start point lies within the range of an entry

	 * that 'index' points to.

	/*

	 * A special case.

	 * We have to add extra range a tail.

/* run_collapse_range

 *

 * Helper for attr_collapse_range(),

 * which is helper for fallocate(collapse_range).

 Should never be here. */

 Collapse tail of run .*/

 Collapse a middle part of sparsed run. */

 Collapse a middle part of normal run, split. */

 Eat this run. */

/*

 * run_get_entry - Return index-th mapped region.

/*

 * run_packed_size - Calculate the size of packed int64.

 Full trusted function. It does not check 'size' for errors. */

 Full trusted function. It does not check 'size' for errors. */

 Full trusted function. It does not check 'size' for errors. */

 memcpy( run_buf, &v, size); Is it faster? */

 full trusted function. It does not check 'size' for errors */

 memcpy( &v, run_buf, size); Is it faster? */

/*

 * run_pack - Pack runs into buffer.

 *

 * packed_vcns - How much runs we have packed.

 * packed_size - How much bytes we have used run_buf.

 How much bytes required to pack len. */

 offset_size - How much bytes is packed dlcn. */

 NOTE: lcn can be less than prev_lcn! */

 Can we store this entire run. */

 Pack run header. */

 Pack the length of run. */

 Pack the offset from previous LCN. */

 Store last zero. */

/*

 * run_unpack - Unpack packed runs from @run_buf.

 *

 * Return: Error if negative, or real used bytes.

 Check for empty. */

 Read all runs the chain. */

 size_size - How much bytes is packed len. */

 size_size - How much bytes is packed len. */

 offset_size - How much bytes is packed dlcn. */

		/*

		 * Unpack runs.

		 * NOTE: Runs are stored little endian order

		 * "len" is unsigned value, "dlcn" is signed.

		 * Large positive number requires to store 5 bytes

		 * e.g.: 05 FF 7E FF FF 00 00 00

 Skip size_size. */

 Initial value of dlcn is -1 or 0. */

 Skip offset_size. */

 Check boundary. */

 LCN range is out of volume. */

 Called from check_attr(fslog.c) to check run. */

			/*

			 * Called from ni_delete_all to free clusters

			 * without storing in run.

 Not expected length of unpacked runs. */

/*

 * run_unpack_ex - Unpack packed runs from "run_buf".

 *

 * Checks unpacked runs to be used in bitmap.

 *

 * Return: Error if negative, or real used bytes.

 Check for free blocks. */

 Looks like volume is corrupted. */

 Mark all zero bits as used in range [lcn, lcn+len). */

/*

 * run_get_highest_vcn

 *

 * Return the highest vcn from a mapping pairs array

 * it used while replaying log file.

 SPDX-License-Identifier: GPL-2.0

/*

 *

 * Copyright (C) 2019-2021 Paragon Software GmbH, All rights reserved.

 *

/*

 * ntfs_cmp_names

 *

 * Thanks Kari Argillander <kari.argillander@gmail.com> for idea and implementation 'bothcase'

 *

 * Straight way to compare names:

 * - Case insensitive

 * - If name equals and 'bothcases' then

 * - Case sensitive

 * 'Straight way' code scans input names twice in worst case.

 * Optimized code scans input names only once.

 SPDX-License-Identifier: GPL-2.0

/*

 *

 * Copyright (C) 2019-2021 Paragon Software GmbH, All rights reserved.

 *

 clang-format off

 clang-format on

/*

 * find_ea

 *

 * Assume there is at least one xattr in the list.

/*

 * ntfs_read_ea - Read all extended attributes.

 * @ea:		New allocated memory.

 * @info:	Pointer into resident data.

 Check Ea limit. */

 Allocate memory for packed Ea. */

/*

 * ntfs_list_ea

 *

 * Copy a list of xattrs names into the buffer

 * provided, or compute the buffer size required.

 *

 * Return:

 * * Number of bytes used / required on

 * * -ERRNO - on failure

 Enumerate all xattrs. */

 Enumerate all xattrs. */

		/*

		 * Check simple case when we try to insert xattr with the same value

		 * e.g. ntfs_save_wsl_perm

 xattr already contains the required value. */

 Remove current xattr. */

 Remove xattr. */

 Append new xattr. */

 New size of ATTR_EA. */

	/*

	 * 1. Check ea_info.size_pack for overflow.

	 * 2. New attibute size must fit value from $AttrDef

 -EINVAL?

 Create xattr. */

 Delete xattr, ATTR_EA_INFO */

 Delete xattr, ATTR_EA */

 Check if we delete the last xattr. */

 Allocate PATH_MAX bytes. */

 Possible values of 'type' was already checked above. */

 Translate extended attribute to acl. */

/*

 * ntfs_get_acl - inode_operations::get_acl

 TODO: init_user_ns? */

 Remove xattr if it can be presented via mode. */

 Removing non existed xattr. */

/*

 * ntfs_set_acl - inode_operations::set_acl

/*

 * ntfs_init_acl - Initialize the ACLs of a new inode.

 *

 * Called from ntfs_create_inode().

/*

 * ntfs_acl_chmod - Helper for ntfs3_setattr().

/*

 * ntfs_permission - inode_operations::permission

 "No access rules" mode - Allow all changes. */

/*

 * ntfs_listxattr - inode_operations::listxattr

 no xattr in file */

 Dispatch request. */

 system.dos_attrib */

 system.ntfs_attrib */

 system.ntfs_security*/

 We should get nt4 security. */

 Deal with NTFS extended attribute. */

/*

 * ntfs_setxattr - inode_operations::setxattr

 Dispatch request. */

 Process compressed/sparsed in special way. */

		/*

		 * Thanks Mark Harmstone:

		 * Keep directory bit consistency.

 Std attribute always in primary record. */

 system.ntfs_security*/

			/*

			 * We should replace ATTR_SECURE.

			 * Skip this way cause it is nt4 feature.

 Std attribute always in primary record. */

 Deal with NTFS extended attribute. */

/*

 * ntfs_save_wsl_perm

 *

 * save uid/gid/mode in xattr

 TODO: refactor this, so we don't lock 4 times in ntfs_set_ea */

 In case of error should we delete all WSL xattr? */

/*

 * ntfs_get_wsl_perm

 *

 * get uid/gid/mode from xattr

 * it is called from ntfs_iget5->ntfs_read_mft

 clang-format off

 clang-format on

 SPDX-License-Identifier: GPL-2.0

/*

 *

 * Copyright (C) 2019-2021 Paragon Software GmbH, All rights reserved.

 *

 * TODO: Merge attr_set_size/attr_data_get_block/attr_allocate_frame?

/*

 * You can set external NTFS_MIN_LOG2_OF_CLUMP/NTFS_MAX_LOG2_OF_CLUMP to manage

 * preallocate algorithm.

 16M

 16G

/*

 * attr_must_be_resident

 *

 * Return: True if attribute must be resident.

/*

 * attr_load_runs - Load all runs stored in @attr.

/*

 * run_deallocate_ex - Deallocate clusters.

 Save memory - don't load entire run. */

/*

 * attr_allocate_clusters - Find free space, mark it as used and store in @run.

 Add new fragment into run storage. */

 Undo last 'ntfs_look_for_free_space' */

 Undo 'ntfs_look_for_free_space' */

/*

 * attr_make_nonresident

 *

 * If page is not NULL - it is already contains resident data

 * and locked (called from ni_write_frame()).

 Make a copy of original attribute. */

 Empty resident -> Empty nonresident. */

 Empty resident -> Non empty nonresident. */

 Remove original attribute. */

 Resident attribute becomes non resident. */

 Undo: do not trim new allocated clusters. */

/*

 * attr_set_size_res - Helper for attr_set_size().

/*

 * attr_set_size - Change the size of attribute.

 *

 * Extend:

 *   - Sparse/compressed: No allocated clusters.

 *   - Normal: Append allocated and preallocated new clusters.

 * Shrink:

 *   - No deallocate if @keep_prealloc is set.

 Layout of records may be changed, so do a full search. */

 MFT allocates clusters from MFT zone. */

 No preallocate for sparse/compress. */

 Get the last LCN to allocate from. */

 ~3 bytes per fragment. */

 Normal way. Update attribute and exit. */

 At least two MFT to avoid recursive loop. */

 Layout of records is changed. */

 Layout of records is changed. */

 This is MFT data, repeat. */

 Insert new attribute segment. */

		/*

		 * Layout of records maybe changed.

		 * Find base attribute to update.

			/*

			 * NOTE: List entries for one attribute are always

			 * the same size. We deal with last entry (vcn==0)

			 * and it is not first in entries array

			 * (list entry for std attribute always first).

			 * So it is safe to step back.

 Update inode_set_bytes. */

 Normal way. */

 Normal way. */

 Get the last LCN to allocate from. */

 Stored [vcn : next_svcn) from [vcn : end). */

 Normal way. Update attribute and exit. */

 Add new segment [next_svcn : evcn1 - next_svcn). */

 Layout of records is changed. */

 Estimate next attribute. */

 Remove segment [svcn : evcn). */

 Last attribute segment. */

 Return special error code to check this case. */

/*

 * attr_load_runs_vcn - Load runs with VCN.

 Is record corrupted? */

 Is record corrupted? */

/*

 * attr_load_runs_range - Load runs for given range [from to).

 Next run_lookup_entry(vcn) must be success. */

/*

 * attr_wof_frame_info

 *

 * Read header of Xpress/LZX file to get info about frame.

 File starts with array of 32 bit offsets. */

 File starts with array of 64 bit offsets. */

	/*

	 * Read 4/8 bytes at [vbo - 4(8)] == offset where compressed frame starts.

	 * Read 4/8 bytes at [vbo] == offset where compressed frame ends.

 Two values in one page. */

/*

 * attr_is_frame_compressed - Used to detect compressed frame.

 Sparsed frame. */

		/*

		 * The frame is not compressed 'cause

		 * it does not contain any sparse clusters.

	/*

	 * The frame is compressed if *clst_data + slen >= clst_frame.

	 * Check next fragments.

				/*

				 * Data_clusters + sparse_clusters =

				 * not enough for frame.

				/*

				 * There is no sparsed clusters in this frame

				 * so it is not compressed.

 Frame is compressed. */

/*

 * attr_allocate_frame - Allocate/free clusters for @frame.

 *

 * Assumed: down_write(&ni->file.run_lock);

 Run contains updated range [vcn + len : end). */

 Get the last LCN to allocate from. */

 Run contains updated range [vcn + clst_data : end). */

 Stored [vcn : next_svcn) from [vcn : end). */

 Normal way. Update attribute and exit. */

 Add new segment [next_svcn : evcn1 - next_svcn). */

 Layout of records is changed. */

 Estimate next attribute. */

 Remove segment [svcn : evcn). */

 Last attribute segment. */

/*

 * attr_collapse_range - Collapse range in file.

 Attribute is resident. Nothing to do? */

 Allow to collapse only cluster aligned ranges. */

 Simple truncate file at 'vbo'. */

	/*

	 * Enumerate all attribute segments and collapse.

 Shift VCN- */

 Collapse a part of this attribute segment. */

 Shift VCN */

 Layout of records maybe changed. */

 Free all allocated memory. */

 Delete this attribute segment. */

 Load next record that contains this attribute. */

 Look for required attribute. */

 Update inode size. */

/*

 * attr_punch_hole

 *

 * Not for normal files.

 NOTE: It is allowed. */

 We have to zero a range(s). */

 Caller insists range is aligned. */

	/*

	 * Enumerate all attribute segments and punch hole where necessary.

 Looks like the required range is already sparsed. */

 Free all allocated memory. */

 Update inode size. */

 SPDX-License-Identifier: GPL-2.0

/*

 *

 * Copyright (C) 2019-2021 Paragon Software GmbH, All rights reserved.

 *

/*

 * ntfs_read_mft - Read record and parses MFT.

 0x18 bytes

 Setup 'uid' and 'gid' */

 Bad inode? */

 Record should contain $I30 root. */

 Enumerate all struct Attributes MFT. */

	/*

	 * To reduce tab pressure use goto instead of

	 * while( (attr = ni_enum_attr_ex(ni, attr, &le, NULL) ))

 This is non primary attribute segment. Ignore if not MFT. */

 Ignore data attribute in dir record. */

 File contains stream attribute. Ignore it. */

 0x20000000 = 2^32 / 8 */

			/*

			 * Normal symlink.

			 * Assume one unicode symbol == one utf8.

 Clear directory bit. */

 Double break.

			/*

			 * ntfs_get_wsl_perm updates inode->i_uid, inode->i_gid, inode->i_mode

 Reuse rec as buffer for ascii name. */

 Correct minor error on the fly. Do not mark inode as dirty. */

		/*

		 * Dot and dot-dot should be included in count but was not

		 * included in enumeration.

		 * Usually a hard links to directories are disabled.

 Records in $Extend are not a files or general directories. */

 If no xattr then no security (stored in xattr). */

/*

 * ntfs_test_inode

 *

 * Return: 1 if match.

 If this is a freshly allocated inode, need to read it now. */

 Inode overlaps? */

 Clear previous state. */

 Direct write uses 'create=0'. */

 Out of valid. */

 Out of size. */

 ntfs_direct_IO will update ni->i_valid. */

 Normal write. */

 Read out of valid data. */

 Should never be here 'cause already checked. */

 Normal read. */

 Normal short read. */

		/*

		 * Read across valid size: vbo < valid && valid < vbo + block_size

 Normal + sparse files. */

 No readahead for resident. */

 No readahead for compressed. */

 Range cross 'valid'. Read it page by page. */

 Switch to buffered write. */

 Fix page. */

 Check for maximum file size. */

 Redirect call to 'ntfs_writepage' for resident files. */

/*

 * ntfs_write_end - Address_space_operations::write_end.

 Clear any buffers in page. */

 ni->i_valid is changed in ntfs_get_block_vbo. */

/*

 * writeback_inode - Helper function for ntfs_flush_inodes().

 *

 * This writes both the inode and the file data blocks, waiting

 * for in flight data blocks before the start of the call.  It

 * does not wait for any io started during the call.

/*

 * ntfs_flush_inodes

 *

 * Write data and metadata corresponding to i1 and i2.  The io is

 * started but we do not wait for any of it to finish.

 *

 * filemap_flush() is used for the block device, so if there is a dirty

 * page for a block already in flight, we will not wait and start the

 * io over again.

 Write non resident data. */

/*

 * ntfs_reparse_bytes

 *

 * Number of bytes for REPARSE_DATA_BUFFER(IO_REPARSE_TAG_SYMLINK)

 * for unicode string of @uni_len length.

 Header + unicode string + decorated unicode string. */

 Convert link name to UTF-16. */

 err = the length of unicode name of symlink. */

 Translate Linux '/' into Windows '\'. */

 PrintName + SubstituteName. */

	/*

	 * TODO: Use relative path if possible to allow Windows to

	 * parse this path.

	 * 0-absolute path 1- relative path (SYMLINK_FLAG_RELATIVE).

 Decorate SubstituteName. */

 Use parent's directory attributes. */

		/*

		 * By default child directory inherits parent attributes.

		 * Root directory is hidden + system.

		 * Make an exception for children in root.

 It is good idea that link should be the same type (file/dir) as target */

		/*

		 * Linux: there are dir/file/symlink and so on.

		 * NTFS: symlinks are "dir + reparse" or "file + reparse"

		 * It is good idea to create:

		 * dir + reparse if 'symname' points to directory

		 * or

		 * file + reparse if 'symname' points to file

		 * Unfortunately kern_path hangs if symname contains 'dir'.

		/*

		 *	struct path path;

		 *

		 *	if (!kern_path(symname, LOOKUP_FOLLOW, &path)){

		 *		struct inode *target = d_inode(path.dentry);

		 *

		 *		if (S_ISDIR(target->i_mode))

		 *			fa |= FILE_ATTRIBUTE_DIRECTORY;

		 *		// if ( target->i_sb == sb ){

		 *		//	use relative path?

		 *		// }

		 *		path_put(&path);

		 *	}

 Sparsed regular file, cause option 'sparse'. */

 Compressed regular file, if parent is compressed. */

 Regular file, default attributes. */

 Allocate PATH_MAX bytes. */

 Mark rw ntfs as dirty. it will be cleared at umount. */

 Step 1: allocate and fill new mft record. */

 Get default security id. */

 Insert standard info. */

 Insert file name. */

 Insert security attribute. */

		/*

		 * Regular directory or symlink to directory.

		 * Create root attribute.

 0x10

		/*

		 * Symlink to file.

		 * Create empty resident data attribute.

 Insert empty ATTR_DATA */

		/*

		 * Regular file. Create empty non resident data attribute.

		/*

		 * Node. Create empty resident data attribute.

		/*

		 * Insert ATTR_REPARSE.

 Resident or non resident? */

		/*

		 * Below function 'ntfs_save_wsl_perm' requires 0x78 bytes.

		 * It is good idea to keep extened attributes resident.

 Bytes per runs. */

 Size of symlink equals the length of input string. */

 Step 2: Add new name in index. */

 Unlock parent directory before ntfs_init_acl. */

 Write non resident data. */

	/*

	 * Call 'd_instantiate' after inode->i_op is set

	 * but before finish_open.

 Normal exit. */

 Undo 'indx_insert_entry'. */

 ni_unlock(dir_ni); will be called later. */

 Allocate PATH_MAX bytes. */

 Mark rw ntfs as dirty. It will be cleared at umount. */

 Construct 'de'. */

 Fill duplicate info. */

/*

 * ntfs_unlink_inode

 *

 * inode_operations::unlink

 * inode_operations::rmdir

 Allocate PATH_MAX bytes. */

 Reparse data present. Try to parse it. */

 Read into temporal buffer. */

 Microsoft Tag. */

 Mount points and junctions. */

 Can we use 'Rp->MountPointReparseBuffer.PrintNameLength'? */

 FolderSymbolicLink */

 Can we use 'Rp->SymbolicLinkReparseBuffer.PrintNameLength'? */

 Unknown Microsoft Tag. */

 Users tag. */

 Convert nlen from bytes to UNICODE chars. */

 Check that name is available. */

 If name is already zero terminated then truncate it now. */

 Translate Windows '\' into Linux '/'. */

 Always set last zero. */

 clang-format off

 clang-format on

 SPDX-License-Identifier: GPL-2.0

/*

 *

 * Copyright (C) 2019-2021 Paragon Software GmbH, All rights reserved.

 *

 *  Directory handling functions for NTFS-based filesystems.

 *

 Convert little endian UTF-16 to NLS string. */

 UTF-16 -> UTF-8 */

 clang-format off

 clang-format on

/*

 * put_utf16 - Modified version of put_utf16 from fs/nls/nls_base.c

 *

 * Function is sparse warnings free.

/*

 * _utf8s_to_utf16s

 *

 * Modified version of 'utf8s_to_utf16s' allows to

 * detect -ENAMETOOLONG without writing out of expected maximum.

/*

 * ntfs_nls_to_utf16 - Convert input string to UTF-16.

 * @name:	Input name.

 * @name_len:	Input name length.

 * @uni:	Destination memory.

 * @max_ulen:	Destination memory.

 * @endian:	Endian of target UTF-16 string.

 *

 * This function is called:

 * - to create NTFS name

 * - to create symlink

 *

 * Return: UTF-16 string length or error (if negative).

 utf8 -> utf16 */

/*

 * dir_search_u - Helper function.

 Skip meta files. Unless option to show metafiles is set. */

/*

 * ntfs_read_hdr - Helper function for ntfs_readdir().

 Skip already enumerated. */

 Submit the name to the filldir callback. */

/*

 * ntfs_readdir - file_operations::iterate_shared

 *

 * Use non sorted enumeration.

 * We have an example of broken volume where sorted enumeration

 * counts each name twice.

 Name is a buffer of PATH_MAX length. */

 Allocate PATH_MAX bytes. */

		/*

		 * Directory inode is locked for read.

		 * Load all subrecords to avoid 'write' access to 'ni' during

		 * directory reading.

 clang-format off

 clang-format on

 SPDX-License-Identifier: GPL-2.0

/*

 *

 * Copyright (C) 2019-2021 Paragon Software GmbH, All rights reserved.

 *

 First, compare the type codes. */

 They have the same type code, so we have to compare the names. */

/*

 * mi_new_attt_id

 *

 * Return: Unused attribute id that is less than mrec->next_attr_id.

 One record can store up to 1024/24 ~= 42 attributes. */

/*

 * mi_read - Read MFT data.

 Check field 'total' only here. */

 Skip non-resident records. */

 Check if input attr inside record. */

 Impossible 'cause we should not return such attribute. */

 Can we use the first field (attr->type). */

 End of enumeration. */

 0x100 is last known attribute for now. */

 Check boundary. */

 Check size of attribute. */

 Check some nonresident fields. */

/*

 * mi_find_attr - Find the attribute by type and name and id.

 Record is reused. Update its sequence number. */

/*

 * mi_mark_free - Mark record as unused and marks it as free in bitmap.

/*

 * mi_insert_attr - Reserve space for new attribute.

 *

 * Return: Not full constructed attribute or NULL if not possible to create.

 Can we insert mi attribute? */

	/*

	 * Scan through the list of attributes to find the point

	 * at which we should insert it.

 Not used, just to suppress warning. */

/*

 * mi_remove_attr - Remove the attribute from record.

 *

 * NOTE: The source attr will point to next attribute.

 bytes = "new attribute size" - "old attribute size" */

 Move tail */

 Make a maximum gap in current record. */

 Pack as much as possible. */

 SPDX-License-Identifier: GPL-2.0

/*

 *

 * Copyright (C) 2019-2021 Paragon Software GmbH, All rights reserved.

 *

 clang-format off

 clang-format on

/*

 * ntfs_fix_pre_write - Insert fixups into @rhdr before writing to disk.

 Get fixup pointer. */

/*

 * ntfs_fix_post_read - Remove fixups after reading from disk.

 *

 * Return: < 0 if error, 0 if ok, 1 if need to update fixups.

 Check errors. */

 Native chkntfs returns ok! */

 Get fixup pointer. */

 Test current word. */

 Fixup does not match! Is it serious error? */

 Replace fixup. */

/*

 * ntfs_extend_init - Load $Extend file.

 If ntfs_iget5() reads from disk it never returns bad inode. */

 Try to find $ObjId */

 Try to find $Quota */

 Try to find $Reparse */

 Try to find $UsnJrnl */

 Check for 4GB. */

 Try to use MFT copy. */

 LogFile should not contains attribute list. */

 Fill LogFile by '-1' if it is initialized. */

/*

 * ntfs_query_def

 *

 * Return: Current ATTR_DEF_ENTRY for given attribute type.

/*

 * ntfs_look_for_free_space - Look for a free space in bitmap.

	/*

	 * 'Cause cluster 0 is always used this value means that we should use

	 * cached value of 'next_free_lcn' to improve performance.

 Try to use clusters from MftZone. */

 Check too big request */

 How many clusters to cat from zone. */

 Allocate continues clusters. */

 Set hint for next requests. */

/*

 * ntfs_extend_mft - Allocate additional MFT records.

 *

 * sbi->mft.bitmap is locked for write.

 *

 * NOTE: recursive:

 *	ntfs_look_free_mft ->

 *	ntfs_extend_mft ->

 *	attr_set_size ->

 *	ni_insert_nonresident ->

 *	ni_insert_attr ->

 *	ni_ins_attr_ext ->

 *	ntfs_look_free_mft ->

 *	ntfs_extend_mft

 *

 * To avoid recursive always allocate space for two new MFT records

 * see attrib.c: "at least two MFT to avoid recursive loop".

 Step 1: Resize $MFT::DATA. */

 Step 2: Resize $MFT::BITMAP. */

 Refresh MFT Zone if necessary. */

/*

 * ntfs_look_free_mft - Look for a free MFT record.

 Always reserve space for MFT. */

 No MFT zone. Find the nearest to '0' free MFT. */

 Resize MFT */

		/*

		 * Look for free record reserved area [11-16) ==

		 * [MFT_REC_RESERVED, MFT_REC_FREE ) MFT bitmap always

		 * marks it as used.

 Once per session create internal bitmap for 5 bits. */

 Scan 5 bits for zero. Bit 0 == MFT_REC_RESERVED */

 [zbit, zbit + zlen) will be used for MFT itself. */

 The request to get record for general purpose. */

 We have found a record that are not reserved for next MFT. */

/*

 * ntfs_mark_rec_free - Mark record as free.

/*

 * ntfs_clear_mft_tail - Format empty records [from, to).

 *

 * sbi->mft.bitmap is locked for write.

/*

 * ntfs_refresh_zone - Refresh MFT zone.

 *

 * sbi->used.bitmap is locked for rw.

 * sbi->mft.bitmap is locked for write.

 * sbi->mft.ni->file.run_lock for write.

 Do not change anything unless we have non empty MFT zone. */

	/*

	 * Compute the MFT zone at two steps.

	 * It would be nice if we are able to allocate 1/8 of

	 * total clusters for MFT but not more then 512 MB.

 We should always find Last Lcn for MFT. */

 Try to allocate clusters after last MFT run. */

 Truncate too large zone. */

/*

 * ntfs_update_mftmirr - Update $MFTMirr data.

/*

 * ntfs_set_state

 *

 * Mount: ntfs_set_state(NTFS_DIRTY_DIRTY)

 * Umount: ntfs_set_state(NTFS_DIRTY_CLEAR)

 * NTFS error: ntfs_set_state(NTFS_DIRTY_ERROR)

	/*

	 * Do not change state if fs was real_dirty.

	 * Do not change state if fs already dirty(clear).

	 * Do not change any thing if mounted read only.

 Check cached value. */

 Cache current volume flags. */

 verify(!ntfs_update_mftmirr()); */

	/*

	 * If we used wait=1, sync_inode_metadata waits for the io for the

	 * inode to finish. It hangs when media is removed.

	 * So wait=0 is sent down to sync_inode_metadata

	 * and filemap_fdatawrite is used for the data blocks.

/*

 * security_hash - Calculates a hash of security descriptor.

 First reading of $Volume + $MFTMirr + $LogFile goes here. */

 Use absolute boot's 'MFTCluster' to read record. */

/*

 * ntfs_read_bh

 *

 * Return: < 0 if error, 0 if ok, -E_NTFS_FIXUP if need to update fixups.

/*

 * ntfs_bio_pages - Read/write pages from/to disk.

 Align vbo and bytes to be 512 bytes aligned. */

/*

 * ntfs_bio_fill_1 - Helper for ntfs_loadlog_and_replay().

 *

 * Fill on-disk logfile range by (-1)

 * this means empty logfile.

	/*

	 * TODO: Try blkdev_issue_write_same.

/*

 * O:BAG:BAD:(A;OICI;FA;;;WD)

 * Owner S-1-5-32-544 (Administrators)

 * Group S-1-5-32-544 (Administrators)

 * ACE: allow S-1-1-0 (Everyone) with FILE_ALL_ACCESS

/*

 * is_acl_valid

 *

 * Thanks Mark Harmstone for idea.

		/*

		 * This value should be ACL_REVISION, unless the ACL contains an

		 * object-specific ACE, in which case this value must be ACL_REVISION_DS.

		 * All ACEs in an ACL must be at the same revision level.

/*

 * ntfs_security_init - Load and parse $Secure.

 Find the last valid Id. */

 Always write new security at the end of bucket. */

/*

 * ntfs_get_security_by_id - Read security descriptor by id.

 Try to find this SECURITY descriptor in SII indexes. */

 Looks like too big security. 0x10000 - is arbitrary big number. */

/*

 * ntfs_insert_security - Insert security descriptor into $Secure::SDS.

 *

 * SECURITY Descriptor Stream data is organized into chunks of 256K bytes

 * and it contains a mirror copy of each security descriptor.  When writing

 * to a security descriptor at location X, another copy will be written at

 * location (X+256K).

 * When writing a security descriptor that will cross the 256K boundary,

 * the pointer will be advanced by 256K to skip

 * over the mirror portion.

 Allocate a temporal buffer. */

	/*

	 * Check if such security already exists.

	 * Use "SDH" and hash -> to get the offset in "SDS".

 Such security already exists. */

 Zero unused space. */

 Zero gap until SecurityDescriptorsBlockSize. */

 Zero "left" bytes from sbi->security.next_off. */

 Zero tail of previous security. */

used = ni->vfs_inode.i_size & (SecurityDescriptorsBlockSize - 1);

	/*

	 * Example:

	 * 0x40438 == ni->vfs_inode.i_size

	 * 0x00440 == sbi->security.next_off

	 * need to zero [0x438-0x440)

	 * if (next > used) {

	 *  u32 tozero = next - used;

	 *  zero "tozero" bytes from sbi->security.next_off - tozero

 Format new security descriptor. */

 Write main SDS bucket. */

 Write copy SDS bucket. */

 Fill SII entry. */

 Fill SDH entry. */

 Update Id and offset for next descriptor. */

/*

 * ntfs_reparse_init - Load and parse $Extend/$Reparse.

/*

 * ntfs_objid_init - Load and parse $Extend/$ObjId.

 1 - forces to ignore rkey.ReparseTag when comparing keys. */

 Impossible. Looks like volume corrupt? */

/*

 * run_deallocate - Deallocate clusters.

 SPDX-License-Identifier: GPL-2.0

/*

 *

 * Copyright (C) 2019-2021 Paragon Software GmbH, All rights reserved.

 *

/*

 * al_is_valid_le

 *

 * Return: True if @le is valid.

/*

 * ntfs_load_attr_list

 *

 * This method makes sure that the ATTRIB list, if present,

 * has been properly set up.

/*

 * al_enumerate

 *

 * Return:

 * * The next list le.

 * * If @le is NULL then return the first le.

 Impossible 'cause we should not return such le. */

 Check boundary. */

 The regular end of list. */

 Check le for errors. */

/*

 * al_find_le

 *

 * Find the first le in the list which matches type, name and VCN.

 *

 * Return: NULL if not found.

/*

 * al_find_ex

 *

 * Find the first le in the list which matches type, name and VCN.

 *

 * Return: NULL if not found.

 List entries are sorted by type, name and VCN. */

			/*

			 * Compare entry names only for entry with vcn == 0.

/*

 * al_find_le_to_insert

 *

 * Find the first list entry which matches type, name and VCN.

 List entries are sorted by type, name and VCN. */

			/*

			 * Compare entry names only for entry with vcn == 0.

/*

 * al_add_le

 *

 * Add an "attribute list entry" to the list.

	/*

	 * Compute the size of the new 'le'

 Scan forward to the point at which the new 'le' should be inserted. */

 Undo memmove above. */

/*

 * al_remove_le - Remove @le from attribute list.

 Save on stack the size of 'le' */

/*

 * al_delete_le - Delete first le from the list which matches its parameters.

 Scan forward to the first le that matches the input. */

	/*

	 * The caller specified a segment reference, so we have to

	 * scan through the matching entries until we find that segment

	 * reference or we run of matching entries.

 Save on stack the size of 'le'. */

 Delete the le. */

	/*

	 * Attribute list increased on demand in al_add_le.

	 * Attribute list decreased here.

 SPDX-License-Identifier: GPL-2.0

/*

 *

 * Copyright (C) 2019-2021 Paragon Software GmbH, All rights reserved.

 *

 *  Regular file handling primitives for NTFS-based filesystems.

 *

 Inappropriate ioctl for device. */

/*

 * ntfs_getattr - inode_operations::getattr

 512, 1K, ..., 2M */

 This function in any case puts page. */

/*

 * ntfs_zero_range - Helper function for punch_hole.

 *

 * It zeroes a range [vbo, vbo_to).

 Unmapped? It's a hole - nothing to do. */

 Ok, it's mapped. Make sure it's up-to-date. */

/*

 * ntfs_sparse_cluster - Helper function to zero a new allocated clusters.

 *

 * NOTE: 512 <= cluster size <= 2M

/*

 * ntfs_file_mmap - file_operations::mmap

 Allocate clusters for rw map. */

 Mark rw ntfs as dirty. It will be cleared at umount. */

ntfs_flush_inodes(inode->i_sb, inode, NULL);*/

/*

 * ntfs_fallocate

 *

 * Preallocate space for a file. This implements ntfs's fallocate file

 * operation, which gets called from sys_fallocate system call. User

 * space requests 'len' bytes at 'vbo'. If FALLOC_FL_KEEP_SIZE is set

 * we just allocate clusters without zeroing them out. Otherwise we

 * allocate and zero out clusters via an expanding truncate.

 No support for dir. */

 Return error if mode is not supported. */

 Should never be here, see ntfs_file_open. */

			/*

			 * Normal file, can't make hole.

			 * TODO: Try to find way to save info about hole.

 Process not aligned punch. */

 Aligned punch_hole */

		/*

		 * Write tail of the last page before removed range since

		 * it will get removed from the page cache below.

		/*

		 * Write data that will be shifted to preserve them

		 * when discarding page cache below.

 Wait for existing dio to complete. */

		/*

		 * Normal file: Allocate clusters, do not change 'valid' size.

			/*

			 * Allocate but do not zero new clusters. (see below comments)

			 * This breaks security: One can read unused on-disk areas.

			 * Zeroing these clusters may be too long.

			 * Maybe we should check here for root rights?

				/*

				 * Unwritten area.

				 * NTFS is not able to store several unwritten areas.

				 * Activate 'ntfs_sparse_cluster' to zero new allocated clusters.

				 *

				 * Dangerous in case:

				 * 1G of sparsed clusters + 1 cluster of data =>

				 * valid_size == 1G + 1 cluster

				 * fallocate(1G) will zero 1G and this can be very long

				 * xfstest 016/086 will fail without 'ntfs_sparse_cluster'.

 True - Keep preallocated. */

/*

 * ntfs3_setattr - inode_operations::setattr

 "No access rules" - Force any changes of time etc. */

 and disable for editing some attributes. */

 Should never be here, see ntfs_file_open(). */

 Linux 'w' -> Windows 'ro'. */

/*

 * ntfs_get_frame_pages

 *

 * Return: Array of locked pages.

/*

 * ntfs_compress_write - Helper for ntfs_file_write_iter() (compressed files).

		/*

		 * frame_size == 8K if cluster 512

		 * frame_size == 64K if cluster 4096

 Zero range [valid : pos). */

 Load full frame. */

 Copy user data [pos : pos + count). */

 Load full frame. */

 Copy user data to pages. */

		/*

		 * We can loop for a long time in here. Be nice and allow

		 * us to schedule out to avoid softlocking if preempt

		 * is disabled.

/*

 * ntfs_file_write_iter - file_operations::write_iter

 Should never be here, see ntfs_file_open(). */

/*

 * ntfs_file_open - file_operations::open

 Decompress "external compressed" file if opened for rw. */

/*

 * ntfs_file_release - file_operations::release

 If we are last writer on the inode, drop the block reservation. */

/*

 * ntfs_fiemap - file_operations::fiemap

 clang-format off

 clang-format on

 SPDX-License-Identifier: GPL-2.0

/*

 *

 * Copyright (C) 2019-2021 Paragon Software GmbH, All rights reserved.

 *

 * This code builds two trees of free clusters extents.

 * Trees are sorted by start of extent and by length of extent.

 * NTFS_MAX_WND_EXTENTS defines the maximum number of elements in trees.

 * In extreme case code reads on-disk bitmap to find free clusters.

 *

/*

 * Maximum number of extents in tree.

 Tree sorted by start. */

 Tree sorted by len. */

/*

 * wnd_scan

 *

 * b_pos + b_len - biggest fragment.

 * Scan range [wpos wbits) window @buf.

 *

 * Return: -1 if not found.

		/*

		 * Now we have a fragment [wpos, wend) staring with 0.

/*

 * wnd_close - Frees all resources.

/*

 * rb_insert_count - Helper function to insert special kind of 'count' tree.

/*

 * rb_insert_start - Helper function to insert special kind of 'count' tree.

/*

 * wnd_add_free_ext - Adds a new extent of free space.

 * @build:	1 when building tree.

 Use extent_min to filter too short extents. */

 Try to find extent before 'bit'. */

 Remove left. */

 Remove right. */

 Check bits before 'bit'. */

 Check bits after 'end_in'. */

 Insert new fragment. */

 Compare with smallest fragment. */

 Do not insert small fragments. */

 Smallest fragment will be 'e2->count.key'. */

 Replace smallest fragment by new one. */

/*

 * wnd_remove_free_ext - Remove a run from the cached free space.

 Try to find extent before 'bit'. */

 Range [bit,end_in) must be inside 'e' or outside 'e' and 'n'. */

 Range [bit,end_in) inside 'e'. */

 Get minimal extent. */

 Replace minimum. */

/*

 * wnd_rescan - Scan all bitmap. Used while initialization.

 All ones. */

 All zeroes. */

 No free blocks. */

 Keep last free block. */

 Skip free block and first '1'. */

 Reset previous tail. */

 Add last block. */

	/*

	 * Before init cycle wnd->uptodated was 0.

	 * If any errors or limits occurs while initialization then

	 * wnd->uptodated will be -1.

	 * If 'uptodated' is still 0 then Tree is really updated.

/*

 * wnd_map - Call sb_bread for requested window.

/*

 * wnd_set_free - Mark the bits range from bit to bit + bits as free.

/*

 * wnd_set_used - Mark the bits range from bit to bit + bits as used.

/*

 * wnd_is_free_hlp

 *

 * Return: True if all clusters [bit, bit+bits) are free (bitmap only).

/*

 * wnd_is_free

 *

 * Return: True if all clusters [bit, bit+bits) are free.

/*

 * wnd_is_used

 *

 * Return: True if all clusters [bit, bit+bits) are used.

/*

 * wnd_find - Look for free space.

 *

 * - flags - BITMAP_FIND_XXX flags

 *

 * Return: 0 if not found.

 Fast checking for available free space. */

 Extents tree is updated -> No free space. */

 Use hint: Enumerate extents by start >= hint. */

 We have found extension with 'hint' inside. */

 Allocate from biggest free extent. */

 Biggest free block is less then requested. */

 Check if we can use more bits. */

 Prepare to return. */

 Extents tree is updated -> no free space. */

 At most two ranges [hint, max_alloc) + [0, hint). */

 TODO: Optimize request for case nbits > wbits. */

 Enumerate all windows. */

 Skip full used window. */

 Here we have a window [wbit, ebit) and zone [zbit, zend). */

 Zone does not overlap window. */

 Zone overlaps window. */

 Scan two ranges window: [wbit, zbit) and [zend, ebit). */

 TODO: Error */

 Scan range [wbit, zbit). */

 Scan range [wpos, zbit). */

 Scan range [zend, ebit). */

 Current window does not overlap zone. */

 Window is empty. */

 Increase 'prev_tail' and process next window. */

 Read window. */

 TODO: Error.

 Scan range [wpos, eBits). */

 The last fragment. */

		/*

		 * We have scanned range [hint max_alloc).

		 * Prepare to scan range [0 hint + to_alloc).

 TODO: Optimize remove extent (pass 'e'?). */

/*

 * wnd_extend - Extend bitmap ($MFT bitmap).

 Align to 8 byte boundary. */

 Zero bits [old_bits,new_bits). */

 err = sync_dirty_buffer(bh); */

 Process the last fragment. */

 SPDX-License-Identifier: GPL-2.0

/*

 *

 * Copyright (C) 2019-2021 Paragon Software GmbH, All rights reserved.

 *

/*

 * LOG FILE structs

 clang-format off

 'RSTR'

 0x10: Page size of the system which initialized the log.

 0x14: Log page size used for this log file.

 0x18:

 0x1A:

 0x1C:

 0x08:

 0x10:

 0x12:

 0x14:

 0x16:

 0x1C: In bytes.

 0x20: Name of client.

 Two copies of these will exist at the beginning of the log file */

 0x00: Current logical end of log file.

 0x08: Maximum number of clients.

 0x0A: Free/use index into the client record arrays.

 0x0E: See RESTART_SINGLE_PAGE_IO.

 0x10: The number of bits in sequence number.

 0x14:

 0x16:

 0x18: Usable log file size.

 0x20:

 0x24: Log page data offset.

 0x26: Log page data length.

 0x28:

 0x2C:

 0x40:

 0x00:  NTFS_LOG_OPERATION

 0x02:  NTFS_LOG_OPERATION

 0x04:  Offset to Redo record.

 0x06:  Redo length.

 0x08:  Offset to Undo record.

 0x0A:  Undo length.

 0x0C:

 0x0E:

 0x10:

 0x12:

 0x14:

 0x16:

 0x18:

 0x20:

 0x00: In bytes

 0x02: Entries

 0x04: Entries

 0x06:

 0x0C:

 0x10:

 0x14:

 Offset in the Open attribute Table.

 0x00: RESTART_ENTRY_ALLOCATED if allocated

 0x04:

 0x08:

 0x0C:

 0x0B: Faked field to manage 'ptr'

 0x0C: Faked field to manage 'ptr'

 0x10: File Reference of file containing attribute

 0x18:

 0x20:

 32 bit version of 'struct OPEN_ATTR_ENRTY' */

 0x00: RESTART_ENTRY_ALLOCATED if allocated

 0x04:

 0x08:

 0x10:

 0x18:

 0x19:

 0x1C:

 0x20: In wchar

 0x24:

 0x28:

 static_assert( 0x2C == sizeof(struct OPEN_ATTR_ENRTY_32) );

/*

 * One entry exists in the Dirty Pages Table for each page which is dirty at

 * the time the Restart Area is written.

 0x00: RESTART_ENTRY_ALLOCATED if allocated

 0x04: Index into the Open attribute Table

 0x08:

 0x0C:

 0x10: Vcn of dirty page

 0x18:

 0x20:

 32 bit version of 'struct DIR_PAGE_ENTRY' */

 0x00: RESTART_ENTRY_ALLOCATED if allocated

 0x04: Index into the Open attribute Table

 0x08:

 0x0C:

 0x10:

 0x14: Vcn of dirty page

 0x18: Vcn of dirty page

 0x1C:

 0x1C:

 0x24:

 0x24:

 0x00: RESTART_ENTRY_ALLOCATED if allocated

 0x04:

 0x05:

 0x08:

 0x10:

 0x18:

 0x20: Number of undo log records pending abort

 0x24: Total undo size

 0x00:

 0x04:

 0x08:

 0x10:

 0x18:

 0x20:

 0x28:

 0x30: In bytes

 0x34: In bytes

 0x38: In bytes

 0x3C: In bytes

 The following type defines the different log record types. */

 This is used to uniquely identify a client for a particular log file. */

 This is the header that begins every Log Record in the log file. */

 0x00:

 0x08:

 0x10:

 0x18:

 0x1C: Owner of this log record.

 0x20: LfsClientRecord or LfsClientRestart.

 0x24:

 0x28: LOG_RECORD_MULTI_PAGE

 0x2A:

 0x00: Offset of the free space in the page,

 0x02:

 0x08: lsn for the last log record which ends on the page,

 'RCRD'

 0x10: See LOG_PAGE_LOG_RECORD_END

 0x14:

 0x16:

 0x18:

 0x28:

 0x3c: Used when major version >= 2

 clang-format on

 Page contains the end of a log record.

/*

 * END of NTFS LOG structures

 Define some tuning parameters to keep the restart tables a reasonable size. */

 NtOfsRestartUpdateRelativeDataInIndex

/*

 * Array for log records which require a target attribute.

 * A true indicates that the corresponding restart operation

 * requires a target attribute.

 Bytes per restart table. */

 Log record length. */

 Log record header of the current lsn.

 lcb_ctx_undo_next/lcb_ctx_prev/lcb_ctx_next

 If true the we should deallocate 'log_rec'.

 Find the oldest lsn from active clients. */

 Ignore this block if it's oldest lsn is 0. */

 Check that if the file offset isn't 0, it is the system page size. */

 Check support version 1.1+. */

	/*

	 * Check the restart length field and whether the entire

	 * restart area is contained that length.

	/*

	 * As a final check make sure that the use list and the free list

	 * are either empty or point to a valid client.

 Make sure the sequence number bits match the log file size. */

 The log page data offset and record header length must be quad-aligned. */

 Find the start of the client array. */

	/*

	 * Start with the free list.

	 * Check that all the clients are valid and that there isn't a cycle.

	 * Do the in-use list on the second pass.

/*

 * remove_client

 *

 * Remove a client record from a client record list an restart area.

/*

 * add_client - Add a client record to the start of a list.

 Loop until we hit the first one allocated, or the end of the list. */

/*

 * find_dp - Search for a @vcn in Dirty Page Table.

 Round the file size down to a system page boundary. */

 File should contain at least 2 restart pages and MinLogRecordPages pages. */

	/*

	 * Verify each entry is either allocated or points

	 * to a valid offset the table.

	/*

	 * Walk through the list headed by the first entry to make

	 * sure none of the entries are currently being used.

/*

 * free_rsttbl_idx - Free a previously allocated index a Restart Table.

/*

 * alloc_rsttbl_idx

 *

 * Allocate an index from within a previously initialized Restart Table.

 Dequeue this entry and zero it. */

 If list is going empty, then we fix the last_free as well. */

/*

 * alloc_rsttbl_from_idx

 *

 * Allocate a specific index from within a previously initialized Restart Table.

 If the entry is not the table, we will have to extend the table. */

		/*

		 * Extend the size by computing the number of entries between

		 * the existing size and the desired index and adding 1 to that.

		/*

		 * There should always be an integral number of entries

		 * being added. Now extend the table.

 See if the entry is already allocated, and just return if it is. */

	/*

	 * Walk through the table, looking for the entry we're

	 * interested and the previous entry.

 this is a match */

	/*

	 * Need to walk through the list looking for the predecessor

	 * of our entry.

 Remember the entry just found */

 Should never run of entries. */

 Lookup up the next entry the list. */

 If this is our match we are done. */

			/*

			 * If this was the last entry, we update that

			 * table as well.

 If the list is now empty, we fix the last_free as well. */

 Zero this entry. */

 Helper struct to work with NTFS $LogFile. */

 page_size - 1

 (1 << file_data_bits) - 1 */

 In-memory image of the next restart area. */

 The usable size of the restart area. */

	/*

	 * If true, then the in-memory restart area is to be written

	 * to the first position on the disk.

 True if we need to set dirty flag. */

 See NTFSLOG_XXX */

 On-disk value for open_log_count. */

 Compute the offset in the log file of the next log page. */

 Check that the update sequence array for this page is valid */

 If we don't allow errors, raise an error status */

/*

 * log_read_rst

 *

 * It walks through 512 blocks of the file looking for a valid

 * restart page header. It will stop the first time we find a

 * valid page header.

 Determine which restart area we are looking for. */

 Loop continuously until we succeed. */

 Read a page header at the current offset. */

 Ignore any errors. */

 Exit if the signature is a log record page. */

				/*

				 * Remember if the signature does not

				 * indicate uninitialized file.

 Let's check the restart area if this is a valid page. */

		/*

		 * We have a valid restart page header and restart area.

		 * If chkdsk was run or we have no clients then we have

		 * no more checking to do.

 Read the entire restart area. */

 Ignore any errors. */

		/*

		 * If chkdsk was run then update the caller's

		 * values and return.

		/*

		 * If we have a valid page then copy the values

		 * we need from it.

/*

 * Ilog_init_pg_hdr - Init @log from restart page header.

/*

 * log_create - Init @log in cases when we don't have a restart area to use.

 All file offsets must be quadword aligned. */

 Set the correct flags for the I/O and indicate if we have wrapped. */

 Compute the log page values. */

 Remember the different page sizes for reservation. */

 Compute the restart page values. */

	/*

	 * The total available log file space is the number of

	 * log file pages times the space available on each page.

	/*

	 * We assume that we can't use the end of the page less than

	 * the file record size.

	 * Then we won't need to reserve more than the caller asks for.

/*

 * log_create_ra - Fill a restart area from the values stored in @log.

 Add the length of the header. */

	/*

	 * If this lsn is contained this log page we are done.

	 * Otherwise we need to walk through several log pages.

			/*

			 * We are done if the remaining bytes

			 * fit on this page.

	/*

	 * We add the remaining bytes to our starting position on this page

	 * and then add that value to the file offset of this log page.

 Remember if we wrapped. */

 Log page header for this page. */

	/*

	 * If the lsn we were given was not the last lsn on this page,

	 * then the starting offset for the next lsn is on a quad word

	 * boundary following the last file offset for the current lsn.

	 * Otherwise the file offset is the start of the data on the next page.

 If we wrapped, we need to increment the sequence number. */

 Compute the lsn based on the file offset and the sequence count. */

	/*

	 * If this lsn is within the legal range for the file, we return true.

	 * Otherwise false indicates that there are no more lsn's.

/*

 * current_log_avail - Calculate the number of bytes available for log records.

 The entire file is available. */

	/*

	 * If there is a last lsn the restart area then we know that we will

	 * have to compute the free range.

	 * If there is no oldest lsn then start at the first page of the file.

	/*

	 * We will use the next log page offset to compute the next free page.

	 * If we are going to reuse this page go to the next page.

	 * If we are at the first page then use the end of the file.

 If the two offsets are the same then there is no available space. */

	/*

	 * If the free offset follows the oldest offset then subtract

	 * this range from the total available pages.

	/*

	 * If the last lsn on the page occurs was written after the page

	 * that caused the original error then we have a fatal error.

	/*

	 * If the sequence number for the lsn the page is equal or greater

	 * than lsn we expect, then this is a subsequent write.

/*

 * last_log_lsn

 *

 * Walks through the log pages for a file, searching for the

 * last log page written to the file.

 0x10 == 0x12 - 0x2

 Read second tail page (at pos 3/0x12000). */

 Read first tail page (at pos 2/0x2000). */

 Read the next log page. */

 Compute the next log page offset the file. */

	/*

	 * If we are at the expected first page of a transfer check to see

	 * if either tail copy is at this offset.

	 * If this page is the last page of a transfer, check if we wrote

	 * a subsequent tail copy.

		/*

		 * Check if the offset matches either the first or second

		 * tail copy. It is possible it will match both.

		/*

		 * If we already matched on the first page then

		 * check the ending lsn's.

 We have a candidate for a tail copy. */

			/*

			 * If the sequence number is not expected,

			 * then don't use the tail copy.

			/*

			 * If the last lsn is greater than the one on

			 * this page then forget this tail.

	/*

	 *If we have an error on the current page,

	 * we will break of this loop.

	/*

	 * Done if the last lsn on this page doesn't match the previous known

	 * last lsn or the sequence number is not expected.

	/*

	 * Check that the page position and page count values are correct.

	 * If this is the first page of a transfer the position must be 1

	 * and the count will be unknown.

			/*

			 * If the current page is the first page we are

			 * looking at and we are reusing this page then

			 * it can be either the first or last page of a

			 * transfer. Otherwise it can only be the first.

		/*

		 * The page position better be 1 more than the last page

		 * position and the page count better match.

	/*

	 * We have a valid page the file and may have a valid page

	 * the tail copy area.

	 * If the tail page was written after the page the file then

	 * break of the loop.

 Remember if we will replace the page. */

		/*

		 * Since we have read this page we know the sequence number

		 * is the same as our expected value.

		/*

		 * If there is room on this page for another header then

		 * remember we want to reuse the page.

 Remember if we wrapped the log file. */

	/*

	 * Remember the last page count and position.

	 * Also remember the last known lsn.

 Remember that the partial IO will start at the next page. */

	/*

	 * If the next page is the first page of the file then update

	 * the sequence number for log records which begon the next page.

	/*

	 * If we have a tail copy or are performing single page I/O we can

	 * immediately look at the next page.

	/*

	 * If the next page causes us to wrap to the beginning of the log

	 * file then we know which page to check next.

 Walk through the file, reading log pages. */

	/*

	 * If we get a USA error then assume that we correctly found

	 * the end of the original transfer.

	/*

	 * If we were able to read the page, we examine it to see if it

	 * is the same or different Io block.

 Skip over the remaining pages this transfer. */

 Call our routine to check this log page. */

 We have a valid file. */

			/*

			 * Correct page and copy the data from this page

			 * into it and flush it to disk.

 Fill last flushed lsn value flush the page. */

/*

 * read_log_rec_buf - Copy a log record from the file to a buffer.

 *

 * The log record may span several log pages and may even wrap the file.

	/*

	 * While there are more bytes to transfer,

	 * we continue to attempt to perform the read.

		/*

		 * The last lsn on this page better be greater or equal

		 * to the lsn we are copying.

 If there are no more bytes to transfer, we exit the loop. */

		/*

		 * Adjust our pointer the user's buffer to transfer

		 * the next block to.

 If the client doesn't have a restart area, go ahead and exit now. */

 If the lsn values don't match, then the disk is corrupt. */

 Copy the data into the 'rst' buffer. */

 Read the record header for this lsn. */

	/*

	 * If the lsn the log record doesn't match the desired

	 * lsn then the disk is corrupt.

	/*

	 * Check that the length field isn't greater than the total

	 * available space the log file.

	/*

	 * If the entire log record is on this log page,

	 * put a pointer to the log record the context block.

 Copy the data into the buffer returned. */

 If beyond the end of the current page -> an error. */

/*

 * read_log_rec_lcb - Init the query operation.

 Check that the given lsn is the legal range for this client. */

 Find the log record indicated by the given lsn. */

/*

 * find_client_next_lsn

 *

 * Attempt to find the next lsn to return to a client based on the context mode.

 Loop as long as another lsn can be found. */

err = -EINVAL; */

 Check the fixed part of the attribute record header. */

 Check the attribute fields. */

 Check the file record header for consistency. */

 Loop to check all of the attributes. */

 CLST rno;

/*

 * cmp_type_and_name

 *

 * Return: 0 if 'attr' has the same type and name.

/*

 * do_action - Common routine for the Redo and Undo Passes.

 * @rlsn: If it is NULL then undo.

 Big switch to prepare. */

	/* ============================================================

	 * Process MFT records, as described by the current log record.

	 * ============================================================

 Read from disk. */

	/*

	 * Process attributes, as described by the current log record.

 align

 Big switch to do operation. */

 run_close(oa2->run1);

 To skip below memmove().

 run_close(&oa2->run0);



/*

 * log_replay - Replays log and empties it.

 *

 * This function is called during mount operation.

 * It replays log and empties it.

 * Initialized is set false if logfile contains '-1'.

 Get the size of page. NOTE: To replay we can use default page. */

 Look for a restart area on the disk. */

 remember 'initialized' */

 No restart area but the file is not initialized. */

	/*

	 * If the restart offset above wasn't zero then we won't

	 * look for a second restart.

 Determine which restart area to use. */

	/*

	 * If the restart area is at offset 0, we want

	 * to write the second restart area first.

 If we have a valid page then grab a pointer to the restart area. */

 Do some checks based on whether we have a valid log page. */

		/*

		 * If the restart page size isn't changing then we want to

		 * check how much work we need to do.

		/* Put the restart areas and initialize

		 * the log file as required.

	/*

	 * If the log page or the system page sizes have changed, we can't

	 * use the log file. We must use the system page size instead of the

	 * default size if there is not a clean shutdown.

 If the file size has shrunk then we won't mount it. */

 This is a pseudo lsn. */

 Find the end of this log record. */

 If we wrapped the file then increment the sequence number. */

 Now compute the next log page to use. */

	/*

	 *If we can fit another log record on the page,

	 * move back a page the log file.

	/*

	 * Find the oldest client lsn. Use the last

	 * flushed lsn as a starting point.

 Now we need to walk through looking for the last lsn. */

 Remember which restart area to write first. */

 1.0, 1.1, 2.0 log->major_ver/minor_ver - short values. */

 One client "NTFS" per logfile. */

 Insert "NTFS" client LogFile. */

 Update the client handle with the client block information. */

 Allocate and Read the Transaction Table. */

 Now check that this is a valid restart table. */

 The next record back should be the Dirty Pages Table. */

 Now check that this is a valid restart table. */

 Convert Ra version '0' into version '1'. */

 NOTE: Danger. Check for of boundary.

	/*

	 * Go through the table and remove the duplicates,

	 * remembering the oldest lsn values.

 The next record should be the Attribute Names. */

 The next record should be the attribute Table. */

 Clear all of the Attr pointers. */

 Really 'oe' points to OPEN_ATTR_ENRTY_32. */

 TODO: Clear table on exit! */

	/*

	 * If the checkpt_lsn is zero, then this is a freshly

	 * formatted disk and we have no work to do.

 Start the analysis pass from the Checkpoint lsn. */

 Read the first lsn. */

 Loop to read all subsequent records to the end of the log file. */

	/*

	 * The first lsn after the previous lsn remembered

	 * the checkpoint is the first candidate for the rlsn.

	/*

	 * Now update the Transaction Table for this transaction. If there

	 * is no entry present or it is unallocated we allocate the entry.

	/*

	 * If this is a compensation log record, then change

	 * the undo_next_lsn to be the undo_next_lsn of this record.

 Dispatch to handle log record depending on type. */

		/*

		 * Calculate the number of clusters per page the system

		 * which wrote the checkpoint, possibly creating the table.

		/*

		 * Copy the Lcns from the log record into the Dirty Page Entry.

		 * TODO: For different page size support, must somehow make

		 * whole routine a loop, case Lcns do not fit below.

 Loop through all of the Lcn ranges this log record. */

			/*

			 * Compute how big the table needs to be.

			 * Add 10 extra entries for some cushion.

 Point to the entry being opened. */

 Initialize this entry from the log record. */

 Convert version '0' into version '1'. */

oe0.name_len;

 The following cases require no action the Analysis Pass. */

		/*

		 * All codes will be explicitly handled.

		 * If we see a code we do not expect, then we are trouble.

	/*

	 * Scan the Dirty Page Table and Transaction Table for

	 * the lowest lsn, and return it as the Redo lsn.

	/*

	 * Only proceed if the Dirty Page Table or Transaction

	 * table are not empty.

 Reopen all of the attributes with dirty pages. */

	/*

	 * Now loop through the dirty page table to extract all of the Vcn/Lcn.

	 * Mapping that we have, and insert it into the appropriate run.

	/*

	 * Perform the Redo Pass, to restore all of the dirty pages to the same

	 * contents that they had immediately before the crash. If the dirty

	 * page table is empty, then we can skip the entire Redo Pass.

	/*

	 * Read the record at the Redo lsn, before falling

	 * into common code to handle each record.

	/*

	 * Now loop to read all of our log records forwards, until

	 * we hit the end of the file, cleaning up at the end.

 Ignore log records that do not update pages. */

 Point to the Redo data and get its length. */

 Shorten length by any Lcns which were deleted. */

 If the Vcn question is allocated, we can just get out. */

		/*

		 * Calculate the allocated space left relative to the

		 * log record Vcn, after removing this unallocated Vcn.

		/*

		 * If the update described this log record goes beyond

		 * the allocated space, then we will have to reduce the length.

	/*

	 * If the resulting dlen from above is now zero,

	 * we can skip this log record.

 Apply the Redo operation a common routine. */

 Keep reading and looping back until end of file. */

 Scan Transaction Table. */

	/*

	 * We only have to do anything if the transaction has

	 * something its undo_next_lsn field.

 Read the first record to be undone by this transaction. */

	/*

	 * Now loop to read all of our log records forwards,

	 * until we hit the end of the file, cleaning up at the end.

	/*

	 * If the mapping isn't already the table or the  mapping

	 * corresponds to a hole the mapping, we need to make sure

	 * there is no partial page already memory.

 Point to the Redo data and get its length. */

 It is time to apply the undo action. */

	/*

	 * Keep reading and looping back until we have read the

	 * last record for this transaction.

 0x1A:

 0x1C:

	/*

	 * Scan the Open Attribute Table to close all of

	 * the open attributes.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * lzx_decompress.c - A decompressor for the LZX compression format, which can

 * be used in "System Compressed" files.  This is based on the code from wimlib.

 * This code only supports a window size (dictionary size) of 32768 bytes, since

 * this is the only size used in System Compression.

 *

 * Copyright (C) 2015 Eric Biggers

 Number of literal byte values  */

 The smallest and largest allowed match lengths  */

 Number of distinct match lengths that can be represented  */

 Number of match lengths for which no length symbol is required  */

 Valid values of the 3-bit block type field  */

 Number of offset slots for a window size of 32768  */

 Number of symbols in the main code for a window size of 32768  */

 Number of symbols in the length code  */

 Number of symbols in the precode  */

 Number of bits in which each precode codeword length is represented  */

/* Number of low-order bits of each match offset that are entropy-encoded in

 * aligned offset blocks

 Number of symbols in the aligned offset code  */

/* Mask for the match offset bits that are entropy-encoded in aligned offset

 * blocks

 Number of bits in which each aligned offset codeword length is represented  */

 Maximum lengths (in bits) of the codewords in each Huffman code  */

/* The default "filesize" value used in pre/post-processing.  In the LZX format

 * used in cabinet files this value must be given to the decompressor, whereas

 * in the LZX format used in WIM files and system-compressed files this value is

 * fixed at 12000000.

 Assumed block size when the encoded block size begins with a 0 bit.  */

 Number of offsets in the recent (or "repeat") offsets queue.  */

 These values are chosen for fast decompression.  */

/* Mapping: offset slot => first match offset that uses that offset slot.

 0  --- 4  */

 5  --- 9  */

 10 --- 14 */

 15 --- 19 */

 20 --- 24 */

 25 --- 29 */

 extra     */

/* Mapping: offset slot => how many extra bits must be read and added to the

 * corresponding offset slot base to decode the match offset.

 Reusable heap-allocated memory for LZX decompression  */

	/* Huffman decoding tables, and arrays that map symbols to codeword

	 * lengths

 Temporary space for make_huffman_decode_table()  */

 "good translation" */

 "compensating translation" */

/*

 * Undo the 'E8' preprocessing used in LZX.  Before compression, the

 * uncompressed data was preprocessed by changing the targets of suspected x86

 * CALL instructions from relative offsets to absolute offsets.  After

 * match/literal decoding, the decompressor must undo the translation.

	/*

	 * A worthwhile optimization is to push the end-of-buffer check into the

	 * relatively rare E8 case.  This is possible if we replace the last six

	 * bytes of data with E8 bytes; then we are guaranteed to hit an E8 byte

	 * before reaching end-of-buffer.  In addition, this scheme guarantees

	 * that no translation can begin following an E8 byte in the last 10

	 * bytes because a 4-byte offset containing E8 as its high byte is a

	 * large negative number that is not valid for translation.  That is

	 * exactly what we need.

 Read a Huffman-encoded symbol using the precode.  */

 Read a Huffman-encoded symbol using the main code.  */

 Read a Huffman-encoded symbol using the length code.  */

 Read a Huffman-encoded symbol using the aligned offset code.  */

/*

 * Read the precode from the compressed input bitstream, then use it to decode

 * @num_lens codeword length values.

 *

 * @is:		The input bitstream.

 *

 * @lens:	An array that contains the length values from the previous time

 *		the codeword lengths for this Huffman code were read, or all 0's

 *		if this is the first time.  This array must have at least

 *		(@num_lens + LZX_READ_LENS_MAX_OVERRUN) entries.

 *

 * @num_lens:	Number of length values to decode.

 *

 * Returns 0 on success, or -1 if the data was invalid.

	/* Read the lengths of the precode codewords.  These are given

	 * explicitly.

 Make the decoding table for the precode.  */

 Decode the codeword lengths.  */

 Read the next precode symbol.  */

 Difference from old length  */

 Special RLE values  */

 Run of 0's  */

 Longer run of 0's  */

 Run of identical lengths  */

			/* Worst case overrun is when presym == 18,

			 * run_len == 20 + 31, and only 1 length was remaining.

			 * So LZX_READ_LENS_MAX_OVERRUN == 50.

			 *

			 * Overrun while reading the first half of maincode_lens

			 * can corrupt the previous values in the second half.

			 * This doesn't really matter because the resulting

			 * lengths will still be in range, and data that

			 * generates overruns is invalid anyway.

/*

 * Read the header of an LZX block and save the block type and (uncompressed)

 * size in *block_type_ret and *block_size_ret, respectively.

 *

 * If the block is compressed, also update the Huffman decode @tables with the

 * new Huffman codes.  If the block is uncompressed, also update the match

 * offset @queue with the new match offsets.

 *

 * Return 0 on success, or -1 if the data was invalid.

	/* The first three bits tell us what kind of block it is, and should be

	 * one of the LZX_BLOCKTYPE_* values.

 Read the block size.  */

		/* Read the aligned offset code and prepare its decode table.

		/* Fall though, since the rest of the header for aligned offset

		 * blocks is the same as that for verbatim blocks.

		/* Read the main code and prepare its decode table.

		 *

		 * Note that the codeword lengths in the main code are encoded

		 * in two parts: one part for literal symbols, and one part for

		 * match symbols.

 Read the length code and prepare its decode table.  */

		/* Before reading the three recent offsets from the uncompressed

		 * block header, the stream must be aligned on a 16-bit

		 * boundary.  But if the stream is *already* aligned, then the

		 * next 16 bits must be discarded.

 Offsets of 0 are invalid.  */

 Unrecognized block type.  */

 Decompress a block of LZX-compressed data.  */

 Literal  */

 Match  */

 Decode the length header and offset slot.  */

 If needed, read a length symbol to decode the full length. */

 Repeat offset  */

			/* Note: This isn't a real LRU queue, since using the R2

			 * offset doesn't bump the R1 offset down to R2.  This

			 * quirk allows all 3 recent offsets to be handled by

			 * the same code.  (For R0, the swap is a no-op.)

 Explicit offset  */

			/* Look up the number of extra bits that need to be read

			 * to decode offsets with this offset slot.

 Start with the offset slot base value.  */

			/* In aligned offset blocks, the low-order 3 bits of

			 * each offset are encoded using the aligned offset

			 * code.  Otherwise, all the extra bits are literal.

 Adjust the offset.  */

 Update the recent offsets.  */

 Validate the match, then copy it to the current position.  */

/*

 * lzx_allocate_decompressor - Allocate an LZX decompressor

 *

 * Return the pointer to the decompressor on success, or return NULL and set

 * errno on failure.

/*

 * lzx_decompress - Decompress a buffer of LZX-compressed data

 *

 * @decompressor:      A decompressor allocated with lzx_allocate_decompressor()

 * @compressed_data:	The buffer of data to decompress

 * @compressed_size:	Number of bytes of compressed data

 * @uncompressed_data:	The buffer in which to store the decompressed data

 * @uncompressed_size:	The number of bytes the data decompresses into

 *

 * Return 0 on success, or return -1 and set errno on failure.

 Codeword lengths begin as all 0's for delta encoding purposes.  */

 Decompress blocks until we have all the uncompressed data.  */

 Compressed block  */

 Uncompressed block  */

 Postprocess the data unless it cannot possibly contain 0xe8 bytes. */

/*

 * lzx_free_decompressor - Free an LZX decompressor

 *

 * @decompressor:       A decompressor that was allocated with

 *			lzx_allocate_decompressor(), or NULL.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * xpress_decompress.c - A decompressor for the XPRESS compression format

 * (Huffman variant), which can be used in "System Compressed" files.  This is

 * based on the code from wimlib.

 *

 * Copyright (C) 2015 Eric Biggers

 This value is chosen for fast decompression.  */

 Reusable heap-allocated memory for XPRESS decompression  */

 The Huffman decoding table  */

 An array that maps symbols to codeword lengths  */

 Temporary space for make_huffman_decode_table()  */

/*

 * xpress_allocate_decompressor - Allocate an XPRESS decompressor

 *

 * Return the pointer to the decompressor on success, or return NULL and set

 * errno on failure.

/*

 * xpress_decompress - Decompress a buffer of XPRESS-compressed data

 *

 * @decompressor:       A decompressor that was allocated with

 *			xpress_allocate_decompressor()

 * @compressed_data:	The buffer of data to decompress

 * @compressed_size:	Number of bytes of compressed data

 * @uncompressed_data:	The buffer in which to store the decompressed data

 * @uncompressed_size:	The number of bytes the data decompresses into

 *

 * Return 0 on success, or return -1 and set errno on failure.

 Read the Huffman codeword lengths.  */

 Build a decoding table for the Huffman code.  */

 Decode the matches and literals.  */

 Literal  */

 Match  */

/*

 * xpress_free_decompressor - Free an XPRESS decompressor

 *

 * @decompressor:       A decompressor that was allocated with

 *			xpress_allocate_decompressor(), or NULL.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * decompress_common.c - Code shared by the XPRESS and LZX decompressors

 *

 * Copyright (C) 2015 Eric Biggers

/*

 * make_huffman_decode_table() -

 *

 * Build a decoding table for a canonical prefix code, or "Huffman code".

 *

 * This is an internal function, not part of the library API!

 *

 * This takes as input the length of the codeword for each symbol in the

 * alphabet and produces as output a table that can be used for fast

 * decoding of prefix-encoded symbols using read_huffsym().

 *

 * Strictly speaking, a canonical prefix code might not be a Huffman

 * code.  But this algorithm will work either way; and in fact, since

 * Huffman codes are defined in terms of symbol frequencies, there is no

 * way for the decompressor to know whether the code is a true Huffman

 * code or not until all symbols have been decoded.

 *

 * Because the prefix code is assumed to be "canonical", it can be

 * reconstructed directly from the codeword lengths.  A prefix code is

 * canonical if and only if a longer codeword never lexicographically

 * precedes a shorter codeword, and the lexicographic ordering of

 * codewords of the same length is the same as the lexicographic ordering

 * of the corresponding symbols.  Consequently, we can sort the symbols

 * primarily by codeword length and secondarily by symbol value, then

 * reconstruct the prefix code by generating codewords lexicographically

 * in that order.

 *

 * This function does not, however, generate the prefix code explicitly.

 * Instead, it directly builds a table for decoding symbols using the

 * code.  The basic idea is this: given the next 'max_codeword_len' bits

 * in the input, we can look up the decoded symbol by indexing a table

 * containing 2**max_codeword_len entries.  A codeword with length

 * 'max_codeword_len' will have exactly one entry in this table, whereas

 * a codeword shorter than 'max_codeword_len' will have multiple entries

 * in this table.  Precisely, a codeword of length n will be represented

 * by 2**(max_codeword_len - n) entries in this table.  The 0-based index

 * of each such entry will contain the corresponding codeword as a prefix

 * when zero-padded on the left to 'max_codeword_len' binary digits.

 *

 * That's the basic idea, but we implement two optimizations regarding

 * the format of the decode table itself:

 *

 * - For many compression formats, the maximum codeword length is too

 *   long for it to be efficient to build the full decoding table

 *   whenever a new prefix code is used.  Instead, we can build the table

 *   using only 2**table_bits entries, where 'table_bits' is some number

 *   less than or equal to 'max_codeword_len'.  Then, only codewords of

 *   length 'table_bits' and shorter can be directly looked up.  For

 *   longer codewords, the direct lookup instead produces the root of a

 *   binary tree.  Using this tree, the decoder can do traditional

 *   bit-by-bit decoding of the remainder of the codeword.  Child nodes

 *   are allocated in extra entries at the end of the table; leaf nodes

 *   contain symbols.  Note that the long-codeword case is, in general,

 *   not performance critical, since in Huffman codes the most frequently

 *   used symbols are assigned the shortest codeword lengths.

 *

 * - When we decode a symbol using a direct lookup of the table, we still

 *   need to know its length so that the bitstream can be advanced by the

 *   appropriate number of bits.  The simple solution is to simply retain

 *   the 'lens' array and use the decoded symbol as an index into it.

 *   However, this requires two separate array accesses in the fast path.

 *   The optimization is to store the length directly in the decode

 *   table.  We use the bottom 11 bits for the symbol and the top 5 bits

 *   for the length.  In addition, to combine this optimization with the

 *   previous one, we introduce a special case where the top 2 bits of

 *   the length are both set if the entry is actually the root of a

 *   binary tree.

 *

 * @decode_table:

 *	The array in which to create the decoding table.  This must have

 *	a length of at least ((2**table_bits) + 2 * num_syms) entries.

 *

 * @num_syms:

 *	The number of symbols in the alphabet; also, the length of the

 *	'lens' array.  Must be less than or equal to 2048.

 *

 * @table_bits:

 *	The order of the decode table size, as explained above.  Must be

 *	less than or equal to 13.

 *

 * @lens:

 *	An array of length @num_syms, indexable by symbol, that gives the

 *	length of the codeword, in bits, for that symbol.  The length can

 *	be 0, which means that the symbol does not have a codeword

 *	assigned.

 *

 * @max_codeword_len:

 *	The longest codeword length allowed in the compression format.

 *	All entries in 'lens' must be less than or equal to this value.

 *	This must be less than or equal to 23.

 *

 * @working_space

 *	A temporary array of length '2 * (max_codeword_len + 1) +

 *	num_syms'.

 *

 * Returns 0 on success, or -1 if the lengths do not form a valid prefix

 * code.

	/* Count how many symbols have each possible codeword length.

	 * Note that a length of 0 indicates the corresponding symbol is not

	 * used in the code and therefore does not have a codeword.

	/* We can assume all lengths are <= max_codeword_len, but we

	 * cannot assume they form a valid prefix code.  A codeword of

	 * length n should require a proportion of the codespace equaling

	 * (1/2)^n.  The code is valid if and only if the codespace is

	 * exactly filled by the lengths, by this measure.

			/* The lengths overflow the codespace; that is, the code

			 * is over-subscribed.

		/* The lengths do not fill the codespace; that is, they form an

		 * incomplete set.

			/* The code is completely empty.  This is arguably

			 * invalid, but in fact it is valid in LZX and XPRESS,

			 * so we must allow it.  By definition, no symbols can

			 * be decoded with an empty code.  Consequently, we

			 * technically don't even need to fill in the decode

			 * table.  However, to avoid accessing uninitialized

			 * memory if the algorithm nevertheless attempts to

			 * decode symbols using such a code, we zero out the

			 * decode table.

	/* Sort the symbols primarily by length and secondarily by symbol order.

	/* Initialize 'offsets' so that offsets[len] for 1 <= len <=

	 * max_codeword_len is the number of codewords shorter than 'len' bits.

	/* Use the 'offsets' array to sort the symbols.  Note that we do not

	 * include symbols that are not used in the code.  Consequently, fewer

	 * than 'num_syms' entries in 'sorted_syms' may be filled.

	/* Fill entries for codewords with length <= table_bits

	 * --- that is, those short enough for a direct mapping.

	 *

	 * The table will start with entries for the shortest codeword(s), which

	 * have the most entries.  From there, the number of entries per

	 * codeword will decrease.

	/* If we've filled in the entire table, we are done.  Otherwise,

	 * there are codewords longer than table_bits for which we must

	 * generate binary trees.

		/* First, zero out the remaining entries.  This is

		 * necessary so that these entries appear as

		 * "unallocated" in the next part.  Each of these entries

		 * will eventually be filled with the representation of

		 * the root node of a binary tree.

		/* We allocate child nodes starting at the end of the

		 * direct lookup table.  Note that there should be

		 * 2*num_syms extra entries for this purpose, although

		 * fewer than this may actually be needed.

		/* Iterate through each codeword with length greater than

		 * 'table_bits', primarily in order of codeword length

		 * and secondarily in order of symbol.

				/* 'sorted_sym' is the symbol represented by the

				 * codeword.

				/* Go through each bit of the current codeword

				 * beyond the prefix of length @table_bits and

				 * walk the appropriate binary tree, allocating

				 * any slots that have not yet been allocated.

				 *

				 * Note that the 'pointer' entry to the binary

				 * tree, which is stored in the direct lookup

				 * portion of the table, is represented

				 * identically to other internal (non-leaf)

				 * nodes of the binary tree; it can be thought

				 * of as simply the root of the tree.  The

				 * representation of these internal nodes is

				 * simply the index of the left child combined

				 * with the special bits 0xC000 to distinguish

				 * the entry from direct mapping and leaf node

				 * entries.

					/* At least one bit remains in the

					 * codeword, but the current node is an

					 * unallocated leaf.  Change it to an

					 * internal node.

					/* Go to the left child if the next bit

					 * in the codeword is 0; otherwise go to

					 * the right child.

				/* We've traversed the tree using the entire

				 * codeword, and we're now at the entry where

				 * the actual symbol will be stored.  This is

				 * distinguished from internal nodes by not

				 * having its high two bits set.

 SPDX-License-Identifier: GPL-2.0

/*

 * (C) 2001 Clemson University and The University of Chicago

 *

 * See COPYING in top-level directory.

	/*

	 * Rather than incurring a network call just to determine the exact

	 * length of the attribute, I just allocate a max length to save on

	 * the network call. Conceivably, we could pass NULL to

	 * orangefs_inode_getxattr() to probe the length of the value, but

	 * I don't do that for now.

 if the key exists, convert it to an in-memory rep */

 kfree(NULL) is safe, so don't worry if value ever got used */

	/*

	 * Go ahead and set the extended attribute now. NOTE: Suppose acl

	 * was NULL, then value will be NULL and size will be 0 and that

	 * will xlate to a removexattr. However, we don't want removexattr

	 * complain if attributes does not exist.

		/*

		 * posix_acl_update_mode checks to see if the permissions

		 * described by the ACL can be encoded into the

		 * object's mode. If so, it sets "acl" to NULL

		 * and "mode" to the new desired value. It is up to

		 * us to propagate the new mode back to the server...

 If mode of the inode was changed, then do a forcible ->setattr */

 SPDX-License-Identifier: GPL-2.0

/*

 * What:		/sys/kernel/debug/orangefs/debug-help

 * Date:		June 2015

 * Contact:		Mike Marshall <hubcap@omnibond.com>

 * Description:

 * 			List of client and kernel debug keywords.

 *

 *

 * What:		/sys/kernel/debug/orangefs/client-debug

 * Date:		June 2015

 * Contact:		Mike Marshall <hubcap@omnibond.com>

 * Description:

 * 			Debug setting for "the client", the userspace

 * 			helper for the kernel module.

 *

 *

 * What:		/sys/kernel/debug/orangefs/kernel-debug

 * Date:		June 2015

 * Contact:		Mike Marshall <hubcap@omnibond.com>

 * Description:

 * 			Debug setting for the orangefs kernel module.

 *

 * 			Any of the keywords, or comma-separated lists

 * 			of keywords, from debug-help can be catted to

 * 			client-debug or kernel-debug.

 *

 * 			"none", "all" and "verbose" are special keywords

 * 			for client-debug. Setting client-debug to "all"

 * 			is kind of like trying to drink water from a

 * 			fire hose, "verbose" triggers most of the same

 * 			output except for the constant flow of output

 * 			from the main wait loop.

 *

 * 			"none" and "all" are similar settings for kernel-debug

 * 			no need for a "verbose".

/*

 * An array of client_debug_mask will be built to hold debug keyword/mask

 * values fetched from userspace.

/*

 * Used to protect data in ORANGEFS_KMOD_DEBUG_FILE and

 * ORANGEFS_KMOD_DEBUG_FILE.

 Used to protect data in ORANGEFS_KMOD_DEBUG_HELP_FILE */

/*

 * initialize kmod debug operations, create orangefs debugfs dir and

 * ORANGEFS_KMOD_DEBUG_HELP_FILE.

 convert input debug mask to a 64-bit unsigned integer */

	/*

	 * set the kernel's gossip debug string; invalid mask values will

	 * be ignored.

 remove any invalid values from the mask */

	/*

	 * if the mask has a non-zero value, then indicate that the mask

	 * was set when the kernel module was loaded.  The orangefs dev ioctl

	 * command will look at this boolean to determine if the kernel's

	 * debug mask should be overwritten when the client-core is started.

/*

 * initialize the kernel-debug file.

 open ORANGEFS_KMOD_DEBUG_HELP_FILE */

/*

 * I think start always gets called again after stop. Start

 * needs to return NULL when it is done. The whole "payload"

 * in this case is a single (long) string, so by the second

 * time we get to start (pos = 1), we're done.

/*

 * initialize the client-debug file.

 open ORANGEFS_KMOD_DEBUG_FILE or ORANGEFS_CLIENT_DEBUG_FILE.*/

	/*

	 * Thwart users who try to jamb a ridiculous number

	 * of bytes into the debug file...

	/*

	 * Map the keyword string from userspace into a valid debug mask.

	 * The mapping process involves mapping the human-inputted string

	 * into a valid mask, and then rebuilding the string from the

	 * verified valid mask.

	 *

	 * A service operation is required to set a new client-side

	 * debug mask.

 Can't reset client debug mask if client is not running. */

 service_operation returns 0 on success... */

/*

 * After obtaining a string representation of the client's debug

 * keywords and their associated masks, this function is called to build an

 * array of these values.

	/*

	 * figure out how many elements the cdm_array needs.

/*

 * /sys/kernel/debug/orangefs/debug-help can be catted to

 * see all the available kernel and client debug keywords.

 *

 * When orangefs.ko initializes, we have no idea what keywords the

 * client supports, nor their associated masks.

 *

 * We pass through this function once at module-load and stamp a

 * boilerplate "we don't know" message for the client in the

 * debug-help file. We pass through here again when the client

 * starts and then we can fill out the debug-help file fully.

 *

 * The client might be restarted any number of times between

 * module reloads, we only build the debug-help file the first time.

 build a new debug_help_string. */

	/*

	 * strlcat(dst, src, size) will append at most

	 * "size - strlen(dst) - 1" bytes of src onto dst,

	 * null terminating the result, and return the total

	 * length of the string it tried to create.

	 *

	 * We'll just plow through here building our new debug

	 * help string and let strlcat take care of assuring that

	 * dst doesn't overflow.

                /*

		 * fill the client keyword/mask array and remember

		 * how many elements there were.

 See if we tried to put too many bytes into "new"... */

/*

 * kernel = type 0

 * client = type 1

	/*

	 * Some keywords, like "all" or "verbose", are amalgams of

	 * numerous other keywords. Make a special check for those

	 * before grinding through the whole mask only to find out

	 * later...

 Build the debug string. */

/*

 * kernel = type 0

 * client = type 1

 *

 * return 1 if we found an amalgam.

/*

 * kernel = type 0

 * client = type 1

	/*

	 * The real client-core makes an effort to ensure

	 * that actual strings that aren't too long to fit in

	 * this buffer is what we get here. We're going to use

	 * string functions on the stuff we got, so we'll make

	 * this extra effort to try and keep from

	 * flowing out of this buffer when we use the string

	 * functions, even if somehow the stuff we end up

	 * with here is garbage.

 Build a proper debug help string. */

			/*

			 * the kernel debug mask was set when the

			 * kernel module was loaded; don't override

			 * it if the client-core was started without

			 * a value for ORANGEFS_KMODMASK.

 SPDX-License-Identifier: GPL-2.0

/*

 * (C) 2001 Clemson University and The University of Chicago

 *

 * See COPYING in top-level directory.

/*

 *  Linux VFS namei operations.

/*

 * Get a newly allocated inode to go with a negative dentry.

/*

 * Attempt to resolve an object name (dentry->d_name), parent handle, and

 * fsid into a handle for the object.

	/*

	 * in theory we could skip a lookup here (if the intent is to

	 * create) in order to avoid a potentially failed lookup, but

	 * leaving it in can skip a valid lookup and try to create a file

	 * that already exists (e.g. the vfs already handles checking for

	 * -EEXIST on O_EXCL opens, which is broken if we skip this lookup

	 * in the create path)

 must be a non-recoverable error */

 return 0 on success; non-zero otherwise */

	/*

	 * This is necessary because orangefs_inode_getattr will not

	 * re-read symlink size as it is impossible for it to change.

	 * Invalidating the cache does not help.  orangefs_new_inode

	 * does not set the correct size (it does not know symname).

	/*

	 * NOTE: we have no good way to keep nlink consistent for directories

	 * across clients; keep constant at 1.

 ORANGEFS implementation of VFS inode operations for directories */

 SPDX-License-Identifier: GPL-2.0

/*

 * (C) 2001 Clemson University and The University of Chicago

 *

 * See COPYING in top-level directory.

 a cache for orangefs-inode objects (i.e. orangefs inode private data) */

 list for storing orangefs specific superblocks in use */

	/*

	 * Force any potential flags that might be set from the mount

	 * to zero, ie, initialize to unset.

	/*

	 * We want to clear everything except for rw_semaphore and the

	 * vfs_inode.

/*

 * NOTE: information filled in here is typically reflected in the

 * output of the system command 'df'

/*

 * Remount as initiated by VFS layer.  We just need to reparse the mount

 * options, no need to signal pvfs2-client-core about it.

/*

 * Remount as initiated by pvfs2-client-core on restart.  This is used to

 * repopulate mount information left from previous pvfs2-client-core.

 *

 * the idea here is that given a valid superblock, we're

 * re-initializing the user space client with the initial mount

 * information specified when the super block was first initialized.

 * this is very different than the first initialization/creation of a

 * superblock.  we use the special service_priority_operation to make

 * sure that the mount gets ahead of any other pending operation that

 * is waiting for servicing.  this means that the pvfs2-client won't

 * fail to start several times for all other pending operations before

 * the client regains all of the mount information from us.

 * NOTE: this function assumes that the request_mutex is already acquired!

	/*

	 * we assume that the calling function has already acquired the

	 * request_mutex to prevent other operations from bypassing

	 * this one

		/*

		 * store the id assigned to this sb -- it's just a

		 * short-lived mapping that the system interface uses

		 * to map this superblock to a particular mount entry

 Not much to do about an error here. */

 Hang the xattr handlers off the superblock */

 allocates and places root dentry in dcache */

 alloc and init our private orangefs sb info */

	/*

	 * on successful mount, store the devname and data

	 * used

 mount_pending must be cleared */

	/*

	 * finally, add this sb to our list of known orangefs

	 * sb's

 Must be removed from the list now. */

 Will call orangefs_kill_sb with sb not in list. */

 ORANGEFS_VFS_OP_FS_UMOUNT is done by orangefs_kill_sb. */

 provided sb cleanup */

	/*

	 * issue the unmount to userspace to tell it to remove the

	 * dynamic mount info it has for this superblock

 remove the sb from our list of orangefs specific sb's */

 not list_del_init */

	/*

	 * make sure that ORANGEFS_DEV_REMOUNT_ALL loop that might've seen us

	 * gets completed before we free the dang thing.

 free the orangefs superblock private data */

 SPDX-License-Identifier: GPL-2.0

/*

 * Documentation/ABI/stable/sysfs-fs-orangefs:

 *

 * What:		/sys/fs/orangefs/perf_counter_reset

 * Date:		June 2015

 * Contact:		Mike Marshall <hubcap@omnibond.com>

 * Description:

 * 			echo a 0 or a 1 into perf_counter_reset to

 * 			reset all the counters in

 * 			/sys/fs/orangefs/perf_counters

 * 			except ones with PINT_PERF_PRESERVE set.

 *

 *

 * What:		/sys/fs/orangefs/perf_counters/...

 * Date:		Jun 2015

 * Contact:		Mike Marshall <hubcap@omnibond.com>

 * Description:

 * 			Counters and settings for various caches.

 * 			Read only.

 *

 *

 * What:		/sys/fs/orangefs/perf_time_interval_secs

 * Date:		Jun 2015

 * Contact:		Mike Marshall <hubcap@omnibond.com>

 * Description:

 *			Length of perf counter intervals in

 *			seconds.

 *

 *

 * What:		/sys/fs/orangefs/perf_history_size

 * Date:		Jun 2015

 * Contact:		Mike Marshall <hubcap@omnibond.com>

 * Description:

 * 			The perf_counters cache statistics have N, or

 * 			perf_history_size, samples. The default is

 * 			one.

 *

 *			Every perf_time_interval_secs the (first)

 *			samples are reset.

 *

 *			If N is greater than one, the "current" set

 *			of samples is reset, and the samples from the

 *			other N-1 intervals remain available.

 *

 *

 * What:		/sys/fs/orangefs/op_timeout_secs

 * Date:		Jun 2015

 * Contact:		Mike Marshall <hubcap@omnibond.com>

 * Description:

 *			Service operation timeout in seconds.

 *

 *

 * What:		/sys/fs/orangefs/slot_timeout_secs

 * Date:		Jun 2015

 * Contact:		Mike Marshall <hubcap@omnibond.com>

 * Description:

 *			"Slot" timeout in seconds. A "slot"

 *			is an indexed buffer in the shared

 *			memory segment used for communication

 *			between the kernel module and userspace.

 *			Slots are requested and waited for,

 *			the wait times out after slot_timeout_secs.

 *

 * What:		/sys/fs/orangefs/cache_timeout_msecs

 * Date:		Mar 2018

 * Contact:		Martin Brandenburg <martin@omnibond.com>

 * Description:

 *			Time in milliseconds between which

 *			orangefs_revalidate_mapping will invalidate the page

 *			cache.

 *

 * What:		/sys/fs/orangefs/dcache_timeout_msecs

 * Date:		Jul 2016

 * Contact:		Martin Brandenburg <martin@omnibond.com>

 * Description:

 *			Time lookup is valid in milliseconds.

 *

 * What:		/sys/fs/orangefs/getattr_timeout_msecs

 * Date:		Jul 2016

 * Contact:		Martin Brandenburg <martin@omnibond.com>

 * Description:

 *			Time getattr is valid in milliseconds.

 *

 * What:		/sys/fs/orangefs/readahead_count

 * Date:		Aug 2016

 * Contact:		Martin Brandenburg <martin@omnibond.com>

 * Description:

 *			Readahead cache buffer count.

 *

 * What:		/sys/fs/orangefs/readahead_size

 * Date:		Aug 2016

 * Contact:		Martin Brandenburg <martin@omnibond.com>

 * Description:

 *			Readahead cache buffer size.

 *

 * What:		/sys/fs/orangefs/readahead_count_size

 * Date:		Aug 2016

 * Contact:		Martin Brandenburg <martin@omnibond.com>

 * Description:

 *			Readahead cache buffer count and size.

 *

 * What:		/sys/fs/orangefs/readahead_readcnt

 * Date:		Jan 2017

 * Contact:		Martin Brandenburg <martin@omnibond.com>

 * Description:

 *			Number of buffers (in multiples of readahead_size)

 *			which can be read ahead for a single file at once.

 *

 * What:		/sys/fs/orangefs/acache/...

 * Date:		Jun 2015

 * Contact:		Martin Brandenburg <martin@omnibond.com>

 * Description:

 * 			Attribute cache configurable settings.

 *

 *

 * What:		/sys/fs/orangefs/ncache/...

 * Date:		Jun 2015

 * Contact:		Mike Marshall <hubcap@omnibond.com>

 * Description:

 * 			Name cache configurable settings.

 *

 *

 * What:		/sys/fs/orangefs/capcache/...

 * Date:		Jun 2015

 * Contact:		Mike Marshall <hubcap@omnibond.com>

 * Description:

 * 			Capability cache configurable settings.

 *

 *

 * What:		/sys/fs/orangefs/ccache/...

 * Date:		Jun 2015

 * Contact:		Mike Marshall <hubcap@omnibond.com>

 * Description:

 * 			Credential cache configurable settings.

 *

/*

 * Every item calls orangefs_attr_show and orangefs_attr_store through

 * orangefs_sysfs_ops. They look at the orangefs_attributes further below to

 * call one of sysfs_int_show, sysfs_int_store, sysfs_service_op_show, or

 * sysfs_service_op_store.

/*

 * obtain attribute values from userspace with a service operation.

 Can't do a service_operation if the client is not running... */

 Drop unsupported requests first. */

	/*

	 * The service_operation will return an errno return code on

	 * error, and zero on success.

/*

 * pass attribute values back to userspace with a service operation.

 *

 * We have to do a memory allocation, an sscanf and a service operation.

 * And we have to evaluate what the user entered, to make sure the

 * value is within the range supported by the attribute. So, there's

 * a lot of return code checking and mapping going on here.

 *

 * We want to return 1 if we think everything went OK, and

 * EINVAL if not.

 sic */

 Can't do a service_operation if the client is not running... */

	/*

	 * The value we want to send back to userspace is in buf, unless this

	 * there are two parameters, which is specially handled below.

 Drop unsupported requests first. */

	/*

	 * The service_operation will return a errno return code on

	 * error, and zero on success.

 create /sys/fs/orangefs. */

 create /sys/fs/orangefs/acache. */

 create /sys/fs/orangefs/capcache. */

 create /sys/fs/orangefs/ccache. */

 create /sys/fs/orangefs/ncache. */

 create /sys/fs/orangefs/perf_counters. */

 create /sys/fs/orangefs/stats. */

 SPDX-License-Identifier: GPL-2.0

/*

 * (C) 2001 Clemson University and The University of Chicago

 * Copyright 2018 Omnibond Systems, L.L.C.

 *

 * See COPYING in top-level directory.

/*

 *  Linux VFS extended attribute operations.

/*

 * this function returns

 *   0 if the key corresponding to name is not meant to be printed as part

 *     of a listxattr.

 *   1 if the key corresponding to name is meant to be returned as part of

 *     a listxattr.

 * The ones that start SYSTEM_ORANGEFS_KEY are the ones to avoid printing.

 Attribute must exist! */

 Attribute must not exist */

/*		if (!time_before(jiffies, cx->timeout)) {

			hlist_del(&cx->node);

			kfree(cx);

			continue;

/*

 * Tries to get a specified key's attributes of a given

 * file into a user-specified buffer. Note that the getxattr

 * interface allows for the users to probe the size of an

 * extended attribute by passing in a value of 0 to size.

 * Thus our return value is always the size of the attribute

 * unless the key does not exist for the file and/or if

 * there were errors in fetching the attribute value.

	/*

	 * NOTE: Although keys are meant to be NULL terminated textual

	 * strings, I am going to explicitly pass the length just in case

	 * we change this later on...

	/*

	 * Length returned includes null terminator.

	/*

	 * Just return the length of the queried attribute.

	/*

	 * Check to see if key length is > provided buffer size.

	/*

	 * NOTE: Although keys are meant to be NULL terminated

	 * textual strings, I am going to explicitly pass the

	 * length just in case we change this later on...

		/*

		 * Request to replace a non-existent attribute is an error.

/*

 * Tries to set an attribute for a given key on a file.

 *

 * Returns a -ve number on error and 0 on success.  Key is text, but value

 * can be binary!

 This is equivalent to a removexattr */

	/*

	 * NOTE: Although keys are meant to be NULL terminated textual

	 * strings, I am going to explicitly pass the length just in

	 * case we change this later on...

 when request is serviced properly, free req op struct */

/*

 * Tries to get a specified object's keys into a user-specified buffer of a

 * given size.  Note that like the previous instances of xattr routines, this

 * also allows you to pass in a NULL pointer and 0 size to probe the size for

 * subsequent memory allocations. Thus our return value is always the size of

 * all the keys unless there were errors in fetching the keys!

		/*

		 * This is a bit of a big upper limit, but I did not want to

		 * spend too much time getting this correct, since users end

		 * up allocating memory rather than us...

	/*

	 * Check to see how much can be fit in the buffer. Fit only whole keys.

		/*

		 * Since many dumb programs try to setxattr() on our reserved

		 * xattrs this is a feeble attempt at defeating those by not

		 * listing them in the output of listxattr.. sigh

	/*

	 * Since the buffer was large enough, we might have to continue

	 * fetching more keys!

 match any name => handlers called with full name */

 SPDX-License-Identifier: GPL-2.0

/*

 * (C) 2001 Clemson University and The University of Chicago

 * Copyright 2018 Omnibond Systems, L.L.C.

 *

 * See COPYING in top-level directory.

/*

 *  Linux VFS inode operations.

 Should've been handled in orangefs_invalidatepage. */

 It's not private so there's nothing to write, right? */

 read in the pages. */

 clean up. */

 offset into this page */

 this will only zero remaining unread portions of the page data */

 takes care of potential aliasing */

 unlock the page after the ->readpage() routine completes */

		/*

		 * Should be impossible.  If it happens, launder the page

		 * since we don't know what's dirty.  This will WARN in

		 * orangefs_writepage_locked.

	/*

	 * No need to use i_size_read() here, the i_size

	 * cannot change under us because we hold the i_mutex.

 zero the stale part of the page if we did a short copy */

 Set fully written pages uptodate. */

 write range entirely within invalidate range (or equal) */

 XXX is this right? only caller in fs */

 invalidate range chops off end of write range */

 invalidate range chops off beginning of write range */

 invalidate range entirely within write range (punch hole) */

 XXX what do we do here... should not WARN_ON */

 punch hole */

		/*

		 * should we just ignore this and write it out anyway?

		 * it hardly makes sense

 non-overlapping ranges */

 WARN if they do overlap */

	/*

	 * Above there are returns where wr is freed or where we WARN.

	 * Thus the following runs if wr was modified above.

	/*

	 * Comment from original do_readv_writev:

	 * Common entry point for read/write/readv/writev

	 * This function will dispatch it to either the direct I/O

	 * or buffered I/O path depending on the mount options and/or

	 * augmented/extended metadata attached to the file.

	 * Note: File extended attributes override any mount options.

 how much to transfer in this loop iteration */

		/*

		 * if we got a short I/O operations,

		 * fall out and return what we got so far

end while */

* ORANGEFS2 implementation of address space operations */

		/*

		 * Should be impossible.  If it happens, launder the page

		 * since we don't know what's dirty.  This will WARN in

		 * orangefs_writepage_locked.

	/*

	 * We mark the page dirty already here so that when freeze is in

	 * progress, we are guaranteed that writeback during freezing will

	 * see the dirty page and writeprotect it again.

 Ensure that we have a up to date size, so we know if it changed. */

 This is truncate_setsize in a different order. */

	/*

	 * the truncate has no downcall members to retrieve, but

	 * the status value tells us if it went through ok or not

				/*

				 * allow sticky bit to be set on root (since

				 * it shows up that way by default anyhow),

				 * but don't show it to the server

 change mod on a file that has ACLs */

/*

 * Change attributes of an object referenced by dentry.

/*

 * Obtain attributes of an object given a dentry

 override block size reported to stat */

 Make sure the permission (and other common attrs) are up to date. */

	/*

	 * ORANGEFS_MIRROR_FL is set internally when the mirroring mode is

	 * turned on for a file. The user is not allowed to turn on this bit,

	 * but the bit is present if the user first gets the flags and then

	 * updates the flags with some new settings. So, we ignore it in the

	 * following edit. bligon.

 ORANGEFS2 implementation of VFS inode operations for files */

/*

 * Given an ORANGEFS object identifier (fsid, handle), convert it into

 * a ino_t type that will be used as a hash-index from where the handle will

 * be searched for in the VFS hash table of inodes.

/*

 * Called to set up an inode from iget5_locked.

/*

 * Called to determine if handles match.

 test handles and fs_ids... */

/*

 * Front-end to lookup the inode-cache maintained by the VFS using the ORANGEFS

 * file handle.

 *

 * @sb: the file system super block instance.

 * @ref: The ORANGEFS object for which we are trying to locate an inode.

 needed for stat etc */

/*

 * Allocate an inode for a newly created file and insert it into the inode hash.

 needed for stat etc */

 SPDX-License-Identifier: GPL-2.0

/*

 * (C) 2001 Clemson University and The University of Chicago

 * Copyright 2018 Omnibond Systems, L.L.C.

 *

 * See COPYING in top-level directory.

/*

 * NOTE: in kernel land, we never use the sys_attr->link_target for

 * anything, so don't bother copying it into the sys_attr object here.

	/*

	 * ORANGEFS cannot set size with a setattr operation. Probably not

	 * likely to be requested through the VFS, but just in case, don't

	 * worry about ATTR_SIZE

		/*

		 * if this occurs, the pvfs2-client-core was killed but we

		 * can't afford to lose the inode operations and such

		 * associated with the root handle in any case.

	/*

	 * If the inode type or symlink target have changed then this

	 * inode is stale.

 Must have all the attributes in the mask and be within cache time. */

	/*

	 * Size is the hardest attribute to get.  The incremental cost of any

	 * other attribute is essentially zero.

 Must have all the attributes in the mask and be within cache time. */

 i.e. -1 */

 XXX: ESTALE?  This is what is done if it is not new. */

 special case: mark the root inode as sticky */

/*

 * issues a orangefs setattr request to make sure the new attribute values

 * take effect if successful.  returns 0 on success; -errno otherwise

/*

 * The following is a very dirty hack that is now a permanent part of the

 * ORANGEFS protocol. See protocol.h for more error definitions.

 The order matches include/orangefs-types.h in the OrangeFS source. */

 Success */

	/*

	 * This shouldn't ever happen. If it does it should be fixed on the

	 * server.

	/*

	 * XXX: This is very bad since error codes from ORANGEFS may not be

	 * suitable for return into userspace.

	/*

	 * Convert ORANGEFS error values into errno values suitable for return

	 * from the kernel.

			/*

			 * cancellation error codes generally correspond to

			 * a timeout from the client's perspective

 assume a default error code */

 Convert ORANGEFS encoded errno values into regular errno values. */

	/*

	 * Only ORANGEFS protocol error codes should ever come here. Otherwise

	 * there is a bug somewhere.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright 2017 Omnibond Systems, L.L.C.

/*

 * There can be up to 512 directory entries.  Each entry is encoded as

 * follows:

 * 4 bytes: string size (n)

 * n bytes: string

 * 1 byte: trailing zero

 * padding to 8 bytes

 * 16 bytes: khandle

 * padding to 8 bytes

 *

 * The trailer_buf starts with a struct orangefs_readdir_response_s

 * which must be skipped to get to the directory data.

 *

 * The data which is received from the userspace daemon is termed a

 * part and is stored in a linked list in case more than one part is

 * needed for a large directory.

 *

 * The position pointer (ctx->pos) encodes the part and offset on which

 * to begin reading at.  Bits above PART_SHIFT encode the part and bits

 * below PART_SHIFT encode the offset.  Parts are stored in a linked

 * list which grows as data is received from the server.  The overhead

 * associated with managing the list is presumed to be small compared to

 * the overhead of communicating with the server.

 *

 * As data is received from the server, it is placed at the end of the

 * part list.  Data is parsed from the current position as it is needed.

 * When data is determined to be corrupt, it is either because the

 * userspace component has sent back corrupt data or because the file

 * pointer has been moved to an invalid location.  Since the two cannot

 * be differentiated, return EIO.

 *

 * Part zero is synthesized to contains `.' and `..'.  Part one is the

 * first part of the part list.

	/*

	 * Despite the badly named field, readdir does not use shared

	 * memory.  However, there are a limited number of readdir

	 * slots, which must be allocated here.  This flag simply tells

	 * the op scheduler to return the op here for retry.

	/*

	 * The maximum size is size per entry times the 512 entries plus

	 * the header.  This is well under the limit.

 The file offset from userspace is too large. */

	/*

	 * If the seek pointer is positioned just before an entry it

	 * should find the next entry.

		/*

		 * len is the size of the string itself.  padlen is the

		 * total size of the encoded string.

 This means the userspace file offset is invalid. */

 Userspace buffer is full. */

			/*

			 * The part ran out of data.  Move to the next

	/*

	 * Delete the stored data so userspace sees new directory

	 * entries.

	/*

	 * The seek position is in the first synthesized part but is not

	 * valid.

	/*

	 * Must read more if the user has sought past what has been read

	 * so far.  Stop a user who has sought past the end.

 Then try to fill if there's any left in the buffer. */

 Finally get some more and try to fill. */

 SPDX-License-Identifier: GPL-2.0

/*

 * (C) 2001 Clemson University and The University of Chicago

 *

 * See COPYING in top-level directory.

/*

 *  Implementation of dentry (directory cache) functions.

 Returns 1 if dentry can still be trusted, else 0. */

 Positive dentry: reject if error or not the same inode. */

 Negative dentry: reject if success or error other than ENOENT. */

/*

 * Verify that dentry is valid.

 *

 * Should return 1 if dentry can still be trusted, else 0.

 skip root handle lookups. */

	/*

	 * If this passes, the positive dentry still exists or the negative

	 * dentry still does not exist.

 We do not need to continue with negative dentries. */

 Now we must perform a getattr to validate the inode contents. */

 SPDX-License-Identifier: GPL-2.0

/*

 * (C) 2001 Clemson University and The University of Chicago

 *

 * See COPYING in top-level directory.

 finished dying */

 we are waiting for map to be installed */

 it would better be there soon, or we go away */

 used to describe mapped buffers */

 user space address pointer */

 array of mapped pages */

 size of above arrays */

 array to track usage of buffer descriptors */

 array to track usage of buffer descriptors for readdir */

/*

 * XXX: Can the size and shift change while the caller gives up the

 * XXX: lock between calling this and doing something useful?

 allocate storage to track our page mappings */

 map the pages */

	/*

	 * ideally we want to get kernel space pointers for each page, but

	 * we can't kmap that many pages at once if highmem is being used.

	 * so instead, we just kmap/kunmap the page address each time the

	 * kaddr is needed.

 build a list of available descriptors */

/*

 * orangefs_bufmap_initialize()

 *

 * initializes the mapped buffer interface

 *

 * returns 0 on success, -errno on failure

	/*

	 * sanity check alignment and size of buffer that caller wants to

	 * work with

/*

 * orangefs_bufmap_finalize()

 *

 * shuts down the mapped buffer interface and releases any resources

 * associated with it

 *

 * no return value

/*

 * orangefs_bufmap_get()

 *

 * gets a free mapped buffer descriptor, will sleep until one becomes

 * available if necessary

 *

 * returns slot on success, -errno on failure

/*

 * orangefs_bufmap_put()

 *

 * returns a mapped buffer descriptor to the collection

 *

 * no return value

/*

 * orangefs_readdir_index_get()

 *

 * gets a free descriptor, will sleep until one becomes

 * available if necessary.

 * Although the readdir buffers are not mapped into kernel space

 * we could do that at a later point of time. Regardless, these

 * indices are used by the client-core.

 *

 * returns slot on success, -errno on failure

/*

 * we've been handed an iovec, we need to copy it to

 * the shared memory descriptor at "buffer_index".

/*

 * we've been handed an iovec, we need to fill it from

 * the shared memory descriptor at "buffer_index".

 SPDX-License-Identifier: GPL-2.0

/*

 * (C) 2001 Clemson University and The University of Chicago

 * Copyright 2018 Omnibond Systems, L.L.C.

 *

 * See COPYING in top-level directory.

/*

 *  Linux VFS file operations.

/*

 * Post and wait for the I/O upcall to finish

 synchronous I/O */

 get a shared buffer index */

	/*

	 * Orangefs has no open, and orangefs checks file permissions

	 * on each file access. Posix requires that file permissions

	 * be checked on open and nowhere else. Orangefs-through-the-kernel

	 * needs to seem posix compliant.

	 *

	 * The VFS opens files, even if the filesystem provides no

	 * method. We can see if a file was successfully opened for

	 * read and or for write by looking at file->f_mode.

	 *

	 * When writes are flowing from the page cache, file is no

	 * longer available. We can trust the VFS to have checked

	 * file->f_mode before writing to the page cache.

	 *

	 * The mode of a file might change between when it is opened

	 * and IO commences, or it might be created with an arbitrary mode.

	 *

	 * We'll make sure we don't hit EACCES during the IO stage by

	 * using UID 0. Some of the time we have access without changing

	 * to UID 0 - how to check?

 not relevant? */

	/*

	 * Stage 1: copy the buffers into client-core's address space

 Stage 2: Service the I/O operation */

	/*

	 * If service_operation() returns -EAGAIN #and# the operation was

	 * purged from orangefs_request_list or htable_ops_in_progress, then

	 * we know that the client was restarted, causing the shared memory

	 * area to be wiped clean.  To restart a  write operation in this

	 * case, we must re-copy the data from the user's iovec to a NEW

	 * shared memory location. To restart a read operation, we must get

	 * a new shared memory location.

			/*

			 * We can't return EINTR if any data was written,

			 * it's not POSIX. It is minimally acceptable

			 * to give a partial write, the way NFS does.

			 *

			 * It would be optimal to return all or nothing,

			 * but if a userspace write is bigger than

			 * an IO buffer, and the interrupt occurs

			 * between buffer writes, that would not be

			 * possible.

			/*

			 * If the op was waiting when the interrupt

			 * occurred, then the client-core did not

			 * trigger the write.

			/*

			 * If the op was in progress when the interrupt

			 * occurred, then the client-core was able to

			 * trigger the write.

	/*

	 * Stage 3: Post copy buffers from client-core's address space

		/*

		 * NOTE: the iovector can either contain addresses which

		 *       can futher be kernel-space or user-space addresses.

		 *       or it can pointers to struct page's

/*

 * Memory map a region of a file.

 set the sequential readahead hint */

/*

 * Called to notify the module that there are no more references to

 * this file (i.e. no processes have it open).

 *

 * \note Not called when each file is closed.

	/*

	 * remove all associated inode pages from the page cache and

	 * readahead cache (if any); this forces an expensive refresh of

	 * data for the next caller of mmap (or 'get_block' accesses)

/*

 * Push all data for a specific file onto permanent storage.

/*

 * Change the file pointer position for an instance of an open file.

 *

 * \note If .llseek is overriden, we must acquire lock as described in

 *       Documentation/filesystems/locking.rst.

 *

 * Future upgrade could support SEEK_DATA and SEEK_HOLE but would

 * require much changes to the FS

		/*

		 * revalidate the inode's file size.

		 * NOTE: We are only interested in file size here,

		 * so we set mask accordingly.

/*

 * Support local locks (locks that only this kernel knows about)

 * if Orangefs was mounted -o local_lock.

	/*

	 * This is vfs_fsync_range(file, 0, LLONG_MAX, 0) without the

	 * service_operation in orangefs_fsync.

	 *

	 * Do not send fsync to OrangeFS server on a close.  Do send fsync

	 * on an explicit fsync call.  This duplicates historical OrangeFS

	 * behavior.

* ORANGEFS implementation of VFS file operations */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * (C) 2001 Clemson University and The University of Chicago

 *

 * Changes by Acxiom Corporation to add proc file handler for pvfs2 client

 * parameters, Copyright Acxiom Corporation, 2005.

 *

 * See COPYING in top-level directory.

 ORANGEFS_VERSION is a ./configure define */

/*

 * global variables declared here

 the size of the hash tables for ops in progress */

/*

 * Blocks non-priority requests from being queued for servicing.  This

 * could be used for protecting the request list data structure, but

 * for now it's only being used to stall the op addition to the request

 * list

 hash table for storing operations waiting for matching downcall */

 list for queueing upcall operations */

 used to protect the above orangefs_request_list */

 used for incoming request notification */

 initialize global book keeping data structures */

 initialize a doubly linked at each hash table index */

	/*

	 * Build the contents of /sys/kernel/debug/orangefs/debug-help

	 * from the keywords in the kernel keyword/mask array.

	 *

	 * The keywords in the client keyword/mask array are

	 * unknown at boot time.

	 *

	 * orangefs_prepare_debugfs_help_string will be used again

	 * later to rebuild the debug-help-string after the client starts

	 * and passes along the needed info. The argument signifies

	 * which time orangefs_prepare_debugfs_help_string is being

	 * called.

 Initialize the orangefsdev subsystem. */

/*

 * What we do in this function is to walk the list of operations

 * that are in progress in the hash table and mark them as purged as well.

 SPDX-License-Identifier: GPL-2.0

/*

 * (C) 2001 Clemson University and The University of Chicago

 *

 * See COPYING in top-level directory.

 SPDX-License-Identifier: GPL-2.0

/*

 * (C) 2001 Clemson University and The University of Chicago

 *

 * Changes by Acxiom Corporation to add protocol version to kernel

 * communication, Copyright Acxiom Corporation, 2005.

 *

 * See COPYING in top-level directory.

 this file implements the /dev/pvfs2-req device node */

/*

 * find the op with this tag and remove it from the in progress

 * hash table.

 Returns whether any FS are still pending remounted */

 All of these file system require a remount */

/*

 * Determine if a given file system needs to be remounted or not

 *  Returns -1 on error

 *           0 if already mounted

 *           1 if needs remount

 in order to ensure that the filesystem driver sees correct UIDs */

 Function for read() callers into the device */

 We do not support blocking IO. */

	/*

	 * The client will do an ioctl to find MAX_DEV_REQ_UPSIZE, then

	 * always read with that size buffer.

 Check for an empty list before locking. */

 Get next op (if any) from top of list. */

 This lock is held past the end of the loop when we break. */

 Skip ops whose filesystem needs to be mounted. */

			/*

			 * Skip ops whose filesystem we don't know about unless

			 * it is being mounted or unmounted.  It is possible for

			 * a filesystem we don't know about to be unmounted if

			 * it fails to mount in the kernel after userspace has

			 * been sent the mount request.

 XXX: is there a better way to detect this? */

		/*

		 * Either this op does not pertain to a filesystem, is mounting

		 * a filesystem, or pertains to a mounted filesystem. Let it

		 * through.

	/*

	 * At this point we either have a valid op and can continue or have not

	 * found an op and must ask the client to try again later.

	/*

	 * Such an op should never be on the list in the first place. If so, we

	 * will abort.

 Push the upcall out. */

	/*

	 * Set the operation to be in progress and move it between lists since

	 * it has been sent to the client.

 The client only asks to read one size buffer. */

	/*

	 * We were unable to copy the op data to the client. Put the op back in

	 * list. If client has crashed, the op will be purged later when the

	 * device is released.

/*

 * Function for writev() callers into the device.

 *

 * Userspace should have written:

 *  - __u32 version

 *  - __u32 magic

 *  - __u64 tag

 *  - struct orangefs_downcall_s

 *  - trailer buffer (in the case of READDIR operations)

 remove the op from the in progress hash table */

	/*

	 * We've successfully peeled off the head and the downcall.

	 * Something has gone awry if total doesn't equal the

	 * sum of head_size, downcall_size and trailer_size.

 Only READDIR operations should have trailers. */

 READDIR operations should always have trailers. */

	/*

	 * Return to vfs waitqueue, and back to service_operation

	 * through wait_for_matching_downcall.

/*

 * NOTE: gets called when the last reference to this device is dropped.

 * Using the open_access_count variable, we enforce a reference count

 * on this file so that it can be opened by only one process at a time.

 * the devreq_mutex is used to make sure all i/o has completed

 * before we call orangefs_bufmap_finalize, and similar such tricky

 * situations

	/*

	 * What this function does is checks if client-core is alive

	 * based on the access count we maintain on the device.

 Check for valid ioctl codes */

 and valid ioctl commands */

 mtmoore: add locking here */

 WTF -EIO and not -EFAULT? */

		/*

		 * remount all mounted orangefs volumes to regain the lost

		 * dynamic mount tables (if any) -- NOTE: this is done

		 * without keeping the superblock list locked due to the

		 * upcall/downcall waiting.  also, the request mutex is

		 * used to ensure that no operations will be serviced until

		 * all of the remounts are serviced (to avoid ops between

		 * mounts to fail)

			/*

			 * We have to drop the spinlock, so entries can be

			 * removed.  They can't be freed, though, so we just

			 * keep the forward pointers and zero the back ones -

			 * that way we can get to the rest of the list.

 Check for properly constructed commands */

 CONFIG_COMPAT is in .config */

  Compat structure for the ORANGEFS_DEV_MAP ioctl */

/*

 * 32 bit user-space apps' ioctl handlers when kernel modules

 * is compiled as a 64 bit one

 Check for properly constructed commands */

 no other ioctl requires translation */

 CONFIG_COMPAT is in .config */

 the assigned character device major number */

 CONFIG_COMPAT is in .config */

/*

 * Initialize orangefs device specific state:

 * Must be called at module load time only

 register orangefs-req device  */

 SPDX-License-Identifier: GPL-2.0

/*

 * (C) 2001 Clemson University and The University of Chicago

 *

 * See COPYING in top-level directory.

 tags assigned to kernel upcall operations */

 the orangefs memory caches */

 a cache for orangefs upcall/downcall operations */

 initialize our atomic tag counter */

 initialize the op specific tag and upcall credentials */

 SPDX-License-Identifier: GPL-2.0

/*

 * (C) 2001 Clemson University and The University of Chicago

 * (C) 2011 Omnibond Systems

 *

 * Changes by Acxiom Corporation to implement generic service_operation()

 * function, Copyright Acxiom Corporation, 2005.

 *

 * See COPYING in top-level directory.

/*

 *  In-kernel waitqueue operations.

/*

 * What we do in this function is to walk the list of operations that are

 * present in the request queue and mark them as purged.

 * NOTE: This is called from the device close after client-core has

 * guaranteed that no new operations could appear on the list since the

 * client-core is anyway going to exit.

/*

 * submits a ORANGEFS operation and waits for it to complete

 *

 * Note op->downcall.status will contain the status of the operation (in

 * errno format), whether provided by pvfs2-client or a result of failure to

 * service the operation.  If the caller wishes to distinguish, then

 * op->state can be checked to see if it was serviced or not.

 *

 * Returns contents of op->downcall.status for convenience

	/*

	 * If ORANGEFS_OP_NO_MUTEX was set in flags, we need to avoid

	 * acquiring the request_mutex because we're servicing a

	 * high priority remount operation and the request_mutex is

	 * already taken.

		/*

		 * check to see if we were interrupted while waiting for

		 * mutex

 queue up the operation */

 add high priority remount op to the front of the line. */

		/*

		 * Don't wait for the userspace component to return if

		 * the filesystem is being umounted anyway.

 got matching downcall; make sure status is in errno format */

 failed to get matching downcall */

	/*

	 * remove a waiting op from the request list or

	 * remove an in-progress op from the in-progress list.

 retry if operation has not been serviced and if requested */

		/*

		 * io ops (ops that use the shared memory buffer) have

		 * to be returned to their caller for a retry. Other ops

		 * can just be recycled here.

 This can get called on an I/O op if it had a bad service_operation. */

 orangefs_request_list_lock is enough of a barrier here */

/*

 * Change an op to the "given up" state and remove it from its list.

	/*

	 * handle interrupted cases depending on what state we were in when

	 * the interruption is detected.

	 *

	 * Called with op->lock held.

	/*

	 * List manipulation code elsewhere will ignore ops that

	 * have been given up upon.

 caught copying to/from daemon */

		/*

		 * upcall hasn't been read; remove op from upcall request

		 * list.

 op must be removed from the in progress htable */

/*

 * Sleeps on waitqueue waiting for matching downcall.

 * If client-core finishes servicing, then we are good to go.

 * else if client-core exits, we get woken up here, and retry with a timeout

 *

 * When this call returns to the caller, the specified op will no

 * longer be in either the in_progress hash table or on the request list.

 *

 * Returns 0 on success and -errno on failure

 * Errors are:

 * EAGAIN in case we want the caller to requeue and try again..

 * EINTR/EIO/ETIMEDOUT indicating we are done trying to service this

 * operation since client-core seems to be exiting too often

 * or if we were interrupted.

 *

 * Returns with op->lock taken.

	/*

	 * There's a "schedule_timeout" inside of these wait

	 * primitives, during which the op is out of the hands of the

	 * user process that needs something done and is being

	 * manipulated by the client-core process.

 !writeback && !interruptible but compiler complains */

 must have timed out, then... */

 SPDX-License-Identifier: GPL-2.0

/*

 * Cryptographic API.

 *

 * MD4 Message Digest Algorithm (RFC1320).

 *

 * Implementation derived from Andrew Tridgell and Steve French's

 * CIFS MD4 implementation, and the cryptoapi implementation

 * originally based on the public domain implementation written

 * by Colin Plumb in 1993.

 *

 * Copyright (c) Andrew Tridgell 1997-1998.

 * Modified by Steve French (sfrench@us.ibm.com) 2002

 * Copyright (c) Cryptoapi developers.

 * Copyright (c) 2002 David S. Miller (davem@redhat.com)

 * Copyright (c) 2002 James Morris <jmorris@intercode.com.au>

 *

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Cryptographic API

 *

 * ARC4 Cipher Algorithm

 *

 * Jon Oberheide <jon@oberheide.org>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * linux/fs/lockd/svc.c

 *

 * This is the central lockd service.

 *

 * FIXME: Separate the lockd NFS server functionality from the lockd NFS

 * 	  client functionality. Oh why didn't Sun create two separate

 *	  services in the first place?

 *

 * Authors:	Olaf Kirch (okir@monad.swb.de)

 *

 * Copyright (C) 1995, 1996 Olaf Kirch <okir@monad.swb.de>

/*

 * These can be set at insmod time (useful for NFS as root filesystem),

 * and also changed through the sysctl interface.  -- Jamie Lokier, Aug 2003

 RLIM_NOFILE defaults to 1024. That seems like a reasonable default here. */

/*

 * Constants needed for the sysctl interface.

 Note: nlm_timeout should always be nonzero */

/*

 * This is the lockd kernel thread

 try_to_freeze() is called from svc_recv() */

 Allow SIGKILL to tell lockd to drop all of its locks */

	/*

	 * The main request loop. We don't terminate until the last

	 * NFS mount or NFS daemon has gone away.

 update sv_maxconn if it has changed */

		/*

		 * Find a socket with data available and call its

		 * recvfrom routine.

/*

 * Ensure there are active UDP and TCP listeners for lockd.

 *

 * Even if we have only TCP NFS mounts and/or TCP NFSDs, some

 * local services (such as rpc.statd) still require UDP, and

 * some NFS servers do not yet support NLM over TCP.

 *

 * Returns zero if all listeners are available; otherwise a

 * negative errno value is returned.

	/*

	 * Create the kernel thread and wait for it to start.

	/*

	 * Check whether we're already up and running.

		/*

		 * Note: increase service usage, because later in case of error

		 * svc_destroy() will be called.

	/*

	 * Sanity check: if there's no pid,

	 * we should be the first user ...

/*

 * Bring up the lockd process if it's not already up.

	/*

	 * Note: svc_serv structures have an initial use count of 1,

	 * so we exit through here on both success and failure.

/*

 * Decrement the user count and bring down lockd if we're the last.

/*

 * Sysctl parameters (same as module parameters, different interface).

 CONFIG_SYSCTL */

/*

 * Module (and sysfs) parameters.

				/* Leave it to individual procedures to

				 * call nlmsvc_lookup_host(rqstp)

/*

 * Initialising and terminating the module.

 FIXME: delete all NLM clients */

/**

 * nlmsvc_dispatch - Process an NLM Request

 * @rqstp: incoming request

 * @statp: pointer to location of accept_stat field in RPC Reply buffer

 *

 * Return values:

 *  %0: Processing complete; do not send a Reply

 *  %1: Processing complete; send Reply in rqstp->rq_res

/*

 * Define NLM program and procedures

 program number */

 number of entries in nlmsvc_version */

 version table */

 service name */

 share authentication with nfsd */

 stats table */

 export authentication */

 SPDX-License-Identifier: GPL-2.0

/*

 * linux/fs/lockd/xdr4.c

 *

 * XDR support for lockd and the lock client.

 *

 * Copyright (C) 1995, 1996 Olaf Kirch <okir@monad.swb.de>

 * Copyright (C) 1999, Trond Myklebust <trond.myklebust@fys.uio.no>

/*

 * NLM file handles are defined by specification to be a variable-length

 * XDR opaque no longer than 1024 bytes. However, this implementation

 * limits their length to the size of an NFSv3 file handle.

 exclusive */

/*

 * Decode Call arguments

 monitor client by default */

 XXX: Range checks are missing in the original code */

/*

 * Encode Reply results

 sequence */

 SPDX-License-Identifier: GPL-2.0

/*

 * linux/fs/lockd/svcproc.c

 *

 * Lockd server procedures. We don't implement the NLM_*_RES 

 * procedures because we don't use the async procedures.

 *

 * Copyright (C) 1996, Olaf Kirch <okir@monad.swb.de>

 Note: status is assumed to be in network byte order !!! */

/*

 * Obtain client and file from arguments

 nfsd callbacks must have been installed for this procedure */

 Obtain host handle */

 Obtain file pointer. Not used by FREE_ALL call. */

 Set up the missing parts of the file_lock structure */

 lockowner allocation has failed */

/*

 * NULL: Test for presence of service

/*

 * TEST: Check for conflicting lock

 Obtain client and file */

 Now check for conflicting locks */

 Obtain client and file */

	/* If supplied state doesn't match current state, we assume it's

	 * an old request that time-warped somehow. Any error return would

	 * do in this case because it's irrelevant anyway.

	 *

	 * NB: We don't retrieve the remote host's state yet.

 Now try to lock the file */

 Don't accept requests during grace period */

 Obtain client and file */

 Try to cancel request. */

/*

 * UNLOCK: release a lock

 Don't accept new lock requests during grace period */

 Obtain client and file */

 Now try to remove the lock */

/*

 * GRANTED: A server calls us to tell that a process' lock request

 * was granted

/*

 * This is the generic lockd callback for async RPC calls

/*

 * `Async' versions of the above service routines. They aren't really,

 * because we send the callback before the reply proper. I hope this

 * doesn't break any clients.

/*

 * SHARE: create a DOS share or alter existing share.

 Don't accept new lock requests during grace period */

 Obtain client and file */

 Now try to create the share */

/*

 * UNSHARE: Release a DOS share.

 Don't accept requests during grace period */

 Obtain client and file */

 Now try to unshare the file */

/*

 * NM_LOCK: Create an unmonitored lock

 just clean the monitor flag */

/*

 * FREE_ALL: Release all locks and shares held by client

 Obtain client */

/*

 * SM_NOTIFY: private callback from statd (not part of official NLM proto)

/*

 * client sent a GRANTED_RES, let's remove the associated block

/*

 * NLM Server procedures.

 cookie */

 status */

 Net Obj */

 range - offset + size */

 SPDX-License-Identifier: GPL-2.0

/*

 * linux/fs/lockd/clntxdr.c

 *

 * XDR functions to encode/decode NLM version 3 RPC arguments and results.

 * NLM version 3 is backwards compatible with NLM versions 1 and 2.

 *

 * NLM client-side only.

 *

 * Copyright (C) 2010, Oracle.  All rights reserved.

/*

 * Declare the space requirements for NLM arguments and replies as

 * number of 32bit-words

/*

 * Encode/decode NLMv3 basic data types

 *

 * Basic NLMv3 data types are not defined in an IETF standards

 * document.  X/Open has a description of these data types that

 * is useful.  See Chapter 10 of "Protocols for Interworking:

 * XNFS, Version 3W".

 *

 * Not all basic data types have their own encoding and decoding

 * functions.  For run-time efficiency, some data types are encoded

 * or decoded inline.

/*

 *	typedef opaque netobj<MAXNETOBJ_SZ>

/*

 *	netobj cookie;

 apparently HPUX can return empty cookies */

/*

 *	netobj fh;

/*

 *	enum nlm_stats {

 *		LCK_GRANTED = 0,

 *		LCK_DENIED = 1,

 *		LCK_DENIED_NOLOCKS = 2,

 *		LCK_BLOCKED = 3,

 *		LCK_DENIED_GRACE_PERIOD = 4

 *	};

 *

 *

 *	struct nlm_stat {

 *		nlm_stats stat;

 *	};

 *

 * NB: we don't swap bytes for the NLM status values.  The upper

 * layers deal directly with the status value in network byte

 * order.

/*

 *	struct nlm_holder {

 *		bool exclusive;

 *		int uppid;

 *		netobj oh;

 *		unsigned l_offset;

 *		unsigned l_len;

 *	};

/*

 *	string caller_name<LM_MAXSTRLEN>;

 NB: client-side does not set lock->len */

/*

 *	struct nlm_lock {

 *		string caller_name<LM_MAXSTRLEN>;

 *		netobj fh;

 *		netobj oh;

 *		int uppid;

 *		unsigned l_offset;

 *		unsigned l_len;

 *	};

/*

 * NLMv3 XDR encode functions

 *

 * NLMv3 argument types are defined in Chapter 10 of The Open Group's

 * "Protocols for Interworking: XNFS, Version 3W".

/*

 *	struct nlm_testargs {

 *		netobj cookie;

 *		bool exclusive;

 *		struct nlm_lock alock;

 *	};

/*

 *	struct nlm_lockargs {

 *		netobj cookie;

 *		bool block;

 *		bool exclusive;

 *		struct nlm_lock alock;

 *		bool reclaim;

 *		int state;

 *	};

/*

 *	struct nlm_cancargs {

 *		netobj cookie;

 *		bool block;

 *		bool exclusive;

 *		struct nlm_lock alock;

 *	};

/*

 *	struct nlm_unlockargs {

 *		netobj cookie;

 *		struct nlm_lock alock;

 *	};

/*

 *	struct nlm_res {

 *		netobj cookie;

 *		nlm_stat stat;

 *	};

/*

 *	union nlm_testrply switch (nlm_stats stat) {

 *	case LCK_DENIED:

 *		struct nlm_holder holder;

 *	default:

 *		void;

 *	};

 *

 *	struct nlm_testres {

 *		netobj cookie;

 *		nlm_testrply test_stat;

 *	};

/*

 * NLMv3 XDR decode functions

 *

 * NLMv3 result types are defined in Chapter 10 of The Open Group's

 * "Protocols for Interworking: XNFS, Version 3W".

/*

 *	union nlm_testrply switch (nlm_stats stat) {

 *	case LCK_DENIED:

 *		struct nlm_holder holder;

 *	default:

 *		void;

 *	};

 *

 *	struct nlm_testres {

 *		netobj cookie;

 *		nlm_testrply test_stat;

 *	};

/*

 *	struct nlm_res {

 *		netobj cookie;

 *		nlm_stat stat;

 *	};

/*

 * For NLM, a void procedure really returns nothing

 SPDX-License-Identifier: GPL-2.0

/*

 * linux/fs/lockd/mon.c

 *

 * The kernel statd client.

 *

 * Copyright (C) 1996, Olaf Kirch <okir@monad.swb.de>

 RPC callback info */

/*

 * Local NSM state

/**

 * nsm_monitor - Notify a peer in case we reboot

 * @host: pointer to nlm_host of peer to notify

 *

 * If this peer is not already monitored, this function sends an

 * upcall to the local rpc.statd to record the name/address of

 * the peer to notify in case we reboot.

 *

 * Returns zero if the peer is monitored by the local rpc.statd;

 * otherwise a negative errno value is returned.

	/*

	 * Choose whether to record the caller_name or IP address of

	 * this peer in the local rpc.statd's database.

/**

 * nsm_unmonitor - Unregister peer notification

 * @host: pointer to nlm_host of peer to stop monitoring

 *

 * If this peer is monitored, this function sends an upcall to

 * tell the local rpc.statd not to send this peer a notification

 * when we reboot.

/*

 * Construct a unique cookie to match this nsm_handle to this monitored

 * host.  It is passed to the local rpc.statd via NSMPROC_MON, and

 * returned via NLMPROC_SM_NOTIFY, in the "priv" field of these

 * requests.

 *

 * The NSM protocol requires that these cookies be unique while the

 * system is running.  We prefer a stronger requirement of making them

 * unique across reboots.  If user space bugs cause a stale cookie to

 * be sent to the kernel, it could cause the wrong host to lose its

 * lock state if cookies were not unique across reboots.

 *

 * The cookies are exposed only to local user space via loopback.  They

 * do not appear on the physical network.  If we want greater security

 * for some reason, nsm_init_private() could perform a one-way hash to

 * obscure the contents of the cookie.

/**

 * nsm_get_handle - Find or create a cached nsm_handle

 * @net: network namespace

 * @sap: pointer to socket address of handle to find

 * @salen: length of socket address

 * @hostname: pointer to C string containing hostname to find

 * @hostname_len: length of C string

 *

 * Behavior is modulated by the global nsm_use_hostnames variable.

 *

 * Returns a cached nsm_handle after bumping its ref count, or

 * returns a fresh nsm_handle if a handle that matches @sap and/or

 * @hostname cannot be found in the handle cache.  Returns NULL if

 * an error occurs.

/**

 * nsm_reboot_lookup - match NLMPROC_SM_NOTIFY arguments to an nsm_handle

 * @net:  network namespace

 * @info: pointer to NLMPROC_SM_NOTIFY arguments

 *

 * Returns a matching nsm_handle if found in the nsm cache. The returned

 * nsm_handle's reference count is bumped. Otherwise returns NULL if some

 * error occurred.

/**

 * nsm_release - Release an NSM handle

 * @nsm: pointer to handle to be released

 *

/*

 * XDR functions for NSM.

 *

 * See https://www.opengroup.org/ for details on the Network

 * Status Monitor wire protocol.

/*

 * "mon_name" specifies the host to be monitored.

/*

 * The "my_id" argument specifies the hostname and RPC procedure

 * to be called when the status manager receives notification

 * (via the NLMPROC_SM_NOTIFY call) that the state of host "mon_name"

 * has changed.

/*

 * The "mon_id" argument specifies the non-private arguments

 * of an NSMPROC_MON or NSMPROC_UNMON call.

/*

 * The "priv" argument may contain private information required

 * by the NSMPROC_MON call. This information will be supplied in the

 * NLMPROC_SM_NOTIFY call.

 SPDX-License-Identifier: GPL-2.0

/*

 * linux/fs/lockd/clnt4xdr.c

 *

 * XDR functions to encode/decode NLM version 4 RPC arguments and results.

 *

 * NLM client-side only.

 *

 * Copyright (C) 2010, Oracle.  All rights reserved.

/*

 * Declare the space requirements for NLM arguments and replies as

 * number of 32bit-words

/*

 * Encode/decode NLMv4 basic data types

 *

 * Basic NLMv4 data types are defined in Appendix II, section 6.1.4

 * of RFC 1813: "NFS Version 3 Protocol Specification" and in Chapter

 * 10 of X/Open's "Protocols for Interworking: XNFS, Version 3W".

 *

 * Not all basic data types have their own encoding and decoding

 * functions.  For run-time efficiency, some data types are encoded

 * or decoded inline.

/*

 *	typedef opaque netobj<MAXNETOBJ_SZ>

/*

 *	netobj cookie;

 apparently HPUX can return empty cookies */

/*

 *	netobj fh;

/*

 *	enum nlm4_stats {

 *		NLM4_GRANTED = 0,

 *		NLM4_DENIED = 1,

 *		NLM4_DENIED_NOLOCKS = 2,

 *		NLM4_BLOCKED = 3,

 *		NLM4_DENIED_GRACE_PERIOD = 4,

 *		NLM4_DEADLCK = 5,

 *		NLM4_ROFS = 6,

 *		NLM4_STALE_FH = 7,

 *		NLM4_FBIG = 8,

 *		NLM4_FAILED = 9

 *	};

 *

 *	struct nlm4_stat {

 *		nlm4_stats stat;

 *	};

 *

 * NB: we don't swap bytes for the NLM status values.  The upper

 * layers deal directly with the status value in network byte

 * order.

/*

 *	struct nlm4_holder {

 *		bool	exclusive;

 *		int32	svid;

 *		netobj	oh;

 *		uint64	l_offset;

 *		uint64	l_len;

 *	};

/*

 *	string caller_name<LM_MAXSTRLEN>;

 NB: client-side does not set lock->len */

/*

 *	struct nlm4_lock {

 *		string	caller_name<LM_MAXSTRLEN>;

 *		netobj	fh;

 *		netobj	oh;

 *		int32	svid;

 *		uint64	l_offset;

 *		uint64	l_len;

 *	};

/*

 * NLMv4 XDR encode functions

 *

 * NLMv4 argument types are defined in Appendix II of RFC 1813:

 * "NFS Version 3 Protocol Specification" and Chapter 10 of X/Open's

 * "Protocols for Interworking: XNFS, Version 3W".

/*

 *	struct nlm4_testargs {

 *		netobj cookie;

 *		bool exclusive;

 *		struct nlm4_lock alock;

 *	};

/*

 *	struct nlm4_lockargs {

 *		netobj cookie;

 *		bool block;

 *		bool exclusive;

 *		struct nlm4_lock alock;

 *		bool reclaim;

 *		int state;

 *	};

/*

 *	struct nlm4_cancargs {

 *		netobj cookie;

 *		bool block;

 *		bool exclusive;

 *		struct nlm4_lock alock;

 *	};

/*

 *	struct nlm4_unlockargs {

 *		netobj cookie;

 *		struct nlm4_lock alock;

 *	};

/*

 *	struct nlm4_res {

 *		netobj cookie;

 *		nlm4_stat stat;

 *	};

/*

 *	union nlm4_testrply switch (nlm4_stats stat) {

 *	case NLM4_DENIED:

 *		struct nlm4_holder holder;

 *	default:

 *		void;

 *	};

 *

 *	struct nlm4_testres {

 *		netobj cookie;

 *		nlm4_testrply test_stat;

 *	};

/*

 * NLMv4 XDR decode functions

 *

 * NLMv4 argument types are defined in Appendix II of RFC 1813:

 * "NFS Version 3 Protocol Specification" and Chapter 10 of X/Open's

 * "Protocols for Interworking: XNFS, Version 3W".

/*

 *	union nlm4_testrply switch (nlm4_stats stat) {

 *	case NLM4_DENIED:

 *		struct nlm4_holder holder;

 *	default:

 *		void;

 *	};

 *

 *	struct nlm4_testres {

 *		netobj cookie;

 *		nlm4_testrply test_stat;

 *	};

/*

 *	struct nlm4_res {

 *		netobj cookie;

 *		nlm4_stat stat;

 *	};

/*

 * For NLM, a void procedure really returns nothing

 SPDX-License-Identifier: GPL-2.0-only

/*

 * linux/fs/lockd/clntproc.c

 *

 * RPC procedures for the client side NLM implementation

 *

 * Copyright (C) 1996, Olaf Kirch <okir@monad.swb.de>

/*

 * Cookie counter for NLM requests

/*

 * Initialize arguments for TEST/LOCK/UNLOCK/CANCEL calls

/**

 * nlmclnt_proc - Perform a single client-side lock request

 * @host: address of a valid nlm_host context representing the NLM server

 * @cmd: fcntl-style file lock operation to perform

 * @fl: address of arguments for the lock operation

 * @data: address of data to be sent to callback operations

 *

 lockowner allocation has failed */

 Set up the argument struct */

/*

 * Allocate an NLM RPC call struct

/*

 * Generic NLM call

 If we have no RPC client yet, create one. */

 Perform the RPC call. If an error occurs, try again */

 We appear to be out of the grace period */

 Okay, call complete */

		/*

		 * The server has rebooted and appears to be in the grace

		 * period during which locks are only allowed to be

		 * reclaimed.

		 * We can only back off and try again later.

/*

 * Generic NLM call, async version.

 If we have no RPC client yet, create one. */

 bootstrap and kick off the async RPC call */

/*

 * NLM asynchronous call.

/*

 * NLM client asynchronous call.

 *

 * Note that although the calls are asynchronous, and are therefore

 *      guaranteed to complete, we still always attempt to wait for

 *      completion in order to be able to correctly track the lock

 *      state.

/*

 * TEST for the presence of a conflicting lock

			/*

			 * Report the conflicting lock back to the application.

/*

 * LOCK: Try to create a lock

 *

 *			Programmer Harassment Alert

 *

 * When given a blocking lock request in a sync RPC call, the HPUX lockd

 * will faithfully return LCK_BLOCKED but never cares to notify us when

 * the lock could be granted. This way, our local process could hang

 * around forever waiting for the callback.

 *

 *  Solution A:	Implement busy-waiting

 *  Solution B: Use the async version of the call (NLM_LOCK_{MSG,RES})

 *

 * For now I am implementing solution A, because I hate the idea of

 * re-implementing lockd for a third time in two months. The async

 * calls shouldn't be too hard to do, however.

 *

 * This is one of the lovely things about standards in the NFS area:

 * they're so soft and squishy you can't really blame HP for doing this.

	/*

	 * Initialise resp->status to a valid non-zero value,

	 * since 0 == nlm_lck_granted

 Reboot protection */

 Did a reclaimer thread notify us of a server reboot? */

 Wait on an NLM blocking lock */

	/* if we were interrupted while blocking, then cancel the lock request

	 * and exit

 Check whether or not the server has rebooted */

 Ensure the resulting lock will get added to granted list */

	/*

	 * EAGAIN doesn't make sense for sleeping locks, and in some

	 * cases NLM_LCK_DENIED is returned for a permanent error.  So

	 * turn it into an ENOLCK.

 Fatal error: ensure that we remove the lock altogether */

/*

 * RECLAIM: Try to reclaim a lock

 Set up the argument struct */

	/*

	 * FIXME: This is a serious failure. We can

	 *

	 *  a.	Ignore the problem

	 *  b.	Send the owning process some signal (Linux doesn't have

	 *	SIGLOST, though...)

	 *  c.	Retry the operation

	 *

	 * Until someone comes up with a simple implementation

	 * for b or c, I'll choose option a.

/*

 * UNLOCK: remove an existing lock

	/*

	 * Note: the server is supposed to either grant us the unlock

	 * request, or to deny it with NLM_LCK_DENIED_GRACE_PERIOD. In either

	 * case, we want to unlock.

 What to do now? I'm out of my depth... */

/*

 * Cancel a blocked lock request.

 * We always use an async RPC call for this in order not to hang a

 * process that has been Ctrl-C'ed.

 Everything's good */

 Don't ever retry more than 3 times */

/*

 * Convert an NLM status code to a generic kernel errno

 SPDX-License-Identifier: GPL-2.0-only

/*

 * linux/fs/lockd/clntlock.c

 *

 * Lock handling for the client side NLM implementation

 *

 * Copyright (C) 1996, Olaf Kirch <okir@monad.swb.de>

/*

 * Local function prototypes

/*

 * The following functions handle blocking and granting from the

 * client perspective.

/*

 * This is the representation of a blocked client lock.

 linked list */

 where to wait on */

 local file lock */

 got to reclaim lock */

 grant callback status */

/**

 * nlmclnt_init - Set up per-NFS mount point lockd data structures

 * @nlm_init: pointer to arguments structure

 *

 * Returns pointer to an appropriate nlm_host struct,

 * or an ERR_PTR value.

/**

 * nlmclnt_done - Release resources allocated by nlmclnt_init()

 * @host: nlm_host structure reserved by nlmclnt_init()

 *

/*

 * Queue up a lock for blocking so that the GRANTED request can see it

/*

 * Block on a lock

	/* A borken server might ask us to block even if we didn't

	 * request it. Just say no!

	/* Go to sleep waiting for GRANT callback. Some servers seem

	 * to lose callbacks, however, so we're going to poll from

	 * time to time just to make sure.

	 *

	 * For now, the retry frequency is pretty high; normally 

	 * a 1 minute timeout would do. See the comment before

	 * nlmclnt_lock for an explanation.

 Reset the lock status after a server reboot so we resend */

/*

 * The server lockd has called us back to tell us the lock was granted

	/*

	 * Look up blocked request based on arguments. 

	 * Warning: must not use cookie to match it!

		/*

		 * Careful! The NLM server will return the 32-bit "pid" that

		 * we put on the wire: in this case the lockowner "pid".

		/* Alright, we found a lock. Set the return status

		 * and wake up the caller

/*

 * The following procedures deal with the recovery of locks after a

 * server crash.

/*

 * Reclaim all locks on server host. We do this by spawning a separate

 * reclaimer thread.

 note: this cannot fail as lockd is already running */

	/* Force a portmap getport - the peer's lockd will

	 * most likely end up on a different port.

 First, reclaim all locks that have been granted. */

		/*

		 * sending this thread a SIGKILL will result in any unreclaimed

		 * locks being removed from the h_granted list. This means that

		 * the kernel will not attempt to reclaim them again if a new

		 * reclaimer thread is spawned for this host.

 Argh! The server rebooted again! */

 Now, wake up all processes that sleep on a blocked lock */

 Release host handle after use */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * linux/fs/lockd/svcsubs.c

 *

 * Various support routines for the NLM server.

 *

 * Copyright (C) 1996, Olaf Kirch <okir@monad.swb.de>

/*

 * Global file hash table

 print the first 32 bytes of the fh */

/*

 * Open the file. Note that if we're reexporting, for example,

 * this could block the lockd thread for a while.

 *

 * We have to make sure we have the right credential to open

 * the file.

/*

 * Lookup file info. If it doesn't exist, create a file info struct

 * and open a (VFS) file for the given inode.

 Lock file table */

/*

 * Delete a file after having released all locks, blocks and shares

/*

 * Loop over all locks on the given file and perform the specified

 * action.

 update current lock count */

/*

 * Inspect a single file

/*

 * Quick check whether there are still any locks, blocks or

 * shares on a given file.

/*

 * Loop over all files in the file table.

			/* Traverse locks, blocks and shares of this file

 No more references to this file. Let go of it. */

/*

 * Release file. If there are no more remote locks on this file,

 * close it and free the handle.

 *

 * Note that we can't do proper reference counting without major

 * contortions because the code in fs/locks.c creates, deletes and

 * splits locks without notification. Our only way is to walk the

 * entire lock list each time we remove a lock.

 Lock file table */

 If there are no more locks etc, delete the file */

/*

 * Helpers function for resource traversal

 *

 * nlmsvc_mark_host:

 *	used by the garbage collector; simply sets h_inuse only for those

 *	hosts, which passed network check.

 *	Always returns 0.

 *

 * nlmsvc_same_host:

 *	returns 1 iff the two hosts match. Used to release

 *	all resources bound to a specific host.

 *

 * nlmsvc_is_client:

 *	returns 1 iff the host is a client.

 *	Used by nlmsvc_invalidate_all

		/* we are destroying locks even though the client

		 * hasn't asked us too, so don't unmonitor the

		 * client

/*

 * Mark all hosts that still hold resources

/*

 * Release all resources held by the given client

/**

 * nlmsvc_invalidate_all - remove all locks held for clients

 *

 * Release all locks held by NFS clients.

 *

	/*

	 * Previously, the code would call

	 * nlmsvc_free_host_resources for each client in

	 * turn, which is about as inefficient as it gets.

	 * Now we just do it once in nlm_traverse_files.

/**

 * nlmsvc_unlock_all_by_sb - release locks held on this file system

 * @sb: super block

 *

 * Release all locks held by clients accessing this file system.

/**

 * nlmsvc_unlock_all_by_ip - release local locks by IP address

 * @server_addr: server's IP address as seen by clients

 *

 * Release all locks held by clients accessing this host

 * via the passed in IP address.

 SPDX-License-Identifier: GPL-2.0

/*

 * linux/fs/lockd/svcshare.c

 *

 * Management of DOS shares.

 *

 * Copyright (C) 1996 Olaf Kirch <okir@monad.swb.de>

 Copy owner handle */

/*

 * Delete a share.

	/* X/Open spec says return success even if there was no

/*

 * Traverse all shares for a given file, and delete

 * those owned by the given (type of) host

 SPDX-License-Identifier: GPL-2.0

/*

 * linux/fs/lockd/xdr.c

 *

 * XDR support for lockd and the lock client.

 *

 * Copyright (C) 1995, 1996 Olaf Kirch <okir@monad.swb.de>

/*

 * NLM file handles are defined by specification to be a variable-length

 * XDR opaque no longer than 1024 bytes. However, this implementation

 * constrains their length to exactly the length of an NFSv2 file

 * handle.

 exclusive */

/*

 * Decode Call arguments

 monitor client by default */

 XXX: Range checks are missing in the original code */

/*

 * Encode Reply results

 sequence */

 SPDX-License-Identifier: GPL-2.0

/*

 * linux/fs/lockd/svc4proc.c

 *

 * Lockd server procedures. We don't implement the NLM_*_RES 

 * procedures because we don't use the async procedures.

 *

 * Copyright (C) 1996, Olaf Kirch <okir@monad.swb.de>

/*

 * Obtain client and file from arguments

 nfsd callbacks must have been installed for this procedure */

 Obtain host handle */

 Obtain file pointer. Not used by FREE_ALL call. */

 Set up the missing parts of the file_lock structure */

 lockowner allocation has failed */

/*

 * NULL: Test for presence of service

/*

 * TEST: Check for conflicting lock

 Obtain client and file */

 Now check for conflicting locks */

 Obtain client and file */

	/* If supplied state doesn't match current state, we assume it's

	 * an old request that time-warped somehow. Any error return would

	 * do in this case because it's irrelevant anyway.

	 *

	 * NB: We don't retrieve the remote host's state yet.

 Now try to lock the file */

 Don't accept requests during grace period */

 Obtain client and file */

 Try to cancel request. */

/*

 * UNLOCK: release a lock

 Don't accept new lock requests during grace period */

 Obtain client and file */

 Now try to remove the lock */

/*

 * GRANTED: A server calls us to tell that a process' lock request

 * was granted

/*

 * This is the generic lockd callback for async RPC calls

/*

 * `Async' versions of the above service routines. They aren't really,

 * because we send the callback before the reply proper. I hope this

 * doesn't break any clients.

/*

 * SHARE: create a DOS share or alter existing share.

 Don't accept new lock requests during grace period */

 Obtain client and file */

 Now try to create the share */

/*

 * UNSHARE: Release a DOS share.

 Don't accept requests during grace period */

 Obtain client and file */

 Now try to lock the file */

/*

 * NM_LOCK: Create an unmonitored lock

 just clean the monitor flag */

/*

 * FREE_ALL: Release all locks and shares held by client

 Obtain client */

/*

 * SM_NOTIFY: private callback from statd (not part of official NLM proto)

/*

 * client sent a GRANTED_RES, let's remove the associated block

/*

 * NLM Server procedures.

 cookie */

 netobj */

 status */

 range (offset + length) */

 SPDX-License-Identifier: GPL-2.0

/*

 * linux/fs/lockd/svclock.c

 *

 * Handling of server-side locks, mostly of the blocked variety.

 * This is the ugliest part of lockd because we tread on very thin ice.

 * GRANT and CANCEL calls may get stuck, meet in mid-flight, etc.

 * IMNSHO introducing the grant callback into the NLM protocol was one

 * of the worst ideas Sun ever had. Except maybe for the idea of doing

 * NFS file locking at all.

 *

 * I'm trying hard to avoid race conditions by protecting most accesses

 * to a file's list of blocked locks through a semaphore. The global

 * list of blocked locks is not protected in this fashion however.

 * Therefore, some functions (such as the RPC callback for the async grant

 * call) move blocked locks towards the head of the list *while some other

 * process might be traversing it*. This should not be a problem in

 * practice, because this will only cause functions traversing the list

 * to visit some blocks twice.

 *

 * Copyright (C) 1996, Olaf Kirch <okir@monad.swb.de>

/*

 * The list of blocked locks to retry

	/*

	 * We can get away with a static buffer because this is only called

	 * from lockd, which is single-threaded.

 allow for trailing \0 */

/*

 * Insert a blocked lock into the global list

		/* On normal exit from the loop, pos == &nlm_blocked,

		 * so we will be adding to the end of the list - good

/*

 * Remove a block from the global list

/*

 * Find a block for a given lock

/*

 * Find a block with a given NLM cookie.

/*

 * Create a block and initialize it.

 *

 * Note: we explicitly set the cookie of the grant reply to that of

 * the blocked lock request. The spec explicitly mentions that the client

 * should _not_ rely on the callback containing the same cookie as the

 * request, but (as I found out later) that's because some implementations

 * do just this. Never mind the standards comittees, they support our

 * logging industries.

 *

 * 10 years later: I hope we can safely ignore these old and broken

 * clients by now. Let's fix this so we can uniquely identify an incoming

 * GRANTED_RES message by cookie, without having to rely on the client's IP

 * address. --okir

 Allocate memory for block, and initialize arguments */

 Set notifier function for VFS, and init args */

 Create and initialize the block */

 Add to file's list of blocks */

 Set up RPC arguments for callback */

/*

 * Delete a block.

 * It is the caller's responsibility to check whether the file

 * can be closed hereafter.

 Remove block from list */

 Remove block from file's list of blocks */

/*

 * Loop over all blocks and delete blocks held by

 * a matching host.

		/* Do not destroy blocks that are not on

 fs/locks.c will manage the refcount through lock_ops */

/*

 * Initialize arguments for GRANTED call. The nlm_rqst structure

 * has been cleared already.

 set default data area */

/*

 * Deferred lock request handling for non-blocking lock

/*

 * Attempt to establish a lock, and if it can't be granted, block it

 * if required.

 Lock file against concurrent access */

	/* Get existing block (in case client is busy-waiting)

	 * or create new block

			/*

			 * If this is a blocking request for an

			 * already pending lock request then we need

			 * to put it back on lockd's block list

			/* Filesystem lock operation is in progress

 includes ENOLCK */

 Append to list of blocked */

/*

 * Test for presence of a conflicting lock.

 If there's a conflicting lock, remember to clean up the test lock */

 We can't currently deal with deferred test requests */

 FIXME */

 don't return OH info */

 Clean up the test lock */

/*

 * Remove a lock.

 * This implies a CANCEL call: We send a GRANT_MSG, the client replies

 * with a GRANT_RES call which gets lost, and calls UNLOCK immediately

 * afterwards. In this case the block will still be there, and hence

 * must be removed.

 First, cancel any lock that might be there */

/*

 * Cancel a previously blocked request.

 *

 * A cancel request always overrides any grant that may currently

 * be in progress.

 * The calling procedure must check whether the file can be closed.

/*

 * This is a callback from the filesystem for VFS file lock requests.

 * It will be used if lm_grant is defined and the filesystem can not

 * respond to the request immediately.

 * For SETLK or SETLKW request it will get the local posix lock.

 * In all cases it will move the block to the head of nlm_blocked q where

 * nlmsvc_retry_blocked() can send back a reply for SETLKW or revisit the

 * deferred rpc for GETLK and SETLK.

/*

 * Unblock a blocked lock request. This is a callback invoked from the

 * VFS layer when a lock on which we blocked is removed.

 *

 * This function doesn't grant the blocked lock instantly, but rather moves

 * the block to the head of nlm_blocked where it can be picked up by lockd.

/*

 * Try to claim a lock that was previously blocked.

 *

 * Note that we use both the RPC_GRANTED_MSG call _and_ an async

 * RPC thread when notifying the client. This seems like overkill...

 * Here's why:

 *  -	we don't want to use a synchronous RPC thread, otherwise

 *	we might find ourselves hanging on a dead portmapper.

 *  -	Some lockd implementations (e.g. HP) don't react to

 *	RPC_GRANTED calls; they seem to insist on RPC_GRANTED_MSG calls.

 Unlink block request from list */

	/* If b_granted is true this means we've been here before.

	 * Just retry the grant callback, possibly refreshing the RPC

 Try the lock operation again */

	/* vfs_lock_file() can mangle fl_start and fl_end, but we need

	 * them unchanged for the GRANT_MSG

 Lock was granted by VFS. */

	/* keep block on the list, but don't reattempt until the RPC

	 * completes or the submission fails

	/* Call the client -- use a soft RPC task since nlmsvc_retry_blocked

	 * will queue up a new one if this one times out

 RPC submission failed, wait a bit and retry */

/*

 * This is the callback from the RPC layer when the NLM_GRANTED_MSG

 * RPC call has succeeded or timed out.

 * Like all RPC callbacks, it is invoked by the rpciod process, so it

 * better not sleep. Therefore, we put the blocked lock on the nlm_blocked

 * chain once more in order to have it removed by lockd itself (which can

 * then sleep on the file semaphore without disrupting e.g. the nfs client).

	/* if the block is not on a list at this point then it has

	 * been invalidated. Don't try to requeue it.

	 *

	 * FIXME: it's possible that the block is removed from the list

	 * after this check but before the nlmsvc_insert_block. In that

	 * case it will be added back. Perhaps we need better locking

	 * for nlm_blocked?

	/* Technically, we should down the file semaphore here. Since we

	 * move the block towards the head of the queue only, no harm

 RPC error: Re-insert for retransmission */

 Call was successful, now wait for client callback */

/*

 * FIXME: nlmsvc_release_block() grabs a mutex.  This is not allowed for an

 * .rpc_release rpc_call_op

/*

 * We received a GRANT_RES callback. Try to find the corresponding

 * block.

 Try again in a couple of seconds */

		/*

		 * Lock is now held by client, or has been rejected.

		 * In both cases, the block should be removed.

/* Helper function to handle retry of a deferred block.

 * If it is a blocking lock, call grant_blocked.

 * For a non-blocking lock or test lock, revisit the request.

/*

 * Retry all blocked locks that have been notified. This is where lockd

 * picks up locks that can be granted, or grant notifications that must

 * be retransmitted.

 SPDX-License-Identifier: GPL-2.0

/*

 * linux/fs/lockd/host.c

 *

 * Management for NLM peer hosts. The nlm_host struct is shared

 * between client and server implementation. The only reason to

 * do so is to reduce code bloat.

 *

 * Copyright (C) 1996, Olaf Kirch <okir@monad.swb.de>

 search for server|client */

 address to search for */

 it's length */

 transport to search for*/

 NLM version to search for */

 remote's hostname */

 it's length */

 use non-priv port */

 network namespace to bind */

/*

 * Hash function must work well on big- and little-endian platforms

/*

 * Allocate and initialize an nlm_host.  Common to both client and server.

/*

 * Destroy an nlm_host and free associated resources

 *

 * Caller must hold nlm_host_mutex.

/**

 * nlmclnt_lookup_host - Find an NLM host handle matching a remote server

 * @sap: network address of server

 * @salen: length of server address

 * @protocol: transport protocol to use

 * @version: NLM protocol version

 * @hostname: '\0'-terminated hostname of server

 * @noresvport: 1 if non-privileged port should be used

 * @net: pointer to net namespace

 * @cred: pointer to cred

 *

 * Returns an nlm_host structure that matches the passed-in

 * [server address, transport protocol, NLM version, server hostname].

 * If one doesn't already exist in the host cache, a new handle is

 * created and returned.

 Same address. Share an NSM handle if we already have one */

/**

 * nlmclnt_release_host - release client nlm_host

 * @host: nlm_host to release

 *

/**

 * nlmsvc_lookup_host - Find an NLM host handle matching a remote client

 * @rqstp: incoming NLM request

 * @hostname: name of client host

 * @hostname_len: length of client hostname

 *

 * Returns an nlm_host structure that matches the [client address,

 * transport protocol, NLM version, client hostname] of the passed-in

 * NLM request.  If one doesn't already exist in the host cache, a

 * new handle is created and returned.

 *

 * Before possibly creating a new nlm_host, construct a sockaddr

 * for a specific source address in case the local system has

 * multiple network addresses.  The family of the address in

 * rq_daddr is guaranteed to be the same as the family of the

 * address in rq_addr, so it's safe to use the same family for

 * the source address.

 Same address. Share an NSM handle if we already have one */

 Move to head of hash chain. */

/**

 * nlmsvc_release_host - release server nlm_host

 * @host: nlm_host to release

 *

 * Host is destroyed later in nlm_gc_host().

/*

 * Create the NLM RPC client for an NLM peer

 Lock host handle */

	/* If we've already created an RPC client, check whether

	 * RPC rebind is required

		/*

		 * lockd retries server side blocks automatically so we want

		 * those to be soft RPC calls. Client side calls need to be

		 * hard RPC tasks.

/**

 * nlm_rebind_host - If needed, force a portmap lookup of the peer's lockd port

 * @host: NLM host handle for peer

 *

 * This is not needed when using a connection-oriented protocol, such as TCP.

 * The existing autobind mechanism is sufficient to force a rebind when

 * required, e.g. on connection state transitions.

/*

 * Increment NLM host count

/**

 * nlm_host_rebooted - Release all resources held by rebooted host

 * @net:  network namespace

 * @info: pointer to decoded results of NLM_SM_NOTIFY call

 *

 * We were notified that the specified host has rebooted.  Release

 * all resources held by that peer.

	/* Mark all hosts tied to this NSM state as having rebooted.

	 * We run the loop repeatedly, because we drop the host table

	 * lock for this.

	 * To avoid processing a host several times, we match the nsmstate.

 First, make all hosts eligible for gc */

 Then, perform a garbage collection pass */

/*

 * Shut down the hosts module.

 * Note that this routine is called only at server shutdown time.

/*

 * Garbage collect any unused NLM hosts.

 * This GC combines reference counting for async operations with

 * mark & sweep for resources held by remote clients.

 Mark all hosts that hold locks, blocks or shares */

 SPDX-License-Identifier: GPL-2.0

/*

 * Procfs support for lockd

 *

 * Copyright (c) 2014 Jeff Layton <jlayton@primarydata.com>

/*

 * We only allow strings that start with 'Y', 'y', or '1'.

 SPDX-License-Identifier: GPL-2.0

/*

 * QNX6 file system, Linux implementation.

 *

 * Version : 1.0.0

 *

 * History :

 *

 * 01-02-2012 by Kai Bankett (chaosman@ontika.net) : first release.

 * 16-02-2012 pagemap extension by Al Viro

 *

 SPDX-License-Identifier: GPL-2.0

/*

 * QNX6 file system, Linux implementation.

 *

 * Version : 1.0.0

 *

 * History :

 *

 * 01-02-2012 by Kai Bankett (chaosman@ontika.net) : first release.

 *

 the rest of the superblock is the same */

	/* Check the superblock signatures

 checksum check - start at byte 8 and end at byte 512 */

 calculate second superblock blocknumber */

 set new blocksize */

 blocksize invalidates bh - pull it back in */

 read second superblock */

 checksum check - start at byte 8 and end at byte 512 */

 superblock #1 active */

 superblock #2 active */

 offset for mmi_fs is just SUPERBLOCK_AREA bytes */

 success */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * QNX6 file system, Linux implementation.

 *

 * Version : 1.0.0

 *

 * History :

 *

 * 01-02-2012 by Kai Bankett (chaosman@ontika.net) : first release.

 * 16-02-2012 pagemap extension by Al Viro

 *

 logical block is before EOF */

/*

 * returns the block number for the no-th element in the tree

 * inodebits requred as there are multiple inodes in one inode block

/*

 * Check the root directory of the filesystem to make sure

 * it really _is_ a qnx6 filesystem, and to check the size

 * of the directory entry.

 maximum 3 bytes - due to match_root limitation */

	/* Check the superblock signatures

 we got a big endian fs */

 Superblock always is 512 Byte long */

 parse the mount-options */

	/* Check the superblock signatures

 try again without bootblock offset */

 seems that no bootblock at partition start */

 checksum check - start at byte 8 and end at byte 512 */

 set new blocksize */

 blocksize invalidates bh - pull it back in */

 calculate second superblock blocknumber */

 set bootblock offset */

 next the second superblock */

 checksum check - start at byte 8 and end at byte 512 */

 superblock #1 active */

 superblock #2 active */

 sanity check - limit maximum indirect pointer levels */

 Yup, read-only yet */

 ease the later tree level calculations */

 prefetch root inode */

 probably wrong */

 calc blocks based on 512 byte blocksize */

	/*

	 * Make sure all delayed rcu free inodes are flushed before we

	 * destroy cache.

 SPDX-License-Identifier: GPL-2.0

/*

 * QNX6 file system, Linux implementation.

 *

 * Version : 1.0.0

 *

 * History :

 *

 * 01-02-2012 by Kai Bankett (chaosman@ontika.net) : first release.

 * 16-02-2012 pagemap extension by Al Viro

 *

 in block units */

 in pages */

 within page */

		/* error - long filename entries always have size 0xff

	/* calc & validate longfilename checksum

 success */

				/* long filename detected

				   get the filename from long filename

/*

 * check if the long filename is correct.

/*

 * check if the filename is correct.

 short filename */

 deal with long filename */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  linux/fs/fat/inode.c

 *

 *  Written 1992,1993 by Werner Almesberger

 *  VFAT extensions by Gordon Chaffee, merged with msdos fs by Henrik Storner

 *  Rewritten for the constant inumbers support by Al Viro

 *

 *  Fixes:

 *

 *	Max Cohan: Fixed invalid FSINFO offset when info_sector is 0

 if user don't select VFAT, this is undefined. */

 DOS dates from 1980/1/1 through 2107/12/31 */

/*

 * A deserialized copy of the on-disk structure laid out in struct

 * fat_boot_sector.

	/* FIXME: this cluster should be added after data of this

	/*

	 * allocate a cluster according to the following.

	 * 1) no more available blocks

	 * 2) not part of fallocate region

 TODO: multiple cluster allocation would be desirable. */

 available blocks on this cluster */

		/*

		 * FIXME: blockdev_direct_IO() doesn't use ->write_begin(),

		 * so we need to update the ->mmu_private to block boundary.

		 *

		 * But we must fill the remaining area or hole by nul for

		 * updating ->mmu_private.

		 *

		 * Return 0, and fallback to normal buffered write.

	/*

	 * FAT need to use the DIO_LOCKING for avoiding the race

	 * condition of fat_get_block() and ->truncate().

 fat_get_cluster() assumes the requested blocknr isn't truncated. */

/*

 * fat_block_truncate_page() zeroes out a mapping from file offset `from'

 * up to the end of the block which corresponds to `from'.

 * This is required during truncate to physically zeroout the tail end

 * of that block so it doesn't yield old data if the file is later grown.

 * Also, avoid causing failure from fsx for cases of "data past EOF"

/*

 * New FAT inode stuff. We do the following:

 *	a) i_ino is constant and has nothing with on-disk location.

 *	b) FAT manages its own cache of directory entries.

 *	c) *This* cache is indexed by on-disk location.

 *	d) inode has an associated directory entry, all right, but

 *		it may be unhashed.

 *	e) currently entries are stored within struct inode. That should

 *		change.

 *	f) we deal with races in the following way:

 *		1. readdir() and lookup() do FAT-dir-cache lookup.

 *		2. rename() unhashes the F-d-c entry and rehashes it in

 *			a new place.

 *		3. unlink() and rmdir() unhash F-d-c entry.

 *		4. fat_write_inode() checks whether the thing is unhashed.

 *			If it is we silently return. If it isn't we do bread(),

 *			check if the location is still valid and retry if it

 *			isn't. Otherwise we do changes.

 *		5. Spinlock is used to protect hash/unhash/location check/lookup

 *		6. fat_evict_inode() unhashes the F-d-c entry.

 *		7. lookup() and readdir() do igrab() if they find a F-d-c entry

 *			and consider negative result as cache miss.

	/* If NFS support is enabled, cache the mapping of start cluster

	 * to directory inode. This is used during reconnection of

	 * dentries to the filesystem root.

 Directory should have "."/".." entries at least. */

 Directory should point valid cluster. */

 doesn't deal with root inode */

 not a directory */

 Release unwritten fallocated blocks on inode eviction. */

		/* Fallocate results in updating the i_start/iogstart

		 * for the zero byte file. So, make it return to

		 * original state during evict and commit it to avoid

		 * any corruption on the next access to the cluster

		 * chain for the file.

 do not change any thing if mounted read only */

 do not change state if fs was dirty */

 warn only on set (mount). */

 fat 16 and 12 */ {

 Note: opts->iocharset can be NULL here */

 Zeroing to allow iput() even if partial initialized inode. */

	/*

	 * Make sure all delayed rcu free inodes are flushed before we

	 * destroy cache.

 make sure we update state on remount. */

 If the count of free cluster is still unknown, counts it here. */

 strip "cp" prefix from displayed option */

 0 or no or false */

 empty or 1 or yes or true */

 0 or no or false */

 empty or 1 or yes or true */

 0 or no or false */

 empty or 1 or yes or true */

 for backward compatibility */

			/*

			 * GMT+-12 zones may have DST corrections so at least

			 * 13 hours difference is needed. Make the limit 24

			 * just in case someone invents something unusual.

 msdos specific */

 vfat specific */

 0 or no or false */

 empty or 1 or yes or true */

 0 or no or false */

 empty or 1 or yes or true */

 0 or no or false */

 negated option */

 empty or 1 or yes or true */

 negated option */

 obsolete mount options */

 unknown option */

 UTF-8 doesn't provide FAT semantics */

 If user doesn't specify allow_utime, it's initialized from dmask. */

 Divide first to avoid overflow */

 Read in BPB ... */

 Validate this looks like a FAT filesystem BPB */

	/*

	 * Earlier we checked here that b->secs_track and b->head are nonzero,

	 * but it turns out valid FAT filesystems can have zero there.

 16-bit DOS 1.x reliably wrote bootstrap short-jmp code */

	/*

	 * If any value in this region is non-zero, it isn't archaic

	 * DOS.

/*

 * Read the super block of an MS-DOS FS.

	/*

	 * GFP_KERNEL is ok here, because while we do hold the

	 * superblock lock, memory pressure can't call back into

	 * the filesystem, since we're only just about to mount

	 * it and have no inodes etc active!

	/*

	 * fat timestamps are complex and truncated by fat itself, so

	 * we set 1 here to be fast

 flavour-specific stuff that needs options */

 Verify that the larger boot sector is fully readable */

 Don't know yet */

 Don't know yet */

 Must be FAT32 */

 MC - if info_sector is 0, don't multiply by 0 */

 interpret volume ID as a little endian 32 bit integer */

 fat 16 or 12 */

 some OSes set FAT_STATE_DIRTY and clean it on unmount. */

 fat 16 or 12 */

 check that FAT table does not overflow */

 check the free_clusters, it's not necessarily correct */

 check the prev_free, it's not necessarily correct */

 set up enough so that it can read an inode */

	/*

	 * The low byte of the first FAT entry must have the same value as

	 * the media field of the boot sector. But in real world, too many

	 * devices are writing wrong values. So, removed that validity check.

	 *

	 * The removed check compared the first FAT entry to a value dependent

	 * on the media field like this:

	 * == (0x0F00 | media), for FAT12

	 * == (0XFF00 | media), for FAT16

	 * == (0x0FFFFF | media), for FAT32

 FIXME: utf8 is using iocharset for upper/lower conversion */

/*

 * helper function for fat_flush_inodes.  This writes both the inode

 * and the file data blocks, waiting for in flight data blocks before

 * the start of the call.  It does not wait for any io started

 * during the call

	/* if we used wait=1, sync_inode_metadata waits for the io for the

	* inode to finish.  So wait=0 is sent down to sync_inode_metadata

	* and filemap_fdatawrite is used for the data blocks

/*

 * write data and metadata corresponding to i1 and i2.  The io is

 * started but we do not wait for any of it to finish.

 *

 * filemap_flush is used for the block device, so if there is a dirty

 * page for a block already in flight, we will not wait and start the

 * io over again

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  linux/fs/fat/dir.c

 *

 *  directory handling functions for fat-based filesystems

 *

 *  Written 1992,1993 by Werner Almesberger

 *

 *  Hidden files 1995 by Albert Cahalan <albert@ccs.neu.edu> <adc@coe.neu.edu>

 *

 *  VFAT extensions by Gordon Chaffee <chaffee@plateau.cs.berkeley.edu>

 *  Merged with msdos fs by Henrik Storner <storner@osiris.ping.dk>

 *  Rewritten for constant inumbers. Plugged buffer overrun in readdir(). AV

 *  Short name translation 1999, 2001 by Wolfram Pienkoss <wp@bszh.de>

/*

 * Maximum buffer size of short name.

 * [(MSDOS_NAME + '.') * max one char + nul]

 * For msdos style, ['.' (hidden) + MSDOS_NAME + '.' + nul]

/*

 * Maximum buffer size of unicode chars from slots.

 * [(max longname slots * 13 (size in a slot) + nul) * sizeof(wchar_t)]

 This is not a first sector of cluster, or sec_per_clus == 1 */

 root dir of FAT12/FAT16 */

/* Returns the inode number of the directory entry at offset pos. If bh is

   non-NULL, it is brelse'd before. Pos is incremented. The buffer header is

   returned in bh.

   AV. Most often we do it item-by-item. Makes sense to optimize.

   AV. OK, there we go: if both bh and de are non-NULL we assume that we just

   AV. want the next entry (took one explicit de=NULL in vfat/namei.c).

   AV. It's done in fat_get_entry() (inlined), here the slow case lives.

   AV. Additionally, when we return -1 (i.e. reached the end of directory)

   AV. we make bh NULL.

 beyond EOF or error */

 skip this block */

 Fast stuff first */

/*

 * Convert Unicode 16 to UTF-8, translated Unicode, or ASCII.

 * If uni_xlate is enabled and we can't get a 1:1 conversion, use a

 * colon as an escape character since it is normally invalid on the vfat

 * filesystem. The following four characters are the hexadecimal digits

 * of Unicode value. This lets us do a full dump and restore of Unicode

 * filenames. We could get into some trouble with long Unicode names,

 * but ignore that right now.

 * Ahem... Stack smashing in ring 0 isn't fun. Fixed.

 a question mark */

 a question mark */

 a question mark */

/**

 * fat_parse_long - Parse extended directory entry.

 *

 * This function returns zero on success, negative value on error, or one of

 * the following:

 *

 * %PARSE_INVALID - Directory entry is invalid.

 * %PARSE_NOT_LONGNAME - Directory entry does not contain longname.

 * %PARSE_EOF - Directory has no more entries.

 ceil(256 * 2 / 26) */

/**

 * fat_parse_short - Parse MS-DOS (short) directory entry.

 * @sb:		superblock

 * @de:		directory entry to parse

 * @name:	FAT_MAX_SHORT_SIZE array in which to place extracted name

 * @dot_hidden:	Nonzero == prepend '.' to names with ATTR_HIDDEN

 *

 * Returns the number of characters extracted into 'name'.

	/* For an explanation of the special treatment of 0x05 in

	 * filenames, see msdos_format_name in namei_msdos.c

 Filename */

 Extension */

/*

 * Return values: negative -> error/not found, 0 -> found.

		/* Never prepend '.' to hidden files here.

		 * That is done only for msdos mounts (and only when

		 * 'dotsOK=yes'); if we are executing here, it is in the

		 * context of a vfat mount.

 Compare shortname */

 Compare longname */

 include the de */

 for dir ioctl */

 Fake . and .. for the root directory. */

	/*

	 * Check for long filename entry, but if short_only, we don't

	 * need to parse long filename.

 !both && !short_only, so we don't need shortname. */

 hack for fat_ioctl_filldir() */

 dirent has only short name */			   \

 dirent has short and long name */			   \

	/*

	 * Yes, we don't need this put_user() absolutely. However old

	 * code didn't return the right value. So, app use this value,

	 * in order to check whether it is EOF.

	/*

	 * Yes, we don't need this put_user() absolutely. However old

	 * code didn't return the right value. So, app use this value,

	 * in order to check whether it is EOF.

 CONFIG_COMPAT */

 free entry or long name entry or volume label */

/*

 * The ".." entry can not provide the "struct fat_slot_info" information

 * for inode, nor a usable i_pos. So, this function provides some information

 * only.

 *

 * Since this function walks through the on-disk inodes within a directory,

 * callers are responsible for taking any locks necessary to prevent the

 * directory from changing.

 See if directory is empty */

/*

 * fat_subdirs counts the number of sub-directories of dir. It can be run

 * on directories being created.

/*

 * Scans a directory for a given file (name points to its formatted name).

 * Returns an error code or zero.

/*

 * Scans a directory for a given logstart.

 * Returns an error code or zero.

 pos is *next* de's position, so this does `- sizeof(de)' */

	/*

	 * First stage: Remove the shortname. By this, the directory

	 * entry is removed.

		/*

		 * Second stage: remove the remaining longname slots.

		 * (This directory entry is already removed, and so return

		 * the success)

 Zeroing the unused blocks on this cluster */

 Avoid race with userspace read via bdev */

 Avoid race with userspace read via bdev */

 filling the new directory slots ("." and ".." entries) */

 extra timestamps */

	/*

	 * The minimum cluster size is 512bytes, and maximum entry

	 * size is 32*slots (672bytes).  So, iff the cluster size is

	 * 512bytes, we may need two clusters.

	/*

	 * First stage: Fill the directory entry.  NOTE: This cluster

	 * is not referenced from any inode yet, so updates order is

	 * not important.

 fill the directory entry */

 Avoid race with userspace read via bdev */

 Second stage: clear the rest of cluster, and write outs */

 32*slots (672bytes) */

 First stage: search free directory entries */

 check the maximum size of directory */

		/*

		 * Second stage: filling the free entries with new entries.

		 * NOTE: If this slots has shortname, first, we write

		 * the long name slots, then write the short name.

 Fill the long name slots. */

 Fill the short name slot. */

		/*

		 * Third stage: allocate the cluster for new entries.

		 * And initialize the cluster with new entries, then

		 * add the cluster to dir.

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  linux/fs/fat/misc.c

 *

 *  Written 1992,1993 by Werner Almesberger

 *  22/11/2000 - Fixed fat_date_unix2dos for dates earlier than 01/01/1980

 *		 and date_dos2unix for date==0 by Igor Zhbanov(bsg@uniyar.ac.ru)

/*

 * fat_fs_error reports a file system problem that might indicate fa data

 * corruption/inconsistency. Depending on 'errors' mount option the

 * panic() is called, or error message is printed FAT and nothing is done,

 * or filesystem is remounted read-only (default behavior).

 * In case the file system is remounted read-only, it can be made writable

 * again by remounting it.

/**

 * fat_msg() - print preformated FAT specific messages. Every thing what is

 * not fat_fs_error() should be fat_msg().

 Flushes the number of free clusters on FAT32 */

 XXX: Need to write one per FSINFO block.  Currently only writes 1 */

 Sanity check */

/*

 * fat_chain_add() adds a new cluster to the chain of clusters represented

 * by inode.

	/*

	 * We must locate the last cluster of the file to add this new

	 * one (new_dclus) to the end of the link list (the FAT).

 add new one to the last of the cluster chain */

		/*

		 * FIXME:Although we can add this cache, fat_cache_add() is

		 * assuming to be called after linear search with fat_cache_id.

		fat_cache_add(inode, new_fclus, new_dclus);

		/*

		 * Since generic_write_sync() synchronizes regular files later,

		 * we sync here only directories.

/*

 * The epoch of FAT timestamp is 1980.

 *     :  bits :     value

 * date:  0 -  4: day	(1 -  31)

 * date:  5 -  8: month	(1 -  12)

 * date:  9 - 15: year	(0 - 127) from 1980

 * time:  0 -  4: sec	(0 -  29) 2sec counts

 * time:  5 - 10: min	(0 -  59)

 * time: 11 - 15: hour	(0 -  23)

 days between 1.1.70 and 1.1.80 (2 leap days) */

 120 (2100 - 1980) isn't leap year */

 Linear day numbers of the respective 1sts in non-leap years. */

 Jan  Feb  Mar  Apr  May  Jun  Jul  Aug  Sep  Oct  Nov  Dec */

 Convert a FAT time/date pair to a UNIX date (seconds since 1 1 70). */

 2100 isn't leap year */

 Export fat_time_fat2unix() for the fat_test KUnit tests. */

 Convert linear UNIX date to a FAT time/date pair. */

  FAT can only support year between 1980 to 2107 */

 from 1900 -> from 1980 */

 0~11 -> 1~12 */

 0~59 -> 0~29(2sec counts) */

/*

 * truncate the various times with appropriate granularity:

 *   root inode:

 *     all times always 0

 *   all other inodes:

 *     mtime - 2 seconds

 *     ctime

 *       msdos - 2 seconds

 *       vfat  - 10 milliseconds

 *     atime - 24 hours (00:00:00 in local timezone)

 to localtime */

 to day boundary, and back to unix time */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  linux/fs/fat/file.c

 *

 *  Written 1992,1993 by Werner Almesberger

 *

 *  regular file handling primitives for fat-based filesystems

	/*

	 * ATTR_VOLUME and ATTR_DIR cannot be changed; this also

	 * prevents the user from turning us into a VFAT

	 * longname entry.  Also, we obviously can't set

	 * any of the NTFS attributes in the high 24 bits.

 Merge in ATTR_VOLUME and ATTR_DIR */

 Equivalent to a chmod() */

 The root directory has no attributes */

	/*

	 * The security check is questionable...  We single

	 * out the RO attribute for checking by the security

	 * module, just because it maps to a file mode.

 This MUST be done before doing anything irreversible... */

 Inappropriate ioctl for device */

		/*

		 * Opencode syncing since we don't have a file open to use

		 * standard fsync path.

/*

 * Preallocate space for a file. This implements fat's fallocate file

 * operation, which gets called from sys_fallocate system call. User

 * space requests len bytes at offset. If FALLOC_FL_KEEP_SIZE is set

 * we just allocate clusters without zeroing them out. Otherwise we

 * allocate and zero out clusters via an expanding truncate.

 Number of clusters to be allocated */

 Number of bytes to be allocated for file */

 block aligned on-disk size in bytes*/

 No support for hole punch or other fallocate flags. */

 No support for dir */

 First compute the number of clusters to be allocated */

 Start the allocation.We are not zeroing out the clusters */

 This is just an expanding truncate */

 Free all clusters after the skip'th cluster. */

 First, we write the new file size. */

 Write a new EOF, and get the remaining cluster chain for freeing. */

 Freeing the remained cluster chain */

	/*

	 * This protects against truncating a file bigger than it was then

	 * trying to write into the hole.

 Use i_pos for ino. This is used as fileid of nfs. */

	/*

	 * Note, the basic check is already done by a caller of

	 * (attr->ia_mode & ~FAT_VALID_MODE)

	/*

	 * Of the r and x bits, all (subject to umask) must be present. Of the

	 * w bits, either all (subject to umask) or none must be present.

	 *

	 * If fat_mode_can_hold_ro(inode) is false, can't change w bits.

 use a default check */

 valid file mode bits */

 Check for setting the inode time. */

	/*

	 * Expand the file. Since inode_setattr() updates ->i_size

	 * before calling the ->truncate(), but FAT needs to fill the

	 * hole before it. XXX: this is no longer true with new truncate

	 * sequence.

	/*

	 * We don't return -EPERM here. Yes, strange, but this is too

	 * old behavior.

	/*

	 * setattr_copy can't truncate these appropriately, so we'll

	 * copy them ourselves

 SPDX-License-Identifier: GPL-2.0-only

/* fs/fat/nfs.c

/**

 * Look up a directory inode given its starting cluster.

		/* If a file is deleted on server and client is not updated

		 * yet, we must not build the inode upon a lookup call.

/**

 * Map a NFS file handle to a corresponding dentry.

 * The dentry may or may not be connected to the filesystem root.

/*

 * Find the parent for a file specified by NFS handle.

 * This requires that the handle contain the i_ino of the parent.

/*

 * Rebuild the parent for a directory that is not connected

 *  to the filesystem root

/*

 * Find the parent for a directory that is not currently connected to

 * the filesystem root.

 *

 * On entry, the caller holds d_inode(child_dir)->i_mutex.

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/fat/cache.c

 *

 *  Written 1992,1993 by Werner Almesberger

 *

 *  Mar 1999. AV. Changed cache, so that it uses the starting cluster instead

 *	of inode number.

 *  May 1999. AV. Fixed the bogosity with FAT32 (read "FAT28"). Fscking lusers.

 this must be > 0. */

 number of contiguous clusters */

 cluster number in the file. */

 cluster number on disk. */

 Find the cache of "fclus" or nearest cache. */

 Find the same part as "new" in cluster-chain. */

 dummy cache */

 this cache was invalidated */

/*

 * Cache invalidation occurs rarely, thus the LRU chain is not updated. It

 * fixes itself after a while.

 Update. The copy of caches before this id is discarded. */

		/*

		 * dummy, always not contiguous

		 * This is reinitialized by cache_init(), later.

 prevent the infinite loop of cluster chain */

		/*

		 * ->mmu_private can access on only allocation path.

		 * (caller must hold ->i_mutex)

 SPDX-License-Identifier: GPL-2.0

/*

 * KUnit tests for FAT filesystems.

 *

 * Copyright (C) 2020 Google LLC.

 * Author: David Gow <davidgow@google.com>

 With no extension. */

 With 3-letter extension. */

 With short (1-letter) extension. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  linux/fs/vfat/namei.c

 *

 *  Written 1992,1993 by Werner Almesberger

 *

 *  Windows95/Windows NT compatible extended MSDOS filesystem

 *    by Gordon Chaffee Copyright (C) 1995.  Send bug reports for the

 *    VFAT filesystem to <chaffee@cs.berkeley.edu>.  Specify

 *    what file operation caused you trouble and if you can duplicate

 *    the problem, send a script that demonstrates it.

 *

 *  Short name translation 1999, 2001 by Wolfram Pienkoss <wp@bszh.de>

 *

 *  Support Multibyte characters and cleanup by

 *				OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>

/*

 * If new entry was created in the parent, it could create the 8.3

 * alias (the shortname of logname).  So, the parent may have the

 * negative-dentry which matches the created 8.3 alias.

 *

 * If it happened, the negative dentry isn't actually negative

 * anymore.  So, drop it.

 This is not negative dentry. Always valid. */

	/*

	 * This is not negative dentry. Always valid.

	 *

	 * Note, rename() to existing directory entry will have ->d_inode,

	 * and will use existing name which isn't specified name by user.

	 *

	 * We may be able to drop this positive dentry here. But dropping

	 * positive dentry isn't good idea. So it's unsupported like

	 * rename("filename", "FILENAME") for now.

	/*

	 * This may be nfsd (or something), anyway, we can't see the

	 * intent of this. So, since this can be for creation, drop it.

	/*

	 * Drop the negative dentry, in order to make sure to use the

	 * case sensitive name which is specified by user if this is

	 * for creation.

 returns the length of a struct qstr, ignoring trailing dots */

/*

 * Compute the hash for the vfat name corresponding to the dentry.

 * Note: if the name is invalid, we leave the hash code unchanged so

 * that the existing dentry can be used. The vfat fs routines will

 * return ENOENT or EINVAL as appropriate.

/*

 * Compute the hash for the vfat name corresponding to the dentry.

 * Note: if the name is invalid, we leave the hash code unchanged so

 * that the existing dentry can be used. The vfat fs routines will

 * return ENOENT or EINVAL as appropriate.

/*

 * Case insensitive compare of two vfat names.

 A filename cannot end in '.' or we treat it like it has none */

/*

 * Case sensitive compare of two vfat names.

 A filename cannot end in '.' or we treat it like it has none */

 Characters that are undesirable in an MS-DOS file name */

 last character cannot be space */

/*

 * 1) Valid characters for the 8.3 format alias are any combination of

 * letters, uppercase alphabets, digits, any of the

 * following special characters:

 *     $ % ' ` - @ { } ~ ! # ( ) & _ ^

 * In this case Longfilename is not stored in disk.

 *

 * WinNT's Extension:

 * File name and extension name is contain uppercase/lowercase

 * only. And it is expressed by CASE_LOWER_BASE and CASE_LOWER_EXT.

 *

 * 2) File name is 8.3 format, but it contain the uppercase and

 * lowercase char, muliti bytes char, etc. In this case numtail is not

 * added, but Longfilename is stored.

 *

 * 3) When the one except for the above, or the following special

 * character are contained:

 *        .   [ ] ; , + =

 * numtail is added, and Longfilename must be stored in disk .

/*

 * Given a valid longname, create a unique shortname.  Make sure the

 * shortname does not exist

 * Returns negative number on error, 0 for a normal

 * return, and 1 for valid shortname

 Now, we need to create a shortname from the long name */

 is `.' */

		/*

		 * Names which start with a dot could be just

		 * an extension eg. "...test".  In this case Win95

		 * uses the extension as the name and sets no extension.

 Yes, it can happen. ".\xe5" would do it. */

	/* OK, at this point we know that base is not longer than 8 symbols,

	 * ext is not longer than 3, base is nonempty, both don't contain

	 * any bad symbols (lowercase transformed to uppercase).

	/*

	 * Try to find a unique extension.  This used to

	 * iterate through all possibilities sequentially,

	 * but that gave extremely bad performance.  Windows

	 * only tries a few cases before using random

	 * values for part of the base.

 Translate a string, including coded sequences into Unicode */

 build the entry of long file name */

 build the entry of 8.3 alias name */

 update timestamp */

	/*

	 * Checking "alias->d_parent == dentry->d_parent" to make sure

	 * FS is not corrupted (especially double linked dir).

		/*

		 * This inode has non anonymous-DCACHE_DISCONNECTED

		 * dentry. This means, the user did ->lookup() by an

		 * another name (longname vs 8.3 alias of it) in past.

		 *

		 * Switch to new one for reason of locality if possible.

 timestamp is already written, so mark_inode_dirty() is unneeded. */

 and releases bh */

 and releases bh */

 the directory was completed, just return a error */

 timestamp is already written, so mark_inode_dirty() is unneeded. */

 and releases bh */

 data cluster is shared, serious corruption */

		/*

		 * If new entry was not sharing the data cluster, it

		 * shouldn't be serious corruption.

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  linux/fs/msdos/namei.c

 *

 *  Written 1992,1993 by Werner Almesberger

 *  Hidden files 1995 by Albert Cahalan <albert@ccs.neu.edu> <adc@coe.neu.edu>

 *  Rewritten for constant inumbers 1999 by Al Viro

 Characters that are undesirable in an MS-DOS file name */

**** Formats an MS-DOS file name. Rejects invalid names. */

	/*

	 * name is the proposed name, len is its length, res is

	 * the resulting name, opts->name_check is either (r)elaxed,

	 * (n)ormal or (s)trict, opts->dotsOK allows dots at the

	 * beginning of name (for hidden files)

 dotfile because . and .. already done */

 Get rid of dot - test for it elsewhere */

	/*

	 * disallow names that _really_ start with a dot

	/*

	 * 0xE5 is legal as a first character, but we must substitute

	 * 0x05 because 0xE5 marks deleted files.  Yes, DOS really

	 * does this.

	 * It seems that Microsoft hacked DOS to support non-US

	 * characters after the 0xE5 character was already in use to

	 * mark deleted files.

**** Locates a directory entry.  Uses unformatted name. */

/*

 * Compute the hash for the msdos name corresponding to the dentry.

 * Note: if the name is invalid, we leave the hash code unchanged so

 * that the existing dentry can be used. The msdos fs routines will

 * return ENOENT or EINVAL as appropriate.

/*

 * Compare two msdos names. If either of the names are invalid,

 * we fall back to doing the standard name comparison.

/*

 * AV. Wrappers for FAT sb operations. Is it wise?

**** Get inode using directory and name */

**** Creates a directory entry (name is already formatted). */

**** Create a file */

 Have to do it due to foo vs. .foo conflicts */

 timestamp is already written, so mark_inode_dirty() is unneeded. */

**** Remove a directory */

 and releases bh */

**** Make a directory */

 foo vs .foo situation */

 the directory was completed, just return a error */

 timestamp is already written, so mark_inode_dirty() is unneeded. */

**** Unlink a file */

 and releases bh */

 "foo" -> ".foo" case. just change the ATTR_HIDDEN */

 and releases bh */

 data cluster is shared, serious corruption */

		/*

		 * If new entry was not sharing the data cluster, it

		 * shouldn't be serious corruption.

**** Rename, a wrapper for rename_same_dir & rename_diff_dir */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2004, OGAWA Hirofumi

 This entry is block boundary, it needs the next block */

 Is this fatent's blocks including this entry? */

 This entry is on bhs[0]. */

 This entry needs the next block. */

 FIXME: We can write the blocks as more big chunk. */

 Avoid race with userspace read via bdev */

 fixed limit */

 Find the free entries in a block */

 make the cluster chain */

				/*

				 * fat_collect_bhs() gets ref-count of bhs,

				 * so we can still use the prev_ent.

 Couldn't allocate the free entries */

			/*

			 * Issue discard for the sectors we no longer

			 * care about, batching contiguous clusters

			 * into one request

	/*

	 * This is the sequential read, so ra_pages * 2 (but try to

	 * align the optimal hardware IO size).

	 * [BTW, 128kb covers the whole sectors for FAT12 and FAT16]

 Initialize the range for sequential read */

 Advancing the window at half size */

 Assuming to be called before reading a new block (increments ->cur). */

		/*

		 * FIXME: we would want to directly use the bio with

		 * pages to reduce the number of segments.

 Advance the readahead window */

 readahead of fat blocks */

	/*

	 * FAT data is organized as clusters, trim at the granulary of cluster.

	 *

	 * fstrim_range is in byte, convert values to cluster index.

	 * Treat sectors before data region as all used, not to trim them.

 readahead of fat blocks */

 handle scenario when tail entries are all free */

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/isofs/namei.c

 *

 *  (C) 1992  Eric Youngdale Modified for ISO 9660 filesystem.

 *

 *  (C) 1991  Linus Torvalds - minix filesystem

/*

 * ok, we cannot use strncmp, as the name is not in our data space.

 * Thus we'll have to use isofs_match. No big problem. Match also makes

 * some sanity tests.

/*

 *	isofs_find_entry()

 *

 * finds an entry in the specified directory with the wanted name. It

 * returns the inode number of the found entry, or 0 on error.

 Make sure we have a full directory entry */

 Basic sanity check, whether name doesn't exceed dir entry */

 possibly -1 */

		/*

		 * Skip hidden or associated files unless hide or showassoc,

		 * respectively, is set

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/isofs/joliet.c

 *

 *  (C) 1996 Gordon Chaffee

 *

 *  Joliet: Microsoft's Unicode extensions to iso9660

/*

 * Convert Unicode 16 to UTF-8 or ASCII.

	/*

	 * Windows doesn't like periods at the end of a name,

	 * so neither do we

 SPDX-License-Identifier: GPL-2.0-or-later

/* -*- linux-c -*- ------------------------------------------------------- *

 *   

 *   Copyright 2001 H. Peter Anvin - All Rights Reserved

 *

/*

 * linux/fs/isofs/compress.c

 *

 * Transparent decompression of files on an iso9660 filesystem

 This should probably be global. */

/*

 * This contains the zlib memory allocation and the mutex for the

 * allocation; this avoids failures at block-decompression time.

/*

 * Read data of @inode from @block_start to @block_end and uncompress

 * to one zisofs block. Store the data in the @pages array with @pcount

 * entries. Start storing at offset @poffset of the first page.

 Empty block? */

 Because zlib is not thread-safe, do all the I/O at the top. */

	/*

	 * First block is special since it may be fractional.  We also wait for

	 * it before grabbing the zlib mutex; odds are that the subsequent

	 * blocks are going to come in in short order so we don't hold the zlib

	 * mutex longer than necessary.

 EOF, error, or trying to read beyond end of input */

 This page completed */

/*

 * Uncompress data so that pages[full_page] is fully uptodate and possibly

 * fills in other pages if we have data for them.

	/*

	 * We want to read at least 'full_page' page. Because we have to

	 * uncompress the whole compression block anyway, fill the surrounding

	 * pages with the data we have anyway...

 Find the pointer to this specific chunk */

 Note: we're not using isonum_731() here because the data is known aligned */

 Note: header_size is in 32-bit words (4 bytes) */

 Load end of the compressed block in the file */

 Traversed to next block? */

			/*

			 * Did we finish reading the page we really wanted

			 * to read?

/*

 * When decompressing, we typically obtain more than one page

 * per reference.  We inject the additional pages into the page

 * cache as a form of readahead.

	/*

	 * If this page is wholly outside i_size we just return zero;

	 * do_generic_file_read() will handle this for us

		/* We have already been given one page, this is the one

 Release any residual pages, do not SetPageUptodate */

 At this point, err contains 0 or -EIO depending on the "critical" page */

 No bmap operation supported */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  linux/fs/isofs/inode.c

 *

 *  (C) 1991  Linus Torvalds - minix filesystem

 *      1992, 1993, 1994  Eric Youngdale Modified for ISO 9660 filesystem.

 *      1994  Eberhard Mönkeberg - multi session handling.

 *      1995  Mark Dobie - allow mounting of some weird VideoCDs and PhotoCDs.

 *	1997  Gordon Chaffee - Joliet CDs

 *	1998  Eric Lammerts - ISO 9660 Level 3

 *	2004  Paul Serice - Inode Support pushed out from 4GB to 128GB

 *	2004  Paul Serice - NFS Export Operations

 max tz offset is 13 hours */

	/*

	 * Make sure all delayed rcu free inodes are flushed before we

	 * destroy cache.

 LVE */

/*

 * Compute the hash for the isofs name corresponding to the dentry.

/*

 * Compare of two isofs names.

 A filename cannot end in '.' or we treat it like it has none */

/*

 * Compute the hash for the isofs name corresponding to the dentry.

 unset */

			/*

			 * Track numbers are supposed to be in range 1-99, the

			 * mount option starts indexing at 0.

/*

 * Display the mount options in /proc/mounts.

/*

 * look if the driver can tell the multi session redirection value

 *

 * don't change this if you don't know what you do, please!

 * Multisession is legal only with XA disks.

 * A non-XA disk with more than one volume descriptor may do it right, but

 * usually is written in a nowhere standardized "multi-partition" manner.

 * Multisession uses absolute addressing (solely the first frame of the whole

 * track is #0), multi-partition uses relative addressing (each first frame of

 * each track is #0), and a track is not a session.

 *

 * A broken CDwriter software or drive firmware does not set new standards,

 * at least not if conflicting with the existing ones.

 *

 * emoenke@gwdg.de

 necessary for a valid ms_info.addr */

/*

 * Check if root directory is empty (has less than 3 files).

 *

 * Used to detect broken CDs where ISO root directory is empty but Joliet root

 * directory is OK. If such CD has Rock Ridge extensions, they will be disabled

 * (and Joliet used instead) or else no files would be visible.

/*

 * Initialize the superblock and read the root inode.

	/*

	 * First of all, get the hardware blocksize for this device.

	 * If we don't know what it is, or the hardware blocksize is

	 * larger than the blocksize the user specified, then use

	 * that value.

	/*

	 * What if bugger tells us to go beyond page size?

 default is iso9660 */

		/*

		 * Due to the overlapping physical location of the descriptors,

		 * ISO CDs can match hdp->id==HS_STANDARD_ID as well. To ensure

		 * proper identification in this case, we first check for ISO.

 Save the buffer in case we need it ... */

 Unknown supplementary volume descriptor */

 Just skip any volume descriptors we don't recognize */

	/*

	 * If we fall through, either no volume descriptor was found,

	 * or else we passed a primary descriptor looking for others.

 We don't support read-write mounts */

		/* This is the case of Joliet with the norock mount flag.

		 * A disc with both Joliet and Rock Ridge is handled later

 No way to figure this out easily */

	/*

	 * If the zone size is smaller than the hardware sector size,

	 * this is a fatal error.  This would occur if the disc drive

	 * had sectors that were 2048 bytes, but the filesystem had

	 * blocks that were 512 bytes (which should only very rarely

	 * happen.)

 RDE: convert log zone size to bit shift */

	/*

	 * With multi-extent files, file size is only limited by the maximum

	 * size of a file system, which is 8 TB.

 ECMA-119 timestamp from 1900/1/1 with tz offset */

	/* Set this for reference. Its not currently used except on write

	/*

	 * If the Joliet level is set, we _may_ decide to use the

	 * secondary descriptor, but can't be sure until after we

	 * read the root inode. But before reading the root inode

	 * we may need to change the device blocksize, and would

	 * rather release the old buffer first. So, we cache the

	 * first_data_zone value from the secondary descriptor.

	/*

	 * We're all done using the volume descriptor, and may need

	 * to change the device blocksize, so release the buffer now.

	/*

	 * Force the blocksize to 512 for 512 byte sectors.  The file

	 * read primitives really get it wrong in a bad way if we don't

	 * do this.

	 *

	 * Note - we should never be setting the blocksize to something

	 * less than the hardware sector size for the device.  If we

	 * do, we would end up having to read larger buffers and split

	 * out portions to satisfy requests.

	 *

	 * Note2- the idea here is that we want to deal with the optimal

	 * zonesize in the filesystem.  If we have it set to something less,

	 * then we have horrible problems with trying to piece together

	 * bits of adjacent blocks in order to properly read directory

	 * entries.  By forcing the blocksize in this way, we ensure

	 * that we will never be required to do this.

 initial offset, will guess until SP is found*/

	/*

	 * It would be incredibly stupid to allow people to mark every file

	 * on the disk as suid, so we merely allow them to set the default

	 * permissions.

	/*

	 * Read the root inode, which _may_ result in changing

	 * the s_rock flag. Once we have the final s_rock value,

	 * we then decide whether to use the Joliet descriptor.

	/*

	 * Fix for broken CDs with Rock Ridge and empty ISO root directory but

	 * correct Joliet root directory.

	/*

	 * If this disk has both Rock Ridge and Joliet on it, then we

	 * want to use Rock Ridge by default.  This can be overridden

	 * by using the norock mount option.  There is still one other

	 * possibility that is not taken into account: a Rock Ridge

	 * CD with Unicode names.  Until someone sees such a beast, it

	 * will not be supported.

 Only Joliet is case insensitive by default */

 Make sure the root inode is a directory */

 get the root dentry */

	/*

	 * Display error messages and free resources.

/*

 * Get a set of blocks; filling in buffer_heads if already allocated

 * or getblk() if they are not.  Returns the number of blocks inserted

 * (-ve == error.)

		/* If we are *way* beyond the end of the file, print a message.

		 * Access beyond the end of the file up to the next page boundary

		 * is normal, however because of the way the page cache works.

		 * In this case, we just return 0 so that we can properly fill

		 * the page with useless information without generating any

		 * I/O errors.

		/* On the last section, nextblk == 0, section size is likely to

		 * exceed sect_size by a partial block, and access beyond the

		 * end of the file will reach beyond the section size, too.

 Next buffer head */

 Next buffer offset */

/*

 * Used by the standard interfaces.

	/* The first 16 blocks are reserved as the System Area.  Thus,

	 * no inodes can appear in block 0.  We use this to flag that

 Make sure we have a full directory entry */

 Assume it is a normal-format file unless told otherwise */

		set_nlink(inode, 1);	/*

					 * Set to 1.  We know there are 2, but

					 * the find utility tries to optimize

					 * if it is 2, and it screws up.  It is

					 * easier to give 1 which tells find to

					 * do it the hard way.

			/*

			 * Set default permissions: r-x for all.  The disc

			 * could be shared with DOS machines so virtually

			 * anything could be a valid executable.

	/*

	 * Some dipshit decided to store some other bit of information

	 * in the high byte of the file length.  Truncate size in case

	 * this CDROM was mounted with the cruft option.

	/* I have no idea what file_unit_size is used for, so

	/* I have no idea what other flag bits are used for, so

 Set the number of blocks for stat() - should be done before RR */

	/*

	 * Now test for possible Rock Ridge extensions which will override

	 * some of these numbers in the inode structure.

 if we want uid/gid set, override the rock ridge setting */

 Now set final access rights if overriding rock ridge setting */

 Install the inode operations vector */

 XXX - parse_rock_ridge_inode() had already set i_rdev. */

/* Store, in the inode's containing structure, the block and block

 * offset that point to the underlying meta-data for the inode.  The

 * code below is otherwise similar to the iget() code in

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/isofs/dir.c

 *

 *  (C) 1992, 1993, 1994  Eric Youngdale Modified for ISO 9660 filesystem.

 *

 *  (C) 1991  Linus Torvalds - minix filesystem

 *

 *  Steve Beynon		       : Missing last directory entries fixed

 *  (stephen@askone.demon.co.uk)      : 21st June 1996

 *

 *  isofs directory handling functions

 lower case */

 Drop trailing '.;1' (ISO 9660:1988 7.5.1 requires period) */

 Drop trailing ';1' */

 Convert remaining ';' to '.' */

 Also '/' to '.' (broken Acorn-generated ISO9660 images) */

 Acorn extensions written by Matthew Wilcox <willy@infradead.org> 1998 */

/*

 * This should _really_ be cleaned up some day..

 Quiet GCC */

 Quiet GCC */

		/*

		 * If the length byte is zero, we should move on to the next

		 * CDROM sector.  If we are at the end of the directory, we

		 * kick out of the while loop.

 Make sure we have a full directory entry */

 Basic sanity check, whether name doesn't exceed dir entry */

 Handle the case of the '.' directory */

 Handle the case of the '..' directory */

		/* Handle everything else.  Do name translation if there

		/*

		 * Do not report hidden files if so instructed, or associated

		 * files unless instructed to do so

 may be -1 */

/*

 * Handle allocation of temporary space for name translation and

 * handling split directory entries.. The real work is done by

 * "do_isofs_readdir()".

/*

 * directories can handle most operations...

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/isofs/rock.c

 *

 *  (C) 1992, 1993  Eric Youngdale

 *

 *  Rock Ridge Extensions to iso9660

/*

 * These functions are designed to read the system areas of a directory record

 * and extract relevant information.  There are different functions provided

 * depending upon what information we need at the time.  One function fills

 * out an inode structure, a second one extracts a filename, a third one

 * returns a symbolic link name, and a fourth one returns the extent number

 * for the file.

 isonum_721() */

/*

 * This is a way of ensuring that we have something in the system

 * use fields that is compatible with Rock Ridge.  Return zero on success.

 Maximum number of Rock Ridge continuation entries */

/*

 * Returns 0 if the caller should continue scanning, 1 if the scan must end

 * and -ve on error.

/*

 * We think there's a record of type `sig' at rs->chr.  Parse the signature

 * and make sure that there's really room for a record of that type.

/*

 * return length of name field; 0: not found, -1: to be ignored

 There may be one byte for padding somewhere */

		/*

		 * Ignore rock ridge info if rr->len is out of range, but

		 * don't return -EIO because that would make the file

		 * invisible.

 Something got screwed up here */

		/*

		 * As above, just ignore the rock ridge info if rr->len

		 * is bogus.

 Something got screwed up here */

			/*

			 * If the flags are 2 or 4, this indicates '.' or '..'.

			 * We don't want to do anything with this, because it

			 * screws up the code that calls us.  We don't really

			 * care anyways, since we can just use the non-RR

			 * name.

 If 0, this file did not have a NM field */

 There may be one byte for padding somewhere */

		/*

		 * Ignore rock ridge info if rr->len is out of range, but

		 * don't return -EIO because that would make the file

		 * invisible.

 Something got screwed up here */

		/*

		 * As above, just ignore the rock ridge info if rr->len

		 * is bogus.

 Something got screwed up here */

 No flag for SF or ZF */

 Invalid length of ER tag id? */

				/*

				 * The Rock Ridge standard specifies that if

				 * sizeof(dev_t) <= 4, then the high field is

				 * unused, and the device number is completely

				 * stored in the low field.  Some writers may

				 * ignore this subtlety,

				 * and as a result we test to see if the entire

				 * device number is

				 * stored in the low field, and use that.

			/*

			 * Some RRIP writers incorrectly place ctime in the

			 * TF_CREATE field. Try to handle this correctly for

			 * either case.

 Rock ridge never appears on a High Sierra disk */

					/*

					 * If this component record isn't

					 * continued, then append a '/'.

					/*

					 * Note: we don't change

					 * i_blocks here

					/*

					 * Parameters to compression

					 * algorithm (header size,

					 * block size)

			/*

			 * If there is another SL record, and this component

			 * record isn't continued, then add a slash.

		/*

		 * If this component record isn't continued, then append a '/'.

	/*

	 * if rockridge flag was reset and we didn't look for attributes

	 * behind eventual XA attributes, have a look there

/*

 * readpage() for symlinks: reads symlink contents into the page and either

 * makes it uptodate and returns 0 or returns error (-EIO)

	/*

	 * If we go past the end of the buffer, there is some sort of error.

	/*

	 * Now test for possible Rock Ridge extensions which will override

	 * some of these numbers in the inode structure.

 There may be one byte for padding somewhere */

 Something got screwed up here */

 corrupted isofs */

 This tells is if there is a continuation record */

 error exit from macro */

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/isofs/util.c

/* 

 * We have to convert from a MM/DD/YY format to the Unix ctime format.

 * We have to take into account leap years and all of that good stuff.

 * Unfortunately, the kernel does not have the information on hand to

 * take into account daylight savings time, but it shouldn't matter.

 * The time stored should be localtime (with or without DST in effect),

 * and the timezone offset should hold the offset required to get back

 * to GMT.  Thus  we should always be correct.

 High sierra has no time zone */

 sign extend */

		/* 

		 * The timezone offset is unreliable on some disks,

		 * so we make a sanity check.  In no case is it ever

		 * more than 13 hours from GMT, which is 52*15min.

		 * The time is always stored in localtime with the

		 * timezone offset being what get added to GMT to

		 * get to localtime.  Thus we need to subtract the offset

		 * to get to true GMT, which is what we store the time

		 * as internally.  On the local system, the user may set

		 * their timezone any way they wish, of course, so GMT

		 * gets converted back to localtime on the receiving

		 * system.

		 *

		 * NOTE: mkisofs in versions prior to mkisofs-1.10 had

		 * the sign wrong on the timezone offset.  This has now

		 * been corrected there too, but if you are getting screwy

		 * results this may be the explanation.  If enough people

		 * complain, a user configuration option could be added

		 * to add the timezone offset in with the wrong sign

		 * for 'compatibility' with older discs, but I cannot see how

		 * it will matter that much.

		 *

		 * Thanks to kuhlmav@elec.canterbury.ac.nz (Volker Kuhlmann)

		 * for pointing out the sign error.

 SPDX-License-Identifier: GPL-2.0

/*

 * fs/isofs/export.c

 *

 *  (C) 2004  Paul Serice - The new inode scheme requires switching

 *                          from iget() to iget5_locked() which means

 *                          the NFS export operations have to be hand

 *                          coded because the default routines rely on

 *                          iget().

 *

 * The following files are helpful:

 *

 *     Documentation/filesystems/nfs/exporting.rst

 *     fs/exportfs/expfs.c.

/* This function is surprisingly simple.  The trick is understanding

 * that "child" is always a directory. So, to find its parent, you

 * simply need to find its ".." entry, normalize its block and offset,

 * and return the underlying inode.  See the comments for

 "child" must always be a directory. */

	/* It is an invariant that the directory offset is zero.  If

	 * it is not zero, it means the directory failed to be

	/* The child inode has been normalized such that its

	 * i_iget5_block value points to the "." entry.  Fortunately,

 Get the block in question. */

 This is the "." entry. */

 The ".." entry is always the second entry. */

 Verify it is in fact the ".." entry. */

 Normalize */

	/*

	 * WARNING: max_len is 5 for NFSv2.  Because of this

	 * limitation, we use the lower 16 bits of fh32[1] to hold the

	 * offset of the inode and the upper 16 bits of fh32[1] to

	 * hold the offset of the parent.

 fh16 [sic] */

 avoid leaking uninitialized data */

 fh16 [sic] */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * fs/nfs_common/nfsacl.c

 *

 *  Copyright (C) 2002-2003 Andreas Gruenbacher <agruen@suse.de>

/*

 * The Solaris nfsacl protocol represents some ACLs slightly differently

 * than POSIX 1003.1e draft 17 does (and we do):

 *

 *  - Minimal ACLs always have an ACL_MASK entry, so they have

 *    four instead of three entries.

 *  - The ACL_MASK entry in such minimal ACLs always has the same

 *    permissions as the ACL_GROUP_OBJ entry. (In extended ACLs

 *    the ACL_MASK and ACL_GROUP_OBJ entries may differ.)

 *  - The identifier fields of the ACL_USER_OBJ and ACL_GROUP_OBJ

 *    entries contain the identifiers of the owner and owning group.

 *    (In POSIX ACLs we always set them to ACL_UNDEFINED_ID).

 *  - ACL entries in the kernel are kept sorted in ascending order

 *    of (e_tag, e_id). Solaris ACLs are unsorted.

 Solaris depends on that! */

/**

 * nfsacl_encode - Encode an NFSv3 ACL

 *

 * @buf: destination xdr_buf to contain XDR encoded ACL

 * @base: byte offset in xdr_buf where XDR'd ACL begins

 * @inode: inode of file whose ACL this is

 * @acl: posix_acl to encode

 * @encode_entries: whether to encode ACEs as well

 * @typeflag: ACL type: NFS_ACL_DEFAULT or zero

 *

 * Returns size of encoded ACL in bytes or a negative errno value.

		/* Avoid the use of posix_acl_alloc().  nfsacl_encode() is

		 * invoked in contexts where a memory allocation failure is

		 * fatal.  Fortunately this fake ACL is small enough to

		/* Insert entries in canonical order: other orders seem

 ACL_USER_OBJ */

 ACL_GROUP_OBJ */

 ACL_MASK */

 ACL_OTHER */

/**

 * nfs_stream_encode_acl - Encode an NFSv3 ACL

 *

 * @xdr: an xdr_stream positioned to receive an encoded ACL

 * @inode: inode of file whose ACL this is

 * @acl: posix_acl to encode

 * @encode_entries: whether to encode ACEs as well

 * @typeflag: ACL type: NFS_ACL_DEFAULT or zero

 *

 * Return values:

 *   %false: The ACL could not be encoded

 *   %true: @xdr is advanced to the next available position

		/* Avoid the use of posix_acl_alloc().  nfsacl_encode() is

		 * invoked in contexts where a memory allocation failure is

		 * fatal.  Fortunately this fake ACL is small enough to

		/* Insert entries in canonical order: other orders seem

 ACL_USER_OBJ */

 ACL_GROUP_OBJ */

 ACL_MASK */

 ACL_OTHER */

 Solaris sometimes sets additional bits in the mask */

/*

 * Convert from a Solaris ACL to a POSIX 1003.1e draft 17 ACL.

 Find the ACL_GROUP_OBJ and ACL_MASK entries. */

 remove bogus ACL_MASK entry */

/**

 * nfsacl_decode - Decode an NFSv3 ACL

 *

 * @buf: xdr_buf containing XDR'd ACL data to decode

 * @base: byte offset in xdr_buf where XDR'd ACL begins

 * @aclcnt: count of ACEs in decoded posix_acl

 * @pacl: buffer in which to place decoded posix_acl

 *

 * Returns the length of the decoded ACL in bytes, or a negative errno value.

/**

 * nfs_stream_decode_acl - Decode an NFSv3 ACL

 *

 * @xdr: an xdr_stream positioned at an encoded ACL

 * @aclcnt: OUT: count of ACEs in decoded posix_acl

 * @pacl: OUT: a dynamically-allocated buffer containing the decoded posix_acl

 *

 * Return values:

 *   %false: The encoded ACL is not valid

 *   %true: @pacl contains a decoded ACL, and @xdr is advanced

 *

 * On a successful return, caller must release *pacl using posix_acl_release().

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Helper for knfsd's SSC to access ops in NFS client modules

 *

 * Author: Dai Ngo <dai.ngo@oracle.com>

 *

 * Copyright (c) 2020, Oracle and/or its affiliates.

/**

 * nfs42_ssc_register - install the NFS_V4 client ops in the nfs_ssc_client_tbl

 * @ops: NFS_V4 ops to be installed

 *

 * Return values:

 *   None

/**

 * nfs42_ssc_unregister - uninstall the NFS_V4 client ops from

 *				the nfs_ssc_client_tbl

 * @ops: ops to be uninstalled

 *

 * Return values:

 *   None

 CONFIG_NFS_V4_2 */

/**

 * nfs_ssc_register - install the NFS_FS client ops in the nfs_ssc_client_tbl

 * @ops: NFS_FS ops to be installed

 *

 * Return values:

 *   None

/**

 * nfs_ssc_unregister - uninstall the NFS_FS client ops from

 *				the nfs_ssc_client_tbl

 * @ops: ops to be uninstalled

 *

 * Return values:

 *   None

 CONFIG_NFS_V4_2 */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Common code for control of lockd and nfsv4 grace periods.

 *

 * Transplanted from lockd code

/**

 * locks_start_grace

 * @net: net namespace that this lock manager belongs to

 * @lm: who this grace period is for

 *

 * A grace period is a period during which locks should not be given

 * out.  Currently grace periods are only enforced by the two lock

 * managers (lockd and nfsd), using the locks_in_grace() function to

 * check when they are in a grace period.

 *

 * This function is called to start a grace period.

/**

 * locks_end_grace

 * @lm: who this grace period is for

 *

 * Call this function to state that the given lock manager is ready to

 * resume regular locking.  The grace period will not end until all lock

 * managers that called locks_start_grace() also call locks_end_grace().

 * Note that callers count on it being safe to call this more than once,

 * and the second call should be a no-op.

/**

 * locks_in_grace

 * @net: network namespace

 *

 * Lock managers call this function to determine when it is OK for them

 * to answer ordinary lock requests, and when they should accept only

 * lock reclaims.

/*

 *  linux/fs/hfs/trans.c

 *

 * Copyright (C) 1995-1997  Paul H. Hargrove

 * This file may be distributed under the terms of the GNU General Public License.

 *

 * This file contains routines for converting between the Macintosh

 * character set and various other encodings.  This includes dealing

 * with ':' vs. '/' as the path-element separator.

================ Global functions ================*/

/*

 * hfs_mac2asc()

 *

 * Given a 'Pascal String' (a string preceded by a length byte) in

 * the Macintosh character set produce the corresponding filename using

 * the 'trivial' name-mangling scheme, returning the length of the

 * mangled filename.  Note that the output string is not NULL

 * terminated.

 *

 * The name-mangling works as follows:

 * The character '/', which is illegal in Linux filenames is replaced

 * by ':' which never appears in HFS filenames.	 All other characters

 * are passed unchanged from input to output.

/*

 * hfs_asc2mac()

 *

 * Given an ASCII string (not null-terminated) and its length,

 * generate the corresponding filename in the Macintosh character set

 * using the 'trivial' name-mangling scheme, returning the length of

 * the mangled filename.  Note that the output string is not NULL

 * terminated.

 *

 * This routine is a inverse to hfs_mac2triv().

 * A ':' is replaced by a '/'.

/*

 *  linux/fs/hfs/mdb.c

 *

 * Copyright (C) 1995-1997  Paul H. Hargrove

 * (C) 2003 Ardis Technologies <roman@ardistech.com>

 * This file may be distributed under the terms of the GNU General Public License.

 *

 * This file contains functions for reading/writing the MDB.

================ File-local data types ================*/

/*

 * The HFS Master Directory Block (MDB).

 *

 * Also known as the Volume Information Block (VIB), this structure is

 * the HFS equivalent of a superblock.

 *

 * Reference: _Inside Macintosh: Files_ pages 2-59 through 2-62

 *

 * modified for HFS Extended

 default values */

/*

 * hfs_mdb_get()

 *

 * Build the in-core MDB for a filesystem, including

 * the B-trees and the volume bitmap.

 set the device driver to 512-byte blocks */

 See if this is an HFS filesystem */

		/* check for a partition block

		 * (should do this only for cdrom/loop though)

 size must be a multiple of 512 */

 align block size to first sector */

 align block size to weird alloc size */

 These parameters are read from the MDB, and never written */

 These parameters are read from and written to the MDB */

 TRY to get the alternate (backup) MDB. */

 read in the bitmap */

 Mark the volume uncleanly unmounted in case we crash */

/*

 * hfs_mdb_commit()

 *

 * Description:

 *   This updates the MDB on disk.

 *   It does not check, if the superblock has been modified, or

 *   if the filesystem has been mounted read-only. It is mainly

 *   called by hfs_sync_fs() and flush_mdb().

 * Input Variable(s):

 *   struct hfs_mdb *mdb: Pointer to the hfs MDB

 *   int backup;

 * Output Variable(s):

 *   NONE

 * Returns:

 *   void

 * Preconditions:

 *   'mdb' points to a "valid" (struct hfs_mdb).

 * Postconditions:

 *   The HFS MDB and on disk will be updated, by copying the possibly

 *   modified fields from the in memory MDB (in native byte order) to

 *   the disk block buffer.

 *   If 'backup' is non-zero then the alternate MDB is also written

 *   and the function doesn't return until it is actually on disk.

 These parameters may have been modified, so write them back */

 write MDB to disk */

	/* write the backup MDB, not returning until it is written.

	 * we only do this when either the catalog or extents overflow

 update volume attributes */

/*

 * hfs_mdb_put()

 *

 free the B-trees */

 free the buffers holding the primary and alternate MDBs */

/*

 *  linux/fs/hfs/super.c

 *

 * Copyright (C) 1995-1997  Paul H. Hargrove

 * (C) 2003 Ardis Technologies <roman@ardistech.com>

 * This file may be distributed under the terms of the GNU General Public License.

 *

 * This file contains hfs_read_super(), some of the super_ops and

 * init_hfs_fs() and exit_hfs_fs().  The remaining super_ops are in

 * inode.c since they deal with inodes.

 *

 * Based on the minix file system code, (C) 1991, 1992 by Linus Torvalds

/*

 * hfs_put_super()

 *

 * This is the put_super() entry in the super_operations structure for

 * HFS filesystems.  The purpose is to release the resources

 * associated with the superblock sb.

 release the MDB's resources */

/*

 * hfs_statfs()

 *

 * This is the statfs() entry in the super_operations structure for

 * HFS filesystems.  The purpose is to return various data about the

 * filesystem.

 *

 * changed f_files/f_ffree to reflect the fs_ablock/free_ablocks.

/*

 * parse_options()

 *

 * adapted from linux/fs/msdos/inode.c written 1992,93 by Werner Almesberger

 * This function is called by hfs_read_super() to parse the mount options.

 initialize the sb with defaults */

 == '????' */

/*

 * hfs_read_super()

 *

 * This is the function that is responsible for mounting an HFS

 * filesystem.	It performs all the tasks necessary to get enough data

 * from the disk to read the root inode.  This includes parsing the

 * mount options, dealing with Macintosh partitions, reading the

 * superblock and the allocation bitmap blocks, calling

 * hfs_btree_init() to get the necessary data about the extents and

 * catalog B-trees and, finally, reading the root inode into memory.

 try to get the root inode */

 everything's okay */

	/*

	 * Make sure all delayed rcu free inodes are flushed before we

	 * destroy cache.

/*

 *  linux/fs/hfs/inode.c

 *

 * Copyright (C) 1995-1997  Paul H. Hargrove

 * (C) 2003 Ardis Technologies <roman@ardistech.com>

 * This file may be distributed under the terms of the GNU General Public License.

 *

 * This file contains inode-related functions which do not depend on

 * which scheme is being used to represent forks.

 *

 * Based on the minix file system code, (C) 1991, 1992 by Linus Torvalds

================ Variable-like macros ================*/

	/*

	 * In case of error extending write may have instantiated a few

	 * blocks outside i_size. Trim these off again.

/*

 * hfs_new_inode

/*

 * hfs_read_inode

 Initialize the inode */

/*

 * __hfs_iget()

 *

 * Given the MDB for a HFS filesystem, a 'key' and an 'entry' in

 * the catalog B-tree and the 'type' of the desired file return the

 * inode for that file/directory or NULL.  Note that 'type' indicates

 * whether we want the actual file or directory, or the corresponding

 * metadata (AppleDouble header file or CAP metadata file).

 panic? */

 panic? */

struct super_block *sb = inode->i_sb;

if (inode->i_flags & S_DEAD) {

	hfs_delete_cat(inode->i_ino, HFSPLUS_SB(sb).hidden_dir, NULL);

	hfs_delete_inode(inode);

}

/*

 * hfs_notify_change()

 *

 * Based very closely on fs/msdos/inode.c by Werner Almesberger

 *

 * This is the notify_change() field in the super_operations structure

 * for HFS file systems.  The purpose is to take that changes made to

 * an inode and apply then in a filesystem-dependent manner.  In this

 * case the process has a few of tasks to do:

 *  1) prevent changes to the i_uid and i_gid fields.

 *  2) map file permissions to the closest allowable permissions

 *  3) Since multiple Linux files can share the same on-disk inode under

 *     HFS (for instance the data and resource forks of a file) a change

 *     to permissions must be applied to all other in-core inodes which

 *     correspond to the same HFS file.

 basic permission checks */

 no uig/gid changes and limit which mode bits can be set */

 Only the 'w' bits can ever change and only all together. */

 sync the inode to buffers */

 sync the superblock to buffers */

 .. finally sync the buffers to disk */

/*

 *  linux/fs/hfs/dir.c

 *

 * Copyright (C) 1995-1997  Paul H. Hargrove

 * (C) 2003 Ardis Technologies <roman@ardistech.com>

 * This file may be distributed under the terms of the GNU General Public License.

 *

 * This file contains directory-related functions independent of which

 * scheme is being used to represent forks.

 *

 * Based on the minix file system code, (C) 1991, 1992 by Linus Torvalds

/*

 * hfs_lookup()

/*

 * hfs_readdir

 This is completely artificial... */

if (fd.entrylength < HFS_MIN_THREAD_SZ) {

	pr_err("truncated catalog thread\n");

	err = -EIO;

	goto out;

}

	/*

	 * Can be done after the list insertion; exclusion with

	 * hfs_delete_cat() is provided by directory lock.

/*

 * hfs_create()

 *

 * This is the create() entry in the inode_operations structure for

 * regular HFS directories.  The purpose is to create a new file in

 * a directory and return a corresponding inode, given the inode for

 * the directory and the name (and its length) of the new file.

/*

 * hfs_mkdir()

 *

 * This is the mkdir() entry in the inode_operations structure for

 * regular HFS directories.  The purpose is to create a new directory

 * in a directory, given the inode for the parent directory and the

 * name (and its length) of the new directory.

/*

 * hfs_remove()

 *

 * This serves as both unlink() and rmdir() in the inode_operations

 * structure for regular HFS directories.  The purpose is to delete

 * an existing child, given the inode for the parent directory and

 * the name (and its length) of the existing directory.

 *

 * HFS does not have hardlinks, so both rmdir and unlink set the

 * link count to 0.  The only difference is the emptiness check.

/*

 * hfs_rename()

 *

 * This is the rename() entry in the inode_operations structure for

 * regular HFS directories.  The purpose is to rename an existing

 * file or directory, given the inode for the current directory and

 * the name (and its length) of the existing file/directory and the

 * inode for the new directory and the name (and its length) of the

 * new file/directory.

 * XXX: how do you handle must_be dir?

 Unlink destination if it already exists */

/*

 *  linux/fs/hfs/sysdep.c

 *

 * Copyright (C) 1996  Paul H. Hargrove

 * (C) 2003 Ardis Technologies <roman@ardistech.com>

 * This file may be distributed under the terms of the GNU General Public License.

 *

 * This file contains the code to do various system dependent things.

 dentry case-handling: just lowercase everything */

 fix up inode on a timezone change */

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/hfs/attr.c

 *

 * (C) 2003 Ardis Technologies <roman@ardistech.com>

 *

 * Export hfs data via xattr

/*

 *  linux/fs/hfs/catalog.c

 *

 * Copyright (C) 1995-1997  Paul H. Hargrove

 * (C) 2003 Ardis Technologies <roman@ardistech.com>

 * This file may be distributed under the terms of the GNU General Public License.

 *

 * This file contains the functions related to the catalog B-tree.

 *

 * Cache code shamelessly stolen from

 *     linux/fs/inode.c Copyright (C) 1991, 1992  Linus Torvalds

 *     re-shamelessly stolen Copyright (C) 1997 Linus Torvalds

/*

 * hfs_cat_build_key()

 *

 * Given the ID of the parent and the name build a search key.

 init some fields for the file record */

/*

 * create_entry()

 *

 * Add a new file or directory to the catalog B-tree and

 * return a (struct hfs_cat_entry) for it in '*result'.

	/*

	 * Fail early and avoid ENOSPC during the btree operations. We may

	 * have to split the root node at most once.

 panic? */

/*

 * hfs_cat_compare()

 *

 * Description:

 *   This is the comparison function used for the catalog B-tree.  In

 *   comparing catalog B-tree entries, the parent id is the most

 *   significant field (compared as unsigned ints).  The name field is

 *   the least significant (compared in "Macintosh lexical order",

 *   see hfs_strcmp() in string.c)

 * Input Variable(s):

 *   struct hfs_cat_key *key1: pointer to the first key to compare

 *   struct hfs_cat_key *key2: pointer to the second key to compare

 * Output Variable(s):

 *   NONE

 * Returns:

 *   int: negative if key1<key2, positive if key1>key2, and 0 if key1==key2

 * Preconditions:

 *   key1 and key2 point to "valid" (struct hfs_cat_key)s.

 * Postconditions:

 *   This function has no side-effects

 Try to get a catalog entry for given catalog id */

 move to read_super???

/*

 * hfs_cat_delete()

 *

 * Delete the indicated file or directory.

 * The associated thread is also removed unless ('with_thread'==0).

 we only need to take spinlock for exclusion with ->release() */

/*

 * hfs_cat_move()

 *

 * Rename a file or directory, possibly to a new directory.

 * If the destination exists it is removed and a

 * (struct hfs_cat_entry) for it is returned in '*result'.

	/*

	 * Fail early and avoid ENOSPC during the btree operations. We may

	 * have to split the root node at most once.

 find the old dir entry and read the data */

 create new dir entry with the data from the old entry */

 finally remove the old entry */

 remove old thread entry */

 create new thread entry */

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/hfs/bnode.c

 *

 * Copyright (C) 2001

 * Brad Boyer (flar@allandria.com)

 * (C) 2003 Ardis Technologies <roman@ardistech.com>

 *

 * Handle basic btree node operations

 compute page offset for the first page */

 page offset only applies to the first page */

 optimize later...

 optimize later...

 optimize later...

 optimize later...

 move down?

 Load a particular node out of a tree */

|| key_size & 1*/)

 Dispose of resources used by a node */

/*

 *  linux/fs/hfs/extent.c

 *

 * Copyright (C) 1995-1997  Paul H. Hargrove

 * (C) 2003 Ardis Technologies <roman@ardistech.com>

 * This file may be distributed under the terms of the GNU General Public License.

 *

 * This file contains the functions related to the extents B-tree.

================ File-local functions ================*/

/*

 * build_key

/*

 * hfs_ext_compare()

 *

 * Description:

 *   This is the comparison function used for the extents B-tree.  In

 *   comparing extent B-tree entries, the file id is the most

 *   significant field (compared as unsigned ints); the fork type is

 *   the second most significant field (compared as unsigned chars);

 *   and the allocation block number field is the least significant

 *   (compared as unsigned ints).

 * Input Variable(s):

 *   struct hfs_ext_key *key1: pointer to the first key to compare

 *   struct hfs_ext_key *key2: pointer to the second key to compare

 * Output Variable(s):

 *   NONE

 * Returns:

 *   int: negative if key1<key2, positive if key1>key2, and 0 if key1==key2

 * Preconditions:

 *   key1 and key2 point to "valid" (struct hfs_ext_key)s.

 * Postconditions:

/*

 * hfs_ext_find_block

 *

 * Find a block within an extent record

 panic? */

 Fail early and avoid ENOSPC during the btree operation */

 panic? */

 panic? */

/*

 * hfs_get_block

 Convert inode block to disk allocation block */

 no extents yet */

 try to append to extents in inode */

 XXX: Can use generic_cont_expand? */

 XXX: We lack error handling of hfs_file_truncate() */

/*

 *  linux/fs/hfs/string.c

 *

 * Copyright (C) 1995-1997  Paul H. Hargrove

 * (C) 2003 Ardis Technologies <roman@ardistech.com>

 * This file may be distributed under the terms of the GNU General Public License.

 *

 * This file contains the string comparison function for the

 * Macintosh character set.

 *

 * The code in this file is derived from code which is copyright

 * 1986, 1989, 1990 by Abacus Research and Development, Inc. (ARDI)

 * It is used here by the permission of ARDI's president Cliff Matthews.

================ File-local variables ================*/

/*

 * unsigned char caseorder[]

 *

 * Defines the lexical ordering of characters on the Macintosh

 *

 * Composition of the 'casefold' and 'order' tables from ARDI's code

 * with the entry for 0x20 changed to match that for 0xCA to remove

 * special case for those two characters.

================ Global functions ================*/

/*

 * Hash a string to an integer in a case-independent way

/*

 * Compare two strings in the HFS filename character ordering

 * Returns positive, negative, or zero, not just 0 or (+/-)1

 *

 * Equivalent to ARDI's call:

 *	ROMlib_RelString(s1+1, s2+1, true, false, (s1[0]<<16) | s2[0])

/*

 * Test for equality of two strings in the HFS filename character ordering.

 * return 1 on failure and 0 on success

/*

 *  linux/fs/hfs/part_tbl.c

 *

 * Copyright (C) 1996-1997  Paul H. Hargrove

 * (C) 2003 Ardis Technologies <roman@ardistech.com>

 * This file may be distributed under the terms of the GNU General Public License.

 *

 * Original code to handle the new style Mac partition table based on

 * a patch contributed by Holger Schemel (aeglos@valinor.owl.de).

/*

 * The new style Mac partition map

 *

 * For each partition on the media there is a physical block (512-byte

 * block) containing one of these structures.  These blocks are

 * contiguous starting at block 1.

 signature */

 padding */

 partition blocks count */

 physical block start of partition */

 physical block count of partition */

	u8	pmPartName[32];	/* (null terminated?) string

				   giving the name of this

	u8	pmPartType[32];	/* (null terminated?) string

				   giving the type of this

 a bunch more stuff we don't need */

/*

 * The old style Mac partition map

 *

 * The partition map consists for a 2-byte signature followed by an

 * array of these structures.  The map is terminated with an all-zero

 * one of these.

 Signature bytes */

/*

 * hfs_part_find()

 *

 * Parse the partition map looking for the

 * start and length of the 'part'th HFS partition.

"TFS1"*/ &&

/*

 *  linux/fs/hfs/bitmap.c

 *

 * Copyright (C) 1996-1997  Paul H. Hargrove

 * (C) 2003 Ardis Technologies <roman@ardistech.com>

 * This file may be distributed under the terms of the GNU General Public License.

 *

 * Based on GPLed code Copyright (C) 1995  Michael Dreher

 *

 * This file contains the code to modify the volume bitmap:

 * search/set/clear bits.

/*

 * hfs_find_zero_bit()

 *

 * Description:

 *  Given a block of memory, its length in bits, and a starting bit number,

 *  determine the number of the first zero bits (in left-to-right ordering)

 *  in that range.

 *

 *  Returns >= 'size' if no zero bits are found in the range.

 *

 *  Accesses memory in 32-bit aligned chunks of 32-bits and thus

 *  may read beyond the 'size'th bit.

 scan the first partial u32 for zero bits */

 scan complete u32s for the first zero bit */

 do any partial u32 at the start */

 do full u32s */

 do any partial u32 at end */

/*

 * hfs_vbm_search_free()

 *

 * Description:

 *   Search for 'num_bits' consecutive cleared bits in the bitmap blocks of

 *   the hfs MDB. 'mdb' had better be locked or the returned range

 *   may be no longer free, when this functions returns!

 *   XXX Currently the search starts from bit 0, but it should start with

 *   the bit number stored in 's_alloc_ptr' of the MDB.

 * Input Variable(s):

 *   struct hfs_mdb *mdb: Pointer to the hfs MDB

 *   u16 *num_bits: Pointer to the number of cleared bits

 *     to search for

 * Output Variable(s):

 *   u16 *num_bits: The number of consecutive clear bits of the

 *     returned range. If the bitmap is fragmented, this will be less than

 *     requested and it will be zero, when the disk is full.

 * Returns:

 *   The number of the first bit of the range of cleared bits which has been

 *   found. When 'num_bits' is zero, this is invalid!

 * Preconditions:

 *   'mdb' points to a "valid" (struct hfs_mdb).

 *   'num_bits' points to a variable of type (u16), which contains

 *	the number of cleared bits to find.

 * Postconditions:

 *   'num_bits' is set to the length of the found sequence.

 make sure we have actual work to perform */

/*

 * hfs_clear_vbm_bits()

 *

 * Description:

 *   Clear the requested bits in the volume bitmap of the hfs filesystem

 * Input Variable(s):

 *   struct hfs_mdb *mdb: Pointer to the hfs MDB

 *   u16 start: The offset of the first bit

 *   u16 count: The number of bits

 * Output Variable(s):

 *   None

 * Returns:

 *    0: no error

 *   -1: One of the bits was already clear.  This is a strange

 *	 error and when it happens, the filesystem must be repaired!

 *   -2: One or more of the bits are out of range of the bitmap.

 * Preconditions:

 *   'mdb' points to a "valid" (struct hfs_mdb).

 * Postconditions:

 *   Starting with bit number 'start', 'count' bits in the volume bitmap

 *   are cleared. The affected bitmap blocks are marked "dirty", the free

 *   block count of the MDB is updated and the MDB is marked dirty.

 is there any actual work to be done? */

 are all of the bits in range? */

 bitmap is always on a 32-bit boundary */

 do any partial u32 at the start */

 do full u32s */

 do any partial u32 at end */

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/hfs/brec.c

 *

 * Copyright (C) 2001

 * Brad Boyer (flar@allandria.com)

 * (C) 2003 Ardis Technologies <roman@ardistech.com>

 *

 * Handle individual btree records

 Get the length and offset of the given record in the given node */

 Get the length of the key from a keyed record */

 new record idx and complete record size */

 get last offset */

 write new last offset */

 move all following entries */

 move data away */

	/*

	 * update parent key if we inserted a key

	 * at the start of the node and it is not the new node

 create index data entry */

 get index key */

 fill hole */

 panic? */

		/* new record is in the lower half,

		 * so leave some more space there

 update new bnode header */

 update previous bnode header */

 update next bnode header */

 if there is no next node, this might be the new tail */

 size difference between old and new key */

 move previous cnid too */

 create index key and entry */

 restore search_key */

 insert old root idx into new root */

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/hfs/bfind.c

 *

 * Copyright (C) 2001

 * Brad Boyer (flar@allandria.com)

 * (C) 2003 Ardis Technologies <roman@ardistech.com>

 *

 * Search routines for btrees

 Find the record in bnode that best matches key (not greater than...)*/

 Traverse a B*Tree from the root to a leaf finding best fit to key */

 Return allocated copy of node found, set recnum to best record */

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/hfs/btree.c

 *

 * Copyright (C) 2001

 * Brad Boyer (flar@allandria.com)

 * (C) 2003 Ardis Technologies <roman@ardistech.com>

 *

 * Handle opening/closing btree

 Get a reference to a B*Tree and do some initial checks */

 Set the correct compare function */

 Load the header */

 Release resources used by a btree */

 panic? */

 Load the header */

 Make sure @tree has enough space for the @rsvd_nodes */

 panic */;

 panic */;

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * inode.c - basic inode and dentry operations.

 *

 * Based on sysfs:

 * 	sysfs is Copyright (C) 2001, 2002, 2003 Patrick Mochel

 *

 * configfs Copyright (C) 2005 Oracle.  All rights reserved.

 *

 * Please see Documentation/filesystems/configfs.rst for more

 * information.

 setting attributes for the first time, allocate now */

 assign default attributes */

 attributes were changed atleast once in past */

			/* sysfs_dirent has non-default attributes

			 * get them for the new inode from persistent copy

			 * in sysfs_dirent

			/*

			 * In practice the maximum level of locking depth is

			 * already reached. Just inform about possible reasons.

 CONFIG_LOCKDEP */

 CONFIG_LOCKDEP */

/*

 * Get the name for corresponding element represented by the given configfs_dirent

 These always have a dentry, so use that */

/*

 * Unhashes the dentry corresponding to given configfs_dirent

 * Called with parent inode's i_mutex held.

 no inode means this hasn't been made visible yet */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * item.c - library routines for handling generic config items

 *

 * Based on kobject:

 *	kobject is Copyright (c) 2002-2003 Patrick Mochel

 *

 * configfs Copyright (C) 2005 Oracle.  All rights reserved.

 *

 * Please see the file Documentation/filesystems/configfs.rst for

 * critical information about using the config_item interface.

 Evil kernel */

/**

 *	config_item_init - initialize item.

 *	@item:	item in question.

/**

 *	config_item_set_name - Set the name of an item

 *	@item:	item.

 *	@fmt:  The vsnprintf()'s format string.

 *

 *	If strlen(name) >= CONFIGFS_ITEM_NAME_LEN, then use a

 *	dynamically allocated string that @item->ci_name points to.

 *	Otherwise, use the static @item->ci_namebuf array.

	/*

	 * First, try the static array

 Free the old name, if necessary. */

 Now, set the new name */

/**

 *	config_item_put - decrement refcount for item.

 *	@item:	item.

 *

 *	Decrement the refcount, and if 0, call config_item_cleanup().

/**

 *	config_group_init - initialize a group for use

 *	@group:	config_group

/**

 *	config_group_find_item - search for item in group.

 *	@group:	group we're looking in.

 *	@name:	item's name.

 *

 *	Iterate over @group->cg_list, looking for a matching config_item.

 *	If matching item is found take a reference and return the item.

 *	Caller must have locked group via @group->cg_subsys->su_mtx.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * dir.c - Operations for configfs directories.

 *

 * Based on sysfs:

 * 	sysfs is Copyright (C) 2001, 2002, 2003 Patrick Mochel

 *

 * configfs Copyright (C) 2005 Oracle.  All rights reserved.

/*

 * Protects mutations of configfs_dirent linkage together with proper i_mutex

 * Also protects mutations of symlinks linkage to target configfs_dirent

 * Mutators of configfs_dirent linkage must *both* have the proper inode locked

 * and configfs_dirent_lock locked, in that order.

 * This allows one to safely traverse configfs_dirent trees and symlinks without

 * having to lock inodes.

 *

 * Protects setting of CONFIGFS_USET_DROPPING: checking the flag

 * unlocked is not reliable unless in detach_groups() called from

 * rmdir()/unregister() and from configfs_attach_group()

 Coordinate with configfs_readdir */

		/*

		 * Set sd->s_dentry to null only when this dentry is the one

		 * that is going to be killed.  Otherwise configfs_d_iput may

		 * run just after configfs_lookup and set sd->s_dentry to

		 * NULL even it's still in use.

/*

 * Helpers to make lockdep happy with our recursive locking of default groups'

 * inodes (see configfs_attach_group() and configfs_detach_group()).

 * We put default groups i_mutexes in separate classes according to their depth

 * from the youngest non-default group ancestor.

 *

 * For a non-default group A having default groups A/B, A/C, and A/C/D, default

 * groups A/B and A/C will have their inode's mutex in class

 * default_group_class[0], and default group A/C/D will be in

 * default_group_class[1].

 *

 * The lock classes are declared and assigned in inode.c, according to the

 * s_depth value.

 * The s_depth value is initialized to -1, adjusted to >= 0 when attaching

 * default groups, and reset to -1 when all default groups are attached. During

 * attachment, if configfs_create() sees s_depth > 0, the lock class of the new

 * inode's mutex is set to default_group_class[s_depth - 1].

	/*

	 * item's i_mutex class is already setup, so s_depth is now only

	 * used to set new sub-directories s_depth, which is always done

	 * with item's i_mutex locked.

	/*

	 *  sd->s_depth == -1 iff we are a non default group.

	 *  else (we are a default group) sd->s_depth > 0 (see

	 *  create_dir()).

		/*

		 * We are a non default group and we are going to create

		 * default groups.

 We will not create default groups anymore. */

 CONFIG_LOCKDEP */

 CONFIG_LOCKDEP */

/*

 * Allocates a new configfs_dirent and links it to the parent configfs_dirent

/*

 *

 * Return -EEXIST if there is already a configfs element with the same

 * name for the same parent.

 *

 * called with parent inode's i_mutex held

/**

 *	configfs_create_dir - create a directory for an config_item.

 *	@item:		config_itemwe're creating directory for.

 *	@dentry:	config_item's dentry.

 *	@frag:		config_item's fragment.

 *

 *	Note: user-created entries won't be allowed under this new directory

 *	until it is validated by configfs_dir_set_ready()

 directory inodes start off with i_nlink == 2 (for "." entry) */

 already hashed */

 pin directory dentries in core */

/*

 * Allow userspace to create new entries under a new directory created with

 * configfs_create_dir(), and under all of its chidlren directories recursively.

 * @sd		configfs_dirent of the new directory to validate

 *

 * Caller must hold configfs_dirent_lock.

/*

 * Check that a directory does not belong to a directory hierarchy being

 * attached and not validated yet.

 * @sd		configfs_dirent of the directory to check

 *

 * @return	non-zero iff the directory was validated

 *

 * Note: takes configfs_dirent_lock, so the result may change from false to true

 * in two consecutive calls, but never from true to false.

 pin link dentries in core */

/**

 * configfs_remove_dir - remove an config_item's directory.

 * @item:	config_item we're removing.

 *

 * The only thing special about this is that we remove any files in

 * the directory before we remove the directory, and we've inlined

 * what used to be configfs_rmdir() below, instead of calling separately.

 *

 * Caller holds the mutex of the item's inode

	/**

	 * Drop reference from dget() on entrance.

	/*

	 * Fake invisibility if dir belongs to a group/default groups hierarchy

	 * being attached

	 *

	 * This forbids userspace to read/write attributes of items which may

	 * not complete their initialization, since the dentries of the

	 * attributes won't be instantiated.

/*

 * Only subdirectories count here.  Files (CONFIGFS_NOT_PINNED) are

 * attributes and are removed by rmdir().  We recurse, setting

 * CONFIGFS_USET_DROPPING on all children that are candidates for

 * default detach.

 * If there is an error, the caller will reset the flags via

 * configfs_detach_rollback().

 Mark that we're trying to drop the group */

 Abort if racing with mkdir() */

			/*

			 * Yup, recursive.  If there's a problem, blame

			 * deep nesting of default_groups

/*

 * Walk the tree, resetting CONFIGFS_USET_DROPPING wherever it was

 * set.

	/**

	 * Drop reference from dget() on entrance.

	/**

	 * Drop reference from dget() on entrance.

/*

 * This fakes mkdir(2) on a default_groups[] entry.  It

 * creates a dentry, attachs it, and then does fixup

 * on the sd->s_type.

 *

 * We could, perhaps, tweak our parent's ->mkdir for a minute and

 * try using vfs_mkdir.  Just a thought.

 We trust the caller holds a reference to parent */

/*

 * All of link_obj/unlink_obj/link_group/unlink_group require that

 * subsys->su_mutex is held.

 Drop the reference for ci_entry */

 Drop the reference for ci_parent */

	/*

	 * Parent seems redundant with group, but it makes certain

	 * traversals much nicer.

	/*

	 * We hold a reference on the parent for the child's ci_parent

	 * link.

	/*

	 * We hold a reference on the child for ci_entry on the parent's

	 * cg_children

 gcc is a turd */

/*

 * The goal is that configfs_attach_item() (and

 * configfs_attach_group()) can be called from either the VFS or this

 * module.  That is, they assume that the items have been created,

 * the dentry allocated, and the dcache is all ready to go.

 *

 * If they fail, they must clean up after themselves as if they

 * had never been called.  The caller (VFS or local function) will

 * handle cleaning up the dcache bits.

 *

 * configfs_detach_group() and configfs_detach_item() behave similarly on

 * the way out.  They assume that the proper semaphores are held, they

 * clean up the configfs items, and they expect their callers will

 * handle the dcache bits.

			/*

			 * We are going to remove an inode and its dentry but

			 * the VFS may already have hit and used them. Thus,

			 * we must lock them as rmdir() would.

 Caller holds the mutex of the item's inode */

		/*

		 * FYI, we're faking mkdir in populate_groups()

		 * We must lock the group's inode to avoid races with the VFS

		 * which can already hit the inode and try to add/remove entries

		 * under it.

		 *

		 * We must also lock the inode to remove it safely in case of

		 * error, as rmdir() would.

 Caller holds the mutex of the group's inode */

/*

 * After the item has been detached from the filesystem view, we are

 * ready to tear it out of the hierarchy.  Notify the client before

 * we do that so they can perform any cleanup that requires

 * navigating the hierarchy.  A client does not need to provide this

 * callback.  The subsystem semaphore MUST be held by the caller, and

 * references must be valid for both items.  It also assumes the

 * caller has validated ci_type.

/*

 * Drop the initial reference from make_item()/make_group()

 * This function assumes that reference is held on item

 * and that item holds a valid reference to the parent.  Also, it

 * assumes the caller has validated ci_type.

	/*

	 * If ->drop_item() exists, it is responsible for the

	 * config_item_put().

/*

 * configfs_depend_item() and configfs_undepend_item()

 *

 * WARNING: Do not call these from a configfs callback!

 *

 * This describes these functions and their helpers.

 *

 * Allow another kernel system to depend on a config_item.  If this

 * happens, the item cannot go away until the dependent can live without

 * it.  The idea is to give client modules as simple an interface as

 * possible.  When a system asks them to depend on an item, they just

 * call configfs_depend_item().  If the item is live and the client

 * driver is in good shape, we'll happily do the work for them.

 *

 * Why is the locking complex?  Because configfs uses the VFS to handle

 * all locking, but this function is called outside the normal

 * VFS->configfs path.  So it must take VFS locks to prevent the

 * VFS->configfs stuff (configfs_mkdir(), configfs_rmdir(), etc).  This is

 * why you can't call these functions underneath configfs callbacks.

 *

 * Note, btw, that this can be called at *any* time, even when a configfs

 * subsystem isn't registered, or when configfs is loading or unloading.

 * Just like configfs_register_subsystem().  So we take the same

 * precautions.  We pin the filesystem.  We lock configfs_dirent_lock.

 * If we can find the target item in the

 * configfs tree, it must be part of the subsystem tree as well, so we

 * do not need the subsystem semaphore.  Holding configfs_dirent_lock helps

 * locking out mkdir() and rmdir(), who might be racing us.

/*

 * configfs_depend_prep()

 *

 * Only subdirectories count here.  Files (CONFIGFS_NOT_PINNED) are

 * attributes.  This is similar but not the same to configfs_detach_prep().

 * Note that configfs_detach_prep() expects the parent to be locked when it

 * is called, but we lock the parent *inside* configfs_depend_prep().  We

 * do that so we can unlock it if we find nothing.

 *

 * Here we do a depth-first search of the dentry hierarchy looking for

 * our object.

 * We deliberately ignore items tagged as dropping since they are virtually

 * dead, as well as items in the middle of attachment since they virtually

 * do not exist yet. This completes the locking out of racing mkdir() and

 * rmdir().

 * Note: subdirectories in the middle of attachment start with s_type =

 * CONFIGFS_DIR|CONFIGFS_USET_CREATING set by create_dir().  When

 * CONFIGFS_USET_CREATING is set, we ignore the item.  The actual set of

 * s_type is in configfs_new_dirent(), which has configfs_dirent_lock.

 *

 * If the target is not found, -ENOENT is bubbled up.

 *

 * This adds a requirement that all config_items be unique!

 *

 * This is recursive.  There isn't

 * much on the stack, though, so folks that need this function - be careful

 * about your stack!  Patches will be accepted to make it iterative.

 Boo-yah */

 Child path boo-yah */

 We looped all our children and didn't find target */

 Scan the tree, return 0 if found */

	/*

	 * We are sure that the item is not about to be removed by rmdir(), and

	 * not in the middle of attachment by mkdir().

	/*

	 * Pin the configfs filesystem.  This means we can safely access

	 * the root of the configfs filesystem.

	/*

	 * Next, lock the root directory.  We're going to check that the

	 * subsystem is really registered, and so we need to lock out

	 * configfs_[un]register_subsystem().

 Ok, now we can trust subsys/s_item */

	/*

	 * If we succeeded, the fs is pinned via other methods.  If not,

	 * we're done with it anyway.  So release_fs() is always right.

/*

 * Release the dependent linkage.  This is much simpler than

 * configfs_depend_item() because we know that the client driver is

 * pinned, thus the subsystem is pinned, and therefore configfs is pinned.

	/*

	 * Since we can trust everything is pinned, we just need

	 * configfs_dirent_lock.

	/*

	 * After this unlock, we cannot trust the item to stay alive!

	 * DO NOT REFERENCE item after this unlock.

/*

 * caller_subsys is a caller's subsystem not target's. This is used to

 * determine if we should lock root and check subsys or not. When we are

 * in the same subsystem as our target there is no need to do locking as

 * we know that subsys is valid and is not unregistered during this function

 * as we are called from callback of one of his children and VFS holds a lock

 * on some inode. Otherwise we have to lock our root to  ensure that target's

 * subsystem it is not unregistered during this function.

 Disallow this function for configfs root */

	/*

	 * This may happen when someone is trying to depend root

	 * directory of some subsystem

 Find a cofnigfs root as we may need it for locking */

		/*

		 * We are in other configfs subsystem, so we have to do

		 * additional locking to prevent other subsystem from being

		 * unregistered

		/*

		 * As we are trying to depend item from other subsystem

		 * we have to check if this subsystem is still registered

 Now we can execute core of depend item */

		/*

		 * We were called from subsystem other than our target so we

		 * took some locks so now it's time to release them

	/*

	 * Fake invisibility if dir belongs to a group/default groups hierarchy

	 * being attached

 Get a working ref for the duration of this function */

 Lack-of-mkdir returns -EPERM */

	/*

	 * The subsystem may belong to a different module than the item

	 * being created.  We don't want to safely pin the new item but

	 * fail to pin the subsystem it sits under.

		/*

		 * If ret != 0, then link_obj() was never called.

		 * There are no extra references to clean up.

	/*

	 * link_obj() has been called (via link_group() for groups).

	 * From here on out, errors must clean that up.

	/*

	 * I hate doing it this way, but if there is

	 * an error,  module_put() probably should

	 * happen after any cleanup.

	/*

	 * Make racing rmdir() fail if it did not tag parent with

	 * CONFIGFS_USET_DROPPING

	 * Note: if CONFIGFS_USET_DROPPING is already set, attach_group() will

	 * fail and let rmdir() terminate correctly

 This will make configfs_detach_prep() fail */

 Tear down everything we built up */

	/*

	 * link_obj()/link_group() took a reference from child->parent,

	 * so the parent is safely pinned.  We can drop our working

	 * reference.

 Get a working ref until we have the child */

 configfs_mkdir() shouldn't have allowed this */

	/*

	 * Ensure that no racing symlink() will make detach_prep() fail while

	 * the new link is temporarily attached

		/*

		 * Here's where we check for dependents.  We're protected by

		 * configfs_dirent_lock.

		 * If no dependent, atomically tag the item as dropping.

 Wait until the racing operation terminates */

 Get a working ref for the duration of this function */

 Drop reference from above, item already holds one. */

 Drop our reference from above */

	/*

	 * Fake invisibility if dir belongs to a group/default groups hierarchy

	 * being attached

 Relationship between s_mode and the DT_xxx types */

		/*

		 * We'll have a dentry and an inode for

		 * PINNED items and for open attribute

		 * files.  We lock here to prevent a race

		 * with configfs_d_iput() clearing

		 * s_dentry before calling iput().

		 *

		 * Why do we go to the trouble?  If

		 * someone has an attribute file open,

		 * the inode number should match until

		 * they close it.  Beyond that, we don't

		 * care.

/**

 * configfs_register_group - creates a parent-child relation between two groups

 * @parent_group:	parent group

 * @group:		child group

 *

 * link groups, creates dentry for the child and attaches it to the

 * parent dentry.

 *

 * Return: 0 on success, negative errno code on error

/**

 * configfs_unregister_group() - unregisters a child group from its parent

 * @group: parent group to be unregistered

 *

 * Undoes configfs_register_group()

/**

 * configfs_register_default_group() - allocates and registers a child group

 * @parent_group:	parent group

 * @name:		child group name

 * @item_type:		child item type description

 *

 * boilerplate to allocate and register a child group with its parent. We need

 * kzalloc'ed memory because child's default_group is initially empty.

 *

 * Return: allocated config group or ERR_PTR() on error

/**

 * configfs_unregister_default_group() - unregisters and frees a child group

 * @group:	the group to act on

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * file.c - operations for regular (text) files.

 *

 * Based on sysfs:

 * 	sysfs is Copyright (C) 2001, 2002, 2003 Patrick Mochel

 *

 * configfs Copyright (C) 2005 Oracle.  All rights reserved.

/*

 * A simple attribute can only be 4096 characters.  Why 4k?  Because the

 * original code limited it to PAGE_SIZE.  That's a bad idea, though,

 * because an attribute of 16k on ia64 won't work on x86.  So we limit to

 * 4k, our minimum common page size.

 we don't support switching read/write modes */

 perform first read with buf == NULL to get extent */

 do not exceed the maximum value */

 perform second read to fill buffer */

 Fill @buffer with data coming from @from. */

	/* if buf is assumed to contain a string, terminate it by \0,

/*

 * There is no easy way for us to know if userspace is only doing a partial

 * write, so we don't support them. We expect the entire buffer to come on the

 * first write.

 * Hint: if you're writing a value, first read the file, modify only the value

 * you're changing, then write entire buffer back.

 we don't support switching read/write modes */

 buffer grows? */

 copy old contents */

 clear the new area */

 Grab the module reference for this attribute if we have one */

	/* File needs write support.

	 * The inode's perms must say it's ok,

	 * and we must have a store method.

	/* File needs read support.

	 * The inode's perms must say it's ok, and we there

	 * must be a show method for it.

 result of ->release() is ignored */

 bin file is not seekable */

/**

 *	configfs_create_file - create an attribute file for an item.

 *	@item:	item we're creating for.

 *	@attr:	atrribute descriptor.

/**

 *	configfs_create_bin_file - create a binary attribute file for an item.

 *	@item:	item we're creating for.

 *	@bin_attr: atrribute descriptor.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * symlink.c - operations for configfs symlinks.

 *

 * Based on sysfs:

 * 	sysfs is Copyright (C) 2001, 2002, 2003 Patrick Mochel

 *

 * configfs Copyright (C) 2005 Oracle.  All rights reserved.

 Protects attachments of new symlinks */

 back up enough to print this bus id with '/' */

	/*

	 * Fake invisibility if dir belongs to a group/default groups hierarchy

	 * being attached

	/*

	 * This is really sick.  What they wanted was a hybrid of

	 * link(2) and symlink(2) - they wanted the target resolved

	 * at syscall time (as link(2) would've done), be a directory

	 * (which link(2) would've refused to do) *AND* be a deep

	 * fucking magic, making the target busy from rmdir POV.

	 * symlink(2) is nothing of that sort, and the locking it

	 * gets matches the normal symlink(2) semantics.  Without

	 * attempts to resolve the target (which might very well

	 * not even exist yet) done prior to locking the parent

	 * directory.  This perversion, OTOH, needs to resolve

	 * the target, which would lead to obvious deadlocks if

	 * attempted with any directories locked.

	 *

	 * Unfortunately, that garbage is userland ABI and we should've

	 * said "no" back in 2005.  Too late now, so we get to

	 * play very ugly games with locking.

	 *

	 * Try *ANYTHING* of that sort in new code, and you will

	 * really regret it.  Just ask yourself - what could a BOFH

	 * do to me and do I want to find it out first-hand?

	 *

	 *  AV, a thoroughly annoyed bastard.

 What lack-of-symlink returns */

	/*

	 * drop_link() must be called before

	 * decrementing target's ->s_links, so that the order of

	 * drop_link(this, target) and drop_item(target) is preserved.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * mount.c - operations for initializing and mounting configfs.

 *

 * Based on sysfs:

 * 	sysfs is Copyright (C) 2001, 2002, 2003 Patrick Mochel

 *

 * configfs Copyright (C) 2005 Oracle.  All rights reserved.

 Random magic number */

 directory inodes start off with i_nlink == 2 (for "." entry) */

 the rest get that */

 SPDX-License-Identifier: LGPL-2.1

/*

 *

 *   vfs operations that deal with io control

 *

 *   Copyright (C) International Business Machines  Corp., 2005,2013

 *   Author(s): Steve French (sfrench@us.ibm.com)

 *

 the destination must be opened for writing */

 check if target volume is readonly and take reference */

	trace_cifs_shutdown(sb, flags);*/

	/*

	 * see:

	 *   https://man7.org/linux/man-pages/man2/ioctl_xfs_goingdown.2.html

	 * for more information and description of original intent of the flags

	/*

	 * We could add support later for default flag which requires:

	 *     "Flush all dirty data and metadata to disk"

	 * would need to call syncfs or equivalent to flush page cache for

	 * the mount and then issue fsync to server (if nostrictsync not set)

	/*

	 * FLAGS_LOGFLUSH is easy since it asks to write out metadata (not

	 * data) but metadata writes are not cached on the client, so can treat

	 * it similarly to NOLOGFLUSH

 copy user input into our output buffer */

 if ses id is 0, use current user session */

 otherwise if a session id is given, look for it in all our sessions */

					/*

					 * since we are using the session outside the crit

					 * section, we need to make sure it won't be released

					 * so increment its refcount

 check if user buffer is big enough to store all the keys */

 overwrite user input with our output */

 append all the keys at the end of the user buffer */

 strange error - but the precedent */

 CONFIG_CIFS_POSIX */

 add in the compressed bit */

 caps = le64_to_cpu(tcon->fsUnixInfo.Capability); */

			/*

			 * if (CIFS_UNIX_EXTATTR_CAP & caps)

			 *	rc = CIFSSetExtAttr(xid, tcon,

			 *		       pSMBFile->fid.netfid,

			 *		       extAttrBits,

			 *		       &ExtAttrMask);

			 * if (rc != EOPNOTSUPP)

			 *	break;

 Currently only flag we can set is compressed flag */

 Try to set compress flag */

			/*

			 * Dump encryption keys. This is an old ioctl that only

			 * handles AES-128-{CCM,GCM}.

 SMB2_NTLMV2_SESSKEY_SIZE */);

			/*

			 * Dump encryption keys (handles any key sizes)

 Notify can only be done on directories */

 SPDX-License-Identifier: LGPL-2.1

/*

 *

 *   Copyright (C) International Business Machines  Corp., 2002,2011

 *   Author(s): Steve French (sfrench@us.ibm.com)

 *

 FIXME: should these be tunable? */

 Drop the connection to not overload the server */

/*

 * Resolve hostname and set ip addr in tcp ses. Useful for hostnames that may

 * get their ip addresses changed at some point.

 *

 * This should be called with server->srv_mutex held.

 rc == 1 means success here */

			/*

			 * To make sure we don't use the cached entry, retry 1s

			 * after expiry.

	/*

	 * Resolve the hostname again to make sure that IP address is up-to-date.

/**

 * Mark all sessions and tcons for reconnect.

 *

 * @server needs to be previously set to CifsNeedReconnect.

	/*

	 * before reconnecting the tcp session, mark the smb session (uid) and the tid bad so they

	 * are not used until reconnected.

 If server is a channel, select the primary channel */

 do not want to be sending data on a socket we are freeing */

 mark submitted MIDs for retry and issue callback */

 the demux thread will exit normally next time through the loop */

/*

 * cifs tcp session reconnection

 *

 * mark tcp session as reconnecting so temporarily locked

 * mark all smb sessions as reconnecting for tcp session

 * reconnect tcp session

 * wake up waiters on reconnection? - (not needed currently)

 resolve the hostname again to make sure that IP address is up-to-date */

 resolve the hostname again to make sure that IP address is up-to-date. */

 Reconnect the socket */

 If dfs target list is empty, then reconnect to last server */

 Otherwise, try every dfs target in @tl */

	/*

	 * Determine the number of dfs targets the referral path in @cifs_sb resolves to.

	 *

	 * smb2_reconnect() needs to know how long it should wait based upon the number of dfs

	 * targets (server->nr_targets).  It's also possible that the cached referral was cleared

	 * through /proc/fs/cifs/dfscache or the target list is empty due to server settings after

	 * refreshing the referral, so, in this case, default it to 1.

 Failed to reconnect socket */

		/*

		 * Socket was created.  Update tcp session status to CifsNeedNegotiate so that a

		 * process waiting for reconnect will know it needs to re-establish session and tcon

		 * through the reconnected target server.

 Need to set up echo worker again once connection has been established */

 If tcp session is not an dfs connection, then reconnect to last target server */

	/*

	 * We cannot send an echo if it is disabled.

	 * Also, no need to ping if we got a response recently.

 Check witness registrations */

 retry will check if exiting */

 we are reusing a dirty large buf, clear its start */

 retry will check if exiting */

 beginning of smb buffer is cleared in our buf_get */

 if existing small buf clear beginning */

	/*

	 * We need to wait 3 echo intervals to make sure we handle such

	 * situations right:

	 * 1s  client sends a normal SMB request

	 * 2s  client gets a response

	 * 30s echo workqueue job pops, and decides we got a response recently

	 *     and don't need to send another

	 * ...

	 * 65s kernel_recvmsg times out, and we see that we haven't gotten

	 *     a response in >60s.

 reconnect if no credits and no requests in flight */

			/*

			 * Minimum sleep to prevent looping, allowing socket

			 * to clear and app threads to set tcpStatus

			 * CifsNeedReconnect if server hung.

	/*

	 *  iov_iter_discard already sets smb_msg.type and count and iov_offset

	 *  and cifs_readv_from_socket sets msg_control and msg_controllen

	 *  so little to initialize in struct msghdr

	/*

	 * The first byte big endian of the length field,

	 * is actually not part of the length but the type

	 * with the most common, zero, as regular data.

 Regular SMB response */

		/*

		 * We get this from Windows 98 instead of an error on

		 * SMB negprot response.

 give server a second to clean up */

		/*

		 * Always try 445 first on reconnect since we get NACK

		 * on some if we ever connected to port 139 (the NACK

		 * is since we do not begin with RFC1001 session

		 * initialize frame).

	/*

	 * Trying to handle/dequeue a mid after the send_recv()

	 * function has finished processing it is a bug.

	/*

	 * SMB1 does not use credits.

 Was previous buf put in mpx struct for multi-rsp? */

 smb buffer will be freed by user thread */

 take it off the list, if it's not already */

 check if we have blocked requests that need to free */

	/*

	 * Although there should not be any requests blocked on this queue it

	 * can not hurt to be paranoid and try to wake up requests that may

	 * haven been blocked when more than 50 at time were on the wire to the

	 * same server - they now will see the session is in exit state and get

	 * out of SendReceive.

 give those requests time to exit */

 now walk dispose list and issue callbacks */

 1/8th of sec is more than enough time for them to exit */

		/*

		 * mpx threads have not exited yet give them at least the smb

		 * send timeout time for long ops.

		 *

		 * Due to delays on oplock break requests, we need to wait at

		 * least 45 seconds before giving up on a request getting a

		 * response and going ahead and killing cifsd.

		/*

		 * If threads still have not exited they are probably never

		 * coming home not much else we can do but free the memory.

 make sure this will fit in a large buffer */

 switch to large buffer if too big for a small one */

 now read the rest */

	/*

	 * We know that we received enough to get to the MID as we

	 * checked the pdu_length earlier. Now check to see

	 * if the rest of the header is OK. We borrow the length

	 * var for the rest of the loop to avoid a new stack var.

	 *

	 * 48 bytes is enough to display the header and a little bit

	 * into the payload for debugging purposes.

	/*

	 * SMB1 does not use credits.

 enough to get RFC1001 header */

		/*

		 * The right amount was read from socket - 4 bytes,

		 * so we can now interpret the length field.

 make sure we have enough to get to the MID */

 read down to the MID */

 CIFS_DEBUG2 */

 end while !EXITING */

 buffer usually freed in free_mid - need to free it here on exit */

 no sense logging a debug message if NULL */

 if server->tsk was NULL then wait for a signal before exiting */

/*

 * Returns true if srcaddr isn't specified and rhs isn't specified, or

 * if srcaddr is specified and matches the IP address of the rhs argument

 don't expect to be here */

/*

 * If no port is specified in addr structure, we try to match with 445 port

 * and if it fails - with 139 ports. It should be called only if address

 * families of server and addr are equal.

 SMBDirect manages its own ports, don't match it here */

 don't expect to be here */

	/*

	 * The select_sectype function should either return the ctx->sectype

	 * that was specified, or "Unspecified" if that sectype was not

	 * compatible with the given NEGOTIATE request.

	/*

	 * Now check if signing mode is acceptable. No need to check

	 * global_secflags at this point since if MUST_SIGN is set then

	 * the server->sign had better be too.

 this server does not share socket */

 If multidialect negotiation see if existing sessions match one */

		/*

		 * DFS failover implementation in cifs_reconnect() requires unique tcp sessions for

		 * DFS connections to do failover properly, so avoid sharing them with regular

		 * shares or even links that may connect to same server but having completely

		 * different failover targets.

		/*

		 * Skip ses channels since they're only handled in lower layers

		 * (e.g. cifs_send_recv).

 srv_count can never go negative */

 For secondary channels, we pick up ref-count on the primary server */

		/*

		 * Avoid deadlock here: reconnect work calls

		 * cifs_put_tcp_session() at its end. Need to be sure

		 * that reconnect work does nothing with server pointer after

		 * that step.

 fscache server cookies are based on primary channel only */

 see if we already have a matching tcp_ses */

	/*

	 * at this point we are the only ones with the pointer

	 * to the struct since the kernel thread not created yet

	 * no need to spinlock this init of tcpStatus or srv_count

	/*

	 * since we're in a cifs function already, we know that

	 * this will succeed. No need for try_module_get().

	/*

	 * at this point we are the only ones with the pointer

	 * to the struct since the kernel thread not created yet

	 * no need to spinlock this update of tcpStatus

 thread spawned, put it on the list */

 fscache server cookies are based on primary channel only */

 queue echo request delayed work */

 queue dns resolution delayed work */

	/*

	 * If an existing session is limited to less channels than

	 * requested, it should not be reused

 NULL username means anonymous session */

 anything else takes username/password */

/**

 * cifs_setup_ipc - helper to setup the IPC tcon for the session

 * @ses: smb session to issue the request on

 * @ctx: the superblock configuration context to use for building the

 *       new tree connection for the IPC (interprocess communication RPC)

 *

 * A new IPC connection is made and stored in the session

 * tcon_ipc. The IPC tcon has the same lifetime as the session.

x/IPC$")] = {0};

	/*

	 * If the mount request that resulted in the creation of the

	 * session requires encryption, force IPC to be encrypted too.

/**

 * cifs_free_ipc - helper to release the session IPC tcon

 * @ses: smb session to unmount the IPC from

 *

 * Needs to be called everytime a session is destroyed.

 *

 * On session close, the IPC is closed and the server must release all tcons of the session.

 * No need to send a tree disconnect here.

 *

 * Besides, it will make the server to not close durable and resilient files on session close, as

 * specified in MS-SMB2 3.3.5.6 Receiving an SMB2 LOGOFF Request.

 ses_count can never go negative */

 close any extra channels */

			/*

			 * note: for now, we're okay accessing ses->chans

			 * without chan_lock. But when chans can go away, we'll

			 * need to introduce ref counting to make sure that chan

			 * is not freed from under us.

 strlen("cifs:a:") + CIFS_MAX_DOMAINNAME_LEN + 1 */

 Populate username and pw fields from keyring if possible */

 try to find an address key first */

 didn't work, try to find a domain key */

 find first : in payload */

	/*

	 * If we have a domain key then we must set the domainName in the

	 * for the request.

 ! CONFIG_KEYS */

 CONFIG_KEYS */

/**

 * cifs_get_smb_ses - get a session matching @ctx data from @server

 * @server: server to setup the session to

 * @ctx: superblock configuration context to use to setup the session

 *

 * This function assumes it is being called from cifs_mount() where we

 * already got a server reference (server refcount +1). See

 * cifs_get_tcon() for refcount explanations.

 problem -- put our ses reference */

 problem -- put our reference */

 existing SMB ses has a server reference already */

 new SMB session uses our server ref */

 ctx->password freed at unmount */

 add server as first channel */

 each channel uses a different signing key */

 success, put it on the list and add it as first channel */

	/*

	 * IPC tcon share the lifetime of their session and are

	 * destroyed in the session put function

 tc_count can never go negative */

/**

 * cifs_get_tcon - get a tcon matching @ctx data from @ses

 * @ses: smb session to issue the request on

 * @ctx: the superblock configuration context to use for building the

 *

 * - tcon refcount is the number of mount points using the tcon.

 * - ses refcount is the number of tcon using the session.

 *

 * 1. This function assumes it is being called from cifs_mount() where

 *    we already got a session reference (ses refcount +1).

 *

 * 2. Since we're in the context of adding a mount point, the end

 *    result should be either:

 *

 * a) a new tcon already allocated with refcount=1 (1 mount point) and

 *    its session refcount incremented (1 new tcon). This +1 was

 *    already done in (1).

 *

 * b) an existing tcon with refcount+1 (add a mount point to it) and

 *    identical ses refcount (no new tcon). Because of (1) we need to

 *    decrement the ses refcount.

		/*

		 * tcon has refcount already incremented but we need to

		 * decrement extra ses reference gotten by caller (case b)

	/*

	 * BB Do we need to wrap session_mutex around this TCon call and Unix

	 * SetFS as we do on SessSetup and reconnect?

 check if SMB2 or later, CIFS does not support persistent handles */

 persistent handles requested but not supported */ {

				/*

				 * Set witness in use flag in first place

				 * to retry registration in the echo task

 And try to register immediately */

 TODO: try to extend for non-cluster uses (eg multichannel) */

 If the user really knows what they are doing they can override */

	/*

	 * We can have only one retry value for a connection to a share so for

	 * resources mounted more than once to the same server share the last

	 * value passed in for the retry flag is used.

	/*

	 * We want to share sb only if we don't specify an r/wsize or

	 * specified r/wsize is greater than or equal to existing one.

 can not match superblock if tlink were ever null */

 See RFC1001 section 14 on representation of Netbios names */

 mask a nibble at a time and encode */

 Bind to the specified local IP address */

	/*

	 * some servers require RFC1001 sessinit before sending

	 * negprot - BB check reconnection in case where second

	 * sessinit is sent but no second negprot

		/*

		 * calling name ends in null (byte 16) from old smb

		 * convention.

 sizeof RFC1002_SESSION_REQUEST with no scope */

		/*

		 * RFC1001 layer in at least one server

		 * requires very short break before negprot

		 * presumably because not expecting negprot

		 * to follow so fast.  This is a simple

		 * solution that works without

		 * complicating the code and causes no

		 * significant slowing down on mount

		 * for everyone else

	/*

	 * else the negprot may still work without this

	 * even though malloc failed

 BB other socket options to set KEEPALIVE, NODELAY? */

	/*

	 * Eventually check for other socket options to change from

	 * the default. sock_setsockopt not used because it expects

	 * user space buffer

 make the bufsizes depend on wsize/rsize and max requests */

	/*

	 * When mounting SMB root file systems, we do not want to block in

	 * connect. Otherwise bail out and then let cifs_reconnect() perform

	 * reconnect failover - if possible.

 try with 445 port at first */

 if it failed, try with 139 port */

	/*

	 * If we are reconnecting then should we check to see if

	 * any requested capabilities changed locally e.g. via

	 * remount but we can not do much about it here

	 * if they have (even if we could detect it by the following)

	 * Perhaps we could add a backpointer to array of sb from tcon

	 * or if we change to make all sb to same share the same

	 * sb as NFS - then we only have one backpointer to sb.

	 * What if we wanted to mount the server share twice once with

	 * and once without posixacls or posix paths?

 Unix Extensions disabled */

 Unix Extensions supported */

		/*

		 * check for reconnect case in which we do not

		 * want to change the mount behavior if we can avoid it

			/*

			 * turn off POSIX ACL and PATHNAMES if not set

			 * originally at mount time

 CIFS_DEBUG2 */

 this is needed for ASCII cp to Unicode converts */

 load_nls_default cannot return null */

 Release all succeed connections */

 Get connections for tcp, ses and tcon */

 get a reference to a tcp session */

 get a reference to a SMB session */

 search for existing tcon to this server share */

 if new SMB3.11 POSIX extensions are supported do not remap / and \ */

 tell server which Unix caps we support */

		/*

		 * reset of caps checks mount to see if unix extensions disabled

		 * for just this mount.

 server does not support them */

 do not care if a following call succeed - informational */

 no need to log a RW mount of a typical RW share */

		/*

		 * The cookie is initialized from volume info returned above.

		 * Inside cifs_fscache_get_super_cookie it checks

		 * that we do not get super cookie twice.

	/*

	 * Clamp the rsize/wsize mount arguments if they are too big for the server

	 * and set the rsize/wsize to the negotiated values if not passed in by

	 * the user on mount

 hang the tcon off of the superblock */

 Get unique dfs connections */

/*

 * cifs_build_path_to_root returns full path to root when we do not have an

 * existing connection (tcon)

 add trailing null */

/*

 * expand_dfs_referral - Update cifs_sb from dfs referral path

 *

 * cifs_sb->ctx->mount_options will be (re-)allocated to a string containing updated options for the

 * submount.  Otherwise it will be left untouched.

		/*

		 * We can not clear out the whole structure since we no longer have an explicit

		 * function to parse a mount-string. Instead we need to clear out the individual

		 * fields that are no longer valid.

/* TODO: all callers to this are broken. We are not parsing mount_options here

 * we should pass a clone of the original context?

 BB fixme parse for domain name here */

	/* In userspace mount helper we can get user name from alternate

 skip separators */

 next separator */

		/*

		 * if the treename is added, we then have to skip the first

		 * part within the separators

		/*

		 * temporarily null-terminate the path at the end of

		 * the current component

/*

 * Check if path is remote (e.g. a DFS share). Return -EREMOTE if it is,

 * otherwise 0.

	/*

	 * cifs_build_path_to_root works only when we have a valid tcon

	/*

	 * If called with 'nodfs' mount option, then skip DFS resolving.  Otherwise unconditionally

	 * try to get an DFS referral (even cached) to determine whether it is an DFS mount.

	 *

	 * Skip prefix path to provide support for DFS referrals from w2k8 servers which don't seem

	 * to respond with PATH_NOT_COVERED to requests that include the prefix.

 Check if it is fully accessible and then mount it */

 Connect to new target only if we were redirected (e.g. mount options changed) */

	/* Put initial connections as they might be shared with other mounts.  We need unique dfs

	 * connections per mount to properly failover, so mount_get_dfs_conns() must be used from

	 * now on.

 Try all dfs root targets */

 Get referral from dfs link */

 Try all dfs link targets */

 Set up DFS referral paths for failover */

	/*

	 * After reconnecting to a different server, unique ids won't match anymore, so we disable

	 * serverino. This prevents dentry revalidation to think the dentry are stale (ESTALE).

	/*

	 * Force the use of prefix path to support failover on DFS paths that resolve to targets

	 * that have different prefix paths.

/*

 * Issue a TREE_CONNECT request.

no tid */ , 4 
 minimum */

 password is null byte */

 skip password */

 already aligned so no need to do it below */

 max utf8 char length in bytes */ *

 server len*/ + 256 
 convert num 16 bit words to bytes */

 skip trailing null */

 ASCII */

 above now done in SendReceive */

 skip service field (NB: this field is always ASCII) */

 the most common case */

 mostly informational -- no need to fail on error here */

 field is in same location */

 only send once per connect */

 krb5 is special, since we don't need username or pw */

 get a reference for the same TCP session */

 find and return a tlink with given uid */

 insert a tcon_link into the tree */

/*

 * Find or construct an appropriate tcon given a cifs_sb and the fsuid of the

 * current task.

 *

 * If the superblock doesn't refer to a multiuser mount, then just return

 * the master tcon for the mount.

 *

 * First, search the rbtree for an existing tcon for this fsuid. If one

 * exists, then check to see if it's pending construction. If it is then wait

 * for construction to complete. Once it's no longer pending, check to see if

 * it failed and either return an error or retry construction, depending on

 * the timeout.

 *

 * If one doesn't exist then insert a new tcon_link struct into the tree and

 * try to construct a new one.

 was one inserted after previous search? */

 if it's good, return it */

 return error if we tried this already recently */

/*

 * periodic workqueue job that scans tcon_tree for a superblock and closes

 * out tcons.

	/*

	 * Because we drop the spinlock in the loop in order to put the tlink

	 * it's not guarded against removal of links from the tree. The only

	 * places that remove entries from the tree are this function and

	 * umounts. Because this function is non-reentrant and is canceled

	 * before umount can proceed, this is safe.

 Update dfs referral path of superblock */

 Check if hostnames or addresses match */

 Try to tree connect to all dfs targets */

 Check if share matches with tcp ses */

		/*

		 * If no dfs referrals were returned from link target, then just do a TREE_CONNECT

		 * to it.  Otherwise, cache the dfs referral and then mark current tcp ses for

		 * reconnect so either the demultiplex thread or the echo worker will reconnect to

		 * newly resolved target.

 Target is another dfs share */

	/*

	 * If we couldn't tree connect to any targets from last referral path, then retry from

	 * original referral path.

 If it is not dfs or there was no cached dfs referral, then reconnect to same share */

 SPDX-License-Identifier: LGPL-2.1

/*

 *

 *   Copyright (C) International Business Machines  Corp., 2002,2008

 *   Author(s): Steve French (sfrench@us.ibm.com)

 *

 *   Common Internet FileSystem (CIFS) client

 *

 Note that BB means BUGBUG (ie something to fix eventually) */

/*

 * DOS dates from 1980/1/1 through 2107/12/31

 * Protocol specifications indicate the range should be to 119, which

 * limits maximum year to 2099. But this range has not been checked.

 false by default */

 false by default */

 false by default */

 unsigned int ntlmv2_support = 0; */

 STATS2 */

/*

 * Bumps refcount for cifs super block.

 * Note that it should be only called if a referece to VFS super block is

 * already held, e.g. in open-type syscalls context. Otherwise it can race with

 * atomic_dec_and_test in deactivate_locked_super.

	/*

	 * Some very old servers like DOS and OS/2 used 2 second granularity

	 * (while all current servers use 100ns granularity - see MS-DTYP)

	 * but 1 second is the maximum allowed granularity for the VFS

	 * so for old servers set time granularity to 1 second while for

	 * everything else (current servers) set it to 100ns.

 1 second is max allowed gran */

		/*

		 * Almost every server, including all SMB2+, uses DCE TIME

		 * ie 100 nanosecond units, since 1601.  See MS-DTYP and MS-FSCC

 tune readahead according to rsize if readahead size not set on mount */

 default 2**14 = CIFS_MAX_MSGSIZE */

 CONFIG_CIFS_NFSD_EXPORT */

	/*

	 * We ned to release all dentries for the cached directories

	 * before we kill the sb.

 are using part of create time for more randomness, see man statfs */

 undefined */

 unlimited */

	} else /* file mode might have been restricted at mount time

		on the client (above and beyond ACL on servers) for

		servers which do not support setting and viewing mode bits,

 default */

	/*

	 * Until the file is open and we have gotten oplock info back from the

	 * server, can not assume caching of file data or metadata.

 2**14 = CIFS_MAX_MSGSIZE */

	/*

	 * Can not set i_flags here - they get immediately overwritten to zero

	 * by the VFS.

 cifs_inode->vfs_inode.i_flags = S_NOATIME | S_NOCMTIME; */

 shouldn't ever happen */

 assume only one client access */

 read only caching assumed */

/*

 * cifs_show_devname() is used so we show the mount device name with correct

 * format (e.g. forward slashes vs. back slashes) in /proc/mounts

 escape all spaces in share names */

/*

 * cifs_show_options() is for displaying mount options in /proc/mounts.

 * Not all settable options are displayed but most of the important

 * ones are.

 Only display max_credits if it was overridden on mount */

	/*

	 * Display file and directory attribute timeout in seconds.

	 * If file and directory attribute timeout the same then actimeo

	 * was likely specified on mount

		/* we have other mounts to same share or we have

		   already tried to force umount this and woken up

 cancel_brl_requests(tcon); */ 
 cancel_notify_requests(tcon); */

 yield */

 we have to kick the requests once more */

 BB FIXME */

 no serverino => unconditional eviction */

	.show_path	= cifs_show_path, */ 
/*	.delete_inode	= cifs_delete_inode,  */  /* Do not need above

	function unless later we add lazy close of inodes or unless the

	kernel forgets to call us with the same number of releases (closes)

/*

 * Get root dentry from superblock according to prefix path mount option.

 * Return dentry with refcount + 1 on success and NULL otherwise.

 skip separators */

 next separator */

	/*

	 * Prints in Kernel / CIFS log the attempted mount operation

	 *	If CIFS_DEBUG && cifs_FYI

 BB should we make this contingent on mount parm? */

	/*

	 * whence == SEEK_END || SEEK_DATA || SEEK_HOLE => we must revalidate

	 * the cached file length

		/*

		 * We need to be sure that all dirty pages are written and the

		 * server has the newest file length.

		/*

		 * Some applications poll for the file length in this strange

		 * way so we must seek to end on non-oplocked files by

		 * setting the revalidate time to zero.

	/*

	 * Note that this is called by vfs setlease with i_lock held to

	 * protect *lease from going away.

 Check if file is oplocked if this is request for new lease */

		/*

		 * If the server claims to support oplock on this file, then we

		 * still need to check oplock even if the local_lease mount

		 * option is set, but there are servers which do not support

		 * oplock for which this mount option may be useful if the user

		 * knows that the file won't be changed on the server by anyone

		 * else.

	/*

	 * Note: cifs case is easier than btrfs since server responsible for

	 * checks for proper open modes and file type and if it wants

	 * server could even support copy of range where source = target

 should we flush first and last page first */

	/* force revalidate of size and timestamps of target file now

	/* although unlocking in the reverse order from locking is not

	/*

	 * Note: cifs case is easier than btrfs since server responsible for

	 * checks for proper open modes and file type and if it wants

	 * server could even support copy of range where source = target

 should we flush first and last page first */

	/* force revalidate of size and timestamps of target file now

	 * that target is updated on the server

	/* although unlocking in the reverse order from locking is not

	 * strictly necessary here it is a little cleaner to be consistent

/*

 * Directory operations under CIFS/SMB2/SMB3 are synchronous, so fsync()

 * is a dummy operation.

	/*

	 * Make sure all delayed rcu free inodes are flushed before we

	 * destroy cache.

	/*

	 * SMB2 maximum header size is bigger than CIFS one - no problems to

	 * allocate some more bytes for CIFS.

	/* Buffer size can not be smaller than 2 * PATH_MAX since maximum

 Round size to even 512 byte mult*/

/*

	cifs_dbg(VFS, "CIFSMaxBufSize %d 0x%x\n",

		 CIFSMaxBufSize, CIFSMaxBufSize);

	/* MAX_CIFS_SMALL_BUFFER_SIZE bytes is enough for most SMB responses and

	almost all handle based requests (but not write response, nor is it

	sufficient for path based requests).  A smaller size would have

	been more efficient (compacting multiple slab items on one 4k page)

	for the case in which debug was on, but this larger size allows

	more SMBs to use small buffer alloc and is still much more

	efficient to alloc 1 per page off the slab compared to 17K (5page)

 3 is a reasonable minimum number of simultaneous operations */

/*

 *  Initialize Global counters

 CONFIG_CIFS_STATS2 */

	/*

	 * Consider in future setting limit!=0 maybe to min(num_of_cores - 1, 3)

	 * so that we don't launch too many worker threads but

	 * Documentation/core-api/workqueue.rst recommends setting it to 0

 WQ_UNBOUND allows decrypt tasks to run on any CPU */

 CONFIG_CIFS_DFS_UPCALL */

 CONFIG_CIFS_UPCALL */

 CONFIG_CIFS_SWN_UPCALL */

 combination of LGPL + GPL source behaves as GPL */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *   Copyright (C) 2020, Microsoft Corporation.

 *

 *   Author(s): Steve French <stfrench@microsoft.com>

 *              Suresh Jayaraman <sjayaraman@suse.de>

 *              Jeff Layton <jlayton@kernel.org>

 extract the host portion of the UNC string */

 skip double chars at beginning of string */

 BB: check validity of these bytes? */

 delimiter between hostname and sharename is always '\\' now */

 skip double chars at the beginning */

 share name is always preceded by '\\' now */

 caller has to free the memory */

 SPDX-License-Identifier: LGPL-2.1

/*

 *

 *   Functions which do error mapping of SMB2 status codes to POSIX errors

 *

 *   Copyright (C) International Business Machines  Corp., 2009

 *   Author(s): Steve French (sfrench@us.ibm.com)

 *

 Note that ENOATTTR and ENODATA are the same errno */

/*****************************************************************************

 Print an error message from the status code

 mask facility */

 on error mapping not found  - return EIO */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *   Copyright (C) 2020, Microsoft Corporation.

 *

 *   Author(s): Steve French <stfrench@microsoft.com>

 *              David Howells <dhowells@redhat.com>

/*

#include <linux/module.h>

#include <linux/nsproxy.h>

#include <linux/slab.h>

#include <linux/magic.h>

#include <linux/security.h>

#include <net/net_namespace.h>

#ifdef CONFIG_CIFS_DFS_UPCALL

#include "dfs_cache.h"

#endif

 Mount options that take no arguments */

 Mount options which take numeric value */

 Mount options which take string value */

 Arguments that should be ignored */

	/*

	 * UNC and prefixpath is now extracted from Opt_source

	 * in the new mount API so we can just ignore them going forward.

	/*

	 * With mount options, the last one should win. Reset any existing

	 * settings back to default.

	/*

	 * Make sure to stay in sync with smb3_cleanup_fs_context_contents()

 CIFS_ALLOW_INSECURE_LEGACY */

 currently identical with 3.0 */

 currently identical with 3.0 */

/*

 * Parse a devname into substrings and populate the ctx->UNC and ctx->prepath

 * fields with the result. Returns 0 on success and an error otherwise

 * (e.g. ENOMEM or EINVAL)

 make sure we have a valid UNC double delimiter prefix */

 find delimiter between host and sharename */

 record the server hostname */

 skip past delimiter */

 now go until next delimiter or end of string */

 move "pos" up to delimiter or NULL */

 skip any delimiter */

 If pos is NULL then no prepath */

/*

 * Parse a monolithic block of data from sys_mount().

 * smb3_fs_context_parse_monolithic - Parse key[=val][,key[=val]]* mount data

 * @ctx: The superblock configuration to fill in.

 * @data: The data to parse

 *

 * Parse a blob of data that's in key[=val][,key[=val]]* form.  This can be

 * called from the ->monolithic_mount_data() fs_context operation.

 *

 * Returns 0 on success or the error returned by the ->parse_option() fs_context

 * operation on failure.

 BB Need to add support for sep= here TBD */

		/* Check if following character is the deliminator If yes,

		 * we have encountered a double deliminator reset the NULL

		 * character to the deliminator

/*

 * Validate the preparsed information in the config.

 Muliuser mounts require CONFIG_KEYS support */

 make sure UNC has a share name */

 No ip= option specified? Try to get it from UNC */

 Use the address part of the UNC. */

 set the port that we got earlier */

/*

 * Create an SMB3 superblock from the parameters passed.

/*

 * Compare the old and new proposed context during reconfigure

 * and check if the changes are compatible.

	/*

	 * We can not change UNC/username/password/domainname/

	 * workstation_name/nodename/iocharset

	 * during reconnect so ignore what we have in the new context and

	 * just use what we already have in cifs_sb->ctx.

 if rsize or wsize not passed in on remount, use previous values */

	/*

	 * fs_parse can not handle string options with an empty value so

	 * we will need special handling of them.

 disable SFU mapping */

 if number of channels not specified, default to 2 */

		/*

		 * inode blocksize realistically should never need to be

		 * less than 16K or greater than 16M and default is 1MB.

		 * Note that small inode block sizes (e.g. 64K) can lead

		 * to very poor performance of common tools like cp and scp

		/*

		 * readahead size realistically should never need to be

		 * less than 1M (CIFS_DEFAULT_IOSIZE) or greater than 32M

		 * (perhaps an exception should be considered in the

		 * for the case of a large number of channels

		 * when multichannel is negotiated) since that would lead

		 * to plenty of parallel I/O in flight to the server.

		 * Note that smaller read ahead sizes would

		 * hurt performance of common tools like cp and scp

		 * which often trigger sequential i/o with read ahead

 If more than one channel requested ... they want multichan */

 null user, ie. anonymous authentication */

		/* if iocharset not set then load_nls_default

		 * is used by caller

		/*

		 * FIXME: are there cases in which a comma can

		 * be valid in workstation netbios name (and

		 * need special handling)?

 don't ucase netbiosname for user */

		/* The string has 16th byte zero still from

		 * set at top of the function

 last byte, type, is 0x20 for servr type */

		/*

		 * BB are there cases in which a comma can be valid in this

		 * workstation netbios name (and need special handling)?

 user or mount helper must uppercase the netbios name */

 The string has 16th byte zero still from set at top of function */

 version of mount userspace tools, not dialect */

 If interface changes in mount.cifs bump to new ver */

 This is the default */

 For all other value, error */

 protocol version (dialect) */

			/*

			 * turn off mandatory locking in mode

			 * if remote locking is turned off since the

			 * local vfs will do advisory

		/* we do not do the following in secFlags because seal

		 * is a per tree connection (mount) not a per socket

		 * or per-smb connection option in the protocol

		 * vol->secFlg |= CIFSSEC_MUST_SEAL;

 already the default */

 tcp nodelay should not usually be needed since we CORK/UNCORK the socket */

 case Opt_ignore: - is ignored as expected ... */

	/*

	 * does not have to be perfect mapping since field is

	 * informational, only used for servers that do not support

	 * port 445 and it can be overridden at mount time

	/*

	 * null target name indicates to use *SMBSERVR default called name

	 *  if we end up sending RFC1001 session initialize

 By default 4MB read ahead size, 1MB block size */

 can improve cp performance significantly */

 0 = use default (ie negotiated rsize) for read ahead pages */

	/*

	 * default to SFM style remapping of seven reserved characters

	 * unless user overrides it or we negotiate CIFS POSIX where

	 * it is unnecessary.  Can not simultaneously use more than one mapping

	 * since then readdir could list files that open could not open

 default to only allowing write access to owner of the mount */

 ctx->retry default is 0 (i.e. "soft" limited retry not hard retry) */

 default is always to request posix paths. */

 default to using server inode numbers where available */

 default is to use strict cifs caching semantics */

 Most clients set timeout to 0, allows server to use its default */

 See MS-SMB2 spec section 2.2.14.2.12 */

 offer SMB2.1 and later (SMB3 etc). Secure and widely accepted */

 default to no multichannel (single server connection) */

 no backup intent for a user */

 no backup intent for a group */

/*

 *	short int override_uid = -1;

 *	short int override_gid = -1;

 *	char *nodename = strdup(utsname()->nodename);

 *	struct sockaddr *dstaddr = (struct sockaddr *)&vol->dstaddr;

	/*

	 * Make sure this stays in sync with smb3_fs_context_dup()

			/*

			 * Our SFU ("Services for Unix" emulation does not allow

			 * creating symlinks but does allow reading existing SFU

			 * symlinks (it does allow both creating and reading SFU

			 * style mknod and FIFOs though). When "mfsymlinks" and

			 * "sfu" are both enabled at the same time, it allows

			 * reading both types of symlinks, but will only create

			 * them with mfsymlinks format. This allows better

			 * Apple compatibility (probably better for Samba too)

			 * while still recognizing old Windows style symlinks.

 SPDX-License-Identifier: GPL-2.0

/*

 * Witness Service client for CIFS

 *

 * Copyright (c) 2020 Samuel Cabrero <scabrero@suse.de>

/*

 * Sends a register message to the userspace daemon based on the registration.

 * The authentication information to connect to the witness service is bundled

 * into the message.

	/*

	 * If there is an address stored use it instead of the server address, because we are

	 * in the process of reconnecting to it after a share has been moved or we have been

	 * told to switch to it (client move message). In these cases we unregister from the

	 * server address and register to the new address when we receive the notification.

/*

 * Sends an uregister message to the userspace daemon based on the registration

/*

 * Try to find a matching registration for the tcon's server name and share name.

 * Calls to this function must be protected by cifs_swnreg_idr_mutex.

 * TODO Try to avoid memory allocations

/*

 * Get a registration for the tcon's server and share name, allocating a new one if it does not

 * exists

 Check if we are already registered for this network and share names */

 Store the reconnect address */

	/*

	 * Unregister to stop receiving notifications for the old IP address.

	/*

	 * And register to receive notifications for the new IP address now that we have

	 * stored the new address.

 Do not put the swnreg or return error, the echo task will retry */

 SPDX-License-Identifier: LGPL-2.1

/*

 *

 *   Copyright (c) International Business Machines  Corp., 2003, 2007

 *   Author(s): Steve French (sfrench@us.ibm.com)

 *

 DACL only */

 owner plus DACL */

 owner/DACL/SACL */

 full name: user.cifs.dosattrib */

 user.cifs.creationtime */

/*

 * Although these three are just aliases for the above, need to move away from

 * confusing users and using the 20+ year old term 'cifs' when it is no longer

 * secure, replaced by SMB2 (then even more highly secure SMB3) many years ago

 DACL only */

 owner plus DACL */

 owner/DACL/SACL */

 full name: user.smb3.dosattrib */

 user.smb3.creationtime */

 BB need to add server (Samba e.g) support for security and trusted prefix */

 return dos attributes as pseudo xattr */

 return alt name if available as pseudo attr */

	/* if proc/fs/cifs/streamstoxattr is set then

		search server for EAs or streams to

 force revalidate of the inode */

 force revalidate of the inode */

 force revalidate of the inode */

 CONFIG_CIFS_POSIX */

 CONFIG_CIFS_POSIX */

 return dos attributes as pseudo xattr */

 return dos attributes as pseudo xattr */

 return alt name if available as pseudo attr */

		/*

		 * fetch owner, DACL, and SACL if asked for full descriptor,

		 * fetch owner and DACL otherwise

 rc already EOPNOTSUPP */

 CONFIG_CIFS_POSIX */

 CONFIG_CIFS_POSIX */

	/* We could add an additional check for streams ie

	    if proc/fs/cifs/streamstoxattr is set then

		search server for EAs or streams to

 return dos attributes as pseudo xattr */

 return alt name if available as pseudo attr */

	/* if proc/fs/cifs/streamstoxattr is set then

		search server for EAs or streams to

 os2.* attributes are treated like user.* attributes */

/*

 * Although this is just an alias for the above, need to move away from

 * confusing users and using the 20 year old term 'cifs' when it is no

 * longer secure and was replaced by SMB2/SMB3 a long time ago, and

 * SMB3 and later are highly secure.

/*

 * Although this is just an alias for the above, need to move away from

 * confusing users and using the 20 year old term 'cifs' when it is no

 * longer secure and was replaced by SMB2/SMB3 a long time ago, and

 * SMB3 and later are highly secure.

/*

 * Although this is just an alias for the above, need to move away from

 * confusing users and using the 20 year old term 'cifs' when it is no

 * longer secure and was replaced by SMB2/SMB3 a long time ago, and

 * SMB3 and later are highly secure.

 alias for above since avoiding "cifs" */

 alias for above since avoiding "cifs" */

 alias for above since avoiding "cifs" */

 SPDX-License-Identifier: LGPL-2.1

/*

 *

 *   Copyright (C) International Business Machines  Corp., 2002,2010

 *   Author(s): Steve French (sfrench@us.ibm.com)

 *

 not direct, send byte range locks */

 check if server can support readpages */

 NO DFS support, treat as a directory */

/* check inode attributes against fattr. If they don't match, tag the

 * inode for cache invalidation

 don't bother with revalidation if we have an oplock */

 revalidate if mtime or size have changed */

/*

 * copy nlink to the inode, unless it wasn't provided.  Provide

 * sane values if we don't have an existing one and none was provided

	/*

	 * if we're in a situation where we can't trust what we

	 * got from the server (readdir, some non-unix cases)

	 * fake reasonable values

 only provide fake values on a new inode */

 we trust the server, so update it */

 populate an inode with info from a cifs_fattr struct */

 force reval */

 we do not want atime to be less than mtime, it broke some apps */

 if dynperm is set, don't clobber existing mode */

	/*

	 * Can't safely change the file size here if the client is writing to

	 * it due to potential races.

		/*

		 * i_blocks is not related to (i_size / i_blksize),

		 * but instead 512 byte (2**9) size is required for

		 * calculating num blocks.

 Fill a cifs_fattr struct with info from FILE_UNIX_BASIC_INFO. */

 old POSIX extensions don't get create time */

	/*

	 * Since we set the inode type below we need to mask off

	 * to avoid strange results if bits set above.

 safest to call it a file if we do not know */

/*

 * Fill a cifs_fattr struct with fake inode info.

 *

 * Needed to setup cifs_fattr data for the directory which is the

 * junction to the new submount (ie to setup the fake directory

 * which represents a DFS referral).

 could have done a find first instead but this returns more info */

 check for Minshall+French symlinks */

 get new inode */

 we already have inode, update it */

 if uniqueid is different, return error */

 force reval */

 if filetype is different, return error */

 EOPNOTSUPP? */

 Read header */

 we have enough to decode dev num */

 major */

 minor */

 we have enough to decode dev num */

 major */

 minor */

 file? */

 then it is a file */

 or some unknown SFU type */

 SETFILEBITS valid bits */

/*

 * Fetch mode bits as provided by SFU.

 *

 * FIXME: Doesn't this clobber the type bit we got from cifs_sfu_type ?

 size of buf */,

 Fill a cifs_fattr struct with info from POSIX info struct */

 no fattr->flags to set */

 The srv fs device id is overridden on network mount so setting rdev isn't needed here */

 fattr->cf_rdev = le32_to_cpu(info->DeviceId); */

 file */

 else if reparse point ... TODO: add support for FIFO and blk dev; special file types */

 TODO: map uid and gid from SID */

 Fill a cifs_fattr struct with info from FILE_ALL_INFO */

 TODO add more reparse tag checks */

		/*

		 * Server can return wrong NumberOfLinks value for directories

		 * when Unix extensions are disabled - fake it.

 clear write bits if ATTR_READONLY is set */

		/*

		 * Don't accept zero nlink from non-unix servers unless

		 * delete is pending.  Instead mark it as unknown.

 TODO: add support to query reparse tag */

 no reparse tag */);

		/*

		 * FIXME: legacy server -- fall back to path-based call?

		 * for now, just skip revalidating and mark inode for

		 * immediate reval.

	/*

	 * don't bother with SFU junk here -- just mark inode as needing

	 * revalidation.

 if filetype is different, return error */

 Simple function to return a 64 bit hash of string.  Rarely called */

 a big enough prime */

/**

 * cifs_backup_query_path_info - SMB1 fallback code to get ino

 *

 * Fallback code to get file metadata when we don't have access to

 * full_path (EACCES) and have backup creds.

 *

 * @xid:	transaction id used to identify original request in logs

 * @tcon:	information about the server share we have mounted

 * @sb:	the superblock stores info such as disk space available

 * @full_path:	name of the file we are getting the metadata for

 * @resp_buf:	will be set to cifs resp buf and needs to be freed with

 * 		cifs_buf_release() when done with @data

 * @data:	will be set to search info result buffer

 no srvino useful for fallback to some netapp */

	/*

	 * If we have an inode pass a NULL tcon to ensure we don't

	 * make a round trip to the server. This only works for SMB2+.

		/*

		 * If that fails reuse existing ino or generate one

		 * and disable server ones

 If no errors, check for zero root inode (invalid) */

 reuse */

 make an ino by hashing the UNC */

	/*

	 * 1. Fetch file metadata if not provided (data)

	/*

	 * 2. Convert it to internal cifs metadata (fattr)

		/*

		 * If the file is a reparse point, it is more complicated

		 * since we have to check if its reparse tag matches a known

		 * special file type e.g. symlink or fifo or char etc.

 DFS link, no metadata available on this server */

		/*

		 * perm errors, try again with backup flags if possible

		 *

		 * For SMB2 and later the backup intent flag

		 * is already sent if needed on open and there

		 * is no path based FindFirst operation to use

		 * to retry with

 for easier reading */

 uniqueid set, skip get inum step */

 nothing we can do, bail out */

	/*

	 * 3. Get or update inode number (fattr.cf_uniqueid)

	/*

	 * 4. Tweak fattr based on mount options

 query for SFU type info if supported and needed */

 fill in 0777 bits from ACL */

 fill in remaining high mode bits e.g. SUID, VTX */

 check for Minshall+French symlinks */

	/*

	 * 5. Update inode with final fattr data

 we already have inode, update it */

 if uniqueid is different, return error */

 force reval */

 if filetype is different, return error */

	/*

	 * 1. Fetch file metadata

	/*

	 * 2. Convert it to internal cifs metadata (fattr)

 DFS link, no metadata available on this server */

		/*

		 * For SMB2 and later the backup intent flag

		 * is already sent if needed on open and there

		 * is no path based FindFirst operation to use

		 * to retry with so nothing we can do, bail out

	/*

	 * 3. Tweak fattr based on mount options

 check for Minshall+French symlinks */

	/*

	 * 4. Update inode with final fattr data

 we already have inode, update it */

 if uniqueid is different, return error */

 force reval */

 if filetype is different, return error */

 don't match inode with different uniqueid */

 use createtime like an i_generation field */

 don't match inode of different type */

 if it's not a directory or has no dentries, then flag it */

/*

 * walk dentry list for an inode and report whether it has aliases that

 * are hashed. We use this to determine if a directory inode can actually

 * be used.

 Given fattrs, get a corresponding inode */

 hash down to 32-bits on 32-bit arch */

 was there a potentially problematic inode collision? */

 can't fail - see cifs_find_inode() */

 initialize per-inode cache cookie pointer */

 gets root inode */

 leading sep + null */, GFP_KERNEL);

 some servers mistakenly claim POSIX support */

 populate tcon->resource_id */

	/*

	 * Samba throws this field away, but windows may actually use it.

	 * Do not set ctime unless other time stamps are changed explicitly

	 * (i.e. by utimes()) since we would then have a mix of client and

	 * server times.

 don't change */

/*

 * Open the given file (if it isn't already), set the DELETE_ON_CLOSE bit

 * and rename it to a random name that hopefully won't conflict with

 * anything else.

	/*

	 * We cannot rename the file if the server doesn't support

	 * CAP_INFOLEVEL_PASSTHRU

 set ATTR_HIDDEN and clear ATTR_READONLY, but only if needed */

		/* although we would like to mark the file hidden

 since not able to change them */

 rename the file */

 try to set DELETE_ON_CLOSE */

		/*

		 * some samba versions return -ENOENT when we try to set the

		 * file disposition here. Likely a samba bug, but work around

		 * it for now. This means that some cifsXXX files may hang

		 * around after they shouldn't.

		 *

		 * BB: remove this hack after more servers have the fix

	/*

	 * reset everything back to the original state. Don't bother

	 * dealing with errors here since we can't do anything about

	 * them anyway.

 copied from fs/nfs/dir.c with small changes */

/*

 * If d_inode(dentry) is null (usually meaning the cached dentry

 * is a negative dentry) then we would attempt a standard SMB delete, but

 * if that fails we can not attempt the fall back mechanisms on EACCES

 * but will return the EACCES to the caller. Note that the VFS does not call

 * unlink on negative dentries currently.

	/* Unlink can be called from rename so we can not take the

 try to reset dos attributes */

 undo the setattr if we errored out and it's needed */

		cifs_inode->time = 0;	/* will force revalidate to get info

 force revalidate of dir as well */

		/*

		 * mkdir succeeded, but another client has managed to remove the

		 * sucker and replace it with non-directory.  Return success,

		 * but don't leave the child in dcache.

	/*

	 * setting nlink not necessary except in cases where we failed to get it

	 * from the server or was set bogus. Also, since this is a brand new

	 * inode, no need to grab the i_lock before setting the i_nlink.

 must turn on setgid bit if parent dir has it */

 no change */

 no change */

 netfid */, info, &oplock, full_path,

 no return info, go query for it */

	/*

	 * BB check (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID ) to see if

	 * need to set uid/gid.

 for time being always refresh inode info */

 BB add setting the equivalent of mode via CreateX w/ACLs */

 TODO: skip this for smb2/smb3 */

	/*

	 * Force revalidate to get parent dir info when needed since cached

	 * attributes are invalid now.

 force revalidate to go get info when needed */

	/*

	 * Force revalidate to get parent dir info when needed since cached

	 * attributes are invalid now.

 try path-based rename first */

	/*

	 * Don't bother with rename by filehandle unless file is busy and

	 * source. Note that cross directory moves do not work with

	 * rename by filehandle to various Windows servers.

 Don't fall back to using SMB on SMB 2+ mount */

 open-file renames don't work across directories */

 open the file to be renamed -- we need DELETE perms */

	/*

	 * No-replace is the natural behavior for CIFS, so skip unlink hacks.

		/*

		 * Are src and dst hardlinks of same inode? We can only tell

		 * with unix extensions enabled.

 same file, POSIX says that this is a noop */

	/*

	 * else ... BB we could add the same check for Windows by

	 * checking the UniqueId via FILE_INTERNAL_INFO

 Try unlinking the target dentry if it's not negative */

 force revalidate to go get info when needed */

	/*

	 * depending on inode type, check if attribute caching disabled for

	 * files or directories

 file */

 hardlinked files w/ noserverino get "special" treatment */

/*

 * Zap the cache. Called when invalid_mapping flag is set.

/**

 * cifs_wait_bit_killable - helper for functions that are sleeping on bit locks

 *

 * @key:	currently unused

 * @mode:	the task state to sleep in

 swapfiles are not supposed to be shared */

 for cache=singleclient, do not invalidate */

 revalidate a dentry's inode attributes */

	/*

	 * We need to be sure that all dirty pages are written and the server

	 * has actual ctime, mtime and file length.

 force revalidate */

	/*

	 * If the caller doesn't require syncing, only sync if

	 * necessary (e.g. due to earlier truncate or setattr

	 * invalidating the cached metadata)

 old CIFS Unix Extensions doesn't return create time */

	/*

	 * If on a multiuser mount without unix extensions or cifsacl being

	 * enabled, and the admin hasn't overridden them, set the ownership

	 * to the fsuid/fsgid of the current process.

	/*

	 * We need to be sure that all dirty pages are written as they

	 * might fill holes on the server.

 Cached inode must be refreshed on truncate */

	/*

	 * To avoid spurious oplock breaks from server, in the case of

	 * inodes that we already have open, avoid doing path based

	 * setting of file size if we can do it by handle.

	 * This keeps our caching token (oplock) and avoids timeouts

	 * when the local oplock break takes longer to flush

	 * writebehind data than the SMB timeout for the SetPathInfo

	 * request would allow

	/*

	 * Set file size by pathname rather than by handle either because no

	 * valid, writeable file handle for it was found or because there was

	 * an error setting it by handle.

		/*

		 * i_blocks is not related to (i_size / i_blksize), but instead

		 * 512 byte (2**9) size is required for calculating num blocks.

		 * Until we can query the server for actual allocation size,

		 * this is best estimate we have for blocks allocated for a file

		 * Number of blocks must be rounded up so size 1 is not 0 blocks

		/*

		 * The man page of truncate says if the size changed,

		 * then the st_ctime and st_mtime fields for the file

		 * are updated.

	/*

	 * Attempt to flush data before changing attributes. We need to do

	 * this for ATTR_SIZE and ATTR_MTIME for sure, and if we change the

	 * ownership or mode then we may also need to do this. Here, we take

	 * the safe way out and just do the flush on all setattr requests. If

	 * the flush returns error, store it to report later and continue.

	 *

	 * BB: This should be smarter. Why bother flushing pages that

	 * will be truncated anyway? Also, should we error out here if

	 * the flush returns error?

 skip mode change if it's just for clearing setuid/setgid */

 set up the struct */

 no change */

 no change */

	/* force revalidate when any of these times are set since some

	   of the fs types (eg ext3, fat) do not have fine enough

	   time granularity to match protocol, and we do not have a

	   a way (yet) to query the server fs's time granularity (and

	   whether it rounds times down).

	/*

	 * Attempt to flush data before changing attributes. We need to do

	 * this for ATTR_SIZE and ATTR_MTIME.  If the flush of the data

	 * returns error, store it to report later and continue.

	 *

	 * BB: This should be smarter. Why bother flushing pages that

	 * will be truncated anyway? Also, should we error out here if

	 * the flush returns error? Do we need to check for ATTR_MTIME_SET flag?

 skip mode change if it's just for clearing setuid/setgid */

			/*

			 * In case of CIFS_MOUNT_CIFS_ACL, we cannot support all modes.

			 * Pick up the actual mode bits that were set.

 fix up mode if we're not using dynperm */

 Attributes of 0 are ignored */

 reset local inode permissions to normal */

 ignore mode change - ATTR_READONLY hasn't changed */

 BB: check for rc = -EOPNOTSUPP and switch to legacy mode */

		/* Even if error on time set, no sense failing the call if

		the server would set the time to a reasonable value anyway,

		and this check ensures that we are not being called from

		sys_utimes in which case we ought to fail the call back to

	/* do not need local check to inode_check_ok since the server does

 BB: add cifs_setattr_legacy for really old servers */

 SPDX-License-Identifier: LGPL-2.1

/*

 *

 *   Copyright (C) International Business Machines  Corp., 2002, 2011

 *                 Etersoft, 2012

 *   Author(s): Pavel Shilovsky (pshilovsky@samba.org),

 *              Steve French (sfrench@us.ibm.com)

 *

/*

 * note: If cfile is passed, the reference to it is dropped here.

 * So make sure that you do not reuse cfile after return from this func.

 We already have a handle so we can skip the open */

 Open */

 Operation */

 TBD: fix following to allow for longer SIDs */

		/*

		 * Directories are created through parameters in the

		 * SMB2_open() call.

 sizeof __u8 See MS-FSCC section 2.4.11 */

 sizeof __le64 */

 null */;

 null */;

 We already have a handle so we can skip the close */

 Close */

 add SIDs */, ptr);

 we don't use it */

 If it is a root and its handle is cached then use it */

 Failed on a symbolic link - query a reparse point info */

 BB TODO: Make struct larger when add support for parsing owner SIDs */

	/*

	 * BB TODO: Add support for using the cached root handle.

	 * Create SMB2_query_posix_info worker function to do non-compounded query

	 * when we already have an open file handle for this. For now this is fast enough

	 * (always using the compounded version).

 BB TODO: When support for special files added to Samba re-verify this path */

 Failed on a symbolic link - query a reparse point info */

 TODO: will need to allow for the 2 SIDs when add support for getting owner UID/GID */

 would be a no op, no sense sending this */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Unix SMB/Netbios implementation.

 *  Version 1.9.

 *  RPC Pipe client / server routines

 *  Copyright (C) Luke Kenneth Casson Leighton 1997-2001.

 NT error codes - see nterr.h */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *

 *   Copyright (C) International Business Machines  Corp., 2000,2005

 *

 *   Modified by Steve French (sfrench@us.ibm.com)

 CONFIG_CIFS_DEBUG2 */

 STATS2 */

 CONFIG_CIFS_DEBUG2 */

 CIFS_DEBUG2 */

 CIFS_DEBUG2 */

 channel info will be printed as a part of sessions below */

 dump session id helpful for use with network trace */

 BB add code to dump additional info such as TCP session info now */

 CONFIG_CIFS_STATS2 */

 CONFIG_CIFS_STATS2 */

 STATS2 */

 CONFIG_CIFS_STATS2 */

 STATS2 */

 see cifs_debug.h for meanings */

/*

 * Ensure that if someone sets a MUST flag, that we disable all other MAY

 * flags except for the ones corresponding to the given MUST flag. If there are

 * multiple MUST flags, then try to prefer more secure ones.

 single char or single char followed by null */

 else we have a number */

 flags look ok - update the global security flags for cifs module */

 requiring signing implies signing is allowed */

 BB should we turn on MAY flags for other MUST options? */

 To make it easier to debug, can help to show mount params */

 cannot use switch with pointers... */

 No need for write for now */

 .proc_write	= cifs_mount_params_proc_write, */

 PROC_FS */

 SPDX-License-Identifier: LGPL-2.1

/*

 *

 *   vfs operations that deal with dentries

 *

 *   Copyright (C) International Business Machines  Corp., 2002,2009

 *   Author(s): Steve French (sfrench@us.ibm.com)

 *

	/* BB check if there is a way to get the kernel to do this or if we

 if no prefix path, simply set path to the root of share to "" */

 Note: caller must free return buffer */

 for root we want "", not "/"

 BB test paths to Windows with '/' in the midst of prepath */

/*

 * Don't allow path components longer than the server max.

 * Don't allow the separator character in a path component.

 * The VFS will not allow "/", but "\" is allowed by posix.

 Inode operations in similar order to how they appear in Linux file fs.h */

 query inode info */

				/*

				 * The server may allow us to open things like

				 * FIFOs, but the client isn't set up to deal

				 * with that. If it's not a regular file, just

				 * close it and proceed as if it were a normal

				 * lookup.

 success, no need to query */

			/*

			 * EIO could indicate that (posix open) operation is not

			 * supported, despite what server claimed in capability

			 * negotiation.

			 *

			 * POSIX open in samba versions 3.3.1 and earlier could

			 * incorrectly fail with invalid parameter.

			/*

			 * EREMOTE indicates DFS junction, which is not handled

			 * in posix open.  If either that or op not supported

			 * returned, follow the normal lookup.

		/*

		 * fallthrough to retry, using older open call, this is case

		 * where server does not support this SMB level, and falsely

		 * claims capability (also get here for DFS case which should be

		 * rare for path not covered on files)

 is this too little? */

	/*

	 * BB add processing to set equivalent of mode - e.g. via CreateX with

	 * ACLs

	/*

	 * if we're not using unix extensions, see if we need to set

	 * ATTR_READONLY on the create call

	/*

	 * If Open reported that we actually created a file then we now have to

	 * set the mode if possible.

 no change */

 no change */

		/*

		 * BB implement mode setting via Windows security

		 * descriptors e.g.

 CIFSSMBWinSetPerms(xid,tcon,path,mode,-1,-1,nls);*/

 Could set r/o dos attribute if mode & 0222 == 0 */

 server might mask mode so we have to query for it */

 TODO: Add support for calling POSIX query info here, but passing in fid */

	/*

	 * Posix open is only called (at lookup time) for file create now. For

	 * opens (rather than creates), because we do not know if it is a file

	 * or directory yet, and current Samba no longer allows us to do posix

	 * open on dirs, we could end up wasting an open call on what turns out

	 * to be a dir. For file opens, we wait to call posix open till

	 * cifs_open.  It could be added to atomic_open in the future but the

	 * performance tradeoff of the extra network request when EISDIR or

	 * EACCES is returned would have to be weighed against the 50% reduction

	 * in network traffic in the other paths.

		/*

		 * Check for hashed negative dentry. We have already revalidated

		 * the dentry and it is fine. No need to perform another lookup.

	/*

	 * BB below access is probably too much for mknod to request

	 *    but we have to do query and setpathinfo so requesting

	 *    less could fail (unless we want to request getatr and setatr

	 *    permissions (only).  At least for POSIX we do not have to

	 *    request so much.

 to get around spurious gcc warning, set to zero here */

 check whether path exists */

	/* can not grab the rename sem here since it would

	deadlock in the cases (beginning of sys_rename itself)

		/* since paths are not looked up by component - the parent

			/* We special case check for Access Denied - since that

 force reval */

				/*

				 * Those errors mean the dentry is invalid

				 * (file was deleted or recreated)

				/*

				 * Otherwise some unexpected error happened

				 * report it as-is to VFS layer

			/*

			 * If the inode wasn't known to be a dfs entry when

			 * the dentry was instantiated, such as when created

			 * via ->readdir(), it needs to be set now since the

			 * attributes will have been updated by

			 * cifs_revalidate_dentry().

	/*

	 * This may be nfsd (or something), anyway, we can't see the

	 * intent of this. So, since this can be for creation, drop it.

	/*

	 * Drop the negative dentry, in order to make sure to use the

	 * case sensitive name which is specified by user if this is

	 * for creation.

/* static int cifs_d_delete(struct dentry *direntry)

{

	int rc = 0;



	cifs_dbg(FYI, "In cifs d_delete, name = %pd\n", direntry);



	return rc;

 d_delete:       cifs_d_delete,      */ 
 error out if we can't convert the character */

	/*

	 * We make the assumption here that uppercase characters in the local

	 * codepage are always the same length as their lowercase counterparts.

	 *

	 * If that's ever not the case, then this will fail to match it.

 Convert characters in both strings to UTF-16. */

		/*

		 * If we can't convert either character, just declare it to

		 * be 1 byte long and compare the original byte.

		/*

		 * Here, we again ass|u|me that upper/lowercase versions of

		 * a character are the same length in the local NLS.

 Now compare uppercase versions of these characters */

 SPDX-License-Identifier: LGPL-2.1

/*

 *

 *   Copyright (C) International Business Machines  Corp., 2002,2011

 *                 Etersoft, 2012

 *   Author(s): Steve French (sfrench@us.ibm.com)

 *              Pavel Shilovsky (pshilovsky@samba.org) 2012

 *

	/*

	 * Make sure that this really is an SMB, that it is a response,

	 * and that the message ids match.

 only one valid case where server sends us request */

 bad signature or mid */

/*

 *  The following table defines the expected "StructureSize" of SMB2 responses

 *  in order by SMB2 command.  This is similar to "wct" in SMB/CIFS responses.

 *

 *  Note that commands are defined in smb2pdu.h in le16 but the array below is

 *  indexed by command in host byte order

 SMB2_NEGOTIATE */ cpu_to_le16(65),

 SMB2_SESSION_SETUP */ cpu_to_le16(9),

 SMB2_LOGOFF */ cpu_to_le16(4),

 SMB2_TREE_CONNECT */ cpu_to_le16(16),

 SMB2_TREE_DISCONNECT */ cpu_to_le16(4),

 SMB2_CREATE */ cpu_to_le16(89),

 SMB2_CLOSE */ cpu_to_le16(60),

 SMB2_FLUSH */ cpu_to_le16(4),

 SMB2_READ */ cpu_to_le16(17),

 SMB2_WRITE */ cpu_to_le16(17),

 SMB2_LOCK */ cpu_to_le16(4),

 SMB2_IOCTL */ cpu_to_le16(49),

 BB CHECK this ... not listed in documentation */

 SMB2_CANCEL */ cpu_to_le16(0),

 SMB2_ECHO */ cpu_to_le16(4),

 SMB2_QUERY_DIRECTORY */ cpu_to_le16(9),

 SMB2_CHANGE_NOTIFY */ cpu_to_le16(9),

 SMB2_QUERY_INFO */ cpu_to_le16(9),

 SMB2_SET_INFO */ cpu_to_le16(2),

 BB FIXME can also be 44 for lease break */

 SMB2_OPLOCK_BREAK */ cpu_to_le16(24)

 Negotiate contexts are only valid for latest dialect SMB3.11 */

	/*

	 * if SPNEGO blob present (ie the RFC2478 GSS info which indicates

	 * which security mechanisms the server supports) make sure that

	 * the negotiate contexts start after it

	/*

	 * non_ctxlen is at least shdr->StructureSize + pdu->StructureSize2

	 * and the latter is 1 byte bigger than the fix-sized area of the

	 * NEGOTIATE response

 has padding, but no SPNEGO blob */

 Verify that at least minimal negotiate contexts fit within frame */

 length of negcontexts including pad from end of sec blob to them */

 calculated length */

	/*

	 * Add function to do table lookup of StructureSize by command

	 * ie Validate the wct via smb2_struct_sizes table above

 decrypt frame now that it is completely read in */

			/*

			 * As with SMB/CIFS, on some error cases servers may

			 * not return wct properly

 error packets have 9 byte structure size */

 special case for SMB2.1 lease break message */

 create failed on symlink */

 Windows 7 server returns 24 bytes more */

 server can return one byte more due to implied bcc[0] */

		/*

		 * Some windows servers (win2016) will pad also the final

		 * PDU in a compound to 8 bytes.

		/*

		 * MacOS server pads after SMB2.1 write response with 3 bytes

		 * of junk. Other servers match RFC1001 len to actual

		 * SMB2/SMB3 frame length (header + smb2 response specific data)

		 * Some windows servers also pad up to 8 bytes when compounding.

/*

 * The size of the variable area depends on the offset and length fields

 * located in different fields for various SMB2 responses. SMB2 responses

 * with no variable length info, show an offset of zero for the offset field.

 SMB2_NEGOTIATE */ true,

 SMB2_SESSION_SETUP */ true,

 SMB2_LOGOFF */ false,

 SMB2_TREE_CONNECT */	false,

 SMB2_TREE_DISCONNECT */ false,

 SMB2_CREATE */ true,

 SMB2_CLOSE */ false,

 SMB2_FLUSH */ false,

 SMB2_READ */	true,

 SMB2_WRITE */ false,

 SMB2_LOCK */	false,

 SMB2_IOCTL */ true,

 SMB2_CANCEL */ false, 
 SMB2_ECHO */ false,

 SMB2_QUERY_DIRECTORY */ true,

 SMB2_CHANGE_NOTIFY */ true,

 SMB2_QUERY_INFO */ true,

 SMB2_SET_INFO */ false,

 SMB2_OPLOCK_BREAK */ false

/*

 * Returns the pointer to the beginning of the data area. Length of the data

 * area and the offset to it (from the beginning of the smb are also returned.

 error responses do not have data area */

	/*

	 * Following commands have data areas so we have to get the location

	 * of the data buffer offset and data buffer length for the particular

	 * command.

 TODO: is this a bug ? */

	/*

	 * Invalid length or offset probably means data area is invalid, but

	 * we have little choice but to ignore the data area in this case.

 return pointer to beginning of data area, ie offset from SMB start */

/*

 * Calculate the size of the SMB message based on the fixed header

 * portion, the number of word parameters and the data portion of the message.

 the offset from the beginning of SMB to data area */

 the length of the variable length data area */

 Structure Size has already been checked to make sure it is 64 */

	/*

	 * StructureSize2, ie length of fixed parameter area has already

	 * been checked to make sure it is the correct length.

		/*

		 * Check to make sure that data area begins after fixed area,

		 * Note that last byte of the fixed area is part of data area

		 * for some commands, typically those with odd StructureSize,

		 * so we must add one to the calculation.

 Note: caller must free return buffer */

 Windows doesn't allow paths beginning with \ */

 SMB311 POSIX extensions paths do not include leading slash */

 look up tcon based on tid & uid */

 look up tcon based on tid & uid */

/*

 * Caller should already has an extra reference to @tcon

 * This function is used to queue work to close a handle to prevent leaks

 * on the server.

 * We handle two cases. If an open was interrupted after we sent the

 * SMB2_CREATE to the server but before we processed the reply, and second

 * if a close was interrupted before we sent the SMB2_CLOSE to the server.

/**

 * smb311_update_preauth_hash - update @ses hash with the packet data in @iov

 *

 * Assumes @iov does not contain the rfc1002 length and iov[0] has the

 * SMB2 header.

 *

 * @ses:	server session structure

 * @iov:	array containing the SMB request we will send to the server

 * @nvec:	number of array entries for the iov

 neg prot are always taken */

	/*

	 * If we process a command which wasn't a negprot it means the

	 * neg prot was already done, so the server dialect was set

	 * and we can test it. Preauth requires 3.1.1 for now.

 skip last sess setup response */

 SPDX-License-Identifier: LGPL-2.1

/*

 *

 *   Copyright (C) International Business Machines  Corp., 2002,2010

 *   Author(s): Steve French (sfrench@us.ibm.com)

 *

 *   Contains the routines for constructing the SMB PDUs themselves

 *

 SMB/CIFS PDU handling routines here - except for leftovers in connect.c   */

 These are mostly routines that operate on a pathname, or on a tree id     */

 (mounted volume), but there are eight handle based routines which must be */

 treated slightly differently for reconnection purposes since we never     */

 want to reuse a stale file handle and only the caller knows the file info */

 define the number of elements in the cifs dialect array */

 not posix */

 CIFS_POSIX */

/*

 * Mark as invalid, all open files on tree connections since they

 * were closed when session to server was lost.

 list all files open on tree connection and mark them invalid */

 cached handle is not valid, so SMB2_CLOSE won't be sent below */

	/*

	 * BB Add call to invalidate_inodes(sb) for all superblocks mounted

	 * to this tcon.

 reconnect the socket, tcon, and smb session if needed */

	/*

	 * SMBs NegProt, SessSetup, uLogoff do not have tcon yet so check for

	 * tcp and smb session status done differently for those three - in the

	 * calling routine

	/*

	 * only tree disconnect, open, and write, (and ulogoff which does not

	 * have tcon) are allowed as we start force umount

	/*

	 * Give demultiplex thread up to 10 seconds to each target available for

	 * reconnect -- should be greater than cifs socket timeout which is 7

	 * seconds.

 are we still trying to reconnect? */

		/*

		 * on "soft" mounts we wait once. Hard mounts keep

		 * retrying until process is killed or server comes

		 * back on-line

	/*

	 * need to prevent multiple threads trying to simultaneously

	 * reconnect the same SMB session

	/*

	 * Recheck after acquire mutex. If another thread is negotiating

	 * and the server never sends an answer the socket will be closed

	 * and tcpStatus set to reconnect.

 do we need to reconnect tcon? */

 tell server Unix caps we support */

	/*

	 * Removed call to reopen open files here. It is safer (and faster) to

	 * reopen files one at a time as needed in read and write.

	 *

	 * FIXME: what about file locks? don't we need to reclaim them ASAP?

	/*

	 * Check if handle based operation so we know whether we can continue

	 * or not without returning to caller to reset file handle

/* Allocate and return pointer to an SMB request buffer, and set basic

   SMB information in the SMB header.  If the return code is zero, this

 BB should we add a retry in here if not a writepage? */

 uid, tid can stay at zero as set in header assemble */

	/* BB add support for turning on the signing when

 If the return code is zero, this function must fill in request_buf pointer */

 BB should we add a retry in here if not a writepage? */

 Although the original thought was we needed the response buf for  */

 potential retries of smb operations it turns out we can determine */

 from the mid flags when the request buffer can be resent without  */

 having to use a second distinct buffer for the response */

 If the return code is zero, this function must fill in request_buf pointer */

 check for plausible wct */

 check for parm and data offset going beyond end of smb */

	/* check that bcc is at least as big as parms + data, and that it is

	 * less than negotiated smb buffer

	/*

	 * Is signing required by mnt options? If not then check

	 * global_secflags to see if it is there.

	/*

	 * If signing is required then it's automatically enabled too,

	 * otherwise, check to see if the secflags allow it.

 If server requires signing, does client allow it? */

 If client requires signing, does server allow it? */

 no tcon yet */ ,

	/*

	 * We know that all the name entries in the protocols array

	 * are short (< 16 bytes anyway) and are NUL terminated.

 Check wct = 1 error case */

		/* core returns wct = 1, but we do not ask for core - otherwise

		small wct just comes when dialect index is -1 indicating we

 unknown wct */

 else wct == 17, NTLM or better */

	/* one byte, so no need to convert this or EncryptionKeyLen from

 probably no need to store and check maxvcs */

 set up max_read for readpages check */

 no crypt key only if plain text pwd */

 BB: do we need to check this? These should never be NULL. */

	/*

	 * No need to return error on this operation if tid invalidated and

	 * closed on server already e.g. due to tcp session crashing. Also,

	 * the tcon is no longer on the list, so no need to take lock before

	 * checking this.

	/* No need to return error on this operation if tid invalidated and

/*

 * This is a no-op for now. We're not really interested in the reply, but

 * rather in the fact that the server sent one and that server->lstrp

 * gets updated.

 *

 * FIXME: maybe we should consider checking that the reply matches request?

 set up echo request */

	/*

	 * BB: do we need to check validity of ses and server? They should

	 * always be valid since we have an active reference. If not, that

	 * should probably be a BUG()

		goto session_already_dead; /* no need to send SMBlogoff if uid

	/* if session dead then we do not need to do ulogoff,

		since server closed smb session, no sense reporting

 trailing null */

 BB double check this with jra */

	/* Setup pointer to Request Data (inode type).

	 * Note that SMB offsets are from the beginning of SMB which is 4 bytes

	 * in, after RFC1001 field

 pad */  + params + sizeof(struct unlink_psx_rq);

 trailing null */

 trailing null */

 trailing null */

 trailing null */

 large enough */

 SMB offsets are from the beginning of SMB which is 4 bytes in, after RFC1001 field */

 pad */  + params + count;

 bad smb */

 copy return information to pRetData */

 cifs fid stays in le */

 Let caller know file was created so we can set the mode. */

 Do we care about the CreateAction in any other cases? */

 check to make sure response data is there */

 unknown */

 regular open */

 just go for read/write */

 none */

 account for one byte pad to word boundary */

 trailing null */

 no pad */

 deny none */

	/* set file as system file if special file such

	   as fifo and server expecting SFU style and

 BB FIXME BB */

ATTR_NORMAL*/);

 BB FIXME BB */

/*	pSMB->CreateOptions = cpu_to_le32(create_options &

 BB FIXME END BB */

 BB verify if wct == 15 */

		*pOplock = pSMBr->OplockLevel; */ 
 cifs fid stays in le */

 Let caller know file was created so we can set the mode. */

 Do we care about the CreateAction in any other cases? */

 BB FIXME BB */

/*		if (cpu_to_le32(FILE_CREATE) == pSMBr->CreateAction)

 BB FIXME END */

 BB convert CreateTime*/

 BB fixme */

 BB fixme */

 BB fixme */

 the file_info buf is endian converted by caller */

 no commands go after this */

 account for one byte pad to word boundary */

 trailing null */

 BB improve check for buffer overruns BB */

 no pad */

	/*

	 * Set file as system file if special file such as fifo and server

	 * expecting SFU style and no Unix extensions.

	/*

	 * XP does not handle ATTR_POSIX_SEMANTICS but it helps speed up case

	 * sensitive checks for other servers such as Samba.

 BB Expirement with various impersonation levels and verify */

 1 byte no need to le_to_cpu */

 cifs fid stays in le */

 Let caller know file was created so we can set the mode. */

 Do we care about the CreateAction in any other cases? */

 copy from CreationTime to Attributes */

 the file_info buf is endian converted by caller */

/*

 * Discard any remaining data in the current SMB. To do this, we borrow the

 * current bigbuf.

	/*

	 * read the rest of READ_RSP header (sans Data array), or whatever we

	 * can if there's not enough data. At this point, we've read down to

	 * the Mid.

 set up first two iov for signature check and to get credits */

 Was the SMB read successful? */

 normal error on read response */

 Is there enough to get to the rest of the READ_RSP header? */

		/*

		 * win2k8 sometimes sends an offset of 0 when the read

		 * is beyond the EOF. Treat it as if the data starts just after

		 * the header.

 data_offset is beyond the end of smallbuf */

 read any junk before data into the rest of smallbuf */

 how much data is in the response? */

 data_len is corrupt -- discard frame */

 discard anything left over */

 result already set, check signature */

 FIXME: should this be counted toward the initiating task? */

 reset bytes number since we can not check a sign */

 FIXME: should this be counted toward the initiating task? */

 cifs_async_readv - send an async write, and set up mid to handle result */

 old style read */

 can not handle this big offset for old */

 none */

 old style read */

 4 for RFC1001 length + 1 for BCC */

 old style read */

 can not handle this big offset for old */

 tcon and ses pointer are checked in smb_init */

 none */

 no need to do le conversion since 0 */

 old style read */

check that DataLength would not go beyond end of SMB */

/*			if (rc = copy_to_user(buf, pReadData, data_length)) {

				cifs_dbg(VFS, "Faulting on read rc = %d\n",rc);

				rc = -EFAULT;

 can not use copy_to_user when using page cache*/

 return buffer to caller to free */

 else no valid buffer on return - leave as null */

	/* Note: On -EAGAIN error only caller can retry on handle based calls

 cifs_dbg(FYI, "write at %lld %d bytes\n", offset, count);*/

 can not handle big offset for old srv */

 tcon and ses pointer are checked in smb_init */

 none */

	/* Can increase buffer size if buffer is big enough in some cases ie we

	can send more if LARGE_WRITE_X capability returned by the server and if

	our buffer is big enough or if we convert to iovecs on socket writes

 No buffer */

 else setting file size with write of zero bytes */

 pad */

 wct == 12 */

 bigger pad, smaller smb hdr */

	else { /* old style write has byte count 4 bytes earlier

		/*

		 * Mask off high 16 bits when bytes written as returned by the

		 * server is greater than bytes requested by the client. Some

		 * OS/2 servers are known to set incorrect CountHigh values.

	/* Note: On -EAGAIN error only caller can retry on handle based calls

/*

 * Write failed with a retryable error. Resend the write request. It's also

 * possible that the page was redirtied so re-clean the page.

 cleanup remaining pages from the original wdata */

/*

 * Check the mid_state and signature on received buffer (if any), and queue the

 * workqueue completion task.

		/*

		 * Mask off high 16 bits when bytes written as returned

		 * by the server is greater than bytes requested by the

		 * client. OS/2 servers are known to set incorrect

		 * CountHigh values.

 cifs_async_writev - send an async write, and set up mid to handle result */

 can not handle big offset for old srv */

 none */

 4 for RFC1001 length + 1 for BCC */

 wct == 12 */

 pad bigger by four bytes */

 can not handle big offset for old srv */

 tcon and ses pointer are checked in smb_init */

 none */

 header + 1 byte pad */

 wct == 12 */

 smb data starts later */

 wct == 12 */ 
 wct == 12 pad bigger by four bytes */

 presumably this can not happen, but best to be safe */

		/*

		 * Mask off high 16 bits when bytes written as returned by the

		 * server is greater than bytes requested by the client. OS/2

		 * servers are known to set incorrect CountHigh values.

	/* Note: On -EAGAIN error only caller can retry on handle based calls

 none */

 netfid stays le */

	LOCK_RSP *pSMBr = NULL; */ 
 no response expected */

 blocking operation, no timeout */

 blocking - do not time out */

 none */

 netfid stays le */

 BB where to store pid high? */

 oplock break */

	/* Note: On -EAGAIN error only caller can retry on handle based calls

 BB find max SMB from sess */

 pad */  + params + count;

 SMB offsets are from the beginning of SMB which is 4 bytes in, after RFC1001 field */

 blocking operation, no timeout */

 normalize negative numbers */

 num iovecs */,

 lock structure can be returned on get */

 bad smb */

	/* Note: On -EAGAIN error only caller can retry on handle based calls

 do not retry on dead session on close */

 EINTR is expected when user ctl-c to kill app */

 Since session is dead, file will be closed on server already */

 trailing null */

 pad */

 protocol requires ASCII signature byte on Unicode string */

 trailing null */  + 1 
 convert to bytes */

 2nd buffer format */

 signature byte */

 1st signature byte */  + name_len + name_len2;

 SMB offsets are from the beginning of SMB which is 4 bytes in, after RFC1001 field */

 BB find max SMB from sess */

 pad */  + params;

 construct random name ".cifs_tmp<inodenum><mid>" */

 unicode only call */

 sizeof(struct set_file_rename) */ + (2 * len_of_str);

	/* Note: On -EAGAIN error only caller can retry on handle based calls

 trailing null */

 pad */

 protocol requires ASCII signature byte on Unicode string */

 trailing null */  + 1 
 convert to bytes */

 2nd buffer format */

 signature byte */

 1st signature byte */  + name_len + name_len2;

 find define for this maxpathcomponent */

 trailing null */

 SMB offsets are from the beginning of SMB which is 4 bytes in, after RFC1001 field */

 find define for this maxpathcomponent */

 trailing null */

 BB find exact max on data count below from sess */

 pad */  + params + name_len_target;

 trailing null */

 SMB offsets are from the beginning of SMB which is 4 bytes in, after RFC1001 field */

 trailing null */

 BB find exact max on data count below from sess*/

 pad */  + params + name_len_target;

 trailing null */

 protocol specifies ASCII buffer format (0x04) for unicode */

 pad */

 trailing null */  + 1 
 convert to bytes */

 2nd buffer format */

 signature byte */

 string type byte */  + name_len + name_len2;

 SMB_QUERY_FILE_UNIX_LINK */

 trailing null */

 level */  + 4  incl null */ ;

 pad */ ;

 decode response */

 BB also check enough total bytes returned */

 BB FIXME investigate remapping reserved chars here */

/*

 *	Recent Windows versions now create symlinks more frequently

 *	and they use the "reparse point" mechanism below.  We can of course

 *	do symlinks nicely to Samba and other servers which support the

 *	CIFS Unix Extensions and we can also do SFU symlinks and "client only"

 *	"MF" symlinks optionally, but for recent Windows we really need to

 *	reenable the code below and fix the cifs_symlink callers to handle this.

 *	In the interim this code has been moved to its own config option so

 *	it is not compiled in by default until callers fixed up and more tested.

 BB find exact data count max from sess structure BB */

 FSCTL */

 file handle always le */

 BB also check enough total bytes returned */

 bad smb */

 Reparse tag is NTFS symlink */

 BB FIXME investigate remapping reserved chars here */

	/*

	 * Note: On -EAGAIN error only caller can retry on handle based calls

	 * since file handle passed in no longer valid.

 84 */

 FSCTL */

 file handle always le */

 3 byte pad, followed by 2 byte compress state */

	/*

	 * Note: On -EAGAIN error only caller can retry on handle based calls

	 * since file handle passed in no longer valid.

Convert an Access Control Entry from wire format to local POSIX xattr format*/

 u8 cifs fields do not need le conversion */

/*

	cifs_dbg(FYI, "perm %d tag %d id %d\n",

		 ace->e_perm, ace->e_tag, ace->e_id);

 Convert ACL from CIFS POSIX wire format to local Linux POSIX ACL xattr */

 check if we would go beyond end of SMB */

 skip past access ACEs to get to default ACEs */

 check if we would go beyond end of SMB */

 illegal type */

 used to query ACL EA size */

 buffer big enough */ {

 BB is there a better way to handle the large uid? */

 Probably no need to le convert -1 on any arch but can not hurt */

/*

	cifs_dbg(FYI, "perm %d tag %d id %d\n",

		 ace->e_perm, ace->e_tag, ace->e_id);

 Convert ACL from local Linux POSIX xattr to CIFS POSIX ACL wire format */

 BB add check to make sure ACL does not overflow SMB */

 SMB_QUERY_POSIX_ACL */

 trailing null */

 level */  + 4  incl null */ ;

 BB find exact max data count below from sess structure BB */

 pad */ ;

 decode response */

 BB also check enough total bytes returned */

 bad smb */

 trailing null */

 BB find max SMB size from sess */

 convert to on the wire format for POSIX ACL */

 pad */  + params + data_count;

 BB fix tabs in this function FIXME BB */

 level */ + 2 
 BB find exact max data count below from sess structure BB */

 pad */ ;

 decode response */

 BB also check enough total bytes returned */

			/* If rc should we check for EOPNOSUPP and

 bad smb */

 BB Do we need a cast or hash here ? */

 CONFIG_POSIX */

/*

 * Initialize NT TRANSACT SMB into small smb request buffer.  This assumes that

 * all NT TRANSACTS that we init here have total parm and data under about 400

 * bytes (to fit in small cifs buffer size), which is the case so far, it

 * easily fits. NB: Setup words themselves and ByteCount MaxSetupCount (size of

 * returned setup area) and MaxParameterCount (returned parms size) must be set

 * by caller

 for rfc1001 length itself */;

 no need to le convert byte fields */

 sizeof byte count */ + bcc +

 should we also check that parm and data areas do not overlap? */

 Get Security Descriptor (by handle) from remote server for a file or dir */

 parm len */, tcon, (void **) &pSMB);

 BB TEST with big acls that might need to be e.g. larger than 16K */

 file handle always le */

 3 bytes pad + 8 bytes parm */

 num iovec */, &buf_type,

 decode response */

 validate_nttransact */

 bad smb */

 BB check that data area is minimum length and as big as acl_len */

		/* check if buffer is big enough for the acl

 pad */  + param_count;

 file handle always le */

/* Legacy Query Path Information call for lookup to old servers such

 trailing null */

 account for buffer type byte */

 decode response */

 BB FIXME - add time zone adjustment BB */

 decode time fields */

 bad buffer passed in */

 level */ + 2 
 BB find exact max data count below from sess structure BB */

 pad */ ;

 decode response */

 BB add auto retry on EOPNOTSUPP? */

 bad smb */

 old style infolevel */,

 level 263 SMB_QUERY_FILE_ALL_INFO */

 cifs_dbg(FYI, "In QPathInfo path %s\n", search_name); */

 trailing null */

 level */ + 4  includes NUL */;

 BB find exact max SMB PDU from sess structure BB */

 pad */ ;

 decode response */

 BB add auto retry on EOPNOTSUPP? */

 bad smb */

			rc = -EIO;  /* 24 or 26 expected but we do not read

			/*

			 * On legacy responses we do not read the last field,

			 * EAsize, fortunately since it varies by subdialect and

			 * also note it differs on Set vs Get, ie two bytes or 4

			 * bytes depending but we don't care here.

 level */ + 2 
 BB find exact max data count below from sess structure BB */

 pad */ ;

 decode response */

 bad smb */

 SMB_QUERY_FILE_UNIX_BASIC */

 trailing null */

 level */ + 4  includes NUL */;

 BB find exact max SMB PDU from sess structure BB */

 pad */ ;

 decode response */

 bad smb */

 xid, tcon, searchName and codepage are input parms, rest are returned */

 level 257 SMB_ */

		/* We can not add the asterik earlier in case

		it got remapped to 0xF03A as if it were part of the

 now the trailing null */

 null terminate just in case */

 overwrite nul byte */

 includes null */ ;

 no EAs */

 pad */ ;

 one byte, no need to make endian neutral */

 BB what should we set StorageType to? Does it matter? BB */

	if (rc) {/* BB add logic to retry regular search if Unix search

 BB Add code to handle unsupported level rc */

 BB eventually could optimize out free and realloc of buf */

    for this case */

 decode response */

 BB remember to free buffer if error BB */

 skip . and .. */ +

 includes 2 bytes of null string, converted to LE below*/

 no EAs */

 always kept as le */

 14 byte parm len above enough for 2 byte null terminator */

 pad */ ;

 search probably was closed at end of search*/

 decode response */

 BB fixme add lock for file (srch_info) struct here */

/*  cifs_dbg(FYI, "fnxt2 entries in buf %d index_of_last %d\n",

 BB fixme add unlock here */

	/* BB On error, should we leave previous search buf (and count and

	/* Note: On -EAGAIN error only caller can retry on handle based calls

	/* no sense returning error if session restarted

 Since session is dead, search handle closed on server already */

 trailing null */

 level */  + 4  incl null */ ;

 BB find exact max data count below from sess structure BB */

 pad */ ;

 decode response */

 BB also check enough total bytes returned */

			/* If rc should we check for EOPNOSUPP and

 bad smb */

 BB Do we need a cast or hash here ? */

 TRANS2_GET_DFS_REFERRAL */

	/* server pointer checked in called function,

 trailing null */

 BB improve the check for buffer overruns BB */

 level */  + name_len 
 BB find exact max SMB PDU from sess structure BB */

 pad */ ;

 BB Also check if enough total bytes returned? */

 bad smb */

 parse returned result into more usable form */

 Query File System Info such as free space to old servers such as Win 9x */

 level 0x01 SMB_QUERY_FILE_SYSTEM_INFO */

 level */

 pad */ ;

 decode response */

 bad smb */

			/*

			 * much prefer larger but if server doesn't report

			 * a valid size than 4K is a reasonable minimum

 level 0x103 SMB_QUERY_FILE_SYSTEM_INFO */

 level */

 pad */ ;

 decode response */

 bad smb */

			/*

			 * much prefer larger but if server doesn't report

			 * a valid size than 4K is a reasonable minimum

 level 0x105  SMB_QUERY_FILE_SYSTEM_INFO */

 level */

 BB find exact max SMB PDU from sess structure BB */

 pad */ ;

 decode response */

 BB also check if enough bytes returned */

 bad smb */

 level 0x104 SMB_QUERY_FILE_SYSTEM_INFO */

 level */

 BB find exact max SMB PDU from sess structure BB */

 pad */ ;

 decode response */

 bad smb */

 level 0x200  SMB_QUERY_CIFS_UNIX_INFO */

 level */

 BB find exact max SMB PDU from sess structure BB */

 pad */ ;

 decode response */

 bad smb */

 level 0x200  SMB_SET_CIFS_UNIX_INFO */

 BB switch to small buf init to save memory */

 2 bytes zero followed by info level. */

 BB find exact max SMB PDU from sess structure BB */

 pad */ + params + 12;

 Params. */

 Data. */

 decode response */

 bad smb */

 level 0x201  SMB_QUERY_CIFS_POSIX_INFO */

 level */

 BB find exact max SMB PDU from sess structure BB */

 pad */ ;

 decode response */

 bad smb */

			/*

			 * much prefer larger but if server doesn't report

			 * a valid size than 4K is a reasonable minimum

/*

 * We can not use write of zero bytes trick to set file size due to need for

 * large file support. Also note that this SetPathInfo is preferred to

 * SetFileInfo based method in next routine which is only needed to work around

 * a sharing violation bugin Samba which this routine can run into.

 trailing null */

 Set File Size */  {

 pad */  + params + data_count;

 BB find exact max SMB PDU from sess structure BB */

 pad */  + params + count;

 SMB offsets are from the beginning of SMB which is 4 bytes in, after RFC1001 field */

 Set File Size */  {

	/* Note: On -EAGAIN error only caller can retry on handle based calls

/* Some legacy servers such as NT4 require that the file times be set on

   an open handle, rather than by pathname - this is awkward due to

   potential access conflicts on the open, but it is unavoidable for these

   old servers since the only other choice is to go from 100 nanosecond DCE

   time and resort to the original setpathinfo level which takes the ancient

 BB find max SMB PDU from sess */

 pad */  + params + count;

	/* Note: On -EAGAIN error only caller can retry on handle based calls

 SMB offsets are from the beginning of SMB which is 4 bytes in, after RFC1001 field */

 BB find max SMB PDU from sess */

 pad */  + params + count;

 trailing null */

 BB find max SMB PDU from sess structure BB */

 pad */  + params + count;

	/*

	 * Samba server ignores set of file size to zero due to bugs in some

	 * older clients, but we should be precise - we use SetFileSize to

	 * set file size and do not want to truncate file size to zero

	 * accidentally as happened on one Samba server beta by putting

	 * zero instead of -1 here

 better to leave device as zero when it is  */

 BB find max SMB PDU from sess */

 pad */  + params + count;

	/* Note: On -EAGAIN error only caller can retry on handle based calls

 trailing null */

 BB find max SMB PDU from sess structure BB */

 SMB offsets are from the beginning of SMB which is 4 bytes in, after RFC1001 field */

 pad */  + params + count;

/*

 * Do a path-based QUERY_ALL_EAS call and parse the result. This is a common

 * function used by listxattr and getxattr type calls. When ea_name is set,

 * it looks for that attribute name and stuffs that value into the EAData

 * buffer. When ea_name is NULL, it stuffs a list of attribute names into the

 * buffer. In both cases, the return value is either the length of the

 * resulting data or a negative error code. If EAData is a NULL pointer then

 * the data isn't copied to it, but the length is returned.

 BB assumes one setup word */

 trailing null */

 level */ + 4  includes NUL */;

 BB find exact max SMB PDU from sess structure BB */

 pad */ ;

 BB also check enough total bytes returned */

	/* BB we need to improve the validity checking

 bad smb */

 check that length of list is not more than bcc */

	/* check that each entry does not go beyond length

	/* check that each element of each entry does not

 validate_trans2_offsets() */

 BB check if start of smb + data_offset > &bcc+ bcc */

 didn't find the named attribute */

 make sure list_len doesn't go past end of SMB */

 account for ea list len */

 make sure we can read name_len and value_len */

 account for prefix user. and trailing null */

 null terminate name */

 skip copy - calc size only */

 stop before overrun buffer */

 didn't find the named attribute */

 trailing null */

	/* done calculating parms using name_len of file name,

	now use name_len to calculate length of ea name

 BB find max SMB PDU from sess */

 pad */  + params + count;

 we checked above that name len is less than 255 */

 EA names are always ASCII */

	/* caller ensures that ea_value_len is less than 64K but

	/*BB add length check to see if it would fit in

 if (ea_value_len > buffer_size - 512 (enough for header)) */

 SPDX-License-Identifier: GPL-2.0

/*

 * DFS referral cache routines

 *

 * Copyright (c) 2018-2019 Paulo Alcantara <palcantara@suse.de>

 2 minutes */

 RESP_GET_DFS_REFERRAL.ReferralHeaderFlags */

 DFS_REREFERRAL_V3.TimeToLive */

 DFS_REREFERRAL_V3.ServerType */

 DFS_REREFERRAL_V3.ReferralEntryFlags */

 RESP_GET_DFS_REFERRAL.PathConsumed */

 List of referral server sessions per dfs mount */

/*

 * Number of entries in the cache

x/IPC$")] = {0};

/**

 * dfs_cache_canonical_path - get a canonical DFS path

 *

 * @path: DFS path

 * @cp: codepage

 * @remap: mapping type

 *

 * Return canonical path if success, otherwise error.

/*

 * dfs cache /proc file

/**

 * dfs_cache_init - Initialize DFS referral cache.

 *

 * Return zero if initialized successfully, otherwise non-zero.

 Return target hint of a DFS cache entry */

 Return expire time out of a new entry's TTL */

 Allocate a new DFS target */

/*

 * Copy DFS referral information to a cache entry and conditionally update

 * target hint.

 Allocate a new cache entry */

 Add a new DFS cache entry */

 Check if two DFS paths are equal.  @s1 and @s2 are expected to be in @cache_cp's charset */

/*

 * Find a DFS cache entry in hash table and optionally check prefix path against normalized @path.

 *

 * Use whole path components in the match.  Must be called with htable_rw_lock held.

 *

 * Return ERR_PTR(-EEXIST) if the entry is not found.

	/*

	 * Handle paths that have more than two path components and are a complete prefix of the DFS

	 * referral request path (@path).

	 *

	 * See MS-DFSC 3.2.5.5 "Receiving a Root Referral Request or Link Referral Request".

 skip separators */

 backward until separator */

/**

 * dfs_cache_destroy - destroy DFS referral cache

 Update a cache entry with the new referral in @refs */

/*

 * Find, create or update a DFS cache entry.

 *

 * If the entry wasn't found, it will create a new one. Or if it was found but

 * expired, then it will update the entry accordingly.

 *

 * For interlinks, cifs_mount() and expand_dfs_referral() are supposed to

 * handle them properly.

	/*

	 * Either the entry was not found, or it is expired.

	 * Request a new DFS referral in order to create or update a cache entry.

/*

 * Set up a DFS referral from a given cache entry.

 *

 * Must be called with htable_rw_lock held.

 Return target list of a DFS cache entry */

/**

 * dfs_cache_find - find a DFS cache entry

 *

 * If it doesn't find the cache entry, then it will get a DFS referral

 * for @path and create a new entry.

 *

 * In case the cache entry exists but expired, it will get a DFS referral

 * for @path and then update the respective cache entry.

 *

 * These parameters are passed down to the get_dfs_refer() call if it

 * needs to be issued:

 * @xid: syscall xid

 * @ses: smb session to issue the request on

 * @cp: codepage

 * @remap: path character remapping type

 * @path: path to lookup in DFS referral cache.

 *

 * @ref: when non-NULL, store single DFS referral result in it.

 * @tgt_list: when non-NULL, store complete DFS target list in it.

 *

 * Return zero if the target was found, otherwise non-zero.

/**

 * dfs_cache_noreq_find - find a DFS cache entry without sending any requests to

 * the currently connected server.

 *

 * NOTE: This function will neither update a cache entry in case it was

 * expired, nor create a new cache entry if @path hasn't been found. It heavily

 * relies on an existing cache entry.

 *

 * @path: canonical DFS path to lookup in the DFS referral cache.

 * @ref: when non-NULL, store single DFS referral result in it.

 * @tgt_list: when non-NULL, store complete DFS target list in it.

 *

 * Return 0 if successful.

 * Return -ENOENT if the entry was not found.

 * Return non-zero for other errors.

/**

 * dfs_cache_update_tgthint - update target hint of a DFS cache entry

 *

 * If it doesn't find the cache entry, then it will get a DFS referral for @path

 * and create a new entry.

 *

 * In case the cache entry exists but expired, it will get a DFS referral

 * for @path and then update the respective cache entry.

 *

 * @xid: syscall id

 * @ses: smb session

 * @cp: codepage

 * @remap: type of character remapping for paths

 * @path: path to lookup in DFS referral cache

 * @it: DFS target iterator

 *

 * Return zero if the target hint was updated successfully, otherwise non-zero.

/**

 * dfs_cache_noreq_update_tgthint - update target hint of a DFS cache entry

 * without sending any requests to the currently connected server.

 *

 * NOTE: This function will neither update a cache entry in case it was

 * expired, nor create a new cache entry if @path hasn't been found. It heavily

 * relies on an existing cache entry.

 *

 * @path: canonical DFS path to lookup in DFS referral cache.

 * @it: target iterator which contains the target hint to update the cache

 * entry with.

 *

 * Return zero if the target hint was updated successfully, otherwise non-zero.

/**

 * dfs_cache_get_tgt_referral - returns a DFS referral (@ref) from a given

 * target iterator (@it).

 *

 * @path: canonical DFS path to lookup in DFS referral cache.

 * @it: DFS target iterator.

 * @ref: DFS referral pointer to set up the gathered information.

 *

 * Return zero if the DFS referral was set up correctly, otherwise non-zero.

/**

 * dfs_cache_add_refsrv_session - add SMB session of referral server

 *

 * @mount_id: mount group uuid to lookup.

 * @ses: reference counted SMB session of referral server.

/**

 * dfs_cache_put_refsrv_sessions - put all referral server sessions

 *

 * Put all SMB sessions from the given mount group id.

 *

 * @mount_id: mount group uuid to lookup.

/**

 * dfs_cache_get_tgt_share - parse a DFS target

 *

 * @path: DFS full path

 * @it: DFS target iterator.

 * @share: tree name.

 * @prefix: prefix path.

 *

 * Return zero if target was parsed correctly, otherwise non-zero.

 point to prefix in target node */

 extract target share */

 skip separator */

 point to prefix in DFS path */

 merge prefix paths from DFS path and target node */

	/*

	 * Resolve share's hostname and check if server address matches.  Otherwise just ignore it

	 * as we could not have upcall to resolve hostname or failed to convert ip address.

/*

 * Mark dfs tcon for reconnecting when the currently connected tcon does not match any of the new

 * target shares in @refs.

 Refresh dfs referral of tcon and mark it for reconnect if needed */

 Create or update a cache entry with the new referral */

/**

 * dfs_cache_remount_fs - remount a DFS share

 *

 * Reconfigure dfs mount by forcing a new DFS referral and if the currently cached targets do not

 * match any of the new targets, mark it for reconnect.

 *

 * @cifs_sb: cifs superblock.

 *

 * Return zero if remounted, otherwise non-zero.

	/*

	 * After reconnecting to a different server, unique ids won't match anymore, so we disable

	 * serverino. This prevents dentry revalidation to think the dentry are stale (ESTALE).

	/*

	 * Force the use of prefix path to support failover on DFS paths that resolve to targets

	 * that have different prefix paths.

/*

 * Refresh all active dfs mounts regardless of whether they are in cache or not.

 * (cache can be cleared)

	/*

	 * Refresh all cached entries.  Get all new referrals outside critical section to avoid

	 * starvation while performing SMB2 IOCTL on broken or slow connections.



	 * The cache entries may cover more paths than the active mounts

	 * (e.g. domain-based DFS referrals or multi tier DFS setups).

			/*

			 * We need to re-check it because other tasks might have it deleted or

			 * updated.

/*

 * Worker that will refresh DFS cache and active mounts based on lowest TTL value from a DFS

 * referral.

 Get refereces of mount groups */

 Fill in local array with an NULL-terminated list of all referral server sessions */

 Refresh all active mounts and cached entries */

 SPDX-License-Identifier: LGPL-2.1

/*

 *

 *   Copyright (C) International Business Machines  Corp., 2002,2008

 *   Author(s): Steve French (sfrench@us.ibm.com)

 *

/* The xid serves as a useful identifier for each incoming vfs request,

   in a similar way to the mid which is useful to track each sent smb,

   and CurrentXid can also provide a running counter (although it

   will eventually wrap past zero) of the total vfs operations handled

 keep high water mark for number of simultaneous ops in filesystem */

	/* if (GlobalTotalActiveXid == 0)

	/*

	 * SMB2 header is bigger than CIFS one - no problems to clean some

	 * more bytes for CIFS.

	/*

	 * We could use negotiated size instead of max_msgsize -

	 * but it may be more efficient to always alloc same size

	 * albeit slightly larger than necessary and maxbuffersize

	 * defaults to this and can not be bigger.

 clear the first few header bytes */

 for most paths, more is cleared in header_assemble */

 CONFIG_CIFS_STATS2 */

 cifs_dbg(FYI, "Null buffer passed to cifs_buf_release\n");*/

/* We could use negotiated size instead of max_msgsize -

   but it may be more efficient to always alloc same size

   albeit slightly larger than necessary and maxbuffersize

 No need to clear memory here, cleared in header assemble */

	memset(ret_buf, 0, sizeof(struct smb_hdr) + 27);*/

 CONFIG_CIFS_STATS2 */

/* NB: MID can not be set if treeCon not passed in, in that

 command */ ,

 length of fixed section (word count) in two byte units  */)

 bigger than MAX_CIFS_HDR_SIZE */

  RFC 1001 length field does not count */  +

 for bcc field itself */) ;

 case sensitive */

 Uid is not converted */

  endian conversion of flags is now done just before sending */

 does it have the right SMB "signature" ? */

 if it's a response then accept */

 only one valid case where server sends us request */

 calculated length */

 is this frame too small to even get to a BCC? */

 it's an error return */

 some error cases do not return wct and bcc */

 Need to work around a bug in two servers here */

 First, check if the part of bcc they sent was zero */

				/* some servers return only half of bcc

				 * on simple responses (wct, bcc both zero)

				 * in particular have seen this on

				 * ulogoffX and FindClose. This leaves

				 * one byte of bcc potentially unitialized

 zero rest of bcc */

 otherwise, there is enough to get to the BCC */

 check if bcc wrapped around for large read responses */

 check if lengths match mod 64K */

 bcc wrapped */

			/*

			 * Some servers (Windows XP in particular) send more

			 * data than the lengths in the SMB packet would

			 * indicate on certain calls (byte range locks and

			 * trans2 find first calls in particular). While the

			 * client can handle such a frame by ignoring the

			 * trailing data, we choose limit the amount of extra

			 * data to 512 bytes.

			/*   cifs_dump_mem("Rcvd notify Data: ",buf,

		/* no sense logging error on invalid handle on oplock

		   break - harmless race between close request and oplock

		   break response is expected from time to time writing out

 on valid oplock brk we get "request" */

 look up tcon based on tid & uid */

/*

 * We wait for oplock breaks to be processed before we attempt to perform

 * writes.

 Check to see if we have started servicing an oplock break */

/**

 * cifs_queue_oplock_break - queue the oplock break handler for cfile

 * @cfile: The file to break the oplock on

 *

 * This function is called from the demultiplex thread when it

 * receives an oplock break for @cfile.

 *

 * Assumes the tcon->open_file_lock is held.

 * Assumes cfile->file_info_lock is NOT held.

	/*

	 * Bump the handle refcount now while we hold the

	 * open_file_lock to enforce the validity of it for the oplock

	 * break handler. The matching put is done at the end of the

	 * handler.

/*

 * Critical section which runs after acquiring deferred_lock.

 * As there is no reference count on cifs_deferred_close, pdclose

 * should not be used outside deferred_lock.

/*

 * Critical section which runs after acquiring deferred_lock.

/*

 * Critical section which runs after acquiring deferred_lock.

/* parses DFS refferal V3 structure

 * caller is responsible for freeing target_nodes

 * returns:

 * - on success - 0

 * - on failure - errno

 get the upper boundary of the resp buffer */

 collect necessary data from referrals */

 copy DfsPath */

 copy link target UNC */

	/*

	 * Must use kzalloc to initialize ctx->bv to NULL and ctx->direct_io

	 * to false so that we know when we have to unreference pages within

	 * cifs_aio_ctx_release()

	/*

	 * ctx->bv is only set if setup_aio_ctx_iter() was call successfuly

	 * which means that iov_iter_get_pages() was a success and thus that

	 * we have taken reference on pages.

/**

 * cifs_alloc_hash - allocate hash and hash context together

 * @name: The name of the crypto hash algo

 * @shash: Where to put the pointer to the hash algo

 * @sdesc: Where to put the pointer to the hash descriptor

 *

 * The caller has to make sure @sdesc is initialized to either NULL or

 * a valid context. Both can be freed via cifs_free_hash().

/**

 * cifs_free_hash - free hash and hash context together

 * @shash: Where to find the pointer to the hash algo

 * @sdesc: Where to find the pointer to the hash descriptor

 *

 * Freeing a NULL hash or context is safe.

/**

 * rqst_page_get_length - obtain the length and offset for a page in smb_rqst

 * @rqst: The request descriptor

 * @page: The index of the page to query

 * @len: Where to store the length for this page:

 * @offset: Where to store the offset for this page

 skip initial slashes */

/**

 * copy_path_name - copy src path to dst, possibly truncating

 * @dst: The destination buffer

 * @src: The source name

 *

 * returns number of bytes written (including trailing nul)

	/*

	 * PATH_MAX includes nul, so if strlen(src) >= PATH_MAX it

	 * will truncate and strlen(dst) will be PATH_MAX-1

 we count the trailing nul */

	/*

	 * Grab an active reference in order to prevent automounts (DFS links)

	 * of expiring and then freeing up our cifs superblock pointer while

	 * we're doing failover.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *

 *   Copyright (c) International Business Machines  Corp., 2000,2009

 *   Modified by Steve French (sfrench@us.ibm.com)

 Convert character using the SFU - "Services for Unix" remapping range */

	/*

	 * BB: Cannot handle remapping UNI_SLASH until all the calls to

	 *     build_path_from_dentry are modified, as they use slash as

	 *     separator.

 Convert character using the SFM - "Services for Mac" remapping range */

/*

 * cifs_mapchar - convert a host-endian char to proper char in codepage

 * @target - where converted character should be copied

 * @src_char - 2 byte host-endian source character

 * @cp - codepage to which character should be converted

 * @map_type - How should the 7 NTFS/SMB reserved characters be mapped to UCS2?

 *

 * This function handles the conversion of a single character. It is the

 * responsibility of the caller to ensure that the target buffer is large

 * enough to hold the result of the conversion (at least NLS_MAX_CHARSET_SIZE).

 if character not one of seven in special remap set */

 convert SURROGATE_PAIR and IVS */

/*

 * cifs_from_utf16 - convert utf16le string to local charset

 * @to - destination buffer

 * @from - source buffer

 * @tolen - destination buffer size (in bytes)

 * @fromlen - source buffer size (in bytes)

 * @codepage - codepage to which characters should be converted

 * @mapchar - should characters be remapped according to the mapchars option?

 *

 * Convert a little-endian utf16le string (as sent by the server) to a string

 * in the provided codepage. The tolen and fromlen parameters are to ensure

 * that the code doesn't walk off of the end of the buffer (which is always

 * a danger if the alignment of the source buffer is off). The destination

 * string is always properly null terminated and fits in the destination

 * buffer. Returns the length of the destination string in bytes (including

 * null terminator).

 *

 * Note that some windows versions actually send multiword UTF-16 characters

 * instead of straight UTF16-2. The linux nls routines however aren't able to

 * deal with those characters properly. In the event that we get some of

 * those characters, they won't be translated properly.

 ftmp[3] = 3array x 2bytes = 6bytes UTF-16 */

	/*

	 * because the chars can be of varying widths, we need to take care

	 * not to overflow the destination buffer when we get close to the

	 * end of it. Until we get to this offset, we don't need to check

	 * for overflow however.

		/*

		 * check to see if converting this character might make the

		 * conversion bleed into the null terminator

 put converted char into 'to' buffer */

		/* charlen (=bytes of UTF-8 for 1 character)

		 * 4bytes UTF-8(surrogate pair) is charlen=4

		 *   (4bytes UTF-16 code)

		 * 7-8bytes UTF-8(IVS) is charlen=3+4 or 4+4

 5-6bytes UTF-8 */

 properly null-terminate string */

/*

 * NAME:	cifs_strtoUTF16()

 *

 * FUNCTION:	Convert character string to unicode string

 *

 needed to quiet sparse */

 special case for utf8 to handle no plane0 chars */

		/*

		 * convert utf8 -> utf16, we assume we have enough space

		 * as caller should have assumed conversion does not overflow

		 * in destination len is length in wchar_t units (16bits)

 if success terminate and exit */

		/*

		 * if fails fall back to UCS encoding as this

		 * function should not return negative values

		 * currently can fail only if source contains

		 * invalid encoded characters

 A question mark */

/*

 * cifs_utf16_bytes - how long will a string be after conversion?

 * @utf16 - pointer to input string

 * @maxbytes - don't go past this many bytes of input string

 * @codepage - destination codepage

 *

 * Walk a utf16le string and return the number of bytes that the string will

 * be after being converted to the given charset, not including any null

 * termination required. Don't walk past maxbytes in the source buffer.

/*

 * cifs_strndup_from_utf16 - copy a string from wire format to the local

 * codepage

 * @src - source string

 * @maxlen - don't walk past this many bytes in the source string

 * @is_unicode - is this a unicode string?

 * @codepage - destination codepage

 *

 * Take a string given by the server, convert it to the local codepage and

 * put it in a new buffer. Returns a pointer to the new string or NULL on

 * error.

/*

 * Convert 16 bit Unicode pathname to wire format from string in current code

 * page. Conversion may involve remapping up the six characters that are

 * only legal in POSIX-like OS (if they are present in the string). Path

 * names are little endian 16 bit Unicode on the wire

 UTF-16 */

 check if end of string */

 see if we must remap this char */

			/**

			 * Remap spaces and periods found at the end of every

			 * component of the path. The special cases of '.' and

			 * '..' do not need to be dealt with explicitly because

			 * they are addressed in namei.c:link_path_walk().

		/*

		 * FIXME: We can not handle remapping backslash (UNI_SLASH)

		 * until all the calls to build_path_from_dentry are modified,

		 * as they use backslash as separator.

			/*

			 * if no match, use question mark, which at least in

			 * some cases serves as wild card

 convert SURROGATE_PAIR */

 1-3bytes UTF-8 to 2bytes UTF-16 */

				/* 4bytes UTF-8(surrogate pair) to 4bytes UTF-16

				 * 7-8bytes UTF-8(IVS) divided to 2 UTF-16

 5-6bytes UTF-8 to 6bytes UTF-16 */

		/*

		 * character may take more than one byte in the source string,

		 * but will take exactly two bytes in the target string

 Null terminate target unicode string */

/*

 * cifs_local_to_utf16_bytes - how long will a string be after conversion?

 * @from - pointer to input string

 * @maxbytes - don't go past this many bytes of input string

 * @codepage - source codepage

 *

 * Walk a string and return the number of bytes that the string will

 * be after being converted to the given charset, not including any null

 * termination required. Don't walk past maxbytes in the source buffer.

 Failed conversion defaults to a question mark */

 UTF16 characters are two bytes */

/*

 * cifs_strndup_to_utf16 - copy a string to wire format from the local codepage

 * @src - source string

 * @maxlen - don't walk past this many bytes in the source string

 * @utf16_len - the length of the allocated string in bytes (including null)

 * @cp - source codepage

 * @remap - map special chars

 *

 * Take a string convert it from the local codepage to UTF16 and

 * put it in a new buffer. Returns a pointer to the new string or NULL on

 * error.

 NULL */

 SPDX-License-Identifier: LGPL-2.1

/*

 *   CIFS filesystem cache interface

 *

 *   Copyright (c) 2010 Novell, Inc.

 *   Author(s): Suresh Jayaraman <sjayaraman@suse.de>

 *

/*

 * Key layout of CIFS server cache index object

 address family */

 IP port */

/*

 * Get a cookie for a server object keyed by {IPaddress,port,family} tuple

	/*

	 * Should not be a problem as sin_family/sin6_family overlays

	 * sa_family field

	/*

	 * Check if cookie was already initialized so don't reinitialize it.

	 * In the future, as we integrate with newer fscache features,

	 * we may want to instead add a check if cookie has changed

 fscache_relinquish_cookie does not seem to update auxdata */

 retire the current fscache cache and get a new one */

/*

 * Retrieve a page from FS-Cache

 page found in fscache, read submitted */

 page won't be cached */

 page not in cache */

/*

 * Retrieve a set of pages from FS-Cache

 read submitted to the cache for all pages */

 some pages are not cached and can't be */

 some pages are not cached */

 SPDX-License-Identifier: LGPL-2.1

/*

 *

 *   Copyright (c) 2007 Igor Mammedov

 *   Author(s): Igor Mammedov (niallain@gmail.com)

 *              Steve French (sfrench@us.ibm.com)

 *              Wang Lei (wang840925@gmail.com)

 *		David Howells (dhowells@redhat.com)

 *

 *   Contains the CIFS DFS upcall routines used for hostname to

 *   IP address translation.

 *

/**

 * dns_resolve_server_name_to_ip - Resolve UNC server name to ip address.

 * @unc: UNC path specifying the server (with '/' as delimiter)

 * @ip_addr: Where to return the IP address.

 * @expiry: Where to return the expiry time for the dns record.

 *

 * The IP address will be returned in string form, and the caller is

 * responsible for freeing it.

 *

 * Returns length of result on success, -ve on error.

 Discount leading slashes for cifs */

 Search for server name delimiter */

 Try to interpret hostname as an IPv4 or IPv6 address */

 Perform the upcall */

 SPDX-License-Identifier: LGPL-2.1

/*

 *

 *   vfs operations that deal with files

 *

 *   Copyright (C) International Business Machines  Corp., 2002,2010

 *   Author(s): Steve French (sfrench@us.ibm.com)

 *              Jeremy Allison (jra@samba.org)

 *

		/* GENERIC_ALL is too much permission to request

 return GENERIC_ALL; */

 be safe and imply O_SYNC for O_DSYNC */

 open ok, caller does qpathinfo */

 caller does not need info */

 get new inode and set it up */

/*********************************************************************

 *  open flag mapping table:

 *

 *	POSIX Flag            CIFS Disposition

 *	----------            ----------------

 *	O_CREAT               FILE_OPEN_IF

 *	O_CREAT | O_EXCL      FILE_CREATE

 *	O_CREAT | O_TRUNC     FILE_OVERWRITE_IF

 *	O_TRUNC               FILE_OVERWRITE

 *	none of the above     FILE_OPEN

 *

 *	Note that there is not a direct match between disposition

 *	FILE_SUPERSEDE (ie create whether or not file exists although

 *	O_CREAT | O_TRUNC is similar but truncates the existing

 *	file rather than creating a new file as FILE_SUPERSEDE does

 *	(which uses the attributes / metadata passed in on open call)

 *?

 *?  O_SYNC is a reasonable match to CIFS writethrough flag

 *?  and the read write flags match reasonably.  O_LARGEFILE

 *?  is irrelevant because largefile support is always used

 *?  by this client. Flags O_APPEND, O_DIRECT, O_DIRECTORY,

 *	 O_FASYNC, O_NOFOLLOW, O_NONBLOCK need further investigation

 BB pass O_SYNC flag through on file attributes .. BB */

 O_SYNC also has bit for O_DSYNC so following check picks up either */

 TODO: Add support for calling posix query info but with passing in fid */

	/*

	 * If the server returned a read oplock and we have mandatory brlocks,

	 * set oplock level to None.

 if readable file instance put first in list*/

	/*

	 * Delete any outstanding lock records. We'll lose them when the file

	 * is closed anyway.

/**

 * cifsFileInfo_put - release a reference of file priv data

 *

 * Always potentially wait for oplock handler. See _cifsFileInfo_put().

 *

 * @cifs_file:	cifs/smb3 specific info (eg refcounts) for an open file

/**

 * _cifsFileInfo_put - release a reference of file priv data

 *

 * This may involve closing the filehandle @cifs_file out on the

 * server. Must be called without holding tcon->open_file_lock,

 * cinode->open_file_lock and cifs_file->file_info_lock.

 *

 * If @wait_for_oplock_handler is true and we are releasing the last

 * reference, wait for any running oplock break handler of the file

 * and cancel any pending one.

 *

 * @cifs_file:	cifs/smb3 specific info (eg refcounts) for an open file

 * @wait_oplock_handler: must be false if called from oplock_break_handler

 * @offload:	not offloaded on close and oplock breaks

 *

 store open in pending opens to make sure we don't miss lease break */

 remove it from the lists */

		/*

		 * In strict cache mode we need invalidate mapping on the last

		 * close  because it may cause a error when we open this file

		 * again and get at least level II oplock.

 Get the cached handle as SMB2 close is deferred */

 can not refresh inode info since size could be stale */

 ignored */,

 path not found or net err */

		/*

		 * Else fallthrough to retry open the old way on network i/o

		 * or DFS errors.

		/*

		 * Time to set mode which we can not set earlier due to

		 * problems creating new read-only files.

 no change */

 no change */

/*

 * Try to reacquire byte range locks that were released when session

 * to server was lost.

 can cache locks - no need to relock */

	/*

	 * Can not grab rename sem here because various ops, including those

	 * that already have the rename sem can end up causing writepage to get

	 * called and if the server was down that means we end up here, and we

	 * can never tell if the caller already has the rename_sem.

		/*

		 * O_CREAT, O_EXCL and O_TRUNC already had their effect on the

		 * original open. Must mask them off for a reopen.

 ignored */,

		/*

		 * fallthrough to retry open the old way on errors, especially

		 * in the reconnect path it is important to retry hard

 O_SYNC also has bit for O_DSYNC so following check picks up either */

	/*

	 * Can not refresh inode by passing in file_info buf to be returned by

	 * ops->open and then calling get_inode_info with returned buf since

	 * file might have write behind data that needs to be flushed and server

	 * version of file size can be stale. If we knew for sure that inode was

	 * not dirty locally we could do this.

 durable handle timeout is expired - open the file again */

 indicate that we need to relock the file */

	/*

	 * Else we are writing out data to server already and could deadlock if

	 * we tried to flush data, and since we do not know if we have data that

	 * would invalidate the current end of file on the server we can not go

	 * to the server to get the new inode info.

	/*

	 * If the server returned a read oplock and we have mandatory brlocks,

	 * set oplock level to None.

				/*

				 * If there is no pending work, mod_delayed_work queues new work.

				 * So, Increase the ref count to avoid use-after-free.

 Deferred close for files */

 return code from the ->release op is always ignored */

 list all files open on tree connection, reopen resilient handles  */

 do not flush */))

 not much we can do if it fails anyway, ignore rc */

 BB can we lock the filestruct while this is going on? */

 @rw_check : 0 - no op, 1 - read, 2 - write */

 shared lock prevents write op through the same fid */

/*

 * Check if there is another lock that prevents us to set the lock (mandatory

 * style). If such a lock exists, update the flock structure with its

 * properties. Otherwise, set the flock type to F_UNLCK if we can cache brlocks

 * or leave it the same if we can't. Returns 0 if we don't need to request to

 * the server or 1 otherwise.

/*

 * Set the byte-range lock (mandatory style). Returns:

 * 1) 0, if we set the lock and don't need to request to the server;

 * 2) 1, if no locks prevent us but we need to request to the server;

 * 3) -EACCES, if there is a lock that prevents us and wait is false.

/*

 * Check if there is another lock that prevents us to set the lock (posix

 * style). If such a lock exists, update the flock structure with its

 * properties. Otherwise, set the flock type to F_UNLCK if we can cache brlocks

 * or leave it the same if we can't. Returns 0 if we don't need to request to

 * the server or 1 otherwise.

/*

 * Set the byte-range lock (posix style). Returns:

 * 1) <0, if the error occurs while setting the lock;

 * 2) 0, if we set the lock and don't need to request to the server;

 * 3) FILE_LOCK_DEFERRED, if we will wait for some other file_lock;

 * 4) FILE_LOCK_DEFERRED + 1, if we need to request to the server.

	/*

	 * Accessing maxBuf is racy with cifs_reconnect - need to store value

	 * and check it before using.

	/*

	 * Allocating count locks is enough because no FL_POSIX locks can be

	 * added to the list while we are holding cinode->lock_sem that

	 * protects locking operations of this inode.

			/*

			 * The list ended. We don't have enough allocated

			 * structures - something is really wrong.

 we are going to update can_cache_brlcks here - need a write access */

 Check if unlock includes more than one lock range */

 BB we could chain these into one lock request BB */

	/*

	 * Accessing maxBuf is racy with cifs_reconnect - need to store value

	 * and check it before using.

				/*

				 * We can cache brlock requests - simply remove

				 * a lock from the file's list.

			/*

			 * We need to save a lock here to let us add it again to

			 * the file's list if the unlock range request fails on

			 * the server.

					/*

					 * We failed on the unlock range

					 * request - add all locks from the tmp

					 * list to the head of the file's list.

					/*

					 * The unlock range request succeed -

					 * free the tmp list.

		/*

		 * Windows 7 server can delay breaking lease from read to None

		 * if we set a byte-range lock on a file - break it explicitly

		 * before sending the lock to the server to be sure the next

		 * read won't conflict with non-overlapted locks due to

		 * pagereading.

		/*

		 * If this is a request to remove all locks because we

		 * are closing the file, it doesn't matter if the

		 * unlocking failed as both cifs.ko and the SMB server

		 * remove the lock on file close

		/*

		 * if no lock or unlock then nothing to do since we do not

		 * know what it is

	/*

	 * BB add code here to normalize offset and length to account for

	 * negative length which we can not accept over the wire.

		/*

		 * if no lock or unlock then nothing to do since we do not

		 * know what it is

/*

 * update the file size (if needed) after a write. Should be called with

 * the inode->i_lock held

				/* we could deadlock if we called

				   filemap_fdatawait from here so tell

				   reopen_file not to flush data to

 iov[0] is reserved for smb header */

 only filter by fsuid on multiuser mounts */

	/* we could simply get the first_list_entry since write-only entries

	   are always at the end of the list but since the first entry might

 found a good file */

 lock it so it will not be closed on us */

			} /* else might as well continue, and look for

			     another, or simply have the caller reopen it

 write only file */

 write only files are last so must be done */

 Return -EBADF if no handle is found and general rc otherwise */

	/*

	 * Having a null inode here (because mapping->host was set to zero by

	 * the VFS or MM) should not happen but we had reports of on oops (due

	 * to it being zero) during stress testcases so we need to check for it

 only filter by fsuid on multiuser mounts */

 found a good writable file */

 couldn't find useable FH with same pid, try any available */

 racing with truncate? */

 don't care */

 check to make sure that we are not extending the file */

 Does mm or vfs already set times? */

		/*

		 * At this point we hold neither the i_pages lock nor the

		 * page lock: the page may be truncated or invalidated

		 * (changing page->mapping to NULL), or even swizzled

		 * back from swapper_space to tmpfs file mapping

 Not next consecutive page */

		/*

		 * This actually clears the dirty bit in the radix tree.

		 * See cifs_writepage() for more commentary.

 reset index to refind any pages skipped */

 put any pages we aren't going to use */

	/*

	 * If wsize is smaller than the page cache size, default to writing

	 * one page at a time via cifs_writepage

 Start from prev offset */

 in case of an error store it to return later */

 nothing to write? */

 send failure -- clean up the mess */

 Return immediately if we received a signal during writing */

		/*

		 * We hit the last page and there is more work to be done: wrap

		 * back to the start of the file

 Indication to update ctime and mtime as close is deferred */

 BB add check for wbc flags */

	/*

	 * Set the "writeback" flag, and clear "dirty" in the radix tree.

	 *

	 * A writepage() implementation always needs to do either this,

	 * or re-dirty the page with "redirty_page_for_writepage()" in

	 * the case of a failure.

	 *

	 * Just unlocking the page will cause the radix tree tag-bits

	 * to fail to update with the state of the page correctly.

		/* this is probably better than directly calling

		   partialpage_write since in this function the file handle is

		/* BB check if anything else missing out of ppw

 if (rc < 0) should we set writebehind rc? */

 Indication to update ctime and mtime as close is deferred */

 don't care about it in fsync */

/*

 * As file closes, flush all cached write data for this inode checking

 * for write behind errors.

			/*

			 * save number of pages we have already allocated and

			 * return with ENOMEM error

 the below call can possibly free the last ref to aio ctx */

		/*

		 * If we didn't copy as much as we expected, then that

		 * may mean we trod into an unmapped area. Stop copying

		 * at that point. On the next pass through the big

		 * loop, we'll likely end up getting a zero-length

		 * write and bailing out of it.

	/*

	 * If we have no data to send, then that probably means that

	 * the copy above failed altogether. That's most likely because

	 * the address in the iovec was bogus. Return -EFAULT and let

	 * the caller free anything we allocated and bail out.

	/*

	 * i + 1 now represents the number of pages we actually used in

	 * the copy phase above.

		/*

		 * Wait for credits to resend this wdata.

		 * Note: we are attempting to resend the whole wdata not in

		 * segments

 If the write was successfully sent, we are done */

 Roll back credits and retry if needed */

			/*

			 * Bring nr_pages down to the number of pages we

			 * actually used, and free any pages that we didn't use.

	/*

	 * Wait for and collect replies for any successful sends in order of

	 * increasing offset. Once an error is hit, then return without waiting

	 * for any more replies.

 resend call if it's a retryable error */

	/*

	 * iov_iter_get_pages_alloc doesn't work with ITER_KVEC.

	 * In this case, fall back to non-direct write function.

	 * this could be improved by getting pages directly in ITER_KVEC

 grab a lock here due to read response handlers can access ctx */

	/*

	 * If at least one write was successfully sent, then discard any rc

	 * value from the later writes. If the other write succeeds, then

	 * we'll end up returning whatever was written. If it fails, then

	 * we'll get a new rc value from that.

	/*

	 * We need to hold the sem to be sure nobody modifies lock list

	 * with a brlock that prevents writing.

	/*

	 * For non-oplocked files in strict cache mode we need to write the data

	 * to the server exactly from the pos to pos+len-1 rather than flush all

	 * affected pages because it may cause a error with mandatory locks on

	 * these pages but not on the region from pos to ppos+len-1.

		/*

		 * We have read level caching and we have just sent a write

		 * request to the server thus making data in the cache stale.

		 * Zap the cache and set oplock/lease level to NONE to avoid

		 * reading stale data from the cache. All subsequent read

		 * operations will read new data from the server.

/**

 * cifs_readdata_to_iov - copy data from pages in response to an iovec

 * @rdata:	the readdata response with list of pages holding data

 * @iter:	destination for our data

 *

 * This function copies data from a list of pages in a readdata response into

 * an array of iovecs. It will first calculate where the data should go

 * based on the info in the readdata and then copy the data into that spot.

 the below call can possibly free the last ref to aio ctx */

 no need to hold page hostage */

 enough data to fill the page */

 XXX: should we pick a new channel here? */

		/*

		 * Wait for credits to resend this rdata.

		 * Note: we are attempting to resend the whole rdata not in

		 * segments

 If the read was successfully sent, we are done */

 Add to aio pending list */

 Roll back credits and retry if needed */

 allocate a readdata struct */

 the loop below should proceed in the order of increasing offsets */

 resend call if it's a retryable error */

				/*

				 * Got a part of data and then reconnect has

				 * happened -- fill the buffer and continue

				 * reading.

					/*

					 * Re-use rdata as this is a

					 * direct I/O

 if there was a short read -- discard anything left */

 mask nodata case */

	/*

	 * iov_iter_get_pages_alloc() doesn't work with ITER_KVEC,

	 * fall back to data copy read path

	 * this could be improved by getting pages directly in ITER_KVEC

 grab a lock here due to read response handlers can access ctx */

 if at least one read request send succeeded, then reset rc */

	/*

	 * In strict cache mode we need to read from the server all the time

	 * if we don't have level II oplock because the server can delay mtime

	 * change - so we can't make a decision about inode invalidating.

	 * And we can also fail with pagereading if there are mandatory locks

	 * on pages affected by this read but not on the region from pos to

	 * pos+len-1.

	/*

	 * We need to hold the sem to be sure nobody modifies lock list

	 * with a brlock that prevents reading.

 FIXME: set up handlers for larger reads and/or convert to async */

			/*

			 * For windows me and 9x we do not want to request more

			 * than it negotiated since it will refuse the read

			 * then.

/*

 * If the page is mmap'ed into a process' page tables, then we need to make

 * sure that it doesn't change while being written back.

 determine the eof that the server (probably) has */

 enough for partial page, fill and zero the rest */

			/*

			 * The VFS will not try to do readahead past the

			 * i_size, but it's possible that we have outstanding

			 * writes with gaps in the middle and the i_size hasn't

			 * caught up yet. Populate those with zeroed out pages

			 * to prevent the VFS from repeatedly attempting to

			 * fill them until the writes are flushed.

 no need to hold page hostage */

	/*

	 * Lock the page and put it in the cache. Since no one else

	 * should have access to this page, we're safe to simply set

	 * PG_locked without checking it first.

 give up if we can't stick it in the cache */

 move first page to the tmplist */

 now try and add more pages onto the request */

 discontinuity ? */

 would this page push the read over the rsize? */

	/*

	 * Reads as many pages as possible from fscache. Returns -ENOBUFS

	 * immediately if the cookie is negative

	 *

	 * After this point, every page in the list might have PG_fscache set,

	 * so we will need to clean that up off of every page we don't use.

	/*

	 * Start with the page at end of list and move it to private

	 * list. Do the same with any following pages until we hit

	 * the rsize limit, hit an index discontinuity, or run out of

	 * pages. Issue the async read and then start the loop again

	 * until the list is empty.

	 *

	 * Note that list order is important. The page_list is in

	 * the order of declining indexes. When we put the pages in

	 * the rdata->pages, then we want them in increasing order.

		/*

		 * Give up immediately if rsize is too small to read an entire

		 * page. The VFS will fall back to readpage. We should never

		 * reach this point however since we set ra_pages to 0 when the

		 * rsize is smaller than a cache page.

 best to give up if we're out of mem */

 Fallback to the readpage in error/reconnect cases */

	/* Any pages that have been shown to fscache but didn't get added to

	 * the pagecache must be uncached before they get returned to the

	 * allocator.

/*

 * cifs_readpage_worker must be called with the page pinned

 Is the page cached? */

 for reads over a certain size could initiate async read ahead */

 we do not want atime to be less than mtime, it broke some apps */

 send this page to the cache */

/* We do not want to update the file size from server for inodes

   open for write - to avoid races with writepage extending

   the file - in the future we could consider allowing

   refreshing the inode only on increases in the file size

   but this is tricky to do without racing with writebehind

 This inode is open for write at least once */

			/* since no page cache to corrupt on directio

	/*

	 * If we write a full page it will be up to date, no need to read from

	 * the server. If the write is short, we'll end up doing a sync write

	 * instead.

	/*

	 * optimize away the read when we have an oplock, and we're not

	 * expecting to use any of the data we'd be reading in. That

	 * is, when the page lies beyond the EOF, or straddles the EOF

	 * and the write will cover all of the existing data.

			/*

			 * PageChecked means that the parts of the page

			 * to which we're not writing are considered up

			 * to date. Once the data is copied to the

			 * page, it can be set uptodate.

		/*

		 * might as well read a page, it is fast enough. If we get

		 * an error, we don't need to return it. cifs_write_end will

		 * do a sync write instead since PG_uptodate isn't set.

		/* we could try using another file handle if there is one -

		   but how would we lock it to prevent close of that handle

		   racing with this read? In any case

	/*

	 * When oplock break is received and there are no active

	 * file handles but cached, then schedule deferred close immediately.

	 * So, new open will not use cached handle.

	/*

	 * releasing stale oplock after recent reconnect of smb session using

	 * a now incorrect file handle is not a data integrity issue but do

	 * not bother sending an oplock release if session to server still is

	 * disconnected since oplock already released by the server

 do not wait for ourself */, false);

/*

 * The presence of cifs_direct_io() in the address space ops vector

 * allowes open() O_DIRECT flags which would have failed otherwise.

 *

 * In the non-cached mode (mount with cache=none), we shunt off direct read and write requests

 * so this method should never be called.

 *

 * Direct IO is not yet supported in the cached mode. 

        /*

         * FIXME

         * Eventually need to support direct IO for non forcedirectio mounts

	/*

	 * TODO: consider adding ACL (or documenting how) to prevent other

	 * users (on this or other systems) from reading it

 TODO: add sk_set_memalloc(inet) or similar */

	/*

	 * TODO: Since file already open, we can't open with DENY_ALL here

	 * but we could add call to grab a byte range lock to prevent others

	 * from reading or writing the file

 TODO: undo sk_set_memalloc(inet) will eventually be needed */

 do we need to unpin (or unlock) the file */

	/*

	 * TODO: investigate and if useful we could add an cifs_migratePage

	 * helper (under an CONFIG_MIGRATION) in the future, and also

	 * investigate and add an is_dirty_writeback helper if needed

/*

 * cifs_readpages requires the server to support a buffer large enough to

 * contain the header plus one complete page of data.  Otherwise, we need

 * to leave cifs_readpages out of the address space operations.

 SPDX-License-Identifier: GPL-2.0

/*

 *  SMB2 version specific operations

 *

 *  Copyright (c) 2012, Jeff Layton <jlayton@redhat.com>

 Change credits for different ops and return the total number of credits */

 eg found case where write overlapping reconnect messed up credits */

 Don't get near 64K credits, avoid srv bugs */

	/*

	 * Sometimes server returns 0 credits on oplock break ack - we need to

	 * rebalance credits in this case.

 change_conf hasn't been executed */

 change_conf rebalanced credits for different types */

 don't log while holding the lock */

 can deadlock with reopen */

 leave some credits for reopen and other ops */

 for SMB2 we need the current value */

 BB we probably don't need to retry with modern servers */

 start with specified wsize, or default */

 start with specified wsize, or default */

			/*

			 * Account for SMB2 data transfer packet header and

			 * possible encryption header

 start with specified rsize, or default */

 start with specified rsize, or default */

			/*

			 * Account for SMB2 data transfer packet header and

			 * possible encryption header

	/*

	 * Fist pass: count and sanity check

 Azure rounds the buffer size up 8, to a 16 byte boundary */

	/*

	 * Second pass: extract info to internal structure

		/*

		 * The kernel and wire socket structures have the same

		 * layout and use network byte order but make the

		 * conversion explicit in case either one changes.

 [MS-SMB2] 2.2.32.5.1.1 Clients MUST ignore these */

 [MS-SMB2] 2.2.32.5.1.2 Clients MUST ignore these */

 is_fsctl */,

 no data input */, 0 
 sort interfaces from fastest to slowest */

	/*

	 * We only check validity above to send SMB2_close,

	 * but we still need to invalidate these entries

	 * when this function is called

/*

 * Open the and cache a directory handle.

 * Only supported for the root handle.

 Null - since an open of top of share */

	/*

	 * We do not hold the lock for the open because in case

	 * SMB2_open needs to reconnect, it will end up calling

	 * cifs_mark_open_files_invalid() which takes the lock again

	 * thus causing a deadlock

 Open */

	/*

	 * Now we need to check again as the cached root might have

	 * been successfully re-opened from a concurrent process

 work was already done */

 stash fids for close() later */

		/*

		 * caller expects this func to set the fid in crfid to valid

		 * cached root, so increment the refcount.

 close extra handle outside of crit sec */

 Cached root is still invalid, continue normaly */

 CIFS_DEBUG2 */

 BB TBD check to see if oplock level check can be removed below */

		/*

		 * See commit 2f94a3125b87. Increment the refcount when we

		 * get a lease for root, release it if lease break occurs

 Null - open root of share */

 SMB3 specific */

 Null - open root of share */

 'user.' plus a terminating null */

 skip copy - calc size only */

 stop before overrun buffer */

 stop before overrun buffer */

 didn't find the named attribute */

		/*

		 * If ea_name is NULL (listxattr) and there are no EAs,

		 * return 0 as it's not an error. Otherwise, the specified

		 * ea_name was not found.

			/* If we are adding a attribute we should first check

			 * if there will be enough space available to store

			 * the new EA. If not we should not add it since we

			 * would not be able to even read the EAs back.

			/* Use a fudge factor of 256 bytes in case we collide

			 * with a different set_EAs command.

 Open */

 Set Info */

 Close */

 no need to bump num_remote_opens because handle immediately closed */

	/*

	 *  Can't display SMB2_NEGOTIATE, SESSION_SETUP, LOGOFF, CANCEL and ECHO

	 *  totals (requests sent) since those SMBs are per-session not per tcon

 CIFS_DEBUG2 */

 Creation time should not need to be updated on close */

	/*

	 * i_blocks is not related to (i_size / i_blksize),

	 * but instead 512 byte (2**9) size is required for

	 * calculating num blocks.

 End of file and Attributes should not have to be updated on close */

 is_fsctl */,

 no input */, CIFSMaxBufSize,

 Open */

 Query */

 Can eventually relax perm check since server enforces too */

 Can eventually relax perm check since server enforces too */

 unknown flags */

 Close */

 No need to bump num_remote_opens since handle immediately closed */

 Request a key from the server to identify the source of the copy */

 Note: request_res_key sets res_key null only if rc !=0 */

 For now array only one chunk long, will make more flexible later */

 Request server copy to target from src identified by key */

 is_fsctl */, (char *)pcchunk,

			/*

			 * Check if server claimed to write more than we asked

			/*

			 * Check if this is the first request using these sizes,

			 * (ie check if copy succeed once with original sizes

			 * and check if the server gave us different sizes after

			 * we already updated max sizes on previous request).

			 * if not then why is the server returning an error now

 Check that server is not asking us to grow size */

 server gave us bogus size */

 No need to change MaxChunks since already set to 1 */

 Set or clear the SPARSE_FILE attribute based on value passed in setsparse */

 if file already sparse don't bother setting sparse again */

 already sparse */

 already not sparse */

	/*

	 * Can't check for sparse support on share the usual way via the

	 * FS attribute info (FILE_SUPPORTS_SPARSE_FILES) on the share

	 * since Samba server doesn't set the flag on the share, yet

	 * supports the set sparse FSCTL and returns sparse correctly

	 * in the file attributes. If we fail setting sparse though we

	 * mark that server does not support sparse files for this share

	 * to avoid repeatedly sending the unsupported fsctl to server

	 * if the file is repeatedly extended.

 is_fctl */,

	/*

	 * If extending file more than one page make sparse. Many Linux fs

	 * make files sparse by default when extending via ftruncate

 whether set sparse succeeds or not, extend the file */

 server fileays advertise duplicate extent support with this flag */

		/*

		 * Although also could set plausible allocation size (i_blocks)

		 * here in addition to setting the file size, in reflink

		 * it is likely that the target file is sparse. Its allocation

		 * size will be queried on next revalidate, but it is important

		 * to make sure that file's cached size is updated immediately

 is_fsctl */,

 is_fsctl */,

 GMT Token is @GMT-YYYY.MM.DD-HH.MM.SS Unicode which is 48 bytes + null */

 See MS-SMB2 section 3.3.5.15.1 */

/*

 * Input buffer contains (empty) struct smb_snapshot array with size filled in

 * For output see struct SRV_SNAPSHOT_ARRAY in MS-SMB2 section 2.2.32.2

	/*

	 * On the first query to enumerate the list of snapshots available

	 * for this volume the buffer begins with 0 (number of snapshots

	 * which can be returned is zero since at that point we do not know

	 * how big the buffer needs to be). On the second query,

	 * it (ret_data_len) is set to number of snapshots so we can

	 * know to set the maximum response size larger (see below).

	/*

	 * Note that for snapshot queries that servers like Azure expect that

	 * the first query be minimal size (and just used to get the number/size

	 * of previous versions) so response size must be specified as EXACTLY

	 * sizeof(struct snapshot_array) which is 16 when rounded up to multiple

	 * of eight bytes.

 is_fsctl */,

 no input data */, max_response_size,

 Fixup buffer */

		/*

		 * Check for min size, ie not large enough to fit even one GMT

		 * token (snapshot).  On the first ioctl some users may pass in

		 * smaller size (or zero) to simply get the size of the array

		 * so the user space caller can allocate sufficient memory

		 * and retry the ioctl again with larger array size sufficient

		 * to hold all of the snapshot GMT tokens on the second try.

		/*

		 * We return struct SRV_SNAPSHOT_ARRAY, followed by

		 * the snapshot array (of 50 byte GMT tokens) each

		 * representing an available previous version of the data

 Open */

 Query directory */

 If the open failed there is nothing to do */

 Anything else than ENODATA means a genuine error */

/*

 * If we negotiate SMB2 protocol and get STATUS_PENDING - update

 * the number of credits and return true. Otherwise - return false.

 SMB headers in a compound are 8 byte aligned. */

 No padding needed */

		/*

		 * If we do not have encryption then we can just add an extra

		 * iov for the padding.

		/*

		 * We can not add a small padding iov for the encryption case

		 * because the encryption framework can not handle the padding

		 * iovs.

		 * We have to flatten this into a single buffer and add

		 * the padding to it.

/*

 * Passes the query info response back to the caller on success.

 * Caller need to free this with free_rsp_buf().

 Null - open root of share */

 Null - open root of share */

	/*

	 * Try to use the IPC tcon, otherwise just use any

 Highest DFS referral version understood */

 Path to resolve in an UTF-16 null-terminated string */

 is_fsctl */,

 is_unicode */);

 ipc tcons are not refcounted */

 tc_count can never go negative */

 See MS-FSCC 2.1.2.6 for the 'NFS' style reparse tags */

 We handle Symbolic Link reparse tag here. See: MS-FSCC 2.1.2.4 */

 See MS-FSCC 2.1.2 */

 Open */

 IOCTL */

 is_fctl */, NULL, 0,

 Close */

	/*

	 * Open was successful and we got an ioctl response.

 See MS-FSCC 2.3.23 */

 open must fail on symlink - reset rc */

	/*

	 * setup smb2open - TODO add optimization to call cifs_get_readable_path

	 * to see if there is a handle already open that we can use

 IOCTL */

 is_fctl */, NULL, 0,

 Close */

	/*

	 * Open was successful and we got an ioctl response.

 See MS-FSCC 2.3.23 */

	/*

	 * When querying an ACL, even if the file is a symlink we want to open

	 * the source not the target, and so the protocol requires that the

	 * client specify this flag when opening a reparse point

 Retrieve an ACL from the server */

	/*

	 * We zero the range through ioctl, so we need remove the page caches

	 * first, otherwise the data may be inconsistent with the server.

 if file not oplocked can't be sure whether asking to extend size */

	/*

	 * do we also need to change the size of the file?

 Need to make file sparse, if not already, before freeing range. */

 Consider adding equivalent for compressed since it could also work */

	/*

	 * We implement the punch hole through ioctl, so we need remove the page

	 * caches first, otherwise the data may be inconsistent with the server.

 is_fctl */, (char *)&fsctl_buf,

 iov[0] is reserved for smb header */

		/*

		 * The rest of the region is unmapped so write it all.

			/*

			 * We are at a hole. Write until the end of the region

			 * or until the next allocated data,

			 * whichever comes next.

		/*

		 * We are at a section of allocated data, just skip forward

		 * until the end of the data or the end of the region

		 * we are supposed to fallocate, whichever comes first.

 if file not oplocked can't be sure whether asking to extend size */

	/*

	 * Extending the file

	/*

	 * Files are non-sparse by default so falloc may be a no-op

	 * Must check if file sparse. If not sparse, and since we are not

	 * extending then no need to do anything since file already allocated

		/*

		 * We can not preallocate pages beyond the end of the file

		 * in SMB2

		/*

		 * For fallocates that are partially beyond the end of file,

		 * clamp len so we only fallocate up to the end of file.

		/*

		 * At this point, we are trying to fallocate an internal

		 * regions of a sparse file. Since smb2 does not have a

		 * fallocate command we have two otions on how to emulate this.

		 * We can either turn the entire file to become non-sparse

		 * which we only do if the fallocate is for virtually

		 * the whole file,  or we can overwrite the region with zeroes

		 * using SMB2_write, which could be prohibitevly expensive

		 * if len is large.

		/*

		 * We are only trying to fallocate a small region so

		 * just write it with zero.

		/*

		 * Check if falloc starts within first few pages of file

		 * and ends within a few pages of the end of file to

		 * ensure that most of file is being forced to be

		 * fallocated now. If so then setting whole file sparse

		 * ie potentially making a few extra pages at the beginning

		 * or end of the file non-sparse via set_sparse is harmless.

	/*

	 * We need to be sure that all dirty pages are written as they

	 * might fill holes on the server.

	 * Note that we also MUST flush any written pages since at least

	 * some servers (Windows2016) will not reflect recent writes in

	 * QUERY_ALLOCATED_RANGES until SMB2_flush is called.

 KEEP_SIZE already checked for by do_fallocate */

 Check if the server granted an oplock rather than a lease */

 SMB2_CREATE_REQUEST_LEASE is "RqLs" */

 SMB2_CREATE_REQUEST_LEASE is "RqLs" */

 not used */

/* We can not use the normal sg_set_buf() as we will sometimes pass a

 * stack object as buf.

	/*

	 * VMAP_STACK (at least) puts stack into the vmalloc address space

/* Assumes the first rqst has a transform header as the first iov.

 * I.e.

 * rqst[0].rq_iov[0]  is transform header

 * rqst[0].rq_iov[1+] data to be encrypted/decrypted

 * rqst[1+].rq_iov[0+] data to be encrypted/decrypted

			/*

			 * The first rqst has a transform header where the

			 * first 20 bytes are not part of the encrypted blob

/*

 * Encrypt or decrypt @rqst message. @rqst[0] has the following format:

 * iov[0]   - transform header (associate data),

 * iov[1-N] - SMB2 header and pages - data to encrypt.

 * On success return encrypted data in iov[1-N] and pages, leave iov[0]

 * untouched.

/*

 * This function will initialize new_rq and encrypt the content.

 * The first entry, new_rq[0], only contains a single iov which contains

 * a smb2_transform_hdr and is pre-allocated by the caller.

 * This function then populates new_rq[1+] with the content from olq_rq[0+].

 *

 * The end result is an array of smb_rqst structures where the first structure

 * only contains a single iov for the transform header which we then can pass

 * to crypt_message().

 *

 * new_rq[0].rq_iov[0] :  smb2_transform_hdr pre-allocated by the caller

 * new_rq[1+].rq_iov[*] == old_rq[0+].rq_iov[*] : SMB2/3 requests

 copy pages form the old */

 fill the 1st iov with a transform header */

 enough data to fill the page */

 set up first two iov to get credits */

 normal error on read response */

		/*

		 * win2k8 sometimes sends an offset of 0 when the read

		 * is beyond the EOF. Treat it as if the data starts just after

		 * the header.

 data_offset is beyond the end of smallbuf */

 read response payload is in pages */

 data offset is beyond the 1st page of response */

 data_len is corrupt -- discard frame */

 read response payload is in buf */

 read response payload cannot be in both buf and pages */

 read read data into pages */

	/*

	 * For large reads, offload to different thread for better performance,

	 * use more cores decrypting which can be expensive

 worker thread takes care of finding mid */

 switch to large buffer if too big for a small one */

 now read the rest */

		/*

		 * ret != 0 here means that we didn't get to handle_mid() thus

		 * server->smallbuf and server->bigbuf are still valid. We need

		 * to free next_buffer because it is not going to be used

		 * anywhere.

 TODO: add support for compounds containing READ. */

	/*

	 * Check if mounted with mount parm 'sfu' mount parm.

	 * SFU emulation should work with all servers, but only

	 * supports block and char device (no socket & fifo),

	 * and was used by default in earlier versions of Windows

	/*

	 * TODO: Add ability to create instead via reparse point. Windows (e.g.

	 * their current NFS server) uses this approach to expose special files

	 * over SMB2/SMB3 and Samba will do this with SMB3.1.1 POSIX Extensions

	/*

	 * BB Do not bother to decode buf since no local inode yet to put

	 * timestamps in, but we can reuse it safely.

 FIXME: add code here to set EAs */

 CIFS_XATTR */

 CIFS_XATTR */

 WSL tags introduced long after smb2.1, enable for SMB3, 3.11 only */

 CIFS_XATTR */

	.validate_negotiate = smb3_validate_negotiate, */ 
 CIFS_XATTR */

 MBZ */

 MBZ on negotiate req until SMB3 dialect */

 doesn't matter, send protocol array */

 doesn't matter, send protocol array */

 SPDX-License-Identifier: LGPL-2.1

/*

 *

 *   Copyright (C) International Business Machines  Corp., 2002, 2011

 *                 Etersoft, 2012

 *   Author(s): Steve French (sfrench@us.ibm.com)

 *              Jeremy Allison (jra@samba.org) 2006

 *              Pavel Shilovsky (pshilovsky@samba.org) 2012

 *

		/*

		 * If we are in the process of binding a new channel

		 * to an existing session, use the master connection

		 * session key

	/*

	 * Otherwise, use the channel key.

/*

 * Obtain tcon corresponding to the tid in the given

 * cifs_ses

 tcon already has a ref to ses, so we don't need ses anymore */

	/*

	 * For SMB2+, __cifs_calc_signature() expects to sign only the actual

	 * data, that is, iov[0] should not contain a rfc1002 length.

	 *

	 * Sign the rfc1002 length prior to passing the data (iov[1-N]) down to

	 * __cifs_calc_signature().

	/*

	 * All channels use the same encryption/decryption keys but

	 * they have their own signing key.

	 *

	 * When we generate the keys, check if it is for a new channel

	 * (binding) in which case we only need to generate a signing

	 * key and store it in the channel as to not overwrite the

	 * master connection signing key stored in the session

	/*

	 * The session id is opaque in terms of endianness, so we can't

	 * print it as a long long. we dump it as we got it on the wire

	/*

	 * we already allocate sdesccmacaes when we init smb3 signing key,

	 * so unlike smb2 case we do not have to check here if secmech are

	 * initialized

	/*

	 * For SMB2+, __cifs_calc_signature() expects to sign only the actual

	 * data, that is, iov[0] should not contain a rfc1002 length.

	 *

	 * Sign the rfc1002 length prior to passing the data (iov[1-N]) down to

	 * __cifs_calc_signature().

 must be called with server->srv_mutex held */

	/*

	 * BB what if signatures are supposed to be on for session but

	 * server does not send one? BB

 Do not need to verify session setups with signature "BSRSPYL " */

	/*

	 * Save off the origiginal signature so we can modify the smb and check

	 * our calculated signature against what the server sent.

/*

 * Set message id for the request. Should be called after wait_for_free_request

 * and when srv_mutex is held.

 skip message numbers according to CreditCharge field */

 Always LE */

	/*

	 * The default is for the mid to be synchronous, so the

	 * default callback just wakes up the current task.

 else ok - we are setting up session */

 else ok - we are shutting down the session */

 convert the length into a more usable form */

 SPDX-License-Identifier: LGPL-2.1

/*

 *   CIFS filesystem cache index structure definitions

 *

 *   Copyright (c) 2010 Novell, Inc.

 *   Authors(s): Suresh Jayaraman (sjayaraman@suse.de>

 *

/*

 * CIFS filesystem definition for FS-Cache

/*

 * Register CIFS for caching with FS-Cache

/*

 * Unregister CIFS for caching

/*

 * Server object for FS-Cache

/*

 * Superblock object for FS-Cache

 SPDX-License-Identifier: LGPL-2.1

/*

 *

 *   Copyright (C) International Business Machines  Corp., 2002,2008

 *   Author(s): Steve French (sfrench@us.ibm.com)

 *   Jeremy Allison (jra@samba.org) 2006.

 *

 Max number of iovectors we can use off the stack when sending requests. */

	do_gettimeofday(&temp->when_sent);*/ 
 when mid allocated can be before when sent */

	/*

	 * The default is for the mid to be synchronous, so the

	 * default callback just wakes up the current task.

	/*

	 * commands taking longer than one second (default) can be indications

	 * that something is wrong, unless it is quite a slow link or a very

	 * busy server. Note that this calc is unlikely or impossible to wrap

	 * as long as slow_rsp_threshold is not set way above recommended max

	 * value (32767 ie 9 hours) and is generally harmless even if wrong

	 * since only affects debug counters - so leaving the calc as simple

	 * comparison rather than doing multiple conversions and overflow

	 * checks

		/*

		 * smb2slowcmd[NUMBER_OF_SMB2_COMMANDS] counts by command

		 * NB: le16_to_cpu returns unsigned so can not be negative below

/*

 * smb_send_kvec - send an array of kvecs to the server

 * @server:	Server to send the data to

 * @smb_msg:	Message to send

 * @sent:	amount of data sent on socket is stored here

 *

 * Our basic "send data to server" function. Should be called with srv_mutex

 * held. The caller is responsible for handling the results.

		/*

		 * If blocking send, we try 3 times, since each can block

		 * for 5 seconds. For nonblocking  we have to try more

		 * but wait increasing amounts of time allowing time for

		 * socket to clear.  The overall time we wait in either

		 * case to send on the socket is about 15 seconds.

		 * Similarly we wait for 15 seconds for a response from

		 * the server in SendReceive[2] for the server to send

		 * a response back for most types of requests (except

		 * SMB Write past end of file which can be slow, and

		 * blocking lock operations). NFS waits slightly longer

		 * than CIFS, but this can make it take longer for

		 * nonresponsive servers to be detected and 15 seconds

		 * is more than enough time for modern networks to

		 * send a packet.  In most cases if we fail to send

		 * after the retries we will kill the socket and

		 * reconnect which may clear the network problem.

			/* should never happen, letting socket clear before

 send was at least partially successful */

 in case we get ENOSPC on the next send */

 total up iov array first */

	/*

	 * Add in the page array if there is one. The caller needs to make

	 * sure rq_offset and rq_tailsz are set correctly. If a buffer of

	 * multiple pages ends at page boundary, rq_tailsz needs to be set to

	 * PAGE_SIZE.

			/*

			 * If there is more than one page, calculate the

			 * buffer length based on rq_offset and rq_tailsz

 return -EAGAIN when connecting or reconnecting */

 cork the socket */

	/*

	 * We should not allow signals to interrupt the network send because

	 * any partial send will cause session reconnects thus increasing

	 * latency of system calls and overload a server with unnecessary

	 * requests.

 Generate a rfc1002 marker for SMB2+ */

 now walk the page array and send each page in it */

	/*

	 * If signal is pending but we have already sent the whole packet to

	 * the server we need to return success status to allow a corresponding

	 * mid entry to be kept in the pending requests queue thus allowing

	 * to handle responses from the server by the client.

	 *

	 * If only part of the packet has been sent there is no need to hide

	 * interrupt because the session will be reconnected anyway, so there

	 * won't be any response from the server to handle.

 uncork it */

		/*

		 * If we have only sent part of an SMB then the next SMB could

		 * be taken as the remainder of this one. We need to kill the

		 * socket so the server throws away the partial SMB

 Since an echo is already inflight, no need to wait to send another */

 oplock breaks must not be held up */

			/*

			 * For normal commands, reserve the last MAX_COMPOUND

			 * credits to compound requests.

			 * Otherwise these compounds could be permanently

			 * starved for credits by single-credit requests.

			 *

			 * To prevent spinning CPU, block this thread until

			 * there are >MAX_COMPOUND credits available.

			 * But only do this is we already have a lot of

			 * credits in flight to avoid triggering this check

			 * for servers that are slow to hand out credits on

			 * new sessions.

			/*

			 * Can not count locking commands against total

			 * as they are allowed to block on server.

 update # of requests on the wire to server */

		/*

		 * If the server is tight on resources or just gives us less

		 * credits for other reasons (e.g. requests are coming out of

		 * order and the server delays granting more credits until it

		 * processes a missing mid) and we exhausted most available

		 * credits there may be situations when we try to send

		 * a compound request but we don't have enough credits. At this

		 * point the client needs to decide if it should wait for

		 * additional credits or fail the request. If at least one

		 * request is in flight there is a high probability that the

		 * server will return enough credits to satisfy this compound

		 * request.

		 *

		 * Return immediately if no requests in flight since we will be

		 * stuck on waiting for credits.

 else ok - we are setting up session */

 check if SMB session is bad because we are setting it up */

 else ok - we are shutting down session */

 enable signing if server requires it */

/*

 * Send a SMB request and set the callback function in the mid to handle

 * the result. Caller is responsible for dealing with timeouts.

	/*

	 * We can't use credits obtained from the previous session to send this

	 * request. Check if there were reconnects after we obtained credits and

	 * return -EAGAIN in such cases to let callers handle it.

 put it on the pending_mid_q */

	/*

	 * Need to store the time in mid before calling I/O. For call_async,

	 * I/O response may come back and free the mid entry on another thread.

/*

 *

 * Send an SMB Request.  No response info (other than return code)

 * needs to be parsed.

 *

 * flags indicate the type of request buffer and how long to wait

 * and whether to log NT STATUS code (error) before mapping it to POSIX error

 *

 convert the length into a more usable form */

 FIXME: add code to kill session */

 BB special case reconnect tid and uid here? */

/*

 * Return a channel (master if none) of @ses that can be used to send

 * regular requests.

 *

 * If we are currently binding a new channel (negprot/sess.setup),

 * return the new incomplete channel.

 round robin */

 no response buf yet */

	/*

	 * Wait for all the requests to become available.

	 * This approach still leaves the possibility to be stuck waiting for

	 * credits if the server doesn't grant credits to the outstanding

	 * requests and if the client is completely idle, not generating any

	 * other requests.

	 * This can be handled by the eventual session reconnect.

	/*

	 * Make sure that we sign in the same order that we send on this socket

	 * and avoid races inside tcp sendmsg code that could cause corruption

	 * of smb data.

	/*

	 * All the parts of the compound chain belong obtained credits from the

	 * same session. We can not use credits obtained from the previous

	 * session to send this request. Check if there were reconnects after

	 * we obtained credits and return -EAGAIN in such cases to let callers

	 * handle it.

 Update # of requests on wire to server */

		/*

		 * Invoke callback for every part of the compound chain

		 * to calculate credits properly. Wake up this thread only when

		 * the last element is received.

	/*

	 * If sending failed for some reason or it is an oplock break that we

	 * will not receive a response to - return credits back

	/*

	 * At this point the request is passed to the network stack - we assume

	 * that any credits taken from the server structure on the client have

	 * been spent and we can't return them back. Once we receive responses

	 * we will collect credits granted by the server in the mid callbacks

	 * and add those credits to the server structure.

	/*

	 * Compounding is never used during session establish.

 mark this mid as cancelled to not free it below */

 mark it so buf will not be freed by cifs_delete_mid */

	/*

	 * Compounding is never used during session establish.

	/*

	 * This will dequeue all mids. After this it is important that the

	 * demultiplex_thread will not process any of these mids any futher.

	 * This is prevented above by using a noop callback that will not

	 * wake this thread except for the very last PDU.

 ret */,

 otherwise cifs_send_recv below sets resp_buf_type */

 1st iov is a RFC1001 length followed by the rest of the packet */

	/* Ensure that we do not send more than 50 overlapping requests

	   to the same server. We may make this configurable later or

	/* make sure that we sign in the same order that we send on this socket

	   and avoid races inside tcp sendmsg code that could cause corruption

 Update # of requests on wire to server */

 no longer considered to be "in-flight" */

/* We send a LOCKINGX_CANCEL_LOCK to cause the Windows

	/* We just modify the current in_buf to change

	   the type of lock from LOCKING_ANDX_SHARED_LOCK

	   or LOCKING_ANDX_EXCLUSIVE_LOCK to

	/* Ensure that we do not send more than 50 overlapping requests

	   to the same server. We may make this configurable later or

	/* make sure that we sign in the same order that we send on this socket

	   and avoid races inside tcp sendmsg code that could cause corruption

 Wait for a reply - allow signals to interrupt. */

 Were we interrupted by a signal ? */

			/* POSIX lock. We send a NT_CANCEL SMB to cause the

			/* Windows lock. We send a LOCKINGX_CANCEL_LOCK

			/* If we get -ENOLCK back the lock may have

 no longer considered to be "in-flight" */

 We got the response - restart system call. */

 rcvd frame is ok */

 SPDX-License-Identifier: LGPL-2.1

/*

 *

 *   Encryption and hashing operations relating to NTLM, NTLMv2.  See MS-NLMP

 *   for more detailed information

 *

 *   Copyright (C) International Business Machines  Corp., 2005,2013

 *   Author(s): Steve French (sfrench@us.ibm.com)

 *

 iov[0] is actual data and not the rfc1002 length for SMB2+ */

 skip rfc1002 length */

 now hash over the rq_pages array */

/*

 * Calculate and return the CIFS signature based on the mac key and SMB PDU.

 * The 16 byte signature must be allocated by the caller. Note we only use the

 * 1st eight bytes and that the smb header signature field on input contains

 * the sequence number before this function is called. Also, this function

 * should be called with the server->srv_mutex held.

 must be called with server->srv_mutex held */

 must be called with server->srv_mutex held */

	/* BB what if signatures are supposed to be on for session but

 Do not need to verify session setups with signature "BSRSPYL "  */

	/* save off the origiginal signature so we can modify the smb and check

/*	cifs_dump_mem("what we think it should be: ",

/* Build a proper attribute value/target info pairs blob.

 * Fill in netbios and dns domain name and workstation name

 * and client time (total five av pairs and + one end of fields indicator.

 * Allocate domain name which gets freed when session struct is deallocated.

	/*

	 * The length of this blob is two times the size of a

	 * structure (av pair) which holds name/size

	 * ( for NTLMSSP_AV_NB_DOMAIN_NAME followed by NTLMSSP_AV_EOL ) +

	 * unicode length of a netbios domain name

	/*

	 * As defined in MS-NTLM 3.3.2, just this av pair field

	 * is sufficient as part of the temp

/* Server has provided av pairs/target info in the type 2 challenge

 * packet and we have plucked it and stored within smb session.

 * We parse that blob here to find netbios domain name to be used

 * as part of ntlmv2 authentication (in Target String), if not already

 * specified on the command line.

 * If this function returns without any error but without fetching

 * domain name, authentication may fail against some server but

 * may not fail against other (those who are not very particular

 * about target string i.e. for some, just user name might suffice.

 advance attr type */

 advance attr size */

 advance attr  value */

/* Server has provided av pairs/target info in the type 2 challenge

 * packet and we have plucked it and stored within smb session.

 * We parse that blob here to find the server given timestamp

 * as part of ntlmv2 authentication (or local current time as

 * default in case of failure)

 advance attr type */

 advance attr size */

 advance attr value */

 calculate md4 hash of password */

 convert ses->user_name to unicode */

 convert ses->domainName to unicode and uppercase */

 We use ses->ip_addr if no domain name available */

 The MD5 hash starts at challenge_key.key */

 Note that the MD5 digest over writes anon.challenge_key.key */

 target info blob */

	/* Must be within 5 minutes of the server (or in range +/-2h

	 * in case of Mac OS X), so simply carry over server timestamp

	 * (as Windows 7 does)

 calculate ntlmv2_hash */

 calculate first part of the client response (CR1) */

 now calculate the session key for NTLMv2 */

 a nonce */

 make secondary_key/nonce as session key */

 and make len as that of session key only */

 SPDX-License-Identifier: LGPL-2.1

/*

 *

 *   Copyright (C) International Business Machines  Corp., 2007

 *   Author(s): Steve French (sfrench@us.ibm.com)

 *

 *   Common Internet FileSystem (CIFS) client

 *

 *   Operations related to support for exporting files via NFSD

 *

 /*

  * See Documentation/filesystems/nfs/exporting.rst

  * and examples in fs/exportfs

  *

  * Since cifs is a network file system, an "fsid" must be included for

  * any nfs exports file entries which refer to cifs paths.  In addition

  * the cifs mount must be mounted with the "serverino" option (ie use stable

  * server inode numbers instead of locally generated temporary ones).

  * Although cifs inodes do not use generation numbers (have generation number

  * of zero) - the inode number alone should be good enough for simple cases

  * in which users want to export cifs shares with NFS. The decode and encode

  * could be improved by using a new routine which expects 64 bit inode numbers

  * instead of the default 32 bit routines in fs/exportfs

  *

 BB need to add code here eventually to enable export via NFSD */

/*	Following five export operations are unneeded so far and can default:

	.get_dentry =

	.get_name =

	.find_exported_dentry =

	.decode_fh =

 CONFIG_CIFS_NFSD_EXPORT */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *

 * Copyright (c) Jeffrey Layton <jlayton@redhat.com>, 2013

 *

 * The const tables in this file were converted from the following info

 * provided by Microsoft:

 *

 * 3.1.5.3 Mapping UTF-16 Strings to Upper Case:

 *

 * https://msdn.microsoft.com/en-us/library/hh877830.aspx

 * http://www.microsoft.com/en-us/download/details.aspx?displaylang=en&id=10921

 *

 * In particular, the table in "Windows 8 Upper Case Mapping Table.txt" was

 * post-processed using the winucase_convert.pl script.

 quiet sparse */

/**

 * cifs_toupper - convert a wchar_t from lower to uppercase

 * @in: character to convert from lower to uppercase

 *

 * This function consults the static tables above to convert a wchar_t from

 * lower to uppercase. In the event that there is no mapping, the original

 * "in" character is returned.

 grab upper byte */

 find pointer to 2nd layer table */

 grab lower byte */

 look up character in table */

 SPDX-License-Identifier: LGPL-2.1

/*

 *

 *   Copyright (C) International Business Machines  Corp., 2007,2008

 *   Author(s): Steve French (sfrench@us.ibm.com)

 *

 *   Contains the routines for mapping CIFS/NTFS ACLs

 *

 security id for everyone/world system group */

 security id for Authenticated Users system group */

 S-1-22-1 Unmapped Unix users */

 S-1-22-2 Unmapped Unix groups */

/*

 * See https://technet.microsoft.com/en-us/library/hh509017(v=ws.10).aspx

 S-1-5-88 MS NFS and Apple style UID/GID/mode */

 S-1-5-88-1 Unix uid */

 S-1-5-88-2 Unix gid */

 S-1-5-88-3 Unix mode */

	/*

	 * If the payload is less than or equal to the size of a pointer, then

	 * an allocation here is wasteful. Just copy the data directly to the

	 * payload.value union member instead.

	 *

	 * With this however, you must check the datalen before trying to

	 * dereference payload.data!

 3 bytes for prefix */

 The authority field is a single 48-bit number */

	/*

	 * MS-DTYP states that if the authority is >= 2^32, then it should be

	 * expressed as a hex value.

/*

 * if the two SIDs (roughly equivalent to a UUID for a user or group) are

 * the same returns zero, if they do not match returns non-zero.

 compare the revision */

 compare all of the six auth values */

 compare all of the subauth values if any */

 sids compare/match */

 check if Mac (or Windows NFS) vs. Samba format for Unix owner SID */

 compare the revision */

 compare all of the six auth values */

 3 subauths, ie Windows/Mac style */ {

 well known sid found, uid returned */

 3 byte prefix + 10 bytes for value + NULL */

	/*

	 * A sid is usually too large to be embedded in payload.value, but if

	 * there are no subauthorities and the host has 8-byte pointers, then

	 * it could be.

	/*

	 * If we have too many subauthorities, then something is really wrong.

	 * Just return an error.

 If unable to find uid/gid easily from SID try via upcall */

	/*

	 * FIXME: Here we assume that uid_t and gid_t are same size. It's

	 * probably a safe assumption but might be better to check based on

	 * sidtype.

	/*

	 * Note that we return 0 here unconditionally. If the mapping

	 * fails then we just fall back to using the ctx->linux_uid/linux_gid.

	/* create an override credential set with a special thread keyring in

	 * which requests are cached

	 *

	 * this is used to prevent malicious redirections from being installed

	 * with add_key().

	/* instruct request_key() to use this special keyring as a cache for

 copy ntsd, owner sid, and group sid from a security descriptor to another */

 copy security descriptor control portion */

 copy owner sid */

 copy group sid */

/*

   change posix mode to reflect permissions

   pmode is the existing mode (we only want to overwrite part of this

   bits to set can be: S_IRWXU, S_IRWXG or S_IRWXO ie 00700 or 00070 or 00007

	/*

	 * Do not assume "preferred" or "canonical" order.

	 * The first DENY or ALLOW ACE which matches perfectly is

	 * the permission to be used. Once allowed or denied, same

	 * permission in later ACEs do not matter.

 If not already allowed, deny these bits */

 else ACCESS_ALLOWED type */

 If DELETE_CHILD is set only on an owner ACE, set sticky bit */

/*

   Generate access flags to reflect permissions mode is the existing mode.

   This function is called for every ACE in the DACL whose SID matches

   with either owner or group or everyone.

 reset access mask */

 bits to use are either S_IRWXU or S_IRWXG or S_IRWXO */

	/* check for R/W/X UGO since we do not know whose flags

	   is this but we have cleared all the bits sans RWX for

 Check if there's a replacement sid specified */

 validate that we do not go past end of acl */

		/* BB add length check to make sure that we do not have huge

 BB need to add parm so we can store the SID BB */

		/* no DACL in the security descriptor, set

 validate that we do not go past end of acl */

	/* reset rwx permissions for user/group/other.

	   Also, if num_aces is 0 i.e. DACL has no ACEs,

				/*

				 * Full permissions are:

				 * 07777 = S_ISUID | S_ISGID | S_ISVTX |

				 *         S_IRWXU | S_IRWXG | S_IRWXO

/*			memcpy((void *)(&(cifscred->aces[i])),

				(void *)ppace[i],

 size = 1 + 1 + 2 + 4 + 1 + 1 + 6 + (psid->num_subauth*4) */

/*

 * Fill in the special SID based on the mode. See

 * https://technet.microsoft.com/en-us/library/hh509017(v=ws.10).aspx

 size = 1 + 1 + 2 + 4 + 1 + 1 + 6 + (psid->num_subauth*4) */

 size = 1 + 1 + 2 + 4 + 1 + 1 + 6 + (psid->num_subauth*4) */

	/*

	 * We'll try to keep the mode as requested by the user.

	 * But in cases where we cannot meaningfully convert that

	 * into ACL, return back the updated mode, so that it is

	 * updated in the inode.

		/*

		 * Case when owner and group SIDs are the same.

		 * Set the more restrictive of the two modes.

 We need DENY ACE when the perm is more restrictive than the next sets. */

 This tells if we should allow delete child for group and everyone. */

 Group DENY ACE does not conflict with owner ALLOW ACE. Keep in preferred order*/

 Group DENY ACE conflicts with owner ALLOW ACE. So keep it after. */

 Go through all the ACEs */

 Assuming that pndacl and pnmode are never NULL */

 If pdacl is NULL, we don't have a src. Simply populate new ACL. */

 Retain old ACEs which we can retain */

 Place the new ACEs in between existing explicit and inherited */

 If it's any one of the ACE we're replacing, skip! */

 update the pointer to the next ACE to populate*/

 If inherited ACEs are not present, place the new ones at the tail */

 BB need to add parm so we can store the SID BB */

	/* validate that we do not go past end of ACL - sid must be at least 8

		/* BB add length check to make sure that we do not have huge

 Convert CIFS ACL to POSIX form */

 no need for SACL ptr */

	cifs_dump_mem("owner_sid: ", owner_sid_ptr, 64); */

 BB grant all or default perms? */

 Convert permission bits from mode to equivalent CIFS ACL */

 no need for SACL ptr */

 no need for SACL ptr */

 chmod */

 copy the non-dacl portion of secdesc */

 chown */

 Populate the user ownership fields S-1-5-88-1 */

 lookup sid with upcall */

 chgrp */

 Populate the group ownership fields S-1-5-88-2 */

 lookup sid with upcall */

 Replace ACEs for old owner with new one */

 copy the non-dacl portion of secdesc */

 errors could jump here. So make sure we return soon after this */

 Retrieve an ACL from the server */

 Set an ACL on the server */

 Translate the CIFS ACL (similar to NTFS ACL) for a file into mode bits */

 if we can retrieve the ACL, now parse Access Control Entries, ACEs */

 get approximated mode from ACL */

 Convert mode bits to an ACL so we can update the ACL on the server */

 default flag to set */

 acl obtained from server */

 modified acl to be sent to server */

 Get the security descriptor */

 Potentially, five new ACEs can be added to the ACL for U,G,O mapping */

 chmod */

 cifsacl */

 chown */

 When ownership changes, changes new owner sid length could be different */

 cifsacl */

	/*

	 * Add three ACEs for owner, group, everyone getting rid of other ACEs

	 * as chmod disables ACEs and set the security descriptor. Allocate

	 * memory for the smb header, set security descriptor request security

	 * descriptor parameters, and security descriptor itself

 Set the security descriptor */

 SPDX-License-Identifier: GPL-2.0

/*

 * SMB root file system support

 *

 * Copyright (c) 2019 Paulo Alcantara <palcantara@suse.de>

 TODO: ipv6 support */

<server-ip>/<share>[,options] */

 make s point to ',' or '\0' at end of line */

 len is strlen(unc) + '\0' */

 SPDX-License-Identifier: LGPL-2.1

/*

 *

 *   SMB/CIFS session setup handling routines

 *

 *   Copyright (c) International Business Machines  Corp., 2006, 2009

 *   Author(s): Steve French (sfrench@us.ibm.com)

 *

 unknown family.. */

 returns number of channels added */

	/*

	 * Make a copy of the iface list at the time and use that

	 * instead so as to not hold the iface spinlock for opening

	 * channels

	/*

	 * Keep connecting to same, fastest, iface for all channels as

	 * long as its RSS. Try next fastest one if not RSS or channel

	 * creation fails.

/*

 * If server is a channel of ses, return the corresponding enclosing

 * cifs_chan otherwise return NULL.

	/*

	 * Setup a ctx with mostly the same info as the existing

	 * session and overwrite it with the requested iface data.

	 *

	 * We need to setup at least the fields used for negprot and

	 * sesssetup.

	 *

	 * We only need the ctx here, so we can reuse memory from

	 * the session and server without caring about memory

	 * management.

 Always make new connection for now (TODO?) */

 Auth */

 UNC and paths */

 XXX: Use ses->server->hostname? */

 Reuse same version as master connection */

	/*

	 * This will be used for encoding/decoding user/domain/pw

	 * during sess setup auth.

 Use RDMA if possible */

 reuse master con client guid */

	/*

	 * We need to allocate the server crypto now as we will need

	 * to sign packets before we generate the channel signing key

	 * (we sign with the session key)

	/* success, put it on the list

	 * XXX: sharing ses between 2 tcp servers is not possible, the

	 * way "internal" linked lists works in linux makes element

	 * only able to belong to one list

	 *

	 * the binding session is already established so the rest of

	 * the code should be able to look it up, no need to add the

	 * ses to the new server.

 Mark all session channels for reconnect */

 init fields common to all four types of SessSetup */

 Note that offsets for first seven fields in req struct are same  */

	in CIFS Specs so does not matter which of 3 forms of struct */

	that we use in next few lines                               */

 Note that header is initialized to zero in header_assemble */

 Now no need to set SMBFLG_CASELESS or obsolete CANONICAL PATH */

	/* BB verify whether signing required on neg or just on auth frame

 Copy OS version */

 trailing null */

 trailing null */

 copy domain */

		/* Sending null domain better than using a bogus domain name (as

 account for null terminator */

	/* BB FIXME add check that strings total less

 unicode strings, must be word aligned before the call */

/*	if ((long) bcc_ptr % 2)	{

		*bcc_ptr = 0;

		bcc_ptr++;

 copy user */

 null user mount */

 account for null termination */

 copy user */

 BB what about null user mounts - check that we do this BB */

 copy user */

 else null user mount */

 account for null termination */

 copy domain */

	} /* else we will send a null domain name

 BB check for overflow here */

	/* No domain field in LANMAN case. Domain is

	/* BB For newer servers which do not support Unicode,

	   but thus do return domain here we could add parsing

 challenge message target info area */

 challenge message target info area length  */

 BB we could decode pblob->NegotiateFlags; some may be useful */

 In particular we can examine sign flags */

	/* BB spec says that if AvId field of MsvAvTimestamp is populated then

 BB Move to ntlmssp.c eventually */

 BB is NTLMV2 session security format easier to use here? */

 these fields should be null in negotiate phase MS-NLMP 3.1.5.1.1 */

		/*

		 * don't send an NT Response for anonymous access

	/* we will send the SMB in three pieces:

	 * a fixed length beginning part, an optional

	 * SPNEGO blob (which can be zero length), and a

	 * last part which will include the strings

	 * and rest of bcc area. This allows us to avoid

	 * a large buffer 17K allocation

	/*

	 * This variable will be used to clear the buffer

	 * allocated above in case of any error in the calling function.

 2000 big enough to fit max user, domain, NOS name etc. */

 num_iovecs */,

 old style NTLM sessionsetup */

 wct = 13 */

 LM2 password would be here if we supported it */

 calculate nlmv2 response and session key */

		/* set case sensitive password length after tilen may get

		 * assigned, tilen is 0 otherwise.

 BB mark SesInfo struct? */

 UID left in wire format (le) */

 BB check if Unicode and decode strings */

 no string area to decode, do nothing */

 unicode string area must be word-aligned */

 extended security */

 wct = 12 */

	/*

	 * check version field to make sure that cifs.upcall is

	 * sending us a response in an expected form

 unicode strings must be word aligned */

 BB: is this right? */

 BB mark SesInfo struct? */

 UID left in wire format (le) */

 BB check if Unicode and decode strings */

 no string area to decode, do nothing */

 unicode string area must be word-aligned */

 ! CONFIG_CIFS_UPCALL */

/*

 * The required kvec buffers have to be allocated before calling this

 * function.

 unicode strings must be word aligned */

	/*

	 * if memory allocation is successful, caller of this function

	 * frees it.

 wct = 12 */

 Build security blob before we assemble the request */

 If true, rc here is expected and not an error */

 UID left in wire format (le) */

 Else error. Cleanup */

 wct = 12 */

 Build security blob before we assemble the request */

	/*

	 * Make sure that we tell the server that we are using

	 * the uid that it just gave us back on the response

	 * (challenge)

 BB mark SesInfo struct? */

 BB check if Unicode and decode strings */

 no string area to decode, do nothing */

 unicode string area must be word-aligned */

 Cleanup */

 CONFIG_CIFS_UPCALL */

 Store result before we free sess_data */

 SPDX-License-Identifier: LGPL-2.1

/*

 *

 *   Copyright (C) International Business Machines  Corp., 2009, 2013

 *                 Etersoft, 2012

 *   Author(s): Steve French (sfrench@us.ibm.com)

 *              Pavel Shilovsky (pshilovsky@samba.org) 2012

 *

 *   Contains the routines for constructing the SMB2 PDUs themselves

 *

 SMB2 PDU handling routines here - except for leftovers (eg session setup) */

 Note that there are handle based routines which must be		      */

 treated slightly differently for reconnection purposes since we never     */

 want to reuse a stale file handle and only the caller knows the file info */

/*

 *  The following table defines the expected "StructureSize" of SMB2 requests

 *  in order by SMB2 command.  This is similar to "wct" in SMB/CIFS requests.

 *

 *  Note that commands are defined in smb2pdu.h in le16 but the array below is

 *  indexed by command in host byte order.

 SMB2_NEGOTIATE */ 36,

 SMB2_SESSION_SETUP */ 25,

 SMB2_LOGOFF */ 4,

 SMB2_TREE_CONNECT */	9,

 SMB2_TREE_DISCONNECT */ 4,

 SMB2_CREATE */ 57,

 SMB2_CLOSE */ 24,

 SMB2_FLUSH */ 24,

 SMB2_READ */	49,

 SMB2_WRITE */ 49,

 SMB2_LOCK */	48,

 SMB2_IOCTL */ 57,

 SMB2_CANCEL */ 4,

 SMB2_ECHO */ 4,

 SMB2_QUERY_DIRECTORY */ 33,

 SMB2_CHANGE_NOTIFY */ 32,

 SMB2_QUERY_INFO */ 41,

 SMB2_SET_INFO */ 33,

 SMB2_OPLOCK_BREAK */ 24 
 Request up to 10 credits but don't go over the limit. */

 GLOBAL_CAP_LARGE_MTU will only be set if dialect > SMB2.02 */

 See sections 2.2.4 and 3.2.4.1.5 of MS-SMB2 */

 else CreditCharge MBZ */

 Uid is not converted */

	/*

	 * If we would set SMB2_FLAGS_DFS_OPERATIONS on open we also would have

	 * to pass the path on the Open SMB prefixed by \\server\share.

	 * Not sure when we would need to do the augmented path (if ever) and

	 * setting this flag breaks the SMB2 open operation since it is

	 * illegal to send an empty path name (without \\server\share prefix)

	 * when the DFS flag is set in the SMB open header. We could

	 * consider setting the flag on all operations other than open

	 * but it is safer to net set it for now.

/*	if (tcon->share_flags & SHI1005_FLAGS_DFS)

	/*

	 * SMB2s NegProt, SessSetup, Logoff do not have tcon yet so

	 * check for tcp and smb session status done differently

	 * for those three - in the calling routine.

	/*

	 * Need to also skip SMB2_IOCTL because it is used for checking nested dfs links in

	 * cifs_tree_connect().

		/*

		 * only tree disconnect, open, and write,

		 * (and ulogoff which does not have tcon)

		 * are allowed as we start force umount.

	/*

	 * Give demultiplex thread up to 10 seconds to each target available for

	 * reconnect -- should be greater than cifs socket timeout which is 7

	 * seconds.

		/*

		 * Return to caller for TREE_DISCONNECT and LOGOFF and CLOSE

		 * here since they are implicitly done when session drops.

		/*

		 * BB Should we keep oplock break and add flush to exceptions?

 are we still trying to reconnect? */

		/*

		 * on "soft" mounts we wait once. Hard mounts keep

		 * retrying until process is killed or server comes

		 * back on-line

	/*

	 * need to prevent multiple threads trying to simultaneously reconnect

	 * the same SMB session

	/*

	 * Recheck after acquire mutex. If another thread is negotiating

	 * and the server never sends an answer the socket will be closed

	 * and tcpStatus set to reconnect.

	/*

	 * If we are reconnecting an extra channel, bind

	/*

	 * End of channel binding

 If sess reconnected but tcon didn't, something strange ... */

	/*

	 * Check if handle based operation so we know whether we can continue

	 * or not without returning to caller to reset file handle.

	/*

	 * BB Is flush done by server on drop of tcp session? Should we special

	 * case it and skip above?

 lookup word count ie StructureSize from table */

	/*

	 * smaller than SMALL_BUFFER_SIZE but bigger than fixed area of

	 * largest operations (Create)

/*

 * Allocate and return pointer to an SMB request hdr, and set basic

 * SMB information in the SMB header. If the return code is zero, this

 * function must have filled in request_buf pointer.

 BB eventually switch this to SMB2 specific small buf size */

 BB should we add a retry in here if not a writepage? */

 Skip reconnect only for FSCTL_VALIDATE_NEGOTIATE_INFO IOCTLs */

 For explanation of negotiate contexts see MS-SMB2 section 2.2.3.1 */

 number of signing algorithms sent */

	/*

	 * Context Data length must be rounded to multiple of 8 for some servers

 sizeof u16 */), 8) * 8);

 sizeof le16 */ * num_algs;

 TBD add SIGNING_ALG_AES_GMAC and/or SIGNING_ALG_HMAC_SHA256 */

 Cipher Count + 1 cipher */

 Cipher Count + 3 ciphers */

 Cipher Count + 2 ciphers */

 copy up to max of first 100 bytes of server name to NetName field */

 context size is DataLength + minimal smb2_neg_context */

 SMB2_CREATE_TAG_POSIX is "0x93AD25509CB411E7B42383DE968BCD7C" */

 In case length corrupted don't want to overrun smb buffer */

	/*

	 * round up total_len of fixed part of SMB3 negotiate request to 8

	 * byte boundary before adding negotiate contexts

 check for and add transport_capabilities and signing capabilities */

 If invalid preauth context warn but use what we requested, SHA-512 */

 sizeof compress context is a one element compression capbility struct */

		/*

		 * e.g. if server only supported AES256_CCM (very unlikely)

		 * or server supported no encryption types or had all disabled.

		 * Since GLOBAL_CAP_ENCRYPTION will be not set, in the case

		 * in which mount requested encryption ("seal") checks later

		 * on during tree connection will return proper rc, but if

		 * seal not requested by client, since server is allowed to

		 * return 0 to indicate no supported cipher, we can't fail here

 server returned a cipher we didn't ask for */

 check that offset is not beyond end of SMB */

 offsets must be 8 byte aligned */

 SMB2_CREATE_TAG_POSIX is "0x93AD25509CB411E7B42383DE968BCD7C" */

/*

 *

 *	SMB2 Worker functions follow:

 *

 *	The general structure of the worker functions is:

 *	1) Call smb2_init (assembles SMB2 header)

 *	2) Initialize SMB2 command specific fields in fixed length area of SMB

 *	3) Call smb_sendrcv2 (sends request on socket and waits for response)

 *	4) Decode SMB2 command specific fields in the fixed length area

 *	5) Decode variable length data area (if any for this SMB2 command type)

 *	6) Call free smb buffer

 *	7) return

 *

 otherwise send specific dialect */

 only one of SMB2 signing flags may be set in SMB2 request */

 ClientGUID must be zero for SMB2.02 dialect */

	/*

	 * No tcon so can't do

	 * cifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_fail[SMB2...]);

 ops set to 3.0 by default for default so update */

 ops set to 3.0 by default for default so update */

 if requested single dialect ensure returned dialect matched */

	/*

	 * Keep a copy of the hash after negprot. This hash will be

	 * the starting hash value for all sessions made from this

	 * server.

 SMB2 only has an extended negflavor */

 set it to the maximum buffer size value we can send with 1 credit */

 Internal types */

	/*

	 * SMB3.0 supports only 1 cipher and doesn't have a encryption neg context

	 * Set the cipher type manually.

	/*

	 * See MS-SMB2 section 2.2.4: if no blob, client picks default which

	 * for us will be

	 *	ses->sectype = RawNTLMSSP;

	 * but for time being this is our only auth choice so doesn't matter.

	 * We just found a server which sets blob length to zero expecting raw.

 max of 4 dialects */

 In SMB3.11 preauth integrity supersedes validate negotiate */

	/*

	 * validation ioctl must be signed, so no point sending this if we

	 * can not sign it (ie are not known user).  Even if signing is not

	 * required (enabled but not negotiated), in those cases we selectively

	 * sign just this, the first and only signed request on a connection.

	 * Having validation of negotiate info  helps reduce attack vectors.

 validation requires signing */

 validation requires signing */

 SMB 2.1 not included so subtract one dialect from len */

 structure is big enough for 4 dialects */

 otherwise specific dialect was requested */

 structure is big enough for 3 dialects, sending only 1 */

 is_fsctl */,

		/*

		 * Old Windows versions or Netapp SMB server can return

		 * not supported error. Client should accept it.

 relax check since Mac returns max bufsize allowed on ioctl */

 check validate negotiate info response matches what we got earlier */

 do not validate server guid because not saved at negprot time yet */

 validate negotiate successful */

	/* we will send the SMB in three pieces:

	 * a fixed length beginning part, an optional

	 * SPNEGO blob (which can be zero length), and a

	 * last part which will include the strings

	 * and rest of bcc area. This allows us to avoid

	 * a large buffer 17K allocation

 First session, not a reauthenticate */

		/*

		 * if reconnect, we need to send previous sess id

		 * otherwise it is 0

 MBZ */

 enough to enable echos and oplocks and one max size write */

 only one of SMB2 signing flags may be set in SMB2 request */

 one flag unlike MUST_ */

 DFS_UPCALL */

 MBZ */

 1 for pad */

	/*

	 * This variable will be used to clear the buffer

	 * allocated above in case of any error in the calling function.

 Testing shows that buffer offset must be at location of Buffer[0] */

 pad */);

 BB add code to build os and lm fields */

 keep existing ses state if binding */

	/*

	 * check version field to make sure that cifs.upcall is

	 * sending us a response in an expected form

 keep session key if binding */

 keep session id and flags if binding */

 else use raw ntlmssp */

	/*

	 * If memory allocation is successful, caller of this function

	 * frees it.

 BB eventually need to add this */

 If true, rc here is expected and not an error */

 keep existing ses id and flags if binding */

 else use raw ntlmssp */

 BB eventually need to add this */

 keep existing ses id and flags if binding */

		/*

		 * The session id is opaque in terms of endianness, so we can't

		 * print it as a long long. we dump it as we got it on the wire

	/*

	 * Initialize the session hash with the server one.

 response is also trivial struct */

 no need to send SMB logoff if uid already closed due to reconnect */

 since no tcon, smb2_init can not do this, so do here */

	/*

	 * No tcon so can't do

	 * cifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_fail[SMB2...]);

 server */ + 80  NULL */)

 These are similar values to what Windows uses */

 always use master channel */

 SMB2 TREE_CONNECT request must be called with TreeId == 0 */

 1 for pad */

 Testing shows that buffer offset must be at location of Buffer[0] */

 pad */);

	/*

	 * 3.11 tcon req must be signed if not encrypted. See MS-SMB2 3.2.4.1.1

	 * unless it is guest or anonymous user. See MS-SMB2 3.2.5.3.1

	 * (Samba servers don't always set the flag so also check if null user)

 Need 64 for max size write so ask for more in case not there yet */

 we keep caps little endian */

 response is trivial */

 SMB2_CREATE_DURABLE_HANDLE_REQUEST is "DHnQ" */

 SMB2_CREATE_DURABLE_HANDLE_RECONNECT is "DHnC" */

 Initialize inode number to 0 in case no valid data in qfid context */

		/* else {

			cifs_dbg(FYI, "Context not matched with len %d\n",

				le16_to_cpu(cc->NameLength));

			cifs_dump_mem("Cctxt name: ", name, 4);

	/*

	 * NB: Handle timeout defaults to 0, which allows server to choose

	 * (most servers default to 120 seconds) and most clients default to 0.

	 * This can be overridden at mount ("handletimeout=") if the user wants

	 * a different persistent (or resilient) handle timeout for all opens

	 * opens on a particular SMB3 mount.

 SMB2_CREATE_DURABLE_HANDLE_REQUEST is "DH2Q" */

 SMB2_CREATE_DURABLE_HANDLE_RECONNECT_V2 is "DH2C" */

 indicate that we don't need to relock the file */

 indicate that we don't need to relock the file */

 See MS-SMB2 2.2.13.2.7 */

 SMB2_CREATE_TIMEWARP_TOKEN is "TWrp" */

 See MS-SMB2 2.2.13.2.7 */

technet.microsoft.com/en-us/library/hh509017(v=ws.10).aspx */

 Populate the user ownership fields S-1-5-88-1 */

 Populate the group ownership fields S-1-5-88-2 */

 See MS-SMB2 2.2.13.2.2 and MS-DTYP 2.4.6 */

 sizeof(struct owner_group_sids) is already multiple of 8 so no need to round */

 offset fields are from beginning of security descriptor not of create context */

 SMB2_CREATE_SD_BUFFER_TOKEN is "SecD" */

 Must be one see MS-DTYP 2.4.6 */

	/*

	 * ACL is "self relative" ie ACL is stored in contiguous block of memory

	 * and "DP" ie the DACL is present

 offset owner, group and Sbz1 and SACL are all zero */

 Ship the ACL for now. we will copy it into buf later. */

 create one ACE to hold the mode embedded in reserved special SID */

 we do not need to reallocate buffer to add the two more ACEs. plenty of space */

 and one more ACE to allow access for authenticated users */

 See 2.4.4.1 of MS-DTYP */

 SMB2_CREATE_QUERY_ON_DISK_ID is "QFid" */

 See MS-SMB2 2.2.13.2.9 */

	/*

	 * skip leading "\\"

	/*

	 * make room for one path separator between the treename and

	 * path

	/*

	 * final path needs to be null-terminated UTF16 with a

	 * size aligned to 8

 make sure at least one for each open context */

 resource #1: path allocation */

 resource #2: request */

 File attributes ignored on open (used in create though) */

 -1 since last byte is buf[0] which is sent below (path) */

	/* [MS-SMB2] 2.2.13 NameOffset:

	 * If SMB2_FLAGS_DFS_OPERATIONS is set in the Flags field of

	 * the SMB2 header, the file name includes a prefix that will

	 * be processed during DFS name normalization as specified in

	 * section 3.3.5.9. Otherwise, the file name is relative to

	 * the share that is identified by the TreeId in the SMB2

	 * header.

 free before overwriting resource */

 MUST set path len (NameLength) to 0 opening root of share */

 free before overwriting resource */

 resource #3: posix buf */

 no need to inc num_remote_opens because we close it just below */

 resource #4: response buffer */

	/*

	 * Although unlikely to be possible for rsp to be null and rc not set,

	 * adding check below is slightly safer long term (and quiets Coverity

	 * warning)

 Eventually save off posix specific response info and timestaps */

 -1 since last byte is buf[0] which is sent below (path) */

 File attributes ignored on open (used in create though) */

	/* [MS-SMB2] 2.2.13 NameOffset:

	 * If SMB2_FLAGS_DFS_OPERATIONS is set in the Flags field of

	 * the SMB2 header, the file name includes a prefix that will

	 * be processed during DFS name normalization as specified in

	 * section 3.3.5.9. Otherwise, the file name is relative to

	 * the share that is identified by the TreeId in the SMB2

	 * header.

 MUST set path len (NameLength) to 0 opening root of share */

 no srv lease support */

 need to set Next field of lease context if we request it */

/* rq_iov[0] is the request and is released by cifs_small_buf_release().

 * All other vectors are freed by kfree().

 unlikely to happen, but safer to check */

 CIFS_DEBUG2 */

		/*

		 * indatalen is usually small at a couple of bytes max, so

		 * just allocate through generic pool

	/*

	 * If no input data, the size of ioctl struct in

	 * protocol spec still includes a 1 byte data buffer,

	 * but if input data passed to ioctl, we do not

	 * want to double count this, so we do not send

	 * the dummy one byte of data in iovec[0] if sending

	 * input data (in iovec[1]).

 do not set InputOffset if no input data */

 MBZ */

	/*

	 * In most cases max_response_size is set to 16K (CIFSMaxBufSize)

	 * We Could increase default MaxOutputResponse, but that could require

	 * more credits. Windows typically sets this smaller, but for some

	 * ioctls it may be useful to allow server to send more. No point

	 * limiting what the server can send as long as fits in one credit

	 * We can not handle more than CIFS_MAX_BUF_SIZE yet but may want

	 * to increase this limit up in the future.

	 * Note that for snapshot queries that servers like Azure expect that

	 * the first query be minimal size (and just used to get the number/size

	 * of previous versions) so response size must be specified as EXACTLY

	 * sizeof(struct snapshot_array) which is 16 when rounded up to multiple

	 * of eight bytes.  Currently that is the only case where we set max

	 * response size smaller.

 validate negotiate request must be signed - see MS-SMB2 3.2.5.5 */

 request */

/*

 *	SMB2 IOCTL is used for both IOCTLs and FSCTLs

 returned data len */)

 zero out returned data len, in case of error */

 check if caller wants to look at return data or just return rc */

	/*

	 * Although unlikely to be possible for rsp to be null and rc not set,

	 * adding check below is slightly safer long term (and quiets Coverity

	 * warning)

 We check for obvious errors in the output buffer length and offset */

 server returned no data */

/*

 *   Individual callers to ioctl worker function follow

 is_fsctl */,

 data input */,

 in data len */, CIFSMaxBufSize 
 out data */, NULL);

 request */

 check if need to ask server to return timestamps in close response */

		/*

		 * Note that have to subtract 4 since struct network_open_info

		 * has a final 4 byte pad that close response does not have

 retry close in a worker thread if this one is interrupted */

 check if beyond RFC1001 maximum length */

/*

 * If SMB buffer fields are valid, copy into temporary buffer to hold result.

 * Caller must free buffer.

 total_len for smb query request never close to le16 max */

 1 for Buffer */

 request */

 currently unused, as now we are doing compounding instead (see smb311_posix_query_path_info) */

 Note caller must free "data" (passed in above). It may be allocated in query_info call */

/*

 * CHANGE_NOTIFY Request is sent to get notifications on changes to a directory

 * See MS-SMB2 2.2.35 and 2.2.36

 See note 354 of MS-SMB2, 64K max */

 request */

/*

 * This is a no-op for now. We're not really interested in the reply, but

 * rather in the fact that the server sent one and that server->lstrp

 * gets updated.

 *

 * FIXME: maybe we should consider checking that the reply matches request?

 Prevent simultaneous reconnects that can corrupt tcon->rlist list */

		/*

		 * IPC has the same lifetime as its session and uses its

		 * refcount.

	/*

	 * Get the reference to server struct to be sure that the last call of

	 * cifs_put_tcon() in the loop below won't release the server pointer.

 now we can safely release srv struct */

 No need to send echo on newly established connections */

 request */

/*

 * To form a chain of read requests, any read requests after the first should

 * have the end_of_chain boolean set to true.

 reserved */

 reserved */

 reserved */

 xid */,

	/*

	 * If we want to do a RDMA write, fill in and append

	 * smbd_buffer_descriptor_v1 to the end of read request

 next 8-byte aligned request */

 END_OF_CHAIN */

			/*

			 * Related requests use info from previous read request

			 * in chain.

 result already set, check signature */

 FIXME: should this be counted toward the initiating task? */

 reset bytes number since we can not check a sign */

 FIXME: should this be counted toward the initiating task? */

	/*

	 * If this rdata has a memmory registered, the MR can be freed

	 * MR needs to be freed as soon as I/O finishes to prevent deadlock

	 * because they have limited number and are used for future I/Os

 xid */,

 xid */,

 smb2_async_readv - send an async read, and set up mid to handle result */

 xid */, io_parms.persistent_fid,

/*

 * Check the mid_state and signature on received buffer (if any), and queue the

 * workqueue completion task.

		/*

		 * Mask off high 16 bits when bytes written as returned

		 * by the server is greater than bytes requested by the

		 * client. OS/2 servers are known to set incorrect

		 * CountHigh values.

	/*

	 * If this wdata has a memory registered, the MR can be freed

	 * The number of MRs available is limited, it's important to recover

	 * used MR as soon as I/O is finished. Hold MR longer in the later

	 * I/O process can possibly result in I/O deadlock due to lack of MR

	 * to send request on I/O retry

 no xid */,

 no xid */,

 smb2_async_writev - send an async write, and set up mid to handle result */

 xid */, wdata->cfile->fid.persistent_fid,

	/*

	 * If we want to do a server RDMA read, fill in and append

	 * smbd_buffer_descriptor_v1 to the end of write request

 For RDMA read, I/O size is in RemainingBytes not in Length */

 no xid */,

/*

 * SMB2_write function gets iov pointer to kvec array with n_vec as a length.

 * The length field from io_parms must be at least 1 and indicates a number of

 * elements with data to write that begins with position 1 in iov array. All

 * data length is specified by count.

 1 for Buffer */

 if no end bound given, assume payload to be correct */

 last element will have a 0 offset, pick a sensible bound */

 check base buf */

 check owner sid */

 check group sid */

 check name len */

 check name */

/*

 * Readdir/FindFirst

	/*

	 * BB could be 30 bytes or so longer if we used SMB2 specific

	 * buffer lengths, but this is safe and close enough.

 1 for Buffer */

 request */

 note that posix payload are variable size */

 1 for Buffer */

 request */

 1 for pad */

 SPDX-License-Identifier: GPL-2.0

/*

 * Netlink routines for CIFS

 *

 * Copyright (c) 2020 Samuel Cabrero <scabrero@suse.de>

/**

 * cifs_genl_init - Register generic netlink family

 *

 * Return zero if initialized successfully, otherwise non-zero.

/**

 * cifs_genl_exit - Unregister generic netlink family

 SPDX-License-Identifier: GPL-2.0-or-later

 SPDX-License-Identifier: LGPL-2.1

/*

 *   SPNEGO upcall management for CIFS

 *

 *   Copyright (c) 2007 Red Hat, Inc.

 *   Author(s): Jeff Layton (jlayton@redhat.com)

 *

 create a new cifs key */

 attach the data */

/*

 * keytype for CIFS spnego keys

 length of longest version string e.g.  strlen("ver=0xFF") */

/* length of longest security mechanism name, eg in future could have

 strlen of "host=" */

 strlen of ";ip4=" or ";ip6=" */

 strlen of ";uid=0x" */

 strlen of ";creduid=0x" */

 strlen of ";user=" */

 strlen of ";pid=0x" */

 get a key struct with a SPNEGO security blob, suitable for session setup */

	/* length of fields (with semicolons): ver=0xyz ip4=ipaddress

 start with version and hostname portion of UNC string */

 add the server address */

 for now, only sec=krb5 and sec=mskrb5 are valid */

 CONFIG_CIFS_DEBUG2 */

	/*

	 * Create an override credential set with special thread keyring for

	 * spnego upcalls.

	/*

	 * instruct request_key() to use this special keyring as a cache for

	 * the results it looks up

 SPDX-License-Identifier: LGPL-2.1

/*

 *

 *   Copyright (C) International Business Machines  Corp., 2002, 2011

 *   Author(s): Steve French (sfrench@us.ibm.com),

 *              Pavel Shilovsky ((pshilovsky@samba.org) 2012

 *

 default timeout is 0, servers pick default (120 seconds) */

 is_fsctl */,

 no return info */);

 if open response does not have IndexNumber field - get it */

				/*

				 * let get_inode_info disable server inode

				 * numbers

	/*

	 * Accessing maxBuf is racy with cifs_reconnect - need to store value

	 * and check it before using.

			/*

			 * flock and OFD lock are associated with an open

			 * file description, not the process.

			/*

			 * We can cache brlock requests - simply remove a lock

			 * from the file's list.

		/*

		 * We need to save a lock here to let us add it again to the

		 * file's list if the unlock range request fails on the server.

				/*

				 * We failed on the unlock range request - add

				 * all locks from the tmp list to the head of

				 * the file's list.

				/*

				 * The unlock range request succeed - free the

				 * tmp list.

	/*

	 * Accessing maxBuf is racy with cifs_reconnect - need to store value

	 * and check it for zero before using.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *

 *   Copyright (c) International Business Machines  Corp., 2002,2008

 *   Author(s): Steve French (sfrench@us.ibm.com)

 *

 *   Error mapping routines from Samba libsmb/errormap.c

 *   Copyright (C) Andrew Tridgell 2001

 was EPERM */

/*	{ERRaccountexpired, -EACCES},

	{ERRbadclient, -EACCES},

	{ERRbadLogonTime, -EACCES},

/*

 * Convert a string containing text IPv4 or IPv6 address to binary form.

 *

 * Returns 0 on failure.

 calculate length by finding first slash or NULL */

/*

 * Try to convert a string to an IPv4 address and then attempt to convert

 * it to an IPv6 address if that fails. Set the family field if either

 * succeeds. If it's an IPv6 address and it has a '%' sign in it, try to

 * treat the part following it as a numeric sin6_scope_id.

 *

 * Returns 0 on failure.

 IPv4 address */

 attempt to exclude the scope ID from the address part */

 grab the scope ID */

/*****************************************************************************

convert a NT status code to a dos class/code

 NT status -> dos error map */

/*	{ This NT error code was 'sqashed'

	 from NT_STATUS_MORE_PROCESSING_REQUIRED to NT_STATUS_OK

/*	{ This NT error code was 'sqashed'

	 from NT_STATUS_ACCESS_DENIED to NT_STATUS_TRUSTED_RELATIONSHIP_FAILURE

 mapping changed since shell does lookup on * expects FileNotFound */

/*	{ This NT error code was 'sqashed'

	 from NT_STATUS_NO_SUCH_USER to NT_STATUS_LOGON_FAILURE

 could map to 2238 */

/*	{ This NT error code was 'sqashed'

	 from NT_STATUS_WRONG_PASSWORD to NT_STATUS_LOGON_FAILURE

/*	{ This NT error code was 'sqashed'

	 from NT_STATUS_INSUFFICIENT_RESOURCES to

/*	{ This NT error code was 'sqashed'

	 from NT_STATUS_NO_TRUST_SAM_ACCOUNT to

/*	{ This NT error code was 'sqashed'

	 from NT_STATUS_DOMAIN_TRUST_INCONSISTENT to NT_STATUS_LOGON_FAILURE

/*****************************************************************************

 Print an error message from the status code

 if transport error smb error may not be set */

 BB if NT Status codes - map NT BB */

 old style smb error codes */

		/* translate the newer STATUS codes to old style SMB errors

 old style errors */

 DOS class smb error codes - map DOS */

 1 byte field no need to byte reverse */

 else try next error mapping one to see if match */

 server class of error codes */

 else try next error mapping to see if match */

 else ERRHRD class errors or junk  - return EIO */

	/* generic corrective action e.g. reconnect SMB session on

 possible ERRBaduid */

 switch can be used to handle different errors */

/*

 * calculate the size of the SMB message based on the fixed header

 * portion, the number of word parameters and the data portion of the message

 size of the bcc field */ + get_bcc(ptr));

 The following are taken from fs/ntfs/util.c */

/*

 * Convert the NT UTC (based 1601-01-01, in hundred nanosecond units)

 * into Unix UTC (based 1970-01-01, in seconds).

 BB what about the timezone? BB */

 Subtract the NTFS time offset, then convert to 1s intervals. */

	/*

	 * Unfortunately can not use normal 64 bit division on 32 bit arch, but

	 * the alternative, do_div, does not work with negative numbers so have

	 * to special case them

 Convert the Unix UTC into NT UTC. */

 Convert to 100ns intervals and then add the NTFS time offset. */

 account for difference in days between 1980 and 1970 */

 leap year */

	/* generalized leap year calculation is more complex, ie no leap year

	for years/100 except for years/400, but since the maximum number for DOS

	 year is 2**7, the last year is 1980+127, which means we need only

	 consider 2 special case years, ie the years 2000 and 2100, and only

	 adjust for the lack of leap year for the year 2100, as 2000 was a

 the year 2100 */

 do not count leap year for the year 2100 */

 adjust for leap year where we are still before leap day */

 cifs_dbg(FYI, "sec after cnvrt dos to unix time %d\n",sec); */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *   Contains the CIFS DFS referral mounting routines used for handling

 *   traversal via DFS junction point

 *

 *   Copyright (c) 2007 Igor Mammedov

 *   Copyright (C) International Business Machines  Corp., 2008

 *   Author(s): Igor Mammedov (niallain@gmail.com)

 *		Steve French (sfrench@us.ibm.com)

/**

 * cifs_build_devname - build a devicename from a UNC and optional prepath

 * @nodename:	pointer to UNC string

 * @prepath:	pointer to prefixpath (or NULL if there isn't one)

 *

 * Build a new cifs devicename after chasing a DFS referral. Allocate a buffer

 * big enough to hold the final thing. Copy the UNC from the nodename, and

 * concatenate the prepath onto the end of it if there is one.

 *

 * Returns pointer to the built string, or a ERR_PTR. Caller is responsible

 * for freeing the returned string.

 skip over any preceding delimiters */

 get length of UNC and set pos to last char */

 trim off any trailing delimiters */

	/* allocate a buffer:

	 * +2 for preceding "//"

	 * +1 for delimiter between UNC and prepath

	 * +1 for trailing NULL

" */

 copy in the UNC portion from referral */

 copy the prefixpath remainder (if there is one) */

 NULL terminator */

/**

 * cifs_compose_mount_options	-	creates mount options for referral

 * @sb_mountdata:	parent/root DFS mount options (template)

 * @fullpath:		full path in UNC format

 * @ref:		optional server's referral

 * @devname:		return the built cifs device name if passed pointer not NULL

 * creates mount options for submount based on template options sb_mountdata

 * and replacing unc,ip,prefixpath options with ones we've got form ref_unc.

 *

 * Returns: pointer to new mount options or ERR_PTR.

 * Caller is responsible for freeing returned value if it is not error.

 skip initial delimiter */

	/*

	 * In most cases, we'll be building a shorter string than the original,

	 * but we do have to assume that the address in the ip= option may be

	 * much longer than the original. Add the max length of an address

	 * string to the length of the original string to allow for worst case.

 copy all options except of unc,ip,prefixpath */

 copy new IP and ref share name */

cifs_dbg(FYI, "%s: parent mountdata: %s\n", __func__, sb_mountdata);*/

cifs_dbg(FYI, "%s: submount mountdata: %s\n", __func__, mountdata );*/

/**

 * cifs_dfs_do_mount - mounts specified path using DFS full path

 *

 * Always pass down @fullpath to smb3_do_mount() so we can use the root server

 * to perform failover in case we failed to connect to the first target in the

 * referral.

 *

 * @mntpt:		directory entry for the path we are trying to automount

 * @cifs_sb:		parent/root superblock

 * @fullpath:		full path in UNC format

 TODO: change to call fs_context_for_mount(), fill in context directly, call fc_mount */

 See afs_mntpt_do_automount in fs/afs/mntpt.c for an example */

 strip first '\' from fullpath */

/*

 * Create a vfsmount that we can automount

	/*

	 * The MSDFS spec states that paths in DFS referral requests and

	 * responses must be prefixed by a single '\' character instead of

	 * the double backslashes usually used in the UNC. This function

	 * gives us the latter, so we must adjust the result.

 always use tree name prefix */

/*

 * Attempt to automount the referral

 prevent immediate expiration */

 SPDX-License-Identifier: LGPL-2.1

/*

 *

 *   Directory search handling

 *

 *   Copyright (C) International Business Machines  Corp., 2004, 2008

 *   Copyright (C) Red Hat, Inc., 2011

 *   Author(s): Steve French (sfrench@us.ibm.com)

 *

/*

 * To be safe - for UCS to UTF-8 with strings loaded with the rare long

 * characters alloc more to account for such multibyte target UTF-8

 * characters.

 DEBUG2 */

/*

 * Attempt to preload the dcache with the results from the FIND_FIRST/NEXT

 *

 * Find the dentry that matches "name". If there isn't one, create one. If it's

 * a negative dentry or the uniqueid or filetype(mode) changed,

 * then drop it and recreate it.

		/*

		 * If we know that the inode will need to be revalidated

		 * immediately, then don't create a new dentry for it.

		 * We'll end up doing an on the wire call either way and

		 * this spares us an invalidation.

			/*

			 * If we're generating inode numbers, then we don't

			 * want to clobber the existing one with the one that

			 * the readdir code created.

			/* update inode in place

	/*

	 * The DFS tags should be only intepreted by server side as per

	 * MS-FSCC 2.1.2.1, but let's include them anyway.

	 *

	 * Besides, if cf_cifstag is unset (0), then we still need it to be

	 * revalidated to know exactly what reparse point it is.

	/*

	 * The IO_REPARSE_TAG_LX_ tags originally were used by WSL but they

	 * are preferred by the Linux client in some cases since, unlike

	 * the NFS reparse tag (or EAs), they don't require an extra query

	 * to determine which type of special file they represent.

	 * TODO: go through all documented  reparse tags to see if we can

	 * reasonably map some of them to directories vs. files vs. symlinks

 TODO: should we mark some other reparse points (like DFSR) as directories? */

	/*

	 * We need to revalidate it further to make a decision about whether it

	 * is a symbolic link, DFS referral or a reparse point with a direct

	 * access like junctions, deduplicated files, NFS symlinks.

 non-unix readdir doesn't provide nlink */

	/*

	 * We of course don't get ACL info in FIND_FIRST/NEXT results, so

	 * mark it for revalidation so that "ls -l" will look right. It might

	 * be super-slow, but if we don't do this then the ownership of files

	 * may look wrong since the inodes may not have timed out by the time

	 * "ls" does a stat() call on them.

			/*

			 * trying to get the type and mode via SFU can be slow,

			 * so just call those regular files for now, and mark

			 * for reval

 Fill a cifs_fattr struct with info from SMB_FIND_FILE_POSIX_INFO. */

	/*

	 * Since we set the inode type below we need to mask off

	 * to avoid strange results if bits set above.

	 * XXX: why not make server&client use the type bits?

		/*

		 * mark anything that is not a dir as regular

		 * file. special files should have the REPARSE

		 * attribute and will be marked as needing revaluation

 See MS-FSCC 2.4.19 FileIdFullDirectoryInformation */

/* BB eventually need to add the following helper function to

      resolve NT_STATUS_STOPPED_ON_SYMLINK return code when

/*

int get_symlink_reparse_path(char *full_path, struct cifs_sb_info *cifs_sb,

			     unsigned int xid)

{

	__u16 fid;

	int len;

	int oplock = 0;

	int rc;

	struct cifs_tcon *ptcon = cifs_sb_tcon(cifs_sb);

	char *tmpbuffer;



	rc = CIFSSMBOpen(xid, ptcon, full_path, FILE_OPEN, GENERIC_READ,

			OPEN_REPARSE_POINT, &fid, &oplock, NULL,

			cifs_sb->local_nls,

			cifs_remap(cifs_sb);

	if (!rc) {

		tmpbuffer = kmalloc(maxpath);

		rc = CIFSSMBQueryReparseLinkInfo(xid, ptcon, full_path,

				tmpbuffer,

				maxpath -1,

				fid,

				cifs_sb->local_nls);

		if (CIFSSMBClose(xid, ptcon, fid)) {

			cifs_dbg(FYI, "Error closing temporary reparsepoint open\n");

		}

	}

}

 test for Unix extensions */

 but now check for them on the share/mount not on the SMB session */

 if (cap_unix(tcon->ses) { */

 not srvinos - BB fixme add check for backlevel? */ {

	/* BB add following call to handle readdir on new NTFS symlink errors

	else if STATUS_STOPPED_ON_SYMLINK

		/*

		 * If we don't have enough credits to start reading the

		 * directory just try again after short wait.

 return length of unicode string in bytes */

 validate that new_entry is not past end of SMB */

 payload should have already been checked at this point */

 one byte length, no endianess conversion */

 return 0 if no match and 1 for . (current directory) and 2 for .. (parent) */

 check for . */

 check for .. */

 ASCII */ {

/* Check if directory that we are searching has changed so we can decide

 directory was changed, perhaps due to unlink */

/*

 * Find the corresponding entry in the search. Note that the SMB server returns

 * search entries for . and .. which complicates logic here if we choose to

 * parse for them and we do not assume that they are located in the findfirst

 * return buffer. We start counting in the buffer with entry 2 and increment for

 * every entry (do not increment for . or .. entry).

 check if index in the buffer */

	/*

	 * If first entry in buf is zero then is first buffer

	 * in search response data which means it is likely . and ..

	 * will be in this buffer, although some servers do not return

	 * . and .. for the root of a drive and for those we need

	 * to start two entries earlier.

 close and restart search */

 FindFirst/Next set last_entry to NULL on malformed reply */

 FindFirst/Next set last_entry to NULL on malformed reply */

 we found the buffer that contains the entry */

 scan and find it */

 go entry by entry figuring out which is first */

 BB fixme - check if we should flag this error */

 skip . and .. since we added them first */

		/*

		 * trying to get the type and mode can be slow,

		 * so just call those regular files for now, and mark

		 * for reval

	/*

	 * Ensure FindFirst doesn't fail before doing filldir() for '.' and

	 * '..'. Otherwise we won't be able to notify VFS in case of failure.

	/* 1) If search is active,

		is in current search buffer?

		if it before then restart search

	} /* else {

		cifsFile->invalidHandle = true;

		tcon->ses->server->close(xid, tcon, &cifsFile->fid);

 evaluate whether this case is an error */

		/*

		 * if buggy server returns . and .. late do we want to

		 * check for that here?

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  SMB1 (CIFS) version specific operations

 *

 *  Copyright (c) 2012, Jeff Layton <jlayton@redhat.com>

/*

 * An NT cancel request header looks just like the original request except:

 *

 * The Command is SMB_COM_NT_CANCEL

 * The WordCount is zeroed out

 * The ByteCount is zeroed out

 *

 * This function mangles an existing request buffer into a

 * SMB_COM_NT_CANCEL request and then sends it.

 -4 for RFC1001 length and +2 for BCC field */

	/*

	 * The response to this call was already factored into the sequence

	 * number when the call went out, so we must adjust it back downward

	 * after signing here.

 It's a bug reading remaining data for SMB1 packets */

/*

 * Find a free multiplex id (SMB mid). Otherwise there could be

 * mid collisions which might cause problems, demultiplexing the

 * wrong response to this request. Multiplex ids could collide if

 * one of a series requests takes much longer than the others, or

 * if a very large number of long lived requests (byte range

 * locks or FindNotify requests) are pending. No more than

 * 64K-1 requests can be outstanding at one time. If no

 * mids are available, return zero. A future optimization

 * could make the combination of mids and uid the key we use

 * to demultiplex on (rather than mid alone).

 * In addition to the above check, the cifs demultiplex

 * code already used the command code as a secondary

 * check of the frame and if signing is negotiated the

 * response would be discarded if the mid were the same

 * but the signature was wrong. Since the mid is not put in the

 * pending queue until later (when it is about to be dispatched)

 * we do have to limit the number of outstanding requests

 * to somewhat less than 64K-1 although it is hard to imagine

 * so many threads being in the vfs at one time.

 mid is 16 bit only for CIFS/SMB */

 we do not want to loop forever */

 avoid 0xFFFF MID */

	/*

	 * This nested loop looks more expensive than it is.

	 * In practice the list of pending requests is short,

	 * fewer than 50, and the mids are likely to be unique

	 * on the first pass through the loop unless some request

	 * takes longer than the 64 thousand requests before it

	 * (and it would also have to have been a request that

	 * did not time out).

 This mid is in use, try a different one */

		/*

		 * if we have more than 32k mids in the list, then something

		 * is very wrong. Possibly a local user is trying to DoS the

		 * box by issuing long-running calls and SIGKILL'ing them. If

		 * we get to 2^16 mids then we're in big trouble as this

		 * function could loop forever.

		 *

		 * Go ahead and assign out the mid in this situation, but force

		 * an eventual reconnect to clean out the pending_mid_q.

/*

	return codes:

		0	not a transact2, or all data present

		>0	transact2 with that much data missing

		-EINVAL	invalid transact2

 check for plausible wct, bcc and t2 data and parm sizes */

 check for parm and data offset going beyond end of smb */

 coalesce_t2 depends on this */

 nothing to do, ignore */

 find end of first SMB data area */

 validate target area */

 is the result too big for the field? */

 fix up the BCC */

 is the result too big for the field? */

 don't allow buffer to overflow */

 copy second buffer into end of first buffer */

 more responses to go */

 we are done */

 merge response - fix up 1st*/

 All parts received or packet is malformed. */

FIXME: switch to already allocated largebuf?*/

 Have first buffer */

 retry only once on 1st time connection */

 start with specified wsize, or default */

 can server support 24-bit write sizes? (via UNIX extensions) */

	/*

	 * no CAP_LARGE_WRITE_X or is signing enabled without CAP_UNIX set?

	 * Limit it to max buffer offered by the server, minus the size of the

	 * WRITEX header, not including the 4 byte RFC1001 length.

 hard limit of CIFS_MAX_WSIZE */

	/*

	 * Set default value...

	 *

	 * HACK alert! Ancient servers have very small buffers. Even though

	 * MS-CIFS indicates that servers are only limited by the client's

	 * bufsize for reads, testing against win98se shows that it throws

	 * INVALID_PARAMETER errors if you try to request too large a read.

	 * OS/2 just sends back short reads.

	 *

	 * If the server doesn't advertise CAP_LARGE_READ_X, then assume that

	 * it can't handle a read request larger than its MaxBufferSize either.

	/*

	 * no CAP_LARGE_READ_X? Then MS-CIFS states that we must limit this to

	 * the client's MaxBufferSize.

 hard limit of CIFS_MAX_RSIZE */

 not legacy */, cifs_sb->local_nls,

 could do find first instead but this returns more info */

 not legacy */,

	/*

	 * BB optimize code so we do not make the above call when server claims

	 * no NT SMB support and the above call failed at least once - set flag

	 * in tcon or mount.

 Need to check if this is a symbolic link or not */

	/*

	 * We can not use the IndexNumber field by default from Windows or

	 * Samba (in ALL_INFO buf) but we can request it explicitly. The SNIA

	 * CIFS spec claims that this value is unique within the scope of a

	 * share, and the windows docs hint that it's actually unique

	 * per-machine.

	 *

	 * There may be higher info levels that work but are there Windows

	 * server or network appliances for which IndexNumber field is not

	 * guaranteed unique?

 if the file is already open for write, just use that fileid */

	/*

	 * We could add a second check for a QFS Unix capability bit

	/*

	 * Only need to call the old QFSInfo if failed on newer one,

	 * e.g. by OS/2.

	/*

	 * Some old Windows servers also do not support level 103, retry with

	 * older level one if old server failed the previous call or we

	 * bypassed it because we detected that this was an older LANMAN sess

 No DFS support */

 Check for unix extensions */

		/*

		 * SMB1 Unix Extensions: requires server support but

		 * works with all special files

 no change */

 no change */

	/*

	 * SMB1 SFU emulation: should work with all servers, but only

	 * support block and char device (no socket & fifo)

	/*

	 * BB Do not bother to decode buf since no local inode yet to put

	 * timestamps in, but we can reuse it safely.

 FIXME: add code here to set EAs */

 CIFS_XATTR */

 SPDX-License-Identifier: LGPL-2.1

/*

 *

 *   Copyright (C) International Business Machines  Corp., 2002,2008

 *   Author(s): Steve French (sfrench@us.ibm.com)

 *

/*

 * M-F Symlink Functions - Begin

 it's not a symlink */

 it's not a symlink */

 not a symlink */

 it's not a symlink */

 not a symlink */

 it's not a symlink */

 it is a symlink */

/*

 * SMB 1.0 Protocol specific functions

 it's not a symlink */

/*

 * SMB 2.1/SMB3 Protocol specific functions

 it's not a symlink */

 Is there a better rc to return? */

 iov[0] is reserved for smb header */

 Make sure we wrote all of the symlink data */

/*

 * M-F Symlink Functions - End

 force new lookup from server of target */

	/*

	 * if source file is cached (oplocked) revalidate will not go to server

	 * until the file is closed or oplock broken so update nlinks locally

			/*

			 * parent dir timestamps will update from srv within a

			 * second, would it really be worth it to set the parent

			 * dir cifs inode time to zero to force revalidate

			 * (faster) for it too?

		/*

		 * if not oplocked will force revalidate to get info on source

		 * file from srv.  Note Samba server prior to 4.2 has bug -

		 * not updating src file ctime on hardlinks but Windows servers

		 * handle it properly

		/*

		 * Will update parent dir timestamps from srv within a second.

		 * Would it really be worth it to set the parent dir (cifs

		 * inode) time field to zero to force revalidate on parent

		 * directory faster ie

		 *

		 * CIFS_I(inode)->time = 0;

	/*

	 * First try Minshall+French Symlinks, if configured

	 * and fallback to UNIX Extensions Symlinks.

 BB what if DFS and this volume is on different share? BB */

	/* else

	   rc = CIFSCreateReparseSymLink(xid, pTcon, fromName, toName,

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *   Copyright (C) 2017, Microsoft Corporation.

 *

 *   Author(s): Long Li <longli@microsoft.com>

 SMBD version number */

 Port numbers for SMBD transport */

 Address lookup and resolve timeout in ms */

 SMBD negotiation timeout in seconds */

 SMBD minimum receive size and fragmented sized defined in [MS-SMBD] */

/*

 * Default maximum number of RDMA read/write outstanding on this connection

 * This value is possibly decreased during QP creation on hardware limit

 Maximum number of retries on data transfer operations */

 No need to retry on Receiver Not Ready since SMBD manages credits */

/*

 * User configurable initial values per SMBD transport connection

 * as defined in [MS-SMBD] 3.1.1.1

 * Those may change after a SMBD negotiation

 The local peer's maximum number of credits to grant to the peer */

 The remote peer's credit request of local peer */

 The maximum single message size can be sent to remote peer */

  The maximum fragmented upper-layer payload receive size supported */

  The maximum single-message size which can be received */

 The timeout to initiate send of a keepalive message on idle */

/*

 * User configurable initial values for RDMA transport

 * The actual values used may be lower and are limited to hardware capabilities

 Default maximum number of SGEs in a RDMA write/read */

 If payload is less than this byte, use RDMA send/recv not read/write */

/* Transport logging functions

 * Logging are defined as classes. They can be OR'ed to define the actual

 * logging level via module parameter smbd_logging_class

 * e.g. cifs.smbd_logging_class=0xa0 will log all log_rdma_recv() and

 * log_rdma_event()

 Upcall from RDMA CM */

 This happenes when we fail the negotiation */

 Upcall from RDMA QP */

 Called when a RDMA send is done */

/*

 * Process a negotiation response message, according to [MS-SMBD]3.1.5.7

 * response, packet_length: the negotiation response message

 * return value: true if negotiation is a success, false if failed

 now switch to emtpy packet queue */

 Promptly send an immediate packet as defined in [MS-SMBD] 3.1.1.1 */

 Called from softirq, when recv is done */

 SMBD negotiation response */

 SMBD data transfer packet */

		/*

		 * If this is a packet with data playload place the data in

		 * reassembly queue and wake up the reading thread

			/*

			 * We have new send credits granted from remote peer

			 * If any sender is waiting for credits, unblock it

 Send a KEEP_ALIVE response right away if requested */

 e.g. if interrupted returns -ERESTARTSYS */

 e.g. if interrupted returns -ERESTARTSYS */

/*

 * Test if FRWR (Fast Registration Work Requests) is supported on the device

 * This implementation requries FRWR on RDMA read/write

 * return value: true if it is supported

/*

 * Send a negotiation request message to the peer

 * The negotiation procedure is in [MS-SMBD] 3.1.5.2 and 3.1.5.3

 * After negotiation, the transport is connected and ready for

 * carrying upper layer SMB payload

 if we reach here, post send failed */

/*

 * Extend the credits to remote peer

 * This implements [MS-SMBD] 3.1.5.9

 * The idea is that we should extend credits to remote peer as quickly as

 * it's allowed, to maintain data flow. We allocate as much receive

 * buffer as possible, and extend the receive credits to remote peer

 * return value: the new credtis being granted.

/*

 * Check if we need to send a KEEP_ALIVE message

 * The idle connection timer triggers a KEEP_ALIVE message when expires

 * SMB_DIRECT_RESPONSE_REQUESTED is set in the message flag to have peer send

 * back a response.

 * return value:

 * 1 if SMB_DIRECT_RESPONSE_REQUESTED needs to be set

 * 0: otherwise

 Post the send request */

 Reset timer for idle connection after packet is sent */

 Wait for send credits. A SMBD packet needs one credit */

 Fill in the packet header */

 Map the packet to DMA */

 If this is a packet without payload, don't send padding */

 Fill in the packet data payload */

 roll back receive credits and credits to be offered */

 roll back send credits and pending */

/*

 * Send a page

 * page: the page to send

 * offset: offset in the page to send

 * size: length in the page to send

 * remaining_data_length: remaining data to send in this payload

/*

 * Send an empty message

 * Empty message is used to extend credits to peer to for keep live

 * while there is no upper layer payload to send at the time

/*

 * Send a data buffer

 * iov: the iov array describing the data buffers

 * n_vec: number of iov array

 * remaining_data_length: remaining data to send following this packet

 * in segmented SMBD packet

/*

 * Post a receive request to the transport

 * The remote peer can only send data when a receive request is posted

 * The interaction is controlled by send/receive credit system

 Perform SMBD negotiate according to [MS-SMBD] 3.1.5.2 */

/*

 * Implement Connection.FragmentReassemblyBuffer defined in [MS-SMBD] 3.1.1.1

 * This is a queue for reassembling upper layer payload and present to upper

 * layer. All the inncoming payload go to the reassembly queue, regardless of

 * if reassembly is required. The uuper layer code reads from the queue for all

 * incoming payloads.

 * Put a received packet to the reassembly queue

 * response: the packet received

 * data_length: the size of payload in this packet

	/*

	 * Make sure reassembly_data_length is updated after list and

	 * reassembly_queue_length are updated. On the dequeue side

	 * reassembly_data_length is checked without a lock to determine

	 * if reassembly_queue_length and list is up to date

/*

 * Get the first entry at the front of reassembly queue

 * Caller is responsible for locking

 * return value: the first entry if any, NULL if queue is empty

/*

 * Get a receive buffer

 * For each remote send, we need to post a receive. The receive buffers are

 * pre-allocated in advance.

 * return value: the receive buffer, NULL if none is available

/*

 * Return a receive buffer

 * Upon returning of a receive buffer, we can post new receive and extend

 * more receive credits to remote peer. This is done immediately after a

 * receive buffer is returned.

 Preallocate all receive buffer on transport establishment */

 Implement idle connection timer [MS-SMBD] 3.1.6.2 */

 Setup the next idle timeout work */

/*

 * Destroy the transport and related RDMA and memory resources

 * Need to go through all the pending counters and make sure on one is using

 * the transport while it is destroyed

 It's not posssible for upper layer to get to reassembly */

	/*

	 * For performance reasons, memory registration and deregistration

	 * are not locked by srv_mutex. It is possible some processes are

	 * blocked on transport srv_mutex while holding memory registration.

	 * Release the transport srv_mutex to allow them to hit the failure

	 * path when sending data, and then release memory registartions.

 free mempools */

/*

 * Reconnect this SMBD connection, called from upper layer

 * return value: 0 on success, or actual error code

	/*

	 * This is possible if transport is disconnected and we haven't received

	 * notification from RDMA, but upper layer has detected timeout

 Create a SMBD connection, called by upper layer */

 Need to send IRD/ORD in private data for iWARP */

 At this point, need to a full transport shutdown */

 Try SMB_PORT if SMBD_PORT doesn't work */

/*

 * Receive data from receive reassembly queue

 * All the incoming data packets are placed in reassembly queue

 * buf: the buffer to read data into

 * size: the length of data to read

 * return value: actual data read

 * Note: this implementation copies the data from reassebmly queue to receive

 * buffers used by upper layer. This is not the optimal code path. A better way

 * to do it is to not have upper layer allocate its receive buffers but rather

 * borrow the buffer from reassembly queue, and return it after data is

 * consumed. But this will require more changes to upper layer code, and also

 * need to consider packet boundaries while they still being reassembled.

	/*

	 * No need to hold the reassembly queue lock all the time as we are

	 * the only one reading from the front of the queue. The transport

	 * may add more entries to the back of the queue at the same time

		/*

		 * Need to make sure reassembly_data_length is read before

		 * reading reassembly_queue_length and calling

		 * _get_first_reassembly. This call is lock free

		 * as we never read at the end of the queue which are being

		 * updated in SOFTIRQ as more data is received

			/*

			 * The upper layer expects RFC1002 length at the

			 * beginning of the payload. Return it to indicate

			 * the total length of the packet. This minimize the

			 * change to upper layer packet processing logic. This

			 * will be eventually remove when an intermediate

			 * transport layer is added

 move on to the next buffer? */

				/*

				 * No need to lock if we are not at the

				 * end of the queue

 Don't return any data if interrupted */

/*

 * Receive a page from receive reassembly queue

 * page: the page to read data into

 * to_read: the length of data to read

 * return value: actual data read

 make sure we have the page ready for read */

 now we can read from reassembly queue and not sleep */

/*

 * Receive data from transport

 * msg: a msghdr point to the buffer, can be ITER_KVEC or ITER_BVEC

 * return: total bytes read, or 0. SMB Direct will not do partial read.

 It's a bug in upper layer to get there */

 It's a bug in upper layer to get there */

 SMBDirect will read it all or nothing */

/*

 * Send data to transport

 * Each rqst is transported as a SMBDirect payload

 * rqst: the data to write

 * return value: 0 if successfully write, otherwise error code

	/*

	 * Add in the page array if there is one. The caller needs to set

	 * rq_tailsz to PAGE_SIZE when the buffer has multiple pages and

	 * ends at page boundary

 iov[start] is too big, break it */

 send out all remaining vecs */

 now sending pages if there are any */

	/*

	 * As an optimization, we don't wait for individual I/O to finish

	 * before sending the next one.

	 * Send them all and wait for pending send count to get to 0

	 * that means all the I/Os have been out and we are good to return

/*

 * The work queue function that recovers MRs

 * We need to call ib_dereg_mr() and ib_alloc_mr() before this MR can be used

 * again. Both calls are slow, so finish them in a workqueue. This will not

 * block I/O path.

 * There is one workqueue that recovers MRs, there is no need to lock as the

 * I/O requests calling smbd_register_mr will never update the links in the

 * mr_list.

 recover this MR entry */

 This MR is being used, don't recover it */

		/* smbdirect_mr->state is updated by this function

		 * and is read and updated by I/O issuing CPUs trying

		 * to get a MR, the call to atomic_inc_return

		 * implicates a memory barrier and guarantees this

		 * value is updated before waking up any calls to

		 * get_mr() from the I/O issuing CPUs

/*

 * Allocate MRs used for RDMA read/write

 * The number of MRs will not exceed hardware capability in responder_resources

 * All MRs are kept in mr_list. The MR can be recovered after it's used

 * Recovery is done in smbd_mr_recovery_work. The content of list entry changes

 * as MRs are used and recovered for I/O, but the list links will not change

 Allocate more MRs (2x) than hardware responder_resources */

/*

 * Get a MR from mr_list. This function waits until there is at least one

 * MR available in the list. It may access the list while the

 * smbd_mr_recovery_work is recovering the MR list. This doesn't need a lock

 * as they never modify the same places. However, there may be several CPUs

 * issueing I/O trying to get MR at the same time, mr_list_lock is used to

 * protect this situation.

	/*

	 * It is possible that we could fail to get MR because other processes may

	 * try to acquire a MR at the same time. If this is the case, retry it.

/*

 * Register memory for RDMA read/write

 * pages[]: the list of pages to register memory with

 * num_pages: the number of pages to register

 * tailsz: if non-zero, the bytes to register in the last page

 * writing: true if this is a RDMA write (SMB read), false for RDMA read

 * need_invalidate: true if this MR needs to be locally invalidated after I/O

 * return value: the MR registered, NULL if failed.

 We have at least two pages to register */

	/*

	 * There is no need for waiting for complemtion on ib_post_send

	 * on IB_WR_REG_MR. Hardware enforces a barrier and order of execution

	 * on the next ib_post_send when we actaully send I/O to remote peer

 If all failed, attempt to recover this MR by setting it MR_ERROR*/

/*

 * Deregister a MR after I/O is done

 * This function may wait if remote invalidation is not used

 * and we have to locally invalidate the buffer to prevent data is being

 * modified by remote peer after upper layer consumes it

 Need to finish local invalidation before returning */

		/*

		 * For remote invalidation, just set it to MR_INVALIDATED

		 * and defer to mr_recovery_work to recover the MR for next use

		/*

		 * Schedule the work to do MR recovery for future I/Os MR

		 * recovery is slow and don't want it to block current I/O

 SPDX-License-Identifier: GPL-2.0

/*

 *   Copyright (C) 2018, Microsoft Corporation.

 *

 *   Author(s): Steve French <stfrench@microsoft.com>

 SPDX-License-Identifier: GPL-2.0-or-later

/*

   Unix SMB/Netbios implementation.

   Version 1.9.

   SMB parameters and setup

   Copyright (C) Andrew Tridgell 1992-2000

   Copyright (C) Luke Kenneth Casson Leighton 1996-2000

   Modified by Jeremy Allison 1995.

   Copyright (C) Andrew Bartlett <abartlet@samba.org> 2002-2003

   Modified by Steve French (sfrench@us.ibm.com) 2002-2003



 following came from the other byteorder.h to avoid include conflicts */

 produce a md4 message digest from data of length n bytes */

/*

 * Creates the MD4 Hash of the users password in NT UNICODE.

 Password cannot be longer than 128 characters */

 Password must be converted to NT unicode */

 Ensure string is null terminated */

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/affs/namei.c

 *

 *  (c) 1996  Hans-Joachim Widmaier - Rewritten

 *

 *  (C) 1993  Ray Burr - Modified for Amiga FFS filesystem.

 *

 *  (C) 1991  Linus Torvalds - minix filesystem

 Simple toupper() for DOS\1 */

 International toupper() for DOS\3 ("international") */

/*

 * Note: the dentry argument is the parent dentry.

	/*

	 * 'str' is the name of an already existing dentry, so the name

	 * must be valid. 'name' must be validated first.

	/*

	 * If the names are longer than the allowed 30 chars,

	 * the excess is ignored, so their length may differ.

/*

 * NOTE! unlike strncmp, affs_match returns 1 for success, 0 for failure.

 store the real header ino in d_fsdata for faster lookups */

link to dirs disabled

case ST_LINKDIR:

 Cannot overflow */

 Unlink destination if it already exists */

 Remove header from its parent directory. */

 And insert it into the new directory with the new name. */

 TODO: move it back to old_dir, if error? */

 Remove old header from its parent directory. */

 Remove new header from its parent directory. */

 Insert old into the new directory with the new name. */

 Insert new into the old directory with the old name. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  linux/fs/affs/inode.c

 *

 *  (c) 1996  Hans-Joachim Widmaier - Rewritten

 *

 *  (C) 1993  Ray Burr - Modified for Amiga FFS filesystem.

 *

 *  (C) 1992  Eric Youngdale Modified for ISO 9660 filesystem.

 *

 *  (C) 1991  Linus Torvalds - minix filesystem

	/*

	 * Make sure all delayed rcu free inodes are flushed before we

	 * destroy cache.

 Fill in defaults */

 Silently ignore the quota options */

/* This function definitely needs to be split up. Some fine day I'll

 * hopefully have the guts to do so. Until then: sorry for the mess.

 fix remount prototype... */

 N.B. after this point s_prefix must be released */

	/* Get the size of the device in 512-byte blocks.

	 * If we later see that the partition uses bigger

	 * blocks, we will have to change it.

 Try to find root block. Its location depends on the block size. */

		/* The root block location that was calculated above is not

		 * correct if the partition size is an odd number of 512-

		 * byte blocks, which will be rounded down to a number of

		 * 1024-byte blocks, and if there were an even number of

		 * reserved blocks. Ideally, all partition checkers should

		 * report the real number of blocks of the real blocksize,

		 * but since this just cannot be done, we have to try to

		 * find the root block anyways. In the above case, it is one

		 * block behind the calculated one. So we check this one, too.

 N.B. after this point bh must be released */

 Keep super block in cache */

 Find out which kind of FS we have */

	/* Dircache filesystems are compatible with non-dircache ones

	 * when reading. As long as they aren't supported, writing is

	 * not recommended.

 set up enough so that it can read an inode */

 protect against readers */

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/affs/inode.c

 *

 *  (c) 1996  Hans-Joachim Widmaier - Rewritten

 *

 *  (C) 1993  Ray Burr - Modified for Amiga FFS filesystem.

 *

 *  (C) 1992  Eric Youngdale Modified for ISO9660 filesystem.

 *

 *  (C) 1991  Linus Torvalds - minix filesystem

 Maybe it should be controlled by mount parameter? */

inode->i_mode |= S_ISVTX;

 ... and leave ->i_op and ->i_fop pointing to empty */

 possibly free block

/*

 * Add an entry to a directory. Create the header block

 * and insert it into the hash table.

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/affs/dir.c

 *

 *  (c) 1996  Hans-Joachim Widmaier - Rewritten

 *

 *  (C) 1993  Ray Burr - Modified for Amiga FFS filesystem.

 *

 *  (C) 1992  Eric Youngdale Modified for ISO 9660 filesystem.

 *

 *  (C) 1991  Linus Torvalds - minix filesystem

 *

 *  affs directory handling functions

 *

/*

 * directories can handle most operations...

	/* If the directory hasn't changed since the last call to readdir(),

	 * we can jump directly to where we left off.

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/affs/amigaffs.c

 *

 *  (c) 1996  Hans-Joachim Widmaier - Rewritten

 *

 *  (C) 1993  Ray Burr - Amiga FFS filesystem.

 *

 *  Please send bug reports to: hjw@zvw.de

/*

 * Functions for accessing Amiga-FFS structures.

/* Insert a header block bh into the directory dir

 * caller must hold AFFS_DIR->i_hash_lock!

/* Remove a header block from its directory.

 * caller must hold AFFS_DIR->i_hash_lock!

 Remove header from link chain */

		/* we can't remove the head of the link, as its blocknr is still used as ino,

		 * so we remove the block of the first link instead.

		/*

		 * if there's a dentry for that block, make it

		 * refer to inode itself.

 Fix the link count, if bh is a normal header block without links */

/* Remove a filesystem object. If the object to be removed has

 * links to it, one of the links must be changed to inherit

 * the file or directory. As above, any inode will do.

 * The buffer will not be freed. If the header is a link, the

 * block will be marked as free.

 * This function returns a negative error number in case of

 * an error, else 0 if the inode is to be deleted or 1 if not.

		/* if we ever want to support links to dirs

		 * i_hash_lock of the inode must only be

		 * taken after some checks

/* Checksum a block, do various consistency checks and optionally return

   the blocks type number.  DATA points to the block.  If their pointers

   are non-null, *PTYPE and *STYPE are set to the primary and secondary

   block types respectively, *HASHSIZE is set to the size of the hashtable

   (which lets us calculate the block size).

/*

 * Calculate the checksum of a disk block and store it

 * at the indicated position.

	/*

	 * First, clear all RWED bits for owner, group, other.

	 * Then, recalculate them afresh.

	 *

	 * We'll always clear the delete-inhibit bit for the owner, as that is

	 * the classic single-user mode AmigaOS protection bit and we need to

	 * stay compatible with all scenarios.

	 *

	 * Since multi-user AmigaOS is an extension, we'll only set the

	 * delete-allow bit if any of the other bits in the same user class

	 * (group/other) are used.

 Classic single-user AmigaOS flags. These are inverted. */

 Multi-user extended flags. Not inverted. */

 Check if the name is valid for a affs object. */

/* This function copies name to bstr, with at most 30

 * characters length. The bstr will be prepended by

 * a length byte.

 * NOTE: The name will must be already checked by

 *       affs_check_name()!

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/affs/file.c

 *

 *  (c) 1996  Hans-Joachim Widmaier - Rewritten

 *

 *  (C) 1993  Ray Burr - Modified for Amiga FFS filesystem.

 *

 *  (C) 1992  Eric Youngdale Modified for ISO 9660 filesystem.

 *

 *  (C) 1991  Linus Torvalds - minix filesystem

 *

 *  affs regular file handling primitives

 need to recalculate linear cache, start from old size */

 fix idx and old size to new shift */

 first shrink old cache to make more space */

 fill cache to the needed index */

 unlock cache

 lock cache

 lock cache

 inline the simplest case: same extended block as last time */

 we have to do more (not inlined) */

 read the next extended block from the current one */

 we seek back to the file header block */

 allocate a new extended block */

 get previous extended block */

 check if there is an extended cache and whether it's large enough */

 every n'th key we find in the linear cache */

 maybe it's still in the associative cache */

 try to find one of the previous extended blocks */

 fall back to the linear cache */

 read all extended blocks until we find the one we need */

unlock cache

lock cache

 store it in the associative cache */

 recalculate ac_idx?

 finally read the right extended block */

unlock cache

lock cache

 release old cached extended block and store the new one */

lock cache

 store new block */

 insert first block into header block */

unlock cache

 unlock cache

 unlock cache

 Clear Archived bit on file writes, as AmigaOS would do */

		/* XXX: this probably leaves a too-big i_size in case of

		 * failure. Should really be updating i_size at write_end time

 XXX: inefficient but safe in the face of short writes */

	/*

	 * XXX: not sure if this can handle short copies (len < copied), but

	 * we don't have to, because the page should always be uptodate here,

	 * due to write_begin.

 Clear Archived bit on file writes, as AmigaOS would do */

.writepage = affs_writepage_ofs,

 Free any preallocated blocks. */

 Truncate (or enlarge) a file to the requested size. */

 lock cache

 clear linear cache */

 clear associative cache */

 unlock cache

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/affs/symlink.c

 *

 *  1995  Hans-Joachim Widmaier - Modified for affs.

 *

 *  Copyright (C) 1991, 1992  Linus Torvalds

 *

 *  affs symlink handling code

 Handle assign or volume name */

 parent dir */

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/affs/bitmap.c

 *

 *  (c) 1996 Hans-Joachim Widmaier

 *

 *  bitmap.c contains the code that handles all bitmap related stuff -

 *  block allocation, deallocation, calculation of free space.

 mark block free */

 fix checksum */

/*

 * Allocate a block in the given allocation zone.

 * Since we have to byte-swap the bitmap on little-endian

 * machines, this is rather expensive. Therefore we will

 * preallocate up to 16 blocks from the same word, if

 * possible. We are not doing preallocations in the

 * header zone, though.

if (!AFFS_I(inode)->i_last_block)

	affs_warning(sb, "affs_balloc", "no last alloc block");

 search for the next bmap buffer with free bits */

 restart search at zero */

 find an unused block in this bitmap block */

 scan the rest of the buffer */

			/* didn't find something, can only happen

			 * if scan didn't start at 0, try next bmap

 finally look for a free bit in the word */

 prealloc as much as possible within this word */

 fix checksum */

		/* Don't try read the extension if this is the last block,

		 * but we also need the right bm pointer below

 Mark unused bits in the last word as allocated */

if (old != new) {

 fix checksum */

new -= old;

old = be32_to_cpu(*(__be32 *)bh->b_data);

			//*(__be32 *)bh->b_data = cpu_to_be32(old - new);

			//mark_buffer_dirty(bh);

		//}

		/* correct offset for the bitmap count below */

		//offset++;

	}

	while (++offset < sb->s_blocksize / 4)

		((__be32 *)bh->b_data)[offset] = 0;

	((__be32 *)bh->b_data)[0] = 0;

	((__be32 *)bh->b_data)[0] = cpu_to_be32(-affs_checksum_block(sb, bh));

	mark_buffer_dirty(bh);



	/* recalculate bitmap count for last block */

	bm--;

	bm->bm_free = memweight(bh->b_data + 4, sb->s_blocksize - 4);



out:

	affs_brelse(bh);

	affs_brelse(bmap_bh);

	return res;

}



void affs_free_bitmap(struct super_block *sb)

{

	struct affs_sb_info *sbi = AFFS_SB(sb);



	if (!sbi->s_bitmap)

		return;



	affs_brelse(sbi->s_bmap_bh);

	sbi->s_bmap_bh = NULL;

	sbi->s_last_bmap = ~0;

	kfree(sbi->s_bitmap);

	sbi->s_bitmap = NULL;

}

 SPDX-License-Identifier: GPL-2.0-or-later

/* Network filesystem high-level read support.

 *

 * Copyright (C) 2021 Red Hat, Inc. All Rights Reserved.

 * Written by David Howells (dhowells@redhat.com)

/*

 * Allocate and partially initialise an I/O request structure.

/*

 * Clear the unread part of an I/O request.

/*

 * Issue a read against the cache.

 * - Eats the caller's ref on subreq.

/*

 * Fill a subrequest region with zeroes.

/*

 * Ask the netfs to issue a read request to the server for us.

 *

 * The netfs is expected to read from subreq->pos + subreq->transferred to

 * subreq->pos + subreq->len - 1.  It may not backtrack and write data into the

 * buffer prior to the transferred point as it might clobber dirty data

 * obtained from the cache.

 *

 * Alternatively, the netfs is allowed to indicate one of two things:

 *

 * - NETFS_SREQ_SHORT_READ: A short read - it will get called again to try and

 *   make progress.

 *

 * - NETFS_SREQ_CLEAR_TAIL: A short read - the rest of the buffer will be

 *   cleared.

/*

 * Release those waiting.

/*

 * Deal with the completion of writing the data to the cache.  We have to clear

 * the PG_fscache bits on the folios involved and release the caller's ref.

 *

 * May be called in softirq mode and we inherit a ref from the caller.

			/* We might have multiple writes from the same huge

			 * folio, but we mustn't unlock a folio more than once.

 If we decrement nr_wr_ops to 0, the ref belongs to us. */

/*

 * Perform any outstanding writes to the cache.  We inherit a ref from the

 * caller.

	/* We don't want terminating writes trying to wake us up whilst we're

	 * still going through the list.

 Amalgamate adjacent writes */

 If we decrement nr_wr_ops to 0, the usage ref belongs to us. */

/*

 * Unlock the folios in a read operation.  We need to set PG_fscache on any

 * folios we're going to write back before we unlock them.

	/* Walk through the pagecache and the I/O request lists simultaneously.

	 * We may have a mixture of cached and uncached sections and we only

	 * really want to write out the uncached sections.  This is slightly

	 * complicated by the possibility that we might have huge pages with a

	 * mixture inside.

/*

 * Handle a short read.

/*

 * Resubmit any short or failed operations.  Returns true if we got the rreq

 * ref back.

	/* We don't want terminating submissions trying to wake us up whilst

	 * we're still going through the list.

 If we decrement nr_rd_ops to 0, the usage ref belongs to us. */

/*

 * Check to see if the data read is still valid.

/*

 * Assess the state of a read request and decide what to do next.

 *

 * Note that we could be in an ordinary kernel thread, on a workqueue or in

 * softirq context at this point.  We inherit a ref from the caller.

/*

 * Handle the completion of all outstanding I/O operations on a read request.

 * We inherit a ref from the caller.

/**

 * netfs_subreq_terminated - Note the termination of an I/O operation.

 * @subreq: The I/O request that has terminated.

 * @transferred_or_error: The amount of data transferred or an error code.

 * @was_async: The termination was asynchronous

 *

 * This tells the read helper that a contributory I/O operation has terminated,

 * one way or another, and that it should integrate the results.

 *

 * The caller indicates in @transferred_or_error the outcome of the operation,

 * supplying a positive value to indicate the number of bytes transferred, 0 to

 * indicate a failure to transfer anything that should be retried or a negative

 * error code.  The helper will look after reissuing I/O operations as

 * appropriate and writing downloaded data to the cache.

 *

 * If @was_async is true, the caller might be running in softirq or interrupt

 * context and we can't sleep.

 If we decrement nr_rd_ops to 0, the ref belongs to us. */

/*

 * Work out what sort of subrequest the next one will be.

		/* Call out to the netfs to let it shrink the request to fit

		 * its own I/O sizes and boundaries.  If it shinks it here, it

		 * will be called again to make simultaneous calls; if it wants

		 * to make serial calls, it can indicate a short read and then

		 * we will call it again.

/*

 * Slice off a piece of a read request and submit an I/O request for it.

	/* Call out to the cache to find out what it can do with the remaining

	 * subset.  It tells us in subreq->flags what it decided should be done

	 * and adjusts subreq->len down if the subset crosses a cache boundary.

	 *

	 * Then when we hand the subset, it can choose to take a subset of that

	 * (the starts must coincide), in which case, we go around the loop

	 * again and ask it to download the next piece.

	/* Give the cache a chance to change the request parameters.  The

	 * resultant request must contain the original region.

	/* Give the netfs a chance to change the request parameters.  The

	 * resultant request must contain the original region.

	/* Expand the request if the cache wants it to start earlier.  Note

	 * that the expansion may get further extended if the VM wishes to

	 * insert THPs and the preferred start and/or end wind up in the middle

	 * of THPs.

	 *

	 * If this is the case, however, the THP size should be an integer

	 * multiple of the cache granule size, so we get a whole number of

	 * granules to deal with.

/**

 * netfs_readahead - Helper to manage a read request

 * @ractl: The description of the readahead request

 * @ops: The network filesystem's operations for the helper to use

 * @netfs_priv: Private netfs data to be retained in the request

 *

 * Fulfil a readahead request by drawing data from the cache if possible, or

 * the netfs if not.  Space beyond the EOF is zero-filled.  Multiple I/O

 * requests from different sources will get munged together.  If necessary, the

 * readahead window can be expanded in either direction to a more convenient

 * alighment for RPC efficiency or to make storage in the cache feasible.

 *

 * The calling netfs must provide a table of operations, only one of which,

 * issue_op, is mandatory.  It may also be passed a private token, which will

 * be retained in rreq->netfs_priv and will be cleaned up by ops->cleanup().

 *

 * This is usable whether or not caching is enabled.

	/* Drop the refs on the folios here rather than in the cache or

	 * filesystem.  The locks will be dropped in netfs_rreq_unlock().

 If we decrement nr_rd_ops to 0, the ref belongs to us. */

/**

 * netfs_readpage - Helper to manage a readpage request

 * @file: The file to read from

 * @folio: The folio to read

 * @ops: The network filesystem's operations for the helper to use

 * @netfs_priv: Private netfs data to be retained in the request

 *

 * Fulfil a readpage request by drawing data from the cache if possible, or the

 * netfs if not.  Space beyond the EOF is zero-filled.  Multiple I/O requests

 * from different sources will get munged together.

 *

 * The calling netfs must provide a table of operations, only one of which,

 * issue_op, is mandatory.  It may also be passed a private token, which will

 * be retained in rreq->netfs_priv and will be cleaned up by ops->cleanup().

 *

 * This is usable whether or not caching is enabled.

	/* Keep nr_rd_ops incremented so that the ref always belongs to us, and

	 * the service code isn't punted off to a random thread pool to

	 * process.

/**

 * netfs_skip_folio_read - prep a folio for writing without reading first

 * @folio: The folio being prepared

 * @pos: starting position for the write

 * @len: length of write

 *

 * In some cases, write_begin doesn't need to read at all:

 * - full folio write

 * - write that lies in a folio that is completely beyond EOF

 * - write that covers the folio from start to EOF or beyond it

 *

 * If any of these criteria are met, then zero out the unwritten parts

 * of the folio and return true. Otherwise, return false.

 Full folio write */

 pos beyond last folio in the file */

 Write that covers from the start of the folio to EOF or beyond */

/**

 * netfs_write_begin - Helper to prepare for writing

 * @file: The file to read from

 * @mapping: The mapping to read from

 * @pos: File position at which the write will begin

 * @len: The length of the write (may extend beyond the end of the folio chosen)

 * @aop_flags: AOP_* flags

 * @_folio: Where to put the resultant folio

 * @_fsdata: Place for the netfs to store a cookie

 * @ops: The network filesystem's operations for the helper to use

 * @netfs_priv: Private netfs data to be retained in the request

 *

 * Pre-read data for a write-begin request by drawing data from the cache if

 * possible, or the netfs if not.  Space beyond the EOF is zero-filled.

 * Multiple I/O requests from different sources will get munged together.  If

 * necessary, the readahead window can be expanded in either direction to a

 * more convenient alighment for RPC efficiency or to make storage in the cache

 * feasible.

 *

 * The calling netfs must provide a table of operations, only one of which,

 * issue_op, is mandatory.

 *

 * The check_write_begin() operation can be provided to check for and flush

 * conflicting writes once the folio is grabbed and locked.  It is passed a

 * pointer to the fsdata cookie that gets returned to the VM to be passed to

 * write_end.  It is permitted to sleep.  It should return 0 if the request

 * should go ahead; unlock the folio and return -EAGAIN to cause the folio to

 * be regot; or return an error.

 *

 * This is usable whether or not caching is enabled.

 Allow the netfs (eg. ceph) to flush conflicts. */

	/* If the page is beyond the EOF, we want to clear it - unless it's

	 * within the cache granule containing the EOF, in which case we need

	 * to preload the granule.

	/* Expand the request to meet caching requirements and download

	 * preferences.

 We hold the folio locks, so we can drop the references */

	/* Keep nr_rd_ops incremented so that the ref always belongs to us, and

	 * the service code isn't punted off to a random thread pool to

	 * process.

 SPDX-License-Identifier: GPL-2.0-or-later

/* Netfs support statistics

 *

 * Copyright (C) 2021 Red Hat, Inc. All Rights Reserved.

 * Written by David Howells (dhowells@redhat.com)

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2013 Trond Myklebust <Trond.Myklebust@netapp.com>

 SPDX-License-Identifier: GPL-2.0-or-later

/* getroot.c: get the root dentry for an NFS mount

 *

 * Copyright (C) 2006 Red Hat, Inc. All Rights Reserved.

 * Written by David Howells (dhowells@redhat.com)

/*

 * Set the superblock root dentry.

 * Note that this function frees the inode in case of error.

 The mntroot acts as the dummy root dentry for this superblock */

		/*

		 * Ensure that this dentry is invisible to d_find_alias().

		 * Otherwise, it may be spliced into the tree by

		 * d_splice_alias if a parent directory from the same

		 * filesystem gets mounted at a later time.

		 * This again causes shrink_dcache_for_umount_subtree() to

		 * Oops, since the test for IS_ROOT() will fail.

/*

 * get an NFS2/NFS3 root dentry from the root filehandle

 get the actual root for this mount */

	/* root dentries normally start off anonymous and get spliced in later

	 * if the dentry tree reaches them; however if the dentry already

	 * exists, we'll pick it up at this point and use it as the root

 clone lsm security options from the parent to the new sb */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2016 Trond Myklebust

 *

 * I/O and data path helper functionality.

 Call with exclusively locked inode->i_rwsem */

/**

 * nfs_start_io_read - declare the file is being used for buffered reads

 * @inode: file inode

 *

 * Declare that a buffered read operation is about to start, and ensure

 * that we block all direct I/O.

 * On exit, the function ensures that the NFS_INO_ODIRECT flag is unset,

 * and holds a shared lock on inode->i_rwsem to ensure that the flag

 * cannot be changed.

 * In practice, this means that buffered read operations are allowed to

 * execute in parallel, thanks to the shared lock, whereas direct I/O

 * operations need to wait to grab an exclusive lock in order to set

 * NFS_INO_ODIRECT.

 * Note that buffered writes and truncates both take a write lock on

 * inode->i_rwsem, meaning that those are serialised w.r.t. the reads.

 Be an optimist! */

 Slow path.... */

/**

 * nfs_end_io_read - declare that the buffered read operation is done

 * @inode: file inode

 *

 * Declare that a buffered read operation is done, and release the shared

 * lock on inode->i_rwsem.

/**

 * nfs_start_io_write - declare the file is being used for buffered writes

 * @inode: file inode

 *

 * Declare that a buffered read operation is about to start, and ensure

 * that we block all direct I/O.

/**

 * nfs_end_io_write - declare that the buffered write operation is done

 * @inode: file inode

 *

 * Declare that a buffered write operation is done, and release the

 * lock on inode->i_rwsem.

 Call with exclusively locked inode->i_rwsem */

/**

 * nfs_start_io_direct - declare the file is being used for direct i/o

 * @inode: file inode

 *

 * Declare that a direct I/O operation is about to start, and ensure

 * that we block all buffered I/O.

 * On exit, the function ensures that the NFS_INO_ODIRECT flag is set,

 * and holds a shared lock on inode->i_rwsem to ensure that the flag

 * cannot be changed.

 * In practice, this means that direct I/O operations are allowed to

 * execute in parallel, thanks to the shared lock, whereas buffered I/O

 * operations need to wait to grab an exclusive lock in order to clear

 * NFS_INO_ODIRECT.

 * Note that buffered writes and truncates both take a write lock on

 * inode->i_rwsem, meaning that those are serialised w.r.t. O_DIRECT.

 Be an optimist! */

 Slow path.... */

/**

 * nfs_end_io_direct - declare that the direct i/o operation is done

 * @inode: file inode

 *

 * Declare that a direct I/O operation is done, and release the shared

 * lock on inode->i_rwsem.

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  linux/fs/nfs/super.c

 *

 *  Copyright (C) 1992  Rick Sladkey

 *

 *  nfs superblock handling functions

 *

 *  Modularised by Alan Cox <alan@lxorguk.ukuu.org.uk>, while hacking some

 *  experimental NFS changes. Modularisation taken straight from SYS5 fs.

 *

 *  Change to nfs_read_super() to permit NFS mounts to multi-homed hosts.

 *  J.S.Peatfield@damtp.cam.ac.uk

 *

 *  Split from inode.c by David Howells <dhowells@redhat.com>

 *

 * - superblocks are indexed on server only - all inodes, dentries, etc. associated with a

 *   particular server are held in the same superblock

 * - NFS superblocks can have several effective roots to the dentry tree

 * - directory type roots are spliced into the tree when a path from one root reaches the root

 *   of another (see nfs_lookup())

 CONFIG_NFS_V4_2 */

/*

 * Register the NFS filesystems

/*

 * Unregister the NFS filesystems

/*

 * Deliver file system statistics to userspace

	/*

	 * Current versions of glibc do not correctly handle the

	 * case where f_frsize != f_bsize.  Eventually we want to

	 * report the value of wtmult in this field.

	/*

	 * On most *nix systems, f_blocks, f_bfree, and f_bavail

	 * are reported in units of f_frsize.  Linux hasn't had

	 * an f_frsize field in its statfs struct until recently,

	 * thus historically Linux's sys_statfs reports these

	 * fields in units of f_bsize.

/*

 * Map the security flavour number to a name

 update NFS_AUTH_INFO_MAX_FLAVORS when this list changes! */

/*

 * Describe the mount options in force on this server representation

/*

 * Describe the mount options on this VFS mountpoint

/*

 * Present statistical information for this VFS mountpoint

	/*

	 * Display all mount option settings

	/*

	 * Display security flavor in effect for this mount

	/*

	 * Display superblock I/O counters

/*

 * Begin unmount by attempting to remove all automounted mountpoints we added

 * in response to xdev traversals and referrals

 -EIO all pending I/O */

/*

 * Return true if 'match' is in auth_info or auth_info is empty.

 * Return false otherwise.

/*

 * Ensure that a specified authtype in ctx->auth_info is supported by

 * the server. Returns 0 and sets ctx->selected_flavor if it's ok, and

 * -EACCES if not.

	/*

	 * If the sec= mount option is used, the specified flavor or AUTH_NULL

	 * must be in the list returned by the server.

	 *

	 * AUTH_NULL has a special meaning when it's in the server list - it

	 * means that the server will ignore the rpc creds, so any flavor

	 * can be used but still use the sec= that was specified.

	 *

	 * Note also that the MNT procedure in MNTv1 does not return a list

	 * of supported security flavors. In this case, nfs_mount() fabricates

	 * a security flavor list containing just AUTH_NULL.

/*

 * Use the remote server's MOUNT service to request the NFS file handle

 * corresponding to the provided path.

	/*

	 * Construct the mount server's address.

	/*

	 * Now ask the mount server to map our export path

	 * to a file handle.

	/*

	 * Was a sec= authflavor specified in the options? First, verify

	 * whether the server supports it, and then just try to use it if so.

	/*

	 * No sec= option was provided. RFC 2623, section 2.7 suggests we

	 * SHOULD prefer the flavor listed first. However, some servers list

	 * AUTH_NULL first. Avoid ever choosing AUTH_NULL.

	/*

	 * Nothing we tried so far worked. At this point, give up if we've

	 * already tried AUTH_UNIX or if the server's list doesn't contain

	 * AUTH_NULL

 Last chance! Try AUTH_UNIX */

	/*

	 * Userspace mount programs that send binary options generally send

	 * them populated with default values. We have no way to know which

	 * ones were explicitly specified. Fall back to legacy behavior and

	 * just return success.

	/*

	 * noac is a special case. It implies -o sync, but that's not

	 * necessarily reflected in the mtab options. reconfigure_super

	 * will clear SB_SYNCHRONOUS if -o sync wasn't specified in the

	 * remount options, so we have to explicitly reset it.

 compare new mount options with old ones */

/*

 * Finish setting up an NFS superblock

		/* The VFS shouldn't apply the umask to mode bits. We will do

		 * so ourselves when necessary.

 We probably want something more informative here */

 Note: NFS_MOUNT_UNSHARED == NFS4_MOUNT_UNSHARED */

 -o noac implies -o sync */

 Get a superblock - note that we may end up sharing one that already exists */

 initial superblock/root creation */

/*

 * Destroy an NFS2/3 superblock

/*

 * NFS v4 module parameters need to stay in the

 * NFS client for backwards compatibility

 Default cache timeout is 10 minutes */

 Turn off NFSv4 uid/gid mapping when using AUTH_SYS */

 CONFIG_NFS_V4 */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * linux/fs/nfs/write.c

 *

 * Write file data over NFS.

 *

 * Copyright (C) 1996, 1997, Olaf Kirch <okir@monad.swb.de>

/*

 * Local function declarations

		/* It is OK to do some reclaim, not no safe to wait

		 * for anything to be returned to the pool.

		 * mempool_alloc() cannot handle that particular combination,

		 * so we need two separate attempts.

/*

 * nfs_page_find_head_request_locked - find head request associated with @page

 *

 * must be called while holding the inode lock.

 *

 * returns matching head request with reference held, or NULL if not found.

/*

 * nfs_page_find_head_request - find head request associated with @page

 *

 * returns matching head request with reference held, or NULL if not found.

 Ensure that nobody removed the request before we locked it */

 Adjust the file length if we're writing beyond the end */

 A writeback failed: mark the page as bad, and invalidate the page cache */

 Force file size revalidation */

/*

 * nfs_page_group_search_locked

 * @head - head request of page group

 * @page_offset - offset into page

 *

 * Search page group with head @head to find a request that contains the

 * page offset @page_offset.

 *

 * Returns a pointer to the first matching nfs request, or NULL if no

 * match is found.

 *

 * Must be called with the page group lock held

/*

 * nfs_page_group_covers_page

 * @head - head request of page group

 *

 * Return true if the page group with head @head covers the whole page,

 * returns false otherwise

/* We can set the PG_uptodate flag if we see that a write request

 * covers the full page.

/*

 * NFS congestion control

/*

 * nfs_destroy_unlinked_subrequests - destroy recently unlinked subrequests

 *

 * @destroy_list - request list (using wb_this_page) terminated by @old_head

 * @old_head - the old head of the list

 *

 * All subrequests must be locked and removed from all lists, so at this point

 * they are only "active" in this function, and possibly in nfs_wait_on_request

 * with a reference held by some other context.

 Note: lock subreq in order to change subreq->wb_head */

 make sure old group is not used */

 Note: races with nfs_page_group_destroy() */

 Check if we raced with nfs_page_group_destroy() */

		/* subreq is now totally disconnected from page group or any

/*

 * nfs_join_page_group - destroy subrequests of the head req

 * @head: the page used to lookup the "page group" of nfs_page structures

 * @inode: Inode to which the request belongs.

 *

 * This function joins all sub requests to the head request by first

 * locking all requests in the group, cancelling any pending operations

 * and finally updating the head request to cover the whole range covered by

 * the (former) group.  All subrequests are removed from any write or commit

 * lists, unlinked from the group and destroyed.

 Subrequests should always form a contiguous range */

 Set the head request's range to cover the former page group */

	/* Now that all requests are locked, make sure they aren't on any list.

 unlink subrequests from head, destroy them later */

 destroy list will be terminated by head */

/*

 * nfs_lock_and_join_requests - join all subreqs to the head req

 * @page: the page used to lookup the "page group" of nfs_page structures

 *

 * This function joins all sub requests to the head request by first

 * locking all requests in the group, cancelling any pending operations

 * and finally updating the head request to cover the whole range covered by

 * the (former) group.  All subrequests are removed from any write or commit

 * lists, unlinked from the group and destroyed.

 *

 * Returns a locked, referenced pointer to the head request - which after

 * this call is guaranteed to be the only request associated with the page.

 * Returns NULL if no requests are found for @page, or a ERR_PTR if an

 * error was encountered.

	/*

	 * A reference is taken only on the head request which acts as a

	 * reference to the whole page group - the group will not be destroyed

	 * until the head reference is released.

 lock each request in the page group */

/*

 * Find an associated nfs write request, and prepare to flush it out

 * May return an error if the user signalled nfs_wait_on_request().

 If there is a fatal error that covers this write, just exit */

		/*

		 * Remove the problematic req upon fatal errors on the server

/*

 * Write an mmapped page to the server.

/*

 * Insert a write request into an inode

 Lock the request! */

	/*

	 * Swap-space should not get truncated. Hence no need to plug the race

	 * with invalidate/truncate.

	/* this a head request for a page group - mark it as having an

	 * extra reference so sub groups can follow suit.

	 * This flag also informs pgio layer when to bump nrequests when

/*

 * Remove a write request from an inode

/*

 * nfs_page_search_commits_for_head_request_locked

 *

 * Search through commit lists on @inode for the head request for @page.

 * Must be called while holding the inode (which is cinfo) lock.

 *

 * Returns the head request if found, or NULL if not found.

 search through pnfs commit lists */

 Linearly search the commit list for the correct request */

/**

 * nfs_request_add_commit_list_locked - add request to a commit list

 * @req: pointer to a struct nfs_page

 * @dst: commit list head

 * @cinfo: holds list lock and accounting info

 *

 * This sets the PG_CLEAN bit, updates the cinfo count of

 * number of outstanding requests requiring a commit as well as

 * the MM page stats.

 *

 * The caller must hold NFS_I(cinfo->inode)->commit_mutex, and the

 * nfs_page lock.

/**

 * nfs_request_add_commit_list - add request to a commit list

 * @req: pointer to a struct nfs_page

 * @cinfo: holds list lock and accounting info

 *

 * This sets the PG_CLEAN bit, updates the cinfo count of

 * number of outstanding requests requiring a commit as well as

 * the MM page stats.

 *

 * The caller must _not_ hold the cinfo->lock, but must be

 * holding the nfs_page lock.

/**

 * nfs_request_remove_commit_list - Remove request from a commit list

 * @req: pointer to a nfs_page

 * @cinfo: holds list lock and accounting info

 *

 * This clears the PG_CLEAN bit, and updates the cinfo's count of

 * number of outstanding requests requiring a commit

 * It does not update the MM page stats.

 *

 * The caller _must_ hold the cinfo->lock and the nfs_page lock.

/*

 * Add a request to the inode's commit list.

 Called holding the request lock on @req */

 Reset wb_nio, since the write was successful. */

 NFS_I(cinfo->inode)->commit_mutex held by caller */

/*

 * nfs_scan_commit - Scan an inode for commit requests

 * @inode: NFS inode to scan

 * @dst: mds destination list

 * @cinfo: mds and ds lists of reqs ready to commit

 *

 * Moves requests from the inode's 'commit' request list.

 * The requests are *not* checked to ensure that they form a contiguous set.

/*

 * Search for an existing write request, and attempt to update

 * it to reflect a new dirty region on a given page.

 *

 * If the attempt fails, then the existing request is flushed out

 * to disk.

	/*

	 * Tell the caller to flush out the request if

	 * the offsets are non-contiguous.

	 * Note: nfs_flush_incompatible() will already

	 * have flushed out requests having wrong owners.

 Okay, the request matches. Update the region */

	/*

	 * Note: we mark the request dirty here because

	 * nfs_lock_and_join_requests() cannot preserve

	 * commit flags, so we have to replay the write.

/*

 * Try to update an existing write request, or create one if there is none.

 *

 * Note: Should always be called with the Page Lock held to prevent races

 * if we have to add a new request. Also assumes that the caller has

 * already called nfs_flush_incompatible() if necessary.

 Update file length */

	/*

	 * Look for a request corresponding to this page. If there

	 * is one, and it belongs to another file, we flush it out

	 * before we try to copy anything into the page. Do this

	 * due to the lack of an ACCESS-type call in NFSv2.

	 * Also do the same if we find a request from an existing

	 * dropped page.

/*

 * Avoid buffered writes when a open context credential's key would

 * expire soon.

 *

 * Returns -EACCES if the key will expire within RPC_KEY_EXPIRE_FAIL.

 *

 * Return 0 and set a credential flag which triggers the inode to flush

 * and performs  NFS_FILE_SYNC writes if the key will expired within

 * RPC_KEY_EXPIRE_TIMEO.

 Already expired! */

/*

 * Test if the open context credential key is marked to expire soon.

/*

 * If the page cache is marked as unsafe or invalid, then we can't rely on

 * the PageUptodate() flag. In this case, we will need to turn off

 * write optimisations that depend on the page contents being correct.

/* If we know the page is up to date, and we're not using byte range locks (or

 * if we have the whole file locked for writing), it may be more efficient to

 * extend the write to cover the entire page in order to avoid fragmentation

 * inefficiencies.

 *

 * If the file is opened for synchronous writes then we can just skip the rest

 * of the checks.

 Check to see if there are whole file write locks */

/*

 * Update and possibly write a cached page of an NFS file.

 *

 * XXX: Keep an eye on generic_file_read to make sure it doesn't do bad

 * things with a page scheduled for an RPC call (e.g. invalidate it).

/* If a nfs_flush_* function fails, it should remove reqs from @head and

 * call this on each, which will prepare them to be retried on next

 * writeback using standard nfs.

 Bump the transmission count */

/*

 * Special version of should_remove_suid() that ignores capabilities.

 suid always must be killed */

	/*

	 * sgid without any exec bits is just a mandatory locking mark; leave

	 * it alone.  If some exec bits are set, it's a real sgid; kill it.

 Set attribute barrier */

 ...and update size */

/*

 * This function is called when the WRITE call is complete.

	/*

	 * ->write_done will attempt to use post-op attributes to detect

	 * conflicting writes by other clients.  A strict interpretation

	 * of close-to-open would allow us to continue caching even if

	 * another writer had changed the file, but some applications

	 * depend on tighter cache coherency when writing.

		/* We tried a write call, but the server did not

		 * commit data to stable storage even though we

		 * requested it.

		 * Note: There is a known bug in Tru64 < 5.0 in which

		 *	 the server reports NFS_DATA_SYNC, but performs

		 *	 NFS_FILE_SYNC. We therefore implement this checking

		 *	 as a dprintk() in order to avoid filling syslog.

 Note this will print the MDS for a DS write */

 Deal with the suid/sgid bit corner case */

/*

 * This function is called when the WRITE call is complete.

 This a short write! */

 Has the server at least made some progress? */

 For non rpc-based layout drivers, retry-through-MDS */

 Was this an NFSv2 write or an NFSv3 stable write? */

 Resend from where the server left off */

			/* Resend as a stable write in order to avoid

			 * headaches in the case of a server crash.

 Set up the initial task struct.  */

/*

 * Set up the argument/result storage required for the RPC call.

	/* Set up the RPC argument and reply structs

 reference transferred */

 only set lwb for pnfs commit */

 Note: we always request a commit of the entire inode */

/*

 * Commit dirty pages

 another commit raced with us */

 Set up the argument struct */

/*

 * COMMIT call returned

 Call the NFS version-specific code */

		/* Okay, COMMIT succeeded, apparently. Check the verifier

 We have a match */

 We have a mismatch. Write the page again */

 Latency breaker */

 no commits means nothing needs to be done */

		/* Don't commit yet if this is a non-blocking flush and there

		 * are a lot of outstanding writes for this mapping.

 don't wait for the COMMIT response */

/*

 * Wrapper for filemap_write_and_wait_range()

 *

 * Needed for pNFS in order to ensure data becomes visible to the

 * client.

/*

 * flush the inode to disk.

	/* blocking call to cancel all requests and join to a single (head)

		/* all requests from this page have been cancelled by

		 * nfs_lock_and_join_requests, so just remove the head

		 * request from the inode / page_private pointer and

/*

 * Write back all requests on one page - we do this before reading it.

	/*

	 * If PagePrivate is set, then the page is currently associated with

	 * an in-progress read or write request. Don't try to migrate it.

	 *

	 * FIXME: we could do this in principle, but we'll need a way to ensure

	 *        that we can safely release the inode reference while holding

	 *        the page lock.

	/*

	 * NFS congestion size, scale with available memory.

	 *

	 *  64MB:    8192k

	 * 128MB:   11585k

	 * 256MB:   16384k

	 * 512MB:   23170k

	 *   1GB:   32768k

	 *   2GB:   46340k

	 *   4GB:   65536k

	 *   8GB:   92681k

	 *  16GB:  131072k

	 *

	 * This allows larger machines to have larger/more transfers.

	 * Limit the default to 256M

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2013 Trond Myklebust <Trond.Myklebust@netapp.com>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * linux/fs/nfs/fs_context.c

 *

 * Copyright (C) 1992 Rick Sladkey

 * Conversion to new mount api Copyright (C) David Howells

 *

 * NFS mount handling.

 *

 * Split from fs/nfs/super.c by David Howells <dhowells@redhat.com>

/*

 * Sanity-check a server address provided by the mount command.

 *

 * Address family must be initialized, and address must not be

 * the ANY address for that family.

/*

 * Sanity check the NFS transport protocol.

/*

 * For text based NFSv2/v3 mounts, the mount protocol transport default

 * settings should depend upon the specified NFS transport.

/*

 * Add 'flavor' to 'auth_info' if not already present.

 * Returns true if 'flavor' ends up in the list, false otherwise

 make sure this flavor isn't already in the list */

/*

 * Parse the value of the 'sec=' option.

		/* Backward compatibility option. In future,

		 * the mount program should always supply

		 * a NFSv4 minor version number.

/*

 * Parse a single mount parameter.

		/*

		 * boolean options:  foo/nofoo

 for side protocols */

		/*

		 * options that take numeric values

		/*

		 * options that take text values

 vector side protocols to TCP */

 not used for side protocols */

		/*

		 * Special options

/*

 * Split fc->source into "hostname:export_path".

 *

 * The leftmost colon demarks the split between the server's hostname

 * and the export path.  If the hostname starts with a left square

 * bracket, then it may contain colons.

 *

 * Note: caller frees hostname and export path, even on error.

 Is the host name protected with square brakcets? */

 kill possible hostname list: not supported */

 N.B. caller will free nfs_server.hostname in all cases */

/*

 * Parse monolithic NFS2/NFS3 mount data

 * - fills in the mount root filehandle

 *

 * For option strings, user space handles the following behaviors:

 *

 * + DNS: mapping server host name to IP address ("addr=" option)

 *

 * + failure mode: how to behave if a mount request can't be handled

 *   immediately ("fg/bg" option)

 *

 * + retry: how often to retry a mount request ("retry=" option)

 *

 * + breaking back: trying proto=udp after proto=tcp, v2 after v3,

 *   mountproto=tcp after mountproto=udp, and so on

 Turn off security negotiation */

		/*

		 * for proto == XPRT_TRANSPORT_UDP, which is what uses

		 * to_exponential, implying shift: limit the shift value

		 * to BITS_PER_LONG (majortimeo is unsigned long)

 this will be UDP */

 shift value is too large */

		/*

		 * Translate to nfs_fs_context, which nfs_fill_super

		 * can deal with.

 N.B. caller will free nfs_server.hostname in all cases */

		/*

		 * The legacy version 6 binary mount data from userspace has a

		 * field used only to transport selinux information into the

		 * kernel.  To continue to support that functionality we

		 * have a touch of selinux knowledge here in the NFS code. The

		 * userspace code converted context=blah to just blah so we are

		 * converting back to the full string selinux understands.

 copy the fields backwards */

/*

 * Validate NFSv4 mount options

	/*

	 * Translate to nfs_fs_context, which nfs_fill_super

	 * can deal with.

/*

 * Parse a monolithic block of data from sys_mount().

/*

 * Validate the preparsed information in the config.

 Check for sanity first. */

	/* Verify that any proto=/mountproto= options match the address

	 * families in the addr=/mountaddr= options.

 Load the NFS protocol module if we haven't done so yet */

 Ensure the filesystem context has the correct fs_type */

/*

 * Create an NFS superblock by the appropriate method.

/*

 * Handle duplication of a configuration.  The caller copied *src into *sc, but

 * it can't deal with resource pointers in the filesystem context, so we have

 * to do that.  We need to clear pointers, copy data or get extra refs as

 * appropriate.

/*

 * Prepare superblock configuration.  We use the namespaces attached to the

 * context.  This may be the current process's namespaces, or it may be a

 * container's namespaces.

 reconfigure, start with the current config */

 defaults */

 CONFIG_NFS_V4 */

 SPDX-License-Identifier: GPL-2.0-or-later

/* NFS FS-Cache index structure definition

 *

 * Copyright (C) 2008 Red Hat, Inc. All Rights Reserved.

 * Written by David Howells (dhowells@redhat.com)

/*

 * Define the NFS filesystem for FS-Cache.  Upon registration FS-Cache sticks

 * the cookie for the top-level index object for NFS into here.  The top-level

 * index can than have other cache objects inserted into it.

/*

 * Register NFS for caching

/*

 * Unregister NFS for caching

/*

 * Define the server object for FS-Cache.  This is used to describe a server

 * object to fscache_acquire_cookie().  It is keyed by the NFS protocol and

 * server address parameters.

/*

 * Define the superblock object for FS-Cache.  This is used to describe a

 * superblock object to fscache_acquire_cookie().  It is keyed by all the NFS

 * parameters that might cause a separate superblock.

/*

 * Consult the netfs about the state of an object

 * - This function can be absent if the index carries no state data

 * - The netfs data from the cookie being used as the target is

 *   presented, as is the auxiliary data

/*

 * Get an extra reference on a read context.

 * - This function can be absent if the completion function doesn't require a

 *   context.

 * - The read context is passed back to NFS in the event that a data read on the

 *   cache fails with EIO - in which case the server must be contacted to

 *   retrieve the data, which requires the read context for security.

/*

 * Release an extra reference on a read context.

 * - This function can be absent if the completion function doesn't require a

 *   context.

/*

 * Define the inode object for FS-Cache.  This is used to describe an inode

 * object to fscache_acquire_cookie().  It is keyed by the NFS file handle for

 * an inode.

 *

 * Coherency is managed by comparing the copies of i_size, i_mtime and i_ctime

 * held in the cache auxiliary data for the data storage object with those in

 * the inode struct in memory.

/*

 *  pNFS functions to call and manage layout drivers.

 *

 *  Copyright (c) 2002 [year of first publication]

 *  The Regents of the University of Michigan

 *  All Rights Reserved

 *

 *  Dean Hildebrand <dhildebz@umich.edu>

 *

 *  Permission is granted to use, copy, create derivative works, and

 *  redistribute this software and such derivative works for any purpose,

 *  so long as the name of the University of Michigan is not used in

 *  any advertising or publicity pertaining to the use or distribution

 *  of this software without specific, written prior authorization. If

 *  the above copyright notice or any other identification of the

 *  University of Michigan is included in any copy of any portion of

 *  this software, then the disclaimer below must also be included.

 *

 *  This software is provided as is, without representation or warranty

 *  of any kind either express or implied, including without limitation

 *  the implied warranties of merchantability, fitness for a particular

 *  purpose, or noninfringement.  The Regents of the University of

 *  Michigan shall not be liable for any damages, including special,

 *  indirect, incidental, or consequential damages, with respect to any

 *  claim arising out of or in connection with the use of the software,

 *  even if it has been or is hereafter advised of the possibility of

 *  such damages.

/* Locking:

 *

 * pnfs_spinlock:

 *      protects pnfs_modules_tbl.

/*

 * pnfs_modules_tbl holds all pnfs modules

 Return the registered pnfs layout driver module matching given id */

 Decrement the MDS count. Purge the deviceid cache if zero */

/*

 * When the server sends a list of layout types, we choose one in the order

 * given in the list below.

 *

 * FIXME: should this list be configurable in some fashion? module param?

 * 	  mount option? something else?

/*

 * Try to set the server's pnfs module to the pnfs layout type specified by id.

 * Currently only one pNFS layout driver per filesystem is supported.

 *

 * @ids array of layout types supported by MDS.

 Bump the MDS count */

/*

 * pNFS client layout cache

 Need to hold i_lock if caller does not already hold reference */

 Reset MDS Threshold I/O counters */

 Notify pnfs_destroy_layout_final() that we're done */

/*

 * Compare 2 layout stateid sequence ids, to see which is newer,

 * taking into account wraparound issues.

	/*

	 * We must set lo->plh_return_seq to avoid livelocks with

	 * pnfs_layout_need_return()

/*

 * Update the seqid of a layout stateid after receiving

 * NFS4ERR_OLD_STATEID

 Is our call using the most recent seqid? If so, bump it */

 Try to update the seqid to the most recent */

/*

 * Mark a pnfs_layout_hdr and all associated layout segments as invalid

 *

 * In order to continue using the pnfs_layout_hdr, a full recovery

 * is required.

 * Note that caller must hold inode->i_lock.

 It is time to retry the failed layoutgets */

 Matched by pnfs_get_layout_hdr in pnfs_layout_insert_lseg */

/*

 * is l2 fully contained in l1?

 *   start1                             end1

 *   [----------------------------------)

 *           start2           end2

 *           [----------------)

 Returns 1 if lseg is removed from list, 0 otherwise */

		/* Remove the reference keeping the lseg in the

		 * list.  It will now be removed when all

		 * outstanding io is finished.

/**

 * pnfs_mark_matching_lsegs_invalid - tear down lsegs or mark them for later

 * @lo: layout header containing the lsegs

 * @tmp_list: list head where doomed lsegs should go

 * @recall_range: optional recall range argument to match (may be NULL)

 * @seq: only invalidate lsegs obtained prior to this sequence (may be 0)

 *

 * Walk the list of lsegs in the layout header, and tear down any that should

 * be destroyed. If "recall_range" is specified then the segment must match

 * that range. If "seq" is non-zero, then only match segments that were handed

 * out at or before that sequence.

 *

 * Returns number of matching invalid lsegs remaining in list after scanning

 * it and purging them.

 note free_me must contain lsegs from a single layout_hdr */

 Caller must hold rcu_read_lock and clp->cl_lock */

 If the sb is being destroyed, just bail */

 Free all lsegs that are attached to commit buckets */

/*

 * Called by the state manager to remove all layouts established under an

 * expired lease.

 update lo->plh_stateid with new if is more recent */

	/*

	 * Because of wraparound, we want to keep the barrier

	 * "close" to the current seqids. We really only want to

	 * get here from a layoutget call.

 lget is set to 1 if called from inside send_layoutget call chain */

 Don't confuse uninitialised result and success */

 Serialise LAYOUTGET/LAYOUTRETURN */

 Return true if layoutreturn is needed */

 Send an async layoutreturn so we dont deadlock */

/*

 * Initiates a LAYOUTRETURN(FILE), and removes the pnfs_layout_hdr

 * when the layout segment list is empty.

 *

 * Note that a pnfs_layout_hdr can exist with an empty layout segment

 * list when LAYOUTGET has failed, or when LAYOUTGET succeeded, but the

 * deviceid is marked invalid.

 Reference matched in nfs4_layoutreturn_release */

 Is there an outstanding layoutreturn ? */

 Don't send a LAYOUTRETURN if list was initially empty */

 Block new layoutgets and read/write to ds */

 no roc if we hold a delegation */

 Don't return layout if there is open file state */

 If we are sending layoutreturn, invalidate all valid lsegs */

		/*

		 * Note: mark lseg for return so pnfs_layout_remove_lseg

		 * doesn't invalidate the layout for us.

	/* ROC in two conditions:

	 * 1. there are ROC lsegs

	 * 2. we don't send layoutreturn

 lo ref dropped in pnfs_roc_release() */

 If the creds don't match, we can't compound the layoutreturn */

 Handle Layoutreturn errors */

 Was there an RPC level error? If not, retry */

 If the call was not sent, let caller handle it */

		/*

		 * Otherwise, assume the call succeeded and

		 * that we need to release the layout

 Let the caller handle the retry */

	/* we might not have grabbed lo reference. so need to check under

/*

 * Compare two layout segments for sorting into layout cache.

 * We want to preferentially return RW over RO layouts, so ensure those

 * are seen first.

 high offset > low offset */

 short length > long length */

 read > read/write */

 Won the race? */

/*

 * iomode matching rules:

 * iomode	lseg	strict match

 *                      iomode

 * -----	-----	------ -----

 * ANY		READ	N/A    true

 * ANY		RW	N/A    true

 * RW		READ	N/A    false

 * RW		RW	N/A    true

 * READ		READ	N/A    true

 * READ		RW	true   false

 * READ		RW	false  true

 range1 covers only the first byte in the range */

/*

 * lookup range in layout

/*

 * Use mdsthreshold hints set at each OPEN to determine if I/O should go

 * to the MDS or over pNFS

 *

 * The nfs_inode read_io and write_io fields are cumulative counters reset

 * when there are no layout segments. Note that in pnfs_update_layout iomode

 * is set to IOMODE_READ for a READ request, and set to IOMODE_RW for a

 * WRITE request.

 *

 * A return of true means use MDS I/O.

 *

 * From rfc 5661:

 * If a file's size is smaller than the file size threshold, data accesses

 * SHOULD be sent to the metadata server.  If an I/O request has a length that

 * is below the I/O size threshold, the I/O SHOULD be sent to the metadata

 * server.  If both file size and I/O size are provided, the client SHOULD

 * reach or exceed  both thresholds before sending its read or write

 * requests to the data server.

	/*

	 * send layoutcommit as it can hold up layoutreturn due to lseg

	 * reference

		/* The lo must be on the clp list if there is any

		 * chance of a CB_LAYOUTRECALL(FILE) coming in.

/*

 * Layout segment is retreived from the server if not cached.

 * The appropriate layout segment is referenced and returned to the caller.

 Do we even need to bother with this? */

 if LAYOUTGET already failed once we don't try again */

	/*

	 * If the layout segment list is empty, but there are outstanding

	 * layoutget calls, then they might be subject to a layoutrecall.

	/*

	 * Because we free lsegs when sending LAYOUTRETURN, we need to wait

	 * for LAYOUTRETURN.

	/*

	 * Choose a stateid for the LAYOUTGET. If we don't have a layout

	 * stateid, or it has been invalidated, then we must use the open

	 * stateid.

		/*

		 * The first layoutget for the file. Need to serialize per

		 * RFC 5661 Errata 3208.

 Heuristic: don't send layoutget if we have cached data */

 Could check on max_ops, but currently hardcoded high enough */

		/*

		 * Halt lgopen attempts if the server doesn't recognise

		 * the "current stateid" value, the layout type, or the

		 * layoutget operation as being valid.

		 * Also if it complains about too many ops in the compound

		 * or of the request/reply being too big.

 Inject layout blob into I/O device driver */

 existing state ID, make sure the sequence number matches. */

		/*

		 * We got an entirely new state ID.  Mark all segments for the

		 * inode invalid, and retry the layoutget

 We have a completely new layout */

/**

 * pnfs_mark_matching_lsegs_return - Free or return matching layout segments

 * @lo: pointer to layout header

 * @tmp_list: list header to be used with pnfs_free_lseg_list()

 * @return_range: describe layout segment ranges to be returned

 * @seq: stateid seqid to match

 *

 * This function is mainly intended for use by layoutrecall. It attempts

 * to free the layout segment immediately, or else to mark it for return

 * as soon as its reference count drops to zero.

 *

 * Returns

 * - 0: a layoutreturn needs to be scheduled.

 * - EBUSY: there are layout segment that are still in use.

 * - ENOENT: there are no layout segments that need to be returned.

	/*

	 * mark all matching lsegs so that we are sure to have no live

	 * segments at hand when sending layoutreturn. See pnfs_put_lseg()

	 * for how it works.

 Find open file states whose mode matches that of the range */

/*

 * Check for any intersection between the request and the pgio->pg_lseg,

 * and if none, put this pgio->pg_lseg away.

 If no lseg, fall back to read through mds */

 If no lseg, fall back to write through mds */

/*

 * Return 0 if @req cannot be coalesced into @pgio, otherwise return the number

 * of bytes (maximum @req->wb_bytes) that can be coalesced.

	/*

	 * 'size' contains the number of bytes left in the current page (up

	 * to the original size asked for in @req->wb_bytes).

	 *

	 * Calculate how many bytes are left in the layout segment

	 * and if there are less bytes than 'size', return that instead.

	 *

	 * Please also note that 'end_offset' is actually the offset of the

	 * first byte that lies outside the pnfs_layout_range. FIXME?

	 *

 start of request is past the last byte of this segment */

		/* adjust 'size' iff there are fewer bytes left in the

 Resend all requests through the MDS */

/*

 * Called by non rpc-based layout drivers

 cleanup hdr and prepare to redo pnfs */

 Resend all requests through the MDS */

/*

 * Called by non rpc-based layout drivers

/*

 * Call the appropriate parallel I/O subsystem read function.

 Resend all requests through pnfs. */

 Prevent deadlocks with layoutreturn! */

 cleanup hdr and prepare to redo pnfs */

/*

 * There can be multiple RW segments.

 Matched by references in pnfs_set_layoutcommit */

 references matched in nfs4_layoutcommit_release */

	/* if pnfs_layoutcommit_inode() runs between inode locks, the next one

/*

 * For the LAYOUT4_NFSV4_1_FILES layout type, NFS_DATA_SYNC WRITEs and

 * NFS_UNSTABLE WRITEs with a COMMIT to data servers must store enough

 * data to disk to allow the server to recover the data if it crashes.

 * LAYOUTCOMMIT is only needed when the NFL4_UFLG_COMMIT_THRU_MDS flag

 * is off, and a COMMIT is sent to a data server, or

 * if WRITEs to a data server return NFS_DATA_SYNC.

 Note kzalloc ensures data->res.seq_res.sr_slot == NULL */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  linux/fs/nfs/inode.c

 *

 *  Copyright (C) 1992  Rick Sladkey

 *

 *  nfs inode and superblock handling functions

 *

 *  Modularised by Alan Cox <alan@lxorguk.ukuu.org.uk>, while hacking some

 *  experimental NFS changes. Modularisation taken straight from SYS5 fs.

 *

 *  Change to nfs_read_super() to permit NFS mounts to multi-homed hosts.

 *  J.S.Peatfield@damtp.cam.ac.uk

 *

 Default is to see 64-bit inode numbers */

/**

 * nfs_compat_user_ino64 - returns the user-visible inode number

 * @fileid: 64-bit fileid

 *

 * This function returns a 32-bit inode number if the boot parameter

 * nfs.enable_ino64 is zero.

	/*

	 * The following should never happen...

/**

 * nfs_sync_mapping - helper to flush all mmapped dirty data to disk

 * @mapping: pointer to struct address_space

/*

 * Invalidate the local caches

/*

 * Invalidate, but do not unhash, the inode.

 * NB: must be called with inode->i_lock held!

/*

 * In NFSv3 we can have 64bit inode numbers. In order to support

 * this, and re-exported directories (also seen in NFSv2)

 * we are forced to allow 2 different inodes to have the same

 * i_ino.

 Search for inode identified by fh, fileid and i_mode in inode cache. */

/*

 * This is our front-end to iget that looks up inodes by file handle

 * instead of inode number.

		/* We set i_ino for the few things that still rely on it,

 We can't support update_atime(), since the server will reset it */

		/* Why so? Because we want revalidate for devices/FIFOs, and

		 * that's precisely what we have in nfs_file_inode_operations.

 Deal with crossing mountpoints */

			/*

			 * report the blocks in 512byte units

 skip mode change if it's just for clearing setuid/setgid */

 Optimization: if the end result is no change, don't RPC */

 Write all dirty data */

/**

 * nfs_vmtruncate - unmap mappings "freed" by truncate() syscall

 * @inode: inode of the file used

 * @offset: file offset to start truncating

 *

 * This is a copy of the common vmtruncate, but with the locking

 * corrected to take into account the fact that NFS requires

 * inode->i_size to be updated under the inode->i_lock.

 * Note: must be called with inode->i_lock held!

 Optimisation */

/**

 * nfs_setattr_update_inode - Update inode metadata after a setattr call.

 * @inode: pointer to struct inode

 * @attr: pointer to struct iattr

 * @fattr: pointer to struct nfs_fattr

 *

 * Note: we do this in the *proc.c in order to ensure that

 *       it works for things like exclusive creates too.

 Barrier: bump the attribute generation count. */

 Flush out writes to the server in order to update c/mtime.  */

	/*

	 * We may force a getattr if the user cares about atime.

	 *

	 * Note that we only have to check the vfsmount flags here:

	 *  - NFS always sets S_NOATIME by so checking it would give a

	 *    bogus result

	 *  - NFS never sets SB_NOATIME or SB_NODIRATIME so there is

	 *    no point in checking those.

 Is the user requesting attributes that might need revalidation? */

 Check whether the cached attributes are stale */

 Update the attribute cache */

 Only return attributes that were revalidated. */

/**

 * nfs_close_context - Common close_context() routine NFSv2/v3

 * @ctx: pointer to context

 * @is_sync: is this a synchronous close

 *

 * Ensure that the attributes are up to date if we're mounted

 * with close-to-open semantics and we have cached data that will

 * need to be revalidated on open.

/*

 * Ensure that mmap has a recent RPC credential for use when writing out

 * shared pages

/*

 * Given an inode, search for an open context with the desired characteristics

		/*

		 * We fatal error on write before. Try to writeback

		 * every page again.

/*

 * These allocate and release file read/write context information.

/*

 * This function is called whenever some part of NFS notices that

 * the cached attributes have to be refreshed.

 pNFS: Attributes aren't updated until we layoutcommit */

 A soft timeout occurred. Use cached information? */

/**

 * nfs_revalidate_inode - Revalidate the inode attributes

 * @inode: pointer to inode struct

 * @flags: cache flags to check

 *

 * Updates inode attribute information by retrieving the data from the server.

/**

 * nfs_clear_invalid_mapping - Conditionally clear a mapping

 * @mapping: pointer to mapping

 *

 * If the NFS_INO_INVALID_DATA inode flag is set, clear the mapping.

	/*

	 * We must clear NFS_INO_INVALID_DATA first to ensure that

	 * invalidations that come in while we're shooting down the mappings

	 * are respected. But, that leaves a race window where one revalidator

	 * can clear the flag, and then another checks it before the mapping

	 * gets invalidated. Fix that by serializing access to this part of

	 * the function.

	 *

	 * At the same time, we need to allow other tasks to see whether we

	 * might be in the middle of invalidating the pages, so we only set

	 * the bit lock here if it looks like we're going to be doing that.

/**

 * nfs_revalidate_mapping - Revalidate the pagecache

 * @inode: pointer to host inode

 * @mapping: pointer to mapping

 swapfiles are not supposed to be shared. */

 If we have atomic WCC data, we may update some attributes */

/**

 * nfs_check_inode_attributes - verify consistency of the inode attribute cache

 * @inode: pointer to inode

 * @fattr: updated attributes

 *

 * Verifies the attribute cache. If we have just changed the attributes,

 * so that fattr carries weak cache consistency data, then it may

 * also update the ctime/mtime/change_attribute.

 Only a mounted-on-fileid? Just exit */

 Has the inode gone and changed behind our back? */

 Is this perhaps the mounted-on fileid? */

 Verify a few of the more important attributes */

 Have any file permissions changed? */

 Has the link count changed? */

/**

 * nfs_fattr_set_barrier

 * @fattr: attributes

 *

 * Used to set a barrier after an attribute was updated. This

 * barrier ensures that older attributes from RPC calls that may

 * have raced with our update cannot clobber these new values.

 * Note that you are still responsible for ensuring that other

 * operations which change the attribute on the server do not

 * collide.

/*

 * _nfs_display_fhandle_hash - calculate the crc32 hash for the filehandle

 *                             in the same way that wireshark does

 *

 * @fh: file handle

 *

 * For debugging only.

	/* wireshark uses 32-bit AUTODIN crc and does a bitwise

/*

 * _nfs_display_fhandle - display an NFS file handle on the console

 *

 * @fh: file handle to display

 * @caption: display caption

 *

 * For debugging only.

/**

 * nfs_inode_attrs_cmp_generic - compare attributes

 * @fattr: attributes

 * @inode: pointer to inode

 *

 * Attempt to divine whether or not an RPC call reply carrying stale

 * attributes got scheduled after another call carrying updated ones.

 * Note also the check for wraparound of 'attr_gencount'

 *

 * The function returns '1' if it thinks the attributes in @fattr are

 * more recent than the ones cached in @inode. Otherwise it returns

 * the value '0'.

/**

 * nfs_inode_attrs_cmp_monotonic - compare attributes

 * @fattr: attributes

 * @inode: pointer to inode

 *

 * Attempt to divine whether or not an RPC call reply carrying stale

 * attributes got scheduled after another call carrying updated ones.

 *

 * We assume that the server observes monotonic semantics for

 * the change attribute, so a larger value means that the attributes in

 * @fattr are more recent, in which case the function returns the

 * value '1'.

 * A return value of '0' indicates no measurable change

 * A return value of '-1' means that the attributes in @inode are

 * more recent.

/**

 * nfs_inode_attrs_cmp_strict_monotonic - compare attributes

 * @fattr: attributes

 * @inode: pointer to inode

 *

 * Attempt to divine whether or not an RPC call reply carrying stale

 * attributes got scheduled after another call carrying updated ones.

 *

 * We assume that the server observes strictly monotonic semantics for

 * the change attribute, so a larger value means that the attributes in

 * @fattr are more recent, in which case the function returns the

 * value '1'.

 * A return value of '-1' means that the attributes in @inode are

 * more recent or unchanged.

/**

 * nfs_inode_attrs_cmp - compare attributes

 * @fattr: attributes

 * @inode: pointer to inode

 *

 * This function returns '1' if it thinks the attributes in @fattr are

 * more recent than the ones cached in @inode. It returns '-1' if

 * the attributes in @inode are more recent than the ones in @fattr,

 * and it returns 0 if not sure.

/**

 * nfs_inode_finish_partial_attr_update - complete a previous inode update

 * @fattr: attributes

 * @inode: pointer to inode

 *

 * Returns '1' if the last attribute update left the inode cached

 * attributes in a partially unrevalidated state, and @fattr

 * matches the change attribute of that partial update.

 * Otherwise returns '0'.

/**

 * nfs_refresh_inode - try to update the inode attribute cache

 * @inode: pointer to inode

 * @fattr: updated attributes

 *

 * Check that an RPC call that returned attributes has not overlapped with

 * other recent updates of the inode metadata, then decide whether it is

 * safe to do a full update of the inode attributes, or whether just to

 * call nfs_check_inode_attributes.

/**

 * nfs_post_op_update_inode - try to update the inode attribute cache

 * @inode: pointer to inode

 * @fattr: updated attributes

 *

 * After an operation that has changed the inode metadata, mark the

 * attribute cache as being invalid, then try to update it.

 *

 * NB: if the server didn't return any post op attributes, this

 * function will force the retrieval of attributes before the next

 * NFS request.  Thus it should be used only for operations that

 * are expected to change one or more attributes, to avoid

 * unnecessary NFS requests and trips through nfs_update_inode().

/**

 * nfs_post_op_update_inode_force_wcc_locked - update the inode attribute cache

 * @inode: pointer to inode

 * @fattr: updated attributes

 *

 * After an operation that has changed the inode metadata, mark the

 * attribute cache as being invalid, then try to update it. Fake up

 * weak cache consistency data, if none exist.

 *

 * This function is mainly designed to be used by the ->write_done() functions.

 Don't do a WCC update if these attributes are already stale */

/**

 * nfs_post_op_update_inode_force_wcc - try to update the inode attribute cache

 * @inode: pointer to inode

 * @fattr: updated attributes

 *

 * After an operation that has changed the inode metadata, mark the

 * attribute cache as being invalid, then try to update it. Fake up

 * weak cache consistency data, if none exist.

 *

 * This function is mainly designed to be used by the ->write_done() functions.

/*

 * Many nfs protocol calls return the new file attributes after

 * an operation.  Here we update the inode to reflect the state

 * of the server's inode.

 *

 * This is a bit tricky because we have to make sure all dirty pages

 * have been sent off to the server before calling invalidate_inode_pages.

 * To make sure no other process adds more write requests while we try

 * our best to flush them, we make them sleep during the attribute refresh.

 *

 * A very similar scenario holds for the dir cache.

 Only a mounted-on-fileid? Just exit */

 Has the inode gone and changed behind our back? */

 Is this perhaps the mounted-on fileid? */

	/*

	 * Make sure the inode's type hasn't changed.

		/*

		* Big trouble! The inode has become a different object.

 Update the fsid? */

 Save the delegation state before clearing cache_validity */

	/*

	 * Update the read time so we don't revalidate too often.

 Do atomic weak cache consistency updates */

 More cache consistency checks */

 Could it be a race with writeback? */

 Force revalidate of all attributes */

 Check if our cached file size is stale */

			/* Do we perhaps have any outstanding writes, or has

		/*

		 * report the blocks in 512byte units

 Update attrtimeo value if we're out of the unstable period */

 Set barrier to be more recent than all outstanding updates */

 Set the barrier to be more recent than this fattr */

 Don't invalidate the data if we were to blame */

	/*

	 * No need to worry about unhashing the dentry, as the

	 * lookup validation will know that the inode is bad.

	 * (But we fall through to invalidate the caches.)

 CONFIG_NFS_V4 */

	/*

	 * Make sure all delayed rcu free inodes are flushed before we

	 * destroy cache.

/*

 * start up the nfsiod workqueue

/*

 * Destroy the nfsiod workqueue

/*

 * Initialize NFS

 Not quite true; I just maintain it */

 SPDX-License-Identifier: GPL-2.0

/*

 * linux/fs/nfs/callback.c

 *

 * Copyright (C) 2004 Trond Myklebust

 *

 * NFSv4 callback handling

/*

 * This is the NFSv4 callback kernel thread.

		/*

		 * Listen for a request on the socket

/*

 * The callback service for NFSv4.1 callbacks

		/*

		 * Save the svc_serv in the transport so that it can

		 * be referenced when the session backchannel is initialized

 CONFIG_NFS_V4_1 */

	/*

	 * Check whether we're already up and running.

		/*

		 * Note: increase service usage, because later in case of error

		 * svc_destroy() will be called.

	/*

	 * Sanity check: if there's no task,

	 * we should be the first user ...

	/* As there is only one thread we need to over-ride the

	 * default maximum of 80 connections

/*

 * Bring up the callback thread if it is not already up.

	/*

	 * svc_create creates the svc_serv with sv_nrthreads == 1, and then

	 * svc_prepare_thread increments that. So we need to call svc_destroy

	 * on both success and failure so that the refcount is 1 when the

	 * thread exits.

/*

 * Kill the callback thread if it's no longer being used.

 Boolean check of RPC_AUTH_GSS principal */

 No RPC_AUTH_GSS on NFSv4.1 back channel yet */

	/*

	 * It might just be a normal user principal, in which case

	 * userspace won't bother to tell us the name at all.

	/*

	 * Did we get the acceptor from userland during the SETCLIENID

	 * negotiation?

	/*

	 * Otherwise try to verify it using the cl_hostname. Note that this

	 * doesn't work if a non-canonical hostname was used in the devname.

 Expect a GSS_C_NT_HOSTBASED_NAME like "nfs@serverhostname" */

/*

 * pg_authenticate method for nfsv4 callback threads.

 *

 * The authflavor has been negotiated, so an incorrect flavor is a server

 * bug. Deny packets with incorrect authflavor.

 *

 * All other checking done after NFS decoding where the nfs_client can be

 * found in nfs4_callback_compound

 No RPC_AUTH_GSS support yet in NFSv4.1 */

/*

 * Define NFS4 callback program

 RPC service number */

 Number of entries */

 version table */

 service name */

 authentication class */

 SPDX-License-Identifier: GPL-2.0

/*

 * In-kernel MOUNT protocol client

 *

 * Copyright (C) 1997, Olaf Kirch <okir@monad.swb.de>

/*

 * Defined by RFC 1094, section A.3; and RFC 1813, section 5.1.4

/*

 * XDR data type sizes

/*

 * XDR argument and result sizes

/*

 * Defined by RFC 1094, section A.5

/*

 * Defined by RFC 1813, section 5.2

/*

 * Defined by OpenGroup XNFS Version 3W, chapter 8

/*

 * Defined by RFC 1813, section 5.1.5

 no error */

 Not owner */

 No such file or directory */

 I/O error */

 Permission denied */

 Not a directory */

 Invalid argument */

 Filename too long */

 Operation not supported */

 A failure on the server */

/**

 * nfs_mount - Obtain an NFS file handle for the given host and path

 * @info: pointer to mount request arguments

 * @timeo: deciseconds the mount waits for a response before it retries

 * @retrans: number of times the mount retries a request

 *

 * Uses timeout parameters specified by caller. On successful return, the

 * auth_flavs list and auth_flav_len will be populated with the list from the

 * server or a faked-up list if the server didn't provide one.

	/*

	 * If the server didn't provide a flavor list, allow the

	 * client to try any flavor.

/**

 * nfs_umount - Notify a server that we have unmounted this export

 * @info: pointer to umount request arguments

 *

 * MOUNTPROC_UMNT is advisory, so we set a short timeout, and always

 * use UDP.

/*

 * XDR encode/decode functions for MOUNT

/*

 * RFC 1094: "A non-zero status indicates some sort of error.  In this

 * case, the status is a UNIX error number."  This can be problematic

 * if the server and client use different errno values for the same

 * error.

 *

 * However, the OpenGroup XNFS spec provides a simple mapping that is

 * independent of local errno values on the server and the client.

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/nfs/unlink.c

 *

 * nfs sillydelete handling

 *

/**

 * nfs_free_unlinkdata - release data from a sillydelete operation.

 * @data: pointer to unlink structure.

/**

 * nfs_async_unlink_done - Sillydelete post-processing

 * @task: rpc_task of the sillydelete

 * @calldata: pointer to nfs_unlinkdata

 *

 * Do the directory attribute update.

/**

 * nfs_async_unlink_release - Release the sillydelete data.

 * @calldata: struct nfs_unlinkdata to release

 *

 * We need to call nfs_put_unlinkdata as a 'tk_release' task since the

 * rpc_task would be freed too.

		/*

		 * Hey, we raced with lookup... See if we need to transfer

		 * the sillyrename information to the aliased dentry.

		/*

		 * If we'd displaced old cached devname, free it.  At that

		 * point dentry is definitely not a root, so we won't need

		 * that anymore.

/**

 * nfs_async_unlink - asynchronous unlinking of a file

 * @dentry: parent directory of dentry

 * @name: name of dentry to unlink

	/*

	 * If we'd displaced old cached devname, free it.  At that

	 * point dentry is definitely not a root, so we won't need

	 * that anymore.

/**

 * nfs_complete_unlink - Initialize completion of the sillydelete

 * @dentry: dentry to delete

 * @inode: inode

 *

 * Since we're most likely to be called by dentry_iput(), we

 * only use the dentry to find the sillydelete. We then copy the name

 * into the qstr.

 Cancel a queued async unlink. Called when a sillyrename run fails. */

/**

 * nfs_async_rename_done - Sillyrename post-processing

 * @task: rpc_task of the sillyrename

 * @calldata: nfs_renamedata for the sillyrename

 *

 * Do the directory attribute updates and the d_move

/**

 * nfs_async_rename_release - Release the sillyrename data.

 * @calldata: the struct nfs_renamedata to be released

	/* The result of the rename is unknown. Play it safe by

/**

 * nfs_async_rename - perform an asynchronous rename operation

 * @old_dir: directory that currently holds the dentry to be renamed

 * @new_dir: target directory for the rename

 * @old_dentry: original dentry to be renamed

 * @new_dentry: dentry to which the old_dentry should be renamed

 * @complete: Function to run on successful completion

 *

 * It's expected that valid references to the dentries and inodes are held

 set up nfs_renamedata */

 set up nfs_renameargs */

 set up nfs_renameres */

/*

 * Perform tasks needed when a sillyrename is done such as cancelling the

 * queued async unlink if it failed.

/**

 * nfs_sillyrename - Perform a silly-rename of a dentry

 * @dir: inode of directory that contains dentry

 * @dentry: dentry to be sillyrenamed

 *

 * NFSv2/3 is stateless and the server doesn't know when the client is

 * holding a file open. To prevent application problems when a file is

 * unlinked while it's still open, the client performs a "silly-rename".

 * That is, it renames the file to a hidden file in the same directory,

 * and only performs the unlink once the last reference to it is put.

 *

 * The final cleanup is done during dentry_iput.

 *

 * (Note: NFSv4 is stateful, and has opens, so in theory an NFSv4 server

 * could take responsibility for keeping open files referenced.  The server

 * would also need to ensure that opened-but-deleted files were kept over

 * reboots.  However, we may not assume a server does so.  (RFC 5661

 * does provide an OPEN4_RESULT_PRESERVE_UNLINKED flag that a server can

 * use to advertise that it does this; some day we may take advantage of

 * it.))

	/*

	 * We don't allow a dentry to be silly-renamed twice.

		/*

		 * N.B. Better to return EBUSY here ... it could be

		 * dangerous to delete the file while it's in use.

 need negative lookup */

	/* queue unlink first. Can't do this from rpc_release as it

	 * has to allocate memory

 run the rename task, undo unlink if it fails */

 wait for the RPC task to complete, unless a SIGKILL intervenes */

 The rename succeeded */

		/* The result of the rename is unknown. Play it safe by

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2012 Netapp, Inc. All rights reserved.

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  linux/fs/nfs/dir.c

 *

 *  Copyright (C) 1992  Rick Sladkey

 *

 *  nfs directory handling functions

 *

 * 10 Apr 1996	Added silly rename for unlink	--okir

 * 28 Sep 1996	Improved directory cache --okir

 * 23 Aug 1997  Claus Heine claus@momo.math.rwth-aachen.de 

 *              Re-implemented silly rename for unlink, newly implemented

 *              silly rename for nfs_rename() following the suggestions

 *              of Olaf Kirch (okir) found in this file.

 *              Following Linus comments on my original hack, this version

 *              depends only on the dcache stuff and doesn't touch the inode

 *              layer (iput() and friends).

 *  6 Jun 1999	Cache readdir lookups in the page cache. -DaveM

 #define NFS_DEBUG_VERBOSE 1 */

/*

 * Open file

/*

 * we are freeing strings created by nfs_add_to_readdir_array()

/*

 * the caller is responsible for freeing qstr.name

 * when called by nfs_readdir_add_to_array, the strings will be freed in

 * nfs_clear_readdir_array()

	/*

	 * Avoid a kmemleak false positive. The pointer to the name is stored

	 * in a page cache page which kmemleak does not scan.

/*

 * Check that the next array entry lies entirely within the page bounds

 Optimisation for monotonically increasing cookies */

 Fill a page with xdr information before transferring to the cache page */

 We requested READDIRPLUS, but the server doesn't grok it */

/* Match file and dirent using either filehandle or fileid

 * Note: caller is responsible for checking the fsid

/*

 * This function is called by the lookup and getattr code to request the

 * use of readdirplus to accelerate any future lookups in the same

 * directory.

/*

 * This function is mainly for use by nfs_getattr().

 *

 * If this is an 'ls -l', we want to force use of readdirplus.

 * Do this by checking if there is an active file descriptor

 * and calling nfs_advise_use_readdirplus, then forcing a

 * cache flush.

 Validate that the name doesn't contain any illegal '\0' */

 ...or '/' */

 Is there a mountpoint here? If so, just exit */

 Perform conversion from xdr to cache array */

/*

 * nfs_readdir_alloc_pages() will allocate pages that must be freed with a call

 * to nfs_readdir_free_pages()

/*

 * Returns 0 if desc->dir_cookie was found on page desc->page_index

 * and locks the page to prevent removal from the page cache.

		/*

		 * Set the cookie verifier if the page cache was empty

	/*

	 * Default to uncached readdir if the page cache is empty, and

	 * we're looking for a non-zero cookie in a large directory.

 Search for desc->dir_cookie from the beginning of the page cache */

/*

 * Once we've found the start of the dirent within a page: fill 'er up...

/*

 * If we cannot find a cookie in our cache, we suspect that this is

 * because it points to a deleted file, so we ask the server to return

 * whatever it thinks is the next entry. We then feed this to filldir.

 * If all goes well, we should then be able to find our way round the

 * cache on the next call to readdir_search_pagecache();

 *

 * NOTE: we cannot add the anonymous page to the pagecache because

 *	 the data it contains might not be page aligned. Besides,

 *	 we should already have a complete representation of the

 *	 directory in the page cache by the time we get here.

/* The file offset position represents the dirent entry number.  A

   last cookie cache takes care of the common case of reading the

   whole directory.

	/*

	 * ctx->pos points to the dirent entry number.

	 * *desc->dir_cookie has the cookie for the next entry. We have

	 * to either find the entry with the appropriate number or

	 * revalidate the cookie.

 This means either end of directory */

 Or that the server has 'lost' a cookie */

/*

 * All directory operations under NFS are synchronous, so fsync()

 * is a dummy operation.

/**

 * nfs_force_lookup_revalidate - Mark the directory as having changed

 * @dir: pointer to directory inode

 *

 * This forces the revalidation code in nfs_lookup_revalidate() to do a

 * full lookup on all child dentries of 'dir' whenever a change occurs

 * on the server that might have invalidated our dcache.

 *

 * Note that we reserve bit '0' as a tag to let us know when a dentry

 * was revalidated while holding a delegation on its inode.

 *

 * The caller should be holding dir->i_lock

/**

 * nfs_verify_change_attribute - Detects NFS remote directory changes

 * @dir: pointer to parent directory inode

 * @verf: previously saved change attribute

 *

 * Return "false" if the verifiers doesn't match the change attribute.

 * This would usually indicate that the directory contents have changed on

 * the server, and that any dentries need revalidating.

 IS_ENABLED(CONFIG_NFS_V4) */

/**

 * nfs_set_verifier - save a parent directory verifier in the dentry

 * @dentry: pointer to dentry

 * @verf: verifier to save

 *

 * Saves the parent directory verifier in @dentry. If the inode has

 * a delegation, we also tag the dentry as having been revalidated

 * while holding a delegation so that we know we don't have to

 * look it up again after a directory change.

/**

 * nfs_clear_verifier_delegated - clear the dir verifier delegation tag

 * @inode: pointer to inode

 *

 * Iterates through the dentries in the inode alias list and clears

 * the tag used to indicate that the dentry has been revalidated

 * while holding a delegation.

 * This function is intended for use when the delegation is being

 * returned or revoked.

 IS_ENABLED(CONFIG_NFS_V4) */

/*

 * A check for whether or not the parent directory has changed.

 * In the case it has, we assume that the dentries are untrustworthy

 * and may need to be looked up again.

 * If rcu_walk prevents us from performing a full check, return 0.

 Revalidate nfsi->cache_change_attribute before we declare a match */

/*

 * Use intent information to check whether or not we're going to do

 * an O_EXCL create using this path component.

/*

 * Inode and filehandle revalidation for lookups.

 *

 * We force revalidation in the cases where the VFS sets LOOKUP_REVAL,

 * or if the intent information indicates that we're about to open this

 * particular file and the "nocto" mount flag is not set.

 *

 A NFSv4 OPEN will revalidate later */

 NFS close-to-open cache consistency validation */

 VFS wants an on-the-wire revalidation */

/*

 * We judge how long we want to trust negative

 * dentries by looking at the parent inode mtime.

 *

 * If parent mtime has changed, we revalidate, else we wait for a

 * period corresponding to the parent's attribute cache timeout value.

 *

 * If LOOKUP_RCU prevents us from performing a full check, return 1

 * suggesting a reval is needed.

 *

 * Note that when creating a new file, or looking up a rename target,

 * then it shouldn't be necessary to revalidate a negative dentry.

		/*

		 * We can't d_drop the root of a disconnected tree:

		 * its d_hash is on the s_anon list and d_drop() would hide

		 * it from shrink_dcache_for_unmount(), leading to busy

		 * inodes on unmount and further oopses.

 set a readdirplus hint that we had a cache miss */

	/*

	 * If the lookup failed despite the dentry change attribute being

	 * a match, then we should revalidate the directory cache.

/*

 * This is called every time the dcache has a lookup hit,

 * and we should check whether we can really trust that

 * lookup.

 *

 * NOTE! The hit can be a negative hit too, don't assume

 * we have an inode!

 *

 * If the parent directory is seen to have changed, we throw out the

 * cached dentry and do a new lookup.

 Force a full look up iff the parent directory has changed */

/*

 * A weaker form of d_revalidate for revalidating just the d_inode(dentry)

 * when we don't really care about the dentry name. This is called when a

 * pathwalk ends on a dentry that was not found via a normal lookup in the

 * parent dir (e.g.: ".", "..", procfs symlinks or mountpoint traversals).

 *

 * In this situation, we just want to verify that the inode itself is OK

 * since the dentry might have changed on the server.

	/*

	 * I believe we can only get a negative dentry here in the case of a

	 * procfs-style symlink. Just assume it's correct for now, but we may

	 * eventually need to do something more here.

/*

 * This is called from dput() when d_count is going to 0.

 Unhash any dentry with a stale inode */

 Unhash it, so that ->d_iput() would be called */

		/* Unhash it, so that ancestors of killed async unlink

 Ensure that we revalidate inode->i_nlink */

 drop the inode if we're reasonably sure this is the last link */

/*

 * Called when the dentry loses inode.

 * We use it to clean up silly-renamed files.

 free cached devname value, if it survived that far */

	/*

	 * If we're doing an exclusive create, optimize away the lookup

	 * but don't hash the dentry.

 Notify readdir to use READDIRPLUS */

 Expect a negative dentry */

 NFS only supports OPEN on regular files */

			/*

			 * Hashed negative dentry with O_DIRECTORY: dentry was

			 * revalidated and is fine, no need to perform lookup

			 * again

 case -EINVAL: */

	/* We can't create new files in nfs_open_revalidate(), so we

	 * optimize away revalidation of negative dentries.

 NFS only supports OPEN on regular files */

 We cannot do exclusive creation on a positive dentry */

 Check if the directory changed */

 Let f_op->open() actually open (and revalidate) the file */

 CONFIG_NFSV4 */

/*

 * Code common to create, mkdir, and mknod.

 Callers don't care */

/*

 * Following a failed create operation, we drop the dentry rather

 * than retain a negative dentry. This avoids a problem in the event

 * that the operation succeeded on the server, but an error in the

 * reply path made it appear to have failed.

/*

 * See comments for nfs_proc_create regarding failed operations.

/*

 * See comments for nfs_proc_create regarding failed operations.

 Ensure the VFS deletes this inode */

/*

 * Remove a file after making sure there are no pending writes,

 * and after checking that the file has only one user. 

 *

 * We invalidate the attribute cache and free the inode prior to the operation

 * to avoid possible races if the server reuses the inode.

 If the dentry was sillyrenamed, we simply call d_delete() */

/*  We do silly rename. In case sillyrename() returns -EBUSY, the inode

 *  belongs to an active ".nfs..." file and we return -EBUSY.

 *

 *  If sillyrename() returns 0, we do nothing, otherwise we unlink.

 Start asynchronous writeout of the inode */

/*

 * To create a symbolic link, most file systems instantiate a new inode,

 * add a page to it containing the path, then write it out to the disk

 * using prepare_write/commit_write.

 *

 * Unfortunately the NFS client can't create the in-core inode first

 * because it needs a file handle to create an in-core inode (see

 * fs/nfs/inode.c:nfs_fhget).  We only have a file handle *after* the

 * symlink request has completed on the server.

 *

 * So instead we allocate a raw page, copy the symname into it, then do

 * the SYMLINK request with the page as the buffer.  If it succeeds, we

 * now have a new file handle and can instantiate an in-core NFS inode

 * and move the raw page into its mapping.

	/*

	 * No big deal if we can't add this page to the page cache here.

	 * READLINK will get the missing page from the server if needed.

		/*

		 * add_to_page_cache_lru() grabs an extra page refcount.

		 * Drop it here to avoid leaking this page later.

/*

 * RENAME

 * FIXME: Some nfsds, like the Linux user space nfsd, may generate a

 * different file handle for the same inode after a rename (e.g. when

 * moving to a different directory). A fail-safe method to do so would

 * be to look up old_dir/old_name, create a link to new_dir/new_name and

 * rename the old file using the sillyrename stuff. This way, the original

 * file in old_dir will go away when the last process iput()s the inode.

 *

 * FIXED.

 * 

 * It actually works quite well. One needs to have the possibility for

 * at least one ".nfs..." file in each directory the file ever gets

 * moved or linked to which happens automagically with the new

 * implementation that only depends on the dcache stuff instead of

 * using the inode layer

 *

 * Unfortunately, things are a little more complicated than indicated

 * above. For a cross-directory move, we want to make sure we can get

 * rid of the old inode after the operation.  This means there must be

 * no pending writes (if it's a file), and the use count must be 1.

 * If these conditions are met, we can drop the dentries before doing

 * the rename.

	/*

	 * For non-directories, check whether the target is busy and if so,

	 * make a copy of the dentry and then do a silly-rename. If the

	 * silly-rename succeeds, the copied dentry is hashed and becomes

	 * the new target.

		/*

		 * To prevent any new references to the target during the

		 * rename, we unhash the dentry in advance.

 copy the target dentry's name */

 silly-rename the existing target ... */

 Paired with the atomic_dec_and_test() barrier in rpc_do_put_task() */

 Ensure the inode attributes are revalidated */

		/*

		 * The d_move() should be here instead of in an async RPC completion

		 * handler because we need the proper locks to move the dentry.  If

		 * we're interrupted by a signal, the async RPC completion handler

		 * should mark the directories for revalidation.

 new dentry created? */

 Unhook entries from the cache */

 Remove from global LRU init */

 Found an entry, is our attribute cache valid? */

	/* Only check the most recently returned cache entry,

	 * but do it without locking.

	/* The above field assignments must be visible

	 * before this item appears on the lru.  We cannot easily

	 * use rcu_assign_pointer, so just force the memory barrier.

 Update accounting */

 Add inode to global LRU list */

	/*

	 * Determine which access bits we want to ask for...

 ONLY check exec rights */

 Is this sys_access() ? */

			/*

			 * Optimize away all write operations, since the server

			 * will check permissions when we perform the op.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2014 Anna Schumaker <Anna.Schumaker@Netapp.com>

 offset */ + \

 length */)

 wr_callback_id size */ +\

 wr_count */ + \

 wr_committed */ + \

 One cnr_source_server */\

 nl4_type */ \

 cr_consecutive */ + \

 cr_synchronous */)

 nl4_type */ \

 cnr_lease_time */\

 Support 1 cnr_source_server */\

 nl4_type */ \

 data_content4 */ + \

 data_info4.di_offset */ + \

 data_info4.di_length */)

 rpr_eof */ + \

 rpr_contents count */ + \

 offset */ + \

 whence */)

 eof */ + \

 whence */ + \

 offset */ + \

 length */)

 offset */ + \

 length */ + \

 opaque devaddr4 length */ + \

 status */ + 1 
 offset */ + \

 length */ + \

 Array size */ + \

 src offset */ + \

 dst offset */ + \

 count */)

 Not limited by NFS itself, limited by the generic xattr code */

/*

 * These values specify the maximum amount of data that is not

 * associated with the extended attribute name or extended

 * attribute list in the SETXATTR, GETXATTR and LISTXATTR

 * respectively.

 consecutive = true */

 intra-ssc */

 no src server list */

 supporting 1 server */

 Encode layoutupdate4 */

	/*

	 * Only check against the page length here. The actual

	 * requested length may be smaller, but that is only

	 * checked against after possibly caching a valid reply.

	/*

	 * RFC 8276 says to specify the full max length of the LISTXATTRS

	 * XDR reply. Count is set to the XDR length of the names array

	 * plus the EOF marker. So, add the cookie and the names count.

		/*

		 * Special case: for LISTXATTRS, NFS4ERR_TOOSMALL

		 * should be translated to ERANGE.

	/*

	 * We have asked for enough room to encode the maximum number

	 * of possible attribute names, so everything should fit.

	 *

	 * But, don't rely on that assumption. Just decode entries

	 * until they don't fit anymore, just in case the server did

	 * something odd.

/*

 * Encode ALLOCATE request

/*

 * Encode COPY request

/*

 * Encode OFFLOAD_CANEL request

/*

 * Encode COPY_NOTIFY request

/*

 * Encode DEALLOCATE request

/*

 * Encode READ_PLUS request

/*

 * Encode SEEK request

/*

 * Encode LAYOUTSTATS request

/*

 * Encode CLONE request

/*

 * Encode LAYOUTERROR request

 nl_type */

 netid string */

 uaddr string */

 cnr_lease_time */

 number of source addresses */

 Server returned an out-of-sequence extent */

/*

 * Decode ALLOCATE request

/*

 * Decode COPY response

/*

 * Decode OFFLOAD_CANCEL response

/*

 * Decode COPY_NOTIFY response

/*

 * Decode DEALLOCATE request

/*

 * Decode READ_PLUS request

/*

 * Decode SEEK request

/*

 * Decode LAYOUTSTATS request

/*

 * Decode CLONE request

/*

 * Decode LAYOUTERROR request

 __LINUX_FS_NFS_NFS4_2XDR_H */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2014 Anna Schumaker <Anna.Schumaker@Netapp.com>

/**

 * nfs42_copy_dest_done - perform inode cache updates after clone/copy offload

 * @inode: pointer to destination inode

 * @pos: destination offset

 * @len: copy length

 *

 * Punch a hole in the inode page cache, so that the NFS client will

 * know to retrieve new data.

 * Update the file size if necessary, and then mark the inode as having

 * invalid cached values for change attribute, ctime, mtime and space used.

			/*

			 * Mark the bad layout state as invalid, then retry

			 * with the current stateid.

 Do we need to delay before resending? */

			/*

			 * Mark the bad layout state as invalid, then retry

			 * with the current stateid.

 Do we need to delay before resending? */

	/*

	 * Normally, the caching is done one layer up, but for successful

	 * RPCS, always cache the result here, even if the caller was

	 * just querying the length, or if the reply was too big for

	 * the caller. This avoids a second RPC in the case of the

	 * common query-alloc-retrieve cycle for xattrs.

	 *

	 * Note that xattr_len is always capped to XATTR_SIZE_MAX.

	/*

	 * The GETXATTR op has no length field in the call, and the

	 * xattr data is at the end of the reply.

	 *

	 * There is no downside in using the page-aligned length. It will

	 * allow receiving and caching xattrs that are too large for the

	 * caller but still fit in the page-rounded value.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * linux/fs/nfs/namespace.c

 *

 * Copyright (C) 2005 Trond Myklebust <Trond.Myklebust@netapp.com>

 * - Modified by David Howells <dhowells@redhat.com>

 *

 * NFS namespace

/*

 * nfs_path - reconstruct the path given an arbitrary dentry

 * @base - used to return pointer to the end of devname part of path

 * @dentry_in - pointer to dentry

 * @buffer - result buffer

 * @buflen_in - length of buffer

 * @flags - options (see below)

 *

 * Helper function for constructing the server pathname

 * by arbitrary hashed dentry.

 *

 * This is mainly for use in figuring out the path on the

 * server side when automounting on top of an existing partition

 * and in generating /proc/mounts and friends.

 *

 * Supported flags:

 * NFS_PATH_CANONICAL: ensure there is exactly one slash after

 *		       the original device (export) name

 *		       (if unset, the original name is returned verbatim)

 Strip off excess slashes in base string */

/*

 * nfs_d_automount - Handle crossing a mountpoint on the server

 * @path - The mountpoint

 *

 * When we encounter a mountpoint on the server, we want to set up

 * a mountpoint on the client too, to prevent inode numbers from

 * colliding, and to allow "df" to work properly.

 * On NFSv4, we also want to allow for the fact that different

 * filesystems may be migrated to different servers in a failover

 * situation, and that different filesystems may want to use

 * different security flavours.

	/* Open a new filesystem context, transferring parameters from the

	 * parent superblock, including the network namespace.

 for submounts we want the same server; referrals will reassign */

 prevent immediate expiration */

/**

 * nfs_do_submount - set up mountpoint when crossing a filesystem boundary

 * @fc: pointer to struct nfs_fs_context

 *

 create a new volume representation */

 Look it up again to get its attributes */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2006 Red Hat, Inc. All Rights Reserved.

 * Written by David Howells (dhowells@redhat.com)

/*

 * Get a unique NFSv4.0 callback identifier which will be used

 * by the V4.0 callback service to lookup the nfs_client struct

/*

 * Per auth flavor data server rpc clients

 ds_clp->cl_ds_clients */

/**

 * nfs4_find_ds_client - Common lookup case for DS I/O

 * @ds_clp: pointer to the DS's nfs_client

 * @flavor: rpc auth flavour to match

 need some lock to protect list */

/**

 * nfs4_find_or_create_ds_client - Find or create a DS rpc client

 * @ds_clp: pointer to the DS's nfs_client

 * @inode: pointer to the inode

 *

 * Find or create a DS rpc client with th MDS server rpc client auth flavor

 * in the nfs_client cl_ds_clients list.

 CONFIG_NFS_V4_1 */

	/*

	 * Set up the connection to the server before we add add to the

	 * global list.

 If no clientaddr= option was specified, find a usable cb address */

/*

 * Destroy the NFS4 callback service

/*

 * Initialize the NFS4 callback service

/**

 * nfs40_init_client - nfs_client initialization tasks for NFSv4.0

 * @clp: nfs_client to initialize

 *

 * Returns zero on success, or a negative errno if some error occurred.

/**

 * nfs41_init_client - nfs_client initialization tasks for NFSv4.1+

 * @clp: nfs_client to initialize

 *

 * Returns zero on success, or a negative errno if some error occurred.

	/*

	 * Create the session and mark it expired.

	 * When a SEQUENCE operation encounters the expired session

	 * it will do session recovery to initialize it.

	/*

	 * The create session reply races with the server back

	 * channel probe. Mark the client NFS_CS_SESSION_INITING

	 * so that the client back channel can find the

	 * nfs_client struct

 CONFIG_NFS_V4_1 */

/*

 * Initialize the minor version specific parts of an NFS4 client record

/**

 * nfs4_init_client - Initialise an NFS4 client record

 *

 * @clp: nfs_client to initialise

 * @cl_init: pointer to nfs_client_initdata

 *

 * Returns pointer to an NFS client, or an ERR_PTR value.

 the client is initialised already */

		/*

		 * Mark the client as having failed initialization so other

		 * processes walking the nfs_client_list in nfs_match_client()

		 * won't try to use it.

/*

 * SETCLIENTID just did a callback update with the callback ident in

 * "drop," but server trunking discovery claims "drop" and "keep" are

 * actually the same server.  Swap the callback IDs so that "keep"

 * will continue to use the callback ident the server now knows about,

 * and so that "keep"'s original callback ident is destroyed when

 * "drop" is freed.

	/* If "pos" isn't marked ready, we can't trust the

	 * remaining fields in "pos", especially the client

	 * ID and serverowner fields.  Wait for CREATE_SESSION

	/* NFSv4.1 always uses the uniform string, however someone

	 * might switch the uniquifier string on us.

/**

 * nfs40_walk_client_list - Find server that recognizes a client ID

 *

 * @new: nfs_client with client ID to test

 * @result: OUT: found nfs_client, or new

 * @cred: credential to use for trunking test

 *

 * Returns zero, a negative errno, or a negative NFS4ERR status.

 * If zero is returned, an nfs_client pointer is planted in "result."

 *

 * NB: nfs40_walk_client_list() relies on the new nfs_client being

 *     the last nfs_client on the list.

		/*

		 * We just sent a new SETCLIENTID, which should have

		 * caused the server to return a new cl_confirm.  So if

		 * cl_confirm is the same, then this is a different

		 * server that just returned the same cl_confirm by

		 * coincidence:

		/*

		 * But if the cl_confirm's are different, then the only

		 * way that a SETCLIENTID_CONFIRM to pos can succeed is

		 * if new and pos point to the same server:

			/* The callback path may have been inadvertently

			 * changed. Schedule recovery!

 No match found. The server lost our clientid */

/*

 * Returns true if the server major ids match

/*

 * Returns true if the server scopes match

/**

 * nfs4_detect_session_trunking - Checks for session trunking.

 * @clp:    original mount nfs_client

 * @res:    result structure from an exchange_id using the original mount

 *          nfs_client with a new multi_addr transport

 * @xprt:   pointer to the transport to add.

 *

 * Called after a successful EXCHANGE_ID on a multi-addr connection.

 * Upon success, add the transport.

 *

 * Returns zero on success, otherwise -EINVAL

 *

 * Note: since the exchange_id for the new multi_addr transport uses the

 * same nfs_client from the original mount, the cl_owner_id is reused,

 * so eir_clientowner is the same.

 Check eir_clientid */

 Check eir_server_owner so_major_id */

 Check eir_server_owner so_minor_id */

 Check eir_server_scope */

/**

 * nfs41_walk_client_list - Find nfs_client that matches a client/server owner

 *

 * @new: nfs_client with client ID to test

 * @result: OUT: found nfs_client, or new

 * @cred: credential to use for trunking test

 *

 * Returns zero, a negative errno, or a negative NFS4ERR status.

 * If zero is returned, an nfs_client pointer is planted in "result."

 *

 * NB: nfs41_walk_client_list() relies on the new nfs_client being

 *     the last nfs_client on the list.

		/*

		 * Note that session trunking is just a special subcase of

		 * client id trunking. In either case, we want to fall back

		 * to using the existing nfs_client.

 CONFIG_NFS_V4_1 */

/*

 * NFSv4.0 callback thread helper

 *

 * Find a client by callback identifier

 Common match routine for v4.0 and v4.1 callback services */

 Don't match clients that failed to initialise */

 Match the version and minorversion */

 Match only the IP address, not the port number */

/*

 * NFSv4.1 callback thread helper

 * For CB_COMPOUND calls, find a client by IP address, protocol version,

 * minorversion, and sessionID

 *

 * Returns NULL if no such client

 Match sessionid*/

 CONFIG_NFS_V4_1 */

 CONFIG_NFS_V4_1 */

/*

 * Set up an NFS4 client

 Allocate or find a client reference we can use */

	/*

	 * Query for the lease time on clientid setup or renewal

	 *

	 * Note that this will be set on nfs_clients that were created

	 * only for the DS role and did not set this bit, but now will

	 * serve a dual role.

/*

 * Set up a pNFS Data Server client.

 *

 * Return any existing nfs_client that matches server address,port,version

 * and minorversion.

 *

 * For a new nfs_client, use a soft mount (default), a low retrans and a

 * low timeout interval so that if a connection is lost, we retry through

 * the MDS.

	/*

	 * Set an authflavor equual to the MDS value. Use the MDS nfs_client

	 * cl_ipaddr so as to use the same EXCHANGE_ID co_ownerid as the MDS

	 * (section 13.1 RFC 5661).

/*

 * Session has been established, and the client marked ready.

 * Limit the mount rsize, wsize and dtsize using negotiated fore

 * channel attributes.

 CONFIG_NFS_V4_1 */

/*

 * Limit xattr sizes using the channel attributes.

 Set the basic capabilities */

	/*

	 * Don't use NFS uid/gid mapping if we're using AUTH_SYS or lower

	 * authentication.

 data servers support only a subset of NFSv4.1 */

 We must ensure the session is initialised first */

 Probe the root fh to retrieve its FSID and filehandle */

/*

 * Create a version 4 volume record

 Initialise the client representation from the mount data */

	/* Use the first specified auth flavor. If this flavor isn't

	 * allowed by the server, use the SECINFO path to try the

 Get a client record */

/*

 * Create a version 4 volume record

 * - keyed on server and FSID

 set up the general RPC client */

/*

 * Create an NFS4 referral server record

 Initialise the client representation from the parent server */

 Get a client representation */

 IS_ENABLED(CONFIG_SUNRPC_XPRT_RDMA) */

/**

 * nfs4_update_server - Move an nfs_server to a different nfs_client

 *

 * @server: represents FSID to be moved

 * @hostname: new end-point's hostname

 * @sap: new end-point's socket address

 * @salen: size of "sap"

 * @net: net namespace

 *

 * The nfs_server must be quiescent before this function is invoked.

 * Either its session is drained (NFSv4.1+), or its transport is

 * plugged and drained (NFSv4.0).

 *

 * Returns zero on success, or a negative errno value.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright 2019, 2020 Amazon.com, Inc. or its affiliates. All rights reserved.

 *

 * User extended attribute client side cache functions.

 *

 * Author: Frank van der Linden <fllinden@amazon.com>

/*

 * User extended attributes client side caching is implemented by having

 * a cache structure attached to NFS inodes. This structure is allocated

 * when needed, and freed when the cache is zapped.

 *

 * The cache structure contains as hash table of entries, and a pointer

 * to a special-cased entry for the listxattr cache.

 *

 * Accessing and allocating / freeing the caches is done via reference

 * counting. The cache entries use a similar refcounting scheme.

 *

 * This makes freeing a cache, both from the shrinker and from the

 * zap cache path, easy. It also means that, in current use cases,

 * the large majority of inodes will not waste any memory, as they

 * will never have any user extended attributes assigned to them.

 *

 * Attribute entries are hashed in to a simple hash table. They are

 * also part of an LRU.

 *

 * There are three shrinkers.

 *

 * Two shrinkers deal with the cache entries themselves: one for

 * large entries (> PAGE_SIZE), and one for smaller entries. The

 * shrinker for the larger entries works more aggressively than

 * those for the smaller entries.

 *

 * The other shrinker frees the cache structures themselves.

/*

 * 64 buckets is a good default. There is likely no reasonable

 * workload that uses more than even 64 user extended attributes.

 * You can certainly add a lot more - but you get what you ask for

 * in those circumstances.

/*

 * LRU list of NFS inodes that have xattr caches.

/*

 * Hashing helper functions.

/*

 * Locking order:

 * 1. inode i_lock or bucket lock

 * 2. list_lru lock (taken by list_lru_* functions)

/*

 * Wrapper functions to add a cache entry to the right LRU.

/*

 * This function allocates cache entries. They are the normal

 * extended attribute name/value pairs, but may also be a listxattr

 * cache. Those allocations use the same entry so that they can be

 * treated as one by the memory shrinker.

 *

 * xattr cache entries are allocated together with names. If the

 * value fits in to one page with the entry structure and the name,

 * it will also be part of the same allocation (kmalloc). This is

 * expected to be the vast majority of cases. Larger allocations

 * have a value pointer that is allocated separately by kvmalloc.

 *

 * Parameters:

 *

 * @name:  Name of the extended attribute. NULL for listxattr cache

 *         entry.

 * @value: Value of attribute, or listxattr cache. NULL if the

 *         value is to be copied from pages instead.

 * @pages: Pages to copy the value from, if not NULL. Passed in to

 *	   make it easier to copy the value after an RPC, even if

 *	   the value will not be passed up to application (e.g.

 *	   for a 'query' getxattr with NULL buffer).

 * @len:   Length of the value. Can be 0 for zero-length attributes.

 *         @value and @pages will be NULL if @len is 0.

/*

 * Set the listxattr cache, which is a special-cased cache entry.

 * The special value ERR_PTR(-ESTALE) is used to indicate that

 * the cache is being drained - this prevents a new listxattr

 * cache from being added to what is now a stale cache.

/*

 * Unlink a cache from its parent inode, clearing out an invalid

 * cache. Must be called with i_lock held.

/*

 * Discard a cache. Called by get_cache() if there was an old,

 * invalid cache. Can also be called from a shrinker callback.

 *

 * The cache is dead, it has already been unlinked from its inode,

 * and no longer appears on the cache LRU list.

 *

 * Mark all buckets as draining, so that no new entries are added. This

 * could still happen in the unlikely, but possible case that another

 * thread had grabbed a reference before it was unlinked from the inode,

 * and is still holding it for an add operation.

 *

 * Remove all entries from the LRU lists, so that there is no longer

 * any way to 'find' this cache. Then, remove the entries from the hash

 * table.

 *

 * At that point, the cache will remain empty and can be freed when the final

 * reference drops, which is very likely the kref_put at the end of

 * this function, or the one called immediately afterwards in the

 * shrinker callback.

/*

 * Get a referenced copy of the cache structure. Avoid doing allocs

 * while holding i_lock. Which means that we do some optimistic allocation,

 * and might have to free the result in rare cases.

 *

 * This function only checks the NFS_INO_INVALID_XATTR cache validity bit

 * and acts accordingly, replacing the cache when needed. For the read case

 * (!add), this means that the caller must make sure that the cache

 * is valid before caling this function. getxattr and listxattr call

 * revalidate_inode to do this. The attribute cache timeout (for the

 * non-delegated case) is expected to be dealt with in the revalidate

 * call.

			/*

			 * The cache was invalidated again. Give up,

			 * since what we want to enter is now likely

			 * outdated anyway.

		/*

		 * Check if someone beat us to it.

		/*

		 * If there was a race, throw away the cache we just

		 * allocated, and use the new one allocated by someone

		 * else.

	/*

	 * Discard the now orphaned old cache.

/*

 * Entry point to retrieve an entry from the cache.

 Length probe only */

/*

 * Retrieve a cached list of xattrs from the cache.

 Length probe only */

/*

 * Add an xattr to the cache.

 *

 * This also invalidates the xattr list cache.

/*

 * Remove an xattr from the cache.

 *

 * This also invalidates the xattr list cache.

/*

 * Cache listxattr output, replacing any possible old one.

	/*

	 * This is just there to be able to get to bucket->cache,

	 * which is obviously the same for all buckets, so just

	 * use bucket 0.

/*

 * Zap the entire cache. Called when an inode is evicted.

/*

 * The entry LRU is shrunk more aggressively than the cache LRU,

 * by settings @seeks to 1.

 *

 * Cache structures are freed only when they've become empty, after

 * pruning all but one entry.

	/*

	 * If a cache structure is on the LRU list, we know that

	 * its inode is valid. Try to lock it to break the link.

	 * Since we're inverting the lock order here, only try.

	/*

	 * Unhook the entry from its parent (either a cache bucket

	 * or a cache structure if it's a listxattr buf), so that

	 * it's no longer found. Then add it to the isolate list,

	 * to be freed later.

	 *

	 * In both cases, we're reverting lock order, so use

	 * trylock and skip the entry if we can't get the lock.

 Regular cache entry */

 Listxattr cache entry */

		/*

		 * Drop two references: the one that we just grabbed

		 * in entry_lru_isolate, and the one that was set

		 * when the entry was first allocated.

 SPDX-License-Identifier: GPL-2.0

/*

 * linux/fs/nfs/nfs3xdr.c

 *

 * XDR functions to encode/decode NFSv3 RPC arguments and results.

 *

 * Copyright (C) 1996, 1997 Olaf Kirch

 Mapping from NFS error code to "errno" error code. */

/*

 * Declare the space requirements for NFS arguments and replies as

 * number of 32bit-words

 Page padding */

 shorthand */

/*

 * Map file type to S_IFMT bits

/*

 * Encode/decode NFSv3 basic data types

 *

 * Basic NFSv3 data types are defined in section 2.5 of RFC 1813:

 * "NFS Version 3 Protocol Specification".

 *

 * Not all basic data types have their own encoding and decoding

 * functions.  For run-time efficiency, some data types are encoded

 * or decoded inline.

/*

 * fileid3

 *

 *	typedef uint64 fileid3;

/*

 * filename3

 *

 *	typedef string filename3<>;

/*

 * nfspath3

 *

 *	typedef string nfspath3<>;

/*

 * cookie3

 *

 *	typedef uint64 cookie3

/*

 * cookieverf3

 *

 *	typedef opaque cookieverf3[NFS3_COOKIEVERFSIZE];

/*

 * createverf3

 *

 *	typedef opaque createverf3[NFS3_CREATEVERFSIZE];

/*

 * size3

 *

 *	typedef uint64 size3;

/*

 * nfsstat3

 *

 *	enum nfsstat3 {

 *		NFS3_OK = 0,

 *		...

 *	}

/*

 * ftype3

 *

 *	enum ftype3 {

 *		NF3REG	= 1,

 *		NF3DIR	= 2,

 *		NF3BLK	= 3,

 *		NF3CHR	= 4,

 *		NF3LNK	= 5,

 *		NF3SOCK	= 6,

 *		NF3FIFO	= 7

 *	};

/*

 * specdata3

 *

 *     struct specdata3 {

 *             uint32  specdata1;

 *             uint32  specdata2;

 *     };

/*

 * nfs_fh3

 *

 *	struct nfs_fh3 {

 *		opaque       data<NFS3_FHSIZE>;

 *	};

/*

 * nfstime3

 *

 *	struct nfstime3 {

 *		uint32	seconds;

 *		uint32	nseconds;

 *	};

/*

 * sattr3

 *

 *	enum time_how {

 *		DONT_CHANGE		= 0,

 *		SET_TO_SERVER_TIME	= 1,

 *		SET_TO_CLIENT_TIME	= 2

 *	};

 *

 *	union set_mode3 switch (bool set_it) {

 *	case TRUE:

 *		mode3	mode;

 *	default:

 *		void;

 *	};

 *

 *	union set_uid3 switch (bool set_it) {

 *	case TRUE:

 *		uid3	uid;

 *	default:

 *		void;

 *	};

 *

 *	union set_gid3 switch (bool set_it) {

 *	case TRUE:

 *		gid3	gid;

 *	default:

 *		void;

 *	};

 *

 *	union set_size3 switch (bool set_it) {

 *	case TRUE:

 *		size3	size;

 *	default:

 *		void;

 *	};

 *

 *	union set_atime switch (time_how set_it) {

 *	case SET_TO_CLIENT_TIME:

 *		nfstime3	atime;

 *	default:

 *		void;

 *	};

 *

 *	union set_mtime switch (time_how set_it) {

 *	case SET_TO_CLIENT_TIME:

 *		nfstime3  mtime;

 *	default:

 *		void;

 *	};

 *

 *	struct sattr3 {

 *		set_mode3	mode;

 *		set_uid3	uid;

 *		set_gid3	gid;

 *		set_size3	size;

 *		set_atime	atime;

 *		set_mtime	mtime;

 *	};

	/*

	 * In order to make only a single xdr_reserve_space() call,

	 * pre-compute the total number of bytes to be reserved.

	 * Six boolean values, one for each set_foo field, are always

	 * present in the encoded result, so start there.

/*

 * fattr3

 *

 *	struct fattr3 {

 *		ftype3		type;

 *		mode3		mode;

 *		uint32		nlink;

 *		uid3		uid;

 *		gid3		gid;

 *		size3		size;

 *		size3		used;

 *		specdata3	rdev;

 *		uint64		fsid;

 *		fileid3		fileid;

 *		nfstime3	atime;

 *		nfstime3	mtime;

 *		nfstime3	ctime;

 *	};

/*

 * post_op_attr

 *

 *	union post_op_attr switch (bool attributes_follow) {

 *	case TRUE:

 *		fattr3	attributes;

 *	case FALSE:

 *		void;

 *	};

/*

 * wcc_attr

 *	struct wcc_attr {

 *		size3		size;

 *		nfstime3	mtime;

 *		nfstime3	ctime;

 *	};

/*

 * pre_op_attr

 *	union pre_op_attr switch (bool attributes_follow) {

 *	case TRUE:

 *		wcc_attr	attributes;

 *	case FALSE:

 *		void;

 *	};

 *

 * wcc_data

 *

 *	struct wcc_data {

 *		pre_op_attr	before;

 *		post_op_attr	after;

 *	};

/*

 * post_op_fh3

 *

 *	union post_op_fh3 switch (bool handle_follows) {

 *	case TRUE:

 *		nfs_fh3  handle;

 *	case FALSE:

 *		void;

 *	};

/*

 * diropargs3

 *

 *	struct diropargs3 {

 *		nfs_fh3		dir;

 *		filename3	name;

 *	};

/*

 * NFSv3 XDR encode functions

 *

 * NFSv3 argument types are defined in section 3.3 of RFC 1813:

 * "NFS Version 3 Protocol Specification".

/*

 * 3.3.1  GETATTR3args

 *

 *	struct GETATTR3args {

 *		nfs_fh3  object;

 *	};

/*

 * 3.3.2  SETATTR3args

 *

 *	union sattrguard3 switch (bool check) {

 *	case TRUE:

 *		nfstime3  obj_ctime;

 *	case FALSE:

 *		void;

 *	};

 *

 *	struct SETATTR3args {

 *		nfs_fh3		object;

 *		sattr3		new_attributes;

 *		sattrguard3	guard;

 *	};

/*

 * 3.3.3  LOOKUP3args

 *

 *	struct LOOKUP3args {

 *		diropargs3  what;

 *	};

/*

 * 3.3.4  ACCESS3args

 *

 *	struct ACCESS3args {

 *		nfs_fh3		object;

 *		uint32		access;

 *	};

/*

 * 3.3.5  READLINK3args

 *

 *	struct READLINK3args {

 *		nfs_fh3	symlink;

 *	};

/*

 * 3.3.6  READ3args

 *

 *	struct READ3args {

 *		nfs_fh3		file;

 *		offset3		offset;

 *		count3		count;

 *	};

/*

 * 3.3.7  WRITE3args

 *

 *	enum stable_how {

 *		UNSTABLE  = 0,

 *		DATA_SYNC = 1,

 *		FILE_SYNC = 2

 *	};

 *

 *	struct WRITE3args {

 *		nfs_fh3		file;

 *		offset3		offset;

 *		count3		count;

 *		stable_how	stable;

 *		opaque		data<>;

 *	};

/*

 * 3.3.8  CREATE3args

 *

 *	enum createmode3 {

 *		UNCHECKED = 0,

 *		GUARDED   = 1,

 *		EXCLUSIVE = 2

 *	};

 *

 *	union createhow3 switch (createmode3 mode) {

 *	case UNCHECKED:

 *	case GUARDED:

 *		sattr3       obj_attributes;

 *	case EXCLUSIVE:

 *		createverf3  verf;

 *	};

 *

 *	struct CREATE3args {

 *		diropargs3	where;

 *		createhow3	how;

 *	};

/*

 * 3.3.9  MKDIR3args

 *

 *	struct MKDIR3args {

 *		diropargs3	where;

 *		sattr3		attributes;

 *	};

/*

 * 3.3.10  SYMLINK3args

 *

 *	struct symlinkdata3 {

 *		sattr3		symlink_attributes;

 *		nfspath3	symlink_data;

 *	};

 *

 *	struct SYMLINK3args {

 *		diropargs3	where;

 *		symlinkdata3	symlink;

 *	};

/*

 * 3.3.11  MKNOD3args

 *

 *	struct devicedata3 {

 *		sattr3		dev_attributes;

 *		specdata3	spec;

 *	};

 *

 *	union mknoddata3 switch (ftype3 type) {

 *	case NF3CHR:

 *	case NF3BLK:

 *		devicedata3	device;

 *	case NF3SOCK:

 *	case NF3FIFO:

 *		sattr3		pipe_attributes;

 *	default:

 *		void;

 *	};

 *

 *	struct MKNOD3args {

 *		diropargs3	where;

 *		mknoddata3	what;

 *	};

/*

 * 3.3.12  REMOVE3args

 *

 *	struct REMOVE3args {

 *		diropargs3  object;

 *	};

/*

 * 3.3.14  RENAME3args

 *

 *	struct RENAME3args {

 *		diropargs3	from;

 *		diropargs3	to;

 *	};

/*

 * 3.3.15  LINK3args

 *

 *	struct LINK3args {

 *		nfs_fh3		file;

 *		diropargs3	link;

 *	};

/*

 * 3.3.16  READDIR3args

 *

 *	struct READDIR3args {

 *		nfs_fh3		dir;

 *		cookie3		cookie;

 *		cookieverf3	cookieverf;

 *		count3		count;

 *	};

/*

 * 3.3.17  READDIRPLUS3args

 *

 *	struct READDIRPLUS3args {

 *		nfs_fh3		dir;

 *		cookie3		cookie;

 *		cookieverf3	cookieverf;

 *		count3		dircount;

 *		count3		maxcount;

 *	};

	/*

	 * readdirplus: need dircount + buffer size.

	 * We just make sure we make dircount big enough

/*

 * 3.3.21  COMMIT3args

 *

 *	struct COMMIT3args {

 *		nfs_fh3		file;

 *		offset3		offset;

 *		count3		count;

 *	};

 FIXME: this is just broken */

 CONFIG_NFS_V3_ACL */

/*

 * NFSv3 XDR decode functions

 *

 * NFSv3 result types are defined in section 3.3 of RFC 1813:

 * "NFS Version 3 Protocol Specification".

/*

 * 3.3.1  GETATTR3res

 *

 *	struct GETATTR3resok {

 *		fattr3		obj_attributes;

 *	};

 *

 *	union GETATTR3res switch (nfsstat3 status) {

 *	case NFS3_OK:

 *		GETATTR3resok  resok;

 *	default:

 *		void;

 *	};

/*

 * 3.3.2  SETATTR3res

 *

 *	struct SETATTR3resok {

 *		wcc_data  obj_wcc;

 *	};

 *

 *	struct SETATTR3resfail {

 *		wcc_data  obj_wcc;

 *	};

 *

 *	union SETATTR3res switch (nfsstat3 status) {

 *	case NFS3_OK:

 *		SETATTR3resok   resok;

 *	default:

 *		SETATTR3resfail resfail;

 *	};

/*

 * 3.3.3  LOOKUP3res

 *

 *	struct LOOKUP3resok {

 *		nfs_fh3		object;

 *		post_op_attr	obj_attributes;

 *		post_op_attr	dir_attributes;

 *	};

 *

 *	struct LOOKUP3resfail {

 *		post_op_attr	dir_attributes;

 *	};

 *

 *	union LOOKUP3res switch (nfsstat3 status) {

 *	case NFS3_OK:

 *		LOOKUP3resok	resok;

 *	default:

 *		LOOKUP3resfail	resfail;

 *	};

/*

 * 3.3.4  ACCESS3res

 *

 *	struct ACCESS3resok {

 *		post_op_attr	obj_attributes;

 *		uint32		access;

 *	};

 *

 *	struct ACCESS3resfail {

 *		post_op_attr	obj_attributes;

 *	};

 *

 *	union ACCESS3res switch (nfsstat3 status) {

 *	case NFS3_OK:

 *		ACCESS3resok	resok;

 *	default:

 *		ACCESS3resfail	resfail;

 *	};

/*

 * 3.3.5  READLINK3res

 *

 *	struct READLINK3resok {

 *		post_op_attr	symlink_attributes;

 *		nfspath3	data;

 *	};

 *

 *	struct READLINK3resfail {

 *		post_op_attr	symlink_attributes;

 *	};

 *

 *	union READLINK3res switch (nfsstat3 status) {

 *	case NFS3_OK:

 *		READLINK3resok	resok;

 *	default:

 *		READLINK3resfail resfail;

 *	};

/*

 * 3.3.6  READ3res

 *

 *	struct READ3resok {

 *		post_op_attr	file_attributes;

 *		count3		count;

 *		bool		eof;

 *		opaque		data<>;

 *	};

 *

 *	struct READ3resfail {

 *		post_op_attr	file_attributes;

 *	};

 *

 *	union READ3res switch (nfsstat3 status) {

 *	case NFS3_OK:

 *		READ3resok	resok;

 *	default:

 *		READ3resfail	resfail;

 *	};

/*

 * 3.3.7  WRITE3res

 *

 *	enum stable_how {

 *		UNSTABLE  = 0,

 *		DATA_SYNC = 1,

 *		FILE_SYNC = 2

 *	};

 *

 *	struct WRITE3resok {

 *		wcc_data	file_wcc;

 *		count3		count;

 *		stable_how	committed;

 *		writeverf3	verf;

 *	};

 *

 *	struct WRITE3resfail {

 *		wcc_data	file_wcc;

 *	};

 *

 *	union WRITE3res switch (nfsstat3 status) {

 *	case NFS3_OK:

 *		WRITE3resok	resok;

 *	default:

 *		WRITE3resfail	resfail;

 *	};

/*

 * 3.3.8  CREATE3res

 *

 *	struct CREATE3resok {

 *		post_op_fh3	obj;

 *		post_op_attr	obj_attributes;

 *		wcc_data	dir_wcc;

 *	};

 *

 *	struct CREATE3resfail {

 *		wcc_data	dir_wcc;

 *	};

 *

 *	union CREATE3res switch (nfsstat3 status) {

 *	case NFS3_OK:

 *		CREATE3resok	resok;

 *	default:

 *		CREATE3resfail	resfail;

 *	};

	/* The server isn't required to return a file handle.

	 * If it didn't, force the client to perform a LOOKUP

	 * to determine the correct file handle and attribute

/*

 * 3.3.12  REMOVE3res

 *

 *	struct REMOVE3resok {

 *		wcc_data    dir_wcc;

 *	};

 *

 *	struct REMOVE3resfail {

 *		wcc_data    dir_wcc;

 *	};

 *

 *	union REMOVE3res switch (nfsstat3 status) {

 *	case NFS3_OK:

 *		REMOVE3resok   resok;

 *	default:

 *		REMOVE3resfail resfail;

 *	};

/*

 * 3.3.14  RENAME3res

 *

 *	struct RENAME3resok {

 *		wcc_data	fromdir_wcc;

 *		wcc_data	todir_wcc;

 *	};

 *

 *	struct RENAME3resfail {

 *		wcc_data	fromdir_wcc;

 *		wcc_data	todir_wcc;

 *	};

 *

 *	union RENAME3res switch (nfsstat3 status) {

 *	case NFS3_OK:

 *		RENAME3resok   resok;

 *	default:

 *		RENAME3resfail resfail;

 *	};

/*

 * 3.3.15  LINK3res

 *

 *	struct LINK3resok {

 *		post_op_attr	file_attributes;

 *		wcc_data	linkdir_wcc;

 *	};

 *

 *	struct LINK3resfail {

 *		post_op_attr	file_attributes;

 *		wcc_data	linkdir_wcc;

 *	};

 *

 *	union LINK3res switch (nfsstat3 status) {

 *	case NFS3_OK:

 *		LINK3resok	resok;

 *	default:

 *		LINK3resfail	resfail;

 *	};

/**

 * nfs3_decode_dirent - Decode a single NFSv3 directory entry stored in

 *			the local page cache

 * @xdr: XDR stream where entry resides

 * @entry: buffer to fill in with entry data

 * @plus: boolean indicating whether this should be a readdirplus entry

 *

 * Returns zero if successful, otherwise a negative errno value is

 * returned.

 *

 * This function is not invoked during READDIR reply decoding, but

 * rather whenever an application invokes the getdents(2) system call

 * on a directory already in our cache.

 *

 * 3.3.16  entry3

 *

 *	struct entry3 {

 *		fileid3		fileid;

 *		filename3	name;

 *		cookie3		cookie;

 *		fhandle3	filehandle;

 *		post_op_attr3	attributes;

 *		entry3		*nextentry;

 *	};

 *

 * 3.3.17  entryplus3

 *	struct entryplus3 {

 *		fileid3		fileid;

 *		filename3	name;

 *		cookie3		cookie;

 *		post_op_attr	name_attributes;

 *		post_op_fh3	name_handle;

 *		entryplus3	*nextentry;

 *	};

 In fact, a post_op_fh3: */

/*

 * 3.3.16  READDIR3res

 *

 *	struct dirlist3 {

 *		entry3		*entries;

 *		bool		eof;

 *	};

 *

 *	struct READDIR3resok {

 *		post_op_attr	dir_attributes;

 *		cookieverf3	cookieverf;

 *		dirlist3	reply;

 *	};

 *

 *	struct READDIR3resfail {

 *		post_op_attr	dir_attributes;

 *	};

 *

 *	union READDIR3res switch (nfsstat3 status) {

 *	case NFS3_OK:

 *		READDIR3resok	resok;

 *	default:

 *		READDIR3resfail	resfail;

 *	};

 *

 * Read the directory contents into the page cache, but otherwise

 * don't touch them.  The actual decoding is done by nfs3_decode_entry()

 * during subsequent nfs_readdir() calls.

 XXX: do we need to check if result->verf != NULL ? */

/*

 * 3.3.18  FSSTAT3res

 *

 *	struct FSSTAT3resok {

 *		post_op_attr	obj_attributes;

 *		size3		tbytes;

 *		size3		fbytes;

 *		size3		abytes;

 *		size3		tfiles;

 *		size3		ffiles;

 *		size3		afiles;

 *		uint32		invarsec;

 *	};

 *

 *	struct FSSTAT3resfail {

 *		post_op_attr	obj_attributes;

 *	};

 *

 *	union FSSTAT3res switch (nfsstat3 status) {

 *	case NFS3_OK:

 *		FSSTAT3resok	resok;

 *	default:

 *		FSSTAT3resfail	resfail;

 *	};

 ignore invarsec */

/*

 * 3.3.19  FSINFO3res

 *

 *	struct FSINFO3resok {

 *		post_op_attr	obj_attributes;

 *		uint32		rtmax;

 *		uint32		rtpref;

 *		uint32		rtmult;

 *		uint32		wtmax;

 *		uint32		wtpref;

 *		uint32		wtmult;

 *		uint32		dtpref;

 *		size3		maxfilesize;

 *		nfstime3	time_delta;

 *		uint32		properties;

 *	};

 *

 *	struct FSINFO3resfail {

 *		post_op_attr	obj_attributes;

 *	};

 *

 *	union FSINFO3res switch (nfsstat3 status) {

 *	case NFS3_OK:

 *		FSINFO3resok	resok;

 *	default:

 *		FSINFO3resfail	resfail;

 *	};

 ignore properties */

/*

 * 3.3.20  PATHCONF3res

 *

 *	struct PATHCONF3resok {

 *		post_op_attr	obj_attributes;

 *		uint32		linkmax;

 *		uint32		name_max;

 *		bool		no_trunc;

 *		bool		chown_restricted;

 *		bool		case_insensitive;

 *		bool		case_preserving;

 *	};

 *

 *	struct PATHCONF3resfail {

 *		post_op_attr	obj_attributes;

 *	};

 *

 *	union PATHCONF3res switch (nfsstat3 status) {

 *	case NFS3_OK:

 *		PATHCONF3resok	resok;

 *	default:

 *		PATHCONF3resfail resfail;

 *	};

 ignore remaining fields */

/*

 * 3.3.21  COMMIT3res

 *

 *	struct COMMIT3resok {

 *		wcc_data	file_wcc;

 *		writeverf3	verf;

 *	};

 *

 *	struct COMMIT3resfail {

 *		wcc_data	file_wcc;

 *	};

 *

 *	union COMMIT3res switch (nfsstat3 status) {

 *	case NFS3_OK:

 *		COMMIT3resok	resok;

 *	default:

 *		COMMIT3resfail	resfail;

 *	};

 CONFIG_NFS_V3_ACL */

/*

 * We need to translate between nfs status return values and

 * the local errno values which may not be the same.

	{ NFSERR_EAGAIN,	-EAGAIN		}, */

/**

 * nfs3_stat_to_errno - convert an NFS status code to a local errno

 * @status: NFS status code to convert

 *

 * Returns a local errno value, or -EIO if the NFS status code is

 * not recognized.  This function is used jointly by NFSv2 and NFSv3.

 CONFIG_NFS_V3_ACL */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * linux/fs/nfs/read.c

 *

 * Block I/O for NFS

 *

 * Partial copy of Linus' read cache modifications to fs/nfs/file.c

 * modified for async RPC by okir@monad.swb.de

 It doesn't make sense to do mirrored reads! */

 read path should never have more than one mirror */

			/* note: regions of the page not covered by a

				/* nothing in this request was good, so zero

				/* part of this request has good bytes, but

/*

 * This is the callback from RPC telling us whether a reply was

 * received or some error occurred (timeout or socket shutdown).

 This is a short read! */

 Has the server at least made some progress? */

 For non rpc-based layout drivers, retry-through-MDS */

 Yes, so retry the read at the end of the hdr */

/*

 * Read a page over NFS.

 * We read the page synchronously in the following case:

 *  -	The error flag is set for this page. This happens only when a

 *	previous async read operation failed.

	/*

	 * Try to flush any pending writes to the file..

	 *

	 * NOTE! Because we own the page lock, there cannot

	 * be any new pending writes generated at this point

	 * for this page (other pages can be written to).

	/* attempt to read as many of the pages as possible from the cache

	 * - this returns -ENOBUFS immediately if the cookie is negative

 all pages were read */

 SPDX-License-Identifier: GPL-2.0

/*

 * linux/fs/nfs/sysctl.c

 *

 * Sysctl interface to NFS parameters

 SPDX-License-Identifier: GPL-2.0-or-later

/* client.c: NFS client sharing and management code

 *

 * Copyright (C) 2006 Red Hat, Inc. All Rights Reserved.

 * Written by David Howells (dhowells@redhat.com)

/*

 * RPC cruft for NFS

/*

 * Allocate a shared client record

 *

 * Since these are allocated/deallocated very rarely, we don't

 * bother putting them in a slab cache...

 nfs_client_lock held */

 CONFIG_NFS_V4 */

/*

 * Destroy a shared client record

 -EIO all pending I/O */

/*

 * Release a reference to a shared client record

/*

 * Find an nfs_client on the list that matches the initialisation data

 * that is supplied.

 Don't match clients that failed to initialise properly */

 If a client is still initializing then we need to wait */

 Different NFS versions cannot share the same nfs_client */

 Match nfsv4 minorversion */

 Match request for a dedicated DS */

 Match the full socket address */

 Match all xprt_switch full socket addresses */

/*

 * Return true if @clp is done initializing, false if still working on it.

 *

 * Use nfs_client_init_status to check if it was successful.

/*

 * Return 0 if @clp was successfully initialized, -errno otherwise.

 *

 * This must be called *after* nfs_client_init_is_complete() returns true,

 * otherwise it will pop WARN_ON_ONCE and return -EINVAL

 called without checking nfs_client_init_is_complete */

/*

 * Found an existing client.  Make sure it's ready before returning.

/*

 * Look up a client by IP address and protocol version

 * - creates a new record if one doesn't yet exist

 see if the client already exists */

/*

 * Mark a server as ready or failed

/*

 * Initialise the timeout values for a connection

/*

 * Create an RPC client handle

/*

 * Version 2 or 3 client destruction

/*

 * Version 2 or 3 lockd setup

/*

 * Create a general RPC client

/**

 * nfs_init_client - Initialise an NFS2 or NFS3 client

 *

 * @clp: nfs_client to initialise

 * @cl_init: Initialisation parameters

 *

 * Returns pointer to an NFS client, or an ERR_PTR value.

 the client is already initialised */

	/*

	 * Create a client RPC handle for doing FSSTAT with UNIX auth only

	 * - RFC 2623, sec 2.3.2

/*

 * Create a version 2 or 3 client

 Allocate or find a client reference we can use */

 Initialise the client representation from the mount data */

 Start lockd here, before we might error out */

 Preserve the values of mount_server-related mount options */

/*

 * Load up the server record from information gained in an fsinfo record

 Work out a lot of parameters */

 We're airborne Set socket buffersize */

	/*

	 * Defaults until limited by the session parameters.

/*

 * Probe filesystem information, including the FSID on v2/v3

 Get some general file system info */

/*

 * Grab the destination's particulars, including lease expiry time.

 *

 * Returns zero if probe succeeded and retrieved FSID matches the FSID

 * we have cached.

	/* Sanity: the probe won't work if the destination server

/*

 * Copy useful information when duplicating a server record

/*

 * Allocate and initialise a server record

 Zero out the NFS state stuff */

/*

 * Free up a server record

/*

 * Create a version 2 or 3 volume record

 * - keyed on server and FSID

 Get a client representation */

 Probe the root fh to retrieve its FSID */

/*

 * Clone an NFS2, NFS3 or NFS4 server record

 Copy data from the source */

 probe the filesystem info for this server filesystem */

/*

 * set up the iterator to start reading from the server list and return the first item

 lock the list against modification */

/*

 * move to next server

/*

 * clean up after reading from the transports list

/*

 * display a header line followed by a load of call lines

 display header on line 1 */

 display one transport per line on subsequent lines */

 Check if the client is initialized */

/*

 * set up the iterator to start reading from the volume list and return the first item

 lock the list against modification */

/*

 * move to next volume

/*

 * clean up after reading from the transports list

/*

 * display a header line followed by a load of call lines

 8 for 2^24, 1 for ':', 3 for 2^8, 1 for '\0'

 2 * 16 for %llx, 1 for ':', 1 for '\0'

 display header on line 1 */

 display one transport per line on subsequent lines */

 a file of servers with which we're dealing */

 a file of volumes that we have mounted */

/*

 * initialise the /proc/fs/nfsfs/ directory

 a file of servers with which we're dealing */

 a file of volumes that we have mounted */

/*

 * clean up the /proc/fs/nfsfs/ directory

 CONFIG_PROC_FS */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2012 Netapp, Inc. All rights reserved.

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/nfs/nfs3proc.c

 *

 *  Client-side NFSv3 procedures stubs.

 *

 *  Copyright (C) 1997, Olaf Kirch

 A wrapper to handle the EJUKEBOX error messages */

/*

 * Bare-bones access to getattr: this is for nfs_get_root/nfs_get_sb

/*

 * One function for each procedure in the NFS protocol.

 Is this is an attribute revalidation, subject to softreval? */

 Is this is an attribute revalidation, subject to softreval? */

/*

 * Create a regular file.

		/* If the server doesn't support the exclusive creation

	/* When we created the file with exclusive semantics, make

		/* Note: we could use a guarded setattr here, but I'm

		 * not sure this buys us anything (and I'd have

/*

 * The READDIR implementation is somewhat hackish - we pass the user buffer

 * to the encode function, which installs it in the receive iovec.

 * The decode function itself doesn't perform any decoding, it just makes

 * sure the reply is syntactically correct.

 *

 * Also note that this implementation handles both plain readdir and

 * readdirplus.

/*

 * Bare-bones access to fsinfo: this is for nfs_get_root/nfs_get_sb via

 * nfs_create_server

 protocol version */

 SPDX-License-Identifier: GPL-2.0-or-later

/* NFS filesystem cache interface

 *

 * Copyright (C) 2008 Red Hat, Inc. All Rights Reserved.

 * Written by David Howells (dhowells@redhat.com)

/*

 * Layout of the key for an NFS server cache object.

 NFS protocol version */

 NFSv4 minor version */

 address family */

 IP port */

 IPv4 address */

 IPv6 address */

/*

 * Get the per-client index cookie for an NFS client if the appropriate mount

 * flag was set

 * - We always try and get an index cookie for the client, but get filehandle

 *   cookies on a per-superblock basis, depending on the mount flags

 create a cache index for looking up filehandles */

/*

 * Dispose of a per-client cookie

/*

 * Get the cache cookie for an NFS superblock.  We have to handle

 * uniquification here because the cache doesn't do it for us.

 *

 * The default uniquifier is just an empty string, but it may be overridden

 * either by the 'fsc=xxx' option to mount, or by inheriting it from the parent

 * superblock across an automount point of some nature.

 create a cache index for looking up filehandles */

/*

 * release a per-superblock cookie

/*

 * Initialise the per-inode cache cookie pointer for an NFS inode.

/*

 * Release a per-inode cookie.

/*

 * Enable or disable caching for a file that is being opened as appropriate.

 * The cookie is allocated when the inode is initialised, but is not enabled at

 * that time.  Enablement is deferred to file-open time to avoid stat() and

 * access() thrashing the cache.

 *

 * For now, with NFS, only regular files that are open read-only will be able

 * to use the cache.

 *

 * We enable the cache for an inode if we open it read-only and it isn't

 * currently open for writing.  We disable the cache if the inode is open

 * write-only.

 *

 * The caller uses the file struct to pin i_writecount on the inode before

 * calling us when a file is opened for writing, so we can make use of that.

 *

 * Note that this may be invoked multiple times in parallel by parallel

 * nfs_open() functions.

/*

 * Release the caching state associated with a page, if the page isn't busy

 * interacting with the cache.

 * - Returns true (can release page) or false (page busy).

/*

 * Release the caching state associated with a page if undergoing complete page

 * invalidation.

/*

 * Handle completion of a page being read from the cache.

 * - Called in process (keventd) context.

	/*

	 * If the read completes with an error, mark the page with PG_checked,

	 * unlock the page, and let the VM reissue the readpage.

/*

 * Retrieve a page from fscache

 read BIO submitted (page in fscache) */

 inode not in cache */

 page not in cache */

/*

 * Retrieve a set of pages from fscache

 read submitted to the cache for all pages */

 some pages aren't cached and can't be */

 some pages aren't cached */

/*

 * Store a newly fetched page in fscache

 * - PG_fscache must be set on the page

 SPDX-License-Identifier: GPL-2.0

/*

 * linux/fs/nfs/nfs2xdr.c

 *

 * XDR functions to encode/decode NFS RPC arguments and results.

 *

 * Copyright (C) 1992, 1993, 1994  Rick Sladkey

 * Copyright (C) 1996 Olaf Kirch

 * 04 Aug 1998  Ion Badulescu <ionut@cs.columbia.edu>

 * 		FIFO's need special handling in NFSv2

 Mapping from NFS error code to "errno" error code. */

/*

 * Declare the space requirements for NFS arguments and replies as

 * number of 32bit-words

 Page padding */

/*

 * Encode/decode NFSv2 basic data types

 *

 * Basic NFSv2 data types are defined in section 2.3 of RFC 1094:

 * "NFS: Network File System Protocol Specification".

 *

 * Not all basic data types have their own encoding and decoding

 * functions.  For run-time efficiency, some data types are encoded

 * or decoded inline.

/*

 *	typedef opaque	nfsdata<>;

 NFSv2 does not pass EOF flag on the wire. */

/*

 *	enum stat {

 *		NFS_OK = 0,

 *		NFSERR_PERM = 1,

 *		NFSERR_NOENT = 2,

 *		NFSERR_IO = 5,

 *		NFSERR_NXIO = 6,

 *		NFSERR_ACCES = 13,

 *		NFSERR_EXIST = 17,

 *		NFSERR_NODEV = 19,

 *		NFSERR_NOTDIR = 20,

 *		NFSERR_ISDIR = 21,

 *		NFSERR_FBIG = 27,

 *		NFSERR_NOSPC = 28,

 *		NFSERR_ROFS = 30,

 *		NFSERR_NAMETOOLONG = 63,

 *		NFSERR_NOTEMPTY = 66,

 *		NFSERR_DQUOT = 69,

 *		NFSERR_STALE = 70,

 *		NFSERR_WFLUSH = 99

 *	};

/*

 * 2.3.2.  ftype

 *

 *	enum ftype {

 *		NFNON = 0,

 *		NFREG = 1,

 *		NFDIR = 2,

 *		NFBLK = 3,

 *		NFCHR = 4,

 *		NFLNK = 5

 *	};

 *

/*

 * 2.3.3.  fhandle

 *

 *	typedef opaque fhandle[FHSIZE];

/*

 * 2.3.4.  timeval

 *

 *	struct timeval {

 *		unsigned int seconds;

 *		unsigned int useconds;

 *	};

/*

 * Passing the invalid value useconds=1000000 is a Sun convention for

 * "set to current server time".  It's needed to make permissions checks

 * for the "touch" program across v2 mounts to Solaris and Irix servers

 * work correctly.  See description of sattr in section 6.1 of "NFS

 * Illustrated" by Brent Callaghan, Addison-Wesley, ISBN 0-201-32750-5.

/*

 * 2.3.5.  fattr

 *

 *	struct fattr {

 *		ftype		type;

 *		unsigned int	mode;

 *		unsigned int	nlink;

 *		unsigned int	uid;

 *		unsigned int	gid;

 *		unsigned int	size;

 *		unsigned int	blocksize;

 *		unsigned int	rdev;

 *		unsigned int	blocks;

 *		unsigned int	fsid;

 *		unsigned int	fileid;

 *		timeval		atime;

 *		timeval		mtime;

 *		timeval		ctime;

 *	};

 *

/*

 * 2.3.6.  sattr

 *

 *	struct sattr {

 *		unsigned int	mode;

 *		unsigned int	uid;

 *		unsigned int	gid;

 *		unsigned int	size;

 *		timeval		atime;

 *		timeval		mtime;

 *	};

/*

 * 2.3.7.  filename

 *

 *	typedef string filename<MAXNAMLEN>;

/*

 * 2.3.8.  path

 *

 *	typedef string path<MAXPATHLEN>;

/*

 * 2.3.9.  attrstat

 *

 *	union attrstat switch (stat status) {

 *	case NFS_OK:

 *		fattr attributes;

 *	default:

 *		void;

 *	};

/*

 * 2.3.10.  diropargs

 *

 *	struct diropargs {

 *		fhandle  dir;

 *		filename name;

 *	};

/*

 * 2.3.11.  diropres

 *

 *	union diropres switch (stat status) {

 *	case NFS_OK:

 *		struct {

 *			fhandle file;

 *			fattr   attributes;

 *		} diropok;

 *	default:

 *		void;

 *	};

/*

 * NFSv2 XDR encode functions

 *

 * NFSv2 argument types are defined in section 2.2 of RFC 1094:

 * "NFS: Network File System Protocol Specification".

/*

 * 2.2.3.  sattrargs

 *

 *	struct sattrargs {

 *		fhandle file;

 *		sattr attributes;

 *	};

/*

 * 2.2.7.  readargs

 *

 *	struct readargs {

 *		fhandle file;

 *		unsigned offset;

 *		unsigned count;

 *		unsigned totalcount;

 *	};

/*

 * 2.2.9.  writeargs

 *

 *	struct writeargs {

 *		fhandle file;

 *		unsigned beginoffset;

 *		unsigned offset;

 *		unsigned totalcount;

 *		nfsdata data;

 *	};

 nfsdata */

/*

 * 2.2.10.  createargs

 *

 *	struct createargs {

 *		diropargs where;

 *		sattr attributes;

 *	};

/*

 * 2.2.12.  renameargs

 *

 *	struct renameargs {

 *		diropargs from;

 *		diropargs to;

 *	};

/*

 * 2.2.13.  linkargs

 *

 *	struct linkargs {

 *		fhandle from;

 *		diropargs to;

 *	};

/*

 * 2.2.14.  symlinkargs

 *

 *	struct symlinkargs {

 *		diropargs from;

 *		path to;

 *		sattr attributes;

 *	};

/*

 * 2.2.17.  readdirargs

 *

 *	struct readdirargs {

 *		fhandle dir;

 *		nfscookie cookie;

 *		unsigned count;

 *	};

/*

 * NFSv2 XDR decode functions

 *

 * NFSv2 result types are defined in section 2.2 of RFC 1094:

 * "NFS: Network File System Protocol Specification".

/*

 * 2.2.6.  readlinkres

 *

 *	union readlinkres switch (stat status) {

 *	case NFS_OK:

 *		path data;

 *	default:

 *		void;

 *	};

/*

 * 2.2.7.  readres

 *

 *	union readres switch (stat status) {

 *	case NFS_OK:

 *		fattr attributes;

 *		nfsdata data;

 *	default:

 *		void;

 *	};

 All NFSv2 writes are "file sync" writes */

/**

 * nfs2_decode_dirent - Decode a single NFSv2 directory entry stored in

 *                      the local page cache.

 * @xdr: XDR stream where entry resides

 * @entry: buffer to fill in with entry data

 * @plus: boolean indicating whether this should be a readdirplus entry

 *

 * Returns zero if successful, otherwise a negative errno value is

 * returned.

 *

 * This function is not invoked during READDIR reply decoding, but

 * rather whenever an application invokes the getdents(2) system call

 * on a directory already in our cache.

 *

 * 2.2.17.  entry

 *

 *	struct entry {

 *		unsigned	fileid;

 *		filename	name;

 *		nfscookie	cookie;

 *		entry		*nextentry;

 *	};

	/*

	 * The type (size and byte order) of nfscookie isn't defined in

	 * RFC 1094.  This implementation assumes that it's an XDR uint32.

/*

 * 2.2.17.  readdirres

 *

 *	union readdirres switch (stat status) {

 *	case NFS_OK:

 *		struct {

 *			entry *entries;

 *			bool eof;

 *		} readdirok;

 *	default:

 *		void;

 *	};

 *

 * Read the directory contents into the page cache, but don't

 * touch them.  The actual decoding is done by nfs2_decode_dirent()

 * during subsequent nfs_readdir() calls.

/*

 * 2.2.18.  statfsres

 *

 *	union statfsres (stat status) {

 *	case NFS_OK:

 *		struct {

 *			unsigned tsize;

 *			unsigned bsize;

 *			unsigned blocks;

 *			unsigned bfree;

 *			unsigned bavail;

 *		} info;

 *	default:

 *		void;

 *	};

/*

 * We need to translate between nfs status return values and

 * the local errno values which may not be the same.

	{ NFSERR_EAGAIN,	-EAGAIN		}, */

/**

 * nfs_stat_to_errno - convert an NFS status code to a local errno

 * @status: NFS status code to convert

 *

 * Returns a local errno value, or -EIO if the NFS status code is

 * not recognized.  This function is used jointly by NFSv2 and NFSv3.

 SPDX-License-Identifier: GPL-2.0

/*

 * linux/fs/nfs/dns_resolve.c

 *

 * Copyright (c) 2009 Trond Myklebust <Trond.Myklebust@netapp.com>

 *

 * Resolves DNS hostnames into valid ip addresses

 SPDX-License-Identifier: GPL-2.0-only

/*

 * fs/nfs/nfs4session.c

 *

 * Copyright (c) 2012 Trond Myklebust <Trond.Myklebust@netapp.com>

 *

/*

 * nfs4_shrink_slot_table - free retired slots from the slot table

/**

 * nfs4_slot_tbl_drain_complete - wake waiters when drain is complete

 * @tbl: controlling slot table

 *

/*

 * nfs4_free_slot - free a slot and efficiently update slot table.

 *

 * freeing a slot is trivially done by clearing its respective bit

 * in the bitmap.

 * If the freed slotid equals highest_used_slotid we want to update it

 * so that the server would be able to size down the slot table if needed,

 * otherwise we know that the highest_used_slotid is still in use.

 * When updating highest_used_slotid there may be "holes" in the bitmap

 * so we need to scan down from highest_used_slotid to 0 looking for the now

 * highest slotid in use.

 * If none found, highest_used_slotid is set to NFS4_NO_SLOT.

 *

 * Must be called while holding tbl->slot_tbl_lock

 clear used bit in bitmap */

 update highest_used_slotid when it is freed */

/*

 * nfs4_try_to_lock_slot - Given a slot try to allocate it

 *

 * Note: must be called with the slot_tbl_lock held.

/*

 * nfs4_lookup_slot - Find a slot but don't allocate it

 *

 * Note: must be called with the slot_tbl_lock held.

/*

 * nfs4_slot_seqid_in_use - test if a slot sequence id is still in use

 *

 * Given a slot table, slot id and sequence number, determine if the

 * RPC call in question is still in flight. This function is mainly

 * intended for use by the callback channel.

/*

 * nfs4_slot_wait_on_seqid - wait until a slot sequence id is complete

 *

 * Given a slot table, slot id and sequence number, wait until the

 * corresponding RPC call completes. This function is mainly

 * intended for use by the callback channel.

/*

 * nfs4_alloc_slot - efficiently look for a free slot

 *

 * nfs4_alloc_slot looks for an unset bit in the used_slots bitmap.

 * If found, we mark the slot as used, update the highest_used_slotid,

 * and respectively set up the sequence operation args.

 *

 * Note: must be called with under the slot_tbl_lock.

/*

 * (re)Initialise a slot table

/*

 * nfs4_release_slot_table - release all slot table entries

/**

 * nfs4_shutdown_slot_table - release resources attached to a slot table

 * @tbl: slot table to shut down

 *

/**

 * nfs4_setup_slot_table - prepare a stand-alone slot table for use

 * @tbl: slot table to set up

 * @max_reqs: maximum number of requests allowed

 * @queue: name to give RPC wait queue

 *

 * Returns zero on success, or a negative errno.

 Update the client's idea of target_highest_slotid */

 Deallocate slots */

/* Try to eliminate outliers by checking for sharp changes in the

 * derivatives and second derivatives

 Is first derivative same sign? */

 Is second derivative same sign? */

/*

 * Initialize or reset the forechannel and backchannel tables

 Fore channel */

 -ENOMEM */

 Back channel */

		/* Fore and back channel share a connection so get

/*

 * With sessions, the client is not marked ready until after a

 * successful EXCHANGE_ID and CREATE_SESSION.

 *

 * Map errors cl_cons_state errors to EPROTONOSUPPORT to indicate

 * other versions of NFS can be tried.

		/*

		 * Do not set NFS_CS_CHECK_LEASE_TIME instead set the

		 * DS lease to be equal to the MDS lease.

 Test for the DS role */

 defined(CONFIG_NFS_V4_1) */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  linux/fs/nfs/file.c

 *

 *  Copyright (C) 1992  Rick Sladkey

 *

 *  Changes Copyright (C) 1994 by Florian La Roche

 *   - Do not copy data too often around in the kernel.

 *   - In nfs_file_read the return value of kmalloc wasn't checked.

 *   - Put in a better version of read look-ahead buffering. Original idea

 *     and implementation by Wai S Kok elekokws@ee.nus.sg.

 *

 *  Expire cache on write to a file by Wai S Kok (Oct 1994).

 *

 *  Total rewrite of read side for new NFS buffer cache.. Linus.

 *

 *  nfs regular file handling functions

 Hack for future NFS swap support */

/*

 * Open file

/**

 * nfs_revalidate_file_size - Revalidate the file size

 * @inode: pointer to inode struct

 * @filp: pointer to struct file

 *

 * Revalidates the file length. This is basically a wrapper around

 * nfs_revalidate_inode() that takes into account the fact that we may

 * have cached writes (in which case we don't care about the server's

 * idea of what the file length is), or O_DIRECT (in which case we

 * shouldn't trust the cache).

	/*

	 * whence == SEEK_END || SEEK_DATA || SEEK_HOLE => we must revalidate

	 * the cached file length

/*

 * Flush all dirty pages, and check for write errors.

 Flush writes to the server and return any errors */

	/* Note: generic_file_mmap() returns ENOSYS on nommu systems

	 *       so we call that before revalidating the mapping

/*

 * Flush any dirty pages for this process, and check for write errors.

 * The return status from this call provides a reliable indication of

 * whether any write errors occurred for this process.

		/*

		 * If nfs_file_fsync_commit detected a server reboot, then

		 * resend all dirty pages that might have been covered by

		 * the NFS_CONTEXT_RESEND_WRITES flag

/*

 * Decide whether a read/modify/write cycle may be more efficient

 * then a modify/write/read cycle when writing to a page in the

 * page cache.

 *

 * Some pNFS layout drivers can only read/write at a certain block

 * granularity like all block devices and therefore we must perform

 * read/modify/write whenever a page hasn't read yet and the data

 * to be written there is not aligned to a block boundary and/or

 * smaller than the block size.

 *

 * The modify/write/read cycle may occur if a page is read before

 * being completely filled by the writer.  In this situation, the

 * page must be completely written to stable storage on the server

 * before it can be refilled by reading in the page from the server.

 * This can lead to expensive, small, FILE_SYNC mode writes being

 * done.

 *

 * It may be more efficient to read the page first if the file is

 * open for reading in addition to writing, the page is not marked

 * as Uptodate, it is not dirty or waiting to be committed,

 * indicating that it was previously allocated and then modified,

 * that there were valid bytes of data in that range of the file,

 * and that the new data won't completely replace the old data in

 * that range of the file.

	/*

	 * Up-to-date pages, those with ongoing or full-page write

	 * don't need read/modify/write

 Open for reading too? */

/*

 * This does the "real" work of the write. We must allocate and lock the

 * page to be sent back to the generic routine, which then copies the

 * data from user space.

 *

 * If the writer ends up delaying the write, the writer needs to

 * increment the page use counts until he is done with the page.

	/*

	 * Zero any uninitialised parts of the page, and then mark the page

	 * as up to date if it turns out that we're extending the file.

/*

 * Partially or wholly invalidate a page

 * - Release the private state associated with a page if undergoing complete

 *   page invalidation

 * - Called if either PG_private or PG_fscache is set on the page

 * - Caller holds page lock

 Cancel any unstarted writes on this page */

/*

 * Attempt to release the private state associated with a page

 * - Called if either PG_private or PG_fscache is set on the page

 * - Caller holds page lock

 * - Return true (may release page) or false (may not)

 If PagePrivate() is set, then the page is not freeable */

	/*

	 * Check if an unstable page is currently being committed and

	 * if so, have the VM treat it as if the page is under writeback

	 * so it will not block due to pages that will shortly be freeable.

	/*

	 * If PagePrivate() is set, then the page is not freeable and as the

	 * inode is not being committed, it's not going to be cleaned in the

	 * near future so treat it as dirty

/*

 * Attempt to clear the private state associated with a page when an error

 * occurs that requires the cached contents of an inode to be written back or

 * destroyed

 * - Called if either PG_private or fscache is set on the page

 * - Caller holds page lock

 * - Return 0 if successful, -error otherwise

/*

 * Notification that a PTE pointing to an NFS page is about to be made

 * writable, implying that someone is about to modify the page through a

 * shared-writable mapping

 make sure the cache has finished storing the page */

	/*

	 * O_APPEND implies that we must revalidate the file length.

 Return error values */

 Try local locking first */

 found a conflict */

	/*

	 * Flush all pending writes before doing anything

	 * with locks..

		/*  NOTE: special case

		 * 	If we're signalled while cleaning up locks on process exit, we

		 * 	still need to complete the unlock.

	/*

	 * Use local locking if mounted with "-onolock" or with appropriate

	 * "-olocal_lock="

	/*

	 * Flush all pending writes before doing anything

	 * with locks..

	/*

	 * Use local locking if mounted with "-onolock" or with appropriate

	 * "-olocal_lock="

	/*

	 * Invalidate cache to prevent missing any changes.  If

	 * the file is mapped, clear the page cache as well so

	 * those mappings will be loaded.

	 *

	 * This makes locking act as a cache coherency point.

/*

 * Lock a (portion of) a file

/*

 * Lock a (portion of) a file

 We're simulating flock() locks using posix locks on the server */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Initialise an NFSv3 ACL client connection

 No errors! Assume that Sun nfsacls are supported */

 Create a client RPC handle for the NFS v3 ACL management interface */

/*

 * Set up a pNFS Data Server client over NFSv3.

 *

 * Return any existing nfs_client that matches server address,port,version

 * and minorversion.

 *

 * For a new nfs_client, use a soft mount (default), a low retrans and a

 * low timeout interval so that if a connection is lost, we retry through

 * the MDS.

 fake a hostname because lockd wants it */

 Use the MDS nfs_client cl_ipaddr. */

/*

 *  Device operations for the pnfs client.

 *

 *  Copyright (c) 2002

 *  The Regents of the University of Michigan

 *  All Rights Reserved

 *

 *  Dean Hildebrand <dhildebz@umich.edu>

 *  Garth Goodson   <Garth.Goodson@netapp.com>

 *

 *  Permission is granted to use, copy, create derivative works, and

 *  redistribute this software and such derivative works for any purpose,

 *  so long as the name of the University of Michigan is not used in

 *  any advertising or publicity pertaining to the use or distribution

 *  of this software without specific, written prior authorization. If

 *  the above copyright notice or any other identification of the

 *  University of Michigan is included in any copy of any portion of

 *  this software, then the disclaimer below must also be included.

 *

 *  This software is provided as is, without representation or warranty

 *  of any kind either express or implied, including without limitation

 *  the implied warranties of merchantability, fitness for a particular

 *  purpose, or noninfringement.  The Regents of the University of

 *  Michigan shall not be liable for any damages, including special,

 *  indirect, incidental, or consequential damages, with respect to any

 *  claim arising out of or in connection with the use of the software,

 *  even if it has been or is hereafter advised of the possibility of

 *  such damages.

/*

 * Device ID RCU cache. A device ID is unique per server and layout type.

	/*

	 * Use the session max response size as the basis for setting

	 * GETDEVICEINFO's maxcount

	/*

	 * Found new device, need to decode it and then add it to the

	 * list of known devices for this mountpoint.

/*

 * Lookup a deviceid in cache and get a reference count on it if found

 *

 * @clp nfs_client associated with deviceid

 * @id deviceid to look up

/*

 * Remove a deviceid from cache

 *

 * @clp nfs_client associated with deviceid

 * @id the deviceid to unhash

 *

 * @ret the unhashed node, if found and dereferenced to zero, NULL otherwise.

 balance the initial ref set in pnfs_insert_deviceid */

/*

 * Dereference a deviceid node and delete it when its reference count drops

 * to zero.

 *

 * @d deviceid node to put

 *

 * return true iff the node was deleted

 * Note that since the test for d->ref == 0 is sufficient to establish

 * that the node is no longer hashed in the global device id cache.

/*

 * Stop use of all deviceids associated with an nfs_client

 SPDX-License-Identifier: GPL-2.0-only

/*

 * linux/fs/nfs/pagelist.c

 *

 * A set of helper functions for managing NFS read and write requests.

 * The main purpose of these routines is to provide support for the

 * coalescing of several requests into a single RPC call.

 *

 * Copyright 2000, 2001 (c) Trond Myklebust <trond.myklebust@fys.uio.no>

 *

/**

 * nfs_iocounter_wait - wait for i/o to complete

 * @l_ctx: nfs_lock_context with io_counter to use

 *

 * returns -ERESTARTSYS if interrupted by a fatal signal.

 * Otherwise returns 0 once the io_count hits 0.

/**

 * nfs_async_iocounter_wait - wait on a rpc_waitqueue for I/O

 * to complete

 * @task: the rpc_task that should wait

 * @l_ctx: nfs_lock_context with io_counter to check

 *

 * Returns true if there is outstanding I/O to wait on and the

 * task has been put to sleep.

/*

 * nfs_page_lock_head_request - page lock the head of the page group

 * @req: any member of the page group

/*

 * nfs_unroll_locks -  unlock all newly locked reqs and wait on @req

 * @head: head request of page group, must be holding head lock

 * @req: request that couldn't lock and needs to wait on the req bit lock

 *

 * This is a helper function for nfs_lock_and_join_requests

 * returns 0 on success, < 0 on error.

 relinquish all the locks successfully grabbed this run */

/*

 * nfs_page_group_lock_subreq -  try to lock a subrequest

 * @head: head request of page group

 * @subreq: request to lock

 *

 * This is a helper function for nfs_lock_and_join_requests which

 * must be called with the head request and page group both locked.

 * On error, it returns with the page group unlocked.

/*

 * nfs_page_group_lock_subrequests -  try to lock the subrequests

 * @head: head request of page group

 *

 * This is a helper function for nfs_lock_and_join_requests which

 * must be called with the head request locked.

 lock each request in the page group */

/*

 * nfs_page_set_headlock - set the request PG_HEADLOCK

 * @req: request that is to be locked

 *

 * this lock must be held when modifying req->wb_head

 *

 * return 0 on success, < 0 on error

/*

 * nfs_page_clear_headlock - clear the request PG_HEADLOCK

 * @req: request that is to be locked

/*

 * nfs_page_group_lock - lock the head of the page group

 * @req: request in group that is to be locked

 *

 * this lock must be held when traversing or modifying the page

 * group list

 *

 * return 0 on success, < 0 on error

/*

 * nfs_page_group_unlock - unlock the head of the page group

 * @req: request in group that is to be unlocked

/*

 * nfs_page_group_sync_on_bit_locked

 *

 * must be called with page group lock held

 true! reset all bits */

/*

 * nfs_page_group_sync_on_bit - set bit on current request, but only

 *   return true if the bit is set for all requests in page group

 * @req - request in page group

 * @bit - PG_* bit that is used to sync page group

/*

 * nfs_page_group_init - Initialize the page group linkage for @req

 * @req - a new nfs request

 * @prev - the previous request in page group, or NULL if @req is the first

 *         or only request in the group (the head).

 a head request */

 a subrequest */

		/* All subrequests take a ref on the head request until

		/* grab extra ref and bump the request count if head request

		 * has extra ref from the write/commit path to handle handoff

/*

 * nfs_page_group_destroy - sync the destruction of page groups

 * @req - request that no longer needs the page group

 *

 * releases the page group reference from each member once all

 * members have called this function.

 unlink and free */

 subrequests must release the ref on the head request */

 try to allocate the request struct */

	/* Initialize the request struct. Initially, we assume a

	 * long write-back delay. This will be adjusted in

/**

 * nfs_create_request - Create an NFS read/write request.

 * @ctx: open context to use

 * @page: page to write

 * @offset: starting offset within the page for the write

 * @count: number of bytes to read/write

 *

 * The page must be locked by the caller. This makes sure we never

 * create two different requests for the same page.

 * User should ensure it is safe to sleep in this function.

 find the last request */

/**

 * nfs_unlock_request - Unlock request and wake up sleepers.

 * @req: pointer to request

/**

 * nfs_unlock_and_release_request - Unlock request and release the nfs_page

 * @req: pointer to request

/*

 * nfs_clear_request - Free up all resources allocated to the request

 * @req:

 *

 * Release page and open context resources associated with a read/write

 * request after it has completed.

/**

 * nfs_free_request - Release the count on an NFS read/write request

 * @req: request to release

 *

 * Note: Should never be called with the spinlock held!

 extra debug: make sure no sync bits are still set */

 Release struct file and open context */

/**

 * nfs_wait_on_request - Wait for a request to complete.

 * @req: request to wait upon.

 *

 * Interruptible by fatal signals only.

 * The user is responsible for holding a count on the request.

/*

 * nfs_generic_pg_test - determine if requests can be coalesced

 * @desc: pointer to descriptor

 * @prev: previous request in desc, or NULL

 * @req: this request

 *

 * Returns zero if @req cannot be coalesced into @desc, otherwise it returns

 * the size of the request.

 should never happen */

	/*

	 * Limit the request size so that we can still allocate a page array

	 * for it without upsetting the slab allocator.

/**

 * nfs_pgio_data_destroy - make @hdr suitable for reuse

 *

 * Frees memory and releases refs from nfs_generic_pgio, so that it may

 * be called again.

 *

 * @hdr: A header that has had nfs_generic_pgio called

/*

 * nfs_pgio_header_free - Free a read or write header

 * @hdr: The header to free

/**

 * nfs_pgio_rpcsetup - Set up arguments for a pageio call

 * @hdr: The pageio hdr

 * @count: Number of bytes to read

 * @how: How to commit data (writes only)

 * @cinfo: Commit information for the call (writes only)

	/* Set up the RPC argument and reply structs

 pnfs_set_layoutcommit needs this */

/**

 * nfs_pgio_prepare - Prepare pageio hdr to go over the wire

 * @task: The current task

 * @calldata: pageio header to prepare

/**

 * nfs_pgio_error - Clean up from a pageio error

 * @hdr: pageio header

/**

 * nfs_pgio_release - Release pageio data

 * @calldata: The pageio header to release

/**

 * nfs_pageio_init - initialise a page io descriptor

 * @desc: pointer to descriptor

 * @inode: pointer to inode

 * @pg_ops: pointer to pageio operations

 * @compl_ops: pointer to pageio completion operations

 * @rw_ops: pointer to nfs read/write operations

 * @bsize: io block size

 * @io_flags: extra parameters for the io function

/**

 * nfs_pgio_result - Basic pageio error handling

 * @task: The task that ran

 * @calldata: Pageio header to check

/*

 * Create an RPC task for the given read or write request and kick it.

 * The page must have been locked by the caller.

 *

 * It may happen that the page we're passed is not marked dirty.

 * This is the case if nfs_updatepage detects a conflicting request

 * that has been written but not committed.

 Set up the argument struct */

/*

 * nfs_pageio_setup_mirroring - determine if mirroring is to be used

 *				by calling the pg_get_mirror_count op

/**

 * nfs_coalesce_size - test two requests for compatibility

 * @prev: pointer to nfs_page

 * @req: pointer to nfs_page

 * @pgio: pointer to nfs_pagio_descriptor

 *

 * The nfs_page structures 'prev' and 'req' are compared to ensure that the

 * page data area they describe is contiguous, and that their RPC

 * credentials, NFSv4 open state, and lockowners are the same.

 *

 * Returns size of the request that can be coalesced

/**

 * nfs_pageio_do_add_request - Attempt to coalesce a request into a page list.

 * @desc: destination io descriptor

 * @req: request

 *

 * If the request 'req' was successfully coalesced into the existing list

 * of pages 'desc', it returns the size of req.

/*

 * Helper for nfs_pageio_add_request and nfs_pageio_complete

/**

 * __nfs_pageio_add_request - Attempt to coalesce a request into a page list.

 * @desc: destination io descriptor

 * @req: request

 *

 * This may split a request into subrequests which are all part of the

 * same page group. If so, it will submit @req as the last one, to ensure

 * the pointer to @req is still valid in case of failure.

 *

 * Returns true if the request 'req' was successfully coalesced into the

 * existing list of pages 'desc'.

 We successfully submitted a request */

 Can't coalesce any more, so do I/O */

 retry add_request for this subreq */

 Create the mirror instances first, and fire them off */

/*

 * nfs_pageio_complete_mirror - Complete I/O on the current mirror of an

 *				nfs_pageio_descriptor

 * @desc: pointer to io descriptor

 * @mirror_idx: pointer to mirror index

/*

 * nfs_pageio_resend - Transfer requests to new descriptor and resend

 * @hdr - the pgio header to move request from

 * @desc - the pageio descriptor to add requests to

 *

 * Try to move each request (nfs_page) from @hdr to @desc then attempt

 * to send them.

 *

 * Returns 0 on success and < 0 on error.

/**

 * nfs_pageio_complete - Complete I/O then cleanup an nfs_pageio_descriptor

 * @desc: pointer to io descriptor

/**

 * nfs_pageio_cond_complete - Conditional I/O completion

 * @desc: pointer to io descriptor

 * @index: page index

 *

 * It is important to ensure that processes don't try to take locks

 * on non-contiguous ranges of pages as that might deadlock. This

 * function should be called before attempting to wait on a locked

 * nfs_page. It will complete the I/O if the page index 'index'

 * is not contiguous with the existing list of pages in 'desc'.

/*

 * nfs_pageio_stop_mirroring - stop using mirroring (set mirror count to 1)

 SPDX-License-Identifier: GPL-2.0

/*

 *  Copyright (C) 1995, 1996  Gero Kuhlmann <gero@gkminix.han.de>

 *

 *  Allow an NFS filesystem to be mounted as root. The way this works is:

 *     (1) Use the IP autoconfig mechanism to set local IP addresses and routes.

 *     (2) Construct the device string and the options string using DHCP

 *         option 17 and/or kernel command line options.

 *     (3) When mount_root() sets up the root file system, pass these strings

 *         to the NFS client's regular mount interface via sys_mount().

 *

 *

 *	Changes:

 *

 *	Alan Cox	:	Removed get_address name clash with FPU.

 *	Alan Cox	:	Reformatted a bit.

 *	Gero Kuhlmann	:	Code cleanup

 *	Michael Rausch  :	Fixed recognition of an incoming RARP answer.

 *	Martin Mares	: (2.0)	Auto-configuration via BOOTP supported.

 *	Martin Mares	:	Manual selection of interface & BOOTP/RARP.

 *	Martin Mares	:	Using network routes instead of host routes,

 *				allowing the default configuration to be used

 *				for normal operation of the host.

 *	Martin Mares	:	Randomized timer with exponential backoff

 *				installed to minimize network congestion.

 *	Martin Mares	:	Code cleanup.

 *	Martin Mares	: (2.1)	BOOTP and RARP made configuration options.

 *	Martin Mares	:	Server hostname generation fixed.

 *	Gerd Knorr	:	Fixed wired inode handling

 *	Martin Mares	: (2.2)	"0.0.0.0" addresses from command line ignored.

 *	Martin Mares	:	RARP replies not tested for server address.

 *	Gero Kuhlmann	: (2.3) Some bug fixes and code cleanup again (please

 *				send me your new patches _before_ bothering

 *				Linus so that I don' always have to cleanup

 *				_afterwards_ - thanks)

 *	Gero Kuhlmann	:	Last changes of Martin Mares undone.

 *	Gero Kuhlmann	: 	RARP replies are tested for specified server

 *				again. However, it's now possible to have

 *				different RARP and NFS servers.

 *	Gero Kuhlmann	:	"0.0.0.0" addresses from command line are

 *				now mapped to INADDR_NONE.

 *	Gero Kuhlmann	:	Fixed a bug which prevented BOOTP path name

 *				from being used (thanks to Leo Spiekman)

 *	Andy Walker	:	Allow to specify the NFS server in nfs_root

 *				without giving a path name

 *	Swen Thümmler	:	Allow to specify the NFS options in nfs_root

 *				without giving a path name. Fix BOOTP request

 *				for domainname (domainname is NIS domain, not

 *				DNS domain!). Skip dummy devices for BOOTP.

 *	Jacek Zapala	:	Fixed a bug which prevented server-ip address

 *				from nfsroot parameter from being used.

 *	Olaf Kirch	:	Adapted to new NFS code.

 *	Jakub Jelinek	:	Free used code segment.

 *	Marko Kohtala	:	Fixed some bugs.

 *	Martin Mares	:	Debug message cleanup

 *	Martin Mares	:	Changed to use the new generic IP layer autoconfig

 *				code. BOOTP and RARP moved there.

 *	Martin Mares	:	Default path now contains host name instead of

 *				host IP address (but host name defaults to IP

 *				address anyway).

 *	Martin Mares	:	Use root_server_addr appropriately during setup.

 *	Martin Mares	:	Rewrote parameter parsing, now hopefully giving

 *				correct overriding.

 *	Trond Myklebust :	Add in preliminary support for NFSv3 and TCP.

 *				Fix bug in root_nfs_addr(). nfs_data.namlen

 *				is NOT for the length of the hostname.

 *	Hua Qin		:	Support for mounting root file system via

 *				NFS over TCP.

 *	Fabian Frederick:	Option parser rebuilt (using parser lib)

 *	Chuck Lever	:	Use super.c's text-based mount option parsing

 *	Chuck Lever	:	Add "nfsrootdebug".

 Default path we try to mount. "%s" gets replaced by our IP address */

 Default NFSROOT mount options. */

 Parameters passed from the kernel command line */

 Text-based mount options passed to super.c */

 Address of NFS server */

 Name of directory to mount */

 server:export path string passed to super.c */

/*

 * When the "nfsrootdebug" kernel command line option is specified,

 * enable debugging messages for NFSROOT.

/*

 *  Parse NFS server and directory information passed on the kernel

 *  command line.

 *

 *  nfsroot=[<server-ip>:]<root-dir>[,<nfs-options>]

 *

 *  If there is a "%s" token in the <root-dir> string, it is replaced

 *  by the ASCII-representation of the client's IP address.

	/*

	 * Extract the IP address of the NFS server containing our

	 * root file system, if one was specified.

	 *

	 * Note: root_nfs_parse_addr() removes the server-ip from

	 *	 nfs_root_parms, if it exists.

/*

 * Parse out root export path and mount options from

 * passed-in string @incoming.

 *

 * Copy the export path into @exppath.

	/*

	 * Set the NFS remote path

	/*

	 * @incoming now points to the rest of the string; if it

	 * contains something, append it to our root options buffer

/*

 *  Decode the export directory path name and NFS options from

 *  the kernel command line.  This has to be done late in order to

 *  use a dynamically acquired client IP address for the remote

 *  root directory path.

 *

 *  Returns zero if successful; otherwise -1 is returned.

	/*

	 * Append mandatory options for nfsroot so they override

	 * what has come before

	/*

	 * Set up nfs_root_device.  For NFS mounts, this looks like

	 *

	 *	server:/path

	 *

	 * At this point, utsname()->nodename contains our local

	 * IP address or hostname, set by ipconfig.  If "%s" exists

	 * in tmp, substitute the nodename, then shovel the whole

	 * mess into nfs_root_device.

/**

 * nfs_root_data - Return prepared 'data' for NFSROOT mount

 * @root_device: OUT: address of string containing NFSROOT device

 * @root_data: OUT: address of string containing NFSROOT mount options

 *

 * Returns zero and sets @root_device and @root_data if successful,

 * otherwise -1 is returned.

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/nfs/symlink.c

 *

 *  Copyright (C) 1992  Rick Sladkey

 *

 *  Optimization changes Copyright (C) 1994 Florian La Roche

 *

 *  Jun 7 1999, cache symlink lookups in the page cache.  -DaveM

 *

 *  nfs symlink handling code

/* Symlink caching in the page cache is even more simplistic

 * and straight-forward than readdir caching.

/*

 * symlinks can't do much...

/*

 *  fs/nfs/nfs4renewd.c

 *

 *  Copyright (c) 2002 The Regents of the University of Michigan.

 *  All rights reserved.

 *

 *  Kendrick Smith <kmsmith@umich.edu>

 *

 *  Redistribution and use in source and binary forms, with or without

 *  modification, are permitted provided that the following conditions

 *  are met:

 *

 *  1. Redistributions of source code must retain the above copyright

 *     notice, this list of conditions and the following disclaimer.

 *  2. Redistributions in binary form must reproduce the above copyright

 *     notice, this list of conditions and the following disclaimer in the

 *     documentation and/or other materials provided with the distribution.

 *  3. Neither the name of the University nor the names of its

 *     contributors may be used to endorse or promote products derived

 *     from this software without specific prior written permission.

 *

 *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED

 *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF

 *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE

 *  DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE

 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR

 *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF

 *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR

 *  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF

 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING

 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS

 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 *

 * Implementation of the NFSv4 "renew daemon", which wakes up periodically to

 * send a RENEW, to keep state alive on the server.  The daemon is implemented

 * as an rpc_task, not a real kernel thread, so it always runs in rpciod's

 * context.  There is one renewd per nfs_server.

 *

 Are we close to a lease timeout? */

 Queue an asynchronous RENEW. */

/**

 * nfs4_set_lease_period - Sets the lease period on a nfs_client

 *

 * @clp: pointer to nfs_client

 * @lease: new value for lease period

 Cap maximum reconnect timeout at 1/2 lease period */

 SPDX-License-Identifier: GPL-2.0

/*

 * nfs3_prepare_get_acl, nfs3_complete_get_acl, nfs3_abort_get_acl: Helpers for

 * caching get_acl results in a race-free way.  See fs/posix_acl.c:get_acl()

 * for explanations.

 Not the first reader or sentinel already in place. */

 Only cache the ACL if our sentinel is still in place. */

 Remove our sentinel upon failure. */

 The xdr layer may allocate pages here. */

	/*

	 * Only get the access acl when explicitly requested: We don't

	 * need it for access decisions, and only some applications use

	 * it. Applications which request the access acl first are not

	 * penalized from this optimization.

 pages may have been allocated at the xdr layer. */

	/* We are doing this here because XDR marshalling does not

 SPDX-License-Identifier: GPL-2.0

/*

 * linux/fs/nfs/nfs4sysctl.c

 *

 * Sysctl interface to NFS v4 parameters

 *

 * Copyright (c) 2006 Trond Myklebust <Trond.Myklebust@netapp.com>

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/nfs/file.c

 *

 *  Copyright (C) 1992  Rick Sladkey

	/*

	 * If no cached dentry exists or if it's negative, NFSv4 handled the

	 * opens in ->lookup() or ->create().

	 *

	 * We only get this far for a cached positive dentry.  We skipped

	 * revalidation, so handle it here by dropping the dentry and returning

	 * -EOPENSTALE.  The VFS will retry the lookup/create/open.

 We can't create new files here */

/*

 * Flush all dirty pages, and check for write errors.

	/*

	 * If we're holding a write delegation, then check if we're required

	 * to flush the i/o on close. If not, then just start the i/o now.

 Flush writes to the server and return any errors */

 Only offload copy if superblock is the same */

	/* if the copy size if smaller than 2 RPC payloads, make it

	 * synchronous

		/*

		 * for inter copy, if copy size is too small

		 * then fallback to generic copy.

 NFS does not support deduplication. */

 check alignment w.r.t. clone_blksize */

 XXX: do we lock at all? what if server needs CB_RECALL_LAYOUT? */

	/* flush all pending writes on both src and dst so that server

	/* truncate inode page cache of the dst range so that future reads can fetch

/**

 * nfs42_ssc_register_ops - Wrapper to register NFS_V4 ops in nfs_common

 *

 * Return values:

 *   None

/**

 * nfs42_ssc_unregister_ops - wrapper to un-register NFS_V4 ops in nfs_common

 *

 * Return values:

 *   None.

 CONFIG_NFS_V4_2 */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * linux/fs/nfs/delegation.c

 *

 * Copyright (C) 2004 Trond Myklebust

 *

 * NFS file delegation management

 *

/**

 * nfs_mark_delegation_referenced - set delegation's REFERENCED flag

 * @delegation: delegation to process

 *

/**

 * nfs4_have_delegation - check if inode has a delegation, mark it

 * NFS_DELEGATION_REFERENCED if there is one.

 * @inode: inode to check

 * @flags: delegation types to check for

 *

 * Returns one if inode has the indicated delegation, otherwise zero.

/*

 * nfs4_check_delegation - check if inode has a delegation, do not mark

 * NFS_DELEGATION_REFERENCED if it has one.

 Block nfs4_proc_unlck */

/**

 * nfs_inode_reclaim_delegation - process a delegation reclaim request

 * @inode: inode to process

 * @cred: credential to use for request

 * @type: delegation type

 * @stateid: delegation stateid

 * @pagemod_limit: write delegation "space_limit"

 *

 We appear to have raced with a delegation return. */

 Refcount matched in nfs_end_delegation_return() */

 smp_mb__before_atomic() is implicit due to xchg() */

/**

 * nfs_inode_set_delegation - set up a delegation on an inode

 * @inode: inode to which delegation applies

 * @cred: cred to use for subsequent delegation processing

 * @type: delegation type

 * @stateid: delegation stateid

 * @pagemod_limit: write delegation "space_limit"

 *

 * Returns zero on success, or a negative errno value.

 Is this an update of the existing delegation? */

		/*

		 * Deal with broken servers that hand out two

		 * delegations for the same file.

		 * Allow for upgrades to a WRITE delegation, but

		 * nothing else.

	/*

	 * If we didn't revalidate the change attribute before setting

	 * the delegation, then pre-emptively ask for a full attribute

	 * cache revalidation.

/*

 * Basic procedure for returning a delegation to the server

 Recall of any remaining application leases */

		/*

		 * Guard against state recovery

 Refcount matched in nfs_start_delegation_return_locked() */

	/*

	 * To avoid quadratic looping we hold a reference

	 * to an inode place_holder.  Each time we restart, we

	 * list delegation in the server from the delegations

	 * of that inode.

	 * prev is an RCU-protected pointer to a delegation which

	 * wasn't marked for return and might be a good choice for

	 * the next place_holder.

/**

 * nfs_client_return_marked_delegations - return previously marked delegations

 * @clp: nfs_client to process

 *

 * Note that this function is designed to be called by the state

 * manager thread. For this reason, it cannot flush the dirty data,

 * since that could deadlock in case of a state recovery error.

 *

 * Returns zero on success, or a negative errno value.

 If a return was delayed, sleep to prevent hard looping */

/**

 * nfs_inode_evict_delegation - return delegation, don't reclaim opens

 * @inode: inode to process

 *

 * Does not protect against delegation reclaims, therefore really only safe

 * to be called from nfs4_clear_inode(). Guaranteed to always free

 * the delegation structure.

/**

 * nfs4_inode_return_delegation - synchronously return a delegation

 * @inode: inode to process

 *

 * This routine will always flush any dirty data to disk on the

 * assumption that if we need to return the delegation, then

 * we should stop caching.

 *

 * Returns zero on success, or a negative errno value.

 Synchronous recall of any application leases */

/**

 * nfs4_inode_return_delegation_on_close - asynchronously return a delegation

 * @inode: inode to process

 *

 * This routine is called on file close in order to determine if the

 * inode delegation needs to be returned immediately.

 Refcount matched in nfs_end_delegation_return() */

/**

 * nfs4_inode_make_writeable

 * @inode: pointer to inode

 *

 * Make the inode writeable by returning the delegation if necessary

 *

 * Returns zero on success, or a negative errno value.

/**

 * nfs_expire_all_delegations

 * @clp: client to process

 *

/**

 * nfs_server_return_all_delegations - return delegations for one superblock

 * @server: pointer to nfs_server to process

 *

 If delegation->stateid is newer, dont mark as returned */

/**

 * nfs_expire_unused_delegation_types

 * @clp: client to process

 * @flags: delegation types to expire

 *

/**

 * nfs_expire_unreferenced_delegations - Eliminate unused delegations

 * @clp: nfs_client to process

 *

/**

 * nfs_async_inode_return_delegation - asynchronously return a delegation

 * @inode: inode to process

 * @stateid: state ID information

 *

 * Returns zero on success, or a negative errno value.

 If there are any application leases or delegations, recall them */

/**

 * nfs_delegation_find_inode - retrieve the inode associated with a delegation

 * @clp: client state handle

 * @fhandle: filehandle from a delegation recall

 *

 * Returns pointer to inode matching "fhandle," or NULL if a matching inode

 * cannot be found.

		/*

		 * If the delegation may have been admin revoked, then we

		 * cannot reclaim it.

/**

 * nfs_delegation_mark_reclaim - mark all delegations as needing to be reclaimed

 * @clp: nfs_client to process

 *

 Match nfs_start_delegation_return_locked */

/**

 * nfs_delegation_reap_unclaimed - reap unclaimed delegations after reboot recovery is done

 * @clp: nfs_client to process

 *

/**

 * nfs_mark_test_expired_all_delegations - mark all delegations for testing

 * @clp: nfs_client to process

 *

 * Iterates through all the delegations associated with this server and

 * marks them as needing to be checked for validity.

/**

 * nfs_test_expired_all_delegations - test all delegations for a client

 * @clp: nfs_client to process

 *

 * Helper for handling "recallable state revoked" status from server.

/**

 * nfs_reap_expired_delegations - reap expired delegations

 * @clp: nfs_client to process

 *

 * Iterates through all the delegations associated with this server and

 * checks if they have may have been revoked. This function is usually

 * expected to be called in cases where the server may have lost its

 * lease.

/**

 * nfs_delegations_present - check for existence of delegations

 * @clp: client state handle

 *

 * Returns one if there are any nfs_delegation structures attached

 * to this nfs_client.

/**

 * nfs4_refresh_delegation_stateid - Update delegation stateid seqid

 * @dst: stateid to refresh

 * @inode: inode to check

 *

 * Returns "true" and updates "dst->seqid" * if inode had a delegation

 * that matches our delegation stateid. Otherwise "false" is returned.

/**

 * nfs4_copy_delegation_stateid - Copy inode's state ID information

 * @inode: inode to check

 * @flags: delegation type requirement

 * @dst: stateid data structure to fill in

 * @cred: optional argument to retrieve credential

 *

 * Returns "true" and fills in "dst->data" * if inode had a delegation,

 * otherwise "false" is returned.

/**

 * nfs4_delegation_flush_on_close - Check if we must flush file on close

 * @inode: inode to check

 *

 * This function checks the number of outstanding writes to the file

 * against the delegation 'space_limit' field to see if

 * the spec requires us to flush the file on close.

 SPDX-License-Identifier: GPL-2.0

/*

 * linux/fs/nfs/cache_lib.c

 *

 * Helper routines for the NFS client caches

 *

 * Copyright (c) 2009 Trond Myklebust <Trond.Myklebust@netapp.com>

	/*

	 * Disable the upcall mechanism if we're getting an ENOENT or

	 * EACCES error. The admin can re-enable it on the fly by using

	 * sysfs to set the 'cache_getent' parameter once the problem

	 * has been fixed.

/*

 * Deferred request handling

 SPDX-License-Identifier: GPL-2.0

/*

* Copyright (C) 2006 Red Hat, Inc. All Rights Reserved.

* Written by David Howells (dhowells@redhat.com)

 Start by getting the root filehandle from the server */

/*

 *  fs/nfs/nfs4proc.c

 *

 *  Client-side procedure declarations for NFSv4.

 *

 *  Copyright (c) 2002 The Regents of the University of Michigan.

 *  All rights reserved.

 *

 *  Kendrick Smith <kmsmith@umich.edu>

 *  Andy Adamson   <andros@umich.edu>

 *

 *  Redistribution and use in source and binary forms, with or without

 *  modification, are permitted provided that the following conditions

 *  are met:

 *

 *  1. Redistributions of source code must retain the above copyright

 *     notice, this list of conditions and the following disclaimer.

 *  2. Redistributions in binary form must reproduce the above copyright

 *     notice, this list of conditions and the following disclaimer in the

 *     documentation and/or other materials provided with the distribution.

 *  3. Neither the name of the University nor the names of its

 *     contributors may be used to endorse or promote products derived

 *     from this software without specific prior written permission.

 *

 *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED

 *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF

 *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE

 *  DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE

 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR

 *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF

 *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR

 *  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF

 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING

 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS

 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 file attributes which can be mapped to nfs attributes */

 Prevent leaks of NFSv4 errors into userland */

/*

 * This is our standard bitmap for GETATTR requests.

 Remove the attributes over which we have full control */

	/*

	 * NFSv4 servers do not return entries for '.' and '..'

	 * Therefore, we fake these entries here.  We let '.'

	 * have cookie 0 and '..' have cookie 1.  Note that

	 * when talking to the server, we always send cookie 0

	 * instead of 1 or 2.

 next */

 cookie, first word */

 cookie, second word */

 entry len */

 entry */

 bitmap length */

 bitmap */

 attribute buffer length */

 next */

 cookie, first word */

 cookie, second word */

 entry len */

 entry */

 bitmap length */

 bitmap */

 attribute buffer length */

/* This is the error handling routine for processes that are allowed

 * to sleep.

 Handled in nfs41_sequence_process() */

 defined(CONFIG_NFS_V4_1) */

				/* We have retried a decent amount, time to

				 * fail

 The following works around a Linux server bug! */

 We failed to handle the error */

/* This is the error handling routine for processes that are allowed

 * to sleep.

		/*

		 * For NFS4ERR_MOVED, the client transport will need to

		 * be recomputed after migration recovery has completed.

/*

 * Return 'true' if 'clp' is using an rpc_client that is integrity protected

 * or 'false' otherwise.

 Bump the slot sequence number */

	/* Be nice to the server: try to ensure that the last transmitted

	 * value for highest_user_slotid <= target_highest_slotid

 don't increment the sequence number if the task wasn't sent */

 Check the SEQUENCE operation status */

 Mark this sequence number as having been acked */

 Update the slot's sequence and clientid lease timer */

 Check sequence flags */

		/*

		 * sr_status remains 1 if an RPC level error occurred.

		 * The server may or may not have processed the sequence

		 * operation..

		/* The server detected a resend of the RPC call and

		 * returned NFS4ERR_DELAY as per Section 2.10.6.2

		 * of RFC5661.

		/*

		 * The server thinks we tried to replay a request.

		 * Retry the call after bumping the sequence ID.

		/*

		 * The slot id we used was probably retired. Try again

		 * using a different slot id.

		/*

		 * Were one or more calls using this slot interrupted?

		 * If the server never received the request, then our

		 * transmitted slot sequence number may be too high. However,

		 * if the server did receive the request then it might

		 * accidentally give us a reply with a mismatched operation.

		 * We can sort this out by sending a lone sequence operation

		 * to the server on the same slot.

		/*

		 * RFC5661:

		 * A retry might be sent while the original request is

		 * still in progress on the replier. The replier SHOULD

		 * deal with the issue by returning NFS4ERR_DELAY as the

		 * reply to SEQUENCE or CB_SEQUENCE operation, but

		 * implementations MAY return NFS4ERR_SEQ_MISORDERED.

		 *

		 * Restart the search after a delay.

 Just update the slot sequence no. */

 The session may be reset by one of the error handlers. */

 !CONFIG_NFS_V4_1 */

 !CONFIG_NFS_V4_1 */

 slot already allocated? */

 The state manager will wait until the slot table is empty */

 Try again in 1/4 second */

 Want no delegation if we're using O_DIRECT */

	/* ask server to check for all possible rights as results

 CONFIG_NFS_V4_1 */

/*

 * Check for whether or not the caller may update the open stateid

 * to the value passed in by stateid.

 *

 * Note: This function relies heavily on the server implementing

 * RFC7530 Section 9.1.4.2, and RFC5661 Section 8.2.2

 * correctly.

 * i.e. The stateid seqids have to be initialised to 1, and

 * are then incremented on every state transition.

 The common case - we're updating to a new sequence number */

 The server returned a new stateid */

 This is the first OPEN in this generation */

 Handle OPEN+OPEN_DOWNGRADE races */

 Ignore, if the CLOSE argment doesn't match the current stateid */

 Rely on seqids for serialisation with NFSv4.0 */

		/*

		 * Ensure we process the state changes in the same order

		 * in which the server processed them by delaying the

		 * update of the stateid until we are in sequence.

	/*

	 * Protect the call to nfs4_state_set_mode_locked and

	 * serialise the stateid update

	/*

	 * Protect the call to nfs4_state_set_mode_locked and

	 * serialise the stateid update

 Save the delegation */

 Try to update the stateid using the delegation */

/*

 * Check the inode attributes against the CLAIM_PREVIOUS returned attributes

 * and update the nfs4_state.

 cached opens have already been processed */

 memory barrier prior to reading state->n_* */

	/*

	 * We may have performed cached opens for all three recoveries.

	 * Check if we need to update the current stateid.

/*

 * OPEN_RECLAIM:

 * 	reclaim state on the server after a reboot.

 Don't recall a delegation if it was lost */

 If this request hasn't been cancelled, do nothing */

 In case of error, no cleanup! */

/*

 * Note: On error, nfs4_proc_open_confirm will free the struct nfs4_opendata

	/*

	 * Check if we still need to send an OPEN call, or if we can use

	 * a delegation instead.

 Update client id. */

 Set the create mode (note dependency on the session type) */

			/* don't put an ACCESS op in OPEN compound if O_EXCL,

			 * because ACCESS will return permission denied for

 If this request hasn't been cancelled, do nothing */

 In case of error, no cleanup! */

 In case we need an open_confirm, no cleanup! */

/*

 * Additional permission checks in order to distinguish between an

 * open for read, and an open for execute. This works around the

 * fact that NFSv4 OPEN treats read and execute permissions as being

 * the same.

 * Note that in the non-execute case, we want to turn off permission

 * checking if we just created a new file (POSIX open() semantics).

	/* access call failed or for some reason the server doesn't

	/*

	 * Use openflags to check for exec, because fmode won't

	 * always have FMODE_EXEC set when file open for exec.

 ONLY check for exec rights */

/*

 * Note: On error, nfs4_proc_open will free the struct nfs4_opendata

/*

 * OPEN_EXPIRED:

 * 	reclaim state on the server after a network partition.

 * 	Assumes caller holds the appropriate lock

 NFSv4.0 doesn't allow for delegation recovery on open expire */

 Ack the revoked state to the server */

 Get the delegation credential for use by test/free_stateid */

/**

 * nfs41_check_expired_locks - possibly free a lock stateid

 *

 * @state: NFSv4 state for an inode

 *

 * Returns NFS_OK if recovery for this stateid is now finished.

 * Otherwise a negative NFS4ERR value is returned.

/**

 * nfs41_check_open_stateid - possibly free an open stateid

 *

 * @state: NFSv4 state for an inode

 *

 * Returns NFS_OK if recovery for this stateid is now finished.

 * Otherwise a negative NFS4ERR value is returned.

/*

 * on an EXCLUSIVE create, the server should send back a bitmask with FATTR4-*

 * fields corresponding to attributes that were used to store the verifier.

 * Make sure we clobber those fields in the later setattr call

 d_splice_alias() can't fail here - it's a non-directory */

 Parse layoutget results before we check for access */

/*

 * Returns a referenced nfs4_state

 Protect against reboot recovery conflicts */

		/*

		 * send create attributes which was not set by open

		 * with an extra setattr.

		/* NOTE: BAD_SEQID means the server and client disagree about the

		 * book-keeping w.r.t. state-changing operations

		 * (OPEN/CLOSE/LOCK/LOCKU...)

		 * It is actually a sign of a bug on the client or on the server.

		 *

		 * If we receive a BAD_SEQID error in the particular case of

		 * doing an OPEN, we assume that nfs_increment_open_seqid() will

		 * have unhashed the old state_owner for us, and that we can

		 * therefore safely retry using a new one. We should still warn

		 * the user though...

		/*

		 * BAD_STATEID on OPEN means that the server cancelled our

		 * state before it received the OPEN_CONFIRM.

		 * Recover by retrying the request as per the discussion

		 * on Page 181 of RFC3530.

 We must have found a delegation */

 Servers should only apply open mode checks for file size changes */

 Use that stateid */

/*

 * Update the seqid of an open stateid

/*

 * Update the seqid of an open stateid after receiving

 * NFS4ERR_OLD_STATEID

 Did another OPEN bump the state's seqid?  try again: */

 server says we're behind but we haven't seen the update yet */

 we slept the whole 5 seconds, we must have lost a seqid */

 Handle Layoutreturn errors */

	/* hmm. we are done with the inode, and in the process of freeing

	 * the state_owner. we keep this around to process errors

 Did we race with OPEN? */

 Calculate the change in open mode */

 Note: exit _without_ calling nfs4_close_done */

 Close-to-open cache consistency revalidation */

/* 

 * It is possible for data to be read/written from a mem-mapped file 

 * after the sys_close call (which hits the vfs layer as a flush).

 * This means that we can't safely call nfsv4 close on a file until 

 * the inode is cleared. This in turn means that we are not good

 * NFSv4 citizens - we do not indicate to the server to update the file's 

 * share state even when we are done with one of the three share 

 * stateid's in the inode.

 *

 * NOTE: Caller must be holding the sp->so_owner semaphore!

 Serialization for the sequence id */

 Protect against concurrent sillydeletes */

 Sanity check the server answers */

 Avoid a regression due to buggy server */

	/*

	 * Process the label in the upcoming getfattr

/*

 * Retry pseudoroot lookup with various security flavors.  We do this when:

 *

 *   NFSv4.0: the PUTROOTFH operation returns NFS4ERR_WRONGSEC

 *   NFSv4.1: the server does not support the SECINFO_NO_NAME operation

 *

 * Returns zero on success, or a negative NFS4ERR value, or a

 * negative errno value.

 Per 3530bis 15.33.5 */

 courtesy */

 try each flavor specified by user */

 no flavors specified by user, try default list */

	/*

	 * -EACCES could mean that the user doesn't have correct permissions

	 * to access the mount.  It could also mean that we tried to mount

	 * with a gss auth flavor, but rpc.gssd isn't running.  Either way,

	 * existing mount programs don't handle -EACCES very well so it should

	 * be mapped to -EPERM instead.

/**

 * nfs4_proc_get_rootfh - get file handle for server's pseudoroot

 * @server: initialized nfs_server handle

 * @fhandle: we fill in the pseudo-fs root file handle

 * @info: we fill in an FSINFO struct

 * @auth_probe: probe the auth flavours

 *

 * Returns zero on success, or a negative errno.

/*

 * Get locations and (maybe) other attributes of a referral.

 * Note that we'll actually follow the referral later when

 * we detect fsid mismatch in inode revalidation

	/*

	 * If the fsid didn't change, this is a migration event, not a

	 * referral.  Cause us to drop into the exception handler, which

	 * will kick off migration recovery.

 Fixup attributes for the nfs_lookup() call to nfs_fhget() */

 replace the lookup nfs_fattr with the locations nfs_fattr */

 Is this is an attribute revalidation, subject to softreval? */

/* 

 * The file is not closed if it is opened due to the a request to change

 * the size of the file. The open call will not be needed once the

 * VFS layer lookup-intents are implemented.

 *

 * Close is called when the inode is destroyed.

 * If we haven't opened the file for O_WRONLY, we

 * need to in the size_change case to obtain a stateid.

 *

 * Got race?

 * Because OPEN is always done by name in nfsv4, it is

 * possible that we opened a different file by the same

 * name.  We can recognize this race condition, but we

 * can't do anything about it besides returning an error.

 *

 * This will be fixed with VFS changes (lookup-intent).

 Deal with open(O_TRUNC) */

 Optimization: if the end result is no change, don't RPC */

 Search for an existing open(O_WRITE) file */

 Return any delegations if we're going to change ACLs */

 Is this is an attribute revalidation, subject to softreval? */

/*

 * TODO: For the time being, we don't try to get any attributes

 * along with any of the zero-copy operations READ, READDIR,

 * READLINK, WRITE.

 *

 * In the case of the first three, we want to put the GETATTR

 * after the read-type operation -- this is because it is hard

 * to predict the length of a GETATTR response in v4, and thus

 * align the READ data correctly.  This means that the GETATTR

 * may end up partially falling into the page cache, and we should

 * shift it into the 'tail' of the xdr_buf before processing.

 * To do this efficiently, we need to know the total length

 * of data received, which doesn't seem to be available outside

 * of the RPC layer.

 *

 * In the case of WRITE, we also want to put the GETATTR after

 * the operation -- in this case because we want to make sure

 * we get the post-operation mtime and size.

 *

 * Both of these changes to the XDR layer would in fact be quite

 * minor, but I decided to leave them for a subsequent patch.

/*

 * This is just for mknod.  open(O_CREAT) will always do ->open_context().

 Removing a directory decrements nlink in the parent */

 Note: If we moved a directory, nlink will change */

 Creating a directory bumps nlink in the parent */

 block layout checks this! */

 None of the pathconf attributes are mandatory to implement */

 If the current stateid represents a lost lock, then exit */

 Note: We don't use READ_PLUS with pNFS yet */

 CONFIG_NFS_V4_2 */

 Don't request attributes for pNFS or O_DIRECT writes */

	/* Otherwise, request attributes if and only if we don't hold

	 * a delegation

/*

 * nfs4_proc_async_renew(): This is not one of the nfs_rpc_ops; it is a special

 * standalone procedure for queueing an asynchronous RENEW.

 Unless we're shutting down, schedule state recovery! */

/* Assuming that XATTR_SIZE_MAX is a multiple of PAGE_SIZE, and that

 * it's OK to put sizeof(void) * (XATTR_SIZE_MAX/PAGE_SIZE) bytes on

 * the stack.

 user is just asking for length */

 see getxattr(2) man page */

/*

 * The getxattr API returns the required buffer length when called with a

 * NULL buf. The NFSv4 acl tool then calls getxattr again after allocating

 * the required buf.  On a NULL buf, we send a page of data to the server

 * guessing that the ACL request can be serviced by a page. If so, we cache

 * up to the page of ACL data, and the 2nd call to getxattr is serviced by

 * the cache. If not so, we throw away the page, and cache the required

 * length. The next getxattr call will then produce another round trip to

 * the server, this time with the input buf of the required size.

 for decoding across pages */

 Handle the case where the passed-in buffer is too short */

 Did the user only issue a request for the acl length? */

		/* -ENOENT is returned if there is no ACL or if there is an ACL

 You can't remove system.nfs4_acl: */

	/*

	 * Free each page after tx, so the only ref left is

	 * held by the network stack

	/*

	 * Acl update can result in inode attribute update.

	 * so mark the attribute cache invalid.

			/*

			 * no need to retry since the kernel

			 * isn't involved in encoding the ACEs.

 CONFIG_NFS_V4_SECURITY_LABEL */

		/* An impossible timestamp guarantees this value

	/*

	 * Since this string is allocated at mount time, and held until the

	 * nfs_client is destroyed, we can use GFP_KERNEL here w/o worrying

	 * about a memory-reclaim deadlock.

	/*

	 * Since this string is allocated at mount time, and held until the

	 * nfs_client is destroyed, we can use GFP_KERNEL here w/o worrying

	 * about a memory-reclaim deadlock.

/*

 * nfs4_callback_up_net() starts only "tcp" and "tcp6" callback

 * services.  Advertise one based on the address family of the

 * clientaddr.

/**

 * nfs4_proc_setclientid - Negotiate client ID

 * @clp: state data structure

 * @program: RPC program for NFSv4 callback service

 * @port: IP port number for NFS4 callback service

 * @cred: credential to use for this call

 * @res: where to place the result

 *

 * Returns zero, a negative errno, or a negative NFS4ERR status code.

 nfs_client_id4 */

 cb_client4 */

/**

 * nfs4_proc_setclientid_confirm - Confirm client ID

 * @clp: state data structure

 * @arg: result of a previous SETCLIENTID

 * @cred: credential to use for this call

 *

 * Returns zero, a negative errno, or a negative NFS4ERR status code.

 Handle Layoutreturn errors */

/*

 * Update the seqid of a lock stateid after receiving

 * NFS4ERR_OLD_STATEID

 Ensure we don't close file until we're done freeing locks! */

 Note: exit _without_ running nfs4_locku_done */

	/* Ensure this is an unlock - when canceling a lock, the

	 * canceled lock is passed in, and it won't be an unlock.

 Unlock _before_ we do the RPC call */

 Exclude nfs_delegation_claim_locks() */

 Exclude nfs4_reclaim_open_stateid() - note nesting! */

 Is this a delegated lock? */

 Do we need to do an open_to_lock_owner? */

 Cache the lock if possible... */

 Yes: cache locks! */

 ...but avoid races with delegation recall... */

 NULL key means to wake up everyone */

 Only wake if the callback was for the same owner. */

 Make sure it's for the right inode */

 Don't bother with waitqueue if we don't expect a callback */

 !CONFIG_NFS_V4_1 */

 verify open state */

	/*

	 * Don't rely on the VFS having checked the file open mode,

	 * since it won't do this for flock() locks.

 No delegation, no lease */

 We raced with a delegation return */

	/*

	 * There is no mapping from the MAY_* flags to the NFS_ACCESS_XA*

	 * flags right now. Handling of xattr operations use the normal

	 * file read/write permissions.

	 *

	 * Just in case the server has other ideas (which RFC 8276 allows),

	 * do a cached access check for the XA* flags to possibly avoid

	 * doing an RPC and getting EACCES back.

 CONFIG_NFS_V4_2 */

/*

 * nfs_fhget will use either the mounted_on_fileid or the fileid

	/* Ask for the fileid of the absent filesystem if mounted_on_fileid

/*

 * This operation also signals the server that this client is

 * performing migration recovery.  The server can stop returning

 * NFS4ERR_LEASE_MOVED to this client.  A RENEW operation is

 * appended to this compound to identify the client ID which is

 * performing recovery.

 skip LOOKUP */

 append RENEW */

/*

 * This operation also signals the server that this client is

 * performing migration recovery.  The server can stop asserting

 * SEQ4_STATUS_LEASE_MOVED for this client.  The client ID

 * performing this operation is identified in the SEQUENCE

 * operation in this compound.

 *

 * When the client supports GETATTR(fs_locations_info), it can

 * be plumbed in here.

 skip LOOKUP */

 CONFIG_NFS_V4_1 */

/**

 * nfs4_proc_get_locations - discover locations for a migrated FSID

 * @inode: inode on FSID that is migrating

 * @locations: result of query

 * @page: buffer

 * @cred: credential to use for this operation

 *

 * Returns NFS4_OK on success, a negative NFS4ERR status code if the

 * operation failed, or a negative errno if a local error occurred.

 *

 * On success, "locations" is filled in, but if the server has

 * no locations information, NFS_ATTR_FATTR_V4_LOCATIONS is not

 * asserted.

 *

 * -NFS4ERR_LEASE_MOVED is returned if the server still has leases

 * from this client that require migration recovery.

/*

 * This operation also signals the server that this client is

 * performing "lease moved" recovery.  The server can stop

 * returning NFS4ERR_LEASE_MOVED to this client.  A RENEW operation

 * is appended to this compound to identify the client ID which is

 * performing recovery.

 append RENEW */

/*

 * This operation also signals the server that this client is

 * performing "lease moved" recovery.  The server can stop asserting

 * SEQ4_STATUS_LEASE_MOVED for this client.  The client ID performing

 * this operation is identified in the SEQUENCE operation in this

 * compound.

 CONFIG_NFS_V4_1 */

/**

 * nfs4_proc_fsid_present - Is this FSID present or absent on server?

 * @inode: inode on FSID to check

 * @cred: credential to use for this operation

 *

 * Server indicates whether the FSID is present, moved, or not

 * recognized.  This operation is necessary to clear a LEASE_MOVED

 * condition for this client ID.

 *

 * Returns NFS4_OK if the FSID is present on this server,

 * -NFS4ERR_MOVED if the FSID is no longer present, a negative

 *  NFS4ERR code if some error occurred on the server, or a

 *  negative errno if a local failure occurred.

/*

 * If 'use_integrity' is true and the state managment nfs_client

 * cl_rpcclient is using krb5i/p, use the integrity protected cl_rpcclient

 * and the machine credential as per RFC3530bis and RFC5661 Security

 * Considerations sections. Otherwise, just use the user cred with the

 * filesystem's rpc_client.

 try to use integrity protection with machine cred */

		/*

		 * if unable to use integrity protection, or SECINFO with

		 * integrity protection returns NFS4ERR_WRONGSEC (which is

		 * disallowed by spec, but exists in deployed servers) use

		 * the current filesystem's rpc_client and the user cred.

/*

 * Check the exchange flags returned by the server for invalid flags, having

 * both PNFS and NON_PNFS flags set, and not having one of NON_PNFS, PNFS, or

 * DS flags set.

/*

 * nfs4_proc_bind_one_conn_to_session()

 *

 * The 4.1 client currently uses the same TCP connection for the

 * fore and backchannel.

 Do not set the backchannel flag unless this is clnt->cl_xprt */

/*

 * Minimum set of SP4_MACH_CRED operations from RFC 5661 in the enforce map

 * and operations we'd like to see to enable certain features in the allow map

/*

 * Select the state protection mode for client `clp' given the server results

 * from exchange_id in `sp'.

 *

 * Returns 0 on success, negative errno otherwise.

 Print state protect result */

 make sure nothing is on enforce list that isn't supported */

		/*

		 * Minimal mode - state operations are allowed to use machine

		 * credential.  Note this already happens by default, so the

		 * client doesn't have to do anything more than the negotiation.

		 *

		 * NOTE: we don't care if EXCHANGE_ID is in the list -

		 *       we're already using the machine cred for exchange_id

		 *       and will never use a different cred.

/*

 * _nfs4_proc_exchange_id()

 *

 * Wrapper for EXCHANGE_ID operation.

 unsupported! */

/*

 * _nfs4_proc_exchange_id()

 *

 * Wrapper for EXCHANGE_ID operation.

 Client ID is not confirmed */

 Save the EXCHANGE_ID verifier session trunk tests */

/*

 * nfs4_proc_exchange_id()

 *

 * Returns zero, a negative errno, or a negative NFS4ERR status code.

 *

 * Since the clientid has expired, all compounds using sessions

 * associated with the stale clientid will be returning

 * NFS4ERR_BADSESSION in the sequence operation, and will therefore

 * be in some phase of session reset.

 *

 * Will attempt to negotiate SP4_MACH_CRED if krb5i / krb5p auth is used.

 try SP4_MACH_CRED if krb5i/p	*/

 try SP4_NONE */

/**

 * nfs4_test_session_trunk

 *

 * This is an add_xprt_test() test function called from

 * rpc_clnt_setup_test_and_add_xprt.

 *

 * The rpc_xprt_switch is referrenced by rpc_clnt_setup_test_and_add_xprt

 * and is dereferrenced in nfs4_exchange_id_release

 *

 * Upon success, add the new transport to the rpc_clnt

 *

 * @clnt: struct rpc_clnt to get new transport

 * @xprt: the rpc_xprt to test

 * @data: call data for _nfs4_proc_exchange_id.

 Test connection for session trunking. Async exchange_id call */

 CONFIG_NFS_V4_1 */

	/* just setup sequence, do not trigger session recovery

/*

 * Called from nfs4_state_manager thread for session setup, so don't recover

 * from sequence operation or clientid errors.

/*

 * Initialize the values to be used by the client in CREATE_SESSION

 * If nfs4_init_session set the fore channel request and response sizes,

 * use them.

 *

 * Set the back channel max_resp_sz_cached to zero to force the client to

 * always set csa_cachethis to FALSE because the current implementation

 * of the back channel DRC only supports caching the CB_SEQUENCE operation.

 Fore channel attributes */

 Back channel attributes */

	/*

	 * Our requested max_ops is the minimum we need; we're not

	 * prepared to break up compounds into smaller pieces than that.

	 * So, no point even trying to continue if the server won't

	 * cooperate:

 Mark client id and session as being confirmed */

 Verify the session's negotiated channel_attrs values */

 Increment the clientid slot sequence id */

/*

 * Issues a CREATE_SESSION operation to the server.

 * It is the responsibility of the caller to verify the session is

 * expired before calling this routine.

 Init or reset the session slot tables */

/*

 * Issue the over-the-wire RPC DESTROY_SESSION.

 * The caller must serialize access to this routine.

 session is still being setup */

/*

 * Renew the cl_session lease.

 What to do here? */

/*

 * Issue a global reclaim complete.

	/*

	 * NFS4ERR_LAYOUTUNAVAILABLE means we are not supposed to use pnfs

	 * on the file. set tk_status to -ENODATA to tell upper layer to

	 * retry go inband.

	/*

	 * NFS4ERR_BADLAYOUT means the MDS cannot return a layout of

	 * length lgp->args.minlength != 0 (see RFC5661 section 18.43.3).

	/*

	 * NFS4ERR_LAYOUTTRYLATER is a conflict with another client

	 * (or clients) writing to the same RAID stripe except when

	 * the minlength argument is 0 (see RFC5661 section 18.43.3).

	 *

	 * Treat it like we would RECALLCONFLICT -- we retry for a little

	 * while, and then eventually give up.

 If the open stateid was bad, then recover it. */

		/*

		 * Mark the bad layout state as invalid, then retry

	/*

	 * Was there an RPC level error? Assume the call succeeded,

	 * and that we need to release the layout

 Just ignore these failures */

 layout was recalled */

 no IOMODE_RW layout for range */

 no layout */

 loca_recalim always false */

/*

 * Use the state managment nfs_client cl_rpcclient, which uses krb5i (if

 * possible) as per RFC3530bis and RFC5661 Security Considerations sections

 first try using integrity protection */

 try to use integrity protection with machine cred */

		/*

		 * if unable to use integrity protection, or SECINFO with

		 * integrity protection returns NFS4ERR_WRONGSEC (which is

		 * disallowed by spec, but exists in deployed servers) use

		 * the current filesystem's rpc_client and the user cred.

	/*

	 * Fall back on "guess and check" method if

	 * the server doesn't support SECINFO_NO_NAME

/**

 * nfs41_test_stateid - perform a TEST_STATEID operation

 *

 * @server: server / transport on which to perform the operation

 * @stateid: state ID to test

 * @cred: credential

 *

 * Returns NFS_OK if the server recognizes that "stateid" is valid.

 * Otherwise a negative NFS4ERR value is returned if the operation

 * failed or the state ID is not currently valid.

/**

 * nfs41_free_stateid - perform a FREE_STATEID operation

 *

 * @server: server / transport on which to perform the operation

 * @stateid: state ID to release

 * @cred: credential

 * @privileged: set to true if this call needs to be privileged

 *

 * Note: this function is always asynchronous.

 CONFIG_NFS_V4_1 */

 CONFIG_NFS_V4_1 */

 CONFIG_NFS_V4_1 */

 CONFIG_NFS_V4_1 */

 protocol version */

/*

 * fs/nfs/idmap.c

 *

 *  UID and GID to name mapping for clients.

 *

 *  Copyright (c) 2002 The Regents of the University of Michigan.

 *  All rights reserved.

 *

 *  Marius Aamodt Eriksen <marius@umich.edu>

 *

 *  Redistribution and use in source and binary forms, with or without

 *  modification, are permitted provided that the following conditions

 *  are met:

 *

 *  1. Redistributions of source code must retain the above copyright

 *     notice, this list of conditions and the following disclaimer.

 *  2. Redistributions in binary form must reproduce the above copyright

 *     notice, this list of conditions and the following disclaimer in the

 *     documentation and/or other materials provided with the distribution.

 *  3. Neither the name of the University nor the names of its

 *     contributors may be used to endorse or promote products derived

 *     from this software without specific prior written permission.

 *

 *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED

 *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF

 *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE

 *  DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE

 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR

 *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF

 *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR

 *  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF

 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING

 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS

 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/**

 * nfs_fattr_init_names - initialise the nfs_fattr owner_name/group_name fields

 * @fattr: fully initialised struct nfs_fattr

 * @owner_name: owner name string cache

 * @group_name: group name string cache

/**

 * nfs_fattr_free_names - free up the NFSv4 owner and group strings

 * @fattr: a fully initialised nfs_fattr structure

/**

 * nfs_fattr_map_and_free_names - map owner/group strings into uid/gid and free

 * @server: pointer to the filesystem nfs_server structure

 * @fattr: a fully initialised nfs_fattr structure

 *

 * This helper maps the cached NFSv4 owner/group strings in fattr into

 * their numeric uid/gid equivalents, and then frees the cached strings.

/*

 * Assemble the description to pass to request_key()

 * This function will allocate a new string and update dest to point

 * at it.  The caller is responsible for freeing dest.

 *

 * On error 0 is returned.  Otherwise, the length of dest is returned.

 ID -> Name */

 Name -> ID */

 idmap classic begins here */

 msg and im are freed in idmap_pipe_destroy_msg */

 ret = -ENOKEY */

 Note: here we store the NUL terminator too */

	/* If instantiation is successful, anyone waiting for key construction

	 * will have been woken up and someone else may now have used

	 * idmap_key_cons - so after this point we may no longer touch it.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2019 Hammerspace Inc

 Strip trailing '\n' */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2015, Primary Data, Inc. All rights reserved.

 *

 * Tao Peng <bergwolf@primarydata.com>

 inode fileid high */

 inode fileid low */

 inode type */

 embeded server fh */

/*

 * Let's break subtree checking for now... otherwise we'll have to embed parent fh

 * but there might not be enough space.

 Padding */

 NULL translates to ESTALE */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * linux/fs/nfs/direct.c

 *

 * Copyright (C) 2003 by Chuck Lever <cel@netapp.com>

 *

 * High-performance uncached I/O for the Linux NFS client

 *

 * There are important applications whose performance or correctness

 * depends on uncached access to file data.  Database clusters

 * (multiple copies of the same instance running on separate hosts)

 * implement their own cache coherency protocol that subsumes file

 * system cache protocols.  Applications that process datasets

 * considerably larger than the client's memory do not always benefit

 * from a local cache.  A streaming video server, for instance, has no

 * need to cache the contents of a file.

 *

 * When an application requests uncached I/O, all read and write requests

 * are made directly to the server; data stored or fetched via these

 * requests is not cached in the Linux page cache.  The client does not

 * correct unaligned requests from applications.  All requested bytes are

 * held on permanent storage before a direct write system call returns to

 * an application.

 *

 * Solaris implements an uncached I/O facility called directio() that

 * is used for backups and sequential I/O to very large files.  Solaris

 * also supports uncaching whole NFS partitions with "-o forcedirectio,"

 * an undocumented mount option.

 *

 * Designed by Jeff Kimmel, Chuck Lever, and Trond Myklebust, with

 * help from Andrew Morton.

 *

 * 18 Dec 2001	Initial implementation for 2.4  --cel

 * 08 Jul 2002	Version for 2.4.19, with bug fixes --trondmy

 * 08 Jun 2003	Port to 2.5 APIs  --cel

 * 31 Mar 2004	Handle direct I/O without VFS support  --cel

 * 15 Sep 2004	Parallel async reads  --cel

 * 04 May 2005	support O_DIRECT with aio  --cel

 *

 release manager */

 I/O parameters */

 file open context info */

 Lock context info */

 controlling i/o request */

 target file of i/o */

 completion state */

 i/os we're waiting for */

 protect completion state */

 Start offset for I/O */

 bytes actually processed */

 max expected count */

 bytes left to be sent */

 any reported error */

 wait for i/o completion */

 commit state */

 Storage for cinfo */

 Storage for cinfo */

 for write */

 an unstable reply was received */

 write verification failed */

 for read */

 dirty user-space page after read */

 write verification failed */

 Clear outstanding error if this is EOF */

/**

 * nfs_direct_IO - NFS address space operation for direct I/O

 * @iocb: target I/O control block

 * @iter: I/O buffer

 *

 * The presence of this routine in the address space ops vector means

 * the NFS client supports direct I/O. However, for most direct IO, we

 * shunt off direct read and write requests before the VFS gets them,

 * so this method is only ever called for swap.

 we only support swap file calling nfs_direct_IO */

/*

 * Collects and returns the final error value/byte-count.

 Async requests don't wait here */

/*

 * Synchronous I/O uses a stack-allocated iocb.  Thus we can't trust

 * the iocb is still valid here if this is a synchronous request.

/*

 * For each rsize'd chunk of the user's buffer, dispatch an NFS READ

 * operation.  If nfs_readdata_alloc() or get_user_pages() fails,

 * bail and stop sending more reads.  Read length accounting is

 * handled automatically by nfs_direct_read_result().  Otherwise, if

 * no requests have been sent, just return an error.

 XXX do we need to do the eof zeroing found in async_filler? */

	/*

	 * If no bytes were started, return the error, and let the

	 * generic layer handle the completion.

/**

 * nfs_file_direct_read - file direct read operation for NFS files

 * @iocb: target I/O control block

 * @iter: vector of user buffers into which to read data

 *

 * We use this function for direct reads instead of calling

 * generic_file_aio_read() in order to avoid gfar's check to see if

 * the request starts before the end of the file.  For that check

 * to work, we must generate a GETATTR before each direct read, and

 * even then there is a window between the GETATTR and the subsequent

 * READ where the file size could change.  Our preference is simply

 * to do all reads the application wants, and the server will take

 * care of managing the end of file boundary.

 *

 * This function also eliminates unnecessarily updating the file's

 * atime locally, as the NFS server sets the file's atime, and this

 * client must read the updated atime from the server back into its

 * cache.

 Bump the transmission count */

 Errors in commit are fatal */

			/*

			 * Despite the reboot, the write was successful,

			 * so reset wb_nio.

 Error or match */

 res == -ENOMEM */

 Calls nfs_direct_write_schedule_work */

 fake unstable write to let common nfs resend pages */

/*

 * NB: Return the value of the first error return code.  Subsequent

 *     errors after the first one are ignored.

/*

 * For each wsize'd chunk of the user's buffer, dispatch an NFS WRITE

 * operation.  If nfs_writedata_alloc() or get_user_pages() fails,

 * bail and stop sending more writes.  Write length accounting is

 * handled automatically by nfs_direct_write_result().  Otherwise, if

 * no requests have been sent, just return an error.

	/*

	 * If no bytes were started, return the error, and let the

	 * generic layer handle the completion.

/**

 * nfs_file_direct_write - file direct write operation for NFS files

 * @iocb: target I/O control block

 * @iter: vector of user buffers from which to write data

 *

 * We use this function for direct writes instead of calling

 * generic_file_aio_write() in order to avoid taking the inode

 * semaphore and updating the i_size.  The NFS server will set

 * the new i_size and this client must read the updated size

 * back into its cache.  We let the server do generic write

 * parameter checking and report problems.

 *

 * We eliminate local atime updates, see direct read above.

 *

 * We avoid unnecessary page cache invalidations for normal cached

 * readers of this file.

 *

 * Note that O_APPEND is not supported for NFS direct writes, as there

 * is no atomic O_APPEND write facility in the NFS protocol.

 XXX: should check the generic_write_sync retval */

/**

 * nfs_init_directcache - create a slab cache for nfs_direct_req structures

 *

/**

 * nfs_destroy_directcache - destroy the slab cache for nfs_direct_req structures

 *

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Common NFS I/O  operations for the pnfs file based

 * layout drivers.

 *

 * Copyright (c) 2014, Primary Data, Inc. All rights reserved.

 *

 * Tom Haynes <loghyr@primarydata.com>

 Fake up some data that will cause nfs_commit_release to retry the writes. */

 Note this may cause RPC to be resent */

/* The generic layer is about to remove the req from the commit list.

 * If this will make the bucket empty, it will need to put the lseg reference.

 * Note this must be called holding nfsi->commit_mutex

/*

 * Locks the nfs_page requests for commit and moves them to

 * @bucket->committing.

/* Move reqs from written to committing lists, returning count

 * of number moved.

 Pull everything off the committing lists and dump into @dst.  */

	/* Linearly search the commit lists for each bucket until a matching

/* pnfs_generic_search_commit_reqs - Search lists in @cinfo for the head reqest

 *				   for @page

 * @cinfo - commit info for current inode

 * @page - page to search for matching head request

 *

 * Returns a the head request if one is found, otherwise returns NULL.

 Clean up on error */

 This follows nfs_commit_list pretty closely */

/*

 * Data server cache

 *

 * Data servers can be mapped to different device ids.

 * nfs4_pnfs_ds reference counting

 *   - set to 1 on allocation

 *   - incremented when a device id maps a data server already in the cache.

 *   - decremented when deviceid is removed from the cache.

 Debug routines */

 LINKLOCAL addresses must have matching scope_id */

/*

 * Checks if 'dsaddrs1' contains a subset of 'dsaddrs2'. If it does,

 * declare a match.

/*

 * Lookup DS by addresses.  nfs4_ds_cache_lock is held

/*

 * Create a string with a human readable address and port to avoid

 * complicated setup around many dprinks.

 '{', '}' and eol */

 string plus comma */

/*

 * Given a list of multipath struct nfs4_pnfs_ds_addr, add it to ds cache if

 * uncached and return cached struct nfs4_pnfs_ds.

 this is only used for debugging, so it's ok if its NULL */

 Add this address as an alias */

			/**

			* Test this address for session trunking and

			* add as an alias

/*

 * Create an rpc connection to the nfs4_pnfs_ds data server.

 * Currently only supports IPv4 and IPv6 addresses.

 * If connection fails, make devid unavailable and return a -errno.

	/*

	 * At this point the ds->ds_clp should be ready, but it might have

	 * hit an error.

/*

 * Currently only supports ipv4, ipv6 and one multi-path address.

 r_netid */

 r_addr: ip/ip6addr with port in dec octets - see RFC 5665 */

 port is ".ABC.DEF", 8 chars max */

 replace port '.' with '-' */

 find '.' between address and port */

 save human readable address */

 NULL is ok, only used for dprintk */

	/* Non-empty buckets hold a reference on the lseg.  That ref

	 * is normally transferred to the COMMIT call and released

	 * there.  It could also be released if the last req is pulled

	 * off due to a rewrite, in which case it will be done in

	 * pnfs_common_clear_request_commit

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2012 Bryan Schumaker <bjschuma@netapp.com>

/*

 * Clean out any remaining NFSv4 state that might be left over due

 * to open() calls that passed nfs_atomic_lookup, but failed to call

 * nfs_open().

 If we are holding a delegation, return and free it */

 Note that above delegreturn would trigger pnfs return-on-close */

 First call standard NFS clear_inode() code */

 We leave export_path unset as it's not used to find the root. */

 Does hostname needs to be enclosed in brackets? */

	/* We create a mount for the server's root, walk to the requested

	 * location and then create another mount for that.

/*

 * Create an NFS4 server record on referral traversal

 create a new volume representation */

 Not called in the _init(), conditionally loaded */

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/nfs/proc.c

 *

 *  Copyright (C) 1992, 1993, 1994  Rick Sladkey

 *

 *  OS-independent nfs remote procedure call functions

 *

 *  Tuned by Alan Cox <A.Cox@swansea.ac.uk> for >3K buffers

 *  so at last we can have decent(ish) throughput off a 

 *  Sun server.

 *

 *  Coding optimized and cleaned up by Florian La Roche.

 *  Note: Error returns are optimized for NFS_OK, which isn't translated via

 *  nfs_stat_to_errno(), but happens to be already the right return code.

 *

 *  Also, the code currently doesn't check the size of the packet, when

 *  it decodes the packet.

 *

 *  Feel free to fix it and mail me the diffs if it worries you.

 *

 *  Completely rewritten to support the new RPC call interface;

 *  rewrote and moved the entire XDR stuff to xdr.c

 *  --Olaf Kirch June 1996

 *

 *  The code below initializes all auto variables explicitly, otherwise

 *  it will fail to work as a module (gcc generates a memset call for an

 *  incomplete struct).

/*

 * Bare-bones access to getattr: this is for nfs_read_super.

 Retry with default authentication if different */

 Retry with default authentication if different */

/*

 * One function for each procedure in the NFS protocol.

 Is this is an attribute revalidation, subject to softreval? */

 Mask out the non-modebit related stuff from attr->ia_mode */

 Is this is an attribute revalidation, subject to softreval? */

/*

 * In NFSv2, mknod is grafted onto the create call.

 get out your barf bag */

	/*

	 * V2 SYMLINK requests don't return any attributes.  Setting the

	 * filehandle size to zero indicates to nfs_instantiate that it

	 * should fill in the data with a LOOKUP call on the wire.

/*

 * The READDIR implementation is somewhat hackish - we pass a temporary

 * buffer to the encode function, which installs it in the receive

 * the receive iovec. The decode function just parses the reply to make

 * sure it is syntactically correct; the entries itself are decoded

 * from nfs_readdir by calling the decode_entry function directly.

		/* Emulate the eof flag, which isn't normally needed in NFSv2

		 * as it is guaranteed to always return the file attributes

 Note: NFSv2 ignores @stable and always uses NFS_FILE_SYNC */

 Helper functions for NFS lock bounds checking */

 protocol version */

 access */

/*

 *  fs/nfs/nfs4state.c

 *

 *  Client-side XDR for NFSv4.

 *

 *  Copyright (c) 2002 The Regents of the University of Michigan.

 *  All rights reserved.

 *

 *  Kendrick Smith <kmsmith@umich.edu>

 *

 *  Redistribution and use in source and binary forms, with or without

 *  modification, are permitted provided that the following conditions

 *  are met:

 *

 *  1. Redistributions of source code must retain the above copyright

 *     notice, this list of conditions and the following disclaimer.

 *  2. Redistributions in binary form must reproduce the above copyright

 *     notice, this list of conditions and the following disclaimer in the

 *     documentation and/or other materials provided with the distribution.

 *  3. Neither the name of the University nor the names of its

 *     contributors may be used to endorse or promote products derived

 *     from this software without specific prior written permission.

 *

 *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED

 *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF

 *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE

 *  DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE

 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR

 *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF

 *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR

 *  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF

 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING

 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS

 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 *

 * Implementation of the NFSv4 state model.  For the time being,

 * this is minimal, but will be made much more complex in a

 * subsequent patch.

 Funky initialiser keeps older gcc versions happy */

 Funky initialiser keeps older gcc versions happy */

/**

 * nfs40_discover_server_trunking - Detect server IP address trunking (mv0)

 *

 * @clp: nfs_client under test

 * @result: OUT: found nfs_client, or clp

 * @cred: credential to use for trunking test

 *

 * Returns zero, a negative errno, or a negative NFS4ERR status.

 * If zero is returned, an nfs_client pointer is planted in

 * "result".

 *

 * Note: The returned client may not yet be marked ready.

		/* Sustain the lease, even if it's empty.  If the clientid4

 If the client state need to recover, do it. */

 Force root creds instead of machine */

/**

 * nfs4_get_renew_cred - Acquire credential for a renew operation

 * @clp: client state handle

 *

 * Returns an rpc_cred with reference count bumped, or NULL.

 * Caller must hold clp->cl_lock.

 Use machine credentials if available */

 back channel */

 fore channel */

 create_session negotiated new slot table */

/**

 * nfs41_discover_server_trunking - Detect server IP address trunking (mv1)

 *

 * @clp: nfs_client under test

 * @result: OUT: found nfs_client, or clp

 * @cred: credential to use for trunking test

 *

 * Returns NFS4_OK, a negative errno, or a negative NFS4ERR status.

 * If NFS4_OK is returned, an nfs_client pointer is planted in

 * "result".

 *

 * Note: The returned client may not yet be marked ready.

	/*

	 * Purge state if the client id was established in a prior

	 * instance and the client id could not have arrived on the

	 * server via Transparent State Migration.

 CONFIG_NFS_V4_1 */

/**

 * nfs4_get_clid_cred - Acquire credential for a setclientid operation

 * @clp: client state handle

 *

 * Returns a cred with reference count bumped, or NULL.

/*

 * nfs4_alloc_state_owner(): this is called on the OPEN or CREATE path to

 * create a new state_owner.

 *

	/* This state_owner is no longer usable, but must

	 * remain in place so that state recovery can find it

	 * and the opens associated with it.

	 * It may also be used for new 'open' request to

	 * return a delegation to the server.

	 * So update the 'create_time' so that it looks like

	 * a new state_owner.  This will cause the server to

	 * request an OPEN_CONFIRM to start a new sequence.

 NB: LRU is sorted so that oldest is at the head */

/**

 * nfs4_get_state_owner - Look up a state owner given a credential

 * @server: nfs_server to search

 * @cred: RPC credential to match

 * @gfp_flags: allocation mode

 *

 * Returns a pointer to an instantiated nfs4_state_owner struct, or NULL.

/**

 * nfs4_put_state_owner - Release a nfs4_state_owner

 * @sp: state owner data to release

 *

 * Note that we keep released state owners on an LRU

 * list.

 * This caches valid state owners so that they can be

 * reused, to avoid the OPEN_CONFIRM on minor version 0.

 * It also pins the uniquifier of dropped state owners for

 * a while, to ensure that those state owner names are

 * never reused.

/**

 * nfs4_purge_state_owners - Release all cached state owners

 * @server: nfs_server with cached state owners to release

 * @head: resulting list of state owners

 *

 * Called at umount time.  Remaining state owners will be on

 * the LRU with ref count of zero.

 * Note that the state owners are not freed, but are added

 * to the list @head, which can later be used as an argument

 * to nfs4_free_state_owners.

/**

 * nfs4_free_state_owners - Release all cached state owners

 * @head: resulting list of state owners

 *

 * Frees a list of state owners that was generated by

 * nfs4_purge_state_owners

 NB! List reordering - see the reclaim code for why.  */

		/* Note: The reclaim code dictates that we add stateless

/*

 * Close the current file.

 Protect against nfs4_find_state() */

/*

 * Search the state->lock_states for an existing lock_owner

 * that is compatible with either of the given owners.

 * If the second is non-zero, then the first refers to a Posix-lock

 * owner (current->files) and the second refers to a flock/OFD

 * owner (struct file*).  In that case, prefer a match for the first

 * owner.

 * If both sorts of locks are held on the one file we cannot know

 * which stateid was intended to be used, so a "correct" choice cannot

 * be made.  Failing that, a "consistent" choice is preferable.  The

 * consistent choice we make is to prefer the first owner, that of a

 * Posix lock.

/*

 * Return a compatible lock_state. If no initialized lock_state structure

 * exists, return an uninitialized one.

 *

/*

 * Return a compatible lock_state. If no initialized lock_state structure

 * exists, return an uninitialized one.

 *

/*

 * Release reference to lock_state, and free it if we see that

 * it is no longer in use

/*

 * Byte-range lock aware utility to initialize the stateid of read/write

 * requests.

 A lost lock - don't even consider delegations */

 returns true if delegation stateid found and copied */

		/* nfs4_copy_delegation_stateid() didn't over-write

		 * dst, so it still has the lock stateid which we now

		 * choose to use.

/*

 * Increment the seqid if the OPEN/OPEN_DOWNGRADE/CLOSE succeeded, or

 * failed with a seqid incrementing error -

 * see comments nfs4.h:seqid_mutating_error()

 Non-seqid mutating errors */

	/*

	 * Note: no locking needed as we are guaranteed to be first

	 * on the sequence list

/*

 * Increment the seqid if the LOCK/LOCKU succeeded, or

 * failed with a seqid incrementing error -

 * see comments nfs4.h:seqid_mutating_error()

/*

 * Schedule the nfs_client asynchronous state management routine

	/* The rcu_read_lock() is not strictly necessary, as the state

	 * manager is the only thread that ever changes the rpc_xprt

/*

 * Schedule a lease recovery attempt

/**

 * nfs4_schedule_migration_recovery - trigger migration recovery

 *

 * @server: FSID that is migrating

 *

 * Returns zero if recovery has started, otherwise a negative NFS4ERR

 * value is returned.

/**

 * nfs4_schedule_lease_moved_recovery - start lease-moved recovery

 *

 * @clp: server to check for moved leases

 *

/*

 * nfs40_handle_cb_pathdown - return all delegations after NFS4ERR_CB_PATH_DOWN

 * @clp: client to process

 *

 * Set the NFS4CLNT_LEASE_EXPIRED state in order to force a

 * resend of the SETCLIENTID and hence re-establish the

 * callback channel. Then return all existing delegations.

 Don't recover state that expired before the reboot */

 Guard against delegation returns and new lock/unlock calls */

 !CONFIG_NFS_V4_2 */

 CONFIG_NFS_V4_2 */

 CONFIG_NFS_V4_2 */

	/* Note: we rely on the sp->so_states list being ordered 

	 * so that we always reclaim open(O_RDWR) and/or open(O_WRITE)

	 * states first.

	 * This is needed to ensure that the server won't give us any

	 * read delegations that we have to return if, say, we are

	 * recovering after a network partition or a reboot from a

	 * server that doesn't support a grace period.

 CONFIG_NFS_V4_2 */

 Open state on this file cannot be recovered */

 CONFIG_NFS_V4_2 */

 Mark all delegations for reclaim */

 Notify the server we're done reclaiming our state */

 Zero session reset errors */

 Is the client already known to have an expired lease? */

/* Set NFS4CLNT_LEASE_EXPIRED and reclaim reboot state for all v4.0 errors

 * and for recoverable errors on EXCHANGE_ID for v4.1

 Lease confirmation error: retry after purging the lease */

	case -NFS4ERR_NOT_SAME: /* FixMe: implement recovery

/*

 * Returns zero or a negative errno.  NFS4ERR values are converted

 * to local errno values.

/*

 * Try remote migration of one FSID from a source server to a

 * destination server.  The source server provides a list of

 * potential destinations.

 *

 * Returns zero or a negative NFS4ERR status code.

/*

 * Returns zero or a negative NFS4ERR status code.

/*

 * Test each nfs_server on the clp's cl_superblocks list to see

 * if it's moved to another server.  Stop when the server no longer

 * returns NFS4ERR_LEASE_MOVED.

 wasn't this one */

 there are more */

/**

 * nfs4_discover_server_trunking - Detect server IP address trunking

 *

 * @clp: nfs_client under test

 * @result: OUT: found nfs_client, or clp

 *

 * Returns zero or a negative errno.  If zero is returned,

 * an nfs_client pointer is planted in "result".

 *

 * Note: since we are invoked in process context, and

 * not from inside the state manager, we cannot use

 * nfs4_handle_reclaim_lease_error().

 No point in retrying if we already used RPC_AUTH_UNIX */

		/* Note: this is safe because we haven't yet marked the

		 * client as ready, so we are the only user of

		 * clp->cl_rpcclient

	case -NFS4ERR_NOT_SAME: /* FixMe: implement recovery

 Use CHECK_LEASE to ping the server with a SEQUENCE */

 FIXME: For now, we destroy all layouts. */

	/*

	 * If we're called from the state manager thread, then assume we're

	 * already handling the RECLAIM_NEEDED and/or STATE_REVOKED.

	 * Those flags are expected to remain set until we're done

	 * recovering (see RFC5661, section 18.46.3).

 Note: IOMODE_READ + IOMODE_RW == IOMODE_ANY */

 CONFIG_NFS_V4_1 */

 CONFIG_NFS_V4_1 */

 Ensure exclusive access to NFSv4 state */

 We're going to have to re-establish a clientid */

 Initialize or reset the session */

 Send BIND_CONN_TO_SESSION */

 First recover reboot state... */

 Detect expired delegations... */

 Now recover expired state... */

 Did we race with an attempt to give us more work? */

/*

 *  fs/nfs/nfs4xdr.c

 *

 *  Client-side XDR for NFSv4.

 *

 *  Copyright (c) 2002 The Regents of the University of Michigan.

 *  All rights reserved.

 *

 *  Kendrick Smith <kmsmith@umich.edu>

 *  Andy Adamson   <andros@umich.edu>

 *

 *  Redistribution and use in source and binary forms, with or without

 *  modification, are permitted provided that the following conditions

 *  are met:

 *

 *  1. Redistributions of source code must retain the above copyright

 *     notice, this list of conditions and the following disclaimer.

 *  2. Redistributions in binary form must reproduce the above copyright

 *     notice, this list of conditions and the following disclaimer in the

 *     documentation and/or other materials provided with the distribution.

 *  3. Neither the name of the University nor the names of its

 *     contributors may be used to endorse or promote products derived

 *     from this software without specific prior written permission.

 *

 *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED

 *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF

 *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE

 *  DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE

 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR

 *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF

 *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR

 *  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF

 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING

 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS

 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 Mapping from NFS error code to "errno" error code. */

 NFSv4 COMPOUND tags are only wanted for debugging purposes */

/* lock,open owner id:

 * we currently use size 2 (u64) out of (NFS4_OPAQUE_LIMIT  >> 2)

 PI(4 bytes) + LFS(4 bytes) + 1(for null terminator?) + MAXLABELLEN */

 We support only one layout type per file system */

 This is based on getfattr, which uses the most attributes: */

/* The 5 accounts for the PNFS attributes, and assumes that at most three

 * layout types will be returned.

 lease time */ + \

 max filesize */ + \

 max read */ + \

 max write */ + \

 time delta */ + \

 fs layout types */ + \

 layout blksize */ + \

 clone blksize */ + \

 change attr type */ + \

 xattr support */)

 client name */ \

 sc_prog */ + \

 sc_cb_ident */

 clientid */ + \

 co_ownerid.len */ + \

 eia_clientowner */ \

 flags */ + \

 spa_how */ + \

 max is SP4_MACH_CRED (for now) */ + \

 implementation id array of size 1 */ + \

 nii_domain */ + \

 nii_name */ + \

 nii_date */)

 eir_clientid */ + \

 eir_sequenceid */ + \

 eir_flags */ + \

 spr_how */ + \

 max is SP4_MACH_CRED (for now) */ + \

 eir_server_owner.so_minor_id */ + \

 eir_server_owner.so_major_id<> */ \

 eir_server_scope<> */ \

 eir_server_impl_id array length */ + \

 nii_domain */ + \

 nii_name */ + \

 nii_date */)

 ca_rdma_ird.len (0) */)

 ca_rdma_ird.len */ + \

 ca_rdma_ird */)

 csa_clientid */ + \

 csa_sequence */ + \

 csa_flags */ + \

 csa_cb_program */ + \

 csa_sec_parms.len (1) */ + \

 cb_secflavor (AUTH_SYS) */ + \

 stamp */ + \

 machinename.len */ + \

 uid */ + \

 gid */ + \

 gids.len (0) */)

 csr_sequence */ + \

 csr_flags */ + \

 bctsa_sessid */ \

 bctsa_dir */ + \

 bctsa_use_conn_in_rdma_mode */)

 bctsr_sessid */ \

 bctsr_dir */ + \

 bctsr_use_conn_in_rdma_mode */)

 layout type */ + \

 maxcount */ + \

 bitmap size */ + \

 notification bitmap length */ + \

 notification bitmap, word 0 */)

 layout type */ + \

 opaque devaddr4 length */ + \

 devaddr4 payload is read into page */ \

 notification bitmap length */ + \

 notification bitmap, word 0 */ + \

 possible XDR padding */)

 offset */ + \

 length */ + \

 reclaim */ + \

 new offset (true) */ + \

 last byte written */ + \

 nt_timechanged (false) */ + \

 layoutupdate4 layout type */ + \

 layoutupdate4 opaqueue len */)

				  /* the actual content of layoutupdate4 should

				     be allocated by drivers and spliced in

 CONFIG_NFS_V4_1 */

 CONFIG_NFS_V4_1 */

 XXX: large enough? */

 XXX: large enough? */

 CONFIG_NFS_V4_1 */

 expected reply words */

 Trim empty words */

	/* initialize running count of expected bytes in reply.

	 * NOTE: the replied tag SHOULD be the same is the one sent,

	/*

	 * We reserve enough space to write the entire attribute buffer at once.

 XXX */

 goto out; */

 goto out; */

 out: */

/*

 * opcode,type,reclaim,offset,length,new_lock_owner = 32

 * open_seqid,open_stateid,lock_seqid,lock_owner.clientid, lock_owner.id = 40

 for linux, share_deny = 0 always */

 /*

 * opcode 4, seqid 4, share_access 4, share_deny 4, clientid 8, ownerlen 4,

 * owner 4 = 32

 Use mounted_on_fileid only if the server supports it */

 NFSv4.1 operations */

 implementation id array length=1 */

 just send zeros for nii_date - the date is in nii_name */

 implementation id array length=0 */

	/*

	 * Assumes OPEN is the biggest non-idempotent compound.

	 * 2 is the verifier.

Sequence id */

flags */

 Fore Channel */

 header padding size */

 max req size */

 max resp size */

 Max resp sz cached */

 max operations */

 max requests */

 rdmachannel_attrs */

 Back Channel */

 header padding size */

 max req size */

 max resp size */

 Max resp sz cached */

 max operations */

 max requests */

 rdmachannel_attrs */

 cb_program */

 auth_sys */

 authsys_parms rfc1831 */

 stamp */

 UID */

 GID */

 No more gids */

 CONFIG_NFS_V4_1 */

	/*

	 * Sessionid + seqid + slotid + max slotid + cache_this

 CONFIG_NFS_V4_1 */

 gdia_maxcount */

 bitmap length */

 Signal layout available */

 Only whole file layouts */

 offset */

 length */

 reclaim */

 newoffset = TRUE */

 newoffset = FALSE */

 Never send time_modify_changed */

 type */

 reclaim. always 0 for now */

 CONFIG_NFS_V4_1 */

/*

 * END OF "GENERIC" ENCODE ROUTINES.

 CONFIG_NFS_V4_1 */

/*

 * Encode an ACCESS request

/*

 * Encode LOOKUP request

/*

 * Encode LOOKUPP request

/*

 * Encode LOOKUP_ROOT request

/*

 * Encode REMOVE request

/*

 * Encode RENAME request

/*

 * Encode LINK request

/*

 * Encode CREATE request

/*

 * Encode SYMLINK request

/*

 * Encode GETATTR request

/*

 * Encode a CLOSE request

/*

 * Encode an OPEN request

/*

 * Encode an OPEN_CONFIRM request

/*

 * Encode an OPEN request with no attributes.

/*

 * Encode an OPEN_DOWNGRADE request

/*

 * Encode a LOCK request

/*

 * Encode a LOCKT request

/*

 * Encode a LOCKU request

/*

 * Encode a READLINK request

/*

 * Encode a READDIR request

/*

 * Encode a READ request

/*

 * Encode an SETATTR request

/*

 * Encode a GETACL request

/*

 * Encode a WRITE request

/*

 *  a COMMIT request

/*

 * FSINFO request

/*

 * a PATHCONF request

/*

 * a STATFS request

/*

 * GETATTR_BITMAP request

/*

 * a RENEW request

/*

 * a SETCLIENTID request

/*

 * a SETCLIENTID_CONFIRM request

/*

 * DELEGRETURN request

/*

 * Encode FS_LOCATIONS request

/*

 * Encode SECINFO request

/*

 * Encode FSID_PRESENT request

/*

 * BIND_CONN_TO_SESSION request

/*

 * EXCHANGE_ID request

/*

 * a CREATE_SESSION request

/*

 * a DESTROY_SESSION request

/*

 * a DESTROY_CLIENTID request

/*

 * a SEQUENCE request

/*

 * a GET_LEASE_TIME request

/*

 * a RECLAIM_COMPLETE request

/*

 * Encode GETDEVICEINFO request

	/* set up reply kvec. device_addr4 opaque data is read into the

/*

 *  Encode LAYOUTGET request

/*

 *  Encode LAYOUTCOMMIT request

/*

 * Encode LAYOUTRETURN request

/*

 * Encode SECINFO_NO_NAME request

/*

 *  Encode TEST_STATEID request

/*

 *  Encode FREE_STATEID request

 CONFIG_NFS_V4_1 */

 Dummy routine */

 a root pathname is sent as a zero component4 */

 Ignore borken servers that return unrequested attrs */

 layout type */

 thi_hintset bitmap */

 thi_hintlist length */

 thi_hintlist */

/*

 * Thresholds on pNFS direct I/O vrs MDS I/O

 Did the server return an unrequested attribute? */

/*

 * Decode potentially multiple layout types.

 pNFS is not supported by the underlying file system */

 Decode and set first layout type, move xdr->p past unused types */

 If we get too many, then just cap it at the max */

/*

 * The type of file system exported.

 * Note we must ensure that layouttype is set in any non-error case.

/*

 * The prefered block size for layout directed io

/*

 * The granularity of a CLONE operation.

 ??? */

 Zero handle first to allow comparisons */

/*

 * We create the owner, so we know a proper owner.id length is 4.

 read 32 bytes */

 read 2 8-byte long words */

 4 byte read */

 manipulate file lock */

 read 8 bytes */

 read 4 bytes */  
 variable size field */

 This is too sick! */

 Ignore for now */

 Convert length of symlink */

	/*

	 * The XDR encode routine has set things up so that

	 * the link text will be copied directly into the

	 * buffer.  We just have to do overflow-checking,

	 * and null-terminate the text (the VFS expects

	 * null-termination).

		/* The bitmap (xdr len + bitmaps) and the attr xdr len words

		 * are stored with the acl data to handle the problem of

 Check for receive buffer overflow */

 skip netid string */

 skip uaddr string */

 server_owner4.so_minor_id */

 server_owner4.so_major_id */

 server_scope4 */

 Implementation Id */

 nii_domain */

 nii_name */

 nii_date */

 if there's more than one entry, ignore the rest */

 headerpadsz */

 no support for header padding yet */

 skip rdma_attrs */

 dir flags, rdma mode bool */

 seqid, flags */

 Channel attributes */

 CONFIG_NFS_V4_1 */

	/*

	 * If the server returns different values for sessionID, slotID or

	 * sequence number, the server is looney tunes.

 seqid */

 slot id */

 highest slot id */

 target highest slot id */

 result flags */

 CONFIG_NFS_V4_1 */

 CONFIG_NFS_V4_1 */

	/*

	 * Get the length of the opaque device_addr4. xdr_read_pages places

	 * the opaque device_addr4 in the xdr_buf->pages (pnfs_device->pages)

	 * and places the remaining xdr data in xdr_buf->tail

 Parse notification bitmap, verifying that it is zero. */

		/* We only handle a length one array at the moment.  Any

		 * further entries are just ignored.  Note that this means

		 * the client may see a response that is less than the

		 * minimum it requested.

 throw away new size */

 CONFIG_NFS_V4_1 */

/*

 * END OF "GENERIC" DECODE ROUTINES.

/*

 * Decode OPEN_DOWNGRADE response

/*

 * Decode ACCESS response

/*

 * Decode LOOKUP response

/*

 * Decode LOOKUPP response

/*

 * Decode LOOKUP_ROOT response

/*

 * Decode REMOVE response

/*

 * Decode RENAME response

/*

 * Decode LINK response

	/*

	 * Note order: OP_LINK leaves the directory as the current

	 *             filehandle.

/*

 * Decode CREATE response

/*

 * Decode SYMLINK response

/*

 * Decode GETATTR response

/*

 * Encode an SETACL request

/*

 * Decode SETACL response

/*

 * Decode GETACL response

/*

 * Decode CLOSE response

/*

 * Decode OPEN response

/*

 * Decode OPEN_CONFIRM response

/*

 * Decode OPEN response

/*

 * Decode SETATTR response

/*

 * Decode LOCK response

/*

 * Decode LOCKT response

/*

 * Decode LOCKU response

/*

 * Decode READLINK response

/*

 * Decode READDIR response

/*

 * Decode Read response

/*

 * Decode WRITE response

/*

 * Decode COMMIT response

/*

 * Decode FSINFO response

/*

 * Decode PATHCONF response

/*

 * Decode STATFS response

/*

 * Decode GETATTR_BITMAP response

/*

 * Decode RENEW response

/*

 * Decode SETCLIENTID response

/*

 * Decode SETCLIENTID_CONFIRM response

/*

 * Decode DELEGRETURN response

/*

 * Decode FS_LOCATIONS response

/*

 * Decode SECINFO response

/*

 * Decode FSID_PRESENT response

/*

 * Decode BIND_CONN_TO_SESSION response

/*

 * Decode EXCHANGE_ID response

/*

 * Decode CREATE_SESSION response

/*

 * Decode DESTROY_SESSION response

/*

 * Decode DESTROY_CLIENTID response

/*

 * Decode SEQUENCE response

/*

 * Decode GET_LEASE_TIME response

/*

 * Decode RECLAIM_COMPLETE response

/*

 * Decode GETDEVINFO response

/*

 * Decode LAYOUTGET response

/*

 * Decode LAYOUTRETURN response

/*

 * Decode LAYOUTCOMMIT response

/*

 * Decode SECINFO_NO_NAME response

/*

 * Decode TEST_STATEID response

/*

 * Decode FREE_STATEID response

 CONFIG_NFS_V4_1 */

/**

 * nfs4_decode_dirent - Decode a single NFSv4 directory entry stored in

 *                      the local page cache.

 * @xdr: XDR stream where entry resides

 * @entry: buffer to fill in with entry data

 * @plus: boolean indicating whether this should be a readdirplus entry

 *

 * Returns zero if successful, otherwise a negative errno value is

 * returned.

 *

 * This function is not invoked during READDIR reply decoding, but

 * rather whenever an application invokes the getdents(2) system call

 * on a directory already in our cache.

	/*

	 * In case the server doesn't return an inode number,

	 * we fake one here.  (We don't use inode number 0,

	 * since glibc seems to choke on it...)

/*

 * We need to translate between nfs status return values and

 * the local errno values which may not be the same.

/*

 * Convert an NFS error code to a local one.

 * This one is used jointly by NFSv2 and NFSv3.

 The server is looney tunes. */

	/* If we cannot translate the error, the recovery routines should

	 * handle it.

	 * Note: remaining NFSv4 error codes have values > 10000, so should

	 * not conflict with native Linux error codes.

 CONFIG_NFS_V4_2 */

 SPDX-License-Identifier: GPL-2.0

/*

 * linux/fs/nfs/nfs4namespace.c

 *

 * Copyright (C) 2005 Trond Myklebust <Trond.Myklebust@netapp.com>

 * - Modified by David Howells <dhowells@redhat.com>

 *

 * NFSv4 namespace

/*

 * Work out the length that an NFSv4 path would render to as a standard posix

 * path, with a leading slash but no terminating slash.

 Adding "/foo" */

/*

 * Convert the NFSv4 pathname components into a standard posix path.

/*

 * return the path component of "<server>:<path>"

 *  nfspath - the "<server>:<path>" string

 *  end - one past the last char that could contain "<server>:"

 * returns NULL on failure

 parse [] escaped IPv6 addrs */

 otherwise split on first colon */

/*

 * Determine the mount path as a string

/*

 * Check that fs_locations::fs_root [RFC3530 6.3] is a prefix for what we

 * believe to be the server path to this dentry

/**

 * nfs_find_best_sec - Find a security mechanism supported locally

 * @clnt: pointer to rpc_clnt

 * @server: NFS server struct

 * @flavors: List of security tuples returned by SECINFO procedure

 *

 * Return an rpc client that uses the first security mechanism in

 * "flavors" that is locally supported.  The "flavors" array

 * is searched in the order returned from the server, per RFC 3530

 * recommendation and each flavor is checked for membership in the

 * sec= mount option list if it exists.

 *

 * Return -EPERM if no matching flavor is found in the array.

 *

 * Please call rpc_shutdown_client() when you are done with this rpc client.

 *

 does the pseudoflavor match a sec= mount opt? */

 Cloning creates an rpc_auth for the flavor */

				/**

				* Check that the user actually can use the

				* flavor. This is mostly for RPC_AUTH_GSS

				* where cr_init obtains a gss context

/**

 * nfs4_negotiate_security - in response to an NFS4ERR_WRONGSEC on lookup,

 * return an rpc_clnt that uses the best available security flavor with

 * respect to the secinfo flavor list and the sec= mount options.

 *

 * @clnt: RPC client to clone

 * @inode: directory inode

 * @name: lookup name

 *

 * Please call rpc_shutdown_client() when you are done with this rpc client.

	/* Allocate a buffer big enough to hold any of the hostnames plus a

	 * terminating char and also a buffer big enough to hold the hostname

	 * plus a colon plus the path.

/**

 * nfs_follow_referral - set up mountpoint when hitting a referral on moved error

 * @fc: pointer to struct nfs_fs_context

 * @locations: array of NFSv4 server location information

 *

 Ensure fs path is a prefix of current dentry path */

/*

 * nfs_do_refmount - handle crossing a referral on server

 * @dentry - dentry of referral

 *

 BUG_ON(IS_ROOT(dentry)); */

 Get locations */

 Look it up again to get its attributes and sec flavor */

/*

 * Try one location from the fs_locations array.

 *

 * Returns zero on success, or a negative errno value.

/**

 * nfs4_replace_transport - set up transport to destination server

 *

 * @server: export being migrated

 * @locations: fs_locations array

 *

 * Returns zero on success, or a negative errno value.

 *

 * The client tries all the entries in the "locations" array, in the

 * order returned by the server, until one works or the end of the

 * array is reached.

 SPDX-License-Identifier: GPL-2.0

/*

 * linux/fs/nfs/callback_proc.c

 *

 * Copyright (C) 2004 Trond Myklebust

 *

 * NFSv4 callback procedures

 Always set for v4.0. Set in cb_sequence for v4.1 */

 Always set for v4.0. Set in cb_sequence for v4.1 */

 Set up a helper thread to actually return the delegation */

/*

 * Lookup a layout inode by stateid

 *

 * Note: returns a refcount on the inode and superblock

/*

 * Lookup a layout inode by filehandle.

 *

 * Note: returns a refcount on the inode and superblock

 *

/*

 * Enforce RFC5661 section 12.5.5.2.1. (Layout Recall and Return Sequencing)

 Is the stateid not initialised? */

 Mismatched stateid? */

 Are we already in a layout recall situation? */

 Check that the stateid matches what we think it should be. */

 Crazy server! */

	/*

	 * Enforce RFC5661 Section 12.5.5.2.1.5 (Bulk Recall and Return)

 There are layout segments that need to be returned */

 Embrace your forgetfulness! */

 Free all lsegs that are attached to commit buckets */

 Pretend we got a CB_LAYOUTRECALL(ALL) */

 FIXME we ignore errors, what should we do? */

/*

 * Validate the sequenceID sent by the server.

 * Return success if the sequenceID is one more than what we last saw on

 * this slot, accounting for wraparound.  Increments the slot's sequence.

 *

 * We don't yet implement a duplicate request cache, instead we set the

 * back channel ca_maxresponsesize_cached to zero. This is OK for now

 * since we only currently implement idempotent callbacks anyway.

 *

 * We have a single slot backchannel at this time, so we don't bother

 * checking the used_slots bit array on the table.  The lower layer guarantees

 * a single outstanding callback request at a time.

 Replay */

 Signal process_op to set this error on next op */

 Liar! We never allowed you to set csa_cachethis != 0 */

 Note: wraparound relies on seq_nr being of type u32 */

 Misordered request */

/*

 * For each referring call triple, check the session's slot table for

 * a match.  If the slot is in use and the sequence numbers match, the

 * client is still waiting for a response to the original request.

	/*

	 * XXX When client trunking is implemented, this becomes

	 * a session lookup from within the loop

 Set up res before grabbing the spinlock */

 state manager is resetting the session */

		/* Return NFS4ERR_BADSESSION if we're draining the session

		 * in order to reset it.

 The ca_maxresponsesize_cached is 0 with no DRC */

	/*

	 * Check for pending referring calls.  If a match is found, a

	 * related callback was received before the response to the original

	 * call.

	/*

	 * RFC5661 20.9.3

	 * If CB_SEQUENCE returns an error, then the state of the slot

	 * (sequence ID, cached reply) MUST NOT change.

 put in nfs4_callback_compound */

 set in cb_sequence */

 Reduce the fore channel's max_slots to the target value */

 set in cb_sequence */

 set in cb_sequence */

 Don't wake anybody if the string looked bogus */

 CONFIG_NFS_V4_1 */

 CONFIG_NFS_V4_2 */

 SPDX-License-Identifier: GPL-2.0

/*

 * linux/fs/nfs/callback_xdr.c

 *

 * Copyright (C) 2004 Trond Myklebust

 *

 * NFSv4 callback encode/decode procedures

 opcode, status

 bitmap length, 3 bitmaps

 change, size, ctime, mtime */\

 seqid, 3 slotids

 CONFIG_NFS_V4_1 */

 CONFIG_NFS_V4_2 */

 Internal error code */

/*

 * svc_process_common() looks for an XDR encoder to know when

 * not to drop a Reply.

 Check for minor version support */

 ignored by v4.1 and v4.2 */

	/* Depite the spec's xdr, iomode really belongs in the FILE switch,

	 * as it is unusable and ignored with the other types.

 Num of device notifications */

 Decode each dev notification */

 bitmap size */

 opaque size */

 Only try to decode if the length is right */

 skip "lock id:" */

 CONFIG_NFS_V4_1 */

 skip the always zero field */

 decode count, stable_how, verifier */

 decode fh */

 decode stateid */

 decode status */

 CONFIG_NFS_V4_2 */

	/*

	 * Let the state manager know callback processing done.

	 * A single slot, so highest used slotid is either 0 or -1

 CONFIG_NFS_V4_1 */

 CONFIG_NFS_V4_1 */

 CONFIG_NFS_V4_2 */

 CONFIG_NFS_V4_2 */

/*

 * Decode, process and encode a COMPOUND

	/* Buffer overflow in decode_ops_hdr or encode_ops_hdr. Return

/*

 * Define NFS4 callback COMPOUND ops.

 CONFIG_NFS_V4_1 */

 CONFIG_NFS_V4_2 */

/*

 * Define NFS4 callback procedures

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Module for pnfs flexfile layout driver.

 *

 * Copyright (c) 2014, Primary Data, Inc. All rights reserved.

 *

 * Tao Peng <bergwolf@primarydata.com>

 fh.data */

/*

 * Currently only stringified uids and gids are accepted.

 * I.e., kerberos is not supported to the DSes, so no pricipals.

 *

 * That means that one common function will suffice, but when

 * principals are added, this should be split to accomodate

 * calls to both nfs_map_name_to_uid() and nfs_map_group_to_gid().

 opaque_length(4)*/

 opaque body */

 Mergeable: copy info from 'old' to 'new' */

 stripe unit and mirror_array_cnt */

 FIXME: allow for striping? */

 deviceid */

 efficiency */

 stateid */

 fh */

 user */

 group */

 swap cred ptrs so free_mirror will clean up old */

 first IO request? */

 mirrors are initially sorted by efficiency */

 Use full layout for now */

 Sleep for 1 second before retrying */

 If no lseg, fall back to write through mds */

 Use a direct mapping of ds_idx to pgio mirror_idx */

 Sleep for 1 second before retrying */

 no lseg means that pnfs is not in use, so no mirroring here */

 Invalidate Layout errors */

 mapped NFS4ERR_STALE */

 mapped NFS4ERR_BADHANDLE */

 mapped NFS4ERR_ISDIR */

		/*

		 * Destroy layout so new i/o will get a new layout.

		 * Layout will not be destroyed until all current lseg

		 * references are put. Mark layout as invalid to resend failed

		 * i/o and all i/o waiting on the slot table to the MDS until

		 * layout is destroyed and a new valid layout is obtained.

 RPC connection errors */

 Retry all errors through either pNFS or MDS except for -EJUKEBOX */

 File access problems. Don't mark the device as unavailable */

 FIXME: Need to prevent infinite looping here. */

 Handle the case of an invalid layout segment */

 should never happen */

		/*

		 * Don't return the layout if this is a read and we still

		 * have layouts to try

 NFS_PROTO call done callback routines */

/*

 * We reference the rpc_cred of the first WRITE that triggers the need for

 * a LAYOUTCOMMIT, and use it to send the layoutcommit compound.

 * rfc5661 is not clear about which credential should be used.

 *

 * Flexlayout client should treat DS replied FILE_SYNC as DATA_SYNC, so

 * to follow http://www.rfc-editor.org/errata_search.php?rfc=5661&eid=2751

 * we always send layoutcommit after DS writes.

/*

 * Call ops for the async read/write cases

 * In the case of dense layouts, the offset needs to be reset to its

 * original value.

 Note this may cause RPC to be resent */

 Note: if the write is unstable, don't set end_offs until commit */

 zero out fattr since we don't care DS attr at all */

 Note this may cause RPC to be resent */

	/*

	 * Note that if we ever decide to split across DSes,

	 * then we may need to handle dense-like offsets.

 Perform an asynchronous read to ds */

 Perform async writes. */

	/*

	 * Note that if we ever decide to split across DSes,

	 * then we may need to handle dense-like offsets.

 Perform an asynchronous write */

	/* FIXME: Assume that there is only one NFS version available

	 * for the DS.

 This assume we always return _ALL_ layouts */

 report nothing for now */

	/*

	 * RFC 4291, Section 2.2.2

	 *

	 * Shorthanded ANY address

	/*

	 * RFC 4291, Section 2.2.2

	 *

	 * Shorthanded loopback address

	/*

	 * RFC 4291, Section 2.2.3

	 *

	 * Special presentation address format for mapped v4

	 * addresses.

	/*

	 * RFC 4291, Section 2.2.1

 Derived from rpc_sockaddr2uaddr */

 netaddr4 */

 nfs_fh4 */

 ff_io_latency4 read */

 ff_io_latency4 write */

 nfstime4 */

 bool */

 layoutupdate length */

 mirror refcount put in cleanup_layoutstats */

 For now, send at most PNFS_LAYOUTSTATS_MAXDEV statistics */

 1 page or so... */

 SPDX-License-Identifier: GPL-2.0

/*

 * Device operations for the pnfs nfs4 file layout driver.

 *

 * Copyright (c) 2014, Primary Data, Inc. All rights reserved.

 *

 * Tao Peng <bergwolf@primarydata.com>

 Decode opaque device data and construct new_ds using it */

 set up xdr stream */

 multipath count */

 multipath ds */

 version count */

		/* 20 = version(4) + minor_version(4) + rsize(4) + wsize(4) +

		/*

		 * check for valid major/minor combination.

		 * currently we support dataserver which talk:

		 *   v3, v4.0, v4.1, v4.2

 If DS was already in cache, free ds addrs */

 If ranges overlap or are contiguous, they are the same */

 Do insertion sort w/ merges */

 Add entry "dserr" _before_ entry "err" */

 Entries match, so merge "err" into "dserr" */

 FIXME: For now assume there is only 1 version available for the DS */

 check for race with another call to this function */

/**

 * nfs4_ff_layout_prepare_ds - prepare a DS connection for an RPC call

 * @lseg: the layout segment we're operating on

 * @mirror: layout mirror describing the DS to use

 * @fail_return: return layout on connect failure?

 *

 * Try to prepare a DS connection to accept an RPC call. This involves

 * selecting a mirror to use and connecting the client to it if it's not

 * already connected.

 *

 * Since we only need a single functioning mirror to satisfy a read, we don't

 * want to return the layout if there is one. For writes though, any down

 * mirror should result in a LAYOUTRETURN. @fail_return is how we distinguish

 * between the two cases.

 *

 * Returns a pointer to a connected DS object on success or NULL on failure.

 matching smp_wmb() in _nfs4_pnfs_v3/4_ds_connect */

	/* FIXME: For now we assume the server sent only one version of NFS

	 * to use for the DS.

 connect success, check rsize/wsize limit */

/**

 * nfs4_ff_find_or_create_ds_client - Find or create a DS rpc client

 * @mirror: pointer to the mirror

 * @ds_clp: nfs_client for the DS

 * @inode: pointer to inode

 *

 * Find or create a DS rpc client with th MDS server rpc client auth flavor

 * in the nfs_client cl_ds_clients list.

 For NFSv3 DS, flavor is set when creating DS connections */

 called with inode i_lock held */

		/* offset(8) + length(8) + stateid(NFS4_STATEID_SIZE)

		 * + array length + deviceid(NFS4_DEVICEID4_SIZE)

		 * + status(4) + opnum(4)

 Encode 1 error */

 If we're over the max, discard all remaining entries */

 Note: RW layout needs all mirrors available */

/*

 *  Module for the pnfs nfs4 file layout driver.

 *  Defines all I/O and Policy interface operations, plus code

 *  to register itself with the pNFS client.

 *

 *  Copyright (c) 2002

 *  The Regents of the University of Michigan

 *  All Rights Reserved

 *

 *  Dean Hildebrand <dhildebz@umich.edu>

 *

 *  Permission is granted to use, copy, create derivative works, and

 *  redistribute this software and such derivative works for any purpose,

 *  so long as the name of the University of Michigan is not used in

 *  any advertising or publicity pertaining to the use or distribution

 *  of this software without specific, written prior authorization. If

 *  the above copyright notice or any other identification of the

 *  University of Michigan is included in any copy of any portion of

 *  this software, then the disclaimer below must also be included.

 *

 *  This software is provided as is, without representation or warranty

 *  of any kind either express or implied, including without limitation

 *  the implied warranties of merchantability, fitness for a particular

 *  purpose, or noninfringement.  The Regents of the University of

 *  Michigan shall not be liable for any damages, including special,

 *  indirect, incidental, or consequential damages, with respect to any

 *  claim arising out of or in connection with the use of the software,

 *  even if it has been or is hereafter advised of the possibility of

 *  such damages.

/* This function is used by the layout driver to calculate the

 * offset of the file on the dserver based on whether the

 * layout type is STRIPE_DENSE or STRIPE_SPARSE

 DS session errors */

 Invalidate Layout errors */

 mapped NFS4ERR_STALE */

 mapped NFS4ERR_BADHANDLE */

 mapped NFS4ERR_ISDIR */

		/*

		 * Destroy layout so new i/o will get a new layout.

		 * Layout will not be destroyed until all current lseg

		 * references are put. Mark layout as invalid to resend failed

		 * i/o and all i/o waiting on the slot table to the MDS until

		 * layout is destroyed and a new valid layout is obtained.

 RPC connection errors */

 NFS_PROTO call done callback routines */

/*

 * We reference the rpc_cred of the first WRITE that triggers the need for

 * a LAYOUTCOMMIT, and use it to send the layoutcommit compound.

 * rfc5661 is not clear about which credential should be used.

 Note: if the write is unstable, don't set end_offs until commit */

/*

 * Call ops for the async read/write cases

 * In the case of dense layouts, the offset needs to be reset to its

 * original value.

 lost lock, terminate I/O */

 Note this may cause RPC to be resent */

 zero out the fattr */

 lost lock, terminate I/O */

 Note this may cause RPC to be resent */

 Retrieve the correct rpc_client for the byte range */

 No multipath support. Use first DS */

 Perform an asynchronous read to ds */

 Perform async writes. */

 Retrieve the correct rpc_client for the byte range */

 Perform an asynchronous write */

 Is the deviceid already set? If so, we're good. */

 find and reference the deviceid */

 Found deviceid is unavailable */

	/*

	 * Atomic compare and xchange to ensure we don't scribble

	 * over a non-NULL pointer.

/*

 * filelayout_check_layout()

 *

 * Make sure layout segment parameters are sane WRT the device.

 * At this point no generic layer initialization of the lseg has occurred,

 * and nothing has been added to the layout_hdr cache.

 *

 FIXME: remove this check when layout segment support is added */

	/* 20 = ufl_util (4), first_stripe_index (4), pattern_offset (8),

	/* Note that a zero value for num_fh is legal for STRIPE_SPARSE.

 Do we want to use a mempool here? */

 This assumes a single RW lseg */

/*

 * filelayout_pg_test(). Called by nfs_can_coalesce_requests()

 *

 * Return 0 if @req cannot be coalesced into @pgio, otherwise return the number

 * of bytes (maximum @req->wb_bytes) that can be coalesced.

 calls nfs_generic_pg_test */

 see if req and prev are in the same stripe */

 calculate remaining bytes in the current stripe */

 If no lseg, fall back to read through mds */

 If no lseg, fall back to write through mds */

		/* Note that we are calling nfs4_fl_calc_j_index on each page

		 * that ends up being committed to a data server.  An attractive

		 * alternative is to add a field to nfs_write_data and nfs_page

		 * to store the value calculated in filelayout_write_pagelist

		 * and just use that here.

 Use the MDS OPEN fh set in nfs_read_rpcsetup */

 1 page or so... */

/*

 *  Device operations for the pnfs nfs4 file layout driver.

 *

 *  Copyright (c) 2002

 *  The Regents of the University of Michigan

 *  All Rights Reserved

 *

 *  Dean Hildebrand <dhildebz@umich.edu>

 *  Garth Goodson   <Garth.Goodson@netapp.com>

 *

 *  Permission is granted to use, copy, create derivative works, and

 *  redistribute this software and such derivative works for any purpose,

 *  so long as the name of the University of Michigan is not used in

 *  any advertising or publicity pertaining to the use or distribution

 *  of this software without specific, written prior authorization. If

 *  the above copyright notice or any other identification of the

 *  University of Michigan is included in any copy of any portion of

 *  this software, then the disclaimer below must also be included.

 *

 *  This software is provided as is, without representation or warranty

 *  of any kind either express or implied, including without limitation

 *  the implied warranties of merchantability, fitness for a particular

 *  purpose, or noninfringement.  The Regents of the University of

 *  Michigan shall not be liable for any damages, including special,

 *  indirect, incidental, or consequential damages, with respect to any

 *  claim arising out of or in connection with the use of the software,

 *  even if it has been or is hereafter advised of the possibility of

 *  such damages.

 Decode opaque device data and return the result */

 set up xdr stream */

 Get the stripe count (number of stripe index) */

 read stripe indices */

 Check the multipath list count */

 validate stripe indices are all < num */

 multipath count */

 If DS was already in cache, free ds addrs */

 stripe_indicies was part of dsaddr */

/*

 * Want res = (offset - layout->pattern_offset)/ layout->stripe_unit

 * Then: ((res + fsi) % dsaddr->stripe_count)

 Use the MDS OPEN fh set in nfs_read_rpcsetup */

 Upon return, either ds is connected, or ds is NULL */

/*

 *  Copyright (c) 2006,2007 The Regents of the University of Michigan.

 *  All rights reserved.

 *

 *  Andy Adamson <andros@citi.umich.edu>

 *  Fred Isaman <iisaman@umich.edu>

 *

 * permission is granted to use, copy, create derivative works and

 * redistribute this software and such derivative works for any purpose,

 * so long as the name of the university of michigan is not used in

 * any advertising or publicity pertaining to the use or distribution

 * of this software without specific, written prior authorization.  if

 * the above copyright notice or any other identification of the

 * university of michigan is included in any copy of any portion of

 * this software, then the disclaimer below must also be included.

 *

 * this software is provided as is, without representation from the

 * university of michigan as to its fitness for any purpose, and without

 * warranty by the university of michigan of any kind, either express

 * or implied, including without limitation the implied warranties of

 * merchantability and fitness for a particular purpose.  the regents

 * of the university of michigan shall not be liable for any damages,

 * including special, indirect, incidental, or consequential damages,

 * with respect to any claim arising out or in connection with the use

 * of the software, even if it has been or is hereafter advised of the

 * possibility of such damages.

 single volume */

/*

 *  linux/fs/nfs/blocklayout/blocklayout.c

 *

 *  Module for the NFSv4.1 pNFS block layout driver.

 *

 *  Copyright (c) 2006 The Regents of the University of Michigan.

 *  All rights reserved.

 *

 *  Andy Adamson <andros@citi.umich.edu>

 *  Fred Isaman <iisaman@umich.edu>

 *

 * permission is granted to use, copy, create derivative works and

 * redistribute this software and such derivative works for any purpose,

 * so long as the name of the university of michigan is not used in

 * any advertising or publicity pertaining to the use or distribution

 * of this software without specific, written prior authorization.  if

 * the above copyright notice or any other identification of the

 * university of michigan is included in any copy of any portion of

 * this software, then the disclaimer below must also be included.

 *

 * this software is provided as is, without representation from the

 * university of michigan as to its fitness for any purpose, and without

 * warranty by the university of michigan of any kind, either express

 * or implied, including without limitation the implied warranties of

 * merchantability and fitness for a particular purpose.  the regents

 * of the university of michigan shall not be liable for any damages,

 * including special, indirect, incidental, or consequential damages,

 * with respect to any claim arising out or in connection with the use

 * of the software, even if it has been or is hereafter advised of the

 * possibility of such damages.

 struct bio */

/* The data we are handed might be spread across several bios.  We need

 * to track when the last one is finished.

 translate to device offset */

 translate to physical disk offset */

 limit length to what the device mapping allows */

 Code assumes extents are page-aligned */

 We've used up the previous extent */

 Get the next one */

 Fill hole w/ zeroes w/o accessing device */

 invalidate map */

/* Function scheduled for call during bl_end_par_io_write,

 * it marks sectors as written and extends the commitlist.

 Called when last of bios associated with a bl_write_pagelist call finishes */

	/* At this point, header->page_aray is a (sequential) list of nfs_pages.

	 * We want to write each, and if there is an error set pnfs_error

	 * to have it redone using nfs.

 we always write out the whole page */

 We've used up the previous extent */

 Get the next one */

 Tracks info needed to ensure extents in layout obey constraints of spec */

 R or RW */

 Expected start of next non-COW extent */

 Start of INVAL coverage */

 End of COW read coverage */

/* Verify the extent meets the layout requirements of the pnfs-block draft,

 * section 2.3.1.

 lv->mode == IOMODE_RW */

		/* It looks like you might want to min this with lv->start,

		 * but you really don't.

	/*

	 * The next three values are read in as bytes, but stored in the

	 * extent structure in 512-byte granularity.

	/*

	 * Decode individual extents, putting them in temporary staging area

	 * until whole layout is decoded to make error recovery easier.

 Our extent block devices are unavailable */

	/*

	 * Always accept buffered writes, higher layers take care of the

	 * right alignment.

		/*

		 * If the write goes up to the inode size, just write

		 * the full page.  Data past the inode size is

		 * guaranteed to be zeroed by the higher level client

		 * code, and this behaviour is mandated by RFC 5663

		 * section 2.3.2.

/*

 * Return 0 if @req cannot be coalesced into @pgio, otherwise return the number

 * of bytes (maximum @req->wb_bytes) that can be coalesced.

/*

 * Return the number of contiguous bytes for a given inode

 * starting at page frame idx.

 Optimize common case that writes from 0 to end of file */

/*

 * Return 0 if @req cannot be coalesced into @pgio, otherwise return the number

 * of bytes (maximum @req->wb_bytes) that can be coalesced.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2014-2016 Christoph Hellwig.

 error, should not happen */

 truncate offset to the beginning of the stripe */

 disk offset of the stripe */

/*

 * Try to open the udev path for the WWN.  At least on Debian the udev

 * by-id path will always point to the dm-multipath device if one exists.

/*

 * Try to open the RH/Fedora specific dm-mpath udev path for this WWN, as the

 * wwn- links will only point to the first discovered SCSI device there.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2014-2016 Christoph Hellwig.

	/*

	 * First remove all COW extents or holes from written to range.

	/*

	 * Then mark all invalid extents in the range as written to.

 keep counting.. */

			/*

			 * Mark as written and try again.

			 *

			 * XXX: some real error handling here wouldn't hurt..

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/proc/kmsg.c

 *

 *  Copyright (C) 1992  by Linus Torvalds

 *

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2010 Werner Fink, Jiri Slaby

/*

 * This is handler for /proc/consoles

 SPDX-License-Identifier: GPL-2.0

/*

 * Logic: we've got two memory sums for each process, "shared", and

 * "non-shared". Shared memory may get counted more than once, for

 * each process that owns it. Non-shared memory is counted

 * accurately.

 includes kernel stack */

	/*

	 * We make no effort to guess what a given thread considers to be

	 * its "stack".  It's not even well-defined for programs written

	 * languages like Go.

/*

 * display a single VMA to a sequenced file

/*

 * display mapping lines for a particular process's /proc/pid/maps

 pin the task and mm whilst we play with them */

 start from the Nth VMA */

 SPDX-License-Identifier: GPL-2.0

 Nothing to do */

 SPDX-License-Identifier: GPL-2.0

	/*

	 * Note: to minimize their overhead, mm maintains hiwater_vm and

	 * hiwater_rss only when about to *lower* total_vm or rss.  Any

	 * collector of these hiwater stats must therefore get total_vm

	 * and rss too, which will usually be the higher.  Barriers? not

	 * worth the effort, such snapshots can always be inconsistent.

 split executable areas between text and lib */

/*

 * Save get_task_policy() for show_numa_map().

 See m_next(). Zero at the start or after lseek. */

/*

 * Indicate if the VMA is a stack for the given task; for

 * /proc/PID/maps that is the stack of the main task.

	/*

	 * We make no effort to guess what a given thread considers to be

	 * its "stack".  It's not even well-defined for programs written

	 * languages like Go.

	/*

	 * Print the dentry name for named mappings, and a

	 * special [heap] marker for the heap:

/*

 * Proportional Set Size(PSS): my share of RSS.

 *

 * PSS of a process is the count of pages it has in memory, where each

 * page is divided by the number of processes sharing it.  So if a

 * process has 1000 pages all to itself, and 1000 shared with one other

 * process, its PSS will be 1500.

 *

 * To keep (accumulated) division errors low, we adopt a 64bit

 * fixed-point pss counter to minimize division errors. So (pss >>

 * PSS_SHIFT) would be the real byte count.

 *

 * A shift of 12 before division means (assuming 4K page size):

 * 	- 1M 3-user-pages add up to 8KB errors;

 * 	- supports mapcount up to 2^24, or 16M;

 * 	- supports PSS up to 2^52 bytes, or 4PB.

	/*

	 * First accumulate quantities that depend only on |size| and the type

	 * of the compound page.

 Accumulate the size in pages that have been accessed. */

	/*

	 * Then accumulate quantities that may depend on sharing, or that may

	 * differ page-by-page.

	 *

	 * page_count(page) == 1 guarantees the page is mapped exactly once.

	 * If any subpage of the compound page mapped with PTE it would elevate

	 * page_count().

 CONFIG_SHMEM */

 depth is not used */

 FOLL_DUMP will return -EFAULT on huge zero page */

 pass */;

	/*

	 * The mmap_lock held all the way back in m_start() is what

	 * keeps khugepaged out of here and from collapsing things

	 * in here.

	/*

	 * Don't forget to update Documentation/ on changes.

		/*

		 * In case if we meet a flag we don't know about.

 These come out via ProtectionKey: */

 CONFIG_ARCH_HAS_PKEYS */

 CONFIG_HAVE_ARCH_USERFAULTFD_MINOR */

 HUGETLB_PAGE */

/*

 * Gather mem stats from @vma with the indicated beginning

 * address @start, and keep them in @mss.

 *

 * Use vm_start of @vma as the beginning address if @start is 0.

 Invalid start */

		/*

		 * For shared or readonly shmem mappings we know that all

		 * swapped out pages belong to the shmem object, and we can

		 * obtain the swap value much more efficiently. For private

		 * writable mappings, we might have COW pages that are

		 * not affected by the parent swapped out pages of the shmem

		 * object, so we have to distinguish them during the page walk.

		 * Unless we know that the shmem object (or the part mapped by

		 * our VMA) has no swapped out pages at all.

 mmap_lock is held in m_start */

 Show the contents common for smaps and smaps_rollup */

		/*

		 * These are meaningful only for smaps_rollup, otherwise two of

		 * them are zero, and the other one is the same as Pss.

		/*

		 * Release mmap_lock temporarily if someone wants to

		 * access it for write request.

			/*

			 * After dropping the lock, there are four cases to

			 * consider. See the following example for explanation.

			 *

			 *   +------+------+-----------+

			 *   | VMA1 | VMA2 | VMA3      |

			 *   +------+------+-----------+

			 *   |      |      |           |

			 *  4k     8k     16k         400k

			 *

			 * Suppose we drop the lock after reading VMA2 due to

			 * contention, then we get:

			 *

			 *	last_vma_end = 16k

			 *

			 * 1) VMA2 is freed, but VMA3 exists:

			 *

			 *    find_vma(mm, 16k - 1) will return VMA3.

			 *    In this case, just continue from VMA3.

			 *

			 * 2) VMA2 still exists:

			 *

			 *    find_vma(mm, 16k - 1) will return VMA2.

			 *    Iterate the loop like the original one.

			 *

			 * 3) No more VMAs can be found:

			 *

			 *    find_vma(mm, 16k - 1) will return NULL.

			 *    No more things to do, just break.

			 *

			 * 4) (last_vma_end - 1) is the middle of a vma (VMA'):

			 *

			 *    find_vma(mm, 16k - 1) will return VMA' whose range

			 *    contains last_vma_end.

			 *    Iterate VMA' from last_vma_end.

 Case 3 above */

 Case 1 above */

 Case 4 above */

 Case 2 above */

	/*

	 * The soft-dirty tracker uses #PF-s to catch writes

	 * to pages, so write-protect the pte as well. See the

	 * Documentation/admin-guide/mm/soft-dirty.rst for full description

	 * of how soft-dirty works.

 See comment in change_huge_pmd() */

 Clear accessed and referenced bits. */

 Clear accessed and referenced bits. */

	/*

	 * Writing 1 to /proc/pid/clear_refs affects all pages.

	 * Writing 2 to /proc/pid/clear_refs only affects anonymous pages.

	 * Writing 3 to /proc/pid/clear_refs only affects file mapped pages.

	 * Writing 4 to /proc/pid/clear_refs affects all pages.

			/*

			 * Writing 5 to /proc/pid/clear_refs resets the peak

			 * resident set size to this mm's current rss value.

 units: PM_ENTRY_BYTES, not bytes */

 End of address space hole, which we mark as non-present. */

 Addresses in the VMA. */

 CONFIG_TRANSPARENT_HUGEPAGE */

	/*

	 * We can assume that @vma always points to a valid one and @end never

	 * goes beyond vma->vm_end.

 This function walks within one hugetlb entry in the single call */

 HUGETLB_PAGE */

/*

 * /proc/pid/pagemap - an array mapping virtual pages to pfns

 *

 * For each page in the address space, this file contains one 64-bit entry

 * consisting of the following:

 *

 * Bits 0-54  page frame number (PFN) if present

 * Bits 0-4   swap type if swapped

 * Bits 5-54  swap offset if swapped

 * Bit  55    pte is soft-dirty (see Documentation/admin-guide/mm/soft-dirty.rst)

 * Bit  56    page exclusively mapped

 * Bits 57-60 zero

 * Bit  61    page is file-page or shared-anon

 * Bit  62    page swapped

 * Bit  63    page present

 *

 * If the page is not present but in swap, then the PFN contains an

 * encoding of the swap file number and the page's offset into the

 * swap. Unmapped pages return a null PFN. This allows determining

 * precisely which pages are mapped (or in swap) and comparing mapped

 * pages between processes.

 *

 * Efficient users of this interface will use /proc/pid/maps to

 * determine which areas of memory are actually mapped and llseek to

 * skip over unmapped regions.

 file position must be aligned */

 do not disclose physical addresses: attack vector */

 watch out for wraparound */

 Ensure the address is inside the task */

	/*

	 * The odds are that this will stop walking way

	 * before end_vaddr, because the length of the

	 * user buffer is tracked in "pm", and the walk

	 * will stop when we hit the end of the buffer.

 overflow ? */

 borrow this */

 CONFIG_PROC_PAGE_MONITOR */

/*

 * Display pages allocated per node and memory policy via /proc.

 Ensure we start with an empty set of numa_maps statistics. */

 mmap_lock is held by m_start */

 CONFIG_NUMA */

 SPDX-License-Identifier: GPL-2.0-or-later

/* nommu.c: mmu-less memory info files

 *

 * Copyright (C) 2004 Red Hat, Inc. All Rights Reserved.

 * Written by David Howells (dhowells@redhat.com)

/*

 * display a single region to a sequenced file

/*

 * display a list of all the REGIONs the kernel knows about

 * - nommu kernels have a single flat list

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/proc/inode.c

 *

 *  Copyright (C) 1991, 1992  Linus Torvalds

 Stop tracking associated processes */

 Let go of any associated proc directory entry */

 pde is locked on entry, unlocked on exit */

	/*

	 * close() (proc_reg_release()) can't delete an entry and proceed:

	 * ->release hook needs to be available at the right moment.

	 *

	 * rmmod (remove_proc_entry() et al) can't delete an entry and proceed:

	 * "struct file" needs to be available at the right moment.

	 *

	 * Therefore, first process to enter this function does ->release() and

	 * signals its completion to the other process which does nothing.

 somebody else is doing that, just wait */

 After ->release. */

 Wait until all existing callers into module are done. */

 ->pde_openers list can't grow from now on. */

	/*

	 * Ensure that

	 * 1) PDE's ->release hook will be called no matter what

	 *    either normally by close()/->release, or forcefully by

	 *    rmmod/remove_proc_entry.

	 *

	 * 2) rmmod isn't blocked by opening file in /proc and sitting on

	 *    the descriptor (including "rmmod foo </proc/foo" scenario).

	 *

	 * Save every "struct file" with custom ->release hook.

 To know what to release. */

 SPDX-License-Identifier: GPL-2.0

 show_fd_locks() never deferences files so a stale value is safe */

/*

 * /proc/pid/fd needs a special permission handler so that a process can still

 * access /proc/self/fd after it has executed a setuid().

 SPDX-License-Identifier: GPL-2.0

/*

 * /proc/bootconfig - Extra boot configuration

 Rest size of buffer */

 Return the needed total length if @size is 0 */

 SPDX-License-Identifier: GPL-2.0

/*

 * /proc/self:

 max length of unsigned int in decimal + NULL term */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/proc/base.c

 *

 *  Copyright (C) 1991, 1992 Linus Torvalds

 *

 *  proc base directory handling functions

 *

 *  1999, Al Viro. Rewritten. Now it covers the whole per-process part.

 *  Instead of using magical inumbers to determine the kind of object

 *  we allocate and fill in-core inodes upon lookup. They don't even

 *  go into icache. We cache the reference to task_struct upon lookup too.

 *  Eventually it should become a filesystem in its own. We don't use the

 *  rest of procfs anymore.

 *

 *

 *  Changelog:

 *  17-Jan-2005

 *  Allan Bezerra

 *  Bruna Moreira <bruna.moreira@indt.org.br>

 *  Edjard Mota <edjard.mota@indt.org.br>

 *  Ilias Biris <ilias.biris@indt.org.br>

 *  Mauricio Lin <mauricio.lin@indt.org.br>

 *

 *  Embedded Linux Lab - 10LE Instituto Nokia de Tecnologia - INdT

 *

 *  A new process specific entry (smaps) included in /proc. It shows the

 *  size of rss for each memory area. The maps entry lacks information

 *  about physical memory size (rss) for each mapped file, i.e.,

 *  rss information for executables and library files.

 *  This additional information is useful for any tools that need to know

 *  about physical memory consumption for a process specific library.

 *

 *  Changelog:

 *  21-Feb-2005

 *  Embedded Linux Lab - 10LE Instituto Nokia de Tecnologia - INdT

 *  Pud inclusion in the page table walking.

 *

 *  ChangeLog:

 *  10-Mar-2005

 *  10LE Instituto Nokia de Tecnologia - INdT:

 *  A better way to walks through the page table as suggested by Hugh Dickins.

 *

 *  Simo Piiroinen <simo.piiroinen@nokia.com>:

 *  Smaps information related to shared, private, clean and dirty pages.

 *

 *  Paul Mundt <paul.mundt@nokia.com>:

 *  Overall revision about smaps.

/* NOTE:

 *	Implementing inode permission operations in /proc is almost

 *	certainly an error.  Permission checks need to happen during

 *	each system call not at open time.  The reason is that most of

 *	what we wish to check for permissions in /proc varies at runtime.

 *

 *	The classic example of a problem is opening file descriptors

 *	in /proc for a task before it execs a suid executable.

/*

 * Count the number of hardlinks for the pid_entry table, excluding the .

 * and .. links.

/*

 * If the user used setproctitle(), we just get the string from

 * user space at arg_start, and limit it to a maximum of one page.

 Include the NUL character if it was found */

 Check if process spawned far enough to have cmdline. */

	/*

	 * We allow setproctitle() to overwrite the argument

	 * strings, and overflow past the original end. But

	 * only when it overflows into the environment area.

 We're not going to care if "*ppos" has high bits set */

	/*

	 * Magical special case: if the argv[] end byte is not

	 * zero, the user has overwritten it with setproctitle(3).

	 *

	 * Possible future enhancement: do this only once when

	 * pos is 0, and set a flag in the 'struct file'.

	/*

	 * For the non-setproctitle() case we limit things strictly

	 * to the [arg_start, arg_end[ range.

/*

 * Provides a wchan file via kallsyms in a proper one-value-per-file format.

 * Returns the resolved symbol.  If that fails, simply return the address.

 CONFIG_KALLSYMS */

	/*

	 * The ability to racily run the kernel stack unwinder on a running task

	 * and then observe the unwinder output is scary; while it is useful for

	 * debugging kernel issues, it can also allow an attacker to leak kernel

	 * stack contents.

	 * Doing this in a manner that is at least safe from races would require

	 * some work to ensure that the remote task can not be scheduled; and

	 * even then, this would still expose the unwinder as local attack

	 * surface.

	 * Therefore, this interface is restricted to root.

/*

 * Provides /proc/PID/schedstat

	/*

	 * Special case OOM_SCORE_ADJ_MIN for all others scale the

	 * badness value into [0, 2000] range which we have been

	 * exporting for a long time so userspace might depend on it.

 Display limits for a process */

	/*

	 * print the file header

 CONFIG_HAVE_ARCH_TRACEHOOK */

***********************************************************************/

                       Here the fs part begins                        */

***********************************************************************/

 permission checks */

	/* Allow access to a task's file descriptors if it is us or we

	 * may use ptrace attach to the process and find out that

	 * information.

/*

 * May current process learn task's sched/cmdline info (for hide_pid_min=1)

 * or euid/egid (for hide_pid_min=2)?

	/*

	 * If 'hidpid' mount option is set force a ptrace check,

	 * we indicate that we are using a filesystem syscall

	 * by passing PTRACE_MODE_READ_FSCREDS

			/*

			 * Let's make getdents(), stat(), and open()

			 * consistent with each other.  If a process

			 * may not stat() a file, it shouldn't be seen

			 * in procfs at all.

 ensure this mm_struct can't be freed */

 but do not pin its memory */

 OK to pass negative loff_t, we can catch out-of-range */

 Ensure the process spawned far enough to have an environment. */

 AT_NULL */

		/*

		 * /proc/pid/oom_adj is provided for legacy purposes, ask users to use

		 * /proc/pid/oom_score_adj instead.

	/*

	 * Make sure we will check other processes sharing the mm if this is

	 * not vfrok which wants its own oom_score_adj.

	 * pin the mm so it doesn't go away and get reused after task_unlock

 do not touch kernel threads or the global init */

/*

 * /proc/pid/oom_adj exists solely for backwards compatibility with previous

 * kernels.  The effective policy is defined by oom_score_adj, which has a

 * different scale: oom_adj grew exponentially and oom_score_adj grows linearly.

 * Values written to oom_adj are simply mapped linearly to oom_score_adj.

 * Processes that become oom disabled via oom_adj will still be oom disabled

 * with this implementation.

 *

 * oom_adj cannot be removed since existing userspace binaries use it.

	/*

	 * Scale /proc/pid/oom_score_adj appropriately ensuring that a maximum

	 * value is always attainable.

 Don't let kthreads write their own loginuid */

 No partial writes. */

 is userspace tring to explicitly UNSET the loginuid? */

/*

 * Print out various scheduling related per-task fields:

/*

 * Print out autogroup related information:

 CONFIG_SCHED_AUTOGROUP */

 Only allow < page size writes at the beginning of the file */

 Slurp in the user data */

 Parse the user data */

 Find the end of line and ensure we don't look past it */

 CONFIG_TIME_NS */

 Are we allowed to snoop on the tasks file descriptors? */

 Are we allowed to snoop on the tasks file descriptors? */

 building an inode */

	/* Depending on the state of dumpable compute who should own a

	 * proc file for a task.

 Default to the tasks effective ownership */

	/*

	 * Before the /proc/pid/status file was created the only way to read

	 * the effective uid of a /process was to stat /proc/pid.  Reading

	 * /proc/pid/status is slow enough that procps and other packages

	 * kept stating /proc/pid.  To keep the rules in /proc simple I have

	 * made this apply to all per process world readable and executable

	 * directories.

 Make non-dumpable tasks owned by some root */

 We need a new inode */

 Common stuff */

	/*

	 * grab the reference to task.

 Let the pid remember us for quick removal */

			/*

			 * This doesn't prevent learning whether PID exists,

			 * it only makes getattr() consistent with readdir().

 dentry stuff */

/*

 * Set <pid>/... inode ownership (can change due to setuid(), etc.)

/*

 * Rewrite the inode's ownerships here because the owning task may have

 * performed a setuid(), etc.

 *

	/* Is the task we represent dead?

	 * If so, then don't put the dentry on the lru list,

	 * kill it immediately.

 Lookups */

/*

 * Fill a directory entry.

 *

 * If possible create the dcache entry and derive our inode number and

 * file type from dcache entry.

 *

 * Since all of the proc inode numbers are dynamically generated, the inode

 * numbers do not exist until the inode is cache.  This means creating

 * the dcache entry in readdir is necessary to keep the inode numbers

 * reported by readdir in sync with the inode numbers reported

 * by stat.

/*

 * dname_to_vma_addr - maps a dentry name into two unsigned longs

 * which represent vma start and end addresses.

/*

 * Only allow CAP_SYS_ADMIN and CAP_CHECKPOINT_RESTORE to follow the links, due

 * to concerns about how the symlinks may be used to bypass permissions on

 * ancestor directories in the path to the file in question.

/*

 * Identical to proc_pid_link_inode_operations except for get_link()

	/*

	 * We need two passes here:

	 *

	 *  1) Collect vmas of mapped files with mmap_lock taken

	 *  2) Release mmap_lock and instantiate entries

	 *

	 * otherwise we get lockdep complained, since filldir()

	 * routine might require mmap_lock taken in might_fault().

 max: %lx-%lx\0 */

 Use getattr to fix if necessary */

	/*

	 * Yes, it does not scale. And it should not. Don't add

	 * new entries into /proc/<tgid>/ without very good reasons.

 A task may only write when it was the opener. */

 A task may only write its own attributes. */

 Prevent changes to overridden credentials. */

 No partial writes. */

 Guard against adverse ptrace interaction */

 CONFIG_TASK_IO_ACCOUNTING */

 CONFIG_USER_NS */

 CONFIG_LIVEPATCH */

 CONFIG_STACKLEAK_METRICS */

/*

 * Thread groups

/**

 * proc_flush_pid -  Remove dcache entries for @pid from the /proc dcache.

 * @pid: pid that should be flushed.

 *

 * This function walks a list of inodes (that belong to any proc

 * filesystem) that are attached to the pid and flushes them from

 * the dentry cache.

 *

 * It is safe and reasonable to cache /proc entries for a task until

 * that task exits.  After that they just clog up the dcache with

 * useless entries, possibly causing useful dcache entries to be

 * flushed instead.  This routine is provided to flush those useless

 * dcache entries when a process is reaped.

 *

 * NOTE: This routine is just an optimization so it does not guarantee

 *       that no dcache entries will exist after a process is reaped

 *       it just makes it very unlikely that any will persist.

 Limit procfs to only ptraceable tasks */

/*

 * Find the first task with tgid >= tgid

 *

 for the /proc/ directory itself, after non-process stuff has been done */

/*

 * proc_tid_comm_permission is a special permission function exclusively

 * used for the node /proc/<pid>/task/<tid>/comm.

 * It bypasses generic permission checks in the case where a task of the same

 * task group attempts to access the node.

 * The rationale behind this is that glibc and bionic access this node for

 * cross thread naming (pthread_set/getname_np(!self)). However, if

 * PR_SET_DUMPABLE gets set to 0 this node among others becomes uid=0 gid=0,

 * which locks out the cross thread naming implementation.

 * This function makes sure that the node is always accessible for members of

 * same thread group.

		/* This file (/proc/<pid>/task/<tid>/comm) can always be

		 * read or written by the members of the corresponding

		 * thread group.

/*

 * Tasks

/*

 * Find the first tid of a thread group to return to user space.

 *

 * Usually this is just the thread group leader, but if the users

 * buffer was too small or there was a seek into the middle of the

 * directory we have more work todo.

 *

 * In the case of a short read we start with find_task_by_pid.

 *

 * In the case of a seek we start with the leader and walk nr

 * threads past it.

 32bit overflow? */

 Attempt to start with the tid of a thread */

 If nr exceeds the number of threads there is nothing todo */

	/* If we haven't found our starting place yet start

	 * with the leader and walk nr threads forward.

/*

 * Find the next thread in the thread list.

 * Return NULL if there is an error or no next thread.

 *

 * The reference to the input task_struct is released.

 for the /proc/TGID/task/ directories */

	/* f_version caches the tgid value that the last readdir call couldn't

	 * return. lseek aka telldir automagically resets f_version to 0.

 The task has just exited. */

			/* returning this tgid failed, save it as the first

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0-only

/*

 *	fs/proc/vmcore.c Interface for accessing the crash

 * 				 dump from the system's previous life.

 * 	Heavily borrowed from fs/proc/kcore.c

 *	Created by: Hariprasad Nellitheertha (hari@in.ibm.com)

 *	Copyright (C) IBM Corporation, 2004. All rights reserved

 *

/* List representing chunks of contiguous memory areas and their offsets in

 * vmcore file.

 Stores the pointer to the buffer containing kernel elf core headers. */

 Size of all notes minus the device dump notes */

 Total size of vmcore file. */

 Device Dump list and mutex to synchronize access to list */

 CONFIG_PROC_VMCORE_DEVICE_DUMP */

 Device Dump Size */

 List of registered vmcore callbacks. */

 Whether we had a surprise unregistration of a callback. */

 Whether the vmcore has been opened once. */

	/*

	 * Registering a vmcore callback after the vmcore was opened is

	 * very unusual (e.g., manual driver loading).

	/*

	 * Unregistering a vmcore callback after the vmcore was opened is

	 * very unusual (e.g., forced driver removal), but we cannot stop

	 * unregistering.

 Reads a page from the oldmem device from given offset. */

 If pfn is not ram, return zeros for sparse dump files */

/*

 * Architectures may override this function to allocate ELF header in 2nd kernel

/*

 * Architectures may override this function to free header

/*

 * Architectures may override this function to read from ELF header

/*

 * Architectures may override this function to read from notes sections

/*

 * Architectures may override this function to map oldmem

/*

 * Architectures which support memory encryption override this.

/*

 * Copy to either kernel or user space

 Leave now if buffer filled already */

 Leave now if buffer filled already */

 CONFIG_MMU */

 CONFIG_PROC_VMCORE_DEVICE_DUMP */

/* Read from the ELF header and then the crash dump. On error, negative value is

 * returned otherwise number of bytes read are returned.

 trim buflen to not go beyond EOF */

 Read ELF core header */

 leave now if filled buffer already */

 Read Elf note segment */

		/* We add device dumps before other elf notes because the

		 * other elf notes may not fill the elf notes buffer

		 * completely and we will end up with zero-filled data

		 * between the elf notes and the device dumps. Tools will

		 * then try to decode this zero-filled data as valid notes

		 * and we don't want that. Hence, adding device dumps before

		 * the other elf notes ensure that zero-filled data can be

		 * avoided.

 Read device dumps */

 leave now if filled buffer already */

 CONFIG_PROC_VMCORE_DEVICE_DUMP */

 Read remaining elf notes */

 leave now if filled buffer already */

 leave now if filled buffer already */

/*

 * The vmcore fault handler uses the page cache and fills data using the

 * standard __vmcore_read() function.

 *

 * On s390 the fault handler is used for memory regions that can't be mapped

 * directly with remap_pfn_range().

/**

 * vmcore_alloc_buf - allocate buffer in vmalloc memory

 * @sizez: size of buffer

 *

 * If CONFIG_MMU is defined, use vmalloc_user() to allow users to mmap

 * the buffer to user-space by means of remap_vmalloc_range().

 *

 * If CONFIG_MMU is not defined, use vzalloc() since mmap_vmcore() is

 * disabled and there's no need to allow users to mmap the buffer.

/*

 * Disable mmap_vmcore() if CONFIG_MMU is not defined. MMU is

 * essential for mmap_vmcore() in order to map physically

 * non-contiguous objects (ELF header, ELF note segment and memory

 * regions in the 1st kernel pointed to by PT_LOAD entries) into

 * virtually contiguous user-space in ELF layout.

/*

 * remap_oldmem_pfn_checked - do remap_oldmem_pfn_range replacing all pages

 * reported as not being ram with the zero page.

 *

 * @vma: vm_area_struct describing requested mapping

 * @from: start remapping from

 * @pfn: page frame number to start remapping to

 * @size: remapping size

 * @prot: protection bits

 *

 * Returns zero on success, -EAGAIN on failure.

			/*

			 * We hit a page which is not ram. Remap the continuous

			 * region between pos_start and pos-1 and replace

			 * the non-ram page at pos with the zero page.

 Remap continuous region */

 Remap the zero page */

 Remap the rest */

	/*

	 * Check if oldmem_pfn_is_ram was registered to avoid

	 * looping over all pages without a reason.

		/* We add device dumps before other elf notes because the

		 * other elf notes may not fill the elf notes buffer

		 * completely and we will end up with zero-filled data

		 * between the elf notes and the device dumps. Tools will

		 * then try to decode this zero-filled data as valid notes

		 * and we don't want that. Hence, adding device dumps before

		 * the other elf notes ensure that zero-filled data can be

		 * avoided. This also ensures that the device dumps and

		 * other elf notes can be properly mmaped at page aligned

		 * address.

 Read device dumps */

 leave now if filled buffer already */

 CONFIG_PROC_VMCORE_DEVICE_DUMP */

 Read remaining elf notes */

/**

 * update_note_header_size_elf64 - update p_memsz member of each PT_NOTE entry

 *

 * @ehdr_ptr: ELF header

 *

 * This function updates p_memsz member of each PT_NOTE entry in the

 * program header table pointed to by @ehdr_ptr to real size of ELF

 * note segment.

/**

 * get_note_number_and_size_elf64 - get the number of PT_NOTE program

 * headers and sum of real size of their ELF note segment headers and

 * data.

 *

 * @ehdr_ptr: ELF header

 * @nr_ptnote: buffer for the number of PT_NOTE program headers

 * @sz_ptnote: buffer for size of unique PT_NOTE program header

 *

 * This function is used to merge multiple PT_NOTE program headers

 * into a unique single one. The resulting unique entry will have

 * @sz_ptnote in its phdr->p_mem.

 *

 * It is assumed that program headers with PT_NOTE type pointed to by

 * @ehdr_ptr has already been updated by update_note_header_size_elf64

 * and each of PT_NOTE program headers has actual ELF note segment

 * size in its p_memsz member.

/**

 * copy_notes_elf64 - copy ELF note segments in a given buffer

 *

 * @ehdr_ptr: ELF header

 * @notes_buf: buffer into which ELF note segments are copied

 *

 * This function is used to copy ELF note segment in the 1st kernel

 * into the buffer @notes_buf in the 2nd kernel. It is assumed that

 * size of the buffer @notes_buf is equal to or larger than sum of the

 * real ELF note segment headers and data.

 *

 * It is assumed that program headers with PT_NOTE type pointed to by

 * @ehdr_ptr has already been updated by update_note_header_size_elf64

 * and each of PT_NOTE program headers has actual ELF note segment

 * size in its p_memsz member.

 Merges all the PT_NOTE headers into one. */

 Prepare merged PT_NOTE program header. */

 Add merged PT_NOTE program header*/

 Remove unwanted PT_NOTE program headers. */

 Modify e_phnum to reflect merged headers. */

	/* Store the size of all notes.  We need this to update the note

	 * header when the device dumps will be added.

/**

 * update_note_header_size_elf32 - update p_memsz member of each PT_NOTE entry

 *

 * @ehdr_ptr: ELF header

 *

 * This function updates p_memsz member of each PT_NOTE entry in the

 * program header table pointed to by @ehdr_ptr to real size of ELF

 * note segment.

/**

 * get_note_number_and_size_elf32 - get the number of PT_NOTE program

 * headers and sum of real size of their ELF note segment headers and

 * data.

 *

 * @ehdr_ptr: ELF header

 * @nr_ptnote: buffer for the number of PT_NOTE program headers

 * @sz_ptnote: buffer for size of unique PT_NOTE program header

 *

 * This function is used to merge multiple PT_NOTE program headers

 * into a unique single one. The resulting unique entry will have

 * @sz_ptnote in its phdr->p_mem.

 *

 * It is assumed that program headers with PT_NOTE type pointed to by

 * @ehdr_ptr has already been updated by update_note_header_size_elf32

 * and each of PT_NOTE program headers has actual ELF note segment

 * size in its p_memsz member.

/**

 * copy_notes_elf32 - copy ELF note segments in a given buffer

 *

 * @ehdr_ptr: ELF header

 * @notes_buf: buffer into which ELF note segments are copied

 *

 * This function is used to copy ELF note segment in the 1st kernel

 * into the buffer @notes_buf in the 2nd kernel. It is assumed that

 * size of the buffer @notes_buf is equal to or larger than sum of the

 * real ELF note segment headers and data.

 *

 * It is assumed that program headers with PT_NOTE type pointed to by

 * @ehdr_ptr has already been updated by update_note_header_size_elf32

 * and each of PT_NOTE program headers has actual ELF note segment

 * size in its p_memsz member.

 Merges all the PT_NOTE headers into one. */

 Prepare merged PT_NOTE program header. */

 Add merged PT_NOTE program header*/

 Remove unwanted PT_NOTE program headers. */

 Modify e_phnum to reflect merged headers. */

	/* Store the size of all notes.  We need this to update the note

	 * header when the device dumps will be added.

/* Add memory chunks represented by program headers to vmcore list. Also update

 PT_NOTE hdr */

 Skip Elf header, program headers and Elf note segment. */

 Add this contiguous chunk of memory to vmcore list.*/

 Update the program header offset. */

 PT_NOTE hdr */

 Skip Elf header, program headers and Elf note segment. */

 Add this contiguous chunk of memory to vmcore list.*/

 Update the program header offset */

 Sets offset fields of vmcore elements. */

 Skip Elf header, program headers and Elf note segment. */

 Read Elf header */

 Do some basic Verification. */

 Read in all elf headers. */

 Merge all PT_NOTE headers into one. */

 Read Elf header */

 Do some basic Verification. */

 Read in all elf headers. */

 Merge all PT_NOTE headers into one. */

 Determine vmcore size. */

/**

 * vmcoredd_write_header - Write vmcore device dump header at the

 * beginning of the dump's buffer.

 * @buf: Output buffer where the note is written

 * @data: Dump info

 * @size: Size of the dump

 *

 * Fills beginning of the dump's buffer with vmcore device dump header.

/**

 * vmcoredd_update_program_headers - Update all Elf program headers

 * @elfptr: Pointer to elf header

 * @elfnotesz: Size of elf notes aligned to page size

 * @vmcoreddsz: Size of device dumps to be added to elf note header

 *

 * Determine type of Elf header (Elf64 or Elf32) and update the elf note size.

 * Also update the offsets of all the program headers after the elf note header.

 Update all program headers */

 Update note size */

 Update all program headers */

 Update note size */

/**

 * vmcoredd_update_size - Update the total size of the device dumps and update

 * Elf header

 * @dump_size: Size of the current device dump to be added to total size

 *

 * Update the total size of all the device dumps and update the Elf program

 * headers. Calculate the new offsets for the vmcore list and update the

 * total vmcore size.

 Update vmcore list offsets */

/**

 * vmcore_add_device_dump - Add a buffer containing device dump to vmcore

 * @data: dump info.

 *

 * Allocate a buffer and invoke the calling driver's dump collect routine.

 * Write Elf note at the beginning of the buffer to indicate vmcore device

 * dump and add the dump to global list.

 Keep size of the buffer page aligned so that it can be mmaped */

 Allocate buffer for driver's to write their dumps */

 Invoke the driver's dump collection routing */

 Add the dump to driver sysfs list */

 CONFIG_PROC_VMCORE_DEVICE_DUMP */

 Free all dumps in vmcore device dump list */

 CONFIG_PROC_VMCORE_DEVICE_DUMP */

 Init function for vmcore module. */

 Allow architectures to allocate ELF header in 2nd kernel */

	/*

	 * If elfcorehdr= has been passed in cmdline or created in 2nd kernel,

	 * then capture the dump.

 Cleanup function for vmcore module. */

 clear the vmcore list. */

 clear vmcore device dump list */

 SPDX-License-Identifier: GPL-2.0

	/*

	 * The memmap of early sections is completely populated and marked

	 * online even if max_pfn does not fall on a section boundary -

	 * pfn_to_online_page() will succeed on all pages. Allow inspecting

	 * these memmaps.

/* /proc/kpagecount - an array exposing page counts

 *

 * Each entry is a u64 representing the corresponding

 * physical page count.

		/*

		 * TODO: ZONE_DEVICE support requires to identify

		 * memmaps that were actually initialized.

/* /proc/kpageflags - an array exposing page flags

 *

 * Each entry is a u64 representing the corresponding

 * physical page flags.

	/*

	 * pseudo flag: KPF_NOPAGE

	 * it differentiates a memory hole from a page with no flags

	/*

	 * pseudo flags for the well known (anonymous) memory mapped pages

	 *

	 * Note that page->_mapcount is overloaded in SLOB/SLUB/SLQB, so the

	 * simple test in page_mapped() is not enough.

	/*

	 * compound pages: export both head/tail info

	 * they together define a compound page's start/end pos and order

	/*

	 * PageTransCompound can be true for non-huge compound pages (slab

	 * pages or pages allocated by drivers with __GFP_COMP) because it

	 * just checks PG_head/PG_tail, so we need to check PageLRU/PageAnon

	 * to make sure a given page is a thp, not a non-huge compound page.

	/*

	 * Caveats on high order pages: page->_refcount will only be set

	 * -1 on the head page; SLUB/SLQB do the same for PG_slab;

	 * SLOB won't set PG_slab at all on compound pages.

		/*

		 * TODO: ZONE_DEVICE support requires to identify

		 * memmaps that were actually initialized.

		/*

		 * TODO: ZONE_DEVICE support requires to identify

		 * memmaps that were actually initialized.

 CONFIG_MEMCG */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * proc/fs/generic.c --- generic routines for the proc-fs

 *

 * This file contains generic proc-fs routines for handling

 * directories and files.

 * 

 * Copyright (C) 1991, 1992 Linus Torvalds.

 * Copyright (C) 1997 Theodore Ts'o

 Figure out where to put new node */

 Add new node and rebalance tree. */

/*

 * This function parses a name such as "tty/driver/serial", and

 * returns the struct proc_dir_entry for "/proc/tty/driver", and

 * returns "serial" in residual.

/*

 * Return an inode number between PROC_DYNAMIC_FIRST and

 * 0xffffffff, or zero on failure.

 revalidate */

/*

 * Don't create negative dentries here, return -ENOENT by hand

 * instead.

/*

 * This returns non-zero if at EOF, so that the /proc

 * root directory can use this and check if it should

 * continue with the <pid> entries..

 *

 * Note that the VFS-layer doesn't care about the return

 * value of the readdir() call, as long as it's non-negative

 * for success..

/*

 * These are the generic /proc directory operations. They

 * use the in-memory "struct proc_dir_entry" tree to parse

 * the /proc directory.

/*

 * proc directories can do almost nothing..

 returns the registered entry, or frees dp and returns NULL on failure */

 not permanent -- can call into arbitrary seq_operations */

 not permanent -- can call into arbitrary ->single_show */

/*

 * Remove a /proc entry and free it if it's not currently in use.

/*

 * Pull a user buffer into memory and pass it to the file's write handler if

 * one is supplied.  The ->write() method is permitted to modify the

 * kernel-side buffer.

 SPDX-License-Identifier: GPL-2.0

/*

 * proc_tty.c -- handles /proc/tty

 *

 * Copyright 1997, Theodore Ts'o

/*

 * The /proc/tty directory inodes...

/*

 * This is the handler for /proc/tty/drivers

 pseudo-drivers first */

 iterator */

/*

 * This function is called by tty_register_driver() to handle

 * registering the driver's /proc handler into /proc/tty/driver/<foo>

/*

 * This function is called by tty_unregister_driver()

/*

 * Called by proc_root_init() to initialize the /proc/tty subtree

 Preserved: it's userspace visible */

	/*

	 * /proc/tty/driver/serial reveals the exact character counts for

	 * serial links which is just too easy to abuse for inferring

	 * password lengths and inter-keystroke timings during password

	 * entry.

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

/*

 * /proc/thread_self:

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  linux/fs/proc/net.c

 *

 *  Copyright (C) 2007

 *

 *  Author: Eric Biederman <ebiederm@xmission.com>

 *

 *  proc net directory handling functions

/**

 * proc_create_net_data_write - Create a writable net_ns-specific proc file

 * @name: The name of the file.

 * @mode: The file's access mode.

 * @parent: The parent directory in which to create.

 * @ops: The seq_file ops with which to read the file.

 * @write: The write method with which to 'modify' the file.

 * @data: Data for retrieval by PDE_DATA().

 *

 * Create a network namespaced proc file in the @parent directory with the

 * specified @name and @mode that allows reading of a file that displays a

 * series of elements and also provides for the file accepting writes that have

 * some arbitrary effect.

 *

 * The functions in the @ops table are used to iterate over items to be

 * presented and extract the readable content using the seq_file interface.

 *

 * The @write function is called with the data copied into a kernel space

 * scratch buffer and has a NUL appended for convenience.  The buffer may be

 * modified by the @write function.  @write should return 0 on success.

 *

 * The @data value is accessible from the @show and @write functions by calling

 * PDE_DATA() on the file inode.  The network namespace must be accessed by

 * calling seq_file_net() on the seq_file struct.

/**

 * proc_create_net_single_write - Create a writable net_ns-specific proc file

 * @name: The name of the file.

 * @mode: The file's access mode.

 * @parent: The parent directory in which to create.

 * @show: The seqfile show method with which to read the file.

 * @write: The write method with which to 'modify' the file.

 * @data: Data for retrieval by PDE_DATA().

 *

 * Create a network-namespaced proc file in the @parent directory with the

 * specified @name and @mode that allows reading of a file that displays a

 * single element rather than a series and also provides for the file accepting

 * writes that have some arbitrary effect.

 *

 * The @show function is called to extract the readable content via the

 * seq_file interface.

 *

 * The @write function is called with the data copied into a kernel space

 * scratch buffer and has a NUL appended for convenience.  The buffer may be

 * modified by the @write function.  @write should return 0 on success.

 *

 * The @data value is accessible from the @show and @write functions by calling

 * PDE_DATA() on the file inode.  The network namespace must be accessed by

 * calling seq_file_single_net() on the seq_file struct.

 SPDX-License-Identifier: GPL-2.0

/*

 * /proc/interrupts

 Nothing to do */

 SPDX-License-Identifier: GPL-2.0

 !NO_HZ or cpu offline so we can rely on cpustat.idle */

 !NO_HZ or cpu offline so we can rely on cpustat.iowait */

 shift boot timestamp according to the timens offset */

 Copy values here to work around gcc-2.95.3, gcc-2.96 */

 minimum size to display an interrupt count : 2 bytes */

 SPDX-License-Identifier: GPL-2.0

/*

 * /proc/sys support

 shared constants to be used in various sysctls */

 Support for permanently empty directories */

 Called under sysctl_lock */

 Is this a permanently empty directory? */

 Am I creating a permanently empty directory? */

 called under sysctl_lock */

 called under sysctl_lock */

 called under sysctl_lock, will reacquire if has to wait */

	/*

	 * if p->used is 0, nobody will ever touch that entry again;

	 * we'll eliminate all paths to it before dropping sysctl_lock

 anything non-NULL; we'll never dereference it */

	/*

	 * Invalidate dentries for unregistered sysctls: namespaced sysctls

	 * can have duplicate names and contaminate dcache very badly.

	/*

	 * do not remove from the list until nobody holds it; walking the

	 * list in do_sysctl() relies on that.

/*

 * sysctl_perm does NOT grant the superuser all rights automatically, because

 * some sysctl variables are readonly even to root.

	/*

	 * At this point we know that the sysctl was not unregistered

	 * and won't be until we finish.

 if that can happen at all, it should be -EINVAL, not -EISDIR */

 don't even try if the size is too large */

 careful: calling conventions are nasty here */

 sysctl was unregistered */

 sysctl was unregistered */

 It is not an error if we can not follow the link ignore it */

	/*

	 * sysctl entries that are not writeable,

	 * are _NOT_ writeable, capabilities or not.

 Executable files are not allowed under /proc/sys/ */

 global root - r-xr-xr-x */

 Use the permissions on the sysctl table entry */

	/* Although proc doesn't have negative dentries, rcu-walk means

 AV: can it, indeed? */

/**

 * get_subdir - find or create a subdir with the specified name.

 * @dir:  Directory to create the subdirectory in

 * @name: The name of the subdirectory to find or create

 * @namelen: The length of name

 *

 * Takes a directory with an elevated reference count so we know that

 * if we drop the lock the directory will not go away.  Upon success

 * the reference is moved from @dir to the returned subdirectory.

 * Upon error an error code is returned and the reference on @dir is

 * simply dropped.

 Was the subdir added while we dropped the lock? */

 Nope.  Use the our freshly made directory entry. */

 Are there links available for every entry in table? */

 The checks passed.  Increase the registration count on the links */

/**

 * __register_sysctl_table - register a leaf sysctl table

 * @set: Sysctl tree to register on

 * @path: The path to the directory the sysctl table is in.

 * @table: the top-level table structure

 *

 * Register a sysctl table hierarchy. @table should be a filled in ctl_table

 * array. A completely 0 filled entry terminates the table.

 *

 * The members of the &struct ctl_table structure are used as follows:

 *

 * procname - the name of the sysctl file under /proc/sys. Set to %NULL to not

 *            enter a sysctl file

 *

 * data - a pointer to data for use by proc_handler

 *

 * maxlen - the maximum size in bytes of the data

 *

 * mode - the file permissions for the /proc/sys file

 *

 * child - must be %NULL.

 *

 * proc_handler - the text handler routine (described below)

 *

 * extra1, extra2 - extra pointers usable by the proc handler routines

 *

 * Leaf nodes in the sysctl tree will be represented by a single file

 * under /proc; non-leaf nodes will be represented by directories.

 *

 * There must be a proc_handler routine for any terminal nodes.

 * Several default handlers are available to cover common cases -

 *

 * proc_dostring(), proc_dointvec(), proc_dointvec_jiffies(),

 * proc_dointvec_userhz_jiffies(), proc_dointvec_minmax(),

 * proc_doulongvec_ms_jiffies_minmax(), proc_doulongvec_minmax()

 *

 * It is the handler's job to read the input buffer from user memory

 * and process it. The handler should return 0 on success.

 *

 * This routine returns %NULL on a failure to register, and a pointer

 * to the table header on success.

 Reference moved down the diretory tree get_subdir */

 Find the directory for the ctl_table */

/**

 * register_sysctl - register a sysctl table

 * @path: The path to the directory the sysctl table is in.

 * @table: the table structure

 *

 * Register a sysctl table. @table should be a filled in ctl_table

 * array. A completely 0 filled entry terminates the table.

 *

 * See __register_sysctl_table for more details.

 special case: no directory and empty directory */

 If there are mixed files and directories we need a new table */

 Register everything except a directory full of subdirectories */

 Remember if we need to free the file table */

 Recurse into the subdirectories. */

 On failure our caller will unregister all registered subheaders */

/**

 * __register_sysctl_paths - register a sysctl table hierarchy

 * @set: Sysctl tree to register on

 * @path: The path to the directory the sysctl table is in.

 * @table: the top-level table structure

 *

 * Register a sysctl table hierarchy. @table should be a filled in ctl_table

 * array. A completely 0 filled entry terminates the table.

 *

 * See __register_sysctl_table for more details.

/**

 * register_sysctl_paths - register a sysctl table hierarchy

 * @path: The path to the directory the sysctl table is in.

 * @table: the top-level table structure

 *

 * Register a sysctl table hierarchy. @table should be a filled in ctl_table

 * array. A completely 0 filled entry terminates the table.

 *

 * See __register_sysctl_paths for more details.

/**

 * register_sysctl_table - register a sysctl table hierarchy

 * @table: the top-level table structure

 *

 * Register a sysctl table hierarchy. @table should be a filled in ctl_table

 * array. A completely 0 filled entry terminates the table.

 *

 * See register_sysctl_paths for more details.

/**

 * unregister_sysctl_table - unregister a sysctl table hierarchy

 * @header: the header returned from register_sysctl_table

 *

 * Unregisters the sysctl table and all children. proc entries may not

 * actually be removed until they are no longer used by anyone.

/*

 * Historically some settings had both sysctl and a command line parameter.

 * With the generic sysctl. parameter support, we can handle them at a single

 * place and only keep the historical name for compatibility. This is not meant

 * to add brand new aliases. When adding existing aliases, consider whether

 * the possibly different moment of changing the value (e.g. from early_param

 * to the moment do_sysctl_args() is called) is an issue for the specific

 * parameter.

 Set sysctl value passed on kernel command line. */

	/*

	 * To set sysctl options, we use a temporary mount of proc, look up the

	 * respective sys/ file and write to it. To avoid mounting it when no

	 * options were given, we mount it only when the first sysctl option is

	 * found. Why not a persistent mount? There are problems with a

	 * persistent mount of proc in that it forces userspace not to use any

	 * proc mount options.

 SPDX-License-Identifier: GPL-2.0

/*

 *	fs/proc/kcore.c kernel ELF core dumper

 *

 *	Modelled on fs/exec.c:aout_core_dump()

 *	Jeremy Fitzhardinge <jeremy@sw.oz.au>

 *	ELF version written by David Howells <David.Howells@nexor.co.uk>

 *	Modified and incorporated into 2.3.x by Tigran Aivazian <tigran@veritas.com>

 *	Support to dump vmalloc'd areas (ELF only), Tigran Aivazian <tigran@veritas.com>

 *	Safe accesses to vmalloc/direct-mapped discontiguous areas, Kanoj Sarcar <kanoj@sgi.com>

/*

 * Returns > 0 for RAM pages, 0 for non-RAM pages, < 0 on error

 * Same as oldmem_pfn_is_ram in vmcore

 This doesn't grab kclist_lock, so it should only be used at init time. */

 PT_NOTE */

/*

 * If no highmem, we can assume [0...max_low_pfn) continuous range of memory

 * because memory hole is not as big as !HIGHMEM case.

 * (HIGHMEM is special because part of memory is _invisible_ from the kernel.)

 !CONFIG_HIGHMEM */

 calculate vmemmap's address from given system ram pfn and register it */

 overlap check (because we have to align page */

 cut not-mapped area. ....from ppc-32 code. */

	/*

	 * We've already checked virt_addr_valid so we know this address

	 * is a valid pointer, therefore we can check against it to determine

	 * if we need to trim

 Not inialized....update now */

 find out "max pfn" */

 scan 0 to max_pfn */

 CONFIG_HIGHMEM */

 Couldn't get the RAM list, try again next time. */

	/*

	 * Don't race against drivers that set PageOffline() and expect no

	 * further page access.

 ELF file header. */

 ELF program headers. */

 ELF note segment. */

		/*

		 * vmcoreinfo_size is mostly constant after init time, but it

		 * can be changed by crash_save_vmcoreinfo(). Racing here with a

		 * panic on another CPU before the machine goes down is insanely

		 * unlikely, but it's better to not leave potential buffer

		 * overflows lying around, regardless.

	/*

	 * Check to see if our file offset matches with any of

	 * the addresses in the elf_phdr on our list.

		/*

		 * If this is the first iteration or the address is not within

		 * the previous entry, search for a matching entry.

 skip the list anchor */

 we have to zero-fill user buffer even if no read */

 User page is handled prior to normal kernel page: */

			/*

			 * Don't read offline sections, logically offline pages

			 * (e.g., inflated in a balloon), hwpoisoned pages,

			 * and explicitly excluded physical ranges.

				/*

				 * Using bounce buffer to bypass the

				 * hardened user copy kernel text checks.

 just remember that we have to update kcore */

/*

 * If defined, special segment is used for mapping kernel text instead of

 * direct-map area. We need to create special TEXT section.

/*

 * MODULES_VADDR has no intersection with VMALLOC_ADDR.

 Always returns 0. */

 Store text area if it's special */

 Store vmalloc area */

 Store direct-map area from physical memory map */

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/proc/array.c

 *

 *  Copyright (C) 1992  by Linus Torvalds

 *  based on ideas by Darren Senn

 *

 * Fixes:

 * Michael. K. Johnson: stat,statm extensions.

 *                      <johnsonm@stolaf.edu>

 *

 * Pauline Middelink :  Made cmdline,envline only break at '\0's, to

 *                      make sure SET_PROCTITLE works. Also removed

 *                      bad '!' which forced address recalculation for

 *                      EVERY character on the current page.

 *                      <middelin@polyware.iaf.nl>

 *

 * Danny ter Haar    :	added cpuinfo

 *			<dth@cistron.nl>

 *

 * Alessandro Rubini :  profile extension.

 *                      <rubini@ipvvis.unipv.it>

 *

 * Jeff Tranter      :  added BogoMips field to cpuinfo

 *                      <Jeff_Tranter@Mitel.COM>

 *

 * Bruno Haible      :  remove 4K limit for the maps file

 *			<haible@ma2s2.mathematik.uni-karlsruhe.de>

 *

 * Yves Arrouye      :  remove removal of trailing spaces in get_array.

 *			<Yves.Arrouye@marin.fdn.fr>

 *

 * Jerome Forissier  :  added per-CPU time information to /proc/stat

 *                      and /proc/<pid>/cpu extension

 *                      <forissier@isia.cma.fr>

 *			- Incorporation and non-SMP safe operation

 *			of forissier patch in 2.1.78 by

 *			Hans Marcus <crowbar@concepts.nl>

 *

 * aeb@cwi.nl        :  /proc/partitions

 *

 *

 * Alan Cox	     :  security fixes.

 *			<alan@lxorguk.ukuu.org.uk>

 *

 * Al Viro           :  safe handling of mm_struct

 *

 * Gerhard Wichert   :  added BIGMEM support

 * Siemens AG           <Gerhard.Wichert@pdb.siemens.de>

 *

 * Al Viro & Jeff Garzik :  moved most of the thing into base.c and

 *			 :  proc_misc.c. The rest may eventually go into

 *			 :  base.c too.

/*

 * The task state array is a strange "bitmap" of

 * reasons to sleep. Thus "running" is zero, and

 * you can test for combinations of others with

 * simple bit tests.

 states in TASK_REPORT: */

 0x00 */

 0x01 */

 0x02 */

 0x04 */

 0x08 */

 0x10 */

 0x20 */

 0x40 */

 states beyond TASK_REPORT: */

 0x80 */

 Trailing space shouldn't have been added in the first place. */

 FIXME: is this correct? */

 render them all */

		/*

		 * esp and eip are intentionally zeroed out.  There is no

		 * non-racy way to read them without freezing the task.

		 * Programs that need reliable values can use ptrace(2).

		 *

		 * The only exception is if the task is core dumping because

		 * a program is not able to use ptrace(2) in that case. It is

		 * safe because the task has stopped executing permanently.

 add up live thread stats at the group level */

 scale priority and nice values from timeslices to -20..20 */

 to make it look like a "normal" Unix priority/nice value  */

 apply timens offset for boottime and convert nsec -> ticks */

	/* The signal information here is obsolete.

	 * It must be decimal for Linux 2.0 compatibility.

	 * Use /proc/#/status for real-time signals.

	/*

	 * We used to output the absolute kernel address, but that's an

	 * information leak - so instead we show a 0/1 flag here, to signal

	 * to user-space whether there's a wchan field in /proc/PID/wchan.

	 *

	 * This works with older implementations of procps as well.

		/*

		 * For quick read, open code by putting numbers directly

		 * expected format is

		 * seq_printf(m, "%lu %lu %lu %lu 0 %lu 0\n",

		 *               size, resident, shared, text, data);

	/*

	 * Lets try to continue searching first, this gives

	 * us significant speedup on children-rich processes.

	/*

	 * Slow search case.

	 *

	 * We might miss some children here if children

	 * are exited while we were not holding the lock,

	 * but it was never promised to be accurate that

	 * much.

	 *

	 * "Just suppose that the parent sleeps, but N children

	 *  exit after we printed their tids. Now the slow paths

	 *  skips N extra children, we miss N tasks." (c)

	 *

	 * So one need to stop or freeze the leader and all

	 * its children to get a precise result.

 CONFIG_PROC_CHILDREN */

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/proc/root.c

 *

 *  Copyright (C) 1991, 1992 Linus Torvalds

 *

 *  proc root directory handling functions

 User space would break if executables or devices appear on proc */

	/*

	 * procfs isn't actually a stacking filesystem; however, there is

	 * too much magic going on inside it to permit stacking things on

	 * top of it

 procfs dentries and inodes don't require IO to create */

 somewhere for the nfsd filesystem to be mounted */

 just give it a mountpoint */

/*

 * The root /proc directory is special, as it has the

 * <pid> directories. Thus we don't use the generic

 * directory handling functions for that..

/*

 * proc root can do almost nothing..

/*

 * This is the root "inode" in the /proc tree..

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

/*

 * /proc/softirqs  ... display the number of softirqs

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  linux/fs/adfs/super.c

 *

 *  Copyright (C) 1997-1999 Russell King

 sector size must be 256, 512 or 1024 bytes */

 idlen must be at least log2secsize + 3 */

	/* we cannot have such a large disc that we

	 * are unable to represent sector offsets in

	 * 32 bits.  This works out at 2.0 TB.

	/*

	 * Maximum idlen is limited to 16 bits for new directories by

	 * the three-byte storage of an indirect disc address.  For

	 * big directories, idlen must be no greater than 19 v2 [1.0]

 reserved bytes should be zero */

 always drop inodes if we are read-only */

	/*

	 * Make sure all delayed rcu free inodes are flushed before we

	 * destroy cache.

 try to set the requested block size */

 read the buffer */

 validate it */

 does the block size match the filesystem block size? */

 Do some sanity checks on the ADFS disc record */

 Do some sanity checks on the ADFS disc record */

 set default options */

 Try to probe the filesystem boot block */

 set up enough so that we can read an inode */

 Set root object date as 01 Jan 1987 00:00:00 */

	/*

	 * If this is a F+ disk with variable length directories,

	 * get the root_size from the disc record.

	/*

	 * ,xyz hex filetype suffix may be added by driver

	 * to files that have valid RISC OS filetype

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  linux/fs/adfs/inode.c

 *

 *  Copyright (C) 1997-1999 Russell King

/*

 * Lookup/Create a block at offset 'block' into 'inode'.  We currently do

 * not support creation of new blocks, so we return -EIO for this case.

 don't support allocation of blocks yet */

/*

 * Convert ADFS attributes and filetype to Linux permission.

 LinkFS */

 UnixExec */

/*

 * Convert Linux permission to ADFS attribute.  We try to do the reverse

 * of atts2mode, but there is not a 1:1 translation.

 FIXME: should we be able to alter a link? */

 Directories do not have read/write permissions on the media */

/*

 * Convert an ADFS time to Unix time.  ADFS has a 40-bit centi-second time

 * referenced to 1 Jan 1900 (til 2248) so we need to discard 2208988800 seconds

 * of time to convert from RISC OS epoch to Unix epoch.

	/* 01 Jan 1970 00:00:00 (Unix epoch) as nanoseconds since

	 * 01 Jan 1900 00:00:00 (RISC OS epoch)

 top 8 bits of timestamp */

 bottom 32 bits of timestamp */

	/* convert 40-bit centi-seconds to 32-bit seconds

	 * going via nanoseconds to retain precision

 cs to ns */

 Files dated pre  01 Jan 1970 00:00:00. */

 convert from RISC OS to Unix epoch */

 Convert an Unix time to ADFS time for an entry that is already stamped. */

 convert from Unix to RISC OS epoch */

 convert from nanoseconds to centiseconds */

/*

 * Fill in the inode information from the object information.

 *

 * Note that this is an inode-less filesystem, so we can't use the inode

 * number to reference the metadata on the media.  Instead, we use the

 * inode number to hold the object ID, which in turn will tell us where

 * the data is held.  We also save the parent object ID, and with these

 * two, we can locate the metadata.

 *

 * This does mean that we rely on an objects parent remaining the same at

 * all times - we cannot cope with a cross-directory rename (yet).

	/*

	 * we need to save the parent directory ID so that

	 * write_inode can update the directory information

	 * for this file.  This will need special handling

	 * for cross-directory renames.

/*

 * Validate and convert a changed access mode/time to their ADFS equivalents.

 * adfs_write_inode will actually write the information back to the directory

 * later.

	/*

	 * we can't change the UID or GID of any file -

	 * we have a global UID/GID in the superblock

 XXX: this is missing some actual on-disk truncation.. */

	/*

	 * FIXME: should we make these == to i_mtime since we don't

	 * have the ability to represent them in our filesystem?

	/*

	 * FIXME: should we be marking this inode dirty even if

	 * we don't have any metadata to write back?

/*

 * write an existing inode back to the directory, and therefore the disk.

 * The adfs-specific inode data has already been updated by

 * adfs_notify_change()

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  linux/fs/adfs/dir.c

 *

 *  Copyright (C) 1999-2000 Russell King

 *

 *  Common directory handling for ADFS

/*

 * For future.  This should probably be per-directory.

 We only allow one extension */

 Mark the buffers dirty */

	/*

	 * RISC OS allows the use of '/' in directory entry names, so we need

	 * to fix these up.  '/' is typically used for FAT compatibility to

	 * represent '.', so do the same conversion here.  In any case, '.'

	 * will never be in a RISC OS name since it is used as the pathname

	 * separator.  Handle the case where we may generate a '.' or '..'

	 * name, replacing the first character with '^' (the RISC OS "parent

	 * directory" character.)

	/*

	 * If the object is a file, and the user requested the ,xyz hex

	 * filetype suffix to the name, check the filetype and append.

	/*

	 * If the updated failed because the entry wasn't found, we can

	 * just release the buffers. If it was any other error, forget

	 * the dirtied buffers so they aren't written back to the media.

/*

 * Compare two names, taking note of the name length

 * requirements of the underlying filesystem.

		/*

		 * This only returns NULL if get_empty_inode

		 * fails.

/*

 * directories can handle most operations...

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  linux/fs/adfs/dir_fplus.c

 *

 *  Copyright (C) 1997-1999 Russell King

 Return the byte offset to directory entry pos */

 Check that bigdirnamelen fits within the directory */

 Check that bigdirnamesize fits within the directory */

	/*

	 * Avoid division, we know that absolute maximum number of entries

	 * can not be so large to cause overflow of the multiplication below.

 Accumulate the contents of the header, entries and names */

 Accumulate the contents of the tail except for the check byte */

 Read first buffer */

 Read remaining buffers */

 Increment directory sequence number */

 Update directory check byte */

 Make sure the directory still validates correctly */

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/fs/adfs/file.c

 *

 * Copyright (C) 1997-1999 Russell King

 * from:

 *

 *  linux/fs/ext2/file.c

 *

 * Copyright (C) 1992, 1993, 1994, 1995

 * Remy Card (card@masi.ibp.fr)

 * Laboratoire MASI - Institut Blaise Pascal

 * Universite Pierre et Marie Curie (Paris VI)

 *

 *  from

 *

 *  linux/fs/minix/file.c

 *

 *  Copyright (C) 1991, 1992  Linus Torvalds

 *

 *  adfs regular file handling primitives           

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  linux/fs/adfs/dir_f.c

 *

 * Copyright (C) 1997-1999 Russell King

 *

 *  E and F format directory handling

/*

 * Read an (unaligned) value of length 1..4 bytes

/*

 * There are some algorithms that are nice in

 * assembler, but a bitch in C...  This is one

 * of them.

	/*

	 * Accumulate each word up to the last whole

	 * word of the last directory entry.  This

	 * can spread across several buffer heads.

	/*

	 * Accumulate the last few bytes.  These

	 * bytes will be within the same bh.

	/*

	 * The directory tail is in the final bh

	 * Note that contary to the RISC OS PRMs,

	 * the first few bytes are NOT included

	 * in the check.  All bytes are in the

	 * same bh.

 Read and check that a directory is valid */

/*

 * convert a disk-based directory entry to a Linux ADFS directory entry

/*

 * convert a Linux ADFS directory entry to a disk-based directory entry

/*

 * get a directory entry.  Note that the caller is responsible

 * for holding the relevant locks.

 Update the directory entry with the new object state */

 Write the directory entry back to the directory */

 Increment directory sequence number */

 Update directory check byte */

 Make sure the directory still validates correctly */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  linux/fs/adfs/map.c

 *

 *  Copyright (C) 1997-2002 Russell King

/*

 * The ADFS map is basically a set of sectors.  Each sector is called a

 * zone which contains a bitstream made up of variable sized fragments.

 * Each bit refers to a set of bytes in the filesystem, defined by

 * log2bpmb.  This may be larger or smaller than the sector size, but

 * the overall size it describes will always be a round number of

 * sectors.  A fragment id is always idlen bits long.

 *

 *  < idlen > <       n        > <1>

 * +---------+-------//---------+---+

 * | frag id |  0000....000000  | 1 |

 * +---------+-------//---------+---+

 *

 * The physical disk space used by a fragment is taken from the start of

 * the fragment id up to and including the '1' bit - ie, idlen + n + 1

 * bits.

 *

 * A fragment id can be repeated multiple times in the whole map for

 * large or fragmented files.  The first map zone a fragment starts in

 * is given by fragment id / ids_per_zone - this allows objects to start

 * from any zone on the disk.

 *

 * Free space is described by a linked list of fragments.  Each free

 * fragment describes free space in the same way as the other fragments,

 * however, the frag id specifies an offset (in map bits) from the end

 * of this fragment to the start of the next free fragment.

 *

 * Objects stored on the disk are allocated object ids (we use these as

 * our inode numbers.)  Object ids contain a fragment id and an optional

 * offset.  This allows a directory fragment to contain small files

 * associated with that directory.

/*

 * For the future...

/*

 * This is fun.  We need to load up to 19 bits from the map at an

 * arbitrary bit alignment.  (We're limited to 19 bits by F+ version 2).

/*

 * return the map bit offset of the fragment frag_id in the zone dm.

 * Note that the loop is optimised for best asm code - look at the

 * output of:

 *  gcc -D__KERNEL__ -O2 -I../../include -o - -S map.c

/*

 * Scan the free space map, for this zone, calculating the total

 * number of map bits in each free space fragment.

 *

 * Note: idmask is limited to 15 bits [3.2]

	/*

	 * get fragment id

	/*

	 * If the freelink is null, then no free fragments

	 * exist in this zone.

/*

 * calculate the amount of free blocks in the map.

 *

 *              n=1

 *  total_free = E(free_in_zone_n)

 *              nzones

	/*

	 * map & root fragment is special - it starts in the center of the

	 * disk.  The other fragments start at zone (frag / ids_per_zone)

 Convert sector offset to map offset */

 Calculate sector offset into map block */

/*

 * Layout the map - the first zone contains a copy of the disc record,

 * and the last zone must be limited to the size of the filesystem.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * fs/kernfs/inode.c - kernfs inode implementation

 *

 * Copyright (c) 2001-3 Patrick Mochel

 * Copyright (c) 2007 SUSE Linux Products GmbH

 * Copyright (c) 2007, 2013 Tejun Heo <tj@kernel.org>

 assign default attributes */

/**

 * kernfs_setattr - set iattr on a node

 * @kn: target node

 * @iattr: iattr to set

 *

 * Returns 0 on success, -errno on failure.

 this ignores size changes */

		/*

		 * kernfs_node has non-default attributes get them from

		 * persistent copy in kernfs_node.

 initialize inode according to type */

/**

 *	kernfs_get_inode - get inode for kernfs_node

 *	@sb: super block

 *	@kn: kernfs_node to allocate inode for

 *

 *	Get inode for @kn.  If such inode doesn't exist, a new inode is

 *	allocated and basics are initialized.  New inode is returned

 *	locked.

 *

 *	LOCKING:

 *	Kernel thread context (may sleep).

 *

 *	RETURNS:

 *	Pointer to allocated inode on success, NULL on failure.

/*

 * The kernfs_node serves as both an inode and a directory entry for

 * kernfs.  To prevent the kernfs inode numbers from being freed

 * prematurely we take a reference to kernfs_node from the kernfs inode.  A

 * super_operations.evict_inode() implementation is needed to drop that

 * reference upon inode destruction.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * fs/kernfs/dir.c - kernfs directory implementation

 *

 * Copyright (c) 2001-3 Patrick Mochel

 * Copyright (c) 2007 SUSE Linux Products GmbH

 * Copyright (c) 2007, 2013 Tejun Heo <tj@kernel.org>

 kn->parent and ->name */

 protected by rename_lock */

 root->ino_idr */

 kernfs_node_depth - compute depth from @from to @to */

 worst case b and a will be the same at root */

/**

 * kernfs_path_from_node_locked - find a pseudo-absolute path to @kn_to,

 * where kn_from is treated as root of the path.

 * @kn_from: kernfs node which should be treated as root for the path

 * @kn_to: kernfs node to which path is needed

 * @buf: buffer to copy the path into

 * @buflen: size of @buf

 *

 * We need to handle couple of scenarios here:

 * [1] when @kn_from is an ancestor of @kn_to at some level

 * kn_from: /n1/n2/n3

 * kn_to:   /n1/n2/n3/n4/n5

 * result:  /n4/n5

 *

 * [2] when @kn_from is on a different hierarchy and we need to find common

 * ancestor between @kn_from and @kn_to.

 * kn_from: /n1/n2/n3/n4

 * kn_to:   /n1/n2/n5

 * result:  /../../n5

 * OR

 * kn_from: /n1/n2/n3/n4/n5   [depth=5]

 * kn_to:   /n1/n2/n3         [depth=3]

 * result:  /../..

 *

 * [3] when @kn_to is NULL result will be "(null)"

 *

 * Returns the length of the full path.  If the full length is equal to or

 * greater than @buflen, @buf contains the truncated path with the trailing

 * '\0'.  On error, -errno is returned.

 Calculate how many bytes we need for the rest */

/**

 * kernfs_name - obtain the name of a given node

 * @kn: kernfs_node of interest

 * @buf: buffer to copy @kn's name into

 * @buflen: size of @buf

 *

 * Copies the name of @kn into @buf of @buflen bytes.  The behavior is

 * similar to strlcpy().  It returns the length of @kn's name and if @buf

 * isn't long enough, it's filled upto @buflen-1 and nul terminated.

 *

 * Fills buffer with "(null)" if @kn is NULL.

 *

 * This function can be called from any context.

/**

 * kernfs_path_from_node - build path of node @to relative to @from.

 * @from: parent kernfs_node relative to which we need to build the path

 * @to: kernfs_node of interest

 * @buf: buffer to copy @to's path into

 * @buflen: size of @buf

 *

 * Builds @to's path relative to @from in @buf. @from and @to must

 * be on the same kernfs-root. If @from is not parent of @to, then a relative

 * path (which includes '..'s) as needed to reach from @from to @to is

 * returned.

 *

 * Returns the length of the full path.  If the full length is equal to or

 * greater than @buflen, @buf contains the truncated path with the trailing

 * '\0'.  On error, -errno is returned.

/**

 * pr_cont_kernfs_name - pr_cont name of a kernfs_node

 * @kn: kernfs_node of interest

 *

 * This function can be called from any context.

/**

 * pr_cont_kernfs_path - pr_cont path of a kernfs_node

 * @kn: kernfs_node of interest

 *

 * This function can be called from any context.

/**

 * kernfs_get_parent - determine the parent node and pin it

 * @kn: kernfs_node of interest

 *

 * Determines @kn's parent, pins and returns it.  This function can be

 * called from any context.

/**

 *	kernfs_name_hash

 *	@name: Null terminated string to hash

 *	@ns:   Namespace tag to hash

 *

 *	Returns 31 bit hash of ns + name (so it fits in an off_t )

 Reserve hash numbers 0, 1 and INT_MAX for magic directory entries */

/**

 *	kernfs_link_sibling - link kernfs_node into sibling rbtree

 *	@kn: kernfs_node of interest

 *

 *	Link @kn into its sibling rbtree which starts from

 *	@kn->parent->dir.children.

 *

 *	Locking:

 *	kernfs_rwsem held exclusive

 *

 *	RETURNS:

 *	0 on susccess -EEXIST on failure.

 add new node and rebalance the tree */

 successfully added, account subdir number */

/**

 *	kernfs_unlink_sibling - unlink kernfs_node from sibling rbtree

 *	@kn: kernfs_node of interest

 *

 *	Try to unlink @kn from its sibling rbtree which starts from

 *	kn->parent->dir.children.  Returns %true if @kn was actually

 *	removed, %false if @kn wasn't on the rbtree.

 *

 *	Locking:

 *	kernfs_rwsem held exclusive

/**

 *	kernfs_get_active - get an active reference to kernfs_node

 *	@kn: kernfs_node to get an active reference to

 *

 *	Get an active reference of @kn.  This function is noop if @kn

 *	is NULL.

 *

 *	RETURNS:

 *	Pointer to @kn on success, NULL on failure.

/**

 *	kernfs_put_active - put an active reference to kernfs_node

 *	@kn: kernfs_node to put an active reference to

 *

 *	Put an active reference to @kn.  This function is noop if @kn

 *	is NULL.

/**

 * kernfs_drain - drain kernfs_node

 * @kn: kernfs_node to drain

 *

 * Drain existing usages and nuke all existing mmaps of @kn.  Mutiple

 * removers may invoke this function concurrently on @kn and all will

 * return after draining is complete.

 but everyone should wait for draining */

/**

 * kernfs_get - get a reference count on a kernfs_node

 * @kn: the target kernfs_node

/**

 * kernfs_put - put a reference count on a kernfs_node

 * @kn: the target kernfs_node

 *

 * Put a reference count of @kn and destroy it if it reached zero.

	/*

	 * Moving/renaming is always done while holding reference.

	 * kn->parent won't change beneath us.

 just released the root kn, free @root too */

/**

 * kernfs_node_from_dentry - determine kernfs_node associated with a dentry

 * @dentry: the dentry in question

 *

 * Return the kernfs_node associated with @dentry.  If @dentry is not a

 * kernfs one, %NULL is returned.

 *

 * While the returned kernfs_node will stay accessible as long as @dentry

 * is accessible, the returned node can be in any state and the caller is

 * fully responsible for determining what's accessible.

/*

 * kernfs_find_and_get_node_by_id - get kernfs_node from node id

 * @root: the kernfs root

 * @id: the target node id

 *

 * @id's lower 32bits encode ino and upper gen.  If the gen portion is

 * zero, all generations are matched.

 *

 * RETURNS:

 * NULL on failure. Return a kernfs node with reference counter incremented

 we looked up with the low 32bits, compare the whole */

 0 matches all generations */

	/*

	 * ACTIVATED is protected with kernfs_mutex but it was clear when

	 * @kn was added to idr and we just wanna see it set.  No need to

	 * grab kernfs_mutex.

/**

 *	kernfs_add_one - add kernfs_node to parent without warning

 *	@kn: kernfs_node to be added

 *

 *	The caller must already have initialized @kn->parent.  This

 *	function increments nlink of the parent's inode if @kn is a

 *	directory and link into the children list of the parent.

 *

 *	RETURNS:

 *	0 on success, -EEXIST if entry with the given name already

 *	exists.

 Update timestamps on the parent */

	/*

	 * Activate the new node unless CREATE_DEACTIVATED is requested.

	 * If not activated here, the kernfs user is responsible for

	 * activating the node with kernfs_activate().  A node which hasn't

	 * been activated is not visible to userland and its removal won't

	 * trigger deactivation.

/**

 * kernfs_find_ns - find kernfs_node with the given name

 * @parent: kernfs_node to search under

 * @name: name to look for

 * @ns: the namespace tag to use

 *

 * Look for kernfs_node with name @name under @parent.  Returns pointer to

 * the found kernfs_node on success, %NULL on failure.

 grab kernfs_rename_lock to piggy back on kernfs_pr_cont_buf */

/**

 * kernfs_find_and_get_ns - find and get kernfs_node with the given name

 * @parent: kernfs_node to search under

 * @name: name to look for

 * @ns: the namespace tag to use

 *

 * Look for kernfs_node with name @name under @parent and get a reference

 * if found.  This function may sleep and returns pointer to the found

 * kernfs_node on success, %NULL on failure.

/**

 * kernfs_walk_and_get_ns - find and get kernfs_node with the given path

 * @parent: kernfs_node to search under

 * @path: path to look for

 * @ns: the namespace tag to use

 *

 * Look for kernfs_node with path @path under @parent and get a reference

 * if found.  This function may sleep and returns pointer to the found

 * kernfs_node on success, %NULL on failure.

/**

 * kernfs_create_root - create a new kernfs hierarchy

 * @scops: optional syscall operations for the hierarchy

 * @flags: KERNFS_ROOT_* flags

 * @priv: opaque data associated with the new directory

 *

 * Returns the root of the new hierarchy on success, ERR_PTR() value on

 * failure.

	/*

	 * On 64bit ino setups, id is ino.  On 32bit, low 32bits are ino.

	 * High bits generation.  The starting value for both ino and

	 * genenration is 1.  Initialize upper 32bit allocation

	 * accordingly.

/**

 * kernfs_destroy_root - destroy a kernfs hierarchy

 * @root: root of the hierarchy to destroy

 *

 * Destroy the hierarchy anchored at @root by removing all existing

 * directories and destroying @root.

 will also free @root */

/**

 * kernfs_create_dir_ns - create a directory

 * @parent: parent in which to create a new directory

 * @name: name of the new directory

 * @mode: mode of the new directory

 * @uid: uid of the new directory

 * @gid: gid of the new directory

 * @priv: opaque data associated with the new directory

 * @ns: optional namespace tag of the directory

 *

 * Returns the created node on success, ERR_PTR() value on failure.

 allocate */

 link in */

/**

 * kernfs_create_empty_dir - create an always empty directory

 * @parent: parent in which to create a new directory

 * @name: name of the new directory

 *

 * Returns the created node on success, ERR_PTR() value on failure.

 allocate */

 link in */

 Negative hashed dentry? */

		/* If the kernfs parent node has changed discard and

		 * proceed to ->lookup.

		/* The kernfs parent node hasn't changed, leave the

		 * dentry negative and return success.

 The kernfs node has been deactivated */

 The kernfs node has been moved? */

 The kernfs node has been renamed */

 The kernfs node has been moved to a different namespace */

 attach dentry and inode */

		/* Inactive nodes are invisible to the VFS so don't

		 * create a negative.

	/*

	 * Needed for negative dentry validation.

	 * The negative dentry can be created in kernfs_iop_lookup()

	 * or transforms from positive dentry in dentry_unlink_inode()

	 * called from vfs_rmdir().

 instantiate and hash (possibly negative) dentry */

/**

 * kernfs_next_descendant_post - find the next descendant for post-order walk

 * @pos: the current position (%NULL to initiate traversal)

 * @root: kernfs_node whose descendants to walk

 *

 * Find the next descendant to visit for post-order traversal of @root's

 * descendants.  @root is included in the iteration and the last node to be

 * visited.

 if first iteration, visit leftmost descendant which may be root */

 if we visited @root, we're done */

 if there's an unvisited sibling, visit its leftmost descendant */

 no sibling left, visit parent */

/**

 * kernfs_activate - activate a node which started deactivated

 * @kn: kernfs_node whose subtree is to be activated

 *

 * If the root has KERNFS_ROOT_CREATE_DEACTIVATED set, a newly created node

 * needs to be explicitly activated.  A node which hasn't been activated

 * isn't visible to userland and deactivation is skipped during its

 * removal.  This is useful to construct atomic init sequences where

 * creation of multiple nodes should either succeed or fail atomically.

 *

 * The caller is responsible for ensuring that this function is not called

 * after kernfs_remove*() is invoked on @kn.

	/*

	 * Short-circuit if non-root @kn has already finished removal.

	 * This is for kernfs_remove_self() which plays with active ref

	 * after removal.

 prevent any new usage under @kn by deactivating all nodes */

 deactivate and unlink the subtree node-by-node */

		/*

		 * kernfs_drain() drops kernfs_rwsem temporarily and @pos's

		 * base ref could have been put by someone else by the time

		 * the function returns.  Make sure it doesn't go away

		 * underneath us.

		/*

		 * Drain iff @kn was activated.  This avoids draining and

		 * its lockdep annotations for nodes which have never been

		 * activated and allows embedding kernfs_remove() in create

		 * error paths without worrying about draining.

		/*

		 * kernfs_unlink_sibling() succeeds once per node.  Use it

		 * to decide who's responsible for cleanups.

 update timestamps on the parent */

/**

 * kernfs_remove - remove a kernfs_node recursively

 * @kn: the kernfs_node to remove

 *

 * Remove @kn along with all its subdirectories and files.

/**

 * kernfs_break_active_protection - break out of active protection

 * @kn: the self kernfs_node

 *

 * The caller must be running off of a kernfs operation which is invoked

 * with an active reference - e.g. one of kernfs_ops.  Each invocation of

 * this function must also be matched with an invocation of

 * kernfs_unbreak_active_protection().

 *

 * This function releases the active reference of @kn the caller is

 * holding.  Once this function is called, @kn may be removed at any point

 * and the caller is solely responsible for ensuring that the objects it

 * dereferences are accessible.

	/*

	 * Take out ourself out of the active ref dependency chain.  If

	 * we're called without an active ref, lockdep will complain.

/**

 * kernfs_unbreak_active_protection - undo kernfs_break_active_protection()

 * @kn: the self kernfs_node

 *

 * If kernfs_break_active_protection() was called, this function must be

 * invoked before finishing the kernfs operation.  Note that while this

 * function restores the active reference, it doesn't and can't actually

 * restore the active protection - @kn may already or be in the process of

 * being removed.  Once kernfs_break_active_protection() is invoked, that

 * protection is irreversibly gone for the kernfs operation instance.

 *

 * While this function may be called at any point after

 * kernfs_break_active_protection() is invoked, its most useful location

 * would be right before the enclosing kernfs operation returns.

	/*

	 * @kn->active could be in any state; however, the increment we do

	 * here will be undone as soon as the enclosing kernfs operation

	 * finishes and this temporary bump can't break anything.  If @kn

	 * is alive, nothing changes.  If @kn is being deactivated, the

	 * soon-to-follow put will either finish deactivation or restore

	 * deactivated state.  If @kn is already removed, the temporary

	 * bump is guaranteed to be gone before @kn is released.

/**

 * kernfs_remove_self - remove a kernfs_node from its own method

 * @kn: the self kernfs_node to remove

 *

 * The caller must be running off of a kernfs operation which is invoked

 * with an active reference - e.g. one of kernfs_ops.  This can be used to

 * implement a file operation which deletes itself.

 *

 * For example, the "delete" file for a sysfs device directory can be

 * implemented by invoking kernfs_remove_self() on the "delete" file

 * itself.  This function breaks the circular dependency of trying to

 * deactivate self while holding an active ref itself.  It isn't necessary

 * to modify the usual removal path to use kernfs_remove_self().  The

 * "delete" implementation can simply invoke kernfs_remove_self() on self

 * before proceeding with the usual removal path.  kernfs will ignore later

 * kernfs_remove() on self.

 *

 * kernfs_remove_self() can be called multiple times concurrently on the

 * same kernfs_node.  Only the first one actually performs removal and

 * returns %true.  All others will wait until the kernfs operation which

 * won self-removal finishes and return %false.  Note that the losers wait

 * for the completion of not only the winning kernfs_remove_self() but also

 * the whole kernfs_ops which won the arbitration.  This can be used to

 * guarantee, for example, all concurrent writes to a "delete" file to

 * finish only after the whole operation is complete.

	/*

	 * SUICIDAL is used to arbitrate among competing invocations.  Only

	 * the first one will actually perform removal.  When the removal

	 * is complete, SUICIDED is set and the active ref is restored

	 * while kernfs_rwsem for held exclusive.  The ones which lost

	 * arbitration waits for SUICIDED && drained which can happen only

	 * after the enclosing kernfs operation which executed the winning

	 * instance of kernfs_remove_self() finished.

	/*

	 * This must be done while kernfs_rwsem held exclusive; otherwise,

	 * waiting for SUICIDED && deactivated could finish prematurely.

/**

 * kernfs_remove_by_name_ns - find a kernfs_node by name and remove it

 * @parent: parent of the target

 * @name: name of the kernfs_node to remove

 * @ns: namespace tag of the kernfs_node to remove

 *

 * Look for the kernfs_node with @name and @ns under @parent and remove it.

 * Returns 0 on success, -ENOENT if such entry doesn't exist.

/**

 * kernfs_rename_ns - move and rename a kernfs_node

 * @kn: target node

 * @new_parent: new parent to put @sd under

 * @new_name: new name

 * @new_ns: new namespace tag

 can't move or rename root */

 nothing to rename */

 rename kernfs_node */

	/*

	 * Move to the appropriate place in the appropriate directories rbtree.

 rename_lock protects ->parent and ->name accessors */

 Relationship between mode and the DT_xxx types */

 Skip over entries which are dying/dead or in the wrong namespace */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * fs/kernfs/file.c - kernfs file implementation

 *

 * Copyright (c) 2001-3 Patrick Mochel

 * Copyright (c) 2007 SUSE Linux Products GmbH

 * Copyright (c) 2007, 2013 Tejun Heo <tj@kernel.org>

/*

 * There's one kernfs_open_file for each open file and one kernfs_open_node

 * for each kernfs_node with one or more open files.

 *

 * kernfs_node->attr.open points to kernfs_open_node.  attr.open is

 * protected by kernfs_open_node_lock.

 *

 * filp->private_data points to seq_file whose ->private points to

 * kernfs_open_file.  kernfs_open_files are chained at

 * kernfs_open_node->files, which is protected by kernfs_open_file_mutex.

 goes through kernfs_open_file.list */

/*

 * kernfs_notify() may be called from any context and bounces notifications

 * through a work item.  To minimize space overhead in kernfs_node, the

 * pending queue is implemented as a singly linked list of kernfs_nodes.

 * The list is terminated with the self pointer so that whether a

 * kernfs_node is on the list or not can be determined by testing the next

 * pointer for NULL.

/*

 * Determine the kernfs_ops for the given kernfs_node.  This function must

 * be called while holding an active reference.

/*

 * As kernfs_seq_stop() is also called after kernfs_seq_start() or

 * kernfs_seq_next() failure, it needs to distinguish whether it's stopping

 * a seq_file iteration which is fully initialized with an active reference

 * or an aborted kernfs_seq_start() due to get_active failure.  The

 * position pointer is the only context for each seq_file iteration and

 * thus the stop condition should be encoded in it.  As the return value is

 * directly visible to userland, ERR_PTR(-ENODEV) is the only acceptable

 * choice to indicate get_active failure.

 *

 * Unfortunately, this is complicated due to the optional custom seq_file

 * operations which may return ERR_PTR(-ENODEV) too.  kernfs_seq_stop()

 * can't distinguish whether ERR_PTR(-ENODEV) is from get_active failure or

 * custom seq_file operations and thus can't decide whether put_active

 * should be performed or not only on ERR_PTR(-ENODEV).

 *

 * This is worked around by factoring out the custom seq_stop() and

 * put_active part into kernfs_seq_stop_active(), skipping it from

 * kernfs_seq_stop() if ERR_PTR(-ENODEV) while invoking it directly after

 * custom seq_file operations fail with ERR_PTR(-ENODEV) - this ensures

 * that kernfs_seq_stop_active() is skipped only after get_active failure.

	/*

	 * @of->mutex nests outside active ref and is primarily to ensure that

	 * the ops aren't called concurrently for the same open file.

 see the comment above kernfs_seq_stop_active() */

		/*

		 * The same behavior and code as single_open().  Returns

		 * !NULL if pos is at the beginning; otherwise, NULL.

 see the comment above kernfs_seq_stop_active() */

		/*

		 * The same behavior and code as single_open(), always

		 * terminate after the initial read.

/*

 * As reading a bin file can have side-effects, the exact offset and bytes

 * specified in read(2) call should be passed to the read callback making

 * it difficult to use seq_file.  Implement simplistic custom buffering for

 * bin files.

	/*

	 * @of->mutex nests outside active ref and is used both to ensure that

	 * the ops aren't called concurrently for the same open file.

/*

 * Copy data in from userland and pass it to the matching kernfs write

 * operation.

 *

 * There is no easy way for us to know if userspace is only doing a partial

 * write, so we don't support them. We expect the entire buffer to come on

 * the first write.  Hint: if you're writing a value, first read the file,

 * modify only the the value you're changing, then write entire buffer

 * back.

 guarantee string termination */

	/*

	 * @of->mutex nests outside active ref and is used both to ensure that

	 * the ops aren't called concurrently for the same open file.

	/*

	 * mmap path and of->mutex are prone to triggering spurious lockdep

	 * warnings and we don't want to add spurious locking dependency

	 * between the two.  Check whether mmap is actually implemented

	 * without grabbing @of->mutex by testing HAS_MMAP flag.  See the

	 * comment in kernfs_file_open() for more details.

	/*

	 * PowerPC's pci_mmap of legacy_mem uses shmem_zero_setup()

	 * to satisfy versions of X which crash if the mmap fails: that

	 * substitutes a new vm_file, and we don't then want bin_vm_ops.

	/*

	 * It is not possible to successfully wrap close.

	 * So error if someone is trying to use close.

/**

 *	kernfs_get_open_node - get or create kernfs_open_node

 *	@kn: target kernfs_node

 *	@of: kernfs_open_file for this instance of open

 *

 *	If @kn->attr.open exists, increment its reference count; otherwise,

 *	create one.  @of is chained to the files list.

 *

 *	LOCKING:

 *	Kernel thread context (may sleep).

 *

 *	RETURNS:

 *	0 on success, -errno on failure.

 not there, initialize a new one and retry */

/**

 *	kernfs_put_open_node - put kernfs_open_node

 *	@kn: target kernfs_nodet

 *	@of: associated kernfs_open_file

 *

 *	Put @kn->attr.open and unlink @of from the files list.  If

 *	reference count reaches zero, disassociate and free it.

 *

 *	LOCKING:

 *	None.

 see the flag definition for details */

 allocate a kernfs_open_file for the file */

	/*

	 * The following is done to give a different lockdep key to

	 * @of->mutex for files which implement mmap.  This is a rather

	 * crude way to avoid false positive lockdep warning around

	 * mm->mmap_lock - mmap nests @of->mutex under mm->mmap_lock and

	 * reading /sys/block/sda/trace/act_mask grabs sr_mutex, under

	 * which mm->mmap_lock nests, while holding @of->mutex.  As each

	 * open file has a separate mutex, it's okay as long as those don't

	 * happen on the same file.  At this point, we can't easily give

	 * each file a separate locking class.  Let's differentiate on

	 * whether the file has mmap or not for now.

	 *

	 * Both paths of the branch look the same.  They're supposed to

	 * look that way and give @of->mutex different static lockdep keys.

	/*

	 * Write path needs to atomic_write_len outside active reference.

	 * Cache it in open_file.  See kernfs_fop_write_iter() for details.

	/*

	 * ->seq_show is incompatible with ->prealloc,

	 * as seq_read does its own allocation.

	 * ->read must be used instead.

	/*

	 * Always instantiate seq_file even if read access doesn't use

	 * seq_file or is not requested.  This unifies private data access

	 * and readable regular files are the vast majority anyway.

 seq_file clears PWRITE unconditionally, restore it if WRITE */

 make sure we have open node struct */

 nobody has access to @of yet, skip @of->mutex */

 open succeeded, put active references */

 used from release/drain to ensure that ->release() is called exactly once */

	/*

	 * @of is guaranteed to have no other file operations in flight and

	 * we just want to synchronize release and drain paths.

	 * @kernfs_open_file_mutex is enough.  @of->mutex can't be used

	 * here because drain path may be called from places which can

	 * cause circular dependency.

		/*

		 * A file is never detached without being released and we

		 * need to be able to release files which are deactivated

		 * and being drained.  Don't use kernfs_ops().

/*

 * Kernfs attribute files are pollable.  The idea is that you read

 * the content and then you use 'poll' or 'select' to wait for

 * the content to change.  When the content changes (assuming the

 * manager for the kobject supports notification), poll will

 * return EPOLLERR|EPOLLPRI, and select will return the fd whether

 * it is waiting for read, write, or exceptions.

 * Once poll/select indicates that the value has changed, you

 * need to close and re-open the file, or seek to 0 and read again.

 * Reminder: this only works for attributes which actively support

 * it, and it is not possible to test an attribute from userspace

 * to see if it supports poll (Neither 'poll' nor 'select' return

 * an appropriate error code).  When in doubt, set a suitable timeout value.

 pop one off the notify_list */

 kick fsnotify */

		/*

		 * We want fsnotify_modify() on @kn but as the

		 * modifications aren't originating from userland don't

		 * have the matching @file available.  Look up the inodes

		 * and generate the events manually.

/**

 * kernfs_notify - notify a kernfs file

 * @kn: file to notify

 *

 * Notify @kn such that poll(2) on @kn wakes up.  Maybe be called from any

 * context.

 kick poll immediately */

 schedule work to kick fsnotify */

/**

 * __kernfs_create_file - kernfs internal function to create a file

 * @parent: directory to create the file in

 * @name: name of the file

 * @mode: mode of the file

 * @uid: uid of the file

 * @gid: gid of the file

 * @size: size of the file

 * @ops: kernfs operations for the file

 * @priv: private data for the file

 * @ns: optional namespace tag of the file

 * @key: lockdep key for the file's active_ref, %NULL to disable lockdep

 *

 * Returns the created node on success, ERR_PTR() value on error.

	/*

	 * kn->attr.ops is accesible only while holding active ref.  We

	 * need to know whether some ops are implemented outside active

	 * ref.  Cache their existence in flags.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * fs/kernfs/symlink.c - kernfs symlink implementation

 *

 * Copyright (c) 2001-3 Patrick Mochel

 * Copyright (c) 2007 SUSE Linux Products GmbH

 * Copyright (c) 2007, 2013 Tejun Heo <tj@kernel.org>

/**

 * kernfs_create_link - create a symlink

 * @parent: directory to create the symlink in

 * @name: name of the symlink

 * @target: target node for the symlink to point to

 *

 * Returns the created node on success, ERR_PTR() value on error.

 * Ownership of the link matches ownership of the target.

 ref owned by symlink */

 go up to the root, stop at the base */

 determine end of target string for reverse fillup */

 check limits */

 reverse fillup of target string from target to base */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * fs/kernfs/mount.c - kernfs mount implementation

 *

 * Copyright (c) 2001-3 Patrick Mochel

 * Copyright (c) 2007 SUSE Linux Products GmbH

 * Copyright (c) 2007, 2013 Tejun Heo <tj@kernel.org>

		/*

		 * blk_log_action() exposes "LOW32,HIGH32" pair without

		 * type and userland can call us with generic fid

		 * constructed from them.  Combine it back to ID.  See

		 * blk_log_action().

/**

 * kernfs_root_from_sb - determine kernfs_root associated with a super_block

 * @sb: the super_block in question

 *

 * Return the kernfs_root associated with @sb.  If @sb is not a kernfs one,

 * %NULL is returned.

/*

 * find the next ancestor in the path down to @child, where @parent was the

 * ancestor whose descendant we want to find.

 *

 * Say the path is /a/b/c/d.  @child is d, @parent is NULL.  We return the root

 * node.  If @parent is b, then we return the node for c.

 * Passing in d as @parent is not ok.

/**

 * kernfs_node_dentry - get a dentry for the given kernfs_node

 * @kn: kernfs_node for which a dentry is needed

 * @sb: the kernfs super_block

 Check if this is the root kernfs_node */

 Userspace would break if executables or devices appear on sysfs */

 sysfs dentries and inodes don't require IO to create */

 get root inode, initialize and unlock it */

 instantiate and link root dentry */

/**

 * kernfs_super_ns - determine the namespace tag of a kernfs super_block

 * @sb: super_block of interest

 *

 * Return the namespace tag associated with kernfs super_block @sb.

/**

 * kernfs_get_tree - kernfs filesystem access/retrieval helper

 * @fc: The filesystem context.

 *

 * This is to be called from each kernfs user's fs_context->ops->get_tree()

 * implementation, which should set the specified ->@fs_type and ->@flags, and

 * specify the hierarchy and namespace tag to mount via ->@root and ->@ns,

 * respectively.

 Note that we don't deal with kfc->ns_tag here. */

/**

 * kernfs_kill_sb - kill_sb for kernfs

 * @sb: super_block being killed

 *

 * This can be used directly for file_system_type->kill_sb().  If a kernfs

 * user needs extra cleanup, it can implement its own kill_sb() and call

 * this function at the end.

	/*

	 * Remove the superblock from fs_supers/s_instances

	 * so we can't find it, before freeing kernfs_super_info.

 Creates slab cache for kernfs inode attributes */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Optimized MPEG FS - inode and super operations.

 * Copyright (C) 2006 Bob Copeland <me@bobcopeland.com>

/*

 * Update the header checksums for a dirty inode based on its contents.

 * Caller is expected to hold the buffer head underlying oi and mark it

 * dirty.

 get current inode since we may have written sibling ptrs etc. */

 if mirroring writes, copy to next fsblock */

/*

 * called when an entry is deleted, need to clear the bits in the

 * bitmaps.

 check self */

/*

 * Display the mount options in /proc/mounts.

/*

 * For Rio Karma, there is an on-disk free bitmap whose location is

 * stored in the root block.  For ReplayTV, there is no such free bitmap

 * so we have to walk the tree.  Both inodes and file data are allocated

 * from the same map.  This array can be big (300k) so we allocate

 * in units of the blocksize.

	/*

	 * Use sys_blocksize as the fs block since it is smaller than a

	 * page while the fs blocksize can be larger.

	/*

	 * ...and the difference goes into a shift.  sys_blocksize is always

	 * a power of two factor of blocksize.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * OMFS (as used by RIO Karma) directory operations.

 * Copyright (C) 2005 Bob Copeland <me@bobcopeland.com>

/*

 * Finds the bucket for a given name and reads the containing block;

 * *ofs is set to the offset of the first list entry.

 just prepend to head of queue in proper bucket */

 now set the sibling and parent pointers on the new inode */

 mark affected inodes dirty to rebuild checksums */

 delete the proper node in the bucket's linked list */

 found in middle of list, get list ptr */

 sanity check block's self pointer */

 follow chain in this bucket */

 skip visited nodes */

 overwriting existing file/dir */

	/* since omfs locates files by name, we need to unlink _before_

 high 12 bits store bucket + 1 and low 20 bits store hash index */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * OMFS (as used by RIO Karma) file operations.

 * Copyright (C) 2005 Bob Copeland <me@bobcopeland.com>

	/* traverse extent table, freeing each entry that is greater

	 * than inode->i_size;

 only support truncate -> 0 for now */

 ignore last entry as it is the terminator */

/*

 * Add new blocks to the current extent, or create new entries/continuations

 * as necessary.

	/* reached the end of the extent table with no blocks mapped.

	 * there are three possibilities for adding: grow last extent,

	 * add a new extent to the current extent table, and add a

	 * continuation inode.  in last two cases need an allocator for

	 * sbi->s_cluster_size

 TODO: handle holes */

 should always have a terminator */

 trivially grow current extent, if next block is not taken */

 TODO: add a continuation block here */

 try to allocate a new cluster */

 copy terminator down an entry */

 write in new entry */

/*

 * Scans across the directory table for a given file block number.

 * If block not found, return 0.

 count > 1 because of terminator */

			/*

			 * found it at cluster + (block - searched)

			 * numblocks - (block - searched) is remainder

 SPDX-License-Identifier: GPL-2.0

/*

 *  Counts the run of zero bits starting at bit up to max.

 *  It handles the case where a run might spill over a buffer.

 *  Called with bitmap lock.

/*

 * Sets or clears the run of count bits starting with bit.

 * Called with bitmap lock.

/*

 * Tries to allocate exactly one block.  Returns true if successful.

/*

 *  Tries to allocate a set of blocks.	The request size depends on the

 *  type: for inodes, we must allocate sbi->s_mirrors blocks, and for file

 *  blocks, we try to allocate sbi->s_clustersize, but can always get away

 *  with just one block.

/*

 * Clears count bits starting at a given block.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * acl.c

 *

 * Copyright (C) 2004, 2008 Oracle.  All rights reserved.

 *

 * CREDITS:

 * Lots of code in this file is copy from linux/fs/ext3/acl.c.

 * Copyright (C) 2001-2003 Andreas Gruenbacher, <agruen@suse.de>

/*

 * Convert from xattr value to acl struct.

/*

 * Convert acl struct to xattr value.

/*

 * Helper function to set i_mode in memory and disk. Some call paths

 * will not have di_bh or a journal handle to pass, in which case it

 * will create it's own.

/*

 * Set the access or default ACL of an inode.

/*

 * Initialize the ACLs of a new inode. If parent directory has default ACL,

 * then clone to new inode. Called from ocfs2_mknod.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * uptodate.c

 *

 * Tracking the up-to-date-ness of a local buffer_head with respect to

 * the cluster.

 *

 * Copyright (C) 2002, 2004, 2005 Oracle.  All rights reserved.

 *

 * Standard buffer head caching flags (uptodate, etc) are insufficient

 * in a clustered environment - a buffer may be marked up to date on

 * our local node but could have been modified by another cluster

 * member. As a result an additional (and performant) caching scheme

 * is required. A further requirement is that we consume as little

 * memory as possible - we never pin buffer_head structures in order

 * to cache them.

 *

 * We track the existence of up to date buffers on the inodes which

 * are associated with them. Because we don't want to pin

 * buffer_heads, this is only a (strong) hint and several other checks

 * are made in the I/O path to ensure that we don't use a stale or

 * invalid buffer without going to disk:

 *	- buffer_jbd is used liberally - if a bh is in the journal on

 *	  this node then it *must* be up to date.

 *	- the standard buffer_uptodate() macro is used to detect buffers

 *	  which may be invalid (even if we have an up to date tracking

 * 	  item for them)

 *

 * For a full understanding of how this code works together, one

 * should read the callers in dlmglue.c, the I/O functions in

 * buffer_head_io.c and ocfs2_journal_access in journal.c

/* No lock taken here as 'root' is not expected to be visible to other

/* Called from locking and called from ocfs2_clear_inode. Dump the

 * cache for a given inode.

 *

 * This function is a few more lines longer than necessary due to some

 * accounting done here, but I think it's worth tracking down those

	/* If we're a tree, save off the root so that we can safely

	 * initialize the cache. We do the work to free tree members

	/* If possible, track the number wiped so that we can more

	 * easily detect counting errors. Unfortunately, this is only

/* Returns the index in the cache array, -1 if not found.

/* Returns the cache item if found, otherwise NULL.

/* Warning: even if it returns true, this does *not* guarantee that

 * the block is stored in our inode metadata cache.

 *

 * This can be called under lock_buffer()

	/* Doesn't matter if the bh is in our cache or not -- if it's

	 * not marked uptodate then we know it can't have correct

	/* OCFS2 does not allow multiple nodes to be changing the same

	/* Ok, locally the buffer is marked as up to date, now search

/*

 * Determine whether a buffer is currently out on a read-ahead request.

 * ci_io_sem should be held to serialize submitters with the logic here.

 Requires ip_lock */

/* By now the caller should have checked that the item does *not*

 * exist in the tree.

 This should never happen! */

 co_cache_lock() must be held */

/* tree should be exactly OCFS2_CACHE_INFO_MAX_ARRAY wide. NULL the

 * pointers in tree after we use them - this allows caller to detect

 * when to free in case of error.

 *

	/* Be careful to initialize the tree members *first* because

 this will be set again by __ocfs2_insert_cache_tree */

/* Slow path function - memory allocation is necessary. See the

		/* Do *not* allocate an array here - the removal code

 These are initialized in ocfs2_expand_cache! */

		/* Ok, items were removed from the cache in between

	/* If these were used, then ocfs2_expand_cache re-set them to

/* Item insertion is guarded by co_io_lock(), so the insertion path takes

 * advantage of this by not rechecking for a duplicate insert during

 * the slow case. Additionally, if the cache needs to be bumped up to

 * a tree, the code will not recheck after acquiring the lock --

 * multiple paths cannot be expanding to a tree at the same time.

 *

 * The slow path takes into account that items can be removed

 * (including the whole tree wiped and reset) when this process it out

 * allocating memory. In those cases, it reverts back to the fast

 * path.

 *

 * Note that this function may actually fail to insert the block if

 * memory cannot be allocated. This is not fatal however (but may

 * result in a performance penalty)

 *

 * Readahead buffers can be passed in here before the I/O request is

 * completed.

	/* The block may very well exist in our cache already, so avoid

	/* No need to recheck under spinlock - insertion is guarded by

		/* Fast case - it's an array and there's a free

 We need to bump things up to a tree. */

/* Called against a newly allocated buffer. Most likely nobody should

 * be able to read this sort of metadata while it's still being

 This should definitely *not* exist in our cache */

 Requires ip_lock. */

	/* don't need to copy if the array is now empty, or if we

 Requires ip_lock. */

/*

 * Called when we remove a chunk of metadata from an inode. We don't

 * bother reverting things to an inlined array in the case of a remove

 * which moves us back under the limit.

 Called when we remove xattr clusters from an inode. */

 SPDX-License-Identifier: GPL-2.0

/*

 * linux/fs/ocfs2/ioctl.c

 *

 * Copyright (C) 2006 Herbert Poetzl

 * adapted from Remy Card's ext2/ioctl.c

/*

 * This is just a best-effort to tell userspace that this request

 * caused the error.

 Check already done by VFS, but repeat with ocfs lock */

			/*

			 * last chunk may be not an entire one.

				/*

				 * - chunk_free counts free clusters in #N chunk.

				 * - last_chunksize records the size(in) clusters

				 *   for the last real free chunk being counted.

		/*

		 * need to update the info for last free chunk.

	/*

	 * Chunksize(in) clusters from userspace should be

	 * less than clusters in a group.

	/*

	 * chunksize from userspace should be power of 2.

/*

 * Validate and distinguish OCFS2_IOC_INFO requests.

 *

 * - validate the magic number.

 * - distinguish different requests.

 * - validate size of different requests.

		/*

		 * pointer bp stores the base address of a pointers array,

		 * which collects all addresses of separate request.

/*

 * OCFS2_IOC_INFO handles an array of requests passed from userspace.

 *

 * ocfs2_info_handle() recevies a large info aggregation, grab and

 * validate the request count from header, then break it into small

 * pieces, later specific handlers can handle them one by one.

 *

 * Idea here is to make each separate request small enough to ensure

 * a better backward&forward compatibility, since a small piece of

 * request will be less likely to be broken if disk layout get changed.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * namei.c

 *

 * Create and rename file, directory, symlinks

 *

 * Copyright (C) 2002, 2004 Oracle.  All rights reserved.

 *

 *  Portions of this code from linux/fs/ext3/dir.c

 *

 *  Copyright (C) 1992, 1993, 1994, 1995

 *  Remy Card (card@masi.ibp.fr)

 *  Laboratoire MASI - Institut Blaise pascal

 *  Universite Pierre et Marie Curie (Paris VI)

 *

 *   from

 *

 *   linux/fs/minix/dir.c

 *

 *   Copyright (C) 1991, 1992 Linux Torvalds

 An orphan dir name is an 8 byte value, printed as a hex string */

	/* Clear any orphaned state... If we were able to look up the

	 * inode from a directory, it certainly can't be orphaned. We

	 * might have the bad state from a node which intended to

	 * orphan this inode but crashed before it could commit the

		/*

		 * If d_splice_alias() finds a DCACHE_DISCONNECTED

		 * dentry, it will d_move() it on top of ourse. The

		 * return value will indicate this however, so in

		 * those cases, we switch them around for the locking

		 * code.

		 *

		 * NOTE: This dentry already has ->d_op set from

		 * ocfs2_get_parent() and ocfs2_get_dentry()

	/* Don't drop the cluster lock until *after* the d_add --

	 * unlink on another node will message us to remove that

	 * dentry under this lock so otherwise we can race this with

	/* populate as many fields early on as possible - many of

	 * these are used by the support functions here and in

 get our super block */

 can't make a file in a deleted directory. */

 get a spot inside the dir. */

 reserve an inode spot */

 get security xattr */

 calculate meta data/clusters for setting security and acl xattr */

 Reserve a cluster if creating an extent based directory. */

 Dir indexing requires extra space as well */

 Starting to change things, restart is no longer possible. */

 do the real work now. */

	/*

	 * Do this before adding the entry to the directory. We add

	 * also set d_op after success so that ->d_iput() will cleanup

	 * the dentry lock even if ocfs2_add_entry() fails below.

	/*

	 * We should call iput after the i_mutex of the bitmap been

	 * unlocked in ocfs2_free_alloc_context, or the

	 * ocfs2_delete_inode will mutex_lock again.

	/* populate as many fields early on as possible - many of

	 * these are used by the support functions here and in

	/*

	 * If supported, directories start with inline data. If inline

	 * isn't supported, but indexing is, we start them as indexed.

	/* make sure both dirs have bhs

	/*

	 * Check whether another node removed the source inode while we

	 * were in the vfs.

 Starting to change things, restart is no longer possible. */

/*

 * Takes and drops an exclusive lock on the given dentry. This will

 * force other nodes to drop it.

		/* This remote delete should succeed under all normal

 delete the name from the parent dir */

 This was locked for us in ocfs2_prepare_orphan_dir() */

/*

 * The only place this should be used is rename and link!

 * if they have the same id, then the 1st one is the only one locked.

	/* we always want to lock the one with the lower lockid first.

 switch id1 and id2 around */

 lock id2 */

 lock id1 */

		/*

		 * An error return must mean that no cluster locks

		 * were held on function exit.

	/* At some point it might be nice to break this function up a

	/* Assume a directory hierarchy thusly:

	 * a/b/c

	 * a/d

	 * a,b,c, and d are all directories.

	 *

	 * from cwd of 'a' on both nodes:

	 * node1: mv b/c d

	 * node2: mv d   b/c

	 *

	 * And that's why, just like the VFS, we need a file system

		/* here we cannot guarantee the inodes haven't just been

 if old and new are the same, this'll just do one lock. */

	/* make sure both dirs have bhs

	/*

	 * Aside from allowing a meta data update, the locking here

	 * also ensures that the downconvert thread on other nodes

	 * won't have to concurrently downconvert the inode and the

	 * dentry locks.

	/*

	 *  Check for inode number is _not_ due to possible IO errors.

	 *  We might rmdir the source, keep it as pwd of some process

	 *  and merrily kill the link to whatever was created under the

	 *  same name. Goodbye sticky bit ;-<

	/* check if the target already exists (in which case we need

	/* The only error we allow here is -ENOENT because the new

 If we cannot find the file specified we should just */

 return the error... */

		/*

		 * Target was unlinked by another node while we were

		 * waiting to get to ocfs2_rename(). There isn't

		 * anything we can do here to help the situation, so

		 * bubble up the appropriate error.

	/* In case we need to overwrite an existing file, we blow it

		/* VFS didn't think there existed an inode here, but

		 * someone else in the cluster must have raced our

		 * rename to create one. Today we error cleanly, in

		 * the future we should consider calling iget to build

 change the dirent to point to the correct inode */

 if the name was not found in new_dir, add it now */

	/*

	 * Now that the name has been added to new_dir, remove the old name.

	 *

	 * We don't keep any directory entry context around until now

	 * because the insert might have changed the type of directory

	 * we're dealing with.

 Keep the same times on both directories.*/

		/*

		 * This will also pick up the i_nlink change from the

		 * block above.

 This was locked for us in ocfs2_prepare_orphan_dir() */

/*

 * we expect i_size = strlen(symname). Copy symname into the file

 * data, including the null terminator.

	/* we can't trust i_blocks because we're actually going to

 Sanity check -- make sure we're going to fit. */

	/* links can never be larger than one cluster so we know this

	 * is all going to be contiguous, but do a sanity check

 lock the parent directory */

 can't make a file in a deleted directory. */

 get security xattr */

 calculate meta data/clusters for setting security xattr */

 don't reserve bitmap space for fast symlinks. */

 Starting to change things, restart is no longer possible. */

	/*

	 * Do this before adding the entry to the directory. We add

	 * also set d_op after success so that ->d_iput() will cleanup

	 * the dentry lock even if ocfs2_add_entry() fails below.

/**

 * ocfs2_prepare_orphan_dir() - Prepare an orphan directory for

 * insertion of an orphan.

 * @osb: ocfs2 file system

 * @ret_orphan_dir: Orphan dir inode - returned locked!

 * @blkno: Actual block number of the inode to be inserted into orphan dir.

 * @lookup: dir lookup result, to be passed back into functions like

 *          ocfs2_orphan_add

 *

 * Returns zero on success and the ret_orphan_dir, name and lookup

 * fields will be populated.

 *

 * Returns non-zero on failure. 

	/*

	 * We're going to journal the change of i_flags and i_orphaned_slot.

	 * It's safe anyway, though some callers may duplicate the journaling.

	 * Journaling within the func just make the logic look more

	 * straightforward.

	/* we're a cluster, and nlink can change on disk from

		/* Update flag OCFS2_DIO_ORPHANED_FL and record the orphan

		 * slot.

		/* Record which orphan dir our inode now resides

		 * in. delete_inode will use this to determine which orphan

 unlike orphan_add, we expect the orphan dir to already be locked here. */

 find it's spot in the orphan directory */

 remove it from the orphan directory */

 do the i_nlink dance! :) */

/**

 * ocfs2_prep_new_orphaned_file() - Prepare the orphan dir to receive a newly

 * allocated file. This is different from the typical 'add to orphan dir'

 * operation in that the inode does not yet exist. This is a problem because

 * the orphan dir stringifies the inode block number to come up with it's

 * dirent. Obviously if the inode does not yet exist we have a chicken and egg

 * problem. This function works around it by calling deeper into the orphan

 * and suballoc code than other callers. Use this only by necessity.

 * @dir: The directory which this inode will ultimately wind up under - not the

 * orphan dir!

 * @dir_bh: buffer_head the @dir inode block

 * @orphan_name: string of length (CFS2_ORPHAN_NAMELEN + 1). Will be filled

 * with the string to be used for orphan dirent. Pass back to the orphan dir

 * code.

 * @ret_orphan_dir: orphan dir inode returned to be passed back into orphan

 * dir code.

 * @ret_di_blkno: block number where the new inode will be allocated.

 * @orphan_insert: Dir insert context to be passed back into orphan dir code.

 * @ret_inode_ac: Inode alloc context to be passed back to the allocator.

 *

 * Returns zero on success and the ret_orphan_dir, name and lookup

 * fields will be populated.

 *

 * Returns non-zero on failure. 

 reserve an inode spot */

		/*

		 * orphan_name and orphan_insert are already up to

		 * date via prepare_orphan_dir

 Unroll reserve_new_inode* */

 Unroll orphan dir locking */

 do the real work now. */

 get open lock so that only nodes can't remove it from orphan dir. */

 This was locked for us in ocfs2_prepare_orphan_dir() */

	/*

	 * Another append dio crashed?

	 * If so, manually recover it first.

 can't make a file in a deleted directory. */

 get a spot inside the dir. */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * super.c

 *

 * load/unload driver, mount/dismount volumes

 *

 * Copyright (C) 2002, 2004 Oracle.  All rights reserved.

 this should be the only file to include a version 1 header */

 CONFIG_DEBUG_FS */

 the array now has one ref, so drop this one

 the array now has one ref, so drop this one */

 We're allocating fs objects, use GFP_NOFS */

	/*

	 * i_size and all block offsets in ocfs2 are always 64 bits

	 * wide. i_clusters is 32 bits, in cluster-sized units. So on

	 * 64 bit platforms, cluster size will be the limiting factor.

	/*

	 * We might be limited by page cache size.

		/*

		 * Shift by 31 here so that we don't get larger than

		 * MAX_LFS_FILESIZE

	/*

	 * Trim by a whole cluster when we can actually approach the

	 * on-disk limits. Otherwise we can overflow i_clusters when

	 * an extent start is at the max offset.

	/* Probably don't want this on remount; it might

 We're going to/from readonly mode. */

 Disable quota accounting before remounting RO */

		/* Lock here so the check of HARD_RO and the potential

 Enable quota accounting after remounting RW */

 Return back changes... */

		/* Only save off the new mount options in case of a successful

 may be > 512 */

 Can this really happen? */

 check block zero for old format */

	/*

	 * Now check at magic offset for 512, 1024, 2048, 4096

	 * blocksizes.  4096 is the maximum blocksize because it is

	 * the minimum clustersize.

/*

 * If we're using a userspace stack, mount should have passed

 * a name that matches the disk.  If not, mount should not

 * have passed a stack.

 Cancel periodic syncing before suspending */

	/* We mostly ignore errors in this function because there's not much

		/* Turn off quotas. This will remove all dquot structures from

		 * memory and so they will be automatically synced to global

 probe for superblock */

	/* Hard readonly mode only if: bdev_read_only, SB_RDONLY,

		/* You should not be able to start a local heartbeat

	/* Create filecheck sysfs related directories/files at

	/* Now we can initialize quotas because we can afford to wait

	 * for cluster locks recovery now. That also means that truncation

			/* We have to err-out specially here because

 Now we wake up again for processes waiting for quotas */

 Start this when the mount is almost sure of being successful */

 No ACL setting specified? Use XATTR feature... */

			/*

			 * Changing this during remount could race

			 * flock() requests, or "unbalance" existing

			 * ones (e.g., a lock is taken in one mode but

			 * dropped in the other). If users care enough

			 * to flip locking modes during remount, we

			 * could add a "local" flag to individual

			 * flock structures for proper tracking of

			 * state.

			/* Check both that the option we were passed

			 * is of the right length and that it is a proper

			 * string of the right length.

			/*

			 * Open code the memcmp here as we don't have

			 * an osb to pass to

			 * ocfs2_userspace_stack().

 Ensure only one heartbeat mode */

	/*

	 * Make sure all delayed rcu free inodes are flushed before we

	 * destroy cache.

 This will load up the node map and add ourselves to it. */

 load all node-local system inodes */

	/* Remove file check sysfs related directores/files,

 Orphan scan should be stopped as early as possible */

 All dquots should be freed by now */

 Wait for worker to be done with the work structure in osb */

 This will disable recovery and flush any recovery work. */

	/* No cluster connection means we've failed during mount, so skip

	/*

	 * If we're dismounting due to mount error, mount.ocfs2 will clean

	 * up heartbeat.  If we're a local mount, there is no heartbeat.

	 * If we failed before we got a uuid_str yet, we can't stop

	 * heartbeat.  Otherwise, do it.

 print with null */

 drop super cleans up */

 then only advance past the last char */

/* Make sure entire volume is addressable by our journal.  Requires

   osb_clusters_at_boot to be valid and for the journal to have been

 32-bit block number is always OK. */

	/* Volume is "huge", so see if our journal is new enough to

 this is needed to support O_LARGEFILE */

 Copy the blockcheck stats from the superblock probe */

		/*

		 * ci_stack and ci_cluster in ocfs2_cluster_info may not be null

		 * terminated, so make sure no overflow happens here by using

		 * memcpy. Destination strings will always be null terminated

		 * because osb is allocated using kzalloc.

		/* The empty string is identical with classic tools that

 get some pseudo constants for clustersize bits */

 load root, system_dir, and all global system inodes */

	/*

	 * global bitmap

/*

 * will return: -EAGAIN if it is ok to keep searching for superblocks

 *              -EINVAL if there is a bad superblock

 *              0 on success

 We have to do a raw check of the feature here */

 found it! */

	struct ocfs2_dinode *local_alloc = NULL; /* only used if we

						  * recover

 Init our journal object. */

	/* Now that journal has been initialized, check to make sure

	/* If the journal was unmounted cleanly then we don't want to

	 * recover anything. Otherwise, journal_load will do that

 will play back anything left in the journal. */

 recover my local alloc if we didn't unmount cleanly. */

		/* we complete the recovery process after we've marked

		/* Recovery will be completed after we've mounted the

	/* go through each journal, trylock it and if you get the

	 * lock, and it's marked as dirty, set the bit in the recover

/*

 * The routine gets called from dismount or close whenever a dismount on

 * volume is requested and the osb open count becomes 1.

 * It will remove the osb from the global list and also free up all the

 * initialized resources and fileobject.

 This function assumes that the caller has the main osb resource */

 ocfs2_initializer_super have already created this workqueue */

/* Depending on the mount option passed, perform one of the following:

 * Put OCFS2 into a readonly state (default)

 * Return EIO so that only the process errs

 * Fix the error as if fsck.ocfs2 -y

 * panic

 default option */

	/* Not using mlog here because we want to show the actual

/* Handle critical errors. This is intentionally more drastic than

 * ocfs2_handle_error, so we only use for things like journal errors,

	/* We don't have the cluster support yet to go straight to

	 * hard readonly in here. Until then, we want to keep

	 * ocfs2_abort() so that we can at least mark critical

	 * errors.

	 *

	 * TODO: This should abort the journal and alert other nodes

	/* Force a panic(). This stinks, but it's better than letting

	 * things continue without having a proper hard readonly

/*

 * Void signal blockers, because in-kernel sigprocmask() only fails

 * when SIG_* is wrong.

 SPDX-License-Identifier: GPL-2.0

/*

 *  Implementation of operations over global quota file

/*

 * Locking of quotas with OCFS2 is rather complex. Here are rules that

 * should be obeyed by all the functions:

 * - any write of quota structure (either to local or global file) is protected

 *   by dqio_sem or dquot->dq_lock.

 * - any modification of global quota file holds inode cluster lock, i_mutex,

 *   and ip_alloc_sem of the global quota file (achieved by

 *   ocfs2_lock_global_qf). It also has to hold qinfo_lock.

 * - an allocation of new blocks for local quota file is protected by

 *   its ip_alloc_sem

 *

 * A rough sketch of locking dependencies (lf = local file, gf = global file):

 * Normal filesystem operation:

 *   start_trans -> dqio_sem -> write to lf

 * Syncing of local and global file:

 *   ocfs2_lock_global_qf -> start_trans -> dqio_sem -> qinfo_lock ->

 *     write to gf

 *						       -> write to lf

 * Acquire dquot for the first time:

 *   dq_lock -> ocfs2_lock_global_qf -> qinfo_lock -> read from gf

 *				     -> alloc space for gf

 *				     -> start_trans -> qinfo_lock -> write to gf

 *	     -> ip_alloc_sem of lf -> alloc space for lf

 *	     -> write to lf

 * Release last reference to dquot:

 *   dq_lock -> ocfs2_lock_global_qf -> start_trans -> qinfo_lock -> write to gf

 *	     -> write to lf

 * Note that all the above operations also hold the inode cluster lock of lf.

 * Recovery:

 *   inode cluster lock of recovered lf

 *     -> read bitmaps -> ip_alloc_sem of lf

 *     -> ocfs2_lock_global_qf -> start_trans -> dqio_sem -> qinfo_lock ->

 *        write to gf

 Update from disk only entries not set by the admin */

	/*

	 * If the ecc fails, we return the error but otherwise

	 * leave the filesystem running.  We know any error is

	 * local to this block.

/* Read data from global quotafile - avoid pagecache and such because we cannot

 * afford acquiring the locks... We use quota cluster lock to serialize

/* Write to quotafile (we know the transaction is already started and has

 Space is already allocated in ocfs2_acquire_dquot() */

 Not rewriting whole block? */

 Read information header from global quota file */

 Read global header */

/* Write information to global quota file. Expects exlusive lock on quota

	/*

	 * We may need to allocate tree blocks and a leaf block but not the

	 * root block

	/* We modify all the allocated blocks, tree root, info block and

/* Sync local information about quota modifications with global quota file.

 * Caller must have started the transaction and obtained exclusive lock for

	/* Update space and inode usage. Get also other information from

	 * global quota file so that we don't overwrite any changes there.

 Set properly space grace time... */

 Set properly inode grace time... */

 All information is properly updated, clear the flags */

/*

 *  Functions for periodic syncing of dquots with global file

 We have to write local structure as well... */

	/*

	 * We have to be careful here not to deadlock on s_umount as umount

	 * disabling quotas may be in progress and it waits for this work to

	 * complete. If trylock fails, we'll do the sync next time...

/*

 *  Wrappers for generic quota functions

	/*

	 * We modify tree, leaf block, global info, local chunk header,

	 * global and local inode; OCFS2_QINFO_WRITE_CREDITS already

	 * accounts for inode update

 Drop the reference we acquired in ocfs2_dquot_release() */

/*

 * Called when the last reference to dquot is dropped. If we are called from

 * downconvert thread, we cannot do all the handling here because grabbing

 * quota lock could deadlock (the node holding the quota lock could need some

 * other cluster lock to proceed but with blocked downconvert thread we cannot

 * release any lock).

 Check whether we are not racing with some other dqget() */

 Running from downconvert thread? Postpone quota processing to wq */

		/*

		 * Grab our own reference to dquot and queue it for delayed

		 * dropping.  Quota code rechecks after calling

		 * ->release_dquot() and won't free dquot structure.

 First entry on list -> queue work */

	/*

	 * If we fail here, we cannot do much as global structure is

	 * already released. So just complain...

	/*

	 * Clear dq_off so that we search for the structure in quota file next

	 * time we acquire it. The structure might be deleted and reallocated

	 * elsewhere by another node while our dquot structure is on freelist.

/*

 * Read global dquot structure from disk or create it if it does

 * not exist. Also update use count of the global structure and

 * create structure in node-local quota file.

	/*

	 * We need an exclusive lock, because we're going to update use count

	 * and instantiate possibly new dquot structure

	/*

	 * We always want to read dquot structure from disk because we don't

	 * know what happened with it while it was on freelist.

 No real quota entry? */

		/*

		 * Add blocks to quota file before we start a transaction since

		 * locking allocators ranks above a transaction start

	/*

	 * Avoid logging ENOENT since it just means there isn't next ID and

	 * ESRCH which means quota isn't enabled for the filesystem.

	/* In case user set some limits, sync dquot immediately to global

	/* This is a slight hack but we can't afford getting global quota

 Now write updated local dquot structure */

 This should happen only after set_dqinfo(). */

 We never make dquot dirty so .write_dquot is never called */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * xattr.c

 *

 * Copyright (C) 2004, 2008 Oracle.  All rights reserved.

 *

 * CREDITS:

 * Lots of code in this file is copy from linux/fs/ext3/xattr.c.

 * Copyright (C) 2001-2003 Andreas Gruenbacher, <agruen@suse.de>

 The inode these xattrs are associated with */

 The actual buffers that make up the bucket */

 How many blocks make up one bucket for this filesystem */

	/*

	 * xattr_bh point to the block buffer head which has extended attribute

	 * when extended attribute in inode, xattr_bh is equal to inode_bh.

 Operations on struct ocfs2_xa_entry */

	/*

	 * Journal functions

	/*

	 * Return a pointer to the appropriate buffer in loc->xl_storage

	 * at the given offset from loc->xl_header.

 Can we reuse the existing entry for the new value? */

 How much space is needed for the new value? */

	/*

	 * Return the offset of the first name+value pair.  This is

	 * the start of our downward-filling free space.

	/*

	 * Remove the name+value at this location.  Do whatever is

	 * appropriate with the remaining name+value pairs.

 Fill xl_entry with a new entry */

 Add name+value storage to an entry */

	/*

	 * Initialize the value buf's access and bh fields for this entry.

	 * ocfs2_xa_fill_value_buf() will handle the xv pointer.

/*

 * Describes an xattr entry location.  This is a memory structure

 * tracking the on-disk structure.

 This xattr belongs to this inode */

 The ocfs2_xattr_header inside the on-disk storage. Not NULL. */

 Bytes from xl_header to the end of the storage */

	/*

	 * The ocfs2_xattr_entry this location describes.  If this is

	 * NULL, this location describes the on-disk structure where it

	 * would have been.

	/*

	 * Internal housekeeping

 Buffer(s) containing this entry */

 Operations on the storage backing this location */

/*

 * Convenience functions to calculate how much space is needed for a

 * given name+value pair

/*

 * A bucket that has never been written to disk doesn't need to be

 * read.  We just need the buffer_heads.  Don't call this for

 * buckets that are already on disk.  ocfs2_read_xattr_bucket() initializes

 * them fully.

 Read the xattr bucket at xb_blkno */

	/*

	 * If the ecc fails, we return the error but otherwise

	 * leave the filesystem running.  We know any error is

	 * local to this block.

	/*

	 * Errors after here are fatal

 If ocfs2_read_block() got us a new bh, pass it up. */

 Get hash value of uuid from super block */

 hash extended attribute name */

	/*

	 * The max space of security xattr taken inline is

	 * 256(name) + 80(value) + 16(entry) = 352 bytes,

	 * So reserve one metadata block for it is ok.

 reserve clusters for xattr value which will be set in B tree*/

	/*

	 * The max space of security xattr taken inline is

	 * 256(name) + 80(value) + 16(entry) = 352 bytes,

	 * The max space of acl xattr taken inline is

	 * 80(value) + 16(entry) * 2(if directory) = 192 bytes,

	 * when blocksize = 512, may reserve one more cluser for

	 * xattr bucket, otherwise reserve one metadata block

	 * for them is ok.

	 * If this is a new directory with inline data,

	 * we choose to reserve the entire inline area for

	 * directory contents and force an external xattr block.

	/*

	 * reserve credits and clusters for xattrs which has large value

	 * and have to be set outside

 for directory, it has DEFAULT and ACCESS two types of acls */

			/*

			 * We can only fail in case the alloc file doesn't give

			 * up enough clusters.

 we are just looking for how big our buffer needs to be */

 Copy ocfs2_xattr_value */

/* ocfs2_xattr_get()

 *

 * Copy an extended attribute into the buffer provided.

 * Buffer is NULL to compute the size of buffer required.

			/*

			 * XXX: do we need to empty all the following

			 * blocks in this cluster?

 Give a pointer into the storage for the given offset */

/*

 * Wipe the name+value pair and allow the storage to reclaim it.  This

 * must be followed by either removal of the entry or a call to

 * ocfs2_xa_add_namevalue().

/*

 * Find lowest offset to a name+value pair.  This is the start of our

 * downward-growing free space.

 Can we reuse loc->xl_entry for xi? */

 How much free space is needed to set the new value */

	/*

	 * We can't leave the new entry's xe_name_offset at zero or

	 * add_namevalue() will go nuts.  We set it to the size of our

	 * storage so that it can never be less than any other entry.

 Value bufs are for value trees */

	/*

	 * Block storage is strict.  If the sizes aren't exact, we will

	 * remove the old one and reinsert the new.

	/*

	 * Block storage will reclaim the original entry before inserting

	 * the new value, so we only need the difference.  If the new

	 * entry is smaller than the old one, we don't need anything.

 Don't need space if we're reusing! */

/*

 * Block storage for xattrs keeps the name+value pairs compacted.  When

 * we remove one, we have to shift any that preceded it towards the end.

 Shift the name+value pairs */

 Now tell xh->xh_entries about it */

	/*

	 * Note that we don't update xh_free_start or xh_name_value_len

	 * because they're not used in block-stored xattrs.

/*

 * Operations for xattrs stored in blocks.  This includes inline inode

 * storage and unindexed ocfs2_xattr_blocks.

 The header is at the front of the bucket */

	/*

	 * We need to make sure that the name+value pair fits within

	 * one block.

	/*

	 * Bucket storage does not reclaim name+value pairs it cannot

	 * reuse.  They live as holes until the bucket fills, and then

	 * the bucket is defragmented.  However, the bucket can reclaim

	 * the ocfs2_xattr_entry.

 Don't need space if we're reusing! */

		/*

		 * First we check if it would fit in the first place.

		 * Below, we align the free start to a block.  This may

		 * slide us below the minimum gap.  By checking unaligned

		 * first, we avoid that error.

	/*

	 * We keep buckets sorted by name_hash, so we need to find

	 * our insert place.

 Values are not allowed to straddle block boundaries */

 We expect the bucket to be filled in */

 Operations for xattrs stored in buckets. */

	/*

	 * The caller of ocfs2_xa_value_truncate() has already called

	 * ocfs2_xa_journal_access on the loc.  However, The truncate code

	 * calls ocfs2_extend_trans().  This may commit the previous

	 * transaction and open a new one.  If this is a bucket, truncate

	 * could leave only vb->vb_bh set up for journaling.  Meanwhile,

	 * the caller is expecting to dirty the entire bucket.  So we must

	 * reset the journal work.  We do this even if truncate has failed,

	 * as it could have failed after committing the extend.

 Errors in truncate take precedence */

	/*

	 * Only zero out the entry if there are more remaining.  This is

	 * important for an empty bucket, as it keeps track of the

	 * bucket's hash value.  It doesn't hurt empty block storage.

/*

 * If we have a problem adjusting the size of an external value during

 * ocfs2_xa_prepare_entry() or ocfs2_xa_remove(), we may have an xattr

 * in an intermediate state.  For example, the value may be partially

 * truncated.

 *

 * If the value tree hasn't changed, the extend/truncate went nowhere.

 * We have nothing to do.  The caller can treat it as a straight error.

 *

 * If the value tree got partially truncated, we now have a corrupted

 * extended attribute.  We're going to wipe its entry and leak the

 * clusters.  Better to leak some storage than leave a corrupt entry.

 *

 * If the value tree grew, it obviously didn't grow enough for the

 * new entry.  We're not going to try and reclaim those clusters either.

 * If there was already an external value there (orig_clusters != 0),

 * the new clusters are attached safely and we can just leave the old

 * value in place.  If there was no external value there, we remove

 * the entry.

 *

 * This way, the xattr block we store in the journal will be consistent.

 * If the size change broke because of the journal, no changes will hit

 * disk anyway.

			/*

			 * Since this is remove, we can return 0 if

			 * ocfs2_xa_cleanup_value_truncate() is going to

			 * wipe the entry anyway.  So we check the

			 * cluster count as well.

/*

 * Take an existing entry and make it ready for the new value.  This

 * won't allocate space, but it may free space.  It should be ready for

 * ocfs2_xa_prepare_entry() to finish the work.

/*

 * Prepares loc->xl_entry to receive the new xattr.  This includes

 * properly setting up the name+value pair region.  If loc->xl_entry

 * already exists, it will take care of modifying it appropriately.

 *

 * Note that this modifies the data.  You did journal_access already,

 * right?

	/*

	 * If we get here, we have a blank entry.  Fill it.  We grow our

	 * name+value pair back from the end.

			/*

			 * If we were growing an existing value,

			 * ocfs2_xa_cleanup_value_truncate() won't remove

			 * the entry. We need to restore the original value

			 * size.

/*

 * Store the value portion of the name+value pair.  This will skip

 * values that are stored externally.  Their tree roots were set up

 * by ocfs2_xa_prepare_entry().

	/*

	 * From here on out, everything is going to modify the buffer a

	 * little.  Errors are going to leave the xattr header in a

	 * sane state.  Thus, even with errors we dirty the sucker.

 Don't worry, we are never called with !xi_value and !xl_entry */

/*

 * In xattr remove, if it is stored outside and refcounted, we may have

 * the chance to split the refcount tree. So need the allocators.

/*

 * ocfs2_xattr_remove()

 *

 * Free extended attribute resources associated with this inode.

/*

 * ocfs2_xattr_ibody_find()

 *

 * Find extended attribute in inode block and

 * fill search info into struct ocfs2_xattr_search.

 Find the named attribute. */

	/*

	 * Adjust extent record count or inline data size

	 * to reserve space for extended attribute.

/*

 * ocfs2_xattr_ibody_set()

 *

 * Set, replace or remove an extended attribute into inode block.

 *

/*

 * ocfs2_xattr_block_find()

 *

 * Find extended attribute in external block and

 * fill search info into struct ocfs2_xattr_search.

 Initialize ocfs2_xattr_block */

 Add it to the inode */

/*

 * ocfs2_xattr_block_set()

 *

 * Set, replace or remove an extended attribute into external block.

 *

 Check whether the new xattr can be inserted into the inode. */

	/*

	 * Calculate the clusters we need to write.

	 * No matter whether we replace an old one or add a new one,

	 * we need this for writing.

	/*

	 * delete a xattr doesn't need metadata and cluster allocation.

	 * so just calculate the credits and return.

	 *

	 * The credits for removing the value tree will be extended

	 * by ocfs2_remove_extent itself.

 do cluster allocation guess first. */

		/*

		 * In xattr set, we always try to set the xe in inode first,

		 * so if it can be inserted into inode successfully, the old

		 * one will be removed from the xattr block, and this xattr

		 * will be inserted into inode as a new xattr in inode.

 the new values will be stored outside. */

		/*

		 * Now the new value will be stored inside. So if the new

		 * value is smaller than the size of value root or the old

		 * value, we don't need any allocation, otherwise we have

		 * to guess metadata allocation.

 calculate metadata allocation. */

		/*

		 * If there is already an xattr tree, good, we can calculate

		 * like other b-trees. Otherwise we may have the chance of

		 * create a tree, the credit calculation is borrowed from

		 * ocfs2_calc_extend_credits with root_el = NULL. And the

		 * new tree will be cluster based, so no meta is needed.

		/*

		 * This cluster will be used either for new bucket or for

		 * new xattr block.

		 * If the cluster size is the same as the bucket size, one

		 * more is needed since we may need to extend the bucket

		 * also.

		/*

		 * We cannot have an error and a non null ctxt->data_ac.

 Remove existing extended attribute */

 We always try to set extended attribute into inode first*/

			/*

			 * If succeed and that extended attribute existing in

			 * external block, then we will remove it.

			/*

			 * If no space in inode, we will set extended attribute

			 * into external block.

				/*

				 * If succeed and that extended attribute

				 * existing in inode, we will remove it.

 Update inode ctime. */

/*

 * This function only called duing creating inode

 * for init security/acl xattrs of the new inode.

 * All transanction credits have been reserved in mknod.

	/*

	 * In extreme situation, may need xattr bucket when

	 * block size is too small. And we have already reserved

	 * the credits for bucket in mknod.

/*

 * ocfs2_xattr_set()

 *

 * Set, replace or remove an extended attribute for this inode.

 * value is NULL to remove an existing extended attribute, else either

 * create or replace an extended attribute.

	/*

	 * Only xbs will be used on indexed trees.  xis doesn't need a

	 * bucket.

	/*

	 * Scan inode and external block to find the same name

	 * extended attribute and collect search information.

 Check whether the value is refcounted and do some preparation. */

 we need to update inode's ctime field, so add credit for it. */

/*

 * Find the xattr extent rec which may contains name_hash.

 * e_cpos will be the first name hash of the xattr rec.

 * el must be the ocfs2_xattr_header.xb_attrs.xb_root.xt_list.

	/*

	 * We don't use binary search in the bucket because there

	 * may be multiple entries with the same name hash.

/*

 * Find the specified xattr entry in a series of buckets.

 * This series start from p_blkno and last for num_clusters.

 * The ocfs2_xattr_header.xh_num_buckets of the first bucket contains

 * the num of the valid buckets.

 *

 * Return the buffer_head this xattr should reside in. And if the xattr's

 * hash is in the gap of 2 buckets, return the lower bucket.

		/*

		 * Check whether the hash of the last entry in our

		 * bucket is larger than the search one. for an empty

		 * bucket, the last one is also the first one.

 record lower_blkno which may be the insert place. */

 the searched xattr should reside in this bucket if exists. */

	/*

	 * Record the bucket we have found.

	 * When the xattr's hash value is in the gap of 2 buckets, we will

	 * always set it to the previous bucket.

 This should be in cache - we just read it during the search */

		/*

		 * The real bucket num in this series of blocks is stored

		 * in the 1st bucket.

 Fall through to bucket_relse() */

/*

 * When the ocfs2_xattr_block is filled up, new bucket will be created

 * and all the xattr entries will be moved to the new bucket.

 * The header goes at the start of the bucket, and the names+values are

 * filled from the end.  This is why *target starts as the last buffer.

 * Note: we need to sort the entries since they are not saved in order

 * in the ocfs2_xattr_block.

	/*

	 * Since the xe_name_offset is based on ocfs2_xattr_header,

	 * there is a offset change corresponding to the change of

	 * ocfs2_xattr_header's position.

 copy all the names and values. */

 Init new header now. */

 copy all the entries. */

 Change the xe offset for all the xe because of the move. */

/*

 * After we move xattr from block to index btree, we have to

 * update ocfs2_xattr_search to the new xe and base.

 *

 * When the entry is in xattr block, xattr_bh indicates the storage place.

 * While if the entry is in index b-tree, "bucket" indicates the

 * real place of the xattr.

	/*

	 * XXX:

	 * We can use this lock for now, and maybe move to a dedicated mutex

	 * if performance becomes a problem later.

	/*

	 * The bucket may spread in many blocks, and

	 * we will only touch the 1st block and the last block

	 * in the whole bucket(one for entry and one for data).

 Change from ocfs2_xattr_header to ocfs2_xattr_tree_root */

/*

 * defrag a xattr bucket if we find that the bucket has some

 * holes beteen name/value pairs.

 * We will move all the name/value pairs to the end of the bucket

 * so that we can spare some space for insertion.

	/*

	 * In order to make the operation more efficient and generic,

	 * we copy all the blocks into a contiguous memory and do the

	 * defragment there, so if anything is error, we will not touch

	 * the real block.

	/*

	 * sort all the entries by their offset.

	 * the largest will be the first, so that we can

	 * move them to the end one by one.

 Move all name/values to the end of the bucket. */

		/*

		 * We must make sure that the name/value pair

		 * exist in the same block. So adjust end to

		 * the previous block end if needed.

 sort the entries by their name_hash. */

/*

 * prev_blkno points to the start of an existing extent.  new_blkno

 * points to a newly allocated extent.  Because we know each of our

 * clusters contains more than bucket, we can easily split one cluster

 * at a bucket boundary.  So we take the last cluster of the existing

 * extent and split it down the middle.  We move the last half of the

 * buckets in the last cluster of the existing extent over to the new

 * extent.

 *

 * first_bh is the buffer at prev_blkno so we can update the existing

 * extent's bucket count.  header_bh is the bucket were we were hoping

 * to insert our xattr.  If the bucket move places the target in the new

 * extent, we'll update first_bh and header_bh after modifying the old

 * extent.

 *

 * first_hash will be set as the 1st xe's name_hash in the new extent.

 This is the first bucket that got moved */

	/*

	 * If the target bucket was part of the moved buckets, we need to

	 * update first and target.

 Find the block for the new target bucket */

		/*

		 * These shouldn't fail - the buffers are in the

		 * journal from ocfs2_cp_xattr_bucket().

/*

 * Find the suitable pos when we divide a bucket into 2.

 * We have to make sure the xattrs with the same hash value exist

 * in the same bucket.

 *

 * If this ocfs2_xattr_header covers more than one hash value, find a

 * place where the hash value changes.  Try to find the most even split.

 * The most common case is that all entries have different hash values,

 * and the first check we make will find a place to split.

	/*

	 * We start at the middle.  Each step gets farther away in both

	 * directions.  We therefore hit the change in hash value

	 * nearest to the middle.  Note that this loop does not execute for

	 * count < 2.

 Let's check delta earlier than middle */

 For even counts, don't walk off the end */

 Now try delta past middle */

 Every entry had the same hash */

/*

 * Move some xattrs in old bucket(blk) to new bucket(new_blk).

 * first_hash will record the 1st hash of the new bucket.

 *

 * Normally half of the xattrs will be moved.  But we have to make

 * sure that the xattrs with the same hash value are stored in the

 * same bucket. If all the xattrs in this bucket have the same hash

 * value, the new bucket will be initialized as an empty one and the

 * first_hash will be initialized as (hash_value+1).

	/*

	 * Even if !new_bucket_head, we're overwriting t_bucket.  Thus,

	 * there's no need to read it.

	/*

	 * Hey, if we're overwriting t_bucket, what difference does

	 * ACCESS_CREATE vs ACCESS_WRITE make?  See the comment in the

	 * same part of ocfs2_cp_xattr_bucket().

		/*

		 * initialized a new empty bucket here.

		 * The hash value is set as one larger than

		 * that of the last entry in the previous bucket.

 copy the whole bucket to the new first. */

 update the new bucket. */

	/*

	 * Calculate the total name/value len and xh_free_start for

	 * the old bucket first.

	/*

	 * Now begin the modification to the new bucket.

	 *

	 * In the new bucket, We just move the xattr entry to the beginning

	 * and don't touch the name/value. So there will be some holes in the

	 * bucket, and they will be removed when ocfs2_defrag_xattr_bucket is

	 * called.

 Calculate xh_free_start for the new bucket. */

 set xh->xh_num_buckets for the new xh. */

 store the first_hash of the new bucket. */

	/*

	 * Now only update the 1st block of the old bucket.  If we

	 * just added a new empty bucket, there is no need to modify

	 * it.

/*

 * Copy xattr from one bucket to another bucket.

 *

 * The caller must make sure that the journal transaction

 * has enough space for journaling.

	/*

	 * Even if !t_is_new, we're overwriting t_bucket.  Thus,

	 * there's no need to read it.

	/*

	 * Hey, if we're overwriting t_bucket, what difference does

	 * ACCESS_CREATE vs ACCESS_WRITE make?  Well, if we allocated a new

	 * cluster to fill, we came here from

	 * ocfs2_mv_xattr_buckets(), and it is really new -

	 * ACCESS_CREATE is required.  But we also might have moved data

	 * out of t_bucket before extending back into it.

	 * ocfs2_add_new_xattr_bucket() can do this - its call to

	 * ocfs2_add_new_xattr_cluster() may have created a new extent

	 * and copied out the end of the old extent.  Then it re-extends

	 * the old extent back to create space for new xattrs.  That's

	 * how we get here, and the bucket isn't really new.

/*

 * src_blk points to the start of an existing extent.  last_blk points to

 * last cluster in that extent.  to_blk points to a newly allocated

 * extent.  We copy the buckets from the cluster at last_blk to the new

 * extent.  If start_bucket is non-zero, we skip that many buckets before

 * we start copying.  The new extent's xh_num_buckets gets set to the

 * number of buckets we copied.  The old extent's xh_num_buckets shrinks

 * by the same amount.

 The first bucket of the original extent */

 The first bucket of the new extent */

	/*

	 * We need to update the first bucket of the old extent and all

	 * the buckets going to the new extent.

	/*

	 * Get the new bucket ready before we dirty anything

	 * (This actually shouldn't fail, because we already dirtied

	 * it once in ocfs2_cp_xattr_bucket()).

 Now update the headers */

/*

 * Move some xattrs in this cluster to the new cluster.

 * This function should only be called when bucket size == cluster size.

 * Otherwise ocfs2_mv_xattr_bucket_cross_cluster should be used instead.

 Move half of the xattr in start_blk to the next bucket. */

/*

 * Move some xattrs from the old cluster to the new one since they are not

 * contiguous in ocfs2 xattr tree.

 *

 * new_blk starts a new separate cluster, and we will move some xattrs from

 * prev_blk to it. v_start will be set as the first name hash value in this

 * new cluster so that it can be used as e_cpos during tree insertion and

 * don't collide with our original b-tree operations. first_bh and header_bh

 * will also be updated since they will be used in ocfs2_extend_xattr_bucket

 * to extend the insert bucket.

 *

 * The problem is how much xattr should we move to the new one and when should

 * we update first_bh and header_bh?

 * 1. If cluster size > bucket size, that means the previous cluster has more

 *    than 1 bucket, so just move half nums of bucket into the new cluster and

 *    update the first_bh and header_bh if the insert bucket has been moved

 *    to the new cluster.

 * 2. If cluster_size == bucket_size:

 *    a) If the previous extent rec has more than one cluster and the insert

 *       place isn't in the last cluster, copy the entire last cluster to the

 *       new one. This time, we don't need to upate the first_bh and header_bh

 *       since they will not be moved into the new cluster.

 *    b) Otherwise, move the bottom half of the xattrs in the last cluster into

 *       the new one. And we set the extend flag to zero if the insert place is

 *       moved into the new allocated cluster since no extend is needed.

 The start of the last cluster in the first extent */

/*

 * Add a new cluster for xattr storage.

 *

 * If the new cluster is contiguous with the previous one, it will be

 * appended to the same extent record, and num_clusters will be updated.

 * If not, we will insert a new extent for it and move some xattrs in

 * the last cluster into the new allocated one.

 * We also need to limit the maximum size of a btree leaf, otherwise we'll

 * lose the benefits of hashing because we'll have to search large leaves.

 * So now the maximum size is OCFS2_MAX_XATTR_TREE_LEAF_SIZE(or clustersize,

 * if it's bigger).

 *

 * first_bh is the first block of the previous extent rec and header_bh

 * indicates the bucket we will insert the new xattrs. They will be updated

 * when the header_bh is moved into the new cluster.

		/*

		 * If this cluster is contiguous with the old one and

		 * adding this new cluster, we don't surpass the limit of

		 * OCFS2_MAX_XATTR_TREE_LEAF_SIZE, cool. We will let it be

		 * initialized and used like other buckets in the previous

		 * cluster.

		 * So add it as a contiguous one. The caller will handle

		 * its init process.

/*

 * We are given an extent.  'first' is the bucket at the very front of

 * the extent.  The extent has space for an additional bucket past

 * bucket_xh(first)->xh_num_buckets.  'target_blkno' is the block number

 * of the target bucket.  We wish to shift every bucket past the target

 * down one, filling in that additional space.  When we get back to the

 * target, we split the target between itself and the now-empty bucket

 * at target+1 (aka, target_blkno + blks_per_bucket).

 The extent must have room for an additional bucket */

 end_blk points to the last existing bucket */

	/*

	 * end_blk is the start of the last existing bucket.

	 * Thus, (end_blk - target_blk) covers the target bucket and

	 * every bucket after it up to, but not including, the last

	 * existing bucket.  Then we add the last existing bucket, the

	 * new bucket, and the first bucket (3 * blk_per_bucket).

 Move half of the xattr in target_blkno to the next bucket. */

/*

 * Add new xattr bucket in an extent record and adjust the buckets

 * accordingly.  xb_bh is the ocfs2_xattr_block, and target is the

 * bucket we want to insert into.

 *

 * In the easy case, we will move all the buckets after target down by

 * one. Half of target's xattrs will be moved to the next bucket.

 *

 * If current cluster is full, we'll allocate a new one.  This may not

 * be contiguous.  The underlying calls will make sure that there is

 * space for the insert, shifting buckets around if necessary.

 * 'target' may be moved by those calls.

 The bucket at the front of the extent */

 The first bucket of the original extent */

		/*

		 * This can move first+target if the target bucket moves

		 * to the new extent.

/*

 * Truncate the specified xe_off entry in xattr bucket.

 * bucket is indicated by header_bh and len is the new length.

 * Both the ocfs2_xattr_value_root and the entry will be updated here.

 *

 * Copy the new updated xe and xe_value_root to new_xe and new_xv if needed.

 We don't allow ocfs2_xattr_value to be stored in different block. */

	/*

	 * From here on out we have to dirty the bucket.  The generic

	 * value calls only modify one of the bucket's bhs, but we need

	 * to send the bucket at once.  So if they error, they *could* have

	 * modified something.  We have to assume they did, and dirty

	 * the whole bucket.  This leaves us in a consistent state.

/*

 * check whether the xattr bucket is filled up with the same hash value.

 * If we want to insert the xattr with the same hash, return -ENOSPC.

 * If we want to insert a xattr with different hash value, go ahead

 * and ocfs2_divide_xattr_bucket will handle this.

/*

 * Try to set the entry in the current bucket.  If we fail, the caller

 * will handle getting us another bucket.

 Ok, we need space.  Let's try defragmenting the bucket. */

 Ack, need more space.  Let's try to get another bucket! */

	/*

	 * We do not allow for overlapping ranges between buckets. And

	 * the maximum number of collisions we will allow for then is

	 * one bucket's worth, so check it here whether we need to

	 * add a new bucket for the insert.

	/*

	 * ocfs2_add_new_xattr_bucket() will have updated

	 * xs->bucket if it moved, but it will not have updated

	 * any of the other search fields.  Thus, we drop it and

	 * re-search.  Everything should be cached, so it'll be

	 * quick.

 Ok, we have a new bucket, let's try again */

/*

 * Whenever we modify a xattr value root in the bucket(e.g, CoW

 * or change the extent record flag), we need to recalculate

 * the metaecc for the whole bucket. So it is done here.

 *

 * Note:

 * We have to give the extra credits for the caller.

/*

 * Special action we need if the xattr value is refcounted.

 *

 * 1. If the xattr is refcounted, lock the tree.

 * 2. CoW the xattr if we are setting the new value and the value

 *    will be stored outside.

 * 3. In other case, decrease_refcount will work for us, so just

 *    lock the refcount tree, calculate the meta and credits is OK.

 *

 * We have to do CoW before ocfs2_init_xattr_set_ctxt since

 * currently CoW is a completed transaction, while this function

 * will also lock the allocators and let us deadlock. So we will

 * CoW the whole xattr value.

create parameters for ocfs2_post_refcount. */

	/*

	 * We just need to check the 1st extent record, since we always

	 * CoW the whole xattr. So there shouldn't be a xattr with

	 * some REFCOUNT extent recs after the 1st one.

	/*

	 * If we are deleting the xattr or the new size will be stored inside,

	 * cool, leave it there, the xattr truncate process will remove them

	 * for us(it still needs the refcount tree lock and the meta, credits).

	 * And the worse case is that every cluster truncate will split the

	 * refcount tree, and make the original extent become 3. So we will need

	 * 2 * cluster more extent recs at most.

/*

 * Add the REFCOUNTED flags for all the extent rec in ocfs2_xattr_value_root.

 * The physical clusters will be added to refcount tree.

/*

 * Given a normal ocfs2_xattr_header, refcount all the entries which

 * have value stored outside.

 * Used for xattrs stored in inode and ocfs2_xattr_block.

/*

 * For a given xattr bucket, refcount all the entries which

 * have value stored outside.

 We only need post_refcount if we support metaecc. */

/*

 * Store the information we need in xattr reflink.

 * old_bh and new_bh are inode bh for the old and new inode.

/*

 * Given a xattr header and xe offset,

 * return the proper xv and the corresponding bh.

 * xattr in inode, block and xattr tree have different implementaions.

/*

 * Calculate all the xattr value root metadata stored in this xattr header and

 * credits we need if we create them from the scratch.

 * We use get_xattr_value_root so that all types of xattr container can use it.

		/*

		 * If the value is a tree with depth > 1, We don't go deep

		 * to the extent block, so just calculate a maximum record num.

 Used by xattr inode and block to return the right xv and buffer_head. */

/*

 * Lock the meta_ac and caculate how much credits we need for reflink xattrs.

 * It is only used for inline xattr and xattr block.

	/*

	 * We need to add/modify num_recs in refcount tree, so just calculate

	 * an approximate number we need for refcount tree change.

	 * Sometimes we need to split the tree, and after split,  half recs

	 * will be moved to the new block, and a new block can only provide

	 * half number of recs. So we multiple new blocks by 2.

/*

 * Given a xattr header, reflink all the xattrs in this container.

 * It can be used for inode, block and bucket.

 *

 * NOTE:

 * Before we call this function, the caller has memcpy the xattr in

 * old_xh to the new_xh.

 *

 * If args.xattr_reflinked is set, call it to decide whether the xe should

 * be reflinked or not. If not, remove it from the new xattr header.

			/*

			 * We don't want j to increase in the next round since

			 * it is already moved ahead.

		/*

		 * For the xattr which has l_tree_depth = 0, all the extent

		 * recs have already be copied to the new xh with the

		 * propriate OCFS2_EXT_REFCOUNTED flag we just need to

		 * increase the refount count int the refcount tree.

		 *

		 * For the xattr which has l_tree_depth > 0, we need

		 * to initialize it to the empty default value root,

		 * and then insert the extents one by one.

	/*

	 * Adjust extent record count to reserve space for extended attribute.

	 * Inline data count had been adjusted in ocfs2_duplicate_inline_data().

 One more credits in case we need to add xattr flags in new inode. */

/*

 * NOTE:

 * We have to handle the case that both old bucket and new bucket

 * will call this function to get the right ret_bh.

 * So The caller must give us the right bh.

 Add the credits for this bucket first. */

/*

 * Given a xattr extent rec starting from blkno and having len clusters,

 * iterate all the buckets calculate how much metadata we need for reflinking

 * all the ocfs2_xattr_value_root and lock the allocators accordingly.

	/*

	 * Calculate we need for refcount tree change.

	 *

	 * We need to add/modify num_recs in refcount tree, so just calculate

	 * an approximate number we need for refcount tree change.

	 * Sometimes we need to split the tree, and after split,  half recs

	 * will be moved to the new block, and a new block can only provide

	 * half number of recs. So we multiple new blocks by 2.

	 * In the end, we have to add credits for modifying the already

	 * existed refcount block.

 count in the xattr tree change. */

		/*

		 * Record the start cpos so that we can use it to initialize

		 * our xattr tree we also set the xh_num_bucket for the new

		 * bucket.

		/*

		 * Re-access and dirty the bucket to calculate metaecc.

		 * Because we may extend the transaction in reflink_xattr_header

		 * which will let the already accessed block gone.

		/*

		 * For the 1st allocated cluster, we make it use the same cpos

		 * so that the xattr tree looks the same as the original one

		 * in the most case.

/*

 * Create the same xattr extent record in the new inode's xattr tree.

/*

 * Create reflinked xattr buckets.

 * We will add bucket one by one, and refcount all the xattrs in the bucket

 * if they are stored outside.

/*

 * Initialize security and acl for a already created inode.

 * Used for reflink a non-preserve-security file.

 *

 * It uses common api like ocfs2_xattr_set, so the caller

 * must not hold any lock expect i_mutex.

/*

 * 'security' attributes support

 check whether ocfs2 support feature xattr */

/*

 * 'trusted' attributes support

/*

 * 'user' attributes support

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * journal.c

 *

 * Defines functions of journalling api

 *

 * Copyright (C) 2003, 2004 Oracle.  All rights reserved.

/*

 * This replay_map is to track online/offline slots, so we could recover

 * offline slots during recovery and mount

 Replay is not needed, so ignore this map */

 Replay slots marked in rm_replay_slots */

 Replay was already queued */

 If we've already queued the replay, we don't have any more to do */

 If replay map is already set, we don't do it again */

 set rm_replay_slots for offline slot(s) */

/* we can't grab the goofy sem lock from inside wait_event, so we use

 * memory barriers to make sure that we'll see the null task before

	/* disable any new recovery threads and wait for any currently

	/* At this point, we know that no more recovery threads can be

	 * launched, so wait for any recovery completion work to

	/*

	 * Now that recovery is shut down, and the osb is about to be

	 * freed,  the osb_lock is not taken here.

 XXX: Should we bug if there are dirty entries? */

 Behaves like test-and-set.  Returns the previous value */

 XXX: Can this be exploited? Not from o2dlm... */

 XXX: be careful with the pointer math */

 Flush all pending commits and checkpoint the journal. */

 Nested transaction? Just return the handle... */

/*

 * 'nblocks' is what you want to add to the current transaction.

 *

 * This might call jbd2_journal_restart() which will commit dirty buffers

 * and then restart the transaction. Before calling

 * ocfs2_extend_trans(), any changed blocks should have been

 * dirtied. After calling it, all blocks which need to be changed must

 * go through another set of journal_access/journal_dirty calls.

 *

 * WARNING: This will not release any semaphores or disk locks taken

 * during the transaction, so make sure they were taken *before*

 * start_trans or we'll have ordering deadlocks.

 *

 * WARNING2: Note that we do *not* drop j_trans_barrier here. This is

 * good because transaction ids haven't yet been recorded on the

 * cluster locks associated with this handle.

/*

 * If we have fewer than thresh credits, extend by OCFS2_MAX_TRANS_DATA.

 * If that fails, restart the transaction & regain write access for the

 * buffer head which is used for metadata modifications.

 * Taken from Ext4: extend_or_restart_transaction()

	/*

	 * We aren't guaranteed to have the superblock here, so we

	 * must unconditionally compute the ecc data.

	 * __ocfs2_journal_access() will only set the triggers if

	 * metaecc is enabled.

/*

 * Quota blocks have their own trigger because the struct ocfs2_block_check

 * offset depends on the blocksize.

	/*

	 * We aren't guaranteed to have the superblock here, so we

	 * must unconditionally compute the ecc data.

	 * __ocfs2_journal_access() will only set the triggers if

	 * metaecc is enabled.

/*

 * Directory blocks also have their own trigger because the

 * struct ocfs2_block_check offset depends on the blocksize.

	/*

	 * We aren't guaranteed to have the superblock here, so we

	 * must unconditionally compute the ecc data.

	 * __ocfs2_journal_access() will only set the triggers if

	 * metaecc is enabled.

 we can safely remove this assertion after testing. */

		/*

		 * A previous transaction with a couple of buffer heads fail

		 * to checkpoint, so all the bhs are marked as BH_Write_EIO.

		 * For current transaction, the bh is just among those error

		 * bhs which previous transaction handle. We can't just clear

		 * its BH_Write_EIO and reuse directly, since other bhs are

		 * not written to disk yet and that will cause metadata

		 * inconsistency. So we should set fs read-only to avoid

		 * further damage.

	/* Set the current transaction information on the ci so

	 * that the locking code knows whether it can drop it's locks

	 * on this ci or not. We're protected from the commit

	 * thread updating the current transaction id until

	 * ocfs2_commit_trans() because ocfs2_start_trans() took

 the journal inode */

 initialize our journal structure */

 already have the inode for our journal */

	/* Skip recovery waits here - journal inode metadata never

	 * changes in a live cluster so it can be considered an

 call the kernels journal init function now */

	/* The journal bh on the osb always comes from ocfs2_journal_init()

	 * and was validated there inside ocfs2_inode_lock_full().  It's a

/*

 * If the journal has been kmalloc'd it needs to be freed after this

 * call.

 need to inc inode use count - jbd2_journal_destroy will iput. */

	/* Do a commit_cache here. It will flush our journal, *and*

	 * release any locks that are still held.

	 * set the SHUTDOWN flag and release the trans lock.

	/* The OCFS2_JOURNAL_IN_SHUTDOWN will signal to commit_cache to not

	 * drop the trans_lock (which we want to hold until we

 Wait for the commit thread */

 Shutdown the kernel journal system */

		/*

		 * Do not toggle if flush was unsuccessful otherwise

		 * will leave dirty metadata in a "clean" journal

 unlock our journal */

 Launch the commit thread */

/* 'full' flag tells us whether we clear out all blocks or if we just

/*

 * JBD Might read a cached version of another nodes journal file. We

 * don't want this as this file changes often and we get no

 * notification on those changes. The only way to be sure that we've

 * got the most up to date version of those blocks then is to force

 * read them off disk. Just searching through the buffer cache won't

 * work as there may be pages backing this file which are still marked

 * up to date. We know things can't change on this file underneath us

 * as we have the lock by now :)

 block not cached. */

			/* We are reading journal data which should not

			 * be put in the uptodate cache.

/* Does the second half of the recovery process. By this point, the

 * node is marked clean and can actually be considered recovered,

 * hence it's no longer in the recovery map, but there's still some

 * cleanup we can do which shouldn't happen within the recovery thread

 * as locking in that context becomes very difficult if we are to take

 * recovering nodes into account.

 *

 * NOTE: This function can and will sleep on recovery of other nodes

 * during cluster locking, just like any other ocfs2 process.

 Recovery info is already freed now */

/* NOTE: This function always eats your references to la_dinode and

 * tl_dinode, either manually on error, or by passing them to

		/* Though we wish to avoid it, we are in fact safe in

		 * skipping local alloc cleanup as fsck.ocfs2 is more

/* Called by the mount code to queue recovery the last part of

	/* No need to queue up our truncate_log as regular cleanup will catch

 queue to recover orphan slots for all offline slots */

 Whether the quota supported. */

 queue recovery for our own slot */

		/* It's always safe to remove entry zero, as we won't

		/* It is a bit subtle with quota recovery. We cannot do it

		 * immediately because we have to obtain cluster locks from

		 * quota files and we also don't want to just skip it because

		 * then quota usage would be out of sync until some node takes

		 * the slot. So we remember which nodes need quota recovery

 Refresh all journal recovery generations from disk */

	/* Now it is right time to recover quotas... We have to do this under

	 * superblock lock so that no one can start using the slot (and crash)

 queue recovery for offline slots */

 sync with ocfs2_recovery_thread_running */

/* Does the actual journal replay and marks the journal inode as

	/*

	 * As the fs recovery is asynchronous, there is a small chance that

	 * another node mounted (and recovered) the slot before the recovery

	 * thread could get the lock. To handle that, we dirty read the journal

	 * inode for that slot to get the recovery generation. If it is

	 * different than what we expected, the slot has been recovered.

	 * If not, it needs recovery.

 Continue with recovery as the journal has not yet been recovered */

 Refresh recovery generation for the slot */

 we need to run complete recovery for offline orphan slots */

 wipe the journal */

 This will mark the node clean */

 Increment recovery generation to indicate successful recovery */

 drop the lock on this nodes journal */

/*

 * Do the most important parts of node recovery:

 *  - Replay it's journal

 *  - Stamp a clean local allocator file

 *  - Stamp a clean truncate log

 *  - Mark the node clean

 *

 * If this function completes without error, a node in OCFS2 can be

 * said to have been safely recovered. As a result, failure during the

 * second part of a nodes recovery process (local alloc recovery) is

 * far less concerning.

	/* Should not ever be called to recover ourselves -- in that

 Stamp a clean local alloc file AFTER recovering the journal... */

	/* An error from begin_truncate_log_recovery is not

	 * serious enough to warrant halting the rest of

	/* Likewise, this would be a strange but ultimately not so

 This will kfree the memory pointed to by la_copy and tl_copy */

/* Test node liveness by trylocking his journal. If we get the lock,

 * we drop it here. Return 0 if we got the lock, -EAGAIN if node is

/* Call this underneath ocfs2_super_lock. It also assumes that the

	/* This is called with the super block cluster lock, so we

 Read journal inode to get the recovery generation */

		/* Ok, we have a slot occupied by another node which

		 * is not in the recovery map. We trylock his journal

			/* Since we're called from mount, we know that

			 * the recovery thread can't race us on

/*

 * Scan timer should get fired every ORPHAN_SCAN_SCHEDULE_TIMEOUT. Add some

 * randomness to the timeout to minimize multple nodes firing the timer at the

 * same time.

/*

 * ocfs2_queue_orphan_scan calls ocfs2_queue_recovery_completion for

 * every slot, queuing a recovery of the slot on the ocfs2_wq thread. This

 * is done to catch any orphans that are left over in orphan directories.

 *

 * It scans all slots, even ones that are in use. It does so to handle the

 * case described below:

 *

 *   Node 1 has an inode it was using. The dentry went away due to memory

 *   pressure.  Node 1 closes the inode, but it's on the free list. The node

 *   has the open lock.

 *   Node 2 unlinks the inode. It grabs the dentry lock to notify others,

 *   but node 1 has no dentry and doesn't get the message. It trylocks the

 *   open lock, sees that another node has a PR, and does nothing.

 *   Later node 2 runs its orphan dir. It igets the inode, trylocks the

 *   open lock, sees the PR still, and does nothing.

 *   Basically, we have to trigger an orphan iput on node 1. The only way

 *   for this to happen is if node 1 runs node 2's orphan dir.

 *

 * ocfs2_queue_orphan_scan gets called every ORPHAN_SCAN_SCHEDULE_TIMEOUT

 * seconds.  It gets an EX lock on os_lockres and checks sequence number

 * stored in LVB. If the sequence number has changed, it means some other

 * node has done the scan.  This node skips the scan and tracks the

 * sequence number.  If the sequence number didn't change, it means a scan

 * hasn't happened.  The node queues a scan and increments the

 * sequence number in the LVB.

 Do no queue the tasks if the volume is being umounted */

	/*

	 * We queued a recovery on orphan slots, increment the sequence

	 * number and update LVB so other node will skip the scan for a while

 Worker task that gets fired every ORPHAN_SCAN_SCHEDULE_TIMEOUT millsec */

 do not include dio entry in case of orphan scan */

 Skip bad inodes so that recovery can continue */

	/* Skip inodes which are already added to recover list, since dio may

	/* No locking is required for the next_orphan queue as there

	/* Mark ourselves such that new processes in delete_inode()

		/* If any processes are already in the middle of an

		 * orphan wipe on this dir, then we need to wait for

/*

 * Orphan recovery. Each mounted node has it's own orphan dir which we

 * must run during recovery. Our strategy here is to build a list of

 * the inodes in the orphan dir and iget/iput them. The VFS does

 * (most) of the rest of the work.

 *

 * Orphan recovery can happen at any time, not just mount so we have a

 * couple of extra considerations.

 *

 * - We grab as many inodes as we can under the orphan dir lock -

 *   doing iget() outside the orphan dir risks getting a reference on

 *   an invalid inode.

 * - We must be sure not to deadlock with other processes on the

 *   system wanting to run delete_inode(). This can happen when they go

 *   to lock the orphan dir and the orphan recovery process attempts to

 *   iget() inside the orphan dir lock. This can be avoided by

 *   advertising our state to ocfs2_delete_inode().

	/* Error here should be noted, but we want to continue with as

			/*

			 * We need to take and drop the inode lock to

			 * force read inode from disk.

 clear dio flag in ocfs2_inode_info */

			/* Set the proper information to get us going into

	/* This check is good because ocfs2 will wait on our recovery

	 * thread before changing it to something other than MOUNTED

	/* If there's an error on mount, then we may never get to the

	 * MOUNTED flag, but this is set right before

	/* we can trust j_num_trans here because _should_stop() is only set in

	 * shutdown and nobody other than ourselves should be able to start

	 * transactions.  committing on shutdown might take a few iterations

 Warn about this once per minute */

			/*

			 * After ocfs2_commit_cache() fails, j_num_trans has a

			 * non-zero value.  Sleep here to avoid a busy-wait

			 * loop.

/* Reads all the journal inodes without taking any cluster locks. Used

 * for hard readonly access to determine whether any journal requires

 * recovery. Also used to refresh the recovery generation numbers after

 * a journal has been recovered by another node.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * inode.c

 *

 * vfs' aops, fops, dops and iops

 *

 * Copyright (C) 2002, 2004 Oracle.  All rights reserved.

 Propagate flags from i_flags to OCFS2_I(inode)->ip_attr */

	/* Ok. By now we've either got the offsets passed to us by the

	 * caller, or we just pulled them off the bh. Lets do some

	/* inode was *not* in the inode cache. 2.6.x requires

	 * us to do our own read_inode call and unlock it

	/*

	 * Set transaction id's of transactions that have to be committed

	 * to finish f[data]sync. We set them to currently running transaction

	 * as we cannot be sure that the inode or some of its metadata isn't

	 * part of the transaction - the inode could have been reclaimed and

	 * now it is reread from disk.

/*

 * here's how inodes get read from disk:

 * iget5_locked -> find_actor -> OCFS2_FIND_ACTOR

 * found? : return the in-memory inode

 * not found? : get_new_inode -> OCFS2_INIT_LOCKED_INODE

/*

 * initialize the new inode, but don't do anything that would cause

 * us to sleep.

 * return 0 on success, 1 on failure

	/*

	 * These have all been checked by ocfs2_read_inode_block() or set

	 * by ocfs2_mknod_locked(), so a failure is a code bug.

	BUG_ON(!OCFS2_IS_VALID_DINODE(fe));  /* This means that read_inode

						cannot create a superblock

						inode today.  change if

 Fast symlinks will have i_size but no allocated clusters. */

		/* we can't actually hit this as read_inode can't

		/*

		 * If we ever want to create system files from kernel,

		 * the generation argument to

		 * ocfs2_inode_lock_res_init() will have to change.

	/*

	 * To improve performance of cold-cache inode stats, we take

	 * the cluster lock here if possible.

	 *

	 * Generally, OCFS2 never trusts the contents of an inode

	 * unless it's holding a cluster lock, so taking it here isn't

	 * a correctness issue as much as it is a performance

	 * improvement.

	 *

	 * There are three times when taking the lock is not a good idea:

	 *

	 * 1) During startup, before we have initialized the DLM.

	 *

	 * 2) If we are reading certain system files which never get

	 *    cluster locks (local alloc, truncate log).

	 *

	 * 3) If the process doing the iget() is responsible for

	 *    orphan dir recovery. We're holding the orphan dir lock and

	 *    can get into a deadlock with another process on another

	 *    node in ->delete_inode().

	 *

	 * #1 and #2 can be simply solved by never taking the lock

	 * here for system files (which are the only type we read

	 * during mount). It's a heavier approach, but our main

	 * concern is user-accessible files anyway.

	 *

	 * #3 works itself out because we'll eventually take the

	 * cluster lock before trusting anything anyway.

	/*

	 * To maintain backwards compatibility with older versions of

	 * ocfs2-tools, we still store the generation value for system

	 * files. The only ones that actually matter to userspace are

	 * the journals, but it's easier and inexpensive to just flag

	 * all system files similarly.

		/*

		 * If buffer is in jbd, then its checksum may not have been

		 * computed as yet.

	/*

	 * This is a code bug. Right now the caller needs to

	 * understand whether it is asking for a system file inode or

	 * not so the proper lock names can be built.

	/*

	 * This check will also skip truncate of inodes with inline

	 * data and fast symlinks.

 set the inodes dtime */

/*

 * Serialize with orphan dir recovery. If the process doing

 * recovery on this orphan dir does an iget() with the dir

 * i_mutex held, we'll deadlock here. Instead we detect this

 * and exit early - recovery will wipe this inode for us.

	/* This signals to the orphan recovery process that it should

		/* Lock the orphan dir. The lock will be held for the entire

		 * delete_inode operation. We do this now to avoid races with

	/* we do this while holding the orphan dir lock because we

	 * don't want recovery being run from another node to try an

	 * inode delete underneath us -- this will result in two nodes

 Remove any dir index tree */

Free extended attribute resources associated with this inode.*/

/* There is a series of simple checks that should be done before a

	/* We shouldn't be getting here for the root directory

	/*

	 * If we're coming from downconvert_thread we can't go into our own

	 * voting [hello, deadlock city!] so we cannot delete the inode. But

	 * since we dropped last inode ref when downconverting dentry lock,

	 * we cannot have the file open and thus the node doing unlink will

	 * take care of deleting the inode.

	/* OCFS2 *never* deletes system files. This should technically

	 * never get here as system file inodes should always have a

/* Query the cluster to determine whether we should wipe an inode from

 * disk or not.

 *

	/* While we were waiting for the cluster lock in

	 * ocfs2_delete_inode, another node might have asked to delete

	/* Now that we have an up to date inode, we can double check

 Do some basic inode verification... */

		/*

		 * Inodes in the orphan dir must have ORPHANED_FL.  The only

		 * inodes that come back out of the orphan dir are reflink

		 * targets. A reflink target may be moved out of the orphan

		 * dir between the time we scan the directory and the time we

		 * process it. This would lead to HAS_REFCOUNT_FL being set but

		 * ORPHANED_FL not.

 for lack of a better error? */

 has someone already deleted us?! baaad... */

	/*

	 * This is how ocfs2 determines whether an inode is still live

	 * within the cluster. Every node takes a shared read lock on

	 * the inode open lock in ocfs2_read_locked_inode(). When we

	 * get to ->delete_inode(), each node tries to convert it's

	 * lock to an exclusive. Trylocks are serialized by the inode

	 * meta data lock. If the upconvert succeeds, we know the inode

	 * is no longer live and can be deleted.

	 *

	 * Though we call this with the meta data lock held, the

	 * trylock keeps us from ABBA deadlock.

/* Support function for ocfs2_delete_inode. Will help us keep the

 * inode data in a consistent state for clear_inode. Always truncates

	/* When we fail in read_inode() we mark inode as bad. The second test

	 * catches the case when inode allocation fails before allocating

		/* It's probably not necessary to truncate_inode_pages

		 * here but we do it for safety anyway (it will most

	/* We want to block signals in delete_inode as the lock and

	 * messaging paths may return us -ERESTARTSYS. Which would

	 * cause us to exit early, resulting in inodes being orphaned

	/*

	 * Synchronize us against ocfs2_get_dentry. We take this in

	 * shared mode so that all nodes can still concurrently

	 * process deletes.

	/* Lock down the inode. This gives us an up to date view of

	 * it's metadata (for verification), and allows us to

	 * serialize delete_inode on multiple nodes.

	 *

	 * Even though we might be doing a truncate, we don't take the

	 * allocation lock here as it won't be needed - nobody will

	 * have the file open.

	/* Skip inode deletion and wait for dio orphan entry recovered

	/* Query the cluster. This will be the final decision made

		/* Error and remote inode busy both mean we won't be

		 * removing the inode, so they take almost the same

		/* Someone in the cluster has disallowed a wipe of

		 * this inode, or it was never completely

	/*

	 * Mark the inode as successfully deleted.

	 *

	 * This is important for ocfs2_clear_inode() as it will check

	 * this flag and skip any checkpointing work

	 *

	 * ocfs2_stuff_meta_lvb() also uses this flag to invalidate

	 * the LVB for other nodes.

	/* To preven remote deletes we hold open lock before, now it

	/* Do these before all the other work so that we don't bounce

	/* We very well may get a clear_inode before all an inodes

	 * metadata has hit disk. Of course, we can't drop any cluster

	 * locks until the journal has finished with it. The only

	 * exception here are successfully wiped inodes - their

	 * metadata can now be considered to be part of the system

	/*

	 * down_trylock() returns 0, down_write_trylock() returns 1

	 * kernel 1, world 0

 Clear all other flags. */

	/*

	 * ip_jinode is used to track txns against this inode. We ensure that

	 * the journal is flushed before journal shutdown. Thus it is safe to

	 * have inodes get cleaned up after journal shutdown.

/* Called under inode_lock, with no more references on the

 * struct inode, so it's safe here to check the flags field

/*

 * This is called from our getattr.

	/* Let ocfs2_inode_lock do the work of updating our struct

/*

 * Updates a disk inode from a

 * struct inode.

 * Only takes ip_lock.

/*

 *

 * Updates a struct inode from a disk inode.

 * does no i/o, only takes ip_lock.

	/*

	 * If the ecc fails, we return the error but otherwise

	 * leave the filesystem running.  We know any error is

	 * local to this block.

	/*

	 * Errors after here are fatal.

	/*

	 * Call ocfs2_validate_meta_ecc() first since it has ecc repair

	 * function, but we should not return error immediately when ecc

	 * validation fails, because the reason is quite likely the invalid

	 * inode number inputed.

 Cannot fix invalid inode block */

		/* Cannot just add VALID_FL flag back as a fix,

		 * need more things to check here.

 Check inode block */

 Repair inode block */

 If ocfs2_read_blocks() got us a new bh, pass it up. */

 If ocfs2_read_blocks() got us a new bh, pass it up. */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * slot_map.c

 *

 * Copyright (C) 2002, 2004 Oracle.  All rights reserved.

 This version is for the extended slot map */

/*

 * Post the slot information on disk into our slot_info struct.

 * Must be protected by osb_lock.

	/*

	 * The slot data will have been refreshed when ocfs2_super_lock

	 * was taken.

	/*

	 * We pass -1 as blocknr because we expect all of si->si_bh to

	 * be !NULL.  Thus, ocfs2_read_blocks() will ignore blocknr.  If

	 * this is not true, the read of -1 (UINT64_MAX) will fail.

/* post the our slot info stuff into it's destination bh and write it

/*

 * Calculate how many bytes are needed by the slot map.  Returns

 * an error if the slot map file is too small.

/* try to find global node in the slot info. Returns -ENOENT

 The size checks above should ensure this */

 Acquire a fresh bh */

 use slot 0 directly in local mode */

		/* search for ourselves first and take the slot if it already

		 * exists. Perhaps we need to mark this in a variable for our

		 * own journal recovery? Possibly not, though we certainly

			/* if no slot yet, then just take 1st available

		/*

		 * if write block failed, invalidate slot to avoid overwrite

		 * slot during dismount in case another node rightly has mounted

 SPDX-License-Identifier: GPL-2.0-only

/*

 * stack_o2cb.c

 *

 * Code which interfaces ocfs2 with the o2cb stack.

 *

 * Copyright (C) 2007 Oracle.  All rights reserved.

 Needed for AOP_TRUNCATED_PAGE in mlog_errno() */

 These should be identical */

/*

 * Map an o2dlm status to standard errno values.

 *

 * o2dlm only uses a handful of these, and returns even fewer to the

 * caller. Still, we try to assign sane values to each error.

 *

 * The following value pairs have special meanings to dlmglue, thus

 * the right hand side needs to stay unique - never duplicate the

 * mapping elsewhere in the table!

 *

 * DLM_NORMAL:		0

 * DLM_NOTQUEUED:	-EAGAIN

 * DLM_CANCELGRANT:	-EBUSY

 * DLM_CANCEL:		-DLM_ECANCEL

 Keep in sync with dlmapi.h */

 Success */

 It is what it is */

 Cancel after grant */

 Trylock failed */

 Successful cancel */

	/*

	 * In o2dlm, you can get both the lock_ast() for the lock being

	 * granted and the unlock_ast() for the CANCEL failing.  A

	 * successful cancel sends DLM_NORMAL here.  If the

	 * lock grant happened before the cancel arrived, you get

	 * DLM_CANCELGRANT.

	 *

	 * There's no need for the double-ast.  If we see DLM_CANCELGRANT,

	 * we just ignore it.  We expect the lock_ast() to handle the

	 * granted lock.

/*

 * o2dlm aways has a "valid" LVB. If the dlm loses track of the LVB

 * contents, it will zero out the LVB.  Thus the caller can always trust

 * the contents.

/*

 * Check if this node is heartbeating and is connected to all other

 * heartbeating nodes.

	/*

	 * o2dlm expects o2net sockets to be created. If not, then

	 * dlm_join_domain() fails with a stack of errors which are both cryptic

	 * and incomplete. The idea here is to detect upfront whether we have

	 * managed to connect to all nodes or not. If not, then list the nodes

	 * to allow the user to check the configuration (incorrect IP, firewall,

	 * etc.) Yes, this is racy. But its not the end of the world.

 Force set the current node to allow easy compare */

/*

 * Called from the dlm when it's about to evict a node. This is how the

 * classic stack signals node death.

 Ensure cluster stack is up and all nodes are connected */

 This just fills the structure in.  It is safe to pass conn. */

	/* used by the dlm code to make message headers unique, each

 SPDX-License-Identifier: GPL-2.0

/*

 *  Implementation of operations over local quota file

 Number of local quota structures per block */

 Number of blocks with entries in one chunk */

 Number of entries in a chunk bitmap */

 Offset of the chunk in quota file */

 1 block for local quota file info, 1 block per chunk for chunk info */

 Offset of the dquot structure in the quota file */

 Compute offset in the chunk of a structure with the given offset */

 Write bufferhead into the fs */

/*

 * Read quota block from a given logical offset.

 *

 * This function acquires ip_alloc_sem and thus it must not be called with a

 * transaction started.

 If ocfs2_read_virt_blocks() got us a new bh, pass it up. */

 Check whether we understand format of quota files */

 First check whether we understand local quota file */

 Next check whether we understand global quota file */

 Since the header is read only, we don't care about locking */

 Release given list of quota file chunks */

 Load quota bitmaps into memory */

 Load entries in our quota file we have to recover*/

 Load information we need for quota recovery into memory */

 First init... */

		/* At this point, journal of the slot is already replayed so

 Now read local header */

/* Sync changes in local quota file into global quota file and

 * reinitialize local quota file.

 * The function expects local quota file to be already locked and

			/* Add usage from quota entry into quota changes

			 * of our node. Auxiliary variables are important

			/* We want to drop reference held by the crashed

			 * node. Since we have our own reference we know

 Release local quota file entry */

 Recover local quota files for given node different from us */

		/* Someone else is holding the lock? Then he must be

 Now read local header */

 Is recovery still needed? */

		/* We don't want to mark file as clean when it is actually

		/* Mark quota file as clean if we are recovering quota file of

 Read information header from quota file */

 Now read local header */

 We crashed when using local quota file? */

 Now mark quota file as used */

 Write local info to quota file */

 Release info from memory */

 Not all entries free? Bug! */

	/*

	 * s_umount held in exclusive mode protects us against racing with

	 * recovery thread...

 Mark local file as clean */

 Write dquot to local quota file */

 Find free entry in local quota file */

 We failed? */

 Add new chunk to the local quota file */

 We are protected by dqio_sem so no locking needed */

 Local quota info and two new blocks we initialize */

 Initialize chunk header */

 Initialize new block with structures */

 Update local quotafile info */

 Find free entry in local quota file */

 Is the last chunk full? */

 We are protected by dqio_sem so no locking needed */

 Get buffer from the just added block */

 Local quota info, chunk header and the new block we initialize */

 Zero created block */

 Update chunk header */

 Update file header */

 Create dquot in the local file for given id */

 Initialize dquot structure on disk */

 Mark structure as allocated */

/*

 * Release dquot structure from local quota file. ocfs2_release_dquot() has

 * already started a transaction and written all changes to global quota file

 Mark structure as freed */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * dir.c

 *

 * Creates, reads, walks and deletes directory-nodes

 *

 * Copyright (C) 2002, 2004 Oracle.  All rights reserved.

 *

 *  Portions of this code from linux/fs/ext3/dir.c

 *

 *  Copyright (C) 1992, 1993, 1994, 1995

 *  Remy Card (card@masi.ibp.fr)

 *  Laboratoire MASI - Institut Blaise pascal

 *  Universite Pierre et Marie Curie (Paris VI)

 *

 *   from

 *

 *   linux/fs/minix/dir.c

 *

 *   Copyright (C) 1991, 1992 Linus Torvalds

/*

 * These are distinct checks because future versions of the file system will

 * want to have a trailing dirent structure independent of indexing.

/*

 * "new' here refers to the point at which we're creating a new

 * directory via "mkdir()", but also when we're expanding an inline

 * directory. In either case, we don't yet have the indexing bit set

 * on the directory, so the standard checks will fail in when metaecc

 * is turned off. Only directory-initialization type functions should

 * use this then. Everything else wants ocfs2_supports_dir_trailer()

/* XXX ocfs2_block_dqtrailer() is similar but not quite - can we make

/*

 * XXX: This is executed once on every dirent. We should consider optimizing

 * it.

/*

 * Link an unindexed block with a dir trailer structure into the index free

 * list. This function will modify dirdata_bh, but assumes you've already

 * passed it to the journal.

/*

 * Hashing code adapted from ext3

	/*

	 * XXX: Is this really necessary, if the index is never looked

	 * at by readdir? Is a hash value of '0' a bad idea?

	/*

	 * This makes it very easy to debug indexing problems. We

	 * should never allow this to be selected without hand editing

	 * this file though.

/*

 * bh passed here can be an inode block or a dir data block, depending

 * on the inode inline data flag.

/*

 * Returns 0 if not found, -1 on failure, and 1 on success

 this code is executed quadratically often */

 do minimal checking `by hand' */

 found a match - just to be sure, do a full check */

 prevent looping on a bad block */

	/*

	 * We don't validate dirents here, that's handled

	 * in-place when the code walks them.

	/*

	 * If the ecc fails, we return the error but otherwise

	 * leave the filesystem running.  We know any error is

	 * local to this block.

	 *

	 * Note that we are safe to call this even if the directory

	 * doesn't have a trailer.  Filesystems without metaecc will do

	 * nothing, and filesystems with it will have one.

/*

 * Validate a directory trailer.

 *

 * We check the trailer here rather than in ocfs2_validate_dir_block()

 * because that function doesn't have the inode to test.

/*

 * This function forces all errors to -EIO for consistency with its

 * predecessor, ocfs2_bread().  We haven't audited what returning the

 * real error codes would do to callers.  We log the real codes with

 * mlog_errno() before we squash them.

 If ocfs2_read_virt_blocks() got us a new bh, pass it up. */

/*

 * Read the block at 'phys' which belongs to this directory

 * inode. This function does no virtual->physical block translation -

 * what's passed in is assumed to be a valid directory block.

 If ocfs2_read_block() got us a new bh, pass it up. */

 If ocfs2_read_block() got us a new bh, pass it up. */

/*

 * Read a series of dx_leaf blocks. This expects all buffer_head

 * pointers to be NULL on function entry.

	int ra_max = 0;		/* Number of bh's in the readahead

	int ra_ptr = 0;		/* Current index into readahead

		/*

		 * We deal with the read-ahead logic here.

 Refill the readahead buffer */

				/*

				 * Terminate if we reach the end of the

				 * directory and must wrap, or if our

				 * search has finished at this block.

			/* read error, skip block & hope for the best.

	/*

	 * If the directory has grown while we were searching, then

	 * search the last part of the directory before giving up.

 Clean up the read-ahead blocks */

/*

 * Returns the block index, from the start of the cluster which this

 * hash belongs too.

 We want the last cluster */

	/*

	 * We now have the cluster which should hold our entry. To

	 * find the exact block from the start of the cluster to

	 * search, we take the lower bits of the hash.

	/*

	 * Empty leaf is legal, so no need to check for that.

		/*

		 * Search unindexed leaf block now. We're not

		 * guaranteed to find anything.

		/*

		 * XXX: We should check the unindexed block here,

		 * before using it.

 This means we found a bad directory entry. */

/*

 * Try to find an entry of the provided name within 'dir'.

 *

 * If nothing was found, -ENOENT is returned. Otherwise, zero is

 * returned and the struct 'res' will contain information useful to

 * other directory manipulation functions.

 *

 * Caller can NOT assume anything about the contents of the

 * buffer_heads - they are passed back only so that it can be passed

 * into any one of the manipulation functions (add entry, delete

 * entry, etc). As an example, bh in the extent directory case is a

 * data block, in the inline-data case it actually points to an inode,

 * in the indexed directory case, multiple buffers are involved.

	/*

	 * The unindexed dir code only uses part of the lookup

	 * structure, so there's no reason to push it down further

	 * than this.

/*

 * Update inode number and type of a previously found directory entry.

	/*

	 * The same code works fine for both inline-data and extent

	 * based directories, so no need to split this up.  The only

	 * difference is the journal_access function.

/*

 * __ocfs2_delete_entry deletes a directory entry by merging it with the

 * previous entry

	/*

	 * This function gets a bit messy because we might have to

	 * modify the root block, regardless of whether the indexed

	 * entries are stored inline.

	/*

	 * *Only* set 'entry_list' here, based on where we're looking

	 * for the indexed entries. Later, we might still want to

	 * journal both blocks, based on free list state.

	/* Neither of these are a disk corruption - that should have

	/*

	 * We know that removal of this dirent will leave enough room

	 * for a new one, so add this block to the free list if it

	 * isn't already there.

	/*

	 * Add the block holding our index into the journal before

	 * removing the unindexed entry. If we get an error return

	 * from __ocfs2_delete_entry(), then it hasn't removed the

	 * entry yet. Likewise, successful return means we *must*

	 * remove the indexed entry.

	 *

	 * We're also careful to journal the root tree block here as

	 * the entry count needs to be updated. Also, we might be

	 * adding to the start of the free list.

 leaf_bh was journal_accessed for us in __ocfs2_delete_entry */

/*

 * Delete a directory entry. Hide the details of directory

 * implementation from the caller.

/*

 * Check whether 'de' has enough room to hold an entry of

 * 'new_rec_len' bytes.

 Check whether this is an empty record with enough space */

	/*

	 * Record might have free space at the end which we can

	 * use.

/*

 * This expects that a journal write has been reserved on

 * lookup->dl_prev_leaf_bh or lookup->dl_dx_root_bh

 Walk dl_leaf_bh to figure out what the new free rec_len is. */

		/*

		 * There's still room in this block, so no need to remove it

		 * from the free list. In this case, we just want to update

		 * the rec len accounting.

/* we don't always have a dentry for what we want to add, so people

 * like orphan dir can call this instead.

 *

 * The lookup context must have been filled from

 * ocfs2_prepare_dir_for_insert.

		/*

		 * An indexed dir may require that we update the free space

		 * list. Reserve a write to the previous node in the list so

		 * that we don't fail later.

		 *

		 * XXX: This can be either a dx_root_block, or an unindexed

		 * directory tree leaf block.

		/* These checks should've already been passed by the

		 * prepare function, but I guess we can leave them

		/* We're guaranteed that we should have space, so we

 By now the buffer is marked for journaling */

	/* when you think about it, the assert above should prevent us

		/* If the dir block has changed since the last call to

		 * readdir(2), then we might be pointing to an invalid

		 * dirent right now.  Scan from the start of the block

				/* It's too expensive to do a full

				 * dirent test each time round this

				 * loop, but we do have to test at

				 * least that it is non-zero.  A

				 * failure will be detected in the

 On error, skip the f_pos to the end. */

/*

 * NOTE: This function can be called against unindexed directories,

 * and indexed ones.

 Skip the corrupt dirblock and keep trying */

		/* The idea here is to begin with 8k read-ahead and to stay

		 * 4k ahead of our current position.

		 *

		 * TODO: Use the pagecache for this. We just need to

		/* If the dir block has changed since the last call to

		 * readdir(2), then we might be pointing to an invalid

		 * dirent right now.  Scan from the start of the block

				/* It's too expensive to do a full

				 * dirent test each time round this

				 * loop, but we do have to test at

				 * least that it is non-zero.  A

				 * failure will be detected in the

				/* On error, skip the f_pos to the

/*

 * This is intended to be called from inside other kernel functions,

 * so we fake some arguments.

/*

 * ocfs2_readdir()

 *

		/* We release EX lock which used to update atime

		 * and get PR lock again to reduce contention

 we haven't got any yet, so propagate the error. */

/*

 * NOTE: this should always be called with parent dir i_mutex taken.

/*

 * Convenience function for callers which just want the block number

 * mapped to a name and don't require the full dirent info, etc.

/* Check for a name within a directory.

 *

 * Return 0 if the name does not exist

 * Return -EEXIST if the directory contains the name

 *

 * Callers should have i_mutex + a cluster lock on dir

	/*

	 * Check the positions of "." and ".." records to be sure

	 * they're in the correct place.

	 *

	 * Indexed directories don't need to proceed past the first

	 * two entries, so we end the scan after seeing '..'. Despite

	 * that, we allow the scan to proceed In the event that we

	 * have a corrupted indexed directory (no dot or dot dot

	 * entries). This allows us to double check for existing

	 * entries which might not have been found in the index.

/*

 * routine to check that the specified directory is empty (for rmdir)

 *

 * Returns 1 if dir is empty, zero otherwise.

 *

 * XXX: This is a performance problem for unindexed directories.

		/*

		 * We still run ocfs2_dir_foreach to get the checks

		 * for "." and "..".

		/*

		 * XXX: Is it really safe to allow an unlink to continue?

/*

 * Fills "." and ".." dirents in a new directory block. Returns dirent for

 * "..", which might be used during creation of a directory with a trailing

 * header. It is otherwise safe to ignore the return code.

/*

 * This works together with code in ocfs2_mknod_locked() which sets

 * the inline-data flag and initializes the inline-data section.

		/*

		 * Figure out the size of the hole left over after

		 * insertion of '.' and '..'. The trailer wants this

		 * information.

/*

 * Allocates and formats a new cluster for use in an indexed dir

 * leaf. This version will not do the extent insert, so that it can be

 * used by operations which need careful ordering.

	/*

	 * XXX: For create, this should claim cluster for the index

	 * *before* the unindexed insert so that we have a better

	 * chance of contiguousness as the directory grows in number

	 * of entries.

	/*

	 * Format the new cluster first. That way, we're inserting

	 * valid data.

	/*

	 * Our strategy is to create the directory as though it were

	 * unindexed, then add the index block. This works with very

	 * little complication since the state of a new directory is a

	 * very well known quantity.

	 *

	 * Essentially, we have two dirents ("." and ".."), in the 1st

	 * block which need indexing. These are easily inserted into

	 * the index block.

 Buffer has been journaled for us by ocfs2_dx_dir_attach_index */

/*

 * XXX: This expects dx_root_bh to already be part of the transaction.

/*

 * Count the number of inline directory entries in di_bh and compare

 * them against the number of entries we can hold in an inline dx root

 * block.

 We are careful to leave room for one extra record. */

/*

 * Expand rec_len of the rightmost dirent in a directory block so that it

 * contains the end of our valid space for dirents. We do this during

 * expansion from an inline directory to one with extents. The first dir block

 * in that case is taken from the inline data portion of the inode block.

 *

 * This will also return the largest amount of contiguous space for a dirent

 * in the block. That value is *not* necessarily the last dirent, even after

 * expansion. The directory indexing code wants this value for free space

 * accounting. We do this here since we're already walking the entire dir

 * block.

 *

 * We add the dir trailer if this filesystem wants it.

	/* We need to double check this after modification of the final

/*

 * We allocate enough clusters to fulfill "blocks_wanted", but set

 * i_size to exactly one block. Ocfs2_extend_dir() will handle the

 * rest automatically for us.

 *

 * *first_block_bh is a pointer to the 1st data block allocated to the

 *  directory.

 Add one more cluster for an index leaf */

 This gets us the dx_root */

	/*

	 * We should never need more than 2 clusters for the unindexed

	 * tree - maximum dirent size is far less than one block. In

	 * fact, the only time we'd need more than one cluster is if

	 * blocksize == clustersize and the dirent won't fit in the

	 * extra space that the expansion to a single block gives. As

	 * of today, that only happens on 4k/4k file systems.

	/*

	 * Prepare for worst case allocation scenario of two separate

	 * extents in the unindexed tree.

		/*

		 * Allocate our index cluster first, to maximize the

		 * possibility that unindexed leaves grow

		 * contiguously.

	/*

	 * Try to claim as many clusters as the bitmap can give though

	 * if we only get one now, that's enough to continue. The rest

	 * will be claimed after the conversion to extents.

	/*

	 * Operations are carefully ordered so that we set up the new

	 * data block first. The conversion from inline data to

	 * extents follows.

		/*

		 * Prepare the dir trailer up front. It will otherwise look

		 * like a valid dirent. Even if inserting the index fails

		 * (unlikely), then all we'll have done is given first dir

		 * block a small amount of fragmentation.

		/*

		 * Dx dirs with an external cluster need to do this up

		 * front. Inline dx root's get handled later, after

		 * we've allocated our root block. We get passed back

		 * a total number of items so that dr_num_entries can

		 * be correctly set once the dx_root has been

		 * allocated.

	/*

	 * Set extent, i_size, etc on the directory. After this, the

	 * inode should contain the same exact dirents as before and

	 * be fully accessible from system calls.

	 *

	 * We let the later dirent insert modify c/mtime - to the user

	 * the data hasn't changed.

	/*

	 * This should never fail as our extent list is empty and all

	 * related blocks have been journaled already.

	/*

	 * Set i_blocks after the extent insert for the most up to

	 * date ip_clusters value.

	/*

	 * We asked for two clusters, but only got one in the 1st

	 * pass. Claim the 2nd cluster as a separate extent.

			/*

			 * We need to return the correct block within the

			 * cluster which should hold our entry.

 returns a bh of the 1st new block in the allocation. */

/*

 * Assumes you already have a cluster lock on the directory.

 *

 * 'blocks_wanted' is only used if we have an inline directory which

 * is to be turned into an extent based one. The size of the dirent to

 * insert might be larger than the space gained by growing to just one

 * block, so we may have to grow the inode by two blocks in that case.

 *

 * If the directory is already indexed, dx_root_bh must be provided.

		/*

		 * This would be a code error as an inline directory should

		 * never have an index root.

		/* Expansion from inline to an indexed directory will

			/*

			 * If the new dirent will fit inside the space

			 * created by pushing out to one block, then

			 * we can complete the operation

			 * here. Otherwise we have to expand i_size

			 * and format the 2nd block below.

		/*

		 * Get rid of 'new_bh' - we want to format the 2nd

		 * data block and return that instead.

 dir->i_size is always block aligned. */

		credits++; /* For attaching the new dirent block to the

	/*

	 * This calculates how many free bytes we'd have in block zero, should

	 * this function force expansion to an extent tree.

		/*

		 * No need to check for a trailing dirent record here as

		 * they're not used for inline dirs.

			/* Ok, we found a spot. Return this bh and let

	/*

	 * We're going to require expansion of the directory - figure

	 * out how many blocks we'll need so that a place for the

	 * dirent can be found.

				/*

				 * Caller will have to expand this

				 * directory.

 move to next block */

			/* Ok, we found a spot. Return this bh and let

	/*

	 * It is not strictly necessary to sort by minor

/*

 * Find the optimal value to split this leaf on. This expects the leaf

 * entries to be in sorted order.

 *

 * leaf_cpos is the cpos of the leaf we're splitting. insert_hash is

 * the hash we want to insert.

 *

 * This function is only concerned with the major hash - that which

 * determines which cluster an item belongs to.

	/*

	 * There's a couple rare, but nasty corner cases we have to

	 * check for here. All of them involve a leaf where all value

	 * have the same hash, which is what we look for first.

	 *

	 * Most of the time, all of the above is false, and we simply

	 * pick the median value for a split.

			/*

			 * No matter where we would choose to split,

			 * the new entry would want to occupy the same

			 * block as these. Since there's no space left

			 * in their existing block, we know there

			 * won't be space after the split.

			/*

			 * Because val is the same as leaf_cpos (which

			 * is the smallest value this leaf can have),

			 * yet is not equal to insert_hash, then we

			 * know that insert_hash *must* be larger than

			 * val (and leaf_cpos). At least cpos+1 in value.

			 *

			 * We also know then, that there cannot be an

			 * adjacent extent (otherwise we'd be looking

			 * at it). Choosing this value gives us a

			 * chance to get some contiguousness.

			/*

			 * val can not be the same as insert hash, and

			 * also must be larger than leaf_cpos. Also,

			 * we know that there can't be a leaf between

			 * cpos and val, otherwise the entries with

			 * hash 'val' would be there.

	/*

	 * Since the records are sorted and the checks above

	 * guaranteed that not all records in this block are the same,

	 * we simple travel forward, from the median, and pick the 1st

	 * record whose value is larger than leaf_cpos.

 Should be impossible */

/*

 * Transfer all entries in orig_dx_leaves whose major hash is equal to or

 * larger than split_hash into new_dx_leaves. We use a temporary

 * buffer (tmp_dx_leaf) to make the changes to the original leaf blocks.

 *

 * Since the block offset inside a leaf (cluster) is a constant mask

 * of minor_hash, we can optimize - an item at block offset X within

 * the original cluster, will be at offset X within the new cluster.

/*

 * Find the median value in dx_leaf_bh and allocate a new leaf to move

 * half our entries into.

	/*

	 * XXX: This is a rather large limit. We should use a more

	 * realistic value.

	/*

	 * This block is changing anyway, so we can sort it in place.

	/*

	 * We have to carefully order operations here. There are items

	 * which want to be in the new cluster before insert, but in

	 * order to put those items in the new cluster, we alter the

	 * old cluster. A failure to insert gets nasty.

	 *

	 * So, start by reserving writes to the old

	 * cluster. ocfs2_dx_dir_new_cluster will reserve writes on

	 * the new cluster for us, before inserting it. The insert

	 * won't happen if there's an error before that. Once the

	 * insert is done then, we can transfer from one leaf into the

	 * other without fear of hitting any error.

	/*

	 * The leaf transfer wants some scratch space so that we don't

	 * wind up doing a bunch of expensive memmove().

			/*

			 * Rebalancing should have provided us with

			 * space in an appropriate leaf.

			 *

			 * XXX: Is this an abnormal condition then?

			 * Should we print a message here?

		/*

		 * Restart the lookup. The rebalance might have

		 * changed which block our item fits into. Mark our

		 * progress, so we only execute this once.

	/*

	 * We do this up front, before the allocation, so that a

	 * failure to add the dx_root_bh to the journal won't result

	 * us losing clusters.

	/*

	 * Transfer the entries from our dx_root into the appropriate

	 * block

		/* Each leaf has been passed to the journal already

	/* This should never fail considering we start with an empty

		/*

		 * We ran out of room in the root block. Expand it to

		 * an extent, then allow ocfs2_find_dir_space_dx to do

		 * the rest.

	/*

	 * Insert preparation for an indexed directory is split into two

	 * steps. The call to find_dir_space_dx reserves room in the index for

	 * an additional item. If we run out of space there, it's a real error

	 * we can't continue on.

	/*

	 * Next, we need to find space in the unindexed tree. This call

	 * searches using the free space linked list. If the unindexed tree

	 * lacks sufficient space, we'll expand it below. The expansion code

	 * is smart enough to add any new blocks to the free space list.

 Do this up here - ocfs2_extend_dir might need the dx_root */

		/*

		 * We make the assumption here that new leaf blocks are added

		 * to the front of our free list.

/*

 * Get a directory ready for insert. Any directory allocation required

 * happens here. Success returns zero, and enough context in the dir

 * lookup result that ocfs2_add_entry() will be able complete the task

 * with minimal performance impact.

	/*

	 * Do this up front to reduce confusion.

	 *

	 * The directory might start inline, then be turned into an

	 * indexed one, in which case we'd need to hash deep inside

	 * ocfs2_find_dir_space_id(). Since

	 * ocfs2_prepare_dx_dir_for_insert() also needs this hash

	 * done, there seems no point in spreading out the calls. We

	 * can optimize away the case where the file system doesn't

	 * support indexing.

		/*

		 * We have to expand the directory to add this name.

 XXX: What if dr_clusters is too large? */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * dcache.c

 *

 * dentry cache handling code

 *

 * Copyright (C) 2002, 2004 Oracle.  All rights reserved.

 if all else fails, just return false */

	/* For a negative dentry -

	 * check the generation number of the parent and compare with the

	 * one stored in the inode.

 did we or someone else delete this inode? */

	/*

	 * We don't need a cluster lock to test this because once an

	 * inode nlink hits zero, it never goes back.

	/*

	 * If the last lookup failed to create dentry lock, let us

	 * redo it.

	/*

	 * ocfs2_lookup() does a d_splice_alias() _before_ attaching

	 * to the lock data, so we skip those here, otherwise

	 * ocfs2_dentry_attach_lock() will get its original dentry

	 * back.

 Negative parent dentry? */

 Name is in a different directory. */

/*

 * Walk the inode alias list, and find a dentry which has a given

 * parent. ocfs2_dentry_attach_lock() wants to find _any_ alias as it

 * is looking for a dentry_lock reference. The downconvert thread is

 * looking to unhash aliases, so we allow it to skip any that already

 * have that property.

/*

 * Attach this dentry to a cluster lock.

 *

 * Dentry locks cover all links in a given directory to a particular

 * inode. We do this so that ocfs2 can build a lock name which all

 * nodes in the cluster can agree on at all times. Shoving full names

 * in the cluster lock won't work due to size restrictions. Covering

 * links inside of a directory is a good compromise because it still

 * allows us to use the parent directory lock to synchronize

 * operations.

 *

 * Call this function with the parent dir semaphore and the parent dir

 * cluster lock held.

 *

 * The dir semaphore will protect us from having to worry about

 * concurrent processes on our node trying to attach a lock at the

 * same time.

 *

 * The dir cluster lock (held at either PR or EX mode) protects us

 * from unlink and rename on other nodes.

 *

 * A dput() can happen asynchronously due to pruning, so we cover

 * attaching and detaching the dentry lock with a

 * dentry_attach_lock.

 *

 * A node which has done lookup on a name retains a protected read

 * lock until final dput. If the user requests and unlink or rename,

 * the protected read is upgraded to an exclusive lock. Other nodes

 * who have seen the dentry will then be informed that they need to

 * downgrade their lock, which will involve d_delete on the

 * dentry. This happens in ocfs2_dentry_convert_worker().

	/*

	 * Negative dentry. We ignore these for now.

	 *

	 * XXX: Could we can improve ocfs2_dentry_revalidate() by

	 * tracking these?

		/* Converting a negative dentry to positive

		/*

		 * Great, an alias exists, which means we must have a

		 * dentry lock already. We can just grab the lock off

		 * the alias and add it to the list.

		 *

		 * We're depending here on the fact that this dentry

		 * was found and exists in the dcache and so must have

		 * a reference to the dentry_lock because we can't

		 * race creates. Final dput() cannot happen on it

		 * since we have it pinned, so our reference is safe.

	/*

	 * There are no other aliases

	/*

	 * Does this have to happen below, for all attaches, in case

	 * the struct inode gets blown away by the downconvert thread?

		/* d_fsdata is set by a racing thread which is doing

		 * the same thing as this thread is doing. Leave the racing

		 * thread going ahead and we return here.

	/*

	 * This actually gets us our PRMODE level lock. From now on,

	 * we'll have a notification if one of these names is

	 * destroyed on another node.

	/*

	 * In case of error, manually free the allocation and do the iput().

	 * We need to do this because error here means no d_instantiate(),

	 * which means iput() will not be called during dput(dentry).

/*

 * ocfs2_dentry_iput() and friends.

 *

 * At this point, our particular dentry is detached from the inodes

 * alias list, so there's no way that the locking code can find it.

 *

 * The interesting stuff happens when we determine that our lock needs

 * to go away because this is the last subdir alias in the

 * system. This function needs to handle a couple things:

 *

 * 1) Synchronizing lock shutdown with the downconvert threads. This

 *    is already handled for us via the lockres release drop function

 *    called in ocfs2_release_dentry_lock()

 *

 * 2) A race may occur when we're doing our lock shutdown and

 *    another process wants to create a new dentry lock. Right now we

 *    let them race, which means that for a very short while, this

 *    node might have two locks on a lock resource. This should be a

 *    problem though because one of them is in the process of being

 *    thrown out.

		/*

		 * No dentry lock is ok if we're disconnected or

		 * unhashed.

/*

 * d_move(), but keep the locks in sync.

 *

 * When we are done, "dentry" will have the parent dir and name of

 * "target", which will be thrown away.

 *

 * We manually update the lock of "dentry" if need be.

 *

 * "target" doesn't have it's dentry lock touched - we allow the later

 * dput() to handle this for us.

 *

 * This is called during ocfs2_rename(), while holding parent

 * directory locks. The dentries have already been deleted on other

 * nodes via ocfs2_remote_dentry_delete().

 *

 * Normally, the VFS handles the d_move() for the file system, after

 * the ->rename() callback. OCFS2 wants to handle this internally, so

 * the new lock can be created atomically with respect to the cluster.

	/*

	 * Move within the same directory, so the actual lock info won't

	 * change.

	 *

	 * XXX: Is there any advantage to dropping the lock here?

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * mmap.c

 *

 * Code to deal with the mess that is clustered mmap.

 *

 * Copyright (C) 2002, 2004 Oracle.  All rights reserved.

	/*

	 * There are cases that lead to the page no longer belonging to the

	 * mapping.

	 * 1) pagecache truncates locally due to memory pressure.

	 * 2) pagecache truncates when another is taking EX lock against 

	 * inode lock. see ocfs2_data_convert_worker.

	 * 

	 * The i_size check doesn't catch the case where nodes truncated and

	 * then re-extended the file. We'll re-check the page mapping after

	 * taking the page lock inside of ocfs2_write_begin_nolock().

	 *

	 * Let VM retry with these cases.

	/*

	 * Call ocfs2_write_begin() and ocfs2_write_end() to take

	 * advantage of the allocation code there. We pass a write

	 * length of the whole page (chopped to i_size) to make sure

	 * the whole thing is allocated.

	 *

	 * Since we know the page is up to date, we don't have to

	 * worry about ocfs2_write_begin() skipping some buffer reads

	 * because the "write" would invalidate their data.

	/*

	 * The cluster locks taken will block a truncate from another

	 * node. Taking the data lock will also ensure that we don't

	 * attempt page truncation as part of a downconvert.

	/*

	 * The alloc sem should be enough to serialize with

	 * ocfs2_truncate_file() changing i_size as well as any thread

	 * modifying the inode btree.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * extent_map.c

 *

 * Block/Cluster mapping functions

 *

 * Copyright (C) 2004 Oracle.  All rights reserved.

/*

 * The extent caching implementation is intentionally trivial.

 *

 * We only cache a small number of extents stored directly on the

 * inode, so linear order operations are acceptable. If we ever want

 * to increase the size of the extent map, then these algorithms must

 * get smarter.

/*

 * Forget about all clusters equal to or greater than cpos.

 Full truncate of this record. */

 Partial truncate */

/*

 * Is any part of emi2 contained within emi1

	/*

	 * Check if logical start of emi2 is inside emi1

	/*

	 * Check if logical end of emi2 is inside emi1

/*

 * Try to merge emi with ins. Returns 1 if merge succeeds, zero

 * otherwise.

	/*

	 * Handle contiguousness

	/*

	 * Overlapping extents - this shouldn't happen unless we've

	 * split an extent to change it's flags. That is exceedingly

	 * rare, so there's no sense in trying to optimize it yet.

 No merge was possible. */

/*

 * In order to reduce complexity on the caller, this insert function

 * is intentionally liberal in what it will accept.

 *

 * The only rule is that the truncate call *must* be used whenever

 * records have been deleted. This avoids inserting overlapping

 * records with different physical mappings.

	/*

	 * No item could be merged.

	 *

	 * Either allocate and add a new item, or overwrite the last recently

	 * inserted.

/*

 * Return the 1st index within el which contains an extent start

 * larger than v_cluster.

/*

 * Figure out the size of a hole which starts at v_cluster within the given

 * extent list.

 *

 * If there is no more allocation past v_cluster, we return the maximum

 * cluster size minus v_cluster.

 *

 * If we have in-inode extents, then el points to the dinode list and

 * eb_bh is NULL. Otherwise, eb_bh should point to the extent block

 * containing el.

		/*

		 * Check the next leaf for any extents.

		/*

		 * We're at the end of our existing allocation. Just

		 * return the maximum number of clusters we could

		 * possibly allocate.

		/*

		 * Holes can be larger than the maximum size of an

		 * extent, so we return their lengths in a separate

		 * field.

	/*

	 * Checking for last extent is potentially expensive - we

	 * might have to look at the next leaf over to see if it's

	 * empty.

	 *

	 * The first two checks are to see whether the caller even

	 * cares for this information, and if the extent is at least

	 * the last in it's list.

	 *

	 * If those hold true, then the extent is last if any of the

	 * additional conditions hold true:

	 *  - Extent list is in-inode

	 *  - Extent list is right-most

	 *  - Extent list is 2nd to rightmost, with empty right-most

		/*

		 * A hole was found. Return some canned values that

		 * callers can key on. If asked for, num_clusters will

		 * be populated with the size of the hole.

/*

 * This expects alloc_sem to be held. The allocation cannot change at

 * all while the map is in the process of being updated.

	/*

	 * p_cluster == 0 indicates a hole.

/*

 * The ocfs2_fiemap_inline() may be a little bit misleading, since

 * it not only handles the fiemap for inlined files, but also deals

 * with the fast symlink, cause they have no difference for extent

 * mapping per se.

	/*

	 * Handle inline-data and fast symlink separately.

 Is IO overwriting allocated blocks? */

		/*

		 * If the caller passed us bhs, they should have come

		 * from a previous readahead call to this function.  Thus,

		 * they should have the right b_blocknr.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * dlmglue.c

 *

 * Code which implements an OCFS2 specific interface to our DLM.

 *

 * Copyright (C) 2003, 2004 Oracle.  All rights reserved.

/*

 * Return value from ->downconvert_worker functions.

 *

 * These control the precise actions of ocfs2_unblock_lock()

 * and ocfs2_process_blocked_lock()

 *

 Continue downconvert */

	UNBLOCK_CONTINUE_POST	= 1, /* Continue downconvert, fire

	UNBLOCK_STOP_POST	= 2, /* Do not downconvert, fire

 Lockdep class keys */

 This aids in debugging situations where a bad LVB might be involved. */

/*

 * OCFS2 Lock Resource Operations

 *

 * These fine tune the behavior of the generic dlmglue locking infrastructure.

 *

 * The most basic of lock types can point ->l_priv to their respective

 * struct ocfs2_super and allow the default actions to manage things.

 *

 * Right now, each lock type also needs to implement an init function,

 * and trivial lock/unlock wrappers. ocfs2_simple_drop_lockres()

 * should be called when the lock is no longer needed (i.e., object

 * destruction time).

	/*

	 * Translate an ocfs2_lock_res * into an ocfs2_super *. Define

	 * this callback if ->l_priv is not an ocfs2_super pointer

	/*

	 * Optionally called in the downconvert thread after a

	 * successful downconvert. The lockres will not be referenced

	 * after this callback is called, so it is safe to free

	 * memory, etc.

	 *

	 * The exact semantics of when this is called are controlled

	 * by ->downconvert_worker()

	/*

	 * Allow a lock type to add checks to determine whether it is

	 * safe to downconvert a lock. Return 0 to re-queue the

	 * downconvert at a later time, nonzero to continue.

	 *

	 * For most locks, the default checks that there are no

	 * incompatible holders are sufficient.

	 *

	 * Called with the lockres spinlock held.

	/*

	 * Allows a lock type to populate the lock value block. This

	 * is called on downconvert, and when we drop a lock.

	 *

	 * Locks that want to use this should set LOCK_TYPE_USES_LVB

	 * in the flags field.

	 *

	 * Called with the lockres spinlock held.

	/*

	 * Called from the downconvert thread when it is determined

	 * that a lock will be downconverted. This is called without

	 * any locks held so the function can do work that might

	 * schedule (syncing out data, etc).

	 *

	 * This should return any one of the ocfs2_unblock_action

	 * values, depending on what it wants the thread to do.

	/*

	 * LOCK_TYPE_* flags which describe the specific requirements

	 * of a lock type. Descriptions of each individual flag follow.

/*

 * Some locks want to "refresh" potentially stale data when a

 * meaningful (PRMODE or EXMODE) lock level is first obtained. If this

 * flag is set, the OCFS2_LOCK_NEEDS_REFRESH flag will be set on the

 * individual lockres l_flags member from the ast function. It is

 * expected that the locking wrapper will clear the

 * OCFS2_LOCK_NEEDS_REFRESH flag when done.

/*

 * Indicate that a lock type makes use of the lock value block. The

 * ->set_lvb lock type callback must be defined.

 overflow */

 This also clears out the lock status block */

 thanks, gcc */

	/*

	 * Unfortunately, the standard lock naming scheme won't work

	 * here because we have two 16 byte values to use. Instead,

	 * we'll stuff the inode number as a binary value. We still

	 * want error prints to show something without garbling the

	 * display, so drop a null byte in there before the inode

	 * number. A future version of OCFS2 will likely use all

	 * binary lock names. The stringified names have been a

	 * tremendous aid in debugging, but now that the debugfs

	 * interface exists, we can mangle things there if need be.

	 *

	 * NOTE: We also drop the standard "pad" value (the total lock

	 * name size stays the same though - the last part is all

	 * zeros due to the memset in ocfs2_lock_res_init_once()

	/* Superblock lockres doesn't come from a slab so we call init

	/* Rename lockres doesn't come from a slab so we call init

	/* nfs_sync lockres doesn't come from a slab so we call init

 Only one trimfs thread are allowed to work at the same time. */

 Need to clear out the lock status block for the dlm */

/*

 * Keep a list of processes who have interest in a lockres.

 * Note: this is now only uesed for check recursive cluster locking.

/* WARNING: This function lives in a world where the only three lock

 * levels are EX, PR, and NL. It *will* have to be adjusted when more

	/* Convert from RO to EX doesn't really need anything as our

	 * information is already up to data. Convert from NL to

	 * *anything* however should mark ourselves as needing an

	/*

	 * We set the OCFS2_LOCK_UPCONVERT_FINISHING flag before clearing

	 * the OCFS2_LOCK_BUSY flag to prevent the dc thread from

	 * downconverting the lock before the upconvert has fully completed.

	 * Do not prevent the dc thread from downconverting if NONBLOCK lock

	 * had already returned.

		/* only schedule a downconvert if we haven't already scheduled

		 * one that goes low enough to satisfy the level we're

		 * blocking.  this also catches the case where we get

/*

 * OCFS2_LOCK_PENDING and l_pending_gen.

 *

 * Why does OCFS2_LOCK_PENDING exist?  To close a race between setting

 * OCFS2_LOCK_BUSY and calling ocfs2_dlm_lock().  See ocfs2_unblock_lock()

 * for more details on the race.

 *

 * OCFS2_LOCK_PENDING closes the race quite nicely.  However, it introduces

 * a race on itself.  In o2dlm, we can get the ast before ocfs2_dlm_lock()

 * returns.  The ast clears OCFS2_LOCK_BUSY, and must therefore clear

 * OCFS2_LOCK_PENDING at the same time.  When ocfs2_dlm_lock() returns,

 * the caller is going to try to clear PENDING again.  If nothing else is

 * happening, __lockres_clear_pending() sees PENDING is unset and does

 * nothing.

 *

 * But what if another path (eg downconvert thread) has just started a

 * new locking action?  The other path has re-set PENDING.  Our path

 * cannot clear PENDING, because that will re-open the original race

 * window.

 *

 * [Example]

 *

 * ocfs2_meta_lock()

 *  ocfs2_cluster_lock()

 *   set BUSY

 *   set PENDING

 *   drop l_lock

 *   ocfs2_dlm_lock()

 *    ocfs2_locking_ast()		ocfs2_downconvert_thread()

 *     clear PENDING			 ocfs2_unblock_lock()

 *					  take_l_lock

 *					  !BUSY

 *					  ocfs2_prepare_downconvert()

 *					   set BUSY

 *					   set PENDING

 *					  drop l_lock

 *   take l_lock

 *   clear PENDING

 *   drop l_lock

 *			<window>

 *					  ocfs2_dlm_lock()

 *

 * So as you can see, we now have a window where l_lock is not held,

 * PENDING is not set, and ocfs2_dlm_lock() has not been called.

 *

 * The core problem is that ocfs2_cluster_lock() has cleared the PENDING

 * set by ocfs2_prepare_downconvert().  That wasn't nice.

 *

 * To solve this we introduce l_pending_gen.  A call to

 * lockres_clear_pending() will only do so when it is passed a generation

 * number that matches the lockres.  lockres_set_pending() will return the

 * current generation number.  When ocfs2_cluster_lock() goes to clear

 * PENDING, it passes the generation it got from set_pending().  In our

 * example above, the generation numbers will *not* match.  Thus,

 * ocfs2_cluster_lock() will not clear the PENDING set by

 * ocfs2_prepare_downconvert().

 Unlocked version for ocfs2_locking_ast() */

	/*

	 * The ast and locking functions can race us here.  The winner

	 * will clear pending, the loser will not.

	/*

	 * The downconvert thread may have skipped us because we

	 * were PENDING.  Wake it up.

 Locked version for callers of ocfs2_dlm_lock() */

	/*

	 * We can skip the bast for locks which don't enable caching -

	 * they'll be dropped at the earliest possible time anyway.

	/* set it to something invalid so if we get called again we

 Did we try to cancel this lock?  Clear that state */

	/*

	 * We may have beaten the locking functions here.  We certainly

	 * know that dlm_lock() has been called :-)

	 * Because we can't have two lock calls in flight at once, we

	 * can use lockres->l_pending_gen.

		/* Downconvert thread may have requeued this lock, we

/*

 * This is the filesystem locking protocol.  It provides the lock handling

 * hooks for the underlying DLM.  It has a maximum version number.

 * The version number allows interoperability with systems running at

 * the same major number and an equal or smaller minor number.

 *

 * Whenever the filesystem does new things with locks (adds or removes a

 * lock, orders them differently, does different things underneath a lock),

 * the version must be changed.  The protocol is negotiated when joining

 * the dlm domain.  A node may join the domain if its major version is

 * identical to all other nodes and its minor version is greater than

 * or equal to all other nodes.  When its minor version is greater than

 * the other nodes, it will run at the minor version specified by the

 * other nodes.

 *

 * If a locking change is made that will not be compatible with older

 * versions, the major number must be increased and the minor version set

 * to zero.  If a change merely adds a behavior that can be disabled when

 * speaking to older versions, the minor version must be increased.  If a

 * change adds a fully backwards compatible change (eg, LVB changes that

 * are just ignored by older versions), the version does not need to be

 * updated.

/* Note: If we detect another process working on the lock (i.e.,

 * OCFS2_LOCK_BUSY), we'll bail out returning 0. It's up to the caller

 * to do the right thing in that case.

/* predict what lock level we'll be dropping down to on behalf

 * of another node, and return true if the currently wanted

 Re-arm the completion in case we want to wait on it again */

/* returns 0 if the mw that was removed was already satisfied, -EBUSY

 Re-arm the completion in case we want to wait on it again */

 gcc doesn't realize wait = 1 guarantees ret is set */

	/* We only compare against the currently granted level

	 * here. If the lock is blocked waiting on a downconvert,

		/* is someone sitting in dlm_lock? If so, wait on

		/*

		 * We've upconverted. If the lock now has a level we can

		 * work with, we take it. If, however, the lock is not at the

		 * required level, we go thru the full cycle. One way this could

		 * happen is if a process requesting an upconvert to PR is

		 * closely followed by another requesting upconvert to an EX.

		 * If the process requesting EX lands here, we want it to

		 * continue attempting to upconvert and let the process

		 * requesting PR take the lock.

		 * If multiple processes request upconvert to PR, the first one

		 * here will take the lock. The others will have to go thru the

		 * OCFS2_LOCK_BLOCKED check to ensure that there is no pending

		 * downconvert request.

		/* is the lock is currently blocked on behalf of

 call dlm_lock to upgrade lock now */

		/* At this point we've gone inside the dlm and need to

 wait for busy to clear and carry on */

 Ok, if we get here then we're good to go. */

 ocfs2_unblock_lock reques on seeing OCFS2_LOCK_UPCONVERT_FINISHING */

	/*

	 * This is helping work around a lock inversion between the page lock

	 * and dlm locks.  One path holds the page lock while calling aops

	 * which block acquiring dlm locks.  The voting thread holds dlm

	 * locks while acquiring page locks while down converting data locks.

	 * This block is helping an aop path notice the inversion and back

	 * off to unlock its page lock before trying the dlm lock again.

/* Grants us an EX lock on the data and metadata resources, skipping

 * the normal cluster directory lookup. Use this ONLY on newly created

 * inodes which other nodes can't possibly see, and which haven't been

 * hashed in the inode hash yet. This can give us a good performance

 * increase as it'll skip the network broadcast normally associated

	/* NOTE: That we don't increment any of the holder counts, nor

	 * do we add anything to a journal handle. Since this is

	 * supposed to be a new inode which the cluster doesn't know

	 * about yet, there is no need to.  As far as the LVB handling

	 * is concerned, this is basically like acquiring an EX lock

	 * on a resource which has an invalid one -- we'll set it

	/*

	 * We don't want to use DLM_LKF_LOCAL on a meta data lock as they

	 * don't use a generation in their lock names.

/*

 * ocfs2_open_lock always get PR mode lock.

	/*

	 * The file system may already holding a PRMODE/EXMODE open lock.

	 * Since we pass DLM_LKF_NOQUEUE, the request won't block waiting on

	 * other nodes and the -EAGAIN will indicate to the caller that

	 * this inode is still in use.

/*

 * ocfs2_open_unlock unlock PR and EX mode open locks.

	/*

	 * We may still have gotten the lock, in which case there's no

	 * point to restarting the syscall.

/*

 * ocfs2_file_lock() and ocfs2_file_unlock() map to a single pair of

 * flock() calls. The locking approach this requires is sufficiently

 * different from all other cluster lock types that we implement a

 * separate path to the "low-level" dlm calls. In particular:

 *

 * - No optimization of lock levels is done - we take at exactly

 *   what's been requested.

 *

 * - No lock caching is employed. We immediately downconvert to

 *   no-lock at unlock time. This also means flock locks never go on

 *   the blocking list).

 *

 * - Since userspace can trivially deadlock itself with flock, we make

 *   sure to allow cancellation of a misbehaving applications flock()

 *   request.

 *

 * - Access to any flock lockres doesn't require concurrency, so we

 *   can simplify the code by requiring the caller to guarantee

 *   serialization of dlmglue flock calls.

		/*

		 * Get the lock at NLMODE to start - that way we

		 * can cancel the upconvert request if need be.

		/*

		 * Userspace can cause deadlock itself with

		 * flock(). Current behavior locally is to allow the

		 * deadlock, but abort the system call if a signal is

		 * received. We follow this example, otherwise a

		 * poorly written program could sit in kernel until

		 * reboot.

		 *

		 * Handling this is a bit more complicated for Ocfs2

		 * though. We can't exit this function with an

		 * outstanding lock request, so a cancel convert is

		 * required. We intentionally overwrite 'ret' - if the

		 * cancel fails and the lock was granted, it's easier

		 * to just bubble success back up to the user.

 Trylock failed asynchronously */

	/*

	 * Fake a blocking ast for the downconvert code.

	/* If we know that another node is waiting on our lock, kick

	 * the downconvert thread * pre-emptively when we reach a release

/* LVB only has room for 64 bits of time here so we pack it for

/* Call this with the lockres locked. I am reasonably sure we don't

 * need ip_lock in this function as anyone who would be changing those

	/*

	 * Invalidate the LVB of a deleted inode - this way other

	 * nodes are forced to go to disk and discover the new inode

	 * status.

 We're safe here without the lockres lock... */

 fast-symlinks are a special case */

/* Determine whether a lock resource needs to be refreshed, and

 * arbitrate who gets to refresh it.

 *

 *   0 means no refresh needed.

 *

 *   > 0 means you need to refresh this and you MUST call

 Ok, I'll be the one to refresh this lock. */

/* If status is non zero, I'll mark it as not being in refresh

 may or may not return a bh if it went to disk. */

	/* This will discard any caching information we might have had

 Boo, we have to go to disk. */

 read bh, cast, ocfs2_refresh_inode */

		/* This is a good chance to make sure we're not

		 * locking an invalid object.  ocfs2_read_inode_block()

		 * already checked that the inode block is sane.

		 *

		 * We bug on a stale inode here because we checked

		 * above whether it was wiped from disk. The wiping

		 * node provides a guarantee that we receive that

		 * message and can mark the inode before dropping any

		/* Ok, the update went to disk for us, use the

/*

 * returns < 0 error if the callback will never be called, otherwise

 * the result of the lock will be communicated via the callback.

	/* We'll allow faking a readonly metadata lock for

 Notify the error cleanup path to drop the cluster lock. */

	/* We wait twice because a node may have died while we were in

	 * the lower dlm layers. The second time though, we've

	 * committed to owning this lock so we don't allow signals to

	/*

	 * We only see this flag if we're being called from

	 * ocfs2_read_locked_inode(). It means we're locking an inode

	 * which hasn't been populated yet, so clear the refresh flag

	 * and let the caller handle it.

	/* This is fun. The caller may want a bh back, or it may

	 * not. ocfs2_inode_lock_update definitely wants one in, but

	 * may or may not read one, depending on what's in the

	 * LVB. The result of all of this is that we've *only* gone to

/*

 * This is working around a lock inversion between tasks acquiring DLM

 * locks while holding a page lock and the downconvert thread which

 * blocks dlm lock acquiry while acquiring page locks.

 *

 * ** These _with_page variantes are only intended to be called from aop

 * methods that hold page locks and return a very specific *positive* error

 * code that aop methods pass up to the VFS -- test for errors with != 0. **

 *

 * The DLM is called such that it returns -EAGAIN if it would have

 * blocked waiting for the downconvert thread.  In that case we unlock

 * our page so the downconvert thread can make progress.  Once we've

 * done this we have to return AOP_TRUNCATED_PAGE so the aop method

 * that called us can bubble that back up into the VFS who will then

 * immediately retry the aop call.

		/*

		 * If we can't get inode lock immediately, we should not return

		 * directly here, since this will lead to a softlockup problem.

		 * The method is to get a blocking lock and immediately unlock

		 * before returning, this can avoid CPU resource waste due to

		 * lots of retries, and benefits fairness in getting lock.

	/*

	 * If we should update atime, we will get EX lock,

	 * otherwise we just get PR lock.

/*

 * This _tracker variantes are introduced to deal with the recursive cluster

 * locking issue. The idea is to keep track of a lock holder on the stack of

 * the current process. If there's a lock holder on the stack, we know the

 * task context is already protected by cluster locking. Currently, they're

 * used in some VFS entry routines.

 *

 * return < 0 on error, return == 0 if there's no lock holder on the stack

 * before this call, return == 1 if this call would be a recursive locking.

 * return == -1 if this lock attempt will cause an upgrade which is forbidden.

 *

 * When taking lock levels into account,we face some different situations.

 *

 * 1. no lock is held

 *    In this case, just lock the inode as requested and return 0

 *

 * 2. We are holding a lock

 *    For this situation, things diverges into several cases

 *

 *    wanted     holding	     what to do

 *    ex		ex	    see 2.1 below

 *    ex		pr	    see 2.2 below

 *    pr		ex	    see 2.1 below

 *    pr		pr	    see 2.1 below

 *

 *    2.1 lock level that is been held is compatible

 *    with the wanted level, so no lock action will be tacken.

 *

 *    2.2 Otherwise, an upgrade is needed, but it is forbidden.

 *

 * Reason why upgrade within a process is forbidden is that

 * lock upgrade may cause dead lock. The following illustrates

 * how it happens.

 *

 *         thread on node1                             thread on node2

 * ocfs2_inode_lock_tracker(ex=0)

 *

 *                                <======   ocfs2_inode_lock_tracker(ex=1)

 *

 * ocfs2_inode_lock_tracker(ex=1)

		/*

		 * This corresponds to the case 1.

		 * We haven't got any lock before.

		/*

		 * case 2.2 upgrade may cause dead lock, forbid it.

	/*

	 *  case 2.1 OCFS2_META_LOCK_GETBH flag make ocfs2_inode_lock_full.

	 *  ignore the lock level and just update it.

	/* had_lock means that the currect process already takes the cluster

	 * lock previously.

	 * If had_lock is 1, we have nothing to do here.

	 * If had_lock is 0, we will release the lock.

	/* The super block lock path is really in the best position to

	 * know when resources covered by the lock need to be

	 * refreshed, so we do it here. Of course, making sense of

/* Reference counting of the dlm debug structure. We want this because

 * open references on the debug inodes can live on after a mount, so

 Access to this is arbitrated for us via seq_file->sem. */

 discover the head of the list */

		/* We track our "dummy" iteration lockres' by a NULL

		/* Since lockres' have the lifetime of their container

		 * (which can be inodes, ocfs2_supers, etc) we want to

		 * copy this out to a temporary lockres while still

		 * under the spinlock. Obviously after this we can't

		 * trust any pointers on the copy returned, but that's

		 * ok as the information we want isn't typically held

/*

 * Version is used by debugfs.ocfs2 to determine the format being used

 *

 * New in version 2

 *	- Lock stats printed

 * New in version 3

 *	- Max time in lock stats is in usecs (instead of nsecs)

 * New in version 4

 *	- Add last pr/ex unlock times and first lock wait time in usecs

		/*

		 * Use d_filter_secs field to filter lock resources dump,

		 * the default d_filter_secs(0) value filters nothing,

		 * otherwise, only dump the last N seconds active lock

		 * resources.

 Dump the raw LVB */

 The following seq_print was added in version 2 of this output */

 End the line */

 launch downconvert thread */

 for now, uuid == domain */

	/*

	 * Now that we have dropped all locks and ocfs2_dismount_volume()

	 * has disabled recovery, the DLM won't be talking to us.  It's

	 * safe to tear things down before disconnecting the cluster.

 We didn't get anywhere near actually using this lockres. */

		/* XXX: Today we just wait on any busy

		 * locks... Perhaps we need to cancel converts in the

	/* make sure we never get here while waiting for an ast to

 is this necessary? */

/* Mark the lockres as being dropped. It will no longer be

 * queued if blocking, but we still may have to wait on it

 * being dequeued from the downconvert thread before we can consider

 * it safe to drop.

 *

		/*

		 * We know the downconvert is queued but not in progress

		 * because we are the downconvert thread and processing

		 * different lock. So we can just remove the lock from the

		 * queue. This is not only an optimization but also a way

		 * to avoid the following deadlock:

		 *   ocfs2_dentry_post_unlock()

		 *     ocfs2_dentry_lock_put()

		 *       ocfs2_drop_dentry_lock()

		 *         iput()

		 *           ocfs2_evict_inode()

		 *             ocfs2_clear_inode()

		 *               ocfs2_mark_lockres_freeing()

		 *                 ... blocks waiting for OCFS2_LOCK_QUEUED

		 *                 since we are the downconvert thread which

		 *                 should clear the flag.

		/*

		 * Warn if we recurse into another post_unlock call.  Strictly

		 * speaking it isn't a problem but we need to be careful if

		 * that happens (stack overflow, deadlocks, ...) so warn if

		 * ocfs2 grows a path for which this can happen.

 Since the lock is freeing we don't do much in the fn below */

	/* No need to call ocfs2_mark_lockres_freeing here -

	/*

	 * On DLM_LKF_VALBLK, fsdlm behaves differently with o2cb. It always

	 * expects DLM_LKF_VALBLK being set if the LKB has LVB, so that

	 * we can recover correctly from node failure. Otherwise, we may get

	 * invalid LVB in LKB, but without DLM_SBF_VALNOTVALID being set.

 returns 1 when the caller should unlock and call ocfs2_dlm_unlock */

		/* If we're already trying to cancel a lock conversion

		 * then just drop the spinlock and allow the caller to

 were we in a convert when we got the bast fire? */

	/* set things up for the unlockast to know to just

	/*

	 * Is it still blocking? If not, we have no more work to do.

		/* XXX

		 * This is a *big* race.  The OCFS2_LOCK_PENDING flag

		 * exists entirely for one reason - another thread has set

		 * OCFS2_LOCK_BUSY, but has *NOT* yet called dlm_lock().

		 *

		 * If we do ocfs2_cancel_convert() before the other thread

		 * calls dlm_lock(), our cancel will do nothing.  We will

		 * get no ast, and we will have no way of knowing the

		 * cancel failed.  Meanwhile, the other thread will call

		 * into dlm_lock() and wait...forever.

		 *

		 * Why forever?  Because another node has asked for the

		 * lock first; that's why we're here in unblock_lock().

		 *

		 * The solution is OCFS2_LOCK_PENDING.  When PENDING is

		 * set, we just requeue the unblock.  Only when the other

		 * thread has called dlm_lock() and cleared PENDING will

		 * we then cancel their request.

		 *

		 * All callers of dlm_lock() must set OCFS2_DLM_PENDING

		 * at the same time they set OCFS2_DLM_BUSY.  They must

		 * clear OCFS2_DLM_PENDING after dlm_lock() returns.

	/*

	 * This prevents livelocks. OCFS2_LOCK_UPCONVERT_FINISHING flag is

	 * set when the ast is received for an upconvert just before the

	 * OCFS2_LOCK_BUSY flag is cleared. Now if the fs received a bast

	 * on the heels of the ast, we want to delay the downconvert just

	 * enough to allow the up requestor to do its task. Because this

	 * lock is in the blocked queue, the lock will be downconverted

	 * as soon as the requestor is done with the lock.

	/*

	 * How can we block and yet be at NL?  We were trying to upconvert

	 * from NL and got canceled.  The code comes back here, and now

	 * we notice and clear BLOCKING.

	/* if we're blocking an exclusive and we have *any* holders,

	/* If it's a PR we're blocking, then only

	/*

	 * Can we get a lock in this state if the holder counts are

	 * zero? The meta data unblock code used to check this.

	/* If we get here, then we know that there are no more

	 * incompatible holders (and anyone asking for an incompatible

	/* Some lockres types want to do a bit of work before

	 * downconverting a lock. Allow that here. The worker function

	 * may sleep, so we save off a copy of what we're blocking as

		/* If this changed underneath us, then we can't drop

		/*

		 * We only set the lvb if the lock has been fully

		 * refreshed - otherwise we risk setting stale

		 * data. Otherwise, there's no need to actually clear

		 * out the lvb here as it's value is still valid.

	/* The dlm lock convert is being cancelled in background,

	 * ocfs2_cancel_convert() is asynchronous in fs/dlm,

	 * requeue it, try again later.

	/*

	 * We need this before the filemap_fdatawrite() so that it can

	 * transfer the dirty bit from the PTE to the

	 * page. Unfortunately this means that even for EX->PR

	 * downconverts, we'll lose our mappings and have to build

	 * them up again.

		/* We only need to wait on the I/O if we're not also

		 * truncating pages because truncate_inode_pages waits

		 * for us above. We don't truncate pages if we're

		 * blocking anything < EXMODE because we want to keep

/*

 * Does the final reference drop on our dentry lock. Right now this

 * happens in the downconvert thread, but we could choose to simplify the

 * dlmglue API and push these off to the ocfs2_wq in the future.

/*

 * d_delete() matching dentries before the lock downconvert.

 *

 * At this point, any process waiting to destroy the

 * dentry_lock due to last ref count is stopped by the

 * OCFS2_LOCK_QUEUED flag.

 *

 * We have two potential problems

 *

 * 1) If we do the last reference drop on our dentry_lock (via dput)

 *    we'll wind up in ocfs2_release_dentry_lock(), waiting on

 *    the downconvert to finish. Instead we take an elevated

 *    reference and push the drop until after we've completed our

 *    unblock processing.

 *

 * 2) There might be another process with a final reference,

 *    waiting on us to finish processing. If this is the case, we

 *    detect it and exit out - there's no more dentries anyway.

	/*

	 * This node is blocking another node from getting a read

	 * lock. This happens when we've renamed within a

	 * directory. We've forced the other nodes to d_delete(), but

	 * we never actually dropped our lock because it's still

	 * valid. The downconvert code will retain a PR for this node,

	 * so there's no further work to do.

	/*

	 * Mark this inode as potentially orphaned. The code in

	 * ocfs2_delete_inode() will figure out whether it actually

	 * needs to be freed or not.

	/*

	 * Yuck. We need to make sure however that the check of

	 * OCFS2_LOCK_FREEING and the extra reference are atomic with

	 * respect to a reference decrement or the setting of that

	 * flag.

	/*

	 * We have a process waiting on us in ocfs2_dentry_iput(),

	 * which means we can't have any more outstanding

	 * aliases. There's no need to do any more work.

		/*

		 * The following dcache calls may do an

		 * iput(). Normally we don't want that from the

		 * downconverting thread, but in this case it's ok

		 * because the requesting node already has an

		 * exclusive lock on the inode, so it can't be queued

		 * for a downconvert.

	/*

	 * If we are the last holder of this dentry lock, there is no

	 * reason to downconvert so skip straight to the unlock.

/* Lock quota info, this function expects at least shared lock on the quota file

 On RO devices, locking really isn't needed... */

 OK, we have the lock but we need to refresh the quota info */

	/* Our reference to the lockres in this function can be

	 * considered valid until we remove the OCFS2_LOCK_QUEUED

	/* Detect whether a lock has been marked as going away while

	 * the downconvert thread was processing other things. A lock can

	 * still be marked with OCFS2_LOCK_FREEING after this check,

	 * but short circuiting here will still save us some

		/* Do not schedule a lock for downconvert when it's on

		 * the way to destruction - any nodes wanting access

	/* grab this early so we know to try again if a state change and

	/*

	 * blocked lock processing in this loop might call iput which can

	 * remove items off osb->blocked_lock_list. Downconvert up to

	 * 'processed' number of locks, but stop short if we had some

	 * removed in ocfs2_mark_lockres_freeing when downconverting.

	/* only quit once we've been asked to stop and there is no more

	/* make sure the voting thread gets a swipe at whatever changes

 SPDX-License-Identifier: GPL-2.0-only

/*

 * refcounttree.c

 *

 * Copyright (C) 2009 Oracle.  All rights reserved.

	/*

	 * If the ecc fails, we return the error but otherwise

	 * leave the filesystem running.  We know any error is

	 * local to this block.

 If ocfs2_read_block() got us a new bh, pass it up. */

 osb_lock is already locked. */

 This should never happen! */

	/*

	 * We need the generation to create the refcount tree lock and since

	 * it isn't changed during the tree modification, we are safe here to

	 * read without protection.

	 * We also have to purge the cache after we create the lock since the

	 * refcount block may have the stale data. It can only be trusted when

	 * we hold the refcount lock.

/*

 * Lock the refcount tree pointed by ref_blkno and return the tree.

 * In most case, we lock the tree and read the refcount block.

 * So read it here if the caller really needs it.

 *

 * If the tree has been re-created by other node, it will free the

 * old one and re-create it.

	/*

	 * If the refcount block has been freed and re-created, we may need

	 * to recreate the refcount tree also.

	 *

	 * Here we just remove the tree from the rb-tree, and the last

	 * kref holder will unlock and delete this refcount_tree.

	 * Then we goto "again" and ocfs2_get_refcount_tree will create

	 * the new refcount tree for us.

		/*

		 * We get an extra reference when we create the refcount

		 * tree, so another put will destroy it.

/*

 * Create a refcount tree for an inode.

 * We take for granted that the inode is already locked.

 Initialize ocfs2_refcount_block. */

	/*

	 * We have to init the tree lock here since it will use

	 * the generation number to create it.

	/*

	 * We've just created a new refcount tree in this block.  If

	 * we found a refcount tree on the ocfs2_super, it must be

	 * one we just deleted.  We free the old tree before

	 * inserting the new tree.

	/*

	 * If we are the last user, we need to free the block.

	 * So lock the allocator ahead.

 ok, cpos fail in this rec. Just return. */

 We meet with a hole here, so fake the rec. */

/*

 * Try to remove refcount tree. The mechanism is:

 * 1) Check whether i_clusters == 0, if no, exit.

 * 2) check whether we have i_xattr_loc in dinode. if yes, exit.

 * 3) Check whether we have inline xattr stored outside, if yes, exit.

 * 4) Remove the tree.

/*

 * Find the end range for a leaf refcount block indicated by

 * el->l_recs[index].e_blkno.

		/*

		 * We have a extent rec after index, so just use the e_cpos

		 * of the next extent rec.

		/*

		 * We are the last extent rec, so any high cpos should

		 * be stored in this leaf refcount block.

	/*

	 * If the extent block isn't the last one, we have to find

	 * the subtree root between this extent block and the next

	 * leaf extent block and get the corresponding e_cpos from

	 * the subroot. Otherwise we may corrupt the b-tree.

/*

 * Given a cpos and len, try to find the refcount record which contains cpos.

 * 1. If cpos can be found in one refcount record, return the record.

 * 2. If cpos can't be found, return a fake record which start from cpos

 *    and end at a small value between cpos+len and start of the next record.

 *    This fake record has r_refcount = 0.

/*

 * Merge the refcount rec if we are contiguous with the adjacent recs.

/*

 * Change the refcount indexed by "index" in ref_bh.

 * If refcount reaches 0, remove it.

	/*

	 * Initialize ocfs2_refcount_block.

	 * It should contain the same information as the old root.

	 * so just memcpy it and change the corresponding field.

 Now change the root. */

/*

 * The refcount cpos are ordered by their 64bit cpos,

 * But we will use the low 32 bit to be the e_cpos in the b-tree.

 * So we need to make sure that this pos isn't intersected with others.

 *

 * Note: The refcount block is already sorted by their low 32 bit cpos,

 *       So just try the middle pos first, and we will exit when we find

 *       the good position.

 Let's check delta earlier than middle */

 For even counts, don't walk off the end */

 Now try delta past middle */

	/*

	 * XXX: Improvement later.

	 * If we know all the high 32 bit cpos is the same, no need to sort.

	 *

	 * In order to make the whole process safe, we do:

	 * 1. sort the entries by their low 32 bit cpos first so that we can

	 *    find the split cpos easily.

	 * 2. call ocfs2_insert_extent to insert the new refcount block.

	 * 3. move the refcount rec to the new block.

	 * 4. sort the entries by their 64 bit cpos.

	 * 5. dirty the new_rb and rb.

 move refcount records starting from split_index to the new block. */

ok, remove the entries we just moved over to the other block. */

 change old and new rl_used accordingly. */

 Initialize ocfs2_refcount_block. */

 Insert the new leaf block with the specific offset cpos. */

		/*

		 * the old root bh hasn't been expanded to a b-tree,

		 * so expand it first.

 Now add a new refcount block into the tree.*/

/*

 * Adjust the extent rec in b-tree representing ref_leaf_bh.

 *

 * Only called when we have inserted a new refcount rec at index 0

 * which means ocfs2_extent_rec.e_cpos may need some change.

	/*

	 * 2 more credits, one for the leaf refcount block, one for

	 * the extent block contains the extent rec.

 change the leaf extent block first. */

 change the r_cpos in the leaf block. */

/*

 * Split the refcount_rec indexed by "index" in ref_leaf_bh.

 * This is much simple than our b-tree code.

 * split_rec is the new refcount rec we want to insert.

 * If split_rec->r_refcount > 0, we are changing the refcount(in case we

 * increase refcount or decrease a refcount to non-zero).

 * If split_rec->r_refcount == 0, we are punching a hole in current refcount

 * rec( in case we decrease a refcount to zero).

	/*

	 * If we just need to split the header or tail clusters,

	 * no more recs are needed, just split is OK.

	 * Otherwise we at least need one new recs.

	/*

	 * We need one more rec if we split in the middle and the new rec have

	 * some refcount in it.

 If the leaf block don't have enough record, expand it. */

		/*

		 * We have to re-get it since now cpos may be moved to

		 * another leaf block.

	/*

	 * We have calculated out how many new records we need and store

	 * in recs_need, so spare enough space first by moving the records

	 * after "index" to the end.

	/*

	 * If we have "len", the we will split in the tail and move it

	 * to the end of the space we have just spared.

	/*

	 * If the split pos isn't the same as the original one, we need to

	 * split in the head.

	 *

	 * Note: We have the chance that split_rec.r_refcount = 0,

	 * recs_need = 0 and len > 0, which means we just cut the head from

	 * the orig_rec and in that case we have done some modification in

	 * orig_rec above, so the check for r_cpos is faked.

		/*

		 * Here we may meet with 3 situations:

		 *

		 * 1. If we find an already existing record, and the length

		 *    is the same, cool, we just need to increase the r_refcount

		 *    and it is OK.

		 * 2. If we find a hole, just insert it with r_refcount = 1.

		 * 3. If we are in the middle of one extent record, split

		 *    it.

	/*

	 * add the freed block to the dealloc so that it will be freed

	 * when we run dealloc.

	/*

	 * check whether we need to restore the root refcount block if

	 * there is no leaf extent block at atll.

 Remove the leaf refcount block if it contains no refcount record. */

 Caller must hold refcount tree lock. */

/*

 * Mark the already-existing extent at cpos as refcounted for len clusters.

 * This adds the refcount extent flag.

 *

 * If the existing extent is larger than the request, initiate a

 * split. An attempt will be made at merging with adjacent extents.

 *

 * The caller is responsible for passing down meta_ac if we'll need it.

/*

 * Given some contiguous physical clusters, calculate what we need

 * for modifying their refcount.

			/*

			 * Now we encounter a new leaf block, so calculate

			 * whether we need to extend the old leaf.

		/*

		 * We record all the records which will be inserted to the

		 * same refcount block, so that we can tell exactly whether

		 * we need a new refcount block or not.

		 *

		 * If we will insert a new one, this is easy and only happens

		 * during adding refcounted flag to the extent, so we don't

		 * have a chance of spliting. We just need one record.

		 *

		 * If the refcount rec already exists, that would be a little

		 * complicated. we may have to:

		 * 1) split at the beginning if the start pos isn't aligned.

		 *    we need 1 more record in this case.

		 * 2) split int the end if the end pos isn't aligned.

		 *    we need 1 more record in this case.

		 * 3) split in the middle because of file system fragmentation.

		 *    we need 2 more records in this case(we can't detect this

		 *    beforehand, so always think of the worst case).

 Check whether we need a split at the beginning. */

 Check whether we need a split in the end. */

	/*

	 * So we may need ref_blocks to insert into the tree.

	 * That also means we need to change the b-tree and add that number

	 * of records since we never merge them.

	 * We need one more block for expansion since the new created leaf

	 * block is also full and needs split.

/*

 * For refcount tree, we will decrease some contiguous clusters

 * refcount count, so just go through it to see how many blocks

 * we gonna touch and whether we need to create new blocks.

 *

 * Normally the refcount blocks store these refcount should be

 * contiguous also, so that we can get the number easily.

 * We will at most add split 2 refcount records and 2 more

 * refcount blocks, so just check it in a rough way.

 *

 * Caller must hold refcount tree lock.

/*

 * Given an extent that starts at 'start' and an I/O that starts at 'cpos',

 * find an offset (start + (n * contig_clusters)) that is closest to cpos

 * while still being less than or equal to it.

 *

 * The goal is to break the extent at a multiple of contig_clusters.

/*

 * Given a cluster count of len, pad it out so that it is a multiple

 * of contig_clusters.

 Did we wrap? */

/*

 * Calculate out the start and number of virtual clusters we need to to CoW.

 *

 * cpos is vitual start cluster position we want to do CoW in a

 * file and write_len is the cluster length.

 * max_cpos is the place where we want to stop CoW intentionally.

 *

 * Normal we will start CoW from the beginning of extent record cotaining cpos.

 * We try to break up extents on boundaries of MAX_CONTIG_BYTES so that we

 * get good I/O from the resulting extent tree.

			/*

			 * We should find a refcounted record in the

			 * first pass.

		/*

		 * If we encounter a hole, a non-refcounted record or

		 * pass the max_cpos, stop the search.

		/*

		 * How many clusters do we actually need from

		 * this extent?  First we see how many we actually

		 * need to complete the write.  If that's smaller

		 * than contig_clusters, we try for contig_clusters.

		/*

		 * If the write does not cover the whole extent, we

		 * need to calculate how we're going to split the extent.

		 * We try to do it on contig_clusters boundaries.

		 *

		 * Any extent smaller than contig_clusters will be

		 * CoWed in its entirety.

			/*

			 * This extent needs to be CoW'd from its

			 * beginning, so all we have to do is compute

			 * how many clusters to grab.  We align

			 * want_clusters to the edge of contig_clusters

			 * to get better I/O.

			/*

			 * Breaking off contig_clusters at the front

			 * of the extent will cover our write.  That's

			 * easy.

			/*

			 * Breaking off contig_clusters at the tail of

			 * this extent will cover cpos.

			/*

			 * While we can't fit the entire write in this

			 * extent, we know that the write goes from cpos

			 * to the end of the extent.  Break that off.

			 * We try to break it at some multiple of

			 * contig_clusters from the front of the extent.

			 * Failing that (ie, cpos is within

			 * contig_clusters of the front), we'll CoW the

			 * entire extent.

			/*

			 * Ok, the entire write lives in the middle of

			 * this extent.  Let's try to slice the extent up

			 * nicely.  Optimally, our CoW region starts at

			 * m*contig_clusters from the beginning of the

			 * extent and goes for n*contig_clusters,

			 * covering the entire write.

 Have we covered our entire write yet? */

		/*

		 * If we reach the end of the extent block and don't get enough

		 * clusters, continue with the next extent block if possible.

/*

 * Prepare meta_ac, data_ac and calculate credits when we want to add some

 * num_clusters in data_tree "et" and change the refcount for the old

 * clusters(starting form p_cluster) in the refcount tree.

 *

 * Note:

 * 1. since we may split the old tree, so we at most will need num_clusters + 2

 *    more new leaf records.

 * 2. In some case, we may not need to reserve new clusters(e.g, reflink), so

 *    just give data_ac = NULL.

	/*

	 * We only duplicate pages until we reach the page contains i_size - 1.

	 * So trim 'end' to i_size.

 from, to is the offset within the page. */

		/*

		 * In case PAGE_SIZE <= CLUSTER_SIZE, we do not expect a dirty

		 * page, so write it back.

				/*

				 * write_on_page will unlock the page on return

If the old clusters is unwritten, no need to duplicate. */

		/*

		 * There are many different situation here.

		 * 1. If refcount == 1, remove the flag and don't COW.

		 * 2. If refcount > 1, allocate clusters.

		 *    Here we may not allocate r_len once at a time, so continue

		 *    until we reach num_clusters.

 handle any post_cow action. */

	/*

	 * Here we should write the new page out first if we are

	 * in write-back mode.

/*

 * Starting at cpos, try to CoW write_len clusters.  Don't CoW

 * past max_cpos.  This will stop when it runs into a hole or an

 * unrefcounted extent.

	/*

	 * truncate the extent map here since no matter whether we meet with

	 * any error during the action, we shouldn't trust cached extent map

	 * any more.

/*

 * CoW any and all clusters between cpos and cpos+write_len.

 * Don't CoW past max_cpos.  If this returns successfully, all

 * clusters between cpos and cpos+write_len are safe to modify.

/*

 * Given a xattr value root, calculate the most meta/credits we need for

 * refcount tree change if we truncate it to 0.

			/*

			 * We really don't know whether the other clusters is in

			 * this refcount block or not, so just take the worst

			 * case that all the clusters are in this block and each

			 * one will split a refcount rec, so totally we need

			 * clusters * 2 new refcount rec.

/*

 * Do CoW for xattr.

 We need the extra credits for duplicate_clusters by jbd. */

/*

 * Insert a new extent into refcount tree and mark a extent rec

 * as refcounted in the dinode tree.

 We need to be able to handle at least an extent tree split. */

	/*

	 * Empty the extent map so that we may get the right extent

	 * record from the disk.

/*

 * change the new file's attributes to the src.

 *

 * reflink creates a snapshot of a file, that means the attributes

 * must be identical except for three exceptions - nlink, ino, and ctime.

		/*

		 * update time.

		 * we want mtime to appear identical to the source and

		 * update ctime.

 If the security isn't preserved, we need to re-initialize them. */

		/*

		 * We need to open_unlock the inode no matter whether we

		 * succeed or not, so that other nodes can delete it later.

/*

 * Below here are the bits used by OCFS2_IOC_REFLINK() to fake

 * sys_reflink().  This will go away when vfs_reflink() exists in

 * fs/namei.c.

 copied from may_create in VFS. */

/**

 * ocfs2_vfs_reflink - Create a reference-counted link

 *

 * @old_dentry:        source dentry + inode

 * @dir:       directory to create the target

 * @new_dentry:        target dentry

 * @preserve:  if true, preserve all file attributes

	/*

	 * A reflink to an append-only or immutable file cannot be created.

 Only regular files can be reflinked. */

	/*

	 * If the caller wants to preserve ownership, they require the

	 * rights to do so.

	/*

	 * If the caller is modifying any aspect of the attributes, they

	 * are not creating a snapshot.  They need read permission on the

	 * file.

/*

 * Most codes are copied from sys_linkat.

 Update destination inode size, if necessary. */

 Extend i_size if needed. */

 Remap the range pos_in:len in s_inode to pos_out:len in t_inode. */

 Look up the extent. */

 Punch out the dest range. */

 Lock the refcount btree... */

 Mark s_inode's extent as refcounted. */

 Map in the new extent. */

 Set up refcount tree and remap s_inode to t_inode. */

	/*

	 * If we're reflinking the entire file and the source is inline

	 * data, just copy the contents.

	/*

	 * If both inodes belong to two different refcount groups then

	 * forget it because we don't know how (or want) to go merging

	 * refcount trees.

 Neither inode has a refcount tree.  Add one to s_inode. */

 Ensure that both inodes end up with the same refcount tree. */

 Turn off inline data in the dest file. */

 Actually remap extents now. */

 Lock an inode and grab a bh pointing to the inode. */

 First grab the VFS and rw locks. */

 Now go for the cluster locks */

 We always want to lock the one with the lower lockid first. */

 lock id1 */

 lock id2 */

	/*

	 * If we swapped inode order above, we have to swap the buffer heads

	 * before passing them back to the caller.

 Unlock both inodes and release buffers. */

