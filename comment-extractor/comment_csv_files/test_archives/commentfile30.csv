 SPDX-License-Identifier: GPL-2.0-only

/*

 * i2c-exynos5.c - Samsung Exynos5 I2C Controller Driver

 *

 * Copyright (C) 2013 Samsung Electronics Co., Ltd.

/*

 * HSI2C controller from Samsung supports 2 modes of operation

 * 1. Auto mode: Where in master automatically controls the whole transaction

 * 2. Manual mode: Software controls the transaction by issuing commands

 *    START, READ, WRITE, STOP, RESTART in I2C_MANUAL_CMD register.

 *

 * Operation mode can be selected by setting AUTO_MODE bit in I2C_CONF register

 *

 * Special bits are available for both modes of operation to set commands

 * and for checking transfer status

 Register Map */

 I2C_CTL Register bits */

 I2C_FIFO_CTL Register bits */

 I2C_TRAILING_CTL Register bits */

 I2C_INT_EN Register bits */

 I2C_INT_STAT Register bits */

 I2C_FIFO_STAT Register bits */

 I2C_CONF Register bits */

 I2C_AUTO_CONF Register bits */

 I2C_TIMEOUT Register bits */

 I2C_MANUAL_CMD register bits */

 I2C_TRANS_STATUS register bits */

 I2C_TRANS_STATUS register bits for Exynos5 variant */

 I2C_TRANS_STATUS register bits for Exynos7 variant */

 I2C_ADDR register bits */

 IRQ synchronization */

	/*

	 * Since the TRANS_DONE bit is cleared on read, and we may read it

	 * either during an IRQ or after a transaction, keep track of its

	 * state here.

 Controller operating frequency */

 Version of HS-I2C Hardware */

/**

 * struct exynos_hsi2c_variant - platform specific HSI2C driver data

 * @fifo_depth: the fifo depth supported by the HSI2C module

 * @hw: the hardware variant of Exynos I2C controller

 *

 * Specifies platform specific configuration of HSI2C module.

 * Note: A structure for driver specific platform data is used for future

 * expansion of its usage.

/*

 * exynos5_i2c_set_timing: updates the registers with appropriate

 * timing values calculated

 *

 * Timing values for operation are calculated against either 100kHz

 * or 1MHz controller operating frequency.

 *

 * Returns 0 on success, -EINVAL if the cycle length cannot

 * be calculated.

	/*

	 * In case of HSI2C controller in Exynos5 series

	 * FPCLK / FI2C =

	 * (CLK_DIV + 1) * (TSCLK_L + TSCLK_H + 2) + 8 + 2 * FLT_CYCLE

	 *

	 * In case of HSI2C controllers in Exynos7 series

	 * FPCLK / FI2C =

	 * (CLK_DIV + 1) * (TSCLK_L + TSCLK_H + 2) + 8 + FLT_CYCLE

	 *

	 * clk_cycle := TSCLK_L + TSCLK_H

	 * temp := (CLK_DIV + 1) * (clk_cycle + 2)

	 *

	 * Constraints: 4 <= temp, 0 <= CLK_DIV < 256, 2 <= clk_cycle <= 510

	 *

 always set Fast Speed timings */

/*

 * exynos5_i2c_init: configures the controller for I2C functionality

 * Programs I2C controller for Master mode operation

 Clear to disable Timeout */

 Set and clear the bit for reset */

 We don't expect calculations to fail during the run */

 Initialize the configure registers */

/*

 * exynos5_i2c_irq: top level IRQ servicing routine

 *

 * INT_STATUS registers gives the interrupt details. Further,

 * FIFO_STATUS or TRANS_STATUS registers are to be check for detailed

 * state of the bus.

 handle interrupt related to the transfer status */

/*

 * exynos5_i2c_wait_bus_idle

 *

 * Wait for the bus to go idle, indicated by the MASTER_BUSY bit being

 * cleared.

 *

 * Returns -EBUSY if the bus cannot be bought to idle

 wait for 100 milli seconds for the bus to be idle */

	/*

	 * Specification says master should send nine clock pulses. It can be

	 * emulated by sending manual read command (nine pulses for read eight

	 * bits + one pulse for NACK).

	/*

	 * HSI2C_MASTER_ST_LOSE state in EXYNOS7 variant before transaction

	 * indicates that bus is stuck (SDA is low). In such case bus recovery

	 * can be performed.

/*

 * exynos5_i2c_message_start: Configures the bus and starts the xfer

 * i2c: struct exynos5_i2c pointer for the current bus

 * stop: Enables stop after transfer if set. Set for last transfer of

 *       in the list of messages.

 *

 * Configures the bus for read/write function

 * Sets chip address to talk to, message length to be sent.

 * Enables appropriate interrupts and sends start xfer command.

	/*

	 * Enable interrupts before starting the transfer so that we don't

	 * miss any INT_I2C interrupts.

	/*

	 * If this is the last message to be transfered (stop == 1)

	 * Then check if the bus can be brought back to idle.

 Return the state as in interrupt routine */

 Clear pending interrupts from u-boot or misc causes */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * TI DAVINCI I2C adapter driver.

 *

 * Copyright (C) 2006 Texas Instruments.

 * Copyright (C) 2007 MontaVista Software Inc.

 *

 * Updated by Vinod & Sudhakar Feb 2005

 *

 * ----------------------------------------------------------------------------

 *

 * ----------------------------------------------------------------------------

 ----- global defines ----------------------------------------------- */

 set SDA and SCL as GPIO */

 set SCL as output when used as GPIO*/

 set SDA as output when used as GPIO*/

 read SCL GPIO level */

 read SDA GPIO level */

set the SCL GPIO high */

set the SDA GPIO high */

 set the SCL GPIO low */

 set the SDA GPIO low */

 timeout for pm runtime autosuspend */

 ms */

 default platform data to use if not supplied in the platform_device */

 put I2C into reset */

 take I2C out of reset */

	/* NOTE: I2C Clock divider programming info

	 * As per I2C specs the following formulas provide prescaler

	 * and low/high divider values

	 * input clk --> PSC Div -----------> ICCL/H Div --> output clock

	 *                       module clk

	 *

	 * output clk = module clk / (PSC + 1) [ (ICCL + d) + (ICCH + d) ]

	 *

	 * Thus,

	 * (ICCL + ICCH) = clk = (input clk / ((psc +1) * output clk)) - 2d;

	 *

	 * where if PSC == 0, d = 7,

	 *       if PSC == 1, d = 6

	 *       if PSC > 1 , d = 5

	 *

	 * Note:

	 * d is always 6 on Keystone I2C controller

	/*

	 * Both Davinci and current Keystone User Guides recommend a value

	 * between 7MHz and 12MHz. In reality 7MHz module clock doesn't

	 * always produce enough margin between SDA and SCL transitions.

	 * Measurements show that the higher the module clock is, the

	 * bigger is the margin, providing more reliable communication.

	 * So we better target for 12MHz.

 better to run under spec than over */

 Avoid driving the bus too fast because of rounding errors above */

	/*

	 * According to I2C-BUS Spec 2.1, in FAST-MODE LOW period should be at

	 * least 1.3uS, which is not the case with 50% duty cycle. Driving HIGH

	 * to LOW ratio as 1 to 2 is more safe.

	/*

	 * It's not always possible to have 1 to 2 ratio when d=7, so fall back

	 * to minimal possible clkh in this case.

	 *

	 * Note:

	 * CLKH is not allowed to be 0, in this case I2C clock is not generated

	 * at all

/*

 * This function configures I2C and brings I2C out of reset.

 * This function is called during I2C init function. This function

 * also gets called if I2C encounters any errors.

 put I2C into reset */

 compute clock dividers */

	/* Respond at reserved "SMBus Host" slave address" (and zero);

	 * we seem to have no option to not respond...

 Take the I2C module out of reset: */

 Enable interrupts */

/*

 * This routine does i2c bus recovery by using i2c_generic_scl_recovery

 * which is provided by I2C Bus recovery infrastructure.

 Disable interrupts */

 put I2C into reset */

 read the state of SCL */

 read the state of SDA */

 SCL output, SDA input */

 change to GPIO mode */

 change back to I2C mode */

/*

 * Waiting for bus not busy

	/*

	 * if bus is still "busy" here, it's most probably a HW problem like

	 * short-circuit

/*

 * Low level master read/write transaction. This function is called

 * from i2c_davinci_xfer.

 Introduce a delay, required for some boards (e.g Davinci EVM) */

 set the slave address */

 Take I2C out of reset and configure it as master */

 if the slave address is ten bit address, enable XA bit */

 Enable receive or transmit interrupts */

	/*

	 * Write mode register first as needed for correct behaviour

	 * on OMAP-L138, but don't set STT yet to avoid a race with XRDY

	 * occurring before we have loaded DXR

	/*

	 * First byte should be set here, not after interrupt,

	 * because transmit-data-ready interrupt can come before

	 * NACK-interrupt during sending of previous message and

	 * ICDXR may have wrong data

	 * It also saves us one interrupt, slightly faster

 Set STT to begin transmit now DXR is loaded */

		/* This should be 0 if all bytes were transferred

		 * or dev->cmd_err denotes an error.

 no error */

 We have an error */

/*

 * Prepare controller for a transaction and call i2c_davinci_xfer_msg

 Throw away data */

/*

 * Interrupt service routine. This gets called whenever an I2C interrupt

 * occurs.

 Arbitration lost, must retry */

 signal can terminate transfer */

 signal can terminate transfer */

 put I2C into reset */

 take I2C out of reset */

 work with hotplug and coldplug */

 I2C may be needed to bring up other drivers */

 SPDX-License-Identifier: GPL-2.0

/*

 * I2C driver for the Renesas EMEV2 SoC

 *

 * Copyright (C) 2015 Wolfram Sang <wsa@sang-engineering.com>

 * Copyright 2013 Codethink Ltd.

 * Copyright 2010-2015 Renesas Electronics Corporation

 I2C Registers */

 start */

 shift */

 control */

 slave address */

 clock select */

 extension */

 status */

 status For emulation */

 IIC flag */

 I2C IICACT0 Masks */

 I2C IICC0 Masks */

 I2C IICCL0 Masks */

 I2C IICSE0 Masks */

 I2C IICF0 Masks */

 Send Stop condition */

 Wait for stop condition */

 If I2C active */

 Disable I2C operation */

 Transfer mode set */

 Can Issue start without detecting a stop, Reservation disabled. */

 I2C enable, 9 bit interrupt mode */

 Enable I2C operation */

 Send start condition */

 Send slave address and R/W type */

 Wait for transaction */

 Received NACK (result of setting slave address and R/W) */

 Extra setup for read transactions */

 8 bit interrupt mode */

 Wait for transaction */

 Send / receive data */

 Read transaction */

 Write transaction */

 Received NACK */

 Write data */

 Wait for R/W transaction */

 I2C transfer completed */

 Extension code, do not participate */

 Stop detected, we don't know if it's for slave or master */

 Notify slave device */

 Pretend we did not handle the interrupt */

 Only handle interrupts addressed to us */

 Enable stop interrupts */

 Transmission or Reception */

 9 bit interrupt mode */

 Send data */

 NACK, stop transmitting */

 8 bit interrupt mode */

 Recv data */

 Set slave address */

	/*

	 * Wait for interrupt to finish. New slave irqs cannot happen because we

	 * cleared the slave address and, thus, only extension codes will be

	 * detected which do not use the slave ptr.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * I2C bus driver for Conexant Digicolor SoCs

 *

 * Author: Baruch Siach <baruch@tkos.co.il>

 *

 * Copyright (C) 2015 Paradox Innovation Ltd.

/*

 * Provides I2C support for Philips PNX010x/PNX4008 boards.

 *

 * Authors: Dennis Kovalev <dkovalev@ru.mvista.com>

 *	    Vitaly Wool <vwool@ru.mvista.com>

 *

 * 2004-2006 (c) MontaVista Software, Inc. This file is licensed under

 * the terms of the GNU General Public License version 2. This program

 * is licensed "as is" without any warranty of any kind, whether express

 * or implied.

 msec */

 Return value */

 Interface mode */

 I/O completion */

 Timeout */

 Data buffer */

 Length of data buffer */

 RX Bytes to order via TX */

 Rx FIFO reg (RO) */

 Tx FIFO reg (WO) */

 Status reg (RO) */

 Ctl reg */

 Clock divider low */

 Clock divider high */

 I2C address */

 Rx FIFO level (RO) */

 Tx FIFO level (RO) */

 Num of bytes Rx-ed (RO) */

 Num of bytes Tx-ed (RO) */

 Tx slave FIFO (RO) */

 Tx slave FIFO level (RO) */

/**

 * i2c_pnx_start - start a device

 * @slave_addr:		slave address

 * @alg_data:		pointer to local driver data structure

 *

 * Generate a START signal in the desired mode.

 Check for 7 bit slave addresses only */

 First, make sure bus is idle */

 Somebody else is monopolizing the bus */

 Sorry, we lost the bus */

	/*

	 * OK, I2C is enabled and we have the bus.

	 * Clear the current TDI and AFI status flags.

 Write the slave address, START bit and R/W bit */

/**

 * i2c_pnx_stop - stop a device

 * @alg_data:		pointer to local driver data structure

 *

 * Generate a STOP signal to terminate the master transaction.

 Only 1 msec max timeout due to interrupt context */

 Write a STOP bit to TX FIFO */

 Wait until the STOP is seen. */

 may be called from interrupt context */

/**

 * i2c_pnx_master_xmit - transmit data to slave

 * @alg_data:		pointer to local driver data structure

 *

 * Sends one byte of data to the slave

 We still have something to talk about... */

 Wait until the STOP is seen. */

 Disable master interrupts */

 zero-sized transfer */

 Disable master interrupts. */

 Stop timer. */

/**

 * i2c_pnx_master_rcv - receive data from slave

 * @alg_data:		pointer to local driver data structure

 *

 * Reads one byte data from the slave

	/* Check, whether there is already data,

	 * or we didn't 'ask' for it yet.

		/* 'Asking' is done asynchronously, e.g. dummy TX of several

		 * bytes is done before the first actual RX arrives in FIFO.

		 * Therefore, ordered bytes (via TX) are counted separately.

 Last byte, do not acknowledge next rcv. */

				/*

				 * Enable interrupt RFDAIE (data in Rx fifo),

				 * and disable DRMIE (need data for Tx)

			/*

			 * Now we'll 'ask' for data:

			 * For each byte we want to receive, we must

			 * write a (dummy) byte to the Tx-FIFO.

 Handle data. */

 Wait until the STOP is seen. */

 Disable master interrupts */

 Kill timer. */

 let's see what kind of event this is */

 We lost arbitration in the midst of a transfer */

 Disable master interrupts. */

 Stop timer, to prevent timeout. */

 Slave did not acknowledge, generate a STOP */

 Disable master interrupts. */

 Our return value. */

 Stop timer, to prevent timeout. */

		/*

		 * Two options:

		 * - Master Tx needs data.

		 * - There is data in the Rx-fifo

		 * The latter is only the case if we have requested for data,

		 * via a dummy write. (See 'i2c_pnx_master_rcv'.)

		 * We therefore check, as a sanity check, whether that interrupt

		 * has been enabled.

 Clear TDI and AFI bits */

 Reset master and disable interrupts */

		/* If there is data in the fifo's after transfer,

		 * flush fifo's by reset.

/**

 * i2c_pnx_xfer - generic transfer entry point

 * @adap:		pointer to I2C adapter structure

 * @msgs:		array of messages

 * @num:		number of messages

 *

 * Initiates the transfer

 Process transactions in a loop. */

 initialize the completion var */

 Enable master interrupt */

 Put start-code and slave-address on the bus. */

 Wait for completion */

 Clear TDI and AFI bits in case they are set. */

 Cleanup to be sure... */

		/*

		 * At this point, it is planned to add an OF timeout property.

		 * As soon as there is a consensus about how to call and handle

		 * this, sth. like the following can be put here:

		 *

		 * of_property_read_u32(pdev->dev.of_node, "timeout",

		 *                      &alg_data->timeout);

 Register I/O resource */

	/*

	 * Clock Divisor High This value is the number of system clocks

	 * the serial clock (SCL) will be high.

	 * For example, if the system clock period is 50 ns and the maximum

	 * desired serial period is 10000 ns (100 kHz), then CLKHI would be

	 * set to 0.5*(f_sys/f_i2c)-2=0.5*(20e6/100e3)-2=98. The actual value

	 * programmed into CLKHI will vary from this slightly due to

	 * variations in the output pad's rise and fall times as well as

	 * the deglitching filter length.

 Register this adapter with the I2C subsystem */

 We need to make sure I2C is initialized before USB */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Actions Semiconductor Owl SoC's I2C driver

 *

 * Copyright (c) 2014 Actions Semi Inc.

 * Author: David Liu <liuwei@actions-semi.com>

 *

 * Copyright (c) 2018 Linaro Ltd.

 * Author: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>

 I2C registers */

 I2Cx_CTL Bit Mask */

 I2Cx_STAT Bit Mask */

 I2Cx_CMD Bit Mask */

 I2Cx_FIFOCTL Bit Mask */

 I2Cc_FIFOSTAT Bit Mask */

 I2C bus timeout */

 Clear status registers */

 Reset FIFO */

 Wait 50ms for FIFO reset complete */

 Set clock divider factor */

 Handle NACK from slave */

 Clear NACK error bit by writing "1" */

 Handle bus error */

 Clear BUS error bit by writing "1" */

 Handle FIFO read */

 Handle the remaining bytes which were not sent */

 Clear pending interrupts */

 Check for Bus busy */

 Reset I2C controller */

 Set bus frequency */

	/*

	 * Spinlock should be released before calling reset FIFO and

	 * bus busy check since those functions may sleep

 Reset FIFO */

 Check for bus busy */

 Check for Arbitration lost */

 Enable/disable I2C controller interrupt */

	/*

	 * Select: FIFO enable, Master mode, Stop enable, Data count enable,

	 * Send start bit

 Handle repeated start condition */

 Set internal address length and enable repeated start */

 Write slave address */

 Write internal register address */

 Set address length */

 Set data count for the message */

 Write data to FIFO */

 Check for FIFO full */

 Ignore the NACK if needed */

 Start the transfer */

 Wait for Command Execute Completed or NACK Error bits */

 Send stop condition and release the bus */

 Disable I2C controller */

 We support only frequencies of 100k and 400k for now */

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0

/*

 * HiSilicon I2C Controller Driver for Kunpeng SoC

 *

 * Copyright (c) 2021 HiSilicon Technologies Co., Ltd.

 Intermediates for recording the transfer process */

 I2C bus configuration */

/*

 * Initialize the transfer information and start the I2C bus transfer.

 * We only configure the transfer and do some pre/post works here, and

 * wait for the transfer done. The major transfer process is performed

 * in the IRQ handler.

 Signal the SR bit when we start transferring a new message */

 Signal the STOP bit at the last frame of the last message */

 Update the transfer index after per message transfer is done. */

 Drain the rx fifo before finish the transfer */

/*

 * Helper function for calculating and configuring the HIGH and LOW

 * periods of SCL clock. The caller will pass the ratio of the

 * counts (divide / divisor) according to the target speed mode,

 * and the target registers.

 Total SCL clock cycles per speed period */

 Total HIGH level SCL clock cycles including edges */

 Total LOW level SCL clock cycles including edges */

 Fall edge SCL clock cycles */

 Rise edge SCL clock cycles */

 Calculated HIGH and LOW periods of SCL clock */

 For default condition force the bus speed to standard mode. */

 SPDX-License-Identifier: GPL-2.0

/*

 *  i2c Support for Atmel's AT91 Two-Wire Interface (TWI)

 *

 *  Copyright (C) 2011 Weinmann Medical GmbH

 *  Author: Nikolaus Voss <n.voss@weinmann.de>

 *

 *  Evolved from original work by:

 *  Copyright (C) 2004 Rick Bronson

 *  Converted to 2.6 by Andrew Victor <andrew@sanpeople.com>

 *

 *  Borrowed heavily from original work by:

 *  Copyright (C) 2000 Philip Edelbrock <phil@stimpy.netroedge.com>

 sentinel */

 due to errata, CLEAR cmd is not working */

 sentinel */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * i2c-amd756-s4882.c - i2c-amd756 extras for the Tyan S4882 motherboard

 *

 * Copyright (C) 2004, 2008 Jean Delvare <jdelvare@suse.de>

/*

 * We select the channels by sending commands to the Philips

 * PCA9556 chip at I2C address 0x18. The main adapter is used for

 * the non-multiplexed part of the bus, and 4 virtual adapters

 * are defined for the multiplexed addresses: 0x50-0x53 (memory

 * module EEPROM) located on channels 1-4, and 0x4c (LM63)

 * located on multiplexed channels 0 and 5-7. We define one

 * virtual adapter per CPU, which corresponds to two multiplexed

 * channels:

 *   CPU0: virtual adapter 1, channels 1 and 0

 *   CPU1: virtual adapter 2, channels 2 and 5

 *   CPU2: virtual adapter 3, channels 3 and 6

 *   CPU3: virtual adapter 4, channels 4 and 7

 Wrapper access functions for multiplexed SMBus */

 We exclude the multiplexed addresses */

/* We remember the last used channels combination so as to only switch

   channels when it is really needed. This greatly reduces the SMBus

   overhead, but also assumes that nobody will be writing to the PCA9556

 We exclude the non-multiplexed addresses */

 CPU0: channels 1 and 0 enabled */

 CPU1: channels 2 and 5 enabled */

 CPU2: channels 3 and 6 enabled */

 CPU3: channels 4 and 7 enabled */

 Configure the PCA9556 multiplexer */

 All I/O to output mode */

 Unregister physical bus */

 Define the 5 virtual adapters and algorithms structures */

 Fill in the new structures */

 Register virtual adapters */

 Restore physical bus */

 Restore physical bus */

/*

 * Copyright (c) 2003-2015 Broadcom Corporation

 *

 * This file is licensed under the terms of the GNU General Public

 * License version 2. This program is licensed "as is" without any

 * warranty of any kind, whether express or implied.

		/* interrupt after the first read to examine

		 * the length byte before proceeding further

	/*

	 * Update receive length. Re-read len to get the latest value,

	 * and then add 4 to have a minimum value that can be safely

	 * written. This is to account for the byte read above, the

	 * transfer in progress and any delays in the register I/O

 read length byte */

		/*

		 * We expect at least 2 interrupts for I2C_M_RECV_LEN

		 * transactions. The length is updated during the first

		 * interrupt, and the buffer contents are only copied

		 * during subsequent interrupts. If in case the interrupts

		 * get merged we would complete the transaction without

		 * copying out the bytes from RX fifo. To avoid this now we

		 * drain the fifo as and when data is available.

		 * We drained the rlen byte already, decrement total length

		 * by one.

abort transfer */

 account for error check byte */

 update remaining bytes and message length */

 SADDR ACK for SMBUS_QUICK */

 TX FIFO got empty, fill it up again */

 data is in FIFO, read it */

 Transfer complete */

	/*

	 * The controller uses 5 * SCL clock internally.

	 * So prescale value should be divided by 5.

 Reset FIFO */

 set slave addr */

 Build control word for transfer */

 read */

 10-bit address mode*/

 set FIFO threshold if reading */

 set data length to be transferred */

 fill fifo during tx */

 set interrupt mask */

 set cmd reg */

 update msg->len with actual received length */

 SMBAlert irq */

 sentinel */ },

 SPDX-License-Identifier: GPL-2.0-only

/*

 * SMBus driver for ACPI SMBus CMI

 *

 * Copyright (C) 2009 Crane Cai <crane.cai@amd.com>

 SMBUS HID definition as supported by Microsoft Windows */

 Some IBM BIOSes omit the leading underscore */

 SPDX-License-Identifier: GPL-2.0-only

/*

    i2c-isch.c - Linux kernel driver for Intel SCH chipset SMBus

    - Based on i2c-piix4.c

    Copyright (c) 1998 - 2002 Frodo Looijaard <frodol@dds.nl> and

    Philip Edelbrock <phil@netroedge.com>

    - Intel SCH support

    Copyright (c) 2007 - 2008 Jacob Jun Pan <jacob.jun.pan@intel.com>



/*

   Supports:

	Intel SCH chipsets (AF82US15W, AF82US15L, AF82UL11L)

   Note: we assume there can only be one device, with one SMBus interface.

 SCH SMBus address offsets */

 TSA */

 Other settings */

 I2C constants */

 backbone speed in kHz */

/*

 * Start the i2c transaction -- the i2c_access will prepare the transaction

 * and this function will execute it.

 * return 0 for success and others for failure.

 Make sure the SMBus host is ready to start transmitting */

 Can not be busy since we checked it in sch_access */

 start the transaction by setting bit 4 */

 If the SMBus is still busy, we give up */

 Clock stops and slave is stuck in mid-transmission */

 Completion clear failed */

/*

 * This is the main access entry for i2c-sch access

 * adap is i2c_adapter pointer, addr is the i2c device bus address, read_write

 * (0 for read and 1 for write), size is i2c transaction type and data is the

 * union of transaction for data to be transferred or data read from bus.

 * return 0 for success and others for failure.

 Make sure the SMBus host is not busy */

		/*

		 * We can't determine if we have 33 or 25 MHz clock for

		 * SMBus, so expect 33 MHz and calculate a bus clock of

		 * 100 kHz. If we actually run at 25 MHz the bus will be

		 * run ~75 kHz instead which should do no harm.

 Error in transaction */

 set up the sysfs linkage to our parent device */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * X-Gene SLIMpro I2C Driver

 *

 * Copyright (c) 2014, Applied Micro Circuits Corporation

 * Author: Feng Kan <fkan@apm.com>

 * Author: Hieu Le <hnle@apm.com>

 *

 * This driver provides support for X-Gene SLIMpro I2C device access

 * using the APM X-Gene SLIMpro mailbox driver.

 Operation time out in ms */

 Use I2C bus 1 only */

/*

 * SLIMpro I2C message encode

 *

 * dev		- Controller number (0-based)

 * chip		- I2C chip address

 * op		- SLIMPRO_IIC_READ or SLIMPRO_IIC_WRITE

 * proto	- SLIMPRO_IIC_SMB_PROTOCOL or SLIMPRO_IIC_I2C_PROTOCOL

 * addrlen	- Length of the address field

 * datalen	- Length of the data field

/*

 * Encode for upper address for block data

 PCC related defines */

 dma_buffer[0] is used for length */

/*

 * This function tests and clears a bitmask then returns its old value

	/*

	 * Response message format:

	 * mssg[0] is the return code of the operation

	 * mssg[1] is the first data word

	 * mssg[2] is NOT used

 Check if platform sends interrupt */

 Response message msg[1] contains the return value. */

 Copy the message to the PCC comm space */

 Check of invalid data or no device */

 Copy to destination */

/*

* Return list of supported functionality.

 Request mailbox channel */

		/*

		 * This is the shared communication region

		 * for the OS and Platform to communicate over.

 Setup I2C adapter */

 SPDX-License-Identifier: GPL-2.0-or-later

 ------------------------------------------------------------------------- */

 i2c-elektor.c i2c-hw access for PCF8584 style isa bus adaptes             */

 ------------------------------------------------------------------------- */

/*   Copyright (C) 1995-97 Simon G. Vogl

                   1998-99 Hans Berglund



 ------------------------------------------------------------------------- */

/* With some changes from Kyösti Mälkki <kmalkki@cc.hut.fi> and even

/* Partially rewriten by Oleg I. Vdovikin for mmapped support of

/* vdovikin: removed static struct i2c_pcf_isa gpi; code -

  this module in real supports only one device, due to missing arguments

  in some functions, called from the algo-pcf module. Sometimes it's

 ----- local functions ----------------------------------------------	*/

 enable irq if any specified for serial operation */

 API UP2000 needs some hardware fudging to make the write stick */

/* ------------------------------------------------------------------------

 * Encapsulate the above functions in the correct operations structure.

 * This is only done when more than one hardware adapter is supported.

	/* check to see we have memory mapped PCF8584 connected to the

 yeap, we've found cypress, let's check config */

				/* UP2000 board has this register set to 0xe1,

				   but the most significant bit as seems can be

				   reset during the proper initialisation

				   sequence if guys from API decides to do that

				   (so, we can even enable Tsunami Pchip

				/* so just check for ROMCS at 0xe0000,

				   ROMCS enabled for writes

 seems to be UP2000 like board */

					/* UP2000 drives ISA with

					   8.25 MHz (PCI/4) clock

 sanity checks for mmapped I/O */

 SPDX-License-Identifier: GPL-2.0

/*

 *  i2c Support for Atmel's AT91 Two-Wire Interface (TWI)

 *

 *  Copyright (C) 2011 Weinmann Medical GmbH

 *  Author: Nikolaus Voss <n.voss@weinmann.de>

 *

 *  Evolved from original work by:

 *  Copyright (C) 2004 Rick Bronson

 *  Converted to 2.6 by Andrew Victor <andrew@sanpeople.com>

 *

 *  Borrowed heavily from original work by:

 *  Copyright (C) 2000 Philip Edelbrock <phil@stimpy.netroedge.com>

 FIFO should be enabled immediately after the software reset */

 enable digital filter */

 enable advanced digital filter */

 enable analog filter */

/*

 * Calculate symmetric clock as stated in datasheet:

 * twi_clk = F_MAIN / (2 * (cdiv * (1 << ckdiv) + offset))

		/*

		 * hold time = HOLD + 3 x T_peripheral_clock

		 * Use clk rate in kHz to prevent overflows when computing

		 * hold.

		/*

		 * filter width = 0 to AT91_TWI_FILTR_THRES_MAX

		 * peripheral clocks

 8bit write works with and without FIFO */

 send stop when last byte has been written */

	/*

	 * When this callback is called, THR/TX FIFO is likely not to be empty

	 * yet. So we have to wait for TXCOMP or NACK bits to be set into the

	 * Status Register to be sure that the STOP bit has been sent and the

	 * transfer is completed. The NACK interrupt has already been enabled,

	 * we just have to enable TXCOMP one.

		/*

		 * DMA controller is triggered when at least 4 data can be

		 * written into the TX FIFO

	/*

	 * If we are in this case, it means there is garbage data in RHR, so

	 * delete them.

 8bit read works with and without FIFO */

 return if aborting, we only needed to read RHR to clear RXRDY*/

 handle I2C_SMBUS_BLOCK_DATA */

 ensure length byte is a valid value */

 abort and send the stop by reading one more byte */

 send stop if second but last byte has been read */

 The last two bytes have to be read without using dma */

 Keep in mind that we won't use dma to read the last two bytes */

		/*

		 * DMA controller is triggered when at least 4 data can be

		 * read from the RX FIFO

	/*

	 * In reception, the behavior of the twi device (before sama5d2) is

	 * weird. There is some magic about RXRDY flag! When a data has been

	 * almost received, the reception of a new one is anticipated if there

	 * is no stop command to send. That is the reason why ask for sending

	 * the stop command not on the last data but on the second last one.

	 *

	 * Unfortunately, we could still have the RXRDY flag set even if the

	 * transfer is done and we have read the last data. It might happen

	 * when the i2c slave device sends too quickly data after receiving the

	 * ack from the master. The data has been almost received before having

	 * the order to send stop. In this case, sending the stop command could

	 * cause a RXRDY interrupt with a TXCOMP one. It is better to manage

	 * the RXRDY interrupt first in order to not keep garbage data in the

	 * Receive Holding Register for the next transfer.

		/*

		 * Read all available bytes at once by polling RXRDY usable w/

		 * and w/o FIFO. With FIFO enabled we could also read RXFL and

		 * avoid polling RXRDY.

	/*

	 * When a NACK condition is detected, the I2C controller sets the NACK,

	 * TXCOMP and TXRDY bits all together in the Status Register (SR).

	 *

	 * 1 - Handling NACK errors with CPU write transfer.

	 *

	 * In such case, we should not write the next byte into the Transmit

	 * Holding Register (THR) otherwise the I2C controller would start a new

	 * transfer and the I2C slave is likely to reply by another NACK.

	 *

	 * 2 - Handling NACK errors with DMA write transfer.

	 *

	 * By setting the TXRDY bit in the SR, the I2C controller also triggers

	 * the DMA controller to write the next data into the THR. Then the

	 * result depends on the hardware version of the I2C controller.

	 *

	 * 2a - Without support of the Alternative Command mode.

	 *

	 * This is the worst case: the DMA controller is triggered to write the

	 * next data into the THR, hence starting a new transfer: the I2C slave

	 * is likely to reply by another NACK.

	 * Concurrently, this interrupt handler is likely to be called to manage

	 * the first NACK before the I2C controller detects the second NACK and

	 * sets once again the NACK bit into the SR.

	 * When handling the first NACK, this interrupt handler disables the I2C

	 * controller interruptions, especially the NACK interrupt.

	 * Hence, the NACK bit is pending into the SR. This is why we should

	 * read the SR to clear all pending interrupts at the beginning of

	 * at91_do_twi_transfer() before actually starting a new transfer.

	 *

	 * 2b - With support of the Alternative Command mode.

	 *

	 * When a NACK condition is detected, the I2C controller also locks the

	 * THR (and sets the LOCK bit in the SR): even though the DMA controller

	 * is triggered by the TXRDY bit to write the next data into the THR,

	 * this data actually won't go on the I2C bus hence a second NACK is not

	 * generated.

 catch error flags */

	/*

	 * WARNING: the TXCOMP bit in the Status Register is NOT a clear on

	 * read flag but shows the state of the transmission at the time the

	 * Status Register is read. According to the programmer datasheet,

	 * TXCOMP is set when both holding register and internal shifter are

	 * empty and STOP condition has been sent.

	 * Consequently, we should enable NACK interrupt rather than TXCOMP to

	 * detect transmission failure.

	 * Indeed let's take the case of an i2c write command using DMA.

	 * Whenever the slave doesn't acknowledge a byte, the LOCK, NACK and

	 * TXCOMP bits are set together into the Status Register.

	 * LOCK is a clear on write bit, which is set to prevent the DMA

	 * controller from sending new data on the i2c bus after a NACK

	 * condition has happened. Once locked, this i2c peripheral stops

	 * triggering the DMA controller for new data but it is more than

	 * likely that a new DMA transaction is already in progress, writing

	 * into the Transmit Holding Register. Since the peripheral is locked,

	 * these new data won't be sent to the i2c bus but they will remain

	 * into the Transmit Holding Register, so TXCOMP bit is cleared.

	 * Then when the interrupt handler is called, the Status Register is

	 * read: the TXCOMP bit is clear but NACK bit is still set. The driver

	 * manage the error properly, without waiting for timeout.

	 * This case can be reproduced easyly when writing into an at24 eeprom.

	 *

	 * Besides, the TXCOMP bit is already set before the i2c transaction

	 * has been started. For read transactions, this bit is cleared when

	 * writing the START bit into the Control Register. So the

	 * corresponding interrupt can safely be enabled just after.

	 * However for write transactions managed by the CPU, we first write

	 * into THR, so TXCOMP is cleared. Then we can safely enable TXCOMP

	 * interrupt. If TXCOMP interrupt were enabled before writing into THR,

	 * the interrupt handler would be called immediately and the i2c command

	 * would be reported as completed.

	 * Also when a write transaction is managed by the DMA controller,

	 * enabling the TXCOMP interrupt in this function may lead to a race

	 * condition since we don't know whether the TXCOMP interrupt is enabled

	 * before or after the DMA has started to write into THR. So the TXCOMP

	 * interrupt is enabled later by at91_twi_write_data_dma_callback().

	 * Immediately after in that DMA callback, if the alternative command

	 * mode is not used, we still need to send the STOP condition manually

	 * writing the corresponding bit into the Control Register.

 Clear pending interrupts, such as NACK. */

 Reset FIFO mode register */

 Flush FIFOs */

 if only one byte is to be read, immediately stop transfer */

		/*

		 * When using dma without alternative command mode, the last

		 * byte has to be read manually in order to not send the stop

		 * command too late and then to receive extra data.

		 * In practice, there are some issues if you use the dma to

		 * read n-1 bytes because of latency.

		 * Reading n-2 bytes with dma and the two last ones manually

		 * seems to be the best solution.

 first stop DMA transfer if still in progress */

 then flush THR/FIFO and unlock TX if locked */

	/*

	 * some faulty I2C slave devices might hold SDA down;

	 * we can send a bus clear command, hoping that the pins will be

	 * released

 1st msg is put into the internal address, start with 2nd */

/*

 * The hardware can handle at most two messages concatenated by a

 * repeated start via it's internal address feature.

	/*

	 * The actual width of the access will be chosen in

	 * dmaengine_prep_slave_sg():

	 * for each buffer in the scatter-gather list, if its size is aligned

	 * to addr_width then addr_width accesses will be performed to transfer

	 * the buffer. On the other hand, if the buffer size is not aligned to

	 * addr_width then the buffer is transferred using single byte accesses.

	 * Please refer to the Atmel eXtended DMA controller driver.

	 * When FIFOs are used, the TXRDYM threshold can always be set to

	 * trigger the XDMAC when at least 4 data can be written into the TX

	 * FIFO, even if single byte accesses are performed.

	 * However the RXRDYM threshold must be set to fit the access width,

	 * deduced from buffer length, so the XDMAC is triggered properly to

	 * read data from the RX FIFO.

 SPDX-License-Identifier: GPL-2.0

/*

 * drivers/i2c/busses/i2c-mt7621.c

 *

 * Copyright (C) 2013 Steven Liu <steven_liu@mediatek.com>

 * Copyright (C) 2016 Michael Lee <igvtee@gmail.com>

 * Copyright (C) 2018 Jan Breuer <jan.breuer@jaybee.cz>

 *

 * Improve driver for i2cdetect from i2c-tools to detect i2c devices on the bus.

 * (C) 2014 Sittisak <sittisaks@hotmail.com>

 REG_SM0CFG2_REG */

 REG_SM0CTL0_REG */

 REG_SM0CTL1_REG */

 timeout waiting for I2C devices to respond */

	/*

	 * Don't set SM0CTL0_ODRAIN as its bit meaning is inverted. To

	 * configure open-drain mode, this bit needs to be cleared.

 wait hardware idle */

 start sequence */

 write address */

 10 bits address */

 7 bits address */

 check address ACK */

 transfer data */

 the return value is number of executed messages */

 sentinel */ }

/*

 * Copyright (C) 2014 Broadcom Corporation

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License as

 * published by the Free Software Foundation version 2.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

/*

 * PER_I2C/BSC count register mask depends on 1 byte/4 byte data register

 * size. Cable modem and DSL SoCs with Peripheral i2c cores use 1 byte per

 * data register whereas STB SoCs use 4 byte per data register transfer,

 * account for this difference in total count per transaction and mask to

 * use.

 BSC CTL register field definitions */

 BSC_IIC_ENABLE r/w enable and interrupt field definitions */

 BSC_CTLHI control register field definitions */

 msecs */

 Condition mask used for non combined transfer */

 BSC data transfer direction */

 BSC data transfer direction combined format */

 BSC block register map structure to cache fields to be written */

 slave address */

 tx data buffer*/

 rx/tx data length */

 control register */

 xfer enable and status */

 rx data buffer */

 more control fields */

 reserved */

 register accessors for both be and le cpu arch */

 Enable BSC  CTL interrupt line */

 Disable BSC CTL interrupt line */

 Wait for device to be ready */

 i2c xfer completion function, handles both irq and polling mode */

 we are in polling mode */

 Set xfer START/STOP conditions for subsequent transfer */

 Send I2C request check completion */

 Make sure the hardware is ready */

 only if we are in interrupt mode */

 enable BSC CTL interrupt line */

 initiate transfer by setting iic_enable */

 Wait for transaction to finish or timeout */

 Actual data transfer through the BSC master */

 see if the transaction needs to check NACK conditions */

 set data transfer direction */

 set the read/write length */

 Write data into data_in register */

 Initiate xfer, the function will return on completion */

 Read data from data_out register */

 Write a single byte of data to the i2c bus */

 Send i2c address */

 First byte is 11110XX0 where XX is upper 2 bits */

 Second byte is the remaining 8 bits */

 For read, send restart without stop condition */

 Then re-send the first byte with the read bit set */

 Master transfer function */

 Loop through all messages */

 Send slave address */

 Perform data transfer */

 in case we did not get find a valid speed */

 set 4 byte data in/out xfers  */

 set bus speed */

 Map hardware registers */

 We need to reset the controller after the release */

 Allocate memory for private data structure */

 Map hardware registers */

 Get the interrupt number */

 disable the bsc interrupt line */

 register the ISR handler */

 set the data in/out register size for compatible SoCs */

 Add the i2c adapter */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * I2C bus driver for the Cadence I2C controller.

 *

 * Copyright (C) 2009 - 2014 Xilinx, Inc.

 Register offsets for the I2C device. */

 Control Register, RW */

 Status Register, RO */

 I2C Address Register, RW */

 I2C Data Register, RW */

 IRQ Status Register, RW */

 Transfer Size Register, RW */

 Time Out Register, RW */

 IRQ Mask Register, RO */

 IRQ Enable Register, WO */

 IRQ Disable Register, WO */

 Control Register Bit mask definitions */

 Hold Bus bit */

 Read or Write Master transfer 0 = Transmitter, 1 = Receiver */

 1 = Auto init FIFO to zeroes */

 Status Register Bit mask definitions */

/*

 * I2C Address Register Bit mask definitions

 * Normal addressing mode uses [6:0] bits. Extended addressing mode uses [9:0]

 * bits. A write access to this register always initiates a transfer if the I2C

 * is in master mode.

 I2C Address Mask */

/*

 * I2C Interrupt Registers Bit mask definitions

 * All the four interrupt registers (Status/Mask/Enable/Disable) have the same

 * bit definitions.

 timeout for pm runtime autosuspend */

 ms */

 FIFO depth at which the DATA interrupt occurs */

 Transfer size in multiples of data interrupt depth */

/**

 * enum cdns_i2c_mode - I2C Controller current operating mode

 *

 * @CDNS_I2C_MODE_SLAVE:       I2C controller operating in slave mode

 * @CDNS_I2C_MODE_MASTER:      I2C Controller operating in master mode

/**

 * enum cdns_i2c_slave_state - Slave state when I2C is operating in slave mode

 *

 * @CDNS_I2C_SLAVE_STATE_IDLE: I2C slave idle

 * @CDNS_I2C_SLAVE_STATE_SEND: I2C slave sending data to master

 * @CDNS_I2C_SLAVE_STATE_RECV: I2C slave receiving data from master

/**

 * struct cdns_i2c - I2C device private data structure

 *

 * @dev:		Pointer to device structure

 * @membase:		Base address of the I2C device

 * @adap:		I2C adapter instance

 * @p_msg:		Message pointer

 * @err_status:		Error status in Interrupt Status Register

 * @xfer_done:		Transfer complete status

 * @p_send_buf:		Pointer to transmit buffer

 * @p_recv_buf:		Pointer to receive buffer

 * @send_count:		Number of bytes still expected to send

 * @recv_count:		Number of bytes still expected to receive

 * @curr_recv_count:	Number of bytes to be received in current transfer

 * @irq:		IRQ number

 * @input_clk:		Input clock to I2C controller

 * @i2c_clk:		Maximum I2C clock speed

 * @bus_hold_flag:	Flag used in repeated start for clearing HOLD bit

 * @clk:		Pointer to struct clk

 * @clk_rate_change_nb:	Notifier block for clock rate changes

 * @quirks:		flag for broken hold bit usage in r1p10

 * @ctrl_reg:		Cached value of the control register.

 * @ctrl_reg_diva_divb: value of fields DIV_A and DIV_B from CR register

 * @slave:		Registered slave instance.

 * @dev_mode:		I2C operating role(master/slave).

 * @slave_state:	I2C Slave state(idle/read/write).

/**

 * cdns_i2c_clear_bus_hold - Clear bus hold bit

 * @id:	Pointer to driver data struct

 *

 * Helper to clear the controller's bus hold bit.

 Disable all interrupts */

 Clear FIFO and transfer size */

 Update device mode and state */

 Enable i2c master */

		/*

		 * This delay is needed to give the IP some time to switch to

		 * the master mode. With lower values(like 110 us) i2cdetect

		 * will not detect any slave and without this delay, the IP will

		 * trigger a timeout interrupt.

 Enable i2c slave */

 Setting slave address */

 Enable slave send/receive interrupts */

 Prepare backend for data reception */

 Fetch number of bytes to receive */

 Read data and send to backend */

 Prepare backend for data transmission */

 Send data over bus */

/**

 * cdns_i2c_slave_isr - Interrupt handler for the I2C device in slave role

 * @ptr:       Pointer to I2C device private data

 *

 * This function handles the data interrupt and transfer complete interrupt of

 * the I2C device in slave role.

 *

 * Return: IRQ_HANDLED always

 Fetch the interrupt status */

 Ignore masked interrupts */

 Fetch transfer mode (send/receive) */

 Handle data send/receive */

 Send data to master */

 Receive data from master */

 Master indicated xfer stop or fifo underflow/overflow */

/**

 * cdns_i2c_master_isr - Interrupt handler for the I2C device in master role

 * @ptr:       Pointer to I2C device private data

 *

 * This function handles the data interrupt, transfer complete interrupt and

 * the error interrupts of the I2C device in master role.

 *

 * Return: IRQ_HANDLED always

 Signal completion only after everything is updated */

 Handling nack and arbitration lost interrupt */

	/*

	 * Check if transfer size register needs to be updated again for a

	 * large data receive operation.

 When receiving, handle data interrupt and completion interrupt */

 Read data if receive data valid is set */

				/*

				 * Clear hold bit that was set for FIFO control

				 * if RX data left is less than or equal to

				 * FIFO DEPTH unless repeated start is selected

		/*

		 * The controller sends NACK to the slave when transfer size

		 * register reaches zero without considering the HOLD bit.

		 * This workaround is implemented for large data transfers to

		 * maintain transfer size non-zero while performing a large

		 * receive operation.

 wait while fifo is full */

			/*

			 * Check number of bytes to be received against maximum

			 * transfer size and update register accordingly.

 Set the slave address in address register*/

 Clear hold (if not repeated start) and signal completion */

 When sending, handle transfer complete interrupt */

		/*

		 * If there is more data to be sent, calculate the

		 * space available in FIFO and fill with that many bytes.

			/*

			 * Signal the completion of transaction and

			 * clear the hold bus bit if there are no

			 * further messages to be processed.

 Update the status for errors */

/**

 * cdns_i2c_isr - Interrupt handler for the I2C device

 * @irq:	irq number for the I2C device

 * @ptr:	void pointer to cdns_i2c structure

 *

 * This function passes the control to slave/master based on current role of

 * i2c controller.

 *

 * Return: IRQ_HANDLED always

/**

 * cdns_i2c_mrecv - Prepare and start a master receive operation

 * @id:		pointer to the i2c device structure

 Put the controller in master receive mode and clear the FIFO */

	/*

	 * Check for the message size against FIFO depth and set the

	 * 'hold bus' bit if it is greater than FIFO depth.

 Clear the interrupts in interrupt status register */

	/*

	 * The no. of bytes to receive is checked against the limit of

	 * max transfer size. Set transfer size register with no of bytes

	 * receive if it is less than transfer size and transfer size if

	 * it is more. Enable the interrupts.

 Determine hold_clear based on number of bytes to receive and hold flag */

		/*

		 * In case of Xilinx Zynq SOC, clear the HOLD bit before transfer size

		 * register reaches '0'. This is an IP bug which causes transfer size

		 * register overflow to 0xFF. To satisfy this timing requirement,

		 * disable the interrupts on current processor core between register

		 * writes to slave address register and control register.

 Read it back to avoid bufferring and make sure write happens */

/**

 * cdns_i2c_msend - Prepare and start a master send operation

 * @id:		pointer to the i2c device

 Set the controller in Master transmit mode and clear the FIFO. */

	/*

	 * Check for the message size against FIFO depth and set the

	 * 'hold bus' bit if it is greater than FIFO depth.

 Clear the interrupts in interrupt status register. */

	/*

	 * Calculate the space available in FIFO. Check the message length

	 * against the space available, and fill the FIFO accordingly.

	 * Enable the interrupts.

	/*

	 * Clear the bus hold flag if there is no more data

	 * and if it is the last message.

 Set the slave address in address register - triggers operation. */

/**

 * cdns_i2c_master_reset - Reset the interface

 * @adap:	pointer to the i2c adapter driver instance

 *

 * This function cleanup the fifos, clear the hold bit and status

 * and disable the interrupts.

 Disable the interrupts */

 Clear the hold bit and fifos */

 Update the transfercount register to zero */

 Clear the interrupt status register */

 Clear the status register */

 Check for the TEN Bit mode on each msg */

 Check for the R/W flag on each msg */

 Wait for the signal of completion */

 If it is bus arbitration error, try again */

/**

 * cdns_i2c_master_xfer - The main i2c transfer function

 * @adap:	pointer to the i2c adapter driver instance

 * @msgs:	pointer to the i2c message structure

 * @num:	the number of messages to transfer

 *

 * Initiates the send/recv activity based on the transfer message received.

 *

 * Return: number of msgs processed on success, negative error otherwise

 Check i2c operating mode and switch if possible */

 Set mode to master */

 Mark flag to change role once xfer is completed */

 Check if the bus is free */

	/*

	 * Set the flag to one when multiple messages are to be

	 * processed with a repeated start.

		/*

		 * This controller does not give completion interrupt after a

		 * master receive message if HOLD bit is set (repeated start),

		 * resulting in SW timeout. Hence, if a receive message is

		 * followed by any other message, an error is returned

		 * indicating that this sequence is not supported.

 Process the msg one by one */

 Report the other error interrupts to application */

 Switch i2c mode to slave */

/**

 * cdns_i2c_func - Returns the supported features of the I2C driver

 * @adap:	pointer to the i2c adapter structure

 *

 * Return: 32 bit value, each bit corresponding to a feature

 Store slave information */

 Enable I2C slave */

 Remove slave information */

 Enable I2C master */

/**

 * cdns_i2c_calc_divs - Calculate clock dividers

 * @f:		I2C clock frequency

 * @input_clk:	Input clock frequency

 * @a:		First divider (return value)

 * @b:		Second divider (return value)

 *

 * f is used as input and output variable. As input it is used as target I2C

 * frequency. On function exit f holds the actually resulting I2C frequency.

 *

 * Return: 0 on success, negative errno otherwise.

 calculate (divisor_a+1) x (divisor_b+1) */

	/*

	 * If the calculated value is negative or 0, the fscl input is out of

	 * range. Return error.

/**

 * cdns_i2c_setclk - This function sets the serial clock rate for the I2C device

 * @clk_in:	I2C clock input frequency in Hz

 * @id:		Pointer to the I2C device structure

 *

 * The device must be idle rather than busy transferring data before setting

 * these device options.

 * The data rate is set by values in the control register.

 * The formula for determining the correct register values is

 *	Fscl = Fpclk/(22 x (divisor_a+1) x (divisor_b+1))

 * See the hardware data sheet for a full explanation of setting the serial

 * clock rate. The clock can not be faster than the input clock divide by 22.

 * The two most common clock rates are 100KHz and 400KHz.

 *

 * Return: 0 on success, negative error otherwise

/**

 * cdns_i2c_clk_notifier_cb - Clock rate change callback

 * @nb:		Pointer to notifier block

 * @event:	Notification reason

 * @data:	Pointer to notification data object

 *

 * This function is called when the cdns_i2c input clock frequency changes.

 * The callback checks whether a valid bus frequency can be generated after the

 * change. If so, the change is acknowledged, otherwise the change is aborted.

 * New dividers are written to the HW in the pre- or post change notification

 * depending on the scaling direction.

 *

 * Return:	NOTIFY_STOP if the rate change should be aborted, NOTIFY_OK

 *		to acknowledge the change, NOTIFY_DONE if the notification is

 *		considered irrelevant.

 scale up */

 scale down */

 scale up */

/**

 * cdns_i2c_runtime_suspend -  Runtime suspend method for the driver

 * @dev:	Address of the platform_device structure

 *

 * Put the driver into low power mode.

 *

 * Return: 0 always

/**

 * cdns_i2c_init -  Controller initialisation

 * @id:		Device private data structure

 *

 * Initialise the i2c controller.

 *

	/*

	 * Cadence I2C controller has a bug wherein it generates

	 * invalid read transaction after HW timeout in master receiver mode.

	 * HW timeout is not used by this driver and the interrupt is disabled.

	 * But the feature itself cannot be disabled. Hence maximum value

	 * is written to this register to reduce the chances of error.

/**

 * cdns_i2c_runtime_resume - Runtime resume

 * @dev:	Address of the platform_device structure

 *

 * Runtime resume callback.

 *

 * Return: 0 on success and error value on error

 end of table */ }

/**

 * cdns_i2c_probe - Platform registration call

 * @pdev:	Handle to the platform device structure

 *

 * This function does all the memory allocation and registration for the i2c

 * device. User can modify the address mode to 10 bit address mode using the

 * ioctl call with option I2C_TENBIT.

 *

 * Return: 0 on success, negative error otherwise

 Default retry value. */

 Set initial mode to master */

/**

 * cdns_i2c_remove - Unregister the device after releasing the resources

 * @pdev:	Handle to the platform device structure

 *

 * This function frees all the resources allocated to the device.

 *

 * Return: 0 always

 SPDX-License-Identifier: GPL-2.0

/*

 * Intel BayTrail PMIC I2C bus semaphore implementation

 * Copyright (c) 2014, Intel Corporation.

 SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause

/*

 * AMD MP2 PCIe communication driver

 *

 * Authors: Shyam Sundar S K <Shyam-sundar.S-k@amd.com>

 *          Elie Morisse <syniurge@gmail.com>

 there is only one data mailbox for two i2c adapters */

 Set up intx irq */

 CONFIG_PM */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

    Copyright (c) 1999  Frodo Looijaard <frodol@dds.nl> and

    Philip Edelbrock <phil@netroedge.com> and

    Mark D. Studebaker <mdsxyz123@yahoo.com>



/*

    This is the driver for the SMB Host controller on

    Acer Labs Inc. (ALI) M1541 and M1543C South Bridges.



    The M1543C is a South bridge for desktop systems.

    The M1533 is a South bridge for portable systems.

    They are part of the following ALI chipsets:

       "Aladdin Pro 2": Includes the M1621 Slot 1 North bridge

       with AGP and 100MHz CPU Front Side bus

       "Aladdin V": Includes the M1541 Socket 7 North bridge

       with AGP and 100MHz CPU Front Side bus

       "Aladdin IV": Includes the M1541 Socket 7 North bridge

       with host bus up to 83.3 MHz.

    For an overview of these chips see http://www.acerlabs.com



    The M1533/M1543C devices appear as FOUR separate devices

    on the PCI bus. An output of lspci will show something similar

    to the following:



	00:02.0 USB Controller: Acer Laboratories Inc. M5237

	00:03.0 Bridge: Acer Laboratories Inc. M7101

	00:07.0 ISA bridge: Acer Laboratories Inc. M1533

	00:0f.0 IDE interface: Acer Laboratories Inc. M5229



    The SMB controller is part of the 7101 device, which is an

    ACPI-compliant Power Management Unit (PMU).



    The whole 7101 device has to be enabled for the SMB to work.

    You can't just enable the SMB alone.

    The SMB and the ACPI have separate I/O spaces.

    We make sure that the SMB is enabled. We leave the ACPI alone.



    This driver controls the SMB Host only.

    The SMB Slave controller on the M15X3 is not enabled.



    This driver does not use interrupts.

 Note: we assume there can only be one ALI15X3, with one SMBus interface */

 ALI15X3 SMBus address offsets */

 PCI Address Constants */

 used to unlock xxxBA registers */

 Other settings */

 times 1/100 sec */

/* this is what the Award 1004 BIOS sets them to on a ASUS P5A MB.

   We don't use these here. If the bases aren't set to some value we

   tell user to upgrade BIOS and we fail.

 ALI15X3 address lock bits */

 ALI15X3 command constants */

 ALI15X3 status register bits */

 device error */

 collision or no response */

 terminated by abort */

 all the bad error bits */

/* If force_addr is set to anything different from 0, we forcibly enable

	/* Check the following things:

		- SMB I/O address is initialized

		- Device is enabled

		- We can use the addresses

	/* Unlock the register.

	   The data sheet says that the address registers are read-only

	   if the lock bits are 1, but in fact the address registers

	   are zero unless you clear the lock bits.

 Determine the address of the SMBus area */

 make sure it works */

 check if whole device is enabled */

 Is SMB Host controller enabled? */

 set SMB clock to 74KHz as recommended in data sheet */

	/*

	  The interrupt routing for SMB is set up in register 0x77 in the

	  1533 ISA Bridge device, NOT in the 7101 device.

	  Don't bother with finding the 1533 device and reading the register.

	if ((....... & 0x0F) == 1)

		dev_dbg(&ALI15X3_dev->dev, "ALI15X3 using Interrupt 9 for SMBus.\n");

 Another internally used function */

 get status */

 Make sure the SMBus host is ready to start transmitting */

 Check the busy bit first */

	/*

	   If the host controller is still busy, it may have timed out in the

	   previous transaction, resulting in a "SMBus Timeout" Dev.

	   I've tried the following to reset a stuck busy bit.

		1. Reset the controller with an ABORT command.

		   (this doesn't seem to clear the controller if an external

		   device is hung)

		2. Reset the controller and the other SMBus devices with a

		   T_OUT command.  (this clears the host busy bit if an

		   external device is hung, but it comes back upon a new access

		   to a device)

		3. Disable and reenable the controller in SMBHSTCFG

	   Worst case, nothing seems to work except power reset.

 Abort - reset the host controller */

	/*

	   Try resetting entire SMB bus, including other devices -

	   This may not work either - it clears the BUSY bit but

	   then the BUSY bit may come back on when you try and use the chip again.

	   If that's the case you are stuck.

 now check the error bits and the busy bit */

 do a clear-on-write */

			/* this is probably going to be correctable only by a power reset

 This may be a bus or device with electrical problems. */

 check and clear done bit */

 start the transaction by writing anything to the start register */

 We will always wait for a fraction of a second! */

 If the SMBus is still busy, we give up */

	/*

	  Unfortunately the ALI SMB controller maps "no response" and "bus

	  collision" into a single bit. No response is the usual case so don't

	  do a printk.

	  This means that bus collisions go unreported.

 haven't ever seen this */

 Return negative errno on error. */

 clear all the bits (clear-on-write) */

 make sure SMBus is idle */

 Reset SMBBLKDAT */

 output command */

 Result put in SMBHSTDAT0 */

 Reset SMBBLKDAT */

 set up the sysfs linkage to our parent device */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2006-2007 PA Semi, Inc

 *

 * SMBus host driver for PA Semi PWRficient

 Register offsets */

 Register defs */

 Got NACK? */

 Clear XEN */

 All our ops take 8-bit shifted addresses */

 set up the sysfs linkage to our parent device */

/*

 * (C) Copyright 2009-2010

 * Nokia Siemens Networks, michael.lawnick.ext@nsn.com

 *

 * Portions Copyright (C) 2010 - 2016 Cavium, Inc.

 *

 * This is a driver for the i2c adapter in Cavium Networks' OCTEON processors.

 *

 * This file is licensed under the terms of the GNU General Public

 * License version 2. This program is licensed "as is" without any

 * warranty of any kind, whether express or implied.

/**

 * octeon_i2c_int_enable - enable the CORE interrupt

 * @i2c: The struct octeon_i2c

 *

 * The interrupt will be asserted when there is non-STAT_IDLE state in

 * the SW_TWSI_EOP_TWSI_STAT register.

 disable the CORE interrupt */

 clear TS/ST/IFLG events */

/**

 * octeon_i2c_int_enable78 - enable the CORE interrupt

 * @i2c: The struct octeon_i2c

 *

 * The interrupt will be asserted when there is non-STAT_IDLE state in the

 * SW_TWSI_EOP_TWSI_STAT register.

	/*

	 * The interrupt can be disabled in two places, but we only

	 * want to make the disable_irq_nosync() call once, so keep

	 * track with the atomic variable.

 disable the CORE interrupt */

/**

 * octeon_i2c_hlc_int_enable78 - enable the ST interrupt

 * @i2c: The struct octeon_i2c

 *

 * The interrupt will be asserted when there is non-STAT_IDLE state in

 * the SW_TWSI_EOP_TWSI_STAT register.

 disable the ST interrupt */

 HLC interrupt service routine */

 All adaptors have an irq.  */

	/*

	 * "clock-rate" is a legacy binding, the official binding is

	 * "clock-frequency".  Try the official one first and then

	 * fall back if it doesn't exist.

 SPDX-License-Identifier: GPL-2.0-only

 ------------------------------------------------------------------------- */

 i2c-iop3xx.c i2c driver algorithms for Intel XScale IOP3xx & IXP46x       */

 ------------------------------------------------------------------------- */

/* Copyright (C) 2003 Peter Milne, D-TACQ Solutions Ltd

 *                    <Peter dot Milne at D hyphen TACQ dot com>

 *

 * With acknowledgements to i2c-algo-ibm_ocp.c by

 * Ian DaSilva, MontaVista Software, Inc. idasilva@mvista.com

 *

 * And i2c-algo-pcf.c, which was created by Simon G. Vogl and Hans Berglund:

 *

 * Copyright (C) 1995-1997 Simon G. Vogl, 1998-2000 Hans Berglund

 *

 * And which acknowledged Kyösti Mälkki <kmalkki@cc.hut.fi>,

 * Frodo Looijaard <frodol@dds.nl>, Martin Bailey<mbailey@littlefeet-inc.com>

 *

 * Major cleanup by Deepak Saxena <dsaxena@plexity.net>, 01/2005:

 *

 * - Use driver model to pass per-chip info instead of hardcoding and #ifdefs

 * - Use ioremap/__raw_readl/__raw_writel instead of direct dereference

 * - Make it work with IXP46x chips

 * - Cleanup function names, coding style, etc

 *

 * - writing to slave address causes latchup on iop331.

 *	fix: driver refuses to address self.

 global unit counter */

 Follows devman 9.3 */

	/*

	 * Every time unit enable is asserted, GPOD needs to be cleared

	 * on IOP3XX to avoid data corruption on the bus. We use the

	 * gpiod_set_raw_value() to make sure the 0 hits the hardware

	 * GPOD register. These descriptors are only passed along to

	 * the device if this is necessary.

 NB SR bits not same position as CR IE bits :-( */

/*

 * NB: the handler has to clear the source of the interrupt!

 * Then it passes the SR flags of interest to BH via adap data

 check all error conditions, clear them , report most important */

/*

 * sleep until interrupted, then recover and analyse the SR

 * saved by handler

 returns 1 on correct comparison */

/*

 * Concrete compare_funcs

	/* avoid writing to my slave address (hangs on 80331),

	 * forbidden in Intel developer manual

/*

 * Description:  This function implements combined transactions.  Combined

 * transactions consist of combinations of reading and writing blocks of data.

 * FROM THE SAME ADDRESS

 * Each transfer (i.e. a read or a write) is separated by a repeated start

 * condition.

/*

 * master_xfer() - main read/write entry

	/*

	 * Disable the actual HW unit

 set the adapter enumeration # */

	/*

	 * Default values...should these come in from board code?

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2017-2018, The Linux Foundation. All rights reserved.

 M_CMD OP codes for I2C */

 M_CMD params for I2C */

 I2C SCL COUNTER fields */

/*

 * Hardware uses the underlying formula to calculate time periods of

 * SCL clock cycle. Firmware uses some additional cycles excluded from the

 * below formula and it is confirmed that the time periods are within

 * specification limits.

 *

 * time of high period of SCL: t_high = (t_high_cnt * clk_div) / source_clock

 * time of low period of SCL: t_low = (t_low_cnt * clk_div) / source_clock

 * time of full period of SCL: t_cycle = (t_cycle_cnt * clk_div) / source_clock

 * clk_freq_out = t / t_cycle

 * source_clock = 19.2 MHz

 Disable the TX Watermark interrupt to stop TX */

 TX Complete, Disable the TX Watermark interrupt */

 if this is err with done-bit not set, handle that through timeout. */

 Get FIFO IRQ */

 Set device in suspended since resume failed */

 Disable the interrupt so that the system can enter low-power mode */

	/*

	 * Set the bus quota for core and cpu to a reasonable value for

	 * register access.

	 * Set quota for DDR based on bus speed.

 Make client i2c transfers start failing */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

    SMBus driver for nVidia nForce2 MCP



    Added nForce3 Pro 150  Thomas Leibold <thomas@plx.com>,

	Ported to 2.5 Patrick Dreker <patrick@dreker.de>,

    Copyright (c) 2003  Hans-Frieder Vogt <hfvogt@arcor.de>,

    Based on

    SMBus 2.0 driver for AMD-8111 IO-Hub

    Copyright (c) 2002 Vojtech Pavlik



/*

    SUPPORTED DEVICES		PCI ID

    nForce2 MCP			0064

    nForce2 Ultra 400 MCP	0084

    nForce3 Pro150 MCP		00D4

    nForce3 250Gb MCP		00E4

    nForce4 MCP			0052

    nForce4 MCP-04		0034

    nForce MCP51		0264

    nForce MCP55		0368

    nForce MCP61		03EB

    nForce MCP65		0446

    nForce MCP67		0542

    nForce MCP73		07D8

    nForce MCP78S		0752

    nForce MCP79		0AA2



    This driver supports the 2 SMBuses that are included in the MCP of the

    nForce2/3/4/5xx chipsets.

 Note: we assume there can only be one nForce2, with two SMBus interfaces */

/*

 * nVidia nForce2 SMBus control register definitions

 * (Newer incarnations use standard BARs 4 and 5 instead)

/*

 * ACPI 2.0 chapter 13 SMBus 2.0 EC register model

 protocol, PEC */

 status */

 address */

 command */

 32 data registers */

#define NVIDIA_SMB_BCNT		(smbus->base + 0x24)	/* number of data

#define NVIDIA_SMB_STATUS_ABRT	(smbus->base + 0x3c)	/* register used to

							   check the status of

 control register */

#define NVIDIA_SMB_STATUS_ABRT_STS	0x01		/* Bit to notify that

 Misc definitions */

 We disable the second SMBus channel on these boards */

/* For multiplexing support, we need a global reference to the 1st

 Return negative errno on error */

 other functionality might be possible, but is not tested */

 Older incarnations of the device used non-standard BARs */

 we support 2 SMBus adapters */

 SMBus adapter 1 */

 to have a check value */

 SMBus adapter 2 */

 to have a check value */

 we did not find even one of the SMBuses, so we give up */

 SPDX-License-Identifier: GPL-2.0

/*

 * Driver for the Renesas R-Car I2C unit

 *

 * Copyright (C) 2014-19 Wolfram Sang <wsa@sang-engineering.com>

 * Copyright (C) 2011-2019 Renesas Electronics Corporation

 *

 * Copyright (C) 2012-14 Renesas Solutions Corp.

 * Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>

 *

 * This file is based on the drivers/i2c/busses/i2c-sh7760.c

 * (c) 2005-2008 MSC Vertriebsges.m.b.H, Manuel Lauss <mlau@msc-ge.com>

 register offsets */

 slave ctrl */

 master ctrl */

 slave status */

 master status */

 slave irq enable */

 master irq enable */

 clock dividers */

 slave address */

 master address */

 data port */

 first bit setup cycle (Gen3) */

 DMA enable (Gen3) */

 ICSCR */

 slave data buffer select */

 slave interface enable */

 general call address enable */

 forced non acknowledgment */

 ICMCR */

 non-fifo mode switch */

 override SCL pin */

 override SDA pin */

 override pins */

 master if enable */

 force stop bit */

 enable start bit gen */

 ICSSR (also for ICSIER) */

 general call received */

 slave transmit mode */

 stop received */

 slave data empty */

 slave data transmitted */

 slave data received */

 slave addr received */

 ICMSR (also for ICMIE) */

 nack received */

 arbitration lost */

 sent a stop */

 slave addr xfer done */

 ICDMAER */

 DMA Slave Received Enable */

 DMA Slave Transmitted Enable */

 DMA Master Received Enable */

 DMA Master Transmitted Enable */

 ICFBSCR */

 17*Tcyc delay 1st bit between SDA and SCL */

 persistent flags */

 HW forbids RXDMA sometimes */

 protected by adapter lock */

 reset master mode */

 start clock */

 Waiting did not help, try to recover */

 Fall back to previously used values if not supplied */

	/*

	 * calculate SCL clock

	 * see

	 *	ICCCR

	 *

	 * ick	= clkp / (1 + CDF)

	 * SCL	= ick / (20 + SCGD * 8 + F[(ticf + tr + intd) * ick])

	 *

	 * ick  : I2C internal clock < 20 MHz

	 * ticf : I2C SCL falling time

	 * tr   : I2C SCL rising  time

	 * intd : LSI internal delay

	 * clkp : peripheral_clk

	 * F[]  : integer up-valuation

	/*

	 * it is impossible to calculate large scale

	 * number on u32. separate it

	 *

	 * F[(ticf + tr + intd) * ick] with sum = (ticf + tr + intd)

	 *  = F[sum * ick / 1000000000]

	 *  = F[(ick / 1000000) * sum / 1000]

	/*

	 * SCL	= ick / (20 + SCGD * 8 + F[(ticf + tr + intd) * ick])

	 *

	 * Calculation result (= SCL) should be less than

	 * bus_speed for hardware safety

	 *

	 * We could use something along the lines of

	 *	div = ick / (bus_speed + 1) + 1;

	 *	scgd = (div - 20 - round + 7) / 8;

	 *	scl = ick / (20 + (scgd * 8) + round);

	 * (not fully verified) but that would get pretty involved

 keep icccr value */

	/*

	 * We don't have a test case but the HW engineers say that the write order

	 * of ICMSR and ICMCR depends on whether we issue START or REP_START. Since

	 * it didn't cause a drawback for me, let's rather be safe than sorry.

 Gen3 can only do one RXDMA per transfer and we just completed it */

 Disable DMA Master Received/Transmitted, must be last! */

 Do various checks to see if DMA is feasible at all */

		/*

		 * The last two bytes needs to be fetched using PIO in

		 * order for the STOP phase to work.

		/*

		 * First byte in message was sent using PIO.

 Enable DMA Master Received/Transmitted */

 FIXME: sometimes, unknown interrupt happened. Do nothing */

 Check if DMA can be enabled and take over */

		/*

		 * Prepare next data to ICRXTX register.

		 * This data will go to _SHIFT_ register.

		 *

		 *    *

		 * [ICRXTX] -> [SHIFT] -> [I2C bus]

		/*

		 * The last data was pushed to ICRXTX on _PREV_ empty irq.

		 * It is on _SHIFT_ register, and will sent to I2C bus.

		 *

		 *		  *

		 * [ICRXTX] -> [SHIFT] -> [I2C bus]

			/*

			 * If current msg is the _LAST_ msg,

			 * prepare stop condition here.

			 * ID_DONE will be set on STOP irq.

 FIXME: sometimes, unknown interrupt happened. Do nothing */

		/*

		 * Address transfer phase finished, but no data at this point.

		 * Try to use DMA to receive data.

 get received data */

 If next received data is the _LAST_, go to new phase. */

 address detected */

 read or write request */

 dummy read */

 Clear SSR, too, because of old STOPs to other clients than us */

 master sent stop */

 clear our NACK */

 master wants to write to us */

 Send NACK in case of error */

 master wants to read from us */

/*

 * This driver has a lock-free design because there are IP cores (at least

 * R-Car Gen2) which have an inherent race condition in their hardware design.

 * There, we need to switch to RCAR_BUS_PHASE_DATA as soon as possible after

 * the interrupt was generated, otherwise an unwanted repeated message gets

 * generated. It turned out that taking a spinlock at the beginning of the ISR

 * was already causing repeated messages. Thus, this driver was converted to

 * the now lockless behaviour. Please keep this in mind when hacking the driver.

 * R-Car Gen3 seems to have this fixed but earlier versions than R-Car Gen2 are

 * likely affected. Therefore, we have different interrupt handler entries.

 Arbitration lost */

 Nack */

 HW automatically sends STOP after received NACK */

 Stop */

 The last message also made it */

 Clear START or STOP immediately, except for REPSTART after read */

 Only handle interrupts that are currently enabled */

 Only handle interrupts that are currently enabled */

	/*

	 * Clear START or STOP immediately, except for REPSTART after read or

	 * if a spurious interrupt was detected.

 I2C is a special case, we need to poll the status of a reset */

 Check bus state before init otherwise bus busy info will be lost */

 Gen3 needs a reset before allowing RXDMA once */

 init first message */

 cleanup DMA if it couldn't complete properly due to an error */

 The number of transfer */

 Check bus state before init otherwise bus busy info will be lost */

 init first message */

 The number of transfer */

 Keep device active for slave address detection logic */

 ensure no irq is running before clearing ptr */

 Gen2: must be 0 if not using slave */

	/*

	 * This HW can't do:

	 * I2C_SMBUS_QUICK (setting FSB during START didn't work)

	 * I2C_M_NOSTART (automatically sends address after START)

	 * I2C_M_IGNORE_NAK (automatically sends STOP after NAK)

 Otherwise logic will break because some bytes must always use PIO */

 Init DMA */

 Activate device for clock calculation */

 Gen2: must be 0 if not using slave */

 Stay always active when multi-master to keep arbitration working */

 CONFIG_PM_SLEEP */

/*

 * Cavium ThunderX i2c driver.

 *

 * Copyright (C) 2015,2016 Cavium Inc.

 * Authors: Fred Martin <fmartin@caviumnetworks.com>

 *	    Jan Glauber <jglauber@cavium.com>

 *

 * This file is licensed under the terms of the GNU General Public

 * License version 2. This program is licensed "as is" without any

 * warranty of any kind, whether express or implied.

/*

 * Enable the CORE interrupt.

 * The interrupt will be asserted when there is non-STAT_IDLE state in the

 * SW_TWSI_EOP_TWSI_STAT register.

/*

 * Disable the CORE interrupt.

 DT */

 ACPI */

 TODO: ACPI support */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2009 ST-Ericsson SA

 * Copyright (C) 2009 STMicroelectronics

 *

 * I2C master mode controller driver, used in Nomadik 8815

 * and Ux500 platforms.

 *

 * Author: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>

 * Author: Sachin Verma <sachin.verma@st.com>

 I2C Controller register offsets */

 Control registers */

 Peripheral Enable */

 Operating mode */

 Slave addressing mode */

 Speed mode */

 Slave general call mode */

 Flush Transmit */

 Flush Receive */

 DMA Tx enable */

 DMA Rx Enable */

 DMA sync. logic enable */

 Loopback mode */

 Filtering on */

 Force stop enable */

 Master controller (MCR) register */

 Operation */

 7-bit address */

 10-bit Extended address */

 Extended address */

 Address type */

 Stop condition */

 Transaction length */

 Status register (SR) */

 Operation */

 controller status */

 Abort cause */

 Receive type */

 Transfer length */

 Interrupt mask set/clear (IMSCR) bits */

 some bits in ICR are reserved */

 first three msb bits are reserved */

 maximum threshold value */

 up to 100 Kb/s */

 up to 400 Kb/s */

 up to 3.4 Mb/s */

 up to 1 Mb/s */

/**

 * struct i2c_vendor_data - per-vendor variations

 * @has_mtdws: variant has the MTDWS bit

 * @fifodepth: variant FIFO depth

 operation */

/**

 * struct i2c_nmk_client - client specific data

 * @slave_adr: 7-bit slave address

 * @count: no. bytes to be transferred

 * @buffer: client data buffer

 * @xfer_bytes: bytes transferred till now

 * @operation: current I2C operation

/**

 * struct nmk_i2c_dev - private data structure of the controller.

 * @vendor: vendor data for this variant.

 * @adev: parent amba device.

 * @adap: corresponding I2C adapter.

 * @irq: interrupt line for the controller.

 * @virtbase: virtual io memory area.

 * @clk: hardware i2c block clock.

 * @cli: holder of client specific data.

 * @clk_freq: clock frequency for the operation mode

 * @tft: Tx FIFO Threshold in bytes

 * @rft: Rx FIFO Threshold in bytes

 * @timeout: Slave response timeout (ms)

 * @sm: speed mode

 * @stop: stop condition.

 * @xfer_complete: acknowledge completion for a I2C message.

 * @result: controller propogated result.

 controller's abort causes */

/**

 * flush_i2c_fifo() - This function flushes the I2C FIFO

 * @dev: private data of I2C Driver

 *

 * This function flushes the I2C Tx and Rx FIFOs. It returns

 * 0 on successful flushing of FIFO

	/*

	 * flush the transmit and receive FIFO. The flushing

	 * operation takes several cycles before to be completed.

	 * On the completion, the I2C internal logic clears these

	 * bits, until then no one must access Tx, Rx FIFO and

	 * should poll on these bits waiting for the completion.

/**

 * disable_all_interrupts() - Disable all interrupts of this I2c Bus

 * @dev: private data of I2C Driver

/**

 * clear_all_interrupts() - Clear all interrupts of I2C Controller

 * @dev: private data of I2C Driver

/**

 * init_hw() - initialize the I2C hardware

 * @dev: private data of I2C Driver

 disable the controller */

 enable peripheral, master mode operation */

/**

 * load_i2c_mcr_reg() - load the MCR register

 * @dev: private data of controller

 * @flags: message flags

 10-bit address transaction */

		/*

		 * Get the top 3 bits.

		 * EA10 represents extended address in MCR. This includes

		 * the extension (MSB bits) of the 7 bit address loaded

		 * in A7

 7-bit address transaction */

 start byte procedure not applied */

 check the operation, master read/write? */

 stop or repeated start? */

/**

 * setup_i2c_controller() - setup the controller

 * @dev: private data of controller

	/*

	 * set the slsu:

	 *

	 * slsu defines the data setup time after SCL clock

	 * stretching in terms of i2c clk cycles + 1 (zero means

	 * "wait one cycle"), the needed setup time for the three

	 * modes are 250ns, 100ns, 10ns respectively.

	 *

	 * As the time for one cycle T in nanoseconds is

	 * T = (1/f) * 1000000000 =>

	 * slsu = cycles / (1000000000 / f) + 1

 Fast */

 High */

 Standard */

	/*

	 * The spec says, in case of std. mode the divider is

	 * 2 whereas it is 3 for fast and fastplus mode of

	 * operation. TODO - high speed support.

	/*

	 * generate the mask for baud rate counters. The controller

	 * has two baud rate counters. One is used for High speed

	 * operation, and the other is for std, fast mode, fast mode

	 * plus operation. Currently we do not supprt high speed mode

	 * so set brcr1 to 0.

 set the baud rate counter register */

	/*

	 * set the speed mode. Currently we support

	 * only standard and fast mode of operation

	 * TODO - support for fast mode plus (up to 1Mb/s)

	 * and high speed (up to 3.4 Mb/s)

 set the Tx and Rx FIFO threshold */

/**

 * read_i2c() - Read from I2C client device

 * @dev: private data of I2C Driver

 * @flags: message flags

 *

 * This function reads from i2c client device when controller is in

 * master mode. There is a completion timeout. If there is no transfer

 * before timeout error is returned.

 load the current CR value */

 enable the controller */

 enable interrupts by setting the mask */

 Controller timed out */

 write to the Tx FIFO */

/**

 * write_i2c() - Write data to I2C client.

 * @dev: private data of I2C Driver

 * @flags: message flags

 *

 * This function writes data to I2C client

 load the current CR value */

 enable the controller */

 enable interrupts by settings the masks */

 Fill the TX FIFO with transmit data */

	/*

	 * check if we want to transfer a single or multiple bytes, if so

	 * set the MTDWS bit (Master Transaction Done Without Stop)

	 * to start repeated start operation

 Controller timed out */

/**

 * nmk_i2c_xfer_one() - transmit a single I2C message

 * @dev: device with a message encoded into it

 * @flags: message flags

 read operation */

 write operation */

		/*

		 * Check if the controller I2C operation status

		 * is set to ABORT(11b).

 get the abort cause */

/**

 * nmk_i2c_xfer() - I2C transfer function used by kernel framework

 * @i2c_adap: Adapter pointer to the controller

 * @msgs: Pointer to data to be written.

 * @num_msgs: Number of messages to be executed

 *

 * This is the function called by the generic kernel i2c_transfer()

 * or i2c_smbus...() API calls. Note that this code is protected by the

 * semaphore set in the kernel i2c_transfer() function.

 *

 * NOTE:

 * READ TRANSFER : We impose a restriction of the first message to be the

 *		index message for any read transaction.

 *		- a no index is coded as '0',

 *		- 2byte big endian index is coded as '3'

 *		!!! msg[0].buf holds the actual index.

 *		This is compatible with generic messages of smbus emulator

 *		that send a one byte index.

 *		eg. a I2C transation to read 2 bytes from index 0

 *			idx = 0;

 *			msg[0].addr = client->addr;

 *			msg[0].flags = 0x0;

 *			msg[0].len = 1;

 *			msg[0].buf = &idx;

 *

 *			msg[1].addr = client->addr;

 *			msg[1].flags = I2C_M_RD;

 *			msg[1].len = 2;

 *			msg[1].buf = rd_buff

 *			i2c_transfer(adap, msg, 2);

 *

 * WRITE TRANSFER : The I2C standard interface interprets all data as payload.

 *		If you want to emulate an SMBUS write transaction put the

 *		index as first byte(or first and second) in the payload.

 *		eg. a I2C transation to write 2 bytes from index 1

 *			wr_buff[0] = 0x1;

 *			wr_buff[1] = 0x23;

 *			wr_buff[2] = 0x46;

 *			msg[0].flags = 0x0;

 *			msg[0].len = 3;

 *			msg[0].buf = wr_buff;

 *			i2c_transfer(adap, msg, 1);

 *

 * To read or write a block of data (multiple bytes) using SMBUS emulation

 * please use the i2c_smbus_read_i2c_block_data()

 * or i2c_smbus_write_i2c_block_data() API

 Attempt three times to send the message queue */

 setup the i2c controller */

 return the no. messages processed */

/**

 * disable_interrupts() - disable the interrupts

 * @dev: private data of controller

 * @irq: interrupt number

/**

 * i2c_irq_handler() - interrupt routine

 * @irq: interrupt number

 * @arg: data passed to the handler

 *

 * This is the interrupt handler for the i2c driver. Currently

 * it handles the major interrupts like Rx & Tx FIFO management

 * interrupts, master transaction interrupts, arbitration and

 * bus error interrupts. The rest of the interrupts are treated as

 * unhandled.

 load Tx FIFO and Rx FIFO threshold values */

 read interrupt status register */

 Transmit FIFO nearly empty interrupt */

			/*

			 * in read operation why do we care for writing?

			 * so disable the Transmit FIFO interrupt

			/*

			 * if done, close the transfer by disabling the

			 * corresponding TXFNE interrupt

	/*

	 * Rx FIFO nearly full interrupt.

	 * This is set when the numer of entries in Rx FIFO is

	 * greater or equal than the threshold value programmed

	 * in RFT

 Read the Rx FIFO */

 Rx FIFO full */

 Master Transaction Done with/without stop */

 Master Arbitration lost interrupt */

	/*

	 * Bus Error interrupt.

	 * This happens when an unexpected start/stop condition occurs

	 * during the transaction.

 get the status */

	/*

	 * Tx FIFO overrun interrupt.

	 * This is set when a write operation in Tx FIFO is performed and

	 * the Tx FIFO is full.

 unhandled interrupts by this driver - TODO*/

 Default to 100 kHz if no frequency is given in the node */

 This driver only supports 'standard' and 'fast' modes of operation. */

 Tx FIFO threshold */

 Rx FIFO threshold */

 Slave response timeout(ms) */

 disable the controller */

 Guessed from TFTR/RFTR = 7 */

 Guessed from TFTR/RFTR = 15 */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

    Copyright (c) 2003 Mark M. Hoffman <mhoffman@lightlink.com>



/*

    This module must be considered BETA unless and until

    the chipset manufacturer releases a datasheet.

    The register definitions are based on the SiS630.



    This module relies on quirk_sis_96x_smbus (drivers/pci/quirks.c)

    for just about every machine for which users have reported.

    If this module isn't detecting your 96x south bridge, have a 

    look there.



    We assume there can only be one SiS96x with one SMBus interface.

 base address register in PCI config space */

 SiS96x SMBus registers */

 register count for request_region */

 Other settings */

 SiS96x SMBus constants */

/* Execute a SMBus transaction.

   int size is from SIS96x_QUICK to SIS96x_BLOCK_DATA

 Make sure the SMBus host is ready to start transmitting */

 kill the transaction */

 check it again */

 Turn off timeout interrupts, set fast host clock */

 clear all (sticky) status flags */

 start the transaction by setting bit 4 and size bits */

 We will always wait for a fraction of a second! */

 If the SMBus is still busy, we give up */

 device error - probably missing ACK */

 bus collision */

 Finish up by resetting the bus */

 Return negative errno on error. */

 Everything is happy, let's grab the memory and set things up. */

 set up the sysfs linkage to our parent device */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2012-2016, The Linux Foundation. All rights reserved.

 Copyright (c) 2017-20 Linaro Limited.

 Max number of resources + 1 for a NULL terminator */

 HIGH period of the SCL clock in clock ticks */

 LOW period of the SCL clock */

 set-up time for STOP condition */

 set-up time for a repeated START condition */

 data hold time */

 hold time (repeated) START condition */

 bus free time between a STOP and START condition */

 pulse width of spikes suppressed by the input filter */

	/*

	 * we reset the whole controller, here and for implicity use

	 * master[0].xxx for waiting on it.

	/*

	 * Call validate queue to make sure queue is empty before starting.

	 * This is to avoid overflow / underflow of queue.

				/* The LS byte of this register represents the

				 * first byte read from the slave during a read

				 * access.

	/*

	 * Call validate queue to make sure queue is empty before starting.

	 * This is to avoid overflow / underflow of queue.

 Memory */

 Clocks */

 Retrieve CCI clock rate */

		/* cci clock set by the bootloader or via assigned clock rate

		 * in DT.

 Interrupt */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * drivers/i2c/busses/i2c-tegra-bpmp.c

 *

 * Copyright (c) 2016 NVIDIA Corporation.  All rights reserved.

 *

 * Author: Shardar Shariff Md <smohammed@nvidia.com>

/*

 * Serialized I2C message header size is 6 bytes and includes address, flags

 * and length

/*

 * Linux flags are translated to BPMP defined I2C flags that are used in BPMP

 * firmware I2C driver to avoid any issues in future if Linux I2C flags are

 * changed.

/*

 * The serialized I2C format is simply the following:

 * [addr little-endian][flags little-endian][len little-endian][data if write]

 * [addr little-endian][flags little-endian][len little-endian][data if write]

 *  ...

 *

 * The flags are translated from Linux kernel representation to seriali2c

 * representation. Any undefined flag being set causes an error.

 *

 * The data is there only for writes. Reads have the data transferred in the

 * other direction, and thus data is not present.

 *

 * See deserialize_i2c documentation for the data format in the other direction.

/*

 * The data in the BPMP -> CPU direction is composed of sequential blocks for

 * those messages that have I2C_M_RD. So, for example, if you have:

 *

 * - !I2C_M_RD, len == 5, data == a0 01 02 03 04

 * - !I2C_M_RD, len == 1, data == a0

 * - I2C_M_RD, len == 2, data == [uninitialized buffer 1]

 * - !I2C_M_RD, len == 1, data == a2

 * - I2C_M_RD, len == 2, data == [uninitialized buffer 2]

 *

 * ...then the data in the BPMP -> CPU direction would be 4 bytes total, and

 * would contain 2 bytes that will go to uninitialized buffer 1, and 2 bytes

 * that will go to uninitialized buffer 2.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

    Copyright (c) 1998 - 2002 Frodo Looijaard <frodol@dds.nl> and

    Philip Edelbrock <phil@netroedge.com>



/*

   Supports:

	Intel PIIX4, 440MX

	Serverworks OSB4, CSB5, CSB6, HT-1000, HT-1100

	ATI IXP200, IXP300, IXP400, SB600, SB700/SP5100, SB800

	AMD Hudson-2, ML, CZ

	Hygon CZ

	SMSC Victory66



   Note: we assume there can only be one device, with one or more

   SMBus interfaces.

   The device can register multiple i2c_adapters (up to PIIX4_MAX_ADAPTERS).

   For devices supporting multiple ports the i2c_adapter should provide

   an i2c_algorithm to access them.

 PIIX4 SMBus address offsets */

 count for request_region */

 PCI Address Constants */

 Other settings */

 PIIX4 constants */

 Multi-port constants */

 HUDSON2, KERNCZ reserves ports 3, 4 */

 SB800 constants */

/*

 * SB800 port is selected by bits 2:1 of the smb_en register (0x2c)

 * or the smb_sel register (0x2e), depending on bit 0 of register 0x2f.

 * Hudson-2/Bolton port is always selected by bits 2:1 of register 0x2f.

 On kerncz and Hudson2, SmBus0Sel is at bit 20:19 of PMx00 DecodeEn */

 insmod parameters */

/* If force is set to anything different from 0, we forcibly enable the

/* If force_addr is set to anything different from 0, we forcibly enable

/* The IBM entry is in a separate table because we only check it

/*

 * SB800 globals

 SB800 */

 Port number, shifted */

	/* On some motherboards, it was reported that accessing the SMBus

 Don't access SMBus on IBM systems which get corrupted eeproms */

 Determine the address of the SMBus areas */

	/* If force_addr is set, we program the new address here. Just to make

			/* This should never need to be done, but has been

			 * noted that many Dell machines have the SMBus

			 * interface on the PIIX4 disabled!? NOTE: This assumes

			 * I/O space and other allocations WERE done by the

			 * Bios!  Don't complain if your hardware does weird

			 * things after enabling this. :') Check for Bios

			 * updates before resorting to this.

 SB800 and later SMBus does not support forcing address */

 Determine the address of the SMBus areas */

 Aux SMBus does not support IRQ information */

 Request the SMBus I2C bus config region */

 Find which register is used for port selection */

	/* Set up auxiliary SMBus controllers found on some

 Read address of auxiliary SMBus controller */

 Make sure the SMBus host is ready to start transmitting */

 start the transaction by setting bit 6 */

 We will always wait for a fraction of a second! (See PIIX4 docs errata) */

 Extra delay for SERVERWORKS_CSB5 */

 If the SMBus is still busy, we give up */

 Clock stops and slave is stuck in mid-transmission */

 Return negative errno on error. */

 Reset SMBBLKDAT */

 Reset SMBBLKDAT */

 clear response register */

 request ownership flag */

 kick off IMC Mailbox command 96 */

 clear response register */

 release ownership flag */

 kick off IMC Mailbox command 96 */

/*

 * Handles access to multiple SMBus ports on the SB800.

 * The port is selected by bits 2:1 of the smb_en register (0x2c).

 * Returns negative errno on error.

 *

 * Note: The selected port must be returned to the initial selection to avoid

 * problems on certain systems.

 Request the SMBUS semaphore, avoid conflicts with the IMC */

 Check the semaphore status */

 SMBus is still owned by the IMC, we give up */

	/*

	 * Notify the IMC (Integrated Micro Controller) if required.

	 * Among other responsibilities, the IMC is in charge of monitoring

	 * the System fans and temperature sensors, and act accordingly.

	 * All this is done through SMBus and can/will collide

	 * with our transactions if they are long (BLOCK_DATA).

	 * Therefore we need to request the ownership flag during those

	 * transactions.

 If IMC communication fails do not retry */

 Release the semaphore */

 set up the sysfs linkage to our parent device */

			/*

			 * Detect if IMC is active or not, this method is

			 * described on coreboot's AMD IMC notes

 base address location etc changed in SB800 */

		/*

		 * Try to register multiplexed main SMBus adapter,

		 * give up if we can't

 Try to register main SMBus adapter, give up if we can't */

 Check for auxiliary SMBus on some AMD chipsets */

 SB800 added aux bus too */

		/* Try to add the aux adapter if it exists,

 SPDX-License-Identifier: GPL-2.0-only

/*

 *	i2c-ali1563.c - i2c driver for the ALi 1563 Southbridge

 *

 *	Copyright (C) 2004 Patrick Mochel

 *		      2005 Rudolf Marek <r.marek@assembler.cz>

 *

 *	The 1563 southbridge is deceptively similar to the 1533, with a

 *	few notable exceptions. One of those happens to be the fact they

 *	upgraded the i2c core to be 2.0 compliant, and happens to be almost

 *	identical to the i2c controller found in the Intel 801 south

 *	bridges.

 *

 *	This driver is based on a mix of the 15x3, 1535, and i801 drivers,

 *	with a little help from the ALi 1563 spec.

 Issue 'kill' to host controller */

 device error - no response, ignore the autodetection case */

 bus collision */

 Issue timeout, hoping it helps */

 Clear byte-ready bit */

 Start transaction and wait for byte-ready bit to be set */

 Do we need this? */

 Do we need this? */

 Map the size to what the chip understands */

 Write the command register */

 Beware it uses DAT0 register and not CMD! */

 Result put in SMBHSTDAT0 */

	/* SMB I/O Base in high 12 bits and must be aligned with the

 Check if device is enabled */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * SMBus 2.0 driver for AMD-8111 IO-Hub.

 *

 * Copyright (c) 2002 Vojtech Pavlik

/*

 * AMD PCI control registers definitions.

 deliver SCI */

 deliver PCI IRQ */

 16x clock speedup */

/*

 * ACPI 2.0 chapter 13 PCI interface definitions.

 data register */

 status of controller */

 command register */

 interrupt control register */

 smi event pending */

 sci event pending */

 burst mode enabled */

 byte in data reg is command */

 data ready for embedded controller */

 data ready for host */

 read EC */

 write EC */

 enable burst mode */

 disable burst mode */

 query EC */

/*

 * ACPI 2.0 chapter 13 access of registers of the EC

/*

 * ACPI 2.0 chapter 13 SMBus 2.0 EC register model

 protocol, PEC */

 status */

 address */

 command */

 32 data registers */

 number of data bytes */

 alarm address */

 2 bytes alarm data */

 set up the sysfs linkage to our parent device */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*

 * Mellanox i2c driver

 *

 * Copyright (C) 2016-2020 Mellanox Technologies

 General defines */

 usec */

 usec */

 LPC I2C registers */

 LPC I2C masks and parametres */

/*

 * Check validity of received i2c messages parameters.

 * Returns 0 if OK, other - in case of invalid parameters.

/*

 * Check if transfer is completed and status of operation.

 * Returns 0 - transfer completed (both ACK or NACK),

 * negative - transfer isn't finished.

			/*

			 * The slave is unable to accept the data. No such

			 * slave, command not understood, or unable to accept

			 * any more data.

	/*

	 * All upper layers currently are never use transfer with more than

	 * 2 messages. Actually, it's also not so relevant in Mellanox systems

	 * because of HW limitation. Max size of transfer is not more than 32

	 * or 68 bytes in the current x86 LPCI2C bridge.

 Reset CPLD LPCI2C block */

 Make sure the CPLD is ready to start transmitting. */

/*

 * Wait for master transfer to complete.

 * It puts current process to sleep until we get interrupt or timeout expires.

 * Returns the number of transferred or read bytes or error (<0).

		/*

		 * Actual read data len will be always the same as

		 * requested len. 0xff (line pull-up) will be returned

		 * if slave has no data to return. Thus don't read

		 * MLXCPLD_LPCI2C_NUM_DAT_REG reg from CPLD.  Only in case of

		 * SMBus block read transaction data len can be different,

		 * check this case.

 Notify HW about SMBus block read transaction */

 Don't write to CPLD buffer in read transaction */

	/*

	 * Set target slave address with command for master transfer.

	 * It should be latest executed function before CPLD transaction.

/*

 * Generic lpc-i2c transfer.

 * Returns the number of processed messages or error (<0).

 Check bus state */

		/*

		 * Usually it means something serious has happened.

		 * We can not have unfinished previous transfer

		 * so it doesn't make any sense to try to stop it.

		 * Probably we were not able to recover from the

		 * previous error.

		 * The only reasonable thing - is soft reset.

 Do real transfer. Can't fail */

 Wait for transaction complete */

 Read frequency setting. */

 Set frequency only if it is not 100KHz, which is default. */

 Set I2C bus frequency if platform data provides this info. */

 Register with i2c layer */

 Read capability register */

 Check support for extended transaction length */

 Check support for smbus block transaction */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

    Copyright (c) 1998 - 2002  Frodo Looijaard <frodol@dds.nl>,

    Philip Edelbrock <phil@netroedge.com>, Kyösti Mälkki <kmalkki@cc.hut.fi>,

    Mark D. Studebaker <mdsxyz123@yahoo.com>

    Copyright (C) 2005 - 2008  Jean Delvare <jdelvare@suse.de>



/*

   Supports the following VIA south bridges:



   Chip name          PCI ID  REV     I2C block

   VT82C596A          0x3050             no

   VT82C596B          0x3051             no

   VT82C686A          0x3057  0x30       no

   VT82C686B          0x3057  0x40       yes

   VT8231             0x8235             no?

   VT8233             0x3074             yes

   VT8233A            0x3147             yes?

   VT8235             0x3177             yes

   VT8237R            0x3227             yes

   VT8237A            0x3337             yes

   VT8237S            0x3372             yes

   VT8251             0x3287             yes

   CX700              0x8324             yes

   VX800/VX820        0x8353             yes

   VX855/VX875        0x8409             yes



   Note: we assume there can only be one device, with one SMBus interface.

 SMBus address offsets */

 PCI Address Constants */

/* SMBus data in configuration space can be found in two places,

 Other settings */

 VT82C596 constants */

/* If force is set to anything different from 0, we forcibly enable the

/* If force_addr is set to anything different from 0, we forcibly enable

 Return -1 on error, 0 on success */

 Make sure the SMBus host is ready to start transmitting */

 Start the transaction by setting bit 6 */

 We will always wait for a fraction of a second */

 If the SMBus is still busy, we give up */

 Resetting status register */

 Return negative errno on error, 0 on success */

 Reset SMBBLKDAT */

 Reset SMBBLKDAT */

 Determine the address of the SMBus areas */

 try 2nd address and config reg. for 596 */

 no matches at all */

	/* If force_addr is set, we program the new address here. Just to make

			/* NOTE: This assumes I/O space and other allocations

			 * WERE done by the Bios!  Don't complain if your

			 * hardware does weird things after enabling this.

			 * :') Check for Bios updates before resorting to

			 * this.

		/* The VT82C686B (rev 0x40) does support I2C block

	/* Always return failure here.  This is to allow other drivers to bind

	 * to this pci device.  We don't really want to have control over the

	 * pci device, we only wanted to read as few register values from it.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * i2c-nforce2-s4985.c - i2c-nforce2 extras for the Tyan S4985 motherboard

 *

 * Copyright (C) 2008 Jean Delvare <jdelvare@suse.de>

/*

 * We select the channels by sending commands to the Philips

 * PCA9556 chip at I2C address 0x18. The main adapter is used for

 * the non-multiplexed part of the bus, and 4 virtual adapters

 * are defined for the multiplexed addresses: 0x50-0x53 (memory

 * module EEPROM) located on channels 1-4. We define one virtual

 * adapter per CPU, which corresponds to one multiplexed channel:

 *   CPU0: virtual adapter 1, channel 1

 *   CPU1: virtual adapter 2, channel 2

 *   CPU2: virtual adapter 3, channel 3

 *   CPU3: virtual adapter 4, channel 4

 Wrapper access functions for multiplexed SMBus */

 We exclude the multiplexed addresses */

/* We remember the last used channels combination so as to only switch

   channels when it is really needed. This greatly reduces the SMBus

   overhead, but also assumes that nobody will be writing to the PCA9556

 We exclude the non-multiplexed addresses */

 CPU0: channel 1 enabled */

 CPU1: channel 2 enabled */

 CPU2: channel 3 enabled */

 CPU3: channel 4 enabled */

 Configure the PCA9556 multiplexer */

 All I/O to output mode */

 Unregister physical bus */

 Define the 5 virtual adapters and algorithms structures */

 Fill in the new structures */

 Register virtual adapters */

 Restore physical bus */

 Restore physical bus */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2014 MediaTek Inc.

 * Author: Xudong Chen <xudong.chen@mediatek.com>

 i2c host adapter */

 set in i2c probe */

 i2c base addr */

 dma base address*/

 main clock for i2c bus */

 DMA clock for i2c via DMA */

 PMIC clock for i2c from PMIC */

 Arbitrator clock for i2c */

 can use i2c pins from PMIC */

 IO config push-pull mode */

 interrupt status */

 The speed in transfer */

/**

 * struct i2c_spec_values:

 * @min_low_ns: min LOW period of the SCL clock

 * @min_su_sta_ns: min set-up time for a repeated START condition

 * @max_hd_dat_ns: max data hold time

 * @min_su_dat_ns: min data set-up time

 Set ioconfig */

 If use i2c pin from PMIC mt6397 side, need set PATH_DIR first */

/*

 * Check and Calculate i2c ac-timing

 *

 * Hardware design:

 * sample_ns = (1000000000 * (sample_cnt + 1)) / clk_src

 * xxx_cnt_div =  spec->min_xxx_ns / sample_ns

 *

 * Sample_ns is rounded down for xxx_cnt_div would be greater

 * than the smallest spec.

 * The sda_timing is chosen as the middle value between

 * the largest and smallest.

/*

 * Calculate i2c port speed

 *

 * Hardware design:

 * i2c_bus_freq = parent_clk / (clock_div * 2 * sample_cnt * step_cnt)

 * clock_div: fixed in hardware, but may be various in different SoCs

 *

 * The calculation want to pick the highest bus frequency that is still

 * less than or equal to i2c->speed_hz. The calculation try to get

 * sample_cnt and step_cn

 Find the best combination */

	/* Search for the best pair (sample_cnt, step_cnt) with

	 * 0 < sample_cnt < MAX_SAMPLE_CNT_DIV

	 * 0 < step_cnt < max_step_cnt

	 * sample_cnt * step_cnt >= opt_div

	 * optimizing for sample_cnt * step_cnt being minimal

		/* In this case, hardware can't support such

		 * low i2c_bus_freq

 Set master code speed register */

 Set the high speed mode register */

 Disable the high speed transaction */

 Clear interrupt status */

 Enable interrupt */

 Set transfer and transaction len */

 Prepare buffer data to start transfer */

 Clear interrupt mask */

 checking if we can skip restart and optimize using WRRD mode */

		/* ignore the first restart irq after the master code,

		 * otherwise the first transfer will be discarded.

 combined two messages into one transaction */

 always use DMA mode. */

 the return value is number of executed messages */

	/*

	 * when occurs ack error, i2c controller generate two interrupts

	 * first is the ack error interrupt, then the complete interrupt

	 * i2c->irq_stat need keep the two interrupt value.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * CE4100 PCI-I2C glue code for PXA's driver

 * Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>

 *

 * The CE4100's I2C device is more or less the same one as found on PXA.

 * It does not support slave mode, the register slightly moved. This PCI

 * device provides three bars, every contains a single I2C controller.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

    i2c Support for Via Technologies 82C586B South Bridge



    Copyright (c) 1998, 1999 Kyösti Mälkki <kmalkki@cc.hut.fi>



 Power management registers */

 silicon revision code */

 clock bit in DIR/OUT/IN register */

 io-region reservation */

/*

   It does not appear from the datasheet that the GPIO pins are

   open drain. So a we set a low value by setting the direction to

   output and a high value by setting the direction to input and

   relying on the required I2C pullup. The data value is initialized

   to 0 in via_init() and never changed.

 later revision */

 set up the sysfs linkage to our parent device */

 SPDX-License-Identifier: GPL-2.0

/*

 * Renesas RIIC driver

 *

 * Copyright (C) 2013 Wolfram Sang <wsa@sang-engineering.com>

 * Copyright (C) 2013 Renesas Solutions Corp.

/*

 * This i2c core has a lot of interrupts, namely 8. We use their chaining as

 * some kind of state machine.

 *

 * 1) The main xfer routine kicks off a transmission by putting the start bit

 * (or repeated start) on the bus and enabling the transmit interrupt (TIE)

 * since we need to send the slave address + RW bit in every case.

 *

 * 2) TIE sends slave address + RW bit and selects how to continue.

 *

 * 3a) Write case: We keep utilizing TIE as long as we have data to send. If we

 * are done, we switch over to the transmission done interrupt (TEIE) and mark

 * the message as completed (includes sending STOP) there.

 *

 * 3b) Read case: We switch over to receive interrupt (RIE). One dummy read is

 * needed to start clocking, then we keep receiving until we are done. Note

 * that we use the RDRFS mode all the time, i.e. we ACK/NACK every byte by

 * writing to the ACKBT bit. I tried using the RDRFS mode only at the end of a

 * message to create the final NACK as sketched in the datasheet. This caused

 * some subtle races (when byte n was processed and byte n+1 was already

 * waiting), though, and I started with the safe approach.

 *

 * 4) If we got a NACK somewhere, we flag the error and stop the transmission

 * via NAKIE.

 *

 * Also check the comments in the interrupt routines for some gory details.

 Should be 1 on writes */

 On read, switch over to receive interrupt */

 On write, initialize length */

	/*

	 * Switch to transmission ended interrupt when done. Do check here

	 * after bytes_left was initialized to support SMBUS_QUICK (new msg has

	 * 0 length then)

	/*

	 * This acks the TIE interrupt. We get another TIE immediately if our

	 * value could be moved to the shadow shift register right away. So

	 * this must be after updates to ICIER (where we want to disable TIE)!

 We got a NACKIE */

 dummy read */

 Transfer is complete, but do not send STOP */

 dummy read */

 STOP must come before we set ACKBT! */

 Reading acks the RIE interrupt */

 read back registers to confirm writes have fully propagated */

	/*

	 * Assume the default register settings:

	 *  FER.SCLE = 1 (SCL sync circuit enabled, adds 2 or 3 cycles)

	 *  FER.NFE = 1 (noise circuit enabled)

	 *  MR3.NF = 0 (1 cycle of noise filtered out)

	 *

	 * Freq (CKS=000) = (I2CCLK + tr + tf)/ (BRH + 3 + 1) + (BRL + 3 + 1)

	 * Freq (CKS!=000) = (I2CCLK + tr + tf)/ (BRH + 2 + 1) + (BRL + 2 + 1)

	/*

	 * Determine reference clock rate. We must be able to get the desired

	 * frequency with only 62 clock ticks max (31 high, 31 low).

	 * Aim for a duty of 60% LOW, 40% HIGH.

		/*

		 * 60% low time must be less than BRL + 2 + 1

		 * BRL max register value is 0x1F.

 Remove automatic clock ticks for sync circuit and NF */

	/*

	 * Remove clock ticks for rise and fall times. Convert ns to clock

	 * ticks.

 Adjust for min register values for when SCLE=1 and NFE=1 */

 Changing the order of accessing IICRST and ICE may break things! */

 Sentinel */ },

 SPDX-License-Identifier: GPL-2.0-only

/*

 * I2C bus driver for Kontron COM modules

 *

 * Copyright (c) 2010-2013 Kontron Europe GmbH

 * Author: Michael Brunner <michael.brunner@kontron.com>

 *

 * The driver is based on the i2c-ocores driver by Peter Korsgaard.

 2.7 mHz */

 100 kHz */

/*

 * kempld_get_mutex must be called prior to calling this function.

 Ready? */

 Stop has been sent */

 Error? */

 10 bit address? */

 Set read bit if necessary */

 Second part of 10 bit addressing */

 Handle the transfer */

/*

 * kempld_get_mutex must be called prior to calling this function.

 Make sure the device is disabled */

 Round to the best matching value */

 Activate I2C bus output on GPIO pins */

 Enable the device */

 Add I2C adapter to I2C tree */

	/*

	 * Disable I2C logic if it was not activated before the

	 * driver loaded

 SPDX-License-Identifier: GPL-2.0-only

/*

 * driver for the i2c-tiny-usb adapter - 1.0

 * http://www.harbaum.org/till/i2c_tiny_usb

 *

 * Copyright (C) 2006-2007 Till Harbaum (Till@Harbaum.org)

 include interfaces to usb layer */

 include interface to i2c layer */

 commands via USB, must match command ids in the firmware */

/* i2c bit delay, default is 10us -> 100kHz max

   (in practice, due to additional delays in the i2c bitbanging

 ----- begin of i2c layer ---------------------------------------------- */

 and directly send the message */

 read data */

 write data */

 read status */

 get functionality from adapter */

 This is the actual algorithm we define */

 ----- end of i2c layer ------------------------------------------------ */

 ----- begin of usb layer ---------------------------------------------- */

/*

 * Initially the usb i2c interface uses a vid/pid pair donated by

 * Future Technology Devices International Ltd., later a pair was

 * bought from EZPrototypes

 FTDI */

 EZPrototypes */

 Terminating entry */

 Structure to hold all of our device specific stuff */

 the usb device for this device */

 the interface for this device */

 i2c related things */

 do control transfer */

 do control transfer */

 allocate memory for our device state and initialize it */

 save our data pointer in this interface device */

 setup i2c adapter description */

 and finally attach to i2c layer */

 inform user about successful attachment to i2c layer */

 ----- end of usb layer ------------------------------------------------ */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * General Purpose I2C multiplexer

 *

 * Copyright (C) 2017 Axentia Technologies AB

 *

 * Author: Peter Rosin <peda@axentia.se>

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

/*

 * Mellanox i2c mux driver

 *

 * Copyright (C) 2016-2020 Mellanox Technologies

/* mlxcpld_mux - mux control structure:

 * @last_val - last selected register value or -1 if mux deselected

 * @client - I2C device client

 * @pdata: platform data

/* MUX logic description.

 * Driver can support different mux control logic, according to CPLD

 * implementation.

 *

 * Connectivity schema.

 *

 * i2c-mlxcpld                                 Digital               Analog

 * driver

 * *--------*                                 * -> mux1 (virt bus2) -> mux -> |

 * | I2CLPC | i2c physical                    * -> mux2 (virt bus3) -> mux -> |

 * | bridge | bus 1                 *---------*                               |

 * | logic  |---------------------> * mux reg *                               |

 * | in CPLD|                       *---------*                               |

 * *--------*   i2c-mux-mlxpcld          ^    * -> muxn (virt busn) -> mux -> |

 *     |        driver                   |                                    |

 *     |        *---------------*        |                              Devices

 *     |        * CPLD (i2c bus)* select |

 *     |        * registers for *--------*

 *     |        * mux selection * deselect

 *     |        *---------------*

 *     |                 |

 * <-------->     <----------->

 * i2c cntrl      Board cntrl reg

 * reg space      space (mux select,

 *                IO, LED, WD, info)

 *

/* Write to mux register. Don't use i2c_transfer() and i2c_smbus_xfer()

 * for this as they will try to lock adapter a second time.

 Only select the channel if its different from the last channel */

 Deselect active channel */

 Probe/reomove functions */

 force the first selection */

 Create an adapter for each channel. */

 Notify caller when all channels' adapters are created. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Pinctrl based I2C DeMultiplexer

 *

 * Copyright (C) 2015-16 by Wolfram Sang, Sang Engineering <wsa@sang-engineering.com>

 * Copyright (C) 2015-16 by Renesas Electronics Corporation

 *

 * See the bindings doc for DTS setup and the sysfs doc for usage information.

 * (look for filenames containing 'i2c-demux-pinctrl' in Documentation/)

	/*

	 * Check if there are pinctrl states at all. Note: we cant' use

	 * devm_pinctrl_get_select() because we need to distinguish between

	 * the -ENODEV from devm_pinctrl_get() and pinctrl_lookup_state().

 continue if just no pinctrl states (e.g. i2c-gpio), otherwise exit */

 there are states. check and use them */

 Now fill out current adapter structure. cur_chan must be up to date */

 switch to first parent as active master */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Linear Technology LTC4306 and LTC4305 I2C multiplexer/switch

 *

 * Copyright (C) 2017 Analog Devices Inc.

 *

 * Based on: i2c-mux-pca954x.c

 *

 * Datasheet: http://cds.linear.com/docs/en/datasheet/4306.pdf

 gpiolib assumes all GPIOs default input */

 Reset and enable the mux if an enable GPIO is specified. */

	/*

	 * Write the mux register at addr to verify

	 * that the mux is in fact present. This also

	 * initializes the mux to disconnected state.

 Now create an adapter for each channel */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * I2C multiplexer using pinctrl API

 *

 * Copyright (c) 2012, NVIDIA CORPORATION.  All rights reserved.

 Do not add any adapter for the idle state (if it's there at all). */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * GPIO-based I2C Arbitration Using a Challenge & Response Mechanism

 *

 * Copyright (C) 2012 Google, Inc

/**

 * struct i2c_arbitrator_data - Driver data for I2C arbitrator

 *

 * @our_gpio: GPIO descriptor we'll use to claim.

 * @their_gpio: GPIO descriptor that the other side will use to claim.

 * @slew_delay_us: microseconds to wait for a GPIO to go high.

 * @wait_retry_us: we'll attempt another claim after this many microseconds.

 * @wait_free_us: we'll give up after this many microseconds.

/*

 * i2c_arbitrator_select - claim the I2C bus

 *

 * Use the GPIO-based signalling protocol; return -EBUSY if we fail.

 Start a round of trying to claim the bus */

 Indicate that we want to claim the bus */

 Wait for the other master to release it */

 We got it, so return */

 It didn't release, so give up, wait, and try again */

 Give up, release our claim */

/*

 * i2c_arbitrator_deselect - release the I2C bus

 *

 * Release the I2C bus using the GPIO-based signalling protocol.

 Release the bus and wait for the other master to notice */

 We only support probing from device tree; no platform_data */

 Request GPIOs, our GPIO as unclaimed to begin with */

 At the moment we only support a single two master (us + 1 other) */

 Arbitration parameters */

 Find our parent */

 Actually add the mux adapter */

 SPDX-License-Identifier: GPL-2.0

/*

 * I2C multiplexer

 *

 * Copyright (c) 2008-2009 Rodolfo Giometti <giometti@linux.it>

 * Copyright (c) 2008-2009 Eurotech S.p.A. <info@eurotech.it>

 *

 * This module supports the PCA954x and PCA984x series of I2C multiplexer/switch

 * chips made by NXP Semiconductors.

 * This includes the:

 *	 PCA9540, PCA9542, PCA9543, PCA9544, PCA9545, PCA9546, PCA9547,

 *	 PCA9548, PCA9846, PCA9847, PCA9848 and PCA9849.

 *

 * These chips are all controlled via the I2C bus itself, and all have a

 * single 8-bit register. The upstream "parent" bus fans out to two,

 * four, or eight downstream busses or channels; which of these

 * are selected is determined by the chip type and register contents. A

 * mux can select only one sub-bus at a time; a switch can select any

 * combination simultaneously.

 *

 * Based on:

 *	pca954x.c from Kumar Gala <galak@kernel.crashing.org>

 * Copyright (C) 2006

 *

 * Based on:

 *	pca954x.c from Ken Harrenstien

 * Copyright (C) 2004 Google, Inc. (Ken Harrenstien)

 *

 * Based on:

 *	i2c-virtual_cb.c from Brian Kuschak <bkuschak@yahoo.com>

 * and

 *	pca9540.c from Jean Delvare <jdelvare@suse.de>.

 used for muxes only */

 last register value */

 MUX_IDLE_AS_IS, MUX_IDLE_DISCONNECT or >= 0 for channel */

 Provide specs for the PCA954x types we know about */

/* Write to mux register. Don't use i2c_transfer()/i2c_smbus_xfer()

 We make switches look like muxes, not sure how to be smarter. */

 Only select the channel if its different from the last channel */

 Set the mux back to a predetermined channel */

 Deselect active channel */

 otherwise leave as-is */

	/*

	 * Set the mux into a state consistent with the new

	 * idle_state.

 Disconnect multiplexer */

/*

 * I2C init/probing/exit functions

 Reset the mux if a reset GPIO is specified. */

 Give the chip some time to recover. */

	/*

	 * Write the mux register at addr to verify

	 * that the mux is in fact present. This also

	 * initializes the mux to a channel

	 * or disconnected state.

 Now create an adapter for each channel */

	/*

	 * The attr probably isn't going to be needed in most cases,

	 * so don't fail completely on error.

/*

 * I2C multiplexer driver for PCA9541 bus master selector

 *

 * Copyright (c) 2010 Ericsson AB.

 *

 * Author: Guenter Roeck <linux@roeck-us.net>

 *

 * Derived from:

 *  pca954x.c

 *

 *  Copyright (c) 2008-2009 Rodolfo Giometti <giometti@linux.it>

 *  Copyright (c) 2008-2009 Eurotech S.p.A. <info@eurotech.it>

 *

 * This file is licensed under the terms of the GNU General Public

 * License version 2. This program is licensed "as is" without any

 * warranty of any kind, whether express or implied.

/*

 * The PCA9541 is a bus master selector. It supports two I2C masters connected

 * to a single slave bus.

 *

 * Before each bus transaction, a master has to acquire bus ownership. After the

 * transaction is complete, bus ownership has to be released. This fits well

 * into the I2C multiplexer framework, which provides select and release

 * functions for this purpose. For this reason, this driver is modeled as

 * single-channel I2C bus multiplexer.

 *

 * This driver assumes that the two bus masters are controlled by two different

 * hosts. If a single host controls both masters, platform code has to ensure

 * that only one of the masters is instantiated at any given time.

 arbitration timeouts, in jiffies */

 125 ms until forcing bus ownership */

 250 ms until acquisition failure */

 arbitration retry delays, in us */

/*

 * Write to chip register. Don't use i2c_transfer()/i2c_smbus_xfer()

 * as they will try to lock the adapter a second time.

/*

 * Read from chip register. Don't use i2c_transfer()/i2c_smbus_xfer()

 * as they will try to lock adapter a second time.

/*

 * Arbitration management functions

 Release bus. Also reset NTESTON and BUSINIT if it was set. */

/*

 * Arbitration is defined as a two-step process. A bus master can only activate

 * the slave bus if it owns it; otherwise it has to request ownership first.

 * This multi-step process ensures that access contention is resolved

 * gracefully.

 *

 * Bus	Ownership	Other master	Action

 * state		requested access

 * ----------------------------------------------------

 * off	-		yes		wait for arbitration timeout or

 *					for other master to drop request

 * off	no		no		take ownership

 * off	yes		no		turn on bus

 * on	yes		-		done

 * on	no		-		wait for arbitration timeout or

 *					for other master to release bus

 *

 * The main contention point occurs if the slave bus is off and both masters

 * request ownership at the same time. In this case, one master will turn on

 * the slave bus, believing that it owns it. The other master will request

 * bus ownership. Result is that the bus is turned on, and master which did

 * _not_ own the slave bus before ends up owning it.

 Control commands per PCA9541 datasheet */

/*

 * Channel arbitration

 *

 * Return values:

 *  <0: error

 *  0 : bus not acquired

 *  1 : bus acquired

		/*

		 * Bus is off. Request ownership or turn it on unless

		 * other master requested ownership.

			/*

			 * Other master did not request ownership,

			 * or arbitration timeout expired. Take the bus.

			/*

			 * Other master requested ownership.

			 * Set extra long timeout to give it time to acquire it.

		/*

		 * Bus is on, and we own it. We are done with acquisition.

		 * Reset NTESTON and BUSINIT, then return success.

		/*

		 * Other master owns the bus.

		 * If arbitration timeout has expired, force ownership.

		 * Otherwise request it.

 Time is up, take the bus and reset it. */

 Request bus ownership if needed */

 give up after this time */

 force bus ownership after this time */

/*

 * I2C init/probing/exit functions

	/*

	 * I2C accesses are unprotected here.

	 * We have to lock the I2C segment before releasing the bus.

 Create mux adapter */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * I2C multiplexer using a single register

 *

 * Copyright 2015 Freescale Semiconductor

 * York Sun  <yorksun@freescale.com>

	/*

	 * Write to the register, followed by a read to ensure the write is

	 * completed on a "posted" bus, for example PCI or write buffers.

	 * The endianness of reading doesn't matter and the return data

	 * is not used.

 map address from "reg" if exists */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * I2C multiplexer using GPIO API

 *

 * Peter Korsgaard <peter.korsgaard@barco.com>

 FIXME: stop poking around inside gpiolib */

		/*

		 * In ACPI land the mux should be a direct child of the i2c

		 * bus it muxes.

 FIXME: find a proper way to access the GPIO device */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * i2c-algo-pcf.c i2c driver algorithms for PCF8584 adapters

 *

 *   Copyright (C) 1995-1997 Simon G. Vogl

 *		   1998-2000 Hans Berglund

 *

 * With some changes from Kyösti Mälkki <kmalkki@cc.hut.fi> and

 * Frodo Looijaard <frodol@dds.nl>, and also from Martin Bailey

 * <mbailey@littlefeet-inc.com>

 *

 * Partially rewriten by Oleg I. Vdovikin <vdovikin@jscc.ru> to handle multiple

 * messages, proper stop/repstart signaling during receive, added detect code

 print several statistical values */

 debug the protocol by showing transferred bits */

/*

 * module parameters:

 setting states on the bus with the right timing: */

 other auxiliary functions */

	/*

	 * Cleanup from LAB -- reset and enable ESO.

	 * This resets the PCF8584; since we've lost the bus, no

	 * further attempts should be made by callers to clean up

	 * (no i2c_stop() etc.)

	/*

	 * We pause for a time period sufficient for any running

	 * I2C transaction to complete -- the arbitration logic won't

	 * work properly until the next START is seen.

	 * It is assumed the bus driver or client has set a proper value.

	 *

	 * REVISIT: should probably use msleep instead of mdelay if we

	 * know we can sleep.

 wait for 100 us */

/*

 * This should perform the 'PCF8584 initialization sequence' as described

 * in the Philips IC12 data book (1995, Aug 29).

 * There should be a 30 clock cycle wait after reset, I assume this

 * has been fulfilled.

 * There should be a delay at the end equal to the longest I2C message

 * to synchronize the BB-bit (in multimaster systems). How long is

 * this? I assume 1 second is always long enough.

 *

 * vdovikin: added detect code for PCF8584

 S1=0x80: S0 selected, serial interface off */

	/*

	 * check to see S1 now used as R/W ctrl -

	 * PCF8584 does that when ESO is zero

 definitely not PCF8584 */

 load own address in S0, effective address is (own << 1) */

 check it's really written */

 S1=0xA0, next byte in S2 */

 check to see S2 now selected */

 load clock register S2 */

 check it's really written, the only 5 lowest bits does matter */

 Enable serial interface, idle, S0 selected */

 check to see PCF is really idled and we can access status register */

 arbitration lost */

 got a better one ?? */

 got a better one ?? */

 increment number of bytes to read by one -- read dummy byte */

 arbitration lost */

 dummy read */

 Check for bus busy */

 Send START */

 Wait for PIN (pending interrupt NOT) */

 arbitration lost */

 Check LRB (last rcvd bit - slave ack) */

 exported algorithm data: */

/*

 * registering functions to load algorithms at runtime

 register new adapter to i2c module... */

 SPDX-License-Identifier: GPL-2.0+

/*

 * i2c-algo-bit.c: i2c driver algorithms for bit-shift adapters

 *

 *   Copyright (C) 1995-2000 Simon G. Vogl

 *

 * With some changes from Frodo Looijaard <frodol@dds.nl>, Kyösti Mälkki

 * <kmalkki@cc.hut.fi> and Jean Delvare <jdelvare@suse.de>

 ----- global defines ----------------------------------------------- */

 DEBUG */

 ----- global variables ---------------------------------------------	*/

 see if the line-setting functions work	*/

 --- setting states on the bus with the right timing: ---------------	*/

/*

 * Raise scl line, and do checking for delays. This is necessary for slower

 * devices.

 Not all adapters have scl sense line... */

		/* This hw knows how to read the clock line, so we wait

		 * until it actually gets high.  This is safer as some

		 * chips may hold it low ("clock stretching") while they

		 * are processing data internally.

			/* Test one last time, as we may have been preempted

			 * between last check and timeout test.

 --- other auxiliary functions --------------------------------------	*/

 assert: scl, sda are high */

 assert: scl is low */

 assert: scl is low */

/* send a byte without start cond., look for arbitration,

/* returns:

 * 1 if the device acknowledged

 * 0 if the device did not ack

 * -ETIMEDOUT if an error occurred (while raising the scl line)

 assert: scl is low */

 timed out */

		/* FIXME do arbitration here:

		 * if (sb && !getsda(adap)) -> ouch! Get out of here.

		 *

		 * Report a unique code, so higher level code can retry

		 * the whole (combined) message and *NOT* issue STOP.

 timeout */

	/* read ack: SDA should be pulled down by slave, or it may

	 * NAK (usually to report problems with the data we wrote).

 ack: sda is pulled low -> success */

 assert: scl is low (sda undef) */

 read byte via i2c port, without start/stop sequence	*/

 acknowledge is sent in i2c_read.			*/

 assert: scl is low */

 timeout */

 assert: scl is low */

/*

 * Sanity check for the adapter hardware - check the reaction of

 * the bus lines only if it seems to be idle.

/* ----- Utility functions

/* try_address tries to contact a chip for a number of

 * times before it gives up.

 * return values:

 * 1 chip answered

 * 0 chip did not answer

 * -x transmission error

 OK/ACK; or ignored NAK */

		/* A slave NAKing the master means the slave didn't like

		 * something about the data it saw.  For example, maybe

		 * the SMBus PEC was wrong.

		/* Timeout; or (someday) lost arbitration

		 *

		 * FIXME Lost ARB implies retrying the transaction from

		 * the first message, after the "winning" master issues

		 * its STOP.  As a rule, upper layer code has no reason

		 * to know or care about this ... it is *NOT* an error.

 assert: sda is high */

 send ack */

 timeout */

 counts bytes read */

 read timed out */

		/* Some SMBus transactions require that we receive the

			/* The original count value accounts for the extra

			   bytes, that is, either 1 for a regular transaction,

/* doAddress initiates the transfer by generating the start condition (in

 * try_address) and transmits the address in the necessary format to handle

 * reads, writes as well as 10bit-addresses.

 * returns:

 *  0 everything went okay, the chip ack'ed, or IGNORE_NAK flag was set

 * -x an error occurred (like: -ENXIO if the device did not answer, or

 *	-ETIMEDOUT, for example if the lines are stuck...)

 a ten bit address */

 try extended address code...*/

 the remaining 8 bit address */

 the chip did not ack / xmission error occurred */

 okay, now switch into reading mode */

 normal 7bit address	*/

 read bytes into buffer*/

 write bytes from buffer */

/*

 * We print a warning when we are not flagged to support atomic transfers but

 * will try anyhow. That's what the I2C core would do as well. Sadly, we can't

 * modify the algorithm struct at probe time because this struct is exported

 * 'const'.

 -----exported algorithm data: -------------------------------------	*/

/*

 * registering functions to load algorithms at runtime

 register new adapter to i2c module... */

	/*

	 * We tried forcing SCL/SDA to an initial state here. But that caused a

	 * regression, sadly. Check Bugzilla #200045 for details.

 Complain if SCL can't be read */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  i2c-algo-pca.c i2c driver algorithms for PCA9564 adapters

 *    Copyright (C) 2004 Arcom Control Systems

 *    Copyright (C) 2008 Pengutronix

		/* Ignore the reset function from the module,

		 * we can use the parallel bus reset.

		/*

		 * After a reset we need to re-apply any configuration

		 * (calculated in pca_init) to get the bus in a working state.

/*

 * Generate a start condition on the i2c bus.

 *

 * returns after the start condition has occurred

/*

 * Generate a repeated start condition on the i2c bus

 *

 * return after the repeated start condition has occurred

/*

 * Generate a stop condition on the i2c bus

 *

 * returns after the stop condition has been generated

 *

 * STOPs do not generate an interrupt or set the SI flag, since the

 * part returns the idle state (0xf8). Hence we don't need to

 * pca_wait here.

/*

 * Send the slave address and R/W bit

 *

 * returns after the address has been sent

/*

 * Transmit a byte.

 *

 * Returns after the byte has been transmitted

/*

 * Receive a byte

 *

 * returns immediately.

/*

 * Setup ACK or NACK for next received byte and wait for it to arrive.

 *

 * Returns after next byte has arrived.

 On reset or stop the bus is idle */

 A START condition has been transmitted */

 A repeated start condition has been transmitted */

 SLA+W has been transmitted; ACK has been received */

 Data byte in I2CDAT has been transmitted; ACK has been received */

 SLA+W has been transmitted; NOT ACK has been received */

 SLA+R has been transmitted; ACK has been received */

 Data bytes has been received; ACK has been returned */

 SLA+R has been transmitted; NOT ACK has been received */

 Data byte in I2CDAT has been transmitted; NOT ACK has been received */

 Arbitration lost during SLA+W, SLA+R or data bytes */

			/*

			 * The PCA9564 data sheet (2006-09-01) says "A

			 * START condition will be transmitted when the

			 * bus becomes free (STOP or SCL and SDA high)"

			 * when the STA bit is set (p. 11).

			 *

			 * In case this won't work, try pca_reset()

			 * instead.

 Data byte has been received; NOT ACK has been returned */

 Bus error - SDA stuck low */

 Bus error - SCL stuck low (PCA9665) */

 Bus error - SCL stuck low (PCA9564) */

 Bus error during master or slave mode due to illegal START or STOP condition */

	/* The trick here is to check if there is an indirect register

	 * available. If there is one, we will read the value we first

	 * wrote on I2C_PCA_IADR. Otherwise, we will read the last value

	 * we wrote on I2C_PCA_ADR

 Store settings as these will be needed when the PCA chip is reset */

 Values can be found on PCA9665 datasheet section 7.3.2.6 */

		/* These values are the maximum raise and fall values allowed

		 * by the I2C operation mode (Standard, Fast or Fast+)

		 * They are used (added) below to calculate the clock dividers

		 * of PCA9665. Note that they are slightly different of the

		 * real maximum, to allow the change on mode exactly on the

		 * maximum clock rate for each mode

 To avoid integer overflow, use clock/100 for calculations */

 Raise 11e-8s, Fall 11e-8s */

 Raise 11e-8s, Fall 11e-8s */

 Raise 29e-8s, Fall 29e-8s */

 Raise 29e-8s, Fall 98e-8s */

		/* The minimum clock that respects the thi/tlow = 134/157 is

		 * 64800 Hz. Below that, we have to fix the tlow to 255 and

		 * calculate the thi factor.

 Store settings as these will be needed when the PCA chip is reset */

 500 us for oscillator to stabilise */

/*

 * registering functions to load algorithms at runtime

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2013 - 2014 Texas Instruments Incorporated - https://www.ti.com

 *

 * Authors:

 *    Jyri Sarha <jsarha@ti.com>

 *    Sergej Sawazki <ce3a@gmx.de>

 *

 * Gpio controlled clock implementation

/**

 * DOC: basic gpio gated clock which can be enabled and disabled

 *      with gpio output

 * Traits of this clock:

 * prepare - clk_(un)prepare only ensures parent is (un)prepared

 * enable - clk_enable and clk_disable are functional & control gpio

 * rate - inherits rate from parent.  No clk_set_rate support

 * parent - fixed parent.  No clk_set_parent support

/**

 * struct clk_gpio - gpio gated clock

 *

 * @hw:		handle between common and hardware-specific interfaces

 * @gpiod:	gpio descriptor

 *

 * Clock with a gpio control for enabling and disabling the parent clock

 * or switching between two parents by asserting or deasserting the gpio.

 *

 * Implements .enable, .disable and .is_enabled or

 * .get_parent, .set_parent and .determine_rate depending on which clk_ops

 * is used.

/**

 * DOC: basic clock multiplexer which can be controlled with a gpio output

 * Traits of this clock:

 * prepare - clk_prepare only ensures that parents are prepared

 * rate - rate is only affected by parent switching.  No clk_set_rate support

 * parent - parent is adjustable through clk_set_parent

 SPDX-License-Identifier: GPL-2.0

/*

 * Nuvoton NPCM7xx Clock Generator

 * All the clocks are initialized by the bootloader, so this driver allow only

 * reading of current settings directly from the hardware.

 *

 * Copyright (C) 2018 Nuvoton Technologies tali.perry@nuvoton.com

	/*

	 * If this clock is exported via DT, set onecell_idx to constant

	 * defined in include/dt-bindings/clock/nuvoton, NPCM7XX-clock.h for

	 * this specific clock.  Otherwise, set to -1.

	/*

	 * If this clock is exported via DT, set onecell_idx to constant

	 * defined in include/dt-bindings/clock/nuvoton, NPCM7XX-clock.h for

	 * this specific clock.  Otherwise, set to -1.

	/*

	 * If this clock is exported via DT, set onecell_idx to constant

	 * defined in include/dt-bindings/clock/nuvoton, NPCM7XX-clock.h for

	 * this specific clock.  Otherwise, set to -1.

	/*

	 * If this clock is exported via DT, set onecell_idx to constant

	 * defined in include/dt-bindings/clock/nuvoton, NPCM7XX-clock.h for

	 * this specific clock.  Otherwise, set to -1.

	/*

	 * If this clock is exported via DT, set onecell_idx to constant

	 * defined in include/dt-bindings/clock/nuvoton, NPCM7XX-clock.h for

	 * this specific clock.  Otherwise, set to -1.

/*

 * Single copy of strings used to refer to clocks within this driver indexed by

 * above enum.

AKA system clock.*/

AKA CLK2*/

AKA CLK4*/

 divided by 2

 configurable dividers: */

30-28 ADCCKDIV*/

27-26 CLK4DIV*/

25-21 TIMCKDIV*/

20-16 UARTDIV*/

15-11 MMCCKDIV*/

10-6 AHB3CKDIV*/

5-2 PCICKDIV*/

0 CLK2DIV*/

31-30 APB4CKDIV*/

29-28 APB3CKDIV*/

27-26 APB2CKDIV*/

25-24 APB1CKDIV*/

23-22 APB5CKDIV*/

20-16 CLKOUTDIV*/

15-13 GFXCKDIV*/

12-8 SUCKDIV*/

7-4 SU48CKDIV*/

3-0 SD1CKDIV*/

10-6 SPI0CKDV*/

5-1 SPIXCKDV*/

 Register plls */

 Register fixed dividers */

 Register muxes */

 Register clock dividers specified in npcm7xx_divs */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) STMicroelectronics 2018 - All Rights Reserved

 * Author: Olivier Bideau <olivier.bideau@st.com> for STMicroelectronics.

 * Author: Gabriel Fernandez <gabriel.fernandez@st.com> for STMicroelectronics.

 STM32 Composite clock */

 MP1 Gate clock with set & clear registers */

 STM32 PLL */

 lock pll enable/disable registers */

	/* We can't use readl_poll_timeout() because we can be blocked if

	 * someone enables this clock before clocksource changes.

	 * Only jiffies counter is available. Jiffies are incremented by

	 * interruptions and enable op does not allow to be interrupted.

 Kernel Timer */

 lock the kernel output divider register */

 The divider of RTC clock concerns only ck_hse clock */

 STM32 GATE */

 Peripheral gates */

 Multi gates */

 Kernel multi mux */

  Kernel simple mux */

  External / Internal Oscillators */

 ck_csi is used by IO compensation and should be critical */

 PLLs */

 ODF */

 MUX system clocks */

 Kernel Timers */

 Peripheral clocks */

 Kernel clocks */

 Particulary Kernel Clocks (no mux or no gate) */

 RTC clock */

 MCO clocks */

 Debug clocks */

 reset lock */

 RCC Reset Configuration */

 RCC Clock Configuration */

 Device gets a reference count on the clock */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Driver for Silicon Labs Si514 Programmable Oscillator

 *

 * Copyright (C) 2015 Topic Embedded Products

 *

 * Author: Mike Looijmans <mike.looijmans@topic.nl>

 I2C registers */

 Register values */

 Multiplier/divider settings */

 29-bit Fractional part of multiplier M */

 Integer part of multiplier M, 65..78 */

 2nd divider, as 2^x */

 1st divider, must be even and 10<=x<=1022 */

 Enables or disables the output driver */

 Retrieve clock multiplier and dividers from hardware */

 Calculate LP1/LP2 according to table 13 in the datasheet */

 65.259980246 */

 67.859763463 */

 72.937624981 */

 75.843265046 */

	/*

	 * Writing to SI514_REG_M_INT_FRAC triggers the clock change, so that

	 * must be written last

 Calculate divider settings for a given frequency */

 Determine the minimum value of LS_DIV and resulting target freq. */

 Determine minimum HS_DIV, round up to even number */

 M = LS_DIV x HS_DIV x frequency / F_XO (in fixed-point) */

 Calculate resulting frequency given the register settings */

/*

 * Update output frequency for big frequency changes (> 1000 ppm).

 * The chip supports <1000ppm changes "on the fly", we haven't implemented

 * that here.

 Undefined state now, best to leave disabled */

 Trigger calibration */

 Applying a new frequency can take up to 10ms */

 SPDX-License-Identifier: GPL-2.0

/*

 * LMK04832 Ultra Low-Noise JESD204B Compliant Clock Jitter Cleaner

 * Pin compatible with the LMK0482x family

 *

 * Datasheet: https://www.ti.com/lit/ds/symlink/lmk04832.pdf

 *

 * Copyright (c) 2020, Xiphos Systems Corp.

 *

 0x000 - 0x00d System Functions */

 0x100 - 0x137 Device Clock and SYSREF Clock Output Control */

 0x138 - 0x145 SYSREF, SYNC, and Device Config */

 0x146 - 0x14a CLKin Control */

 0x14b - 0x152 Holdover */

 0x153 - 0x15f PLL1 Configuration */

 0x160 - 0x16e PLL2 Configuration */

 0x16F - 0x555 Misc Registers */

/**

 * lmk04832_device_info - Holds static device information that is specific to

 *                        the chip revision

 *

 * pid:          Product Identifier

 * maskrev:      IC version identifier

 * num_channels: Number of available output channels (clkout count)

 * vco0_range:   {min, max} of the VCO0 operating range (in MHz)

 * vco1_range:   {min, max} of the VCO1 operating range (in MHz)

 WARNING PROD_ID is inverted in the datasheet */

/**

 * struct lmk04832 - The LMK04832 device structure

 *

 * @dev: reference to a struct device, linked to the spi_device

 * @regmap: struct regmap instance use to access the chip

 * @sync_mode: operational mode for SYNC signal

 * @sysref_mux: select SYSREF source

 * @sysref_pulse_cnt: number of SYSREF pulses generated while not in continuous

 *                    mode.

 * @sysref_ddly: SYSREF digital delay value

 * @oscin: PLL2 input clock

 * @vco: reference to the internal VCO clock

 * @sclk: reference to the internal sysref clock (SCLK)

 * @vco_rate: user provided VCO rate

 * @reset_gpio: reference to the reset GPIO

 * @dclk: list of internal device clock references.

 *        Each pair of clkout clocks share a single device clock (DCLKX_Y)

 * @clkout: list of output clock references

 * @clk_data: holds clkout related data like clk_hw* and number of clocks

 Don't set LMK04832_BIT_OSCIN_PD since other clocks depend on it */

/**

 * lmk04832_check_vco_ranges - Check requested VCO frequency against VCO ranges

 *

 * @lmk:   Reference to the lmk device

 * @rate:  Desired output rate for the VCO

 *

 * The LMK04832 has 2 internal VCO, each with independent operating ranges.

 * Use the device_info structure to determine which VCO to use based on rate.

 *

 * Returns VCO_MUX value or negative errno.

/**

 * lmk04832_calc_pll2_params - Get PLL2 parameters used to set the VCO frequency

 *

 * @prate: parent rate to the PLL2, usually OSCin

 * @rate:  Desired output rate for the VCO

 * @n:     reference to PLL2_N

 * @p:     reference to PLL2_P

 * @r:     reference to PLL2_R

 *

 * This functions assumes LMK04832_BIT_PLL2_MISC_REF_2X_EN is set since it is

 * recommended in the datasheet because a higher phase detector frequencies

 * makes the design of wider loop bandwidth filters possible.

 *

 * the VCO rate can be calculated using the following expression:

 *

 *	VCO = OSCin * 2 * PLL2_N * PLL2_P / PLL2_R

 *

 * Returns vco rate or negative errno.

 Set PLL2_P to a fixed value to simplify optimizations */

	/*

	 * PLL2_N registers must be programmed after other PLL2 dividers are

	 * programmed to ensure proper VCO frequency calibration

/*

 * lmk04832_register_vco - Initialize the internal VCO and clock distribution

 *                         path in PLL2 single loop mode.

/** lmk04832_sclk_sync - Establish deterministic phase relationship between sclk

 *                       and dclk

 *

 * @lmk: Reference to the lmk device

 *

 * The synchronization sequence:

 * - in the datasheet https://www.ti.com/lit/ds/symlink/lmk04832.pdf, p.31

 *   (8.3.3.1 How to enable SYSREF)

 * - Ti forum: https://e2e.ti.com/support/clock-and-timing/f/48/t/970972

 *

 * Returns 0 or negative errno.

 1. (optional) mute all sysref_outputs during synchronization */

 2. Enable and write device clock digital delay to applicable clocks */

	/*

	 * 3. Configure SYNC_MODE to SYNC_PIN and SYSREF_MUX to Normal SYNC,

	 *    and clear SYSREF_REQ_EN (see 6.)

 4. Clear SYNXC_DISx or applicable clocks and clear SYNC_DISSYSREF */

	/*

	 * 5. If SCLKX_Y_DDLY != 0, Set SYSREF_CLR=1 for at least 15 clock

	 *    distribution path cycles (VCO cycles), then back to 0. In

	 *    PLL2-only use case, this will be complete in less than one SPI

	 *    transaction. If SYSREF local digital delay is not used, this step

	 *    can be skipped.

	/*

	 * 6. Toggle SYNC_POL state between inverted and not inverted.

	 *    If you use an external signal on the SYNC pin instead of toggling

	 *    SYNC_POL, make sure that SYSREF_REQ_EN=0 so that the SYSREF_MUX

	 *    does not shift into continuous SYSREF mode.

 7. Set all SYNC_DISx=1, including SYNC_DISSYSREF */

 8. Restore state of SYNC_MODE and SYSREF_MUX to desired values */

	/*

	 * 9. (optional) if SCLKx_y_DIS_MODE was used to mute SYSREF outputs

	 *    during the SYNC event, restore SCLKx_y_DIS_MODE=0 for active state,

	 *    or set SYSREF_GBL_PD=0 if SCLKx_y_DIS_MODE is set to a conditional

	 *    option.

	/*

	 * 10. (optional) To reduce power consumption, after the synchronization

	 *     event is complete, DCLKx_y_DDLY_PD=1 and SYSREF_DDLY_PD=1 disable the

	 *     digital delay counters (which are only used immediately after the

	 *     SYNC pulse to delay the output by some number of VCO counts).

 Enable Duty Cycle Correction */

	/*

	 * While using Divide-by-2 or Divide-by-3 for DCLK_X_Y_DIV, SYNC

	 * procedure requires to first program Divide-by-4 and then back to

	 * Divide-by-2 or Divide-by-3 before doing SYNC.

 Set initial parent */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Nomadik clock implementation

 * Copyright (C) 2013 ST-Ericsson AB

 * Author: Linus Walleij <linus.walleij@linaro.org>

/*

 * The Nomadik clock tree is described in the STN8815A12 DB V4.2

 * reference manual for the chip, page 94 ff.

 * Clock IDs are in the STn8815 Reference Manual table 3, page 27.

 Lock protecting the SRC_CR register */

 Base address of the SRC */

 The main chrystal need to be enabled for reboot to work */

 sentinel */ }

 Set all timers to use the 2.4 MHz TIMCLK */

 The machine uses an external oscillator circuit */

 Disable this too: also run by external oscillator */

/**

 * struct clk_pll1 - Nomadik PLL1 clock

 * @hw: corresponding clock hardware entry

 * @id: PLL instance: 1 or 2

/**

 * struct clk_src - Nomadik src clock

 * @hw: corresponding clock hardware entry

 * @id: the clock ID

 * @group1: true if the clock is in group1, else it is in group0

 * @clkbit: bit 0...31 corresponding to the clock in each clock register

 Unknown PLL */

/*

 * The Nomadik SRC clocks are gated, but not in the sense that

 * you read-modify-write a register. Instead there are separate

 * clock enable and clock disable registers. Writing a '1' bit in

 * the enable register for a certain clock ungates that clock without

 * affecting the other clocks. The disable register works the opposite

 * way.

 spin until enabled */

 spin until disabled */

 Do not force-disable the static SDRAM controller */

 Vital for multiplatform */

	/*

	 * The HCLK divides PLL1 with 1 (passthru), 2, 3 or 4.

 SPDX-License-Identifier: GPL-2.0

 This chip has only one register of 8 bit width. */

/*

 * Ordered by frequency. For frequency the hardware can generate with

 * multiple settings, the one with lowest jitter is listed first.

 sentinel */

/*

 * CLKOUT - configurable clock output

 Exact matches */

		/*

		 * Find the first entry that has a frequency higher than the

		 * requested one.

			/*

			 * If this is the first entry, clamp the value to the

			 * lowest possible frequency.

			/*

			 * Otherwise, determine whether the previous entry or

			 * current one is closer.

 If the last entry was still too high, clamp the value */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2010-2011 Canonical Ltd <jeremy.kerr@canonical.com>

 * Copyright (C) 2011-2012 Linaro Ltd <mturquette@linaro.org>

 *

 * Standard functionality for the common clock API.  See Documentation/driver-api/clk.rst

**    private data structures    ***/

**           runtime pm          ***/

**           locking             ***/

	/*

	 * On UP systems, spin_trylock_irqsave() always returns true, even if

	 * we already hold the lock. So, in that case, we rely only on

	 * reference counting.

	/*

	 * .is_prepared is optional for clocks that can prepare

	 * fall back to software usage counter if it is missing

	/*

	 * .is_enabled is only mandatory for clocks that gate

	 * fall back to software usage counter if .is_enabled is missing

	/*

	 * Check if clock controller's device is runtime active before

	 * calling .is_enabled callback. If not, assume that clock is

	 * disabled, because we might be called from atomic context, from

	 * which pm_runtime_get() is not allowed.

	 * This function is called mainly from clk_disable_unused_subtree,

	 * which ensures proper runtime pm activation of controller before

	 * taking enable spinlock, but the below check is needed if one tries

	 * to call it from other places.

**    helper functions   ***/

 search the 'proper' clk tree first */

 if not found, then search the orphan tree */

/**

 * clk_core_get - Find the clk_core parent of a clk

 * @core: clk to find parent of

 * @p_index: parent index to search for

 *

 * This is the preferred method for clk providers to find the parent of a

 * clk when that parent is external to the clk controller. The parent_names

 * array is indexed and treated as a local name matching a string in the device

 * node's 'clock-names' property or as the 'con_id' matching the device's

 * dev_name() in a clk_lookup. This allows clk providers to use their own

 * namespace instead of looking for a globally unique parent string.

 *

 * For example the following DT snippet would allow a clock registered by the

 * clock-controller@c001 that has a clk_init_data::parent_data array

 * with 'xtal' in the 'name' member to find the clock provided by the

 * clock-controller@f00abcd without needing to get the globally unique name of

 * the xtal clk.

 *

 *      parent: clock-controller@f00abcd {

 *              reg = <0xf00abcd 0xabcd>;

 *              #clock-cells = <0>;

 *      };

 *

 *      clock-controller@c001 {

 *              reg = <0xc001 0xf00d>;

 *              clocks = <&parent>;

 *              clock-names = "xtal";

 *              #clock-cells = <1>;

 *      };

 *

 * Returns: -ENOENT when the provider can't be found or the clk doesn't

 * exist in the provider or the name can't be found in the DT node or

 * in a clkdev lookup. NULL when the provider knows about the clk but it

 * isn't provided on this system.

 * A valid clk_core pointer when the clk can be found in the provider.

		/*

		 * If the DT search above couldn't find the provider fallback to

		 * looking up via clkdev based clk_lookups.

		/*

		 * We have a direct reference but it isn't registered yet?

		 * Orphan it and let clk_reparent() update the orphan status

		 * when the parent is registered.

 Only cache it if it's not an error */

	/*

	 * Clk must have a parent because num_parents > 0 but the parent isn't

	 * known yet. Best to return 0 as the rate of this clk until we can

	 * properly recalc the rate based on the parent's rate.

 if NO_REPARENT flag set, pass through to current parent */

 find the parent that can provide the fastest rate <= rate */

/*

 * __clk_mux_determine_rate - clk_ops::determine_rate implementation for a mux type clk

 * @hw: mux type clk to determine rate on

 * @req: rate request, also used to return preferred parent and frequencies

 *

 * Helper for finding best parent to provide a given frequency. This can be used

 * directly as a determine_rate callback (e.g. for a mux), or from a more

 * complex clock that may combine a mux with other operations.

 *

 * Returns: 0 on success, -EERROR value on error

**        clk api        ***/

/**

 * clk_rate_exclusive_put - release exclusivity over clock rate control

 * @clk: the clk over which the exclusivity is released

 *

 * clk_rate_exclusive_put() completes a critical section during which a clock

 * consumer cannot tolerate any other consumer making any operation on the

 * clock which could result in a rate change or rate glitch. Exclusive clocks

 * cannot have their rate changed, either directly or indirectly due to changes

 * further up the parent chain of clocks. As a result, clocks up parent chain

 * also get under exclusive control of the calling consumer.

 *

 * If exlusivity is claimed more than once on clock, even by the same consumer,

 * the rate effectively gets locked as exclusivity can't be preempted.

 *

 * Calls to clk_rate_exclusive_put() must be balanced with calls to

 * clk_rate_exclusive_get(). Calls to this function may sleep, and do not return

 * error status.

	/*

	 * if there is something wrong with this consumer protect count, stop

	 * here before messing with the provider

/**

 * clk_rate_exclusive_get - get exclusivity over the clk rate control

 * @clk: the clk over which the exclusity of rate control is requested

 *

 * clk_rate_exclusive_get() begins a critical section during which a clock

 * consumer cannot tolerate any other consumer making any operation on the

 * clock which could result in a rate change or rate glitch. Exclusive clocks

 * cannot have their rate changed, either directly or indirectly due to changes

 * further up the parent chain of clocks. As a result, clocks up parent chain

 * also get under exclusive control of the calling consumer.

 *

 * If exlusivity is claimed more than once on clock, even by the same consumer,

 * the rate effectively gets locked as exclusivity can't be preempted.

 *

 * Calls to clk_rate_exclusive_get() should be balanced with calls to

 * clk_rate_exclusive_put(). Calls to this function may sleep.

 * Returns 0 on success, -EERROR otherwise

/**

 * clk_unprepare - undo preparation of a clock source

 * @clk: the clk being unprepared

 *

 * clk_unprepare may sleep, which differentiates it from clk_disable.  In a

 * simple case, clk_unprepare can be used instead of clk_disable to gate a clk

 * if the operation may sleep.  One example is a clk which is accessed over

 * I2c.  In the complex case a clk gate operation may require a fast and a slow

 * part.  It is this reason that clk_unprepare and clk_disable are not mutually

 * exclusive.  In fact clk_disable must be called before clk_unprepare.

	/*

	 * CLK_SET_RATE_GATE is a special case of clock protection

	 * Instead of a consumer claiming exclusive rate control, it is

	 * actually the provider which prevents any consumer from making any

	 * operation which could result in a rate change or rate glitch while

	 * the clock is prepared.

/**

 * clk_prepare - prepare a clock source

 * @clk: the clk being prepared

 *

 * clk_prepare may sleep, which differentiates it from clk_enable.  In a simple

 * case, clk_prepare can be used instead of clk_enable to ungate a clk if the

 * operation may sleep.  One example is a clk which is accessed over I2c.  In

 * the complex case a clk ungate operation may require a fast and a slow part.

 * It is this reason that clk_prepare and clk_enable are not mutually

 * exclusive.  In fact clk_prepare must be called before clk_enable.

 * Returns 0 on success, -EERROR otherwise.

/**

 * clk_disable - gate a clock

 * @clk: the clk being gated

 *

 * clk_disable must not sleep, which differentiates it from clk_unprepare.  In

 * a simple case, clk_disable can be used instead of clk_unprepare to gate a

 * clk if the operation is fast and will never sleep.  One example is a

 * SoC-internal clk which is controlled via simple register writes.  In the

 * complex case a clk gate operation may require a fast and a slow part.  It is

 * this reason that clk_unprepare and clk_disable are not mutually exclusive.

 * In fact clk_disable must be called before clk_unprepare.

/**

 * clk_gate_restore_context - restore context for poweroff

 * @hw: the clk_hw pointer of clock whose state is to be restored

 *

 * The clock gate restore context function enables or disables

 * the gate clocks based on the enable_count. This is done in cases

 * where the clock context is lost and based on the enable_count

 * the clock either needs to be enabled/disabled. This

 * helps restore the state of gate clocks.

/**

 * clk_save_context - save clock context for poweroff

 *

 * Saves the context of the clock register for powerstates in which the

 * contents of the registers will be lost. Occurs deep within the suspend

 * code.  Returns 0 on success.

/**

 * clk_restore_context - restore clock context after poweroff

 *

 * Restore the saved clock context upon resume.

 *

/**

 * clk_enable - ungate a clock

 * @clk: the clk being ungated

 *

 * clk_enable must not sleep, which differentiates it from clk_prepare.  In a

 * simple case, clk_enable can be used instead of clk_prepare to ungate a clk

 * if the operation will never sleep.  One example is a SoC-internal clk which

 * is controlled via simple register writes.  In the complex case a clk ungate

 * operation may require a fast and a slow part.  It is this reason that

 * clk_enable and clk_prepare are not mutually exclusive.  In fact clk_prepare

 * must be called before clk_enable.  Returns 0 on success, -EERROR

 * otherwise.

/**

 * clk_is_enabled_when_prepared - indicate if preparing a clock also enables it.

 * @clk: clock source

 *

 * Returns true if clk_prepare() implicitly enables the clock, effectively

 * making clk_enable()/clk_disable() no-ops, false otherwise.

 *

 * This is of interest mainly to power management code where actually

 * disabling the clock also requires unpreparing it to have any material

 * effect.

 *

 * Regardless of the value returned here, the caller must always invoke

 * clk_enable() or clk_prepare_enable()  and counterparts for usage counts

 * to be right.

	/*

	 * some gate clocks have special needs during the disable-unused

	 * sequence.  call .disable_unused if available, otherwise fall

	 * back to .disable

	/*

	 * At this point, core protection will be disabled

	 * - if the provider is not protected at all

	 * - if the calling consumer is the only one which has exclusivity

	 *   over the provider

/**

 * __clk_determine_rate - get the closest rate actually supported by a clock

 * @hw: determine the rate of this clock

 * @req: target rate request

 *

 * Useful for clk_ops such as .set_rate and .determine_rate.

/**

 * clk_hw_round_rate() - round the given rate for a hw clk

 * @hw: the hw clk for which we are rounding a rate

 * @rate: the rate which is to be rounded

 *

 * Takes in a rate as input and rounds it to a rate that the clk can actually

 * use.

 *

 * Context: prepare_lock must be held.

 *          For clk providers to call from within clk_ops such as .round_rate,

 *          .determine_rate.

 *

 * Return: returns rounded rate of hw clk if clk supports round_rate operation

 *         else returns the parent rate.

/**

 * clk_round_rate - round the given rate for a clk

 * @clk: the clk for which we are rounding a rate

 * @rate: the rate which is to be rounded

 *

 * Takes in a rate as input and rounds it to a rate that the clk can actually

 * use which is then returned.  If clk doesn't support round_rate operation

 * then the parent rate is returned.

/**

 * __clk_notify - call clk notifier chain

 * @core: clk that is changing rate

 * @msg: clk notifier type (see include/linux/clk.h)

 * @old_rate: old clk rate

 * @new_rate: new clk rate

 *

 * Triggers a notifier call chain on the clk rate-change notification

 * for 'clk'.  Passes a pointer to the struct clk and the previous

 * and current rates to the notifier callback.  Intended to be called by

 * internal clock code only.  Returns NOTIFY_DONE from the last driver

 * called if all went well, or NOTIFY_STOP or NOTIFY_BAD immediately if

 * a driver returns that.

/**

 * __clk_recalc_accuracies

 * @core: first clk in the subtree

 *

 * Walks the subtree of clks starting with clk and recalculates accuracies as

 * it goes.  Note that if a clk does not implement the .recalc_accuracy

 * callback then it is assumed that the clock will take on the accuracy of its

 * parent.

/**

 * clk_get_accuracy - return the accuracy of clk

 * @clk: the clk whose accuracy is being returned

 *

 * Simply returns the cached accuracy of the clk, unless

 * CLK_GET_ACCURACY_NOCACHE flag is set, which means a recalc_rate will be

 * issued.

 * If clk is NULL then returns 0.

/**

 * __clk_recalc_rates

 * @core: first clk in the subtree

 * @msg: notification type (see include/linux/clk.h)

 *

 * Walks the subtree of clks starting with clk and recalculates rates as it

 * goes.  Note that if a clk does not implement the .recalc_rate callback then

 * it is assumed that the clock will take on the rate of its parent.

 *

 * clk_recalc_rates also propagates the POST_RATE_CHANGE notification,

 * if necessary.

	/*

	 * ignore NOTIFY_STOP and NOTIFY_BAD return values for POST_RATE_CHANGE

	 * & ABORT_RATE_CHANGE notifiers

/**

 * clk_get_rate - return the rate of clk

 * @clk: the clk whose rate is being returned

 *

 * Simply returns the cached rate of the clk, unless CLK_GET_RATE_NOCACHE flag

 * is set, which means a recalc_rate will be issued.

 * If clk is NULL then returns 0.

 Found it first try! */

 Something else is here, so keep looking */

 Maybe core hasn't been cached but the hw is all we know? */

 Didn't match, but we're expecting a clk_hw */

 Maybe it hasn't been cached (clk_set_parent() path) */

 Fallback to comparing globally unique names */

/**

 * clk_hw_get_parent_index - return the index of the parent clock

 * @hw: clk_hw associated with the clk being consumed

 *

 * Fetches and returns the index of parent clock. Returns -EINVAL if the given

 * clock does not have a current parent.

/*

 * Update the orphan status of @core and all its children.

 avoid duplicate POST_RATE_CHANGE notifications */

	/*

	 * 1. enable parents for CLK_OPS_PARENT_ENABLE clock

	 *

	 * 2. Migrate prepare state between parents and prevent race with

	 * clk_enable().

	 *

	 * If the clock is not prepared, then a race with

	 * clk_enable/disable() is impossible since we already have the

	 * prepare lock (future calls to clk_enable() need to be preceded by

	 * a clk_prepare()).

	 *

	 * If the clock is prepared, migrate the prepared state to the new

	 * parent and also protect against a race with clk_enable() by

	 * forcing the clock and the new parent on.  This ensures that all

	 * future calls to clk_enable() are practically NOPs with respect to

	 * hardware and software states.

	 *

	 * See also: Comment for clk_set_parent() below.

 enable old_parent & parent if CLK_OPS_PARENT_ENABLE is set */

 migrate prepare count if > 0 */

 update the clk tree topology */

	/*

	 * Finish the migration of prepare state and undo the changes done

	 * for preventing a race with clk_enable().

 re-balance ref counting if CLK_OPS_PARENT_ENABLE is set */

 change clock input source */

/**

 * __clk_speculate_rates

 * @core: first clk in the subtree

 * @parent_rate: the "future" rate of clk's parent

 *

 * Walks the subtree of clks starting with clk, speculating rates as it

 * goes and firing off PRE_RATE_CHANGE notifications as necessary.

 *

 * Unlike clk_recalc_rates, clk_speculate_rates exists only for sending

 * pre-rate change notifications and returns early if no clks in the

 * subtree have subscribed to the notifications.  Note that if a clk does not

 * implement the .recalc_rate callback then it is assumed that the clock will

 * take on the rate of its parent.

 abort rate change if a driver returns NOTIFY_BAD or NOTIFY_STOP */

 include clk in new parent's PRE_RATE_CHANGE notifications */

/*

 * calculate the new rates returning the topmost clock that has to be

 * changed.

 sanity */

 save parent rate, if it exists */

 find the closest rate and parent clk/rate */

 pass-through clock without adjustable parent */

 pass-through clock with adjustable parent */

 some clocks must be gated to change parent */

 try finding the new parent index */

/*

 * Notify about rate changes in a subtree. Always walk down the whole tree

 * so that in case of an error we can walk down the whole tree again and

 * abort the change.

 Skip children who will be reparented to another clock */

 handle the new child who might not be in core->children yet */

/*

 * walk down a subtree and set the new rates notifying the rate

 * change on the way

	/*

	 * Use safe iteration, as change_rate can actually swap parents

	 * for certain clock types.

 Skip children who will be reparented to another clock */

 handle the new child who might not be in core->children yet */

 simulate what the rate would be if it could be freely set */

 restore the protection */

 bail early if nothing to do */

 fail on a direct rate set of a protected provider */

 calculate new rates and get the topmost changed clock */

 notify that we are about to change rates */

 change the rates */

/**

 * clk_set_rate - specify a new rate for clk

 * @clk: the clk whose rate is being changed

 * @rate: the new rate for clk

 *

 * In the simplest case clk_set_rate will only adjust the rate of clk.

 *

 * Setting the CLK_SET_RATE_PARENT flag allows the rate change operation to

 * propagate up to clk's parent; whether or not this happens depends on the

 * outcome of clk's .round_rate implementation.  If *parent_rate is unchanged

 * after calling .round_rate then upstream parent propagation is ignored.  If

 * *parent_rate comes back with a new rate for clk's parent then we propagate

 * up to clk's parent and set its rate.  Upward propagation will continue

 * until either a clk does not support the CLK_SET_RATE_PARENT flag or

 * .round_rate stops requesting changes to clk's parent_rate.

 *

 * Rate changes are accomplished via tree traversal that also recalculates the

 * rates for the clocks and fires off POST_RATE_CHANGE notifiers.

 *

 * Returns 0 on success, -EERROR otherwise.

 prevent racing with updates to the clock topology */

/**

 * clk_set_rate_exclusive - specify a new rate and get exclusive control

 * @clk: the clk whose rate is being changed

 * @rate: the new rate for clk

 *

 * This is a combination of clk_set_rate() and clk_rate_exclusive_get()

 * within a critical section

 *

 * This can be used initially to ensure that at least 1 consumer is

 * satisfied when several consumers are competing for exclusivity over the

 * same clock provider.

 *

 * The exclusivity is not applied if setting the rate failed.

 *

 * Calls to clk_rate_exclusive_get() should be balanced with calls to

 * clk_rate_exclusive_put().

 *

 * Returns 0 on success, -EERROR otherwise.

 prevent racing with updates to the clock topology */

	/*

	 * The temporary protection removal is not here, on purpose

	 * This function is meant to be used instead of clk_rate_protect,

	 * so before the consumer code path protect the clock provider

/**

 * clk_set_rate_range - set a rate range for a clock source

 * @clk: clock source

 * @min: desired minimum clock rate in Hz, inclusive

 * @max: desired maximum clock rate in Hz, inclusive

 *

 * Returns success (0) or negative errno.

 Save the current values in case we need to rollback the change */

		/*

		 * FIXME:

		 * We are in bit of trouble here, current rate is outside the

		 * the requested range. We are going try to request appropriate

		 * range boundary but there is a catch. It may fail for the

		 * usual reason (clock broken, clock protected, etc) but also

		 * because:

		 * - round_rate() was not favorable and fell on the wrong

		 *   side of the boundary

		 * - the determine_rate() callback does not really check for

		 *   this corner case when determining the rate

 rollback the changes */

/**

 * clk_set_min_rate - set a minimum clock rate for a clock source

 * @clk: clock source

 * @rate: desired minimum clock rate in Hz, inclusive

 *

 * Returns success (0) or negative errno.

/**

 * clk_set_max_rate - set a maximum clock rate for a clock source

 * @clk: clock source

 * @rate: desired maximum clock rate in Hz, inclusive

 *

 * Returns success (0) or negative errno.

/**

 * clk_get_parent - return the parent of a clk

 * @clk: the clk whose parent gets returned

 *

 * Simply returns clk->parent.  Returns NULL if clk is NULL.

 TODO: Create a per-user clk and change callers to call clk_put */

/**

 * clk_has_parent - check if a clock is a possible parent for another

 * @clk: clock source

 * @parent: parent clock source

 *

 * This function can be used in drivers that need to check that a clock can be

 * the parent of another without actually changing the parent.

 *

 * Returns true if @parent is a possible parent for @clk, false otherwise.

 NULL clocks should be nops, so return success if either is NULL. */

 Optimize for the case where the parent is already the parent. */

 verify ops for multi-parent clks */

 check that we are allowed to re-parent if the clock is in use */

 try finding the new parent index */

 propagate PRE_RATE_CHANGE notifications */

 abort if a driver objects */

 do the re-parent */

 propagate rate an accuracy recalculation accordingly */

/**

 * clk_set_parent - switch the parent of a mux clk

 * @clk: the mux clk whose input we are switching

 * @parent: the new input to clk

 *

 * Re-parent clk to use parent as its new input source.  If clk is in

 * prepared state, the clk will get enabled for the duration of this call. If

 * that's not acceptable for a specific clk (Eg: the consumer can't handle

 * that, the reparenting is glitchy in hardware, etc), use the

 * CLK_SET_PARENT_GATE flag to allow reparenting only when clk is unprepared.

 *

 * After successfully changing clk's parent clk_set_parent will update the

 * clk topology, sysfs topology and propagate rate recalculation via

 * __clk_recalc_rates.

 *

 * Returns 0 on success, -EERROR otherwise.

/**

 * clk_set_phase - adjust the phase shift of a clock signal

 * @clk: clock signal source

 * @degrees: number of degrees the signal is shifted

 *

 * Shifts the phase of a clock signal by the specified

 * degrees. Returns 0 on success, -EERROR otherwise.

 *

 * This function makes no distinction about the input or reference

 * signal that we adjust the clock signal phase against. For example

 * phase locked-loop clock signal generators we may shift phase with

 * respect to feedback clock signal input, but for other cases the

 * clock phase may be shifted with respect to some other, unspecified

 * signal.

 *

 * Additionally the concept of phase shift does not propagate through

 * the clock tree hierarchy, which sets it apart from clock rates and

 * clock accuracy. A parent clock phase attribute does not have an

 * impact on the phase attribute of a child clock.

 sanity check degrees */

 Always try to update cached phase if possible */

/**

 * clk_get_phase - return the phase shift of a clock signal

 * @clk: clock signal source

 *

 * Returns the phase shift of a clock node in degrees, otherwise returns

 * -EERROR.

 Assume a default value of 50% */

 Don't trust the clock provider too much */

/**

 * clk_set_duty_cycle - adjust the duty cycle ratio of a clock signal

 * @clk: clock signal source

 * @num: numerator of the duty cycle ratio to be applied

 * @den: denominator of the duty cycle ratio to be applied

 *

 * Apply the duty cycle ratio if the ratio is valid and the clock can

 * perform this operation

 *

 * Returns (0) on success, a negative errno otherwise.

 sanity check the ratio */

/**

 * clk_get_scaled_duty_cycle - return the duty cycle ratio of a clock signal

 * @clk: clock signal source

 * @scale: scaling factor to be applied to represent the ratio as an integer

 *

 * Returns the duty cycle ratio of a clock node multiplied by the provided

 * scaling factor, or negative errno on error.

/**

 * clk_is_match - check if two clk's point to the same hardware clock

 * @p: clk compared against q

 * @q: clk compared against p

 *

 * Returns true if the two struct clk pointers both point to the same hardware

 * clock node. Put differently, returns true if struct clk *p and struct clk *q

 * share the same struct clk_core object.

 *

 * Returns false otherwise. Note that two NULL clks are treated as matching.

 trivial case: identical struct clk's or both NULL */

 true if clk->core pointers match. Avoid dereferencing garbage */

**        debugfs support        ***/

 This should be JSON format, i.e. elements separated with a comma */

/*

 * This can be dangerous, therefore don't provide any real compile time

 * configuration option for this feature.

 * People who want to use this will need to modify the source code directly.

 Unknown flags */

	/*

	 * Go through the following options to fetch a parent's name.

	 *

	 * 1. Fetch the registered parent clock and use its name

	 * 2. Use the global (fallback) name if specified

	 * 3. Use the local fw_name if provided

	 * 4. Fetch parent clock's clock-output-name if DT index was set

	 *

	 * This may still fail in some cases, such as when the parent is

	 * specified directly via a struct clk_hw pointer, but it isn't

	 * registered (yet).

/**

 * clk_debug_register - add a clk node to the debugfs clk directory

 * @core: the clk being added to the debugfs clk directory

 *

 * Dynamically adds a clk to the debugfs clk directory if debugfs has been

 * initialized.  Otherwise it bails out early since the debugfs clk directory

 * will be created lazily by clk_debug_init as part of a late_initcall.

 /**

 * clk_debug_unregister - remove a clk node from the debugfs clk directory

 * @core: the clk being removed from the debugfs clk directory

 *

 * Dynamically removes a clk and all its child nodes from the

 * debugfs clk directory if clk->dentry points to debugfs created by

 * clk_debug_register in __clk_core_init.

/**

 * clk_debug_init - lazily populate the debugfs clk directory

 *

 * clks are often initialized very early during boot before memory can be

 * dynamically allocated and well before debugfs is setup. This function

 * populates the debugfs clk directory once at boot-time when we know that

 * debugfs is setup. It should only be called once at boot-time, all other clks

 * added dynamically will be done so with clk_debug_register.

	/*

	 * walk the list of orphan clocks and reparent any that newly finds a

	 * parent.

		/*

		 * We need to use __clk_set_parent_before() and _after() to

		 * to properly migrate any prepare/enable count of the orphan

		 * clock. This is important for CLK_IS_CRITICAL clocks, which

		 * are enabled during init but might not have a parent yet.

 update the clk tree topology */

/**

 * __clk_core_init - initialize the data structures in a struct clk_core

 * @core:	clk_core being initialized

 *

 * Initializes the lists in struct clk_core, queries the hardware for the

 * parent and rate and sets them both.

 check to see if a clock with this name is already registered */

 check that clk_ops are sane.  See Documentation/driver-api/clk.rst */

	/*

	 * optional platform-specific magic

	 *

	 * The .init callback is not used by any of the basic clock types, but

	 * exists for weird hardware that must perform initialization magic for

	 * CCF to get an accurate view of clock for any other callbacks. It may

	 * also be used needs to perform dynamic allocations. Such allocation

	 * must be freed in the terminate() callback.

	 * This callback shall not be used to initialize the parameters state,

	 * such as rate, parent, etc ...

	 *

	 * If it exist, this callback should called before any other callback of

	 * the clock

	/*

	 * Populate core->parent if parent has already been clk_core_init'd. If

	 * parent has not yet been clk_core_init'd then place clk in the orphan

	 * list.  If clk doesn't have any parents then place it in the root

	 * clk list.

	 *

	 * Every time a new clk is clk_init'd then we walk the list of orphan

	 * clocks and re-parent any that are children of the clock currently

	 * being clk_init'd.

	/*

	 * Set clk's accuracy.  The preferred method is to use

	 * .recalc_accuracy. For simple clocks and lazy developers the default

	 * fallback is to use the parent's accuracy.  If a clock doesn't have a

	 * parent (or is orphaned) then accuracy is set to zero (perfect

	 * clock).

	/*

	 * Set clk's phase by clk_core_get_phase() caching the phase.

	 * Since a phase is by definition relative to its parent, just

	 * query the current clock phase, or just assume it's in phase.

	/*

	 * Set clk's duty cycle.

	/*

	 * Set clk's rate.  The preferred method is to use .recalc_rate.  For

	 * simple clocks and lazy developers the default fallback is to use the

	 * parent's rate.  If a clock doesn't have a parent (or is orphaned)

	 * then rate is set to zero.

	/*

	 * Enable CLK_IS_CRITICAL clocks so newly added critical clocks

	 * don't get accidentally disabled when walking the orphan tree and

	 * reparenting clocks

/**

 * clk_core_link_consumer - Add a clk consumer to the list of consumers in a clk_core

 * @core: clk to add consumer to

 * @clk: consumer to link to a clk

/**

 * clk_core_unlink_consumer - Remove a clk consumer from the list of consumers in a clk_core

 * @clk: consumer to unlink

/**

 * alloc_clk - Allocate a clk consumer, but leave it unlinked to the clk_core

 * @core: clk to allocate a consumer for

 * @dev_id: string describing device name

 * @con_id: connection ID string on device

 *

 * Returns: clk consumer left unlinked from the consumer list

/**

 * free_clk - Free a clk consumer

 * @clk: clk consumer to free

 *

 * Note, this assumes the clk has been unlinked from the clk_core consumer

 * list.

/**

 * clk_hw_create_clk: Allocate and link a clk consumer to a clk_core given

 * a clk_hw

 * @dev: clk consumer device

 * @hw: clk_hw associated with the clk being consumed

 * @dev_id: string describing device name

 * @con_id: connection ID string on device

 *

 * This is the main function used to create a clk pointer for use by clk

 * consumers. It connects a consumer to the clk_core and clk_hw structures

 * used by the framework and clk provider respectively.

 This is to allow this function to be chained to others */

/**

 * clk_hw_get_clk - get clk consumer given an clk_hw

 * @hw: clk_hw associated with the clk being consumed

 * @con_id: connection ID string on device

 *

 * Returns: new clk consumer

 * This is the function to be used by providers which need

 * to get a consumer clk and act on the clock element

 * Calls to this function must be balanced with calls clk_put()

	/*

	 * Avoid unnecessary string look-ups of clk_core's possible parents by

	 * having a cache of names/clk_hw pointers to clk_core pointers.

 Copy everything over because it might be __initdata */

 throw a WARN if any entries are NULL */

	/*

	 * The init data is not supposed to be used outside of registration path.

	 * Set it to NULL so that provider drivers can't use it either and so that

	 * we catch use of hw->init early on in the core.

	/*

	 * Don't call clk_hw_create_clk() here because that would pin the

	 * provider module to itself and prevent it from ever being removed.

/**

 * dev_or_parent_of_node() - Get device node of @dev or @dev's parent

 * @dev: Device to get device node of

 *

 * Return: device node pointer of @dev, or the device node pointer of

 * @dev->parent if dev doesn't have a device node, or NULL if neither

 * @dev or @dev->parent have a device node.

/**

 * clk_register - allocate a new clock, register it and return an opaque cookie

 * @dev: device that is registering this clock

 * @hw: link to hardware-specific clock data

 *

 * clk_register is the *deprecated* interface for populating the clock tree with

 * new clock nodes. Use clk_hw_register() instead.

 *

 * Returns: a pointer to the newly allocated struct clk which

 * cannot be dereferenced by driver code but may be used in conjunction with the

 * rest of the clock API.  In the event of an error clk_register will return an

 * error code; drivers must test for an error code after calling clk_register.

/**

 * clk_hw_register - register a clk_hw and return an error code

 * @dev: device that is registering this clock

 * @hw: link to hardware-specific clock data

 *

 * clk_hw_register is the primary interface for populating the clock tree with

 * new clock nodes. It returns an integer equal to zero indicating success or

 * less than zero indicating failure. Drivers must test for an error code after

 * calling clk_hw_register().

/*

 * of_clk_hw_register - register a clk_hw and return an error code

 * @node: device_node of device that is registering this clock

 * @hw: link to hardware-specific clock data

 *

 * of_clk_hw_register() is the primary interface for populating the clock tree

 * with new clock nodes when a struct device is not available, but a struct

 * device_node is. It returns an integer equal to zero indicating success or

 * less than zero indicating failure. Drivers must test for an error code after

 * calling of_clk_hw_register().

 Free memory allocated for a clock. */

/*

 * Empty clk_ops for unregistered clocks. These are used temporarily

 * after clk_unregister() was called on a clock and until last clock

 * consumer calls clk_put() and the struct clk object is freed.

 Remove this clk from all parent caches */

/**

 * clk_unregister - unregister a currently registered clock

 * @clk: clock to unregister

	/*

	 * Assign empty clock ops for consumers that might still hold

	 * a reference to this clock.

 Reparent all children to the orphan list. */

/**

 * clk_hw_unregister - unregister a currently registered clk_hw

 * @hw: hardware-specific clock data to unregister

/**

 * devm_clk_register - resource managed clk_register()

 * @dev: device that is registering this clock

 * @hw: link to hardware-specific clock data

 *

 * Managed clk_register(). This function is *deprecated*, use devm_clk_hw_register() instead.

 *

 * Clocks returned from this function are automatically clk_unregister()ed on

 * driver detach. See clk_register() for more information.

/**

 * devm_clk_hw_register - resource managed clk_hw_register()

 * @dev: device that is registering this clock

 * @hw: link to hardware-specific clock data

 *

 * Managed clk_hw_register(). Clocks registered by this function are

 * automatically clk_hw_unregister()ed on driver detach. See clk_hw_register()

 * for more information.

/**

 * devm_clk_unregister - resource managed clk_unregister()

 * @dev: device that is unregistering the clock data

 * @clk: clock to unregister

 *

 * Deallocate a clock allocated with devm_clk_register(). Normally

 * this function will not need to be called and the resource management

 * code will ensure that the resource is freed.

/**

 * devm_clk_hw_unregister - resource managed clk_hw_unregister()

 * @dev: device that is unregistering the hardware-specific clock data

 * @hw: link to hardware-specific clock data

 *

 * Unregister a clk_hw registered with devm_clk_hw_register(). Normally

 * this function will not need to be called and the resource management

 * code will ensure that the resource is freed.

/**

 * devm_clk_hw_get_clk - resource managed clk_hw_get_clk()

 * @dev: device that is registering this clock

 * @hw: clk_hw associated with the clk being consumed

 * @con_id: connection ID string on device

 *

 * Managed clk_hw_get_clk(). Clocks got with this function are

 * automatically clk_put() on driver detach. See clk_put()

 * for more information.

	/* This should not happen because it would mean we have drivers

	 * passing around clk_hw pointers instead of having the caller use

	 * proper clk_get() style APIs

/*

 * clkdev helpers

	/*

	 * Before calling clk_put, all calls to clk_rate_exclusive_get() from a

	 * given user should be balanced with calls to clk_rate_exclusive_put()

	 * and by that same consumer

 We voiced our concern, let's sanitize the situation */

**        clk rate change notifiers        ***/

/**

 * clk_notifier_register - add a clk rate change notifier

 * @clk: struct clk * to watch

 * @nb: struct notifier_block * with callback info

 *

 * Request notification when clk's rate changes.  This uses an SRCU

 * notifier because we want it to block and notifier unregistrations are

 * uncommon.  The callbacks associated with the notifier must not

 * re-enter into the clk framework by calling any top-level clk APIs;

 * this will cause a nested prepare_lock mutex.

 *

 * In all notification cases (pre, post and abort rate change) the original

 * clock rate is passed to the callback via struct clk_notifier_data.old_rate

 * and the new frequency is passed via struct clk_notifier_data.new_rate.

 *

 * clk_notifier_register() must be called from non-atomic context.

 * Returns -EINVAL if called with null arguments, -ENOMEM upon

 * allocation failure; otherwise, passes along the return value of

 * srcu_notifier_chain_register().

 search the list of notifiers for this clk */

 if clk wasn't in the notifier list, allocate new clk_notifier */

/**

 * clk_notifier_unregister - remove a clk rate change notifier

 * @clk: struct clk *

 * @nb: struct notifier_block * with callback info

 *

 * Request no further notification for changes to 'clk' and frees memory

 * allocated in clk_notifier_register.

 *

 * Returns -EINVAL if called with null arguments; otherwise, passes

 * along the return value of srcu_notifier_chain_unregister().

 XXX the notifier code should handle this better */

/**

 * struct of_clk_provider - Clock provider registration structure

 * @link: Entry in global list of clock providers

 * @node: Pointer to device tree node of clock provider

 * @get: Get clock callback.  Returns NULL or a struct clk for the

 *       given clock specifier

 * @get_hw: Get clk_hw callback.  Returns NULL, ERR_PTR or a

 *       struct clk_hw for the given clock specifier

 * @data: context pointer to be passed into @get callback

/**

 * of_clk_add_provider() - Register a clock provider for a node

 * @np: Device node pointer associated with clock provider

 * @clk_src_get: callback for decoding clock

 * @data: context pointer for @clk_src_get callback.

 *

 * This function is *deprecated*. Use of_clk_add_hw_provider() instead.

/**

 * of_clk_add_hw_provider() - Register a clock provider for a node

 * @np: Device node pointer associated with clock provider

 * @get: callback for decoding clk_hw

 * @data: context pointer for @get callback.

/*

 * We allow a child device to use its parent device as the clock provider node

 * for cases like MFD sub-devices where the child device driver wants to use

 * devm_*() APIs but not list the device in DT as a sub-node.

/**

 * devm_of_clk_add_hw_provider() - Managed clk provider node registration

 * @dev: Device acting as the clock provider (used for DT node and lifetime)

 * @get: callback for decoding clk_hw

 * @data: context pointer for @get callback

 *

 * Registers clock provider for given device's node. If the device has no DT

 * node or if the device node lacks of clock provider information (#clock-cells)

 * then the parent device's node is scanned for this information. If parent node

 * has the #clock-cells then it is used in registration. Provider is

 * automatically released at device exit.

 *

 * Return: 0 on success or an errno on failure.

/**

 * of_clk_del_provider() - Remove a previously registered clock provider

 * @np: Device node pointer associated with clock provider

/**

 * devm_of_clk_del_provider() - Remove clock provider registered using devm

 * @dev: Device to whose lifetime the clock provider was bound

/**

 * of_parse_clkspec() - Parse a DT clock specifier for a given device node

 * @np: device node to parse clock specifier from

 * @index: index of phandle to parse clock out of. If index < 0, @name is used

 * @name: clock name to find and parse. If name is NULL, the index is used

 * @out_args: Result of parsing the clock specifier

 *

 * Parses a device node's "clocks" and "clock-names" properties to find the

 * phandle and cells for the index or name that is desired. The resulting clock

 * specifier is placed into @out_args, or an errno is returned when there's a

 * parsing error. The @index argument is ignored if @name is non-NULL.

 *

 * Example:

 *

 * phandle1: clock-controller@1 {

 *	#clock-cells = <2>;

 * }

 *

 * phandle2: clock-controller@2 {

 *	#clock-cells = <1>;

 * }

 *

 * clock-consumer@3 {

 *	clocks = <&phandle1 1 2 &phandle2 3>;

 *	clock-names = "name1", "name2";

 * }

 *

 * To get a device_node for `clock-controller@2' node you may call this

 * function a few different ways:

 *

 *   of_parse_clkspec(clock-consumer@3, -1, "name2", &args);

 *   of_parse_clkspec(clock-consumer@3, 1, NULL, &args);

 *   of_parse_clkspec(clock-consumer@3, 1, "name2", &args);

 *

 * Return: 0 upon successfully parsing the clock specifier. Otherwise, -ENOENT

 * if @name is NULL or -EINVAL if @name is non-NULL and it can't be found in

 * the "clock-names" property of @np.

 Walk up the tree of devices looking for a clock property that matches */

		/*

		 * For named clocks, first look up the name in the

		 * "clock-names" property.  If it cannot be found, then index

		 * will be an error code and of_parse_phandle_with_args() will

		 * return -EINVAL.

		/*

		 * No matching clock found on this node.  If the parent node

		 * has a "clock-ranges" property, then we can try one of its

		 * clocks.

/**

 * of_clk_get_from_provider() - Lookup a clock from a clock provider

 * @clkspec: pointer to a clock specifier data structure

 *

 * This function looks up a struct clk from the registered list of clock

 * providers, an input is a clock specifier data structure as returned

 * from the of_parse_phandle_with_args() function call.

/**

 * of_clk_get_by_name() - Parse and lookup a clock referenced by a device node

 * @np: pointer to clock consumer node

 * @name: name of consumer's clock input, or NULL for the first clock reference

 *

 * This function parses the clocks and clock-names properties,

 * and uses them to look up the struct clk from the registered list of clock

 * providers.

/**

 * of_clk_get_parent_count() - Count the number of clocks a device node has

 * @np: device node to count

 *

 * Returns: The number of clocks that are possible parents of this node

	/* if there is an indices property, use it to transfer the index

	 * specified into an array offset for the clock-output-names property.

 We went off the end of 'clock-indices' without finding it */

		/*

		 * Best effort to get the name if the clock has been

		 * registered with the framework. If the clock isn't

		 * registered, we return the node name as the name of

		 * the clock as long as #clock-cells = 0.

/**

 * of_clk_parent_fill() - Fill @parents with names of @np's parents and return

 * number of parents

 * @np: Device node pointer associated with clock provider

 * @parents: pointer to char array that hold the parents' names

 * @size: size of the @parents array

 *

 * Return: number of parents for the clock node.

/*

 * This function looks for a parent clock. If there is one, then it

 * checks that the provider for this parent clock was initialized, in

 * this case the parent clock will be ready.

 this parent is ready we can check the next one */

 at least one parent is not ready, we exit now */

		/*

		 * Here we make assumption that the device tree is

		 * written correctly. So an error means that there is

		 * no more parent. As we didn't exit yet, then the

		 * previous parent are ready. If there is no clock

		 * parent, no need to wait for them, then we can

		 * consider their absence as being ready

/**

 * of_clk_detect_critical() - set CLK_IS_CRITICAL flag from Device Tree

 * @np: Device node pointer associated with clock provider

 * @index: clock index

 * @flags: pointer to top-level framework flags

 *

 * Detects if the clock-critical property exists and, if so, sets the

 * corresponding CLK_IS_CRITICAL flag.

 *

 * Do not use this function. It exists only for legacy Device Tree

 * bindings, such as the one-clock-per-node style that are outdated.

 * Those bindings typically put all clock data into .dts and the Linux

 * driver has no clock data, thus making it impossible to set this flag

 * correctly from the driver. Only those drivers may call

 * of_clk_detect_critical from their setup functions.

 *

 * Return: error code or zero on success

/**

 * of_clk_init() - Scan and init clock providers from the DT

 * @matches: array of compatible values and init functions for providers.

 *

 * This function scans the device tree for matching clock providers

 * and calls their initialization functions. It also does it by trying

 * to follow the dependencies.

 First prepare the list of the clocks providers */

 Don't populate platform devices */

		/*

		 * We didn't manage to initialize any of the

		 * remaining providers during the last loop, so now we

		 * initialize all the remaining ones unconditionally

		 * in case the clock parent was not mandatory

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Cirrus Logic CLPS711X CLK driver

 *

 *  Copyright (C) 2014 Alexander Shiyan <shc_work@mail.ru>

 Read PLL multiplier value and sanity check */

	/* Timer1 in free running mode.

	 * Counter will wrap around to 0xffff when it underflows

	 * and will continue to count down.

	/* Timer2 in prescale mode.

	 * Value writen is automatically re-loaded when

	 * the counter underflows.

 SPDX-License-Identifier: GPL-2.0+

 Copyright IBM Corp

 Globally visible clocks */

 Keeps track of all clocks */

 TODO: ask Aspeed about the actual parent data */

				 clk rst   name			parent	flags */

 Video Engine */

 2D engine */

 SDRAM */

 Video Capture */

 PCIe/PCI */

 DAC */

 USB2.0 Host port 2 */

 LPC */

 USB1.1 (requires port 2 enabled) */

 GFX CRT */

 HAC */

 USB2 hub/USB2 host port 1/USB1.1 dev */

 UART1 */

 UART2 */

 UART5 */

 eSPI */

 MAC1 */

 MAC2 */

 RSA */

 UART3 */

 UART4 */

 SDIO/SD */

 LPC master/LPC+ */

 Yep, really. Aspeed confirmed this is correct */

 Pass through mode */

 F = 24Mhz * (2-OD) * [(N + 2) / (D + 1)] */

 Pass through mode */

 F = clkin * [(M+1) / (N+1)] / (P + 1) */

	/*

	 * If the IP is in reset, treat the clock as not enabled,

	 * this happens with some clocks such as the USB one when

	 * coming from cold reset. Without this, aspeed_clk_enable()

	 * will fail to lift the reset.

 Put IP in reset */

 Delay 100us */

 Enable clock */

 A delay of 10ms is specified by the ASPEED docs */

 Take IP out of reset */

 SCU04 resets */

	/*

	 * SCUD4 resets start at an offset to separate them from

	 * the SCU04 resets.

 SoC generations share common layouts but have different divisors */

 UART clock div13 setting */

 TODO: Find the parent data for the uart clock */

	/*

	 * Memory controller (M-PLL) PLL. This clock is configured by the

	 * bootloader, and is exposed to Linux as a read-only clock rate.

 SD/SDIO clock divider and gate */

 MAC AHB bus clock divider */

 RMII 50MHz RCLK */

 RMII1 50MHz (RCLK) output enable */

 RMII2 50MHz (RCLK) output enable */

 LPC Host (LHCLK) clock divider */

 P-Bus (BCLK) clock divider */

 Fixed 24MHz clock */

	/*

	 * TODO: There are a number of clocks that not included in this driver

	 * as more information is required:

	 *   D2-PLL

	 *   D-PLL

	 *   YCLK

	 *   RGMII

	 *   RMII

	 *   UART[1..5] clock source mux

		/* Special case: the USB port 1 clock (bit 14) is always

		 * working the opposite way from the other ones.

	/*

	 * CLKIN is the crystal oscillator, 24, 48 or 25MHz selected by

	 * strapping

	/*

	 * High-speed PLL clock derived from the crystal. This the CPU clock,

	 * and we assume that it is enabled. It can be configured through the

	 * HPLL_PARAM register, or set to a specified frequency by strapping.

	/*

	 * Strap bits 11:10 define the CPU/AHB clock frequency ratio (aka HCLK)

	 *   00: Select CPU:AHB = 1:1

	 *   01: Select CPU:AHB = 2:1

	 *   10: Select CPU:AHB = 4:1

	 *   11: Select CPU:AHB = 3:1

 APB clock clock selection register SCU08 (aka PCLK) */

 CLKIN is the crystal oscillator, 24 or 25MHz selected by strapping */

	/*

	 * High-speed PLL clock derived from the crystal. This the CPU clock,

	 * and we assume that it is enabled

 Strap bits 11:9 define the AXI/AHB clock frequency ratio (aka HCLK)*/

 APB clock clock selection register SCU08 (aka PCLK) */

	/*

	 * This way all clocks fetched before the platform device probes,

	 * except those we assign here for early use, will be deferred.

	/*

	 * We check that the regmap works on this very first access,

	 * but as this is an MMIO-backed regmap, subsequent regmap

	 * access is not going to fail and we skip error checks from

	 * this point.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2015 Maxime Ripard <maxime.ripard@free-electrons.com>

 Make sure we don't end up with a 0 multiplier */

 Make sure we don't overflow the multiplier */

			/*

			 * This is the best case for us if we have a

			 * perfect match without changing the parent

			 * rate.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2018 Socionext Inc.

 * Copyright (C) 2016 Linaro Ltd.

 if read only, just return current value */

 register the clock */

	/*

	 * The registers on CLKSEL(9) or CLKSEL(10) need additional

	 * writing to become valid.

	/*

	 * This way all clocks fetched before the platform device probes,

	 * except those we assign here for early use, will be deferred.

	/*

	 * PLLs are set by bootloader so this driver registers them as the

	 * fixed factor.

	/*

	 * timer consumes "rclk" so it needs to register here.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright 2019 NXP

 *

 * Clock driver for LS1028A Display output interfaces(LCD, DPHY).

 PLLDIG register offsets and bit masks */

 Range of the VCO frequencies, in Hz */

 Range of the output frequencies, in Hz */

 Maximum value of the reduced frequency divider */

 Best value of multiplication factor divider */

/*

 * Denominator part of the fractional part of the

 * loop multiplication factor.

	/*

	 * Use Bypass mode with PLL off by default, the frequency overshoot

	 * detector output was disable. SSCG Bypass mode should be enable.

 Check if PLL is bypassed */

	/*

	 * If RFDPHI1 has a value of 1 the VCO frequency is also divided by

	 * one.

 update the divider value */

 waiting for old lock state to clear */

 Wait until PLL is locked or timeout */

 Enable fractional divider */

	/*

	 * The frequency of the VCO cannot be changed during runtime.

	 * Therefore, let the user specify a desired frequency.

 SPDX-License-Identifier: GPL-2.0-only

/*

* TWL6040 clock module driver for OMAP4 McPDM functional clock

*

* Copyright (C) 2012 Texas Instruments Inc.

* Peter Ujfalusi <peter.ujfalusi@ti.com>

 Same for HPPLL and LPPLL */

/*

 * TWL6040A2 Phoenix Audio IC erratum #6: "PDM Clock Generation Issue At

 * Cold Temperature". This affects cold boot and deeper idle states it

 * seems. The workaround consists of resetting HPPLL and LPPLL.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2013 Freescale Semiconductor, Inc.

 * Copyright 2021 NXP

 *

 * clock driver for Freescale QorIQ SoCs.

 only on clockgen-1.0, which lacks CGB */

 Only allowed if PLL <= 80% of max cpu freq */

 CLKSEL_xxx */

 CGx_PLLn */

 PLL_DIVn */

/*

 * cmux freq must be >= platform pll.

 * If not set, cmux freq must be >= platform pll/2

 PLLCnGSR[CFG] is 8 bits, not 6 */

 version 3 cg: reg layout different */

 array should be -1 terminated */

 1 << n bit set if PLL n is valid */

 CG_xxx */

 mutable copy */

/*

 * Don't allow setting for now, as the clock options haven't been

 * sanitized for additional restrictions.

	/*

	 * Find the rate for the default clksel, and treat it as the

	 * maximum rated core frequency.  If this is an incorrect

	 * assumption, certain clock options (possibly including the

	 * default clksel) may be inappropriately excluded on certain

	 * chips.

/*

 * Legacy nodes may get probed before the parent clockgen node.

 * It is assumed that device trees with legacy nodes will not

 * contain a "clocks" property -- otherwise the input clocks may

 * not be initialized at this point.

 Legacy node */

 Register the input clock under the desired name. */

	/*

	 * This indicates a mix of legacy nodes with the new coreclk

	 * mechanism, which should never happen.  If this error occurs,

	 * don't use the wrong input clock just because coreclk isn't

	 * ready yet.

 Legacy node */

 Get the multiple of PLL */

 Check if this PLL is disabled */

		/*

		 * For platform PLL, there are MAX_PLL_DIV divider clocks.

		 * For core PLL, there are 4 divider clocks at most.

 Legacy node */

 Legacy node */

		/*

		 * ls1021a devtree labels the platform PLL

		 * with the core PLL compatible

 P2040 1.0 */

 P2040 1.1 */

 P2041 1.0 */

 P2041 1.1 */

 P3041 1.0 */

 P3041 1.1 */

 P4040 2.0 */

 P4080 2.0 */

 P5010 1.0 */

 P5010 2.0 */

 P5020 1.0 */

 P5021 1.0 */

 P5040 1.0 */

 The Security (E) bit */

 May have already been called by a legacy probe */

 Compatibility hack for old, broken device trees */

 Don't create cpufreq device for legacy clockgen blocks */

 Legacy nodes */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2010 Broadcom

 * Copyright (C) 2012 Stephen Warren

 * Copyright (C) 2016 Neil Armstrong <narmstrong@baylibre.com>

 Standard regmap gate clocks */

 Regmap offsets */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2014 Philipp Zabel, Pengutronix

 *

 * PWM (mis)used as clock output

	/*

	 * FIXME: pwm_apply_args() should be removed when switching to the

	 * atomic PWM API.

 SPDX-License-Identifier: GPL-2.0-only

/*

 *

 *  Copyright (C) 2013 Daniel Tang <tangrs@tangrs.id.au>

 SPDX-License-Identifier: GPL-2.0+



 clk-max77686.c - Clock driver for Maxim 77686/MAX77802



 Copyright (C) 2012 Samsung Electornics

 Jonghwa Lee <jonghwa3.lee@samsung.com>

 MAX77802: Enable low-jitter mode on the 32khz clocks. */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2019-20 Sean Anderson <seanga2@gmail.com>

 * Copyright (c) 2019 Western Digital Corporation or its affiliates.

 Gated clocks, no mux, no divider */

 Gated divider clocks */

 Divider clocks, no gate, no mux */

 Muxed gated divider clocks */

/*

 * PLL control register bits.

 PLL2 only */

/*

 * PLL lock register bits.

/*

 * Clock selector register bits.

/*

 * PLLs.

/*

 * PLLs configuration: by default PLL0 runs at 780 MHz and PLL1 at 299 MHz.

 * The first 2 SRAM banks depend on ACLK/CPU clock which is by default PLL0

 * rate divided by 2. Set PLL1 to 390 MHz so that the third SRAM bank has the

 * same clock as the first 2.

 780 MHz */

 390 MHz */

 299 MHz */

/**

 * struct k210_sysclk - sysclk driver data

 * @regs: system controller registers start address

 * @clk_lock: clock setting spinlock

 * @plls: SoC PLLs descriptors

 * @aclk: ACLK clock

 * @clks: All other clocks

/*

 * Set ACLK parent selector: 0 for IN0, 1 for PLL0.

	/*

	 * For PLL0, we need to re-parent ACLK to IN0 to keep the CPU cores and

	 * SRAM running.

 Set PLL factors */

	/*

	 * Reset the PLL: ensure reset is low before asserting it.

	 * The magic NOPs come from the Kendryte reference SDK.

	/*

	 * Bypassing before powering off is important so child clocks do not

	 * stop working. This is especially important for pll0, the indirect

	 * parent of the cpu clock.

 .index = 0 for in0 */ },

 PLL0 and PLL1 only have IN0 as parent */

 PLL2 has IN0, PLL0 and PLL1 as parents */

/*

 * ACLK has IN0 and PLL0 as parents.

 .index = 0 for in0 */ },

/*

 * All muxed clocks have IN0 and PLL0 as parents.

 .index = 0 for in0 */ },

 .index = 0 for in0 */

	/*

	 * Critical clocks: there are no consumers of the SRAM clocks,

	 * including the AI clock for the third SRAM bank. The CPU clock

	 * is only referenced by the uarths serial device and so would be

	 * disabled if the serial console is disabled to switch to another

	 * console. Mark all these clocks as critical so that they are never

	 * disabled by the core clock management.

 Clocks with aclk as source */

 Clocks with PLL0 as source */

 Clocks with PLL2 as source */

 Clocks with IN0 as source */

 Clocks with APB0 as source */

 Clocks with APB1 as source */

 Mux clocks with in0 or pll0 as source */

 Check for registration errors */

/*

 * Enable PLL1 to be able to use the AI SRAM.

 Make sure ACLK selector is set to PLL0 */

 Startup PLL1 to enable the aisram bank for general memory use */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2014 Samsung Electronics Co., Ltd.

 * Sylwester Nawrocki <s.nawrocki@samsung.com>

 skip empty (null) phandles */

 skip empty (null) phandles */

/**

 * of_clk_set_defaults() - parse and set assigned clocks configuration

 * @node: device node to apply clock settings for

 * @clk_supplier: true if clocks supplied by @node should also be considered

 *

 * This function parses 'assigned-{clocks/clock-parents/clock-rates}' properties

 * and sets any specified clock parents and rates. The @clk_supplier argument

 * should be set to true if @node may be also a clock supplier of any clock

 * listed in its 'assigned-clocks' or 'assigned-clock-parents' properties.

 * If @clk_supplier is false the function exits returning 0 as soon as it

 * determines the @node is also a supplier of any of the clocks.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Driver for Silicon Labs Si570/Si571 Programmable XO/VCXO

 *

 * Copyright (C) 2010, 2011 Ericsson AB.

 * Copyright (C) 2011 Guenter Roeck.

 * Copyright (C) 2011 - 2021 Xilinx Inc.

 *

 * Author: Guenter Roeck <guenter.roeck@ericsson.com>

 *	   Sören Brinkmann <soren.brinkmann@xilinx.com>

 Si570 registers */

/**

 * struct clk_si570:

 * @hw:	Clock hw struct

 * @regmap:	Device's regmap

 * @div_offset:	Rgister offset for dividers

 * @max_freq:	Maximum frequency for this device

 * @fxtal:	Factory xtal frequency

 * @n1:		Clock divider N1

 * @hs_div:	Clock divider HSDIV

 * @rfreq:	Clock multiplier RFREQ

 * @frequency:	Current output frequency

 * @i2c_client:	I2C client pointer

/**

 * si570_get_divs() - Read clock dividers from HW

 * @data:	Pointer to struct clk_si570

 * @rfreq:	Fractional multiplier (output)

 * @n1:		Divider N1 (output)

 * @hs_div:	Divider HSDIV (output)

 * Returns 0 on success, negative errno otherwise.

 *

 * Retrieve clock dividers and multipliers from the HW.

 Handle invalid cases */

/**

 * si570_get_defaults() - Get default values

 * @data:	Driver data structure

 * @fout:	Factory frequency output

 * @skip_recall:	If true, don't recall NVM into RAM

 * Returns 0 on success, negative errno otherwise.

	/*

	 * Accept optional precision loss to avoid arithmetic overflows.

	 * Acceptable per Silicon Labs Application Note AN334.

/**

 * si570_update_rfreq() - Update clock multiplier

 * @data:	Driver data structure

 * Passes on regmap_bulk_write() return value.

/**

 * si570_calc_divs() - Caluclate clock dividers

 * @frequency:	Target frequency

 * @data:	Driver data structure

 * @out_rfreq:	RFREG fractional multiplier (output)

 * @out_n1:	Clock divider N1 (output)

 * @out_hs_div:	Clock divider HSDIV (output)

 * Returns 0 on success, negative errno otherwise.

 *

 * Calculate the clock dividers (@out_hs_div, @out_n1) and clock multiplier

 * (@out_rfreq) for a given target @frequency.

 Calculate lowest possible value for n1 */

/**

 * si570_set_frequency() - Adjust output frequency

 * @data:	Driver data structure

 * @frequency:	Target frequency

 * Returns 0 on success.

 *

 * Update output frequency for big frequency changes (> 3,500 ppm).

	/*

	 * The DCO reg should be accessed with a read-modify-write operation

	 * per AN334

 Applying a new frequency can take up to 10ms */

/**

 * si570_set_frequency_small() - Adjust output frequency

 * @data:	Driver data structure

 * @frequency:	Target frequency

 * Returns 0 on success.

 *

 * Update output frequency for small frequency changes (< 3,500 ppm).

	/*

	 * This is a re-implementation of DIV_ROUND_CLOSEST

	 * using the div64_u64 function lieu of letting the compiler

	 * insert EABI calls

 Applying a new frequency (small change) can take up to 100us */

 adjust register offsets for 7ppm devices */

 Read the requested initial output frequency from device tree */

 Display a message indicating that we've successfully registered */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2010-2011 Canonical Ltd <jeremy.kerr@canonical.com>

 * Copyright (C) 2011-2012 Mike Turquette, Linaro Ltd <mturquette@linaro.org>

 *

 * Fixed rate clock implementation

/*

 * DOC: basic fixed-rate clock that cannot gate

 *

 * Traits of this clock:

 * prepare - clk_(un)prepare only ensures parents are prepared

 * enable - clk_enable only ensures parents are enabled

 * rate - rate is always a fixed value.  No clk_set_rate support

 * parent - fixed parent.  No clk_set_parent support

 allocate fixed-rate clock */

 struct clk_fixed_rate assignments */

 register the clock */

/**

 * of_fixed_clk_setup() - Setup function for simple fixed rate clock

 * @node:	device node for the clock

	/*

	 * This function is not executed when of_fixed_clk_setup

	 * succeeded.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2011 Sascha Hauer, Pengutronix <s.hauer@pengutronix.de>

 * Copyright (C) 2011 Richard Zhao, Linaro <richard.zhao@linaro.org>

 * Copyright (C) 2011-2012 Mike Turquette, Linaro Ltd <mturquette@linaro.org>

 *

 * Adjustable divider clock implementation

/*

 * DOC: basic adjustable divider clock that cannot gate

 *

 * Traits of this clock:

 * prepare - clk_prepare only ensures that parents are prepared

 * enable - clk_enable only ensures that parents are enabled

 * rate - rate is adjustable.  clk->rate = ceiling(parent->rate / divisor)

 * parent - fixed parent.  No clk_set_parent support

	/*

	 * The maximum divider we can use without overflowing

	 * unsigned long in rate * i below

			/*

			 * It's the most ideal case if the requested rate can be

			 * divided from parent clock without needing to change

			 * parent rate, so return the divider immediately.

 Even a read-only clock can propagate a rate change */

 if read only, just return current value */

 if read only, just return current value */

 allocate the divider */

 struct clk_divider assignments */

 register the clock */

/**

 * clk_register_divider_table - register a table based divider clock with

 * the clock framework

 * @dev: device registering this clock

 * @name: name of this clock

 * @parent_name: name of clock's parent

 * @flags: framework-specific flags

 * @reg: register address to adjust divider

 * @shift: number of bits to shift the bitfield

 * @width: width of the bitfield

 * @clk_divider_flags: divider-specific flags for this clock

 * @table: array of divider/value pairs ending with a div set to 0

 * @lock: shared register lock for this clock

/**

 * clk_hw_unregister_divider - unregister a clk divider

 * @hw: hardware-specific clock data to unregister

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) STMicroelectronics 2017

 * Author: Gabriel Fernandez <gabriel.fernandez@st.com> for STMicroelectronics.

 Reset Clock Control Registers */

 System clock parent */

 Kernel clock parent */

 i2c 1,2,3 src */

 usart 1,6 src */

 usart 2,3,4,5,7,8 src */

 lptim 2,3,4,5 src */

 RTC clock parent */

 Micro-controller output clock parent */

 LCD clock */

 Gate clock with ready bit and backup domain management */

	/* We can't use readl_poll_timeout() because we can blocked if

	 * someone enables this clock before clocksource changes.

	 * Only jiffies counter is available. Jiffies are incremented by

	 * interruptions and enable op does not allow to be interrupted.

/*

 * General config definition of a composite clock (only clock diviser for rate)

 Kernel Timer */

 CORE AND BUS */

 D1 DOMAIN */

 * CPU Systick */

 * APB3 peripheral */

 D2 DOMAIN */

 * APB1 peripheral */

 Timers prescaler clocks */

 * APB2 peripheral */

 D3 DOMAIN */

 * APB4 peripheral */

 MUX clock configuration */

 Oscillary clock configuration */

 PLL configuration */

 ODF CLOCKS */

 PERIF CLOCKS */

 KERNEL CLOCKS */

 RTC clock */

/*

 * RTC & LSE registers are protected against parasitic write access.

 * PWR_CR_DBP bit must be set to enable write access to RTC registers.

 STM32_PWR_CR */

 STM32_PWR_CR bit field */

 Micro-controller output clock */

 get RCC base @ from DT */

		/* In any case disable backup domain write protection

		 * and will never be enabled.

		 * Needed by LSE & RTC clocks.

 Put parent names from DT */

 Register Internal oscillators */

 This clock is coming from outside. Frequencies unknown */

 Mux system clocks */

 Oscillary clocks */

 PLLs */

 Register the VCO */

 Register the 3 output dividers */

 Peripheral clocks */

 Kernel clocks */

 RTC clock (default state is off) */

 Micro-controller clocks */

/* The RCC node is a clock and reset controller, and these

 * functionalities are supported by different drivers that

 * matches the same compatible strings.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * drivers/clk/clk-axm5516.c

 *

 * Provides clock implementations for three different types of clock devices on

 * the Axxia device: PLL clock, a clock divider and a clock mux.

 *

 * Copyright (C) 2014 LSI Corporation

/**

 * struct axxia_clk - Common struct to all Axxia clocks.

 * @hw: clk_hw for the common clk framework

 * @regmap: Regmap for the clock control registers

/**

 * struct axxia_pllclk - Axxia PLL generated clock.

 * @aclk: Common struct

 * @reg: Offset into regmap for PLL control register

/**

 * axxia_pllclk_recalc - Calculate the PLL generated clock rate given the

 * parent clock rate.

/**

 * struct axxia_divclk - Axxia clock divider

 * @aclk: Common struct

 * @reg: Offset into regmap for PLL control register

 * @shift: Bit position for divider value

 * @width: Number of bits in divider value

/**

 * axxia_divclk_recalc_rate - Calculate clock divider output rage

/**

 * struct axxia_clkmux - Axxia clock mux

 * @aclk: Common struct

 * @reg: Offset into regmap for PLL control register

 * @shift: Bit position for selection value

 * @width: Number of bits in selection value

/**

 * axxia_clkmux_get_parent - Return the index of selected parent clock

/*

 * PLLs

/*

 * Clock dividers

/*

 * Clock MUXes

/* Table of all supported clocks indexed by the clock identifiers from the

 * device tree binding

	/* Update each entry with the allocated regmap and register the clock

	 * with the common clock framework

 SPDX-License-Identifier: GPL-2.0

/*

 * Clock driver for Palmas device.

 *

 * Copyright (c) 2013, NVIDIA Corporation.

 * Copyright (c) 2013-2014 Texas Instruments, Inc.

 *

 * Author:	Laxman Dewangan <ldewangan@nvidia.com>

 *		Peter Ujfalusi <peter.ujfalusi@ti.com>

	/*

	 * Clock can be disabled through external pin if it is externally

	 * controlled.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Clock implementation for VIA/Wondermedia SoC's

 * Copyright (C) 2012 Tony Prisk <linux@prisktech.co.nz>

 All clocks share the same lock as none can be changed concurrently */

/*

 * Add new PLL_TYPE_x definitions here as required. Use the first known model

 * to support the new type as the name.

 * Add case statements to vtwm_pll_recalc_rate(), vtwm_pll_round_round() and

 * vtwm_pll_set_rate() to handle the new PLL_TYPE_x

 Special case for SDMMC devices */

 div == 0 is actually the highest divisor */

 If prate / rate would be decimal, incr the divisor */

	/*

	 * If this is a request for SDMMC we have to adjust the divisor

	 * when >31 to use the fixed predivisor

 SDMMC mask may need to be corrected before testing if its valid */

		/*

		 * Bit 5 is a fixed /64 predivisor. If the requested divisor

		 * is >31 then correct for the fixed divisor being required.

		/*

		 * use 0x1f as the default mask since it covers

		 * almost all the clocks and reduces dts properties

 PLL clock related functions */

 Helper macros for PLL_VT8500 */

 Helper macros for PLL_WM8650 */

 Helper macros for PLL_WM8750 */

 Helper macros for PLL_WM8850 */

 sanity check */

 use the prediv to double the resolution */

/*

 * M * parent [O1] => / P [O2] => / D [O3]

 * Where O1 is 900MHz...3GHz;

 * O2 is 600MHz >= (M * parent) / P >= 300MHz;

 * M is 36...120 [25MHz parent]; D is 1 or 2 or 4 or 8.

 * Possible ranges (O3):

 * D = 8: 37,5MHz...75MHz

 * D = 4: 75MHz...150MHz

 * D = 2: 150MHz...300MHz

 * D = 1: 300MHz...600MHz

	/*

	 * Divisor P cannot be calculated. Test all divisors and find where M

	 * will be as close as possible to the requested rate.

 calculate frequency (MHz) after pre-divisor */

 Find the closest match (lower or equal to requested) */

 error will always be +ve */

 if we got here, it wasn't an exact match */

 Find the closest match (lower or equal to requested) */

 error will always be +ve */

 if we got here, it wasn't an exact match */

 sanity check */

 Wrappers for initialization functions */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * System Control and Power Interface (SCPI) Protocol based clock driver

 *

 * Copyright (C) 2015 ARM Ltd.

	/*

	 * We can't figure out what rate it will be, so just return the

	 * rate back to the caller. scpi_clk_recalc_rate() will be called

	 * after the rate is set and we'll know what rate the clock is

	 * running at then.

 find closest match to given frequency in OPP table */

 Add the virtual cpufreq device if it's DVFS clock provider */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2011 Sascha Hauer, Pengutronix <s.hauer@pengutronix.de>

 * Copyright (C) 2011 Richard Zhao, Linaro <richard.zhao@linaro.org>

 * Copyright (C) 2011-2012 Mike Turquette, Linaro Ltd <mturquette@linaro.org>

 *

 * Simple multiplexer clock implementation

/*

 * DOC: basic adjustable multiplexer clock that cannot gate

 *

 * Traits of this clock:

 * prepare - clk_prepare only ensures that parents are prepared

 * enable - clk_enable only ensures that parents are enabled

 * rate - rate is only affected by parent switching.  No clk_set_rate support

 * parent - parent is adjustable through clk_set_parent

 allocate the mux */

 struct clk_mux assignments */

 SPDX-License-Identifier: GPL-2.0+

/*

 * Bitmain BM1880 SoC clock driver

 *

 * Copyright (c) 2019 Linaro Ltd.

 * Author: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>

/*

 * All PLL clocks are marked as CRITICAL, hence they are very crucial

 * for the functioning of the SoC

/*

 * Clocks marked as CRITICAL are needed for the proper functioning

 * of the SoC.

	/*

	 * Since this clock is sourcing the DDR memory, let's mark it as

	 * critical to avoid gating.

 Don't gate GPIO clocks as it is not owned by the GPIO driver */

	/*

	 * Not sure which module this clock is sourcing but gating this clock

	 * prevents the system from booting. So, let's mark it as critical.

/*

 * Clocks marked as CRITICAL are needed for the proper functioning

 * of the SoC.

/*

 * Clocks marked as CRITICAL are all needed for the proper functioning

 * of the SoC.

	/*

	 * Since clk_a53 and clk_50m_a53 clocks are sourcing the CPU core,

	 * let's mark them as critical to avoid gating.

 Don't gate GPIO clocks as it is not owned by the GPIO driver */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * clk-si5351.c: Skyworks / Silicon Labs Si5351A/B/C I2C Clock Generator

 *

 * Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>

 * Rabeeh Khoury <rabeeh@solid-run.com>

 *

 * References:

 * [1] "Si5351A/B/C Data Sheet"

 *     https://www.skyworksinc.com/-/media/Skyworks/SL/documents/public/data-sheets/Si5351-B.pdf

 * [2] "AN619: Manually Generating an Si5351 Register Map"

 *     https://www.skyworksinc.com/-/media/Skyworks/SL/documents/public/application-notes/AN619.pdf

/*

 * Si5351 i2c regmap

 save rdiv and divby4 */

 reserved registers */

 read-only */

/*

 * Si5351 xtal clock input

/*

 * Si5351 clkin clock input (Si5351C only)

/*

 * CMOS clock source constraints:

 * The input frequency range of the PLL is 10Mhz to 40MHz.

 * If CLKIN is >40MHz, the input divider must be used.

/*

 * Si5351 vxco clock input (Si5351B only)

/*

 * Si5351 pll a/b

 *

 * Feedback Multisynth Divider Equations [2]

 *

 * fVCO = fIN * (a + b/c)

 *

 * with 15 + 0/1048575 <= (a + b/c) <= 90 + 0/1048575 and

 * fIN = fXTAL or fIN = fCLKIN/CLKIN_DIV

 *

 * Feedback Multisynth Register Equations

 *

 * (1) MSNx_P1[17:0] = 128 * a + floor(128 * b/c) - 512

 * (2) MSNx_P2[19:0] = 128 * b - c * floor(128 * b/c) = (128*b) mod c

 * (3) MSNx_P3[19:0] = c

 *

 * Transposing (2) yields: (4) floor(128 * b/c) = (128 * b / MSNx_P2)/c

 *

 * Using (4) on (1) yields:

 * MSNx_P1 = 128 * a + (128 * b/MSNx_P2)/c - 512

 * MSNx_P1 + 512 + MSNx_P2/c = 128 * a + 128 * b/c

 *

 * a + b/c = (MSNx_P1 + MSNx_P2/MSNx_P3 + 512)/128

 *         = (MSNx_P1*MSNx_P3 + MSNx_P2 + 512*MSNx_P3)/(128*MSNx_P3)

 *

 fVCO = fIN * (P1*P3 + 512*P3 + P2)/(128*P3) */

 determine integer part of feedback equation */

 find best approximation for b/c = fVCO mod fIN */

 calculate parameters */

 recalculate rate by fIN * (a + b/c) */

 write multisynth parameters */

 plla/pllb ctrl is in clk6/clk7 ctrl registers */

 Do a pll soft reset on the affected pll */

/*

 * Si5351 multisync divider

 *

 * for fOUT <= 150 MHz:

 *

 * fOUT = (fIN * (a + b/c)) / CLKOUTDIV

 *

 * with 6 + 0/1048575 <= (a + b/c) <= 1800 + 0/1048575 and

 * fIN = fVCO0, fVCO1

 *

 * Output Clock Multisynth Register Equations

 *

 * MSx_P1[17:0] = 128 * a + floor(128 * b/c) - 512

 * MSx_P2[19:0] = 128 * b - c * floor(128 * b/c) = (128*b) mod c

 * MSx_P3[19:0] = c

 *

 * MS[6,7] are integer (P1) divide only, P1 = divide value,

 * P2 and P3 are not applicable

 *

 * for 150MHz < fOUT <= 160MHz:

 *

 * MSx_P1 = 0, MSx_P2 = 0, MSx_P3 = 1, MSx_INT = 1, MSx_DIVBY4 = 11b

	/*

	 * multisync0-5: fOUT = (128 * P3 * fIN) / (P1*P3 + P2 + 512*P3)

	 * multisync6-7: fOUT = fIN / P1

 multisync6-7 can only handle freqencies < 150MHz */

 multisync frequency is 1MHz .. 160MHz */

 multisync can set pll */

		/*

		 * find largest integer divider for max

		 * vco frequency and given target rate

 determine the closest integer divider */

 disable divby4 */

 determine integer part of divider equation */

 find best approximation for b/c = fVCO mod fOUT */

 recalculate rate by fOUT = fIN / (a + b/c) */

 calculate parameters */

 write multisynth parameters */

 enable/disable integer mode and divby4 on multisynth0-5 */

/*

 * Si5351 clkout divider

 clk0/clk4 can only connect to its own multisync */

 pll not used, no need to reset */

	/*

	 * Do a pll soft reset on the parent pll -- needed to get a

	 * deterministic phase relationship between the output clocks.

 clkout6/7 can only handle output freqencies < 150MHz */

 clkout freqency is 8kHz - 160MHz */

 request frequency if multisync master */

 use r divider for frequencies below 1MHz */

 round to closed rdiv */

 round to closed rdiv */

 write output divider */

 powerup clkout */

/*

 * Si5351 i2c probe and DT

	/*

	 * property silabs,pll-source : <num src>, [<..>]

	 * allow to selectively set pll source

 per clkout properties */

 CONFIG_OF */

	/*

	 * Check for valid parent clock: VARIANT_A and VARIANT_B need XTAL,

	 *   VARIANT_C can have CLKIN instead.

 Disable interrupts */

 Ensure pll select is on XTAL for Si5351A/B */

 setup clock configuration */

 register xtal input clock gate */

 register clkin input clock gate */

 Si5351C allows to mux either xtal or clkin to PLL input */

 register PLLA */

 register PLLB or VXCO (Si5351B) */

 register clk multisync and clk out divider */

 set initial clkout rate */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2014 Oleksij Rempel <linux@rempel-privat.de>.

	/* i2s has two deviders: one for only external mclk and internal

 ahb gates */

 register pll */

 TODO: Convert to DT parent scheme */

 clock mux gate cells */

 clock div cells */

 clock ahb gate cells */

 check for errors on leaf clocks */

 register clk-provider */

 SPDX-License-Identifier: GPL-2.0

 Copyright (C) 2018 ROHM Semiconductors

 clk control registers */

 BD71815 */

 BD71828 */

 BD71837 and BD71847 */

/*

 * BD71837, BD71847, and BD71828 all use bit [0] to clk output control

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Clkout driver for Rockchip RK808

 *

 * Copyright (c) 2014, Fuzhou Rockchip Electronics Co., Ltd

 *

 * Author:Chris Zhong <zyw@rock-chips.com>

	/*

	 * For the default case, it match the following PMIC type.

	 * RK805_ID

	 * RK808_ID

	 * RK818_ID

 optional override of the clockname */

 optional override of the clockname */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2013 NVIDIA CORPORATION.  All rights reserved.

 .set_rate requires either .round_rate or .determine_rate */

 SPDX-License-Identifier: GPL-2.0

/*

 * Driver for Silicon Labs Si544 Programmable Oscillator

 * Copyright (C) 2018 Topic Embedded Products

 * Author: Mike Looijmans <mike.looijmans@topic.nl>

 I2C registers (decimal as in datasheet) */

 Register values */

 Max freq depends on speed grade */

 Si544 Internal oscilator runs at 55.05 MHz */

 VCO range is 10.8 .. 12.1 GHz, max depends on speed grade */

 Lowest frequency synthesizeable using only the HS divider */

 Range and interpretation of the adjustment value */

/**

 * struct clk_si544_muldiv - Multiplier/divider settings

 * @fb_div_frac:	integer part of feedback divider (32 bits)

 * @fb_div_int:		fractional part of feedback divider (11 bits)

 * @hs_div:		1st divider, 5..2046, must be even when >33

 * @ls_div_bits:	2nd divider, as 2^x, range 0..5

 *                      If ls_div_bits is non-zero, hs_div must be even

 * @delta_m:		Frequency shift for small -950..+950 ppm changes, 24 bit

 Enables or disables the output driver */

 Retrieve clock multiplier and dividers from hardware */

 Interpret as 24-bit signed number */

	/*

	 * Writing to SI544_REG_FBDIV40 triggers the clock change, so that

	 * must be written last

 Calculate divider settings for a given frequency */

 Determine the minimum value of LS_DIV and resulting target freq. */

 Determine minimum HS_DIV by rounding up */

 round up to even number when required */

 Calculate VCO frequency (in 10..12GHz range) */

 Calculate the integer part of the feedback divider */

 And the fractional bits using the remainder */

 Round to nearest multiple */

 Reset the frequency adjustment */

 Calculate resulting frequency given the register settings */

 Calculate VCO from the fractional part */

 Add the integer part of the VCO frequency */

 Apply divider to obtain the generated frequency */

	/*

	 * The clock adjustment is much smaller than 1 Hz, round to the

	 * nearest multiple. Apparently div64_s64 rounds towards zero, hence

	 * check the sign and adjust into the proper direction.

 The accuracy is less than 1 Hz, so any rate is possible */

 Calculates the maximum "small" change, 950 * rate / 1000000 */

 Try using the frequency adjustment feature for a <= 950ppm change */

 Too big for the delta adjustment, need to reprogram */

 Allow FCAL for this frequency update */

 Undefined state now, best to leave disabled */

 Trigger calibration */

 Applying a new frequency can take up to 10ms */

 Select page 0, just to be sure, there appear to be no more */

 SPDX-License-Identifier: GPL-2.0+



 clk-s2mps11.c - Clock driver for S2MPS11.



 Copyright (C) 2013,2014 Samsung Electornics

 This s2mps11_clks_init tructure is common to s2mps11, s2mps13 and s2mps14 */

 Store clocks of_node in first element of s2mps11_clks array */

 Skip clocks not present in some devices */

 Drop the reference obtained in s2mps11_clk_parse_dt */

 Skip clocks not present on S2MPS14 */

/*

 * Device is instantiated through parent MFD device and device matching is done

 * through platform_device_id.

 *

 * However if device's DT node contains proper clock compatible and driver is

 * built as a module, then the *module* matching will be done trough DT aliases.

 * This requires of_device_id table.  In the same time this will not change the

 * actual *device* matching so do not add .of_match_table.

 Sentinel */

/*

 * Synopsys HSDK SDP Generic PLL clock driver

 *

 * Copyright (C) 2017 Synopsys

 *

 * This file is licensed under the terms of the GNU General Public

 * License version 2. This program is licensed "as is" without any

 * warranty of any kind, whether express or implied.

 ARC PLL control register */

 ARC PLL status register */

 ARC PLL frequency measurement register */

 ARC PLL monitor register */

 100 us */

 Powerdown and Bypass bits should be cleared */

 Check if PLL is bypassed */

 Check if PLL is disabled */

 input divider = reg.idiv + 1 */

 fb divider = 2*(reg.fbdiv + 1) */

 output divider = 2^(reg.odiv) */

	/*

	 * Wait until CGU relocks and check error status.

	 * If after timeout CGU is unlocked yet return error.

	/*

	 * When core clock exceeds 500MHz, the divider for the interface

	 * clock must be programmed to div-by-2.

	/*

	 * Wait until CGU relocks and check error status.

	 * If after timeout CGU is unlocked yet return error.

	/*

	 * Program divider to div-by-1 if we succesfuly set core clock below

	 * 500MHz threshold.

 Core PLL needed early for ARC cpus timers */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * WM831x clock control

 *

 * Copyright 2011-2 Wolfson Microelectronics PLC.

 *

 * Author: Mark Brown <broonie@opensource.wolfsonmicro.com>

 wait 2-3 ms for new frequency taking effect */

 AUTO mode is always clocked from the crystal */

 XTAL_ENA can only be set via OTP/InstantConfig so just read once */

 Module information */

 SPDX-License-Identifier: GPL-2.0-or-later

 Copyright IBM Corp

 Copyright ASPEED Technology

 Globally visible clocks */

 Keeps track of all clocks */

 AST2600 revision: A0, A1, A2, etc */

/*

 * Clocks marked with CLK_IS_CRITICAL:

 *

 *  ref0 and ref1 are essential for the SoC to operate

 *  mpll is required if SDRAM is used

				    clk rst  name		parent	 flags */

 SDRAM */

 Video Engine */

 2D engine */

 vclk parent - dclk/d1clk/hclk/mclk */

 Video Capture */

 PCIe/PCI */

 From dpll */

 DAC */

 USB2.0 Host port 2 */

 Reserved 8 */

 USB1.1 (requires port 2 enabled) */

 From dpll/epll/40mhz usb p1 phy/gpioc6/dp phy pll */

 GFX CRT */

 Reserved 11/12 */

 HAC */

 USB2 hub/USB2 host port 1/USB1.1 dev */

 UART5 */

 Reserved 16/19 */

 MAC1 */

 MAC2 */

 Reserved 22/23 */

 HAC */

 RVAS */

 Reserved 26 */

 For card clk */

 Reserved 28/29/30 */

 LPC */

 eSPI */

 Reserved 35 */

 SDIO/SD */

 LPC master/LPC+ */

 Reserved 38 RSA: no longer used */

 Reserved 39 */

 I3C0 */

 I3C1 */

 I3C2 */

 I3C3 */

 I3C4 */

 I3C5 */

 I3C6 */

 I3C7 */

 UART1 */

 UART2 */

 UART3 */

 UART4 */

 MAC3 */

 MAC4 */

 UART6 */

 UART7 */

 UART8 */

 UART9 */

 UART10 */

 UART11 */

 UART12 */

 UART13 */

 FSI */

 For hpll/dpll/epll/mpll */

 Pass through mode */

 F = 25Mhz * [(M + 2) / (n + 1)] / (p + 1) */

 Pass through mode */

 F = 25Mhz * [(m + 1) / (n + 1)] / (p + 1) */

 Pass through mode */

 F = 25Mhz * (2-od) * [(m + 2) / (n + 1)] */

	/*

	 * If the IP is in reset, treat the clock as not enabled,

	 * this happens with some clocks such as the USB one when

	 * coming from cold reset. Without this, aspeed_clk_enable()

	 * will fail to lift the reset.

 Put IP in reset */

 Delay 100us */

 Enable clock */

 Clock is clear to enable, so use set to clear register */

 Clock is set to enable, so use write to set register */

 A delay of 10ms is specified by the ASPEED docs */

 Take IP out of reset */

 Use set to clear register */

 Use set to clear register */

 UART clock div13 setting */

 UART6~13 clock div13 setting */

 EMMC ext clock */

 SD/SDIO clock divider and gate */

 MAC1/2 RMII 50MHz RCLK */

 MAC1/2 AHB bus clock divider */

 RMII1 50MHz (RCLK) output enable */

 RMII2 50MHz (RCLK) output enable */

 MAC1/2 RMII 50MHz RCLK */

 MAC3/4 AHB bus clock divider */

 RMII3 50MHz (RCLK) output enable */

 RMII4 50MHz (RCLK) output enable */

 LPC Host (LHCLK) clock divider */

 gfx d1clk : use dp clk */

 SoC Display clock selection */

 d1 clk div 0x308[17:15] x [14:12] - 8,7,6,5,4,3,2,1 */

 3x3 = 9 */

 P-Bus (BCLK) clock divider */

 Video Capture clock selection */

 Video Engine clock divider */

		/*

		 * Special case: the USB port 1 clock (bit 14) is always

		 * working the opposite way from the other ones.

	/*

	 * High-speed PLL clock derived from the crystal. This the CPU clock,

	 * and we assume that it is enabled

 Strap bits 12:11 define the AXI/AHB clock frequency ratio (aka HCLK)*/

 USB 2.0 port1 phy 40MHz clock */

	/*

	 * This way all clocks fetched before the platform device probes,

	 * except those we assign here for early use, will be deferred.

	/*

	 * We check that the regmap works on this very first access,

	 * but as this is an MMIO-backed regmap, subsequent regmap

	 * access is not going to fail and we skip error checks from

	 * this point.

 SPDX-License-Identifier: GPL-2.0

/*

 * Driver for Silicon Labs Si5340, Si5341, Si5342, Si5344 and Si5345

 * Copyright (C) 2019 Topic Embedded Products

 * Author: Mike Looijmans <mike.looijmans@topic.nl>

 *

 * The Si5341 has 10 outputs and 5 synthesizers.

 * The Si5340 is a smaller version of the Si5341 with only 4 outputs.

 * The Si5345 is similar to the Si5341, with the addition of fractional input

 * dividers and automatic input selection.

 * The Si5342 and Si5344 are smaller versions of the Si5345.

 Range of the synthesizer fractional divider */

 The chip can get its input clock from 3 input pins or an XTAL */

 There is one PLL running at 13500–14256 MHz */

 The 5 frequency synthesizers obtain their input from the PLL */

 The output stages can be connected to any synth (full mux) */

 13500–14256 MHz */

 Status bits */

 Input selection */

 XTAL config bits */

 Input dividers (48-bit) */

 PLL configuration */

 Output configuration */

 Synthesize N divider */

 Synthesizer output enable, phase bypass, power mode */

 SI5341_OUT_CONFIG bits */

 Static configuration (to be moved to firmware) */

 Output configuration registers 0..9 are not quite logically organized */

 Also for si5345 */

 for si5340, si5342 and si5344 */

 The location of the R divider registers */

/*

 * Programming sequence from ClockBuilder, settings to initialize the system

 * using only the XTAL input, without pre-divider.

 * This also contains settings that aren't mentioned anywhere in the datasheet.

 * The "known" settings like synth and output configuration are done later.

 INT mask (disable interrupts) */

 INT mask */

 Select XTAL as input */

 Not in datasheet */

 SPI config */

 LOS enable for XTAL */

 LOS timing */

 LOS setting (thresholds) */

 LOS setting (thresholds) end */

 LOS0_DIV_SEL */

 LOS1_DIV_SEL */

 LOS2_DIV_SEL */

 LOS3_DIV_SEL */

 Not in datasheet */

 Enable outputs */

 Not in datasheet */

 Not in datasheet */

 OUT LOS */

 XAXB_FREQ_OFFSET (=0)*/

 PXAXB (2^x) */

 Px divider setting (usually 0) */

 Px divider setting (usually 0) end */

 DESIGN_ID (ASCII string) */

 DESIGN_ID (ASCII string) end */

 N_FSTEP_MSK */

 Nx_FSTEPW (Frequency step) */

 Nx_FSTEPW (Frequency step) end */

 Nx_DELAY */

 Nx_DELAY end */

 Not in datasheet */

 Not in datasheet */

 Not in datasheet */

 XAXB_EXTCLK_EN=0 XAXB_PDNB=1 (use XTAL) */

 ZDM_EN=4 (Normal mode) */

 IN_EN (disable input clocks) */

 INx_TO_PFD_EN (disabled) */

 Not in datasheet */

 PDIV_ENB (datasheet does not mention what it is) */

 VCO_RESET_CALCODE (not described in datasheet) */

 VCO_RESET_CALCODE (not described in datasheet) */

 Read and interpret a 44-bit followed by a 32-bit value in the regmap */

 Shift left as far as possible without overflowing */

 44 bits (6 bytes) numerator */

 32 bits denominator */

 Program the fraction */

 VCO, we assume it runs at a constant frequency */

 Assume that PDIV is not being used, just read the PLL setting */

	/*

	 * Though m_num is 64-bit, only the upper bits are actually used. While

	 * calculating m_num and m_den, they are shifted as far as possible to

	 * the left. To avoid 96-bit division here, we just shift them back so

	 * we can do with just 64 bits.

 We cannot return the actual frequency in 32 bit, store it locally */

 Report kHz since the value is out of range */

 Apparently we cannot report errors */

 Enable register-based input selection */

 Enable input buffer for selected input */

 Enables the input to phase detector */

 Power down XTAL oscillator and buffer */

		/*

		 * Set the P divider to "1". There's no explanation in the

		 * datasheet of these registers, but the clockbuilder software

		 * programs a "1" when the input is being used.

 Set update PDIV bit */

 Disable all input buffers */

 Disable input to phase detector */

 Power up XTAL oscillator and buffer, select clock mode */

 Synthesizers, there are 5 synthesizers that connect to any of the outputs */

 The synthesizer is on if all power and enable bits are set */

 This bit must be 0 for the synthesizer to receive clock input */

 In range 0..5 */

 Disable output */

 Power down */

 Disable clock input to synth (set to 1 to disable) */

 Power up */

 Enable clock input to synth (set bit to 0 to enable) */

 Enable output */

 Synth clock frequency: Fvco * n_den / n_den, with Fvco in 13500-14256 MHz */

 Check for bogus/uninitialized settings */

	/*

	 * n_num and n_den are shifted left as much as possible, so to prevent

	 * overflow in 64-bit math, we shift n_den 4 bits to the right

 Now we need to to 64-bit division: f/n_num */

 And compensate for the 4 bits we dropped */

 The synthesizer accuracy is such that anything in range will work */

 see if there's an integer solution */

 Integer divider equal to n_num */

 Calculate a fractional solution */

 Bit 0=PDN, 1=OE so only a value of 0x2 enables the output */

 Disables and then powers down the output */

 Powers up and then enables the output */

 Calculate value as 24-bit integer*/

 If Rx_REG is zero, the divider is disabled, so return a "0" rate */

 Divider is 2*(Rx_REG+1) */

 If rate is an even divisor, no changes to parent required */

 minimum r-divider is 2 */

 Take a parent frequency near 400 MHz */

 We cannot change our parent's rate, report what we can do */

 Frequency divider is (r_div + 1) * 2 */

 For a value of "2", we set the "OUT0_RDIV_FORCE2" bit */

 Always write Rx_REG, because a zero value disables the divider */

/*

 * The chip can be bought in a pre-programmed version, or one can program the

 * NVM in the chip to boot up in a preset mode. This routine tries to determine

 * if that's the case, or if we need to reset and program everything from

 * scratch. Returns negative error, or true/false.

 Read the PLL divider value, it must have a non-zero value */

 Read active settings into the regmap cache for later reference */

 For revision 2 and up, the values are slightly different */

 Write "preamble" as specified by datasheet */

 The si5342..si5345 require a different preamble */

 Datasheet specifies a 300ms wait after sending the preamble */

 Perform a soft reset and write post-amble */

 The si5342..si5345 have an additional post-amble */

 Datasheet does not explain these nameless registers */

 Status */

 reset, finc/fdec */

 NVM, interrupts, device ready */

 Update bits for P divider and synth config */

 Pages 0, 1, 2, 3, 9, A, B are valid, so there are 12 pages */

	/* Datasheet warns: Any attempt to read or write any register other

	 * than DEVICE_READY before DEVICE_READY reads as 0x0F may corrupt the

	 * NVM programming and may corrupt the register contents, as they are

	 * read from NVM. Note that this includes accesses to the PAGE register.

	 * Also: DEVICE_READY is available on every register page, so no page

	 * change is needed to read it.

	 * Do this outside regmap to avoid automatic PAGE register access.

	 * May take up to 300ms to complete.

 Set cm and ampl conservatively to 3v3 settings */

 normal differential */

 low-power differential */

 LVCMOS */

 Set SI recommended impedance for LVCMOS */

 Always enable the SYNC feature */

 chip seems to default to 2.5V when not set */

/*

 * If not pre-configured, calculate and set the PLL configuration manually.

 * For low-jitter performance, the PLL should be set such that the synthesizers

 * only need integer division.

 * Without any user guidance, we'll set the PLL to 14GHz, which still allows

 * the chip to generate any frequency on its outputs, but jitter performance

 * may be sub-optimal.

 If the current register setting is invalid, pick the first input */

 Make sure the selected clock is also enabled and routed */

 Must be done before otherwise touching hardware */

 Populate the regmap cache in preparation for "cache only" */

		/*

		 * We intend to send all 'final' register values in a single

		 * transaction. So cache all register writes until we're done

		 * configuring.

 Write the configuration pairs from the firmware blob */

 Input must be up and running at this point */

 PLL configuration is required */

 Register the PLL */

 clock framework made a copy of the name */

 Synchronize */

 wait for device to report input clock present and PLL lock */

 clear sticky alarm bits from initialization */

 Free the names, clk framework makes copies */

 SPDX-License-Identifier: GPL-2.0

/*

 * System Control and Power Interface (SCMI) Protocol based clock driver

 *

 * Copyright (C) 2018-2021 ARM Ltd.

	/*

	 * We can't figure out what rate it will be, so just return the

	 * rate back to the caller. scmi_clk_recalc_rate() will be called

	 * after the rate is set and we'll know what rate the clock is

	 * running at then.

 to round up */

	/*

	 * We can't provide enable/disable callback as we can't perform the same

	 * in atomic context. Since the clock framework provides standard API

	 * clk_prepare_enable that helps cases using clk_enable in non-atomic

	 * context, it should be fine providing prepare/unprepare.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2011 Sascha Hauer, Pengutronix <s.hauer@pengutronix.de>

/*

 * DOC: basic fixed multiplier and divider clock that cannot gate

 *

 * Traits of this clock:

 * prepare - clk_prepare only ensures that parents are prepared

 * enable - clk_enable only ensures that parents are enabled

 * rate - rate is fixed.  clk->rate = parent->rate / div * mult

 * parent - fixed parent.  No clk_set_parent support

	/*

	 * We must report success but we can do so unconditionally because

	 * clk_factor_round_rate returns values that ensure this call is a

	 * nop.

	/*

	 * We can not use clk_hw_unregister_fixed_factor, since it will kfree()

	 * the hw, resulting in double free. Just unregister the hw and let

	 * devres code kfree() it.

 You can't use devm without a dev */

 struct clk_fixed_factor assignments */

 Sentinel */ },

		/*

		 * Clear OF_POPULATED flag so that clock registration can be

		 * attempted again from probe function.

/**

 * of_fixed_factor_clk_setup() - Setup function for simple fixed factor clock

 * @node:	device node for the clock

	/*

	 * This function is not executed when of_fixed_factor_clk_setup

	 * succeeded.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Layerscape FlexSPI clock driver

 *

 * Copyright 2020 Michael Walle <michael@walle.cc>

	/*

	 * Can't use devm_ioremap_resource() or devm_of_iomap() because the

	 * resource might already be taken by the parent device.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Microchip Sparx5 SoC Clock driver.

 *

 * Copyright (c) 2019 Microchip Inc.

 *

 * Author: Lars Povlsen <lars.povlsen@microchip.com>

 Fractional rate */

 Best match */

 Straight match? */

 Try without rounding divider */

 Select the better match */

 Straight fit */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * TI CDCE706 programmable 3-PLL clock synthesizer driver

 *

 * Copyright (c) 2014 Cadence Design Systems Inc.

 *

 * Reference: https://www.ti.com/lit/ds/symlink/cdce706.pdf

/*

 * MOXA ART SoCs clock driver.

 *

 * Copyright (C) 2013 Jonas Jensen

 *

 * Jonas Jensen <jonas.jensen@gmail.com>

 *

 * This file is licensed under the terms of the GNU General Public

 * License version 2.  This program is licensed "as is" without any

 * warranty of any kind, whether express or implied.

/*

 * Driver for TI Multi PLL CDCE913/925/937/949 clock synthesizer

 *

 * This driver always connects the Y1 to the input clock, Y2/Y3 to PLL1,

 * Y4/Y5 to PLL2, and so on. PLL frequency is set on a first-come-first-serve

 * basis. Clients can directly request any frequency that the chip can

 * deliver using the standard clk framework. In addition, the device can

 * be configured and activated via the devicetree.

 *

 * Copyright (C) 2014, Topic Embedded Products

 * Licenced under GPL

/* Each chip has different number of PLLs and outputs, for example:

 * The CECE925 has 2 PLLs which can be routed through dividers to 5 outputs.

 * Model this as 2 PLL clocks which are parents to the outputs.

 PLL parameters start at 0x10, steps of 0x10 */

 Add CDCE925_OFFSET_PLL * (pll) to these registers before sending */

 1..127 for Y2-Y9; 1..1023 for Y1 */

 1..511 */

 1..4095 */

 ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** */

 In bypass mode runs at same frequency */

 Output frequency of PLL is Fout = (Fin/Pdiv)*(N/M) */

 Can always deliver parent_rate in bypass mode */

 In PLL mode, need to apply min/max range */

 When outside hw range, reduce to fit (rounding errors) */

 Bypass mode */

 calculate p = max(0, 4 - int(log2 (n/m))) */

 Returns VCO range bits for VCO1_0_RANGE */

/* I2C clock, hence everything must happen in (un)prepare because this

 Bits are spread out over 4 byte registers */

 Set PLL mux to bypass mode, leave the rest as is */

 According to data sheet: */

 p = max(0, 4 - int(log2 (n/m))) */

 nn = n * 2^p */

 q = int(nn/m) */

 encode into register bits */

 Write to registers */

 Enable PLL */

 Disable clock by setting divider to "0" */

 Don't need the PLL, use bypass */

 No can do? */

		/* TODO: Consider PLL frequency based on smaller n/m values

 Y1 has 10-bit divider */

 First byte is command code */

/* The CDCE925 uses a funky way to read/write registers. Bulk mode is

 PWDN bit */

 Set input source for Y1 to be the XTAL */

 Register PLL clocks */

 Register output clock Y1 */

 Mux Y1 to input */

 clock framework made a copy of the name */

 Register output clocks Y2 .. Y5*/

 Mux Y2/3 to PLL1 */

 Mux Y4/5 to PLL2 */

 Mux Y6/7 to PLL3 */

 Mux Y8/9 to PLL4 */

 clock framework made a copy of the name */

 Register the output clocks */

 clock framework made a copy of the name */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Clock driver for Hi655x

 *

 * Copyright (c) 2017, Linaro Ltd.

 *

 * Author: Daniel Lezcano <daniel.lezcano@linaro.org>

 SPDX-License-Identifier: GPL-2.0

/*

 * Cortina Gemini SoC Clock Controller driver

 * Copyright (c) 2017 Linus Walleij <linus.walleij@linaro.org>

 Globally visible clocks */

/**

 * struct gemini_data_data - Gemini gated clocks

 * @bit_idx: the bit used to gate this clock in the clock register

 * @name: the clock name

 * @parent_name: the name of the parent clock

 * @flags: standard clock framework flags

/**

 * struct clk_gemini_pci - Gemini PCI clock

 * @hw: corresponding clock hardware entry

 * @map: regmap to access the registers

 * @rate: current rate

/**

 * struct gemini_reset - gemini reset controller

 * @map: regmap to access the containing system controller

 * @rcdev: reset controller device

 Keeps track of all clocks */

	/*

	 * The DDR controller may never have a driver, but certainly must

	 * not be gated off.

	/*

	 * The flash controller must be on to access NOR flash through the

	 * memory map.

 We support 33 and 66 MHz */

/*

 * This is a self-deasserting reset controller.

 Manual says to always set BIT 30 (CPU1) to 1 */

 Gives the fracions 1x, 1.5x, 1.85x and 2x */

 Remap the system controller for the exclusive register */

 RTC clock 32768 Hz */

 CPU clock derived as a fixed ratio from the AHB clock */

 Security clock is 1:1 or 0.75 of APB */

	/*

	 * These are the leaf gates, at boot no clocks are gated.

	/*

	 * The TV Interface Controller has a 5-bit half divider register.

	 * This clock is supposed to be 27MHz as this is an exact multiple

	 * of PAL and NTSC frequencies. The register is undocumented :(

	 * FIXME: figure out the parent and how the divider works.

 FIXME: very unclear what the parent is */

 FIXME: very unclear what the parent is */

 sentinel */ },

	/*

	 * This way all clock fetched before the platform device probes,

	 * except those we assign here for early use, will be deferred.

	/*

	 * We check that the regmap works on this very first access,

	 * but as this is an MMIO-backed regmap, subsequent regmap

	 * access is not going to fail and we skip error checks from

	 * this point.

	/*

	 * XTAL is the crystal oscillator, 60 or 30 MHz selected from

	 * strap pin E6

 VCO clock derived from the crystal */

 If we run on 30 MHz crystal we have to multiply with two */

 The AHB clock is always 1/3 of the VCO */

 The APB clock is always 1/6 of the AHB */

 Register the clocks to be accessed by the device tree */

 SPDX-License-Identifier: GPL-2.0

/*

 * Lochnagar clock control

 *

 * Copyright (c) 2017-2018 Cirrus Logic, Inc. and

 *                         Cirrus Logic International Semiconductor Ltd.

 *

 * Author: Charles Keepax <ckeepax@opensource.cirrus.com>

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * clk-xgene.c - AppliedMicro X-Gene Clock Interface

 *

 * Copyright (c) 2013, Applied Micro Circuits Corporation

 * Author: Loc Ho <lho@apm.com>

 Register SCU_PCPPLL bit fields */

 Register SCU_SOCPLL bit fields */

 PLL Clock */

			/*

			* PLL VCO = Reference clock * NF

			* PCP PLL = PLL_VCO / 2

			/*

			* Fref = Reference Clock / NREF;

			* Fvco = Fref * NFB;

			* Fout = Fvco / NOUT;

		/*

		 * fvco = Reference clock * FBDIVC

		 * PLL freq = fvco / NOUT

 allocate the APM clock structure */

 Register the clock */

/**

 * struct xgene_clk_pmd - PMD clock

 *

 * @hw:		handle between common and hardware-specific interfaces

 * @reg:	register containing the fractional scale multiplier (scaler)

 * @shift:	shift to the unit bit field

 * @mask:	mask to the unit bit field

 * @denom:	1/denominator unit

 * @lock:	register lock

 * @flags: XGENE_CLK_PMD_SCALE_INVERTED - By default the scaler is the value read

 *	from the register plus one. For example,

 *		0 for (0 + 1) / denom,

 *		1 for (1 + 1) / denom and etc.

 *	If this flag is set, it is

 *		0 for (denom - 0) / denom,

 *		1 for (denom - 1) / denom and etc.

 freq = parent_rate * scaler / denom */

 freq = parent_rate * scaler / denom */

	/*

	 * Compute the scaler:

	 *

	 * freq = parent_rate * scaler / denom, or

	 * scaler = freq * denom / parent_rate

 Check if inverted */

 Check if the entry is disabled */

 Parse the DTS register for resource */

 IP Clock */

 CSR for IP clock */

 Offset to clock enable CSR */

 Mask bit for clock enable */

 Offset to CSR reset */

 Mask bit for disable CSR reset */

 CSR for divider */

 Offset to divider register */

 Bit shift to divider field */

 Width of the bit to divider field */

 First enable the clock */

 Second enable the CSR */

 First put the CSR in reset */

 Second disable the clock */

 Let's compute the divider */

 Rounded down */

 Set new divider */

 Let's compute the divider */

 Rounded down */

 allocate the APM clock structure */

 Register the clock */

 Register the clock for lookup */

 Check if the entry is disabled */

 Parse the DTS register for resource */

 if (strcmp(res->name, "csr-reg") == 0) */

 SPDX-License-Identifier: GPL-2.0

/*

 * CS2000  --  CIRRUS LOGIC Fractional-N Clock Synthesizer & Clock Multiplier

 *

 * Copyright (C) 2015 Renesas Electronics Corporation

 * Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>

 DEVICE_ID */

 DEVICE_CTRL */

 DEVICE_CFG1 */

 DEVICE_CFG2 */

 GLOBAL_CFG */

 FUNC_CFG1 */

 FUNC_CFG2 */

 suspend/resume */

 FIXME: for Static ratio mode */

 enable both AUX_OUT, CLK_OUT */

	/*

	 * ratio = rate_out / rate_in * 2^20

	 *

	 * To avoid over flow, rate_out is u64.

	 * The result should be u32.

	/*

	 * ratio = rate_out / rate_in * 2^20

	 *

	 * To avoid over flow, rate_out is u64.

	 * The result should be u32 or unsigned long.

	/*

	 * FIXME

	 *

	 * this driver supports static ratio mode only at this point.

 it uses ch0 only at this point */

 it uses ch0 only at this point */

 it uses ch0 only at this point */

 always return REF_CLK */

 not yet provided */

 not yet provided */

 it uses ch0 only at this point */

	/*

	 * set default rate as 1/1.

	 * otherwise .set_rate which setup ratio

	 * is never called if user requests 1/1 rate

 CS2000 should be 0x0 */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Driver for IDT Versaclock 5

 *

 * Copyright (C) 2017 Marek Vasut <marek.vasut@gmail.com>

/*

 * Possible optimizations:

 * - Use spread spectrum

 * - Use integer divider in FOD if applicable

 VersaClock5 registers */

 Factory-reserved register block */

 Configuration register block */

 These registers are named "Unused Factory Reserved Registers" */

 bypass_sync<idx> bit */

 Output divider control for divider 1,2,3,4 */

 Clock control register for clock 1,2 */

 PLL/VCO runs between 2.5 GHz and 3.0 GHz */

 VC5 Input mux settings */

 Maximum number of clk_out supported by this driver */

 Maximum number of FODs supported by this driver */

 flags to describe chip features */

 chip has built-in oscilator */

 chip has PFD requency doubler */

 chip has bits to disable FOD sync */

 Supported IDT VC5 models. */

 Structure to describe features of a particular VC5 model */

/*

 * VersaClock5 i2c regmap

 Factory reserved regs, make them read-only */

 Factory reserved regs, make them read-only */

/*

 * VersaClock5 input multiplexer between XTAL and CLKIN divider

 Invalid; should have been caught by vc5_probe() */

 The bypass_prediv is set, PLL fed from Ref_in directly. */

 The Sel_prediv2 is set, PLL fed from prediv2 (Ref_in / 2) */

 PLL cannot operate with input clock above 50 MHz. */

 CLKIN within range of PLL input, feed directly to PLL. */

 CLKIN within range of PLL input, feed directly to PLL. */

 We have dedicated div-2 predivider. */

/*

 * VersaClock5 PLL/VCO

 The PLL divider has 12 integer bits and 24 fractional bits */

 Determine integer part, which is 12 bit wide */

 Determine best fractional part, which is 24 bit wide */

 VCO frequency is divided by two before entering FOD */

 Avoid division by zero if the output is not configured. */

 The PLL divider has 12 integer bits and 30 fractional bits */

 VCO frequency is divided by two before entering FOD */

 Determine integer part, which is 12 bit wide */

	/*

	 * WARNING: The clock chip does not output signal if the integer part

	 *          of the divider is 0xfff and fractional part is non-zero.

	 *          Clamp the divider at 0xffe to keep the code simple.

 Determine best fractional part, which is 30 bit wide */

	/*

	 * Toggle magic bit in undocumented register for unknown reason.

	 * This is what the IDT timing commander tool does and the chip

	 * datasheet somewhat implies this is needed, but the register

	 * and the bit is not documented.

	/*

	 * When enabling a FOD, all currently enabled FODs are briefly

	 * stopped in order to synchronize all of them. This causes a clock

	 * disruption to any unrelated chips that might be already using

	 * other clock outputs. Bypass the sync feature to avoid the issue,

	 * which is possible on the VersaClock 6E family via reserved

	 * registers.

	/*

	 * If the input mux is disabled, enable it first and

	 * select source from matching FOD.

 Enable the clock buffer */

 Disable the clock buffer */

 Input mux set to DISABLED */

	/*

	 * The datasheet explicitly states 9000 - 25000 with 0.5pF

	 * steps, but the Programmer's guide shows the steps are 0.430pF.

	 * After getting feedback from Renesas, the .5pF steps were the

	 * goal, but 430nF was the actual values.

	 * Because of this, the actual range goes to 22760 instead of 25000

	/*

	 * The Programmer's guide shows XTAL[5:0] but in reality,

	 * XTAL[0] and XTAL[1] are both LSB which makes the math

	 * strange.  With clarfication from Renesas, setting the

	 * values should be simpler by ignoring XTAL[0]

	/*

	 * Since the calculation ignores XTAL[0], there is one

	 * special case where mapped_value = 32.  In reality, this means

	 * the real mapped value should be 111111b.  In other cases,

	 * the mapped_value needs to be shifted 1 to the left.

		/*

		 * The mapped_value is really the high 6 bits of

		 * VC5_XTAL_X1_LOAD_CAP and VC5_XTAL_X2_LOAD_CAP, so

		 * shift the value 2 places.

 Register clock input mux */

 Configure Optional Loading Capacitance for external XTAL */

 clock framework made a copy of the name */

 Register frequency doubler */

 clock framework made a copy of the name */

 Register PFD */

 clock framework made a copy of the name */

 Register PLL */

 clock framework made a copy of the name */

 Register FODs */

 clock framework made a copy of the name */

 Register MUX-connected OUT0_I2C_SELB output */

 clock framework made a copy of the name */

 Register FOD-connected OUTx outputs */

 clock framework made a copy of the name */

 Fetch Clock Output configuration from DT (if specified) */

 clock framework made a copy of the name */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2011-2012 Calxeda, Inc.

 Need to re-lock PLL, so put it into bypass mode */

 Map system registers */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2010-2011 Canonical Ltd <jeremy.kerr@canonical.com>

 * Copyright (C) 2011-2012 Mike Turquette, Linaro Ltd <mturquette@linaro.org>

 *

 * Gated clock implementation

/**

 * DOC: basic gatable clock which can gate and ungate it's ouput

 *

 * Traits of this clock:

 * prepare - clk_(un)prepare only ensures parent is (un)prepared

 * enable - clk_enable and clk_disable are functional & control gating

 * rate - inherits rate from parent.  No clk_set_rate support

 * parent - fixed parent.  No clk_set_parent support

/*

 * It works on following logic:

 *

 * For enabling clock, enable = 1

 *	set2dis = 1	-> clear bit	-> set = 0

 *	set2dis = 0	-> set bit	-> set = 1

 *

 * For disabling clock, enable = 0

 *	set2dis = 1	-> set bit	-> set = 1

 *	set2dis = 0	-> clear bit	-> set = 0

 *

 * So, result is always: enable xor set2dis.

 if a set bit disables this clk, flip it before masking */

 allocate the gate */

 struct clk_gate assignments */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * drivers/clk/clkdev.c

 *

 *  Copyright (C) 2008 Russell King.

 *

 * Helper for the clk API to assist looking up a struct clk.

/*

 * Find the correct struct clk for the device and connection ID.

 * We do slightly fuzzy matching here:

 *  An entry with a NULL ID is assumed to be a wildcard.

 *  If an entry has a device ID, it must match

 *  If an entry has a connection ID, it must match

 * Then we take the most specific entry - with the following

 * order of precedence: dev+con > dev only > con only.

/**

 * clkdev_create - allocate and add a clkdev lookup structure

 * @clk: struct clk to associate with all clk_lookups

 * @con_id: connection ID string on device

 * @dev_fmt: format string describing device name

 *

 * Returns a clk_lookup structure, which can be later unregistered and

 * freed.

/**

 * clkdev_hw_create - allocate and add a clkdev lookup structure

 * @hw: struct clk_hw to associate with all clk_lookups

 * @con_id: connection ID string on device

 * @dev_fmt: format string describing device name

 *

 * Returns a clk_lookup structure, which can be later unregistered and

 * freed.

/*

 * clkdev_drop - remove a clock dynamically allocated

	/*

	 * Since dev_id can be NULL, and NULL is handled specially, we must

	 * pass it as either a NULL format string, or with "%s".

/**

 * clk_register_clkdev - register one clock lookup for a struct clk

 * @clk: struct clk to associate with all clk_lookups

 * @con_id: connection ID string on device

 * @dev_id: string describing device name

 *

 * con_id or dev_id may be NULL as a wildcard, just as in the rest of

 * clkdev.

 *

 * To make things easier for mass registration, we detect error clks

 * from a previous clk_register() call, and return the error code for

 * those.  This is to permit this function to be called immediately

 * after clk_register().

/**

 * clk_hw_register_clkdev - register one clock lookup for a struct clk_hw

 * @hw: struct clk_hw to associate with all clk_lookups

 * @con_id: connection ID string on device

 * @dev_id: format string describing device name

 *

 * con_id or dev_id may be NULL as a wildcard, just as in the rest of

 * clkdev.

 *

 * To make things easier for mass registration, we detect error clk_hws

 * from a previous clk_hw_register_*() call, and return the error code for

 * those.  This is to permit this function to be called immediately

 * after clk_hw_register_*().

/**

 * devm_clk_release_clkdev - Resource managed clkdev lookup release

 * @dev: device this lookup is bound

 * @con_id: connection ID string on device

 * @dev_id: format string describing device name

 *

 * Drop the clkdev lookup created with devm_clk_hw_register_clkdev.

 * Normally this function will not need to be called and the resource

 * management code will ensure that the resource is freed.

/**

 * devm_clk_hw_register_clkdev - managed clk lookup registration for clk_hw

 * @dev: device this lookup is bound

 * @hw: struct clk_hw to associate with all clk_lookups

 * @con_id: connection ID string on device

 * @dev_id: format string describing device name

 *

 * con_id or dev_id may be NULL as a wildcard, just as in the rest of

 * clkdev.

 *

 * To make things easier for mass registration, we detect error clk_hws

 * from a previous clk_hw_register_*() call, and return the error code for

 * those.  This is to permit this function to be called immediately

 * after clk_hw_register_*().

 SPDX-License-Identifier: GPL-2.0

/*

 * Freescale SAI BCLK as a generic clock driver

 *

 * Copyright 2020 Michael Walle <michael@walle.cc>

 set clock direction, we are the BCLK master */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * AXI clkgen driver

 *

 * Copyright 2012-2013 Analog Devices Inc.

 *  Author: Lars-Peter Clausen <lars@metafoo.de>

 Lets see if we find a better setting in fractional mode */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2014 Intel Corporation

 *

 * Adjustable fractional divider clock implementation.

 * Uses rational best approximation algorithm.

 *

 * Output is calculated as

 *

 *	rate = (m / n) * parent_rate				(1)

 *

 * This is useful when we have a prescaler block which asks for

 * m (numerator) and n (denominator) values to be provided to satisfy

 * the (1) as much as possible.

 *

 * Since m and n have the limitation by a range, e.g.

 *

 *	n >= 1, n < N_width, where N_width = 2^nwidth		(2)

 *

 * for some cases the output may be saturated. Hence, from (1) and (2),

 * assuming the worst case when m = 1, the inequality

 *

 *	floor(log2(parent_rate / rate)) <= nwidth		(3)

 *

 * may be derived. Thus, in cases when

 *

 *	(parent_rate / rate) >> N_width				(4)

 *

 * we might scale up the rate by 2^scale (see the description of

 * CLK_FRAC_DIVIDER_POWER_OF_TWO_PS for additional information), where

 *

 *	scale = floor(log2(parent_rate / rate)) - nwidth	(5)

 *

 * and assume that the IP, that needs m and n, has also its own

 * prescaler, which is capable to divide by 2^scale. In this way

 * we get the denominator to satisfy the desired range (2) and

 * at the same time much much better result of m and n than simple

 * saturated values.

	/*

	 * Get rate closer to *parent_rate to guarantee there is no overflow

	 * for m and n. In the result it will be the nearest rate left shifted

	 * by (scale - fd->nwidth) bits.

	 *

	 * For the detailed explanation see the top comment in this file.

 SPDX-License-Identifier: GPL-2.0

/*

 * Memory Mapped IO Fixed clock driver

 *

 * Copyright (C) 2018 Cadence Design Systems, Inc.

 *

 * Authors:

 *	Jan Kotas <jank@cadence.com>

/*

 * This is not executed when of_fixed_mmio_clk_setup succeeded.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Author: Daniel Thompson <daniel.thompson@linaro.org>

 *

 * Inspired by clk-asm9260.c .

/*

 * Include list of clocks wich are not derived from system clock (SYSCLOCK)

 * The index of these clocks is the secondary index of DT bindings

 *

/*

 * This bitmask tells us which bit offsets (0..192) on STM32F4[23]xxx

 * have gate bits associated with them. Its combined hweight is 71.

/*

 * "Multiplier" device for APBx clocks.

 *

 * The APBx dividers are power-of-two dividers and, if *not* running in 1:1

 * mode, they also tap out the one of the low order state bits to run the

 * timers. ST datasheets represent this feature as a (conditional) clock

 * multiplier.

	/*

	 * We must report success but we can do so unconditionally because

	 * clk_apb_mul_round_rate returns values that ensure this call is a

	 * nop.

 allocate the divider */

 struct clk_divider assignments */

 register the clock */

/*

 * Converts the primary and secondary indices (as they appear in DT) to an

 * offset into our struct clock array.

 only bits set in table can be used as indices */

 mask out bits above our current index */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright 2017 NXP

 *

 * Dong Aisheng <aisheng.dong@nxp.com>

/**

 * clk_bulk_unprepare - undo preparation of a set of clock sources

 * @num_clks: the number of clk_bulk_data

 * @clks: the clk_bulk_data table being unprepared

 *

 * clk_bulk_unprepare may sleep, which differentiates it from clk_bulk_disable.

 * Returns 0 on success, -EERROR otherwise.

/**

 * clk_bulk_prepare - prepare a set of clocks

 * @num_clks: the number of clk_bulk_data

 * @clks: the clk_bulk_data table being prepared

 *

 * clk_bulk_prepare may sleep, which differentiates it from clk_bulk_enable.

 * Returns 0 on success, -EERROR otherwise.

 CONFIG_HAVE_CLK_PREPARE */

/**

 * clk_bulk_disable - gate a set of clocks

 * @num_clks: the number of clk_bulk_data

 * @clks: the clk_bulk_data table being gated

 *

 * clk_bulk_disable must not sleep, which differentiates it from

 * clk_bulk_unprepare. clk_bulk_disable must be called before

 * clk_bulk_unprepare.

/**

 * clk_bulk_enable - ungate a set of clocks

 * @num_clks: the number of clk_bulk_data

 * @clks: the clk_bulk_data table being ungated

 *

 * clk_bulk_enable must not sleep

 * Returns 0 on success, -EERROR otherwise.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ARTPEC-6 clock initialization

 *

 * Copyright 2015-2016 Axis Comunications AB.

 Mandatory parent clock. */

 Read PLL1 factors configured by boot strap pins. */

 DDR3-2133 mode */

 DDR3-1866 mode */

 DDR3-1600 mode */

 DDR3-1333 mode */

 EPROBE_DEFER on the apb_clock is not handled in amba devices. */

 Mandatory parent clock. */

 Find clock names of optional parent clocks. */

 Lock the mux for internal clock reference. */

 Lock the mux for external clock reference. */

 SPDX-License-Identifier: GPL-2.0

/*

 * Marvell Armada CP110 System Controller

 *

 * Copyright (C) 2016 Marvell

 *

 * Thomas Petazzoni <thomas.petazzoni@free-electrons.com>

 *

/*

 * CP110 has 6 core clocks:

 *

 *  - PLL0		(1 Ghz)

 *    - PPv2 core	(1/3 PLL0)

 *    - x2 Core		(1/2 PLL0)

 *	- Core		(1/2 x2 Core)

 *    - SDIO		(2/5 PLL0)

 *

 *  - NAND clock, which is either:

 *    - Equal to SDIO clock

 *    - 2/5 PLL0

 *

 * CP110 has 32 gateable clocks, for the various peripherals in the IP.

 A number of gateable clocks need special handling */

 Register the PLL0 which is the root of the hw tree */

 PPv2 is PLL0/3 */

 X2CORE clock is PLL0/2 */

 Core clock is X2CORE/2 */

 NAND can be either PLL0/2.5 or core clock */

 SDIO clock is PLL0/2.5 */

 create the unique name for all the gate clocks */

 SPDX-License-Identifier: GPL-2.0

/*

 * Marvell Armada 370 SoC clocks

 *

 * Copyright (C) 2012 Marvell

 *

 * Gregory CLEMENT <gregory.clement@free-electrons.com>

 * Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>

 * Andrew Lunn <andrew@lunn.ch>

 *

/*

 * Core Clocks

 Low part [0:31] */

/*

 * Clock Gating Control

 SPDX-License-Identifier: GPL-2.0

/*

 * Marvell Armada 39x SoC clocks

 *

 * Copyright (C) 2015 Marvell

 *

 * Gregory CLEMENT <gregory.clement@free-electrons.com>

 * Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>

 * Andrew Lunn <andrew@lunn.ch>

 * Thomas Petazzoni <thomas.petazzoni@free-electrons.com>

 *

/*

 * SARL[14:10] : Ratios between CPU, NBCLK, HCLK and DCLK.

 *

 * SARL[15]    : TCLK frequency

 *		 0 = 250 MHz

 *		 1 = 200 MHz

 *

 * SARH[0]     : Reference clock frequency

 *               0 = 25 Mhz

 *               1 = 40 Mhz

/*

 * Clock Gating Control

 SPDX-License-Identifier: GPL-2.0

/*

 * Marvell Dove SoC clocks

 *

 * Copyright (C) 2012 Marvell

 *

 * Gregory CLEMENT <gregory.clement@free-electrons.com>

 * Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>

 * Andrew Lunn <andrew@lunn.ch>

 *

/*

 * Core Clocks

 *

 * Dove PLL sample-at-reset configuration

 *

 * SAR0[8:5]   : CPU frequency

 *		 5  = 1000 MHz

 *		 6  =  933 MHz

 *		 7  =  933 MHz

 *		 8  =  800 MHz

 *		 9  =  800 MHz

 *		 10 =  800 MHz

 *		 11 = 1067 MHz

 *		 12 =  667 MHz

 *		 13 =  533 MHz

 *		 14 =  400 MHz

 *		 15 =  333 MHz

 *		 others reserved.

 *

 * SAR0[11:9]  : CPU to L2 Clock divider ratio

 *		 0 = (1/1) * CPU

 *		 2 = (1/2) * CPU

 *		 4 = (1/3) * CPU

 *		 6 = (1/4) * CPU

 *		 others reserved.

 *

 * SAR0[15:12] : CPU to DDR DRAM Clock divider ratio

 *		 0  = (1/1) * CPU

 *		 2  = (1/2) * CPU

 *		 3  = (2/5) * CPU

 *		 4  = (1/3) * CPU

 *		 6  = (1/4) * CPU

 *		 8  = (1/5) * CPU

 *		 10 = (1/6) * CPU

 *		 12 = (1/7) * CPU

 *		 14 = (1/8) * CPU

 *		 15 = (1/10) * CPU

 *		 others reserved.

 *

 * SAR0[24:23] : TCLK frequency

 *		 0 = 166 MHz

 *		 1 = 125 MHz

 *		 others reserved.

/*

 * Clock Gating Control

 SPDX-License-Identifier: GPL-2.0+

/*

 * Marvell Armada AP CPU Clock Controller

 *

 * Copyright (C) 2018 Marvell

 *

 * Omri Itach <omrii@marvell.com>

 * Gregory Clement <gregory.clement@bootlin.com>

/*

 * struct cpu_dfs_regs: CPU DFS register mapping

 * @divider_reg: full integer ratio from PLL frequency to CPU clock frequency

 * @force_reg: request to force new ratio regardless of relation to other clocks

 * @ratio_reg: central request to switch ratios

 AP806 CPU DFS register mapping*/

 AP807 CPU DFS register mapping */

/*

 * struct ap806_clk: CPU cluster clock controller instance

 * @cluster: Cluster clock controller index

 * @clk_name: Cluster clock controller name

 * @dev : Cluster clock device

 * @hw: HW specific structure of Cluster clock controller

 * @pll_cr_base: CA72MP2 Register base (Device Sample at Reset register)

	/*

	 * AP807 CPU divider has two channels with ratio 1:3 and divider_ratio

	 * is 1. Otherwise, in the case of the AP806, divider_ratio is 0.

	/*

	 * AP806 has 4 cpus and DFS for AP806 is controlled per

	 * cluster (2 CPUs per cluster), cpu0 and cpu1 are fixed to

	 * cluster0 while cpu2 and cpu3 are fixed to cluster1 whether

	 * they are enabled or not.  Since cpu0 is the boot cpu, then

	 * cluster0 must exist.  If cpu2 or cpu3 is enabled, cluster1

	 * will exist and the cluster number is 2; otherwise the

	 * cluster number is 1.

 If cpu2 or cpu3 is enabled */

	/*

	 * DFS for AP806 is controlled per cluster (2 CPUs per cluster),

	 * so allocate structs per cluster

 Initialize once for one cluster */

 SPDX-License-Identifier: GPL-2.0

/*

 * Marvell Armada AP806 System Controller

 *

 * Copyright (C) 2016 Marvell

 *

 * Thomas Petazzoni <thomas.petazzoni@free-electrons.com>

 *

 Convert to hertz */

 CPU clocks depend on the Sample At Reset configuration */

 Fixed clock is always 1200 Mhz */

 MSS Clock is fixed clock divided by 6 */

 SDIO(/eMMC) Clock is fixed clock divided by 3 */

 AP-DCLK(HCLK) Clock is DDR clock divided by 2 */

 SPDX-License-Identifier: GPL-2.0

/*

 * Marvell Kirkwood SoC clocks

 *

 * Copyright (C) 2012 Marvell

 *

 * Gregory CLEMENT <gregory.clement@free-electrons.com>

 * Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>

 * Andrew Lunn <andrew@lunn.ch>

 *

/*

 * Core Clocks

 *

 * Kirkwood PLL sample-at-reset configuration

 * (6180 has different SAR layout than other Kirkwood SoCs)

 *

 * SAR0[4:3,22,1] : CPU frequency (6281,6292,6282)

 *	4  =  600 MHz

 *	6  =  800 MHz

 *	7  = 1000 MHz

 *	9  = 1200 MHz

 *	12 = 1500 MHz

 *	13 = 1600 MHz

 *	14 = 1800 MHz

 *	15 = 2000 MHz

 *	others reserved.

 *

 * SAR0[19,10:9] : CPU to L2 Clock divider ratio (6281,6292,6282)

 *	1 = (1/2) * CPU

 *	3 = (1/3) * CPU

 *	5 = (1/4) * CPU

 *	others reserved.

 *

 * SAR0[8:5] : CPU to DDR DRAM Clock divider ratio (6281,6292,6282)

 *	2 = (1/2) * CPU

 *	4 = (1/3) * CPU

 *	6 = (1/4) * CPU

 *	7 = (2/9) * CPU

 *	8 = (1/5) * CPU

 *	9 = (1/6) * CPU

 *	others reserved.

 *

 * SAR0[4:2] : Kirkwood 6180 cpu/l2/ddr clock configuration (6180 only)

 *	5 = [CPU =  600 MHz, L2 = (1/2) * CPU, DDR = 200 MHz = (1/3) * CPU]

 *	6 = [CPU =  800 MHz, L2 = (1/2) * CPU, DDR = 200 MHz = (1/4) * CPU]

 *	7 = [CPU = 1000 MHz, L2 = (1/2) * CPU, DDR = 200 MHz = (1/5) * CPU]

 *	others reserved.

 *

 * SAR0[21] : TCLK frequency

 *	0 = 200 MHz

 *	1 = 166 MHz

 *	others reserved.

 mv88f6180 has a fixed 1:2 CPU-to-L2 ratio */

/*

 * Clock Gating Control

/*

 * Clock Muxing Control

 lock must already be initialized */

 Count, allocate, and register clock muxes */

 SPDX-License-Identifier: GPL-2.0

/*

 * Marvell Armada 375 SoC clocks

 *

 * Copyright (C) 2014 Marvell

 *

 * Gregory CLEMENT <gregory.clement@free-electrons.com>

 * Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>

 * Andrew Lunn <andrew@lunn.ch>

 *

/*

 * Core Clocks

/*

 * For the Armada 375 SoCs, the CPU, DDR and L2 clocks frequencies are

 * all modified at the same time, and not separately as for the Armada

 * 370 or the Armada XP SoCs.

 *

 * SAR1[21:17]   : CPU frequency    DDR frequency   L2 frequency

 *		 6   =  400 MHz	    400 MHz	    200 MHz

 *		 15  =  600 MHz	    600 MHz	    300 MHz

 *		 21  =  800 MHz	    534 MHz	    400 MHz

 *		 25  = 1000 MHz	    500 MHz	    500 MHz

 *		 others reserved.

 *

 * SAR1[22]   : TCLK frequency

 *		 0 = 166 MHz

 *		 1 = 200 MHz

/*

 * Clock Gating Control

 SPDX-License-Identifier: GPL-2.0

/*

 * Marvell Armada 37xx SoC xtal clocks

 *

 * Copyright (C) 2016 Marvell

 *

 * Gregory CLEMENT <gregory.clement@free-electrons.com>

 *

 SPDX-License-Identifier: GPL-2.0+

/*

 * Marvell Armada 37xx SoC Time Base Generator clocks

 *

 * Copyright (C) 2016 Marvell

 *

 * Gregory CLEMENT <gregory.clement@free-electrons.com>

 SPDX-License-Identifier: GPL-2.0

/*

 * Marvell MVEBU CPU clock handling.

 *

 * Copyright (C) 2012 Marvell

 *

 * Gregory CLEMENT <gregory.clement@free-electrons.com>

 *

 Valid ratio are 1:1, 1:2 and 1:3 */

 Set clock divider reload smooth bit mask */

 Now trigger the clock update */

 Wait for clocks to settle down then clear reload request */

	/*

	 * PMU DFS registers are not mapped, Device Tree does not

	 * describes them. We cannot change the frequency dynamically.

 Frequency is going up */

 Frequency is going down */

 SPDX-License-Identifier: GPL-2.0

/*

 * Marvell Orion SoC clocks

 *

 * Copyright (C) 2014 Thomas Petazzoni

 *

 * Thomas Petazzoni <thomas.petazzoni@free-electrons.com>

 *

/*

 * Orion 5181

/*

 * Orion 5182

/*

 * Orion 5281

 On 5281, tclk is always 166 Mhz */

/*

 * Orion 6183

 SPDX-License-Identifier: GPL-2.0+

/*

 * Marvell Armada AP and CP110 helper

 *

 * Copyright (C) 2018 Marvell

 *

 * Gregory Clement <gregory.clement@bootlin.com>

 *

 Do not create a name if there is no clock */

 SPDX-License-Identifier: GPL-2.0

/*

 * Marvell Armada 380/385 SoC clocks

 *

 * Copyright (C) 2014 Marvell

 *

 * Gregory CLEMENT <gregory.clement@free-electrons.com>

 * Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>

 * Andrew Lunn <andrew@lunn.ch>

 *

/*

 * SAR[14:10] : Ratios between PCLK0, NBCLK, HCLK and DRAM clocks

 *

 * SAR[15]    : TCLK frequency

 *		 0 = 250 MHz

 *		 1 = 200 MHz

/*

 * Clock Gating Control

 SPDX-License-Identifier: GPL-2.0

/*

 * Marvell Dove PMU Core PLL divider driver

 *

 * Cleaned up by substantially rewriting, and converted to DT by

 * Russell King.  Origin is not known.

	/*

	 * Create the core PLL clock.  We treat this as a fixed rate

	 * clock as we don't know any better, and documentation is sparse.

 SPDX-License-Identifier: GPL-2.0

/*

 * Marvell MV98DX3236 SoC clocks

 *

 * Copyright (C) 2012 Marvell

 *

 * Gregory CLEMENT <gregory.clement@free-electrons.com>

 * Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>

 * Andrew Lunn <andrew@lunn.ch>

 *

/*

 * For 98DX4251 Sample At Reset the CPU, DDR and Main PLL clocks are all

 * defined at the same time

 *

 * SAR1[20:18]   : CPU frequency    DDR frequency   MPLL frequency

 *		 0  =  400 MHz	    400 MHz	    800 MHz

 *		 2  =  667 MHz	    667 MHz	    2000 MHz

 *		 3  =  800 MHz	    800 MHz	    1600 MHz

 *		 others reserved.

 *

 * For 98DX3236 Sample At Reset the CPU, DDR and Main PLL clocks are all

 * defined at the same time

 *

 * SAR1[20:18]   : CPU frequency    DDR frequency   MPLL frequency

 *		 1  =  667 MHz	    667 MHz	    2000 MHz

 *		 2  =  400 MHz	    400 MHz	    400 MHz

 *		 3  =  800 MHz	    800 MHz	    800 MHz

 *		 5  =  800 MHz	    400 MHz	    800 MHz

 *		 others reserved.

 Tclk = 200MHz, no SaR dependency */

/*

 * Clock Gating Control

 SPDX-License-Identifier: GPL-2.0+

/*

 * Marvell Armada 37xx SoC Peripheral clocks

 *

 * Copyright (C) 2016 Marvell

 *

 * Gregory CLEMENT <gregory.clement@free-electrons.com>

 *

 * Most of the peripheral clocks can be modelled like this:

 *             _____    _______    _______

 * TBG-A-P  --|     |  |       |  |       |   ______

 * TBG-B-P  --| Mux |--| /div1 |--| /div2 |--| Gate |--> perip_clk

 * TBG-A-S  --|     |  |       |  |       |  |______|

 * TBG-B-S  --|_____|  |_______|  |_______|

 *

 * However some clocks may use only one or two block or and use the

 * xtal clock as parent.

 Storage registers for suspend/resume operations */

 last entry */

 last entry */

 last entry */

 NB periph clocks */

 SB periph clocks */

	/*

	 * This function is always called after the function

	 * armada_3700_pm_dvfs_is_enabled, so no need to check again

	 * if the base is valid.

	/*

	 * The register and the offset inside this register accessed to

	 * read the current divider depend on the load level

	/*

	 * This function is always called after the function

	 * armada_3700_pm_dvfs_is_enabled, so no need to check again

	 * if the base is valid

	/*

	 * The register and the offset inside this register accessed to

	 * read the current divider depend on the load level

 only available when DVFS is enabled */

			/*

			 * We found a load level matching the target

			 * divider, switch to this load level and

			 * return.

 We didn't find any valid divider */

/*

 * Workaround when base CPU frequnecy is 1000 or 1200 MHz

 *

 * Switching the CPU from the L2 or L3 frequencies (250/300 or 200 MHz

 * respectively) to L0 frequency (1/1.2 GHz) requires a significant

 * amount of time to let VDD stabilize to the appropriate

 * voltage. This amount of time is large enough that it cannot be

 * covered by the hardware countdown register. Due to this, the CPU

 * might start operating at L0 before the voltage is stabilized,

 * leading to CPU stalls.

 *

 * To work around this problem, we prevent switching directly from the

 * L2/L3 frequencies to the L0 frequency, and instead switch to the L1

 * frequency in-between. The sequence therefore becomes:

 * 1. First switch from L2/L3 (200/250/300 MHz) to L1 (500/600 MHz)

 * 2. Sleep 20ms for stabling VDD voltage

 * 3. Then switch from L1 (500/600 MHz) to L0 (1000/1200 MHz).

	/*

	 * System wants to go to L1 on its own. If we are going from L2/L3,

	 * remember when 20ms will expire. If from L0, set the value so that

	 * next switch to L0 won't have to wait.

	/*

	 * If we are setting to L2/L3, just invalidate L1 expiration time,

	 * sleeping is not needed.

	/*

	 * We are going to L0 with rate >= 1GHz. Check whether we have been at

	 * L1 for long enough time. If not, go to L1 for 20ms.

 only available when DVFS is enabled */

			/*

			 * We found a load level matching the target

			 * divider, switch to this load level and

			 * return.

 Apply workaround when base CPU frequency is 1000 or 1200 MHz */

 We didn't find any valid divider */

 Follow the same order than what the Cortex-M3 does (ATF code) */

 SPDX-License-Identifier: GPL-2.0

/*

 * MVEBU Core divider clock

 *

 * Copyright (C) 2013 Marvell

 *

 * Ezequiel Garcia <ezequiel.garcia@free-electrons.com>

 *

/*

 * This structure describes the hardware details (bit offset and mask)

 * to configure one particular core divider clock. Those hardware

 * details may differ from one SoC to another. This structure is

 * therefore typically instantiated statically to describe the

 * hardware details.

/*

 * This structure describes the hardware details to configure the core

 * divider clocks on a given SoC. Amongst others, it points to the

 * array of core divider clock descriptors for this SoC, as well as

 * the corresponding operations to manipulate them.

/*

 * This structure represents one core divider clock for the clock

 * framework, and is dynamically allocated for each core divider clock

 * existing in the current SoC.

/*

 * Description of the core divider clocks available. For now, we

 * support only NAND, and it is available at the same register

 * locations regardless of the SoC.

 NAND clock */

 NAND clock */

 Valid ratio are 1:4, 1:5, 1:6 and 1:8 */

 Write new divider to the divider ratio register */

 Set reload-force for this clock */

 Now trigger the clock update */

	/*

	 * Wait for clocks to settle down, and then clear all the

	 * ratios request and the reload request.

 clks holds the clock array */

 corediv holds the clock specific array */

 SPDX-License-Identifier: GPL-2.0

/*

 * Marvell Armada XP SoC clocks

 *

 * Copyright (C) 2012 Marvell

 *

 * Gregory CLEMENT <gregory.clement@free-electrons.com>

 * Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>

 * Andrew Lunn <andrew@lunn.ch>

 *

/*

 * Core Clocks

 *

 * Armada XP Sample At Reset is a 64 bit bitfiled split in two

 * register of 32 bits

 Low part [0:31] */

 High part [32:63] */

 Armada XP TCLK frequency is fixed to 250MHz */

	/*

	 * The upper bit is not contiguous to the other ones and

	 * located in the high part of the SAR registers

	/*

	 * The upper bit is not contiguous to the other ones and

	 * located in the high part of the SAR registers

/*

 * Clock Gating Control

 SPDX-License-Identifier: GPL-2.0

/*

 * Marvell EBU SoC common clock handling

 *

 * Copyright (C) 2012 Marvell

 *

 * Gregory CLEMENT <gregory.clement@free-electrons.com>

 * Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>

 * Andrew Lunn <andrew@lunn.ch>

 *

/*

 * Core Clocks

/*

 * This function can be used by the Kirkwood, the Armada 370, the

 * Armada XP and the Armada 375 SoC. The name of the function was

 * chosen following the dt convention: using the first known SoC

 * compatible with it.

	/*

	 * From Marvell engineer we got the following formula (when

	 * this code was written, the datasheet was erroneous)

	 * Spread percentage = 1/96 * (H - L) / H

	 * H = SSCG_High_Boundary

	 * L = SSCG_Low_Boundary

	 *

	 * As the deviation is half of spread then it lead to the

	 * following formula in the code.

	 *

	 * To avoid an overflow and not lose any significant digit in

	 * the same time we have to use a 64 bit integer.

 Allocate struct for TCLK, cpu clk, and core ratio clocks */

 One more clock for the optional refclk */

 Register TCLK */

 Register CPU clock */

 Register fixed-factor clocks derived from CPU clock */

 Register optional refclk */

 SAR register isn't needed anymore */

/*

 * Clock Gating Control

 lock must already be initialized */

 Count, allocate, and register clock gates */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2016-2017 Imagination Technologies

 * Author: Paul Burton <paul.burton@mips.com>

/*

 * Use CLK_OF_DECLARE so that this driver is probed early enough to provide the

 * CPU frequency for use with the GIC or cop0 counters/timers.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2014, The Linux Foundation. All rights reserved.

 Setup PLL18 static bits */

 Set GMAC footswitch sleep/wakeup values */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2013, The Linux Foundation. All rights reserved.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2016, Linaro Limited

 * Copyright (c) 2014, The Linux Foundation. All rights reserved.

	/*

	 * The vendor tree simply reads the status for this

	 * RPM clock.

 to kHz */

 to kHz */

	/*

	 * Active-only clocks don't care what the rate is during sleep. So,

	 * they vote for zero.

 Don't send requests to the RPM if the rate has not been set. */

 Take peer clock's rate into account only if it's enabled. */

 Undo the active set vote and restore it */

 Take peer clock's rate into account only if it's enabled. */

 Take peer clock's rate into account only if it's enabled. */

	/*

	 * RPM handles rate rounding and we don't have a way to

	 * know what the rate will be, so just return whatever

	 * rate is requested.

	/*

	 * RPM handles rate rounding and we don't have a way to

	 * know what the rate will be, so just return whatever

	 * rate was set.

 MSM8660/APQ8060 */

 apq8064 */

 ipq806x */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2014, The Linux Foundation. All rights reserved.

/**

 * clk_is_enabled_regmap - standard is_enabled() for regmap users

 *

 * @hw: clk to operate on

 *

 * Clocks that use regmap for their register I/O can set the

 * enable_reg and enable_mask fields in their struct clk_regmap and then use

 * this as their is_enabled operation, saving some code.

/**

 * clk_enable_regmap - standard enable() for regmap users

 *

 * @hw: clk to operate on

 *

 * Clocks that use regmap for their register I/O can set the

 * enable_reg and enable_mask fields in their struct clk_regmap and then use

 * this as their enable() operation, saving some code.

/**

 * clk_disable_regmap - standard disable() for regmap users

 *

 * @hw: clk to operate on

 *

 * Clocks that use regmap for their register I/O can set the

 * enable_reg and enable_mask fields in their struct clk_regmap and then use

 * this as their disable() operation, saving some code.

/**

 * devm_clk_register_regmap - register a clk_regmap clock

 *

 * @dev: reference to the caller's device

 * @rclk: clk to operate on

 *

 * Clocks that use regmap for their register I/O should register their

 * clk_regmap struct via this function so that the regmap is initialized

 * and so that the clock is registered with the common clock framework.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2019, Jeffrey Hugo

 Instead of going directly to the block, XO is routed through this branch */

 force periph logic on to avoid perf counter corruption */

 tweak droop detector (GPUCC_GPU_DD_WRAP_CTRL) to reduce leakage */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2018, The Linux Foundation. All rights reserved.

 Secondary and primary muxes share the same cp15 register */

 Wait for switch to complete. */

 Don't touch mux if CPU is off as it won't work */

 The divider can divide by 2, 4, 6 and 8. But we only really need div-2. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2019-2021, The Linux Foundation. All rights reserved.

 listed as BRAMMO, but it doesn't really match */

 1152MHz configuration */

 600MHz configuration */

 800MHz configuration */

 1152MHz configuration */

 | CLK_ENABLE_HAND_OFF */,

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2017, Linaro Limited

 * Author: Georgi Djakov <georgi.djakov@linaro.org>

 Wait for update to take effect */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2021, The Linux Foundation. All rights reserved.

 400MHz Configuration */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2018, The Linux Foundation. All rights reserved.

 CLK_OFF would not toggle until LPASS is out of reset */

 CLK_OFF would not toggle until LPASS is out of reset */

 CLK_OFF would not toggle until LPASS is out of reset */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.

 * Copyright (c) 2020-2021, Linaro Limited

 external clocks so add BRANCH_HALT_SKIP */

 external clocks so add BRANCH_HALT_SKIP */

 external clocks so add BRANCH_HALT_SKIP */

 external clocks so add BRANCH_HALT_SKIP */

 external clocks so add BRANCH_HALT_SKIP */

 external clocks so add BRANCH_HALT_SKIP */

 external clocks so add BRANCH_HALT_SKIP */

 external clocks so add BRANCH_HALT_SKIP */

 Clock ON depends on external parent clock, so don't poll */

 Clock ON depends on external parent clock, so don't poll */

 external clocks so add BRANCH_HALT_SKIP */

 external clocks so add BRANCH_HALT_SKIP */

 external clocks so add BRANCH_HALT_SKIP */

 external clocks so add BRANCH_HALT_SKIP */

 Clock ON depends on external parent clock, so don't poll */

 Clock ON depends on external parent clock, so don't poll */

 Clock ON depends on external parent clock, so don't poll */

 Clock ON depends on external parent clock, so don't poll */

 Clock ON depends on external parent clock, so don't poll */

 Clock ON depends on external parent clock, so don't poll */

 Clock ON depends on external parent clock, so don't poll */

 Clock ON depends on external parent clock, so don't poll */

 external clocks so add BRANCH_HALT_SKIP */

 external clocks so add BRANCH_HALT_SKIP */

	/*

	 * Keep the critical clock always-On

	 * GCC_CAMERA_AHB_CLK, GCC_CAMERA_XO_CLK, GCC_DISP_AHB_CLK, GCC_DISP_XO_CLK,

	 * GCC_GPU_CFG_AHB_CLK, GCC_VIDEO_AHB_CLK, GCC_VIDEO_XO_CLK

 FORCE_MEM_CORE_ON for ufs phy ice core clocks */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2016, The Linux Foundation. All rights reserved.

			/*

			 * The GPU IOMMU depends on this clock and hypervisor

			 * will crash the SoC if this clock goes down, due to

			 * secure contexts protection.

			/*

			 * Any access to mmss depends on this clock.

			 * Gating this clock has been shown to crash the system

			 * when mmssnoc_axi_rpm_clk is inited in rpmcc.

	/*

	 * Set the HMSS_AHB_CLK_SLEEP_ENA bit to allow the hmss_ahb_clk to be

	 * turned off by hardware during certain apps low power modes.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2019, Linaro Ltd.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2018, The Linux Foundation. All rights reserved.

 Disable SW_COLLAPSE for USB0 GDSCR */

 Enable SW_OVERRIDE for USB0 GDSCR */

 Disable SW_COLLAPSE for USB1 GDSCR */

 Enable SW_OVERRIDE for USB1 GDSCR */

 SW Workaround for UBI Huyara PLL */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2015, 2017-2018, The Linux Foundation. All rights reserved.

 CFG_GDSCR */

 Wait 2^n CXO cycles between all states. Here, n=2 (4 cycles). */

 Returns 1 if GDSC status is status, 0 if not, and < 0 on error */

 If disabling votable gdscs, don't poll on status */

		/*

		 * Add a short delay here to ensure that an enable

		 * right after it was disabled does not put it in an

		 * unknown state

		/*

		 * The gds hw controller asserts/de-asserts the status bit soon

		 * after it receives a power on/off request from a master.

		 * The controller then takes around 8 xo cycles to start its

		 * internal state machine and update the status bit. During

		 * this time, the status bit does not reflect the true status

		 * of the core.

		 * Add a delay of 1 us between writing to the SW_COLLAPSE bit

		 * and polling the status bit.

	/*

	 * If clocks to this power domain were already on, they will take an

	 * additional 4 clock cycles to re-enable after the power domain is

	 * enabled. Delay to account for this. A delay is also needed to ensure

	 * clocks are not enabled within 400ns of enabling power to the

	 * memories.

 Turn on HW trigger mode if supported */

		/*

		 * Wait for the GDSC to go through a power down and

		 * up cycle.  In case a firmware ends up polling status

		 * bits for the gdsc, it might read an 'on' status before

		 * the GDSC can finish the power cycle.

		 * We wait 1us before returning to ensure the firmware

		 * can't immediately poll the status bits.

 Turn off HW trigger mode if supported */

		/*

		 * Wait for the GDSC to go through a power down and

		 * up cycle.  In case we end up polling status

		 * bits for the gdsc before the power cycle is completed

		 * it might read an 'on' status wrongly.

	/*

	 * Disable HW trigger: collapse/restore occur based on registers writes.

	 * Disable SW override: Use hardware state-machine for sequencing.

	 * Configure wait time between states.

 Force gdsc ON if only ON state is supported */

 The regulator must be on, sync the kernel state */

		/*

		 * Votable GDSCs can be ON due to Vote from other masters.

		 * If a Votable GDSC is ON, make sure we have a Vote.

 Turn on HW trigger mode if supported */

		/*

		 * Make sure the retain bit is set if the GDSC is already on,

		 * otherwise we end up turning off the GDSC and destroying all

		 * the register contents that we thought we were saving.

 If ALWAYS_ON GDSCs are not ON, turn them ON */

 Add subdomains */

 Remove subdomains */

/*

 * On SDM845+ the GPU GX domain is *almost* entirely controlled by the GMU

 * running in the CX domain so the CPU doesn't need to know anything about the

 * GX domain EXCEPT....

 *

 * Hardware constraints dictate that the GX be powered down before the CX. If

 * the GMU crashes it could leave the GX on. In order to successfully bring back

 * the device the CPU needs to disable the GX headswitch. There being no sane

 * way to reach in and touch that register from deep inside the GPU driver we

 * need to set up the infrastructure to be able to ensure that the GPU can

 * ensure that the GX is off during this super special case. We do this by

 * defining a GX gdsc with a dummy enable function and a "default" disable

 * function.

 *

 * This allows us to attach with genpd_dev_pm_attach_by_name() in the GPU

 * driver. During power up, nothing will happen from the CPU (and the GMU will

 * power up normally but during power down this will ensure that the GX domain

 * is *really* off - this gives us a semi standard way of doing what we need.

 Do nothing but give genpd the impression that we were successful */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2014, The Linux Foundation. All rights reserved.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.

 Keep VIDEO_CC_AHB_CLK and VIDEO_CC_XO_CLK ALWAYS-ON */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2013, The Linux Foundation. All rights reserved.

	/*

	 * Skip checking halt bit if we're explicitly ignoring the bit or the

	 * clock is in hardware gated mode

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2020, The Linux Foundation. All rights reserved.

 600MHz configuration */

 860MHz configuration */

 1920MHz configuration */

 1080MHz configuration */

 SPDX-License-Identifier: GPL-2.0

/*

 * Qualcomm SDX55 APCS clock controller driver

 *

 * Copyright (c) 2020, Linaro Limited

 * Author: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>

/*

 * We use the notifier function for switching to a temporary safe configuration

 * (mux and divider), while the A7 PLL is reconfigured.

 set the mux and divider to safe frequency (400mhz) */

	/*

	 * Attach the power domain to cpudev. Since there is no dedicated driver

	 * for CPUs and the SDX55 platform lacks hardware specific CPUFreq

	 * driver, there seems to be no better place to do this. So do it here!

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2014, The Linux Foundation. All rights reserved.

 Configure the rate of PLL4 if the bootloader hasn't already */

 Enable PLL4 source on the LPASS Primary PLL Mux */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2014, The Linux Foundation. All rights reserved.

 Use the correct frequency plan depending on speed of PLL4 */

 Enable PLL4 source on the LPASS Primary PLL Mux */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2018-2019, The Linux Foundation. All rights reserved.

 * Copyright (c) 2020-2021, Linaro Ltd.

 For CPUSS functionality the AHB clock needs to be left enabled */

 For CPUSS functionality the SYS NOC clock needs to be left enabled */

	/*

	 * Enable the following always-on clocks:

	 * GCC_VIDEO_AHB_CLK, GCC_CAMERA_AHB_CLK, GCC_DISP_AHB_CLK,

	 * GCC_VIDEO_XO_CLK, GCC_CAMERA_XO_CLK, GCC_DISP_XO_CLK,

	 * GCC_CPUSS_GNOC_CLK, GCC_CPUSS_DVM_BUS_CLK, GCC_NPU_CFG_AHB_CLK and

	 * GCC_GPU_CFG_AHB_CLK

 Disable the GPLL0 active input to NPU and GPU via MISC registers */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2020, The Linux Foundation. All rights reserved.

/*

 * Each of the CPU clusters (Power and Perf) on msm8996 are

 * clocked via 2 PLLs, a primary and alternate. There are also

 * 2 Mux'es, a primary and secondary all connected together

 * as shown below

 *

 *                              +-------+

 *               XO             |       |

 *           +------------------>0      |

 *                              |       |

 *                    PLL/2     | SMUX  +----+

 *                      +------->1      |    |

 *                      |       |       |    |

 *                      |       +-------+    |    +-------+

 *                      |                    +---->0      |

 *                      |                         |       |

 * +---------------+    |             +----------->1      | CPU clk

 * |Primary PLL    +----+ PLL_EARLY   |           |       +------>

 * |               +------+-----------+    +------>2 PMUX |

 * +---------------+      |                |      |       |

 *                        |   +------+     |   +-->3      |

 *                        +--^+  ACD +-----+   |  +-------+

 * +---------------+          +------+         |

 * |Alt PLL        |                           |

 * |               +---------------------------+

 * +---------------+         PLL_EARLY

 *

 * The primary PLL is what drives the CPU clk, except for times

 * when we are reprogramming the PLL itself (for rate changes) when

 * we temporarily switch to an alternate PLL.

 *

 * The primary PLL operates on a single VCO range, between 600MHz

 * and 3GHz. However the CPUs do support OPPs with frequencies

 * between 300MHz and 600MHz. In order to support running the CPUs

 * at those frequencies we end up having to lock the PLL at twice

 * the rate and drive the CPU clk via the PLL/2 output and SMUX.

 *

 * So for frequencies above 600MHz we follow the following path

 *  Primary PLL --> PLL_EARLY --> PMUX(1) --> CPU clk

 * and for frequencies between 300MHz and 600MHz we follow

 *  Primary PLL --> PLL/2 --> SMUX(1) --> PMUX(0) --> CPU clk

 *

 * ACD stands for Adaptive Clock Distribution and is used to

 * detect voltage droops.

 PLLs */

 CPU clock is critical and should never be gated */

 CPU clock is critical and should never be gated */

 Enable alt PLLs */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2015 The Linux Foundation. All rights reserved.

/*

 * struct clk_fepll_vco - vco feedback divider corresponds for FEPLL clocks

 * @fdbkdiv_shift: lowest bit for FDBKDIV

 * @fdbkdiv_width: number of bits in FDBKDIV

 * @refclkdiv_shift: lowest bit for REFCLKDIV

 * @refclkdiv_width: number of bits in REFCLKDIV

 * @reg: PLL_DIV register address

/*

 * struct clk_fepll - clk divider corresponds to FEPLL clocks

 * @fixed_div: fixed divider value if divider is fixed

 * @parent_map: map from software's parent index to hardware's src_sel field

 * @cdiv: divider values for PLL_DIV

 * @pll_vco: vco feedback divider

 * @div_table: mapping for actual divider value to register divider value

 *             in case of non fixed divider

 * @freq_tbl: frequency table

/*

 * Contains index for safe clock during APSS freq change.

 * fepll500 is being used as safe clock so initialize it

 * with its index in parents list gcc_xo_ddr_500_200.

 Calculates the VCO rate for FEPLL. */

/*

 * Round rate function for APSS CPU PLL Clock divider.

 * It looks up the frequency table and returns the next higher frequency

 * supported in hardware.

/*

 * Clock set rate function for APSS CPU PLL Clock divider.

 * It looks up the frequency table and updates the PLL divider to corresponding

 * divider value.

	/*

	 * There is no status bit which can be checked for successful CPU

	 * divider update operation so using delay for the same.

/*

 * Clock frequency calculation function for APSS CPU PLL Clock divider.

 * This clock divider is nonlinear so this function calculates the actual

 * divider and returns the output frequency by dividing VCO Frequency

 * with this actual divider value.

	/*

	 * Some dividers have value in 0.5 fraction so multiply both VCO

	 * frequency(parent_rate) and pre_div with 2 to make integer

	 * calculation.

/* Calculates the rate for PLL divider.

 * If the divider value is not fixed then it gets the actual divider value

 * from divider table. Then, it calculate the clock rate by dividing the

 * parent rate with actual divider value.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2020 Linaro Limited

 GPLL3 at 1100 MHz, main output enabled. */

 GPLL4 at 1200 MHz, main output enabled. */

 This is not in the documentation but is in the downstream driver */

 This is not in the documentation but is in the downstream driver */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.

	/*

	 * Keep the clocks always-ON

	 * GCC_CAMERA_AHB_CLK/XO_CLK, GCC_DISP_AHB_CLK/XO_CLK

	 * GCC_VIDEO_AHB_CLK/XO_CLK, GCC_GPU_CFG_AHB_CLK

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2018, The Linux Foundation. All rights reserved.

	/*

	 * Configure gpu_cc_cx_gmu_clk with recommended

	 * wakeup/sleep settings

 Configure clk_dis_wait for gpu_cx_gdsc */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2018, The Linux Foundation. All rights reserved.

/*

 * Notifier function for switching the muxes to safe parent

 * while the hfpll is getting reprogrammed.

 Switch to safe parent */

	/*

	 * By the time POST_RATE_CHANGE notifier is called,

	 * clk framework itself would have changed the parent for the new rate.

	 * Only otherwise, put back to the old parent.

 id < 0 for L2, otherwise id == physical CPU number */

 Rate is 1 because 0 causes problems for __clk_mux_determine_rate */

 Krait configurations have at most 4 CPUs and one L2 */

	/*

	 * We don't want the CPU or L2 clocks to be turned off at late init

	 * if CPUFREQ or HOTPLUG configs are disabled. So, bump up the

	 * refcount of these clocks. Any cpufreq/hotplug manager can assume

	 * that the clocks have already been prepared and enabled by the time

	 * they take over.

	/*

	 * Force reinit of HFPLLs and muxes to overwrite any potential

	 * incorrect configuration of HFPLLs and muxes by the bootloader.

	 * While at it, also make sure the cores are running at known rates

	 * and print the current rate.

	 *

	 * The clocks are set to aux clock rate first to make sure the

	 * secondary mux is not sourcing off of QSB. The rate is then set to

	 * two different rates to force a HFPLL reinit under all

	 * circumstances.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2021, The Linux Foundation. All rights reserved.

 1520MHz Configuration*/

	/*

	 * Keep the clocks always-ON

	 * DISP_CC_XO_CLK

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2018, The Linux Foundation. All rights reserved.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2021, The Linux Foundation. All rights reserved.

 500MHz Configuration */

	/*

	 * Keep the clocks always-ON

	 * GPU_CC_CB_CLK, GPUCC_CX_GMU_CLK

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2013, The Linux Foundation. All rights reserved.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2020, The Linux Foundation. All rights reserved.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2013, The Linux Foundation. All rights reserved.

 SPDX-License-Identifier: GPL-2.0

/*

 * LPASS Audio CC and Always ON CC Glitch Free Mux clock driver

 *

 * Copyright (c) 2020 Linaro Ltd.

 * Author: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2018, The Linux Foundation. All rights reserved.

		/*

		 * rather than marking the clock critical and forcing the clock

		 * to be always enabled, we make sure that the clock is not

		 * disabled: the firmware remains responsible of enabling this

		 * clock (for more info check the commit log)

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2020, The Linux Foundation. All rights reserved.

 * Copyright (c) 2020, AngeloGioacchino Del Regno

 *                     <angelogioacchino.delregno@somainline.org>

 800MHz configuration for GPU PLL0 */

 740MHz configuration for GPU PLL1 */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2021, The Linux Foundation. All rights reserved.

 * Copyright (c) 2021, Konrad Dybcio <konrad.dybcio@somainline.org>

 Disable the GPLL0 active input to NPU and GPU via MISC registers */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2013, The Linux Foundation. All rights reserved.

 Skip if already enabled or in FSM mode */

 Disable PLL bypass mode. */

	/*

	 * H/W requires a 5us delay between disabling the bypass and

	 * de-asserting the reset. Delay 10us just to be safe.

 De-assert active-low PLL reset. */

 Wait until PLL is locked. */

 Enable PLL output. */

 Skip if in FSM mode */

 Wait for pll to enable. */

 Disable PLL bypass mode. */

	/*

	 * H/W requires a 5us delay between disabling the bypass and

	 * de-asserting the reset. Delay 10us just to be safe.

 De-assert active-low PLL reset. */

 Enable PLL output. */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2015, 2018, The Linux Foundation. All rights reserved.

/*

 * Even though 40 bits are present, use only 32 for ease of calculation.

 TRION PLL specific settings and offsets */

 LUCID PLL specific settings and offsets */

 LUCID 5LPE PLL specific settings and offsets */

 ZONDA PLL specific */

 Make sure enable request goes through before waiting for update */

 Disable hwfsm */

 If in FSM mode, just vote for it */

 Skip if already enabled */

	/*

	 * H/W requires a 5us delay between disabling the bypass and

	 * de-asserting the reset.

 Ensure that the write above goes through before returning. */

 If in FSM mode, just unvote it */

 Delay of 2 output clock ticks required until output is disabled */

 Upper ALPHA_BITWIDTH bits of Alpha */

 Latch the input to the PLL */

 Wait for 2 reference cycle before checking ACK bit */

	/*

	 * PLL will latch the new L, Alpha and freq control word.

	 * PLL will respond by raising PLL_ACK_LATCH output when new programming

	 * has been latched in and PLL is being updated. When

	 * UPDATE_LOGIC_BYPASS bit is not set, PLL_UPDATE will be cleared

	 * automatically by hardware when PLL_ACK_LATCH is asserted by PLL.

 Wait for PLL output to stabilize */

	/*

	 * a contains 16 bit alpha_val in two’s complement number in the range

	 * of [-0.5, 0.5).

	/*

	 * alpha_val should be in two’s complement number in the range

	 * of [-0.5, 0.5) so if quotient >= 0.5 then increment the l value

	 * since alpha value will be subtracted in this case.

		/*

		 * Depending upon alpha_mode, it can be treated as M/N value or

		 * as a two’s complement number. When alpha_mode=1,

		 * pll_alpha_val<15:8>=M and pll_apla_val<7:0>=N

		 *

		 *		Fout=FIN*(L+(M/N))

		 *

		 * M is a signed number (-128 to 127) and N is unsigned

		 * (0 to 255). M/N has to be within +/-0.5.

		 *

		 * When alpha_mode=0, it is a two’s complement number in the

		 * range [-0.5, 0.5).

		 *

		 *		Fout=FIN*(L+(alpha_val)/2^16)

		 *

		 * where alpha_val is two’s complement number.

	/*

	 * Huayra PLL supports PLL dynamic programming. User can change L_VAL,

	 * without having to go through the power on sequence.

 Ensure that the write above goes to detect L val change. */

 If in FSM mode, just vote for it */

 Set operation mode to RUN */

 Enable the PLL outputs */

 Enable the global PLL outputs */

 If in FSM mode, just unvote it */

 Disable the global PLL output */

 Disable the PLL outputs */

 Place the PLL mode in STANDBY */

 16 -> 0xf, 8 -> 0x7, 4 -> 0x3, 2 -> 0x1, 1 -> 0x0 */

 If in FSM mode, just vote for it */

 Skip If PLL is already running */

 If in FSM mode, just unvote it */

 Disable main outputs */

 Place the PLL in STANDBY */

/*

 * Due to limited number of bits for fractional rate programming, the

 * rounded up rate could be marginally higher than the requested rate.

 Check if calibration needs to be done i.e. PLL is in reset */

 Return early if calibration is not needed. */

 Setup PLL for calibration frequency */

 Bringup the PLL at calibration frequency */

	/*

	 * If the PLL is in FSM mode, then treat set_rate callback as a

	 * no-operation.

/**

 * clk_lucid_pll_configure - configure the lucid pll

 *

 * @pll: clk alpha pll

 * @regmap: register map

 * @config: configuration to apply for pll

 Disable PLL output */

 Set operation mode to OFF */

 Place the PLL in STANDBY mode */

/*

 * The TRION PLL requires a power-on self-calibration which happens when the

 * PLL comes out of reset. Calibrate in case it is not completed.

 Return early if calibration is not needed. */

 On/off to calibrate */

 Latch the PLL input */

 Wait for 2 reference cycles before checking the ACK bit. */

 Return the latch input to 0 */

 Wait for PLL output to stabilize */

 change L_VAL without having to go through the power on sequence */

 If in FSM mode, just vote for it */

 Check if PLL is already enabled, return if enabled */

 Enable the PLL outputs */

 Enable the global PLL outputs */

 If in FSM mode, just unvote it */

 Disable the global PLL output */

 Disable the PLL outputs */

 Place the PLL mode in STANDBY */

/*

 * The Lucid 5LPE PLL requires a power-on self-calibration which happens

 * when the PLL comes out of reset. Calibrate in case it is not completed.

 Return early if calibration is not needed. */

	/*

	 * If the PLL is in FSM mode, then treat set_rate callback as a

	 * no-operation.

 Disable PLL output */

 Set operation mode to OFF */

 Place the PLL in STANDBY mode */

 If in FSM mode, just vote for it */

 Get the PLL out of bypass mode */

	/*

	 * H/W requires a 1us delay between disabling the bypass and

	 * de-asserting the reset.

 Set operation mode to RUN */

 If cfa mode then poll for freq lock */

 Enable the PLL outputs */

 Enable the global PLL outputs */

 If in FSM mode, just unvote it */

 Disable the global PLL output */

 Disable the PLL outputs */

 Put the PLL in bypass and reset */

 Place the PLL mode in OFF state */

 Wait before polling for the frequency latch */

 Read stay in cfa mode */

 If cfa mode then poll for freq lock */

 Wait for PLL output to stabilize */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2014-2015, The Linux Foundation. All rights reserved.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2018-2019, The Linux Foundation. All rights reserved.

 Return the HW recalc rate for idle use case */

 Return the HW recalc rate for idle use case */

 Return the HW recalc rate for idle use case */

 Return the HW recalc rate for idle use case */

 Return the HW recalc rate for idle use case */

 Return the HW recalc rate for idle use case */

 Return the HW recalc rate for idle use case */

 Return the HW recalc rate for idle use case */

 Return the HW recalc rate for idle use case */

 Return the HW recalc rate for idle use case */

 reset state of disp_cc_mdss_dp_link_div_clk_src divider is 0x3 (div 4) */

 Return the HW recalc rate for idle use case */

 Return the HW recalc rate for idle use case */

 Enable hardware clock gating for DSI and MDP clocks */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2020, The Linux Foundation. All rights reserved.

	/*

	 * Keep the CLK always-ON

	 * LPASS_AUDIO_CORE_SYSNOC_SWAY_CORE_CLK

 PLL settings */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2018, The Linux Foundation. All rights reserved.

 P_VIDEO_PLL0_OUT_EVEN, */

 P_VIDEO_PLL0_OUT_ODD, */

 { P_VIDEO_PLL0_OUT_EVEN, 2 }, */

 { P_VIDEO_PLL0_OUT_ODD, 3 }, */

 { .name = "video_pll0_out_even" }, */

 { .name = "video_pll0_out_odd" }, */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2013, 2018, The Linux Foundation. All rights reserved.

 Dynamic Frequency Scaling */

 Wait for update to take effect */

/*

 * Calculate m/n:d rate

 *

 *          parent_rate     m

 *   rate = ----------- x  ---

 *            hid_div       n

 50 % duty-cycle for Non-MND RCGs */

 50 % duty-cycle always */

 Duty-cycle cannot be modified for non-MND RCGs */

 Calculate 2d value */

 Check bit widths of 2d. If D is too big reduce duty cycle. */

 link rate of 270M */

 119 M */

 130.25 M */

 138.50 M */

 148.50 M */

 154 M */

 205.25 M */

 268.50 M */

 Link rate of 162M */

 119 M */

 130.25 M */

 138.50 M */

 148.50 M */

 154 M */

 205.25 M */

 268.50 M */

 Parent index is set statically in frequency table */

 Force the correct parent */

 Parent index is set statically in frequency table */

 Read the hardware to determine parent during set_rate */

	/*

	 * This function does ping-pong the RCG between PLLs: if we don't

	 * have at least one fixed PLL and two variable ones,

	 * then it's not going to work correctly.

 This has to be a fixed rate PLL */

 Are we going back to a previously used rate? */

 On some targets, the GFX3D RCG may need to divide PLL frequency */

	/*

	 * We should never get here; clk_gfx3d_determine_rate() should always

	 * make us use a different parent than what we're currently using, so

	 * clk_gfx3d_set_rate_and_parent() should always be called.

 wait for RCG to turn ON */

	/*

	 * In case clock is disabled, update the CFG, M, N and D registers

	 * and don't hit the update bit of CMD register.

	/*

	 * Set the update bit because required configuration has already

	 * been written in clk_rcg2_shared_set_rate()

	/*

	 * Store current configuration as switching to safe source would clear

	 * the SRC and DIV of CFG register

	/*

	 * Park the RCG at a safe configuration - sourced off of safe source.

	 * Force enable and disable the RCG while configuring it to safeguard

	 * against any update signal coming from the downstream clock.

	 * The current parent is still prepared and enabled at this point, and

	 * the safe source is always on while application processor subsystem

	 * is online. Therefore, the RCG can safely switch its parent.

 Write back the stored configuration corresponding to current rate */

 Common APIs to be used for DFS based RCGR */

 Allocate space for 1 extra since table is NULL terminated */

	/*

	 * Assume that parent_rate is actually the parent because

	 * we can't do any better at figuring it out when the table

	 * hasn't been populated yet. We only populate the table

	 * in determine_rate because we can't guarantee the parents

	 * will be registered with the framework until then.

	/*

	 * Rate changes with consumer writing a register in

	 * their own I/O region

 Parent rate is a fixed phy link rate */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2015 Linaro Limited

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2016, Linaro Limited

 * Copyright (c) 2014, The Linux Foundation. All rights reserved.

 to kHz */

 Buffered clock needs a binary value */

 to kHz */

 Buffered clock needs a binary value */

	/*

	 * Active-only clocks don't care what the rate is during sleep. So,

	 * they vote for zero.

 Don't send requests to the RPM if the rate has not been set. */

 Take peer clock's rate into account only if it's enabled. */

 Undo the active set vote and restore it */

 Take peer clock's rate into account only if it's enabled. */

 Take peer clock's rate into account only if it's enabled. */

	/*

	 * RPM handles rate rounding and we don't have a way to

	 * know what the rate will be, so just return whatever

	 * rate is requested.

	/*

	 * RPM handles rate rounding and we don't have a way to

	 * know what the rate will be, so just return whatever

	 * rate was set.

 SM6125 */

 SM6115 */

 QCM2290 */

 SPDX-License-Identifier: GPL-2.0

/*

 * Qualcomm APCS clock controller driver

 *

 * Copyright (c) 2017, Linaro Limited

 * Author: Georgi Djakov <georgi.djakov@linaro.org>

/*

 * We use the notifier function for switching to a temporary safe configuration

 * (mux and divider), while the A53 PLL is reconfigured.

 set the mux and divider to safe frequency (400mhz) */

 Use an unique name by appending parent's @unit-address */

 SPDX-License-Identifier: GPL-2.0

/*

 * Qualcomm A53 PLL driver

 *

 * Copyright (c) 2017, Linaro Limited

 * Author: Georgi Djakov <georgi.djakov@linaro.org>

 Skip the freq that is not divisible */

 Fall on a53pll_freq if no freq_tbl is found from OPP */

 Use an unique name by appending @unit-address */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2018-2021, The Linux Foundation. All rights reserved.

/**

 * struct bcm_db - Auxiliary data pertaining to each Bus Clock Manager(BCM)

 * @unit: divisor used to convert Hz value to an RPMh msg

 * @width: multiplier used to convert Hz value to an RPMh msg

 * @vcd: virtual clock domain that this bcm belongs to

 * @reserved: reserved to pad the struct

/**

 * struct clk_rpmh - individual rpmh clock data structure

 * @hw:			handle between common and hardware-specific interfaces

 * @res_name:		resource name for the rpmh clock

 * @div:		clock divider to compute the clock rate

 * @res_addr:		base address of the rpmh resource within the RPMh

 * @res_on_val:		rpmh clock enable value

 * @state:		rpmh clock requested state

 * @aggr_state:		rpmh clock aggregated state

 * @last_sent_aggr_state: rpmh clock last aggr state sent to RPMh

 * @valid_state_mask:	mask to determine the state of the rpmh clock

 * @unit:		divisor to convert rate to rpmh msg in magnitudes of Khz

 * @dev:		device to which it is attached

 * @peer:		pointer to the clock rpmh sibling

/*

 * Update state and aggregate state values based on enable value.

 Nothing required to be done if already off or on */

	/*

	 * RPMh clocks have a fixed rate. Return static rate.

	/*

	 * Since any non-zero value sent to hw would result in enabling the

	 * clock, only send the value if the clock has already been prepared.

 Resource name must match resource id present in cmd-db */

 Resource name must match resource id present in cmd-db */

 Convert unit from Khz to Hz */

 typecast to silence compiler warning */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2013, The Linux Foundation. All rights reserved.

	/*

	 * These clocks select three inputs via two muxes. One mux selects

	 * between csi0 and csi1 and the second mux selects between that mux's

	 * output and csi2. The source and destination selections for each

	 * mux must be clocking for the switch to succeed so just turn on

	 * all three sources because it's easier than figuring out what source

	 * needs to be on at what time.

	/*

	 * Wait at least 6 cycles of slowest clock

	 * for the glitch-free MUX to fully switch sources.

	/*

	 * Wait at least 6 cycles of slowest clock

	 * for the glitch-free MUX to fully switch sources.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2020, The Linux Foundation. All rights reserved.

 1152MHz configuration */

 532MHz configuration */

 533.2MHz configuration */

 1152MHz configuration */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.

 Keep VIDEO_CC_XO_CLK ALWAYS-ON */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2014, The Linux Foundation. All rights reserved.

 * Copyright (c) BayLibre, SAS.

 * Author : Neil Armstrong <narmstrong@baylibre.com>

 Use the correct frequency plan depending on speed of PLL4 */

 Enable PLL4 source on the LPASS Primary PLL Mux */

 SPDX-License-Identifier: GPL-2.0-only

/*x

 * Copyright (c) 2015, The Linux Foundation. All rights reserved.

 Disable the AHB DCD */

 Disable the NoC FSM for mmss_mmagic_cfg_ahb_clk */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.

	/*

	 * Configure gpu_cc_cx_gmu_clk with recommended

	 * wakeup/sleep settings

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2021, Konrad Dybcio <konrad.dybcio@somainline.org>

 Yeah, apparently it's not 2 */

 Vote for GPLL0 to turn on. Needed by acpuclock. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2019-2021, The Linux Foundation. All rights reserved.

 For CPUSS functionality the AHB clock needs to be left enabled */

 For CPUSS functionality the SYS NOC clock needs to be left enabled */

	/*

	 * Disable the GPLL0 active input to MM blocks, NPU

	 * and GPU via MISC registers.

	/*

	 * Keep the clocks always-ON

	 * GCC_CPUSS_GNOC_CLK, GCC_VIDEO_AHB_CLK, GCC_CAMERA_AHB_CLK,

	 * GCC_DISP_AHB_CLK, GCC_GPU_CFG_AHB_CLK

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2016-2017, The Linux Foundation. All rights reserved.

 * Copyright (c) 2018, Craig Tatlor.

			/*

			 * Any access to mmss depends on this clock.

			 * Gating this clock has been shown to crash the system

			 * when mmssnoc_axi_rpm_clk is inited in rpmcc.

	/*

	 * Set the HMSS_AHB_CLK_SLEEP_ENA bit to allow the hmss_ahb_clk to be

	 * turned off by hardware during certain apps low power modes.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.

 * Copyright (c) BayLibre, SAS.

 * Author : Neil Armstrong <narmstrong@baylibre.com>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2020, The Linux Foundation. All rights reserved.

 * Copyright (c) 2020, Martin Botka <martin.botka@somainline.org>

 * Copyright (c) 2020, Konrad Dybcio <konrad.dybcio@somainline.org>

 Voteable PLL */

 APSS controlled PLLs */

 RO to linux */

	/*

	 * NOTE: Op does not work for div-3. Current assumption is that div-3

	 * is not a recommended setting for this divider.

	/*

	 * NOTE: Op does not work for div-3. Current assumption is that div-3

	 * is not a recommended setting for this divider.

 Reset state of MDSS_DP_LINK_INTF_DIV is 0x3 (div-4) */

			/*

			 * Dependency to be enabled before the branch is

			 * enabled.

/* This GDSC seems to hang the whole multimedia subsystem.

static struct gdsc bimc_smmu_gdsc = {

	.gdscr = 0xe020,

	.gds_hw_ctrl = 0xe024,

	.pd = {

		.name = "bimc_smmu",

	},

	.pwrsts = PWRSTS_OFF_ON,

	.parent = &bimc_smmu_gdsc.pd,

	.flags = HW_CTRL,

};

 SDM630 has only one DSI */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2018-2021, The Linux Foundation. All rights reserved.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2019, The Linux Foundation. All rights reserved.

 1380MHz configuration */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2013, The Linux Foundation. All rights reserved.

 Two NS registers means mode control is in NS register */

/*

 * Calculate m/n:d rate

 *

 *          parent_rate     m

 *   rate = ----------- x  ---

 *            pre_div       n

 MN counter mode is in hw.enable_reg sometimes */

 Two NS registers means mode control is in NS register */

 MN counter mode is in hw.enable_reg sometimes */

 Read the hardware to determine parent during set_rate */

 bypass the pre divider */

 let us find appropriate m/n values for this */

/*

 * This type of clock has a glitch-free mux that switches between the output of

 * the M/N counter and an always on clock source (XO). When clk_set_rate() is

 * called we need to make sure that we don't switch to the M/N counter if it

 * isn't clocking because the mux will get stuck and the clock will stop

 * outputting a clock. This can happen if the framework isn't aware that this

 * clock is on and so clk_set_rate() doesn't turn on the new parent. To fix

 * this we switch the mux in the enable/disable ops and reprogram the M/N

 * counter in the set_rate op. We also make sure to switch away from the M/N

 * counter in set_rate if software thinks the clock is off.

 Switch to XO to avoid glitches */

 Switch back to M/N if it's clocking */

 Use M/N */

 Use XO */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2020, The Linux Foundation. All rights reserved.

	/*

	 * Disable the GPLL0 active input to NPU and GPU

	 * via MISC registers.

	/*

	 * Keep the clocks always-ON

	 * GCC_VIDEO_AHB_CLK, GCC_CAMERA_AHB_CLK, GCC_DISP_AHB_CLK,

	 * GCC_CPUSS_DVM_BUS_CLK, GCC_GPU_CFG_AHB_CLK,

	 * GCC_SYS_NOC_CPUSS_AHB_CLK

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.

/*

 * Clock ON depends on external parent 'config noc', so cant poll

 * delay and also mark as crtitical for camss boot

 XO critical input to camss, so no need to poll */

 required for cpuss */

 required for cpuss */

 required for cpuss */

/*

 * Clock ON depends on external parent 'config noc', so cant poll

 * delay and also mark as crtitical for disp boot

 XO critical input to disp, so no need to poll */

 required for gpu */

 required for npu */

 Clock ON depends on external parent 'PIPE' clock, so dont poll */

 Clock ON depends on external parent 'PIPE' clock, so dont poll */

 required for cpuss */

 external clocks so add BRANCH_HALT_SKIP */

 external clocks so add BRANCH_HALT_SKIP */

 external clocks so add BRANCH_HALT_SKIP */

 external clocks so add BRANCH_HALT_SKIP */

 external clocks so add BRANCH_HALT_SKIP */

 external clocks so add BRANCH_HALT_SKIP */

/*

 * Clock ON depends on external parent 'config noc', so cant poll

 * delay and also mark as crtitical for video boot

 XO critical input to video, so no need to poll */

 Disable the GPLL0 active input to NPU and GPU via MISC registers */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2021, Konrad Dybcio <konrad.dybcio@somainline.org>

	/*

	 * Disable the GPLL0 active input to video block via

	 * MISC registers.

	/*

	 * Enable DUAL_EDGE mode for MCLK RCGs

	 * This is requierd to enable MND divider mode

 SPDX-License-Identifier: GPL-2.0

/*

 * Qualcomm A7 PLL driver

 *

 * Copyright (c) 2020, Linaro Limited

 * Author: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>

 Configure PLL only if the l_val is zero */

 SPDX-License-Identifier: GPL-2.0-only

/* Copyright (c) 2013-2016, The Linux Foundation. All rights reserved.

 BLSP1 QUP1 and BLSP2 QUP5 use the same freqs */

 This GDSC does not exist, but ABI has to remain intact */

 V2 and V2.1 */

 MSM8992 features less clocks and some have different freq tables */

		/*

		 * Some 8992 boards might *possibly* use

		 * PCIe1 clocks and controller, but it's not

		 * standard and they should be disabled otherwise.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2017, The Linux Foundation. All rights reserved.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.

 Default to our fastest rate */

 De-assert reset to FSM */

 Program bias count and lock count */

 Enable PLL FSM voting */

/*

 * Backwards compatibility with old DTs. Register a pass-through factor 1/1

 * clock to translate 'path' clk into 'name' clk and register the 'path'

 * clk as a fixed rate clock if it isn't present.

	/*

	 * TODO: The RPM clock driver currently does not support the xo clock.

	 * When xo is added to the RPM clock driver, we should change this

	 * function to skip registration of xo factor clocks.

 Drop 'protected-clocks' from the list of clocks to register */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2018, The Linux Foundation. All rights reserved.

/*

 * As per HW design, some of the CAMCC RCGs needs to

 * move to XO clock during their clock disable so using

 * clk_rcg2_shared_ops for such RCGs. This is required

 * to power down the camera memories gracefully.

 * Also, use CLK_SET_RATE_PARENT flag for the RCGs which

 * have CAM_CC_PLL2_OUT_EVEN PLL as parent in frequency

 * table and requires reconfiguration of the PLL frequency.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2018, 2020, The Linux Foundation. All rights reserved.

 TODO: Remove after DTS updated to protect these */

 Disable the GPLL0 active input to MMSS and GPU via MISC registers */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.

 { P_DISP_CC_PLL1_OUT_EVEN, 5 }, */

 { .hw = &disp_cc_pll1_out_even.clkr.hw }, */

 note: trion == lucid, except for the prepare() op */

 Enable clock gating for MDP clocks */

 DISP_CC_XO_CLK always-on */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2014, The Linux Foundation. All rights reserved.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2018-2019, The Linux Foundation. All rights reserved.

 * Copyright (c) 2020, Linaro Ltd.

	/*

	 * Keep the clocks always-ON as they are critical to the functioning

	 * of the system:

	 * GCC_SYS_NOC_CPUSS_AHB_CLK, GCC_CPUSS_AHB_CLK, GCC_CPUSS_GNOC_CLK

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2021, Konrad Dybcio <konrad.dybcio@somainline.org>

 Is this one even used by anything? Downstream doesn't tell. */

 Note: There might be more frequencies desired here. */

 Gating this clock will wreck havoc among MMSS! */

 V2 and V2.1 */

 MSM8992 features less clocks and some have different freq tables */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2019, The Linux Foundation. All rights reserved.

 360MHz Configuration */

 Recommended WAKEUP/SLEEP settings for the gpu_cc_cx_gmu_clk */

 Configure clk_dis_wait for gpu_cx_gdsc */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2019, The Linux Foundation. All rights reserved.

 Keep VIDEO_CC_XO_CLK ALWAYS-ON */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2013, The Linux Foundation. All rights reserved.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2018, The Linux Foundation. All rights reserved.

 930MHz configuration */

 PWM clks do not have XO as parent as src clk is a balance root */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2021, The Linux Foundation. All rights reserved.

 CLK_OFF would not toggle until LPASS is out of reset */

 CLK_OFF would not toggle until LPASS is out of reset */

 CLK_OFF would not toggle until LPASS is out of reset */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2018, The Linux Foundation. All rights reserved.

 Initialize a HFPLL at a given rate and enable it. */

 Configure PLL parameters for integer mode. */

 Pick the right VCO. */

 Disable PLL bypass mode. */

	/*

	 * H/W requires a 5us delay between disabling the bypass and

	 * de-asserting the reset. Delay 10us just to be safe.

 De-assert active-low PLL reset. */

 Wait for PLL to lock. */

 Enable PLL output. */

 Enable an already-configured HFPLL. */

	/*

	 * Disable the PLL output, disable test mode, enable the bypass mode,

	 * and assert the reset.

/*

 * For optimization reasons, assumes no downstream clocks are actively using

 * it.

 Pick the right VCO. */

 SPDX-License-Identifier: GPL-2.0-only

 Copyright (c) 2021, The Linux Foundation. All rights reserved.

	/*

	 * FIXME: dwc3 usb gadget cannot resume after GDSC power off

	 * dwc3 7000000.dwc3: failed to enable ep0out

 SPDX-License-Identifier: GPL-2.0-only

/* Copyright (c) 2017, The Linux Foundation. All rights reserved.

 Start at 1 instead of 0 */

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2019, The Linux Foundation. All rights reserved.

 RO to linux */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2018, The Linux Foundation. All rights reserved.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2018, The Linux Foundation. All rights reserved.

 TCSR clock */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2018, The Linux Foundation. All rights reserved.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2021, The Linux Foundation. All rights reserved.

 1200MHz Configuration */

 600MHz Configuration */

 1440MHz Configuration */

 760MHz Configuration */

 760MHz Configuration */

 760MHz Configuration */

 960MHz Configuration */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2015, The Linux Foundation. All rights reserved.

	/*

	 * Set the HMSS_AHB_CLK_SLEEP_ENA bit to allow the hmss_ahb_clk to be

	 * turned off by hardware during certain apps low power modes.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2014, The Linux Foundation. All rights reserved.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2019 Paul Cercueil <paul@crapouillou.net>

 SPDX-License-Identifier: GPL-2.0

/*

 * X1000 SoC CGU driver

 * Copyright (c) 2019 周琰杰 (Zhou Yanjie) <zhouyanjie@wanyeetech.com>

 CGU register offsets */

 bits within the OPCR register */

 bits within the USBPCR register */

 bits within the USBPCR1 register */

 External clocks */

 PLLs */

 Custom (SoC-specific) OTG PHY */

 Muxes & dividers */

 Gate-only clocks */

/*

 * CGU has some children devices, this is useful for probing children devices

 * in the case where the device node is compatible with "simple-mfd".

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Ingenic JZ4740 SoC CGU driver

 *

 * Copyright (c) 2015 Imagination Technologies

 * Author: Paul Burton <paul.burton@mips.com>

 CGU register offsets */

 bits within a PLL control register */

 bits within the LCR register */

 bits within the CLKGR register */

 External clocks */

 Muxes & dividers */

 Gate-only clocks */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Ingenic JZ4780 SoC CGU driver

 *

 * Copyright (c) 2013-2015 Imagination Technologies

 * Author: Paul Burton <paul.burton@mips.com>

 * Copyright (c) 2020 周琰杰 (Zhou Yanjie) <zhouyanjie@wanyeetech.com>

 CGU register offsets */

 bits within the OPCR register */

 bits within the USBPCR register */

 bits within the USBPCR1 register */

 bits within the USBRDT register */

 bits within the USBVBFIL register */

 bits within the LCR register */

 bits within the CLKGR1 register */

 wait for the CPU to be powered up */

 External clocks */

 PLLs */

 Custom (SoC-specific) OTG PHY */

 Muxes & dividers */

 Gate-only clocks */

 SPDX-License-Identifier: GPL-2.0

/*

 * Ingenic JZ4725B SoC CGU driver

 *

 * Copyright (C) 2018 Paul Cercueil

 * Author: Paul Cercueil <paul@crapouillou.net>

 CGU register offsets */

 bits within the LCR register */

 External clocks */

 Muxes & dividers */

 Gate-only clocks */

 not sure */, -1, -1, -1 },

 not sure */, -1, -1, -1 },

 Doc calls it EXT512, but it seems to be /256... */

 SPDX-License-Identifier: GPL-2.0

/*

 * JZ4760 SoC CGU driver

 * Copyright 2018, Paul Cercueil <paul@crapouillou.net>

/*

 * CPM registers offset address definition

 The frequency after the N divider must be between 1 and 50 MHz. */

 The N divider must be >= 2. */

 External clocks */

 PLLs */

 TODO: PLL1 can depend on PLL0 */

 Main clocks */

 Divided clocks */

 Those divided clocks can connect to PLL0 or PLL1 */

 Those divided clocks can connect to EXT, PLL0 or PLL1 */

 Those divided clocks can connect to EXT or PLL0 */

 These divided clock can connect to PLL0 only */

 Gate-only clocks */

 Custom clocks */

 We only probe via devicetree, no need for a platform driver */

 JZ4760B has some small differences, but we don't implement them. */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Ingenic SoC CGU driver

 *

 * Copyright (c) 2013-2015 Imagination Technologies

 * Author: Paul Burton <paul.burton@mips.com>

/**

 * ingenic_cgu_gate_get() - get the value of clock gate register bit

 * @cgu: reference to the CGU whose registers should be read

 * @info: info struct describing the gate bit

 *

 * Retrieves the state of the clock gate bit described by info. The

 * caller must hold cgu->lock.

 *

 * Return: true if the gate bit is set, else false.

/**

 * ingenic_cgu_gate_set() - set the value of clock gate register bit

 * @cgu: reference to the CGU whose registers should be modified

 * @info: info struct describing the gate bit

 * @val: non-zero to gate a clock, otherwise zero

 *

 * Sets the given gate bit in order to gate or ungate a clock.

 *

 * The caller must hold cgu->lock.

/*

 * PLL operations

	/*

	 * The frequency after the input divider must be between 10 and 50 MHz.

	 * The highest divider yields the best resolution.

 If the PLL is enabled, verify that it's stable */

/*

 * Operations for all non-PLL clocks

		/*

		 * Convert the hardware index to the parent index by skipping

		 * over any -1's in the parents array.

		/*

		 * Convert the parent index to the hardware index by adding

		 * 1 for any -1 in the parents array preceding the given

		 * index. That is, we want the index of idx'th entry in

		 * clk_info->parents which does not equal -1.

 idx should always be a valid parent */

 write the register */

 calculate the divide */

 Impose hardware constraints */

	/*

	 * If the divider value itself must be divided before being written to

	 * the divider register, we must ensure we don't have any bits set that

	 * would be lost as a result of doing so.

 update the divide */

 clear the stop bit */

 set the change enable bit */

 update the hardware */

 wait for the change to take effect */

 ungate the clock */

 gate the clock */

/*

 * Setup functions.

 pass rate changes to the parent clock */

 nothing to do for gates or fixed dividers */

 SPDX-License-Identifier: GPL-2.0

/*

 * JZ4770 SoC CGU driver

 * Copyright 2018, Paul Cercueil <paul@crapouillou.net>

/*

 * CPM registers offset address definition

 bits within the OPCR register */

 UHC PHY suspend */

 bits within the USBPCR1 register */

 UHC PHY power down */

 External clocks */

 PLLs */

 TODO: PLL1 can depend on PLL0 */

 Main clocks */

 disable CCLK stop on idle

 Those divided clocks can connect to PLL0 or PLL1 */

 Those divided clocks can connect to EXT, PLL0 or PLL1 */

 Gate-only clocks */

 Custom clocks */

 We only probe via devicetree, no need for a platform driver */

 SPDX-License-Identifier: GPL-2.0

/*

 * X1830 SoC CGU driver

 * Copyright (c) 2019 周琰杰 (Zhou Yanjie) <zhouyanjie@wanyeetech.com>

 CGU register offsets */

 bits within the OPCR register */

 bits within the USBPCR register */

 External clocks */

 PLLs */

 Custom (SoC-specific) OTG PHY */

 Muxes & dividers */

 Gate-only clocks */

/*

 * CGU has some children devices, this is useful for probing children devices

 * in the case where the device node is compatible with "simple-mfd".

 SPDX-License-Identifier: GPL-2.0

/*

 * JZ47xx SoCs TCU clocks driver

 * Copyright (C) 2019 Paul Cercueil <paul@crapouillou.net>

 8 channels max + watchdog + OST */

	/*

	 * If the SoC has no global TCU clock, we must ungate the channel's

	 * clock to be able to access its registers.

	 * If we have a TCU clock, it will be enabled automatically as it has

	 * been attached to the regmap.

 /1024 divider */

 Reset channel and clock divider, set default parent */

 X1000 has OST, but it not belong TCU */

 sentinel */ }

	/*

	 * We set EXT as the default parent clock for all the TCU clocks

	 * except for the watchdog one, where we set the RTC clock as the

	 * parent. Since the EXT and PCLK are much faster than the RTC clock,

	 * the watchdog would kick after a maximum time of 5s, and we might

	 * want a slower kicking time.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2019 BayLibre, SAS.

 * Author: Jerome Brunet <jbrunet@baylibre.com>

 Get the hhi system controller node */

 Populate regmap for the regmap backed clocks */

 array might be sparse */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2018 BayLibre, SAS.

 * Author: Jerome Brunet <jbrunet@baylibre.com>

 Gives a hint that something is wrong */

 if read only, just return current value */

 Would prefer clk_regmap_div_ro_ops but clashes with qcom */

 SPDX-License-Identifier: GPL-2.0+

/*

 * Amlogic Meson-AXG Clock Controller Driver

 *

 * Copyright (c) 2016 Baylibre SAS.

 * Author: Michael Turquette <mturquette@baylibre.com>

 *

 * Copyright (c) 2019 Baylibre SAS.

 * Author: Neil Armstrong <narmstrong@baylibre.com>

/*

 * AO Configuration Clock registers offsets

 * Register offsets from the data sheet must be multiplied by 4.

/*

 * Like every other peripheral clock gate in Amlogic Clock drivers,

 * we are using CLK_IGNORE_UNUSED here, so we keep the state of the

 * bootloader. The goal is to remove this flag at some point.

 * Actually removing it will require some extensive test to be done safely.

 32k_by_oscin clock */

 cec clock */

 SPDX-License-Identifier: GPL-2.0+

/*

 * Amlogic Meson8 DDR clock controller

 *

 * Copyright (C) 2019 Martin Blumenstingl <martin.blumenstingl@googlemail.com>

 Populate regmap */

 Register all clks */

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0+

/*

 * Amlogic Meson-AXG Clock Controller Driver

 *

 * Copyright (c) 2016 BayLibre, SAS.

 * Author: Neil Armstrong <narmstrong@baylibre.com>

 *

 * Copyright (c) 2018 Amlogic, inc.

 * Author: Qiufang Dai <qiufang.dai@amlogic.com>

 * Author: Yixun Lan <yixun.lan@amlogic.com>

 Reset Controller */

 Populate regmap */

 Register all clks */

 SPDX-License-Identifier: (GPL-2.0 OR MIT)

/*

 * Copyright (c) 2018 BayLibre, SAS.

 * Author: Jerome Brunet <jbrunet@baylibre.com>

 Audio Master Clocks */

 Sample Clocks */

 TDM bit clock sources */

 TDM sample clock sources */

 Pad master clock sources */

 Pad bit clock sources */

 Pad sample clock sources */

 Common Clocks */

 AXG Clocks */

 AXG/G12A Clocks */

 Provide aud_top signal name on axg and g12a */

 G12a clocks */

 SM1 Clocks */

/*

 * Array of all clocks provided by this provider

 * The input clocks of the controller will be populated at runtime

/*

 * Array of all G12A clocks provided by this provider

 * The input clocks of the controller will be populated at runtime

/*

 * Array of all SM1 clocks provided by this provider

 * The input clocks of the controller will be populated at runtime

 Convenience table to populate regmap in .probe(). */

 Get the mandatory peripheral clock */

 Populate regmap for the regmap backed clocks */

 Take care to skip the registered input clocks */

 array might be sparse */

 Stop here if there is no reset */

 SPDX-License-Identifier: (GPL-2.0 OR MIT)

/*

 * Copyright (c) 2019 BayLibre, SAS.

 * Author: Neil Armstrong <narmstrong@baylibre.com>

 Write the SYS_CPU_DYN_ENABLE bit before changing the divider */

 Update the divider while removing the SYS_CPU_DYN_ENABLE bit */

 SPDX-License-Identifier: GPL-2.0+

/*

 * Amlogic Meson-AXG Clock Controller Driver

 *

 * Copyright (c) 2016 Baylibre SAS.

 * Author: Michael Turquette <mturquette@baylibre.com>

 *

 * Copyright (c) 2018 Amlogic, inc.

 * Author: Qiufang Dai <qiufang.dai@amlogic.com>

/*

 * AO Configuration Clock registers offsets

 * Register offsets from the data sheet must be multiplied by 4.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2018 BayLibre, SAS.

 * Author: Neil Armstrong <narmstrong@baylibre.com>

/*

 * This vid_pll divided is a fully programmable fractionnal divider to

 * achieve complex video clock rates.

 *

 * Here are provided the commonly used fraction values provided by Amlogic.

 2/1  => /2 */

 5/2  => /2.5 */

 3/1  => /3 */

 7/2  => /3.5 */

 15/4 => /3.75 */

 4/1  => /4 */

 5/1  => /5 */

 6/1  => /6 */

 25/4 => /6.25 */

 7/1  => /7 */

 15/2 => /7.5 */

 12/1 => /12 */

 14/1 => /14 */

 15/1 => /15 */

 SPDX-License-Identifier: GPL-2.0+

/*

 * AmLogic Meson-AXG Clock Controller Driver

 *

 * Copyright (c) 2016 Baylibre SAS.

 * Author: Michael Turquette <mturquette@baylibre.com>

 *

 * Copyright (c) 2017 Amlogic, inc.

 * Author: Qiufang Dai <qiufang.dai@amlogic.com>

		/*

		 * This clock won't ever change at runtime so

		 * CLK_SET_RATE_PARENT is not required

 sentinel */ },

		/*

		 * FIXME:

		 * This clock, as fdiv2, is used by the SCPI FW and is required

		 * by the platform to operate correctly.

		 * Until the following condition are met, we need this clock to

		 * be marked as critical:

		 * a) The SCPI generic driver claims and enable all the clocks

		 *    it needs

		 * b) CCF has a clock hand-off mechanism to make the sure the

		 *    clock stays on until the proper driver comes along

 sentinel */ },

 skip the parent mpll3, reserved for debug */

 skip the parent 0, reserved for debug */

	/*

	 * Following these parent clocks, we should also have had mpll2, mpll3

	 * and gp0_pll but these clocks are too precious to be used here. All

	 * the necessary rates for MMC and NAND operation can be acheived using

	 * xtal or fclk_div clocks

 SDcard clock */

 EMMC/NAND clock */

 VPU Clock */

 We need a specific parent for VPU clock source, let it be set in DT */

		/*

		 * We want to avoid CCF to disable the VPU clock if

		 * display has been set by Bootloader

 We need a specific parent for VPU clock source, let it be set in DT */

		/*

		 * We want to avoid CCF to disable the VPU clock if

		 * display has been set by Bootloader

 VAPB Clock */

 Video Clocks */

 MIPI DSI Host Clock */

		/*

		 * bits 15:12 selects from 14 possible parents:

		 * xtal, [rtc_oscin_i], [sys_cpu_div16], [ddr_dpll_pt],

		 * hifi_pll, mpll0, mpll1, mpll2, mpll3, fdiv4,

		 * fdiv3, fdiv5, [cts_msr_clk], fdiv7, gp0_pll

 Everything Else (EE) domain gates */

 Always On (AO) domain gates */

 Array of all clocks provided by this provider */

 Convenience table to populate regmap in .probe */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2015 Endless Mobile, Inc.

 * Author: Carlo Caione <carlo@endlessm.com>

 *

 * Copyright (c) 2016 BayLibre, Inc.

 * Michael Turquette <mturquette@baylibre.com>

 sentinel */ },

		/*

		 * This clock won't ever change at runtime so

		 * CLK_SET_RATE_PARENT is not required

/*

 * Taken from the vendor driver for the 2970/2975MHz (both only differ in the

 * FRAC part in HHI_VID_PLL_CNTL2) where these values are identical for Meson8,

 * Meson8b and Meson8m2. This doubles the input (or output - it's not clear

 * which one but the result is the same) clock. The vendor driver additionally

 * has the following comment about: "optimise HPLL VCO 2.97GHz performance".

 sentinel */ }

 sometimes also called "HPLL" or "HPLL PLL" */

		/*

		 * FIXME bits 14:12 selects from 8 possible parents:

		 * xtal, 1'b0 (wtf), fclk_div7, mpll_clkout1, mpll_clkout2,

		 * fclk_div4, fclk_div3, fclk_div5

 sentinel */ },

		/*

		 * NOTE: We are skipping the parent with value 0x2 (which is

		 * meson8b_cpu_in_div3) because it results in a duty cycle of

		 * 33% which makes the system unstable and can result in a

		 * lockup of the whole system.

 FIXME all other parents are unknown: */

 also called LVDS_CLK_EN */

		/*

		 * TODO: depending on the SoC there is also a second parent:

		 * Meson8: unknown

		 * Meson8b: hdmi_pll_dco

		 * Meson8m2: vid2_pll

 TODO: parent 0x2 is vid_pll_pre_div_mult7_div2 */

 FIXME: all other parents are unknown */

/*

 * The MALI IP is clocked by two identical clocks (mali_0 and mali_1)

 * muxed by a glitch-free switch on Meson8b and Meson8m2. The CCF can

 * actually manage this glitch-free mux because it does top-to-bottom

 * updates the each clock tree and switches to the "inactive" one when

 * CLK_SET_RATE_GATE is set.

 * Meson8 only has mali_0 and no glitch-free mux.

		/*

		 * Don't propagate rate changes up because the only changeable

		 * parents are mpll1 and mpll2 but we need those for audio and

		 * RGMII (Ethernet). We don't want to change the audio or

		 * Ethernet clocks when setting the GPU frequency.

		/*

		 * Don't propagate rate changes up because the only changeable

		 * parents are mpll1 and mpll2 but we need those for audio and

		 * RGMII (Ethernet). We don't want to change the audio or

		 * Ethernet clocks when setting the GPU frequency.

 sentinel */ },

			/*

			 * Note:

			 * meson8b and meson8m2 have different vpu_0_sels (with

			 * different struct clk_hw). We fallback to the global

			 * naming string mechanism so vpu_0_div picks up the

			 * appropriate one.

			/*

			 * Note:

			 * meson8b and meson8m2 have different vpu_1_sels (with

			 * different struct clk_hw). We fallback to the global

			 * naming string mechanism so vpu_1_div picks up the

			 * appropriate one.

/*

 * The VPU clock has two two identical clock trees (vpu_0 and vpu_1)

 * muxed by a glitch-free switch on Meson8b and Meson8m2. The CCF can

 * actually manage this glitch-free mux because it does top-to-bottom

 * updates the each clock tree and switches to the "inactive" one when

 * CLK_SET_RATE_GATE is set.

 * Meson8 only has vpu_0 and no glitch-free mux.

 TODO: The second parent is currently unknown */

 TODO: the clock at index 0 is "DDR_PLL" which we don't support yet */

 TODO: the clock at index 0 is "DDR_PLL" which we don't support yet */

		/*

		 * The parent is specific to origin of the audio data. Let the

		 * consumer choose the appropriate parent.

 Everything Else (EE) domain gates */

 AIU gates */

 Always On (AO) domain gates */

 xtal */

 cpu_scale_out_sel */

 Reset Controller */

 Populate regmap for the regmap backed clocks */

	/*

	 * register all clks and start with the first used ID (which is

	 * CLKID_PLL_FIXED)

 array might be sparse */

	/*

	 * FIXME we shouldn't program the muxes in notifier handlers. The

	 * tricky programming sequence will be handled by the forthcoming

	 * coordinated clock rates mechanism once that feature is released.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2015 Endless Mobile, Inc.

 * Author: Carlo Caione <carlo@endlessm.com>

 *

 * Copyright (c) 2018 Baylibre, SAS.

 * Author: Jerome Brunet <jbrunet@baylibre.com>

/*

 * In the most basic form, a Meson PLL is composed as follows:

 *

 *                     PLL

 *        +--------------------------------+

 *        |                                |

 *        |             +--+               |

 *  in >>-----[ /N ]--->|  |      +-----+  |

 *        |             |  |------| DCO |---->> out

 *        |  +--------->|  |      +--v--+  |

 *        |  |          +--+         |     |

 *        |  |                       |     |

 *        |  +--[ *(M + (F/Fmax) ]<--+     |

 *        |                                |

 *        +--------------------------------+

 *

 * out = in * (m + frac / frac_max) / n

	/*

	 * On some HW, N is set to zero on init. This value is invalid as

	 * it would result in a division by zero. The rate can't be

	 * calculated in this case

 Bail out if we are already over the requested rate */

 Round Closest */

 Round down */

 Check the predivider range */

 Get the boundaries out the way */

 the pre-divider gives a multiplier too big - stop */

	/*

	 * The rate provided by the setting is not an exact match, let's

	 * try to improve the result using the fractional parameter

 Is the clock locked now ? */

 do nothing if the PLL is already enabled */

 Make sure the pll is in reset */

 Enable the pll */

 Take the pll out reset */

 Put the pll is in reset */

 Disable the pll */

 If the pll is stopped, bail out now */

		/*

		 * FIXME: Do we really need/want this HACK ?

		 * It looks unsafe. what happens if the clock gets into a

		 * broken state and we can't lock back on the old_rate ? Looks

		 * like an infinite recursion is possible

/*

 * The Meson G12A PCIE PLL is fined tuned to deliver a very precise

 * 100MHz reference clock for the PCIe Analog PHY, and thus requires

 * a strict register sequence to enable the PLL.

 * To simplify, re-use the _init() op to enable the PLL and keep

 * the other ops except set_rate since the rate is fixed.

 SPDX-License-Identifier: (GPL-2.0 OR MIT)

/*

 * Copyright (c) 2018 BayLibre, SAS.

 * Author: Jerome Brunet <jbrunet@baylibre.com>

 *

 * Sample clock generator divider:

 * This HW divider gates with value 0 but is otherwise a zero based divider:

 *

 * val >= 1

 * divider = val + 1

 *

 * The duty cycle may also be set for the LR clock variant. The duty cycle

 * ratio is:

 *

 * hi = [0 - val]

 * duty_cycle = (1 + hi) / (1 + val)

	/*

	 * The maximum divider we can use without overflowing

	 * unsigned long in rate * i below

		/*

		 * It's the most ideal case if the requested rate can be

		 * divided from parent clock without needing to change

		 * parent rate, so return the divider immediately.

 if the divider is initially disabled, assume max */

 SPDX-License-Identifier: GPL-2.0+

/*

 * Amlogic Meson-G12A Clock Controller Driver

 *

 * Copyright (c) 2016 Baylibre SAS.

 * Author: Michael Turquette <mturquette@baylibre.com>

 *

 * Copyright (c) 2018 Amlogic, inc.

 * Author: Qiufang Dai <qiufang.dai@amlogic.com>

 * Author: Jian Hu <jian.hu@amlogic.com>

		/*

		 * This clock won't ever change at runtime so

		 * CLK_SET_RATE_PARENT is not required

 This clock feeds the CPU, avoid disabling it */

 This clock feeds the CPU, avoid disabling it */

		/*

		 * This clock is used to debug the sys_pll range

		 * Linux should not change it at runtime

		/*

		 * This clock is used to debug the sys_pll range

		 * Linux should not change it at runtime

		/*

		 * Similar to fclk_div3, it seems that this clock is used by

		 * the resident firmware and is required by the platform to

		 * operate correctly.

		 * Until the following condition are met, we need this clock to

		 * be marked as critical:

		 * a) Mark the clock used by a firmware resource, if possible

		 * b) CCF has a clock hand-off mechanism to make the sure the

		 *    clock stays on until the proper driver comes along

		/*

		 * This clock is used by the resident firmware and is required

		 * by the platform to operate correctly.

		 * Until the following condition are met, we need this clock to

		 * be marked as critical:

		 * a) Mark the clock used by a firmware resource, if possible

		 * b) CCF has a clock hand-off mechanism to make the sure the

		 *    clock stays on until the proper driver comes along

 Datasheet names this field as "premux0" */

 Datasheet names this field as "premux1" */

 This sub-tree is used a parking clock */

 Datasheet names this field as "mux0_divn_tcnt" */

 Datasheet names this field as "postmux0" */

 Datasheet names this field as "Mux1_divn_tcnt" */

 Datasheet names this field as "postmux1" */

 This sub-tree is used a parking clock */

 Datasheet names this field as "Final_dyn_mux_sel" */

 Datasheet names this field as "Final_mux_sel" */

 Datasheet names this field as "Final_mux_sel" */

 Datasheet names this field as "premux0" */

 Datasheet names this field as "mux0_divn_tcnt" */

 Datasheet names this field as "postmux0" */

 Datasheet names this field as "premux1" */

 This sub-tree is used a parking clock */

 Datasheet names this field as "Mux1_divn_tcnt" */

 Datasheet names this field as "postmux1" */

 This sub-tree is used a parking clock */

 Datasheet names this field as "Final_dyn_mux_sel" */

 Datasheet names this field as "Final_mux_sel" */

 Datasheet names this field as "premux0" */

 Datasheet names this field as "premux1" */

 Datasheet names this field as "Mux0_divn_tcnt" */

 Datasheet names this field as "postmux0" */

 Datasheet names this field as "Mux1_divn_tcnt" */

 Datasheet names this field as "postmux1" */

 Datasheet names this field as "Final_dyn_mux_sel" */

 Datasheet names this field as "Final_mux_sel" */

 Datasheet names this field as "Cpu_clk_sync_mux_sel" bit 0 */

 This CPU also have a dedicated clock tree */

 Datasheet names this field as "Cpu_clk_sync_mux_sel" bit 1 */

 This CPU also have a dedicated clock tree */

 Datasheet names this field as "Cpu_clk_sync_mux_sel" bit 2 */

 This CPU also have a dedicated clock tree */

 Datasheet names this field as "Cpu_clk_sync_mux_sel" bit 4 */

 Wait for clock propagation before/after changing the mux */

		/*

		 * This notifier means cpu_clk_postmux0 clock will be changed

		 * to feed cpu_clk, this is the current path :

		 * cpu_clk

		 *    \- cpu_clk_dyn

		 *          \- cpu_clk_postmux0

		 *                \- cpu_clk_muxX_div

		 *                      \- cpu_clk_premux0

		 *				\- fclk_div3 or fclk_div2

		 *		OR

		 *                \- cpu_clk_premux0

		 *			\- fclk_div3 or fclk_div2

 Setup cpu_clk_premux1 to xtal */

 Setup cpu_clk_postmux1 to bypass divider */

 Switch to parking clk on cpu_clk_postmux1 */

		/*

		 * Now, cpu_clk is 24MHz in the current path :

		 * cpu_clk

		 *    \- cpu_clk_dyn

		 *          \- cpu_clk_postmux1

		 *                \- cpu_clk_premux1

		 *                      \- xtal

		/*

		 * The cpu_clk_postmux0 has ben updated, now switch back

		 * cpu_clk_dyn to cpu_clk_postmux0 and take the changes

		 * in account.

 Configure cpu_clk_dyn back to cpu_clk_postmux0 */

		/*

		 * new path :

		 * cpu_clk

		 *    \- cpu_clk_dyn

		 *          \- cpu_clk_postmux0

		 *                \- cpu_clk_muxX_div

		 *                      \- cpu_clk_premux0

		 *				\- fclk_div3 or fclk_div2

		 *		OR

		 *                \- cpu_clk_premux0

		 *			\- fclk_div3 or fclk_div2

		/*

		 * This notifier means sys_pll clock will be changed

		 * to feed cpu_clk, this the current path :

		 * cpu_clk

		 *    \- sys_pll

		 *          \- sys_pll_dco

 Configure cpu_clk to use cpu_clk_dyn */

		/*

		 * Now, cpu_clk uses the dyn path

		 * cpu_clk

		 *    \- cpu_clk_dyn

		 *          \- cpu_clk_dynX

		 *                \- cpu_clk_dynX_sel

		 *		     \- cpu_clk_dynX_div

		 *                      \- xtal/fclk_div2/fclk_div3

		 *                   \- xtal/fclk_div2/fclk_div3

		/*

		 * The sys_pll has ben updated, now switch back cpu_clk to

		 * sys_pll

 Configure cpu_clk to use sys_pll */

		/* new path :

		 * cpu_clk

		 *    \- sys_pll

		 *          \- sys_pll_dco

 G12B first CPU cluster uses sys1_pll */

 G12B second CPU cluster uses sys_pll */

		/*

		 * This clock is used to debug the cpu_clk range

		 * Linux should not change it at runtime

		/*

		 * This clock is used to debug the cpu_clk range

		 * Linux should not change it at runtime

		/*

		 * This clock is set by the ROM monitor code,

		 * Linux should not change it at runtime

		/*

		 * This clock is set by the ROM monitor code,

		 * Linux should not change it at runtime

		/*

		 * This clock is set by the ROM monitor code,

		 * Linux should not change it at runtime

			/*

			 * Note:

			 * G12A and G12B have different cpu_clks (with

			 * different struct clk_hw). We fallback to the global

			 * naming string mechanism so cpu_clk_trace_div picks

			 * up the appropriate one.

		/*

		 * This clock is set by the ROM monitor code,

		 * Linux should not change it at runtime

		/*

		 * This clock is set by the ROM monitor code,

		 * Linux should not change it at runtime

		/*

		 * This clock is set by the ROM monitor code,

		 * Linux should not change it at runtime

		/*

		 * This clock is set by the ROM monitor code,

		 * Linux should not change it at runtime

		/*

		 * This clock is set by the ROM monitor code,

		 * Linux should not change it at runtime

/*

 * Internal gp0 pll emulation configuration parameters

 This clock feeds the DSU, avoid disabling it */

/*

 * Internal hifi pll emulation configuration parameters

/*

 * The Meson G12A PCIE PLL is fined tuned to deliver a very precise

 * 100MHz reference clock for the PCIe Analog PHY, and thus requires

 * a strict register sequence to enable the PLL.

 Keep a single entry table for recalc/round_rate() ops */

		/*

		 * Display directly handle hdmi pll registers ATM, we need

		 * NOCACHE to keep our view of the clock as accurate as possible

	/*

	 * Following these parent clocks, we should also have had mpll2, mpll3

	 * and gp0_pll but these clocks are too precious to be used here. All

	 * the necessary rates for MMC and NAND operation can be acheived using

	 * g12a_ee_core or fclk_div clocks

 SDIO clock */

 SDcard clock */

 EMMC/NAND clock */

 Video Clocks */

		/*

		 * bit 18 selects from 2 possible parents:

		 * vid_pll_div or hdmi_pll

 VPU Clock */

		/*

		 * bit 31 selects from 2 possible parents:

		 * vpu_0 or vpu_1

 VDEC clocks */

 VAPB Clock */

		/*

		 * bit 31 selects from 2 possible parents:

		 * vapb_0 or vapb_1

 TOFIX: add support for cts_tcon */

 MIPI DSI Host Clocks */

 HDMI Clocks */

/*

 * The MALI IP is clocked by two identical clocks (mali_0 and mali_1)

 * muxed by a glitch-free switch. The CCF can manage this glitch-free

 * mux because it does top-to-bottom updates the each clock tree and

 * switches to the "inactive" one when CLK_SET_RATE_GATE is set.

		/*

		 * Don't request the parent to change the rate because

		 * all GPU frequencies can be derived from the fclk_*

		 * clocks and one special GP0_PLL setting. This is

		 * important because we need the MPLL clocks for audio.

		/*

		 * Don't request the parent to change the rate because

		 * all GPU frequencies can be derived from the fclk_*

		 * clocks and one special GP0_PLL setting. This is

		 * important because we need the MPLL clocks for audio.

 SPICC SCLK source clock */

 Neural Network Accelerator source clock */

 Everything Else (EE) domain gates */

 Array of all clocks provided by this provider */

 Convenience table to populate regmap in .probe */

 Setup clock notifier for cpu_clk_postmux0 */

 Setup clock notifier for cpu_clk_dyn mux */

 Setup clock notifier for cpu_clk mux */

 Setup clock notifier for sys1_pll */

 Add notifiers for the second CPU cluster */

 Setup clock notifier for cpub_clk_postmux0 */

 Setup clock notifier for cpub_clk_dyn mux */

 Setup clock notifier for cpub_clk mux */

 Setup clock notifier for sys_pll */

 Setup clock notifier for cpu_clk mux */

 Setup clock notifier for sys_pll */

 SPDX-License-Identifier: (GPL-2.0 OR MIT)

/*

 * Copyright (c) 2018 BayLibre, SAS.

 * Author: Jerome Brunet <jbrunet@baylibre.com>

	/*

	 * This last calculation is here for cases when degrees is rounded

	 * to 360, in which case val == (1 << width).

/*

 * This is a special clock for the audio controller.

 * The phase of mst_sclk clock output can be controlled independently

 * for the outside world (ph0), the tdmout (ph1) and tdmin (ph2).

 * Controlling these 3 phases as just one makes things simpler and

 * give the same clock view to all the element on the i2s bus.

 * If necessary, we can still control the phase in the tdm block

 * which makes these independent control redundant.

 Get phase 0 and sync it to phase 1 and 2 */

 Phase are in sync, reading phase 0 is enough */

/*

 * This is a special clock for the audio controller.

 * This drive a bit clock inverter for which the

 * opposite value of the inverter bit needs to be manually

 * set into another bit

 Get phase and sync the inverted value to ws */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2016 AmLogic, Inc.

 * Michael Turquette <mturquette@baylibre.com>

 sentinel */ },

 sentinel */ },

		/*

		 * This clock won't ever change at runtime so

		 * CLK_SET_RATE_PARENT is not required

		/*

		 * Display directly handle hdmi pll registers ATM, we need

		 * NOCACHE to keep our view of the clock as accurate as possible

		/*

		 * On gxl, there is a register shift due to

		 * HHI_HDMI_PLL_CNTL1 which does not exist on gxbb,

		 * so we use the HHI_HDMI_PLL_CNTL2 define from GXBB

		 * instead which is defined at the same offset.

		/*

		 * Display directly handle hdmi pll registers ATM, we need

		 * NOCACHE to keep our view of the clock as accurate as possible

			/*

			 * Note:

			 * GXL and GXBB have different gp0_pll_dco (with

			 * different struct clk_hw). We fallback to the global

			 * naming string mechanism so gp0_pll picks up the

			 * appropriate one.

		/*

		 * FIXME:

		 * This clock, as fdiv2, is used by the SCPI FW and is required

		 * by the platform to operate correctly.

		 * Until the following condition are met, we need this clock to

		 * be marked as critical:

		 * a) The SCPI generic driver claims and enable all the clocks

		 *    it needs

		 * b) CCF has a clock hand-off mechanism to make the sure the

		 *    clock stays on until the proper driver comes along

		/*

		 * bits 14:12 selects from 8 possible parents:

		 * xtal, 1'b0 (wtf), fclk_div7, mpll_clkout1, mpll_clkout2,

		 * fclk_div4, fclk_div3, fclk_div5

 the mother of dragons gates */

 NOTE: The datasheet doesn't list the parents for bit 10 */

/*

 * The MALI IP is clocked by two identical clocks (mali_0 and mali_1)

 * muxed by a glitch-free switch. The CCF can manage this glitch-free

 * mux because it does top-to-bottom updates the each clock tree and

 * switches to the "inactive" one when CLK_SET_RATE_GATE is set.

		/*

		 * Don't request the parent to change the rate because

		 * all GPU frequencies can be derived from the fclk_*

		 * clocks and one special GP0_PLL setting. This is

		 * important because we need the MPLL clocks for audio.

		/*

		 * Don't request the parent to change the rate because

		 * all GPU frequencies can be derived from the fclk_*

		 * clocks and one special GP0_PLL setting. This is

		 * important because we need the MPLL clocks for audio.

		/*

		 *The parent is specific to origin of the audio data. Let the

		 * consumer choose the appropriate parent

	/*

	 * FIXME: This clock is provided by the ao clock controller but the

	 * clock is not yet part of the binding of this controller, so string

	 * name must be use to set this parent.

	/*

	 * Following these parent clocks, we should also have had mpll2, mpll3

	 * and gp0_pll but these clocks are too precious to be used here. All

	 * the necessary rates for MMC and NAND operation can be acheived using

	 * xtal or fclk_div clocks

 SDIO clock */

 SDcard clock */

 EMMC/NAND clock */

 VPU Clock */

		/*

		 * bits 9:10 selects from 4 possible parents:

		 * fclk_div4, fclk_div3, fclk_div5, fclk_div7,

		/*

		 * bits 25:26 selects from 4 possible parents:

		 * fclk_div4, fclk_div3, fclk_div5, fclk_div7,

		/*

		 * bit 31 selects from 2 possible parents:

		 * vpu_0 or vpu_1

 VAPB Clock */

		/*

		 * bits 9:10 selects from 4 possible parents:

		 * fclk_div4, fclk_div3, fclk_div5, fclk_div7,

		/*

		 * bits 25:26 selects from 4 possible parents:

		 * fclk_div4, fclk_div3, fclk_div5, fclk_div7,

		/*

		 * bit 31 selects from 2 possible parents:

		 * vapb_0 or vapb_1

 Video Clocks */

			/*

			 * Note:

			 * GXL and GXBB have different hdmi_plls (with

			 * different struct clk_hw). We fallback to the global

			 * naming string mechanism so vid_pll_div picks up the

			 * appropriate one.

	/*

	 * Note:

	 * GXL and GXBB have different hdmi_plls (with

	 * different struct clk_hw). We fallback to the global

	 * naming string mechanism so vid_pll_div picks up the

	 * appropriate one.

		/*

		 * bit 18 selects from 2 possible parents:

		 * vid_pll_div or hdmi_pll

		/*

		 * bits 16:18 selects from 8 possible parents:

		 * vid_pll, fclk_div4, fclk_div3, fclk_div5,

		 * vid_pll, fclk_div7, mp1

		/*

		 * bits 16:18 selects from 8 possible parents:

		 * vid_pll, fclk_div4, fclk_div3, fclk_div5,

		 * vid_pll, fclk_div7, mp1

 TOFIX: add support for cts_tcon */

		/*

		 * bits 31:28 selects from 12 possible parents:

		 * vclk_div1, vclk_div2, vclk_div4, vclk_div6, vclk_div12

		 * vclk2_div1, vclk2_div2, vclk2_div4, vclk2_div6, vclk2_div12,

		 * cts_tcon

 HDMI Clocks */

 VDEC clocks */

		/*

		 * bits 15:12 selects from 14 possible parents:

		 * xtal, [rtc_oscin_i], [sys_cpu_div16], [ddr_dpll_pt],

		 * vid_pll, vid2_pll (hevc), mpll0, mpll1, mpll2, fdiv4,

		 * fdiv3, fdiv5, [cts_msr_clk], fdiv7, gp0_pll

 Everything Else (EE) domain gates */

 Always On (AO) domain gates */

 AIU gates */

 Array of all clocks provided by this provider */

 SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)

/*

 * Copyright (c) 2016 AmLogic, Inc.

 * Author: Michael Turquette <mturquette@baylibre.com>

/*

 * MultiPhase Locked Loops are outputs from a PLL with additional frequency

 * scaling capabilities. MPLL rates are calculated as:

 *

 * f(N2_integer, SDM_IN ) = 2.0G/(N2_integer + SDM_IN/16384)

 Set the fractional part */

 Set the integer divider part */

 Enable the fractional part */

 Set spread spectrum if possible */

 Set the magic misc bit if required */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2017 BayLibre, SAS

 * Author: Neil Armstrong <narmstrong@baylibre.com>

 * Author: Jerome Brunet <jbrunet@baylibre.com>

/*

 * The AO Domain embeds a dual/divider to generate a more precise

 * 32,768KHz clock for low-power suspend mode and CEC.

 *     ______   ______

 *    |      | |      |

 *    | Div1 |-| Cnt1 |

 *   /|______| |______|\

 * -|  ______   ______  X--> Out

 *   \|      | |      |/

 *    | Div2 |-| Cnt2 |

 *    |______| |______|

 *

 * The dividing can be switched to single or dual, with a counter

 * for each divider to set when the switching is done.

 If we get an exact match, don't bother any further */

 SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)

/*

 * Copyright (c) 2016 BayLibre, SAS.

 * Author: Neil Armstrong <narmstrong@baylibre.com>

 AO Configuration Clock registers offsets */

		/*

		 * FIXME: The 'fixme' parent obviously does not exist.

		 *

		 * ATM, CCF won't call get_parent() if num_parents is 1. It

		 * does not allow NULL as a parent name either.

		 *

		 * On this particular mux, we only know the input #1 parent

		 * but, on boot, unknown input #0 is set, so it is critical

		 * to call .get_parent() on it

		 *

		 * Until CCF gets fixed, adding this fake parent that won't

		 * ever be registered should work around the problem

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2018-2019 SiFive, Inc.

 * Wesley Terpstra

 * Paul Walmsley

 *

 * This library supports configuration parsing and reprogramming of

 * the CLN28HPC variant of the Analog Bits Wide Range PLL.  The

 * intention is for this library to be reusable for any device that

 * integrates this PLL; thus the register structure and programming

 * details are expected to be provided by a separate IP block driver.

 *

 * The bulk of this code is primarily useful for clock configurations

 * that must operate at arbitrary rates, as opposed to clock configurations

 * that are restricted by software or manufacturer guidance to a small,

 * pre-determined set of performance points.

 *

 * References:

 * - Analog Bits "Wide Range PLL Datasheet", version 2015.10.01

 * - SiFive FU540-C000 Manual v1p0, Chapter 7 "Clocking and Reset"

 *   https://static.dev.sifive.com/FU540-C000-v1.0.pdf

 MIN_INPUT_FREQ: minimum input clock frequency, in Hz (Fref_min) */

 MAX_INPUT_FREQ: maximum input clock frequency, in Hz (Fref_max) */

 MIN_POST_DIVIDE_REF_FREQ: minimum post-divider reference frequency, in Hz */

 MAX_POST_DIVIDE_REF_FREQ: maximum post-divider reference frequency, in Hz */

 MIN_VCO_FREQ: minimum VCO frequency, in Hz (Fvco_min) */

 MAX_VCO_FREQ: maximum VCO frequency, in Hz (Fvco_max) */

 MAX_DIVQ_DIVISOR: maximum output divisor.  Selected by DIVQ = 6 */

 MAX_DIVR_DIVISOR: maximum reference divisor.  Selected by DIVR = 63 */

 MAX_LOCK_US: maximum PLL lock time, in microseconds (tLOCK_max) */

/*

 * ROUND_SHIFT: number of bits to shift to avoid precision loss in the rounding

 *              algorithm

/*

 * Private functions

/**

 * __wrpll_calc_filter_range() - determine PLL loop filter bandwidth

 * @post_divr_freq: input clock rate after the R divider

 *

 * Select the value to be presented to the PLL RANGE input signals, based

 * on the input clock frequency after the post-R-divider @post_divr_freq.

 * This code follows the recommendations in the PLL datasheet for filter

 * range selection.

 *

 * Return: The RANGE value to be presented to the PLL configuration inputs,

 *         or a negative return code upon error.

/**

 * __wrpll_calc_fbdiv() - return feedback fixed divide value

 * @c: ptr to a struct wrpll_cfg record to read from

 *

 * The internal feedback path includes a fixed by-two divider; the

 * external feedback path does not.  Return the appropriate divider

 * value (2 or 1) depending on whether internal or external feedback

 * is enabled.  This code doesn't test for invalid configurations

 * (e.g. both or neither of WRPLL_FLAGS_*_FEEDBACK are set); it relies

 * on the caller to do so.

 *

 * Context: Any context.  Caller must protect the memory pointed to by

 *          @c from simultaneous modification.

 *

 * Return: 2 if internal feedback is enabled or 1 if external feedback

 *         is enabled.

/**

 * __wrpll_calc_divq() - determine DIVQ based on target PLL output clock rate

 * @target_rate: target PLL output clock rate

 * @vco_rate: pointer to a u64 to store the computed VCO rate into

 *

 * Determine a reasonable value for the PLL Q post-divider, based on the

 * target output rate @target_rate for the PLL.  Along with returning the

 * computed Q divider value as the return value, this function stores the

 * desired target VCO rate into the variable pointed to by @vco_rate.

 *

 * Context: Any context.  Caller must protect the memory pointed to by

 *          @vco_rate from simultaneous access or modification.

 *

 * Return: a positive integer DIVQ value to be programmed into the hardware

 *         upon success, or 0 upon error (since 0 is an invalid DIVQ value)

/**

 * __wrpll_update_parent_rate() - update PLL data when parent rate changes

 * @c: ptr to a struct wrpll_cfg record to write PLL data to

 * @parent_rate: PLL input refclk rate (pre-R-divider)

 *

 * Pre-compute some data used by the PLL configuration algorithm when

 * the PLL's reference clock rate changes.  The intention is to avoid

 * computation when the parent rate remains constant - expected to be

 * the common case.

 *

 * Returns: 0 upon success or -ERANGE if the reference clock rate is

 * out of range.

/**

 * wrpll_configure_for_rate() - compute PLL configuration for a target rate

 * @c: ptr to a struct wrpll_cfg record to write into

 * @target_rate: target PLL output clock rate (post-Q-divider)

 * @parent_rate: PLL input refclk rate (pre-R-divider)

 *

 * Compute the appropriate PLL signal configuration values and store

 * in PLL context @c.  PLL reprogramming is not glitchless, so the

 * caller should switch any downstream logic to a different clock

 * source or clock-gate it before presenting these values to the PLL

 * configuration signals.

 *

 * The caller must pass this function a pre-initialized struct

 * wrpll_cfg record: either initialized to zero (with the

 * exception of the .name and .flags fields) or read from the PLL.

 *

 * Context: Any context.  Caller must protect the memory pointed to by @c

 *          from simultaneous access or modification.

 *

 * Return: 0 upon success; anything else upon failure.

 Initialize rounding data if it hasn't been initialized already */

 Put the PLL into bypass if the user requests the parent clock rate */

 Calculate the Q shift and target VCO rate */

 Precalculate the pre-Q divider target ratio */

	/*

	 * Consider all values for R which land within

	 * [MIN_POST_DIVR_FREQ, MAX_POST_DIVR_FREQ]; prefer smaller R

 Ensure rounding didn't take us out of range */

 Pick the best PLL jitter filter */

/**

 * wrpll_calc_output_rate() - calculate the PLL's target output rate

 * @c: ptr to a struct wrpll_cfg record to read from

 * @parent_rate: PLL refclk rate

 *

 * Given a pointer to the PLL's current input configuration @c and the

 * PLL's input reference clock rate @parent_rate (before the R

 * pre-divider), calculate the PLL's output clock rate (after the Q

 * post-divider).

 *

 * Context: Any context.  Caller must protect the memory pointed to by @c

 *          from simultaneous modification.

 *

 * Return: the PLL's output clock rate, in Hz.  The return value from

 *         this function is intended to be convenient to pass directly

 *         to the Linux clock framework; thus there is no explicit

 *         error return value.

/**

 * wrpll_calc_max_lock_us() - return the time for the PLL to lock

 * @c: ptr to a struct wrpll_cfg record to read from

 *

 * Return the minimum amount of time (in microseconds) that the caller

 * must wait after reprogramming the PLL to ensure that it is locked

 * to the input frequency and stable.  This is likely to depend on the DIVR

 * value; this is under discussion with the manufacturer.

 *

 * Return: the minimum amount of time the caller must wait for the PLL

 *         to lock (in microseconds)

 SPDX-License-Identifier: GPL-2.0

/*

 * Xilinx VCU Init

 *

 * Copyright (C) 2016 - 2017 Xilinx, Inc.

 *

 * Contacts   Dhaval Shah <dshah@xilinx.com>

/**

 * struct xvcu_device - Xilinx VCU init device structure

 * @dev: Platform device

 * @pll_ref: pll ref clock source

 * @aclk: axi clock source

 * @logicore_reg_ba: logicore reg base address

 * @vcu_slcr_ba: vcu_slcr Register base address

 * @pll: handle for the VCU PLL

 * @pll_post: handle for the VCU PLL post divider

 * @clk_data: clocks provided by the vcu clock provider

/**

 * struct xvcu_pll_cfg - Helper data

 * @fbdiv: The integer portion of the feedback divider to the PLL

 * @cp: PLL charge pump control

 * @res: PLL loop filter resistor control

 * @lfhf: PLL loop filter high frequency capacitor control

 * @lock_dly: Lock circuit configuration settings for lock windowsize

 * @lock_cnt: Lock circuit counter setting

/**

 * xvcu_read - Read from the VCU register space

 * @iomem:	vcu reg space base address

 * @offset:	vcu reg offset from base

 *

 * Return:	Returns 32bit value from VCU register specified

 *

/**

 * xvcu_write - Write to the VCU register space

 * @iomem:	vcu reg space base address

 * @offset:	vcu reg offset from base

 * @value:	Value to write

	/*

	 * The output divider of the PLL must be set to 1/2 to meet the

	 * timing in the design.

 Protect register shared by clocks */

/**

 * xvcu_probe - Probe existence of the logicoreIP

 *			and initialize PLL

 *

 * @pdev:	Pointer to the platform_device structure

 *

 * Return:	Returns 0 on success

 *		Negative error code otherwise

	/*

	 * Do the Gasket isolation and put the VCU out of reset

	 * Bit 0 : Gasket isolation

	 * Bit 1 : put VCU out of reset

/**

 * xvcu_remove - Insert gasket isolation

 *			and disable the clock

 * @pdev:	Pointer to the platform_device structure

 *

 * Return:	Returns 0 on success

 *		Negative error code otherwise

 Add the Gasket isolation and put the VCU in reset. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Marvell PXA25x family clocks

 *

 * Copyright (C) 2014 Robert Jarzmik

 *

 * Heavily inspired from former arch/arm/mach-pxa/pxa25x.c.

 *

 * For non-devicetree platforms. Once pxa is fully converted to devicetree, this

 * should go away.

 Define the refresh period in mSec for the SDRAM and the number of rows */

 standard 64ms SDRAM */

/*

 * Various clock factors driven by the CCCR register.

 Crystal Frequency to Memory Frequency Multiplier (L) */

 Memory Frequency to Run Mode Frequency Multiplier (M) */

 Run Mode Frequency to Turbo Mode Frequency Multiplier (N) */

 Note: we store the value N * 2 here. */

/*

 * Get the clock frequency as reflected by CCCR and the turbo flag.

 * We assume these values have been applied via a fcs.

 * If info is not 0 we also display the current settings.

/*

 * In this table, PXA25x_CCCR(N2, M, L) has the following meaning, where :

 *   - freq_cpll = n * m * L * 3.6864 MHz

 *   - n = N2 / 2

 *   - m = 2^(M - 1), where 1 <= M <= 3

 *   - l = L_clk_mult[L], ie. { 0, 27, 32, 36, 40, 45, 0, }[L]

 CPU  MEMBUS  CCCR                  DIV2 CCLKCFG      */

	/*

	 * All pinctrl logic has been wiped out of the clock driver, especially

	 * for gpio11 and gpio12 outputs. Machine code should ensure proper pin

	 * control (ie. pxa2xx_mfp_config() invocation).

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Marvell PXA3xxx family clocks

 *

 * Copyright (C) 2014 Robert Jarzmik

 *

 * Heavily inspired from former arch/arm/mach-pxa/pxa3xx.c

 *

 * For non-devicetree platforms. Once pxa is fully converted to devicetree, this

 * should go away.

 crystal frequency to HSIO bus frequency multiplier (HSS) */

 crystal frequency to static memory controller multiplier (SMCFS) */

/*

 * Get the clock frequency as reflected by ACSR and the turbo flag.

 * We assume these values have been applied via a fcs.

 * If info is not 0 we also display the current settings.

	/* This may loose precision for some rates but won't for the

	 * standard 24.576MHz.

 Read XCLKCFG register turbo bit */

 Read XCLKCFG register turbo bit */

 Read XCLKCFG register turbo bit */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Marvell PXA family clocks

 *

 * Copyright (C) 2014 Robert Jarzmik

 *

 * Common clock code for PXA clocks ("CKEN" type clocks + DT)

 SDCLK0 Divide by 4 Control/Status */

 SDRAM Free-Running Control */

 SDRAM Free-Running Control */

 SDRAM Free-Running Control */

 SDRAM Self-Refresh Control/Status */

 SDRAM/SSRAM Auto-Power-Down Enable */

 SDCLK2 Divide by 2 Control/Status */

 SDCLK2 Run Control/Status */

 SDCLK1 Divide by 2 Control/Status */

 SDCLK1 Run Control/Status */

 SDCKE1 Level Control/Status */

 SDCLK0 Divide by 2 Control/Status */

 SDCLK0 Run Control/Status */

 SDCKE0 Level Control/Status */

	/* Calculate the next MDREFR.  If we're slowing down the SDRAM clock

	 * we need to preset the smaller DRI before the change.	 If we're

	 * speeding up we need to set the larger DRI value after the change.

	/* If we're dividing the memory clock by two for the SDRAM clock, this

	 * must be set prior to the change.  Clearing the divide must be done

	 * after the change.

 Set new the CCCR and prepare CLKCFG */

 preset the MDREFR */\n"

 set CLKCFG[FCS] */\n"

 postset the MDREFR */\n"

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Marvell PXA27x family clocks

 *

 * Copyright (C) 2014 Robert Jarzmik

 *

 * Heavily inspired from former arch/arm/mach-pxa/clock.c.

 Define the refresh period in mSec for the SDRAM and the number of rows */

 standard 64ms SDRAM */

/*

 * Get the clock frequency as reflected by CCSR and the turbo flag.

 * We assume these values have been applied via a fcs.

 * If info is not 0 we also display the current settings.

/*

 * PXA270 definitions

 *

 * For the PXA27x:

 * Control variables are A, L, 2N for CCCR; B, HT, T for CLKCFG.

 *

 * A = 0 => memory controller clock from table 3-7,

 * A = 1 => memory controller clock = system bus clock

 * Run mode frequency	= 13 MHz * L

 * Turbo mode frequency = 13 MHz * L * N

 * System bus frequency = 13 MHz * L / (B + 1)

 *

 * In CCCR:

 * A = 1

 * L = 16	  oscillator to run mode ratio

 * 2N = 6	  2 * (turbo mode to run mode ratio)

 *

 * In CCLKCFG:

 * B = 1	  Fast bus mode

 * HT = 0	  Half-Turbo mode

 * T = 1	  Turbo mode

 *

 * For now, just support some of the combinations in table 3-7 of

 * PXA27x Processor Family Developer's Manual to simplify frequency

 * change sequences.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2013 Samsung Electronics Co., Ltd.

 * Copyright (c) 2013 Linaro Ltd.

 * Author: Thomas Abraham <thomas.ab@samsung.com>

 *

 * Common Clock Framework support for Exynos5250 SoC.

Below definitions are used for PWR_CTRL settings*/

 list of PLLs to be registered */

 number of PLLs */

/*

 * list of controller registers to be saved and restored during a

 * suspend/resume cycle.

 list of all parent clock list */

 fixed rate clocks generated outside the soc */

 fixed rate clocks generated inside the soc */

	/*

	 * NOTE: Following table is sorted by (clock domain, register address,

	 * bitfield shift) triplet in ascending order. When adding new entries,

	 * please make sure that the order is kept, to avoid merge conflicts

	 * and make further work with defined data easier.

	/*

	 * CMU_CPU

	/*

	 * CMU_CORE

	/*

	 * CMU_TOP

	/*

	 * CMU_CDREX

	/*

	 * NOTE: Following table is sorted by (clock domain, register address,

	 * bitfield shift) triplet in ascending order. When adding new entries,

	 * please make sure that the order is kept, to avoid merge conflicts

	 * and make further work with defined data easier.

	/*

	 * CMU_CPU

	/*

	 * CMU_TOP

	/*

	 * NOTE: Following table is sorted by (clock domain, register address,

	 * bitfield shift) triplet in ascending order. When adding new entries,

	 * please make sure that the order is kept, to avoid merge conflicts

	 * and make further work with defined data easier.

	/*

	 * CMU_ACP

	/*

	 * CMU_TOP

 DISP1 gates */

 MUX mout_aclk200_disp1_sub */

 MUX mout_aclk300_disp1_sub */

 sorted in descending order */

 PLL_36XX_RATE(rate, m, p, s, k) */

 Not in UM, but need for eDP on snow */

 sorted in descending order */

 PLL_36XX_RATE(rate, m, p, s, k) */

 sorted in descending order */

 PLL_35XX_RATE(fin, rate, m, p, s) */

 register exynox5250 clocks */

	/*

	 * Enable arm clock down (in idle) and set arm divider

	 * ratios in WFI/WFE state.

	/*

	 * Enable arm clock up (on exiting idle). Set arm divider

	 * ratios when not in idle along with the standby duration

	 * ratios.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2014 Samsung Electronics Co., Ltd.

 * Author: Chanwoo Choi <cw00.choi@samsung.com>

 *

 * Common Clock Framework support for Exynos5433 SoC.

/*

 * Register offset definitions for CMU_TOP

 force all aclk clocks enabled */

 force all sclk_uart clocks enabled */

 ISP PLL has to be enabled for suspend: reset value + ENABLE bit */

 ISP PLL has to be enabled for suspend: reset value + ENABLE bit */

 list of all parent clock list */

 Xi2s{0|1}CDCLK input clock for I2S/PCM */

 Xi2s1SDI input clock for SPDIF */

 XspiCLK[4:0] input clock for SPI */

 Xi2s1SCLK input clock for I2S1_BCLK */

 MUX_SEL_TOP0 */

 MUX_SEL_TOP1 */

 MUX_SEL_TOP2 */

 MUX_SEL_TOP3 */

 MUX_SEL_TOP4 */

 MUX_SEL_TOP_MSCL */

 MUX_SEL_TOP_CAM1 */

 MUX_SEL_TOP_FSYS0 */

 MUX_SEL_TOP_FSYS1 */

 MUX_SEL_TOP_PERIC0 */

 MUX_SEL_TOP_PERIC1 */

 MUX_SEL_TOP_DISP */

 DIV_TOP0 */

 DIV_TOP1 */

 DIV_TOP2 */

 DIV_TOP3 */

 DIV_TOP4 */

 DIV_TOP_MSCL */

 DIV_TOP_CAM10 */

 DIV_TOP_CAM11 */

 DIV_TOP_FSYS0 */

 DIV_TOP_FSYS1 */

 DIV_TOP_FSYS2 */

 DIV_TOP_PERIC0 */

 DIV_TOP_PERIC1 */

 DIV_TOP_PERIC2 */

 DIV_TOP_PERIC3 */

 DIV_TOP_PERIC4 */

 ENABLE_ACLK_TOP */

 ENABLE_SCLK_TOP_MSCL */

 ENABLE_SCLK_TOP_CAM1 */

 ENABLE_SCLK_TOP_DISP */

 ENABLE_SCLK_TOP_FSYS */

 ENABLE_SCLK_TOP_PERIC */

 MUX_ENABLE_TOP_PERIC1 */

/*

 * ATLAS_PLL & APOLLO_PLL & MEM0_PLL & MEM1_PLL & BUS_PLL & MFC_PLL

 * & MPHY_PLL & G3D_PLL & DISP_PLL & ISP_PLL

 sentinel */ }

 AUD_PLL */

 sentinel */ }

/*

 * Register offset definitions for CMU_CPIF

 force all sclk clocks enabled */

 MPHY PLL has to be enabled for suspend: reset value + ENABLE bit */

 list of all parent clock list */

 MUX_SEL_CPIF0 */

 DIV_CPIF */

 ENABLE_SCLK_CPIF */

/*

 * Register offset definitions for CMU_MIF

 list of all parent clock list */

 dout_{mfc|bus|mem1|mem0}_pll is half fixed rate from parent mux */

 MUX_SEL_MIF0 */

 MUX_SEL_MIF1 */

 MUX_SEL_MIF2 */

 MUX_SEL_MIF3 */

 MUX_SEL_MIF4 */

 MUX_SEL_MIF5 */

 MUX_SEL_MIF6 */

 MUX_SEL_MIF7 */

 DIV_MIF1 */

 DIV_MIF2 */

 DIV_MIF3 */

 DIV_MIF4 */

 DIV_MIF5 */

 ENABLE_ACLK_MIF0 */

 ENABLE_ACLK_MIF1 */

 ENABLE_ACLK_MIF2 */

 ENABLE_ACLK_MIF3 */

 ENABLE_PCLK_MIF */

 ENABLE_PCLK_MIF_SECURE_DREX0_TZ */

 ENABLE_PCLK_MIF_SECURE_DREX1_TZ */

 ENABLE_PCLK_MIF_SECURE_MONOTONIC_CNT */

 ENABLE_PCLK_MIF_SECURE_RTC */

 ENABLE_SCLK_MIF */

/*

 * Register offset definitions for CMU_PERIC

 pclk: sci, pmu, sysreg, gpio_{finger, ese, touch, nfc}, uart2-0 */

 sclk: uart2-0 */

 DIV_PERIC */

 ENABLE_ACLK_PERIC */

 ENABLE_PCLK_PERIC0 */

 ENABLE_PCLK_PERIC1 */

 ENABLE_SCLK_PERIC */

/*

 * Register offset definitions for CMU_PERIS

 ENABLE_ACLK_PERIS */

 ENABLE_PCLK_PERIS */

 ENABLE_PCLK_PERIS_SECURE_TZPC */

 ENABLE_PCLK_PERIS_SECURE_SECKEY_APBIF */

 ENABLE_PCLK_PERIS_SECURE_CHIPID_APBIF */

 ENABLE_PCLK_PERIS_SECURE_TOPRTC */

 ENABLE_PCLK_PERIS_SECURE_CUSTOM_EFUSE_APBIF */

 ENABLE_PCLK_PERIS_SECURE_ANTIRBK_CNT_APBIF */

 ENABLE_PCLK_PERIS_SECURE_OTP_CON_APBIF */

 ENABLE_SCLK_PERIS */

 ENABLE_SCLK_PERIS_SECURE_SECKEY */

 ENABLE_SCLK_PERIS_SECURE_CHIPID */

 ENABLE_SCLK_PERIS_SECURE_TOPRTC */

 ENABLE_SCLK_PERIS_SECURE_CUSTOM_EFUSE */

 ENABLE_SCLK_PERIS_SECURE_ANTIRBK_CNT */

 ENABLE_SCLK_PERIS_SECURE_OTP_CON */

/*

 * Register offset definitions for CMU_FSYS

 list of all parent clock list */

 PHY clocks from USBDRD30_PHY */

 PHY clocks from USBHOST30_PHY */

 PHY clocks from USBHOST20_PHY */

 PHY clocks from UFS_PHY */

 PHY clocks from LLI_PHY */

 MUX_SEL_FSYS0 */

 MUX_SEL_FSYS1 */

 MUX_SEL_FSYS2 */

 MUX_SEL_FSYS3 */

 MUX_SEL_FSYS4 */

 ENABLE_ACLK_FSYS0 */

 ENABLE_ACLK_FSYS1 */

 ENABLE_PCLK_FSYS */

 ENABLE_SCLK_FSYS */

 ENABLE_IP_FSYS0 */

/*

 * Register offset definitions for CMU_G2D

 list of all parent clock list */

 MUX_SEL_G2D0 */

 DIV_G2D */

 DIV_ENABLE_ACLK_G2D */

 DIV_ENABLE_ACLK_G2D_SECURE_SMMU_G2D */

 DIV_ENABLE_PCLK_G2D */

 DIV_ENABLE_PCLK_G2D_SECURE_SMMU_G2D */

/*

 * Register offset definitions for CMU_DISP

 PLL has to be enabled for suspend */

 ignore status of external PHY muxes during suspend to avoid hangs */

 list of all parent clock list */

	/*

	 * sclk_rgb_{vclk|tv_vclk} is half clock of sclk_decon_{vclk|tv_vclk}.

	 * The divider has fixed value (2) between sclk_rgb_{vclk|tv_vclk}

	 * and sclk_decon_{vclk|tv_vclk}.

 PHY clocks from MIPI_DPHY1 */

 PHY clocks from MIPI_DPHY0 */

 PHY clocks from HDMI_PHY */

 MUX_SEL_DISP0 */

 MUX_SEL_DISP1 */

 MUX_SEL_DISP2 */

 MUX_SEL_DISP3 */

 MUX_SEL_DISP4 */

 DIV_DISP */

 ENABLE_ACLK_DISP0 */

 ENABLE_ACLK_DISP1 */

 ENABLE_PCLK_DISP */

 ENABLE_SCLK_DISP */

/*

 * Register offset definitions for CMU_AUD

 list of all parent clock list */

 MUX_SEL_AUD0 */

 MUX_SEL_AUD1 */

 DIV_AUD0 */

 DIV_AUD1 */

 ENABLE_ACLK_AUD */

 ENABLE_PCLK_AUD */

 ENABLE_SCLK_AUD0 */

 ENABLE_SCLK_AUD1 */

/*

 * Register offset definitions for CMU_BUS{0|1|2}

 Only for CMU_BUS2 */

 Only for CMU_BUS2 */

 Only for CMU_BUS2 */

 list of all parent clock list */

 DIV_BUS0 */

 CMU_BUS0 clocks */

 ENABLE_ACLK_BUS0 */

 ENABLE_PCLK_BUS0 */

 CMU_BUS1 clocks */

 DIV_BUS1 */

 ENABLE_ACLK_BUS1 */

 ENABLE_PCLK_BUS1 */

 CMU_BUS2 clocks */

 MUX_SEL_BUS2 */

 DIV_BUS2 */

 ENABLE_ACLK_BUS2 */

 ENABLE_PCLK_BUS2 */

/*

 * Register offset definitions for CMU_G3D

 list of all parent clock list */

 MUX_SEL_G3D */

 DIV_G3D */

 ENABLE_ACLK_G3D */

 ENABLE_PCLK_G3D */

 ENABLE_SCLK_G3D */

/*

 * Register offset definitions for CMU_GSCL

 list of all parent clock list */

 MUX_SEL_GSCL */

 ENABLE_ACLK_GSCL */

 ENABLE_ACLK_GSCL_SECURE_SMMU_GSCL0 */

 ENABLE_ACLK_GSCL_SECURE_SMMU_GSCL1 */

 ENABLE_ACLK_GSCL_SECURE_SMMU_GSCL2 */

 ENABLE_PCLK_GSCL */

 ENABLE_PCLK_GSCL_SECURE_SMMU_GSCL0 */

 ENABLE_PCLK_GSCL_SECURE_SMMU_GSCL1 */

 ENABLE_PCLK_GSCL_SECURE_SMMU_GSCL2 */

/*

 * Register offset definitions for CMU_APOLLO

 list of all parent clock list */

 MUX_SEL_APOLLO0 */

 MUX_SEL_APOLLO1 */

 MUX_SEL_APOLLO2 */

 DIV_APOLLO0 */

 DIV_APOLLO1 */

 ENABLE_ACLK_APOLLO */

 ENABLE_PCLK_APOLLO */

 ENABLE_SCLK_APOLLO */

/*

 * Register offset definitions for CMU_ATLAS

 list of all parent clock list */

 MUX_SEL_ATLAS0 */

 MUX_SEL_ATLAS1 */

 MUX_SEL_ATLAS2 */

 DIV_ATLAS0 */

 DIV_ATLAS1 */

 ENABLE_ACLK_ATLAS */

 ENABLE_PCLK_ATLAS */

 ENABLE_SCLK_ATLAS */

/*

 * Register offset definitions for CMU_MSCL

 list of all parent clock list */

 MUX_SEL_MSCL0 */

 MUX_SEL_MSCL1 */

 DIV_MSCL */

 ENABLE_ACLK_MSCL */

 ENABLE_ACLK_MSCL_SECURE_SMMU_M2MSCALER0 */

 ENABLE_ACLK_MSCL_SECURE_SMMU_M2MSCALER1 */

 ENABLE_ACLK_MSCL_SECURE_SMMU_JPEG */

 ENABLE_PCLK_MSCL */

 ENABLE_PCLK_MSCL_SECURE_SMMU_M2MSCALER0 */

 ENABLE_PCLK_MSCL_SECURE_SMMU_M2MSCALER1 */

 ENABLE_PCLK_MSCL_SECURE_SMMU_JPEG */

 ENABLE_SCLK_MSCL */

/*

 * Register offset definitions for CMU_MFC

 MUX_SEL_MFC */

 DIV_MFC */

 ENABLE_ACLK_MFC */

 ENABLE_ACLK_MFC_SECURE_SMMU_MFC */

 ENABLE_PCLK_MFC */

 ENABLE_PCLK_MFC_SECURE_SMMU_MFC */

/*

 * Register offset definitions for CMU_HEVC

 MUX_SEL_HEVC */

 DIV_HEVC */

 ENABLE_ACLK_HEVC */

 ENABLE_ACLK_HEVC_SECURE_SMMU_HEVC */

 ENABLE_PCLK_HEVC */

 ENABLE_PCLK_HEVC_SECURE_SMMU_HEVC */

/*

 * Register offset definitions for CMU_ISP

 MUX_SEL_ISP */

 DIV_ISP */

 ENABLE_ACLK_ISP0 */

 ENABLE_ACLK_ISP1 */

 ENABLE_ACLK_ISP2 */

 ENABLE_PCLK_ISP */

 ENABLE_SCLK_ISP */

/*

 * Register offset definitions for CMU_CAM0

 MUX_SEL_CAM00 */

 MUX_SEL_CAM01 */

 MUX_SEL_CAM02 */

 MUX_SEL_CAM03 */

 MUX_SEL_CAM04 */

 DIV_CAM00 */

 DIV_CAM01 */

 DIV_CAM02 */

 DIV_CAM03 */

 ENABLE_ACLK_CAM00 */

 ENABLE_ACLK_CAM01 */

 ENABLE_ACLK_CAM02 */

 ENABLE_PCLK_CAM0 */

 ENABLE_SCLK_CAM0 */

/*

 * Register offset definitions for CMU_CAM1

 MUX_SEL_CAM10 */

 MUX_SEL_CAM11 */

 MUX_SEL_CAM12 */

 DIV_CAM10 */

 DIV_CAM11 */

 ENABLE_ACLK_CAM10 */

 ENABLE_ACLK_CAM11 */

 ENABLE_ACLK_CAM12 */

 ENABLE_PCLK_CAM1 */

 ENABLE_SCLK_CAM1 */

/*

 * Register offset definitions for CMU_IMEM

 ENABLE_ACLK_IMEM_SLIMSSS */

 ENABLE_PCLK_IMEM_SLIMSSS */

 must be the last entry */

 for suspend some registers have to be set to certain values */

	/*

	 * Enable runtime PM here to allow the clock core using runtime PM

	 * for the registered clocks. Additionally, we increase the runtime

	 * PM usage count before registering the clocks, to prevent the

	 * clock core from runtime suspending the device.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2021 Linaro Ltd.

 * Author: Sam Protsenko <semen.protsenko@linaro.org>

 *

 * Common Clock Framework support for Exynos850 SoC.

 Gate register bits */

 Gate register offsets range */

/**

 * exynos850_init_clocks - Set clocks initial configuration

 * @np:			CMU device tree node with "reg" property (CMU addr)

 * @reg_offs:		Register offsets array for clocks to init

 * @reg_offs_len:	Number of register offsets in reg_offs array

 *

 * Set manual control mode for all gate clocks.

 Modify only gate clock registers */

 ---- CMU_TOP ------------------------------------------------------------- */

 Register Offset definitions for CMU_TOP (0x120e0000) */

/*

 * Do not provide PLL tables to core PLLs, as MANUAL_PLL_CTRL bit is not set

 * for those PLLs by default, so set_rate operation would fail.

 CMU_TOP_PURECLKCOMP */

 List of parent clocks for Muxes in CMU_TOP */

 List of parent clocks for Muxes in CMU_TOP: for CMU_CORE */

 List of parent clocks for Muxes in CMU_TOP: for CMU_HSI */

 List of parent clocks for Muxes in CMU_TOP: for CMU_PERI */

 List of parent clocks for Muxes in CMU_TOP: for CMU_DPU */

 CMU_TOP_PURECLKCOMP */

 CORE */

 DPU */

 HSI */

 PERI */

 CMU_TOP_PURECLKCOMP */

 CORE */

 DPU */

 HSI */

 PERI */

 CORE */

 DPU */

 HSI */

 PERI */

 ---- CMU_HSI ------------------------------------------------------------- */

 Register Offset definitions for CMU_HSI (0x13400000) */

 List of parent clocks for Muxes in CMU_PERI */

 ---- CMU_PERI ------------------------------------------------------------ */

 Register Offset definitions for CMU_PERI (0x10030000) */

 List of parent clocks for Muxes in CMU_PERI */

 ---- CMU_CORE ------------------------------------------------------------ */

 Register Offset definitions for CMU_CORE (0x12000000) */

 List of parent clocks for Muxes in CMU_CORE */

 ---- CMU_DPU ------------------------------------------------------------- */

 Register Offset definitions for CMU_DPU (0x13000000) */

 List of parent clocks for Muxes in CMU_CORE */

 ---- platform_driver ----------------------------------------------------- */

 Keep bus clock running, so it's possible to access CMU registers */

 CMUs which belong to Power Domains and need runtime PM to be implemented */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2013 Samsung Electronics Co., Ltd.

 * Copyright (c) 2013 Linaro Ltd.

 * Author: Thomas Abraham <thomas.ab@samsung.com>

 *

 * This file includes utility functions to register clocks to common

 * clock framework for Samsung platforms.

 setup the essentials required to support clock lookup using ccf */

 add a clock instance to the clock lookup table used for dt based lookup */

 register a list of aliases */

 register a list of fixed clocks */

		/*

		 * Unconditionally add a clock lookup for the fixed rate clocks.

		 * There are not many of these on any of Samsung platforms.

 register a list of fixed factor clocks */

 register a list of mux clocks */

 register a list of div clocks */

 register a list of gate clocks */

/*

 * obtain the clock speed of all external fixed clock sources from device

 * tree and register it

 utility function to get the rate of a specified clock */

/*

 * Common function which registers plls, muxes, dividers and gates

 * for each CMU. It also add CMU register list to register cache.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2014 Samsung Electronics Co., Ltd.

 * Author: Naveen Krishna Ch <naveenkrishna.ch@gmail.com>

 Register Offset definitions for CMU_TOPC (0x10570000) */

 List of parent clocks for Muxes in CMU_TOPC */

 Register Offset definitions for CMU_TOP0 (0x105D0000) */

 List of parent clocks for Muxes in CMU_TOP0 */

 Register Offset definitions for CMU_TOP1 (0x105E0000) */

 List of parent clocks for Muxes in CMU_TOP1 */

	/*

	 * This clock is required for the CMU_FSYS1 registers access, keep it

	 * enabled permanently until proper runtime PM support is added.

 Register Offset definitions for CMU_CCORE (0x105B0000) */

/*

 * List of parent clocks for Muxes in CMU_CCORE

 Register Offset definitions for CMU_PERIC0 (0x13610000) */

 List of parent clocks for Muxes in CMU_PERIC0 */

 Register Offset definitions for CMU_PERIC1 (0x14C80000) */

 List of parent clocks for Muxes in CMU_PERIC1 */

 Register Offset definitions for CMU_PERIS (0x10040000) */

 List of parent clocks for Muxes in CMU_PERIS */

 Register Offset definitions for CMU_FSYS0 (0x10E90000) */

/*

 * List of parent clocks for Muxes in CMU_FSYS0

 fixed rate clocks used in the FSYS0 block */

 Register Offset definitions for CMU_FSYS1 (0x156E0000) */

/*

 * List of parent clocks for Muxes in CMU_FSYS1

 fixed rate clocks used in the FSYS1 block */

 List of parent clocks for Muxes in CMU_MSCL */

 Register Offset definitions for CMU_AUD (0x114C0000) */

/*

 * List of parent clocks for Muxes in CMU_AUD

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2013 Samsung Electronics Co., Ltd.

 * Author: Padmavathi Venna <padma.v@samsung.com>

 *

 * Common Clock Framework support for Audio Subsystem Clock Controller.

/*

 * On Exynos5420 this will be a clock which has to be enabled before any

 * access to audss registers. Typically a child of EPLL.

 *

 * On other platforms this will be -ENODEV.

 register exynos_audss clocks */

	/*

	 * Enable runtime PM here to allow the clock core using runtime PM

	 * for the registered clocks. Additionally, we increase the runtime

	 * PM usage count before registering the clocks, to prevent the

	 * clock core from runtime suspending the device.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2013 Heiko Stuebner <heiko@sntech.de>

 *

 * Common Clock Framework support for s3c24xx external clock output.

/*

 * Clock for output-parent selection in misccr

 allocate the clkout */

/*

 * dclk and clkout init

 clk_data must be the last entry in the structure */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2013 Samsung Electronics Co., Ltd.

 * Copyright (c) 2013 Linaro Ltd.

 *

 * This file contains the utility functions to register the pll clocks.

 PLL enable control bit offset in @con_reg register */

 PLL lock status bit offset in @con_reg register */

 Assumming rate_table is in descending order */

 return minimum supported value */

 Wait until the PLL is locked */

	/*

	 * This function might be called when the timekeeping API can't be used

	 * to detect timeouts. One situation is when the clocksource is not yet

	 * initialized, another when the timekeeping is suspended. udelay() also

	 * cannot be used when the clocksource is not running on arm64, since

	 * the current timer is used as cycle counter. So a simple busy loop

	 * is used here in that special cases. The limit of iterations has been

	 * derived from experimental measurements of various PLLs on multiple

	 * Exynos SoC variants. Single register read time was usually in range

	 * 0.4...1.5 us, never less than 0.4 us.

/*

 * PLL2126 Clock Type

/*

 * PLL3000 Clock Type

/*

 * PLL35xx Clock Type

 Maximum lock time can be 270 * PDIV cycles */

 Get required rate settings from table */

 If only s change, change just s value only*/

 Set PLL lock time. */

 Change PLL PMS values */

 Wait for PLL lock if the PLL is enabled */

/*

 * PLL36xx Clock Type

 Maximum lock time can be 3000 * PDIV cycles */

 If only s change, change just s value only*/

 Set PLL lock time. */

 Change PLL PMS values */

/*

 * PLL0822x Clock Type

 Maximum lock time can be 150 * PDIV cycles */

 Get required rate settings from table */

 Change PLL PMS values */

 Set PLL lock time */

 Write PMS values */

 Wait for PLL lock if the PLL is enabled */

/*

 * PLL0831x Clock Type

 Maximum lock time can be 500 * PDIV cycles */

 Get required rate settings from table */

 Change PLL PMSK values */

	/*

	 * kdiv is 16-bit 2's complement (s16), but stored as unsigned int.

	 * Cast it to u16 to avoid leading 0xffff's in case of negative value.

 Set PLL lock time */

 Write PMSK values */

 Wait for PLL lock if the PLL is enabled */

/*

 * PLL45xx Clock Type

 Get required rate settings from table */

 If only s change, change just s value only*/

 Set PLL PMS values. */

 Set PLL AFC value. */

 Set PLL lock time. */

 Set new configuration. */

 Wait for PLL lock */

/*

 * PLL46xx Clock Type

 Get required rate settings from table */

 If only s change, change just s value only*/

 Set PLL lock time. */

 Maximum lock time bitfield is 16-bit. */

 Set PLL PMS and VSEL values. */

 Set PLL K, MFR and MRR values. */

 Write configuration to PLL */

 Wait for PLL lock */

/*

 * PLL6552 Clock Type

/*

 * PLL6553 Clock Type

/*

 * PLL Clock Type of S3C24XX before S3C2443

 Get required rate settings from table */

 Change PLL PMS values */

 Time to settle according to the manual */

 if we started the UPLL, then allow to settle */

/*

 * PLL2550x Clock Type

/*

 * PLL2550xx Clock Type

 Maximum lock time can be 270 * PDIV cycles */

 Get required rate settings from table */

 If only s change, change just s value only*/

 Set PLL lock time. */

 Change PLL PMS values */

 Wait for PLL lock */

/*

 * PLL2650x Clock Type

 Maximum lock time can be 3000 * PDIV cycles */

 Get required rate settings from table */

 Set PLL lock time. */

 Change PLL PMS values */

 Wait for PLL lock */

/*

 * PLL2650XX Clock Type

 Maximum lock time can be 3000 * PDIV cycles */

 Change PLL PMS values */

 Set PLL lock time. */

 find count of rates in rate_table */

 clk_ops for 35xx and 2550 are similar */

 clk_ops for 36xx and 2650 are similar */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2014 Samsung Electronics Co., Ltd.

 * Author: Thomas Abraham <thomas.ab@samsung.com>

 *

 * Copyright (c) 2015 Samsung Electronics Co., Ltd.

 * Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>

 *

 * This file contains the utility function to register CPU clock for Samsung

 * Exynos platforms. A CPU clock is defined as a clock supplied to a CPU or a

 * group of CPUs. The CPU clock is typically derived from a hierarchy of clock

 * blocks which includes mux and divider blocks. There are a number of other

 * auxiliary clocks supplied to the CPU domain such as the debug blocks and AXI

 * clock for CPU domain. The rates of these auxiliary clocks are related to the

 * CPU clock rate and this relation is usually specified in the hardware manual

 * of the SoC or supplied after the SoC characterization.

 *

 * The below implementation of the CPU clock allows the rate changes of the CPU

 * clock and the corresponding rate changes of the auxillary clocks of the CPU

 * domain. The platform clock driver provides a clock register configuration

 * for each configurable rate which is then used to program the clock hardware

 * registers to acheive a fast co-oridinated rate change for all the CPU domain

 * clocks.

 *

 * On a rate change request for the CPU clock, the rate change is propagated

 * upto the PLL supplying the clock to the CPU domain clock blocks. While the

 * CPU domain PLL is reconfigured, the CPU domain clocks are driven using an

 * alternate clock source. If required, the alternate clock source is divided

 * down in order to keep the output clock rate within the previous OPP limits.

/*

 * Helper function to wait until divider(s) have stabilized after the divider

 * value has changed.

/*

 * Helper function to wait until mux has stabilized after the mux selection

 * value was changed.

 common round rate callback useable for all types of CPU clocks */

 common recalc rate callback useable for all types of CPU clocks */

	/*

	 * The CPU clock output (armclk) rate is the same as its parent

	 * rate. Although there exist certain dividers inside the CPU

	 * clock block that could be used to divide the parent clock,

	 * the driver does not make use of them currently, except during

	 * frequency transitions.

/*

 * Helper function to set the 'safe' dividers for the CPU clock. The parameters

 * div and mask contain the divider value and the register bit mask of the

 * dividers to be programmed.

 handler for pre-rate change notification from parent clock */

 find out the divider values to use for clock data */

	/*

	 * For the selected PLL clock frequency, get the pre-defined divider

	 * values. If the clock for sclk_hpm is not sourced from apll, then

	 * the values for DIV_COPY and DIV_HPM dividers need not be set.

	/*

	 * If the old parent clock speed is less than the clock speed of

	 * the alternate parent, then it should be ensured that at no point

	 * the armclk speed is more than the old_prate until the dividers are

	 * set.  Also workaround the issue of the dividers being set to lower

	 * values before the parent clock speed is set to new lower speed

	 * (this can result in too high speed of armclk output clocks).

			/*

			 * In Exynos4210, ATB clock parent is also mout_core. So

			 * ATB clock also needs to be mantained at safe speed.

 select sclk_mpll as the alternate parent */

 alternate parent is active now. set the dividers */

 handler for post-rate change notification from parent clock */

 find out the divider values to use for clock data */

 select mout_apll as the alternate parent */

/*

 * Helper function to set the 'safe' dividers for the CPU clock. The parameters

 * div and mask contain the divider value and the register bit mask of the

 * dividers to be programmed.

 handler for pre-rate change notification from parent clock */

 find out the divider values to use for clock data */

	/*

	 * For the selected PLL clock frequency, get the pre-defined divider

	 * values.

	/*

	 * If the old parent clock speed is less than the clock speed of

	 * the alternate parent, then it should be ensured that at no point

	 * the armclk speed is more than the old_prate until the dividers are

	 * set.  Also workaround the issue of the dividers being set to lower

	 * values before the parent clock speed is set to new lower speed

	 * (this can result in too high speed of armclk output clocks).

 select the alternate parent */

 alternate parent is active now. set the dividers */

 handler for post-rate change notification from parent clock */

 select apll as the alternate parent */

/*

 * This notifier function is called for the pre-rate and post-rate change

 * notifications of the parent clock of cpuclk.

/*

 * This notifier function is called for the pre-rate and post-rate change

 * notifications of the parent clock of cpuclk.

 helper function to register a CPU clock */

 find count of configuration rates in cfg */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2013 Samsung Electronics Co., Ltd.

 * Author: Tarek Dakhran <t.dakhran@samsung.com>

 *

 * Common Clock Framework support for Exynos5410 SoC.

 list of PLLs */

 number of PLLs */

 list of all parent clocks */

 register exynos5410 clocks */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2014 Tomasz Figa <t.figa@samsung.com>

 *

 * Based on Exynos Audio Subsystem Clock Controller driver:

 *

 * Copyright (c) 2013 Samsung Electronics Co., Ltd.

 * Author: Padmavathi Venna <padma.v@samsung.com>

 *

 * Driver for Audio Subsystem Clock Controller of S5PV210-compatible SoCs.

 CONFIG_PM_SLEEP */

 register s5pv210_audss clocks */

 iiscdclk0 is an optional external I2S codec clock */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2013 Heiko Stuebner <heiko@sntech.de>

 *

 * Common Clock Framework support for S3C2443 and following SoCs.

 S3C2416 clock controller register offsets */

 the soc types */

/*

 * list of controller registers to be saved and restored during a

 * suspend/resume cycle.

 sentinel */ },

 sentinel */ },

 S3C2416 specific clocks */

 sentinel */ },

 S3C2443 specific clocks */

 sentinel */ },

 S3C2450 specific clocks */

/*

 * fixed rate clocks generated outside the soc

 * Only necessary until the devicetree-move is complete

 Register external clocks only in non-dt cases */

 Register PLLs. */

 Register common internal clocks. */

 Register SoC-specific clocks. */

 as s3c2450 extends the s3c2416 clocks */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2013 Samsung Electronics Co., Ltd.

 * Author: Mateusz Krawczuk <m.krawczuk@partner.samsung.com>

 *

 * Based on clock drivers for S3C64xx and Exynos4 SoCs.

 *

 * Common Clock Framework support for all S5PC110/S5PV210 SoCs.

 S5PC110/S5PV210 clock controller register offsets */

 IDs of PLLs available on S5PV210/S5P6442 SoCs */

 IDs of external clocks (used for legacy boards) */

 List of registers that need to be preserved across suspend/resume. */

 Mux parent lists. */

 Common fixed factor clocks. */

 PLL input mux (fin_pll), which needs to be registered before PLLs. */

 Common clock muxes. */

 S5PV210-specific clock muxes. */

 S5P6442-specific clock muxes. */

 S5PV210-specific fixed rate clocks generated inside the SoC. */

 S5P6442-specific fixed rate clocks generated inside the SoC. */

 Common clock dividers. */

 S5PV210-specific clock dividers. */

 S5P6442-specific clock dividers. */

 Common clock gates. */

 S5PV210-specific clock gates. */

 S5P6442-specific clock gates. */

/*

 * Clock aliases for legacy clkdev look-up.

 * NOTE: Needed only to support legacy board files.

 S5PV210-specific PLLs. */

 S5P6442-specific PLLs. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2014 Samsung Electronics Co., Ltd.

 * Author: Tomasz Figa <t.figa@samsung.com>

 *

 * Clock driver for Exynos clock output

/*

 * Device will be instantiated as child of PMU device without its own

 * device node.  Therefore match compatibles against parent.

		/*

		 * pdev->dev.parent was checked by exynos_clkout_match_parent_dev()

		 * so it is not NULL.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2013 Samsung Electronics Co., Ltd.

 * Copyright (c) 2013 Linaro Ltd.

 * Author: Thomas Abraham <thomas.ab@samsung.com>

 *

 * Common Clock Framework support for all Exynos4 SoCs.

 Exynos4 clock controller register offsets */

 Below definitions are used for PWR_CTRL settings */

 the exynos4 soc type */

 list of PLLs to be registered */

 number of PLLs */

/*

 * list of controller registers to be saved and restored during a

 * suspend/resume cycle.

 list of all parent clock list */

 Exynos 4210-specific parent groups */

 Exynos 4x12-specific parent groups */

 fixed rate clocks generated outside the soc */

 fixed rate clocks generated inside the soc */

 list of mux clocks supported in all exynos4 soc's */

 list of mux clocks supported in exynos4210 soc */

 list of mux clocks supported in exynos4x12 soc */

 list of divider clocks supported in all exynos4 soc's */

 list of divider clocks supported in exynos4210 soc */

 list of divider clocks supported in exynos4x12 soc */

 list of gate clocks supported in all exynos4 soc's */

 list of gate clocks supported in exynos4210 soc */

 list of gate clocks supported in exynos4x12 soc */

/*

 * The parent of the fin_pll clock is selected by the XOM[0] bit. This bit

 * resides in chipid register space, outside of the clock controller memory

 * mapped space. So to determine the parent of fin_pll clock, the chipid

 * controller is first remapped and the value of XOM[0] bit is read to

 * determine the parent clock.

 PLLs PMS values */

 sentinel */ }

 sentinel */ }

 sentinel */ }

 sentinel */ }

 sentinel */ }

 sentinel */ }

	/*

	 * Enable arm clock down (in idle) and set arm divider

	 * ratios in WFI/WFE state.

 On Exynos4412 enable it also on core 2 and 3 */

	/*

	 * Disable the clock up feature in case it was enabled by bootloader.

 register exynos4 clocks */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2013 Tomasz Figa <tomasz.figa at gmail.com>

 *

 * Common Clock Framework support for all S3C64xx SoCs.

 S3C64xx clock controller register offsets. */

 Helper macros to define clock arrays. */

 Helper macros for gate types present on S3C64xx. */

/*

 * List of controller registers to be saved and restored during

 * a suspend/resume cycle.

 List of parent clocks common for all S3C64xx SoCs. */

 S3C6400-specific parent clocks. */

 S3C6410-specific parent clocks. */

 Fixed rate clocks generated outside the SoC. */

 Fixed rate clocks generated inside the SoC. */

 List of clock muxes present on all S3C64xx SoCs. */

 List of clock muxes present on S3C6400. */

 List of clock muxes present on S3C6410. */

 List of clock dividers present on all S3C64xx SoCs. */

 List of clock dividers present on S3C6400. */

 List of clock dividers present on S3C6410. */

 List of clock gates present on all S3C64xx SoCs. */

 List of clock gates present on S3C6400. */

 List of clock gates present on S3C6410. */

 List of PLL clocks. */

 Aliases for common s3c64xx clocks. */

 Aliases for s3c6400-specific clocks. */

 Nothing to place here yet. */

 Aliases for s3c6410-specific clocks. */

 Register s3c64xx clocks. */

 Register external clocks. */

 Register PLLs. */

 Register common internal clocks. */

 Register SoC-specific clocks. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2013 Samsung Electronics Co., Ltd.

 * Authors: Thomas Abraham <thomas.ab@samsung.com>

 *	    Chander Kashyap <k.chander@samsung.com>

 *

 * Common Clock Framework support for Exynos5420 SoC.

 5800 specific */

 5800 specific */

 5800 specific */

 5800 specific */

 5800 specific */

 5800 specific */

 5800 specific */

 5800 specific */

 Exynos5x SoC type */

 list of PLLs */

 number of PLLs */

/*

 * list of controller registers to be saved and restored during a

 * suspend/resume cycle.

 list of all parent clocks */

 List of parents specific to exynos5800 */

 fixed rate clocks generated outside the soc */

 fixed rate clocks generated inside the soc */

 Maudio Block */

 DISP1 Block */

 CDREX block */

 MAU Block */

 FSYS Block */

 PERIC Block */

 ISP Block */

 DISP1 Block */

 CDREX Block */

	/*

	 * The three clocks below are controlled using the same register and

	 * bits. They are put into one because there is a need of

	 * synchronization between the BUS and DREXs (two external memory

	 * interfaces).

	 * They are put here to show this HW assumption and for clock

	 * information summary completeness.

 Audio Block */

 USB3.0 */

 MMC */

 UART and PWM */

 SPI */

 PCM */

 Audio - I2S */

 SPI Pre-Ratio */

 GSCL Block */

 PSGEN */

 ISP Block */

 G2D */

 sclk */

 Display */

 FSYS Block */

 PERIC Block */

 PERIS Block */

 GEN Block */

 GATE_IP_GEN doesn't list gates for smmu_jpeg2 and mc */

 GSCL Block */

 ISP */

 CDREX */

 DISP1 gates */

 MUX mout_user_aclk400_disp1 */

 MUX mout_user_aclk300_disp1 */

 MUX mout_user_aclk200_disp1 */

 DIV dout_disp1_blk */

 GSC gates */

 GSC gates */

 MUX mout_user_aclk300_gscl */

 DIV dout_gscl_blk_300 */

 G3D gates */

 MUX mout_user_aclk_g3d */

 MFC gates */

 MUX mout_user_aclk333 */

 DIV dout_mfc_blk */

 MSCL Block */

 MSCL gates */

 MUX mout_user_aclk400_mscl */

 DIV dout_mscl_blk */

 MUX mout_user_mau_epll */

 for Exynos5800 */

 register exynos5420 clocks */

	/*

	 * Keep top part of G3D clock path enabled permanently to ensure

	 * that the internal busses get their clock regardless of the

	 * main G3D clock enablement status.

	/*

	 * Keep top BPLL mux enabled permanently to ensure that DRAM operates

	 * properly.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2013 Heiko Stuebner <heiko@sntech.de>

 *

 * Common Clock Framework support for S3C2412 and S3C2413.

/*

 * list of controller registers to be saved and restored during a

 * suspend/resume cycle.

 sentinel */ },

/*

 * The first two use the OM[4] setting, which is not readable from

 * software, so assume it is set to xti.

	/* errata "Watch-dog/Software Reset Problem" specifies that

	 * this reset must be done with the SYSCLK sourced from

	 * EXTCLK instead of FOUT to avoid a glitch in the reset

	 * mechanism.

	 *

	 * See the watchdog section of the S3C2412 manual for more

	 * information on this fix.

/*

 * fixed rate clocks generated outside the soc

 * Only necessary until the devicetree-move is complete

 xtal alias is necessary for the current cpufreq driver */

 Register external clocks only in non-dt cases */

 Register PLLs. */

 Register common internal clocks. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2013 Heiko Stuebner <heiko@sntech.de>

 *

 * Common Clock Framework support for S3C2410 and following SoCs.

 the soc types */

 list of PLLs to be registered */

/*

 * list of controller registers to be saved and restored during a

 * suspend/resume cycle.

 sentinel */ },

 should be added _after_ the soc-specific clocks are created */

 S3C2410 specific clocks */

 sorted in descending order */

 2410A extras */

 2410 common */

 sentinel */ },

	/*

	 * armclk is directly supplied by the fclk, without

	 * switching possibility like on the s3c244x below.

 uclk is fed from the unmodified upll */

 S3C244x specific clocks */

 sorted in descending order */

 sentinel */ },

 sentinel */ },

 sentinel */ },

 S3C2440 specific clocks */

 S3C2442 specific clocks */

/*

 * fixed rate clocks generated outside the soc

 * Only necessary until the devicetree-move is complete

 Register external clocks only in non-dt cases */

 Register PLLs. */

 S3C2440, S3C2442 */

			/*

			 * plls follow different calculation schemes, with the

			 * upll following the same scheme as the s3c2410 plls

 Register PLLs. */

 Register common internal clocks. */

 Register SoC-specific clocks. */

	/*

	 * Register common aliases at the end, as some of the aliased clocks

	 * are SoC specific.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2014 Samsung Electronics Co., Ltd.

 *

 * Common Clock Framework support for Exynos3250 SoC.

 Below definitions are used for PWR_CTRL settings */

 list of all parent clock list */

 HACK: fin_pll hardcoded to xusbxti until detection is implemented. */

	/*

	 * NOTE: Following table is sorted by register address in ascending

	 * order and then bitfield shift in descending order, as it is done

	 * in the User's Manual. When adding new entries, please make sure

	 * that the order is preserved, to avoid merge conflicts and make

	 * further work with defined data easier.

 SRC_LEFTBUS */

 SRC_RIGHTBUS */

 SRC_TOP0 */

 SRC_TOP1 */

 SRC_CAM */

 SRC_MFC */

 SRC_G3D */

 SRC_LCD */

 SRC_ISP */

 SRC_FSYS */

 SRC_PERIL0 */

 SRC_PERIL1 */

 SRC_CPU */

	/*

	 * NOTE: Following table is sorted by register address in ascending

	 * order and then bitfield shift in descending order, as it is done

	 * in the User's Manual. When adding new entries, please make sure

	 * that the order is preserved, to avoid merge conflicts and make

	 * further work with defined data easier.

 DIV_LEFTBUS */

 DIV_RIGHTBUS */

 DIV_TOP */

 DIV_CAM */

 DIV_MFC */

 DIV_G3D */

 DIV_LCD */

 DIV_ISP */

 DIV_FSYS0 */

 DIV_FSYS1 */

 DIV_FSYS2 */

 DIV_PERIL0 */

 DIV_PERIL1 */

 DIV_PERIL4 */

 DIV_PERIL5 */

 DIV_CPU0 */

 DIV_CPU1 */

	/*

	 * NOTE: Following table is sorted by register address in ascending

	 * order and then bitfield shift in descending order, as it is done

	 * in the User's Manual. When adding new entries, please make sure

	 * that the order is preserved, to avoid merge conflicts and make

	 * further work with defined data easier.

 GATE_IP_LEFTBUS */

 GATE_IP_RIGHTBUS */

 GATE_IP_PERIR */

 GATE_SCLK_CAM */

 GATE_SCLK_MFC */

 GATE_SCLK_G3D */

 GATE_SCLK_LCD */

 GATE_SCLK_ISP_TOP */

 GATE_SCLK_FSYS */

 GATE_SCLK_PERIL */

 GATE_IP_CAM */

 GATE_IP_MFC */

 GATE_IP_G3D */

 GATE_IP_LCD */

 GATE_IP_ISP */

 GATE_IP_FSYS */

 GATE_IP_PERIL */

 APLL & MPLL & BPLL & UPLL */

 sentinel */ }

 EPLL */

 sentinel */ }

 VPLL */

 sentinel */ }

	/*

	 * Enable arm clock down (in idle) and set arm divider

	 * ratios in WFI/WFE state.

	/*

	 * Disable the clock up feature on Exynos4x12, in case it was

	 * enabled by bootloader.

/*

 * CMU DMC

	/*

	 * NOTE: Following table is sorted by register address in ascending

	 * order and then bitfield shift in descending order, as it is done

	 * in the User's Manual. When adding new entries, please make sure

	 * that the order is preserved, to avoid merge conflicts and make

	 * further work with defined data easier.

 SRC_DMC */

 SRC_EPLL */

	/*

	 * NOTE: Following table is sorted by register address in ascending

	 * order and then bitfield shift in descending order, as it is done

	 * in the User's Manual. When adding new entries, please make sure

	 * that the order is preserved, to avoid merge conflicts and make

	 * further work with defined data easier.

 DIV_DMC1 */

/*

 * CMU ISP

	/*

	 * NOTE: Following table is sorted by register address in ascending

	 * order and then bitfield shift in descending order, as it is done

	 * in the User's Manual. When adding new entries, please make sure

	 * that the order is preserved, to avoid merge conflicts and make

	 * further work with defined data easier.

 DIV_ISP0 */

 DIV_ISP1 */

	/*

	 * NOTE: Following table is sorted by register address in ascending

	 * order and then bitfield shift in descending order, as it is done

	 * in the User's Manual. When adding new entries, please make sure

	 * that the order is preserved, to avoid merge conflicts and make

	 * further work with defined data easier.

 GATE_IP_ISP0 */

 GATE_IP_ISP1 */

 GATE_SCLK_ISP */

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0



 Copyright (c) 2018 Samsung Electronics Co., Ltd.

 Author: Marek Szyprowski <m.szyprowski@samsung.com>

 Common Clock Framework support for Exynos5 power-domain dependent clocks

/*

 * Pass the needed clock provider context and register sub-CMU clocks

 *

 * NOTE: This function has to be called from the main, OF_CLK_DECLARE-

 * initialized clock provider driver. This happens very early during boot

 * process. Then this driver, during core_initcall registers two platform

 * drivers: one which binds to the same device-tree node as OF_CLK_DECLARE

 * driver and second, for handling its per-domain child-devices. Those

 * platform drivers are bound to their devices a bit later in arch_initcall,

 * when OF-core populates all device-tree nodes.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2014 Samsung Electronics Co., Ltd.

 * Author: Rahul Sharma <rahul.sharma@samsung.com>

 *

 * Common Clock Framework support for Exynos5260 SoC.

/*

 * Applicable for all 2550 Type PLLS for Exynos5260, listed below

 * DISP_PLL, EGL_PLL, KFC_PLL, MEM_PLL, BUS_PLL, MEDIA_PLL, G3D_PLL.

/*

 * Applicable for 2650 Type PLL for AUD_PLL.

 CMU_AUD */

 CMU_DISP */

 CMU_EGL */

 CMU_FSYS */

 CMU_G2D */

 CMU_G3D */

 CMU_GSCL */

 CMU_ISP */

 CMU_KFC */

 CMU_MFC */

 CMU_MIF */

 CMU_PERI */

 CMU_TOP */

 fixed rate clocks generated inside the soc */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2017 Samsung Electronics Co., Ltd.

 * Author: Marek Szyprowski <m.szyprowski@samsung.com>

 *

 * Common Clock Framework support for Exynos4412 ISP module.

 Exynos4x12 specific registers, which belong to ISP power domain */

/*

 * Support for CMU save/restore across system suspends

 SPDX-License-Identifier: GPL-2.0

/*

 * Zynq UltraScale+ MPSoC clock controller

 *

 *  Copyright (C) 2016-2019 Xilinx

 *

 * Based on drivers/clk/zynq/clkc.c

 Flags for parents */

/**

 * struct clock_parent - Clock parent

 * @name:	Parent name

 * @id:		Parent clock ID

 * @flag:	Parent flags

/**

 * struct zynqmp_clock - Clock

 * @clk_name:		Clock name

 * @valid:		Validity flag of clock

 * @type:		Clock type (Output/External)

 * @node:		Clock topology nodes

 * @num_nodes:		Number of nodes present in topology

 * @parent:		Parent of clock

 * @num_parents:	Number of parents of clock

 * @clk_id:		Clock id

/**

 * zynqmp_is_valid_clock() - Check whether clock is valid or not

 * @clk_id:	Clock index

 *

 * Return: 1 if clock is valid, 0 if clock is invalid else error code

/**

 * zynqmp_get_clock_name() - Get name of clock from Clock index

 * @clk_id:	Clock index

 * @clk_name:	Name of clock

 *

 * Return: 0 on success else error code

/**

 * zynqmp_get_clock_type() - Get type of clock

 * @clk_id:	Clock index

 * @type:	Clock type: CLK_TYPE_OUTPUT or CLK_TYPE_EXTERNAL

 *

 * Return: 0 on success else error code

/**

 * zynqmp_pm_clock_get_num_clocks() - Get number of clocks in system

 * @nclocks:	Number of clocks in system/board.

 *

 * Call firmware API to get number of clocks.

 *

 * Return: 0 on success else error code.

/**

 * zynqmp_pm_clock_get_name() - Get the name of clock for given id

 * @clock_id:	ID of the clock to be queried

 * @response:	Name of the clock with the given id

 *

 * This function is used to get name of clock specified by given

 * clock ID.

 *

 * Return: Returns 0

/**

 * zynqmp_pm_clock_get_topology() - Get the topology of clock for given id

 * @clock_id:	ID of the clock to be queried

 * @index:	Node index of clock topology

 * @response:	Buffer used for the topology response

 *

 * This function is used to get topology information for the clock

 * specified by given clock ID.

 *

 * This API will return 3 node of topology with a single response. To get

 * other nodes, master should call same API in loop with new

 * index till error is returned. E.g First call should have

 * index 0 which will return nodes 0,1 and 2. Next call, index

 * should be 3 which will return nodes 3,4 and 5 and so on.

 *

 * Return: 0 on success else error+reason

/**

 * zynqmp_clk_register_fixed_factor() - Register fixed factor with the

 *					clock framework

 * @name:		Name of this clock

 * @clk_id:		Clock ID

 * @parents:		Name of this clock's parents

 * @num_parents:	Number of parents

 * @nodes:		Clock topology node

 *

 * Return: clock hardware to the registered clock

/**

 * zynqmp_pm_clock_get_parents() - Get the first 3 parents of clock for given id

 * @clock_id:	Clock ID

 * @index:	Parent index

 * @response:	Parents of the given clock

 *

 * This function is used to get 3 parents for the clock specified by

 * given clock ID.

 *

 * This API will return 3 parents with a single response. To get

 * other parents, master should call same API in loop with new

 * parent index till error is returned. E.g First call should have

 * index 0 which will return parents 0,1 and 2. Next call, index

 * should be 3 which will return parent 3,4 and 5 and so on.

 *

 * Return: 0 on success else error+reason

/**

 * zynqmp_pm_clock_get_attributes() - Get the attributes of clock for given id

 * @clock_id:	Clock ID

 * @response:	Clock attributes response

 *

 * This function is used to get clock's attributes(e.g. valid, clock type, etc).

 *

 * Return: 0 on success else error+reason

/**

 * __zynqmp_clock_get_topology() - Get topology data of clock from firmware

 *				   response data

 * @topology:		Clock topology

 * @response:		Clock topology data received from firmware

 * @nnodes:		Number of nodes

 *

 * Return: 0 on success else error+reason

/**

 * zynqmp_clock_get_topology() - Get topology of clock from firmware using

 *				 PM_API

 * @clk_id:		Clock index

 * @topology:		Clock topology

 * @num_nodes:		Number of nodes

 *

 * Return: 0 on success else error+reason

/**

 * __zynqmp_clock_get_parents() - Get parents info of clock from firmware

 *				   response data

 * @parents:		Clock parents

 * @response:		Clock parents data received from firmware

 * @nparent:		Number of parent

 *

 * Return: 0 on success else error+reason

/**

 * zynqmp_clock_get_parents() - Get parents info from firmware using PM_API

 * @clk_id:		Clock index

 * @parents:		Clock parents

 * @num_parents:	Total number of parents

 *

 * Return: 0 on success else error+reason

 Get parents from firmware */

/**

 * zynqmp_get_parent_list() - Create list of parents name

 * @np:			Device node

 * @clk_id:		Clock index

 * @parent_list:	List of parent's name

 * @num_parents:	Total number of parents

 *

 * Return: 0 on success else error+reason

/**

 * zynqmp_register_clk_topology() - Register clock topology

 * @clk_id:		Clock index

 * @clk_name:		Clock Name

 * @num_parents:	Total number of parents

 * @parent_names:	List of parents name

 *

 * Return: Returns either clock hardware or error+reason

		/*

		 * Clock name received from firmware is output clock name.

		 * Intermediate clock names are postfixed with type of clock.

/**

 * zynqmp_register_clocks() - Register clocks

 * @np:		Device node

 *

 * Return: 0 on success else error code

 get clock name, continue to next clock if name not found */

		/* Check if clock is valid and output clock.

		 * Do not register invalid or external clock.

 Get parents of clock*/

/**

 * zynqmp_get_clock_info() - Get clock information from firmware using PM_API

 skip query for Invalid clock */

 Get topology of all clock */

/**

 * zynqmp_clk_setup() - Setup the clock framework and register clocks

 * @np:		Device node

 *

 * Return: 0 on success else error code

 SPDX-License-Identifier: GPL-2.0

/*

 * Zynq UltraScale+ MPSoC clock controller

 *

 *  Copyright (C) 2016-2018 Xilinx

 *

 * Gated clock implementation

/**

 * struct zynqmp_clk_gate - gating clock

 * @hw:		handle between common and hardware-specific interfaces

 * @flags:	hardware-specific flags

 * @clk_id:	Id of clock

/**

 * zynqmp_clk_gate_enable() - Enable clock

 * @hw:		handle between common and hardware-specific interfaces

 *

 * Return: 0 on success else error code

/*

 * zynqmp_clk_gate_disable() - Disable clock

 * @hw:		handle between common and hardware-specific interfaces

/**

 * zynqmp_clk_gate_is_enabled() - Check clock state

 * @hw:		handle between common and hardware-specific interfaces

 *

 * Return: 1 if enabled, 0 if disabled else error code

/**

 * zynqmp_clk_register_gate() - Register a gate clock with the clock framework

 * @name:		Name of this clock

 * @clk_id:		Id of this clock

 * @parents:		Name of this clock's parents

 * @num_parents:	Number of parents

 * @nodes:		Clock topology node

 *

 * Return: clock hardware of the registered clock gate

 allocate the gate */

 struct clk_gate assignments */

 SPDX-License-Identifier: GPL-2.0

/*

 * Zynq UltraScale+ MPSoC PLL driver

 *

 *  Copyright (C) 2016-2018 Xilinx

/**

 * struct zynqmp_pll - PLL clock

 * @hw:		Handle between common and hardware-specific interfaces

 * @clk_id:	PLL clock ID

 * @set_pll_mode:	Whether an IOCTL_SET_PLL_FRAC_MODE request be sent to ATF

 2^16 */

/**

 * zynqmp_pll_get_mode() - Get mode of PLL

 * @hw:		Handle between common and hardware-specific interfaces

 *

 * Return: Mode of PLL

/**

 * zynqmp_pll_set_mode() - Set the PLL mode

 * @hw:		Handle between common and hardware-specific interfaces

 * @on:		Flag to determine the mode

/**

 * zynqmp_pll_round_rate() - Round a clock frequency

 * @hw:		Handle between common and hardware-specific interfaces

 * @rate:	Desired clock frequency

 * @prate:	Clock frequency of parent clock

 *

 * Return: Frequency closest to @rate the hardware can generate

 Enable the fractional mode if needed */

/**

 * zynqmp_pll_recalc_rate() - Recalculate clock frequency

 * @hw:			Handle between common and hardware-specific interfaces

 * @parent_rate:	Clock frequency of parent clock

 *

 * Return: Current clock frequency or 0 in case of error

/**

 * zynqmp_pll_set_rate() - Set rate of PLL

 * @hw:			Handle between common and hardware-specific interfaces

 * @rate:		Frequency of clock to be set

 * @parent_rate:	Clock frequency of parent clock

 *

 * Set PLL divider to set desired rate.

 *

 * Returns:            rate which is set on success else error code

/**

 * zynqmp_pll_is_enabled() - Check if a clock is enabled

 * @hw:		Handle between common and hardware-specific interfaces

 *

 * Return: 1 if the clock is enabled, 0 otherwise

/**

 * zynqmp_pll_enable() - Enable clock

 * @hw:		Handle between common and hardware-specific interfaces

 *

 * Return: 0 on success else error code

	/*

	 * Don't skip enabling clock if there is an IOCTL_SET_PLL_FRAC_MODE request

	 * that has been sent to ATF.

/**

 * zynqmp_pll_disable() - Disable clock

 * @hw:		Handle between common and hardware-specific interfaces

/**

 * zynqmp_clk_register_pll() - Register PLL with the clock framework

 * @name:		PLL name

 * @clk_id:		Clock ID

 * @parents:		Name of this clock's parents

 * @num_parents:	Number of parents

 * @nodes:		Clock topology node

 *

 * Return: clock hardware to the registered clock

 SPDX-License-Identifier: GPL-2.0

/*

 * Zynq UltraScale+ MPSoC mux

 *

 *  Copyright (C) 2016-2018 Xilinx

/*

 * DOC: basic adjustable multiplexer clock that cannot gate

 *

 * Traits of this clock:

 * prepare - clk_prepare only ensures that parents are prepared

 * enable - clk_enable only ensures that parents are enabled

 * rate - rate is only affected by parent switching.  No clk_set_rate support

 * parent - parent is adjustable through clk_set_parent

/**

 * struct zynqmp_clk_mux - multiplexer clock

 *

 * @hw:		handle between common and hardware-specific interfaces

 * @flags:	hardware-specific flags

 * @clk_id:	Id of clock

/**

 * zynqmp_clk_mux_get_parent() - Get parent of clock

 * @hw:		handle between common and hardware-specific interfaces

 *

 * Return: Parent index on success or number of parents in case of error

		/*

		 * clk_core_get_parent_by_index() takes num_parents as incorrect

		 * index which is exactly what I want to return here

/**

 * zynqmp_clk_mux_set_parent() - Set parent of clock

 * @hw:		handle between common and hardware-specific interfaces

 * @index:	Parent index

 *

 * Return: 0 on success else error+reason

/**

 * zynqmp_clk_register_mux() - Register a mux table with the clock

 *			       framework

 * @name:		Name of this clock

 * @clk_id:		Id of this clock

 * @parents:		Name of this clock's parents

 * @num_parents:	Number of parents

 * @nodes:		Clock topology node

 *

 * Return: clock hardware of the registered clock mux

 SPDX-License-Identifier: GPL-2.0

/*

 * Zynq UltraScale+ MPSoC Divider support

 *

 *  Copyright (C) 2016-2019 Xilinx

 *

 * Adjustable divider clock implementation

/*

 * DOC: basic adjustable divider clock that cannot gate

 *

 * Traits of this clock:

 * prepare - clk_prepare only ensures that parents are prepared

 * enable - clk_enable only ensures that parents are enabled

 * rate - rate is adjustable.  clk->rate = ceiling(parent->rate / divisor)

 * parent - fixed parent.  No clk_set_parent support

 has a fractional parent */

 has a fractional parent in custom type flag */

/**

 * struct zynqmp_clk_divider - adjustable divider clock

 * @hw:		handle between common and hardware-specific interfaces

 * @flags:	Hardware specific flags

 * @is_frac:	The divider is a fractional divider

 * @clk_id:	Id of clock

 * @div_type:	divisor type (TYPE_DIV1 or TYPE_DIV2)

 * @max_div:	maximum supported divisor (fetched from firmware)

/**

 * zynqmp_clk_divider_recalc_rate() - Recalc rate of divider clock

 * @hw:			handle between common and hardware-specific interfaces

 * @parent_rate:	rate of parent clock

 *

 * Return: 0 on success else error+reason

/**

 * zynqmp_clk_divider_round_rate() - Round rate of divider clock

 * @hw:			handle between common and hardware-specific interfaces

 * @rate:		rate of clock to be set

 * @prate:		rate of parent clock

 *

 * Return: 0 on success else error+reason

 if read only, just return current value */

	/*

	 * In case of two divisors, compute best divider values and return

	 * divider2 value based on compute value. div1 will  be automatically

	 * set to optimum based on required total divider value.

/**

 * zynqmp_clk_divider_set_rate() - Set rate of divider clock

 * @hw:			handle between common and hardware-specific interfaces

 * @rate:		rate of clock to be set

 * @parent_rate:	rate of parent clock

 *

 * Return: 0 on success else error+reason

/**

 * zynqmp_clk_get_max_divisor() - Get maximum supported divisor from firmware.

 * @clk_id:		Id of clock

 * @type:		Divider type

 *

 * Return: Maximum divisor of a clock if query data is successful

 *	   U16_MAX in case of query data is not success

	/*

	 * To maintain backward compatibility return maximum possible value

	 * (0xFFFF) if query for max divisor is not successful.

/**

 * zynqmp_clk_register_divider() - Register a divider clock

 * @name:		Name of this clock

 * @clk_id:		Id of clock

 * @parents:		Name of this clock's parents

 * @num_parents:	Number of parents

 * @nodes:		Clock topology node

 *

 * Return: clock hardware to registered clock divider

 allocate the divider */

 struct clk_divider assignments */

	/*

	 * To achieve best possible rate, maximum limit of divider is required

	 * while computation.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2020 SiFive, Inc.

 * Copyright (C) 2020 Zong Li

 PRCI integration data for each WRPLL instance */

 Linux clock framework integration */

 List of clock controls provided by the PRCI */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2020 SiFive, Inc.

 * Copyright (C) 2020 Zong Li

/*

 * Private functions

/**

 * __prci_readl() - read from a PRCI register

 * @pd: PRCI context

 * @offs: register offset to read from (in bytes, from PRCI base address)

 *

 * Read the register located at offset @offs from the base virtual

 * address of the PRCI register target described by @pd, and return

 * the value to the caller.

 *

 * Context: Any context.

 *

 * Return: the contents of the register described by @pd and @offs.

 WRPLL-related private functions */

/**

 * __prci_wrpll_unpack() - unpack WRPLL configuration registers into parameters

 * @c: ptr to a struct wrpll_cfg record to write config into

 * @r: value read from the PRCI PLL configuration register

 *

 * Given a value @r read from an FU740 PRCI PLL configuration register,

 * split it into fields and populate it into the WRPLL configuration record

 * pointed to by @c.

 *

 * The COREPLLCFG0 macros are used below, but the other *PLLCFG0 macros

 * have the same register layout.

 *

 * Context: Any context.

 external feedback mode not supported */

/**

 * __prci_wrpll_pack() - pack PLL configuration parameters into a register value

 * @c: pointer to a struct wrpll_cfg record containing the PLL's cfg

 *

 * Using a set of WRPLL configuration values pointed to by @c,

 * assemble a PRCI PLL configuration register value, and return it to

 * the caller.

 *

 * Context: Any context.  Caller must ensure that the contents of the

 *          record pointed to by @c do not change during the execution

 *          of this function.

 *

 * Returns: a value suitable for writing into a PRCI PLL configuration

 *          register

 external feedback mode not supported */

/**

 * __prci_wrpll_read_cfg0() - read the WRPLL configuration from the PRCI

 * @pd: PRCI context

 * @pwd: PRCI WRPLL metadata

 *

 * Read the current configuration of the PLL identified by @pwd from

 * the PRCI identified by @pd, and store it into the local configuration

 * cache in @pwd.

 *

 * Context: Any context.  Caller must prevent the records pointed to by

 *          @pd and @pwd from changing during execution.

/**

 * __prci_wrpll_write_cfg0() - write WRPLL configuration into the PRCI

 * @pd: PRCI context

 * @pwd: PRCI WRPLL metadata

 * @c: WRPLL configuration record to write

 *

 * Write the WRPLL configuration described by @c into the WRPLL

 * configuration register identified by @pwd in the PRCI instance

 * described by @c.  Make a cached copy of the WRPLL's current

 * configuration so it can be used by other code.

 *

 * Context: Any context.  Caller must prevent the records pointed to by

 *          @pd and @pwd from changing during execution.

/**

 * __prci_wrpll_write_cfg1() - write Clock enable/disable configuration

 * into the PRCI

 * @pd: PRCI context

 * @pwd: PRCI WRPLL metadata

 * @enable: Clock enable or disable value

/*

 * Linux clock framework integration

 *

 * See the Linux clock framework documentation for more information on

 * these functions.

 TLCLKSEL clock integration */

 HFPCLK clock integration */

/*

 * Core clock mux control

/**

 * sifive_prci_coreclksel_use_hfclk() - switch the CORECLK mux to output HFCLK

 * @pd: struct __prci_data * for the PRCI containing the CORECLK mux reg

 *

 * Switch the CORECLK mux to the HFCLK input source; return once complete.

 *

 * Context: Any context.  Caller must prevent concurrent changes to the

 *          PRCI_CORECLKSEL_OFFSET register.

 barrier */

/**

 * sifive_prci_coreclksel_use_corepll() - switch the CORECLK mux to output

 * COREPLL

 * @pd: struct __prci_data * for the PRCI containing the CORECLK mux reg

 *

 * Switch the CORECLK mux to the COREPLL output clock; return once complete.

 *

 * Context: Any context.  Caller must prevent concurrent changes to the

 *          PRCI_CORECLKSEL_OFFSET register.

 barrier */

/**

 * sifive_prci_coreclksel_use_final_corepll() - switch the CORECLK mux to output

 * FINAL_COREPLL

 * @pd: struct __prci_data * for the PRCI containing the CORECLK mux reg

 *

 * Switch the CORECLK mux to the final COREPLL output clock; return once

 * complete.

 *

 * Context: Any context.  Caller must prevent concurrent changes to the

 *          PRCI_CORECLKSEL_OFFSET register.

 barrier */

/**

 * sifive_prci_corepllsel_use_dvfscorepll() - switch the COREPLL mux to

 * output DVFS_COREPLL

 * @pd: struct __prci_data * for the PRCI containing the COREPLL mux reg

 *

 * Switch the COREPLL mux to the DVFSCOREPLL output clock; return once complete.

 *

 * Context: Any context.  Caller must prevent concurrent changes to the

 *          PRCI_COREPLLSEL_OFFSET register.

 barrier */

/**

 * sifive_prci_corepllsel_use_corepll() - switch the COREPLL mux to

 * output COREPLL

 * @pd: struct __prci_data * for the PRCI containing the COREPLL mux reg

 *

 * Switch the COREPLL mux to the COREPLL output clock; return once complete.

 *

 * Context: Any context.  Caller must prevent concurrent changes to the

 *          PRCI_COREPLLSEL_OFFSET register.

 barrier */

/**

 * sifive_prci_hfpclkpllsel_use_hfclk() - switch the HFPCLKPLL mux to

 * output HFCLK

 * @pd: struct __prci_data * for the PRCI containing the HFPCLKPLL mux reg

 *

 * Switch the HFPCLKPLL mux to the HFCLK input source; return once complete.

 *

 * Context: Any context.  Caller must prevent concurrent changes to the

 *          PRCI_HFPCLKPLLSEL_OFFSET register.

 barrier */

/**

 * sifive_prci_hfpclkpllsel_use_hfpclkpll() - switch the HFPCLKPLL mux to

 * output HFPCLKPLL

 * @pd: struct __prci_data * for the PRCI containing the HFPCLKPLL mux reg

 *

 * Switch the HFPCLKPLL mux to the HFPCLKPLL output clock; return once complete.

 *

 * Context: Any context.  Caller must prevent concurrent changes to the

 *          PRCI_HFPCLKPLLSEL_OFFSET register.

 barrier */

 PCIE AUX clock APIs for enable, disable. */

 barrier */

 barrier */

/**

 * __prci_register_clocks() - register clock controls in the PRCI

 * @dev: Linux struct device

 * @pd: The pointer for PRCI per-device instance data

 * @desc: The pointer for the information of clocks of each SoCs

 *

 * Register the list of clock controls described in __prci_init_clocks[] with

 * the Linux clock framework.

 *

 * Return: 0 upon success or a negative error code upon failure.

 Register PLLs */

/**

 * sifive_prci_probe() - initialize prci data and check parent count

 * @pdev: platform device pointer for the prci

 *

 * Return: 0 upon success or a negative error code upon failure.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2018-2019 SiFive, Inc.

 * Copyright (C) 2018-2019 Wesley Terpstra

 * Copyright (C) 2018-2019 Paul Walmsley

 * Copyright (C) 2020 Zong Li

 *

 * The FU540 PRCI implements clock and reset control for the SiFive

 * FU540-C000 chip.  This driver assumes that it has sole control

 * over all PRCI resources.

 *

 * This driver is based on the PRCI driver written by Wesley Terpstra:

 * https://github.com/riscv/riscv-linux/commit/999529edf517ed75b56659d456d221b2ee56bb60

 *

 * References:

 * - SiFive FU540-C000 manual v1p0, Chapter 7 "Clocking and Reset"

 PRCI integration data for each WRPLL instance */

 Linux clock framework integration */

 List of clock controls provided by the PRCI */

 SPDX-License-Identifier: GPL-2.0

/*

 * MStar MSC313 MPLL driver

 *

 * Copyright (C) 2020 Daniel Palmer <daniel@thingy.jp>

/*

 * pxa910 clock framework source file

 *

 * Copyright (C) 2012 Marvell

 * Chao Xie <xiechao.mail@gmail.com>

 *

 * This file is licensed under the terms of the GNU General Public

 * License version 2. This program is licensed "as is" without any

 * warranty of any kind, whether express or implied.

14.745MHZ */

 The gate clocks has mux parent. */

 The gate clocks has mux parent. */

 The gate clocks has mux parent. */

 SPDX-License-Identifier: GPL-2.0

/*

 * mmp APB clock operation source file

 *

 * Copyright (C) 2012 Marvell

 * Chao Xie <xiechao.mail@gmail.com>

 *

 * This file is licensed under the terms of the GNU General Public

 * License version 2. This program is licensed "as is" without any

 * warranty of any kind, whether express or implied.

 Common APB clock register bit definitions */

 APB Bus Clock Enable */

 Functional Clock Enable */

 Reset Generation */

 Reset Generation */

	/*

	 * It may share same register as MUX clock,

	 * and it will impact FNCLK enable. Spinlock is needed

/*

 * mmp2 clock framework source file

 *

 * Copyright (C) 2012 Marvell

 * Chao Xie <xiechao.mail@gmail.com>

 *

 * This file is licensed under the terms of the GNU General Public

 * License version 2. This program is licensed "as is" without any

 * warranty of any kind, whether express or implied.

14.745MHZ */

19.23MHZ */

/*

 * mmp factor clock operation source file

 *

 * Copyright (C) 2012 Marvell

 * Chao Xie <xiechao.mail@gmail.com>

 *

 * This file is licensed under the terms of the GNU General Public

 * License version 2. This program is licensed "as is" without any

 * warranty of any kind, whether express or implied.

/*

 * It is M/N clock

 *

 * Fout from synthesizer can be given from two equations:

 * numerator/denominator = Fin / (Fout * factor)

 calculate numerator */

 calculate denominator */

 Configures new clock rate*/

 calculate numerator */

 calculate denominator */

 struct clk_aux assignments */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * MMP PLL clock rate calculation

 *

 * Copyright (C) 2020 Lubomir Rintel <lkundrak@v3.sk>

 Some PLLs, if not software controlled, output default clock. */

 MMP3 clock rate calculation */

 MMP2 clock rate calculation */

/*

 * mmp AXI peripharal clock operation source file

 *

 * Copyright (C) 2012 Marvell

 * Chao Xie <xiechao.mail@gmail.com>

 *

 * This file is licensed under the terms of the GNU General Public

 * License version 2. This program is licensed "as is" without any

 * warranty of any kind, whether express or implied.

/*

 * pxa1928 clock framework source file

 *

 * Copyright (C) 2015 Linaro, Ltd.

 * Rob Herring <robh@kernel.org>

 *

 * Based on drivers/clk/mmp/clk-of-mmp2.c:

 * Copyright (C) 2012 Marvell

 * Chao Xie <xiechao.mail@gmail.com>

 *

 * This file is licensed under the terms of the GNU General Public

 * License version 2. This program is licensed "as is" without any

 * warranty of any kind, whether express or implied.

58.5MHZ */

26MHZ */

 The gate clocks has mux parent. */

 The gate clocks has mux parent. */

/*

 * mmp mix(div and mux) clock operation source file

 *

 * Copyright (C) 2014 Marvell

 * Chao Xie <chao.xie@marvell.com>

 *

 * This file is licensed under the terms of the GNU General Public

 * License version 2. This program is licensed "as is" without any

 * warranty of any kind, whether express or implied.

/*

 * The mix clock is a clock combined mux and div type clock.

 * Because the div field and mux field need to be set at same

 * time, we can not divide it into 2 types of clock

/*

 * pxa910 clock framework source file

 *

 * Copyright (C) 2012 Marvell

 * Chao Xie <xiechao.mail@gmail.com>

 *

 * This file is licensed under the terms of the GNU General Public

 * License version 2. This program is licensed "as is" without any

 * warranty of any kind, whether express or implied.

14.745MHZ */

/*

 * pxa168 clock framework source file

 *

 * Copyright (C) 2012 Marvell

 * Chao Xie <xiechao.mail@gmail.com>

 *

 * This file is licensed under the terms of the GNU General Public

 * License version 2. This program is licensed "as is" without any

 * warranty of any kind, whether express or implied.

14.745MHZ */

/*

 * mmp2 clock framework source file

 *

 * Copyright (C) 2012 Marvell

 * Chao Xie <xiechao.mail@gmail.com>

 * Copyright (C) 2020 Lubomir Rintel <lkundrak@v3.sk>

 *

 * This file is licensed under the terms of the GNU General Public

 * License version 2. This program is licensed "as is" without any

 * warranty of any kind, whether express or implied.

 MMP3 specific below */

14.745MHZ */

19.23MHZ */

  2.0480 MHz */

  2.8224 MHz */

  4.0960 MHz */

  5.6448 MHz */

  8.1920 MHz */

 11.2896 MHz */

 12.2880 MHz */

 22.5792 MHz */

 24.5760 MHz */

 The gate clocks has mux parent. */

 The gate clocks has mux parent. */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * MMP PMU power island support

 *

 * Copyright (C) 2020 Lubomir Rintel <lkundrak@v3.sk>

 Turn on the power island */

 Disable isolation */

 Some blocks need to be reset after a power up */

 Turn off and isolate the the power island. */

/*

 * mmp gate clock operation source file

 *

 * Copyright (C) 2014 Marvell

 * Chao Xie <chao.xie@marvell.com>

 *

 * This file is licensed under the terms of the GNU General Public

 * License version 2. This program is licensed "as is" without any

 * warranty of any kind, whether express or implied.

/*

 * Some clocks will have mutiple bits to enable the clocks, and

 * the bits to disable the clock is not same as enabling bits.

 Need delay 2 cycles. */

 allocate the gate */

 struct clk_gate assignments */

 SPDX-License-Identifier: GPL-2.0

/*

 * pxa168 clock framework source file

 *

 * Copyright (C) 2012 Marvell

 * Chao Xie <xiechao.mail@gmail.com>

 *

 * This file is licensed under the terms of the GNU General Public

 * License version 2. This program is licensed "as is" without any

 * warranty of any kind, whether express or implied.

14.745MHZ */

 The gate clocks has mux parent. */

 The gate clocks has mux parent. */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * MMP Audio Clock Controller driver

 *

 * Copyright (C) 2020 Lubomir Rintel <lkundrak@v3.sk>

 Audio Controller Registers */

 SSPA Audio Control Register */

 SSPA Audio PLL Control 0 Register */

 SSPA Audio PLL Control 1 Register */

 Must be last */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Hisilicon clock driver

 *

 * Copyright (c) 2012-2013 Hisilicon Limited.

 * Copyright (c) 2012-2013 Linaro Limited.

 *

 * Author: Haojian Zhuang <haojian.zhuang@linaro.org>

 *	   Xin Li <li.xin@linaro.org>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Hi6220 stub clock driver

 *

 * Copyright (c) 2015 Hisilicon Limited.

 * Copyright (c) 2015 Linaro Limited.

 *

 * Author: Leo Yan <leo.yan@linaro.org>

 Stub clocks id */

 Mailbox message */

 CPU dynamic frequency scaling */

 set the frequency in sram */

 compound mailbox message */

 check the constrained frequency */

 check the supported maximum frequency */

 calculate the real maximum frequency */

 convert from kHz to Hz */

 kHz */

 kHz */

 convert from kHz to Hz */

 Use mailbox client with blocking mode */

 Allocate mailbox channel */

 initialize buffer to zero */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Hi3519 Clock Driver

 *

 * Copyright (c) 2015-2016 HiSilicon Technologies Co., Ltd.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Hisilicon Hi6220 clock driver

 *

 * Copyright (c) 2015 Hisilicon Limited.

 *

 * Author: Bintian Wang <bintian.wang@huawei.com>

 clocks in AO (always on) controller */

 Allow reset driver to probe as well */

 clocks in sysctrl */

 clocks in media controller */

 clocks in pmctrl */

 clocks in acpu */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Hisilicon Hi3620 clock driver

 *

 * Copyright (c) 2012-2013 Hisilicon Limited.

 * Copyright (c) 2012-2013 Linaro Limited.

 *

 * Author: Haojian Zhuang <haojian.zhuang@linaro.org>

 *	   Xin Li <li.xin@linaro.org>

 clock parent list */

 share axi parent */

 fixed rate clocks */

 fixed factor clocks */

 max is 180M */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Hisilicon HiP04 clock driver

 *

 * Copyright (c) 2013-2014 Hisilicon Limited.

 * Copyright (c) 2013-2014 Linaro Limited.

 *

 * Author: Haojian Zhuang <haojian.zhuang@linaro.org>

 fixed rate clocks */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2001-2021, Huawei Tech. Co., Ltd.

 * Author: chenjun <chenjun14@huawei.com>

 *

 * Copyright (c) 2018, Linaro Ltd.

 * Author: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>

 crgctrl */

 clk_pmuctrl */

 clk_pctrl */

 clk_sctrl */

 clk_iomcu */

 clk_media1 */

 clk_media2 */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Hi3516CV300 Clock and Reset Generator Driver

 *

 * Copyright (c) 2016 HiSilicon Technologies Co., Ltd.

 hi3516CV300 core CRG */

 hi3516CV300 sysctrl CRG */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2014 Linaro Ltd.

 * Copyright (c) 2014 Hisilicon Limited.

 sfc */

 sdio0 */

 sdio1 */

 gsf */

 wdg0 */

 I2C */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Hisilicon clock driver

 *

 * Copyright (c) 2013-2017 Hisilicon Limited.

 * Copyright (c) 2017 Linaro Limited.

 *

 * Author: Kai Zhao <zhaokai1@hisilicon.com>

 *	    Tao Wang <kevin.wangtao@hisilicon.com>

 *	    Leo Yan <leo.yan@linaro.org>

	/*

	 * LPM3 writes back the CPU frequency in shared SRAM so read

	 * back the frequency.

	/*

	 * LPM3 handles rate rounding so just return whatever

	 * rate is requested.

 Use mailbox client without blocking */

 Allocate mailbox channel */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Hisilicon hi6220 SoC divider clock driver

 *

 * Copyright (c) 2015 Hisilicon Limited.

 *

 * Author: Bintian Wang <bintian.wang@huawei.com>

/**

 * struct hi6220_clk_divider - divider clock for hi6220

 *

 * @hw:		handle between common and hardware-specific interfaces

 * @reg:	register containing divider

 * @shift:	shift to the divider bit field

 * @width:	width of the divider bit field

 * @mask:	mask for setting divider rate

 * @table:	the div table that the divider supports

 * @lock:	register lock

 allocate the divider */

 Init the divider table */

 struct hi6220_clk_divider assignments */

 register the clock */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Hisilicon clock separated gate driver

 *

 * Copyright (c) 2012-2013 Hisilicon Limited.

 * Copyright (c) 2012-2013 Linaro Limited.

 *

 * Author: Haojian Zhuang <haojian.zhuang@linaro.org>

 *	   Xin Li <li.xin@linaro.org>

 clock separated gate register offset */

 enable register */

 bits in enable/disable register */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) 2016-2017 Linaro Ltd.

 * Copyright (c) 2016-2017 HiSilicon Technologies Co., Ltd.

 crgctrl */

	/*

	 * clk_gate_ufs_subsys is a system bus clock, mark it as critical

	 * clock and keep it on for system suspend and resume.

 clk_pmuctrl */

 pmu register need shift 2 bits */

 clk_pctrl */

 clk_sctrl */

 clk_iomcu */

 clk_crgctrl_data initialization failed */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2017 HiSilicon Technologies Co., Ltd.

 *

 * Simple HiSilicon phase clock implementation.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Hisilicon Hi3559A clock driver

 *

 * Copyright (c) 2019-2020, Huawei Tech. Co., Ltd.

 *

 * Author: Dongjiu Geng <gengdongjiu@huawei.com>

 soc clk config */

 rate = 24000000 * (fbdiv + frac / (1<<24) ) / refdiv  */

 shub mux clk */

 shub div clk */

 shub gate clk */

 SSP: 192M/2 */

 UART: 192M/8 */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Hi3798CV200 Clock and Reset Generator Driver

 *

 * Copyright (c) 2016 HiSilicon Technologies Co., Ltd.

 hi3798CV200 core CRG */

 UART */

 I2C */

 SPI */

 SDIO */

 EMMC */

 PCIE*/

 Ethernet */

 COMBPHY0 */

 COMBPHY1 */

 USB2 */

 USB3 */

 hisi_phase_clock is resource managed */

 hi3798CV200 sysctrl CRG */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Hisilicon Reset Controller Driver

 *

 * Copyright (c) 2015-2016 HiSilicon Technologies Co., Ltd.

 SPDX-License-Identifier: GPL-2.0+



 OWL divider clock driver



 Copyright (c) 2014 Actions Semi Inc.

 Author: David Liu <liuwei@actions-semi.com>



 Copyright (c) 2018 Linaro Ltd.

 Author: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>

 SPDX-License-Identifier: GPL-2.0+

/*

 * Actions Semi Owl S500 SoC clock driver

 *

 * Copyright (c) 2014 Actions Semi Inc.

 * Author: David Liu <liuwei@actions-semi.com>

 *

 * Copyright (c) 2018 Linaro Ltd.

 * Author: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>

 *

 * Copyright (c) 2018 LSI-TEC - Caninos Loucos

 * Author: Edgar Bernardi Righi <edgar.righi@lsitec.org.br>

 pll clocks */

 bit0 ~ 4 */

 bit8: /128 */

 mux clock */

 gate clocks */

 divider clocks */

 factor clocks */

 composite clocks */

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0+



 OWL composite clock driver



 Copyright (c) 2014 Actions Semi Inc.

 Author: David Liu <liuwei@actions-semi.com>



 Copyright (c) 2018 Linaro Ltd.

 Author: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>

	/*

	 * We must report success but we can do so unconditionally because

	 * owl_comp_fix_fact_round_rate returns values that ensure this call is

	 * a nop.

 mux_ops */

 gate_ops */

 div_ops */

 mux_ops */

 gate_ops */

 fact_ops */

 gate_ops */

 fix_fact_ops */

 mux_ops */

 gate_ops */

 SPDX-License-Identifier: GPL-2.0-or-later



 Actions Semi Owl SoCs Reset Management Unit driver



 Copyright (c) 2018 Linaro Ltd.

 Author: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>

	/*

	 * The reset control API expects 0 if reset is not asserted,

	 * which is the opposite of what our hardware uses.

 SPDX-License-Identifier: GPL-2.0+



 OWL pll clock driver



 Copyright (c) 2014 Actions Semi Inc.

 Author: David Liu <liuwei@actions-semi.com>



 Copyright (c) 2018 Linaro Ltd.

 Author: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>

 fixed frequency */

 fixed frequency */

 fixed frequency */

 SPDX-License-Identifier: GPL-2.0+

/*

 * Actions Semi S700 clock driver

 *

 * Copyright (c) 2014 Actions Semi Inc.

 * Author: David Liu <liuwei@actions-semi.com>

 *

 * Author: Pathiban Nallathambi <pn@denx.de>

 * Author: Saravanan Sekar <sravanhome@gmail.com>

 pll clocks */

 mux clocks */

 bit0 ~ 4 */

 bit8: /128 */

 bit0 ~ 3 */

 bit8: /7 */

 divider clocks */

 gate clocks */

 composite clocks */

CMU_AUDIOPLL 24,1 unused*/

 for bluetooth pcm communication */

	/*

	 * FIXME: Reset controller registration should be moved to

	 * common code, once all SoCs of Owl family supports it.

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0+



 OWL common clock driver



 Copyright (c) 2014 Actions Semi Inc.

 Author: David Liu <liuwei@actions-semi.com>



 Copyright (c) 2018 Linaro Ltd.

 Author: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>

 SPDX-License-Identifier: GPL-2.0+



 OWL mux clock driver



 Copyright (c) 2014 Actions Semi Inc.

 Author: David Liu <liuwei@actions-semi.com>



 Copyright (c) 2018 Linaro Ltd.

 Author: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>

 SPDX-License-Identifier: GPL-2.0+



 OWL gate clock driver



 Copyright (c) 2014 Actions Semi Inc.

 Author: David Liu <liuwei@actions-semi.com>



 Copyright (c) 2018 Linaro Ltd.

 Author: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>

 SPDX-License-Identifier: GPL-2.0+



 OWL S900 SoC clock driver



 Copyright (c) 2014 Actions Semi Inc.

 Author: David Liu <liuwei@actions-semi.com>



 Copyright (c) 2018 Linaro Ltd.

 Author: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>

 pll clocks */

 mux clocks */

 divider clocks */

 bit0 ~ 4 */

 bit8: /128 */

 factor clocks */

 gate clocks */

 composite clocks */

/*

 * pwm2 may be for backlight, do not gate it

 * even it is "unused", because it may be

 * enabled at boot stage, and in kernel, driver

 * has no effective method to know the real status,

 * so, the best way is keeping it as what it was.

	/*

	 * FIXME: Reset controller registration should be moved to

	 * common code, once all SoCs of Owl family supports it.

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0+



 OWL factor clock driver



 Copyright (c) 2014 Actions Semi Inc.

 Author: David Liu <liuwei@actions-semi.com>



 Copyright (c) 2018 Linaro Ltd.

 Author: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>

			/*

			 * It's the most ideal case if the requested rate can be

			 * divided from parent clock without any need to change

			 * parent rate, so return the divider immediately.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2014 Marvell Technology Group Ltd.

 *

 * Alexandre Belloni <alexandre.belloni@free-electrons.com>

 * Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>

 BG2Q CPU PLL is not part of global registers */

 overwrite default clock names with DT provided ones */

 simple register PLLs */

 TODO: add BG2Q AVPLL */

	/*

	 * TODO: add reference clock bypass switches:

	 * memPLLSWBypass, cpuPLLSWBypass, and sysPLLSWBypass

 clock divider cells */

 clock gate cells */

 cpuclk divider is fixed to 1 */

 twdclk is derived from cpu/3 */

 check for errors on leaf clocks */

 register clk-provider */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2014 Marvell Technology Group Ltd.

 *

 * Alexandre Belloni <alexandre.belloni@free-electrons.com>

 * Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>

/*

 * The output frequency formula for the pll is:

 * clkout = fbdiv / refdiv * parent / vcodiv

 copy pll_map to allow __initconst */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2014 Marvell Technology Group Ltd.

 *

 * Alexandre Belloni <alexandre.belloni@free-electrons.com>

 * Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>

/*

 * Clock dividers in Berlin2 SoCs comprise a complex cell to select

 * input pll and divider. The virtual structure as it is used in Marvell

 * BSP code can be seen as:

 *

 *                      +---+

 * pll0 --------------->| 0 |                   +---+

 *           +---+      |(B)|--+--------------->| 0 |      +---+

 * pll1.0 -->| 0 |  +-->| 1 |  |   +--------+   |(E)|----->| 0 |   +---+

 * pll1.1 -->| 1 |  |   +---+  +-->|(C) 1:M |-->| 1 |      |(F)|-->|(G)|->

 * ...    -->|(A)|--+          |   +--------+   +---+  +-->| 1 |   +---+

 * ...    -->|   |             +-->|(D) 1:3 |----------+   +---+

 * pll1.N -->| N |                 +---------

 *           +---+

 *

 * (A) input pll clock mux controlled by               <PllSelect[1:n]>

 * (B) input pll bypass mux controlled by              <PllSwitch>

 * (C) programmable clock divider controlled by        <Select[1:n]>

 * (D) constant div-by-3 clock divider

 * (E) programmable clock divider bypass controlled by <Switch>

 * (F) constant div-by-3 clock mux controlled by       <D3Switch>

 * (G) clock gate controlled by                        <Enable>

 *

 * For whatever reason, above control signals come in two flavors:

 * - single register dividers with all bits in one register

 * - shared register dividers with bits spread over multiple registers

 *   (including signals for the same cell spread over consecutive registers)

 *

 * Also, clock gate and pll mux is not available on every div cell, so

 * we have to deal with those, too. We reuse common clock composite driver

 * for it.

 index == 0 is PLL_SWITCH */

 index > 0 is PLL_SELECT */

 PLL_SWITCH == 0 is index 0 */

 constant divide-by-3 (dominant) */

 divider can be bypassed with DIV_SWITCH == 0 */

 clock divider determined by DIV_SELECT */

 copy div_map to allow __initconst */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2014 Marvell Technology Group Ltd.

 *

 * Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>

 * Alexandre Belloni <alexandre.belloni@free-electrons.com>

/*

 * BG2/BG2CD SoCs have the following audio/video I/O units:

 *

 * audiohd: HDMI TX audio

 * audio0:  7.1ch TX

 * audio1:  2ch TX

 * audio2:  2ch RX

 * audio3:  SPDIF TX

 * video0:  HDMI video

 * video1:  Secondary video

 * video2:  SD auxiliary video

 *

 * There are no external audio clocks (ACLKI0, ACLKI1) and

 * only one external video clock (VCLKI0).

 *

 * Currently missing bits and pieces:

 * - audio_fast_pll is unknown

 * - audiohd_pll is unknown

 * - video0_pll is unknown

 * - audio[023], audiohd parent pll is assumed to be audio_fast_pll

 *

 overwrite default clock names with DT provided ones */

 simple register PLLs */

 audio/video VCOs */

 reference clock bypass switches */

 clock muxes */

 clock divider cells */

 clock gate cells */

 twdclk is derived from cpu/3 */

 check for errors on leaf clocks */

 register clk-provider */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2014 Marvell Technology Group Ltd.

 *

 * Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>

 * Alexandre Belloni <alexandre.belloni@free-electrons.com>

/*

 * Berlin2 SoCs comprise up to two PLLs called AVPLL built upon a

 * VCO with 8 channels each, channel 8 is the odd-one-out and does

 * not provide mul/div.

 *

 * Unfortunately, its registers are not named but just numbered. To

 * get in at least some kind of structure, we split each AVPLL into

 * the VCOs and each channel into separate clock drivers.

 *

 * Also, here and there the VCO registers are a bit different with

 * respect to bit shifts. Make sure to add a comment for those.

 BG2/BG2CDs VCO_B has an additional shift of 4 for its VCO_CTRL0 reg */

 PLL Charge Pump Current = 10uA * (x + 1) */

 AVPLL VCO frequency: Fvco = (Fref / refdiv) * fbdiv */

	/*

	 * Fch = (Fref * sync2) /

	 *    (sync1 * div_hdmi * div_av1 * div_av2 * div_av3)

 BG2/BG2CDs SYNC1 reg on AVPLL_B channel 1 is shifted by 4 */

 Channel 8 has no dividers */

	/*

	 * HDMI divider start at VCO_CTRL11, bit 7; MSB is enable, lower 2 bit

	 * determine divider.

	/*

	 * AV1 divider start at VCO_CTRL11, bit 28; MSB is enable, lower 2 bit

	 * determine divider.

	/*

	 * AV2 divider start at VCO_CTRL12, bit 18; each 7 bits wide,

	 * zero is not a valid value.

	/*

	 * AV3 divider start at VCO_CTRL14, bit 7; each 4 bits wide.

	 * AV2/AV3 form a fractional divider, where only specfic values for AV3

	 * are allowed. AV3 != 0 divides by AV2/2, AV3=0 is bypass.

/*

 * Another nice quirk:

 * On some production SoCs, AVPLL channels are scrambled with respect

 * to the channel numbering in the registers but still referenced by

 * their original channel numbers. We deal with it by having a flag

 * and a translation table for the index.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Clock driver for Keystone 2 based devices

 *

 * Copyright (C) 2013 Texas Instruments.

 *	Murali Karicheri <m-karicheri2@ti.com>

 *	Santosh Shilimkar <santosh.shilimkar@ti.com>

 PSC register offsets */

 PSC module states */

 Maximum timeout to bail out state transition for module */

/**

 * struct clk_psc_data - PSC data

 * @control_base: Base address for a PSC control

 * @domain_base: Base address for a PSC domain

 * @domain_id: PSC domain id number

/**

 * struct clk_psc - PSC clock structure

 * @hw: clk_hw for the psc

 * @psc_data: PSC driver specific data

 * @lock: Spinlock used by the driver

 For disable, we always put the module in local reset */

/**

 * clk_register_psc - register psc clock

 * @dev: device that is registering this clock

 * @name: name of this clock

 * @parent_name: name of clock's parent

 * @psc_data: platform data to configure this clock

 * @lock: spinlock used by this clock

/**

 * of_psc_clk_init - initialize psc clock through DT

 * @node: device tree node for this clock

 * @lock: spinlock used by this clock

 Domain transition registers at fixed address space of domain_id 0 */

/**

 * of_keystone_psc_clk_init - initialize psc clock through DT

 * @node: device tree node for this clock

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * PLL clock driver for Keystone devices

 *

 * Copyright (C) 2013 Texas Instruments Inc.

 *	Murali Karicheri <m-karicheri2@ti.com>

 *	Santosh Shilimkar <santosh.shilimkar@ti.com>

/**

 * struct clk_pll_data - pll data structure

 * @has_pllctrl: If set to non zero, lower 6 bits of multiplier is in pllm

 *	register of pll controller, else it is in the pll_ctrl0((bit 11-6)

 * @phy_pllm: Physical address of PLLM in pll controller. Used when

 *	has_pllctrl is non zero.

 * @phy_pll_ctl0: Physical address of PLL ctrl0. This could be that of

 *	Main PLL or any other PLLs in the device such as ARM PLL, DDR PLL

 *	or PA PLL available on keystone2. These PLLs are controlled by

 *	this register. Main PLL is controlled by a PLL controller.

 * @pllm: PLL register map address for multiplier bits

 * @pllod: PLL register map address for post divider bits

 * @pll_ctl0: PLL controller map address

 * @pllm_lower_mask: multiplier lower mask

 * @pllm_upper_mask: multiplier upper mask

 * @pllm_upper_shift: multiplier upper shift

 * @plld_mask: divider mask

 * @clkod_mask: output divider mask

 * @clkod_shift: output divider shift

 * @plld_mask: divider mask

 * @postdiv: Fixed post divider

/**

 * struct clk_pll - Main pll clock

 * @hw: clk_hw for the pll

 * @pll_data: PLL driver specific data

	/*

	 * get bits 0-5 of multiplier from pllctrl PLLM register

	 * if has_pllctrl is non zero

 bit6-12 of PLLM is in Main PLL control register */

 read post divider from od bits*/

/**

 * _of_pll_clk_init - PLL initialisation via DT

 * @node: device tree node for this clock

 * @pllctrl: If true, lower 6 bits of multiplier is in pllm register of

 *		pll controller, else it is in the control register0(bit 11-6)

 assume the PLL has output divider register bits */

		/*

		 * Check if there is an post-divider register. If not

		 * assume od bits are part of control register.

/**

 * of_keystone_pll_clk_init - PLL initialisation DT wrapper

 * @node: device tree node for this clock

/**

 * of_keystone_main_pll_clk_init - Main PLL initialisation DT wrapper

 * @node: device tree node for this clock

/**

 * of_pll_div_clk_init - PLL divider setup function

 * @node: device tree node for this clock

/**

 * of_pll_mux_clk_init - PLL mux setup function

 * @node: device tree node for this clock

/*

 * SCI Clock driver for keystone based devices

 *

 * Copyright (C) 2015-2016 Texas Instruments Incorporated - https://www.ti.com/

 *	Tero Kristo <t-kristo@ti.com>

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License version 2 as

 * published by the Free Software Foundation.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

/**

 * struct sci_clk_provider - TI SCI clock provider representation

 * @sci: Handle to the System Control Interface protocol handler

 * @ops: Pointer to the SCI ops to be used by the clocks

 * @dev: Device pointer for the clock provider

 * @clocks: Clocks array for this device

 * @num_clocks: Total number of clocks for this provider

/**

 * struct sci_clk - TI SCI clock representation

 * @hw:		 Hardware clock cookie for common clock framework

 * @dev_id:	 Device index

 * @clk_id:	 Clock index

 * @num_parents: Number of parents for this clock

 * @provider:	 Master clock provider

 * @flags:	 Flags for the clock

 * @node:	 Link for handling clocks probed via DT

 * @cached_req:	 Cached requested freq for determine rate calls

 * @cached_res:	 Cached result freq for determine rate calls

/**

 * sci_clk_prepare - Prepare (enable) a TI SCI clock

 * @hw: clock to prepare

 *

 * Prepares a clock to be actively used. Returns the SCI protocol status.

/**

 * sci_clk_unprepare - Un-prepares (disables) a TI SCI clock

 * @hw: clock to unprepare

 *

 * Un-prepares a clock from active state.

/**

 * sci_clk_is_prepared - Check if a TI SCI clock is prepared or not

 * @hw: clock to check status for

 *

 * Checks if a clock is prepared (enabled) in hardware. Returns non-zero

 * value if clock is enabled, zero otherwise.

/**

 * sci_clk_recalc_rate - Get clock rate for a TI SCI clock

 * @hw: clock to get rate for

 * @parent_rate: parent rate provided by common clock framework, not used

 *

 * Gets the current clock rate of a TI SCI clock. Returns the current

 * clock rate, or zero in failure.

/**

 * sci_clk_determine_rate - Determines a clock rate a clock can be set to

 * @hw: clock to change rate for

 * @req: requested rate configuration for the clock

 *

 * Determines a suitable clock rate and parent for a TI SCI clock.

 * The parent handling is un-used, as generally the parent clock rates

 * are not known by the kernel; instead these are internally handled

 * by the firmware. Returns 0 on success, negative error value on failure.

/**

 * sci_clk_set_rate - Set rate for a TI SCI clock

 * @hw: clock to change rate for

 * @rate: target rate for the clock

 * @parent_rate: rate of the clock parent, not used for TI SCI clocks

 *

 * Sets a clock frequency for a TI SCI clock. Returns the TI SCI

 * protocol status.

/**

 * sci_clk_get_parent - Get the current parent of a TI SCI clock

 * @hw: clock to get parent for

 *

 * Returns the index of the currently selected parent for a TI SCI clock.

/**

 * sci_clk_set_parent - Set the parent of a TI SCI clock

 * @hw: clock to set parent for

 * @index: new parent index for the clock

 *

 * Sets the parent of a TI SCI clock. Return TI SCI protocol status.

/**

 * _sci_clk_get - Gets a handle for an SCI clock

 * @provider: Handle to SCI clock provider

 * @sci_clk: Handle to the SCI clock to populate

 *

 * Gets a handle to an existing TI SCI hw clock, or builds a new clock

 * entry and registers it with the common clock framework. Called from

 * the common clock framework, when a corresponding of_clk_get call is

 * executed, or recursively from itself when parsing parent clocks.

 * Returns 0 on success, negative error code on failure.

	/*

	 * From kernel point of view, we only care about a clocks parents,

	 * if it has more than 1 possible parent. In this case, it is going

	 * to have mux functionality. Otherwise it is going to act as a root

	 * clock.

/**

 * sci_clk_get - Xlate function for getting clock handles

 * @clkspec: device tree clock specifier

 * @data: pointer to the clock provider

 *

 * Xlate function for retrieving clock TI SCI hw clock handles based on

 * device tree clock specifier. Called from the common clock framework,

 * when a corresponding of_clk_get call is executed. Returns a pointer

 * to the TI SCI hw clock struct, or ERR_PTR value in failure.

 Sentinel */ },

				/*

				 * Linux kernel has inherent limitation

				 * of 255 clock parents at the moment.

				 * Right now, it is not expected that

				 * any mux clock from sci-clk driver

				 * would exceed that limit either, but

				 * the ABI basically provides that

				 * possibility. Print out a warning if

				 * this happens for any clock.

/**

 * ti_sci_clk_probe - Probe function for the TI SCI clock driver

 * @pdev: platform device pointer to be probed

 *

 * Probes the TI SCI clock device. Allocates a new clock provider

 * and registers this to the common clock framework. Also applies

 * any required flags to the identified clocks via clock lists

 * supplied from DT. Returns 0 for success, negative error value

 * for failure.

/**

 * ti_sci_clk_remove - Remove TI SCI clock device

 * @pdev: platform device pointer for the device to be removed

 *

 * Removes the TI SCI device. Unregisters the clock provider registered

 * via common clock framework. Any memory allocated for the device will

 * be free'd silently via the devm framework. Returns 0 always.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2020 Texas Instruments Incorporated - https://www.ti.com/

 Sentinel */ },

 Sentinel */ },

 SPDX-License-Identifier: GPL-2.0

/*

 * PSC clock descriptions for TI DaVinci DM365

 *

 * Copyright (C) 2018 David Lechner <david@lechnology.com>

 REVISIT: gpio-davinci.c should be modified to drop con_id */

 REVISIT: why can't this be disabled? */

	/*

	 * The TRM (ARM Subsystem User's Guide) shows two clocks input into

	 * voice codec module (PLL2 SYSCLK4 with a DIV2 and PLL1 SYSCLK4). Its

	 * not fully clear from documentation which clock should be considered

	 * as parent for PSC. The clock chosen here is to maintain

	 * compatibility with existing code in arch/arm/mach-davinci/dm365.c

	/*

	 * Its not fully clear from TRM (ARM Subsystem User's Guide) as to what

	 * the parent of VPSS DAC LPSC should actually be. PLL1 SYSCLK3 feeds

	 * into HDVICP and MJCP. The clock chosen here is to remain compatible

	 * with code existing in arch/arm/mach-davinci/dm365.c

 SPDX-License-Identifier: GPL-2.0

/*

 * PSC clock descriptions for TI DaVinci DM355

 *

 * Copyright (C) 2018 David Lechner <david@lechnology.com>

 REVISIT: gpio-davinci.c should be modified to drop con_id */

 REVISIT: why can't this be disabled? */

 SPDX-License-Identifier: GPL-2.0

/*

 * PSC clock descriptions for TI DaVinci DM644x

 *

 * Copyright (C) 2018 David Lechner <david@lechnology.com>

 REVISIT: gpio-davinci.c should be modified to drop con_id */

 REVISIT: why can't this be disabled? */

 REVISIT how to disable? */

 REVISIT how to disable? */

 SPDX-License-Identifier: GPL-2.0

/*

 * Clock driver for TI Davinci PSC controllers

 *

 * Copyright (C) 2017 David Lechner <david@lechnology.com>

 *

 * Based on: drivers/clk/keystone/gate.c

 * Copyright (C) 2013 Texas Instruments.

 *	Murali Karicheri <m-karicheri2@ti.com>

 *	Santosh Shilimkar <santosh.shilimkar@ti.com>

 *

 * And: arch/arm/mach-davinci/psc.c

 * Copyright (C) 2006 Texas Instruments.

 PSC register offsets */

 PSC module states */

/**

 * struct davinci_lpsc_clk - LPSC clock structure

 * @dev: the device that provides this LPSC or NULL

 * @hw: clk_hw for the LPSC

 * @pm_domain: power domain for the LPSC

 * @genpd_clk: clock reference owned by @pm_domain

 * @regmap: PSC MMIO region

 * @md: Module domain (LPSC module id)

 * @pd: Power domain

 * @flags: LPSC_* quirk flags

/**

 * best_dev_name - get the "best" device name.

 * @dev: the device

 *

 * Returns the device tree compatible name if the device has a DT node,

 * otherwise return the device name. This is mainly needed because clkdev

 * lookups are limited to 20 chars for dev_id and when using device tree,

 * dev_name(dev) is much longer than that.

	/*

	 * pm_clk_remove_clk() will call clk_put(), so we have to use clk_get()

	 * to get the clock instead of using lpsc->hw.clk directly.

/**

 * davinci_lpsc_clk_register - register LPSC clock

 * @dev: the clocks's device or NULL

 * @name: name of this clock

 * @parent_name: name of clock's parent

 * @regmap: PSC MMIO region

 * @md: local PSC number

 * @pd: power domain

 * @flags: LPSC_* flags

 for now, genpd is only registered when using device-tree */

 genpd attach needs a way to look up this clock */

 discard const qualifier */

 the clock node is the same as the reset node */

 not all modules support local reset */

	/*

	 * init array with error so that of_clk_src_onecell_get() doesn't

	 * return NULL for gaps in the sparse array

	/*

	 * for now, a reset controller is only registered when there is a device

	 * to associate it with.

 has to be postcore_initcall because davinci_gpio depend on PSC clocks */

 SPDX-License-Identifier: GPL-2.0

/*

 * PSC clock descriptions for TI DA850/OMAP-L138/AM18XX

 *

 * Copyright (C) 2018 David Lechner <david@lechnology.com>

 REVISIT: used dev_id instead of con_id */

 REVISIT: gpio-davinci.c should be modified to drop con_id */

 SPDX-License-Identifier: GPL-2.0

/*

 * PLL clock descriptions for TI DM365

 *

 * Copyright (C) 2018 David Lechner <david@lechnology.com>

/*

 * This is a bit of a hack to make OCSEL[OCSRC] on DM365 look like OCSEL[OCSRC]

 * on DA850. On DM365, OCSEL[OCSRC] is just an enable/disable bit instead of a

 * multiplexer. By modeling it as a single parent mux clock, the clock code will

 * still do the right thing in this case.

 SPDX-License-Identifier: GPL-2.0

/*

 * Clock driver for DA8xx/AM17xx/AM18xx/OMAP-L13x CFGCHIP

 *

 * Copyright (C) 2018 David Lechner <david@lechnology.com>

 --- Gate clocks --- */

 this clock divides by 4.5 */

 --- MUX clocks --- */

 pll1_sysclk2 is not affected by CPU scaling, so use it for async3 */

 --- USB 2.0 PHY clock --- */

	/* The USB 2.0 PSC clock is only needed temporarily during the USB 2.0

	 * PHY clock enable, but since clk_prepare() can't be called in an

	 * atomic context (i.e. in clk_enable()), we have to prepare it here.

	/* Locking the USB 2.O PLL requires that the USB 2.O PSC is enabled

	 * temporaily. It can be turned back off once the PLL is locked.

	/* Turn on the USB 2.0 PHY, but just the PLL, and not OTG. The USB 1.1

	 * PHY may use the USB 2.0 PLL clock without USB 2.0 OTG being used.

 The parent clock rate must be one of the following */

 USB 2.0 PLL always supplies 48MHz */

 --- USB 1.1 PHY clock --- */

/**

 * da8xx_cfgchip_register_usb1_clk48 - Register a new USB 1.1 PHY clock

 * @dev: The device

 * @regmap: The CFGCHIP regmap

	/*

	 * All existing boards use pll0_auxclk as the parent and new boards

	 * should use device tree, so hard-coding the value (1) here.

	/*

	 * All existing boards use usb0_clk48 as the parent and new boards

	 * should use device tree, so hard-coding the value (0) here.

 --- platform device --- */

 has to be postcore_initcall because PSC devices depend on the async3 clock */

 SPDX-License-Identifier: GPL-2.0

/*

 * PLL clock descriptions for TI DM355

 *

 * Copyright (C) 2018 David Lechner <david@lechnology.com>

 SPDX-License-Identifier: GPL-2.0

/*

 * PLL clock descriptions for TI DA830/OMAP-L137/AM17XX

 *

 * Copyright (C) 2018 David Lechner <david@lechnology.com>

/*

 * NB: Technically, the clocks flagged as SYSCLK_FIXED_DIV are "fixed ratio",

 * meaning that we could change the divider as long as we keep the correct

 * ratio between all of the clocks, but we don't support that because there is

 * currently not a need for it.

 SPDX-License-Identifier: GPL-2.0

/*

 * PLL clock descriptions for TI DM644X

 *

 * Copyright (C) 2018 David Lechner <david@lechnology.com>

 810MHz @ 1.3V, -810 only */

 SPDX-License-Identifier: GPL-2.0

/*

 * PSC clock descriptions for TI DA830/OMAP-L137/AM17XX

 *

 * Copyright (C) 2018 David Lechner <david@lechnology.com>

 REVISIT: gpio-davinci.c should be modified to drop con_id */

 SPDX-License-Identifier: GPL-2.0

/*

 * PLL clock driver for TI Davinci SoCs

 *

 * Copyright (C) 2018 David Lechner <david@lechnology.com>

 *

 * Based on arch/arm/mach-davinci/clock.c

 * Copyright (C) 2006-2007 Texas Instruments.

 * Copyright (C) 2008-2009 Deep Root Systems, LLC

 shared by most *DIV registers */

/*

 * OMAP-L138 system reference guide recommends a wait for 4 OSCIN/CLKIN

 * cycles to ensure that the PLLC has switched to bypass mode. Delay of 1us

 * ensures we are good for all > 4MHz OSCIN/CLKIN inputs. Typically the input

 * is ~25MHz. Units are micro seconds.

 From OMAP-L138 datasheet table 6-4. Units are micro seconds */

/*

 * From OMAP-L138 datasheet table 6-4; assuming prediv = 1, sqrt(pllm) = 4

 * Units are micro seconds.

/**

 * struct davinci_pll_clk - Main PLL clock (aka PLLOUT)

 * @hw: clk_hw for the pll

 * @base: Base memory address

 * @pllm_min: The minimum allowable PLLM[PLLM] value

 * @pllm_max: The maxiumum allowable PLLM[PLLM] value

 * @pllm_mask: Bitmask for PLLM[PLLM] value

 there is a limited range of valid outputs (see datasheet) */

 easy case when there is no PREDIV */

 see if the PREDIV clock can help us */

 PLLM works differently on DM365 */

/**

 * davinci_pll_div_register - common *DIV clock implementation

 * @dev: The PLL platform device or NULL

 * @name: the clock name

 * @parent_name: the parent clock name

 * @reg: the *DIV register

 * @fixed: if true, the divider is a fixed value

 * @flags: bitmap of CLK_* flags from clock-provider.h

 this clocks just uses the clock notification feature */

/*

 * The PLL has to be switched into bypass mode while we are chaning the rate,

 * so we do that on the PLLEN clock since it is the end of the line. This will

 * switch to bypass before any of the parent clocks (PREDIV, PLL, POSTDIV) are

 * changed and will switch back to the PLL after the changes have been made.

 Switch the PLL to bypass mode */

 Reset and enable PLL */

 Bring PLL out of reset */

 Remove PLL from bypass mode */

/**

 * davinci_pll_clk_register - Register a PLL clock

 * @dev: The PLL platform device or NULL

 * @info: The device-specific clock info

 * @parent_name: The parent clock name

 * @base: The PLL's memory region

 * @cfgchip: CFGCHIP syscon regmap for info->unlock_reg or NULL

 *

 * This creates a series of clocks that represent the PLL.

 *

 *     OSCIN > [PREDIV >] PLL > [POSTDIV >] PLLEN

 *

 * - OSCIN is the parent clock (on secondary PLL, may come from primary PLL)

 * - PREDIV and POSTDIV are optional (depends on the PLL controller)

 * - PLL is the PLL output (aka PLLOUT)

 * - PLLEN is the bypass multiplexer

 *

 * Returns: The PLLOUT clock or a negative error code.

		/*

		 * If a PLL has PLLCTL[CLKMODE], then it is the primary PLL.

		 * We register a clock named "oscin" that serves as the internal

		 * "input clock" domain shared by both PLLs (if there are 2)

		 * and will be the parent clock to the AUXCLK, SYSCLKBP and

		 * OBSCLK domains. NB: The various TRMs use "OSCIN" to mean

		 * a number of different things. In this driver we use it to

		 * mean the signal after the PLLCTL[CLKMODE] switch.

 Some? DM355 chips don't correctly report the PREDIV value */

 Unlock writing to PLL registers */

/**

 * davinci_pll_auxclk_register - Register bypass clock (AUXCLK)

 * @dev: The PLL platform device or NULL

 * @name: The clock name

 * @base: The PLL memory region

/**

 * davinci_pll_sysclkbp_clk_register - Register bypass divider clock (SYSCLKBP)

 * @dev: The PLL platform device or NULL

 * @name: The clock name

 * @base: The PLL memory region

/**

 * davinci_pll_obsclk_register - Register oscillator divider clock (OBSCLK)

 * @dev: The PLL platform device or NULL

 * @info: The clock info

 * @base: The PLL memory region

 make sure divider is enabled just in case bootloader disabled it */

 The PLL SYSCLKn clocks have a mechanism for synchronizing rate changes. */

 apply the changes */

 Wait until for outstanding changes to take effect */

/**

 * davinci_pll_sysclk_register - Register divider clocks (SYSCLKn)

 * @dev: The PLL platform device or NULL

 * @info: The clock info

 * @base: The PLL memory region

 PLLDIVn registers are not entirely consecutive */

 Only the ARM clock can change the parent PLL rate */

	/*

	 * Platform data is optional, so allocate a new struct if one was not

	 * provided. For device tree, this will always be the case.

 for device tree, we need to fill in the struct */

 needed in early boot for clocksource/clockevent */

 has to be postcore_initcall because PSC devices depend on PLL parent clocks */

 SPDX-License-Identifier: GPL-2.0

/*

 * PLL clock descriptions for TI DA850/OMAP-L138/AM18XX

 *

 * Copyright (C) 2018 David Lechner <david@lechnology.com>

/*

 * NB: Technically, the clocks flagged as SYSCLK_FIXED_DIV are "fixed ratio",

 * meaning that we could change the divider as long as we keep the correct

 * ratio between all of the clocks, but we don't support that because there is

 * currently not a need for it.

 SPDX-License-Identifier: GPL-2.0

/*

 * PLL clock descriptions for TI DM646X

 *

 * Copyright (C) 2018 David Lechner <david@lechnology.com>

 SPDX-License-Identifier: GPL-2.0

/*

 * PSC clock descriptions for TI DaVinci DM646x

 *

 * Copyright (C) 2018 David Lechner <david@lechnology.com>

 REVISIT: gpio-davinci.c should be modified to drop con_id */

 REVISIT how to disable? */

 REVIST: disabling hangs system */

 REVIST: disabling hangs system */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2016 Socionext Inc.

 *   Author: Masahiro Yamada <yamada.masahiro@socionext.com>

 sentinel */ }

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2016 Socionext Inc.

 *   Author: Masahiro Yamada <yamada.masahiro@socionext.com>

 allocate fixed-rate clock */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2016 Socionext Inc.

 *   Author: Masahiro Yamada <yamada.masahiro@socionext.com>

 parent should be syscon node */

 avoid returning NULL for unused idx */

 System clock */

 Media I/O clock, SD clock */

 Peripheral clock */

 SoC-glue clock */

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2016 Socionext Inc.

 *   Author: Masahiro Yamada <yamada.masahiro@socionext.com>

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2016 Socionext Inc.

 *   Author: Masahiro Yamada <yamada.masahiro@socionext.com>

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2016 Socionext Inc.

 *   Author: Masahiro Yamada <yamada.masahiro@socionext.com>

 sentinel */ }

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2016 Socionext Inc.

 *   Author: Masahiro Yamada <yamada.masahiro@socionext.com>

 1597.44 MHz */

 288 MHz */

 589.824 MHz */

 270 MHz */

 Ether, HSC, MIO */

 sentinel */ }

 1600 MHz */

 288 MHz */

 589.824 MHz */

 270 MHz */

 250 MHz */

 HSC, MIO, RLE */

 Ether, SATA, USB3 */

 sentinel */ }

 1600 MHz */

 288 MHz */

 270 MHz */

 Ether, HSC, MIO */

 sentinel */ }

 2400 MHz */

 2560 MHz */

 2949.12 MHz */

 HSC */

 PCIe, USB3 */

 sentinel */ }

 2400 MHz */

 HSC, RLE */

 GIO is always clock-enabled: no function for 0x2104 bit6 */

 The document mentions 0x2104 bit 18, but not functional */

 sentinel */ }

 1960 MHz */

 1600 MHz */

 2000 MHz */

 2000 MHz */

 Index 5 reserved for eMMC PHY */

 HSC, MIO */

 CPU gears */

 Note: both gear1 and gear4 are spll/4.  This is not a bug. */

 sentinel */ }

 ARM: 2200 MHz */

 Mali: 1300 MHz */

 Codec: 1600 MHz */

 2000 MHz */

 IPP: 2200 MHz */

 2520 MHz */

 Index 5 reserved for eMMC PHY */

 HSC */

 GIO is always clock-enabled: no function for 0x210c bit5 */

	/*

	 * clock for USB Link is enabled by the logic "OR" of bit 14 and bit 15.

	 * We do not use bit 15 here.

 CPU gears */

 sentinel */ }

 ARM: 2600 MHz */

 2000 MHz */

 IPP: 2400 MHz */

 =GIO0 */

 =GIO1 */

 =GIO1-1 */

 CPU gears */

 sentinel */ }

 ARM: 2500 MHz */

 800 MHz */

 =GIO */

 =GIO1P */

 CPU gears */

 sentinel */ }

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2016 Socionext Inc.

 *   Author: Masahiro Yamada <yamada.masahiro@socionext.com>

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2016 Socionext Inc.

 *   Author: Masahiro Yamada <yamada.masahiro@socionext.com>

 status */

 set */

 update */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2015 Vladimir Zapolskiy <vz@mleia.com>

 Common bitfield definitions for x397 PLL (lock), USB PLL and HCLK PLL */

 Clock registers on System Control Block */

 Clock registers on USB controller */

 Start from the last defined clock in dt bindings */

 System clocks, PLL 397x and HCLK PLL clocks */

 USB clocks */

 Only one control PWR_CTRL[10] for both muxes */

 Only one control PWR_CTRL[2] for all three muxes */

 Two clock sources external to the driver */

 Renumbered USB clocks, may have a parent from SCB table */

 Stub for composite clocks */

 Subclocks of composite clocks, clocks above are for CCF */

	/*

	 * CLK_GET_RATE_NOCACHE is needed, if UART clock is disabled, its

	 * divider register does not contain information about selected rate.

 USB controller clocks */

 Validate PLL clock parameters computed on round rate stage */

 Sanity check that round rate is equal to the requested one */

 Have to check all 20 possibilities to find the minimal M */

 Check for valid PLL parameter constraints */

 Store some intermediate valid parameters */

 Set only direct or non-integer mode of PLL */

	/*

	 * The only supported USB clock is 48MHz, with PLL internal constraints

	 * on Fclkin, Fcco and Fref this implies that Fcco must be 192MHz

	 * and post-divider must be 4, this slightly simplifies calculation of

	 * USB divider, USB PLL N and M parameters.

 USB divider clock */

 Main oscillator clock */

 must be in range 1..20 MHz */

 Check if valid USB divider and USB PLL parameters exists */

	/*

	 * DDRAM clock must be 2 times higher than HCLK,

	 * this implies DDRAM clock can not be enabled,

	 * if HCLK clock rate is equal to ARM clock rate

 if read only, just return current value */

 Register 3 read-only muxes with a single control PWR_CTRL[2] */

 Register 2 read-only muxes with a single control PWR_CTRL[10] */

 3 always on gates with a single control PWR_CTRL[0] same as OSC */

	/*

	 * ADC/TS clock unfortunately cannot be registered as a composite one

	 * due to a different connection of gate, div and mux, e.g. gating it

	 * won't mean that the clock is off, if peripheral clock is its parent:

	 *

	 * rtc-->[gate]-->|     |

	 *                | mux |--> adc/ts

	 * pclk-->[div]-->|     |

	 *

	 * Constraints:

	 * ADC --- resulting clock must be <= 4.5 MHz

	 * TS  --- resulting clock must be <= 400 KHz

 USB controller clocks */

 Ensure that parent clocks are available and valid */

	/*

	 * Divider part of PWM and MS clocks requires a quirk to avoid

	 * a misinterpretation of formally valid zero value in register

	 * bitfield, which indicates another clock gate. Instead of

	 * adding complexity to a gate clock ensure that zero value in

	 * divider clock is never met in runtime.

 Set 48MHz rate of USB PLL clock */

 These two clocks must be always on independently on consumers */

 Enable ARM VFP by default */

 Disable enabled by default clocks for NAND MLC and SLC */

/*

 * Clk driver for NXP LPC18xx/LPC43xx Clock Generation Unit (CGU)

 *

 * Copyright (C) 2015 Joachim Eastwood <manabian@gmail.com>

 *

 * This file is licensed under the terms of the GNU General Public

 * License version 2. This program is licensed "as is" without any

 * warranty of any kind, whether express or implied.

 Clock Generation Unit (CGU) registers */

 PLL0 bits common to both audio and USB PLL */

 Register value that gives PLL0 post/pre dividers equal to 1 */

 21 reserved */ },

 22 reserved */ },

 23 reserved */ },

 24 reserved */ },

/*

 * PLL0 uses a special register value encoding. The compute functions below

 * are taken or derived from the LPC1850 user manual (section 12.6.3.3).

 Compute PLL0 multiplier from decoded version */

 Compute PLL0 decoded multiplier from binary version */

 Compute PLL0 bandwidth SELI reg from multiplier */

 Compute PLL0 bandwidth SELP reg from multiplier */

 Power down PLL, disable clk output and dividers */

 Configure new PLL settings */

 Power up PLL and wait for lock */

	/*

	 * The consumer of base clocks needs know if the

	 * base clock is really enabled before it can be

	 * accessed. It is therefore necessary to verify

	 * this all the way up.

 SAFE_CLK can not be turned off */

 Register the internal 12 MHz RC oscillator (IRC) */

 Register crystal oscillator controlller */

 Register all PLLs */

 Register all clock dividers A-E */

/*

 * Clk driver for NXP LPC18xx/43xx Configuration Registers (CREG)

 *

 * Copyright (C) 2015 Joachim Eastwood <manabian@gmail.com>

 *

 * This file is licensed under the terms of the GNU General Public

 * License version 2. This program is licensed "as is" without any

 * warranty of any kind, whether express or implied.

	/*

	 * Powering up the 32k oscillator takes a long while

	 * and sadly there aren't any status bit to poll.

/*

 * Clk driver for NXP LPC18xx/LPC43xx Clock Control Unit (CCU)

 *

 * Copyright (C) 2015 Joachim Eastwood <manabian@gmail.com>

 *

 * This file is licensed under the terms of the GNU General Public

 * License version 2. This program is licensed "as is" without any

 * warranty of any kind, whether express or implied.

 Bit defines for CCU branch configuration register */

 CCU branch feature bits */

	/*

	 * Divider field is write only, so divider stat field must

	 * be read so divider field can be set accordingly.

		/*

		 * To safely disable a branch clock a squence of two separate

		 * writes must be used. First write should set the AUTO bit

		 * and the next write should clear the RUN bit.

	/*

	 * The branch clock registers are only accessible

	 * if the base (parent) clock is enabled. Register

	 * access with a disabled base clock will hang the

	 * system.

 Grab essential branch clocks for CPU and SDRAM */

 SPDX-License-Identifier: GPL-2.0

/*

 * r8a77995 Clock Pulse Generator / Module Standby and Software Reset

 *

 * Copyright (C) 2017 Glider bvba

 *

 * Based on r8a7795-cpg-mssr.c

 *

 * Copyright (C) 2015 Glider bvba

 * Copyright (C) 2015 Renesas Electronics Corp.

 Core Clock Outputs exported to DT */

 External Input Clocks */

 Internal Core Clocks */

 Module Clocks */

 External Clock Inputs */

 Internal Core Clocks */

 Core Clock Outputs */

 RWDT */

 INTC-AP (GIC) */

/*

 * CPG Clock Data

/*

 * MD19		EXTAL (MHz)	PLL0		PLL1		PLL3

 *--------------------------------------------------------------------

 * 0		48 x 1		x250/4		x100/3		x100/3

 * 1		48 x 1		x250/4		x100/3		x58/3

 EXTAL div	PLL1 mult/div	PLL3 mult/div */

 Core Clocks */

 Module Clocks */

 Critical Module Clocks */

 Callbacks */

 SPDX-License-Identifier: GPL-2.0

/*

 * Renesas Clock Pulse Generator / Module Standby and Software Reset

 *

 * Copyright (C) 2015 Glider bvba

 *

 * Based on clk-mstp.c, clk-rcar-gen2.c, and clk-rcar-gen3.c

 *

 * Copyright (C) 2013 Ideas On Board SPRL

 * Copyright (C) 2015 Renesas Electronics Corp.

/*

 * Module Standby and Software Reset register offets.

 *

 * If the registers exist, these are valid for SH-Mobile, R-Mobile,

 * R-Car Gen2, R-Car Gen3, and RZ/G1.

 * These are NOT valid for R-Car Gen1 and RZ/A1!

/*

 * Module Stop Status Register offsets

/*

 * System Module Stop Control Register offsets

/*

 * Standby Control Register offsets (RZ/A)

 * Base address is FRQCR register

dummy*/, 0x010, 0x014, 0x410, 0x414, 0x418, 0x41C, 0x420,

/*

 * Software Reset Register offsets

/*

 * Software Reset Clearing Register offsets

/**

 * struct cpg_mssr_priv - Clock Pulse Generator / Module Standby

 *                        and Software Reset Private Data

 *

 * @rcdev: Optional reset controller entity

 * @dev: CPG/MSSR device

 * @base: CPG/MSSR register block base address

 * @reg_layout: CPG/MSSR register layout

 * @rmw_lock: protects RMW register accesses

 * @np: Device node in DT for this CPG/MSSR module

 * @num_core_clks: Number of Core Clocks in clks[]

 * @num_mod_clks: Number of Module Clocks in clks[]

 * @last_dt_core_clk: ID of the last Core Clock exported to DT

 * @notifiers: Notifier chain to save/restore clock state for system resume

 * @status_regs: Pointer to status registers array

 * @control_regs: Pointer to control registers array

 * @reset_regs: Pointer to reset registers array

 * @reset_clear_regs:  Pointer to reset clearing registers array

 * @smstpcr_saved: [].mask: Mask of SMSTPCR[] bits under our control

 *                 [].val: Saved values of SMSTPCR[]

 * @clks: Array containing all Core and Module Clocks

/**

 * struct mstp_clock - MSTP gating clock

 * @hw: handle between common and hardware-specific interfaces

 * @index: MSTP clock number

 * @priv: CPG/MSSR private data

 dummy read to ensure write has completed */

 Skip NULLified clock */

 Multiply with the DIV6 register value */

 Skip NULLified clock */

 Reset module */

 Wait for at least one cycle of the RCLK clock (@ ca. 32 kHz) */

 Release module from reset state */

 !CONFIG_RESET_CONTROLLER */

 !CONFIG_RESET_CONTROLLER */

 RZ/G1N is (almost) identical to RZ/G1M w.r.t. clocks. */

 R-Car M2-N is (almost) identical to R-Car M2-W w.r.t. clocks. */

 sentinel */ }

 This is the best we can do to check for the presence of PSCI */

 Save module registers with bits under our control */

 Save core clocks */

 This is the best we can do to check for the presence of PSCI */

 Restore core clocks */

 Restore module clocks */

 dummy read to ensure write has completed */

 Wait until enabled clocks are really enabled */

 CONFIG_PM_SLEEP && CONFIG_ARM_PSCI_FW */

 Reset Controller not supported for Standby Control SoCs */

 SPDX-License-Identifier: GPL-2.0

/*

 * r8a774a1 Clock Pulse Generator / Module Standby and Software Reset

 *

 * Copyright (C) 2018 Renesas Electronics Corp.

 *

 * Based on r8a7796-cpg-mssr.c

 *

 * Copyright (C) 2016 Glider bvba

 Core Clock Outputs exported to DT */

 External Input Clocks */

 Internal Core Clocks */

 Module Clocks */

 External Clock Inputs */

 Internal Core Clocks */

 Core Clock Outputs */

 RWDT */

 INTC-AP (GIC) */

/*

 * CPG Clock Data

/*

 *   MD		EXTAL		PLL0	PLL1	PLL2	PLL3	PLL4	OSC

 * 14 13 19 17	(MHz)

 *-------------------------------------------------------------------------

 * 0  0  0  0	16.66 x 1	x180	x192	x144	x192	x144	/16

 * 0  0  0  1	16.66 x 1	x180	x192	x144	x128	x144	/16

 * 0  0  1  0	Prohibited setting

 * 0  0  1  1	16.66 x 1	x180	x192	x144	x192	x144	/16

 * 0  1  0  0	20    x 1	x150	x160	x120	x160	x120	/19

 * 0  1  0  1	20    x 1	x150	x160	x120	x106	x120	/19

 * 0  1  1  0	Prohibited setting

 * 0  1  1  1	20    x 1	x150	x160	x120	x160	x120	/19

 * 1  0  0  0	25    x 1	x120	x128	x96	x128	x96	/24

 * 1  0  0  1	25    x 1	x120	x128	x96	x84	x96	/24

 * 1  0  1  0	Prohibited setting

 * 1  0  1  1	25    x 1	x120	x128	x96	x128	x96	/24

 * 1  1  0  0	33.33 / 2	x180	x192	x144	x192	x144	/32

 * 1  1  0  1	33.33 / 2	x180	x192	x144	x128	x144	/32

 * 1  1  1  0	Prohibited setting

 * 1  1  1  1	33.33 / 2	x180	x192	x144	x192	x144	/32

 EXTAL div	PLL1 mult/div	PLL3 mult/div	OSC prediv */

 Prohibited setting */				},

 Prohibited setting */				},

 Prohibited setting */				},

 Prohibited setting */				},

 Core Clocks */

 Module Clocks */

 Critical Module Clocks */

 Callbacks */

 SPDX-License-Identifier: GPL-2.0

/*

 * RZ/G2L CPG driver

 *

 * Copyright (C) 2021 Renesas Electronics Corp.

 Core Clock Outputs exported to DT */

 External Input Clocks */

 Internal Core Clocks */

 Module Clocks */

 Divider tables */

 Mux clock tables */

 External Clock Inputs */

 Internal Core Clocks */

 Core output clk */

 Core Clocks */

 Critical Module Clocks */

 Module Clocks */

 Resets */

 SPDX-License-Identifier: GPL-2.0

/*

 * r8a77965 Clock Pulse Generator / Module Standby and Software Reset

 *

 * Copyright (C) 2018 Jacopo Mondi <jacopo+renesas@jmondi.org>

 * Copyright (C) 2019 Renesas Electronics Corp.

 *

 * Based on r8a7795-cpg-mssr.c

 *

 * Copyright (C) 2015 Glider bvba

 * Copyright (C) 2015 Renesas Electronics Corp.

 Core Clock Outputs exported to DT */

 External Input Clocks */

 Internal Core Clocks */

 Module Clocks */

 External Clock Inputs */

 Internal Core Clocks */

 Core Clock Outputs */

 RWDT */

 INTC-AP (GIC) */

/*

 * CPG Clock Data

/*

 *   MD		EXTAL		PLL0	PLL1	PLL3	PLL4	OSC

 * 14 13 19 17	(MHz)

 *-----------------------------------------------------------------

 * 0  0  0  0	16.66 x 1	x180	x192	x192	x144	/16

 * 0  0  0  1	16.66 x 1	x180	x192	x128	x144	/16

 * 0  0  1  0	Prohibited setting

 * 0  0  1  1	16.66 x 1	x180	x192	x192	x144	/16

 * 0  1  0  0	20    x 1	x150	x160	x160	x120	/19

 * 0  1  0  1	20    x 1	x150	x160	x106	x120	/19

 * 0  1  1  0	Prohibited setting

 * 0  1  1  1	20    x 1	x150	x160	x160	x120	/19

 * 1  0  0  0	25    x 1	x120	x128	x128	x96	/24

 * 1  0  0  1	25    x 1	x120	x128	x84	x96	/24

 * 1  0  1  0	Prohibited setting

 * 1  0  1  1	25    x 1	x120	x128	x128	x96	/24

 * 1  1  0  0	33.33 / 2	x180	x192	x192	x144	/32

 * 1  1  0  1	33.33 / 2	x180	x192	x128	x144	/32

 * 1  1  1  0	Prohibited setting

 * 1  1  1  1	33.33 / 2	x180	x192	x192	x144	/32

 EXTAL div	PLL1 mult/div	PLL3 mult/div	OSC prediv */

 Prohibited setting */				},

 Prohibited setting */				},

 Prohibited setting */				},

 Prohibited setting */				},

 Core Clocks */

 Module Clocks */

 Critical Module Clocks */

 Callbacks */

 SPDX-License-Identifier: GPL-2.0

/*

 * EMMA Mobile EV2 common clock framework support

 *

 * Copyright (C) 2013 Takashi Yoshii <takashi.yoshii.ze@renesas.com>

 * Copyright (C) 2012 Magnus Damm

 EMEV2 SMU registers */

 not pretty, but hey */

 setup STI timer to run on 32.768 kHz and deassert reset */

 deassert reset for UART0->UART3 */

 deassert reset for IIC0->IIC1 */

 SPDX-License-Identifier: GPL-2.0

/*

 * r8a7743 Clock Pulse Generator / Module Standby and Software Reset

 *

 * Copyright (C) 2016 Cogent Embedded Inc.

 Core Clock Outputs exported to DT */

 External Input Clocks */

 Internal Core Clocks */

 Module Clocks */

 External Clock Inputs */

 Internal Core Clocks */

 Core Clock Outputs */

 RWDT */

 INTC-SYS (GIC) */

/*

 * CPG Clock Data

/*

 *    MD	EXTAL		PLL0	PLL1	PLL3

 * 14 13 19	(MHz)		*1	*1

 *---------------------------------------------------

 * 0  0  0	15		x172/2	x208/2	x106

 * 0  0  1	15		x172/2	x208/2	x88

 * 0  1  0	20		x130/2	x156/2	x80

 * 0  1  1	20		x130/2	x156/2	x66

 * 1  0  0	26 / 2		x200/2	x240/2	x122

 * 1  0  1	26 / 2		x200/2	x240/2	x102

 * 1  1  0	30 / 2		x172/2	x208/2	x106

 * 1  1  1	30 / 2		x172/2	x208/2	x88

 *

 * *1 :	Table 7.5a indicates VCO output (PLLx = VCO/2)

 EXTAL div	PLL1 mult	PLL3 mult */

 RZ/G1N uses a 1/5 divider for ZG */

 Core Clocks */

 Module Clocks */

 Critical Module Clocks */

 Callbacks */

 SPDX-License-Identifier: GPL-2.0

/*

 * r8a7790 Common Clock Framework support

 *

 * Copyright (C) 2013  Renesas Solutions Corp.

 *

 * Contact: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

/**

 * struct div6_clock - CPG 6 bit divider clock

 * @hw: handle between common and hardware-specific interfaces

 * @reg: IO-remapped register

 * @div: divisor value (1-64)

 * @src_mask: Bitmask covering the register bits to select the parent clock

 * @nb: Notifier block to save/restore clock state for system resume

 * @parents: Array to map from valid parent clocks indices to hardware indices

	/*

	 * DIV6 clocks require the divisor field to be non-zero when stopping

	 * the clock. However, some clocks (e.g. ZB on sh73a0) fail to be

	 * re-enabled later if the divisor field is changed when stopping the

	 * clock

 Only program the new divisor if the clock isn't stopped. */

		/*

		 * TODO: This does not yet support DIV6 clocks with multiple

		 * parents, as the parent selection bits are not restored.

		 * Fortunately so far such DIV6 clocks are found only on

		 * R/SH-Mobile SoCs, while the resume functionality is only

		 * needed on R-Car Gen3.

/**

 * cpg_div6_register - Register a DIV6 clock

 * @name: Name of the DIV6 clock

 * @num_parents: Number of parent clocks of the DIV6 clock (1, 4, or 8)

 * @parent_names: Array containing the names of the parent clocks

 * @reg: Mapped register used to control the DIV6 clock

 * @notifiers: Optional notifier chain to save/restore state for system resume

	/*

	 * Read the divisor. Disabling the clock overwrites the divisor, so we

	 * need to cache its value for the enable operation.

 fixed parent clock */

 clock with EXSRC bits 6-7 */

 VCLK with EXSRC bits 12-14 */

 Filter out invalid parents */

 Register the clock. */

 Parse the DT properties. */

 SPDX-License-Identifier: GPL-2.0

/*

 * sh73a0 Core CPG Clocks

 *

 * Copyright (C) 2014  Ulrich Hecht

 ZSEL == 0 */

 ZSEL == 1 */

 extal1, extal1_div2, extal2, extal2_div2 */

 handle CFG bit for PLL1 and PLL2 */

		/* We're leaking memory on purpose, there's no point in cleaning

		 * up as the system won't boot anyway.

 Set SDHI clocks to a known state */

 SPDX-License-Identifier: GPL-2.0

/*

 * R7S9210 Clock Pulse Generator / Module Standby

 *

 * Based on r8a7795-cpg-mssr.c

 *

 * Copyright (C) 2018 Chris Brandt

 * Copyright (C) 2018 Renesas Electronics Corp.

 *

 Internal Clock ratio table */

 p0 is always 32 */;

 I,  G,  B, P1 */

 FRQCR = 0x012 */

 FRQCR = 0x112 */

 FRQCR = 0x212 */

 FRQCR = 0x322 */

 FRQCR = 0x333 */

 Core Clock Outputs exported to DT */

 External Input Clocks */

 Internal Core Clocks */

 Module Clocks */

 External Clock Inputs */

 Internal Core Clocks */

 Core Clock Outputs */

 Core Clock Outputs */

 The clock dividers in the table vary based on DT and register settings */

 If EXTAL is above 12MHz, then we know it is Mode 1 */

 Illegal FRQCR value */

 Divider 1 is 1/2 */

 Divider 1 is 1 */

 Early Clocks */

 Core Clocks */

 Module Clocks */

 includes STBCR0 which doesn't exist */

 Callbacks */

 RZ/A2 has Standby Control Registers */

 SPDX-License-Identifier: GPL-2.0

/*

 * r8a7795 Clock Pulse Generator / Module Standby and Software Reset

 *

 * Copyright (C) 2015 Glider bvba

 * Copyright (C) 2018-2019 Renesas Electronics Corp.

 *

 * Based on clk-rcar-gen3.c

 *

 * Copyright (C) 2015 Renesas Electronics Corp.

 Core Clock Outputs exported to DT */

 External Input Clocks */

 Internal Core Clocks */

 Module Clocks */

 External Clock Inputs */

 Internal Core Clocks */

 Core Clock Outputs */

 ES1.x */

 ES1.x */

 ES1.x */

 ES1.x */

 ES1.x */

 ES1.x */

 ES1.x */

 ES1.x */

 ES1.x */

 ES1.x */

 RWDT */

 INTC-AP (GIC) */

/*

 * CPG Clock Data

/*

 *   MD		EXTAL		PLL0	PLL1	PLL2	PLL3	PLL4	OSC

 * 14 13 19 17	(MHz)

 *-------------------------------------------------------------------------

 * 0  0  0  0	16.66 x 1	x180	x192	x144	x192	x144	/16

 * 0  0  0  1	16.66 x 1	x180	x192	x144	x128	x144	/16

 * 0  0  1  0	Prohibited setting

 * 0  0  1  1	16.66 x 1	x180	x192	x144	x192	x144	/16

 * 0  1  0  0	20    x 1	x150	x160	x120	x160	x120	/19

 * 0  1  0  1	20    x 1	x150	x160	x120	x106	x120	/19

 * 0  1  1  0	Prohibited setting

 * 0  1  1  1	20    x 1	x150	x160	x120	x160	x120	/19

 * 1  0  0  0	25    x 1	x120	x128	x96	x128	x96	/24

 * 1  0  0  1	25    x 1	x120	x128	x96	x84	x96	/24

 * 1  0  1  0	Prohibited setting

 * 1  0  1  1	25    x 1	x120	x128	x96	x128	x96	/24

 * 1  1  0  0	33.33 / 2	x180	x192	x144	x192	x144	/32

 * 1  1  0  1	33.33 / 2	x180	x192	x144	x128	x144	/32

 * 1  1  1  0	Prohibited setting

 * 1  1  1  1	33.33 / 2	x180	x192	x144	x192	x144	/32

 EXTAL div	PLL1 mult/div	PLL3 mult/div	OSC prediv */

 Prohibited setting */				},

 Prohibited setting */				},

 Prohibited setting */				},

 Prohibited setting */				},

 sentinel */ }

	/*

	 * Fixups for R-Car H3 ES1.x

 USB-DMAC3-0 */

 USB-DMAC3-1 */

 EHCI/OHCI3 */

 HS-USB-IF3 */

 FDP1-1 */

 FDP1-0 */

 TMU4 */

 SYS-DMAC2 */

 SYS-DMAC1 */

 SYS-DMAC0 */

 INTC-AP */

 AUDMAC1 */

 AUDMAC0 */

 PWM */

 FCPVD2 */

 FCPVD1 */

 FCPVD0 */

 FCPVB1 */

 FCPVB0 */

 FCPVI1 */

 FCPVI0 */

 FCPF1 */

 FCPF0 */

 FCPCS */

 VSPD2 */

 VSPD1 */

 VSPD0 */

 VSPBC */

 VSPBD */

 VSPI1 */

 VSPI0 */

 VIN7 */

 VIN6 */

 VIN5 */

 VIN4 */

 VIN3 */

 VIN2 */

 VIN1 */

 VIN0 */

 EAVB-IF */

 IMR3 */

 IMR2 */

 IMR1 */

 IMR0 */

 GPIO7 */

 GPIO6 */

 GPIO5 */

 GPIO4 */

 GPIO3 */

 GPIO2 */

 GPIO1 */

 GPIO0 */

 I2C6 */

 I2C5 */

 I2C4 */

 I2C3 */

	/*

	 * Fixups for R-Car H3 ES2.x

 FDP1-2 */

 USB3-IF1 */

 FCPVD3 */

 FCPVI2 */

 FCPF2 */

 FCPCI1 */

 FCPCI0 */

 VSPD3 */

 VSPI2 */

 CSI21 */

 Core Clocks */

 Module Clocks */

 Critical Module Clocks */

 Callbacks */

 SPDX-License-Identifier: GPL-2.0

/*

 * RZ/G2L Clock Pulse Generator

 *

 * Copyright (C) 2021 Renesas Electronics Corp.

 *

 * Based on renesas-cpg-mssr.c

 *

 * Copyright (C) 2015 Glider bvba

 * Copyright (C) 2013 Ideas On Board SPRL

 * Copyright (C) 2015 Renesas Electronics Corp.

/**

 * struct rzg2l_cpg_priv - Clock Pulse Generator Private Data

 *

 * @rcdev: Reset controller entity

 * @dev: CPG device

 * @base: CPG register block base address

 * @rmw_lock: protects register accesses

 * @clks: Array containing all Core and Module Clocks

 * @num_core_clks: Number of Core Clocks in clks[]

 * @num_mod_clks: Number of Module Clocks in clks[]

 * @last_dt_core_clk: ID of the last Core Clock exported to DT

 * @notifiers: Notifier chain to save/restore clock state for system resume

 * @info: Pointer to platform data

	/*

	 * As per the HW manual, we should not directly switch from 533 MHz to

	 * 400 MHz and vice versa. To change the setting from 2’b01 (533 MHz)

	 * to 2’b10 (400 MHz) or vice versa, Switch to 2’b11 (266 MHz) first,

	 * and then switch to the target setting (2’b01 (533 MHz) or 2’b10

	 * (400 MHz)).

	 * Setting a value of '0' to the SEL_SDHI0_SET or SEL_SDHI1_SET clock

	 * switching register is prohibited.

	 * The clock mux has 3 input clocks(533 MHz, 400 MHz, and 266 MHz), and

	 * the index to value mapping is done by adding 1 to the index.

 Prohibited clk source, change it to 533 MHz(reset value) */

 Skip NULLified clock */

/**

 * struct mstp_clock - MSTP gating clock

 *

 * @hw: handle between common and hardware-specific interfaces

 * @off: register offset

 * @bit: ON/MON bit

 * @enabled: soft state of the clock, if it is coupled with another clock

 * @priv: CPG/MSTP private data

 * @sibling: pointer to the other coupled clock

 Skip NULLified clock */

 Reset module */

 Wait for at least one cycle of the RCLK clock (@ ca. 32 kHz) */

 Release module from reset state */

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0

/*

 * RZ/A1 Core CPG Clocks

 *

 * Copyright (C) 2013 Ideas On Board SPRL

 * Copyright (C) 2014 Wolfram Sang, Sang Engineering <wsa@sang-engineering.com>

 P0_2 */

/* -----------------------------------------------------------------------------

 * Initialization

 enable input buffer */

 If mapping regs failed, skip non-pll clocks. System will boot anyhow */

	/* FIXME:"i" and "g" are variable clocks with non-integer dividers (e.g. 2/3)

	 * and the constraint that always g <= i. To get the rz platform started,

	 * let them run at fixed current speed and implement the details later.

 SPDX-License-Identifier: GPL-2.0

/*

 * r8a77990 Clock Pulse Generator / Module Standby and Software Reset

 *

 * Copyright (C) 2018-2019 Renesas Electronics Corp.

 *

 * Based on r8a7795-cpg-mssr.c

 *

 * Copyright (C) 2015 Glider bvba

 * Copyright (C) 2015 Renesas Electronics Corp.

 Core Clock Outputs exported to DT */

 External Input Clocks */

 Internal Core Clocks */

 Module Clocks */

 External Clock Inputs */

 Internal Core Clocks */

 Core Clock Outputs */

 RWDT */

 INTC-AP (GIC) */

/*

 * CPG Clock Data

/*

 * MD19		EXTAL (MHz)	PLL0		PLL1		PLL3

 *--------------------------------------------------------------------

 * 0		48 x 1		x100/1		x100/3		x100/3

 * 1		48 x 1		x100/1		x100/3		 x58/3

 EXTAL div	PLL1 mult/div	PLL3 mult/div */

 Core Clocks */

 Module Clocks */

 Critical Module Clocks */

 Callbacks */

 SPDX-License-Identifier: GPL-2.0

/*

 * r8a774e1 Clock Pulse Generator / Module Standby and Software Reset

 *

 * Copyright (C) 2020 Renesas Electronics Corp.

 *

 * Based on r8a7795-cpg-mssr.c

 *

 * Copyright (C) 2015 Glider bvba

 Core Clock Outputs exported to DT */

 External Input Clocks */

 Internal Core Clocks */

 Module Clocks */

 External Clock Inputs */

 Internal Core Clocks */

 Core Clock Outputs */

 RWDT */

 INTC-AP (GIC) */

/*

 * CPG Clock Data

/*

 *   MD		EXTAL		PLL0	PLL1	PLL2	PLL3	PLL4	OSC

 * 14 13 19 17	(MHz)

 *-------------------------------------------------------------------------

 * 0  0  0  0	16.66 x 1	x180	x192	x144	x192	x144	/16

 * 0  0  0  1	16.66 x 1	x180	x192	x144	x128	x144	/16

 * 0  0  1  0	Prohibited setting

 * 0  0  1  1	16.66 x 1	x180	x192	x144	x192	x144	/16

 * 0  1  0  0	20    x 1	x150	x160	x120	x160	x120	/19

 * 0  1  0  1	20    x 1	x150	x160	x120	x106	x120	/19

 * 0  1  1  0	Prohibited setting

 * 0  1  1  1	20    x 1	x150	x160	x120	x160	x120	/19

 * 1  0  0  0	25    x 1	x120	x128	x96	x128	x96	/24

 * 1  0  0  1	25    x 1	x120	x128	x96	x84	x96	/24

 * 1  0  1  0	Prohibited setting

 * 1  0  1  1	25    x 1	x120	x128	x96	x128	x96	/24

 * 1  1  0  0	33.33 / 2	x180	x192	x144	x192	x144	/32

 * 1  1  0  1	33.33 / 2	x180	x192	x144	x128	x144	/32

 * 1  1  1  0	Prohibited setting

 * 1  1  1  1	33.33 / 2	x180	x192	x144	x192	x144	/32

 EXTAL div	PLL1 mult/div	PLL3 mult/div	OSC prediv */

 Prohibited setting */				},

 Prohibited setting */				},

 Prohibited setting */				},

 Prohibited setting */				},

 Core Clocks */

 Module Clocks */

 Critical Module Clocks */

 Callbacks */

 SPDX-License-Identifier: GPL-2.0

/*

 * r8a7790 Clock Pulse Generator / Module Standby and Software Reset

 *

 * Copyright (C) 2017 Glider bvba

 *

 * Based on clk-rcar-gen2.c

 *

 * Copyright (C) 2013 Ideas On Board SPRL

 Core Clock Outputs exported to DT */

 External Input Clocks */

 Internal Core Clocks */

 Module Clocks */

 External Clock Inputs */

 Internal Core Clocks */

 Core Clock Outputs */

 RWDT */

 INTC-SYS (GIC) */

/*

 * CPG Clock Data

/*

 *   MD		EXTAL		PLL0	PLL1	PLL3

 * 14 13 19	(MHz)		*1	*1

 *---------------------------------------------------

 * 0  0  0	15		x172/2	x208/2	x106

 * 0  0  1	15		x172/2	x208/2	x88

 * 0  1  0	20		x130/2	x156/2	x80

 * 0  1  1	20		x130/2	x156/2	x66

 * 1  0  0	26 / 2		x200/2	x240/2	x122

 * 1  0  1	26 / 2		x200/2	x240/2	x102

 * 1  1  0	30 / 2		x172/2	x208/2	x106

 * 1  1  1	30 / 2		x172/2	x208/2	x88

 *

 * *1 :	Table 7.5a indicates VCO output (PLLx = VCO/2)

 Core Clocks */

 Module Clocks */

 Critical Module Clocks */

 Callbacks */

 SPDX-License-Identifier: GPL-2.0

/*

 * r8a7796 (R-Car M3-W/W+) Clock Pulse Generator / Module Standby and Software

 * Reset

 *

 * Copyright (C) 2016-2019 Glider bvba

 * Copyright (C) 2018-2019 Renesas Electronics Corp.

 *

 * Based on r8a7795-cpg-mssr.c

 *

 * Copyright (C) 2015 Glider bvba

 * Copyright (C) 2015 Renesas Electronics Corp.

 Core Clock Outputs exported to DT */

 External Input Clocks */

 Internal Core Clocks */

 Module Clocks */

 External Clock Inputs */

 Internal Core Clocks */

 Core Clock Outputs */

 RWDT */

 INTC-AP (GIC) */

/*

 * CPG Clock Data

/*

 *   MD		EXTAL		PLL0	PLL1	PLL2	PLL3	PLL4	OSC

 * 14 13 19 17	(MHz)

 *-------------------------------------------------------------------------

 * 0  0  0  0	16.66 x 1	x180	x192	x144	x192	x144	/16

 * 0  0  0  1	16.66 x 1	x180	x192	x144	x128	x144	/16

 * 0  0  1  0	Prohibited setting

 * 0  0  1  1	16.66 x 1	x180	x192	x144	x192	x144	/16

 * 0  1  0  0	20    x 1	x150	x160	x120	x160	x120	/19

 * 0  1  0  1	20    x 1	x150	x160	x120	x106	x120	/19

 * 0  1  1  0	Prohibited setting

 * 0  1  1  1	20    x 1	x150	x160	x120	x160	x120	/19

 * 1  0  0  0	25    x 1	x120	x128	x96	x128	x96	/24

 * 1  0  0  1	25    x 1	x120	x128	x96	x84	x96	/24

 * 1  0  1  0	Prohibited setting

 * 1  0  1  1	25    x 1	x120	x128	x96	x128	x96	/24

 * 1  1  0  0	33.33 / 2	x180	x192	x144	x192	x144	/32

 * 1  1  0  1	33.33 / 2	x180	x192	x144	x128	x144	/32

 * 1  1  1  0	Prohibited setting

 * 1  1  1  1	33.33 / 2	x180	x192	x144	x192	x144	/32

 EXTAL div	PLL1 mult/div	PLL3 mult/div	OSC prediv */

 Prohibited setting */				},

 Prohibited setting */				},

 Prohibited setting */				},

 Prohibited setting */				},

	/*

	 * Fixups for R-Car M3-W+

 FCPCI0  */

 Core Clocks */

 Module Clocks */

 Critical Module Clocks */

 Callbacks */

 SPDX-License-Identifier: GPL-2.0

/*

 * r8a774c0 Clock Pulse Generator / Module Standby and Software Reset

 *

 * Copyright (C) 2018 Renesas Electronics Corp.

 *

 * Based on r8a77990-cpg-mssr.c

 *

 * Copyright (C) 2015 Glider bvba

 * Copyright (C) 2015 Renesas Electronics Corp.

 Core Clock Outputs exported to DT */

 External Input Clocks */

 Internal Core Clocks */

 Module Clocks */

 External Clock Inputs */

 Internal Core Clocks */

 Core Clock Outputs */

 RWDT */

 INTC-AP (GIC) */

/*

 * CPG Clock Data

/*

 * MD19		EXTAL (MHz)	PLL0		PLL1		PLL3

 *--------------------------------------------------------------------

 * 0		48 x 1		x100/1		x100/3		x100/3

 * 1		48 x 1		x100/1		x100/3		 x58/3

 EXTAL div	PLL1 mult/div	PLL3 mult/div */

 Core Clocks */

 Module Clocks */

 Critical Module Clocks */

 Callbacks */

 SPDX-License-Identifier: GPL-2.0

/*

 * r8a77470 Clock Pulse Generator / Module Standby and Software Reset

 *

 * Copyright (C) 2018 Renesas Electronics Corp.

 Core Clock Outputs exported to DT */

 External Input Clocks */

 Internal Core Clocks */

 Module Clocks */

 External Clock Inputs */

 Internal Core Clocks */

 Core Clock Outputs */

 RWDT */

 INTC-SYS (GIC) */

/*

 * CPG Clock Data

/*

 *    MD	EXTAL		PLL0	PLL1	PLL3

 * 14 13	(MHz)		*1	*2

 *---------------------------------------------------

 * 0  0		20		x80	x78	x50

 * 0  1		26		x60	x60	x56

 * 1  0		Prohibited setting

 * 1  1		30		x52	x52	x50

 *

 * *1 :	Table 7.4 indicates VCO output (PLL0 = VCO)

 * *2 :	Table 7.4 indicates VCO output (PLL1 = VCO)

 EXTAL div	PLL1 mult x2	PLL3 mult */

 Invalid*/				},

 Core Clocks */

 Module Clocks */

 Critical Module Clocks */

 Callbacks */

 SPDX-License-Identifier: GPL-2.0

/*

 * r8a7794 Clock Pulse Generator / Module Standby and Software Reset

 *

 * Copyright (C) 2017 Glider bvba

 *

 * Based on clk-rcar-gen2.c

 *

 * Copyright (C) 2013 Ideas On Board SPRL

 Core Clock Outputs exported to DT */

 External Input Clocks */

 Internal Core Clocks */

 Module Clocks */

 External Clock Inputs */

 Internal Core Clocks */

 Core Clock Outputs */

 RWDT */

 INTC-SYS (GIC) */

/*

 * CPG Clock Data

/*

 *   MD		EXTAL		PLL0	PLL1	PLL3

 * 14 13 19	(MHz)		*1	*2

 *---------------------------------------------------

 * 0  0  1	15		x200/3	x208/2	x88

 * 0  1  1	20		x150/3	x156/2	x66

 * 1  0  1	26 / 2		x230/3	x240/2	x102

 * 1  1  1	30 / 2		x200/3	x208/2	x88

 *

 * *1 :	Table 7.5c indicates VCO output (PLL0 = VCO/3)

 * *2 :	Table 7.5c indicates VCO output (PLL1 = VCO/2)

 Core Clocks */

 Module Clocks */

 Critical Module Clocks */

 Callbacks */

 SPDX-License-Identifier: GPL-2.0

/*

 * r8a779a0 Clock Pulse Generator / Module Standby and Software Reset

 *

 * Copyright (C) 2020 Renesas Electronics Corp.

 *

 * Based on r8a7795-cpg-mssr.c

 *

 * Copyright (C) 2015 Glider bvba

 * Copyright (C) 2015 Renesas Electronics Corp.

 PLL[23][01] */

 Select parent/divider using mode pin */

 OSC EXTAL predivider and fixed divider */

 Core Clock Outputs exported to DT */

 External Input Clocks */

 Internal Core Clocks */

 Module Clocks */

 External Clock Inputs */

 Internal Core Clocks */

 Core Clock Outputs */

/*

 * Z0 Clock & Z1 Clock

 Maximum rate for normal mode */

 Set parent rate to initial value for normal modes */

 Set increased parent rate for boost modes */

	/*

	 * Set KICK bit in FRQCRB to update hardware setting and wait for

	 * clock change completion.

	/*

	 * Note: There is no HW information about the worst case latency.

	 *

	 * Using experimental measurements, it seems that no more than

	 * ~10 iterations are needed, independently of the CPU rate.

	 * Since this value might be dependent on external xtal rate, pll1

	 * rate or even the other emulation clocks rate, use 1000 as a

	 * "super" safe value.

 PLLVCO x 1/div x SYS-CPU divider */

/*

 * RPC Clocks

 some types use high bits */

		/*

		 * Clock selectable between two parents and two fixed dividers

		 * using a mode pin

		/*

		 * Clock combining OSC EXTAL predivider and a fixed divider

 RWDT */

/*

 * CPG Clock Data

/*

 *   MD	 EXTAL		PLL1	PLL20	PLL30	PLL4	PLL5	OSC

 * 14 13 (MHz)			   21	   31

 * --------------------------------------------------------

 * 0  0	 16.66 x 1	x128	x216	x128	x144	x192	/16

 * 0  1	 20    x 1	x106	x180	x106	x120	x160	/19

 * 1  0	 Prohibited setting

 * 1  1	 33.33 / 2	x128	x216	x128	x144	x192	/32

 EXTAL div	PLL1 mult/div	PLL5 mult/div	OSC prediv */

 Core Clocks */

 Module Clocks */

 Critical Module Clocks */

 Callbacks */

 SPDX-License-Identifier: GPL-2.0

/*

 * r8a7792 Clock Pulse Generator / Module Standby and Software Reset

 *

 * Copyright (C) 2017 Glider bvba

 *

 * Based on clk-rcar-gen2.c

 *

 * Copyright (C) 2013 Ideas On Board SPRL

 Core Clock Outputs exported to DT */

 External Input Clocks */

 Internal Core Clocks */

 Module Clocks */

 External Clock Inputs */

 Internal Core Clocks */

 Core Clock Outputs */

 RWDT */

 INTC-SYS (GIC) */

/*

 * CPG Clock Data

/*

 *   MD		EXTAL		PLL0	PLL1	PLL3

 * 14 13 19	(MHz)		*1	*2

 *---------------------------------------------------

 * 0  0  0	15		x200/3	x208/2	x106

 * 0  0  1	15		x200/3	x208/2	x88

 * 0  1  0	20		x150/3	x156/2	x80

 * 0  1  1	20		x150/3	x156/2	x66

 * 1  0  0	26 / 2		x230/3	x240/2	x122

 * 1  0  1	26 / 2		x230/3	x240/2	x102

 * 1  1  0	30 / 2		x200/3	x208/2	x106

 * 1  1  1	30 / 2		x200/3	x208/2	x88

 *

 * *1 :	Table 7.5b indicates VCO output (PLL0 = VCO/3)

 * *2 :	Table 7.5b indicates VCO output (PLL1 = VCO/2)

 Core Clocks */

 Module Clocks */

 Critical Module Clocks */

 Callbacks */

 SPDX-License-Identifier: GPL-2.0

/*

 * r8a774b1 Clock Pulse Generator / Module Standby and Software Reset

 *

 * Copyright (C) 2019 Renesas Electronics Corp.

 *

 * Based on r8a7796-cpg-mssr.c

 *

 * Copyright (C) 2016 Glider bvba

 Core Clock Outputs exported to DT */

 External Input Clocks */

 Internal Core Clocks */

 Module Clocks */

 External Clock Inputs */

 Internal Core Clocks */

 Core Clock Outputs */

 RWDT */

 INTC-AP (GIC) */

/*

 * CPG Clock Data

/*

 *   MD		EXTAL		PLL0	PLL1	PLL3	PLL4	OSC

 * 14 13 19 17	(MHz)

 *-----------------------------------------------------------------

 * 0  0  0  0	16.66 x 1	x180	x192	x192	x144	/16

 * 0  0  0  1	16.66 x 1	x180	x192	x128	x144	/16

 * 0  0  1  0	Prohibited setting

 * 0  0  1  1	16.66 x 1	x180	x192	x192	x144	/16

 * 0  1  0  0	20    x 1	x150	x160	x160	x120	/19

 * 0  1  0  1	20    x 1	x150	x160	x106	x120	/19

 * 0  1  1  0	Prohibited setting

 * 0  1  1  1	20    x 1	x150	x160	x160	x120	/19

 * 1  0  0  0	25    x 1	x120	x128	x128	x96	/24

 * 1  0  0  1	25    x 1	x120	x128	x84	x96	/24

 * 1  0  1  0	Prohibited setting

 * 1  0  1  1	25    x 1	x120	x128	x128	x96	/24

 * 1  1  0  0	33.33 / 2	x180	x192	x192	x144	/32

 * 1  1  0  1	33.33 / 2	x180	x192	x128	x144	/32

 * 1  1  1  0	Prohibited setting

 * 1  1  1  1	33.33 / 2	x180	x192	x192	x144	/32

 EXTAL div	PLL1 mult/div	PLL3 mult/div	OSC prediv */

 Prohibited setting */				},

 Prohibited setting */				},

 Prohibited setting */				},

 Prohibited setting */				},

 Core Clocks */

 Module Clocks */

 Critical Module Clocks */

 Callbacks */

 SPDX-License-Identifier: GPL-2.0

/*

 * r8a7745 Clock Pulse Generator / Module Standby and Software Reset

 *

 * Copyright (C) 2016 Cogent Embedded Inc.

 Core Clock Outputs exported to DT */

 External Input Clocks */

 Internal Core Clocks */

 Module Clocks */

 External Clock Inputs */

 Internal Core Clocks */

 Core Clock Outputs */

 RWDT */

 INTC-SYS (GIC) */

/*

 * CPG Clock Data

/*

 *    MD	EXTAL		PLL0	PLL1	PLL3

 * 14 13 19	(MHz)		*1	*2

 *---------------------------------------------------

 * 0  0  1	15		x200/3	x208/2	x88

 * 0  1  1	20		x150/3	x156/2	x66

 * 1  0  1	26 / 2		x230/3	x240/2	x102

 * 1  1  1	30 / 2		x200/3	x208/2	x88

 *

 * *1 :	Table 7.5b indicates VCO output (PLL0 = VCO/3)

 * *2 :	Table 7.5b indicates VCO output (PLL1 = VCO/2)

 EXTAL div	PLL1 mult	PLL3 mult	PLL0 mult */

 Core Clocks */

 Module Clocks */

 Critical Module Clocks */

 Callbacks */

 SPDX-License-Identifier: GPL-2.0

/*

 * r8a77970 Clock Pulse Generator / Module Standby and Software Reset

 *

 * Copyright (C) 2017-2018 Cogent Embedded Inc.

 *

 * Based on r8a7795-cpg-mssr.c

 *

 * Copyright (C) 2015 Glider bvba

 Core Clock Outputs exported to DT */

 External Input Clocks */

 Internal Core Clocks */

 Module Clocks */

 External Clock Inputs */

 Internal Core Clocks */

 Core Clock Outputs */

 RWDT */

 INTC-AP (GIC) */

/*

 * CPG Clock Data

/*

 *   MD		EXTAL		PLL0	PLL1	PLL3

 * 14 13 19	(MHz)

 *-------------------------------------------------

 * 0  0  0	16.66 x 1	x192	x192	x96

 * 0  0  1	16.66 x 1	x192	x192	x80

 * 0  1  0	20    x 1	x160	x160	x80

 * 0  1  1	20    x 1	x160	x160	x66

 * 1  0  0	27    / 2	x236	x236	x118

 * 1  0  1	27    / 2	x236	x236	x98

 * 1  1  0	33.33 / 2	x192	x192	x96

 * 1  1  1	33.33 / 2	x192	x192	x80

 EXTAL div	PLL1 mult/div	PLL3 mult/div */

 Core Clocks */

 Module Clocks */

 Critical Module Clocks */

 Callbacks */

 SPDX-License-Identifier: GPL-2.0

/*

 * R-Car MSTP clocks

 *

 * Copyright (C) 2013 Ideas On Board SPRL

 * Copyright (C) 2015 Glider bvba

 *

 * Contact: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

/*

 * MSTP clocks. We can't use standard gate clocks as we need to poll on the

 * status register when enabling the clock.

/**

 * struct mstp_clock_group - MSTP gating clocks group

 *

 * @data: clock specifier translation for clocks in this group

 * @smstpcr: module stop control register

 * @mstpsr: module stop status register (optional)

 * @lock: protects writes to SMSTPCR

 * @width_8bit: registers are 8-bit, not 32-bit

 * @clks: clocks in this group

/**

 * struct mstp_clock - MSTP gating clock

 * @hw: handle between common and hardware-specific interfaces

 * @bit_index: control bit index

 * @group: MSTP clocks group

 dummy read to ensure write has completed */

 INTC-SYS is the module clock of the GIC, and must not be disabled */

 Skip clocks with no name. */

			/*

			 * Register a clkdev to let board code retrieve the

			 * clock by name and register aliases for non-DT

			 * devices.

			 *

			 * FIXME: Remove this when all devices that require a

			 * clock will be instantiated from DT.

 BSC on r8a73a4/sh73a0 uses zb_clk instead of an mstp clock */

 SPDX-License-Identifier: GPL-2.0

/*

 * r8a77980 Clock Pulse Generator / Module Standby and Software Reset

 *

 * Copyright (C) 2018 Renesas Electronics Corp.

 * Copyright (C) 2018 Cogent Embedded, Inc.

 *

 * Based on r8a7795-cpg-mssr.c

 *

 * Copyright (C) 2015 Glider bvba

 Core Clock Outputs exported to DT */

 External Input Clocks */

 Internal Core Clocks */

 Module Clocks */

 External Clock Inputs */

 Internal Core Clocks */

 Core Clock Outputs */

 RWDT */

 INTC-AP (GIC) */

/*

 * CPG Clock Data

/*

 *   MD		EXTAL		PLL2	PLL1	PLL3	OSC

 * 14 13	(MHz)

 * --------------------------------------------------------

 * 0  0		16.66 x 1	x240	x192	x192	/16

 * 0  1		20    x 1	x200	x160	x160	/19

 * 1  0		27    x 1	x148	x118	x118	/26

 * 1  1		33.33 / 2	x240	x192	x192	/32

 EXTAL div	PLL1 mult/div	PLL3 mult/div	OSC prediv */

 Core Clocks */

 Module Clocks */

 Critical Module Clocks */

 Callbacks */

 SPDX-License-Identifier: GPL-2.0

/*

 * r8a7742 Clock Pulse Generator / Module Standby and Software Reset

 *

 * Copyright (C) 2020 Renesas Electronics Corp.

 Core Clock Outputs exported to DT */

 External Input Clocks */

 Internal Core Clocks */

 Module Clocks */

 External Clock Inputs */

 Internal Core Clocks */

 Core Clock Outputs */

 RWDT */

 INTC-SYS (GIC) */

/*

 * CPG Clock Data

/*

 *    MD	EXTAL		PLL0	PLL1	PLL3

 * 14 13 19	(MHz)		*1	*1

 *---------------------------------------------------

 * 0  0  0	15		x172/2	x208/2	x106

 * 0  0  1	15		x172/2	x208/2	x88

 * 0  1  0	20		x130/2	x156/2	x80

 * 0  1  1	20		x130/2	x156/2	x66

 * 1  0  0	26 / 2		x200/2	x240/2	x122

 * 1  0  1	26 / 2		x200/2	x240/2	x102

 * 1  1  0	30 / 2		x172/2	x208/2	x106

 * 1  1  1	30 / 2		x172/2	x208/2	x88

 *

 * *1 :	Table 7.5a indicates VCO output (PLLx = VCO/2)

 EXTAL div	PLL1 mult	PLL3 mult */

 Core Clocks */

 Module Clocks */

 Critical Module Clocks */

 Callbacks */

 SPDX-License-Identifier: GPL-2.0

/*

 * Renesas R-Car USB2.0 clock selector

 *

 * Copyright (C) 2017 Renesas Electronics Corp.

 *

 * Based on renesas-cpg-mssr.c

 *

 * Copyright (C) 2015 Glider bvba

/*

 * This module seems a mux, but this driver assumes a gate because

 * ehci/ohci platform drivers don't support clk_set_parent() for now.

 * If this driver acts as a gate, ehci/ohci-platform drivers don't need

 * any modification.

 SPDX-License-Identifier: GPL-2.0

/*

 * R-Car Gen2 Clock Pulse Generator

 *

 * Copyright (C) 2016 Cogent Embedded Inc.

/*

 * Z Clock

 *

 * Traits of this clock:

 * prepare - clk_prepare only ensures that parents are prepared

 * enable - clk_enable only ensures that parents are enabled

 * rate - rate is adjustable.  clk->rate = parent->rate * mult / 32

 * parent - fixed parent.  No clk_set_parent support

	/*

	 * Set KICK bit in FRQCRB to update hardware setting and wait for

	 * clock change completion.

	/*

	 * Note: There is no HW information about the worst case latency.

	 *

	 * Using experimental measurements, it seems that no more than

	 * ~10 iterations are needed, independently of the CPU rate.

	 * Since this value might be dependent on external xtal rate, pll1

	 * rate or even the other emulation clocks rate, use 1000 as a

	 * "super" safe value.

 ADSP divisors */

 SDHI divisors */

 Skip first clock in SD table */

 sentinel */ }

 R-Car Gen2 */

		/*

		 * PLL0 is a  configurable multiplier clock except on R-Car

		 * V2H/E2. Register the PLL0 clock as a fixed factor clock for

		 * now as there's no generic multiplier clock implementation and

		 * we  currently  have no need to change  the multiplier value.

 SPDX-License-Identifier: GPL-2.0

/*

 * r8a7740 Core CPG Clocks

 *

 * Copyright (C) 2014  Ulrich Hecht

 extal1 */

 extal1 */

 extalr */

		/* PLLC0/1 are configurable multiplier clocks. Register them as

		 * fixed factor clocks for now as there's no generic multiplier

		 * clock implementation and we currently have no need to change

		 * the multiplier value.

 extal2 */

		/* We're leaking memory on purpose, there's no point in cleaning

		 * up as the system won't boot anyway.

 SPDX-License-Identifier: GPL-2.0

/*

 * r8a73a4 Core CPG Clocks

 *

 * Copyright (C) 2014  Ulrich Hecht

 extal1 */

 extal1 / 2 */

 extal2 */

 extal2 / 2 */

		/* PLL0/1 are configurable multiplier clocks. Register them as

		 * fixed factor clocks for now as there's no generic multiplier

		 * clock implementation and we currently have no need to change

		 * the multiplier value.

 XXX: enable bit? */

 XXX: enable bit? */

		/* We're leaking memory on purpose, there's no point in cleaning

		 * up as the system won't boot anyway.

 SPDX-License-Identifier: GPL-2.0

/*

 * R9A06G032 clock driver

 *

 * Copyright (C) 2018 Renesas Electronics Europe Limited

 *

 * Michel Pollet <michel.pollet@bp.renesas.com>, <buserror@gmail.com>

 This is used to describe a clock for instantiation */

 source index + 1 (0 == none) */

 these are used to populate the bitsel struct */

 for dividers */

 For fixed-factor ones */

 for dual gate */

 Internal clock IDs */

	/*

	 * These are not hardware clocks, but are needed to handle the special

	 * case where we have a 'selector bit' that doesn't just change the

	 * parent for a clock, but also the gate it's supposed to use.

 R9A06G032_SYSCTRL_REG_PWRCTRL_PG1_PR2 */

 R9A06G032_SYSCTRL_REG_PWRCTRL_PG0_0 */

 protects concurrent access to gates */

 register/bit pairs are encoded as an uint16_t */

/*

 * This implements the R9A06G032 clock gate 'driver'. We cannot use the system's

 * clock gate framework as the gates on the R9A06G032 have a special enabling

 * sequence, therefore we use this little proxy.

 De-assert reset */

 Hardware manual recommends 5us delay after enabling clock & reset */

	/* If the peripheral is memory mapped (i.e. an AXI slave), there is an

	 * associated SLVRDY bit in the System Controller that needs to be set

	 * so that the FlexWAY bus fabric passes on the read/write requests.

 Clear 'Master Idle Request' bit */

 Note: We don't wait for FlexWAY Socket Connection signal */

 if clock is in reset, the gate might be on, and still not 'be' on */

	/*

	 * important here, some clocks are already in use by the CM3, we

	 * have to assume they are not Linux's to play with and try to disable

	 * at the end of the boot!

 we know there are no more than 8 */

/*

 * Attempts to find a value that is in range of min,max,

 * and if a table of set dividers was specified for this

 * register, try to find the fixed divider that is the closest

 * to the target frequency

 + 1 to cope with rates that have the remainder dropped */

			/*

			 * select the divider that generates

			 * the value closest to the ideal frequency

	/*

	 * this is a hack. Currently the serial driver asks for a clock rate

	 * that is 16 times the baud rate -- and that is wildly outside the

	 * range of the UART divider, somehow there is no provision for that

	 * case of 'let the divider as is if outside range'.

	 * The serial driver *shouldn't* play with these clocks anyway, there's

	 * several uarts attached to this divider, and changing this impacts

	 * everyone.

 + 1 to cope with rates that have the remainder dropped */

	/*

	 * Need to write the bit 31 with the divider value to

	 * latch it. Technically we should wait until it has been

	 * cleared too.

	 * TODO: Find whether this callback is sleepable, in case

	 * the hardware /does/ require some sort of spinloop here.

 populate (optional) divider table fixed values */

/*

 * This clock provider handles the case of the R9A06G032 where you have

 * peripherals that have two potential clock source and two gates, one for

 * each of the clock source - the used clock source (for all sub clocks)

 * is selected by a single bit.

 * That single bit affects all sub-clocks, and therefore needs to change the

 * active gate (and turn the others off) and force a recalculation of the rates.

 *

 * This implements two clock providers, one 'bitselect' that

 * handles the switch between both parents, and another 'dualgate'

 * that knows which gate to poke at, depending on the parent's bit position.

 selector register + bit */

 a single bit in the register selects one of two parent clocks */

 allocate the gate */

 selector register + bit */

 we always turn off the 'other' gate, regardless */

 allocate the gate */

	/*

	 * important here, some clocks are already in use by the CM3, we

	 * have to assume they are not Linux's to play with and try to disable

	 * at the end of the boot!

 keep that selector register around */

 SPDX-License-Identifier: GPL-2.0

/*

 * R-Car Gen3 Clock Pulse Generator Library

 *

 * Copyright (C) 2015-2018 Glider bvba

 * Copyright (C) 2019 Renesas Electronics Corp.

 *

 * Based on clk-rcar-gen3.c

 *

 * Copyright (C) 2015 Renesas Electronics Corp.

/*

 * SDn Clock

/* SDn divider

 *           sd_srcfc   sd_fc   div

 * stp_hck   (div)      (div)     = sd_srcfc x sd_fc

 *---------------------------------------------------------

 *  0         0 (1)      1 (4)      4 : SDR104 / HS200 / HS400 (8 TAP)

 *  0         1 (2)      1 (4)      8 : SDR50

 *  1         2 (4)      1 (4)     16 : HS / SDR25

 *  1         3 (8)      1 (4)     32 : NS / SDR12

 *  1         4 (16)     1 (4)     64

 *  0         0 (1)      0 (2)      2

 *  0         1 (2)      0 (2)      4 : SDR104 / HS200 / HS400 (4 TAP)

 *  1         2 (4)      0 (2)      8

 *  1         3 (8)      0 (2)     16

 *  1         4 (16)     0 (2)     32

 *

 *  NOTE: There is a quirk option to ignore the first row of the dividers

 *  table when searching for suitable settings. This is because HS400 on

 *  early ES versions of H3 and M3-W requires a specific setting to work.

	CPG_SD_DIV_TABLE_DATA(stp_hck,  sd_srcfc,   sd_fc,  sd_div) */

	/*

	 * One notifier covers both RPC and RPCD2 clocks as they are both

	 * controlled by the same RPCCKCR register...

 SPDX-License-Identifier: GPL-2.0

/*

 * r8a7791 Clock Pulse Generator / Module Standby and Software Reset

 *

 * Copyright (C) 2015-2017 Glider bvba

 *

 * Based on clk-rcar-gen2.c

 *

 * Copyright (C) 2013 Ideas On Board SPRL

 Core Clock Outputs exported to DT */

 External Input Clocks */

 Internal Core Clocks */

 Module Clocks */

 External Clock Inputs */

 Internal Core Clocks */

 Core Clock Outputs */

 RWDT */

 INTC-SYS (GIC) */

/*

 * CPG Clock Data

/*

 *   MD		EXTAL		PLL0	PLL1	PLL3

 * 14 13 19	(MHz)		*1	*1

 *---------------------------------------------------

 * 0  0  0	15		x172/2	x208/2	x106

 * 0  0  1	15		x172/2	x208/2	x88

 * 0  1  0	20		x130/2	x156/2	x80

 * 0  1  1	20		x130/2	x156/2	x66

 * 1  0  0	26 / 2		x200/2	x240/2	x122

 * 1  0  1	26 / 2		x200/2	x240/2	x102

 * 1  1  0	30 / 2		x172/2	x208/2	x106

 * 1  1  1	30 / 2		x172/2	x208/2	x88

 *

 * *1 :	Table 7.5a indicates VCO output (PLLx = VCO/2)

 R-Car M2-N uses a 1/5 divider for ZG */

 Core Clocks */

 Module Clocks */

 Critical Module Clocks */

 Callbacks */

 SPDX-License-Identifier: GPL-2.0

/*

 * r8a7778 Core CPG Clocks

 *

 * Copyright (C) 2014  Ulrich Hecht

 PLL multipliers per bits 11, 12, and 18 of MODEMR */

 Clock dividers per bits 1 and 2 of MODEMR */

		/* We're leaking memory on purpose, there's no point in cleaning

		 * up as the system won't boot anyway.

 SPDX-License-Identifier: GPL-2.0

/*

 * r8a7779 Core CPG Clocks

 *

 * Copyright (C) 2013, 2014 Horms Solutions Ltd.

 *

 * Contact: Simon Horman <horms@verge.net.au>

/* -----------------------------------------------------------------------------

 * CPG Clock Data

/*

 *		MD1 = 1			MD1 = 0

 *		(PLLA = 1500)		(PLLA = 1600)

 *		(MHz)			(MHz)

 *------------------------------------------------+--------------------

 * clkz		1000   (2/3)		800   (1/2)

 * clkzs	 250   (1/6)		200   (1/8)

 * clki		 750   (1/2)		800   (1/2)

 * clks		 250   (1/6)		200   (1/8)

 * clks1	 125   (1/12)		100   (1/16)

 * clks3	 187.5 (1/8)		200   (1/8)

 * clks4	  93.7 (1/16)		100   (1/16)

 * clkp		  62.5 (1/24)		 50   (1/32)

 * clkg		  62.5 (1/24)		 66.6 (1/24)

 * clkb, CLKOUT

 * (MD2 = 0)	  62.5 (1/24)		 66.6 (1/24)

 * (MD2 = 1)	  41.6 (1/36)		 50   (1/32)

/*

 *   MD		PLLA Ratio

 * 12 11

 *------------------------

 * 0  0		x42

 * 0  1		x48

 * 1  0		x56

 * 1  1		x64

/* -----------------------------------------------------------------------------

 * Initialization

		/* We're leaking memory on purpose, there's no point in cleaning

		 * up as the system won't boot anyway.

 SPDX-License-Identifier: GPL-2.0

/*

 * R-Car Gen3 Clock Pulse Generator

 *

 * Copyright (C) 2015-2018 Glider bvba

 * Copyright (C) 2019 Renesas Electronics Corp.

 *

 * Based on clk-rcar-gen3.c

 *

 * Copyright (C) 2015 Renesas Electronics Corp.

 PLL Enable Control Register */

 PLLn Circuit Status */

 PLLn Control Registers */

 PLL Circuit Mult. Ratio */

 RCLK Clock Source Select */

 PLL Clocks */

 PLL refclk x (setting + 1) x mult */

/*

 * Z Clock & Z2 Clock

 *

 * Traits of this clock:

 * prepare - clk_prepare only ensures that parents are prepared

 * enable - clk_enable only ensures that parents are enabled

 * rate - rate is adjustable.

 *        clk->rate = (parent->rate * mult / 32 ) / fixed_div

 * parent - fixed parent.  No clk_set_parent support

 Maximum rate for normal mode */

 Set parent rate to initial value for normal modes */

 Set increased parent rate for boost modes */

	/*

	 * Set KICK bit in FRQCRB to update hardware setting and wait for

	 * clock change completion.

	/*

	 * Note: There is no HW information about the worst case latency.

	 *

	 * Using experimental measurements, it seems that no more than

	 * ~10 iterations are needed, independently of the CPU rate.

	 * Since this value might be dependent on external xtal rate, pll1

	 * rate or even the other emulation clocks rate, use 1000 as a

	 * "super" safe value.

 PLLVCO x 1/div x SYS-CPU divider */

 Missing PLL0/2/4 post-divider */

 Manual RCLK parent selection */

 Skip first clock in SD table */

 sentinel */ }

 some types use high bits */

		/*

		 * PLL0 is implemented as a custom clock, to change the

		 * multiplier when cpufreq changes between normal and boost

		 * modes.

		/*

		 * PLL2 is implemented as a custom clock, to change the

		 * multiplier when cpufreq changes between normal and boost

		 * modes.

		/*

		 * PLL4 is a configurable multiplier clock. Register it as a

		 * fixed factor clock for now as there's no generic multiplier

		 * clock implementation and we currently have no need to change

		 * the multiplier value.

			/*

			 * RINT is default.

			 * Only if EXTALR is populated, we switch to it.

 Select parent clock of RCLK by MD28 */

		/*

		 * Clock selectable between two parents and two fixed dividers

		 * using a mode pin

		/*

		 * Clock combining OSC EXTAL predivider and a fixed divider

		/*

		 * Clock selectable between two parents and two fixed dividers

		 * using RCKCR.CKSEL

		/*

		 * Register RPCSRC as fixed factor clock based on the

		 * MD[4:1] pins and CPG_RPCCKCR[4:3] register value for

		 * which has been set prior to booting the kernel.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2014 Google, Inc.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2014 Google, Inc.

 Fractional PLL operating modes */

 calculate vco */

 set operating mode */

 get operating mode (int/frac) and calculate rate accordingly */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Pistachio SoC clock controllers

 *

 * Copyright (C) 2014 Google, Inc.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) 2015 Heiko Stuebner <heiko@sntech.de>

 sentinel */ },

 sentinel */ },

 cluster_b: aclkm in clksel0, rest in clksel1 */

 cluster_l: aclkm in clksel2, rest in clksel3 */

	/*

	 * Clock-Architecture Diagram 2

	/*

	 * stclk_mcu is listed as child of fclk_mcu_src in diagram 5,

	 * but stclk_mcu has an additional own divider in diagram 2

	/*

	 * Clock-Architecture Diagram 3

	/*

	 * We use aclk_vdpu by default ---GRF_SOC_CON0[7] setting in system,

	 * so we ignore the mux and make clocks nodes as following,

 sclk_timer has a gate in the sgrf */

	/*

	 * Clock-Architecture Diagram 4

 pmu_grf_soc_con0[6] allows to select between xin32k and pvtm_pmu */

 pmu_grf_soc_con0[6] allows to select between xin32k and pvtm_pmu */

	/*

	 * Clock-Architecture Diagram 5

 aclk_cci_pre gates */

 aclkm_core_* gates */

 armclk* gates */

 sclk_cs_pre gates */

 aclk_bus gates */

 sclk_ddr gates */

 clk_hsadc_tsp is part of diagram2 */

 fclk_mcu_src gates */

 hclk_cpu gates */

 pclk_cpu gates */

	/*

	 * video clk gates

	 * aclk_video(_pre) can actually select between parents of aclk_vdpu

	 * and aclk_vepu by setting bit GRF_SOC_CON0[7].

 aclk_rga_pre gates */

 aclk_vio0 gates */

 sclk_isp gates */

 hclk_vio gates */

	/*

	 * pclk_vio gates

	 * pclk_vio comes from the exactly same source as hclk_vio

 ext_vip gates in diagram3 */

 gpu gates */

 aclk_peri gates */

 hclk_peri gates */

 pclk_peri gates */

 pclk_pd_alive gates */

 Watchdog pclk is controlled by sgrf_soc_con3[7]. */

	/*

	 * pclk_vio gates

	 * pclk_vio comes from the exactly same source as hclk_vio

 pclk_pd_pmu gates */

 timer gates */

	/*

	 * pwm1 supplies vdd_logic on a lot of boards, is currently unhandled

	 * but needs to stay enabled there (including its parents) at all times.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) 2016 Rockchip Electronics Co. Ltd.

 * Author: Elaine <zhangqing@rock-chips.com>

 _mhz, _refdiv, _fbdiv, _postdiv1, _postdiv2, _dsmpd, _frac */

 sentinel */ },

 _mhz, _refdiv, _fbdiv, _postdiv1, _postdiv2, _dsmpd, _frac */

 vco = 1016064000 */

 vco = 983040000 */

 vco = 983040000 */

 vco = 860156000 */

 vco = 903168000 */

 vco = 819200000 */

 sentinel */ },

	/*

	 * Clock-Architecture Diagram 1

 PD_MISC */

	/*

	 * Clock-Architecture Diagram 2

 PD_CORE */

 PD_GPU */

 PD_DDR */

	/*

	 * Clock-Architecture Diagram 3

 PD_BUS */

 PD_I2S */

 PD_UART */

	/*

	 * Clock-Architecture Diagram 4

	/*

	 * Clock-Architecture Diagram 5

 PD_VIDEO */

	/*

	 * Clock-Architecture Diagram 6

 PD_VIO */

	/*

	 * Clock-Architecture Diagram 7

 PD_PERI */

	/*

	 * Clock-Architecture Diagram 8

 PD_GMAC */

	/*

	 * Clock-Architecture Diagram 9

 PD_VOP */

 PD_PERI */

 PD_GMAC */

 PD_BUS */

 Watchdog pclk is controlled from the secure GRF */

 PD_MMC */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) 2014 MundoReader S.L.

 * Author: Heiko Stuebner <heiko@sntech.de>

 *

 * Copyright (c) 2016 Rockchip Electronics Co. Ltd.

 * Author: Xing Zheng <zhengxing@rock-chips.com>

 *

 * based on

 *

 * samsung/clk.c

 * Copyright (c) 2013 Samsung Electronics Co., Ltd.

 * Copyright (c) 2013 Linaro Ltd.

 * Author: Thomas Abraham <thomas.ab@samsung.com>

/*

 * Register a clock branch.

 * Most clock branches have a form like

 *

 * src1 --|--\

 *        |M |--[GATE]-[DIV]-

 * src2 --|--/

 *

 * sometimes without one of those components.

		/*

		 * The POST_RATE_CHANGE notifier runs directly after the

		 * divider clock is set in clk_change_rate, so we'll have

		 * remuxed back to the original parent before clk_change_rate

		 * reaches the mux itself.

/*

 * fractional divider must set that denominator is 20 times larger than

 * numerator to generate precise clock frequency.

 notifier on the fraction divider to catch rate changes */

 without gate, register a simple factor clock */

 catch simple muxes */

 none of the cases above matched */

 Protect the clocks that needs to stay on */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2021 Rockchip Electronics Co. Ltd.

 * Author: Elaine Zhang <zhangqing@rock-chips.com>

 _mhz, _refdiv, _fbdiv, _postdiv1, _postdiv2, _dsmpd, _frac */

 sentinel */ },

	/*

	 * Clock-Architecture Diagram 1

 SRC_CLK */

 PD_CORE */

 PD_GPU */

 PD_NPU */

 PD_DDR */

 PD_GIC_AUDIO */

 PD_SECURE_FLASH */

 PD_PIPE */

 PD_PHP */

 PD_USB */

 PD_PERI */

 PD_VI */

 PD_VO */

 PD_VPU */

 PD_RGA */

 PD_RKVENC */

 PD_BUS */

 PD_TOP */

 PD_PMU */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) 2016 Rockchip Electronics Co. Ltd.

 * Author: Lin Huang <hl@rock-chips.com>

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) 2015 Rockchip Electronics Co. Ltd.

 * Author: Xing Zheng <zhengxing@rock-chips.com>

 *         Jeffy Chen <jeffy.chen@rock-chips.com>

 _mhz, _refdiv, _fbdiv, _postdiv1, _postdiv2, _dsmpd, _frac */

 sentinel */ },

	/*

	 * Clock-Architecture Diagram 1

 PD_DDR */

 PD_CORE */

 PD_MISC */

 PD_BUS */

 PD_VIDEO */

 PD_VIO */

 PD_PERI */

	/*

	 * Clock-Architecture Diagram 2

 PD_UART */

	/*

	 * Clock-Architecture Diagram 3

 PD_VOP */

 PD_PERI */

 PD_GPU */

 PD_BUS */

 PD_MMC */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) 2014 MundoReader S.L.

 * Author: Heiko Stuebner <heiko@sntech.de>

 sentinel */ },

 2 ^ (val + 1) */

 sentinel */ },

	/*

	 * Clock-Architecture Diagram 2

 these two are set by the cpuclk and should not be changed */

	/*

	 * the 480m are generated inside the usb block from these clocks,

	 * but they are also a source for the hsicphy clock.

	/*

	 * Clock-Architecture Diagram 4

 clk_core_pre gates */

 aclk_cpu gates */

 hclk_cpu gates */

 hclk_ahb2apb is part of a clk branch */

 hclk_peri gates */

 aclk_lcdc0_pre gates */

 aclk_lcdc1_pre gates */

 atclk_cpu gates */

 pclk_cpu gates */

 aclk_peri */

 pclk_peri gates */

 sentinel */ },

 sentinel */ },

 do not source aclk_cpu_pre from the apll, to keep complexity down */

 reparent aclk_cpu_pre from apll */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) 2017 Rockchip Electronics Co. Ltd.

 * Author: Elaine <zhangqing@rock-chips.com>

 _mhz, _refdiv, _fbdiv, _postdiv1, _postdiv2, _dsmpd, _frac */

 sentinel */ },

	/*

	 * Clock-Architecture Diagram 1

 PD_DDR */

 PD_CORE */

 PD_MISC */

 PD_CPU */

 PD_VIDEO */

 PD_VIO */

 PD_PERI */

	/*

	 * Clock-Architecture Diagram 2

 PD_UART */

	/*

	 * Clock-Architecture Diagram 3

 PD_VOP */

 PD_PERI */

 PD_BUS */

 PD_MMC */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) 2014 MundoReader S.L.

 * Author: Heiko Stuebner <heiko@sntech.de>

 *

 * Copyright (c) 2015 Rockchip Electronics Co. Ltd.

 * Author: Xing Zheng <zhengxing@rock-chips.com>

 Assumming rate_table is in descending order */

 return minimum supported value */

/*

 * Wait for the pll to reach the locked state.

 * The calling set_rate function is responsible for making sure the

 * grf regmap is available.

/*

 * PLL used in RK3036

	/*

	 * Lock time typical 250, max 500 input clock cycles @24MHz

	 * So define a very safe maximum of 1000us, meaning 24000 cycles.

 fractional mode */

 update pll values */

 GPLL CON2 is not HIWORD_MASK */

 wait for the pll to lock */

 Get required rate settings from table */

 when no rate setting for the current rate, rely on clk_set_rate */

/*

 * PLL used in RK3066, RK3188 and RK3288

 enter reset mode */

 update pll values */

 leave reset and wait the reset_delay */

 wait for the pll to lock */

 Get required rate settings from table */

 when no rate setting for the current rate, rely on clk_set_rate */

/*

 * PLL used in RK3399

	/*

	 * Lock time typical 250, max 500 input clock cycles @24MHz

	 * So define a very safe maximum of 1000us, meaning 24000 cycles.

 fractional mode */

 update pll values */

 xPLL CON2 is not HIWORD_MASK */

 wait for the pll to lock */

 Get required rate settings from table */

 when no rate setting for the current rate, rely on clk_set_rate */

/*

 * Common registering of pll clocks

 name the actual pll */

 create the mux on top of the real pll */

 the actual muxing is xin24m, pll-output, xin32k */

 now create the actual pll */

 keep all plls untouched for now */

 find count of rates in rate_table */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2014 MundoReader S.L.

 * Author: Heiko Stuebner <heiko@sntech.de>

 *

 * based on clk/samsung/clk-cpu.c

 * Copyright (c) 2014 Samsung Electronics Co., Ltd.

 * Author: Thomas Abraham <thomas.ab@samsung.com>

 *

 * A CPU clock is defined as a clock supplied to a CPU or a group of CPUs.

 * The CPU clock is typically derived from a hierarchy of clock

 * blocks which includes mux and divider blocks. There are a number of other

 * auxiliary clocks supplied to the CPU domain such as the debug blocks and AXI

 * clock for CPU domain. The rates of these auxiliary clocks are related to the

 * CPU clock rate and this relation is usually specified in the hardware manual

 * of the SoC or supplied after the SoC characterization.

 *

 * The below implementation of the CPU clock allows the rate changes of the CPU

 * clock and the corresponding rate changes of the auxillary clocks of the CPU

 * domain. The platform clock driver provides a clock register configuration

 * for each configurable rate which is then used to program the clock hardware

 * registers to acheive a fast co-oridinated rate change for all the CPU domain

 * clocks.

 *

 * On a rate change request for the CPU clock, the rate change is propagated

 * upto the PLL supplying the clock to the CPU domain clock blocks. While the

 * CPU domain PLL is reconfigured, the CPU domain clocks are driven using an

 * alternate clock source. If required, the alternate clock source is divided

 * down in order to keep the output clock rate within the previous OPP limits.

/**

 * struct rockchip_cpuclk: information about clock supplied to a CPU core.

 * @hw:		handle between ccf and cpu clock.

 * @alt_parent:	alternate parent clock to use when switching the speed

 *		of the primary parent clock.

 * @reg_base:	base register for cpu-clock values.

 * @clk_nb:	clock notifier registered for changes in clock speed of the

 *		primary parent clock.

 * @rate_count:	number of rates in the rate_table

 * @rate_table:	pll-rates and their associated dividers

 * @reg_data:	cpu-specific register settings

 * @lock:	clock lock

 alternate parent is active now. set the dividers */

 check validity of the new rate */

	/*

	 * If the old parent clock speed is less than the clock speed

	 * of the alternate parent, then it should be ensured that at no point

	 * the armclk speed is more than the old_rate until the dividers are

	 * set.

 calculate dividers */

		/*

		 * Change parents and add dividers in a single transaction.

		 *

		 * NOTE: we do this in a single transaction so we're never

		 * dividing the primary parent by the extra dividers that were

		 * needed for the alt.

 select alternate parent */

	/*

	 * post-rate change event, re-mux to primary parent and remove dividers.

	 *

	 * NOTE: we do this in a single transaction so we're never dividing the

	 * primary parent by the extra dividers that were needed for the alt.

 remove dividers */

/*

 * This clock notifier is called when the frequency of the parent clock

 * of cpuclk is to be changed. This notifier handles the setting up all

 * the divider clocks, remux to temporary parent and handling the safe

 * frequency levels when using temporary parent.

 only allow rate changes when we have a rate table */

 disallow automatic parent changes by ccf */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) 2014 MundoReader S.L.

 * Author: Heiko Stuebner <heiko@sntech.de>

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) 2014 MundoReader S.L.

 * Author: Heiko Stuebner <heiko@sntech.de>

 sentinel */ },

 sentinel */},

	/*

	 * Clock-Architecture Diagram 1

	/*

	 * Clock-Architecture Diagram 2

	/*

	 * Clock-Architecture Diagram 3

	/*

	 * Clock-Architecture Diagram 4

 aclk_cpu gates */

 hclk_cpu gates */

 pclk_cpu gates */

 ddrctrl [DDR Controller PHY clock] gates */

 ddrphy gates */

 aclk_peri gates */

 hclk_peri gates */

 pclk_peri gates */

 sclk_gpu gates */

 pclk_pd_alive gates */

 Watchdog pclk is controlled by RK3288_SGRF_SOC_CON0[1]. */

 pclk_pd_pmu gates */

 hclk_vio gates */

 aclk_vio0 gates */

 aclk_vio1 gates */

 aclk_rga_pre gates */

	/*

	 * Other ungrouped clocks.

 pwm-regulators on some boards, so handoff-critical later */

/*

 * Some CRU registers will be reset in maskrom when the system

 * wakes up from fastboot.

 * So save them before suspend, restore them after resume.

 We turn aclk_dmac1 on for suspend; this will restore it */

	/*

	 * Going into deep sleep (specifically setting PMU_CLR_DMA in

	 * RK3288_PMU_PWRMODE_CON1) appears to fail unless

	 * "aclk_dmac1" is on.

	/*

	 * Switch PLLs other than DPLL (for SDRAM) to slow mode to

	 * avoid crashes on resume. The Mask ROM on the system will

	 * put APLL, CPLL, and GPLL into slow mode at resume time

	 * anyway (which is why we restore them), but we might not

	 * even make it to the Mask ROM if this isn't done at suspend

	 * time.

	 *

	 * NOTE: only APLL truly matters here, but we'll do them all.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) 2016 Rockchip Electronics Co. Ltd.

 * Author: Shawn Lin <shawn.lin@rock-chips.com>

 *         Andy Yan <andy.yan@rock-chips.com>

 _mhz, _refdiv, _fbdiv, _postdiv1, _postdiv2, _dsmpd, _frac */

 sentinel */ },

	/*

	 * Clock-Architecture Diagram 2

 PD_CORE */

 PD_RKVENC */

 PD_RKVDEC */

 PD_PMU_wrapper */

	/*

	 * Clock-Architecture Diagram 3

 PD_DSP_wrapper */

	/*

	 * Clock-Architecture Diagram 4

	/*

	 * Clock-Architecture Diagram 5

 PD_BUS */

 PD_DDR */

	/*

	 * Clock-Architecture Diagram 6

 PD_PERI */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2018 Fuzhou Rockchip Electronics Co., Ltd

	/*

	 * The maximum divider we can use without overflowing

	 * unsigned long in rate * i below

			/*

			 * It's the most ideal case if the requested rate can be

			 * divided from parent clock without needing to change

			 * parent rate, so return the divider immediately.

/*

 * Register a clock branch.

 * Most clock branches have a form like

 *

 * src1 --|--\

 *        |M |--[GATE]-[DIV]-

 * src2 --|--/

 *

 * sometimes without one of those components.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) 2014 MundoReader S.L.

 * Author: Heiko Stuebner <heiko@sntech.de>

 *

 * Copyright (c) 2015 Rockchip Electronics Co. Ltd.

 * Author: Xing Zheng <zhengxing@rock-chips.com>

 _mhz, _refdiv, _fbdiv, _postdiv1, _postdiv2, _dsmpd, _frac */

 sentinel */ },

	/*

	 * Clock-Architecture Diagram 1

	/*

	 * Clock-Architecture Diagram 2

	/*

	 * Clock-Architecture Diagram 3

 aclk_cpu gates */

 hclk_cpu gates */

 pclk_cpu gates */

 aclk_vio gates */

 xin24m gates */

 aclk_peri gates */

 hclk_peri gates */

 pclk_peri gates */

	/*

	 * Make uart_pll_clk a child of the gpll, as all other sources are

	 * not that usable / stable.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) 2018 Rockchip Electronics Co. Ltd.

 * Author: Elaine Zhang<zhangqing@rock-chips.com>

 _mhz, _refdiv, _fbdiv, _postdiv1, _postdiv2, _dsmpd, _frac */

 sentinel */ },

	/*

	 * Clock-Architecture Diagram 1

	/*

	 * Clock-Architecture Diagram 3

 PD_CORE */

 PD_GPU */

	/*

	 * Clock-Architecture Diagram 4

 PD_DDR */

	/*

	 * Clock-Architecture Diagram 5

 PD_VI */

	/*

	 * Clock-Architecture Diagram 6

 PD_VO */

 PD_VPU */

	/*

	 * Clock-Architecture Diagram 7

 PD_MMC_NAND */

 PD_SDCARD */

 PD_USB */

 PD_GMAC */

	/*

	 * Clock-Architecture Diagram 8

 PD_BUS */

 PD_CRYPTO */

	/*

	 * Clock-Architecture Diagram 9

 PD_BUS_TOP */

 PD_VI */

 PD_VO */

 PD_BUS */

 aclk_dmac is controlled by sgrf_soc_con1[11]. */

 PD_VPU */

 PD_CRYPTO */

 PD_SDCARD */

 PD_PERI */

 PD_MMC_NAND */

 PD_USB */

 PD_GMAC */

	/*

	 * Clock-Architecture Diagram 2

	/*

	 * Clock-Architecture Diagram 9

 PD_PMU */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) 2016 Rockchip Electronics Co. Ltd.

 * Author: Xing Zheng <zhengxing@rock-chips.com>

 _mhz, _refdiv, _fbdiv, _postdiv1, _postdiv2, _dsmpd, _frac */

 sentinel */ },

 CRU parents */

 PMU CRU parents */

 cluster_l: aclkm in clksel0, rest in clksel1 */

 cluster_b: aclkm in clksel2, rest in clksel3 */

	/*

	 * CRU Clock-Architecture

 usbphy */

 little core */

 big core */

 gmac */

 spdif */

 i2s */

 uart */

 cci */

 vcodec */

 vdu */

 iep */

 rga */

 center */

 gpu */

 perihp */

 sdio & sdmmc */

 pcie */

 emmc */

 perilp0 */

 aclk_perilp0 gates */

 hclk_perilp0 gates */

 pclk_perilp0 gates */

 crypto */

 cm0s_perilp */

 fclk_cm0s gates */

 perilp1 */

 hclk_perilp1 gates */

 pclk_perilp1 gates */

 saradc */

 tsadc */

 cif_testout */

 vio */

 hdcp */

 edp */

 hdmi */

 vop0 */

 vop1 */

 isp */

	/*

	 * We use pclkin_cifinv by default GRF_SOC_CON20[9] (GSC20_9) setting in system,

	 * so we ignore the mux and make clocks nodes as following,

	 *

	 * pclkin_cifinv --|-------\

	 *                 |GSC20_9|-- pclkin_cifmux -- |G27_6| -- pclkin_isp1_wrapper

	 * pclkin_cif    --|-------/

 cif */

 gic */

 alive */

 pclk_alive_gpll_src is controlled by PMUGRF_SOC_CON0[6] */

 Watchdog pclk is controlled by RK3399 SECURE_GRF_SOC_CON3[8]. */

 testout */

 spi */

 i2c */

 timer */

 clk_test */

 clk_test_pre is controlled by CRU_MISC_CON[3] */

 ddrc */

	/*

	 * PMU CRU Clock-Architecture

 pmu clock gates */

 ddrc */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2014 Google, Inc

 * Author: Alexandru M Stan <amstan@chromium.org>

/*

 * Each fine delay is between 44ps-77ps. Assume each fine delay is 60ps to

 * simplify calculations. So 45degs could be anywhere between 33deg and 57.8deg.

 Constant signal, no measurable phase shift */

 degrees/delaynum * 1000000 */

	/*

	 * The below calculation is based on the output clock from

	 * MMC host to the card, which expects the phase clock inherits

	 * the clock rate from its parent, namely the output clock

	 * provider of MMC host. However, things may go wrong if

	 * (1) It is orphan.

	 * (2) It is assigned to the wrong parent.

	 *

	 * This check help debug the case (1), which seems to be the

	 * most likely problem we often face and which makes it difficult

	 * for people to debug unstable mmc tuning results.

	/*

	 * Due to the inexact nature of the "fine" delay, we might

	 * actually go non-monotonic.  We don't go _too_ monotonic

	 * though, so we should be OK.  Here are options of how we may

	 * work:

	 *

	 * Ideally we end up with:

	 *   1.0, 2.0, ..., 69.0, 70.0, ...,  89.0, 90.0

	 *

	 * On one extreme (if delay is actually 44ps):

	 *   .73, 1.5, ..., 50.6, 51.3, ...,  65.3, 90.0

	 * The other (if delay is actually 77ps):

	 *   1.3, 2.6, ..., 88.6. 89.8, ..., 114.0, 90

	 *

	 * It's possible we might make a delay that is up to 25

	 * degrees off from what we think we're making.  That's OK

	 * though because we should be REALLY far from any bad range.

	/*

	 * Convert to delay; do a little extra work to make sure we

	 * don't overflow 32-bit / 64-bit numbers.

 PSECS_PER_SEC / 10000 / 10 */

	/*

	 * rockchip_mmc_clk is mostly used by mmc controllers to sample

	 * the intput data, which expects the fixed phase after the tuning

	 * process. However if the clock rate is changed, the phase is stale

	 * and may break the data sampling. So here we try to restore the phase

	 * for that case, except that

	 * (1) cached_phase is invaild since we inevitably cached it when the

	 * clock provider be reparented from orphan to its real parent in the

	 * first place. Otherwise we may mess up the initialization of MMC cards

	 * since we only set the default sample phase and drive phase later on.

	 * (2) the new coming rate is higher than the older one since mmc driver

	 * set the max-frequency to match the boards' ability but we can't go

	 * over the heads of that, otherwise the tests smoke out the issue.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) 2019 Rockchip Electronics Co. Ltd.

 * Author: Finley Xiao <finley.xiao@rock-chips.com>

 _mhz, _refdiv, _fbdiv, _postdiv1, _postdiv2, _dsmpd, _frac */

 sentinel */ },

	/*

	 * Clock-Architecture Diagram 1

	/*

	 * Clock-Architecture Diagram 2

	/*

	 * Clock-Architecture Diagram 3

	/*

	 * Clock-Architecture Diagram 4

	/*

	 * Clock-Architecture Diagram 5

	/*

	 * Clock-Architecture Diagram 6

	/*

	 * Clock-Architecture Diagram 7

	/*

	 * Clock-Architecture Diagram 8

 aclk_dmaci0 is controlled by sgrf_clkgat_con. */

 aclk_dmac1 is controlled by sgrf_clkgat_con. */

 watchdog pclk is controlled by sgrf_clkgat_con. */

 SPDX-License-Identifier: GPL-2.0-only

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2015 Heiko Stuebner <heiko@sntech.de>

/*

 * Synopsys AXS10X SDP Generic PLL clock driver

 *

 * Copyright (C) 2017 Synopsys

 *

 * This file is licensed under the terms of the GNU General Public

 * License version 2. This program is licensed "as is" without any

 * warranty of any kind, whether express or implied.

 PLL registers addresses */

/*

 * Bit fields of the PLL IDIV/FBDIV/ODIV registers:

 *  ________________________________________________________________________

 * |31                15|    14    |   13   |  12  |11         6|5         0|

 * |-------RESRVED------|-NOUPDATE-|-BYPASS-|-EDGE-|--HIGHTIME--|--LOWTIME--|

 * |____________________|__________|________|______|____________|___________|

 *

 * Following macros determine the way of access to these registers

 * They should be set up only using the macros.

 * reg should be an u32 variable.

 100 us */

			/*

			 * Wait until CGU relocks and check error status.

			 * If after timeout CGU is unlocked yet return error

/*

 * Synopsys AXS10X SDP I2S PLL clock driver

 *

 * Copyright (C) 2016 Synopsys

 *

 * This file is licensed under the terms of the GNU General Public

 * License version 2. This program is licensed "as is" without any

 * warranty of any kind, whether express or implied.

 PLL registers addresses */

 27 Mhz */

 28.224 Mhz */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Purna Chandra Mandal,<purna.mandal@microchip.com>

 * Copyright (C) 2015 Microchip Technology Inc.  All rights reserved.

 FRC Postscaler */

 SPLL fields */

 step of div_4 -> div_2 -> no_div */

 PIC32MZDA clock data */

 SYSCLK is now running from BFRCCLK. Report clock failure. */

 TODO: detect reason of failure and recover accordingly */

 register fixed rate clocks */

 fixed rate (optional) clock */

 divider clock */

 PLL ICLK mux */

 PLL */

 SYSTEM clock */

 Peripheral bus clocks */

 Reference oscillator clock */

 register clkdev */

 register clock provider */

 force enable critical clocks */

 register NMI for failsafe clock monitor */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Purna Chandra Mandal,<purna.mandal@microchip.com>

 * Copyright (C) 2015 Microchip Technology Inc.  All rights reserved.

 OSCCON Reg fields */

 SPLLCON Reg fields */

 Peripheral Bus Clock Reg Fields */

 Reference Oscillator Control Reg fields */

 Reference Oscillator Trim Register Fields */

 Mux Slew Control Register fields */

 Clock Poll Timeout */

 SoC specific clock needed during SPLL clock rate switch */

 add instruction pipeline delay while CPU clock is in-transition. */

 Perpheral bus clocks */

	/* eq. clk_rate = parent_rate / divider.

	 *

	 * Find best divider to produce closest of target divided rate.

 check & wait for DIV_READY */

 calculate clkdiv and best rate */

 apply new div */

 wait again for DIV_READY */

 confirm that new div is applied correctly */

 Reference oscillator operations */

 initialize clock in disabled state */

	/* fout = fin / [2 * {div + (trim / 512)}]

	 *	= fin * 512 / [1024 * div + 2 * trim]

	 *	= fin * 256 / (512 * div + trim)

	 *	= (fin << 8) / ((div << 9) + trim)

	/* Find integer approximation of floating-point arithmetic.

	 *      fout = fin / [2 * {rodiv + (rotrim / 512)}] ... (1)

	 * i.e. fout = fin / 2 * DIV

	 *      whereas DIV = rodiv + (rotrim / 512)

	 *

	 * Since kernel does not perform floating-point arithmatic so

	 * (rotrim/512) will be zero. And DIV & rodiv will result same.

	 *

	 * ie. fout = (fin * 256) / [(512 * rodiv) + rotrim]  ... from (1)

	 * ie. rotrim = ((fin * 256) / fout) - (512 * DIV)

 get rodiv */

 get trim */

 calculate dividers for new rate */

 caclulate new rate (rounding) based on new rodiv & rotrim */

 find a parent which can generate nearest clkrate >= rate */

 get parent */

 skip if parent runs slower than target rate */

 if no match found, retain old rate */

 wait until ACTIVE bit is zero or timeout */

 calculate & apply new */

 calculate new rodiv & rotrim for new rate */

 wait till source change is active */

 apply parent, if required */

 apply RODIV */

 apply ROTRIM */

 enable & activate divider switching */

 wait till divswen is in-progress */

 leave the clk gated as it was */

 PLL iclk divider, treated fixed */

	/* pll_in_rate = parent_rate / idiv

	 * pll_out_rate = pll_in_rate * mult / div;

	/*

	 * We can't change SPLL counters when it is in-active use

	 * by SYSCLK. So check before applying new counters/rate.

 Is spll_clk active parent of sys_clk ? */

 apply new multiplier & divisor */

 sys unlock before write */

 insert few nops (5-stage) to ensure CPU does not hang */

 Wait until PLL is locked (maximum 100 usecs). */

 SPLL clock operation */

 cache PLL idiv; PLL driver uses it as constant.*/

 System mux clock(aka SCLK) */

 sys-div to divider */

 apply new div */

 wait until BUSY is cleared */

 find new_osc */

 set new parent */

 initate switch */

 add nop to flush pipeline (as cpu_clk is in-flux) */

 wait for SWEN bit to clear */

	/*

	 * SCLK clock-switching logic might reject a clock switching request

	 * if pre-requisites (like new clk_src not present or unstable) are

	 * not met.

	 * So confirm before claiming success.

 Maintain reference to this clk, required in spll_clk_set_rate() */

 apply slew divider on both up and down scaling */

 sclk with post-divider */

 sclk with no slew and no post-divider */

 secondary oscillator */

 enable SOSC */

 wait till warm-up period expires or ready-status is updated */

 check enabled and ready status */

 SPDX-License-Identifier: GPL-2.0

/*

 * Mediatek MT7621 Clock Driver

 * Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>

 Configuration registers */

 SPDX-License-Identifier: GPL-2.0-or-later

 Copyright 2020 Cerno

 sentinel */ }

/*

 * Copyright (C) 2014 Broadcom Corporation

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License as

 * published by the Free Software Foundation version 2.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

 some clocks at the ASIU level are always enabled */

 some clocks at the ASIU level are always enabled */

 if clock divisor is not enabled, simply return parent rate */

 clock rate = parent rate / (high_div + 1) + (low_div + 1) */

 simply disable the divisor if one wants the same rate as parent */

/*

 * Copyright (C) 2014 Broadcom Corporation

 * Copyright 2014 Linaro Limited

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License as

 * published by the Free Software Foundation version 2.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

 Root CCU */

 no policy control */

 AON CCU */

 Master CCU */

 Verify */

 Verify */

 Verify */

 Verify */

 Slave CCU */

 Device tree match table callback functions */

 SPDX-License-Identifier: GPL-2.0+

/*

 * Copyright (C) 2015 Broadcom

 SPDX-License-Identifier: GPL-2.0

 sentinel */

 sentinel */

 sentinel */

 sentinel */

 sentinel */

 sentinel */

 sentinel */

 sentinel */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2016 Rafał Miłecki <rafal@milecki.pl>

 Enable measurement */

 Read initial value */

	/*

	 * At minimum we should loop for a bit to let hardware do the

	 * measurement. This isn't very accurate however, so for a better

	 * precision lets try getting 20 different values for and use average.

 Got different value, use it */

 Same value over and over, give up */

 Disable measurement to save power */

 We need it very early for arch code, before device model gets ready */

/*

 * Copyright (C) 2014 Broadcom Corporation

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License as

 * published by the Free Software Foundation version 2.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

/*

 * PLL MACRO_SELECT modes 0 to 5 choose pre-calculated PLL output frequencies

 * from a look-up table. Mode 7 allows user to manipulate PLL clock dividers

 number of delay loops waiting for PLL to lock */

 number of VCO frequency bands */

	/*

	 * Add half of the divisor so the result will be rounded to closest

	 * instead of rounded down.

/*

 * Based on the target frequency, find a match from the VCO frequency parameter

 * table and return its index

 latch input value so core power can be shut down */

 power down the core */

 power up the PLL and make sure it's not latched */

 certain PLLs also need to be ungated from the ASIU top level */

/*

 * Determines if the change to be applied to the PLL is minor (just an update

 * or the fractional divider). If so, then we can avoid going through a

 * disruptive reset and lock sequence.

 PLL needs to be locked */

	/*

	 * reference frequency = parent frequency / PDIV

	 * If PDIV = 0, then it becomes a multiplier (x2)

 determine Ki and Kp index based on target VCO frequency */

 program fractional part of NDIV */

 put PLL in reset */

 set PLL in user mode before modifying PLL controls */

 program integer part of NDIV */

 program fractional part of NDIV */

 program PDIV */

 PLL needs to be locked */

	/*

	 * PLL output frequency =

	 *

	 * ((ndiv_int + ndiv_frac / 2^20) * (parent clock rate / pdiv)

 break now if perfect match */

 channel enable is active low */

 also make sure channel is not held */

/*

 * Some PLLs require the PLL SW override bit to be set before changes can be

 * applied to the PLL

 Some SoCs do not require the pwr_base, thus failing is not fatal */

 some PLLs require gating control at the top ASIU level */

		/* Some SoCs have a split status/control.  If this does not

		 * exist, assume they are unified.

 initialize and register the PLL itself */

 now initialize and register all leaf clocks */

/*

 * Copyright (C) 2013 Broadcom Corporation

 * Copyright 2013 Linaro Limited

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License as

 * published by the Free Software Foundation version 2.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

 These are used when a selector or trigger is found to be unneeded */

 Validity checking */

 Fixed dividers don't need triggers */

 A bit position must be less than the number of bits in a 32-bit register. */

/*

 * A bitfield must be at least 1 bit wide.  Both the low-order and

 * high-order bits must lie within a 32-bit register.  We require

 * fields to be less than 32 bits wide, mainly because we use

 * shifting to produce field masks, and shifting a full word width

 * is not well-defined by the C standard.

/*

 * All gates, if defined, have a status bit, and for hardware-only

 * gates, that's it.  Gates that can be software controlled also

 * have an enable bit.  And a gate that can be hardware or software

 * controlled will have a hardware/software select bit.

/*

 * A selector bitfield must be valid.  Its parent_sel array must

 * also be reasonable for the field.

		/*

		 * Make sure the selector field can hold all the

		 * selector values we expect to be able to use.  A

		 * clock only needs to have a selector defined if it

		 * has more than one parent.  And in that case the

		 * highest selector value will be in the last entry

		 * in the array.

/*

 * A fixed divider just needs to be non-zero.  A variable divider

 * has to have a valid divider bitfield, and if it has a fraction,

 * the width of the fraction must not be no more than the width of

 * the divider as a whole.

 Any fixed divider value but 0 is OK */

/*

 * If a clock has two dividers, the combined number of fractional

 * bits must be representable in a 32-bit unsigned value.  This

 * is because we scale up a dividend using both dividers before

 * dividing to improve accuracy, and we need to avoid overflow.

 A trigger just needs to represent a valid bit position */

 Determine whether the set of peripheral clock registers are valid. */

	/*

	 * First validate register offsets.  This is the only place

	 * where we need something from the ccu, so we do these

	 * together.

/*

 * Scan an array of parent clock names to determine whether there

 * are any entries containing BAD_CLK_NAME.  Such entries are

 * placeholders for non-supported clocks.  Keep track of the

 * position of each clock name in the original array.

 *

 * Allocates an array of pointers to to hold the names of all

 * non-null entries in the original array, and returns a pointer to

 * that array in *names.  This will be used for registering the

 * clock with the common clock code.  On successful return,

 * *count indicates how many entries are in that names array.

 *

 * If there is more than one entry in the resulting names array,

 * another array is allocated to record the parent selector value

 * for each (defined) parent clock.  This is the value that

 * represents this parent clock in the clock's source selector

 * register.  The position of the clock in the original parent array

 * defines that selector value.  The number of entries in this array

 * is the same as the number of entries in the parent names array.

 *

 * The array of selector values is returned.  If the clock has no

 * parents, no selector is required and a null pointer is returned.

 *

 * Returns a null pointer if the clock names array supplied was

 * null.  (This is not an error.)

 *

 * Returns a pointer-coded error if an error occurs.

 In case of early return */

	/*

	 * Count the number of names in the null-terminated array,

	 * and find out how many of those are actually clock names.

 If all clocks are unsupported, we treat it as no clock */

 Avoid exceeding our parent clock limit */

	/*

	 * There is one parent name for each defined parent clock.

	 * We also maintain an array containing the selector value

	 * for each defined clock.  If there's only one clock, the

	 * selector is not required, but we allocate space for the

	 * array anyway to keep things simple.

 There is at least one parent, so allocate a selector array */

 Now fill in the parent names and selector arrays */

	/*

	 * If a peripheral clock has multiple parents, the value

	 * used by the hardware to select that parent is represented

	 * by the parent clock's position in the "clocks" list.  Some

	 * values don't have defined or supported clocks; these will

	 * have BAD_CLK_NAME entries in the parents[] array.  The

	 * list is terminated by a NULL entry.

	 *

	 * We need to supply (only) the names of defined parent

	 * clocks when registering a clock though, so we use an

	 * array of parent selector values to map between the

	 * indexes the common clock code uses and the selector

	 * values we need.

/*

 * Caller is responsible for freeing the parent_names[] and

 * parent_sel[] arrays in the peripheral clock's "data" structure

 * that can be assigned if the clock has one or more parent clocks

 * associated with it.

 Make sure everything makes sense before we set it up */

 safe if never added */

/*

 * Set up a CCU.  Call the provided ccu_clks_setup callback to

 * initialize the array of clocks provided by the CCU.

	/*

	 * Set up each defined kona clock and save the result in

	 * the clock framework clock array (in ccu->data).  Then

	 * register as a provider for these clocks.

 SPDX-License-Identifier: GPL-2.0+

/*

 * Copyright (C) 2010,2015 Broadcom

 * Copyright (C) 2012 Stephen Warren

/**

 * DOC: BCM2835 CPRMAN (clock manager for the "audio" domain)

 *

 * The clock tree on the 2835 has several levels.  There's a root

 * oscillator running at 19.2Mhz.  After the oscillator there are 5

 * PLLs, roughly divided as "camera", "ARM", "core", "DSI displays",

 * and "HDMI displays".  Those 5 PLLs each can divide their output to

 * produce up to 4 channels.  Finally, there is the level of clocks to

 * be consumed by other hardware components (like "H264" or "HDMI

 * state machine"), which divide off of some subset of the PLL

 * channels.

 *

 * All of the clocks in the tree are exposed in the DT, because the DT

 * may want to make assignments of the final layer of clocks to the

 * PLL channels, and some components of the hardware will actually

 * skip layers of the tree (for example, the pixel clock comes

 * directly from the PLLH PIX channel without using a CM_*CTL clock

 * generator).

 no definition for 0x0b8  and 0x0bc */

 General bits for the CM_*CTL regs */

/*

 * Names of clocks used within the driver that need to be replaced

 * with an external parent's name.  This array is in the order that

 * the clocks node in the DT references external clocks.

 spinlock for all clocks */

	/*

	 * Real names of cprman clock parents looked up through

	 * of_clk_get_parent_name(), which will be used in the

	 * parent_names[] arrays for clock registration.

 Must be last */

/* Does a cycle of measuring a clock through the TCNT clock, which may

 * source from many other clocks in the system.

 1ms */

 do a kind delay at the start */

 Finish off whatever is left of OSCCOUNT */

 Wait for BUSY to clear. */

 Bit in CM_LOCK to indicate when the PLL has locked. */

	/*

	 * Highest rate for the VCO before we have to use the

	 * pre-divide-by-2.

 Bitmap encoding which parents accept rate change propagation. */

 Number of integer bits in the divider */

 Number of fractional bits in the divider */

	/*

	 * On BCM2711 there isn't a pre-divisor available in the PLL feedback

	 * loop. Bits 13:14 of ANA1 (PLLA,PLLB,PLLC,PLLD) have been re-purposed

	 * for to for VCO RANGE bits.

 Take the PLL out of reset. */

 Wait for the PLL to lock. */

	/*

	 * ANA register setup is done as a series of writes to

	 * ANA3-ANA0, in that order.  This lets us write all 4

	 * registers as a single cycle of the serdes interface (taking

	 * 100 xosc clocks), whereas if we were to update ana0, 1, and

	 * 3 individually through their partial-write registers, each

	 * would be their own serdes cycle.

 Unmask the reference clock from the oscillator. */

 Set the PLL multiplier from the oscillator. */

/*

 * The CM dividers do fixed-point division, so we can't use the

 * generic integer divider code like the PLL dividers do (and we can't

 * fake it by having some fixed shifts preceding it in the clock tree,

 * because we'd run out of bits in a 32-bit unsigned long).

 Round up and mask off the unused bits */

 different clamping limits apply for a mash clock */

 clamp to min divider of 2 */

 clamp to the highest possible integer divider */

 clamp to min divider of 1 */

 clamp to the highest possible fractional divider */

 apply the clamping  limits */

	/*

	 * The divisor is a 12.12 fixed point field, but only some of

	 * the bits are populated in any given clock.

 BUSY will remain high until the divider completes its cycle. */

	/* Debug code to measure the clock once it's turned on to see

	 * if it's ticking at the rate we expect.

	/*

	 * Setting up frac support

	 *

	 * In principle it is recommended to stop/start the clock first,

	 * but as we set CLK_SET_RATE_GATE during registration of the

	 * clock this requirement should be take care of by the

	 * clk-framework.

			/*

			 * Return a value which is the maximum deviation

			 * below the ideal rate, for use as a metric.

 clamp to min divider of 2 if we're dealing with a mash clock */

 TODO: Be smart, and only test a subset of the available divisors. */

	/*

	 * Select parent clock that results in the closest but lower rate

		/*

		 * Don't choose a PLLC-derived clock as our parent

		 * unless it had been manually set that way.  PLLC's

		 * frequency gets adjusted by the firmware due to

		 * over-temp or under-voltage conditions, without

		 * prior notification to our clock consumer.

/*

 * The VPU clock can never be disabled (it doesn't have an ENABLE

 * bit), so it gets its own set of clock ops.

 All of the PLLs derive from the external oscillator. */

	/*

	 * PLLH's channels have a fixed divide by 10 afterwards, which

	 * is what our consumers are actually using.

	/*

	 * Replace our strings referencing parent clocks with the

	 * actual clock-output-name of the parent.

	/*

	 * Pass the CLK_SET_RATE_PARENT flag if we are allowed to propagate

	 * rate changes on at least of the parents.

		/* If the clock wasn't actually enabled at boot, it's not

		 * critical.

 assignment helper macros for different clock types */

 parent mux arrays plus helper macros */

 main oscillator parent mux */

 main peripherial parent mux */

/*

 * Restrict clock sources for the PCM peripheral to the oscillator and

 * PLLD_PER because other source may have varying rates or be switched

 * off.

 *

 * Prevent other sources from being selected by replacing their names in

 * the list of potential parents with dummy entries (entry index is

 * significant).

 main vpu parent mux */

/*

 * DSI parent clocks.  The DSI byte/DDR/DDR2 clocks come from the DSI

 * analog PHY.  The _inv variants are generated internally to cprman,

 * but we don't use them so they aren't hooked up.

/*

 * the real definition of all the pll, pll_dividers and clocks

 * these make use of the above REGISTER_* macros

 the PLL + PLL dividers */

	/*

	 * PLLA is the auxiliary PLL, used to drive the CCP2

	 * (Compact Camera Port 2) transmitter clock.

	 *

	 * It is in the PX LDO power domain, which is on when the

	 * AUDIO domain is on.

 PLLB is used for the ARM's clock. */

	/*

	 * PLLC is the core PLL, used to drive the core VPU clock.

	 *

	 * It is in the PX LDO power domain, which is on when the

	 * AUDIO domain is on.

	/*

	 * PLLD is the display PLL, used to drive DSI display panels.

	 *

	 * It is in the PX LDO power domain, which is on when the

	 * AUDIO domain is on.

	/*

	 * VPU firmware assumes that PLLD_PER isn't disabled by the ARM core.

	 * Otherwise this could cause firmware lookups. That's why we mark

	 * it as critical.

	/*

	 * PLLH is used to supply the pixel clock or the AUX clock for the

	 * TV encoder.

	 *

	 * It is in the HDMI power domain.

 the clocks */

 clocks with oscillator parent mux */

 One Time Programmable Memory clock.  Maximum 10Mhz. */

	/*

	 * Used for a 1Mhz clock for the system clocksource, and also used

	 * bythe watchdog timer and the camera pulse generator.

	/*

	 * Clock for the temperature sensor.

	 * Generally run at 2Mhz, max 5Mhz.

 clocks with vpu parent mux */

	/*

	 * Secondary SDRAM clock.  Used for low-voltage modes when the PLL

	 * in the SDRAM controller can't be used.

	/*

	 * VPU clock.  This doesn't have an enable bit, since it drives

	 * the bus for everything else, and is special so it doesn't need

	 * to be gated for rate changes.  It is also known as "clk_audio"

	 * in various hardware documentation.

 clocks with per parent mux */

 Arasan EMMC clock */

 EMMC2 clock (only available for BCM2711) */

 General purpose (GPIO) clocks */

 HDMI state machine */

 TV encoder clock.  Only operating frequency is 108Mhz.  */

		/*

		 * Allow rate change propagation only on PLLH_AUX which is

		 * assigned index 7 in the parent array.

 dsi clocks */

 the gates */

	/*

	 * CM_PERIICTL (and CM_PERIACTL, CM_SYSCTL and CM_VPUCTL if

	 * you have the debug bit set in the power manager, which we

	 * don't bother exposing) are individual gates off of the

	 * non-stop vpu clock.

/*

 * Permanently take a reference on the parent of the SDRAM clock.

 *

 * While the SDRAM is being driven by its dedicated PLL most of the

 * time, there is a little loop running in the firmware that

 * periodically switches the SDRAM to using our CM clock to do PVT

 * recalibration, with the assumption that the previously configured

 * SDRAM parent is still enabled and running.

	/*

	 * Make sure the external oscillator has been registered.

	 *

	 * The other (DSI) clocks are not present on older device

	 * trees, which we still need to support for backwards

	 * compatibility.

/*

 * Copyright (C) 2015 Broadcom Corporation

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License as

 * published by the Free Software Foundation version 2.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

/*

 * Copyright (C) 2013 Broadcom Corporation

 * Copyright 2013 Linaro Limited

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License as

 * published by the Free Software Foundation version 2.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

/*

 * "Policies" affect the frequencies of bus clocks provided by a

 * CCU.  (I believe these polices are named "Deep Sleep", "Economy",

 * "Normal", and "Turbo".)  A lower policy number has lower power

 * consumption, and policy 2 is the default.

 Bitfield operations */

 Produces a mask of set bits covering a range of a 32-bit value */

 Extract the value of a bitfield found within a given register value */

 Replace the value of a bitfield found within a given register value */

 Divider and scaling helpers */

 Convert a divider into the scaled divisor value it represents. */

/*

 * Build a scaled divider value as close as possible to the

 * given whole part (div_value) and fractional part (expressed

 * in billionths).

 The scaled minimum divisor representable by a divider */

 The scaled maximum divisor representable by a divider */

/*

 * Convert a scaled divisor into its divider representation as

 * stored in a divider register field.

 Return a rate scaled for use when dividing by a scaled divisor. */

 CCU access */

 Read a 32-bit register value from a CCU's address space. */

 Write a 32-bit register value into a CCU's address space. */

/*

 * Enable/disable write access to CCU protected registers.  The

 * WR_ACCESS register for all CCUs is at offset 0.

/*

 * Poll a register in a CCU's address space, returning when the

 * specified bit in that register's value is set (or clear).  Delay

 * a microsecond after each read of the register.  Returns true if

 * successful, or false if we gave up trying.

 *

 * Caller must ensure the CCU lock is held.

 Policy operations */

 If we don't need to control policy for this CCU, we're done. */

 Ensure we're not busy before we start */

	/*

	 * If it's a synchronous request, we'll wait for the voltage

	 * and frequency of the active load to stabilize before

	 * returning.  To do this we select the active load by

	 * setting the ATL bit.

	 *

	 * An asynchronous request instead ramps the voltage in the

	 * background, and when that process stabilizes, the target

	 * load is copied to the active load and the CCU frequency

	 * is switched.  We do this by selecting the target load

	 * (ATL bit clear) and setting the request auto-copy (AC bit

	 * set).

	 *

	 * Note, we do NOT read-modify-write this register.

 Wait for indication that operation is complete. */

 If we don't need to control policy for this CCU, we're done. */

 Ensure we're not busy before we start */

 Now set the bit to stop the engine (NO read-modify-write) */

 Wait for indication that it has stopped. */

/*

 * A CCU has four operating conditions ("policies"), and some clocks

 * can be disabled or enabled based on which policy is currently in

 * effect.  Such clocks have a bit in a "policy mask" register for

 * each policy indicating whether the clock is enabled for that

 * policy or not.  The bit position for a clock is the same for all

 * four registers, and the 32-bit registers are at consecutive

 * addresses.

	/*

	 * We need to stop the CCU policy engine to allow update

	 * of our policy bits.

	/*

	 * For now, if a clock defines its policy bit we just mark

	 * it "enabled" for all four policies.

 We're done updating; fire up the policy engine again. */

 Gate operations */

 Determine whether a clock is gated.  CCU lock must be held.  */

 If there is no gate we can assume it's enabled. */

 Determine whether a clock is gated. */

 Avoid taking the lock if we can */

/*

 * Commit our desired gate state to the hardware.

 * Returns true if successful, false otherwise.

 Nothing we can change */

 For a hardware/software gate, set which is in control */

	/*

	 * If software is in control, enable or disable the gate.

	 * If hardware is, clear the enabled bit for good measure.

	 * If a software controlled gate can't be disabled, we're

	 * required to write a 0 into the enable bit (but the gate

	 * will be enabled).

 For a hardware controlled gate, we're done */

 Otherwise wait for the gate to be in desired state */

/*

 * Initialize a gate.  Our desired state (hardware/software select,

 * and if software, its enable state) is committed to hardware

 * without the usual checks to see if it's already set up that way.

 * Returns true if successful, false otherwise.

/*

 * Set a gate to enabled or disabled state.  Does nothing if the

 * gate is not currently under software control, or if it is already

 * in the requested state.  Returns true if successful, false

 * otherwise.  CCU lock must be held.

 Nothing to do */

 No change */

 Revert the change */

 Enable or disable a gate.  Returns 0 if successful, -EIO otherwise */

	/*

	 * Avoid taking the lock if we can.  We quietly ignore

	 * requests to change state that don't make sense.

 Hysteresis operations */

/*

 * If a clock gate requires a turn-off delay it will have

 * "hysteresis" register bits defined.  The first, if set, enables

 * the delay; and if enabled, the second bit determines whether the

 * delay is "low" or "high" (1 means high).  For now, if it's

 * defined for a clock, we set it.

 Trigger operations */

/*

 * Caller must ensure CCU lock is held and access is enabled.

 * Returns true if successful, false otherwise.

 Trigger the clock and wait for it to finish */

 Divider operations */

 Read a divider value and return the scaled divisor it represents. */

 Extract the full divider field from the register value */

 Return the scaled divisor value it represents */

/*

 * Convert a divider's scaled divisor value into its recorded form

 * and commit it into the hardware divider register.

 *

 * Returns 0 on success.  Returns -EINVAL for invalid arguments.

 * Returns -ENXIO if gating failed, and -EIO if a trigger failed.

	/*

	 * If we're just initializing the divider, and no initial

	 * state was defined in the device tree, we just find out

	 * what its current value is rather than updating it.

 Convert the scaled divisor to the value we need to record */

 Clock needs to be enabled before changing the rate */

 Replace the divider value and record the result */

 If the trigger fails we still want to disable the gate */

 Disable the clock again if it was disabled to begin with */

 return first error */

/*

 * Initialize a divider by committing our desired state to hardware

 * without the usual checks to see if it's already set up that way.

 * Returns true if successful, false otherwise.

 No change */

 Revert the change */

 Common clock rate helpers */

/*

 * Implement the common clock framework recalc_rate method, taking

 * into account a divider and an optional pre-divider.  The

 * pre-divider register pointer may be NULL.

 actually this would be a caller bug */

	/*

	 * If there is a pre-divider, divide the scaled parent rate

	 * by the pre-divider value first.  In this case--to improve

	 * accuracy--scale the parent rate by *both* the pre-divider

	 * value and the divider before actually computing the

	 * result of the pre-divider.

	 *

	 * If there's only one divider, just scale the parent rate.

	/*

	 * Get the scaled divisor value, and divide the scaled

	 * parent rate by that to determine this clock's resulting

	 * rate.

/*

 * Compute the output rate produced when a given parent rate is fed

 * into two dividers.  The pre-divider can be NULL, and even if it's

 * non-null it may be nonexistent.  It's also OK for the divider to

 * be nonexistent, and in that case the pre-divider is also ignored.

 *

 * If scaled_div is non-null, it is used to return the scaled divisor

 * value used by the (downstream) divider to produce that rate.

	/*

	 * If there is a pre-divider, divide the scaled parent rate

	 * by the pre-divider value first.  In this case--to improve

	 * accuracy--scale the parent rate by *both* the pre-divider

	 * value and the divider before actually computing the

	 * result of the pre-divider.

	 *

	 * If there's only one divider, just scale the parent rate.

	 *

	 * For simplicity we treat the pre-divider as fixed (for now).

	/*

	 * Compute the best possible divider and ensure it is in

	 * range.  A fixed divider can't be changed, so just report

	 * the best we can do.

 OK, figure out the resulting rate */

 Common clock parent helpers */

/*

 * For a given parent selector (register field) value, find the

 * index into a selector's parent_sel array that contains it.

 * Returns the index, or BAD_CLK_INDEX if it's not found.

/*

 * Fetch the current value of the selector, and translate that into

 * its corresponding index in the parent array we registered with

 * the clock framework.

 *

 * Returns parent array index that corresponds with the value found,

 * or BAD_CLK_INDEX if the found value is out of range.

 If there's no selector, there's only one parent */

 Get the value in the selector register */

 Look up that selector's parent array index and return it */

/*

 * Commit our desired selector value to the hardware.

 *

 * Returns 0 on success.  Returns -EINVAL for invalid arguments.

 * Returns -ENXIO if gating failed, and -EIO if a trigger failed.

	/*

	 * If we're just initializing the selector, and no initial

	 * state was defined in the device tree, we just find out

	 * what its current value is rather than updating it.

 Clock needs to be enabled before changing the parent */

 Replace the selector value and record the result */

 If the trigger fails we still want to disable the gate */

 Disable the clock again if it was disabled to begin with */

 return first error */

/*

 * Initialize a selector by committing our desired state to hardware

 * without the usual checks to see if it's already set up that way.

 * Returns true if successful, false otherwise.

/*

 * Write a new value into a selector register to switch to a

 * different parent clock.  Returns 0 on success, or an error code

 * (from __sel_commit()) otherwise.

 No change */

 Revert the change */

 Clock operations */

 Quietly avoid a zero rate */

	/*

	 * If there is no other parent to choose, use the current one.

	 * Note:  We don't honor (or use) CLK_SET_RATE_NO_REPARENT.

 Unless we can do better, stick with current parent */

 Check whether any other parent clock can produce a better result */

 We don't support CLK_SET_RATE_PARENT */

 If there's only one parent we don't require a selector */

	/*

	 * The regular trigger is used by default, but if there's a

	 * pre-trigger we want to use that instead.

 Don't proliferate weird errors */

 Not all callers would handle an out-of-range value gracefully */

	/*

	 * A fixed divider can't be changed.  (Nor can a fixed

	 * pre-divider be, but for now we never actually try to

	 * change that.)  Tolerate a request for a no-op change.

	/*

	 * Get the scaled divisor value needed to achieve a clock

	 * rate as close as possible to what was requested, given

	 * the parent clock rate supplied.

	/*

	 * We aren't updating any pre-divider at this point, so

	 * we'll use the regular trigger.

 Don't proliferate weird errors */

 Put a peripheral clock into its initial state */

	/*

	 * For the pre-divider and selector, the pre-trigger is used

	 * if it's present, otherwise we just use the regular trigger.

 Set a CCU and all its clocks into their desired initial state */

/*

 * Copyright (C) 2014 Broadcom Corporation

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License as

 * published by the Free Software Foundation version 2.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

 something is seriously wrong */

/*

 * Determine the mdiv (post divider) based on the frequency ID being used.

 * There are 4 sources that can be used to derive the output clock rate:

 *    - 25 MHz Crystal

 *    - System clock

 *    - PLL channel 0 (slow clock)

 *    - PLL channel 1 (fast clock)

		/*

		 * offset mode is active. Read the ndiv from the PLLARM OFFSET

		 * register

 offset mode not active */

/*

 * The output frequency of the ARM PLL is calculated based on the ARM PLL

 * divider values:

 *   pdiv = ARM PLL pre-divider

 *   ndiv = ARM PLL multiplier

 *   mdiv = ARM PLL post divider

 *

 * The frequency is calculated by:

 *   ((ndiv * parent clock rate) / pdiv) / mdiv

 in bypass mode, use parent rate */

 PLL needs to be locked */

 SPDX-License-Identifier: GPL-2.0+

/*

 * Raspberry Pi driver for firmware controlled clocks

 *

 * Even though clk-bcm2835 provides an interface to the hardware registers for

 * the system clocks we've had to factor out 'pllb' as the firmware 'owns' it.

 * We're not allowed to change it directly as we might race with the

 * over-temperature and under-voltage protections provided by the firmware.

 *

 * Copyright (C) 2019 Nicolas Saenz Julienne <nsaenzjulienne@suse.de>

/*

 * Structure of the message passed to Raspberry Pi's firmware in order to

 * change clock rates. The 'disable_turbo' option is only available to the ARM

 * clock (pllb) which we enable by default as turbo mode will alter multiple

 * clocks at once.

 *

 * Even though we're able to access the clock registers directly we're bound to

 * use the firmware interface as the firmware ultimately takes care of

 * mitigating overheating/undervoltage situations and we would be changing

 * frequencies behind his back.

 *

 * For more information on the firmware interface check:

 * https://github.com/raspberrypi/firmware/wiki/Mailbox-property-interface

	/*

	 * The firmware will do the rounding but that isn't part of

	 * the interface with the firmware, so we just do our best

	 * here.

	/*

	 * We can be probed either through the an old-fashioned

	 * platform device registration or through a DT node that is a

	 * child of the firmware node. Handle both cases.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2017 Broadcom

 sentinel */ }

/*

 * Copyright (C) 2017 Broadcom

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License as

 * published by the Free Software Foundation version 2.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

/*

 * Copyright (C) 2014 Broadcom Corporation

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License as

 * published by the Free Software Foundation version 2.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

/*

 * MIPI PLL VCO frequency parameter table

 rate (Hz) ndiv_int ndiv_frac pdiv */

/*

 * Copyright (C) 2015 Broadcom Corporation

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License as

 * published by the Free Software Foundation version 2.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

/*

 * Copyright (C) 2013 Broadcom Corporation

 * Copyright 2013 Linaro Limited

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License as

 * published by the Free Software Foundation version 2.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

 Root CCU */

 AON CCU */

 Hub CCU */

 Master CCU */

 also called usbh_48m */

 also called usbh_12m */

 Slave CCU */

 Device tree match table callback functions */

/*

 * Copyright (C) 2015 Broadcom Corporation

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License as

 * published by the Free Software Foundation version 2.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

	/* bypass_shift, the last value passed into ENABLE_VAL(), is not defined

	 * in NS2.  However, it doesn't appear to be used anywhere, so setting

	 * it to 0.

	/* bypass_shift, the last value passed into ENABLE_VAL(), is not defined

	 * in NS2.  However, it doesn't appear to be used anywhere, so setting

	 * it to 0.

	/* bypass_shift, the last value passed into ENABLE_VAL(), is not defined

	 * in NS2.  However, it doesn't appear to be used anywhere, so setting

	 * it to 0.

	/* bypass_shift, the last value passed into ENABLE_VAL(), is not defined

	 * in NS2.  However, it doesn't appear to be used anywhere, so setting

	 * it to 0.

 SPDX-License-Identifier: GPL-2.0

/*

 * H8S2678 clock driver

 *

 * Copyright 2015 Yoshinori Sato <ysato@users.sourceforge.jp>

 SPDX-License-Identifier: GPL-2.0

/*

 * H8/300 divide clock driver

 *

 * Copyright 2015 Yoshinori Sato <ysato@users.sourceforge.jp>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2020 BAIKAL ELECTRONICS, JSC

 *

 * Authors:

 *   Serge Semin <Sergey.Semin@baikalelectronics.ru>

 *   Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>

 *

 * Baikal-T1 CCU Dividers clock driver

/*

 * AXI Main Interconnect (axi_main_clk) and DDR AXI-bus (axi_ddr_clk) clocks

 * must be left enabled in any case, since former one is responsible for

 * clocking a bus between CPU cores and the rest of the SoC components, while

 * the later is clocking the AXI-bus between DDR controller and the Main

 * Interconnect. So should any of these clocks get to be disabled, the system

 * will literally stop working. That's why we marked them as critical.

/*

 * APB-bus clock is marked as critical since it's a main communication bus

 * for the SoC devices registers IO-operations.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2020 BAIKAL ELECTRONICS, JSC

 *

 * Authors:

 *   Serge Semin <Sergey.Semin@baikalelectronics.ru>

 *   Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>

 *

 * Baikal-T1 CCU Dividers interface driver

/*

 * Use the next two methods until there are generic field setter and

 * getter available with non-constant mask support.

	/*

	 * Until there is nsec-version of readl_poll_timeout() is available

	 * we have to implement the next polling loop.

/*

 * This method is used for the clock divider blocks, which support the

 * on-the-fly rate change. So due to lacking the EN bit functionality

 * they can't be gated before the rate adjustment.

/*

 * This method is used for the clock divider blocks, which don't support

 * the on-the-fly rate change.

	/*

	 * Also disable the clock divider block if it was enabled by default

	 * or by the bootloader.

 The next delay must be enough to cover all the resets. */

/*

 * It can be dangerous to change the Divider settings behind clock framework

 * back, therefore we don't provide any kernel config based compile time option

 * for this feature to enable.

 !CCU_DIV_ALLOW_WRITE_DEBUGFS */

 !CCU_DIV_ALLOW_WRITE_DEBUGFS */

 !CONFIG_DEBUG_FS */

 !CONFIG_DEBUG_FS */

	/*

	 * Note since Baikal-T1 System Controller registers are MMIO-backed

	 * we won't check the regmap IO operations return status, because it

	 * must be zero anyway.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2020 BAIKAL ELECTRONICS, JSC

 *

 * Authors:

 *   Serge Semin <Sergey.Semin@baikalelectronics.ru>

 *   Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>

 *

 * Baikal-T1 CCU PLL interface driver

	/*

	 * Make sure PLL is working with valid input signal (Fdiv). If

	 * you want to speed the function up just reduce CCU_PLL_NR_MAX.

	 * This will cause a worse approximation though.

	/*

	 * Find a closest [nr;nf;od] vector taking into account the

	 * limitations like: 1) 700MHz <= Fvco <= 3.5GHz, 2) PLL Od is

	 * either 1 or even number within the acceptable range (alas 1s

	 * is also excluded by the next loop).

 Use Od factor to fulfill the limitation 2). */

		/*

		 * Make sure Fvco is within the acceptable range to fulfill

		 * the condition 1). Note due to the CCU_PLL_CLKOD_FACTOR value

		 * the actual upper limit is also divided by that factor.

		 * It's not big problem for us since practically there is no

		 * need in clocks with that high frequency.

		/*

		 * Bypass the out-of-bound values, which can't be properly

		 * handled by the rational fraction approximation algorithm.

 Select the best approximation of the target rate. */

/*

 * This method is used for PLLs, which support the on-the-fly dividers

 * adjustment. So there is no need in gating such clocks.

/*

 * This method is used for PLLs, which don't support the on-the-fly dividers

 * adjustment. So the corresponding clocks are supposed to be gated first.

	/*

	 * Disable PLL if it was enabled by default or left enabled by the

	 * system bootloader.

/*

 * It can be dangerous to change the PLL settings behind clock framework back,

 * therefore we don't provide any kernel config based compile time option for

 * this feature to enable.

 !CCU_PLL_ALLOW_WRITE_DEBUGFS */

 !CCU_PLL_ALLOW_WRITE_DEBUGFS */

 !CONFIG_DEBUG_FS */

 !CONFIG_DEBUG_FS */

	/*

	 * Note since Baikal-T1 System Controller registers are MMIO-backed

	 * we won't check the regmap IO operations return status, because it

	 * must be zero anyway.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2020 BAIKAL ELECTRONICS, JSC

 *

 * Authors:

 *   Serge Semin <Sergey.Semin@baikalelectronics.ru>

 *   Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>

 *

 * Baikal-T1 CCU PLL clocks driver

/*

 * Alas we have to mark all PLLs as critical. CPU and DDR PLLs are sources of

 * CPU cores and DDR controller reference clocks, due to which they obviously

 * shouldn't be ever gated. SATA and PCIe PLLs are the parents of APB-bus and

 * DDR controller AXI-bus clocks. If they are gated the system will be

 * unusable. Moreover disabling SATA and Ethernet PLLs causes automatic reset

 * of the corresponding subsystems. So until we aren't ready to re-initialize

 * all the devices consuming those PLLs, they will be marked as critical too.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) 2012-2016 Zhang, Keguang <keguang.zhang@gmail.com>

 clock derived from 33 MHz OSC clk */

 clock derived from PLL clk */

	/*                                 _____

	 *         _______________________|     |

	 * OSC ___/                       | MUX |___ CPU CLK

	 *        \___ PLL ___ CPU DIV ___|     |

	 *                                |_____|

	/*                                 _____

	 *         _______________________|     |

	 * OSC ___/                       | MUX |___ DC  CLK

	 *        \___ PLL ___ DC  DIV ___|     |

	 *                                |_____|

	/*                                 _____

	 *         _______________________|     |

	 * OSC ___/                       | MUX |___ DDR CLK

	 *        \___ PLL ___ DDR DIV ___|     |

	 *                                |_____|

 clock derived from AHB clk */

 APB clk is always half of the AHB clk */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) 2012-2016 Zhang, Keguang <keguang.zhang@gmail.com>

 allocate the divider */

 register the clock */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) 2016 Yang Ling <gnaygnil@gmail.com>

 clock derived from 24 MHz OSC clk */

 clock derived from AHB clk */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Zynq clock controller

 *

 *  Copyright (C) 2012 - 2013 Xilinx

 *

 *  Sören Brinkmann <soren.brinkmann@xilinx.com>

 get clock output names from DT */

 ps_clk */

 PLLs */

 CPU clocks */

 Timers */

 DDR clocks */

 Peripheral clocks */

 leave debug clocks in the state the bootloader set them up to */

 One gated clock for all APER clocks. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Zynq PLL driver

 *

 *  Copyright (C) 2013 Xilinx

 *

 *  Sören Brinkmann <soren.brinkmann@xilinx.com>

/**

 * struct zynq_pll

 * @hw:		Handle between common and hardware-specific interfaces

 * @pll_ctrl:	PLL control register

 * @pll_status:	PLL status register

 * @lock:	Register lock

 * @lockbit:	Indicates the associated PLL_LOCKED bit in the PLL status

 *		register.

 Register bitfield defines */

/**

 * zynq_pll_round_rate() - Round a clock frequency

 * @hw:		Handle between common and hardware-specific interfaces

 * @rate:	Desired clock frequency

 * @prate:	Clock frequency of parent clock

 * Returns frequency closest to @rate the hardware can generate.

/**

 * zynq_pll_recalc_rate() - Recalculate clock frequency

 * @hw:			Handle between common and hardware-specific interfaces

 * @parent_rate:	Clock frequency of parent clock

 * Returns current clock frequency.

	/*

	 * makes probably sense to redundantly save fbdiv in the struct

	 * zynq_pll to save the IO access.

/**

 * zynq_pll_is_enabled - Check if a clock is enabled

 * @hw:		Handle between common and hardware-specific interfaces

 * Returns 1 if the clock is enabled, 0 otherwise.

 *

 * Not sure this is a good idea, but since disabled means bypassed for

 * this clock implementation we say we are always enabled.

/**

 * zynq_pll_enable - Enable clock

 * @hw:		Handle between common and hardware-specific interfaces

 * Returns 0 on success

 Power up PLL and wait for lock */

/**

 * zynq_pll_disable - Disable clock

 * @hw:		Handle between common and hardware-specific interfaces

 * Returns 0 on success

 shut down PLL */

/**

 * clk_register_zynq_pll() - Register PLL with the clock framework

 * @name:	PLL name

 * @parent:	Parent clock name

 * @pll_ctrl:	Pointer to PLL control register

 * @pll_status:	Pointer to PLL status register

 * @lock_index:	Bit index to this PLL's lock status bit in @pll_status

 * @lock:	Register lock

 * Returns handle to the registered clock.

 Populate the struct */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2020 Intel Corporation.

 * Zhu YiXin <yixin.zhu@intel.com>

 * Rahul Tanwar <rahul.tanwar@intel.com>

/*

 * Calculate formula:

 * rate = (prate * mult + (prate * frac) / frac_div) / div

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Intel Atom platform clocks driver for BayTrail and CherryTrail SoCs

 *

 * Copyright (C) 2016, Intel Corporation

 * Author: Irina Tirdea <irina.tirdea@intel.com>

 25 MHz */

 19.2 MHz */

 protect access to PMC registers */

 Return an index in parent table */

 Return clk index of parent */

 Abstract status in simpler enabled/disabled value */

 enabled */

 disabled */

	/*

	 * On some systems, the pmc_plt_clocks already enabled by the

	 * firmware are being marked as critical to avoid them being

	 * gated by the clock framework.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2020 Intel Corporation.

 * Zhu YiXin <yixin.zhu@intel.com>

 * Rahul Tanwar <rahul.tanwar@intel.com>

 if predivide bit is enabled, modify div by factor of 2.5 */

 if predivide bit is enabled, modify rounded rate by factor of 2.5 */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2020 Intel Corporation.

 * Zhu YiXin <yixin.zhu@intel.com>

 * Rahul Tanwar <rahul.tanwar@intel.com>

 Gate0 clock shift */

 Gate1 clock shift */

 Gate2 clock shift */

 Gate3 clock shift */

 Register definition */

/*

 * Below table defines the pair's of regval & effective dividers.

 * It's more efficient to provide an explicit table due to non-linear

 * relation between values.

	/*

	 * Marking ngi_clk (next generation interconnect) and noc_clk

	 * (network on chip peripheral clk) as critical clocks because

	 * these are shared parent clock sources for many different

	 * peripherals.

 SPDX-License-Identifier: MIT

/*

 * clock framework for AMD Stoney based clocks

 *

 * Copyright 2018 Advanced Micro Devices, Inc.

 Clock Driving Strength 2 register */

 Clock Control 1 register */

 Auxiliary clock1 enable bit */

 25Mhz auxiliary output clock freq bit */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Intel Low Power Subsystem clocks.

 *

 * Copyright (C) 2013, Intel Corporation

 * Authors: Mika Westerberg <mika.westerberg@linux.intel.com>

 *	    Heikki Krogerus <heikki.krogerus@linux.intel.com>

 LPSS free running clock */

 SPDX-License-Identifier: GPL-2.0-only



 Copyright (c) 2021 MediaTek Inc.

 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>

 sentinel */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2020 MediaTek Inc.

 * Copyright (c) 2020 BayLibre, SAS

 * Author: James Liao <jamesjj.liao@mediatek.com>

 *         Fabien Parent <fparent@baylibre.com>

 VDEC0 */

 VDEC1 */

 SPDX-License-Identifier: GPL-2.0-only



 Copyright (c) 2021 MediaTek Inc.

 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>

 SPDX-License-Identifier: GPL-2.0-only



 Copyright (c) 2021 MediaTek Inc.

 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>

 sentinel */

 SPDX-License-Identifier: GPL-2.0-only



 Copyright (c) 2021 MediaTek Inc.

 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>

 sentinel */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2014 MediaTek Inc.

 * Author: James Liao <jamesjj.liao@mediatek.com>

 CLK_CFG_0 */

 CLK_CFG_1 */

 CLK_CFG_2 */

 CLK_CFG_3 */

 CLK_CFG_4 */

 CLK_CFG_6 */

 CLK_CFG_7 */

 CLK_CFG_8 */

 CLK_CFG_9 */

 PERI0 */

 PERI1 */

 SPDX-License-Identifier: GPL-2.0-only



 Copyright (c) 2021 MediaTek Inc.

 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>

 sentinel */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2020 MediaTek Inc.

 * Copyright (c) 2020 BayLibre, SAS

 * Author: James Liao <jamesjj.liao@mediatek.com>

 *         Fabien Parent <fparent@baylibre.com>

 SPDX-License-Identifier: GPL-2.0-only



 Copyright (c) 2021 MediaTek Inc.

 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>

 sentinel */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2017 MediaTek Inc.

 * Author: Kevin Chen <kevin-cw.chen@mediatek.com>

 SPDX-License-Identifier: GPL-2.0-only

/* Copyright (c) 2017 MediaTek Inc.

 * Author: Kevin Chen <kevin-cw.chen@mediatek.com>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2017 MediaTek Inc.

 * Author: Weiyi Lu <weiyi.lu@mediatek.com>

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2019 MediaTek Inc.

 * Author: James Liao <jamesjj.liao@mediatek.com>

 *         Fabien Parent <fparent@baylibre.com>

 CLK_MUX_SEL0 */

 CLK_MUX_SEL1 */

 CLK_MUX_SEL8 */

 CLK_SEL_9 */

 CLK_MUX_SEL13 */

 TOP1 */

 TOP2 */

 TOP3 */

 TOP4 */

 TOP5 */

 sentinel */

 SPDX-License-Identifier: GPL-2.0



 Copyright (c) 2018 MediaTek Inc.

 Author: Weiyi Lu <weiyi.lu@mediatek.com>

 AUDIO0 */

 AUDIO1 */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2018 MediaTek Inc.

 * Author: Wenzhen Yu <Wenzhen Yu@mediatek.com>

 *	   Ryder Lee <ryder.lee@mediatek.com>

 sentinel */

 SPDX-License-Identifier: GPL-2.0-only



 Copyright (c) 2021 MediaTek Inc.

 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>

 MM0 */

 MM1 */

 MM2 */

 SPDX-License-Identifier: GPL-2.0-only



 Copyright (c) 2021 MediaTek Inc.

 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>

 sentinel */

 SPDX-License-Identifier: GPL-2.0-only



 Copyright (c) 2021 MediaTek Inc.

 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>

/*

 * CRITICAL CLOCK:

 * axi_sel is the main bus clock of whole SOC.

 * spm_sel is the clock of the always-on co-processor.

 * bus_aximem_sel is clock of the bus that access emi.

 CLK_CFG_0 */

 CLK_CFG_1 */

 CLK_CFG_2 */

 CLK_CFG_4 */

 CLK_CFG_5 */

 CLK_CFG_6 */

 CLK_CFG_7 */

 CLK_CFG_8 */

 CLK_CFG_9 */

 CLK_CFG_10 */

 CLK_CFG_11 */

 CLK_CFG_12 */

 CLK_CFG_13 */

 CLK_CFG_14 */

 CLK_CFG_15 */

 CLK_CFG_16 */

 CLK_AUDDIV_0 */

/*

 * CRITICAL CLOCK:

 * infra_133m and infra_66m are main peripheral bus clocks of SOC.

 * infra_device_apc and infra_device_apc_sync are for device access permission control module.

 INFRA0 */

 INFRA1 */

 INFRA2 */

 INFRA3 */

 INFRA4 */

 INFRA5 */

 sentinel */

 SPDX-License-Identifier: GPL-2.0-only



 Copyright (c) 2021 MediaTek Inc.

 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>

 sentinel */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2014 MediaTek Inc.

 * Author: James Liao <jamesjj.liao@mediatek.com>

 SPDX-License-Identifier: GPL-2.0



 Copyright (c) 2018 MediaTek Inc.

 Author: Weiyi Lu <weiyi.lu@mediatek.com>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2014 MediaTek Inc.

 * Author: Shunli Wang <shunli.wang@mediatek.com>

 SPDX-License-Identifier: GPL-2.0-only



 Copyright (c) 2021 MediaTek Inc.

 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>

 sentinel */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2015 Linaro Ltd.

 * Author: Pi-Cheng Chen <pi-cheng.chen@linaro.org>

 SPDX-License-Identifier: GPL-2.0



 Copyright (c) 2018 MediaTek Inc.

 Author: Weiyi Lu <weiyi.lu@mediatek.com>

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2018 MediaTek Inc.

 * Author: Owen Chen <owen.chen@mediatek.com>

fmeter div select 4*/

 Total 12 subsys */

 CKSYS */

 CG */

 clk cfg update */

 CLK_CFG_0 */

 CLK_CFG_1 */

 CLK_CFG_2 */

 CLK_CFG_3 */

 CLK_CFG_4 */

 CLK_CFG_5 */

 CLK_CFG_6 */

 CLK_CFG_7 */

 TOP0 */

 TOP1 */

 TOP2 */

 INFRA_TOPAXI */

 INFRA PERI */

 INFRA mode 0 */

 INFRA mode 1 */

 INFRA mode 2 */

 INFRA mode 3 */

 additional CCF control for mipi26M race condition(disp/camera) */

 AUDIO0 */

 MPLL, CCIPLL, MAINPLL set HW mode, TDCLKSQ, CLKSQ1 */

 [4]:no need */

[1,2,3,8]: no need*/

 sentinel */

 SPDX-License-Identifier: GPL-2.0



 Copyright (c) 2018 MediaTek Inc.

 Author: Weiyi Lu <weiyi.lu@mediatek.com>

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2020 MediaTek Inc.

 * Copyright (c) 2020 BayLibre, SAS

 * Author: James Liao <jamesjj.liao@mediatek.com>

 *         Fabien Parent <fparent@baylibre.com>

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2018 MediaTek Inc.

 * Author: Wenzhen Yu <Wenzhen Yu@mediatek.com>

 *	   Ryder Lee <ryder.lee@mediatek.com>

 PERI0 */

 PERI1 */

 INFRA_TOPCKGEN_CKMUXSEL */

 CLK_CFG_0 */

 CLK_CFG_1 */

 CLK_CFG_2 */

 CLK_CFG_3 */

 CLK_CFG_4 */

 CLK_CFG_5 */

 CLK_CFG_6 */

 CLK_CFG_7 */

 CLK_CFG_8 */

 PERI_GLOBALCON_CKSEL */

 sentinel */

 SPDX-License-Identifier: GPL-2.0-only



 Copyright (c) 2021 MediaTek Inc.

 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>

 sentinel */

 SPDX-License-Identifier: GPL-2.0-only



 Copyright (c) 2021 MediaTek Inc.

 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>

 VPP0_0 */

 VPP0_1 */

 VPP0_2 */

 sentinel */

 SPDX-License-Identifier: GPL-2.0-only



 Copyright (c) 2021 MediaTek Inc.

 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>

 WPE_VPP0 */

 WPE_VPP1 */

 WPE_VPP0 */

 WPE_VPP1 */

 sentinel */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2019 MediaTek Inc.

 * Author: James Liao <jamesjj.liao@mediatek.com>

 *         Fabien Parent <fparent@baylibre.com>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2017 MediaTek Inc.

 * Author: Weiyi Lu <weiyi.lu@mediatek.com>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2017 MediaTek Inc.

 * Author: Weiyi Lu <weiyi.lu@mediatek.com>

 SPDX-License-Identifier: GPL-2.0-only



 Copyright (c) 2021 MediaTek Inc.

 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>

 VDEC0 */

 VDEC1 */

 VDEC2 */

 VDEC_SOC0 */

 VDEC_SOC1 */

 VDEC_SOC2 */

 sentinel */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2017 MediaTek Inc.

 * Author: Kevin Chen <kevin-cw.chen@mediatek.com>

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2019 MediaTek Inc.

 * Author: Wendell Lin <wendell.lin@mediatek.com>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2017 MediaTek Inc.

 * Author: Weiyi Lu <weiyi.lu@mediatek.com>

 CLK_CFG_0 */

 CLK_CFG_1 */

 CLK_CFG_2 */

 CLK_CFG_3 */

 CLK_CFG_4 */

 CLK_CFG_5 */

 CLK_CFG_6 */

 CLK_CFG_7 */

 CLK_CFG_8 */

 CLK_CFG_9 */

 CLK_CFG_10 */

 CLK_CFG_11 */

 CLK_CFG_12 */

 CLK_CFG_13 */

 CLK_CFG_14 */

 CLK_CFG_15 */

 CLK_CFG_16 */

 CLK_CFG_17 */

 CLK_AUDDIV_4 */

 mp0_pll_divider_cfg */

 mp2_pll_divider_cfg */

 bus_pll_divider_cfg */

 TOP0 */

 TOP1 */

 PERI0 */

 PERI1 */

 PERI2 */

 sentinel */

 sentinel */

 sentinel */

 sentinel */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2015 MediaTek Inc.

 * Author: James Liao <jamesjj.liao@mediatek.com>

 SPDX-License-Identifier: GPL-2.0



 Copyright (c) 2018 MediaTek Inc.

 Author: Weiyi Lu <weiyi.lu@mediatek.com>

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2018 MediaTek Inc.

 * Author: Wenzhen Yu <Wenzhen Yu@mediatek.com>

 *	   Ryder Lee <ryder.lee@mediatek.com>

 sentinel */

 SPDX-License-Identifier: GPL-2.0-only



 Copyright (c) 2021 MediaTek Inc.

 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>

 sentinel */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2014 MediaTek Inc.

 * Author: Shunli Wang <shunli.wang@mediatek.com>

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2018 MediaTek Inc.

 * Author: Owen Chen <owen.chen@mediatek.com>

	/*

	 * If the parent has been changed when the clock was disabled, it will

	 * not be effective yet. Set the update bit to ensure the mux gets

	 * updated.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2017 MediaTek Inc.

 * Author: Chen Zhong <chen.zhong@mediatek.com>

 *	   Sean Wang <sean.wang@mediatek.com>

 sentinel */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2014 MediaTek Inc.

 * Author: James Liao <jamesjj.liao@mediatek.com>

/*

 * For some clocks, we don't care what their actual rates are. And these

 * clocks may change their rate on different products or different scenarios.

 * So we model these clocks' rate as 0, to denote it's not an actual rate.

 CLK_CFG_0 */

 CLK_CFG_1 */

 CLK_CFG_2 */

 CLK_CFG_3 */

 CLK_CFG_4 */

 CLK_CFG_5 */

 7:5 */),

 CLK_CFG_6 */

	/*

	 * The dpi0_sel clock should not propagate rate changes to its parent

	 * clock so the dpi driver can have full control over PLL and divider.

 CLK_CFG_7 */

 CLK_CFG_12 */

 CLK_CFG_13 */

 PERI0 */

 PERI1 */

 sentinel */

 SPDX-License-Identifier: GPL-2.0



 Copyright (c) 2018 MediaTek Inc.

 Author: Weiyi Lu <weiyi.lu@mediatek.com>

 MM0 */

 MM1 */

 SPDX-License-Identifier: GPL-2.0-only



 Copyright (c) 2021 MediaTek Inc.

 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>

	/*

	 * CLK_CFG_0

	 * top_axi and top_bus_aximem are bus clocks, should not be closed by Linux.

	 * top_spm and top_scp are main clocks in always-on co-processor.

 CLK_CFG_1 */

 CLK_CFG_2 */

 CLK_CFG_3 */

 CLK_CFG_4 */

 CLK_CFG_5 */

 CLK_CFG_6 */

 CLK_CFG_7 */

 CLK_CFG_8 */

	/*

	 * CLK_CFG_9

	 * top_pwrmcu is main clock in other co-processor, should not be

	 * handled by Linux.

 CLK_CFG_10 */

 CLK_CFG_11 */

 CLK_CFG_12 */

 CLK_CFG_13 */

 CLK_CFG_14 */

 CLK_CFG_15 */

	/*

	 * CLK_CFG_16

	 * top_mcupm is main clock in other co-processor, should not be

	 * handled by Linux.

	/*

	 * CLK_CFG_17

	 * top_dvfsrc is for internal DVFS usage, should not be handled by Linux.

 CLK_CFG_18 */

 CLK_CFG_19 */

 CLK_CFG_20 */

 CLK_CFG_21 */

 CLK_CFG_22 */

 CLK_CFG_23 */

	/*

	 * CLK_CFG_24

	 * i2so4_mck is not used in MT8195.

	/*

	 * CLK_CFG_25

	 * i2so5_mck and i2si4_mck are not used in MT8195.

	/*

	 * CLK_CFG_26

	 * i2si5_mck is not used in MT8195.

 CLK_CFG_27 */

 CLK_CFG_28 */

	/*

	 * CLK_CFG_29

	 * top_ulposc/top_ulposc_core/top_srck are clock source of always on co-processor,

	 * should not be closed by Linux.

	/*

	 * the clocks in CLK_CFG_30 ~ 37 are backup clock source, no need to handled

	 * by Linux.

 CLK_MISC_CFG_3 */

 apll12_div5 ~ 8 are not used in MT8195. */

 TOP0 */

	/*

	 * cfg_axi_east, cfg_axi_east_north, cfg_axi_north and cfg_axi_south

	 * are peripheral bus clock branches.

 TOP1 */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2019 MediaTek Inc.

 * Author: Wendell Lin <wendell.lin@mediatek.com>

/*

 * CRITICAL CLOCK:

 * axi_sel is the main bus clock of whole SOC.

 * spm_sel is the clock of the always-on co-processor.

 * sspm_sel is the clock of the always-on co-processor.

 CLK_CFG_0 */

 CLK_CFG_1 */

 CLK_CFG_2 */

 CLK_CFG_3 */

 CLK_CFG_4 */

 CLK_CFG_5 */

 CLK_CFG_6 */

 CLK_CFG_7 */

 CLK_CFG_8 */

 CLK_CFG_9 */

 CLK_CFG_10 */

 CLK_CFG_11 */

 CLK_CFG_12 */

 CLK_CFG_13 */

 INFRA0 */

 INFRA1 */

 INFRA2 */

 INFRA3 */

/*

 * CRITICAL CLOCK:

 * apmixed_appll26m is the toppest clock gate of all PLLs.

 sentinel */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2019 MediaTek Inc.

 * Author: Wendell Lin <wendell.lin@mediatek.com>

 MM0 */

 MM1 */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2019 MediaTek Inc.

 * Author: Wendell Lin <wendell.lin@mediatek.com>

 VDEC0 */

 VDEC1 */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2014 MediaTek Inc.

 * Author: James Liao <jamesjj.liao@mediatek.com>

 default 7 bits integer, can be overridden with pcwibits. */

/*

 * MediaTek PLLs are configured through their pcw value. The pcw value describes

 * a divider in the PLL feedback loop which consists of 7 bits for the integer

 * part and the remaining bits (if present) for the fractional part. Also they

 * have a 3 bit power-of-two post divider.

 The fractional part of the PLL divider. */

 disable tuner */

 set postdiv */

 postdiv and pcw need to set at the same time if on same register */

 set pcw */

 restore tuner_en */

/*

 * mtk_pll_calc_values - calculate good values for a given input frequency.

 * @pll:	The pll

 * @pcw:	The pcw value (output)

 * @postdiv:	The post divider (output)

 * @freq:	The desired target frequency

 * @fin:	The input frequency

 *

 _pcw = freq * postdiv / fin * 2^pcwfbits */

 SPDX-License-Identifier: GPL-2.0-only



 Copyright (c) 2021 MediaTek Inc.

 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>

/*

 * The "en_reg" and "pcw_chg_reg" fields are standard offset register compared

 * with "reg" field, so set zero to imply it.

 * No tuner control in apu pll, so set "tuner_XXX" as zero to imply it.

 * No rst or post divider enable in apu pll, so set "rst_bar_mask" and "en_mask"

 * as zero to imply it.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2019 MediaTek Inc.

 * Author: Wendell Lin <wendell.lin@mediatek.com>

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2020 MediaTek Inc.

 * Copyright (c) 2020 BayLibre, SAS

 * Author: James Liao <jamesjj.liao@mediatek.com>

 *         Fabien Parent <fparent@baylibre.com>

 MM0 */

 MM1 */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2020 MediaTek Inc.

 * Copyright (c) 2020 BayLibre, SAS

 * Author: James Liao <jamesjj.liao@mediatek.com>

 *         Fabien Parent <fparent@baylibre.com>

 SPDX-License-Identifier: GPL-2.0-only



 Copyright (c) 2021 MediaTek Inc.

 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>

 INFRA_AO0 */

 infra_ao_sej is main clock is for secure engine with JTAG support */

 INFRA_AO1 */

 infra_ao_device_apc is for device access permission control module */

 INFRA_AO2 */

 INFRA_AO3 */

 infra_ao_device_apc_sync is for device access permission control module */

 INFRA_AO4 */

 infra_ao_133m_m_peri infra_ao_66m_m_peri are main clocks of peripheral */

 sentinel */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2016 MediaTek Inc.

 * Author: Kevin Chen <kevin-cw.chen@mediatek.com>

/*

 * For some clocks, we don't care what their actual rates are. And these

 * clocks may change their rate on different products or different scenarios.

 * So we model these clocks' rate as 0, to denote it's not an actual rate.

/*

 * Clock mux ddrphycfg is needed by the DRAM controller. We mark it as

 * critical as otherwise the system will hang after boot.

/*

 * Clock gates dramc and dramc_b are needed by the DRAM controller.

 * We mark them as critical as otherwise the system will hang after boot.

 sentinel */

 SPDX-License-Identifier: GPL-2.0-only



 Copyright (c) 2021 MediaTek Inc.

 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>

 sentinel */

 SPDX-License-Identifier: GPL-2.0-only



 Copyright (c) 2021 MediaTek Inc.

 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>

 VDEC0 */

 VDEC1 */

 VDEC2 */

 VDEC0 */

 VDEC1 */

 VDEC2 */

 VDEC0 */

 VDEC1 */

 VDEC2 */

 sentinel */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2018 MediaTek Inc.

 * Author: Owen Chen <owen.chen@mediatek.com>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2017 MediaTek Inc.

 * Author: Weiyi Lu <weiyi.lu@mediatek.com>

 SPDX-License-Identifier: GPL-2.0-only



 Copyright (c) 2021 MediaTek Inc.

 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>

 VDO0_0 */

 VDO0_1 */

 VDO0_2 */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2017 MediaTek Inc.

 * Author: Chen Zhong <chen.zhong@mediatek.com>

 *	   Sean Wang <sean.wang@mediatek.com>

 for consumer */

 TOP0 */

 TOP1 */

 PERI0 */

 PERI1 */

 CLK_CFG_0 */

 CLK_CFG_1 */

 CLK_CFG_2 */

 CLK_CFG_3 */

 CLK_CFG_4 */

 CLK_CFG_5 */

 CLK_CFG_6 */

 CLK_CFG_7 */

 CLK_AUDDIV_0 */

 PERI_GLOBALCON_CKSEL */

 sentinel */

 SPDX-License-Identifier: GPL-2.0



 Copyright (c) 2018 MediaTek Inc.

 Author: Weiyi Lu <weiyi.lu@mediatek.com>

 Infra global controller reset set register */

/*

 * CRITICAL CLOCK:

 * axi_sel is the main bus clock of whole SOC.

 * spm_sel is the clock of the always-on co-processor.

 CLK_CFG_0 */

 CLK_CFG_1 */

 CLK_CFG_2 */

 CLK_CFG_3 */

 CLK_CFG_4 */

 CLK_CFG_5 */

 CLK_CFG_6 */

 CLK_CFG_7 */

 CLK_CFG_8 */

 CLK_CFG_9 */

 CLK_CFG_10 */

 mp0_pll_divider_cfg */

 mp2_pll_divider_cfg */

 bus_pll_divider_cfg */

 TOP */

 INFRA0 */

 INFRA1 */

 INFRA2 */

 INFRA3 */

/*

 * CRITICAL CLOCK:

 * apmixed_appll26m is the toppest clock gate of all PLLs.

 AUDIO0 */

 sentinel */

 sentinel */

 sentinel */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2019 MediaTek Inc.

 * Author: Wendell Lin <wendell.lin@mediatek.com>

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2018 MediaTek Inc.

 * Author: Owen Chen <owen.chen@mediatek.com>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2017 MediaTek Inc.

 * Author: Chen Zhong <chen.zhong@mediatek.com>

 *	   Sean Wang <sean.wang@mediatek.com>

 sentinel */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2017 MediaTek Inc.

 * Author: Kevin-CW Chen <kevin-cw.chen@mediatek.com>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2014 MediaTek Inc.

 * Author: Shunli Wang <shunli.wang@mediatek.com>

/*

 * For some clocks, we don't care what their actual rates are. And these

 * clocks may change their rate on different products or different scenarios.

 * So we model these clocks' rate as 0, to denote it's not an actual rate.

 sentinel */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2019 MediaTek Inc.

 * Author: Wendell Lin <wendell.lin@mediatek.com>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2014 MediaTek Inc.

 * Author: Shunli Wang <shunli.wang@mediatek.com>

 SPDX-License-Identifier: GPL-2.0



 Copyright (c) 2018 MediaTek Inc.

 Author: Weiyi Lu <weiyi.lu@mediatek.com>

 SPDX-License-Identifier: GPL-2.0-only



 Copyright (c) 2021 MediaTek Inc.

 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>

 MDP0 */

 MDP1 */

 sentinel */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2018 MediaTek Inc.

 * Author: Ryder Lee <ryder.lee@mediatek.com>

 AUDIO0 */

 AUDIO1 */

 AUDIO2 */

 AUDIO3 */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2017 MediaTek Inc.

 * Author: Weiyi Lu <weiyi.lu@mediatek.com>

 VDEC0 */

 VDEC1 */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2017 MediaTek Inc.

 * Author: Weiyi Lu <weiyi.lu@mediatek.com>

 MM0 */

 MM1 */

 MM2 */

 SPDX-License-Identifier: GPL-2.0-only



 Copyright (c) 2021 MediaTek Inc.

 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>

 sentinel */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2019 MediaTek Inc.

 * Author: Wendell Lin <wendell.lin@mediatek.com>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2014 MediaTek Inc.

 * Author: Shunli Wang <shunli.wang@mediatek.com>

 SPDX-License-Identifier: GPL-2.0-only



 Copyright (c) 2021 MediaTek Inc.

 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>

 VPP1_0 */

 VPP1_1 */

 sentinel */

 SPDX-License-Identifier: GPL-2.0-only



 Copyright (c) 2021 MediaTek Inc.

 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>

 sentinel */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2014 MediaTek Inc.

 * Author: Shunli Wang <shunli.wang@mediatek.com>

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2018 MediaTek Inc.

 * Author: Owen Chen <owen.chen@mediatek.com>

 SPDX-License-Identifier: GPL-2.0



 Copyright (c) 2018 MediaTek Inc.

 Author: Weiyi Lu <weiyi.lu@mediatek.com>

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2018 MediaTek Inc.

 * Author: Owen Chen <owen.chen@mediatek.com>

 MM */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2018 MediaTek Inc.

 * Author: Owen Chen <owen.chen@mediatek.com>

 SPDX-License-Identifier: GPL-2.0



 Copyright (c) 2018 MediaTek Inc.

 Author: Weiyi Lu <weiyi.lu@mediatek.com>

 VDEC0 */

 VDEC1 */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2019 MediaTek Inc.

 * Author: Wendell Lin <wendell.lin@mediatek.com>

 AUDIO0 */

 AUDIO1 */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2018 MediaTek Inc.

 * Author: Sean Wang <sean.wang@mediatek.com>

 *

 sentinel */

 SPDX-License-Identifier: GPL-2.0-only



 Copyright (c) 2021 MediaTek Inc.

 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>

 sentinel */

 SPDX-License-Identifier: GPL-2.0-only



 Copyright (c) 2021 MediaTek Inc.

 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>

 AUD0 */

 AUD1 */

 AUD2 */

 SPDX-License-Identifier: GPL-2.0



 Copyright (c) 2018 MediaTek Inc.

 Author: Weiyi Lu <weiyi.lu@mediatek.com>

 SPDX-License-Identifier: GPL-2.0



 Copyright (c) 2018 MediaTek Inc.

 Author: Weiyi Lu <weiyi.lu@mediatek.com>

 SPDX-License-Identifier: GPL-2.0-only



 Copyright (c) 2021 MediaTek Inc.

 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>

 sentinel */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2017 MediaTek Inc.

 * Author: Weiyi Lu <weiyi.lu@mediatek.com>

 SPDX-License-Identifier: GPL-2.0-only



 Copyright (c) 2021 MediaTek Inc.

 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>

 VDO1_0 */

 VDO1_1 */

 VDO1_2 */

 VDO1_3 */

 SPDX-License-Identifier: GPL-2.0-only



 Copyright (c) 2021 MediaTek Inc.

 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>

 sentinel */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2018 MediaTek Inc.

 * Author: Owen Chen <owen.chen@mediatek.com>

 AUDIO0 */

 AUDIO1 */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2014 MediaTek Inc.

 * Author: Shunli Wang <shunli.wang@mediatek.com>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2014 MediaTek Inc.

 * Author: James Liao <jamesjj.liao@mediatek.com>

 MM0 */

 MM1 */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2014 MediaTek Inc.

 * Author: James Liao <jamesjj.liao@mediatek.com>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2014 MediaTek Inc.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2020 MediaTek Inc.

 * Copyright (c) 2020 BayLibre, SAS

 * Author: James Liao <jamesjj.liao@mediatek.com>

 *         Fabien Parent <fparent@baylibre.com>

 CLK_MUX_SEL0 */

 CLK_MUX_SEL1 */

 CLK_MUX_SEL8 */

 CLK_SEL_9 */

 CLK_MUX_SEL13 */

 TOP0 */

 TOP1 */

 TOP2 */

 TOP3 */

 TOP4 */

 TOP5 */

 sentinel */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2017 MediaTek Inc.

 * Author: Chen Zhong <chen.zhong@mediatek.com>

 *	   Sean Wang <sean.wang@mediatek.com>

 AUDIO0 */

 AUDIO1 */

 AUDIO2 */

 AUDIO3 */

 sentinel */

 SPDX-License-Identifier: GPL-2.0-only



 Copyright (c) 2021 MediaTek Inc.

 Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>

 sentinel */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2012 Freescale Semiconductor, Inc.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2012 Freescale Semiconductor, Inc.

 Gate off cpu clock in WFI for power saving */

 Clear BYPASS for SAIF */

 SAIF has to use frac div for functional operation */

	/*

	 * Source ssp clock from ref_io than ref_xtal,

	 * as ref_xtal only provides 24 MHz as maximum.

	/*

	 * 480 MHz seems too high to be ssp clock source directly,

	 * so set frac to get a 288 MHz ref_io.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2012 Freescale Semiconductor, Inc.

/*

 * HW_SAIF_CLKMUX_SEL:

 *  DIRECT(0x0): SAIF0 clock pins selected for SAIF0 input clocks, and SAIF1

 *		clock pins selected for SAIF1 input clocks.

 *  CROSSINPUT(0x1): SAIF1 clock inputs selected for SAIF0 input clocks, and

 *		SAIF0 clock inputs selected for SAIF1 input clocks.

 *  EXTMSTR0(0x2): SAIF0 clock pin selected for both SAIF0 and SAIF1 input

 *		clocks.

 *  EXTMSTR1(0x3): SAIF1 clock pin selected for both SAIF0 and SAIF1 input

 *		clocks.

 Gate off cpu clock in WFI for power saving */

 0 is a bad default value for a divider */

 Clear BYPASS for SAIF */

 SAIF has to use frac div for functional operation */

 Extra fec clock setting */

	/*

	 * Source ssp clock from ref_io than ref_xtal,

	 * as ref_xtal only provides 24 MHz as maximum.

	/*

	 * 480 MHz seems too high to be ssp clock source directly,

	 * so set frac0 to get a 288 MHz ref_io0 and ref_io1.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2012 Freescale Semiconductor, Inc.

/**

 * struct clk_frac - mxs fractional divider clock

 * @hw: clk_hw for the fractional divider clock

 * @reg: register address

 * @shift: the divider bit shift

 * @width: the divider bit width

 * @busy: busy bit shift

 *

 * The clock is an adjustable fractional divider with a busy bit to wait

 * when the divider is adjusted.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2012 Freescale Semiconductor, Inc.

/**

 * struct clk_pll - mxs pll clock

 * @hw: clk_hw for the pll

 * @base: base address of the pll

 * @power: the shift of power bit

 * @rate: the clock rate of the pll

 *

 * The mxs pll is a fixed rate clock with power and gate control,

 * and the shift of gate bit is always 31.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2012 DENX Software Engineering, GmbH

 *

 * Pulled from code:

 * Portions copyright (C) 2003 Russell King, PXA MMCI Driver

 * Portions copyright (C) 2004-2005 Pierre Ossman, W83L51xD SD/MMC driver

 *

 * Copyright 2008 Embedded Alley Solutions, Inc.

 * Copyright 2009-2011 Freescale Semiconductor, Inc.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2012 Freescale Semiconductor, Inc.

/**

 * struct clk_div - mxs integer divider clock

 * @divider: the parent class

 * @ops: pointer to clk_ops of parent class

 * @reg: register address

 * @busy: busy bit shift

 *

 * The mxs divider clock is a subclass of basic clk_divider with an

 * addtional busy bit.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2012 Freescale Semiconductor, Inc.

/**

 * struct clk_ref - mxs reference clock

 * @hw: clk_hw for the reference clock

 * @reg: register address

 * @idx: the index of the reference clock within the same register

 *

 * The mxs reference clock sources from pll.  Every 4 reference clocks share

 * one register space, and @idx is used to identify them.  Each reference

 * clock has a gate control and a fractional * divider.  The rate is calculated

 * as pll rate  * (18 / FRAC), where FRAC = 18 ~ 35.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2014 Chen-Yu Tsai

 * Author: Chen-Yu Tsai <wens@csie.org>

 *

 * Allwinner A23 APB0 clock driver

 *

 * Based on clk-sun6i-apb0.c

 * Allwinner A31 APB0 clock driver

 *

 * Copyright (C) 2014 Free Electrons

 * Author: Boris BREZILLON <boris.brezillon@free-electrons.com>

 The A23 APB0 clock is a standard 2 bit wide divider clock */

		/*

		 * This happens with clk nodes instantiated through mfd,

		 * as those do not have their resources assigned in the

		 * device tree. Do not print an error in this case.

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2014 Free Electrons

 *

 * Author: Boris BREZILLON <boris.brezillon@free-electrons.com>

 *

 * Allwinner A31 APB0 clock driver

/*

 * The APB0 clk has a configurable divisor.

 *

 * We must use a clk_div_table and not a regular power of 2

 * divisor here, because the first 2 values divide the clock

 * by 2.

 sentinel */ },

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2015 Maxime Ripard

 *

 * Maxime Ripard <maxime.ripard@free-electrons.com>

 ahb_sdram */

 dram_output */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2013-2015 Emilio López

 *

 * Emilio López <emilio@elopez.com.ar>

/*

 * sunxi_usb_reset... - reset bits in usb clk registers handling

/**

 * sunxi_usb_clk_setup() - Setup function for usb gate clocks

 Worst-case size approximation and memory allocation */

 Adjust to the real max */

 Register a reset controller for usb with reset bits */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2015 Maxime Ripard

 *

 * Maxime Ripard <maxime.ripard@free-electrons.com>

 We only have a single reset signal */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2013 Emilio López

 *

 * Emilio López <emilio@elopez.com.ar>

 allocate fixed-rate and gate clock structs */

 set up gate and fixed rate properties */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2013 Emilio López

 * Emilio López <emilio@elopez.com.ar>

 *

 * Copyright 2013 Chen-Yu Tsai

 * Chen-Yu Tsai <wens@csie.org>

/**

 * sun7i_a20_gmac_clk_setup - Setup function for A20/A31 GMAC clock module

 *

 * This clock looks something like this

 *                               ________________________

 *  MII TX clock from PHY >-----|___________    _________|----> to GMAC core

 *  GMAC Int. RGMII TX clk >----|___________\__/__gate---|----> to PHY

 *  Ext. 125MHz RGMII TX clk >--|__divider__/            |

 *                              |________________________|

 *

 * The external 125 MHz reference is optional, i.e. GMAC can use its

 * internal TX clock just fine. The A31 GMAC clock module does not have

 * the divider controls for the external reference.

 *

 * To keep it simple, let the GMAC use either the MII TX clock for MII mode,

 * and its internal TX clock for GMII and RGMII modes. The GMAC driver should

 * select the appropriate source and gate/ungate the output to the PHY.

 *

 * Only the GMAC should use this clock. Altering the clock so that it doesn't

 * match the GMAC's operation parameters will result in the GMAC not being

 * able to send traffic out. The GMAC driver should set the clock rate and

 * enable/disable this clock to configure the required state. The clock

 * driver then responds by auto-reparenting the clock.

 Select mii_phy_tx_clk */

 Select gmac_int_tx_clk */

 allocate mux and gate clock structs */

 gmac clock requires exactly 2 parents */

 set up gate and fixed rate properties */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2015 Chen-Yu Tsai

 *

 * Chen-Yu Tsai <wens@csie.org>

/*

 * sunxi_ve_reset... - reset bit in ve clk registers handling

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2013 Emilio López

 *

 * Emilio López <emilio@elopez.com.ar>

/*

 * sun4i_a10_get_mod0_factors() - calculates m, n factors for MOD0-style clocks

 * MOD0 rate is calculated as follows

 * rate = (parent_rate >> p) / (m + 1);

	/* These clocks can only divide, so we will never be able to achieve

 user manual says "n" but it's really "p" */

		/*

		 * This happens with mod0 clk nodes instantiated through

		 * mfd, as those do not have their resources assigned at

		 * CLK_OF_DECLARE time yet, so do not print an error.

 sentinel */ }

 The MBUS clocks needs to be always enabled */

 Get the main MMC clock */

 And its rate */

 Now, get the MMC parent (most likely some PLL) */

 And its rate */

 Get MMC clock divider */

 Get the main MMC clock */

 And its rate */

 Now, get the MMC parent (most likely some PLL) */

 And its rate */

 Get MMC clock divider */

		/*

		 * We can only outphase the clocks by multiple of the

		 * PLL's period.

		 *

		 * Since the MMC clock in only a divider, and the

		 * formula to get the outphasing in degrees is deg =

		 * 360 * delta / period

		 *

		 * If we simplify this formula, we can see that the

		 * only thing that we're concerned about is the number

		 * of period we want to outphase our clock from, and

		 * the divider set by the MMC clock.

/*

 * sunxi_mmc_setup - Common setup function for mmc module clocks

 *

 * The only difference between module clocks on different platforms is the

 * width of the mux register bits and the valid values, which are passed in

 * through struct factors_data. The phase clocks parts are identical.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2015 Jens Kuske <jenskuske@gmail.com>

 *

 * Based on clk-simple-gates.c, which is:

 * Copyright 2015 Maxime Ripard

 *

 * Maxime Ripard <maxime.ripard@free-electrons.com>

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2013 Emilio López

 *

 * Emilio López <emilio@elopez.com.ar>

 Maximum number of parents our clocks have */

/*

 * sun4i_get_pll1_factors() - calculates n, k, m, p factors for PLL1

 * PLL1 rate is calculated as follows

 * rate = (parent_rate * n * (k + 1) >> p) / (m + 1);

 * parent_rate is always 24Mhz

 Normalize value to a 6M multiple */

 m is always zero for pll1 */

 k is 1 only on these cases */

 p will be 3 for divs under 10 */

 p will be 2 for divs between 10 - 20 and odd divs under 32 */

	/* p will be 1 for even divs under 32, divs under 40 and odd pairs

 any other entries have p = 0 */

 calculate a suitable n based on k and p */

/*

 * sun6i_a31_get_pll1_factors() - calculates n, k and m factors for PLL1

 * PLL1 rate is calculated as follows

 * rate = parent_rate * (n + 1) * (k + 1) / (m + 1);

 * parent_rate should always be 24MHz

	/*

	 * We can operate only on MHz, this will make our life easier

	 * later.

	/*

	 * Round down the frequency to the closest multiple of either

	 * 6 or 16

 If the frequency is a multiple of 32 MHz, k is always 3 */

 If the frequency is a multiple of 9 MHz, k is always 2 */

 If the frequency is a multiple of 8 MHz, k is always 1 */

 Otherwise, we don't use the k factor */

	/*

	 * If the frequency is a multiple of 2 but not a multiple of

	 * 3, m is 3. This is the first time we use 6 here, yet we

	 * will use it on several other places.

	 * We use this number because it's the lowest frequency we can

	 * generate (with n = 0, k = 0, m = 3), so every other frequency

	 * somehow relates to this frequency.

	/*

	 * If the frequency is a multiple of 6MHz, but the factor is

	 * odd, m will be 3

 Otherwise, we end up with m = 1 */

 Calculate n thanks to the above factors we already got */

	/*

	 * If n end up being outbound, and that we can still decrease

	 * m, do it.

/*

 * sun8i_a23_get_pll1_factors() - calculates n, k, m, p factors for PLL1

 * PLL1 rate is calculated as follows

 * rate = (parent_rate * (n + 1) * (k + 1) >> p) / (m + 1);

 * parent_rate is always 24Mhz

 Normalize value to a 6M multiple */

 m is always zero for pll1 */

 k is 1 only on these cases */

 p will be 2 for divs under 20 and odd divs under 32 */

	/* p will be 1 for even divs under 32, divs under 40 and odd pairs

 any other entries have p = 0 */

 calculate a suitable n based on k and p */

/*

 * sun4i_get_pll5_factors() - calculates n, k factors for PLL5

 * PLL5 rate is calculated as follows

 * rate = parent_rate * n * (k + 1)

 * parent_rate is always 24Mhz

 Normalize value to a parent_rate multiple (24M) */

/*

 * sun6i_a31_get_pll6_factors() - calculates n, k factors for A31 PLL6x2

 * PLL6x2 rate is calculated as follows

 * rate = parent_rate * (n + 1) * (k + 1)

 * parent_rate is always 24Mhz

 Normalize value to a parent_rate multiple (24M) */

/*

 * sun5i_a13_get_ahb_factors() - calculates m, p factors for AHB

 * AHB rate is calculated as follows

 * rate = parent_rate >> p

 divide only */

	/*

	 * user manual says valid speed is 8k ~ 276M, but tests show it

	 * can work at speeds up to 300M, just after reparenting to pll6

 p = 0 ~ 3 */

/*

 * sun6i_a31_get_ahb_factors() - calculates m, p factors for AHB

 * AHB rate is calculated as follows

 * rate = parent_rate >> p

 *

 * if parent is pll6, then

 * parent_rate = pll6 rate / (m + 1)

	/*

	 * clock can only divide, so we will never be able to achieve

	 * frequencies higher than the parent frequency

 calculate pre-divider if parent is pll6 */

/*

 * sun6i_ahb1_recalc() - calculates AHB clock rate from m, p factors and

 *			 parent index

 apply pre-divider first if parent is pll6 */

 clk divider */

/*

 * sun4i_get_apb1_factors() - calculates m, p factors for APB1

 * APB1 rate is calculated as follows

 * rate = (parent_rate >> p) / (m + 1);

 Invalid rate! */

/*

 * sun7i_a20_get_out_factors() - calculates m, p factors for CLK_OUT_A/B

 * CLK_OUT rate is calculated as follows

 * rate = (parent_rate >> p) / (m + 1);

	/* These clocks can only divide, so we will never be able to achieve

/*

 * sunxi_factors_clk_setup() - Setup function for factor clocks

 user manual says "n" but it's really "p" */

/*

 * sunxi_mux_clk_setup() - Setup function for muxes

 Protect CPU clock */

/*

 * sunxi_divider_clk_setup() - Setup function for simple divider clocks

 sentinel */

 sentinel */

/*

 * sunxi_gates_clk_setup() - Setup function for leaf gates on clocks

/*

 * sunxi_divs_clk_setup() helper data

 data for the factor clock */

 number of outputs */

	/*

	 * List of outputs. Refer to the diagram for sunxi_divs_clk_setup():

	 * self or base factor clock refers to the output from the pll

	 * itself. The remaining refer to fixed or configurable divider

	 * outputs.

 is it the base factor clock? (only one) */

 is it a fixed divisor? if not... */

 is it a table based divisor? */

 otherwise it's a normal divisor with this shift */

 is it power-of-two based? */

 is it independently gateable? */

 sentinel */

 Protect PLL5_DDR */

 M, DDR */

 P, other */

 No output for the base factor clock */

 M, SATA */

 P, other */

 base factor clock, 2x */

 pll6 / 4, used as ahb input */

 normal output */

 base factor clock, 2x */

/*

 * sunxi_divs_clk_setup() - Setup function for leaf divisors on clocks

 *

 * These clocks look something like this

 *            ________________________

 *           |         ___divisor 1---|----> to consumer

 * parent >--|  pll___/___divisor 2---|----> to consumer

 *           |        \_______________|____> to consumer

 *           |________________________|

 if number of children known, use it */

 Try to find a name for base factor clock */

 If we don't have a .self clk use the first output-name up to '_' */

 Set up factor clock that we will be dividing */

	/* It's not a good idea to have automatic reparenting changing

 If this is the base factor clock, only update clks */

 If this leaf clock can be gated, create a gate */

 Leaves can be fixed or configurable divisors */

		/* Wrap the (potential) gate and the divisor on a composite

 Adjust to the real max */

/*

 * sun6i display

 *

 * rate = parent_rate / (m + 1);

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2014 Chen-Yu Tsai

 *

 * Chen-Yu Tsai <wens@csie.org>

 The MBUS clocks needs to be always enabled */

 parents is deep copied */

 TODO: The composite clock stuff will leak a bit here. */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2013 Emilio López

 *

 * Emilio López <emilio@elopez.com.ar>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2013 Emilio López <emilio@elopez.com.ar>

 *

 * Adjustable factor-based clock implementation

/*

 * DOC: basic adjustable factor-based clock

 *

 * Traits of this clock:

 * prepare - clk_prepare only ensures that parents are prepared

 * enable - clk_enable only ensures that parents are enabled

 * rate - rate is adjustable.

 *        clk->rate = (parent->rate * N * (K + 1) >> P) / (M + 1)

 * parent - fixed parent.  No clk_set_parent support

 Fetch the register value */

 Get each individual factor if applicable */

 get mux details from mux clk structure */

 Calculate the rate */

 find the parent that can help provide the fastest rate <= rate */

 Fetch the register value */

 Set up the new factors - macros do not do anything if width is 0 */

 Apply them now */

 delay 500us so pll stabilizes */

 if we have a mux, we will have >1 parents */

	/*

	 * some factor clocks, such as pll5 and pll6, may have multiple

	 * outputs, and have their name designated in factors_data

 set up factors properties */

 Add a gate if this factor clock can be gated */

 set up gate properties */

 Add a mux if this factor clock can be muxed */

 set up gate properties */

 TODO: The composite clock stuff will leak a bit here. */

 TODO: The composite clock stuff will leak a bit here. */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2015 Maxime Ripard

 *

 * Maxime Ripard <maxime.ripard@free-electrons.com>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2014 Free Electrons

 *

 * Author: Boris BREZILLON <boris.brezillon@free-electrons.com>

 *

 * Allwinner A31 APB0 clock gates driver

 sentinel */ }

 Worst-case size approximation and memory allocation */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2014 Chen-Yu Tsai

 *

 * Chen-Yu Tsai <wens@csie.org>

/*

 * sun9i_a80_get_pll4_factors() - calculates n, p, m factors for PLL4

 * PLL4 rate is calculated as follows

 * rate = (parent_rate * n >> p) / (m + 1);

 * parent_rate is always 24MHz

 *

 * p and m are named div1 and div2 in Allwinner's SDK

 Normalize value to a 6 MHz multiple (24 MHz / 4) */

 If n is too large switch to steps of 12 MHz */

 If n is still too large switch to steps of 24 MHz */

 n must be between 12 and 255 */

/*

 * sun9i_a80_get_gt_factors() - calculates m factor for GT

 * GT rate is calculated as follows

 * rate = parent_rate / (m + 1);

 maximum divider is 4 */

 The GT bus clock needs to be always enabled */

/*

 * sun9i_a80_get_ahb_factors() - calculates p factor for AHB0/1/2

 * AHB rate is calculated as follows

 * rate = parent_rate >> p;

 maximum p is 3 */

/*

 * sun9i_a80_get_apb1_factors() - calculates m, p factors for APB1

 * APB1 rate is calculated as follows

 * rate = (parent_rate >> p) / (m + 1);

 Highest possible divider is 256 (p = 3, m = 31) */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2015 Chen-Yu Tsai

 *

 * Chen-Yu Tsai	<wens@csie.org>

 one clock/reset pair per word */

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2015 Maxime Ripard

 *

 * Maxime Ripard <maxime.ripard@free-electrons.com>

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2015 Chen-Yu Tsai

 *

 * Chen-Yu Tsai <wens@csie.org>

 *

 * Allwinner A80 CPUS clock driver

 *

/**

 * sun9i_a80_cpus_clk_setup() - Setup function for a80 cpus composite clk

 Fetch the register value */

 apply pre-divider first if parent is pll4 */

 clk divider */

	/*

	 * clock can only divide, so we will never be able to achieve

	 * frequencies higher than the parent frequency

 calculate pre-divider if parent is pll4 */

 pre-divider is 1 ~ 32 */

 we were asked to pass back divider values */

 find the parent that can help provide the fastest rate <= rate */

 need to know which parent is used to apply pre-divider */

 we have a mux, we will have >1 parents */

 set up clock properties */

 un-shifted mask is what mux_clk expects */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2013 Emilio López

 *

 * Emilio López <emilio@elopez.com.ar>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2014 Free Electrons

 *

 * Author: Boris BREZILLON <boris.brezillon@free-electrons.com>

 *

 * Allwinner A31 AR100 clock driver

/*

 * sun6i_get_ar100_factors - Calculates factors p, m for AR100

 *

 * AR100 rate is calculated as follows

 * rate = (parent_rate >> p) / (m + 1);

 clock only divides */

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2013 Emilio López

 * Emilio López <emilio@elopez.com.ar>

 *

 * Copyright 2015 Maxime Ripard

 * Maxime Ripard <maxime.ripard@free-electrons.com>

 Setup the gate part of the PLL2 */

 Setup the multiplier part of the PLL2 */

	/*

	 * PLL2-1x

	 *

	 * This is supposed to have a post divider, but we won't need

	 * to use it, we just need to initialise it to 4, and use a

	 * fixed divider.

	/*

	 * PLL2-2x

	 *

	 * This clock doesn't use the post divider, and really is just

	 * a fixed divider from the PLL2 base clock.

 PLL2-4x */

 PLL2-8x */

 SPDX-License-Identifier: GPL-2.0

 sentinel */}

 sentinel */}

 sentinel */}

 sentinel */}

 sentinel */}

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * clk-h32mx.c

 *

 *  Copyright (C) 2014 Atmel

 *

 * Alexandre Belloni <alexandre.belloni@free-electrons.com>

 SPDX-License-Identifier: GPL-2.0

 CONFIG_HAVE_AT91_AUDIO_PLL */

 CONFIG_HAVE_AT91_GENERATED_CLK */

 CONFIG_HAVE_AT91_H32MX */

 CONFIG_HAVE_AT91_I2S_MUX_CLK */

 CONFIG_HAVE_AT91_SMD */

 CONFIG_HAVE_AT91_USB_CLK */

	/*

	 * If the device supports different mainck rates, this value has to be

	 * set in the UTMI Clock Trimming register.

	 * - 9x5: mainck supports several rates but it is indicated that a

	 *   12 MHz is needed in case of USB.

	 * - sama5d3 and sama5d2: mainck supports several rates. Configuring

	 *   the FREQ field of the UTMI Clock Trimming register is mandatory.

	 * - sama5d4: mainck is at 12 MHz.

	 *

	 * We only need to retrieve sama5d3 or sama5d2 sfr regmap.

 CONFIG_HAVE_AT91_UTMI */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright (C) 2013 Boris BREZILLON <b.brezillon@overkiz.com>

 SPDX-License-Identifier: GPL-2.0

/*

 * The TCB is used as the clocksource so its clock is needed early. This means

 * this can't be a platform driver.

 SPDX-License-Identifier: GPL-2.0

					   /*

					    * This feeds pllack_divck which

					    * feeds CPU. It should not be

					    * disabled.

					   /*

					    * This feeds CPU. It should not

					    * be disabled.

 Some clks are used for a clocksource */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright (C) 2013 Boris BREZILLON <b.brezillon@overkiz.com>

 SPDX-License-Identifier: GPL-2.0

/*

 * The TCB is used as the clocksource so its clock is needed early. This means

 * this can't be a platform driver.

 SPDX-License-Identifier: GPL-2.0+

/*

 *  Copyright (C) 2019 Microchip Technology Inc.

 *

 Recommended value for PMC_PLL_ACR */

 Enable the UTMI internal bandgap */

 Enable the UTMI internal regulator */

	/*

	 * Calculate the multiplier associated with the current

	 * divider that provide the closest rate to the requested one.

 Check if resulted rate is a valid.  */

 This function should be called with spinlock acquired. */

 Stop if enabled an nothing changed. */

 Stop if nothing changed. */

	/*

	 * We switch to safe divider to avoid overclocking of other domains

	 * feed by us while the frac PLL (our parent) is changed.

 Stop if nothing changed. */

		/*

		 * This means the PLL is not setup by bootloaders. In this

		 * case we need to set the minimum rate for it. Otherwise

		 * a clock child of this PLL may be enabled before setting

		 * its rate leading to enabling this PLL with unsupported

		 * rate. This will lead to PLL not being locked at all.

 We only support one changeable PLL. */

 SPDX-License-Identifier: GPL-2.0

/*

 * SAMA7G5 PMC code.

 *

 * Copyright (C) 2020 Microchip Technology Inc. and its subsidiaries

 *

 * Author: Claudiu Beznea <claudiu.beznea@microchip.com>

 *

/*

 * PLL clocks identifiers

 * @PLL_ID_CPU:		CPU PLL identifier

 * @PLL_ID_SYS:		System PLL identifier

 * @PLL_ID_DDR:		DDR PLL identifier

 * @PLL_ID_IMG:		Image subsystem PLL identifier

 * @PLL_ID_BAUD:	Baud PLL identifier

 * @PLL_ID_AUDIO:	Audio PLL identifier

 * @PLL_ID_ETH:		Ethernet PLL identifier

/*

 * PLL type identifiers

 * @PLL_TYPE_FRAC:	fractional PLL identifier

 * @PLL_TYPE_DIV:	divider PLL identifier

 Layout for fractional PLLs. */

 Layout for DIVPMC dividers. */

 Layout for DIVIO dividers. */

/*

 * CPU PLL output range.

 * Notice: The upper limit has been setup to 1000000002 due to hardware

 * block which cannot output exactly 1GHz.

 PLL output range. */

 CPU PLL characteristics. */

 PLL characteristics. */

/*

 * PLL clocks description

 * @n:		clock name

 * @p:		clock parent

 * @l:		clock layout

 * @c:		clock characteristics

 * @t:		clock type

 * @f:		clock flags

 * @eid:	export index in sama7g5->chws[] array

 * @safe_div:	intermediate divider need to be set on PRE_RATE_CHANGE

 *		notification

		   /*

		    * This feeds cpupll_divpmcck which feeds CPU. It should

		    * not be disabled.

 This feeds CPU. It should not be disabled. */

		  /*

		   * Safe div=15 should be safe even for switching b/w 1GHz and

		   * 90MHz (frac pll might go up to 1.2GHz).

		   /*

		    * This feeds syspll_divpmcck which may feed critical parts

		    * of the systems like timers. Therefore it should not be

		    * disabled.

		   /*

		    * This may feed critical parts of the systems like timers.

		    * Therefore it should not be disabled.

		   /*

		    * This feeds ddrpll_divpmcck which feeds DDR. It should not

		    * be disabled.

 This feeds DDR. It should not be disabled. */

/*

 * Master clock (MCK[1..4]) description

 * @n:			clock name

 * @ep:			extra parents names array

 * @ep_chg_chg_id:	index in parents array that specifies the changeable

 *			parent

 * @ep_count:		extra parents count

 * @ep_mux_table:	mux table for extra parents

 * @id:			clock id

 * @c:			true if clock is critical and cannot be disabled

/*

 * System clock description

 * @n:	clock name

 * @p:	clock parent name

 * @id: clock id

 Mux table for programmable clocks. */

/*

 * Peripheral clock description

 * @n:		clock name

 * @p:		clock parent name

 * @r:		clock range values

 * @id:		clock id

 * @chgp:	index in parent array of the changeable parent

/*

 * Generic clock description

 * @n:			clock name

 * @pp:			PLL parents

 * @pp_mux_table:	PLL parents mux table

 * @r:			clock output range

 * @pp_chg_id:		id in parent array of changeable PLL parent

 * @pp_count:		PLL parents count

 * @id:			clock id

 MCK0 characteristics. */

 MCK0 layout. */

 Programmable clock layout. */

 Peripheral clock layout. */

 Some clks are used for a clocksource */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright (C) 2013 Boris BREZILLON <b.brezillon@overkiz.com>

 Fist step: check the available dividers. */

 Step two: try to request rate from parent. */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

/*

 * The TCB is used as the clocksource so its clock is needed early. This means

 * this can't be a platform driver.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright (C) 2013 Boris BREZILLON <b.brezillon@overkiz.com>

 Check if parent_rate is a valid input rate */

	/*

	 * Calculate minimum divider based on the minimum multiplier, the

	 * parent_rate and the requested rate.

	 * Should always be 2 according to the input and output characteristics

	 * of the PLL blocks.

	/*

	 * Calculate the maximum divider which is limited by PLL register

	 * layout (limited by the MUL or DIV field size).

	/*

	 * Iterate over the acceptable divider values to find the best

	 * divider/multiplier pair (the one that generates the closest

	 * rate to the requested one).

		/*

		 * Calculate the multiplier associated with the current

		 * divider that provide the closest rate to the requested one.

		/*

		 * Compare the remainder with the best remainder found until

		 * now and elect a new best multiplier/divider pair if the

		 * current remainder is smaller than the best one.

		/*

		 * We've found a perfect match!

		 * Stop searching now and use this multiplier/divider pair.

 We haven't found any multiplier/divider pair => return -ERANGE */

 Check if bestrate is a valid output rate  */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright (C) 2013 Boris BREZILLON <b.brezillon@overkiz.com>

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright (C) 2013 Boris BREZILLON <b.brezillon@overkiz.com>

 Address in SECURAM that say if we suspend to backup mode. */

 sentinel */ }

 This has to happen before arch_initcall because of the tcb_clksrc driver */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright (C) 2013 Boris BREZILLON <b.brezillon@overkiz.com>

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright (C) 2015 Atmel Corporation,

 *                     Nicolas Ferre <nicolas.ferre@atmel.com>

 *

 * Based on clk-programmable & clk-peripheral drivers by Boris BREZILLON.

 do not look for a rate that is outside of our range */

	/*

	 * The audio_pll rate can be modified, unlike the five others clocks

	 * that should never be altered.

	 * The audio_pll can technically be used by multiple consumers. However,

	 * with the rate locking, the first consumer to enable to clock will be

	 * the one definitely setting the rate of the clock.

	 * Since audio IPs are most likely to request the same rate, we enforce

	 * that the only clks able to modify gck rate are those of audio IPs.

 No modification of hardware as we have the flag CLK_SET_PARENT_GATE set */

 No modification of hardware as we have the flag CLK_SET_RATE_GATE set */

/**

 * clk_generated_startup - Initialize a given clock to its default parent and

 * divisor parameter.

 *

 * @gck:	Generated clock to set the startup parameters for.

 *

 * Take parameters from the hardware and update local clock configuration

 * accordingly.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright (C) 2013 Boris BREZILLON <b.brezillon@overkiz.com>

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright (C) 2013 Boris BREZILLON <b.brezillon@overkiz.com>

 MCK div reference to be used by notifier. */

 This function must be called with lock acquired. */

		/*

		 * We want to avoid any overclocking of MCK DIV domain. To do

		 * this we set a safe divider (the underclocking is not of

		 * interest as we can go as low as 32KHz). The relation

		 * b/w this clock and its parents are as follows:

		 *

		 * FRAC PLL -> DIV PLL -> MCK DIV

		 *

		 * With the proper safe divider we should be good even with FRAC

		 * PLL at its maximum value.

 Switch to safe divider. */

		/*

		 * At this point we want to restore MCK DIV domain to its maximum

		 * allowed rate.

 Update the div to preserve MCK DIV clock rate. */

 First: check the dividers of MCR. */

 Second: try to request rate form changeable parent. */

 Wait here only if parent is being changed. */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright (C) 2016 Atmel Corporation,

 *		       Songjun Wu <songjun.wu@atmel.com>,

 *                     Nicolas Ferre <nicolas.ferre@atmel.com>

 *  Copyright (C) 2017 Free Electrons,

 *		       Quentin Schulz <quentin.schulz@free-electrons.com>

 *

 * The Sama5d2 SoC has two audio PLLs (PMC and PAD) that shares the same parent

 * (FRAC). FRAC can output between 620 and 700MHz and only multiply the rate of

 * its own parent. PMC and PAD can then divide the FRAC rate to best match the

 * asked rate.

 *

 * Traits of FRAC clock:

 * enable - clk_enable writes nd, fracr parameters and enables PLL

 * rate - rate is adjustable.

 *        clk->rate = parent->rate * ((nd + 1) + (fracr / 2^22))

 * parent - fixed parent.  No clk_set_parent support

 *

 * Traits of PMC clock:

 * enable - clk_enable writes qdpmc, and enables PMC output

 * rate - rate is adjustable.

 *        clk->rate = parent->rate / (qdpmc + 1)

 * parent - fixed parent.  No clk_set_parent support

 *

 * Traits of PAD clock:

 * enable - clk_enable writes divisors and enables PAD output

 * rate - rate is adjustable.

 *        clk->rate = parent->rate / (qdaudio * div))

 * parent - fixed parent.  No clk_set_parent support

	/*

	 * reset and enable have to be done in 2 separated writes

	 * for AT91_PMC_AUDIO_PLL0

 do it in 2 separated writes */

 we can cast here as we verified the bounds just above */

	/*

	 * Rate divisor is actually made of two different divisors, multiplied

	 * between themselves before dividing the rate.

	 * tmp_qd goes from 1 to 31 and div is either 2 or 3.

	 * In order to avoid testing twice the rate divisor (e.g. divisor 12 can

	 * be found with (tmp_qd, div) = (2, 6) or (3, 4)), we remove any loop

	 * for a rate divisor when div is 2 and tmp_qd is a multiple of 3.

	 * We cannot inverse it (condition div is 3 and tmp_qd is even) or we

	 * would miss some rate divisor that aren't reachable with div being 2

	 * (e.g. rate divisor 90 is made with div = 3 and tmp_qd = 30, thus

	 * tmp_qd is even so we skip it because we think div 2 could make this

	 * rate divisor which isn't possible since tmp_qd has to be <= 31).

 got exact match */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * drivers/clk/at91/sckc.c

 *

 *  Copyright (C) 2013 Boris BREZILLON <b.brezillon@overkiz.com>

 DT backward compatibility */

 DT backward compatibility */

 MD_SLCK and TD_SLCK. */

	/*

	 * Assume that if it has already been selected (for example by the

	 * bootloader), enough time has aready passed.

 SPDX-License-Identifier: GPL-2.0

/*

 * While the TCB can be used as the clocksource, the system timer is most likely

 * to be used instead. However, the pinctrl driver doesn't support probe

 * deferring properly. Once this is fixed, this can be switched to a platform

 * driver.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright (C) 2013 Boris BREZILLON <b.brezillon@overkiz.com>

/*

 * The purpose of this clock is to generate a 480 MHz signal. A different

 * rate can't be configured.

	/*

	 * If mainck rate is different from 12 MHz, we have to configure the

	 * FREQ field of the SFR_UTMICKTRIM register to generate properly

	 * the utmi clock.

	/*

	 * Not supported on SAMA5D2 but it's not an issue since MAINCK

	 * maximum value is 24 MHz.

 UTMI clk rate is fixed. */

 SPDX-License-Identifier: GPL-2.0

/*

 *  Copyright (C) 2018 Microchip Technology Inc,

 *                     Codrin Ciubotariu <codrin.ciubotariu@microchip.com>

 *

 *

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright (C) 2013 Boris BREZILLON <b.brezillon@overkiz.com>

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * drivers/clk/at91/clk-slow.c

 *

 *  Copyright (C) 2013 Boris BREZILLON <b.brezillon@overkiz.com>

/*

 * Copyright (C) 2012 ST Microelectronics

 * Viresh Kumar <vireshk@kernel.org>

 *

 * This file is licensed under the terms of the GNU General Public

 * License version 2. This program is licensed "as is" without any

 * warranty of any kind, whether express or implied.

 *

 * Fractional Synthesizer clock implementation

/*

 * DOC: Fractional Synthesizer clock

 *

 * Fout from synthesizer can be given from below equation:

 *

 * Fout= Fin/2*div (division factor)

 * div is 17 bits:-

 *	0-13 (fractional part)

 *	14-16 (integer part)

 *	div is (16-14 bits).(13-0 bits) (in binary)

 *

 *	Fout = Fin/(2 * div)

 *	Fout = ((Fin / 10000)/(2 * div)) * 10000

 *	Fout = (2^14 * (Fin / 10000)/(2^14 * (2 * div))) * 10000

 *	Fout = (((Fin / 10000) << 14)/(2 * (div << 14))) * 10000

 *

 * div << 14 simply 17 bit value written at register.

 * Max error due to scaling down by 10000 is 10 KHz

 Configures new clock rate of frac */

 struct clk_frac assignments */

/*

 * Copyright (C) 2012 ST Microelectronics

 * Viresh Kumar <vireshk@kernel.org>

 *

 * This file is licensed under the terms of the GNU General Public

 * License version 2. This program is licensed "as is" without any

 * warranty of any kind, whether express or implied.

 *

 * SPEAr clk - Common routines

 previous clock was best */

/*

 * SPEAr6xx machines clock framework source file

 *

 * Copyright (C) 2012 ST Microelectronics

 * Viresh Kumar <vireshk@kernel.org>

 *

 * This file is licensed under the terms of the GNU General Public

 * License version 2. This program is licensed "as is" without any

 * warranty of any kind, whether express or implied.

 PLL_CLK_CFG register masks */

 CORE CLK CFG register masks */

 PERIP_CLK_CFG register masks */

 PERIP1_CLK_ENB register masks */

 vco rate configuration table, in ascending order of rates */

 vco 332 & pll 166 MHz */

 vco 532 & pll 266 MHz */

 vco 664 & pll 332 MHz */

 aux rate configuration table, in ascending order of rates */

 For PLL1 = 332 MHz */

 12.296 MHz */

 41.5 MHz */

 83 MHz */

 166 MHz */

 gpt rate configuration table, in ascending order of rates */

 For pll1 = 332 MHz */

 41.5 MHz */

 55.3 MHz */

 83 MHz */

 clock derived from 32 KHz osc clk */

 clock derived from 30 MHz osc clk */

 clock derived from pll1 clk */

 gpt clocks */

 clock derived from pll3 clk */

 clock derived from ahb clk */

 clock derived from apb clk */

/*

 * arch/arm/mach-spear13xx/spear1340_clock.c

 *

 * SPEAr1340 machine clock framework source file

 *

 * Copyright (C) 2012 ST Microelectronics

 * Viresh Kumar <vireshk@kernel.org>

 *

 * This file is licensed under the terms of the GNU General Public

 * License version 2. This program is licensed "as is" without any

 * warranty of any kind, whether express or implied.

 Clock Configuration Registers */

 PLL related registers and bit values */

 PLL_CFG bit values */

 PERIP_CLK_CFG bit values */

 I2S_CLK_CFG register mask */

 pll rate configuration table, in ascending order of rates */

 PCLK 24MHz */

 vco 1572, pll 49.125 MHz */

 vco 1000, pll 125 MHz */

 vco 800, pll 400 MHz */

 vco 1000, pll 500 MHz */

 vco 1328, pll 664 MHz */

 vco 1600, pll 800 MHz */

 vco 1, pll 1 GHz */

 vco 1200, pll 1200 MHz */

 vco-pll4 rate configuration table, in ascending order of rates */

 vco 1000, pll 250 MHz */

 vco 1328, pll 332 MHz */

 vco 1600, pll 400 MHz */

 vco 1, pll 1 GHz */

/*

 * All below entries generate 166 MHz for

 * different values of vco1div2

 for vco1div2 = 600 MHz */

 for vco1div2 = 500 MHz */

 for vco1div2 = 400 MHz */

 for vco1div2 = 332 MHz */

 for vco1div2 = 250 MHz */

 for vco1div2 = 200 MHz */

/*

 * Synthesizer Clock derived from vcodiv2. This clock is one of the

 * possible clocks to feed cpu directly.

 * We can program this synthesizer to make cpu run on different clock

 * frequencies.

 * Following table provides configuration values to let cpu run on 200,

 * 250, 332, 400 or 500 MHz considering different possibilites of input

 * (vco1div2) clock.

 *

 * --------------------------------------------------------------------

 * vco1div2(Mhz)	fout(Mhz)	cpuclk = fout/2		div

 * --------------------------------------------------------------------

 * 400			200		100			0x04000

 * 400			250		125			0x03333

 * 400			332		166			0x0268D

 * 400			400		200			0x02000

 * --------------------------------------------------------------------

 * 500			200		100			0x05000

 * 500			250		125			0x04000

 * 500			332		166			0x03031

 * 500			400		200			0x02800

 * 500			500		250			0x02000

 * --------------------------------------------------------------------

 * 600			200		100			0x06000

 * 600			250		125			0x04CCE

 * 600			332		166			0x039D5

 * 600			400		200			0x03000

 * 600			500		250			0x02666

 * --------------------------------------------------------------------

 * 664			200		100			0x06a38

 * 664			250		125			0x054FD

 * 664			332		166			0x04000

 * 664			400		200			0x0351E

 * 664			500		250			0x02A7E

 * --------------------------------------------------------------------

 * 800			200		100			0x08000

 * 800			250		125			0x06666

 * 800			332		166			0x04D18

 * 800			400		200			0x04000

 * 800			500		250			0x03333

 * --------------------------------------------------------------------

 * sys rate configuration table is in descending order of divisor.

 aux rate configuration table, in ascending order of rates */

 12.29MHz for vic1div2=600MHz and 10.24MHz for VCO1div2=500MHz */

 14.70MHz for vic1div2=600MHz and 12.29MHz for VCO1div2=500MHz */

 48MHz for vic1div2=600MHz and 40 MHz for VCO1div2=500MHz */

 57.14MHz for vic1div2=600MHz and 48 MHz for VCO1div2=500MHz */

 83.33MHz for vic1div2=600MHz and 69.44MHz for VCO1div2=500MHz */

 100MHz for vic1div2=600MHz and 83.33 MHz for VCO1div2=500MHz */

 125MHz for vic1div2=600MHz and 104.1MHz for VCO1div2=500MHz */

 150MHz for vic1div2=600MHz and 125MHz for VCO1div2=500MHz */

 166MHz for vic1div2=600MHz and 138.88MHz for VCO1div2=500MHz */

 200MHz for vic1div2=600MHz and 166MHz for VCO1div2=500MHz */

 250MHz for vic1div2=600MHz and 208.33MHz for VCO1div2=500MHz */

 300MHz for vic1div2=600MHz and 250MHz for VCO1div2=500MHz */

 gmac rate configuration table, in ascending order of rates */

 For gmac phy input clk */

 divided by 6 */

 divided by 4 */

 divided by 3 */

 divided by 2 */

 clcd rate configuration table, in ascending order of rates */

 25 Mhz , for vc01div4 = 300 MHz*/

 27 Mhz , for vc01div4 = 300 MHz*/

 25 Mhz , for vc01div4 = 250 MHz*/

 27 Mhz , for vc01div4 = 250 MHz*/

 58 Mhz , for vco1div4 = 393 MHz */

 58 Mhz , for vco1div4 = 332 MHz */

 58 Mhz , for vco1div4 = 300 MHz */

 65 Mhz , for vc01div4 = 300 MHz*/

 58 Mhz , for vc01div4 = 250 MHz*/

 74 Mhz , for vc01div4 = 300 MHz*/

 65 Mhz , for vc01div4 = 250 MHz*/

 72 Mhz , for vc01div4 = 250 MHz*/

 58 Mhz , for vco1div4 = 200 MHz */

 74 Mhz , for vc01div4 = 250 MHz*/

 108 Mhz , for vc01div4 = 300 MHz*/

 108 Mhz , for vc01div4 = 250 MHz*/

 148.5 Mhz , for vc01div4 = 300 MHz*/

 144 Mhz , for vc01div4 = 250 MHz*/

 148 Mhz , for vc01div4 = 250 MHz*/

 148.5 MHz, for vc01div4 = 250 MHz*/

 i2s prescaler1 masks */

 i2s sclk (bit clock) syynthesizers masks */

 i2s prs1 aux rate configuration table, in ascending order of rates */

 For parent clk = 49.152 MHz */

 2.048 MHz, smp freq = 8Khz */

 2.816 MHz, smp freq = 11Khz */

 4.096 MHz, smp freq = 16Khz */

 5.632 MHz, smp freq = 22Khz */

	/*

	 * with parent clk = 49.152, freq gen is 8.192 MHz, smp freq = 32Khz

	 * with parent clk = 12.288, freq gen is 2.048 MHz, smp freq = 8Khz

 For parent clk = 49.152 MHz */

 11.289 MHz, smp freq = 44Khz*/

 12.288 MHz, smp freq = 48Khz*/

 i2s sclk aux rate configuration table, in ascending order of rates */

 For sclk = ref_clk * x/2/y */

 adc rate configuration table, in ascending order of rates */

 possible adc range is 2.5 MHz to 20 MHz. */

 For ahb = 166.67 MHz */

 2.68 MHz */

 7.94 MHz */

 15.87 MHz */

 19.84 MHz */

 General synth rate configuration table, in ascending order of rates */

 22.5792 MHz for vco1div4=300 MHz*/

 24.576 MHz for vco1div4=300 MHz*/

 25 MHz for vco1div4=300 MHz*/

 22.5792 MHz for vco1div4=250 MHz*/

 24.576 MHz for vco1div4=250 MHz*/

 25 MHz for vco1div4=250 MHz*/

 45.1584 MHz for vco1div4=300 MHz*/

 50 MHz for vco1div4=300 MHz*/

 45.1584 MHz for vco1div4=250 MHz*/

 50 MHz for vco1div4=250 MHz*/

 81.92 MHz for vco1div4=300 MHz*/

 81.92 MHz for vco1div4=250 MHz*/

 100 MHz for vco1div4=300 MHz*/

 100 MHz for vco1div4=250 MHz*/

 200 MHz for vco1div4=300 MHz*/

 210 MHz for vco1div4=300 MHz*/

 220 MHz for vco1div4=300 MHz*/

 230 MHz for vco1div4=300 MHz*/

 200 MHz for vco1div4=250 MHz*/

 250 MHz for vco1div4=300 MHz*/

 210 MHz for vco1div4=250 MHz*/

 220 MHz for vco1div4=250 MHz*/

 230 MHz for vco1div4=250 MHz*/

 240 MHz for vco1div4=250 MHz*/

 250 MHz for vco1div4=250 MHz*/

 clock parents */

 clock derived from 32 KHz osc clk */

 clock derived from 24 or 25 MHz osc clk */

 vco-pll */

 vco div n clocks */

 peripherals */

 clock derived from pll4 clk */

 clock derived from pll1 clk */

 gpt clocks */

 others */

 gmac */

 clcd */

 i2s */

 clock derived from ahb clk */

 clock derived from apb clk */

 RAS clks */

/*

 * SPEAr3xx machines clock framework source file

 *

 * Copyright (C) 2012 ST Microelectronics

 * Viresh Kumar <vireshk@kernel.org>

 *

 * This file is licensed under the terms of the GNU General Public

 * License version 2. This program is licensed "as is" without any

 * warranty of any kind, whether express or implied.

 PLL_CLK_CFG register masks */

 CORE CLK CFG register masks */

 PERIP_CLK_CFG register masks */

 PERIP1_CLK_ENB register masks */

 pll rate configuration table, in ascending order of rates */

 vco 332 & pll 166 MHz */

 vco 532 & pll 266 MHz */

 vco 664 & pll 332 MHz */

 aux rate configuration table, in ascending order of rates */

 For PLL1 = 332 MHz */

 2.049 MHz */

 2.822 MHz */

 4.098 MHz */

 5.644 MHz */

 8.197 MHz */

 11.254 MHz */

 12.296 MHz */

 41.5 MHz */

 83 MHz */

 166 MHz */

 gpt rate configuration table, in ascending order of rates */

 For pll1 = 332 MHz */

 41.5 MHz */

 55.3 MHz */

 83 MHz */

 clock parents */

 array of all spear 310 clock lookups */

 array of all spear 320 clock lookups */

 Enforce ras_apb_clk */

 Enforce ras_apb_clk */

 clock derived from 32 KHz osc clk */

 clock derived from 24 MHz osc clk */

 clock derived from pll1 clk */

 gpt clocks */

 general synths clocks */

 clock derived from pll3 clk */

 clock derived from ahb clk */

 clock derived from apb clk */

 RAS clk enable */

/*

 * arch/arm/mach-spear13xx/spear1310_clock.c

 *

 * SPEAr1310 machine clock framework source file

 *

 * Copyright (C) 2012 ST Microelectronics

 * Viresh Kumar <vireshk@kernel.org>

 *

 * This file is licensed under the terms of the GNU General Public

 * License version 2. This program is licensed "as is" without any

 * warranty of any kind, whether express or implied.

 PLL related registers and bit values */

 PLL_CFG bit values */

 PERIP_CLK_CFG bit values */

 I2S_CLK_CFG register mask */

 Check Fractional synthesizer reg masks */

 PERIP1_CLK_ENB register masks */

 PERIP2_CLK_ENB register masks */

 RAS_CLK_ENB register masks */

 RAS Area Control Register */

 pll rate configuration table, in ascending order of rates */

 PCLK 24MHz */

 vco 1572, pll 49.125 MHz */

 vco 1000, pll 125 MHz */

 vco 800, pll 400 MHz */

 vco 1000, pll 500 MHz */

 vco 1328, pll 664 MHz */

 vco 1600, pll 800 MHz */

 vco 1, pll 1 GHz */

 vco-pll4 rate configuration table, in ascending order of rates */

 vco 1000, pll 250 MHz */

 vco 1328, pll 332 MHz */

 vco 1600, pll 400 MHz */

 vco 1, pll 1 GHz */

 aux rate configuration table, in ascending order of rates */

 For VCO1div2 = 500 MHz */

 12.29 MHz */

 48 MHz */

 83 MHz */

 125 MHz */

 166 MHz */

 250 MHz */

 gmac rate configuration table, in ascending order of rates */

 For gmac phy input clk */

 divided by 6 */

 divided by 4 */

 divided by 3 */

 divided by 2 */

 clcd rate configuration table, in ascending order of rates */

 25 Mhz , for vc01div4 = 250 MHz*/

 27 Mhz , for vc01div4 = 250 MHz*/

 58 Mhz , for vco1div4 = 393 MHz */

 58 Mhz , for vco1div4 = 332 MHz */

 58 Mhz , for vc01div4 = 250 MHz*/

 72 Mhz , for vc01div4 = 250 MHz*/

 58 Mhz , for vco1div4 = 200 MHz */

 74 Mhz , for vc01div4 = 250 MHz*/

 108 Mhz , for vc01div4 = 250 MHz*/

 144 Mhz , for vc01div4 = 250 MHz*/

 i2s prescaler1 masks */

 i2s sclk (bit clock) syynthesizers masks */

 i2s prs1 aux rate configuration table, in ascending order of rates */

 For parent clk = 49.152 MHz */

 2.048 MHz, smp freq = 8Khz */

 2.816 MHz, smp freq = 11Khz */

 4.096 MHz, smp freq = 16Khz */

 5.632 MHz, smp freq = 22Khz */

	/*

	 * with parent clk = 49.152, freq gen is 8.192 MHz, smp freq = 32Khz

	 * with parent clk = 12.288, freq gen is 2.048 MHz, smp freq = 8Khz

 For parent clk = 49.152 MHz */

 11.289 MHz, smp freq = 44Khz*/

 12.288 MHz */

 i2s sclk aux rate configuration table, in ascending order of rates */

 For i2s_ref_clk = 12.288MHz */

 1.53 MHz */

 3.07 Mhz */

 adc rate configuration table, in ascending order of rates */

 possible adc range is 2.5 MHz to 20 MHz. */

 For ahb = 166.67 MHz */

 2.68 MHz */

 7.94 MHz */

 15.87 MHz */

 19.84 MHz */

 General synth rate configuration table, in ascending order of rates */

 For vco1div4 = 250 MHz */

 25 MHz */

 50 MHz */

 100 MHz */

 250 MHz */

 clock parents */

 clock derived from 32 KHz osc clk */

 clock derived from 24 or 25 MHz osc clk */

 vco-pll */

 vco div n clocks */

 peripherals */

 clock derived from pll4 clk */

 clock derived from pll1 clk */

 gpt clocks */

 others */

 gmac */

 clcd */

 i2s */

 clock derived from ahb clk */

 clock derived from apb clk */

 RAS clks */

/*

 * Copyright (C) 2012 ST Microelectronics

 * Viresh Kumar <vireshk@kernel.org>

 *

 * This file is licensed under the terms of the GNU General Public

 * License version 2. This program is licensed "as is" without any

 * warranty of any kind, whether express or implied.

 *

 * VCO-PLL clock implementation

/*

 * DOC: VCO-PLL clock

 *

 * VCO and PLL rate are derived from following equations:

 *

 * In normal mode

 * vco = (2 * M[15:8] * Fin)/N

 *

 * In Dithered mode

 * vco = (2 * M[15:0] * Fin)/(256 * N)

 *

 * pll_rate = pll/2^p

 *

 * vco and pll are very closely bound to each other, "vco needs to program:

 * mode, m & n" and "pll needs to program p", both share common enable/disable

 * logic.

 *

 * clk_register_vco_pll() registers instances of both vco & pll.

 * CLK_SET_RATE_PARENT flag is forced for pll, as it will always pass its

 * set_rate to vco. A single rate table exists for both the clocks, which

 * configures m, n and p.

 PLL_CTR register masks */

 PLL FRQ register masks */

 Calculates pll clk rate for specific value of mode, m, n and p */

 previous clock was best */

 calculate numerator & denominator */

 Normal mode */

 Dithered mode */

 Configures new clock rate of vco */

 struct clk_vco assignments */

/*

 * Copyright (C) 2012 ST Microelectronics

 * Viresh Kumar <vireshk@kernel.org>

 *

 * This file is licensed under the terms of the GNU General Public

 * License version 2. This program is licensed "as is" without any

 * warranty of any kind, whether express or implied.

 *

 * Auxiliary Synthesizer clock implementation

/*

 * DOC: Auxiliary Synthesizer clock

 *

 * Aux synth gives rate for different values of eq, x and y

 *

 * Fout from synthesizer can be given from two equations:

 * Fout1 = (Fin * X/Y)/2		EQ1

 * Fout2 = Fin * X/Y			EQ2

 calculate numerator */

 calculate denominator */

 Configures new clock rate of aux */

 struct clk_aux assignments */

/*

 * Copyright (C) 2012 ST Microelectronics

 * Viresh Kumar <vireshk@kernel.org>

 *

 * This file is licensed under the terms of the GNU General Public

 * License version 2. This program is licensed "as is" without any

 * warranty of any kind, whether express or implied.

 *

 * General Purpose Timer Synthesizer clock implementation

/*

 * DOC: General Purpose Timer Synthesizer clock

 *

 * Calculates gpt synth clk rate for different values of mscale and nscale

 *

 * Fout= Fin/((2 ^ (N+1)) * (M+1))

 Configures new clock rate of gpt */

 struct clk_gpt assignments */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *

 * Copyright (C) 2012 ARM Limited

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Clock driver for the ARM Integrator/AP, Integrator/CP, Versatile AB and

 * Versatile PB boards.

 * Copyright (C) 2012 Linus Walleij

 Base offset for the core module */

 Remap the core module base if not done yet */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Driver for the ICST307 VCO clock found in the ARM Reference designs.

 * We wrap the custom interface from <asm/hardware/icst.h> into the generic

 * clock framework.

 *

 * Copyright (C) 2012-2015 Linus Walleij

 *

 * TODO: when all ARM reference designs are migrated to generic clocks, the

 * ICST clock code from the ARM tree should probably be merged into this

 * file.

 Magic unlocking token used on all Versatile boards */

/**

 * struct clk_icst - ICST VCO clock wrapper

 * @hw: corresponding clock hardware entry

 * @map: register map

 * @vcoreg_off: VCO register address

 * @lockreg_off: VCO lock register address

 * @params: parameters for this ICST instance

 * @rate: current rate

 * @ctype: the type of control register for the ICST

/**

 * vco_get() - get ICST VCO settings from a certain ICST

 * @icst: the ICST clock to get

 * @vco: the VCO struct to return the value in

	/*

	 * The Integrator/AP core clock can only access the low eight

	 * bits of the v PLL divider. Bit 8 is tied low and always zero,

	 * r is hardwired to 22 and output divider s is hardwired to 1

	 * (divide by 2) according to the document

	 * "Integrator CM926EJ-S, CM946E-S, CM966E-S, CM1026EJ-S and

	 * CM1136JF-S User Guide" ARM DUI 0138E, page 3-13 thru 3-14.

	/*

	 * The Integrator/AP system clock on the base board can only

	 * access the low eight bits of the v PLL divider. Bit 8 is tied low

	 * and always zero, r is hardwired to 46, and the output divider is

	 * hardwired to 3 (divide by 4) according to the document

	 * "Integrator AP ASIC Development Motherboard" ARM DUI 0098B,

	 * page 3-16.

	/*

	 * The Integrator/AP PCI clock is using an odd pattern to create

	 * the child clock, basically a single bit called DIVX/Y is used

	 * to select between two different hardwired values: setting the

	 * bit to 0 yields v = 17, r = 22 and OD = 1, whereas setting the

	 * bit to 1 yields v = 14, r = 14 and OD = 1 giving the frequencies

	 * 33 or 25 MHz respectively.

	/*

	 * The Integrator/CP core clock can access the low eight bits

	 * of the v PLL divider. Bit 8 is tied low and always zero,

	 * r is hardwired to 22 and the output divider s is accessible

	 * in bits 8 thru 10 according to the document

	 * "Integrator/CM940T, CM920T, CM740T, and CM720T User Guide"

	 * ARM DUI 0157A, page 3-20 thru 3-23 and 4-10.

/**

 * vco_set() - commit changes to an ICST VCO

 * @icst: the ICST clock to set

 * @vco: the VCO struct to set the changes from

 Mask the bits used by the VCO */

 Uses 12 bits */

 Uses 12 bits */

 Regular auxilary oscillator */

 This magic unlocks the VCO so it can be controlled */

 This locks the VCO again */

 Slam to closest megahertz */

 Slam to closest 0.5 megahertz */

 Divides between 3 and 50 MHz in steps of 0.25 MHz */

 Slam to closest 0.25 MHz */

		/*

		 * If we're below or less than halfway from 25 to 33 MHz

		 * select 25 MHz

 Else just return the default frequency */

 This clock is especially primitive */

 This locks the VCO again */

/*

 * In a device tree, an memory-mapped ICST clock appear as a child

 * of a syscon node. Assume this and probe it only as a child of a

 * syscon.

/*

 * The core modules on the Integrator/AP and Integrator/CP have

 * especially crippled ICST525 control.

 Minimum 12 MHz, VDW = 4 */

	/*

	 * Maximum 160 MHz, VDW = 152 for all core modules, but

	 * CM926EJ-S, CM1026EJ-S and CM1136JF-S can actually

	 * go to 200 MHz (max VDW = 192).

 r is hardcoded to 22 and this is the actual divisor, +2 */

 Minimum 3 MHz, VDW = 4 */

 Maximum 50 MHz, VDW = 192 */

 r is hardcoded to 46 and this is the actual divisor, +2 */

 Minimum 25 MHz */

 Maximum 33 MHz */

 r is hardcoded to 14 or 22 and this is the actual divisors +2 */

 We do not release this reference, we are using it perpetually */

 Parent clock name is not the same as node parent */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  linux/arch/arm/common/icst307.c

 *

 *  Copyright (C) 2003 Deep Blue Solutions, Ltd, All Rights Reserved.

 *

 *  Support functions for calculating clocks/divisors for the ICST307

 *  clock generators.  See https://www.idt.com/ for more information

 *  on these devices.

 *

 *  This is an almost identical implementation to the ICST525 clock generator.

 *  The s2div and idx2s files are different

/*

 * Divisors for each OD setting.

/*

 * Ascending divisor S values.

	/*

	 * First, find the PLL output divisor such

	 * that the PLL output is within spec.

	/*

	 * Now find the closest divisor combination

	 * which gives a PLL output of 'f'.

 SPDX-License-Identifier: GPL-2.0-only

/*

 *

 * Copyright (C) 2013 ARM Limited

		/*

		 * If DT isn't setting the parent, force it to be

		 * the 1 MHz clock without going through the framework.

		 * We do this before clk_register() so that it can determine

		 * the parent and setup the tree properly.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Clock driver for the ARM Integrator/IM-PD1 board

 * Copyright (C) 2012-2013 Linus Walleij

/*

 * There are two VCO's on the IM-PD1

 24 MHz */

 24 MHz */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * abx500 clock implementation for ux500 platform.

 *

 * Copyright (C) 2012 ST-Ericsson SA

 * Author: Ulf Hansson <ulf.hansson@linaro.org>

 Clock definitions for ab8500 */

 Enable SWAT */

 ab8500_sysclk2 */

 ab8500_sysclk3 */

 ab8500_sysclk4 */

 ab_ulpclk */

 ab8500_intclk */

 ab8500_audioclk */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * PRCMU clock implementation for ux500 platform.

 *

 * Copyright (C) 2012 ST-Ericsson SA

 * Author: Ulf Hansson <ulf.hansson@linaro.org>

 PRCMU clock operations. */

 "rate" can be used for changing the initial frequency */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Clock definitions for u8500 platform.

 *

 * Copyright (C) 2012 ST-Ericsson SA

 * Author: Ulf Hansson <ulf.hansson@linaro.org>

	/*

	 * We allocate the reset controller here so that we can fill in the

	 * base addresses properly and pass to the reset controller init

	 * function later on.

 Not much choice but to continue */

 Clock sources */

 FIXME: Add sys, ulp and int clocks here. */

 PRCMU clocks */

	/*

	 * FIXME: Add special handled PRCMU clocks here:

	 * 1. clkout0yuv, use PRCMU as parent + need regulator + pinctrl.

	 * 2. ab9540_clkout1yuv, see clkout0yuv

 PRCC P-clocks */

	/* PRCC K-clocks

	 *

	 * FIXME: Some drivers requires PERPIH[n| to be automatically enabled

	 * by enabling just the K-clock, even if it is not a valid parent to

	 * the K-clock. Until drivers get fixed we might need some kind of

	 * "parent muxed join".

 Periph1 */

 Periph2 */

 Note that rate is received from parent. */

 Periph3 */

 Periph6 */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Sysctrl clock implementation for ux500 platform.

 *

 * Copyright (C) 2013 ST-Ericsson SA

 * Author: Ulf Hansson <ulf.hansson@linaro.org>

 Sysctrl clock operations. */

 set main clock registers */

 handle clocks with more than one parent */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * PRCC clock implementation for ux500 platform.

 *

 * Copyright (C) 2012 ST-Ericsson SA

 * Author: Ulf Hansson <ulf.hansson@linaro.org>

 PRCC clock operations. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Reset controller portions for the U8500 PRCC

 * Copyright (C) 2021 Linus Walleij <linus.walleij@linaro.org>

 This macro flattens the 2-dimensional PRCC numberspace */

/*

 * Reset registers in each PRCC - the reset lines are active low

 * so what you need to do is write a bit for the peripheral you

 * want to put into reset into the CLEAR register, this will assert

 * the reset by pulling the line low. SET take the device out of

 * reset. The status reflects the actual state of the line.

	/*

	 * Assert reset and then release it. The one microsecond

	 * delay is found in the vendor reference code.

 Active low so return the inverse value of the bit */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2012, NVIDIA CORPORATION.  All rights reserved.

 Data in .init is copied by clk_register(), so stack variable OK */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2012, 2013, NVIDIA CORPORATION.  All rights reserved.

 PLLA_OUT0 */

 make sure the DMIC sync clocks have a valid parent */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2015, NVIDIA CORPORATION.  All rights reserved.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2012, NVIDIA CORPORATION.  All rights reserved.

 Global data of Tegra CPU CAR ops */

 Handlers for SoC-specific reset lines */

	/*

	 * If peripheral is on the APB bus then we must read the APB bus to

	 * flush the write operation in apb bus. This will avoid peripheral

	 * access after disabling clock. Since the reset driver has no

	 * knowledge of which reset IDs represent which devices, simply do

	 * this all the time.

	/*

	 * All non-boot peripherals will be in reset state on resume.

	 * Wait for 5us of reset propagation delay before de-asserting

	 * the peripherals based on the saved context.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Based on clk-super.c

 * Copyright (c) 2012, NVIDIA CORPORATION.  All rights reserved.

 *

 * Based on older tegra20-cpufreq driver by Colin Cross <ccross@google.com>

 * Copyright (C) 2010 Google, Inc.

 *

 * Author: Dmitry Osipenko <digetx@gmail.com>

 * Copyright (C) 2019 GRATE-DRIVER project

 check whether thermal throttling is active */

	/*

	 * Switch parent to PLLP for all CCLK rates that are suitable for PLLP.

	 * PLLX will be disabled in this case, saving some power.

	/*

	 * Tegra30+ has the following CPUG clock topology:

	 *

	 *        +---+  +-------+  +-+            +-+                +-+

	 * PLLP+->+   +->+DIVIDER+->+0|  +-------->+0|  ------------->+0|

	 *        |   |  +-------+  | |  |  +---+  | |  |             | |

	 * PLLC+->+MUX|             | +->+  | S |  | +->+             | +->+CPU

	 *  ...   |   |             | |  |  | K |  | |  |  +-------+  | |

	 * PLLX+->+-->+------------>+1|  +->+ I +->+1|  +->+ DIV2  +->+1|

	 *        +---+             +++     | P |  +++     |SKIPPER|  +++

	 *                           ^      | P |   ^      +-------+   ^

	 *                           |      | E |   |                  |

	 *                PLLX_SEL+--+      | R |   |       OVERHEAT+--+

	 *                                  +---+   |

	 *                                          |

	 *                         SUPER_CDIV_ENB+--+

	 *

	 * Tegra20 is similar, but simpler. It doesn't have the divider and

	 * thermal DIV2 skipper.

	 *

	 * At least for now we're not going to use clock-skipper, hence let's

	 * ensure that it is disabled.

	/*

	 * CPU needs to be temporarily re-parented away from PLLX if PLLX

	 * changes its rate. PLLP is a safe parent for CPU on all Tegra SoCs.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2012, 2013, NVIDIA CORPORATION.  All rights reserved.

 SOR1 mux'es */

 PLLP */

		/*

		 * Tegra210 has control on enabling/disabling PLLP branches to

		 * CPU, register a gate clock "pll_p_out_cpu" for this gating

		 * function and parent "pll_p_out4" to it, so when we are

		 * re-parenting CPU off from "pll_p_out4" the PLLP branching to

		 * CPU can be disabled automatically.

 PLLP_OUT_HSIO */

 PLLP_OUT_XUSB */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2015-2020, NVIDIA CORPORATION.  All rights reserved.

	/*

	 * CCF assumes that neither the parent nor its rate will change during

	 * ->set_rate(), so the parent rate passed in here was cached from the

	 * parent before the ->set_rate() call.

	 *

	 * This can lead to wrong results being reported for the EMC clock if

	 * the parent and/or parent rate have changed as part of the EMC rate

	 * change sequence. Fix this by overriding the parent clock with what

	 * we know to be the correct value after the rate change.

 XXX implement cache? */

 if the rate has changed... */

 ... but the clock source remains the same ... */

 ... switch to the alternative clock source. */

			/*

			 * This should never happen because we can't deal with

			 * it.

 set the new parent clock to the required rate */

 enable the new parent clock */

 update the EMC source configuration to reflect the new parent */

	/*

	 * Finally, switch the EMC programming with both old and new parent

	 * clocks enabled.

		/*

		 * If we're unable to switch to the new EMC frequency, we no

		 * longer need the new parent to be enabled.

 reparent to new parent clock and disable the old parent clock */

 do basic sanity checking on the EMC timings */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2012, NVIDIA CORPORATION.  All rights reserved.

 Tegra CPU clock and reset control regs */

 1 GHz */

 912 MHz */

 816 MHz */

 760 MHz */

 750 MHz */

 608 MHz */

 456 MHz */

 312 MHz */

 PLL parameters */

 PLLC */

 PLLC_OUT1 */

 PLLM */

 PLLM_OUT1 */

 PLLX */

 PLLU */

 PLLD */

 PLLD_OUT0 */

 PLLA */

 PLLA_OUT0 */

 PLLE */

 CCLK */

 SCLK */

 twd */

 audio */

 audio_2x */

 ac97 */

 emc */

 dsi */

 pex */

 dev1 OSC divider */

 dev2 OSC divider */

 cdev1 */

 cdev2 */

 clk_m */

 pll_ref */

 Tegra20 CPU clock and reset control functions */

 check CPU been reset or not */

 switch coresite to clk_m, save off original source */

 Is CPU complex already running on PLLX? */

 restore PLLX settings if CPU is on different PLL */

 wait for PLL stabilization if PLLX was enabled */

	/*

	 * Restore original burst policy setting for calls resulting from CPU

	 * LP2 in idle or system suspend.

 must be the last entry */

/*

 * Some clocks may be used by different drivers depending on the board

 * configuration.  List those here to register them twice in the clock lookup

 * table under two names.

 must be the last entry */

	/*

	 * Tegra20 CDEV1 and CDEV2 clocks are a bit special case, their parent

	 * clock is created by the pinctrl driver. It is possible for clk user

	 * to request these clocks before pinctrl driver got probed and hence

	 * user will get an orphaned clock. That might be undesirable because

	 * user may expect parent clock to be enabled by the child.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2012, NVIDIA CORPORATION.  All rights reserved.

 Data in .init is copied by clk_register(), so stack variable OK */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2012, NVIDIA CORPORATION.  All rights reserved.

 Data in .init is copied by clk_register(), so stack variable OK */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2016-2020 NVIDIA Corporation

	/*

	 * The mrq_clk_request structure has an anonymous union at offset 4

	 * that contains all possible sub-command structures. Copy the data

	 * to that union. Ideally we'd be able to refer to it by name, but

	 * doing so would require changing the ABI header and increase the

	 * maintenance burden.

 XXX check parent ID in response */

 clock not exposed by BPMP */

 hardware clock initialization */

 keep a private copy of the ID to parent index map */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * drivers/clk/tegra/clk-emc.c

 *

 * Copyright (c) 2014, NVIDIA CORPORATION.  All rights reserved.

 *

 * Author:

 *	Mikko Perttunen <mperttunen@nvidia.com>

/*

 * List of clock sources for various parents the EMC clock can have.

 * When we change the timing to a timing with a parent that has the same

 * clock source as the current parent, we must first change to a backup

 * timing that has a different clock source.

 Common clock framework callback implementations */

	/*

	 * CCF wrongly assumes that the parent won't change during set_rate,

	 * so get the parent rate explicitly.

/*

 * Rounds up unless no higher rate exists, in which case down. This way is

 * safer since things have EMC rate floors. Also don't touch parent_rate

 * since we don't want the CCF to play with our parent clocks.

/*

 * Get backup timing to use as an intermediate step when a change between

 * two timings with the same clock source has been requested. First try to

 * find a timing with a higher clock rate to avoid a rate below any set rate

 * floors. If that is not possible, find a lower rate.

	/*

	 * When emc_set_timing changes the parent rate, CCF will propagate

	 * that downward to us, so ignore any set_rate calls while a rate

	 * change is already going on.

		/*

		 * Parent clock source not changed but parent rate has changed,

		 * need to temporarily switch to another parent

 Initialization and deinitialization */

		/*

		 * Store timings for all ram codes as we cannot read the

		 * fuses until the apbmisc driver is loaded.

 Allow debugging tools to see the EMC clock */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2012-2020 NVIDIA CORPORATION.  All rights reserved.

/*

 * TEGRA210_CAR_BANK_COUNT: the number of peripheral clock register

 * banks present in the Tegra210 CAR IP block.  The banks are

 * identified by single letters, e.g.: L, H, U, V, W, X, Y.  See

 * periph_regs[] in drivers/clk/tegra/clk.c

 I2S registers to handle during APE MBIST WAR */

 DISPA registers to handle during MBIST WAR */

 VIC register to handle during MBIST WAR */

 APE, DISPA and VIC base addesses needed for MBIST WAR */

/*

 * SDM fractional divisor is 16-bit 2's complement signed number within

 * (-2^12 ... 2^12-1) range. Represented in PLL data structure as unsigned

 * 16-bit value, with "0" divisor mapped to 0xFFFF. Data "0" is used to

 * indicate that SDM is disabled.

 *

 * Effective ndiv value when SDM is enabled: ndiv + 1/2 + sdm_din/2^13

 This macro returns ndiv effective scaled to SDM range */

 Tegra CPU clock and reset control regs */

 possible OSC frequencies in Hz */

 PLLA */

 PLLD */

 PLLD2 and PLLDP  and PLLC4 */

 PLLRE */

 PLLE */

 PLLX */

 PLLMB */

 PLLP */

 PLLU */

 skip if PLLE is not enabled yet */

/*

 * PLLCX: PLLC, PLLC2, PLLC3, PLLA1

 * Hybrid PLLs with dynamic ramp. Dynamic ramp is allowed for any transition

 * that changes NDIV only, while PLL is already locked.

 PLL is ON: only check if defaults already set */

 Defaults assert PLL reset, and set IDDQ */

/*

 * PLLA

 * PLL with dynamic ramp and fractional SDM. Dynamic ramp is not used.

 * Fractional SDM is allowed to provide exact audio rates.

		/*

		 * PLL is ON: check if defaults already set, then set those

		 * that can be updated in flight.

 ignore lock enable */

 ignore all but control bit */

 Enable lock detect */

 set IDDQ, enable lock detect, disable dynamic ramp and SDM */

/*

 * PLLD

 * PLL with fractional SDM.

		/*

		 * PLL is ON: check if defaults already set, then set those

		 * that can be updated in flight.

 ignore lock, DSI and SDM controls, make sure IDDQ not set */

 Enable lock detect */

 set IDDQ, enable lock detect, disable SDM */

/*

 * PLLD2, PLLDP

 * PLL with fractional SDM and Spread Spectrum (SDM is a must if SSC is used).

		/*

		 * PLL is ON: check if defaults already set, then set those

		 * that can be updated in flight.

 ignore lock enable */

		/*

		 * If SSC is used, check all settings, otherwise just confirm

		 * that SSC is not used on boot as well. Do nothing when using

		 * this function for PLLC4 that has only MISC0.

 Enable lock detect */

 set IDDQ, enable lock detect, configure SDM/SSC  */

 When using this function for PLLC4 exit here */

 if SSC used set by 1st enable */

/*

 * PLLC4

 * Base and misc0 layout is the same as PLLD2/PLLDP, but no SDM/SSC support.

 * VCO is exposed to the clock tree via fixed 1/3 and 1/5 dividers.

/*

 * PLLRE

 * VCO is exposed to the clock tree directly along with post-divider output

		/*

		 * PLL is ON: check if defaults already set, then set those

		 * that can be updated in flight.

 Ignore lock enable */

 The PLL doesn't work if it's in IDDQ. */

 Enable lock detect */

 set IDDQ, enable lock detect */

 cf rate */

 ignore lock enable */

 ignore all but control bit */

 Get ready dyn ramp state machine settings */

		/*

		 * PLL is ON: check if defaults already set, then set those

		 * that can be updated in flight.

 Configure dyn ramp, disable lock override */

 Enable lock detect */

 Enable lock detect and CPU output */

 Setup */

 Configure dyn ramp state machine, disable lock override */

 Set IDDQ */

 Disable SDM */

 PLLMB */

		/*

		 * PLL is ON: check if defaults already set, then set those

		 * that can be updated in flight.

 Enable lock detect */

 set IDDQ, enable lock detect */

/*

 * PLLP

 * VCO is exposed to the clock tree directly along with post-divider output.

 * Both VCO and post-divider output rates are fixed at 408MHz and 204MHz,

 * respectively.

 Ignore lock enable (will be set), make sure not in IDDQ if enabled */

 Ignore branch controls */

		/*

		 * PLL is ON: check if defaults already set, then set those

		 * that can be updated in flight.

 Enable lock detect */

 set IDDQ, enable lock detect */

 Preserve branch control */

/*

 * PLLU

 * VCO is exposed to the clock tree directly along with post-divider output.

 * Both VCO and post-divider output rates are fixed at 480MHz and 240MHz,

 * respectively.

 Ignore lock enable (will be set) and IDDQ if under h/w control */

		/*

		 * PLL is ON: check if defaults already set, then set those

		 * that can be updated in flight.

 Enable lock detect */

 set IDDQ, enable lock detect */

 Lock detection safety delays */

/*

 * Common configuration for PLLs with fixed input divider policy:

 * - always set fixed M-value based on the reference rate

 * - always set P-value value 1:1 for output rates above VCO minimum, and

 *   choose minimum necessary P-value for output rates below VCO maximum

 * - calculate N-value based on selected M and P

 * - calculate SDM_DIN fractional part

 Store P as HW value, as that is what is expected */

 If ssc is enabled SDM enabled as well, even for integer n */

/*

 * clk_pll_set_gain - set gain to m, n to calculate correct VCO rate

 *

 * @cfg: struct tegra_clk_pll_freq_table * cfg

 *

 * For Normal mode:

 *     Fvco = Fref * NDIV / MDIV

 *

 * For fractional mode:

 *     Fvco = Fref * (NDIV + 0.5 + SDM_DIN / PLL_SDM_COEFF) / MDIV

/*

 * PLL post divider maps - two types: quasi-linear and exponential

 * post divider.

 1 GHz */

 actual: 996.0 MHz */

 actual: 994.0 MHz */

 actual: 998.4 MHz */

 actual: 507.0 MHz */

 actual: 505.6 MHz */

 actual: 598.0 MHz */

 actual: 595.2 MHz */

 actual: 792.0 MHz */

 actual: 793.0 MHz */

 PLLE special case: use cpcon field to store cml divider value */

 actual: 663.0 MHz */

 cf = 4.8MHz, allowed exception */

 actual: 282240234 */

 actual: 368640381 */

 actual: 282239807 */

 actual: 368640137 */

 actual: 238.3 MHz */

 actual: 282239844 */

 actual: 368639844 */

 actual: 594000183 */

 actual: 594000183 */

 s/w policy, always tegra_pll_ref */

 disable spread-spectrum for pll_d2 */

 actual: 269.8 MHz */

 actual: 468.0 MHz */

 Oscillator Frequency in KHz */

 UTMIP PLL Enable Delay Count  */

 UTMIP PLL Stable count */

  UTMIP PLL Active delay count */

 UTMIP PLL Xtal frequency count */

 Program UTMIP PLL stable and active counts */

 [FIXME] arclk_rst.h says WRONG! This should be 1ms -> 0x50 Check! */

 Program UTMIP PLL delay and oscillator frequency counts */

 Remove power downs from UTMIP PLL control bits */

 Enable samplers for SNPS, XUSB_HOST, XUSB_DEV */

 Setup HW control of UTMIPLL */

 Enable HW control UTMIPLL */

 clear IDDQ bit */

	/*

	 * During clocks resume, same PLLU init and enable sequence get

	 * executed. So, readx_poll_timeout_atomic can't be used here as it

	 * uses ktime_get() and timekeeping resume doesn't happen by that

	 * time. So, using tegra210_wait_for_mask for PLL LOCK.

 skip initialization when pllu is in hw controlled mode */

 enable hw controlled mode */

 enable UTMIPLL hw control if not yet done by the bootloader */

/*

 * The SOR hardware blocks are driven by two clocks: a module clock that is

 * used to access registers and a pixel clock that is sourced from the same

 * pixel clock that also drives the head attached to the SOR. The module

 * clock is typically called sorX (with X being the SOR instance) and the

 * pixel clock is called sorX_out. The source for the SOR pixel clock is

 * referred to as the "parent" clock.

 *

 * On Tegra186 and newer, clocks are provided by the BPMP. Unfortunately the

 * BPMP implementation for the SOR clocks doesn't exactly match the above in

 * some aspects. For example, the SOR module is really clocked by the pad or

 * sor_safe clocks, but BPMP models the sorX clock as being sourced by the

 * pixel clocks. Conversely the sorX_out clock is sourced by the sor_safe or

 * pad clocks on BPMP.

 *

 * In order to allow the display driver to deal with all SoC generations in

 * a unified way, implement the BPMP semantics in this driver.

	/*

	 * Bit 0 of the mux selects sor1_pad_clkout, irrespective of bit 1, so

	 * the sor1_pad_clkout parent appears twice in the list below. This is

	 * merely to support clk_get_parent() if firmware happened to set

	 * these bits to 0b11. While not an invalid setting, code should

	 * always set the bits to 0b01 to select sor1_pad_clkout.

	/*

	 * On Tegra210, the sor0 clock doesn't have a mux it bitfield 31:29,

	 * but it is hardwired to the pll_d_out0 clock.

 xusb_ss_div2 */

 pll_d_dsi_out */

 dsia */

 dsib */

 csi_tpg */

 la */

 cml0 */

 cml1 */

 emc */

 mc */

 PLLC */

 PLLC_OUT1 */

 PLLC_UD */

 PLLC2 */

 PLLC3 */

 PLLM */

 PLLMB */

 PLLM_UD */

 PLLMB_UD */

 PLLP_UD */

 PLLU_VCO */

 PLLU_OUT */

 PLLU_OUT1 */

 PLLU_OUT2 */

 PLLU_480M */

 PLLU_60M */

 PLLU_48M */

 PLLD */

 PLLD_OUT0 */

 PLLRE */

 PLLE */

 PLLC4 */

 PLLC4_OUT0 */

 PLLC4_OUT1 */

 PLLC4_OUT2 */

 PLLC4_OUT3 */

 PLLDP */

 PLLD2 */

 PLLD2_OUT0 */

 PLLP_OUT2 */

 Tegra210 CPU clock and reset control functions */

 check CPU been reset or not */

 flow controller would take care in the power sequence. */

	/*

	 * Save the bootloader configured clock registers SPARE_REG0,

	 * MISC_CLK_ENB, CLK_MASK_ARM, CPU_SOFTRST_CTRL.

	/*

	 * Restore the bootloader configured clock registers SPARE_REG0,

	 * MISC_CLK_ENB, CLK_MASK_ARM, CPU_SOFTRST_CTRL from saved context.

	/*

	 * Tegra clock programming sequence recommends peripheral clock to

	 * be enabled prior to changing its clock source and divider to

	 * prevent glitchless frequency switch.

	 * So, enable all peripheral clocks before restoring their source

	 * and dividers.

 wait for all writes to happen to have all the clocks enabled */

 restore PLLs and all peripheral clock rates */

 restore saved context of peripheral clocks and reset state */

 switch coresite to clk_m, save off original source */

 TODO find a way to enable this on-demand */

 This MUST be the last entry. */

/**

 * tegra210_clock_apply_init_table - initialize clocks on Tegra210 SoCs

 *

 * Program an initial clock rate and enable or disable clocks needed

 * by the rest of the kernel, for Tegra210 SoCs.  It is intended to be

 * called by assigning a pointer to it to tegra_clk_apply_init_table -

 * this will be called as an arch_initcall.  No return value.

/**

 * tegra210_car_barrier - wait for pending writes to the CAR to complete

 *

 * Wait for any outstanding writes to the CAR MMIO space from this CPU

 * to complete before continuing execution.  No return value.

/**

 * tegra210_clock_assert_dfll_dvco_reset - assert the DFLL's DVCO reset

 *

 * Assert the reset line of the DFLL's DVCO.  No return value.

/**

 * tegra210_clock_deassert_dfll_dvco_reset - deassert the DFLL's DVCO reset

 *

 * Deassert the reset line of the DFLL's DVCO, allowing the DVCO to

 * operate.  No return value.

		/*

		 * Considering adsp cpu clock (min: 12.5MHZ, max: 1GHz)

		 * a delay of 5us ensures that it's at least

		 * 6 * adsp_cpu_cycle_period long.

/**

 * tegra210_clock_init - Tegra210-specific clock initialization

 * @np: struct device_node * of the DT node for the SoC CAR IP block

 *

 * Register most SoC clocks for the Tegra210 system-on-chip.  Intended

 * to be called by the OF init code when a DT node with the

 * "nvidia,tegra210-car" string is encountered, and declared with

 * CLK_OF_DECLARE.  No return value.

 For Tegra210, PLLD is the only source for DSIA & DSIB */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2012, 2013, NVIDIA CORPORATION.  All rights reserved.

 override default prop dlys */

 rise->rise prop dly A */

 rise->rise prop dly inc A */

 RST_DFLL_DVCO bitfields */

 CPU_FINETRIM_SELECT and CPU_FINETRIM_DR bitfields */

 fcpu0 */

 fcpu1 */

 fcpu2 */

 fcpu3 */

 fl2 */

 ftop */

 CPU_FINETRIM_R bitfields */

 fcpu0 */

 fcpu1 */

 fcpu2 */

 fcpu3 */

 fl2 */

 ftop */

 PLLM override registers */

 Tegra CPU clock and reset control regs */

 actual: 598.0 MHz */

 actual: 596.4 MHz */

 actual: 595.2 MHz */

 actual: 598.0 MHz */

 s/w policy, h/w capability 50 MHz */

 actual: 598.0 MHz */

 actual: 596.4 MHz */

 actual: 595.2 MHz */

 actual: 598.0 MHz */

 actual: 792.0 MHz */

 actual: 793.0 MHz */

 actual: 789.6 MHz */

 actual: 787.2 MHz */

 actual: 793.0 MHz */

 s/w policy, h/w capability 50 MHz */

 1 GHz */

 actual: 996.0 MHz */

 actual: 988.0 MHz */

 actual: 991.2 MHz */

 actual: 998.4 MHz */

 actual: 988.0 MHz */

 s/w policy, h/w capability 50 MHz */

 PLLE special case: use cpcon field to store cml divider value */

 s/w policy, h/w capability 38 MHz */

 possible OSC frequencies in Hz */

 peripheral mux definitions */

 clk_32k */

 PLLC */

 PLLC_OUT1 */

 PLLC2 */

 PLLC3 */

 PLLM */

 PLLM_OUT1 */

 PLLM_UD */

 PLLU */

 PLLU_480M */

 PLLU_60M */

 PLLU_48M */

 PLLU_12M */

 PLLD */

 PLLD_OUT0 */

 PLLD2 */

 PLLD2_OUT0 */

 PLLRE */

 PLLE */

 xusb_ss_div2 */

 dsia mux */

 dsib mux */

 emc mux */

 Tegra114 CPU clock and reset control functions */

 check CPU been reset or not */

 flow controller would take care in the power sequence. */

 switch coresite to clk_m, save off original source */

/*

 * dfll_soc/dfll_ref apparently must be kept enabled, otherwise I2C5

 * breaks

 must be the last entry */

/**

 * tegra114_car_barrier - wait for pending writes to the CAR to complete

 *

 * Wait for any outstanding writes to the CAR MMIO space from this CPU

 * to complete before continuing execution.  No return value.

 probably unnecessary */

/**

 * tegra114_clock_tune_cpu_trimmers_high - use high-voltage propagation delays

 *

 * When the CPU rail voltage is in the high-voltage range, use the

 * built-in hardwired clock propagation delays in the CPU clock

 * shaper.  No return value.

 Use hardwired rise->rise & fall->fall clock propagation delays */

/**

 * tegra114_clock_tune_cpu_trimmers_low - use low-voltage propagation delays

 *

 * When the CPU rail voltage is in the low-voltage range, use the

 * extended clock propagation delays set by

 * tegra114_clock_tune_cpu_trimmers_init().  The intention is to

 * maintain the input clock duty cycle that the FCPU subsystem

 * expects.  No return value.

	/*

	 * Use software-specified rise->rise & fall->fall clock

	 * propagation delays (from

	 * tegra114_clock_tune_cpu_trimmers_init()

/**

 * tegra114_clock_tune_cpu_trimmers_init - set up and enable clk prop delays

 *

 * Program extended clock propagation delays into the FCPU clock

 * shaper and enable them.  XXX Define the purpose - peak current

 * reduction?  No return value.

 XXX Initial voltage rail state assumption issues? */

 Increment the rise->rise clock delay by four steps */

	/*

	 * Use the rise->rise clock propagation delay specified in the

	 * r field

/**

 * tegra114_clock_assert_dfll_dvco_reset - assert the DFLL's DVCO reset

 *

 * Assert the reset line of the DFLL's DVCO.  No return value.

/**

 * tegra114_clock_deassert_dfll_dvco_reset - deassert the DFLL's DVCO reset

 *

 * Deassert the reset line of the DFLL's DVCO, allowing the DVCO to

 * operate.  No return value.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2012, 2013, NVIDIA CORPORATION.  All rights reserved.

 timeout = 2 * lock time */

	/*

	 * Power Management Controller (PMC) can override the PLLM clock

	 * settings, including the enable-state. The PLLM is enabled when

	 * PLLM's CaR state is ON and when PLLM isn't gated by PMC.

		/*

		 * PLL_P_OUT1 rate is not listed in PLLA table

 Raise VCO to guarantee 0.5% accuracy */

/*

 * SDM (Sigma Delta Modulator) divisor is 16-bit 2's complement signed number

 * within (-2^12 ... 2^12-1) range. Represented in PLL data structure as

 * unsigned 16-bit value, with "0" divisor mapped to 0xFFFF. Data "0" is used

 * to indicate that SDM is disabled.

 *

 * Effective ndiv value when SDM is enabled: ndiv + 1/2 + sdm_din/2^13

 PLLM/MB are used for memory; we do not change rate */

	/*

	 * PLLE is already disabled, and setup cleared;

	 * create falling edge on PLLE IDDQ input.

 configure dividers */

/*

 * Structure defining the fields for USB UTMI clocks Parameters.

 Oscillator Frequency in Hz */

 UTMIP PLL Enable Delay Count  */

 UTMIP PLL Stable count */

  UTMIP PLL Active delay count */

 UTMIP PLL Xtal frequency count */

 Program UTMIP PLL stable and active counts */

 Remove power downs from UTMIP PLL control bits */

 Program UTMIP PLL delay and oscillator frequency counts */

 Remove power downs from UTMIP PLL control bits */

 Disable lock override */

 Enable HW control of XUSB brick PLL */

 Enable HW control of SATA PLL */

 Program UTMIP PLL stable and active counts */

 Remove power downs from UTMIP PLL control bits */

 Program UTMIP PLL delay and oscillator frequency counts */

 Remove power downs from UTMIP PLL control bits */

 Setup HW control of UTMIPLL */

	/*

	 * Setup SW override of UTMIPLL assuming USB2.0 ports are assigned

	 * to USB2

 Enable HW control of UTMIPLL */

 ensure parent is set to pll_ref */

 Default to _calc_rate if unspecified */

 Data in .init is copied by clk_register(), so stack variable OK */

	/*

	 * If the pll has a set_defaults callback, it will take care of

	 * configuring dynamic ramping and setting IDDQ in that path.

 program minimum rate by default */

 disable lock override */

	/*

	 * Most of PLLC register fields are shadowed, and can not be read

	 * directly from PLL h/w. Hence, actual PLLC boot state is unknown.

	 * Initialize PLL to default state: disabled, reset; shadow registers

	 * loaded with default parameters; dividers are preset for half of

	 * minimum VCO rate (the latter assured that shadowed divider settings

	 * are within supported range).

 initialize PLL to minimum rate */

 Disable lock override */

 If PLLE HW sequencer is enabled, SW should not disable PLLE */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * clk-dfll.c - Tegra DFLL clock source common code

 *

 * Copyright (C) 2012-2019 NVIDIA Corporation. All rights reserved.

 *

 * Aleksandr Frid <afrid@nvidia.com>

 * Paul Walmsley <pwalmsley@nvidia.com>

 *

 * This library is for the DVCO and DFLL IP blocks on the Tegra124

 * SoC. These IP blocks together are also known at NVIDIA as

 * "CL-DVFS". To try to avoid confusion, this code refers to them

 * collectively as the "DFLL."

 *

 * The DFLL is a root clocksource which tolerates some amount of

 * supply voltage noise. Tegra124 uses it to clock the fast CPU

 * complex when the target CPU speed is above a particular rate. The

 * DFLL can be operated in either open-loop mode or closed-loop mode.

 * In open-loop mode, the DFLL generates an output clock appropriate

 * to the supply voltage. In closed-loop mode, when configured with a

 * target frequency, the DFLL minimizes supply voltage while

 * delivering an average frequency equal to the target.

 *

 * Devices clocked by the DFLL must be able to tolerate frequency

 * variation. In the case of the CPU, it's important to note that the

 * CPU cycle time will vary. This has implications for

 * performance-measurement code and any code that relies on the CPU

 * cycle time to delay for a certain length of time.

/*

 * DFLL control registers - access via dfll_{readl,writel}

 DFLL_CTRL: DFLL control register */

 DFLL_CONFIG: DFLL sample rate control */

 DFLL_PARAMS: tuning coefficients for closed loop integrator */

 DFLL_TUNE0: delay line configuration register 0 */

 DFLL_TUNE1: delay line configuration register 1 */

 DFLL_FREQ_REQ: target DFLL frequency control */

 DFLL_DROOP_CTRL: droop prevention control */

 DFLL_OUTPUT_CFG: closed loop mode control registers */

 NOTE: access via dfll_i2c_{readl,writel} */

 DFLL_OUTPUT_FORCE: closed loop mode voltage forcing control */

 DFLL_MONITOR_CTRL: internal monitor data source control */

 DFLL_MONITOR_DATA: internal monitor data output */

/*

 * I2C output control registers - access via dfll_i2c_{readl,writel}

 DFLL_I2C_CFG: I2C controller configuration register */

 DFLL_I2C_VDD_REG_ADDR: PMIC I2C address for closed loop mode */

 DFLL_I2C_STS: I2C controller status */

 DFLL_INTR_STS: DFLL interrupt status register */

 DFLL_INTR_EN: DFLL interrupt enable register */

/*

 * Integrated I2C controller registers - relative to td->i2c_controller_base

 DFLL_I2C_CLK_DIVISOR: I2C controller clock divisor */

/*

 * Other constants

 MAX_DFLL_VOLTAGES: number of LUT entries in the DFLL IP block */

/*

 * REF_CLK_CYC_PER_DVCO_SAMPLE: the number of ref_clk cycles that the hardware

 *    integrates the DVCO counter over - used for debug rate monitoring and

 *    droop control

/*

 * REF_CLOCK_RATE: the DFLL reference clock rate currently supported by this

 * driver, in Hz

/**

 * enum dfll_ctrl_mode - DFLL hardware operating mode

 * @DFLL_UNINITIALIZED: (uninitialized state - not in hardware bitfield)

 * @DFLL_DISABLED: DFLL not generating an output clock

 * @DFLL_OPEN_LOOP: DVCO running, but DFLL not adjusting voltage

 * @DFLL_CLOSED_LOOP: DVCO running, and DFLL adjusting voltage to match

 *		      the requested rate

 *

 * The integer corresponding to the last two states, minus one, is

 * written to the DFLL hardware to change operating modes.

/**

 * enum dfll_tune_range - voltage range that the driver believes it's in

 * @DFLL_TUNE_UNINITIALIZED: DFLL tuning not yet programmed

 * @DFLL_TUNE_LOW: DFLL in the low-voltage range (or open-loop mode)

 *

 * Some DFLL tuning parameters may need to change depending on the

 * DVCO's voltage; these states represent the ranges that the driver

 * supports. These are software states; these values are never

 * written into registers.

/**

 * struct dfll_rate_req - target DFLL rate request data

 * @rate: target frequency, after the postscaling

 * @dvco_target_rate: target frequency, after the postscaling

 * @lut_index: LUT index at which voltage the dvco_target_rate will be reached

 * @mult_bits: value to program to the MULT bits of the DFLL_FREQ_REQ register

 * @scale_bits: value to program to the SCALE bits of the DFLL_FREQ_REQ register

 Parameters from DT */

 I2C interface parameters */

 lut array entries are regulator framework selectors or PWM values*/

 PWM interface */

 mode_name: map numeric DFLL modes to names for friendly console messages */

/*

 * Register accessors

 I2C output control registers - for addresses above DFLL_I2C_CFG */

/**

 * dfll_is_running - is the DFLL currently generating a clock?

 * @td: DFLL instance

 *

 * If the DFLL is currently generating an output clock signal, return

 * true; otherwise return false.

/*

 * Runtime PM suspend/resume callbacks

/**

 * tegra_dfll_runtime_resume - enable all clocks needed by the DFLL

 * @dev: DFLL device *

 *

 * Enable all clocks needed by the DFLL. Assumes that clk_prepare()

 * has already been called on all the clocks.

 *

 * XXX Should also handle context restore when returning from off.

/**

 * tegra_dfll_runtime_suspend - disable all clocks needed by the DFLL

 * @dev: DFLL device *

 *

 * Disable all clocks needed by the DFLL. Assumes that other code

 * will later call clk_unprepare().

/*

 * DFLL tuning operations (per-voltage-range tuning settings)

/**

 * dfll_tune_low - tune to DFLL and CPU settings valid for any voltage

 * @td: DFLL instance

 *

 * Tune the DFLL oscillator parameters and the CPU clock shaper for

 * the low-voltage range. These settings are valid for any voltage,

 * but may not be optimal.

/*

 * Output clock scaler helpers

/**

 * dfll_scale_dvco_rate - calculate scaled rate from the DVCO rate

 * @scale_bits: clock scaler value (bits in the DFLL_FREQ_REQ_SCALE field)

 * @dvco_rate: the DVCO rate

 *

 * Apply the same scaling formula that the DFLL hardware uses to scale

 * the DVCO rate.

/*

 * DFLL mode switching

/**

 * dfll_set_mode - change the DFLL control mode

 * @td: DFLL instance

 * @mode: DFLL control mode (see enum dfll_ctrl_mode)

 *

 * Change the DFLL's operating mode between disabled, open-loop mode,

 * and closed-loop mode, or vice versa.

/*

 * DVCO rate control

/*

 * DFLL-to-I2C controller interface

/**

 * dfll_i2c_set_output_enabled - enable/disable I2C PMIC voltage requests

 * @td: DFLL instance

 * @enable: whether to enable or disable the I2C voltage requests

 *

 * Set the master enable control for I2C control value updates. If disabled,

 * then I2C control messages are inhibited, regardless of the DFLL mode.

/*

 * DFLL-to-PWM controller interface

/**

 * dfll_pwm_set_output_enabled - enable/disable PWM voltage requests

 * @td: DFLL instance

 * @enable: whether to enable or disable the PWM voltage requests

 *

 * Set the master enable control for PWM control value updates. If disabled,

 * then the PWM signal is not driven. Also configure the PWM output pad

 * to the appropriate state.

/**

 * dfll_set_force_output_value - set fixed value for force output

 * @td: DFLL instance

 * @out_val: value to force output

 *

 * Set the fixed value for force output, DFLL will output this value when

 * force output is enabled.

/**

 * dfll_set_force_output_enabled - enable/disable force output

 * @td: DFLL instance

 * @enable: whether to enable or disable the force output

 *

 * Set the enable control for fouce output with fixed value.

/**

 * dfll_force_output - force output a fixed value

 * @td: DFLL instance

 * @out_sel: value to force output

 *

 * Set the fixed value for force output, DFLL will output this value.

/**

 * dfll_load_lut - load the voltage lookup table

 * @td: struct tegra_dfll *

 *

 * Load the voltage-to-PMIC register value lookup table into the DFLL

 * IP block memory. Look-up tables can be loaded at any time.

/**

 * dfll_init_i2c_if - set up the DFLL's DFLL-I2C interface

 * @td: DFLL instance

 *

 * During DFLL driver initialization, program the DFLL-I2C interface

 * with the PMU slave address, vdd register offset, and transfer mode.

 * This data is used by the DFLL to automatically construct I2C

 * voltage-set commands, which are then passed to the DFLL's internal

 * I2C controller.

 default hs divisor just in case */

/**

 * dfll_init_out_if - prepare DFLL-to-PMIC interface

 * @td: DFLL instance

 *

 * During DFLL driver initialization or resume from context loss,

 * disable the I2C command output to the PMIC, set safe voltage and

 * output limits, and disable and clear limit interrupts.

 clear DFLL_OUTPUT_CFG before setting new value */

 set initial voltage */

/*

 * Set/get the DFLL's targeted output clock rate

/**

 * find_lut_index_for_rate - determine I2C LUT index for given DFLL rate

 * @td: DFLL instance

 * @rate: clock rate

 *

 * Determines the index of a I2C LUT entry for a voltage that approximately

 * produces the given DFLL clock rate. This is used when forcing a value

 * to the integrator during rate changes. Returns -ENOENT if a suitable

 * LUT index is not found.

/**

 * dfll_calculate_rate_request - calculate DFLL parameters for a given rate

 * @td: DFLL instance

 * @req: DFLL-rate-request structure

 * @rate: the desired DFLL rate

 *

 * Populate the DFLL-rate-request record @req fields with the scale_bits

 * and mult_bits fields, based on the target input rate. Returns 0 upon

 * success, or -EINVAL if the requested rate in req->rate is too high

 * or low for the DFLL to generate.

	/*

	 * If requested rate is below the minimum DVCO rate, active the scaler.

	 * In the future the DVCO minimum voltage should be selected based on

	 * chip temperature and the actual minimum rate should be calibrated

	 * at runtime.

 Convert requested rate into frequency request and scale settings */

/**

 * dfll_set_frequency_request - start the frequency change operation

 * @td: DFLL instance

 * @req: rate request structure

 *

 * Tell the DFLL to try to change its output frequency to the

 * frequency represented by @req. DFLL must be in closed-loop mode.

 FIXME: td->cg_scale? */;

/**

 * tegra_dfll_request_rate - set the next rate for the DFLL to tune to

 * @td: DFLL instance

 * @rate: clock rate to target

 *

 * Convert the requested clock rate @rate into the DFLL control logic

 * settings. In closed-loop mode, update new settings immediately to

 * adjust DFLL output rate accordingly. Otherwise, just save them

 * until the next switch to closed loop. Returns 0 upon success,

 * -EPERM if the DFLL driver has not yet been initialized, or -EINVAL

 * if @rate is outside the DFLL's tunable range.

/*

 * DFLL enable/disable & open-loop <-> closed-loop transitions

/**

 * dfll_disable - switch from open-loop mode to disabled mode

 * @td: DFLL instance

 *

 * Switch from OPEN_LOOP state to DISABLED state. Returns 0 upon success

 * or -EPERM if the DFLL is not currently in open-loop mode.

/**

 * dfll_enable - switch a disabled DFLL to open-loop mode

 * @td: DFLL instance

 *

 * Switch from DISABLED state to OPEN_LOOP state. Returns 0 upon success

 * or -EPERM if the DFLL is not currently disabled.

/**

 * dfll_set_open_loop_config - prepare to switch to open-loop mode

 * @td: DFLL instance

 *

 * Prepare to switch the DFLL to open-loop mode. This switches the

 * DFLL to the low-voltage tuning range, ensures that I2C output

 * forcing is disabled, and disables the output clock rate scaler.

 * The DFLL's low-voltage tuning range parameters must be

 * characterized to keep the downstream device stable at any DVCO

 * input voltage. No return value.

 always tune low (safe) in open loop */

/**

 * tegra_dfll_lock - switch from open-loop to closed-loop mode

 * @td: DFLL instance

 *

 * Switch from OPEN_LOOP state to CLOSED_LOOP state. Returns 0 upon success,

 * -EINVAL if the DFLL's target rate hasn't been set yet, or -EPERM if the

 * DFLL is not currently in open-loop mode.

/**

 * tegra_dfll_unlock - switch from closed-loop to open-loop mode

 * @td: DFLL instance

 *

 * Switch from CLOSED_LOOP state to OPEN_LOOP state. Returns 0 upon success,

 * or -EPERM if the DFLL is not currently in open-loop mode.

/*

 * Clock framework integration

 *

 * When the DFLL is being controlled by the CCF, always enter closed loop

 * mode when the clk is enabled. This requires that a DFLL rate request

 * has been set beforehand, which implies that a clk_set_rate() call is

 * always required before a clk_enable().

 Must use determine_rate since it allows for rates exceeding 2^31-1 */

	/*

	 * Don't set the rounded rate, since it doesn't really matter as

	 * the output rate will be voltage controlled anyway, and cpufreq

	 * freaks out if any rounding happens.

/**

 * dfll_register_clk - register the DFLL output clock with the clock framework

 * @td: DFLL instance

 *

 * Register the DFLL's output clock with the Linux clock framework and register

 * the DFLL driver as an OF clock provider. Returns 0 upon success or -EINVAL

 * or -ENOMEM upon failure.

/**

 * dfll_unregister_clk - unregister the DFLL output clock

 * @td: DFLL instance

 *

 * Unregister the DFLL's output clock from the Linux clock framework

 * and from clkdev. No return value.

/*

 * Debugfs interface

/*

 * Monitor control

/**

 * dfll_calc_monitored_rate - convert DFLL_MONITOR_DATA_VAL rate into real freq

 * @monitor_data: value read from the DFLL_MONITOR_DATA_VAL bitfield

 * @ref_rate: DFLL reference clock rate

 *

 * Convert @monitor_data from DFLL_MONITOR_DATA_VAL units into cycles

 * per second. Returns the converted value.

/**

 * dfll_read_monitor_rate - return the DFLL's output rate from internal monitor

 * @td: DFLL instance

 *

 * If the DFLL is enabled, return the last rate reported by the DFLL's

 * internal monitoring hardware. This works in both open-loop and

 * closed-loop mode, and takes the output scaler setting into account.

 * Assumes that the monitor was programmed to monitor frequency before

 * the sample period started. If the driver believes that the DFLL is

 * currently uninitialized or disabled, it will return 0, since

 * otherwise the DFLL monitor data register will return the last

 * measured rate from when the DFLL was active.

 CONFIG_DEBUG_FS */

/*

 * DFLL initialization

/**

 * dfll_set_default_params - program non-output related DFLL parameters

 * @td: DFLL instance

 *

 * During DFLL driver initialization or resume from context loss,

 * program parameters for the closed loop integrator, DVCO tuning,

 * voltage droop control and monitor control.

/**

 * dfll_init_clks - clk_get() the DFLL source clocks

 * @td: DFLL instance

 *

 * Call clk_get() on the DFLL source clocks and save the pointers for later

 * use. Returns 0 upon success or error (see devm_clk_get) if one or more

 * of the clocks couldn't be looked up.

/**

 * dfll_init - Prepare the DFLL IP block for use

 * @td: DFLL instance

 *

 * Do everything necessary to prepare the DFLL IP block for use. The

 * DFLL will be left in DISABLED state. Called by dfll_probe().

 * Returns 0 upon success, or passes along the error from whatever

 * function returned it.

/**

 * tegra_dfll_suspend - check DFLL is disabled

 * @dev: DFLL instance

 *

 * DFLL clock should be disabled by the CPUFreq driver. So, make

 * sure it is disabled and disable all clocks needed by the DFLL.

/**

 * tegra_dfll_resume - reinitialize DFLL on resume

 * @dev: DFLL instance

 *

 * DFLL is disabled and reset during suspend and resume.

 * So, reinitialize the DFLL IP block back for use.

 * DFLL clock is enabled later in closed loop mode by CPUFreq

 * driver before switching its clock source to DFLL output.

/*

 * DT data fetch

/*

 * Find a PMIC voltage register-to-voltage mapping for the given voltage.

 * An exact voltage match is required.

/*

 * Find a PMIC voltage register-to-voltage mapping for the given voltage,

 * rounding up to the closest supported voltage.

/*

 * dfll_build_pwm_lut - build the PWM regulator lookup table

 * @td: DFLL instance

 * @v_max: Vmax from OPP table

 *

 * Look-up table in h/w is ignored when PWM is used as DFLL interface to PMIC.

 * In this case closed loop output is controlling duty cycle directly. The s/w

 * look-up that maps PWM duty cycle to voltage is still built by this function.

 since opp voltage is exact mv */

 determine voltage boundaries */

 determine rate boundaries */

/**

 * dfll_build_i2c_lut - build the I2C voltage register lookup table

 * @td: DFLL instance

 * @v_max: Vmax from OPP table

 *

 * The DFLL hardware has 33 bytes of look-up table RAM that must be filled with

 * PMIC voltage register values that span the entire DFLL operating range.

 * This function builds the look-up table based on the OPP table provided by

 * the soc-specific platform driver (td->soc->opp_dev) and the PMIC

 * register-to-voltage mapping queried from the regulator framework.

 *

 * On success, fills in td->lut and returns 0, or -err on failure.

/**

 * read_dt_param - helper function for reading required parameters from the DT

 * @td: DFLL instance

 * @param: DT property name

 * @dest: output pointer for the value read

 *

 * Read a required numeric parameter from the DFLL device node, or complain

 * if the property doesn't exist. Returns a boolean indicating success for

 * easy chaining of multiple calls to this function.

/**

 * dfll_fetch_i2c_params - query PMIC I2C params from DT & regulator subsystem

 * @td: DFLL instance

 *

 * Read all the parameters required for operation in I2C mode. The parameters

 * can originate from the device tree or the regulator subsystem.

 * Returns 0 on success or -err on failure.

/**

 * dfll_fetch_common_params - read DFLL parameters from the device tree

 * @td: DFLL instance

 *

 * Read all the DT parameters that are common to both I2C and PWM operation.

 * Returns 0 on success or -EINVAL on any failure.

/*

 * API exported to per-SoC platform drivers

/**

 * tegra_dfll_register - probe a Tegra DFLL device

 * @pdev: DFLL platform_device *

 * @soc: Per-SoC integration and characterization data for this DFLL instance

 *

 * Probe and initialize a DFLL device instance. Intended to be called

 * by a SoC-specific shim driver that passes in per-SoC integration

 * and configuration data via @soc. Returns 0 on success or -err on failure.

 Enable the clocks and set the device up */

/**

 * tegra_dfll_unregister - release all of the DFLL driver resources for a device

 * @pdev: DFLL platform_device *

 *

 * Unbind this driver from the DFLL hardware device represented by

 * @pdev. The DFLL must be disabled for this to succeed. Returns a

 * soc pointer upon success or -EBUSY if the DFLL is still active.

 Try to prevent removal while the DFLL is active */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2012, 2013, NVIDIA CORPORATION.  All rights reserved.

 osc_div2 */

 osc_div4 */

 pll_ref */

 clk_32k */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2012-2014 NVIDIA CORPORATION.  All rights reserved.

/*

 * TEGRA124_CAR_BANK_COUNT: the number of peripheral clock register

 * banks present in the Tegra124/132 CAR IP block.  The banks are

 * identified by single letters, e.g.: L, H, U, V, W, X.  See

 * periph_regs[] in drivers/clk/tegra/clk.c

 Tegra CPU clock and reset control regs */

 possible OSC frequencies in Hz */

 1 GHz */

 actual: 996.0 MHz */

 actual: 988.0 MHz */

 actual: 991.2 MHz */

 actual: 998.4 MHz */

 actual: 988.0 MHz */

 s/w policy, h/w capability 50 MHz */

 actual: 598.0 MHz */

 actual: 596.4 MHz */

 actual: 595.2 MHz */

 actual: 598.0 MHz */

 s/w policy, h/w capability 50 MHz */

 actual: 598.0 MHz */

 actual: 596.4 MHz */

 actual: 595.2 MHz */

 actual: 598.0 MHz */

 actual: 598.0 MHz */

 actual: 596.4 MHz */

 actual: 595.2 MHz */

 actual: 598.0 MHz */

 s/w policy, h/w capability 38 MHz */

 actual: 792.0 MHz */

 actual: 793.0 MHz */

 actual: 789.6 MHz */

 actual: 787.2 MHz */

 actual: 793.0 MHz */

 s/w policy, h/w capability 50 MHz */

 PLLE special case: use cpcon field to store cml divider value */

 s/w policy, h/w capability 38 MHz */

 actual: 591.5 MHz */

 actual: 596.4 MHz */

 actual: 595.2 MHz */

 actual: 591.5 MHz */

 s/w policy, h/w capability 38 MHz */

 actual: 598.0 MHz */

 actual: 596.4 MHz */

 actual: 595.2 MHz */

 actual: 598.0 MHz */

 s/w policy, h/w capability 38 MHz */

 xusb_ss_div2 */

 cml0 */

 cml1 */

 PLLC */

 PLLC_OUT1 */

 PLLC_UD */

 PLLC2 */

 PLLC3 */

 PLLM */

 PLLM_OUT1 */

 PLLM_UD */

 PLLU */

 PLLU_480M */

 PLLU_60M */

 PLLU_48M */

 PLLU_12M */

 PLLD */

 PLLD_OUT0 */

 PLLRE */

 PLLE */

 PLLC4 */

 PLLDP */

 PLLD2 */

 PLLD2_OUT0 */

 Tegra124 CPU clock and reset control functions */

 check CPU been reset or not */

 flow controller would take care in the power sequence. */

 switch coresite to clk_m, save off original source */

 must be the last entry */

 must be the last entry */

 Tegra132 requires the SOC_THERM clock to remain active */

 must be the last entry */

/**

 * tegra124_clock_apply_init_table - initialize clocks on Tegra124 SoCs

 *

 * Program an initial clock rate and enable or disable clocks needed

 * by the rest of the kernel, for Tegra124 SoCs.  It is intended to be

 * called by assigning a pointer to it to tegra_clk_apply_init_table -

 * this will be called as an arch_initcall.  No return value.

/**

 * tegra124_car_barrier - wait for pending writes to the CAR to complete

 *

 * Wait for any outstanding writes to the CAR MMIO space from this CPU

 * to complete before continuing execution.  No return value.

/**

 * tegra124_clock_assert_dfll_dvco_reset - assert the DFLL's DVCO reset

 *

 * Assert the reset line of the DFLL's DVCO.  No return value.

/**

 * tegra124_clock_deassert_dfll_dvco_reset - deassert the DFLL's DVCO reset

 *

 * Deassert the reset line of the DFLL's DVCO, allowing the DVCO to

 * operate.  No return value.

/**

 * tegra132_clock_apply_init_table - initialize clocks on Tegra132 SoCs

 *

 * Program an initial clock rate and enable or disable clocks needed

 * by the rest of the kernel, for Tegra132 SoCs.  It is intended to be

 * called by assigning a pointer to it to tegra_clk_apply_init_table -

 * this will be called as an arch_initcall.  No return value.

/**

 * tegra124_132_clock_init_pre - clock initialization preamble for T124/T132

 * @np: struct device_node * of the DT node for the SoC CAR IP block

 *

 * Register most of the clocks controlled by the CAR IP block.

 * Everything in this function should be common to Tegra124 and Tegra132.

 * No return value.

 For Tegra124 & Tegra132, PLLD is the only source for DSIA & DSIB */

/**

 * tegra124_132_clock_init_post - clock initialization postamble for T124/T132

 * @np: struct device_node * of the DT node for the SoC CAR IP block

 *

 * Register most of the clocks controlled by the CAR IP block.

 * Everything in this function should be common to Tegra124

 * and Tegra132.  This function must be called after

 * tegra124_132_clock_init_pre(), otherwise clk_base will not be set.

 * No return value.

/**

 * tegra124_clock_init - Tegra124-specific clock initialization

 * @np: struct device_node * of the DT node for the SoC CAR IP block

 *

 * Register most SoC clocks for the Tegra124 system-on-chip.  Most of

 * this code is shared between the Tegra124 and Tegra132 SoCs,

 * although some of the initial clock settings and CPU clocks differ.

 * Intended to be called by the OF init code when a DT node with the

 * "nvidia,tegra124-car" string is encountered, and declared with

 * CLK_OF_DECLARE.  No return value.

/**

 * tegra132_clock_init - Tegra132-specific clock initialization

 * @np: struct device_node * of the DT node for the SoC CAR IP block

 *

 * Register most SoC clocks for the Tegra132 system-on-chip.  Most of

 * this code is shared between the Tegra124 and Tegra132 SoCs,

 * although some of the initial clock settings and CPU clocks differ.

 * Intended to be called by the OF init code when a DT node with the

 * "nvidia,tegra132-car" string is encountered, and declared with

 * CLK_OF_DECLARE.  No return value.

	/*

	 * On Tegra132, these clocks are controlled by the

	 * CLUSTER_clocks IP block, located in the CPU complex

 SPDX-License-Identifier: GPL-2.0+

/*

 * Based on drivers/clk/tegra/clk-emc.c

 * Copyright (c) 2014, NVIDIA CORPORATION.  All rights reserved.

 *

 * Author: Dmitry Osipenko <digetx@gmail.com>

 * Copyright (C) 2019 GRATE-DRIVER project

	/*

	 * EMC stands for External Memory Controller.

	 *

	 * We don't want EMC clock to be disabled ever by gating its

	 * parent and whatnot because system is busted immediately in that

	 * case, hence the clock is marked as critical.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2012, 2013, NVIDIA CORPORATION.  All rights reserved.

 SCLK_MUX */

 SCLK */

 SCLK */

 HCLK */

 PCLK */

 CCLKG */

 CCLKLP */

			/*

			 * TEGRA210_CPU_CLK flag is not needed for cclk_lp as

			 * cluster switching is not currently supported on

			 * Tegra210 and also cpu_lp is not used.

 PLLX */

 PLLX_OUT0 */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2012, NVIDIA CORPORATION.  All rights reserved.

 Data in .init is copied by clk_register(), so stack variable OK */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2018 NVIDIA CORPORATION.  All rights reserved.

 *

 * based on clk-mux.c

 *

 * Copyright (C) 2011 Sascha Hauer, Pengutronix <s.hauer@pengutronix.de>

 * Copyright (C) 2011 Richard Zhao, Linaro <richard.zhao@linaro.org>

 * Copyright (C) 2011-2012 Mike Turquette, Linaro Ltd <mturquette@linaro.org>

 *

 Data in .init is copied by clk_register(), so stack variable OK */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Utility functions for parsing Tegra CVB voltage tables

 *

 * Copyright (C) 2012-2019 NVIDIA Corporation.  All rights reserved.

 cvb_mv = ((c2 * speedo / s_scale + c1) * speedo / s_scale + c0) */

 apply only speedo scale: output mv = cvb_mv * v_scale */

 combined: apply voltage scale and round to cvb alignment step */

/**

 * tegra_cvb_add_opp_table - build OPP table from Tegra CVB tables

 * @dev: the struct device * for which the OPP table is built

 * @tables: array of CVB tables

 * @count: size of the previously mentioned array

 * @align: parameters of the regulator step and offset

 * @process_id: process id of the HW module

 * @speedo_id: speedo id of the HW module

 * @speedo_value: speedo value of the HW module

 * @max_freq: highest safe clock rate

 *

 * On Tegra, a CVB table encodes the relationship between operating voltage

 * and safe maximal frequency for a given module (e.g. GPU or CPU). This

 * function calculates the optimal voltage-frequency operating points

 * for the given arguments and exports them via the OPP library for the

 * given @dev. Returns a pointer to the struct cvb_table that matched

 * or an ERR_PTR on failure.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2012, NVIDIA CORPORATION.  All rights reserved.

	/*

	 * If LP_DIV2_BYPASS is not set and PLLX is current parent then

	 * PLLX/2 is the input source to CCLKLP.

	/*

	 * For LP mode super-clock switch between PLLX direct

	 * and divided-by-2 outputs is allowed only when other

	 * than PLLX clock source is current parent.

 enable PLLP branches to CPU before selecting PLLP source */

 disable PLLP branches to CPU if not used */

 Data in .init is copied by clk_register(), so stack variable OK */

 Data in .init is copied by clk_register(), so stack variable OK */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2012, NVIDIA CORPORATION.  All rights reserved.

 Tegra CPU clock and reset control regs */

 PLLM override registers */

 actual: 1039.5 MHz */

 actual: 831.6 MHz */

 actual: 519.75 MHz */

 actual: 415.8 MHz */

 1.7 GHz */

 actual: 1699.2 MHz */

 actual: 1699.2 MHz */

 actual: 1699.2 MHz */

 1.6 GHz */

 actual: 1599.0 MHz */

 actual: 1599.7 MHz */

 1.5 GHz */

 actual: 1499.8 MHz */

 1.4 GHz */

 actual: 1399.7 MHz */

 1.3 GHz */

 actual: 1299.2 MHz */

 actual: 1299.2 MHz */

 1.2 GHz */

 actual: 1199.9 MHz */

 1.1 GHz */

 actual: 1099.8 MHz */

 actual: 1099.8 MHz */

 actual: 1099.5 MHz */

 1 GHz */

 actual: 999.6 MHz */

 PLLE special case: use cpcon field to store cml divider value */

 PLL parameters */

 PLLC */

 PLLC_OUT1 */

 PLLM */

 PLLM_OUT1 */

 PLLX */

 PLLX_OUT0 */

 PLLU */

 PLLD */

 PLLD_OUT0 */

 PLLD2 */

 PLLD2_OUT0 */

 PLLE */

	/*

	 * Clock input to cclk_g divided from pll_p using

	 * U71 divider of cclk_g.

	/*

	 * Clock input to cclk_g divided from pll_p_out3 using

	 * U71 divider of cclk_g.

	/*

	 * Clock input to cclk_g divided from pll_p_out4 using

	 * U71 divider of cclk_g.

 CCLKG */

	/*

	 * Clock input to cclk_lp divided from pll_p using

	 * U71 divider of cclk_lp.

	/*

	 * Clock input to cclk_lp divided from pll_p_out3 using

	 * U71 divider of cclk_lp.

	/*

	 * Clock input to cclk_lp divided from pll_p_out4 using

	 * U71 divider of cclk_lp.

 CCLKLP */

 SCLK */

 twd */

 dsia */

 pcie */

 afi */

 emc */

 cml0 */

 cml1 */

 Tegra30 CPU clock and reset control functions */

 check CPU been reset or not */

 switch coresite to clk_m, save off original source */

 Is CPU complex already running on PLLX? */

 restore PLLX settings if CPU is on different PLL */

 wait for PLL stabilization if PLLX was enabled */

	/*

	 * Restore original burst policy setting for calls resulting from CPU

	 * LP2 in idle or system suspend.

 must be the last entry */

/*

 * Some clocks may be used by different drivers depending on the board

 * configuration.  List those here to register them twice in the clock lookup

 * table under two names.

 must be the last entry */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2018, NVIDIA CORPORATION.  All rights reserved.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2012, NVIDIA CORPORATION.  All rights reserved.

 Macros to assist peripheral gate clock */

 Peripheral gate clock ops */

	/*

	 * If peripheral is in the APB bus then read the APB bus to

	 * flush the write operation in apb bus. This will avoid the

	 * peripheral access after disabling clock

	/*

	 * Some clocks are duplicated and some of them are marked as critical,

	 * like fuse and fuse_burn for example, thus the enable_refcnt will

	 * be non-zero here if the "unused" duplicate is disabled by CCF.

 Data in .init is copied by clk_register(), so stack variable OK */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Tegra124 DFLL FCPU clock source driver

 *

 * Copyright (C) 2012-2019 NVIDIA Corporation.  All rights reserved.

 *

 * Aleksandr Frid <afrid@nvidia.com>

 * Paul Walmsley <pwalmsley@nvidia.com>

 Maximum CPU frequency, indexed by CPU speedo id */

/*

 * OMAP APLL clock support

 *

 * Copyright (C) 2013 Texas Instruments, Inc.

 *

 * J Keerthy <j-keerthy@ti.com>

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License version 2 as

 * published by the Free Software Foundation.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

 Check is already locked */

/*

 * TI clock autoidle support

 *

 * Copyright (C) 2013 Texas Instruments, Inc.

 *

 * Tero Kristo <t-kristo@ti.com>

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License version 2 as

 * published by the Free Software Foundation.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

/*

 * we have some non-atomic read/write

 * operations behind it, so lets

 * take one lock for handling autoidle

 * of all clocks

/**

 * omap2_clk_deny_idle - disable autoidle on an OMAP clock

 * @clk: struct clk * to disable autoidle for

 *

 * Disable autoidle on an OMAP clock.

/**

 * omap2_clk_allow_idle - enable autoidle on an OMAP clock

 * @clk: struct clk * to enable autoidle for

 *

 * Enable autoidle on an OMAP clock.

/**

 * _clk_generic_allow_autoidle_all - enable autoidle for all clocks

 *

 * Enables hardware autoidle for all registered DT clocks, which have

 * the feature.

/**

 * _clk_generic_deny_autoidle_all - disable autoidle for all clocks

 *

 * Disables hardware autoidle for all registered DT clocks, which have

 * the feature.

/**

 * of_ti_clk_autoidle_setup - sets up hardware autoidle for a clock

 * @node: pointer to the clock device node

 *

 * Checks if a clock has hardware autoidle support or not (check

 * for presence of 'ti,autoidle-shift' property in the device tree

 * node) and sets up the hardware autoidle feature for the clock

 * if available. If autoidle is available, the clock is also added

 * to the autoidle list for later processing. Returns 0 on success,

 * negative error value on failure.

 Check if this clock has autoidle support or not */

/**

 * omap2_clk_enable_autoidle_all - enable autoidle on all OMAP clocks that

 * support it

 *

 * Enable clock autoidle on all OMAP clocks that have allow_idle

 * function pointers associated with them.  This function is intended

 * to be temporary until support for this is added to the common clock

 * code.  Returns 0.

/**

 * omap2_clk_disable_autoidle_all - disable autoidle on all OMAP clocks that

 * support it

 *

 * Disable clock autoidle on all OMAP clocks that have allow_idle

 * function pointers associated with them.  This function is intended

 * to be temporary until support for this is added to the common clock

 * code.  Returns 0.

/*

 * TI clock support

 *

 * Copyright (C) 2013 Texas Instruments, Inc.

 *

 * Tero Kristo <t-kristo@ti.com>

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License version 2 as

 * published by the Free Software Foundation.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

/**

 * ti_clk_setup_ll_ops - setup low level clock operations

 * @ops: low level clock ops descriptor

 *

 * Sets up low level clock operations for TI clock driver. This is used

 * to provide various callbacks for the clock driver towards platform

 * specific code. Returns 0 on success, -EBUSY if ll_ops have been

 * registered already.

/**

 * ti_dt_clocks_register - register DT alias clocks during boot

 * @oclks: list of clocks to register

 *

 * Register alias or non-standard DT clock entries during boot. By

 * default, DT clocks are found based on their node name. If any

 * additional con-id / dev-id -> clock mapping is required, use this

 * function to list these.

/**

 * ti_clk_retry_init - retries a failed clock init at later phase

 * @node: device not for the clock

 * @user: user data pointer

 * @func: init function to be called for the clock

 *

 * Adds a failed clock init to the retry list. The retry list is parsed

 * once all the other clocks have been initialized.

/**

 * ti_clk_get_reg_addr - get register address for a clock register

 * @node: device node for the clock

 * @index: register index from the clock node

 * @reg: pointer to target register struct

 *

 * Builds clock register address from device tree information, and returns

 * the data via the provided output pointer @reg. Returns 0 on success,

 * negative error value on failure.

 OCP barrier */

/**

 * omap2_clk_provider_init - init master clock provider

 * @parent: master node

 * @index: internal index for clk_reg_ops

 * @syscon: syscon regmap pointer for accessing clock registers

 * @mem: iomem pointer for the clock provider memory area, only used if

 *       syscon is not provided

 *

 * Initializes a master clock IP block. This basically sets up the

 * mapping from clocks node to the memory map index. All the clocks

 * are then initialized through the common of_clk_init call, and the

 * clocks will access their memory maps based on the node layout.

 * Returns 0 in success.

 get clocks for this parent */

 add clocks node info */

/**

 * omap2_clk_legacy_provider_init - initialize a legacy clock provider

 * @index: index for the clock provider

 * @mem: iomem pointer for the clock provider memory area

 *

 * Initializes a legacy clock provider memory mapping.

/**

 * ti_dt_clk_init_retry_clks - init clocks from the retry list

 *

 * Initializes any clocks that have failed to initialize before,

 * reasons being missing parent node(s) during earlier init. This

 * typically happens only for DPLLs which need to have both of their

 * parent clocks ready during init.

/**

 * ti_clk_add_aliases - setup clock aliases

 *

 * Sets up any missing clock aliases. No return value.

/**

 * ti_clk_setup_features - setup clock features flags

 * @features: features definition to use

 *

 * Initializes the clock driver features flags based on platform

 * provided data. No return value.

/**

 * ti_clk_get_features - get clock driver features flags

 *

 * Get TI clock driver features description. Returns a pointer

 * to the current feature setup.

/**

 * omap2_clk_enable_init_clocks - prepare & enable a list of clocks

 * @clk_names: ptr to an array of strings of clock names to enable

 * @num_clocks: number of clock names in @clk_names

 *

 * Prepare and enable a list of clocks, named by @clk_names.  No

 * return value. XXX Deprecated; only needed until these clocks are

 * properly claimed and enabled by the drivers or core code that uses

 * them.  XXX What code disables & calls clk_put on these clocks?

/**

 * ti_clk_add_alias - add a clock alias for a TI clock

 * @dev: device alias for this clock

 * @clk: clock handle to create alias for

 * @con: connection ID for this clock

 *

 * Creates a clock alias for a TI clock. Allocates the clock lookup entry

 * and assigns the data to it. Returns 0 if successful, negative error

 * value otherwise.

/**

 * ti_clk_register - register a TI clock to the common clock framework

 * @dev: device for this clock

 * @hw: hardware clock handle

 * @con: connection ID for this clock

 *

 * Registers a TI clock to the common clock framework, and adds a clock

 * alias for it. Returns a handle to the registered clock if successful,

 * ERR_PTR value in failure.

/**

 * ti_clk_register_omap_hw - register a clk_hw_omap to the clock framework

 * @dev: device for this clock

 * @hw: hardware clock handle

 * @con: connection ID for this clock

 *

 * Registers a clk_hw_omap clock to the clock framewor, adds a clock alias

 * for it, and adds the list to the available clk_hw_omap type clocks.

 * Returns a handle to the registered clock if successful, ERR_PTR value

 * in failure.

/**

 * omap2_clk_for_each - call function for each registered clk_hw_omap

 * @fn: pointer to a callback function

 *

 * Call @fn for each registered clk_hw_omap, passing @hw to each

 * function.  @fn must return 0 for success or any other value for

 * failure.  If @fn returns non-zero, the iteration across clocks

 * will stop and the non-zero return value will be passed to the

 * caller of omap2_clk_for_each().

/**

 * omap2_clk_is_hw_omap - check if the provided clk_hw is OMAP clock

 * @hw: clk_hw to check if it is an omap clock or not

 *

 * Checks if the provided clk_hw is OMAP clock or not. Returns true if

 * it is, false otherwise.

/*

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License as

 * published by the Free Software Foundation version 2.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the

 * GNU General Public License for more details.

 FAPLL Control Register PLL_CTRL */

 FAPLL powerdown register PWD */

 The bypass bit is inverted on the ddr_pll.. */

/*

 * The audio_pll_clk1 input is hard wired to the 27MHz bypass clock,

 * and the audio_pll_clk1 synthesizer is hardwared to 32KiHz output.

 Synthesizer divider register */

 Synthesizer frequency register */

 PLL pre-divider is P and multiplier is N */

	/*

	 * So far no luck getting decent clock with PLL divider,

	 * PLL does not seem to lock and the signal does not look

	 * right. It seems the divider can only be used together

	 * with the multiplier?

/*

 * See dm816x TRM chapter 1.10.3 Flying Adder PLL fore more info

 The audio_pll_clk1 is hardwired to produce 32.768KiHz clock */

	/*

	 * PLL in bypass sets the synths in bypass mode too. The PLL rate

	 * can be also be set to 27MHz, so we can't use parent_rate to

	 * check for bypass mode.

	/*

	 * Synth frequency integer and fractional divider.

	 * Note that the phase output K is 8, so the result needs

	 * to be multiplied by SYNTH_PHASE_K.

 Synth post-divider M */

 Only post divider m available with no fractional divider? */

 Produce the rate with just post divider M? */

 Need to recalculate the fractional divider? */

 Register the parent PLL */

	/*

	 * Set up the child synthesizers starting at index 1 as the

	 * PLL output is at index 0. We need to check the clock-indices

	 * for numbering in case there are holes in the synth mapping,

	 * and then probe the synth register to see if it has a FREQ

	 * register available.

 Check for hardwired audio_pll_clk1 */

 Does the synthesizer have a FREQ register? */

 Register the child synthesizers as the FAPLL outputs */

 Add clock alias for the outputs */

/*

 * TI Multiplexer Clock

 *

 * Copyright (C) 2013 Texas Instruments, Inc.

 *

 * Tero Kristo <t-kristo@ti.com>

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License version 2 as

 * published by the Free Software Foundation.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

	/*

	 * FIXME need a mux-specific flag to determine if val is bitwise or

	 * numeric. e.g. sys_clkin_ck's clksel field is 3 bits wide, but ranges

	 * from 0x1 to 0x7 (index starts at one)

	 * OTOH, pmd_trace_clk_mux_ck uses a separate bit for each clock, so

	 * val = 0x4 really means "bit 2, index starts at bit 0"

/**

 * clk_mux_save_context - Save the parent selcted in the mux

 * @hw: pointer  struct clk_hw

 *

 * Save the parent mux value.

/**

 * clk_mux_restore_context - Restore the parent in the mux

 * @hw: pointer  struct clk_hw

 *

 * Restore the saved parent mux value.

 allocate the mux */

 struct clk_mux assignments */

/**

 * of_mux_clk_setup - Setup function for simple mux rate clock

 * @node: DT node for the clock

 *

 * Sets up a basic clock multiplexer.

 Generate bit-mask based on parent info */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * OMAP5 Clock init

 *

 * Copyright (C) 2013 Texas Instruments, Inc.

 *

 * Tero Kristo (t-kristo@ti.com)

/*

 * OMAP543x TRM, section "3.6.3.9.5 DPLL_USB Preferred Settings"

 * states it must be at 960MHz

	/*

	 * This must also be set to sys_32k_ck to match or

	 * the ABE DPLL will not lock on a warm reboot when

	 * ABE timers are used.

/*

 * AM43XX Clock init

 *

 * Copyright (C) 2013 Texas Instruments, Inc

 *     Tero Kristo (t-kristo@ti.com)

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License as

 * published by the Free Software Foundation version 2.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the

 * GNU General Public License for more details.

/*

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License as

 * published by the Free Software Foundation version 2.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the

 * GNU General Public License for more details.

 Managed by MPPULL */

 REVISIT: which bit? */

 Only on MPUPLL */

 Only on MPUPLL */

 For ADPLL shared register access */

 See MAX_CON_ID */

 Separate con_id in format "pll040dcoclkldo" to fit MAX_CON_ID */

/*

 * Locked and bypass are not actually mutually exclusive:  if you only care

 * about the DCO clock and not CLKOUT you can clear M2PWDNZ before enabling

 * the PLL, resulting in status (FREQLOCK | PHASELOCK | BYPASS) after lock.

/*

 * Note that the DCO clock is never subject to bypass: if the PLL is off,

 * dcoclk is low.

 PLL parent is always clkinp, bypass only affects the children */

 Internal input clock divider N2 */

 Setting PLL bypass puts clkout and clkoutx2 into bypass */

 Internal mux, sources from divider N2 or clkinpulow */

 Internal divider M2, sources DCO */

 Internal fixed divider, after M2 before clkout */

 Output clkout with a mux and gate, sources from div2 or bypass */

 Output clkoutx2 with a mux and gate, sources from M2 or bypass */

 Internal mux, sources from DCO and clkinphif */

 Output clkouthif with a divider M3, sources from hif */

 Output clock dcoclkldo is the DCO */

 Output clkdcoldo, gated output of DCO */

 Internal divider M2, sources from DCO */

 Output clkoutldo, gated output of M2 */

 Internal mux, sources from divider N2 or clkinpulow */

 Output clkout, sources M2 or bypass */

 MPU PLL manages the lock register for all PLLs */

/*

 * AM33XX Clock init

 *

 * Copyright (C) 2013 Texas Instruments, Inc

 *     Tero Kristo (t-kristo@ti.com)

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License as

 * published by the Free Software Foundation version 2.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the

 * GNU General Public License for more details.

/*

 * OMAP2 Clock init

 *

 * Copyright (C) 2013 Texas Instruments, Inc

 *     Tero Kristo (t-kristo@ti.com)

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License as

 * published by the Free Software Foundation version 2.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the

 * GNU General Public License for more details.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * OMAP4 Clock init

 *

 * Copyright (C) 2013 Texas Instruments, Inc.

 *

 * Tero Kristo (t-kristo@ti.com)

/*

 * OMAP4 ABE DPLL default frequency. In OMAP4460 TRM version V, section

 * "3.6.3.2.3 CM1_ABE Clock Generator" states that the "DPLL_ABE_X2_CLK

 * must be set to 196.608 MHz" and hence, the DPLL locked frequency is

 * half of this value.

/*

 * OMAP4 USB DPLL default frequency. In OMAP4430 TRM version V, section

 * "3.6.3.9.5 DPLL_USB Preferred Settings" shows that the preferred

 * locked frequency for the USB DPLL is 960MHz.

	/*

	 * XXX: All the clock aliases below are only needed for legacy

	 * hwmod support. Once hwmod is removed, these can be removed

	 * also.

	/*

	 * Lock USB DPLL on OMAP4 devices so that the L3INIT power

	 * domain can transition to retention state when not in use.

	/*

	 * On OMAP4460 the ABE DPLL fails to turn on if in idle low-power

	 * state when turning the ABE clock domain. Workaround this by

	 * locking the ABE DPLL on boot.

	 * Lock the ABE DPLL in any case to avoid issues with audio.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * OMAP2/3 interface clock control

 *

 * Copyright (C) 2011 Nokia Corporation

 * Paul Walmsley

 Register offsets */

 Private functions */

 XXX */

 XXX */

/**

 * omap2430_clk_i2chs_find_idlest - return CM_IDLEST info for 2430 I2CHS

 * @clk: struct clk * being enabled

 * @idlest_reg: void __iomem ** to store CM_IDLEST reg address into

 * @idlest_bit: pointer to a u8 to store the CM_IDLEST bit shift into

 * @idlest_val: pointer to a u8 to store the CM_IDLEST indicator

 *

 * OMAP2430 I2CHS CM_IDLEST bits are in CM_IDLEST1_CORE, but the

 * CM_*CLKEN bits are in CM_{I,F}CLKEN2_CORE.  This custom function

 * passes back the correct CM_IDLEST register address for I2CHS

 * modules.  No return value.

 Public data */

 2430 I2CHS has non-standard IDLEST register */

/*

 * DRA7 ATL (Audio Tracking Logic) clock driver

 *

 * Copyright (C) 2013 Texas Instruments, Inc.

 *

 * Peter Ujfalusi <peter.ujfalusi@ti.com>

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License version 2 as

 * published by the Free Software Foundation.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

 the driver for the IP has been loaded */

 configured */

 Baseband Word Select Mux */

 Audio Word Select Mux */

 Cached divider value */

 Get configuration for the ATL instances */

		/*

		 * Enable the clock if it has been asked prior to loading the

		 * hw driver

/*

 * OMAP gate clock support

 *

 * Copyright (C) 2013 Texas Instruments, Inc.

 *

 * Tero Kristo <t-kristo@ti.com>

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License version 2 as

 * published by the Free Software Foundation.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

/**

 * omap36xx_gate_clk_enable_with_hsdiv_restore - enable clocks suffering

 *         from HSDivider PWRDN problem Implements Errata ID: i556.

 * @hw: DPLL output struct clk_hw

 *

 * 3630 only: dpll3_m3_ck, dpll4_m2_ck, dpll4_m3_ck, dpll4_m4_ck,

 * dpll4_m5_ck & dpll4_m6_ck dividers gets loaded with reset

 * valueafter their respective PWRDN bits are set.  Any dummy write

 * (Any other value different from the Read value) to the

 * corresponding CM_CLKSEL register will refresh the dividers.

 Clear PWRDN bit of HSDIVIDER */

 Parent is the x2 node, get parent of parent for the m2 div */

 Restore the dividers */

 Write any other value different from the Read value */

 Write the original divider */

/*

 * TI Fixed Factor Clock

 *

 * Copyright (C) 2013 Texas Instruments, Inc.

 *

 * Tero Kristo <t-kristo@ti.com>

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License version 2 as

 * published by the Free Software Foundation.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

/**

 * of_ti_fixed_factor_clk_setup - Setup function for TI fixed factor clock

 * @node: device node for this clock

 *

 * Sets up a simple fixed factor clock based on device tree info.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * OMAP2/3/4 DPLL clock functions

 *

 * Copyright (C) 2005-2008 Texas Instruments, Inc.

 * Copyright (C) 2004-2010 Nokia Corporation

 *

 * Contacts:

 * Richard Woodruff <r-woodruff2@ti.com>

 * Paul Walmsley

 DPLL rate rounding: minimum DPLL multiplier, divider values */

 Possible error results from _dpll_test_mult */

/*

 * Scale factor to mitigate roundoff errors in DPLL rate rounding.

 * The higher the scale factor, the greater the risk of arithmetic overflow,

 * but the closer the rounded rate to the target rate.  DPLL_SCALE_FACTOR

 * must be a power of DPLL_SCALE_BASE.

/*

 * DPLL valid Fint frequency range for OMAP36xx and OMAP4xxx.

 * From device data manual section 4.3 "DPLL and DLL Specifications".

 _dpll_test_fint() return codes */

 Private functions */

/*

 * _dpll_test_fint - test whether an Fint value is valid for the DPLL

 * @clk: DPLL struct clk to test

 * @n: divider value (N) to test

 *

 * Tests whether a particular divider @n will result in a valid DPLL

 * internal clock frequency Fint. See the 34xx TRM 4.7.6.2 "DPLL Jitter

 * Correction".  Returns 0 if OK, -1 if the enclosing loop can terminate

 * (assuming that it is counting N upwards), or -2 if the enclosing loop

 * should skip to the next iteration (again assuming N is increasing).

 DPLL divider must result in a valid jitter correction val */

/*

 * _dpll_test_mult - test a DPLL multiplier value

 * @m: pointer to the DPLL m (multiplier) value under test

 * @n: current DPLL n (divider) value under test

 * @new_rate: pointer to storage for the resulting rounded rate

 * @target_rate: the desired DPLL rate

 * @parent_rate: the DPLL's parent clock rate

 *

 * This code tests a DPLL multiplier value, ensuring that the

 * resulting rate will not be higher than the target_rate, and that

 * the multiplier value itself is valid for the DPLL.  Initially, the

 * integer pointed to by the m argument should be prescaled by

 * multiplying by DPLL_SCALE_FACTOR.  The code will replace this with

 * a non-scaled m upon return.  This non-scaled m will result in a

 * new_rate as close as possible to target_rate (but not greater than

 * target_rate) given the current (parent_rate, n, prescaled m)

 * triple. Returns DPLL_MULT_UNDERFLOW in the event that the

 * non-scaled m attempted to underflow, which can allow the calling

 * function to bail out early; or 0 upon success.

 Unscale m and round if necessary */

	/*

	 * The new rate must be <= the target rate to avoid programming

	 * a rate that is impossible for the hardware to handle

 Guard against m underflow */

/**

 * _omap2_dpll_is_in_bypass - check if DPLL is in bypass mode or not

 * @v: bitfield value of the DPLL enable

 *

 * Checks given DPLL enable bitfield to see whether the DPLL is in bypass

 * mode or not. Returns 1 if the DPLL is in bypass, 0 otherwise.

	/*

	 * Each set bit in the mask corresponds to a bypass value equal

	 * to the bitshift. Go through each set-bit in the mask and

	 * compare against the given register value.

 Public functions */

 Reparent the struct clk in case the dpll is in bypass */

/**

 * omap2_get_dpll_rate - returns the current DPLL CLKOUT rate

 * @clk: struct clk * of a DPLL

 *

 * DPLLs can be locked or bypassed - basically, enabled or disabled.

 * When locked, the DPLL output depends on the M and N values.  When

 * bypassed, on OMAP2xxx, the output rate is either the 32KiHz clock

 * or sys_clk.  Bypass rates on OMAP3 depend on the DPLL: DPLLs 1 and

 * 2 are bypassed with dpll1_fclk and dpll2_fclk respectively

 * (generated by DPLL3), while DPLL 3, 4, and 5 bypass rates are sys_clk.

 * Returns the current DPLL CLKOUT rate (*not* CLKOUTX2) if the DPLL is

 * locked, or the appropriate bypass rate if the DPLL is bypassed, or 0

 * if the clock @clk is not a DPLL.

 Return bypass rate if DPLL is bypassed */

 DPLL rate rounding code */

/**

 * omap2_dpll_round_rate - round a target rate for an OMAP DPLL

 * @hw: struct clk_hw containing the struct clk * for a DPLL

 * @target_rate: desired DPLL clock rate

 * @parent_rate: parent's DPLL clock rate

 *

 * Given a DPLL and a desired target rate, round the target rate to a

 * possible, programmable rate for this DPLL.  Attempts to select the

 * minimum possible n.  Stores the computed (m, n) in the DPLL's

 * dpll_data structure so set_rate() will not need to call this

 * (expensive) function again.  Returns ~0 if the target rate cannot

 * be rounded, or the rounded rate upon success.

 Is the (input clk, divider) pair valid for the DPLL? */

 Compute the scaled DPLL multiplier, based on the divider */

		/*

		 * Since we're counting n up, a m overflow means we

		 * can bail out completely (since as n increases in

		 * the next iteration, there's no way that m can

		 * increase beyond the current m)

 m can't be set low enough for this n - try with a larger n */

 skip rates above our target rate */

/*

 * AM33XX Clock init

 *

 * Copyright (C) 2013 Texas Instruments, Inc

 *     Tero Kristo (t-kristo@ti.com)

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License as

 * published by the Free Software Foundation version 2.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the

 * GNU General Public License for more details.

 AM3_L3_L3_MAIN_CLKCTRL, needed during suspend */

 Required for external peripherals like, Audio codecs */

	/* TRM ERRATA: Timer 3 & 6 default parent (TCLKIN) may not be always

	 *    physically present, in such a case HWMOD enabling of

	 *    clock would be failure with default parent. And timer

	 *    probe thinks clock is already enabled, this leads to

	 *    crash upon accessing timer 3 & 6 registers in probe.

	 *    Fix by setting parent of both these timers to master

	 *    oscillator clock.

	/*

	 * The On-Chip 32K RC Osc clock is not an accurate clock-source as per

	 * the design/spec, so as a result, for example, timer which supposed

	 * to get expired @60Sec, but will expire somewhere ~@40Sec, which is

	 * not expected by any use-case, so change WDT1 clock source to PRCM

	 * 32KHz clock.

/*

 * OMAP DPLL clock support

 *

 * Copyright (C) 2013 Texas Instruments, Inc.

 *

 * Tero Kristo <t-kristo@ti.com>

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License version 2 as

 * published by the Free Software Foundation.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

/**

 * _register_dpll - low level registration of a DPLL clock

 * @user: pointer to the hardware clock definition for the clock

 * @node: device node for the clock

 *

 * Finalizes DPLL registration process. In case a failure (clk-ref or

 * clk-bypass is missing), the clock is added to retry list and

 * the initialization is retried on later stage.

 register the clock */

/**

 * _register_dpll_x2 - Registers a DPLLx2 clock

 * @node: device node for this clock

 * @ops: clk_ops for this clock

 * @hw_ops: clk_hw_ops for this clock

 *

 * Initializes a DPLL x 2 clock from device tree data.

 Check if register defined, if not, drop hw-ops */

 register the clock */

/**

 * of_ti_dpll_setup - Setup function for OMAP DPLL clocks

 * @node: device node containing the DPLL info

 * @ops: ops for the DPLL

 * @ddt: DPLL data template to use

 *

 * Initializes a DPLL clock from device tree data.

	/*

	 * Special case for OMAP2 DPLL, register order is different due to

	 * missing idlest_reg, also clkhwops is different. Detected from

	 * missing idlest_mask.

 DCC beyond 1.4GHz */

/*

 * OMAP3 Clock init

 *

 * Copyright (C) 2013 Texas Instruments, Inc

 *     Tero Kristo (t-kristo@ti.com)

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License as

 * published by the Free Software Foundation version 2.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the

 * GNU General Public License for more details.

/*

 * In AM35xx IPSS, the {ICK,FCK} enable bits for modules are exported

 * in the same register at a bit offset of 0x8. The EN_ACK for ICK is

 * at an offset of 4 from ICK enable bit.

/**

 * omap3430es2_clk_ssi_find_idlest - return CM_IDLEST info for SSI

 * @clk: struct clk * being enabled

 * @idlest_reg: void __iomem ** to store CM_IDLEST reg address into

 * @idlest_bit: pointer to a u8 to store the CM_IDLEST bit shift into

 * @idlest_val: pointer to a u8 to store the CM_IDLEST indicator

 *

 * The OMAP3430ES2 SSI target CM_IDLEST bit is at a different shift

 * from the CM_{I,F}CLKEN bit.  Pass back the correct info via

 * @idlest_reg and @idlest_bit.  No return value.

/**

 * omap3430es2_clk_dss_usbhost_find_idlest - CM_IDLEST info for DSS, USBHOST

 * @clk: struct clk * being enabled

 * @idlest_reg: void __iomem ** to store CM_IDLEST reg address into

 * @idlest_bit: pointer to a u8 to store the CM_IDLEST bit shift into

 * @idlest_val: pointer to a u8 to store the CM_IDLEST indicator

 *

 * Some OMAP modules on OMAP3 ES2+ chips have both initiator and

 * target IDLEST bits.  For our purposes, we are concerned with the

 * target IDLEST bits, which exist at a different bit position than

 * the *CLKEN bit position for these modules (DSS and USBHOST) (The

 * default find_idlest code assumes that they are at the same

 * position.)  No return value.

 USBHOST_IDLE has same shift */

/**

 * omap3430es2_clk_hsotgusb_find_idlest - return CM_IDLEST info for HSOTGUSB

 * @clk: struct clk * being enabled

 * @idlest_reg: void __iomem ** to store CM_IDLEST reg address into

 * @idlest_bit: pointer to a u8 to store the CM_IDLEST bit shift into

 * @idlest_val: pointer to a u8 to store the CM_IDLEST indicator

 *

 * The OMAP3430ES2 HSOTGUSB target CM_IDLEST bit is at a different

 * shift from the CM_{I,F}CLKEN bit.  Pass back the correct info via

 * @idlest_reg and @idlest_bit.  No return value.

/**

 * am35xx_clk_find_idlest - return clock ACK info for AM35XX IPSS

 * @clk: struct clk * being enabled

 * @idlest_reg: void __iomem ** to store CM_IDLEST reg address into

 * @idlest_bit: pointer to a u8 to store the CM_IDLEST bit shift into

 * @idlest_val: pointer to a u8 to store the CM_IDLEST indicator

 *

 * The interface clocks on AM35xx IPSS reflects the clock idle status

 * in the enable register itsel at a bit offset of 4 from the enable

 * bit. A value of 1 indicates that clock is enabled.

/**

 * am35xx_clk_find_companion - find companion clock to @clk

 * @clk: struct clk * to find the companion clock of

 * @other_reg: void __iomem ** to return the companion clock CM_*CLKEN va in

 * @other_bit: u8 ** to return the companion clock bit shift in

 *

 * Some clocks don't have companion clocks.  For example, modules with

 * only an interface clock (such as HECC) don't have a companion

 * clock.  Right now, this code relies on the hardware exporting a bit

 * in the correct companion register that indicates that the

 * nonexistent 'companion clock' is active.  Future patches will

 * associate this type of code with per-module data structures to

 * avoid this issue, and remove the casts.  No return value.

/**

 * am35xx_clk_ipss_find_idlest - return CM_IDLEST info for IPSS

 * @clk: struct clk * being enabled

 * @idlest_reg: void __iomem ** to store CM_IDLEST reg address into

 * @idlest_bit: pointer to a u8 to store the CM_IDLEST bit shift into

 * @idlest_val: pointer to a u8 to store the CM_IDLEST indicator

 *

 * The IPSS target CM_IDLEST bit is at a different shift from the

 * CM_{I,F}CLKEN bit.  Pass back the correct info via @idlest_reg

 * and @idlest_bit.  No return value.

/**

 * omap3_clk_lock_dpll5 - locks DPLL5

 *

 * Locks DPLL5 to a pre-defined frequency. This is required for proper

 * operation of USB.

	/*

	 * Errata sprz319f advisory 2.1 documents a USB host clock drift issue

	 * that can be worked around using specially crafted dpll5 settings

	 * with a dpll5_m2 divider set to 8. Set the dpll5 rate to 8x the USB

	 * host clock rate, its .set_rate handler() will detect that frequency

	 * and use the errata settings.

 Program dpll5_m2_clk divider */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * DRA7 Clock init

 *

 * Copyright (C) 2013 Texas Instruments, Inc.

 *

 * Tero Kristo (t-kristo@ti.com)

/*

 * TI composite clock support

 *

 * Copyright (C) 2013 Texas Instruments, Inc.

 *

 * Tero Kristo <t-kristo@ti.com>

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License version 2 as

 * published by the Free Software Foundation.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

 Check for presence of each component clock */

 Mark this node as found */

 All components exists, proceed with registration */

 Free component clock list entries */

 Number of component clocks to be put inside this clock */

 Get device node pointers for each component clock */

/**

 * ti_clk_add_component - add a component clock to the pool

 * @node: device node of the component clock

 * @hw: hardware clock definition for the component clock

 * @type: type of the component clock

 *

 * Adds a component clock to the list of available components, so that

 * it can be registered by a composite clock.

/*

 * Default clock type

 *

 * Copyright (C) 2005-2008, 2015 Texas Instruments, Inc.

 * Copyright (C) 2004-2010 Nokia Corporation

 *

 * Contacts:

 * Richard Woodruff <r-woodruff2@ti.com>

 * Paul Walmsley

 * Tero Kristo <t-kristo@ti.com>

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License version 2 as

 * published by the Free Software Foundation.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

/*

 * MAX_MODULE_ENABLE_WAIT: maximum of number of microseconds to wait

 * for a module to indicate that it is no longer in idle

/*

 * CM module register offsets, used for calculating the companion

 * register addresses.

/**

 * _wait_idlest_generic - wait for a module to leave the idle state

 * @clk: module clock to wait for (needed for register offsets)

 * @reg: virtual address of module IDLEST register

 * @mask: value to mask against to determine if the module is active

 * @idlest: idle state indicator (0 or 1) for the clock

 * @name: name of the clock (for printk)

 *

 * Wait for a module to leave idle, where its idle-status register is

 * not inside the CM module.  Returns 1 if the module left idle

 * promptly, or 0 if the module did not leave idle before the timeout

 * elapsed.  XXX Deprecated - should be moved into drivers for the

 * individual IP block that the IDLEST register exists in.

 Wait until module enters enabled state */

/**

 * _omap2_module_wait_ready - wait for an OMAP module to leave IDLE

 * @clk: struct clk * belonging to the module

 *

 * If the necessary clocks for the OMAP hardware IP block that

 * corresponds to clock @clk are enabled, then wait for the module to

 * indicate readiness (i.e., to leave IDLE).  This code does not

 * belong in the clock code and will be moved in the medium term to

 * module-dependent code.  No return value.

 Not all modules have multiple clocks that their IDLEST depends on */

 IDLEST register not in the CM module */

/**

 * omap2_clk_dflt_find_companion - find companion clock to @clk

 * @clk: struct clk * to find the companion clock of

 * @other_reg: void __iomem ** to return the companion clock CM_*CLKEN va in

 * @other_bit: u8 ** to return the companion clock bit shift in

 *

 * Note: We don't need special code here for INVERT_ENABLE for the

 * time being since INVERT_ENABLE only applies to clocks enabled by

 * CM_CLKEN_PLL

 *

 * Convert CM_ICLKEN* <-> CM_FCLKEN*.  This conversion assumes it's

 * just a matter of XORing the bits.

 *

 * Some clocks don't have companion clocks.  For example, modules with

 * only an interface clock (such as MAILBOXES) don't have a companion

 * clock.  Right now, this code relies on the hardware exporting a bit

 * in the correct companion register that indicates that the

 * nonexistent 'companion clock' is active.  Future patches will

 * associate this type of code with per-module data structures to

 * avoid this issue, and remove the casts.  No return value.

	/*

	 * Convert CM_ICLKEN* <-> CM_FCLKEN*.  This conversion assumes

	 * it's just a matter of XORing the bits.

/**

 * omap2_clk_dflt_find_idlest - find CM_IDLEST reg va, bit shift for @clk

 * @clk: struct clk * to find IDLEST info for

 * @idlest_reg: void __iomem ** to return the CM_IDLEST va in

 * @idlest_bit: u8 * to return the CM_IDLEST bit shift in

 * @idlest_val: u8 * to return the idle status indicator

 *

 * Return the CM_IDLEST register address and bit shift corresponding

 * to the module that "owns" this clock.  This default code assumes

 * that the CM_IDLEST bit shift is the CM_*CLKEN bit shift, and that

 * the IDLEST register address ID corresponds to the CM_*CLKEN

 * register address ID (e.g., that CM_FCLKEN2 corresponds to

 * CM_IDLEST2).  This is not true for all modules.  No return value.

	/*

	 * 24xx uses 0 to indicate not ready, and 1 to indicate ready.

	 * 34xx reverses this, just to keep us on our toes

	 * AM35xx uses both, depending on the module.

/**

 * omap2_dflt_clk_enable - enable a clock in the hardware

 * @hw: struct clk_hw * of the clock to enable

 *

 * Enable the clock @hw in the hardware.  We first call into the OMAP

 * clockdomain code to "enable" the corresponding clockdomain if this

 * is the first enabled user of the clockdomain.  Then program the

 * hardware to enable the clock.  Then wait for the IP block that uses

 * this clock to leave idle (if applicable).  Returns the error value

 * from clkdm_clk_enable() if it terminated with an error, or -EINVAL

 * if @hw has a null clock enable_reg, or zero upon success.

 FIXME should not have INVERT_ENABLE bit here */

 OCP barrier */

/**

 * omap2_dflt_clk_disable - disable a clock in the hardware

 * @hw: struct clk_hw * of the clock to disable

 *

 * Disable the clock @hw in the hardware, and call into the OMAP

 * clockdomain code to "disable" the corresponding clockdomain if all

 * clocks/hwmods in that clockdomain are now disabled.  No return

 * value.

 No OCP barrier needed here since it is a disable operation */

/**

 * omap2_dflt_clk_is_enabled - is clock enabled in the hardware?

 * @hw: struct clk_hw * to check

 *

 * Return 1 if the clock represented by @hw is enabled in the

 * hardware, or 0 otherwise.  Intended for use in the struct

 * clk_ops.is_enabled function pointer.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * DRA7 Clock init

 *

 * Copyright (C) 2013 Texas Instruments, Inc.

 *

 * Tero Kristo (t-kristo@ti.com)

/*

 * AM43XX Clock init

 *

 * Copyright (C) 2013 Texas Instruments, Inc

 *     Tero Kristo (t-kristo@ti.com)

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License as

 * published by the Free Software Foundation version 2.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the

 * GNU General Public License for more details.

 AM4_L3_L3_MAIN_CLKCTRL, needed during suspend */

	/*

	 * cpsw_cpts_rft_clk  has got the choice of 3 clocksources

	 * dpll_core_m4_ck, dpll_core_m5_ck and dpll_disp_m2_ck.

	 * By default dpll_core_m4_ck is selected, witn this as clock

	 * source the CPTS doesnot work properly. It gives clockcheck errors

	 * while running PTP.

	 * clockcheck: clock jumped backward or running slower than expected!

	 * By selecting dpll_core_m5_ck as the clocksource fixes this issue.

	 * In AM335x dpll_core_m5_ck is the default clocksource.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * OMAP4-specific DPLL control functions

 *

 * Copyright (C) 2011 Texas Instruments, Inc.

 * Rajendra Nayak

/*

 * Maximum DPLL input frequency (FINT) and output frequency (FOUT) that

 * can supported when using the DPLL low-power mode. Frequencies are

 * defined in OMAP4430/60 Public TRM section 3.6.3.3.2 "Enable Control,

 * Status, and Low-Power Operation Mode".

/*

 * Bitfield declarations

 Static rate multiplier for OMAP4 REGM4XEN clocks */

 Clear the bit to allow gatectrl */

 Set the bit to deny gatectrl */

/**

 * omap4_dpll_lpmode_recalc - compute DPLL low-power setting

 * @dd: pointer to the dpll data structure

 *

 * Calculates if low-power mode can be enabled based upon the last

 * multiplier and divider values calculated. If low-power mode can be

 * enabled, then the bit to enable low-power mode is stored in the

 * last_rounded_lpmode variable. This implementation is based upon the

 * criteria for enabling low-power mode as described in the OMAP4430/60

 * Public TRM section 3.6.3.3.2 "Enable Control, Status, and Low-Power

 * Operation Mode".

/**

 * omap4_dpll_regm4xen_recalc - compute DPLL rate, considering REGM4XEN bit

 * @hw: pointer to the clock to compute the rate for

 * @parent_rate: clock rate of the DPLL parent

 *

 * Compute the output rate for the OMAP4 DPLL represented by @clk.

 * Takes the REGM4XEN bit into consideration, which is needed for the

 * OMAP4 ABE DPLL.  Returns the DPLL's output rate (before M-dividers)

 * upon success, or 0 upon error.

 regm4xen adds a multiplier of 4 to DPLL calculations */

/**

 * omap4_dpll_regm4xen_round_rate - round DPLL rate, considering REGM4XEN bit

 * @hw: struct hw_clk containing the struct clk * of the DPLL to round a rate for

 * @target_rate: the desired rate of the DPLL

 * @parent_rate: clock rate of the DPLL parent

 *

 * Compute the rate that would be programmed into the DPLL hardware

 * for @clk if set_rate() were to be provided with the rate

 * @target_rate.  Takes the REGM4XEN bit into consideration, which is

 * needed for the OMAP4 ABE DPLL.  Returns the rounded rate (before

 * M-dividers) upon success, -EINVAL if @clk is null or not a DPLL, or

 * ~0 if an error occurred in omap2_dpll_round_rate().

	/*

	 * First try to compute the DPLL configuration for

	 * target rate without using the 4X multiplier.

	/*

	 * If we did not find a valid DPLL configuration, try again, but

	 * this time see if using the 4X multiplier can help. Enabling the

	 * 4X multiplier is equivalent to dividing the target rate by 4.

/**

 * omap4_dpll_regm4xen_determine_rate - determine rate for a DPLL

 * @hw: pointer to the clock to determine rate for

 * @req: target rate request

 *

 * Determines which DPLL mode to use for reaching a desired rate.

 * Checks whether the DPLL shall be in bypass or locked mode, and if

 * locked, calculates the M,N values for the DPLL via round-rate.

 * Returns 0 on success and a negative error value otherwise.

/*

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License as

 * published by the Free Software Foundation version 2.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the

 * GNU General Public License for more details.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * OMAP3/4 - specific DPLL control functions

 *

 * Copyright (C) 2009-2010 Texas Instruments, Inc.

 * Copyright (C) 2009-2010 Nokia Corporation

 *

 * Written by Paul Walmsley

 * Testing and integration fixes by Jouni Högander

 *

 * 36xx support added by Vishwanath BS, Richard Woodruff, and Nishanth

 * Menon

 *

 * Parts of this code are based on code written by

 * Richard Woodruff, Tony Lindgren, Tuukka Tikkanen, Karthik Dasu

 CM_AUTOIDLE_PLL*.AUTO_* bit values */

 Forward declarations */

 Private functions */

 _omap3_dpll_write_clken - write clken_bits arg to a DPLL's enable bits */

 _omap3_wait_dpll_status: wait for a DPLL to enter a specific state */

 From 3430 TRM ES2 4.7.6.2 */

/**

 * _omap3_noncore_dpll_lock - instruct a DPLL to lock and wait for readiness

 * @clk: pointer to a DPLL struct clk

 *

 * Instructs a non-CORE DPLL to lock.  Waits for the DPLL to report

 * readiness before returning.  Will save and restore the DPLL's

 * autoidle state across the enable, per the CDP code.  If the DPLL

 * locked successfully, return 0; if the DPLL did not lock in the time

 * allotted, or DPLL3 was passed in, return -EINVAL.

 Check if already locked */

/**

 * _omap3_noncore_dpll_bypass - instruct a DPLL to bypass and wait for readiness

 * @clk: pointer to a DPLL struct clk

 *

 * Instructs a non-CORE DPLL to enter low-power bypass mode.  In

 * bypass mode, the DPLL's rate is set equal to its parent clock's

 * rate.  Waits for the DPLL to report readiness before returning.

 * Will save and restore the DPLL's autoidle state across the enable,

 * per the CDP code.  If the DPLL entered bypass mode successfully,

 * return 0; if the DPLL did not enter bypass in the time allotted, or

 * DPLL3 was passed in, or the DPLL does not support low-power bypass,

 * return -EINVAL.

/**

 * _omap3_noncore_dpll_stop - instruct a DPLL to stop

 * @clk: pointer to a DPLL struct clk

 *

 * Instructs a non-CORE DPLL to enter low-power stop. Will save and

 * restore the DPLL's autoidle state across the stop, per the CDP

 * code.  If DPLL3 was passed in, or the DPLL does not support

 * low-power stop, return -EINVAL; otherwise, return 0.

/**

 * _lookup_dco - Lookup DCO used by j-type DPLL

 * @clk: pointer to a DPLL struct clk

 * @dco: digital control oscillator selector

 * @m: DPLL multiplier to set

 * @n: DPLL divider to set

 *

 * See 36xx TRM section 3.5.3.3.3.2 "Type B DPLL (Low-Jitter)"

 *

 * XXX This code is not needed for 3430/AM35xx; can it be optimized

 * out in non-multi-OMAP builds for those chips?

 watch out for overflow */

/**

 * _lookup_sddiv - Calculate sigma delta divider for j-type DPLL

 * @clk: pointer to a DPLL struct clk

 * @sd_div: target sigma-delta divider

 * @m: DPLL multiplier to set

 * @n: DPLL divider to set

 *

 * See 36xx TRM section 3.5.3.3.3.2 "Type B DPLL (Low-Jitter)"

 *

 * XXX This code is not needed for 3430/AM35xx; can it be optimized

 * out in non-multi-OMAP builds for those chips?

 watch out for overflow */

	/*

	 * target sigma-delta to near 250MHz

	 * sd = ceil[(m/(n+1)) * (clkinp_MHz / 250)]

 shift from MHz to 10*Hz for 38.4 and 19.2 */

/**

 * omap3_noncore_dpll_ssc_program - set spread-spectrum clocking registers

 * @clk:	struct clk * of DPLL to set

 *

 * Enable the DPLL spread spectrum clocking if frequency modulation and

 * frequency spreading have been set, otherwise disable it.

/**

 * omap3_noncore_dpll_program - set non-core DPLL M,N values directly

 * @clk:	struct clk * of DPLL to set

 * @freqsel:	FREQSEL value to set

 *

 * Program the DPLL with the last M, N values calculated, and wait for

 * the DPLL to lock. Returns -EINVAL upon error, or 0 upon success.

 3430 ES2 TRM: 4.7.6.9 DPLL Programming Sequence */

	/*

	 * Set jitter correction. Jitter correction applicable for OMAP343X

	 * only since freqsel field is no longer present on other devices.

 Set DPLL multiplier, divider */

 Handle Duty Cycle Correction */

 Enable DCC */

 Disable DCC */

 Configure dco and sd_div for dplls that have these fields */

	/*

	 * Errata i810 - DPLL controller can get stuck while transitioning

	 * to a power saving state. Software must ensure the DPLL can not

	 * transition to a low power state while changing M/N values.

	 * Easiest way to accomplish this is to prevent DPLL autoidle

	 * before doing the M/N re-program.

 OCP barrier */

 Set 4X multiplier and low-power mode */

 We let the clock framework set the other output dividers later */

 REVISIT: Set ramp-up delay? */

 Public functions */

/**

 * omap3_dpll_recalc - recalculate DPLL rate

 * @hw: struct clk_hw containing the DPLL struct clk

 * @parent_rate: clock rate of the DPLL parent

 *

 * Recalculate and propagate the DPLL rate.

 Non-CORE DPLL (e.g., DPLLs that do not control SDRC) clock functions */

/**

 * omap3_noncore_dpll_enable - instruct a DPLL to enter bypass or lock mode

 * @hw: struct clk_hw containing then pointer to a DPLL struct clk

 *

 * Instructs a non-CORE DPLL to enable, e.g., to enter bypass or lock.

 * The choice of modes depends on the DPLL's programmed rate: if it is

 * the same as the DPLL's parent clock, it will enter bypass;

 * otherwise, it will enter lock.  This code will wait for the DPLL to

 * indicate readiness before returning, unless the DPLL takes too long

 * to enter the target state.  Intended to be used as the struct clk's

 * enable function.  If DPLL3 was passed in, or the DPLL does not

 * support low-power stop, or if the DPLL took too long to enter

 * bypass or lock, return -EINVAL; otherwise, return 0.

/**

 * omap3_noncore_dpll_disable - instruct a DPLL to enter low-power stop

 * @hw: struct clk_hw containing then pointer to a DPLL struct clk

 *

 * Instructs a non-CORE DPLL to enter low-power stop.  This function is

 * intended for use in struct clkops.  No return value.

 Non-CORE DPLL rate set code */

/**

 * omap3_noncore_dpll_determine_rate - determine rate for a DPLL

 * @hw: pointer to the clock to determine rate for

 * @req: target rate request

 *

 * Determines which DPLL mode to use for reaching a desired target rate.

 * Checks whether the DPLL shall be in bypass or locked mode, and if

 * locked, calculates the M,N values for the DPLL via round-rate.

 * Returns a 0 on success, negative error value in failure.

/**

 * omap3_noncore_dpll_set_parent - set parent for a DPLL clock

 * @hw: pointer to the clock to set parent for

 * @index: parent index to select

 *

 * Sets parent for a DPLL clock. This sets the DPLL into bypass or

 * locked mode. Returns 0 with success, negative error value otherwise.

/**

 * omap3_noncore_dpll_set_rate - set rate for a DPLL clock

 * @hw: pointer to the clock to set parent for

 * @rate: target rate for the clock

 * @parent_rate: rate of the parent clock

 *

 * Sets rate for a DPLL clock. First checks if the clock parent is

 * reference clock (in bypass mode, the rate of the clock can't be

 * changed) and proceeds with the rate change operation. Returns 0

 * with success, negative error value otherwise.

 Freqsel is available only on OMAP343X devices */

/**

 * omap3_noncore_dpll_set_rate_and_parent - set rate and parent for a DPLL clock

 * @hw: pointer to the clock to set rate and parent for

 * @rate: target rate for the DPLL

 * @parent_rate: clock rate of the DPLL parent

 * @index: new parent index for the DPLL, 0 - reference, 1 - bypass

 *

 * Sets rate and parent for a DPLL clock. If new parent is the bypass

 * clock, only selects the parent. Otherwise proceeds with a rate

 * change, as this will effectively also change the parent as the

 * DPLL is put into locked mode. Returns 0 with success, negative error

 * value otherwise.

	/*

	 * clk-ref at index[0], in which case we only need to set rate,

	 * the parent will be changed automatically with the lock sequence.

	 * With clk-bypass case we only need to change parent.

 DPLL autoidle read/set code */

/**

 * omap3_dpll_autoidle_read - read a DPLL's autoidle bits

 * @clk: struct clk * of the DPLL to read

 *

 * Return the DPLL's autoidle bits, shifted down to bit 0.  Returns

 * -EINVAL if passed a null pointer or if the struct clk does not

 * appear to refer to a DPLL.

/**

 * omap3_dpll_allow_idle - enable DPLL autoidle bits

 * @clk: struct clk * of the DPLL to operate on

 *

 * Enable DPLL automatic idle control.  This automatic idle mode

 * switching takes effect only when the DPLL is locked, at least on

 * OMAP3430.  The DPLL will enter low-power stop when its downstream

 * clocks are gated.  No return value.

	/*

	 * REVISIT: CORE DPLL can optionally enter low-power bypass

	 * by writing 0x5 instead of 0x1.  Add some mechanism to

	 * optionally enter this mode.

/**

 * omap3_dpll_deny_idle - prevent DPLL from automatically idling

 * @clk: struct clk * of the DPLL to operate on

 *

 * Disable DPLL automatic idle control.  No return value.

 Clock control for DPLL outputs */

 Find the parent DPLL for the given clkoutx2 clock */

 Walk up the parents of clk, looking for a DPLL */

 clk does not have a DPLL as a parent?  error in the clock data */

/**

 * omap3_clkoutx2_recalc - recalculate DPLL X2 output virtual clock rate

 * @hw: pointer  struct clk_hw

 * @parent_rate: clock rate of the DPLL parent

 *

 * Using parent clock DPLL data, look up DPLL state.  If locked, set our

 * rate to the dpll_clk * 2; otherwise, just use dpll_clk.

/**

 * omap3_core_dpll_save_context - Save the m and n values of the divider

 * @hw: pointer  struct clk_hw

 *

 * Before the dpll registers are lost save the last rounded rate m and n

 * and the enable mask.

/**

 * omap3_core_dpll_restore_context - restore the m and n values of the divider

 * @hw: pointer  struct clk_hw

 *

 * Restore the last rounded rate m and n

 * and the enable mask.

/**

 * omap3_non_core_dpll_save_context - Save the m and n values of the divider

 * @hw: pointer  struct clk_hw

 *

 * Before the dpll registers are lost save the last rounded rate m and n

 * and the enable mask.

/**

 * omap3_core_dpll_restore_context - restore the m and n values of the divider

 * @hw: pointer  struct clk_hw

 *

 * Restore the last rounded rate m and n

 * and the enable mask.

 nothing to be done */

 OMAP3/4 non-CORE DPLL clkops */

/**

 * omap3_dpll4_set_rate - set rate for omap3 per-dpll

 * @hw: clock to change

 * @rate: target rate for clock

 * @parent_rate: clock rate of the DPLL parent

 *

 * Check if the current SoC supports the per-dpll reprogram operation

 * or not, and then do the rate change if supported. Returns -EINVAL

 * if not supported, 0 for success, and potential error codes from the

 * clock rate change.

	/*

	 * According to the 12-5 CDP code from TI, "Limitation 2.5"

	 * on 3430ES1 prevents us from changing DPLL multipliers or dividers

	 * on DPLL4.

/**

 * omap3_dpll4_set_rate_and_parent - set rate and parent for omap3 per-dpll

 * @hw: clock to change

 * @rate: target rate for clock

 * @parent_rate: rate of the parent clock

 * @index: parent index, 0 - reference clock, 1 - bypass clock

 *

 * Check if the current SoC support the per-dpll reprogram operation

 * or not, and then do the rate + parent change if supported. Returns

 * -EINVAL if not supported, 0 for success, and potential error codes

 * from the clock rate change.

 Apply DM3730 errata sprz319 advisory 2.1. */

		/*

		 * From DM3730 errata advisory 2.1, table 35 and 36.

		 * The N value is increased by 1 compared to the tables as the

		 * errata lists register values while last_rounded_field is the

		 * real divider value.

 Update the M, N and rounded rate values and program the DPLL. */

/**

 * omap3_dpll5_set_rate - set rate for omap3 dpll5

 * @hw: clock to change

 * @rate: target rate for clock

 * @parent_rate: rate of the parent clock

 *

 * Set rate for the DPLL5 clock. Apply the sprz319 advisory 2.1 on OMAP36xx if

 * the DPLL is used for USB host (detected through the requested rate).

/*

 * OMAP clkctrl clock support

 *

 * Copyright (C) 2017 Texas Instruments, Inc.

 *

 * Tero Kristo <t-kristo@ti.com>

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License version 2 as

 * published by the Free Software Foundation.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

 These timeouts are in us */

	/*

	 * There are two special cases where ktime_to_ns() can't be

	 * used to track the timeouts. First one is during early boot

	 * when the timers haven't been initialized yet. The second

	 * one is during suspend-resume cycle while timekeeping is

	 * being suspended / resumed. Clocksource for the system

	 * can be from a timer that requires pm_runtime access, which

	 * will eventually bring us here with timekeeping_suspended,

	 * during both suspend entry and resume paths. This happens

	 * at least on am43xx platform. Account for flakeyness

	 * with udelay() by multiplying the timeout value by 2.

 Wait until module is enabled */

 Wait until module is disabled */

 Get clkctrl clock base name based on clkctrl_name or dts node */

 l4per-clkctrl:1234:0 style naming based on clkctrl_name */

 l4per:1234:0 old style naming based on clkctrl_name */

 l4per_cm:1234:0 old style naming based on parent node name */

 l4per-clkctrl:1234:0 style naming based on node name */

 Get clock name based on compatible string for clkctrl */

 Two letter minimum name length for l3, l4 etc */

	/*

	 * The code below can be removed when all clkctrl nodes use domain

	 * specific compatible proprerty and standard clock node naming

		/*

		 * Create default clkdm name, replace _cm from end of parent

		 * node name with _clkdm

		/*

		 * Create default clkdm name, replace _clkctrl from end of

		 * node name with _clkdm

 Replace any dash from the clkdm name with underscore */

 Generate clocks */

/**

 * ti_clk_is_in_standby - Check if clkctrl clock is in standby or not

 * @clk: clock to check standby status for

 *

 * Finds whether the provided clock is in standby mode or not. Returns

 * true if the provided clock is a clkctrl type clock and it is in standby,

 * false otherwise.

/*

 * TI Divider Clock

 *

 * Copyright (C) 2013 Texas Instruments, Inc.

 *

 * Tero Kristo <t-kristo@ti.com>

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License version 2 as

 * published by the Free Software Foundation.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

/*

 * The reverse of DIV_ROUND_UP: The maximum number which

 * divided by m is r

	/*

	 * The maximum divider we can use without overflowing

	 * unsigned long in rate * i below

			/*

			 * It's the most ideal case if the requested rate can be

			 * divided from parent clock without needing to change

			 * parent rate, so return the divider immediately.

/**

 * clk_divider_save_context - Save the divider value

 * @hw: pointer  struct clk_hw

 *

 * Save the divider value

/**

 * clk_divider_restore_context - restore the saved the divider value

 * @hw: pointer  struct clk_hw

 *

 * Restore the saved the divider value

 register the clock */

 Determine required size for divider table */

 Clk divider table not provided, determine min/max divs */

/**

 * of_ti_divider_clk_setup - Setup function for simple div rate clock

 * @node: device node for this clock

 *

 * Sets up a basic divider clock.

 SPDX-License-Identifier: GPL-2.0-only

 MPU 481c5040.adpll.clkout */

 DDR 481c5290.adpll.clkout */

/*

 * OMAP interface clock support

 *

 * Copyright (C) 2013 Texas Instruments, Inc.

 *

 * Tero Kristo <t-kristo@ti.com>

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License version 2 as

 * published by the Free Software Foundation.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

/*

 * OMAP clockdomain support

 *

 * Copyright (C) 2013 Texas Instruments, Inc.

 *

 * Tero Kristo <t-kristo@ti.com>

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License version 2 as

 * published by the Free Software Foundation.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

/**

 * omap2_clkops_enable_clkdm - increment usecount on clkdm of @hw

 * @hw: struct clk_hw * of the clock being enabled

 *

 * Increment the usecount of the clockdomain of the clock pointed to

 * by @hw; if the usecount is 1, the clockdomain will be "enabled."

 * Only needed for clocks that don't use omap2_dflt_clk_enable() as

 * their enable function pointer.  Passes along the return value of

 * clkdm_clk_enable(), -EINVAL if @hw is not associated with a

 * clockdomain, or 0 if clock framework-based clockdomain control is

 * not implemented.

/**

 * omap2_clkops_disable_clkdm - decrement usecount on clkdm of @hw

 * @hw: struct clk_hw * of the clock being disabled

 *

 * Decrement the usecount of the clockdomain of the clock pointed to

 * by @hw; if the usecount is 0, the clockdomain will be "disabled."

 * Only needed for clocks that don't use omap2_dflt_clk_disable() as their

 * disable function pointer.  No return value.

/**

 * omap2_init_clk_clkdm - look up a clockdomain name, store pointer in clk

 * @hw: Pointer to clk_hw_omap used to obtain OMAP clock struct ptr to use

 *

 * Convert a clockdomain name stored in a struct clk 'clk' into a

 * clockdomain pointer, and save it into the struct clk.  Intended to be

 * called during clk_register(). Returns 0 on success, -EERROR otherwise.

/**

 * ti_dt_clockdomains_setup - setup device tree clockdomains

 *

 * Initializes clockdomain nodes for a SoC. This parses through all the

 * nodes with compatible = "ti,clockdomain", and add the clockdomain

 * info for all the clocks listed under these. This function shall be

 * called after rest of the DT clock init has completed and all

 * clock nodes have been registered.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2012 Sascha Hauer <kernel@pengutronix.de>

 default */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2012-2013 Freescale Semiconductor, Inc.

 sources for multiplexer clocks, this is used multiple times */

 FTM counter clock source, not module clock */

 Backward compatibility if device tree is missing clks assignments */

 Clock source from external clock via LVDs PAD */

 Do not bypass PLLs initially */

	/*

	 * ftm_ext_clk and ftm_fix_clk are FTM timer counter's

	 * selectable clock sources, both use a common enable bit

	 * in CCM_CSCDR1, selecting "dummy" clock as parent of

	 * "ftm0_ext_fix" make it serve only for enable/disable.

 ftm(n)_clk are FTM module operation clock */

 Add the clocks to provider list */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2015 Freescale Semiconductor, Inc.

 epdc_pre_sels, epdc_sels, esai_sels only exists on i.MX6ULL */

 ipp_di clock is external input */

 Do not bypass PLLs initially */

	/*

	 * Bit 20 is the reserved and read-only bit, we do this only for:

	 * - Do nothing for usbphy clk_enable/disable

	 * - Keep refcount when do usbphy clk_enable/disable, in that case,

	 * the clk framework many need to enable/disable usbphy's parent

	/*

	 * usbphy*_gate needs to be on after system boots up, and software

	 * never needs to control it anymore.

					name		   parent_name	   reg		idx */

						   name		parent_name	 mult  div */

 CCGR0 */

 CCGR1 */

 CCGR2 */

 CCGR3 */

	/*

	 * Although the imx6ull reference manual lists CCGR2 as the csi clk

	 * gate register, tests have shown that it is actually the CCGR3

	 * register bit 0/1, same as for the imx6ul.

 CCGR4 */

 CCGR5 */

 CCGR6 */

 CCOSR */

 mask handshake of mmdc */

	/*

	 * Lower the AHB clock rate before changing the parent clock source,

	 * as AHB clock rate can NOT be higher than 133MHz, but its parent

	 * will be switched from 396MHz PFD to 528MHz PLL in order to increase

	 * AXI clock rate, so we need to lower AHB rate first to make sure at

	 * any time, AHB rate is <= 133MHz.

 Change periph_pre clock to pll2_bus to adjust AXI rate to 264MHz */

 Make sure AHB rate is 132MHz  */

 set perclk to from OSC */

 SPDX-License-Identifier: GPL-2.0+

/*

 * Copyright 2021 NXP

 Set to imx_ccm_lock to protect register access shared with clock control */

 CGC1 */

 CGC2 */

 PCC3 */

 register the pcc3 reset controller */

 PCC4 */

 sai ipg, NOT from sai sel */

 sai ipg */

 register the pcc4 reset controller */

 PCC5 */

 register the pcc5 reset controller */

 sentinel */ },

 SPDX-License-Identifier: GPL-2.0

/*

 * This fixups the register CCM_CSCMR1 write value.

 * The write/read/divider values of the aclk_podf field

 * of that register have the relationship described by

 * the following table:

 *

 * write value       read value        divider

 * 3b'000            3b'110            7

 * 3b'001            3b'111            8

 * 3b'010            3b'100            5

 * 3b'011            3b'101            6

 * 3b'100            3b'010            3

 * 3b'101            3b'011            4

 * 3b'110            3b'000            1

 * 3b'111            3b'001            2(default)

 *

 * That's why we do the xor operation below.

 i.MX boards use device trees now.  For build tests without CONFIG_OF, do nothing */

 Stop if there are no more of_stdout references */

 Only enable the clock if it's not NULL */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2013 Freescale Semiconductor, Inc.

/**

 * struct clk_fixup_mux - imx integer fixup multiplexer clock

 * @mux: the parent class

 * @ops: pointer to clk_ops of parent class

 * @fixup: a hook to fixup the write value

 *

 * The imx fixup multiplexer clock is a subclass of basic clk_mux

 * with an addtional fixup hook.

 SPDX-License-Identifier: GPL-2.0

/**

 * pll v1

 *

 * @clk_hw	clock source

 * @parent	the parent clock name

 * @base	base address of pll registers

 *

 * PLL clock version 1, found on i.MX1/21/25/27/31/35

	/*

	 * Get the resulting clock rate from a PLL register value and the input

	 * frequency. PLLs with this register layout can be found on i.MX1,

	 * i.MX21, i.MX27 and i,MX31

	 *

	 *                  mfi + mfn / (mfd + 1)

	 *  f = 2 * f_ref * --------------------

	 *                        pd + 1

	/*

	 * On all i.MXs except i.MX1 and i.MX21 mfn is a 10bit

	 * 2's complements number.

	 * On i.MX27 the bit 9 is the sign bit.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright 2019 NXP.

 CORE SEL */

 Sentinel */ }

		/*

		 * Disable bind attributes: clocks are not removed and

		 * reloading the driver will crash or break devices.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2011-2013 Freescale Semiconductor, Inc.

 * Copyright 2011 Linaro Ltd.

 sentinel */ }

 sentinel */ }

 sentinel */ }

 skip empty (null) phandles */

 PLL6 bypass is not part of the assigned clock list */

/*

 * The only way to disable the MMDC_CH1 clock is to move it to pll3_sw_clk

 * via periph2_clk2_sel and then to disable pll3_sw_clk by selecting the

 * bypass clock source, since there is no CG bit for mmdc_ch1.

 Disable pll3_sw_clk by selecting the bypass clock source */

 Enable pll3_sw_clk by disabling the bypass */

/*

 * We have to follow a strict procedure when changing the LDB clock source,

 * otherwise we risk introducing a glitch that can lock up the LDB divider.

 * Things to keep in mind:

 *

 * 1. The current and new parent clock inputs to the mux must be disabled.

 * 2. The default clock input for ldb_di0/1_clk_sel is mmdc_ch1_axi, which

 *    has no CG bit.

 * 3. pll2_pfd2_396m can not be gated if it is used as memory clock.

 * 4. In the RTL implementation of the LDB_DI_CLK_SEL muxes the top four

 *    options are in one mux and the PLL3 option along with three unused

 *    inputs is in a second mux. There is a third mux with two inputs used

 *    to decide between the first and second 4-port mux:

 *

 *    pll5_video_div 0 --|\

 *    pll2_pfd0_352m 1 --| |_

 *    pll2_pfd2_396m 2 --| | `-|\

 *    mmdc_ch1_axi   3 --|/    | |

 *                             | |--

 *    pll3_usb_otg   4 --|\    | |

 *                   5 --| |_,-|/

 *                   6 --| |

 *                   7 --|/

 *

 * The ldb_di0/1_clk_sel[1:0] bits control both 4-port muxes at the same time.

 * The ldb_di0/1_clk_sel[2] bit controls the 2-port mux. The code below

 * switches the parent to the bottom mux first and then manipulates the top

 * mux to ensure that no glitch will enter the divider.

 Print a notice if a glitch might have been introduced already */

 Only switch to or from pll2_pfd2_396m if it is disabled */

 First switch to the bottom mux */

 Then configure the top mux before switching back to it */

 Make sure PLL2 PFDs 0-2 are gated */

 Cannot gate PFD2 if pll2_pfd2_396m is the parent of MMDC clock */

 Make sure PLL3 PFDs 0-3 are gated */

 Make sure PLL5 is disabled */

 Clock source from external clock via CLK1/2 PADs */

 Audio/video PLL post dividers do not work on i.MX6q revision 1.0 */

                                    type               name    parent_name        base         div_mask */

 Do not bypass PLLs initially */

	/*

	 * Bit 20 is the reserved and read-only bit, we do this only for:

	 * - Do nothing for usbphy clk_enable/disable

	 * - Keep refcount when do usbphy clk_enable/disable, in that case,

	 * the clk framework may need to enable/disable usbphy's parent

	/*

	 * usbphy*_gate needs to be on after system boots up, and software

	 * never needs to control it anymore.

	/*

	 * The ENET PLL is special in that is has multiple outputs with

	 * different post-dividers that are all affected by the single bypass

	 * bit, so a single mux bit affects 3 independent branches of the clock

	 * tree. There is no good way to model this in the clock framework and

	 * dynamically changing the bypass bit, will yield unexpected results.

	 * So we treat any configuration that bypasses the ENET PLL as

	 * essentially static with the divider ratios reflecting the bypass

	 * status.

	 *

	/*

	 * lvds1_gate and lvds2_gate are pseudo-gates.  Both can be

	 * independently configured as clock inputs or outputs.  We treat

	 * the "output_enable" bit as a gate, even though it's really just

	 * enabling clock output. Initially the gate bits are cleared, as

	 * otherwise the exclusive configuration gets locked in the setup done

	 * by software running before the clock driver, with no way to change

	 * it.

                                            name              parent_name        reg       idx */

                                                name         parent_name     mult div */

                                              name                reg       shift width parent_names     num_parents */

		/*

		 * The LDB_DI0/1_SEL muxes are registered read-only due to a hardware

		 * bug. Set the muxes to the requested values before registering the

		 * ldb_di_sel clocks.

                                          name         reg      shift width busy: reg, shift parent_names  num_parents */

                                                  name                parent_name          reg       shift width */

                                                        name                 parent_name    reg        shift width busy: reg, shift */

                                            name             parent_name          reg         shift */

		/*

		 * The multiplexer and divider of the imx6q clock gpu2d get

		 * redefined/reused as mlb_sys_sel and mlb_sys_clk_podf on imx6dl.

	/*

	 * The gpt_3m clock is not available on i.MX6Q TO1.0.  Let's point it

	 * to clock gpt_ipg_per to ease the gpt driver code.

	/*

	 * The gpmi needs 100MHz frequency in the EDO/Sync mode,

	 * We can not get the 100MHz from the pll2_pfd0_352m.

	 * So choose pll2_pfd2_396m as enfc_sel's parent.

	/*

	 * Let's initially set up CLKO with OSC24M, since this configuration

	 * is widely used by imx6q board designs to clock audio codec.

 Audio-related clocks configuration */

 All existing boards with PCIe use LVDS1 */

	/*

	 * Initialize the GPU clock muxes, so that the maximum specified clock

	 * rates for the respective SoC are not exceeded.

 SPDX-License-Identifier: GPL-2.0+

/*

 * Copyright 2018 NXP

 *	Dong Aisheng <aisheng.dong@nxp.com>

/*

 * struct clk_lpcg_scu - Description of LPCG clock

 *

 * @hw: clk_hw of this LPCG

 * @reg: register of this LPCG clock

 * @bit_idx: bit index of this LPCG clock

 * @hw_gate: HW auto gate enable

 *

 * This structure describes one LPCG clock

 for state save&restore */

	/*

	 * FIXME: Sometimes writes don't work unless the CPU issues

	 * them twice

 SPDX-License-Identifier: GPL-2.0+

/*

 * Copyright 2019-2021 NXP

 *	Dong Aisheng <aisheng.dong@nxp.com>

 Keep sorted in the ascending order */

 SPDX-License-Identifier: GPL-2.0

 Register offsets */

 default */

 SPDX-License-Identifier: GPL-2.0+

/*

 * Copyright 2018-2021 NXP

 *	Dong Aisheng <aisheng.dong@nxp.com>

 ARM core */

 LSIO SS */

 DMA SS */

 Audio SS */

 Connectivity */

 Display controller SS */

 MIPI-LVDS SS */

 MIPI CSI SS */

 Parallel Interface SS */

 GPU SS */

 CM40 SS */

 CM41 SS */

 HDMI TX SS */

 HDMI RX SS */

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0+

/*

 * Copyright 2018-2021 NXP

 *   Dong Aisheng <aisheng.dong@nxp.com>

/*

 * struct clk_scu - Description of one SCU clock

 * @hw: the common clk_hw

 * @rsrc_id: resource ID of this SCU clock

 * @clk_type: type of this clock resource

 for state save&restore */

/*

 * struct clk_gpr_scu - Description of one SCU GPR clock

 * @hw: the common clk_hw

 * @rsrc_id: resource ID of this SCU clock

 * @gpr_id: GPR ID index to control the divider

/*

 * struct imx_sc_msg_req_set_clock_rate - clock set rate protocol

 * @hdr: SCU protocol header

 * @rate: rate to set

 * @resource: clock resource to set rate

 * @clk: clk type of this resource

 *

 * This structure describes the SCU protocol of clock rate set

/*

 * struct imx_sc_msg_get_clock_rate - clock get rate protocol

 * @hdr: SCU protocol header

 * @req: get rate request protocol

 * @resp: get rate response protocol

 *

 * This structure describes the SCU protocol of clock rate get

/*

 * struct imx_sc_msg_get_clock_parent - clock get parent protocol

 * @hdr: SCU protocol header

 * @req: get parent request protocol

 * @resp: get parent response protocol

 *

 * This structure describes the SCU protocol of clock get parent

/*

 * struct imx_sc_msg_set_clock_parent - clock set parent protocol

 * @hdr: SCU protocol header

 * @req: set parent request protocol

 *

 * This structure describes the SCU protocol of clock set parent

/*

 * struct imx_sc_msg_req_clock_enable - clock gate protocol

 * @hdr: SCU protocol header

 * @resource: clock resource to gate

 * @clk: clk type of this resource

 * @enable: whether gate off the clock

 * @autog: HW auto gate enable

 *

 * This structure describes the SCU protocol of clock gate

 pd_np will be used to attach power domains later */

/*

 * clk_scu_recalc_rate - Get clock rate for a SCU clock

 * @hw: clock to get rate for

 * @parent_rate: parent rate provided by common clock framework, not used

 *

 * Gets the current clock rate of a SCU clock. Returns the current

 * clock rate, or zero in failure.

/*

 * clk_scu_round_rate - Round clock rate for a SCU clock

 * @hw: clock to round rate for

 * @rate: rate to round

 * @parent_rate: parent rate provided by common clock framework, not used

 *

 * Returns the current clock rate, or zero in failure.

	/*

	 * Assume we support all the requested rate and let the SCU firmware

	 * to handle the left work

 CPU frequency scaling can ONLY be done by ARM-Trusted-Firmware */

/*

 * clk_scu_set_rate - Set rate for a SCU clock

 * @hw: clock to change rate for

 * @rate: target rate for the clock

 * @parent_rate: rate of the clock parent, not used for SCU clocks

 *

 * Sets a clock frequency for a SCU clock. Returns the SCU

 * protocol status.

/*

 * clk_scu_prepare - Enable a SCU clock

 * @hw: clock to enable

 *

 * Enable the clock at the DSC slice level

/*

 * clk_scu_unprepare - Disable a SCU clock

 * @hw: clock to enable

 *

 * Disable the clock at the DSC slice level

	/*

	 * Note on MX8, the clocks are tightly coupled with power domain

	 * that once the power domain is off, the clock status may be

	 * lost. So we make it NOCACHE to let user to retrieve the real

	 * clock status from HW instead of using the possible invalid

	 * cached rate.

 DC SS needs to handle bypass clock using non-cached clock rate */

 For API backwards compatiblilty, simply return NULL for success */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2009 by Sascha Hauer, Pengutronix

 CCM_CGCR0(17): reserved */

 CCM_CGCR0(29-31): reserved */

 CCM_CGCR1(0): reserved in datasheet, used as audmux in FSL kernel */

 CCM_CGCR1(12): reserved in datasheet, used as esai in FSL kernel */

 CCM_CGCR1(16): reserved in datasheet, used as gpio1 in FSL kernel */

 CCM_CGCR1(17): reserved in datasheet, used as gpio2 in FSL kernel */

 CCM_CGCR1(18): reserved in datasheet, used as gpio3 in FSL kernel */

 CCM_CGCR1(23): reserved in datasheet, used as i2c1 in FSL kernel */

 CCM_CGCR1(24): reserved in datasheet, used as i2c2 in FSL kernel */

 CCM_CGCR1(25): reserved in datasheet, used as i2c3 in FSL kernel */

 CCM_CGCR1(27): reserved in datasheet, used as iomuxc in FSL kernel */

 CCM_CGCR1(28): reserved in datasheet, used as kpp in FSL kernel */

 CCM_CGCR1(30): reserved in datasheet, used as owire in FSL kernel */

 CCM_CGCR2(4): reserved in datasheet, used as rtic in FSL kernel */

 CCM_CGCR2(19): reserved in datasheet, but used as wdt in FSL kernel */

 Clock source for gpt must be derived from AHB */

	/*

	 * Let's initially set up CLKO parent as ipg, since this configuration

	 * is used on some imx25 board designs to clock the audio codec.

 SPDX-License-Identifier: GPL-2.0+

/*

 * Copyright 2019-2021 NXP

 *	Dong Aisheng <aisheng.dong@nxp.com>

 Keep sorted in the ascending order */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2012 Freescale Semiconductor, Inc.

 * Copyright 2012 Linaro Ltd.

/**

 * struct clk_pfd - IMX PFD clock

 * @hw:		clock source

 * @reg:	PFD register address

 * @idx:	the index of PFD encoded in the register

 *

 * PFD clock found on i.MX6 series.  Each register for PFD has 4 clk_pfd

 * data encoded, and member idx is used to specify the one.  And each

 * register has SET, CLR and TOG registers at offset 0x4 0x8 and 0xc.

 SPDX-License-Identifier: GPL-2.0+

/*

 * Copyright (C) 2016 Freescale Semiconductor, Inc.

 * Copyright 2017~2018 NXP

 *

 * Author: Dong Aisheng <aisheng.dong@nxp.com>

 *

/**

 * struct clk_pfdv2 - IMX PFD clock

 * @hw:		clock source

 * @reg:	PFD register address

 * @gate_bit:	Gate bit offset

 * @vld_bit:	Valid bit offset

 * @frac_off:	PLL Fractional Divider offset

	/*

	 * PFD can NOT change rate without gating.

	 * as the PFDs may enabled in HW by default but no

	 * consumer used it, the enable count is '0', so the

	 * 'SET_RATE_GATE' can NOT help on blocking the set_rate

	 * ops especially for 'assigned-clock-xxx'. In order

	 * to simplify the case, just disable the PFD if it is

	 * enabled in HW but not in SW.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2011 Sascha Hauer, Pengutronix <s.hauer@pengutronix.de>

 Low-power Audio Playback Mode clock */

 This is used multiple times */

 dptc_core */, "dummy"
 wrck_clk_root */,

 pll1_ref_clk */,

 ddr_clk_root */,

 arm_axi_clk_root */, "dummy"
 lpsr_clk_root */, "dummy"
 tve_out */, "usb_phy_sel",

 spdif0_clk_root */,

 usbphy2_clk */, "dummy" 
 move usb phy clk to 24MHz */

	/*

	 * This clock is called periph_clk in the i.MX50 Reference Manual, but

	 * it comes closest in scope to the main_bus_clk of i.MX51 and i.MX53

 Set SDHC parents to be PLL2 */

 set SDHC root clock to 200MHZ*/

 set the usboh3 parent to pll2_sw */

 Set SDHC parents to be PLL2 */

 set SDHC root clock to 166.25MHZ*/

	/*

	 * Reference Manual says: Functionality of CCDR[18] and CLPCR[23] is no

	 * longer supported. Set to one for better power saving.

	 *

	 * The effect of not setting these bits is that MIPI clocks can't be

	 * enabled without the IPU clock being enabled aswell.

 Set SDHC parents to be PLL2 */

 set SDHC root clock to 200MHZ*/

 move can bus clk to 24MHz */

 make sure step clock is running from 24MHz */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2014 Freescale Semiconductor, Inc.

 ipp_di clock is external input */

 Clock source from external clock via CLK1/2 PAD */

                                    type               name    parent_name        base         div_mask */

 Do not bypass PLLs initially */

	/*

	 * Bit 20 is the reserved and read-only bit, we do this only for:

	 * - Do nothing for usbphy clk_enable/disable

	 * - Keep refcount when do usbphy clk_enable/disable, in that case,

	 * the clk framework may need to enable/disable usbphy's parent

	/*

	 * usbphy*_gate needs to be on after system boots up, and software

	 * never needs to control it anymore.

 FIXME 100MHz is used for pcie ref for all imx6 pcie, excepted imx6q */

                                       name              parent_name     reg           idx */

                                                name         parent_name       mult div */

                                                name                reg           shift   width   parent_names       num_parents */

                                                name                reg           shift   width   parent_names       num_parents */

                                                    name              parent_name          reg          shift width */

                                               name        reg          shift width busy: reg,   shift parent_names       num_parents */

                                                   name             parent_name    reg          shift width busy: reg,   shift */

                                            name             parent_name          reg         shift */

 CCGR0 */

 CCGR1 */

 CCGR2 */

 CCGR3 */

 CCGR4 */

 CCGR5 */

 CCGR6 */

 mask handshake of mmdc */

 Set the default 132MHz for EIM module */

 set parent clock for LCDIF1 pixel clock */

 Set the parent clks of PCIe lvds1 and pcie_axi to be pcie ref, axi */

	/*

	 * Init enet system AHB clock, set to 200MHz

	 * pll2_pfd2_396m-> ENET_PODF-> ENET_AHB

 Audio clocks */

 Set parent clock for vadc */

 default parent of can_sel clock is invalid, manually set it here */

 Update gpu clock from default 528M to 720M */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright 2018 NXP.

 *

 * This driver supports the fractional plls found in the imx8m SOCs

 *

 * Documentation for this fractional pll can be found at:

 *   https://www.nxp.com/docs/en/reference-manual/IMX8MDQLQRM.pdf#page=834

 return directly if the pll is in powerdown or in bypass */

 Wait for the pll's divfi and divff to be reloaded */

/*

 * To simplify the clock calculation, we can keep the 'PLL_OUTPUT_VAL' at zero

 * (means the PLL output will be divided by 2). So the PLL output can use

 * the below formula:

 * pllout = parent_rate * 8 / 2 * DIVF_VAL;

 * where DIVF_VAL = 1 + DIVFI + DIVFF / 2^24.

 Set the NEV_DIV_VAL to reload the DIVFI and DIVFF */

 clear the NEV_DIV_VAL */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright 2018 NXP.

 * Copyright (C) 2017 Pengutronix, Lucas Stach <kernel@pengutronix.de>

 CCM ROOT */

 PLL bypass out */

 PLL OUT GATE */

 SYS PLL1 fixed output */

 SYS PLL2 fixed output */

 CORE */

 For backwards compatibility */

 CORE SEL */

 BUS */

 AHB */

 AHB clock is used by the AHB bus therefore marked as critical */

 IPG */

	/*

	 * DRAM clocks are manipulated from TF-A outside clock framework.

	 * The fw_managed helper sets GET_RATE_NOCACHE and clears SET_PARENT_GATE

	 * as div value should always be read from hardware

 IP */

 Sentinel */ },

		/*

		 * Disable bind attributes: clocks are not removed and

		 * reloading the driver will crash or break devices.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2014-2015 Freescale Semiconductor, Inc.

 use old gpt clk setting, gpt1 root clk must be twice as gpt counter freq */

 Set clock rate for USBPHY, the USB_PLL at CCM is from USBOTG2 */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2013-2014 Freescale Semiconductor, Inc.

/*

 * ERR005311 CCM: After exit from WAIT mode, unwanted interrupt(s) taken

 *           during WAIT mode entry process could cause cache memory

 *           corruption.

 *

 * Software workaround:

 *     To prevent this issue from occurring, software should ensure that the

 * ARM to IPG clock ratio is less than 12:5 (that is < 2.4x), before

 * entering WAIT mode.

 *

 * This function will set the ARM clk to max value within the 12:5 limit.

 * As IPG clock is fixed at 66MHz(so ARM freq must not exceed 158.4MHz),

 * ARM freq are one of below setpoints: 396MHz, 792MHz and 996MHz, since

 * the clk APIs can NOT be called in idle thread(may cause kernel schedule

 * as there is sleep function in PLL wait function), so here we just slow

 * down ARM to below freq according to previous freq:

 *

 * run mode      wait mode

 * 396MHz   ->   132MHz;

 * 792MHz   ->   158.4MHz;

 * 996MHz   ->   142.3MHz;

	/*

	 * According to hardware design, arm podf change need

	 * PLL1 clock enabled.

 Clock source from external clock via CLK1 PAD */

                                    type               name    parent_name        base         div_mask */

 Do not bypass PLLs initially */

	/*

	 * usbphy1 and usbphy2 are implemented as dummy gates using reserve

	 * bit 20.  They are used by phy driver to keep the refcount of

	 * parent PLL correct. usbphy1_gate and usbphy2_gate only needs to be

	 * turned on during boot, and software will not need to control it

	 * anymore after that.

                                                           dev   name              parent_name      flags                reg        shift width div: flags, div_table lock */

                                       name         parent_name     reg           idx */

                                                name         parent_name     mult div */

                                              name                reg       shift width parent_names     num_parents */

                                          name       reg        shift width busy: reg, shift parent_names  num_parents */

                                                   name                 parent_name          reg       shift width */

                                                name         parent_name reg       shift width busy: reg, shift */

                                            name            parent_name          reg         shift */

 Ensure the MMDC CH0 handshake is bypassed */

 Ensure the AHB clk is at 132MHz. */

 Audio-related clocks configuration */

 set PLL5 video as lcdif pix parent clock */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2016 Freescale Semiconductor, Inc.

 * Copyright 2017-2018 NXP.

 ipp_di clock is external input */

 Do not bypass PLLs initially */

	/*

	 * Bit 20 is the reserved and read-only bit, we do this only for:

	 * - Do nothing for usbphy clk_enable/disable

	 * - Keep refcount when do usbphy clk_enable/disable, in that case,

	 * the clk framework many need to enable/disable usbphy's parent

	/*

	 * usbphy*_gate needs to be on after system boots up, and software

	 * never needs to control it anymore.

					name		   parent_name	   reg		idx */

						   name		parent_name	 mult  div */

 CCGR0 */

 CCGR1 */

 CCGR2 */

 CCGR3 */

 CCGR4 */

 CCGR5 */

 CCGR6 */

 mask handshake of mmdc */

 Lower the AHB clock rate before changing the clock source. */

 Change periph_pre clock to pll2_bus to adjust AXI rate to 264MHz */

 SPDX-License-Identifier: GPL-2.0+

/*

 * Copyright (C) 2016 Freescale Semiconductor, Inc.

 * Copyright 2017~2018 NXP

 *

 * Author: Dong Aisheng <aisheng.dong@nxp.com>

 *

 PLL Control Status Register (xPLLCSR) */

 PLL Configuration Register (xPLLCFG) */

 PLL Numerator Register (xPLLNUM) */

 PLL Denominator Register (xPLLDENOM) */

 Valid PLL MULT Table */

	/*

	 * NOTE: The value of numerator must always be configured to be

	 * less than the value of the denominator. If we can't get a proper

	 * pair of mfn/mfd, we simply return the round_rate without using

	 * the frac part.

 check if mult is in valid MULT table */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2014 Lucas Stach <l.stach@pengutronix.de>, Pengutronix

 switch to PLL bypass clock */

 reprogram PLL */

 switch back to PLL clock */

 Ensure the divider is what we expect */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2012 Freescale Semiconductor, Inc.

 * Copyright 2012 Linaro Ltd.

/**

 * struct clk_pllv3 - IMX PLL clock version 3

 * @hw:		clock source

 * @base:	 base address of PLL registers

 * @power_bit:	 pll power bit mask

 * @powerup_set: set power_bit to power up the PLL

 * @div_mask:	 mask of divider bits

 * @div_shift:	 shift of divider bits

 * @ref_clock:	reference clock rate

 * @num_offset:	num register offset

 * @denom_offset: denom register offset

 *

 * IMX PLL clock version 3, found on i.MX6 series.  Divider for pllv3

 * is actually a multiplier, and always sits at bit 0.

 No need to wait for lock when pll is not powered up */

 integer part, can be 20 or 22 */

 numerator, 30-bit value */

 denominator, 30-bit value, must be less than mfn */

 use max supported value for best accuracy */

 rate = parent_rate * (mfi + mfn/mfd) */

 clear bit for mfi=20 */

 set bit for mfi=22 */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright 2017-2018 NXP.

 Assumming rate_table is in descending order */

 return minimum supported value */

 fvco = (m * 65536 + k) * Fin / (p * 65536) */

 Bypass clock and set lock to pll output lock */

 Enable RST */

 Enable BYPASS */

	/*

	 * According to SPEC, t3 - t2 need to be greater than

	 * 1us and 1/FREF, respectively.

	 * FREF is FIN / Prediv, the prediv is [1, 63], so choose

	 * 3us.

 Disable RST */

 Wait Lock */

 Bypass */

 Enable RST */

 Enable BYPASS */

	/*

	 * According to SPEC, t3 - t2 need to be greater than

	 * 1us and 1/FREF, respectively.

	 * FREF is FIN / Prediv, the prediv is [1, 63], so choose

	 * 3us.

 Disable RST */

 Wait Lock*/

 Bypass */

	/*

	 * RESETB = 1 from 0, PLL starts its normal

	 * operation after lock time

	/*

	 * Set RST to 0, power down mode is enabled and

	 * every digital block is reset

 SPDX-License-Identifier: GPL-2.0+

/*

 * Copyright 2018 NXP.

 *   Dong Aisheng <aisheng.dong@nxp.com>

 restore div val */

 store the current div val */

/*

 * NOTE: In order to reuse the most code from the common divider,

 * we also design our divider following the way that provids an extra

 * clk_divider_flags, however it's fixed to CLK_DIVIDER_ONE_BASED by

 * default as our HW is. Besides that it supports only CLK_DIVIDER_READ_ONLY

 * flag which can be specified by user flexibly.

 cache gate status */

 SPDX-License-Identifier: GPL-2.0+

/*

 * Copyright (C) 2016 Freescale Semiconductor, Inc.

 * Copyright 2017~2018 NXP

 *

 * Author: Dong Aisheng <aisheng.dong@nxp.com>

 *

 used by sosc/sirc/firc/ddr/spll/apll dividers */

 sentinel */ },

 SCG1 */

 NOTE: xPLL config can't be changed when xPLL is enabled */

							   name		    parent_name	   reg			shift	width	flags */

						name	 parent_name	 base */

 APLL PFDs */

 SPLL PFDs */

 PLL Mux */

 scs/ddr/nic select different clock source requires that clock to be enabled first */

 PCC2 */

 PCC3 */

 SMC1 */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  Copyright (C) 2008 Sascha Hauer <s.hauer@pengutronix.de>, Pengutronix

 SPDX-License-Identifier: GPL-2.0+

/*

 * Copyright (C) 2016 Freescale Semiconductor, Inc.

 * Copyright 2017~2018 NXP

 *

	/*

	 * release the sw reset for peripherals associated with

	 * with this pcc clock.

		/*

		 * make sure clock is gated during clock tree initialization,

		 * the HW ONLY allow clock parent/rate changed with clock gated,

		 * during clock tree initialization, clocks could be enabled

		 * by bootloader, so the HW status will mismatch with clock tree

		 * prepare count, then clock core driver will allow parent/rate

		 * change since the prepare count is zero, but HW actually

		 * prevent the parent/rate change due to the clock is enabled.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2010-2011 Canonical Ltd <jeremy.kerr@canonical.com>

 * Copyright (C) 2011-2012 Mike Turquette, Linaro Ltd <mturquette@linaro.org>

 *

 * Gated clock implementation

/**

 * DOC: basic gateable clock which can gate and ungate its output

 *

 * Traits of this clock:

 * prepare - clk_(un)prepare only ensures parent is (un)prepared

 * enable - clk_enable and clk_disable are functional & control gating

 * rate - inherits rate from parent.  No clk_set_rate support

 * parent - fixed parent.  No clk_set_parent support

 struct clk_gate2 assignments */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2014 Freescale Semiconductor, Inc.

/**

 * struct clk_gate_exclusive - i.MX specific gate clock which is mutually

 * exclusive with other gate clocks

 *

 * @gate: the parent class

 * @exclusive_mask: mask of gate bits which are mutually exclusive to this

 *	gate clock

 *

 * The imx exclusive gate clock is a subclass of basic clk_gate

 * with an addtional mask to indicate which other gate bits in the same

 * register is mutually exclusive to this gate clock.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2013 Freescale Semiconductor, Inc.

/**

 * struct clk_fixup_div - imx integer fixup divider clock

 * @divider: the parent class

 * @ops: pointer to clk_ops of parent class

 * @fixup: a hook to fixup the write value

 *

 * The imx fixup divider clock is a subclass of basic clk_divider

 * with an addtional fixup hook.

 Zero based divider */

 SPDX-License-Identifier: (GPL-2.0 OR MIT)

/*

 * Copyright 2018 NXP.

 *

 * This driver supports the SCCG plls found in the imx8m SOCs

 *

 * Documentation for this SCCG pll can be found at:

 *   https://www.nxp.com/docs/en/reference-manual/IMX8MDQLQRM.pdf#page=834

 PLL CFGs */

 These are the specification limits for the SSCG PLL */

 don't wait for lock if all plls are bypassed */

 set bypass here too since the parent might be the same */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright 2017-2018 NXP.

 CCM ROOT */

 PLL bypass out */

 PLL out gate */

 SYS PLL1 fixed output */

 SYS PLL2 fixed output */

 Core Slice */

 For backwards compatibility */

 CORE SEL */

 BUS */

 AHB */

 IPG */

	/*

	 * DRAM clocks are manipulated from TF-A outside clock framework.

	 * The fw_managed helper sets GET_RATE_NOCACHE and clears SET_PARENT_GATE

	 * as div value should always be read from hardware

 IP */

 CCGR */

 Sentinel */ },

		/*

		 * Disable bind attributes: clocks are not removed and

		 * reloading the driver will crash or break devices.

 SPDX-License-Identifier: GPL-2.0

 PLL Register Offsets */

 PLL Register Bit definitions */

 1000 * udelay(1) = 1ms */

 use dpdck0_2 */

 Wait for lock */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2012 Freescale Semiconductor, Inc.

 * Copyright 2012 Linaro Ltd.

 SPDX-License-Identifier: GPL-2.0+

/*

 * Copyright 2018 NXP

 *	Dong Aisheng <aisheng.dong@nxp.com>

/*

 * struct imx8qxp_lpcg_data - Description of one LPCG clock

 * @id: clock ID

 * @name: clock name

 * @parent: parent clock name

 * @flags: common clock flags

 * @offset: offset of this LPCG clock

 * @bit_idx: bit index of this LPCG clock

 * @hw_gate: whether supports HW autogate

 *

 * This structure describes one LPCG clock

/*

 * struct imx8qxp_ss_lpcg - Description of one subsystem LPCG clocks

 * @lpcg: LPCG clocks array of one subsystem

 * @num_lpcg: the number of LPCG clocks

 * @num_max: the maximum number of LPCG clocks

 *

 * This structure describes each subsystem LPCG clocks information

 * which then will be used to create respective LPCGs clocks

	/*

	 * A trick here is that we set the num of clks to the MAX instead

	 * of the count from clock-indices because one LPCG supports up to

	 * 8 clock outputs which each of them is fixed to 4 bits. Then we can

	 * easily get the clock by clk-indices (bit-offset) / 4.

	 * And the cost is very limited few pointers.

 try new binding to parse clocks from device tree first */

	/*

	 * Please don't replace this with devm_platform_ioremap_resource.

	 *

	 * devm_platform_ioremap_resource calls devm_ioremap_resource which

	 * differs from devm_ioremap by also calling devm_request_mem_region

	 * and preventing other mappings in the same area.

	 *

	 * On imx8 the LPCG nodes map entire subsystems and overlap

	 * peripherals, this means that using devm_platform_ioremap_resource

	 * will cause many devices to fail to probe including serial ports.

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright 2018-2019 NXP.

 PLL bypass out */

 PLL out gate */

 SYS PLL1 fixed output */

 SYS PLL2 fixed output */

 CORE */

 CORE SEL */

 BUS */

	/*

	 * DRAM clocks are manipulated from TF-A outside clock framework.

	 * The fw_managed helper sets GET_RATE_NOCACHE and clears SET_PARENT_GATE

	 * as div value should always be read from hardware

 Sentinel */ },

		/*

		 * Disable bind attributes: clocks are not removed and

		 * reloading the driver will crash or break devices.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright 2018 NXP

	/*

	 * write twice to make sure non-target interface

	 * SEL_A/B point the same clk input.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2012 Sascha Hauer, Pengutronix <s.hauer@pengutronix.de>

  0 */ ckih, mpll, ppll, mpll_075, arm, hsp, hsp_div, hsp_sel, ahb,

  9 */ ipg, arm_per_div, ahb_per_div, ipg_per, uart_sel, uart_div,

 15 */ esdhc_sel, esdhc1_div, esdhc2_div, esdhc3_div, spdif_sel,

 20 */ spdif_div_pre, spdif_div_post, ssi_sel, ssi1_div_pre,

 24 */ ssi1_div_post, ssi2_div_pre, ssi2_div_post, usb_sel, usb_div,

 29 */ nfc_div, asrc_gate, pata_gate, audmux_gate, can1_gate,

 34 */ can2_gate, cspi1_gate, cspi2_gate, ect_gate, edio_gate,

 39 */ emi_gate, epit1_gate, epit2_gate, esai_gate, esdhc1_gate,

 44 */ esdhc2_gate, esdhc3_gate, fec_gate, gpio1_gate, gpio2_gate,

 49 */ gpio3_gate, gpt_gate, i2c1_gate, i2c2_gate, i2c3_gate,

 54 */ iomuxc_gate, ipu_gate, kpp_gate, mlb_gate, mshc_gate,

 59 */ owire_gate, pwm_gate, rngc_gate, rtc_gate, rtic_gate, scc_gate,

 65 */ sdma_gate, spba_gate, spdif_gate, ssi1_gate, ssi2_gate,

 70 */ uart1_gate, uart2_gate, uart3_gate, usbotg_gate, wdog_gate,

 75 */ max_gate, admux_gate, csi_gate, csi_div, csi_sel, iim_gate,

 81 */ gpu2d_gate, ckil, clk_max

		/*

		 * We are basically stuck. Continue with a default entry and hope we

		 * get far enough to actually show the above message

 divide by 1 not allowed */ 

	/*

	 * SCC is needed to boot via mmc after a watchdog reset. The clock code

	 * before conversion to common clk also enabled UART1 (which isn't

	 * handled here and not needed for mmc) and IIM (which is enabled

	 * unconditionally above).

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * clkgen-mux.c: ST GEN-MUX Clock driver

 *

 * Copyright (C) 2014 STMicroelectronics (R&D) Limited

 *

 * Authors: Stephen Gallimore <stephen.gallimore@st.com>

 *	    Pankaj Dev <pankaj.dev@st.com>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2014 STMicroelectronics R&D Ltd

/*

 * Authors:

 * Stephen Gallimore <stephen.gallimore@st.com>,

 * Pankaj Dev <pankaj.dev@st.com>.

/*

 * Maximum input clock to the PLL before we divide it down by 2

 * although in reality in actual systems this has never been seen to

 * be used.

/**

 * DOC: A Frequency Synthesizer that multiples its input clock by a fixed factor

 *

 * Traits of this clock:

 * prepare - clk_(un)prepare only ensures parent is (un)prepared

 * enable - clk_enable and clk_disable are functional & control the Fsyn

 * rate - inherits rate from parent. set_rate/round_rate/recalc_rate

 * parent - fixed parent.  No clk_set_parent support

/**

 * struct st_clk_quadfs_pll - A pll which outputs a fixed multiplier of

 *                                  its parent clock, found inside a type of

 *                                  ST quad channel frequency synthesizer block

 *

 * @hw: handle between common and hardware-specific interfaces.

 * @regs_base: base address of the configuration registers.

 * @lock: spinlock.

 * @data: local driver data

 * @ndiv: regmap field for the ndiv control.

	/*

	 * Bring block out of reset if we have reset control.

	/*

	 * Use a fixed input clock noise bandwidth filter for the moment

	/*

	 * Power up the PLL

	/*

	 * Powerdown the PLL and then put block into soft reset if we have

	 * reset control.

 ndiv value */

/* Formula

   VCO frequency = (fin x ndiv) / pdiv

   ndiv = VCOfreq * pdiv / fin

 Output clock range: 384Mhz to 660Mhz */

		/* This means that PDIV would be 2 instead of 1.

 Converting formula value to reg value */

	/*

	 * Sanity check required pointers.

/**

 * DOC: A digital frequency synthesizer

 *

 * Traits of this clock:

 * prepare - clk_(un)prepare only ensures parent is (un)prepared

 * enable - clk_enable and clk_disable are functional

 * rate - set rate is functional

 * parent - fixed parent.  No clk_set_parent support

/*

 * struct st_clk_quadfs_fsynth - One clock output from a four channel digital

 *                                  frequency synthesizer (fsynth) block.

 *

 * @hw: handle between common and hardware-specific interfaces

 *

 * @nsb: regmap field in the output control register for the digital

 *       standby of this fsynth channel. This control is active low so

 *       the channel is in standby when the control bit is cleared.

 *

 * @nsdiv: regmap field in the output control register for

 *          for the optional divide by 3 of this fsynth channel. This control

 *          is active low so the divide by 3 is active when the control bit is

 *          cleared and the divide is bypassed when the bit is set.

	/*

	 * Cached hardware values from set_rate so we can program the

	 * hardware in enable. There are two reasons for this:

	 *

	 *  1. The registers may not be writable until the parent has been

	 *     enabled.

	 *

	 *  2. It restores the clock rate when a driver does an enable

	 *     on PM restore, after a suspend to RAM has lost the hardware

	 *     setup.

	/*

	 * Pulse the program enable register lsb to make the hardware take

	 * notice of the new md/pe values with a glitchless transition.

	/*

	 * Ensure the md/pe parameters are ignored while we are

	 * reprogramming them so we can get a glitchless change

	 * when fine tuning the speed of a running clock.

	/*

	 * 'nsdiv' is a register value ('BIN') which is translated

	 * to a decimal value according to following rules.

	 *

	 *     nsdiv      ns.dec

	 *       0        3

	 *       1        1

 sdiv_reg (8 downto 0) */

 md value */

 initial condition to say: "infinite deviation" */

 pe value */

 Boundary test to avoid useless iteration */

 No solution */

 Try to find best deviation */

 No solution found */

 pe fine tuning if deviation not 0: +/- 2 around computed pe value */

 Check if this is a better solution */

	/*

	 * Get the initial hardware values for recalc_rate

	/*

	 * If All are NULL then assume no clock rate is programmed.

	/*

	 * In some integrations you can only change the fsynth programming when

	 * the parent entity containing it is enabled.

	/*

	 * Sanity check required pointers, note that nsdiv3 is optional.

		/*

		 * If we read an empty clock name then the channel is unused

		/*

		 * If there was an error registering this clock output, clean

		 * up and move on to the next one.

 No longer need local copy of the PLL name */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * clk-flexgen.c

 *

 * Copyright (C) ST-Microelectronics SA 2013

 * Author:  Maxime Coquelin <maxime.coquelin@st.com> for ST-Microelectronics.

 Crossbar */

 Pre-divisor's gate */

 Pre-divisor */

 Final divisor's gate */

 Final divisor */

 Asynchronous mode control */

 hw control flags */

 disable only the final gate */

 Round div according to exact prate and wished rate */

	/*

	* pdiv is mainly targeted for low freq results, while fdiv

	* should be used for div <= 64. The other way round can

	* lead to 'duty cycle' issues.

 Crossbar element config */

 Pre-divider's gate config (in xbar register)*/

 Pre-divider config */

 Final divider's gate config */

 Final divider config */

 Final divider sync config */

 This clk needs to be on so that memory interface is accessible */

 Those clks need to be on so that memory interface is accessible */

 This clk needs to be on to keep bus interconnect alive */

 This clk needs to be on to keep bus interconnect alive */

 This clk needs to be on to keep A9 running */

 This clk needs to be on to keep bus interconnect alive */

 This clk needs to be on to keep bus interconnect alive */

 This clk needs to be on to keep bus interconnect alive */

 This clk needs to be on to keep bus interconnect alive */

 This clk needs to be on to keep A9 running */

 This clk needs to be on to keep bus interconnect alive */

 This clk needs to be on to keep bus interconnect alive */

 This clk needs to be on to keep bus interconnect alive */

 This clk needs to be on to keep bus interconnect alive */

 This clk needs to be on to keep bus interconnect alive */

 This clk needs to be on to keep bus interconnect alive */

 This clk needs to be on to keep bus interconnect alive */

 This clk needs to be on to keep bus interconnect alive */

 This clk needs to be on to keep bus interconnect alive */

 This clk needs to be on to keep bus interconnect alive */

 This clk needs to be on to keep bus interconnect alive */

 This clk needs to be on to keep bus interconnect alive */

 This clk needs to be on to keep bus interconnect alive */

 First try to get output information from the compatible data */

		/*

		 * If we read an empty clock name then the output is unused

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2014 STMicroelectronics (R&D) Limited

/*

 * Authors:

 * Stephen Gallimore <stephen.gallimore@st.com>,

 * Pankaj Dev <pankaj.dev@st.com>.

/*

 * PLL configuration register bits for PLL3200 C32

/*

 * PLL configuration register bits for PLL4600 C28

 407 C0 PLL0 */

 407 C0 PLL1 */

 407 A9 */

 418 A9 */

/**

 * DOC: Clock Generated by PLL, rate set and enabled by bootloader

 *

 * Traits of this clock:

 * prepare - clk_(un)prepare only ensures parent is (un)prepared

 * enable - clk_enable/disable only ensures parent is enabled

 * rate - rate is fixed. No clk_set_rate support

 * parent - fixed parent.  No clk_set_parent support

/*

 * PLL clock that is integrated in the ClockGenA instances on the STiH415

 * and STiH416.

 *

 * @hw: handle between common and hardware-specific interfaces.

 * @regs_base: base of the PLL configuration register(s).

 *

 Charge pump table: highest ndiv value for cp=6 to 25 */

 Output clock range: 800Mhz to 1600Mhz */

 Checks */

 No solution found */

 Computing recommended charge pump value */

 Note: input is divided to avoid overflow */

/* PLL output structure

 * FVCO >> /2 >> FVCOBY2 (no output)

 *                 |> Divider (ODF) >> PHI

 *

 * FVCOby2 output = (input * 2 * NDIV) / IDF (assuming FRAC_CONTROL==L)

 *

 * Rules:

 *   4Mhz <= INFF input <= 350Mhz

 *   4Mhz <= INFIN (INFF / IDF) <= 50Mhz

 *   19.05Mhz <= FVCOby2 output (PHI w ODF=1) <= 3000Mhz

 *   1 <= i (register/dec value for IDF) <= 7

 *   8 <= n (register/dec value for NDIV) <= 246

 Output clock range: 19Mhz to 3000Mhz */

 For better jitter, IDF should be smallest and NDIV must be maximum */

 INFIN checks */

 Invalid case */

 Invalid case */

 To work around 'y' when n=x.y */

 Optimization: shorting loop */

 No solution found */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2016 Maxime Ripard

 * Maxime Ripard <maxime.ripard@free-electrons.com>

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2016 Maxime Ripard

 * Maxime Ripard <maxime.ripard@free-electrons.com>

		/*

		 * adj_parent_rate might have been modified by our clock.

		 * Unapply the pre-divider if there's one, and give

		 * the actual frequency the parent needs to run at.

		/*

		 * parent_rate might have been modified by our clock.

		 * Unapply the pre-divider if there's one, and give

		 * the actual frequency the parent needs to run at.

/*

 * This clock notifier is called when the frequency of the of the parent

 * PLL clock is to be changed. The idea is to switch the parent to a

 * stable clock, such as the main oscillator, while the PLL frequency

 * stabilizes.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2016 Maxime Ripard. All rights reserved.

/*

 * The Audio PLL is supposed to have 4 outputs: 3 fixed factors from

 * the base (2x, 4x and 8x), and one variable divider (the one true

 * pll audio).

 *

 * With sigma-delta modulation for fractional-N on the audio PLL,

 * we have to use specific dividers. This means the variable divider

 * can no longer be used, as the audio codec requests the exact clock

 * rates we support through this mechanism. So we now hard code the

 * variable divider to 1. This means the clock rates will no longer

 * match the clock names.

	/*

	 * The datasheet is wrong here, this doesn't have any

	 * offset

 Sentinel */ },

 M */

 P */

 mux */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 We hardcode the divider to 1 for now */

/*

 * The A13 is the A10s minus the TS, GPS, HDMI, I2S and the keypad

/*

 * The GR8 is the A10s CCU minus the HDMI and keypad, plus SPDIF

 Force the PLL-Audio-1x divider to 1 */

	/*

	 * Use the peripheral PLL as the AHB parent, instead of CPU /

	 * AXI which have rate changes due to cpufreq.

	 *

	 * This is especially a big deal for the HS timer whose parent

	 * clock is AHB.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2016 Maxime Ripard

 * Maxime Ripard <maxime.ripard@free-electrons.com>

	/*

	 * We must report success but we can do so unconditionally because

	 * clk_factor_round_rate returns values that ensure this call is a

	 * nop.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2016 Maxime Ripard

 * Maxime Ripard <maxime.ripard@free-electrons.com>

	/*

	 * The maximum divider we can use without overflowing

	 * unsigned long in rate * m * p below

				/*

				 * It's the most ideal case if the requested

				 * rate can be divided from parent clock without

				 * needing to change parent rate, so return the

				 * divider immediately.

 Adjust parent_rate according to pre-dividers */

 Adjust parent_rate according to pre-dividers */

 Adjust target rate according to post-dividers */

/*

 * Support for MMC timing mode switching

 *

 * The MMC clocks on some SoCs support switching between old and

 * new timing modes. A platform specific API is provided to query

 * and set the timing mode on supported SoCs.

 *

 * In addition, a special class of ccu_mp_ops is provided, which

 * takes in to account the timing mode switch. When the new timing

 * mode is active, the clock output rate is halved. This new class

 * is a wrapper around the generic ccu_mp_ops. When clock rates

 * are passed through to ccu_mp_ops callbacks, they are doubled

 * if the new timing mode bit is set, to account for the post

 * divider. Conversely, when clock rates are passed back, they

 * are halved if the mode bit is set.

 adjust the requested clock rate */

 re-adjust the requested clock rate back */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2016 Chen-Yu Tsai. All rights reserved.

/*

 * The CPU PLLs are actually NP clocks, with P being /1 or /4. However

 * P should only be used for output frequencies lower than 228 MHz.

 * Neither mainline Linux, U-boot, nor the vendor BSPs use these.

 *

 * For now we can just model it as a multiplier clock, and force P to /1.

/*

 * The Audio PLL has d1, d2 dividers in addition to the usual N, M

 * factors. Since we only need 2 frequencies from this PLL: 22.5792 MHz

 * and 24.576 MHz, ignore them for now. Enforce d1 = 0 and d2 = 0.

 Some PLLs are input * N / div1 / div2. Model them as NKMP with no K */

 input divider */

 output divider */

 input divider */

 output divider */

 input divider */

 output divider */

 input divider */

 input divider */

 external divider p */

 input divider */

 output divider */

 input divider */

 output divider */

 input divider */

 output divider */

 input divider */

 output divider */

 Sentinel */ },

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 mux */

 no gate */

 M */

 mux */

 gate */

 M */

 mux */

 gate */

 M */

 mux */

 gate */

 M */

 mux */

 gate */

 M */

 mux */

 gate */

 M */

 mux */

 gate */

 M */

 mux */

 gate */

 M */

 mux */

 gate */

 M */

 mux */

 gate */

 M */

 mux */

 gate */

 M */

 mux */

 gate */

 AHB0 bus gates */

 AHB1 bus gates */

 AHB2 bus gates */

 APB0 bus gates */

 APB1 bus gates */

 module clocks */

 AHB0 bus gates */

 AHB1 bus gates */

 AHB2 bus gates */

 APB0 bus gates */

 APB1 bus gates */

 AHB0 reset controls */

 AHB1 reset controls */

 AHB2 reset controls */

 APB0 reset controls */

 APB1 reset controls */

 bail out if P divider is not used */

	/*

	 * If P is used, output should be less than 288 MHz. When we

	 * set P to 1, we should also decrease the multiplier so the

	 * output doesn't go out of range, but not too much such that

	 * the multiplier stays above 12, the minimal operation value.

	 *

	 * To keep it simple, set the multiplier to 17, the reset value.

 And clear P */

 Enforce d1 = 0, d2 = 0 for Audio PLL */

 Enforce P = 1 for both CPU cluster PLLs */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2016 Icenowy Zheng <icenowy@aosc.xyz>

 *

 * Based on ccu-sun8i-h3.c, which is:

 * Copyright (c) 2016 Maxime Ripard. All rights reserved.

 N */

 K */

 M */

 P */

 gate */

 lock */

/*

 * The Audio PLL is supposed to have 4 outputs: 3 fixed factors from

 * the base (2x, 4x and 8x), and one variable divider (the one true

 * pll audio).

 *

 * With sigma-delta modulation for fractional-N on the audio PLL,

 * we have to use specific dividers. This means the variable divider

 * can no longer be used, as the audio codec requests the exact clock

 * rates we support through this mechanism. So we now hard code the

 * variable divider to 1. This means the clock rates will no longer

 * match the clock names.

 N */

 M */

 gate */

 lock */

 N */

 M */

 frac enable */

 frac select */

 frac rate 0 */

 frac rate 1 */

 gate */

 lock */

 N */

 M */

 frac enable */

 frac select */

 frac rate 0 */

 frac rate 1 */

 gate */

 lock */

 N */

 K */

 M */

 gate */

 lock */

 N */

 K */

 gate */

 lock */

 post-div */

 N */

 M */

 frac enable */

 frac select */

 frac rate 0 */

 frac rate 1 */

 gate */

 lock */

 N */

 K */

 gate */

 lock */

 post-div */

 N */

 M */

 gate */

 lock */

 Sentinel */ },

 M */

 P */

 mux */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 We hardcode the divider to 1 for SDM support */

 Force the PLL-Audio-1x divider to 1 */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2016 Maxime Ripard. All rights reserved.

 N */

 K */

 M */

 P */

 gate */

 lock */

/*

 * The Audio PLL is supposed to have 4 outputs: 3 fixed factors from

 * the base (2x, 4x and 8x), and one variable divider (the one true

 * pll audio).

 *

 * With sigma-delta modulation for fractional-N on the audio PLL,

 * we have to use specific dividers. This means the variable divider

 * can no longer be used, as the audio codec requests the exact clock

 * rates we support through this mechanism. So we now hard code the

 * variable divider to 1. This means the clock rates will no longer

 * match the clock names.

 N */

 M */

 gate */

 lock */

 Minimum rate */

 Maximum rate */

 N */

 M */

 frac enable */

 frac select */

 frac rate 0 */

 frac rate 1 */

 gate */

 lock */

 N */

 M */

 frac enable */

 frac select */

 frac rate 0 */

 frac rate 1 */

 gate */

 lock */

 N */

 K */

 M */

 gate */

 lock */

 N */

 K */

 gate */

 lock */

 post-div */

 N */

 M */

 frac enable */

 frac select */

 frac rate 0 */

 frac rate 1 */

 gate */

 lock */

 N */

 K */

 gate */

 lock */

 post-div */

 N */

 M */

 frac enable */

 frac select */

 frac rate 0 */

 frac rate 1 */

 gate */

 lock */

 Sentinel */ },

 M */

 P */

 mux */

 Sentinel */ },

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 We hardcode the divider to 1 for now */

 copy from pll_cpux_clk */

 > 8 clock cycles at 24 MHz */

 index of 24 MHz oscillator */

 Force the PLL-Audio-1x divider to 1 */

 Gate then ungate PLL CPU after any rate changes */

 Reparent CPU during PLL CPU rate changes */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2020 Yangtao Li <frank@allwinnertech.com>

/*

 * The CPU PLL is actually NP clock, with P being /1, /2 or /4. However

 * P should only be used for output frequencies lower than 288 MHz.

 *

 * For now we can just model it as a multiplier clock, and force P to /1.

 *

 * The M factor is present in the register's description, but not in the

 * frequency formula, and it's documented as "M is only used for backdoor

 * testing", so it's not modelled and then force to 0.

 Some PLLs are input * N / div1 / P. Model them as NKMP with no K */

 input divider */

 output divider */

 input divider */

 output divider */

 input divider */

 output divider */

 input divider */

 output divider */

/*

 * For Video PLLs, the output divider is described as "used for testing"

 * in the user manual. So it's not modelled and forced to 0.

 input divider */

 input divider */

 input divider */

 input divider */

 output divider */

/*

 * The COM PLL has m0 dividers in addition to the usual N, M

 * factors. Since we only need 1 frequencies from this PLL: 45.1584 MHz,

 * ignore it for now.

 input divider */

/*

 * The Audio PLL has m0, m1 dividers in addition to the usual N, M

 * factors. Since we only need 4 frequencies from this PLL: 22.5792 MHz,

 * 24.576 MHz, 90.3168MHz and 98.304MHz ignore them for now.

 * Enforce the default for them, which is m0 = 1, m1 = 0.

 M */

 P */

 mux */

 M */

 P */

 mux */

 M */

 P */

 mux */

 M */

 P */

 mux */

 M */

 mux */

 gate */

 M */

 mux */

 gate */

 M */

 mux */

 gate */

 M */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 post-div */

 M */

 P */

 mux */

 gate */

 post-div */

 M */

 P */

 mux */

 gate */

 post-div */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 mux */

 gate */

 M */

 mux */

 gate */

 M */

 mux */

 gate */

/*

 * There are OHCI 12M clock source selection bits for 2 USB 2.0 ports.

 * We will force them to 0 (12M divided from 48M).

 M */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 mux */

 gate */

 M */

 mux */

 gate */

 M */

 mux */

 gate */

 M */

 mux */

 gate */

 Fixed factor clocks */

 copy from pll_cpux_clk */

 index of pll periph0 */

	/*

	 * Enable lock and enable bits on all PLLs.

	 *

	 * Due to the current design, multiple PLLs share one power switch,

	 * so switching PLL is easy to cause stability problems.

	 * When initializing, we enable them by default. When disable,

	 * we only turn off the output of PLL.

	/*

	 * In order to pass the EMI certification, the SDM function of

	 * the peripheral 1 bus is enabled, and the frequency is still

	 * calculated using the previous division factor.

	/*

	 * Force the output divider of video PLLs to 0.

	 *

	 * See the comment before pll-video0 definition for the reason.

	/*

	 * Enforce m1 = 0, m0 = 1 for Audio PLL

	 *

	 * See the comment before pll-audio definition for the reason.

	/*

	 * Force OHCI 12M clock sources to 00 (12MHz divided from 48MHz)

	 *

	 * This clock mux is still mysterious, and the code just enforces

	 * it to have a valid clock parent.

 Gate then ungate PLL CPU after any rate changes */

 Reparent CPU during PLL CPU rate changes */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2016 Maxime Ripard

 * Maxime Ripard <maxime.ripard@free-electrons.com>

 Adjust target rate according to post-dividers */

 most SoCs require M to be 0 if fractional mode is used */

 Sigma delta modulation requires specific N and M factors */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2017 Chen-Yu Tsai <wens@csie.org>

 Set the pattern */

 Make sure SDM is enabled */

/*

 * Sigma delta modulation provides a way to do fractional-N frequency

 * synthesis, in essence allowing the PLL to output any frequency

 * within its operational range. On earlier SoCs such as the A10/A20,

 * some PLLs support this. On later SoCs, all PLLs support this.

 *

 * The datasheets do not explain what the "wave top" and "wave bottom"

 * parameters mean or do, nor how to calculate the effective output

 * frequency. The only examples (and real world usage) are for the audio

 * PLL to generate 24.576 and 22.5792 MHz clock rates used by the audio

 * peripherals. The author lacks the underlying domain knowledge to

 * pursue this.

 *

 * The goal and function of the following code is to support the two

 * clock rates used by the audio subsystem, allowing for proper audio

 * playback and capture without any pitch or speed changes.

 We can't calculate the effective clock rate, so just fail. */

 nothing found */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2016 Maxime Ripard

 * Maxime Ripard <maxime.ripard@free-electrons.com>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2017 Icenowy Zheng <icenowy@aosc.io>

	/*

	 * Mixer1 reset line is shared with wb, so only RST_WB is

	 * exported here.

	/*

	 * Mixer1 reset line is shared with wb, so only RST_WB is

	 * exported here.

	 * V3s doesn't have mixer1, so it also shares this struct.

 The clocks need to be enabled for us to access the registers */

 The reset control needs to be asserted for the controls to work */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2016 Icenowy Zheng <icenowy@aosc.xyz>

/*

 * Define the parent as an array that can be reused to save space

 * instead of having compound literals for each gate. Also have it

 * non-const so we can change it on the A83T.

 M */

 P */

 mux */

 gate */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2017 Chen-Yu Tsai. All rights reserved.

/*

 * The CPU PLLs are actually NP clocks, with P being /1 or /4. However

 * P should only be used for output frequencies lower than 228 MHz.

 * Neither mainline Linux, U-boot, nor the vendor BSPs use these.

 *

 * For now we can just model it as a multiplier clock, and force P to /1.

/*

 * The Audio PLL has d1, d2 dividers in addition to the usual N, M

 * factors. Since we only need 2 frequencies from this PLL: 22.5792 MHz

 * and 24.576 MHz, ignore them for now. Enforce the default for them,

 * which is d1 = 0, d2 = 1.

 clock rates doubled for post divider */

 Some PLLs are input * N / div1 / P. Model them as NKMP with no K */

 input divider */

 output divider */

 input divider */

 output divider */

 input divider */

 output divider */

 input divider */

 output divider */

 input divider */

 output divider */

 input divider */

 output divider */

 input divider */

 output divider */

 input divider */

 external divider p */

 M */

 P */

 mux */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 TODO divider has minimum of 2 */

 M */

 mux */

 gate */

 M */

 mux */

 gate */

 M */

 mux */

 gate */

 M */

 mux */

 gate */

 M */

 mux */

 gate */

 M */

 mux */

 gate */

 M */

 mux */

 gate */

 bail out if P divider is not used */

	/*

	 * If P is used, output should be less than 288 MHz. When we

	 * set P to 1, we should also decrease the multiplier so the

	 * output doesn't go out of range, but not too much such that

	 * the multiplier stays above 12, the minimal operation value.

	 *

	 * To keep it simple, set the multiplier to 17, the reset value.

 And clear P */

 Enforce d1 = 0, d2 = 1 for Audio PLL */

 Enforce P = 1 for both CPU cluster PLLs */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2016 Maxime Ripard

 * Maxime Ripard <maxime.ripard@free-electrons.com>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2016 Chen-Yu Tsai. All rights reserved.

 The bus clock needs to be enabled for us to access the registers */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2016 Maxime Ripard

 * Maxime Ripard <maxime.ripard@free-electrons.com>

	/*

	 * The reset control API expects 0 if reset is not asserted,

	 * which is the opposite of what our hardware uses.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2016 Maxime Ripard. All rights reserved.

/*

 * The Audio PLL is supposed to have 4 outputs: 3 fixed factors from

 * the base (2x, 4x and 8x), and one variable divider (the one true

 * pll audio).

 *

 * With sigma-delta modulation for fractional-N on the audio PLL,

 * we have to use specific dividers. This means the variable divider

 * can no longer be used, as the audio codec requests the exact clock

 * rates we support through this mechanism. So we now hard code the

 * variable divider to 1. This means the clock rates will no longer

 * match the clock names.

 N */

 M */

 gate */

 lock */

 N */

 M */

 frac enable */

 frac select */

 frac rate 0 */

 frac rate 1 */

 gate */

 lock */

 N */

 M */

 frac enable */

 frac select */

 frac rate 0 */

 frac rate 1 */

 gate */

 lock */

 N */

 K */

 M */

 gate */

 lock */

 N */

 K */

 gate */

 lock */

 post-div */

 N */

 M */

 frac enable */

 frac select */

 frac rate 0 */

 frac rate 1 */

 gate */

 lock */

/*

 * The MIPI PLL has 2 modes: "MIPI" and "HDMI".

 *

 * The MIPI mode is a standard NKM-style clock. The HDMI mode is an

 * integer / fractional clock with switchable multipliers and dividers.

 * This is not supported here. We hardcode the PLL to MIPI mode.

 N */

 K */

 M */

 gate */

 lock */

 N */

 M */

 frac enable */

 frac select */

 frac rate 0 */

 frac rate 1 */

 gate */

 lock */

 N */

 M */

 frac enable */

 frac select */

 frac rate 0 */

 frac rate 1 */

 gate */

 lock */

 Sentinel */ },

 M */

 P */

 mux */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 TODO: the parent for most of the USB clocks is not known */

 We hardcode the divider to 1 for now */

 copy from pll_cpux_clk */

 > 8 clock cycles at 24 MHz */

 index of 24 MHz oscillator */

 Force the PLL-Audio-1x divider to 1 */

 Force PLL-MIPI to MIPI mode */

 Gate then ungate PLL CPU after any rate changes */

 Reparent CPU during PLL CPU rate changes */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2020 Arm Ltd.

 * Based on the H6 CCU driver, which is:

 *   Copyright (c) 2017 Icenowy Zheng <icenowy@aosc.io>

/*

 * The CPU PLL is actually NP clock, with P being /1, /2 or /4. However

 * P should only be used for output frequencies lower than 288 MHz.

 *

 * For now we can just model it as a multiplier clock, and force P to /1.

 *

 * The M factor is present in the register's description, but not in the

 * frequency formula, and it's documented as "M is only used for backdoor

 * testing", so it's not modelled and then force to 0.

 Some PLLs are input * N / div1 / P. Model them as NKMP with no K */

 input divider */

 output divider */

 input divider */

 output divider */

 input divider */

 output divider */

 input divider */

 output divider */

 input divider */

 output divider */

/*

 * For Video PLLs, the output divider is described as "used for testing"

 * in the user manual. So it's not modelled and forced to 0.

 input divider */

 input divider */

 input divider */

 input divider */

 output divider */

 input divider */

 output divider */

/*

 * TODO: Determine SDM settings for the audio PLL. The manual suggests

 * PLL_FACTOR_N=16, PLL_POST_DIV_P=2, OUTPUT_DIV=2, pattern=0xe000c49b

 * for 24.576 MHz, and PLL_FACTOR_N=22, PLL_POST_DIV_P=3, OUTPUT_DIV=2,

 * pattern=0xe001288c for 22.5792 MHz.

 * This clashes with our fixed PLL_POST_DIV_P.

 input divider */

 M */

 P */

 mux */

 M */

 P */

 mux */

 M */

 P */

 mux */

 M */

 P */

 mux */

 M */

 mux */

 gate */

 M */

 mux */

 gate */

 M */

 mux */

 gate */

 M */

 mux */

 gate */

 M */

 mux */

 gate */

 M */

 gate */

 M */

 N */

 mux */

 gate */

 M */

 mux */

 gate */

 M */

 N */

 mux */

 gate */

 M */

 N */

 mux */

 gate */

 M */

 N */

 mux */

 gate */

 post-div */

 M */

 N */

 mux */

 gate */

 post-div */

 M */

 N */

 mux */

 gate */

 post-div */

 M */

 N */

 mux */

 gate */

 M */

 N */

 mux */

 gate */

 M */

 N */

 mux */

 gate */

 M */

 mux */

 gate */

 M */

 mux */

 gate */

/*

 * There are OHCI 12M clock source selection bits for the four USB 2.0 ports.

 * We will force them to 0 (12M divided from 48M).

 M */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 mux */

 gate */

 Fixed factor clocks */

/*

 * The divider of pll-audio is fixed to 24 for now, so 24576000 and 22579200

 * rates can be set exactly in conjunction with sigma-delta modulation.

 Enable the lock bits and the output enable bits on all PLLs */

	/*

	 * Force the output divider of video PLLs to 0.

	 *

	 * See the comment before pll-video0 definition for the reason.

	/*

	 * Force OHCI 12M clock sources to 00 (12MHz divided from 48MHz)

	 *

	 * This clock mux is still mysterious, and the code just enforces

	 * it to have a valid clock parent.

	/*

	 * Force the post-divider of pll-audio to 12 and the output divider

	 * of it to 2, so 24576000 and 22579200 rates can be set exactly.

	/*

	 * First clock parent (osc32K) is unusable for CEC. But since there

	 * is no good way to force parent switch (both run with same frequency),

	 * just set second clock parent here.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2017 Icenowy Zheng <icenowy@aosc.xyz>

/*

 * Information about AR100 and AHB/APB clocks in R_CCU are gathered from

 * clock definitions in the BSP source code.

/*

 * Information about the gate/resets are gathered from the clock header file

 * in the BSP source code, although most of them are unused. The existence

 * of the hardware block is verified with "3.1 Memory Mapping" chapter in

 * "Allwinner H6 V200 User Manual V1.1"; and the parent APB buses are verified

 * with "3.3.2.1 System Bus Tree" chapter inthe same document.

 Information of IR(RX) mod clock is gathered from BSP source code */

 M */

 P */

 mux */

 gate */

/*

 * BSP didn't use the 1-wire function at all now, and the information about

 * this mod clock is guessed from the IR mod clock above. The existence of

 * this mod clock is proven by BSP clock header, and the dividers are verified

 * by contents in the 1-wire related chapter of the User Manual.

 M */

 P */

 mux */

 gate */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2016 Maxime Ripard. All rights reserved.

/*

 * The Audio PLL is supposed to have 4 outputs: 3 fixed factors from

 * the base (2x, 4x and 8x), and one variable divider (the one true

 * pll audio).

 *

 * With sigma-delta modulation for fractional-N on the audio PLL,

 * we have to use specific dividers. This means the variable divider

 * can no longer be used, as the audio codec requests the exact clock

 * rates we support through this mechanism. So we now hard code the

 * variable divider to 1. This means the clock rates will no longer

 * match the clock names.

 N */

 M */

 gate */

 lock */

 Minimum rate */

 Maximum rate */

 N */

 M */

 frac enable */

 frac select */

 frac rate 0 */

 frac rate 1 */

 gate */

 lock */

 N */

 M */

 frac enable */

 frac select */

 frac rate 0 */

 frac rate 1 */

 gate */

 lock */

 N */

 K */

 M */

 gate */

 lock */

 Minimum rate */

 Maximum rate */

 N */

 M */

 frac enable */

 frac select */

 frac rate 0 */

 frac rate 1 */

 gate */

 lock */

 N */

 M */

 frac enable */

 frac select */

 frac rate 0 */

 frac rate 1 */

 gate */

 lock */

/*

 * The output function can be changed to something more complex that

 * we do not handle yet.

 *

 * Hardcode the mode so that we don't fall in that case.

	/*

	 * The bit 23 and 22 are called "LDO{1,2}_EN" on the SoC's

	 * user manual, and by experiments the PLL doesn't work without

	 * these bits toggled.

 N */

 M */

 frac enable */

 frac select */

 frac rate 0 */

 frac rate 1 */

 gate */

 lock */

 N */

 M */

 frac enable */

 frac select */

 frac rate 0 */

 frac rate 1 */

 gate */

 lock */

 N */

 M */

 gate */

 lock */

 Sentinel */ },

 M */

 P */

 mux */

 Sentinel */ },

 M */

 P */

 mux */

 gate */

/*

 * MMC clocks are the new timing mode (see A83T & H3) variety, but without

 * the mode switch. This means they have a 2x post divider between the clock

 * and the MMC module. This is not documented in the manual, but is taken

 * into consideration when setting the mmc module clocks in the BSP kernel.

 * Without it, MMC performance is degraded.

 *

 * We model it here to be consistent with other SoCs supporting this mode.

 * The alternative would be to add the 2x multiplier when setting the MMC

 * module clock in the MMC driver, just for the A64.

 M */

 P */

 mux */

 gate */

 post-div */

 M */

 P */

 mux */

 gate */

 post-div */

 M */

 P */

 mux */

 gate */

 post-div */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 Fixed Factor clocks */

 We hardcode the divider to 1 for now */

 copy from pll_cpux_clk */

 > 8 clock cycles at 24 MHz */

 index of 24 MHz oscillator */

 Force the PLL-Audio-1x divider to 1 */

 Gate then ungate PLL CPU after any rate changes */

 Reparent CPU during PLL CPU rate changes */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2016 Maxime Ripard. All rights reserved.

/*

 * The Audio PLL is supposed to have 4 outputs: 3 fixed factors from

 * the base (2x, 4x and 8x), and one variable divider (the one true

 * pll audio).

 *

 * With sigma-delta modulation for fractional-N on the audio PLL,

 * we have to use specific dividers. This means the variable divider

 * can no longer be used, as the audio codec requests the exact clock

 * rates we support through this mechanism. So we now hard code the

 * variable divider to 1. This means the clock rates will no longer

 * match the clock names.

 N */

 M */

 gate */

 lock */

 N */

 M */

 frac enable */

 frac select */

 frac rate 0 */

 frac rate 1 */

 gate */

 lock */

 N */

 M */

 frac enable */

 frac select */

 frac rate 0 */

 frac rate 1 */

 gate */

 lock */

 N */

 K */

 M */

 gate */

 lock */

 N */

 K */

 gate */

 lock */

 post-div */

 N */

 M */

 frac enable */

 frac select */

 frac rate 0 */

 frac rate 1 */

 gate */

 lock */

/*

 * The MIPI PLL has 2 modes: "MIPI" and "HDMI".

 *

 * The MIPI mode is a standard NKM-style clock. The HDMI mode is an

 * integer / fractional clock with switchable multipliers and dividers.

 * This is not supported here. We hardcode the PLL to MIPI mode.

 N */

 K */

 M */

 gate */

 lock */

 N */

 M */

 frac enable */

 frac select */

 frac rate 0 */

 frac rate 1 */

 gate */

 lock */

 N */

 M */

 frac enable */

 frac select */

 frac rate 0 */

 frac rate 1 */

 gate */

 lock */

 Sentinel */ },

 M */

 P */

 mux */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 TODO: the parent for most of the USB clocks is not known */

 We hardcode the divider to 1 for now */

 Force the PLL-Audio-1x divider to 1 */

 Force PLL-MIPI to MIPI mode */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2017 Chen-Yu Tsai. All rights reserved.

/**

 * sunxi_ccu_set_mmc_timing_mode: Configure the MMC clock timing mode

 * @clk: clock to be configured

 * @new_mode: true for new timing mode introduced in A83T and later

 *

 * Returns 0 on success, -ENOTSUPP if the clock does not support

 * switching modes.

/**

 * sunxi_ccu_set_mmc_timing_mode: Get the current MMC clock timing mode

 * @clk: clock to query

 *

 * Returns 0 if the clock is in old timing mode, > 0 if it is in

 * new timing mode, and -ENOTSUPP if the clock does not support

 * this function.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2016 Icenowy Zheng <icenowy@aosc.io>

 *

 MAX is guessed by the BSP table */

/*

 * The Audio PLL is supposed to have 4 outputs: 3 fixed factors from

 * the base (2x, 4x and 8x), and one variable divider (the one true

 * pll audio).

 *

 * We don't have any need for the variable divider for now, so we just

 * hardcode it to match with the clock names

 N */

 M */

 gate */

 lock */

 N */

 M */

 frac enable */

 frac select */

 frac rate 0 */

 frac rate 1 */

 gate */

 lock */

 N */

 M */

 frac enable */

 frac select */

 frac rate 0 */

 frac rate 1 */

 gate */

 lock */

 N */

 K */

 M */

 gate */

 lock */

 Sentinel */ },

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 The BSP header file has a CIR_CFG, but no mod clock uses this definition */

/*

 * TODO: BSP says the parent is pll-audio, however common sense and experience

 * told us it should be pll-ve. pll-ve is totally not used in BSP code.

 copy from pll_cpu_clk */

 > 8 clock cycles at 24 MHz */

 index of 24 MHz oscillator */

 Force the PLL-Audio-1x divider to 4 */

 Gate then ungate PLL CPU after any rate changes */

 Reparent CPU during PLL CPU rate changes */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2016 Maxime Ripard

 * Maxime Ripard <maxime.ripard@free-electrons.com>

 Get our parent clock, it's the one that can adjust its rate */

 And its rate */

 Now, get our parent's parent (most likely some PLL) */

 And its rate */

 Get our parent clock divider */

 Get our parent clock, it's the one that can adjust its rate */

 And its rate */

 Now, get our parent's parent (most likely some PLL) */

 And its rate */

 Get our parent divider */

		/*

		 * We can only outphase the clocks by multiple of the

		 * PLL's period.

		 *

		 * Since our parent clock is only a divider, and the

		 * formula to get the outphasing in degrees is deg =

		 * 360 * delta / period

		 *

		 * If we simplify this formula, we can see that the

		 * only thing that we're concerned about is the number

		 * of period we want to outphase our clock from, and

		 * the divider set by our parent clock.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2017 Priit Laes <plaes@plaes.org>.

 * Copyright (c) 2017 Maxime Ripard.

 * Copyright (c) 2017 Jonathan Liu.

/*

 * The Audio PLL is supposed to have 4 outputs: 3 fixed factors from

 * the base (2x, 4x and 8x), and one variable divider (the one true

 * pll audio).

 *

 * With sigma-delta modulation for fractional-N on the audio PLL,

 * we have to use specific dividers. This means the variable divider

 * can no longer be used, as the audio codec requests the exact clock

 * rates we support through this mechanism. So we now hard code the

 * variable divider to 1. This means the clock rates will no longer

 * match the clock names.

 Not documented on A10 */

 Not present on A10 */

 Sentinel */ },

 Sentinel */ },

 M */

 P */

 mux */

 Not present on A20 */

 Not documented on A20 */

 Not present on A20 */

 Not present on A10 */

 Not present on A10 */

 Not present on A10 */

 Not present on A10 */

 Not present on A10 */

 Not present on A10 */

 Not present on A10 */

 M */

 P */

 mux */

 gate */

 Undocumented on A10 */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 MMC output and sample clocks are not present on A10 */

 M */

 P */

 mux */

 gate */

 MMC output and sample clocks are not present on A10 */

 M */

 P */

 mux */

 gate */

 MMC output and sample clocks are not present on A10 */

 M */

 P */

 mux */

 gate */

 MMC output and sample clocks are not present on A10 */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 Undocumented on A10 */

 M */

 P */

 mux */

 gate */

 TODO: Check whether A10 actually supports osc32k as 4th parent? */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 Undocumented on A10 */

/*

 * SATA supports external clock as parent via BIT(24) and is probably an

 * optional crystal or oscillator that can be connected to the

 * SATA-CLKM / SATA-CLKP pins.

 TODO: GPS CLK 0x0d0 */

 M */

 P */

 mux */

 gate */

 Not present on A10 */

 Not present on A10 */

 Clock seems to be critical only on sun4i */

 Undocumented on A10 */

 TVD clock setup for A10 */

 TVD clock setup for A20 */

 M */

 P */

 mux */

 gate */

 Post-divider for pll-audio is hardcoded to 1 */

 CLK_GPS is unimplemented */

 CLK_GPS is unimplemented */

	/*

	 * Force VCO and PLL bias current to lowest setting. Higher

	 * settings interfere with sigma-delta modulation and result

	 * in audible noise and distortions when using SPDIF or I2S.

 Force the PLL-Audio-1x divider to 1 */

	/*

	 * Use the peripheral PLL6 as the AHB parent, instead of CPU /

	 * AXI which have rate changes due to cpufreq.

	 *

	 * This is especially a big deal for the HS timer whose parent

	 * clock is AHB.

	 *

	 * NB! These bits are undocumented in A10 manual.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2016 Maxime Ripard

 *

 * Maxime Ripard <maxime.ripard@free-electrons.com>

/*

 * This clock notifier is called when the frequency of a PLL clock is

 * changed. In common PLL designs, changes to the dividers take effect

 * almost immediately, while changes to the multipliers (implemented

 * as dividers in the feedback loop) take a few cycles to work into

 * the feedback loop for the PLL to stablize.

 *

 * Sometimes when the PLL clock rate is changed, the decrease in the

 * divider is too much for the decrease in the multiplier to catch up.

 * The PLL clock rate will spike, and in some cases, might lock up

 * completely.

 *

 * This notifier callback will gate and then ungate the clock,

 * effectively resetting it, so it proceeds to work. Care must be

 * taken to reparent consumers to other temporary clocks during the

 * rate change, and that this notifier callback must be the first

 * to be registered.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2016 Maxime Ripard

 * Maxime Ripard <maxime.ripard@free-electrons.com>

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2017 Icenowy Zheng <icenowy@aosc.io>

/*

 * The CPU PLL is actually NP clock, with P being /1, /2 or /4. However

 * P should only be used for output frequencies lower than 288 MHz.

 *

 * For now we can just model it as a multiplier clock, and force P to /1.

 *

 * The M factor is present in the register's description, but not in the

 * frequency formula, and it's documented as "M is only used for backdoor

 * testing", so it's not modelled and then force to 0.

 Some PLLs are input * N / div1 / P. Model them as NKMP with no K */

 input divider */

 output divider */

 input divider */

 output divider */

 input divider */

 output divider */

 input divider */

 output divider */

/*

 * For Video PLLs, the output divider is described as "used for testing"

 * in the user manual. So it's not modelled and forced to 0.

 input divider */

 input divider */

 input divider */

 output divider */

 input divider */

 output divider */

 input divider */

 output divider */

/*

 * The Audio PLL is supposed to have 3 outputs: 2 fixed factors from

 * the base (2x and 4x), and one variable divider (the one true pll audio).

 *

 * We don't have any need for the variable divider for now, so we just

 * hardcode it to match with the clock names.

 input divider */

 M */

 P */

 mux */

 M */

 P */

 mux */

 M */

 P */

 mux */

 M */

 P */

 mux */

 M */

 mux */

 gate */

 M */

 mux */

 gate */

 M */

 mux */

 gate */

 M */

 mux */

 gate */

 Also applies to EMCE */

 M */

 N */

 mux */

 gate */

 M */

 mux */

 gate */

 M */

 N */

 mux */

 gate */

 M */

 mux */

 gate */

 M */

 N */

 mux */

 gate */

 M */

 N */

 mux */

 gate */

 M */

 N */

 mux */

 gate */

 post-div */

 M */

 N */

 mux */

 gate */

 post-div */

 M */

 N */

 mux */

 gate */

 post-div */

 M */

 N */

 mux */

 gate */

 M */

 N */

 mux */

 gate */

 M */

 N */

 mux */

 gate */

 M */

 N */

 mux */

 gate */

/*

 * There are OHCI 12M clock source selection bits for 2 USB 2.0 ports.

 * We will force them to 0 (12M divided from 48M).

 M */

 gate */

 M */

 gate */

 M */

 mux */

 gate */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 mux */

 gate */

 M */

 mux */

 gate */

 M */

 mux */

 gate */

 Fixed factor clocks */

/*

 * The divider of pll-audio is fixed to 24 for now, so 24576000 and 22579200

 * rates can be set exactly in conjunction with sigma-delta modulation.

 Enable the lock bits on all PLLs */

	/*

	 * Force the output divider of video PLLs to 0.

	 *

	 * See the comment before pll-video0 definition for the reason.

	/*

	 * Force OHCI 12M clock sources to 00 (12MHz divided from 48MHz)

	 *

	 * This clock mux is still mysterious, and the code just enforces

	 * it to have a valid clock parent.

	/*

	 * Force the post-divider of pll-audio to 12 and the output divider

	 * of it to 2, so 24576000 and 22579200 rates can be set exactly.

	/*

	 * First clock parent (osc32K) is unusable for CEC. But since there

	 * is no good way to force parent switch (both run with same frequency),

	 * just set second clock parent here.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2016 Chen-Yu Tsai

 *

 * Chen-Yu Tsai <wens@csie.org>

 *

 * Based on ccu-sun8i-h3.c by Maxime Ripard.

 N */

 K */

 M */

 gate */

 lock */

/*

 * The Audio PLL is supposed to have 4 outputs: 3 fixed factors from

 * the base (2x, 4x and 8x), and one variable divider (the one true

 * pll audio).

 *

 * With sigma-delta modulation for fractional-N on the audio PLL,

 * we have to use specific dividers. This means the variable divider

 * can no longer be used, as the audio codec requests the exact clock

 * rates we support through this mechanism. So we now hard code the

 * variable divider to 1. This means the clock rates will no longer

 * match the clock names.

 N */

 M */

 gate */

 lock */

 N */

 M */

 frac enable */

 frac select */

 frac rate 0 */

 frac rate 1 */

 gate */

 lock */

 N */

 M */

 frac enable */

 frac select */

 frac rate 0 */

 frac rate 1 */

 gate */

 lock */

 N */

 K */

 M */

 gate */

 lock */

 N */

 K */

 gate */

 lock */

 post-div */

 N */

 M */

 frac enable */

 frac select */

 frac rate 0 */

 frac rate 1 */

 gate */

 lock */

 N */

 M */

 frac enable */

 frac select */

 frac rate 0 */

 frac rate 1 */

 gate */

 lock */

/*

 * The MIPI PLL has 2 modes: "MIPI" and "HDMI".

 *

 * The MIPI mode is a standard NKM-style clock. The HDMI mode is an

 * integer / fractional clock with switchable multipliers and dividers.

 * This is not supported here. We hardcode the PLL to MIPI mode.

 N */

 K */

 M */

 mux */

 gate */

 lock */

 N */

 M */

 frac enable */

 frac select */

 frac rate 0 */

 frac rate 1 */

 gate */

 lock */

 N */

 M */

 frac enable */

 frac select */

 frac rate 0 */

 frac rate 1 */

 gate */

 lock */

 Sentinel */ },

 Sentinel */ },

 M */

 P */

 mux */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 TODO emac clk not supported yet */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 mux */

 gate */

 M */

 mux */

 gate */

 We hardcode the divider to 1 for now */

 > 8 clock cycles at 24 MHz */

 index of 24 MHz oscillator */

 Force the PLL-Audio-1x divider to 1 */

 Force PLL-MIPI to MIPI mode */

 Force AHB1 to PLL6 / 3 */

 set PLL6 pre-div = 3 */

 select PLL6 / pre-div */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2016 Maxime Ripard

 * Maxime Ripard <maxime.ripard@free-electrons.com>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2017 Icenowy Zheng <icenowy@aosc.io>

 TODO: The result of N*K is required to be in [10, 88] range. */

/*

 * The Audio PLL is supposed to have 4 outputs: 3 fixed factors from

 * the base (2x, 4x and 8x), and one variable divider (the one true

 * pll audio).

 *

 * With sigma-delta modulation for fractional-N on the audio PLL,

 * we have to use specific dividers. This means the variable divider

 * can no longer be used, as the audio codec requests the exact clock

 * rates we support through this mechanism. So we now hard code the

 * variable divider to 1. This means the clock rates will no longer

 * match the clock names.

 N */

 M */

 gate */

 lock */

 Minimum rate */

 Maximum rate */

 N */

 M */

 frac enable */

 frac select */

 frac rate 0 */

 frac rate 1 */

 gate */

 lock */

 TODO: The result of N/M is required to be in [8, 25] range. */

 N */

 M */

 frac enable */

 frac select */

 frac rate 0 */

 frac rate 1 */

 gate */

 lock */

 TODO: The result of N*K is required to be in [10, 77] range. */

 N */

 K */

 M */

 gate */

 lock */

 TODO: The result of N*K is required to be in [21, 58] range. */

	/*

	 * The formula of pll-periph0 (1x) is 24MHz*N*K/2, and the formula

	 * of pll-periph0-sata is 24MHz*N*K/M/6, so the postdiv here is

	 * 6/2 = 3.

 TODO: The result of N*K is required to be in [21, 58] range. */

 Minimum rate */

 Maximum rate */

 N */

 M */

 frac enable */

 frac select */

 frac rate 0 */

 frac rate 1 */

 gate */

 lock */

 mux */

 gate */

 TODO: The result of N/M is required to be in [8, 25] range. */

 N */

 M */

 frac enable */

 frac select */

 frac rate 0 */

 frac rate 1 */

 gate */

 lock */

/*

 * The MIPI PLL has 2 modes: "MIPI" and "HDMI".

 *

 * The MIPI mode is a standard NKM-style clock. The HDMI mode is an

 * integer / fractional clock with switchable multipliers and dividers.

 * This is not supported here. We hardcode the PLL to MIPI mode.

 *

 * TODO: In the MIPI mode, M/N is required to be equal or lesser than 3,

 * which cannot be implemented now.

 TODO: The result of N/M is required to be in [8, 25] range. */

 N */

 M */

 frac enable */

 frac select */

 frac rate 0 */

 frac rate 1 */

 gate */

 lock */

 TODO: The N factor is required to be in [16, 75] range. */

 N */

 M */

 gate */

 lock */

 Sentinel */ },

 M */

 P */

 mux */

/*

 * In datasheet here's "Reserved", however the gate exists in BSP soucre

 * code.

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

/*

 * There are 3 OHCI 12M clock source selection bits in this register.

 * We will force them to 0 (12M divided from 48M).

 M */

 P */

 mux */

 gate */

 M */

 P */

 mux */

 gate */

/*

 * In the SoC's user manual, the P factor is mentioned, but not used in

 * the frequency formula.

 *

 * Here the factor is included, according to the BSP kernel source,

 * which contains the P factor of this clock.

 M */

 P */

 mux */

 gate */

 Fixed Factor clocks */

 We hardcode the divider to 1 for now */

 copy from pll_cpu_clk */

 > 8 clock cycles at 24 MHz */

 index of 24 MHz oscillator */

/*

 * Add a regmap for the GMAC driver (dwmac-sun8i) to access the

 * GMAC configuration register.

 * Only this register is allowed to be written, in order to

 * prevent overriding critical clock configuration.

 PLL_LOCK_CTRL_REG */

 other devices have no business accessing other registers */

 Force the PLL-Audio-1x divider to 1 */

 Force PLL-MIPI to MIPI mode */

 Force OHCI 12M parent to 12M divided from 48M */

	/*

	 * Force SYS 32k (otherwise known as LOSC throughout the CCU)

	 * clock parent to LOSC output from RTC module instead of the

	 * CCU's internal RC oscillator divided output.

 Gate then ungate PLL CPU after any rate changes */

 Reparent CPU during PLL CPU rate changes */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2016 Chen-Yu Tsai. All rights reserved.

 The bus clock needs to be enabled for us to access the registers */

 The reset control needs to be asserted for the controls to work */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2020 Yangtao Li <frank@allwinnertech.com>

 M */

 P */

 mux */

 gate */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2016 Maxime Ripard

 * Maxime Ripard <maxime.ripard@free-electrons.com>

	/*

	 * If width is 0, GENMASK() macro may not generate expected mask (0)

	 * as it falls under undefined behaviour by C standard due to shifts

	 * which are equal or greater than width of left operand. This can

	 * be easily avoided by explicitly checking if width is 0.

 SPDX-License-Identifier:	GPL-2.0

/*

 * Copyright (C) 2017, Intel Corporation

 Clock Manager offsets */

 PLL Clock enable bits */

 read VCO1 reg for numerator and denominator */

 read VCO1 reg for numerator and denominator */

 Read mdiv and fdiv from the fdbck register */

 read VCO1 reg for numerator and denominator */

 Read mdiv and fdiv from the fdbck register */

 Bring PLL out of reset */

 Bring PLL out of reset */

 SPDX-License-Identifier:	GPL-2.0

/*

 * Copyright (C) 2017, Intel Corporation

 EMACA bypass to bootclk @0xB0 offset */

 only applicable if parent is maca */

 only applicable if parent is macb */

 EMACA bypass to bootclk @0x88 offset */

 only applicable if parent is maca */

 only applicable if parent is macb */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright 2011-2012 Calxeda, Inc.

 *  Copyright (C) 2012-2013 Altera Corporation <www.altera.com>

 *

 * Based from clk-highbank.c

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright 2011-2012 Calxeda, Inc.

 *  Copyright (C) 2012-2013 Altera Corporation <www.altera.com>

 *

 * Based from clk-highbank.c

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2015 Altera Corporation. All rights reserved

 SPDX-License-Identifier:	GPL-2.0

/*

 * Copyright (C) 2017, Intel Corporation

 handle the bypass first */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2015 Altera Corporation. All rights reserved

 SDMMC Group for System Manager defines */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright 2011-2012 Calxeda, Inc.

 *  Copyright (C) 2012-2013 Altera Corporation <www.altera.com>

 *

 * Based from clk-highbank.c

 Clock bypass bits */

 SPDX-License-Identifier:	GPL-2.0

/*

 * Copyright (C) 2017, Intel Corporation

 clocks in AO (always on) controller */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2019, Intel Corporation

 clocks in AO (always on) controller */

	/*

	 * The l4_sp_clk feeds a 100 MHz clock to various peripherals, one of them

	 * being the SP timers, thus cannot get gated.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright 2011-2012 Calxeda, Inc.

 *  Copyright (C) 2012-2013 Altera Corporation <www.altera.com>

 *

 * Based from clk-highbank.c

 SDMMC Group for System Manager defines */

 QSPI clock */

 QSPI clock */

 Check for GPIO_DB_CLK by its offset */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2015 Altera Corporation. All rights reserved

 Clock Manager offsets */

 Clock bypass bits */

 read VCO1 reg for numerator and denominator */

 SPDX-License-Identifier: GPL-2.0



 Spreadtrum divider clock driver



 Copyright (C) 2017 Spreadtrum, Inc.

 Author: Chunyan Zhang <chunyan.zhang@spreadtrum.com>

 SPDX-License-Identifier: GPL-2.0



 Spreadtrum multiplexer clock driver



 Copyright (C) 2017 Spreadtrum, Inc.

 Author: Chunyan Zhang <chunyan.zhang@spreadtrum.com>

 SPDX-License-Identifier: GPL-2.0



 Spreadtrum gate clock driver



 Copyright (C) 2017 Spreadtrum, Inc.

 Author: Chunyan Zhang <chunyan.zhang@spreadtrum.com>

	/*

	 * Each set/clear gate clock has three registers:

	 * common->reg			- base register

	 * common->reg + offset		- set register

	 * common->reg + 2 * offset	- clear register

 SPDX-License-Identifier: GPL-2.0



 Spreadtrum composite clock driver



 Copyright (C) 2017 Spreadtrum, Inc.

 Author: Chunyan Zhang <chunyan.zhang@spreadtrum.com>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Unisoc SC9863A clock driver

 *

 * Copyright (C) 2019 Unisoc, Inc.

 * Author: Chunyan Zhang <chunyan.zhang@unisoc.com>

 mpll*_gate clocks control cpu cores, they were enabled by default */

 address base is 0x402b0000 */

 lock_done	*/

 div_s	*/

 mod_en	*/

 sdm_en	*/

 refin	*/

 ibias	*/

 n		*/

 nint		*/

 kint		*/

 prediv	*/

 postdiv	*/

 lock_done	*/

 div_s	*/

 mod_en	*/

 sdm_en	*/

 refin	*/

 ibias	*/

 n		*/

 nint		*/

 kint		*/

 prediv	*/

 postdiv	*/

 lock_done	*/

 div_s	*/

 mod_en	*/

 sdm_en	*/

 refin	*/

 ibias	*/

 n		*/

 nint		*/

 kint		*/

 prediv	*/

 postdiv	*/

 address base is 0x40353000 */

 address base is 0x40359000 */

 address base is 0x4035c000 */

 address base is 0x40363000 */

 address base is 0x402d0000 */

 address base is 0x21500000 */

 address base is 0x20e00000 */

 aon gate clocks */

 address base is 0x402e0000 */

 mm gate clocks */

 address base is 0x60800000 */

 camera sensor clocks */

 address base is 0x60900000 */

 uart1_eb is for console, don't gate even if unused */

 address base is 0x71300000 */

 0x21500000 */

 0x402b0000 */

 0x40353000 */

 0x40359000 */

 0x4035c000 */

 0x40363000 */

 0x402d0000 */

 0x20e00000 */

 0x402e0000 */

 0x60800000 */

 0x60900000 */

 0x71300000 */

 SPDX-License-Identifier: GPL-2.0



 Spreadtrum pll clock driver



 Copyright (C) 2015~2017 Spreadtrum, Inc.

 Author: Chunyan Zhang <chunyan.zhang@spreadtrum.com>

 table[0] indicates the number of items in this table */

 SPDX-License-Identifier: GPL-2.0



 Spreatrum SC9860 clock driver



 Copyright (C) 2017 Spreadtrum, Inc.

 Author: Chunyan Zhang <chunyan.zhang@spreadtrum.com>

 address base is 0x402b0000 */

 GPLL/LPLL/DPLL/RPLL/CPLL */

 TWPLL/MPLL0/MPLL1 */

 lock_done	*/

 div_s	*/

 mod_en	*/

 sdm_en	*/

 refin	*/

 ibias	*/

 n		*/

 nint		*/

 kint		*/

 prediv	*/

 postdiv	*/

 lock_done	*/

 div_s	*/

 mod_en	*/

 sdm_en	*/

 refin	*/

 ibias	*/

 n		*/

 nint		*/

 kint		*/

 prediv	*/

 postdiv	*/

 lock_done	*/

 div_s	*/

 mod_en	*/

 sdm_en	*/

 refin	*/

 ibias	*/

 n		*/

 nint		*/

 kint		*/

 prediv	*/

 postdiv	*/

 lock_done	*/

 div_s	*/

 mod_en	*/

 sdm_en	*/

 refin	*/

 ibias	*/

 n		*/

 nint		*/

 kint		*/

 prediv	*/

 postdiv	*/

 lock_done	*/

 div_s	*/

 mod_en	*/

 sdm_en	*/

 refin	*/

 ibias	*/

 n		*/

 nint		*/

 kint		*/

 prediv	*/

 postdiv	*/

 lock_done	*/

 div_s	*/

 mod_en	*/

 sdm_en	*/

 refin	*/

 ibias	*/

 n		*/

 nint		*/

 kint		*/

 prediv	*/

 postdiv	*/

 lock_done	*/

 div_s	*/

 mod_en	*/

 sdm_en	*/

 refin	*/

 ibias	*/

 n		*/

 nint		*/

 kint		*/

 prediv	*/

 postdiv	*/

 lock_done	*/

 div_s	*/

 mod_en	*/

 sdm_en	*/

 refin	*/

 ibias	*/

 n		*/

 nint		*/

 kint		*/

 prediv	*/

 postdiv	*/

 address base is 0x40400000 */

 address base is 0x20000000 */

 address base is 0x402d0000 */

 address base is 0x20210000 */

 address base is 0x402e0000 */

 address base is 0x40880000 */

 address base is 0x415e0000 */

 address base is 0x60200000 */

 address base is 0x61000000 */

 address base is 0x61100000 */

 address base is 0x62000000 */

 address base is 0x62100000 */

 address base is 0x63000000 */

 address base is 0x63100000 */

 address base is 0x70b00000 */

 0x402b */

 0x4040 */

 0x2000 */

 0x402d */

 0x2021 */

 0x402e */

 0x4088 */

 0x415e */

 0x6020 */

 0x6100 */

 0x6110 */

 0x6200 */

 0x6210 */

 0x6300 */

 0x6310 */

 0x70b0 */

 SPDX-License-Identifier: GPL-2.0



 Spreadtrum clock infrastructure



 Copyright (C) 2017 Spreadtrum, Inc.

 Author: Chunyan Zhang <chunyan.zhang@spreadtrum.com>

/*

 * Copyright (C) 2012 Avionic Design GmbH

 *

 * Permission is hereby granted, free of charge, to any person obtaining a

 * copy of this software and associated documentation files (the "Software"),

 * to deal in the Software without restriction, including without limitation

 * the rights to use, copy, modify, merge, publish, distribute, sub license,

 * and/or sell copies of the Software, and to permit persons to whom the

 * Software is furnished to do so, subject to the following conditions:

 *

 * The above copyright notice and this permission notice (including the

 * next paragraph) shall be included in all copies or substantial portions

 * of the Software.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR

 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,

 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL

 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER

 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING

 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER

 * DEALINGS IN THE SOFTWARE.

 compute checksum */

/**

 * hdmi_avi_infoframe_init() - initialize an HDMI AVI infoframe

 * @frame: HDMI AVI infoframe

/**

 * hdmi_avi_infoframe_check() - check a HDMI AVI infoframe

 * @frame: HDMI AVI infoframe

 *

 * Validates that the infoframe is consistent and updates derived fields

 * (eg. length) based on other fields.

 *

 * Returns 0 on success or a negative error code on failure.

/**

 * hdmi_avi_infoframe_pack_only() - write HDMI AVI infoframe to binary buffer

 * @frame: HDMI AVI infoframe

 * @buffer: destination buffer

 * @size: size of buffer

 *

 * Packs the information contained in the @frame structure into a binary

 * representation that can be written into the corresponding controller

 * registers. Also computes the checksum as required by section 5.3.5 of

 * the HDMI 1.4 specification.

 *

 * Returns the number of bytes packed into the binary buffer or a negative

 * error code on failure.

 checksum */

 start infoframe payload */

	/*

	 * Data byte 1, bit 4 has to be set if we provide the active format

	 * aspect ratio

 Bit 3 and 2 indicate if we transmit horizontal/vertical bar data */

/**

 * hdmi_avi_infoframe_pack() - check a HDMI AVI infoframe,

 *                             and write it to binary buffer

 * @frame: HDMI AVI infoframe

 * @buffer: destination buffer

 * @size: size of buffer

 *

 * Validates that the infoframe is consistent and updates derived fields

 * (eg. length) based on other fields, after which it packs the information

 * contained in the @frame structure into a binary representation that

 * can be written into the corresponding controller registers. This function

 * also computes the checksum as required by section 5.3.5 of the HDMI 1.4

 * specification.

 *

 * Returns the number of bytes packed into the binary buffer or a negative

 * error code on failure.

/**

 * hdmi_spd_infoframe_init() - initialize an HDMI SPD infoframe

 * @frame: HDMI SPD infoframe

 * @vendor: vendor string

 * @product: product string

 *

 * Returns 0 on success or a negative error code on failure.

/**

 * hdmi_spd_infoframe_check() - check a HDMI SPD infoframe

 * @frame: HDMI SPD infoframe

 *

 * Validates that the infoframe is consistent and updates derived fields

 * (eg. length) based on other fields.

 *

 * Returns 0 on success or a negative error code on failure.

/**

 * hdmi_spd_infoframe_pack_only() - write HDMI SPD infoframe to binary buffer

 * @frame: HDMI SPD infoframe

 * @buffer: destination buffer

 * @size: size of buffer

 *

 * Packs the information contained in the @frame structure into a binary

 * representation that can be written into the corresponding controller

 * registers. Also computes the checksum as required by section 5.3.5 of

 * the HDMI 1.4 specification.

 *

 * Returns the number of bytes packed into the binary buffer or a negative

 * error code on failure.

 checksum */

 start infoframe payload */

/**

 * hdmi_spd_infoframe_pack() - check a HDMI SPD infoframe,

 *                             and write it to binary buffer

 * @frame: HDMI SPD infoframe

 * @buffer: destination buffer

 * @size: size of buffer

 *

 * Validates that the infoframe is consistent and updates derived fields

 * (eg. length) based on other fields, after which it packs the information

 * contained in the @frame structure into a binary representation that

 * can be written into the corresponding controller registers. This function

 * also computes the checksum as required by section 5.3.5 of the HDMI 1.4

 * specification.

 *

 * Returns the number of bytes packed into the binary buffer or a negative

 * error code on failure.

/**

 * hdmi_audio_infoframe_init() - initialize an HDMI audio infoframe

 * @frame: HDMI audio infoframe

 *

 * Returns 0 on success or a negative error code on failure.

/**

 * hdmi_audio_infoframe_check() - check a HDMI audio infoframe

 * @frame: HDMI audio infoframe

 *

 * Validates that the infoframe is consistent and updates derived fields

 * (eg. length) based on other fields.

 *

 * Returns 0 on success or a negative error code on failure.

/**

 * hdmi_audio_infoframe_pack_only() - write HDMI audio infoframe to binary buffer

 * @frame: HDMI audio infoframe

 * @buffer: destination buffer

 * @size: size of buffer

 *

 * Packs the information contained in the @frame structure into a binary

 * representation that can be written into the corresponding controller

 * registers. Also computes the checksum as required by section 5.3.5 of

 * the HDMI 1.4 specification.

 *

 * Returns the number of bytes packed into the binary buffer or a negative

 * error code on failure.

 checksum */

 start infoframe payload */

/**

 * hdmi_audio_infoframe_pack() - check a HDMI Audio infoframe,

 *                               and write it to binary buffer

 * @frame: HDMI Audio infoframe

 * @buffer: destination buffer

 * @size: size of buffer

 *

 * Validates that the infoframe is consistent and updates derived fields

 * (eg. length) based on other fields, after which it packs the information

 * contained in the @frame structure into a binary representation that

 * can be written into the corresponding controller registers. This function

 * also computes the checksum as required by section 5.3.5 of the HDMI 1.4

 * specification.

 *

 * Returns the number of bytes packed into the binary buffer or a negative

 * error code on failure.

/**

 * hdmi_vendor_infoframe_init() - initialize an HDMI vendor infoframe

 * @frame: HDMI vendor infoframe

 *

 * Returns 0 on success or a negative error code on failure.

	/*

	 * 0 is a valid value for s3d_struct, so we use a special "not set"

	 * value

 for side by side (half) we also need to provide 3D_Ext_Data */

 only one of those can be supplied */

/**

 * hdmi_vendor_infoframe_check() - check a HDMI vendor infoframe

 * @frame: HDMI infoframe

 *

 * Validates that the infoframe is consistent and updates derived fields

 * (eg. length) based on other fields.

 *

 * Returns 0 on success or a negative error code on failure.

/**

 * hdmi_vendor_infoframe_pack_only() - write a HDMI vendor infoframe to binary buffer

 * @frame: HDMI infoframe

 * @buffer: destination buffer

 * @size: size of buffer

 *

 * Packs the information contained in the @frame structure into a binary

 * representation that can be written into the corresponding controller

 * registers. Also computes the checksum as required by section 5.3.5 of

 * the HDMI 1.4 specification.

 *

 * Returns the number of bytes packed into the binary buffer or a negative

 * error code on failure.

 checksum */

 HDMI OUI */

 video format */

 video format */

 video format */

/**

 * hdmi_vendor_infoframe_pack() - check a HDMI Vendor infoframe,

 *                                and write it to binary buffer

 * @frame: HDMI Vendor infoframe

 * @buffer: destination buffer

 * @size: size of buffer

 *

 * Validates that the infoframe is consistent and updates derived fields

 * (eg. length) based on other fields, after which it packs the information

 * contained in the @frame structure into a binary representation that

 * can be written into the corresponding controller registers. This function

 * also computes the checksum as required by section 5.3.5 of the HDMI 1.4

 * specification.

 *

 * Returns the number of bytes packed into the binary buffer or a negative

 * error code on failure.

/**

 * hdmi_drm_infoframe_init() - initialize an HDMI Dynaminc Range and

 * mastering infoframe

 * @frame: HDMI DRM infoframe

 *

 * Returns 0 on success or a negative error code on failure.

/**

 * hdmi_drm_infoframe_check() - check a HDMI DRM infoframe

 * @frame: HDMI DRM infoframe

 *

 * Validates that the infoframe is consistent.

 * Returns 0 on success or a negative error code on failure.

/**

 * hdmi_drm_infoframe_pack_only() - write HDMI DRM infoframe to binary buffer

 * @frame: HDMI DRM infoframe

 * @buffer: destination buffer

 * @size: size of buffer

 *

 * Packs the information contained in the @frame structure into a binary

 * representation that can be written into the corresponding controller

 * registers. Also computes the checksum as required by section 5.3.5 of

 * the HDMI 1.4 specification.

 *

 * Returns the number of bytes packed into the binary buffer or a negative

 * error code on failure.

 checksum */

 start infoframe payload */

/**

 * hdmi_drm_infoframe_pack() - check a HDMI DRM infoframe,

 *                             and write it to binary buffer

 * @frame: HDMI DRM infoframe

 * @buffer: destination buffer

 * @size: size of buffer

 *

 * Validates that the infoframe is consistent and updates derived fields

 * (eg. length) based on other fields, after which it packs the information

 * contained in the @frame structure into a binary representation that

 * can be written into the corresponding controller registers. This function

 * also computes the checksum as required by section 5.3.5 of the HDMI 1.4

 * specification.

 *

 * Returns the number of bytes packed into the binary buffer or a negative

 * error code on failure.

/*

 * hdmi_vendor_any_infoframe_check() - check a vendor infoframe

 we only know about HDMI vendor infoframes */

/*

 * hdmi_vendor_any_infoframe_pack_only() - write a vendor infoframe to binary buffer

 we only know about HDMI vendor infoframes */

/*

 * hdmi_vendor_any_infoframe_pack() - check a vendor infoframe,

 *                                    and write it to binary buffer

/**

 * hdmi_infoframe_check() - check a HDMI infoframe

 * @frame: HDMI infoframe

 *

 * Validates that the infoframe is consistent and updates derived fields

 * (eg. length) based on other fields.

 *

 * Returns 0 on success or a negative error code on failure.

/**

 * hdmi_infoframe_pack_only() - write a HDMI infoframe to binary buffer

 * @frame: HDMI infoframe

 * @buffer: destination buffer

 * @size: size of buffer

 *

 * Packs the information contained in the @frame structure into a binary

 * representation that can be written into the corresponding controller

 * registers. Also computes the checksum as required by section 5.3.5 of

 * the HDMI 1.4 specification.

 *

 * Returns the number of bytes packed into the binary buffer or a negative

 * error code on failure.

/**

 * hdmi_infoframe_pack() - check a HDMI infoframe,

 *                         and write it to binary buffer

 * @frame: HDMI infoframe

 * @buffer: destination buffer

 * @size: size of buffer

 *

 * Validates that the infoframe is consistent and updates derived fields

 * (eg. length) based on other fields, after which it packs the information

 * contained in the @frame structure into a binary representation that

 * can be written into the corresponding controller registers. This function

 * also computes the checksum as required by section 5.3.5 of the HDMI 1.4

 * specification.

 *

 * Returns the number of bytes packed into the binary buffer or a negative

 * error code on failure.

/**

 * hdmi_infoframe_log() - log info of HDMI infoframe

 * @level: logging level

 * @dev: device

 * @frame: HDMI infoframe

/**

 * hdmi_avi_infoframe_unpack() - unpack binary buffer to a HDMI AVI infoframe

 * @frame: HDMI AVI infoframe

 * @buffer: source buffer

 * @size: size of buffer

 *

 * Unpacks the information contained in binary @buffer into a structured

 * @frame of the HDMI Auxiliary Video (AVI) information frame.

 * Also verifies the checksum as required by section 5.3.5 of the HDMI 1.4

 * specification.

 *

 * Returns 0 on success or a negative error code on failure.

/**

 * hdmi_spd_infoframe_unpack() - unpack binary buffer to a HDMI SPD infoframe

 * @frame: HDMI SPD infoframe

 * @buffer: source buffer

 * @size: size of buffer

 *

 * Unpacks the information contained in binary @buffer into a structured

 * @frame of the HDMI Source Product Description (SPD) information frame.

 * Also verifies the checksum as required by section 5.3.5 of the HDMI 1.4

 * specification.

 *

 * Returns 0 on success or a negative error code on failure.

/**

 * hdmi_audio_infoframe_unpack() - unpack binary buffer to a HDMI AUDIO infoframe

 * @frame: HDMI Audio infoframe

 * @buffer: source buffer

 * @size: size of buffer

 *

 * Unpacks the information contained in binary @buffer into a structured

 * @frame of the HDMI Audio information frame.

 * Also verifies the checksum as required by section 5.3.5 of the HDMI 1.4

 * specification.

 *

 * Returns 0 on success or a negative error code on failure.

/**

 * hdmi_vendor_any_infoframe_unpack() - unpack binary buffer to a HDMI

 * 	vendor infoframe

 * @frame: HDMI Vendor infoframe

 * @buffer: source buffer

 * @size: size of buffer

 *

 * Unpacks the information contained in binary @buffer into a structured

 * @frame of the HDMI Vendor information frame.

 * Also verifies the checksum as required by section 5.3.5 of the HDMI 1.4

 * specification.

 *

 * Returns 0 on success or a negative error code on failure.

 HDMI OUI */

/**

 * hdmi_drm_infoframe_unpack_only() - unpack binary buffer of CTA-861-G DRM

 *                                    infoframe DataBytes to a HDMI DRM

 *                                    infoframe

 * @frame: HDMI DRM infoframe

 * @buffer: source buffer

 * @size: size of buffer

 *

 * Unpacks CTA-861-G DRM infoframe DataBytes contained in the binary @buffer

 * into a structured @frame of the HDMI Dynamic Range and Mastering (DRM)

 * infoframe.

 *

 * Returns 0 on success or a negative error code on failure.

/**

 * hdmi_drm_infoframe_unpack() - unpack binary buffer to a HDMI DRM infoframe

 * @frame: HDMI DRM infoframe

 * @buffer: source buffer

 * @size: size of buffer

 *

 * Unpacks the CTA-861-G DRM infoframe contained in the binary @buffer into

 * a structured @frame of the HDMI Dynamic Range and Mastering (DRM)

 * infoframe. It also verifies the checksum as required by section 5.3.5 of

 * the HDMI 1.4 specification.

 *

 * Returns 0 on success or a negative error code on failure.

/**

 * hdmi_infoframe_unpack() - unpack binary buffer to a HDMI infoframe

 * @frame: HDMI infoframe

 * @buffer: source buffer

 * @size: size of buffer

 *

 * Unpacks the information contained in binary buffer @buffer into a structured

 * @frame of a HDMI infoframe.

 * Also verifies the checksum as required by section 5.3.5 of the HDMI 1.4

 * specification.

 *

 * Returns 0 on success or a negative error code on failure.

/*

 * linux/drivers/video/vgastate.c -- VGA state save/restore

 *

 * Copyright 2002 James Simmons

 *

 * Copyright history from vga16fb.c:

 *	Copyright 1999 Ben Pfaff and Petr Vandrovec

 *	Based on VGA info at http://www.goodnet.com/~tinara/FreeVGA/home.htm

 *	Based on VESA framebuffer (c) 1998 Gerd Knorr

 *

 * This file is subject to the terms and conditions of the GNU General

 * Public License.  See the file COPYING in the main directory of this

 * archive for more details.

 *

 if in graphics mode, no need to save */

 save regs */

 blank screen */

 save font at plane 2 */

 save font at plane 3 */

 save font at plane 0/1 */

 restore regs */

 unblank screen */

 save regs */

 blank screen */

 restore font at plane 2 */

 restore font at plane 3 */

 restore font at plane 0/1 */

 unblank screen */

 restore regs */

 turn off display */

 disable sequencer */

 enable palette addressing */

 unprotect vga regs */

 reenable sequencer */

 turn display on */

 disable video/palette source */

 assumes DAC is readable and writable */

 assumes DAC is readable and writable */

 exit if window is less than 32K */

		/*

		 * save only first 32K used by vgacon

		/*

		 * largely unused, but if required by the caller

		 * we'll just save everything.

		/*

		 * Save 8K at plane0[0], and 8K at plane1[16K]

 SPDX-License-Identifier: GPL-2.0-only

/*

 * generic display timing functions

 *

 * Copyright (c) 2012 Steffen Trumtrar <s.trumtrar@pengutronix.de>, Pengutronix

 SPDX-License-Identifier: GPL-2.0-only

/*

 * OF helpers for parsing display timings

 *

 * Copyright (c) 2012 Steffen Trumtrar <s.trumtrar@pengutronix.de>, Pengutronix

 *

 * based on of_videomode.c by Sascha Hauer <s.hauer@pengutronix.de>

/**

 * parse_timing_property - parse timing_entry from device_node

 * @np: device_node with the property

 * @name: name of the property

 * @result: will be set to the return value

 *

 * DESCRIPTION:

 * Every display_timing can be specified with either just the typical value or

 * a range consisting of min/typ/max. This function helps handling this

/**

 * of_parse_display_timing - parse display_timing entry from device_node

 * @np: device_node with the properties

 * @dt: display_timing that contains the result. I may be partially written in case of errors

/**

 * of_get_display_timing - parse a display_timing entry

 * @np: device_node with the timing subnode

 * @name: name of the timing node

 * @dt: display_timing struct to fill

/**

 * of_get_display_timings - parse all display_timing entries from a device_node

 * @np: device_node with the subnodes

 assume first child as native mode if none provided */

 if there is no child, it is useless to go on */

 should never happen, as entry was already found above */

			/*

			 * to not encourage wrong devicetrees, fail in case of

			 * an error

	/*

	 * native_mode points to the device_node returned by of_parse_phandle

	 * therefore call of_node_put on it

 SPDX-License-Identifier: GPL-2.0-only

/*

 * generic display timing functions

 *

 * Copyright (c) 2012 Steffen Trumtrar <s.trumtrar@pengutronix.de>, Pengutronix

 SPDX-License-Identifier: GPL-2.0-only

/*

 * generic videomode helper

 *

 * Copyright (c) 2012 Steffen Trumtrar <s.trumtrar@pengutronix.de>, Pengutronix

/**

 * of_get_videomode - get the videomode #<index> from devicetree

 * @np: devicenode with the display_timings

 * @vm: set to return value

 * @index: index into list of display_timings

 *	    (Set this to OF_USE_NATIVE_MODE to use whatever mode is

 *	     specified as native mode in the DT.)

 *

 * DESCRIPTION:

 * Get a list of all display timings and put the one

 * specified by index into *vm. This function should only be used, if

 * only one videomode is to be retrieved. A driver that needs to work

 * with multiple/all videomodes should work with

 * of_get_display_timings instead.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Driver for the Himax HX-8357 LCD Controller

 *

 * Copyright 2012 Free Electrons

	/*

	 * The controller needs 120ms when entering in sleep mode before we can

	 * send the command to go off sleep mode

	/*

	 * The controller needs 120ms when exiting from sleep mode before we

	 * can send the command to enter in sleep mode

 Reset the screen */

 The controller needs 120ms to recover from reset */

	/*

	 * Set the interface selection pins to SPI mode, with three

	 * wires

	/*

	 * The controller needs 120ms to fully recover from exiting sleep mode

	/*

	 * The controller needs 120ms to fully recover from exiting sleep mode

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  LCD/Backlight Driver for Sharp Zaurus Handhelds (various models)

 *

 *  Copyright (c) 2004-2006 Richard Purdie

 *

 *  Based on Sharp's 2.4 Backlight Driver

 *

 *  Copyright (c) 2008 Marvell International Ltd.

 *	Converted to SPI device based LCD/Backlight device driver

 *	by Eric Miao <eric.miao@marvell.com>

 Register Addresses */

 Register Bit Definitions */

 VW Supply FET ON */

 GVSS(-8V) Power Supply ON */

 VDD(8V),SVSS(-4V) Power Supply ON */

 VW Supply FET OFF */

 GVSS(-8V) Power Supply OFF */

 VDD(8V),SVSS(-4V) Power Supply OFF */

 COM Voltage DC Bias DAC Serial Data Clock */

 COM Voltage DC Bias DAC Serial Data Out */

 DAC Power Supply ON */

 COM Power Supply ON */

 VCC5 Power Supply ON */

 DAC Power Supply OFF */

 COM Power Supply OFF */

 VCC5 Power Supply OFF */

/*

 * This is only a pseudo I2C interface. We can't use the standard kernel

 * routines as the interface is write only. We just assume the data is acked...

 Set Common Voltage to M62332FP via I2C */

 Set Phase Adjust */

 Setting for VGA */

 Setting for QVGA */

 Initialize Internal Logic & Port */

 VDD(+8V), SVSS(-4V) ON */

 DAC ON */

 INIB = H, INI = L  */

 PICTL[0] = H , PICTL[1] = PICTL[2] = PICTL[4] = L */

 Set Common Voltage */

 VCC5 ON, DAC ON */

 GVSS(-8V) ON, VDD ON */

 COM SIGNAL ON (PICTL[3] = L) */

 COM ON, DAC ON, VCC5_ON */

 VW ON, GVSS ON, VDD ON */

 Signals output enable */

 Set Phase Adjust */

 Initialize for Input Signals from ATI */

 60Hz x 2 frame = 16.7msec x 2 = 33.4 msec */

 (1)VW OFF */

 (2)COM OFF */

 (3)Set Common Voltage Bias 0V */

 (4)GVSS OFF */

 (5)VCC5 OFF */

 (6)Set PDWN, INIOFF, DACOFF */

 (7)DAC OFF */

 (8)VDD OFF */

 Bit 5 via GPIO_BACKLIGHT_CONT */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * lm3533-bl.c -- LM3533 Backlight driver

 *

 * Copyright (C) 2011-2012 Texas Instruments

 *

 * Author: Johan Hovold <jhovold@gmail.com>

 until registered */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * LCD Lowlevel Control Abstraction

 *

 * Copyright (C) 2003,2004 Hewlett-Packard Company

 *

/* This callback gets called when something important happens inside a

 * framebuffer driver. We're looking if that important event is blanking,

 * and if it is, we're switching lcd power as well ...

 CONFIG_FB */

/**

 * lcd_device_register - register a new object of lcd_device class.

 * @name: the name of the new object(must be the same as the name of the

 *   respective framebuffer device).

 * @parent: pointer to the parent's struct device .

 * @devdata: an optional pointer to be stored in the device. The

 *   methods may retrieve it by using lcd_get_data(ld).

 * @ops: the lcd operations structure.

 *

 * Creates and registers a new lcd device. Returns either an ERR_PTR()

 * or a pointer to the newly allocated device.

/**

 * lcd_device_unregister - unregisters a object of lcd_device class.

 * @ld: the lcd device object to be unregistered and freed.

 *

 * Unregisters a previously registered via lcd_device_register object.

/**

 * devm_lcd_device_register - resource managed lcd_device_register()

 * @dev: the device to register

 * @name: the name of the device

 * @parent: a pointer to the parent device

 * @devdata: an optional pointer to be stored for private driver use

 * @ops: the lcd operations structure

 *

 * @return a struct lcd on success, or an ERR_PTR on error

 *

 * Managed lcd_device_register(). The lcd_device returned from this function

 * are automatically freed on driver detach. See lcd_device_register()

 * for more information.

/**

 * devm_lcd_device_unregister - resource managed lcd_device_unregister()

 * @dev: the device to unregister

 * @ld: the lcd device to unregister

 *

 * Deallocated a lcd allocated with devm_lcd_device_register(). Normally

 * this function will not need to be called and the resource management

 * code will ensure that the resource is freed.

/*

 * if this is compiled into the kernel, we need to ensure that the

 * class is registered before users of the class try to register lcd's

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * (C) Copyright 2008

 * Stefano Babic, DENX Software Engineering, sbabic@denx.de.

 *

 * This driver implements a lcd device for the ILITEK 922x display

 * controller. The interface to the display is SPI and the display's

 * memory is cyclically updated over the RGB interface.

 Register offset, see manual section 8.2 */

/*

 * maximum frequency for register access

 * (not for the GRAM access)

/*

 * Device ID as found in the datasheet (supports 9221 and 9222)

 Last two bits in the START BYTE */

/**

 * START_BYTE(id, rs, rw)

 *

 * Set the start byte according to the required operation.

 * The start byte is defined as:

 *   ----------------------------------

 *  | 0 | 1 | 1 | 1 | 0 | ID | RS | RW |

 *   ----------------------------------

 * @id: display's id as set by the manufacturer

 * @rs: operation type bit, one of:

 *	  - START_RS_INDEX	set the index register

 *	  - START_RS_REG	write/read registers/GRAM

 * @rw: read/write operation

 *	 - START_RW_WRITE	write

 *	 - START_RW_READ	read

/**

 * CHECK_FREQ_REG(spi_device s, spi_transfer x) - Check the frequency

 *	for the SPI transfer. According to the datasheet, the controller

 *	accept higher frequency for the GRAM transfer, but it requires

 *	lower frequency when the registers are read/written.

 *	The macro sets the frequency in the spi_transfer structure if

 *	the frequency exceeds the maximum value.

 * @s: pointer to an SPI device

 * @x: pointer to the read/write buffer pair

/*

 * ili922x_id - id as set by manufacturer

/*

 * driver's private structure

/**

 * ili922x_read_status - read status register from display

 * @spi: spi device

 * @rs:  output value

	/*

	 * we need 4-byte xfer here due to invalid dummy byte

	 * received after start byte

 dummy */

/**

 * ili922x_read - read register from display

 * @spi: spi device

 * @reg: offset of the register to be read

 * @rx:  output value

/**

 * ili922x_write - write a controller register

 * @spi: struct spi_device *

 * @reg: offset of the register to be written

 * @value: value to be written

/**

 * ili922x_reg_dump - dump all registers

 *

 * @spi: pointer to an SPI device

/**

 * set_write_to_gram_reg - initialize the display to write the GRAM

 * @spi: spi device

/**

 * ili922x_poweron - turn the display on

 * @spi: spi device

 *

 * The sequence to turn on the display is taken from

 * the datasheet and/or the example code provided by the

 * manufacturer.

 Power on */

 register 0x56 is not documented in the datasheet */

/**

 * ili922x_poweroff - turn the display off

 * @spi: spi device

 Power off */

/**

 * ili922x_display_init - initialize the display by setting

 *			  the configuration registers

 * @spi: spi device

 Set RGB interface */

 check if the device is connected */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * sky81452-backlight.c	SKY81452 backlight driver

 *

 * Copyright 2014 Skyworks Solutions Inc.

 * Author : Gyungoh Yoo <jack.yoo@skyworksinc.com>

 registers */

 bit mask */

/**

 * struct sky81452_platform_data

 * @name:	backlight driver name.

 *		If it is not defined, default name is lcd-backlight.

 * @gpiod_enable:GPIO descriptor which control EN pin

 * @enable:	Enable mask for current sink channel 1, 2, 3, 4, 5 and 6.

 * @ignore_pwm:	true if DPWMI should be ignored.

 * @dpwm_mode:	true is DPWM dimming mode, otherwise Analog dimming mode.

 * @phase_shift:true is phase shift mode.

 * @short_detection_threshold:	It should be one of 4, 5, 6 and 7V.

 * @boost_current_limit:	It should be one of 2300, 2750mA.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright (C) 2009-2010, Lars-Peter Clausen <lars@metafoo.de>

 *      PCF50633 backlight device driver

/*

 * pcf50633_bl_set_brightness_limit

 *

 * Update the brightness limit for the pc50633 backlight. The actual brightness

 * will not go above the limit. This is useful to limit power drain for example

 * on low battery.

 *

 * @dev: Pointer to a pcf50633 device

 * @limit: The brightness limit. Valid values are 0-63

	/*

	 * Should be different from bl_props.brightness, so we do not exit

	 * update_status early the first time it's called

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *

 * LCD driver for HP Jornada 700 series (710/720/728)

 * Copyright (C) 2006-2009 Kristoffer Ericson <kristoffer.ericson@gmail.com>

 start by sending our set contrast cmd to mcu */

 if successful push the new value */

 lets set our default values */

 give it some time to startup */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * TI LP8788 MFD - backlight driver

 *

 * Copyright 2012 Texas Instruments

 *

 * Author: Milo(Woogyom) Kim <milo.kim@ti.com>

 Register address */

	/*

	 * Update chip configuration if platform data exists,

	 * otherwise use the default settings.

 Brightness ramp up/down */

 Fullscale current setting */

 Brightness control mode */

 request PWM device with the consumer name */

		/*

		 * FIXME: pwm_apply_args() should be removed when switching to

		 * the atomic PWM API.

 Initial brightness */

 Backlight device name */

 SPDX-License-Identifier: GPL-2.0-only

/* drivers/video/backlight/platform_lcd.c

 *

 * Copyright 2008 Simtec Electronics

 *	Ben Dooks <ben@simtec.co.uk>

 *

 * Generic platform-device LCD power control interface.

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  Backlight Driver for the KB3886 Backlight

 *

 *  Copyright (c) 2007-2008 Claudio Nieder

 *

 *  Based on corgi_bl.c by Richard Purdie and kb3886 driver by Robert Woerle

/*

 * Back to driver

 SPDX-License-Identifier: GPL-2.0-only

/*

 * lms283gf05.c -- support for Samsung LMS283GF05 LCD

 *

 * Copyright (c) 2009 Marek Vasut <marek.vasut@gmail.com>

 Magic sequences supplied by manufacturer, for details refer to datasheet */

 REG, VALUE, DELAY */

 De-asserted */

 Asserted */

 De-asserted */

 Asserted */

 kick in the LCD */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * l4f00242t03.c -- support for Epson L4F00242T03 LCD

 *

 * Copyright 2007-2009 Freescale Semiconductor, Inc. All Rights Reserved.

 *

 * Copyright (c) 2009 Alberto Panizzo <maramaopercheseimorto@gmail.com>

 *	Inspired by Marek Vasut work in l4f00242t03.c

 tRES >= 100us */

 Do nothing, the LCD is running */

 priv->lcd_state == FB_BLANK_POWERDOWN */

 Send the display in standby */

 Do nothing, the LCD is already in standby */

 priv->lcd_state == FB_BLANK_POWERDOWN */

 power == FB_BLANK_POWERDOWN */

 Clear the screen before shutting down */

 Init the LCD */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Backlight driver for the Kinetic KTD253

 * Based on code and know-how from the Samsung GT-S7710

 * Gareth Phillips <gareth.phillips@samsung.com>

 Current ratio is n/32 from 1/32 to 32/32 */

 Additional 10ns as safety factor */

 Additional 10ns as safety factor */

 100 us, now it doesn't look good */

 We always fall back to this when we power on */

	/*

	 * These GPIO operations absolutely can NOT sleep so no _cansleep

	 * suffixes, and no using GPIO expanders on slow buses for this!

	 *

	 * The maximum number of cycles of the loop is 32  so the time taken

	 * should nominally be:

	 * (T_LOW_NS + T_HIGH_NS + loop_time) * 32

	 *

	 * Architectures do not always support ndelay() and we will get a few us

	 * instead. If we get to a critical time limit an interrupt has likely

	 * occured in the low part of the loop and we need to restart from the

	 * top so we have the backlight in a known state.

 This is already right */

		/*

		 * We need to keep the GPIO low for at least this long

		 * to actually switch the KTD253 off.

		/*

		 * These GPIO operations absolutely can NOT sleep so no

		 * _cansleep suffixes, and no using GPIO expanders on

		 * slow buses for this!

			/*

			 * Something disturbed the backlight setting code when

			 * running so we need to bring the PWM back to a known

			 * state. This shouldn't happen too much.

 After 1/32 we loop back to 32/32 */

 Clamp brightness to hardware max */

 Clamp default brightness to max brightness */

 Bring backlight to a known off state */

 When we just enable the GPIO line we set max brightness */

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Sanyo LV5207LP LED Driver

 *

 * Copyright (C) 2013 Ideas on board SPRL

 *

 * Contact: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *

 * Backlight driver for HP Jornada 700 series (710/720/728)

 * Copyright (C) 2006-2009 Kristoffer Ericson <kristoffer.ericson@gmail.com>

 check if backlight is on */

 cmd should return txdummy */

 exchange txdummy for value */

 If backlight is off then really turn it off */

 turn off backlight */

 turn on backlight */

 send command to our mcu */

	/*

	 * at this point we expect that the mcu has accepted

	 * our command and is waiting for our new value

	 * please note that maximum brightness is 255,

	 * but due to physical layout it is equal to 0, so we simply

	 * invert the value (MAX VALUE - NEW VALUE).

	/*

	 * If infact we get an TXDUMMY as output we are happy and dont

	 * make any further comments about it

	/*

	 * note. make sure max brightness is set otherwise

	 * you will get seemingly non-related errors when

	 * trying to change brightness

 SPDX-License-Identifier: GPL-2.0-only

/*

 * tdo24m - SPI-based drivers for Toppoly TDO24M series LCD panels

 *

 * Copyright (C) 2008 Marvell International Ltd.

 *	Eric Miao <eric.miao@marvell.com>

 use bit 30, 31 as the indicator of command parameter number */

 reset */

 nop */

 nop */

 nop */

 Display ON */

 Output Control */

 Sleep out */

 Wake */

 Display OFF */

 Output Control */

 Sleep in */

 Deep stand by in */

 Blanking period control (1) */

 Blanking period control (2) */

 CKV timing control on/off */

 CKV 1,2 timing control */

 OEV timing control */

 ASW timing control (1) */

 ASW timing control (2) */

 Invert for normally black display */

 Display on */

 Blanking period control (1) */

 Blanking period control (2) */

 CKV timing control on/off */

 CKV 1,2 timing control */

 OEV timing control */

 ASW timing control (1) */

 ASW timing control (2) */

 Invert for normally black display */

 Display on */

 Blanking period control (1) */

 Blanking period control (2) */

 CKV timing control on/off */

 CKV 1,2 timing control */

 OEV timing control */

 ASW timing control (1) */

 ASW timing control (2) */

 Invert for normally black display */

 Display on */

 Output control */

 sleep out */

 Display mode (1) */

 Display mode (2) */

 Display mode 18-bit RGB */

 Drive system change control */

 Booster operation setup */

 Booster mode setup */

 Booster frequency setup */

 Op amp/system clock */

 VCS voltage */

 VCOM voltage */

 External display signal */

 ASW slew rate */

 Dummy data for QuadData operation */

 Sleep out FR count (A) */

 Sleep out FR count (B) */

 Sleep out FR count (C) */

 Sleep out FR count (D) */

 Sleep out FR count (E) */

 Sleep out FR count (F) */

 Sleep out FR count (G) */

 Gamma 1 fine tuning (1) */

 Gamma 1 fine tuning (2) */

 Gamma 1 inclination adjustment */

 Gamma 1 blue offset adjustment */

 Horizontal clock cycles */

 default to VGA */

 Power down all displays on reboot, poweroff or halt */

 SPDX-License-Identifier: GPL-2.0

/* Driver for ORISE Technology OTM3225A SOC for TFT LCD

 * Copyright (C) 2017, EETS GmbH, Felix Brack <fb@ltec.ch>

 *

 * This driver implements a lcd device for the ORISE OTM3225A display

 * controller. The control interface to the display is SPI and the display's

 * memory is updated over the 16-bit RGB interface.

 * The main source of information for writing this driver was provided by the

 * OTM3225A datasheet from ORISE Technology. Some information arise from the

 * ILI9328 datasheet from ILITEK as well as from the datasheets and sample code

 * provided by Crystalfontz America Inc. who sells the CFAF240320A-032T, a 3.2"

 * TFT LC display using the OTM3225A controller.

 instruction register list */

 register to write */

 data to write to 'reg' */

 delay in ms after write */

 address register using index register */

 write data to addressed register */

 execute delay if any */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * ams369fg06 AMOLED LCD panel driver.

 *

 * Copyright (c) 2011 Samsung Electronics Co., Ltd.

 * Author: Jingoo Han  <jg1.han@samsung.com>

 *

 * Derived from drivers/video/s6e63m0.c

 gamma value: 2.2 */

 set brightness to current value after power on or resume. */

 ams369fg06 lcd panel uses 3-wire 16bits SPI Mode. */

		/*

		 * if lcd panel was off from bootloader then

		 * current lcd status is powerdown and then

		 * it enables lcd panel.

	/*

	 * when lcd panel is suspend, lcd panel becomes off

	 * regardless of status.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Backlight Driver for Dialog DA9052 PMICs

 *

 * Copyright(c) 2012 Dialog Semiconductor Ltd.

 *

 * Author: David Dajun Chen <dchen@diasemi.com>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Backlight driver for Maxim MAX8925

 *

 * Copyright (C) 2009 Marvell International Ltd.

 *      Haojian Zhuang <haojian.zhuang@marvell.com>

 enable WLED output */

 disable WLED output */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Simple PWM based backlight control, board code has to setup

 * 1) pin configuration so PWM waveforms can output

 * 2) platform_data being correctly configured

 luminance scale */

/*

 * CIE lightness to PWM conversion.

 *

 * The CIE 1931 lightness formula is what actually describes how we perceive

 * light:

 *          Y = (L* / 903.3)           if L* ≤ 8

 *          Y = ((L* + 16) / 116)^3    if L* > 8

 *

 * Where Y is the luminance, the amount of light coming out of the screen, and

 * is a number between 0.0 and 1.0; and L* is the lightness, how bright a human

 * perceives the screen to be, and is a number between 0 and 100.

 *

 * The following function does the fixed point maths needed to implement the

 * above formula.

	/*

	 * @lightness is given as a number between 0 and 1, expressed

	 * as a fixed-point number in scale

	 * PWM_LUMINANCE_SCALE. Convert to a percentage, still

	 * expressed as a fixed-point number, so the above formulas

	 * can be applied.

/*

 * Create a default correction table for PWM values to create linear brightness

 * for LED based backlights using the CIE1931 algorithm.

	/*

	 * Once we have 4096 levels there's little point going much higher...

	 * neither interactive sliders nor animation benefits from having

	 * more values in the table.

 Fill the table using the cie1931 algorithm */

	/*

	 * These values are optional and set as 0 by default, the out values

	 * are modified only if a valid u32 value can be decoded.

	/*

	 * Determine the number of brightness levels, if this property is not

	 * set a default table of brightness levels will be used.

 read brightness levels from DT property */

		/*

		 * This property is optional, if is set enables linear

		 * interpolation between each of the values of brightness levels

		 * and creates a new pre-computed table.

		/*

		 * Make sure that there is at least two entries in the

		 * brightness-levels table, otherwise we can't interpolate

		 * between two points.

			/*

			 * Recalculate the number of brightness levels, now

			 * taking in consideration the number of interpolated

			 * steps between two levels.

			/*

			 * Create a new table of brightness levels with all the

			 * interpolated steps.

			/*

			 * Fill the interpolated table[x] = y

			 * by draw lines between each (x1, y1) to (x2, y2).

 Fill in the last point, since no line starts here. */

			/*

			 * As we use interpolation lets remove current

			 * brightness levels table and replace for the

			 * new interpolated table.

	/*

	 * Multiplying by 128 means that even in pathological cases such

	 * as (max_val - min_val) == nlevels the error at max_val is less

	 * than 1%.

 5% */

	/*

	 * If the enable GPIO is present, observable (either as input

	 * or output) and off then the backlight is not currently active.

	/*

	 * Synchronize the enable_gpio with the observed state of the

	 * hardware.

	/*

	 * Do not change pb->enabled here! pb->enabled essentially

	 * tells us if we own one of the regulator's use counts and

	 * right now we do not.

 Not booted with device tree or no phandle link to the node */

	/*

	 * If the driver is probed from the device tree and there is a

	 * phandle link pointing to the backlight node, it is safe to

	 * assume that another driver will enable the backlight at the

	 * appropriate time. Therefore, if it is disabled, keep it so.

 Sync up PWM state. */

	/*

	 * The DT case will set the pwm_period_ns field to 0 and store the

	 * period, parsed from the DT, in the PWM device. For the non-DT case,

	 * set the period from platform data if it has not already been set

	 * via the PWM lookup table.

		/*

		 * For the DT case, only when brightness levels is defined

		 * data->levels is filled. For the non-DT case, data->levels

		 * can come from platform data, however is not usual.

		/*

		 * If no brightness levels are provided and max_brightness is

		 * not set, use the default brightness table. For the DT case,

		 * max_brightness is set to 0 when brightness levels is not

		 * specified. For the non-DT case, max_brightness is usually

		 * set to some value.

 Get the PWM period (in nanoseconds) */

		/*

		 * That only happens for the non-DT case, where platform data

		 * sets the max_brightness value.

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  Backlight Driver for Intel-based Apples

 *

 *  Copyright (c) Red Hat <mjg@redhat.com>

 *  Based on code from Pommed:

 *  Copyright (C) 2006 Nicolas Boichat <nicolas @boichat.ch>

 *  Copyright (C) 2006 Felipe Alfaro Solana <felipe_alfaro @linuxmail.org>

 *  Copyright (C) 2007 Julien BLACHE <jb@jblache.org>

 *

 *  This driver triggers SMIs which cause the firmware to change the

 *  backlight brightness. This is icky in many ways, but it's impractical to

 *  get at the firmware code in order to figure out what it's actually doing.

 I/O resource to allocate. */

 Backlight operations structure. */

 Module parameters. */

/*

 * Implementation for machines with Intel chipset.

/*

 * Implementation for machines with Nvidia chipset.

 Check that the hardware responds - this may not work under EFI */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Backlight driver for Wolfson Microelectronics WM831x PMICs

 *

 * Copyright 2009 Wolfson Microelectonics plc

 Enable the ISINK */

 Enable the DC-DC */

 DCDC first */

 ISINK */

 Set the new brightness */

 Drive current through the ISINK */

	/* If we were in the middle of a power transition always shut down

	 * for safety.

 We need platform data */

 Figure out the maximum current we can use */

 Configure the ISINK to use for feedback */

 Disable the DCDC if it was started so we can bootstrap */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Backlight Lowlevel Control Abstraction

 *

 * Copyright (C) 2003,2004 Hewlett-Packard Company

 *

/**

 * DOC: overview

 *

 * The backlight core supports implementing backlight drivers.

 *

 * A backlight driver registers a driver using

 * devm_backlight_device_register(). The properties of the backlight

 * driver such as type and max_brightness must be specified.

 * When the core detect changes in for example brightness or power state

 * the update_status() operation is called. The backlight driver shall

 * implement this operation and use it to adjust backlight.

 *

 * Several sysfs attributes are provided by the backlight core::

 *

 * - brightness         R/W, set the requested brightness level

 * - actual_brightness  RO, the brightness level used by the HW

 * - max_brightness     RO, the maximum  brightness level supported

 *

 * See Documentation/ABI/stable/sysfs-class-backlight for the full list.

 *

 * The backlight can be adjusted using the sysfs interface, and

 * the backlight driver may also support adjusting backlight using

 * a hot-key or some other platform or firmware specific way.

 *

 * The driver must implement the get_brightness() operation if

 * the HW do not support all the levels that can be specified in

 * brightness, thus providing user-space access to the actual level

 * via the actual_brightness attribute.

 *

 * When the backlight changes this is reported to user-space using

 * an uevent connected to the actual_brightness attribute.

 * When brightness is set by platform specific means, for example

 * a hot-key to adjust backlight, the driver must notify the backlight

 * core that brightness has changed using backlight_force_update().

 *

 * The backlight driver core receives notifications from fbdev and

 * if the event is FB_EVENT_BLANK and if the value of blank, from the

 * FBIOBLANK ioctrl, results in a change in the backlight state the

 * update_status() operation is called.

/*

 * fb_notifier_callback

 *

 * This callback gets called when something important happens inside a

 * framebuffer driver. The backlight core only cares about FB_BLANK_UNBLANK

 * which is reported to the driver using backlight_update_status()

 * as a state change.

 *

 * There may be several fbdev's connected to the backlight device,

 * in which case they are kept track of. A state change is only reported

 * if there is a change in backlight for the specified fbdev.

 If we aren't interested in this event, skip it immediately ... */

 CONFIG_FB */

/**

 * backlight_force_update - tell the backlight subsystem that hardware state

 *   has changed

 * @bd: the backlight device to update

 * @reason: reason for update

 *

 * Updates the internal state of the backlight in response to a hardware event,

 * and generates an uevent to notify userspace. A backlight driver shall call

 * backlight_force_update() when the backlight is changed using, for example,

 * a hot-key. The updated brightness is read using get_brightness() and the

 * brightness value is reported using an uevent.

 deprecated - use devm_backlight_device_register() */

 Set default properties */

/** backlight_device_get_by_type - find first backlight device of a type

 * @type: the type of backlight device

 *

 * Look up the first backlight device of the specified type

 *

 * RETURNS:

 *

 * Pointer to backlight device if any was found. Otherwise NULL.

/**

 * backlight_device_get_by_name - Get backlight device by name

 * @name: Device name

 *

 * This function looks up a backlight device by its name. It obtains a reference

 * on the backlight device and it is the caller's responsibility to drop the

 * reference by calling backlight_put().

 *

 * Returns:

 * A pointer to the backlight device if found, otherwise NULL.

 deprecated - use devm_backlight_device_unregister() */

/**

 * backlight_register_notifier - get notified of backlight (un)registration

 * @nb: notifier block with the notifier to call on backlight (un)registration

 *

 * Register a notifier to get notified when backlight devices get registered

 * or unregistered.

 *

 * RETURNS:

 *

 * 0 on success, otherwise a negative error code

/**

 * backlight_unregister_notifier - unregister a backlight notifier

 * @nb: notifier block to unregister

 *

 * Register a notifier to get notified when backlight devices get registered

 * or unregistered.

 *

 * RETURNS:

 *

 * 0 on success, otherwise a negative error code

/**

 * devm_backlight_device_register - register a new backlight device

 * @dev: the device to register

 * @name: the name of the device

 * @parent: a pointer to the parent device (often the same as @dev)

 * @devdata: an optional pointer to be stored for private driver use

 * @ops: the backlight operations structure

 * @props: the backlight properties

 *

 * Creates and registers new backlight device. When a backlight device

 * is registered the configuration must be specified in the @props

 * parameter. See description of &backlight_properties.

 *

 * RETURNS:

 *

 * struct backlight on success, or an ERR_PTR on error

/**

 * devm_backlight_device_unregister - unregister backlight device

 * @dev: the device to unregister

 * @bd: the backlight device to unregister

 *

 * Deallocates a backlight allocated with devm_backlight_device_register().

 * Normally this function will not need to be called and the resource management

 * code will ensure that the resources are freed.

/**

 * of_find_backlight_by_node() - find backlight device by device-tree node

 * @node: device-tree node of the backlight device

 *

 * Returns a pointer to the backlight device corresponding to the given DT

 * node or NULL if no such backlight device exists or if the device hasn't

 * been probed yet.

 *

 * This function obtains a reference on the backlight device and it is the

 * caller's responsibility to drop the reference by calling put_device() on

 * the backlight device's .dev field.

/**

 * devm_of_find_backlight - find backlight for a device

 * @dev: the device

 *

 * This function looks for a property named 'backlight' on the DT node

 * connected to @dev and looks up the backlight device. The lookup is

 * device managed so the reference to the backlight device is automatically

 * dropped on driver detach.

 *

 * RETURNS:

 *

 * A pointer to the backlight device if found.

 * Error pointer -EPROBE_DEFER if the DT property is set, but no backlight

 * device is found. NULL if there's no backlight property.

/*

 * if this is compiled into the kernel, we need to ensure that the

 * class is registered before users of the class try to register lcd's

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Backlight driver for Dialog Semiconductor DA9030/DA9034

 *

 * Copyright (C) 2008 Compulab, Ltd.

 *	Mike Rapoport <mike@compulab.co.il>

 *

 * Copyright (C) 2006-2008 Marvell International Ltd.

 *	Eric Miao <eric.miao@marvell.com>

 adjust the WLED output current */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  LCD / Backlight control code for Sharp SL-6000x (tosa)

 *

 *  Copyright (c) 2005		Dirk Opfer

 *  Copyright (c) 2007,2008	Dmitry Baryshkov

 SetBacklightDuty */

 SetBacklightVR */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Backlight driver for Analog Devices ADP5520/ADP5501 MFD PMICs

 *

 * Copyright 2009 Analog Devices Inc.

 Disable Ambient Light auto adjust */

			/*

			 * MAX_BRIGHTNESS -> Enable Ambient Light auto adjust

			 * restore daylight l3 sysfs brightness

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Backlight driver for ArcticSand ARC_X_C_0N_0N Devices

 *

 * Copyright 2016 ArcticSand, Inc.

 * Author : Brian Dodge <bdodge@arcticsand.com>

/**

 * struct arcxcnn_platform_data

 * @name		: Backlight driver name (NULL will use default)

 * @initial_brightness	: initial value of backlight brightness

 * @leden		: initial LED string enables, upper bit is global on/off

 * @led_config_0	: fading speed (period between intensity steps)

 * @led_config_1	: misc settings, see datasheet

 * @dim_freq		: pwm dimming frequency if in pwm mode

 * @comp_config		: misc config, see datasheet

 * @filter_config	: RC/PWM filter config, see datasheet

 * @trim_config		: full scale current trim, see datasheet

 Command Register */

   I2C Standby */

   Reset */

   Boost */

   --- Over Voltage Threshold */

   <rsvrd> Over Voltage Threshold */

   20v Over Voltage Threshold */

   24v Over Voltage Threshold */

   31.4v Over Voltage Threshold */

   part (0) or full (1) ext. comp */

 Configuration */

 Status 1 */

 Status 2 */

 Fading Control */

 ILED Configuration */

   config dim mode pwm */

   config dim mode internal */

 LED Enable Register */

   Full-scale current set extern */

   LED string enables mask */

   Bits of LED string enables */

 LED ISET LSB (in upper nibble) */

 ISET LSB Left Shift */

 LED ISET MSB (8 bits) */

 lower nibble of brightness goes in upper nibble of LSB register */

 remaining 8 bits of brightness go in MSB register */

 set power-on/off/save modes */

 device tree entry isn't required, defaults are OK */

 all on is default */

 for each enable in source, set bit in led enable */

 reset the device */

 Setup defaults based on power-on defaults */

 insure dim mode is not default pwm */

 constrain settings to what is possible */

 set initial brightness */

 set other register values directly */

 set initial LED Enables */

 disable all strings (ignore errors) */

 reset the device (ignore errors) */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Power control for Samsung LTV350QV Quarter VGA LCD Panel

 *

 * Copyright (C) 2006, 2007 Atmel Corporation

/*

 * The power-on and power-off sequences are taken from the

 * LTV350QV-F04 data sheet from Samsung. The register definitions are

 * taken from the S6F2002 command list also from Samsung. Both

 * documents are distributed with the AVR32 Linux BSP CD from Atmel.

 *

 * There's still some voodoo going on here, but it's a lot better than

 * in the first incarnation of the driver where all we had was the raw

 * numbers from the initialization sequence.

 register index */

 register value */

 The comments are taken straight from the data sheet */

 Power On Reset Display off State */

 Power Setting Function 1 */

 Power Setting Function 2 */

 Instruction Setting */

 Wait more than 2 frames */

 Display On Sequence */

 Display should now be ON. Phew. */

	/*

	 * Try to recover. Error handling probably isn't very useful

	 * at this point, just make a best effort to switch the panel

	 * off.

 Display Off Sequence */

 Power down setting 1 */

 Wait at least 1 ms */

 Power down setting 2 */

	/*

	 * No point in trying to recover here. If we can't switch the

	 * panel off, what are we supposed to do other than inform the

	 * user about the failure?

 Display power should now be OFF */

 Power down all displays on reboot, poweroff or halt */

/*

 * tps65217_bl.c

 *

 * TPS65217 backlight driver

 *

 * Copyright (C) 2012 Matthias Kaehlcke

 * Author: Matthias Kaehlcke <matthias@kaehlcke.net>

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License as

 * published by the Free Software Foundation version 2.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

 select ISET_1 current level */

 select ISET2 current level */

 set PWM frequency */

 sentinel */ },

 SPDX-License-Identifier: GPL-2.0-only

/* drivers/video/backlight/vgg2432a4.c

 *

 * VGG2432A4 (ILI9320) LCD controller driver.

 *

 * Copyright 2007 Simtec Electronics

 *	http://armlinux.simtec.co.uk/

 *	Ben Dooks <ben@simtec.co.uk>

 Device initialisation sequences */

 set direction and scan mode gate */

 Set VCore before anything else (VGG243237-6UFLWA) */

 Start the oscillator up before we can do anything else. */

 must wait at-lesat 10ms after starting */

 Device probe */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * lms501kf03 TFT LCD panel driver.

 *

 * Copyright (c) 2012 Samsung Electronics Co., Ltd.

 * Author: Jingoo Han  <jg1.han@samsung.com>

	/*

	 * According to the datasheet, 120ms delay time is required.

	 * After sleep out sequence, command is blocked for 120ms.

	 * Thus, LDI should wait for 120ms.

 lms501kf03 lcd panel uses 3-wire 9-bit SPI Mode. */

		/*

		 * if lcd panel was off from bootloader then

		 * current lcd status is powerdown and then

		 * it enables lcd panel.

	/*

	 * when lcd panel is suspend, lcd panel becomes off

	 * regardless of status.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Backlight driver for OMAP based boards.

 *

 * Copyright (c) 2006 Andrzej Zaborowski  <balrog@zabor.org>

 Conflicts with UART3 */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * gpio_backlight.c - Simple GPIO-controlled backlight

 Set the initial power state */

 Not booted with device tree or no phandle link to the node */

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0+

/*

 * LCD Backlight driver for RAVE SP

 *

 * Copyright (C) 2018 Zodiac Inflight Innovations

 *

	/*

	 * If there is a phandle pointing to the device node we can

	 * assume that another device will manage the status changes.

	 * If not we make sure the backlight is in a consistent state.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * TI LP855x Backlight Driver

 *

 *			Copyright (C) 2011 Texas Instruments

 LP8550/1/2/3/6 Registers */

 LP8555/7 Registers */

/*

 * struct lp855x_device_config

 * @pre_init_device: init device function call before updating the brightness

 * @reg_brightness: register address for brigthenss control

 * @reg_devicectrl: register address for device control

 * @post_init_device: late init device function call

 regulator for VDD input */

 regulator for EN/VDDIO input */

 BL_ON = 0 before updating EPROM settings */

 BL_ON = 1 after updating EPROM settings */

/*

 * Device specific configuration flow

 *

 *    a) pre_init_device(optional)

 *    b) update the brightness register

 *    c) update device control register

 *    d) update ROM area(optional)

 *    e) post_init_device(optional)

 *

 request pwm device with the consumer name */

		/*

		 * FIXME: pwm_apply_args() should be removed when switching to

		 * the atomic PWM API.

 Fill ROM platform data if defined */

		/*

		 * LP8555 datasheet says t_RESPONSE (time between VDDIO and

		 * I2C) is 1ms.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Backlight driver for Analog Devices ADP8860 Backlight Devices

 *

 * Copyright 2009-2010 Analog Devices Inc.

 Manufacturer and device ID */

 Device mode and status */

 Device mode and Status Register 2 */

 Interrupts enable */

 Configuration register */

 Sink enable backlight or independent */

 Backlight off timeout */

 Backlight dim timeout */

 Backlight fade in and out rates */

 Backlight (Brightness Level 1-daylight) maximum current */

 Backlight (Brightness Level 1-daylight) dim current */

 Backlight (Brightness Level 2-office) maximum current */

 Backlight (Brightness Level 2-office) dim current */

 Backlight (Brightness Level 3-dark) maximum current */

 Backlight (Brightness Level 3-dark) dim current */

 Independent sink current fade control register */

 Independent sink current control register */

 Independent Sink Current Timer Register LED[7:5] */

 Independent Sink Current Timer Register LED[4:1] */

 Independent sink current fade register */

 Independent Sink Current LED7 */

 Independent Sink Current LED6 */

 Independent Sink Current LED5 */

 Independent Sink Current LED4 */

 Independent Sink Current LED3 */

 Independent Sink Current LED2 */

 Independent Sink Current LED1 */

 Comparator configuration */

 Second comparator configuration */

 L2 comparator reference */

 L2 hysteresis */

 L3 comparator reference */

 L3 hysteresis */

 First phototransistor ambient light level-low byte register */

 First phototransistor ambient light level-high byte register */

 Second phototransistor ambient light level-low byte register */

 Second phototransistor ambient light level-high byte register */

 Analog Devices ADP8860 Manufacturer ID */

 Analog Devices ADP8861 Manufacturer ID */

 Analog Devices ADP8863 Manufacturer ID */

 MDCR Device mode and status */

 ADP8860_CCFG Main ALS comparator level enable */

/*

 * Independent sink / LED

 Disable Ambient Light auto adjust */

			/*

			 * MAX_BRIGHTNESS -> Enable Ambient Light auto adjust

			 * restore daylight l1 sysfs brightness

 Return 13-bit conversion value for the first light sensor */

 Enable automatic ambient light sensing */

 Disable automatic ambient light sensing */

 Set user supplied ambient light zone */

 It's confirmed that the DEVID field is actually a REVID */

 SPDX-License-Identifier: GPL-2.0-only

 common properties */

 vendor properties */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Backlight driver for Pandora handheld.

 * Pandora uses TWL4030 PWM0 -> TPS61161 combo for control backlight.

 * Based on pwm_bl.c

 *

 * Copyright 2009,2012 Gražvydas Ignotas <notasas@gmail.com>

 range accepted by hardware */

 first disable PWM0 output, then clock */

		/*

		 * set PWM duty cycle to max. TPS61161 seems to use this

		 * to calibrate it's PWM sensitivity when it starts.

 first enable clock, then PWM0 out */

		/*

		 * TI made it very easy to enable digital control, so easy that

		 * it often triggers unintentionally and disabes PWM control,

		 * so wait until 1 wire mode detection window ends.

 64 cycle period, ON position 0 */

 enable PWM function in pin mux */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2015-2019 Texas Instruments Incorporated -  http://www.ti.com/

 * Author: Tomi Valkeinen <tomi.valkeinen@ti.com>

 *

 * Based on pwm_bl.c

 check that the LEDs all have the same brightness range */

 get the default brightness from the first LED from the list */

		/*

		 * Try to map actual LED brightness to backlight brightness

		 * level

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Backlight control code for Sharp Zaurus SL-5500

 *

 * Copyright 2005 John Lenz <lenz@cs.wisc.edu>

 * Maintainer: Pavel Machek <pavel@ucw.cz> (unless John wants to :-)

 *

 * This driver assumes single CPU. That's okay, because collie is

 * slightly old hardware, and no one is going to retrofit second CPU to

 * old PDA.

 LCD power functions */

 TFTCRST | CPSOUT=0 | CPSEN */

 Set CPSD */

 TFTCRST | CPSOUT=0 | CPSEN */

 TFTCRST=1 | CPSOUT=1 | CPSEN = 0 */

 TFTCRST=0 | CPSOUT=0 | CPSEN = 0 */

 read comadj */

	/*

	 * AC and non-AC are handled differently,

	 * but produce same results in sharp code?

	/*

	 * the poodle_lcd_power function is called for the first time

	 * from fs_initcall, which is before locomo is activated.

	 * We need to recall poodle_lcd_power here

 Set up frontlight so that screen is readable */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Backlight driver for Marvell Semiconductor 88PM8606

 *

 * Copyright (C) 2009 Marvell International Ltd.

 *	Haojian Zhuang <haojian.zhuang@marvell.com>

 set WLED_ON bit as 100% */

 set WLED_ON bit as 100% */

 clear WLED_ON bit since it's not 100% */

 read current backlight */

 SPDX-License-Identifier: GPL-2.0-only

/*

* Simple driver for Texas Instruments LM3630A Backlight driver chip

* Copyright (C) 2012 Texas Instruments

 i2c access */

 initialize chip */

 set Filter Strength Register */

 set Cofig. register */

 set boost control */

 set current A */

 set current B */

 set control */

 set brightness A and B */

 interrupt handling */

 update and get brightness */

 pwm control */

 disable sleep */

 minimum brightness is 0x04 */

 disable sleep */

 update and get brightness */

 pwm control */

 disable sleep */

 minimum brightness is 0x04 */

 disable sleep */

 default values */

 chip initialize */

 backlight register */

 pwm */

 interrupt enable  : irq 0 is not allowed */

 SPDX-License-Identifier: GPL-2.0-only

/*

* Simple driver for Texas Instruments LM3639 Backlight + Flash LED driver chip

* Copyright (C) 2012 Texas Instruments

 initialize chip */

 input pins config. */

 init brightness */

 output pins config. */

 update and get brightness */

 pwm control */

 i2c control and set brigtness */

 backlight mapping mode */

 torch */

 brightness 0 means off state */

 flash */

 torch off before flash control */

 brightness 0 means off state */

 chip initialize */

 backlight */

 flash */

 torch */

 SPDX-License-Identifier: GPL-2.0-only

/* Copyright (c) 2015, Sony Mobile Communications, AB.

 From DT binding */

 WLED3/WLED4 control registers */

 WLED3/WLED4 sink registers */

 WLED3 specific per-'string' registers below */

 WLED4 specific control registers */

 WLED4 specific sink registers */

 WLED4 specific per-'string' registers below */

 WLED5 specific control registers */

 WLED5 specific sink registers */

 WLED5 specific per-'string' registers below */

 Lock to avoid race from thread irq handler */

 Configures the brightness. Applicable for wled3, wled4 and wled5 */

 Configures the cabc register. Applicable for wled4 and wled5 */

	/*

	 * Toggles the sync bit for the brightness update to take place.

	 * Applicable for WLED3, WLED4 and WLED5.

	/*

	 * Time to wait before checking the OVP status after wled module enable.

	 * Applicable for WLED4 and WLED5.

	/*

	 * Determines if the auto string detection is required.

	 * Applicable for WLED4 and WLED5

 WLED4's lower limit of operation is 0.4% */

 WLED5's lower limit is 0.1% */

			/*

			 * The hardware generates a storm of spurious OVP

			 * interrupts during soft start operations. So defer

			 * enabling the IRQ for 10ms to ensure that the

			 * soft start is complete.

 For WLED5, get the delay based on OVP timer */

			/*

			 * For WLED5 toggling the MOD_SYNC_BIT updates the

			 * brightness

 Read configured sink configuration */

 Disable the module before starting detection */

 Set low brightness across all sinks */

 Disable all sinks */

 Iterate through the strings one by one */

 Enable feedback control */

 Enable the sink */

 Enable the module */

 Disable the module */

 Write the new sink configuration */

 Enable valid sinks */

 Disable modulator_en for unused sink */

 Enable CABC */

 Restore the feedback setting */

 Restore brightness */

	/*

	 * Check if the OVP fault was an occasional one

	 * or if it's firing continuously, the latter qualifies

	 * for an auto-detection check.

	/*

	 * Unlike WLED4, WLED5 has OVP fault density interrupt configuration

	 * i.e. to count the number of OVP alarms for a certain duration before

	 * triggering OVP fault interrupt. By default, number of OVP fault

	 * events counted before an interrupt is fired is 32 and the time

	 * interval is 12 ms. If we see one OVP fault interrupt, then that

	 * should qualify for a real OVP fault condition to run auto detection

	 * algorithm.

 Unlock the secure register access */

 Per sink/string configuration */

 Per sink/string configuration */

 Enable one of the modulators A or B based on mod_sel */

 This updates only FSC configuration in WLED5 */

	/*

	 * 0000 - 38.5 V

	 * 0001 - 37 V ..

	 * 1111 - 16 V

 Keep OVP irq disabled until module is enabled */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  LCD / Backlight control code for Sharp SL-6000x (tosa)

 *

 *  Copyright (c) 2005		Dirk Opfer

 *  Copyright (c) 2007,2008	Dmitry Baryshkov

/*

 * Timing Generator

 bl_enable GP04=1 otherwise GP04=0*/

 TG on */

 delayed 0clk TCTL signal for VGA */

 GPOS0=powercontrol, GPOS1=GPIO, GPOS2=TCTL */

 TG LCD pannel power up */

 TG LCD GVSS */

		/*

		 * after the pannel is powered up the first time,

		 * we can access the i2c bus so probe for the DAC

 TG LCD VHSA off */

 TG LCD signal off */

 TG Off */

 default to VGA mode */

	/*

	 * bits_per_word cannot be configured in platform data

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Driver for the Cirrus EP93xx lcd backlight

 *

 * Copyright (c) 2010 H Hartley Sweeten <hsweeten@visionengravers.com>

 *

 * This driver controls the pulse width modulated brightness control output,

 * BRIGHT, on the Cirrus EP9307, EP9312, and EP9315 processors.

	/*

	 * FIXME - We don't do a request_mem_region here because we are

	 * sharing the register space with the framebuffer driver (see

	 * drivers/video/ep93xx-fb.c) and doing so will cause the second

	 * loaded driver to return -EBUSY.

	 *

	 * NOTE: No locking is required; the framebuffer does not touch

	 * this register.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * linux/drivers/video/backlight/aat2870_bl.c

 *

 * Copyright (c) 2011, NVIDIA Corporation.

 * Author: Jin Park <jinyoungp@nvidia.com>

 current brightness */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ROHM Semiconductor BD6107 LED Driver

 *

 * Copyright (C) 2013 Ideas on board SPRL

 *

 * Contact: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

 Assert the reset line (gpiolib will handle active low) */

	/*

	 * Request the reset GPIO line with GPIOD_OUT_HIGH meaning asserted,

	 * so in the machine descriptor table (or other hardware description),

	 * the line should be flagged as active low so this will assert

	 * the reset.

 SPDX-License-Identifier: GPL-2.0-only

/* drivers/video/backlight/ili9320.c

 *

 * ILI9320 LCD controller driver core.

 *

 * Copyright 2007 Simtec Electronics

 *	http://armlinux.simtec.co.uk/

 *	Ben Dooks <ben@simtec.co.uk>

	/* spi message consits of:

	 * first byte: ID and operation

 second message is the data to transfer */

	/* fill the two messages we are going to use to send the data

	 * with, the first the address followed by the data. The datasheet

	 * says they should be done as two distinct cycles of the SPI CS line.

 verify we where given some information */

 allocate and initialse our state */

 Power down all displays on reboot, poweroff or halt */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) Intel Corp. 2007.

 * All Rights Reserved.

 *

 * Intel funded Tungsten Graphics (http://www.tungstengraphics.com) to

 * develop this driver.

 *

 * This file is part of the Carillo Ranch video subsystem driver.

 *

 * Authors:

 *   Thomas Hellstrom <thomas-at-tungstengraphics-dot-com>

 *   Alan Hourihane <alanh-at-tungstengraphics-dot-com>

/* The LVDS- and panel power controls sits on the

 * GPIO port of the ISA bridge.

 The PLL Clock register sits on Host bridge */

 OFF */

 FULL ON */

 Make sure LVDS controller is down. */

 Power up Panel */

 Power up LVDS controller */

 Power down LVDS controller first to avoid high currents */

 SPDX-License-Identifier: GPL-2.0

/*

 * AS3711 PMIC backlight driver, using DCDC Step Up Converters

 *

 * Copyright (C) 2012 Renesas Electronics Corporation

 * Author: Guennadi Liakhovetski, <g.liakhovetski@gmx.de>

 Only all equal current values are supported */

/*

 * Someone with less fragile or less expensive hardware could try to simplify

 * the brightness adjustment procedure.

 Manual one current feedback pin below */

 Turn SU2 off */

 max tuning I = 31uA for voltage- and 38250uA for current-feedback */

		/*

		 * At least one su2-auto-curr* must be specified iff

		 * AS3711_SU2_CURR_AUTO is used

	/*

	 * Due to possible hardware damage I chose to block all modes,

	 * unsupported on my hardware. Anyone, wishing to use any of those modes

	 * will have to first review the code, then activate and test it.

 SPDX-License-Identifier: GPL-2.0-only

/*

 *

 * iPAQ microcontroller backlight support

 * Author : Linus Walleij <linus.walleij@linaro.org>

	/*

	 * Message format:

	 * Byte 0: backlight instance (usually 1)

	 * Byte 1: on/off

	 * Byte 2: intensity, 0-255

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Backlight driver for Analog Devices ADP8870 Backlight Devices

 *

 * Copyright 2009-2011 Analog Devices Inc.

 Manufacturer and device ID */

 Device mode and status */

 Interrupts status */

 Interrupts enable */

 Configuration register */

 Sink enable backlight or independent */

 PWM Enable Selection Register */

 Backlight off timeout */

 Backlight dim timeout */

 Backlight fade in and out rates */

 Backlight (Brightness Level 1-daylight) maximum current */

 Backlight (Brightness Level 1-daylight) dim current */

 Backlight (Brightness Level 2-bright) maximum current */

 Backlight (Brightness Level 2-bright) dim current */

 Backlight (Brightness Level 3-office) maximum current */

 Backlight (Brightness Level 3-office) dim current */

 Backlight (Brightness Level 4-indoor) maximum current */

 Backlight (Brightness Level 4-indoor) dim current */

 Backlight (Brightness Level 5-dark) maximum current */

 Backlight (Brightness Level 5-dark) dim current */

 Independent sink current fade law register */

 Independent sink current control register */

 Independent Sink Current Timer Register LED[7:5] */

 Independent Sink Current Timer Register LED[4:1] */

 Independent sink current fade register */

 Independent Sink Current LED1 */

 Independent Sink Current LED2 */

 Independent Sink Current LED3 */

 Independent Sink Current LED4 */

 Independent Sink Current LED5 */

 Independent Sink Current LED6 */

 Independent Sink Current LED7 (Brightness Level 1-daylight) */

 Independent Sink Current LED7 (Brightness Level 2-bright) */

 Independent Sink Current LED7 (Brightness Level 3-office) */

 Independent Sink Current LED7 (Brightness Level 4-indoor) */

 Independent Sink Current LED7 (Brightness Level 5-dark) */

 ALS Comparator Control Register */

 Main ALS comparator level enable */

 Second ALS comparator level enable */

 Main ALS Comparator Status Register */

 Second ALS Comparator Status Register */

 L2 comparator reference */

 L2 hysteresis */

 L3 comparator reference */

 L3 hysteresis */

 L4 comparator reference */

 L4 hysteresis */

 L5 comparator reference */

 L5 hysteresis */

 First phototransistor ambient light level-low byte register */

 First phototransistor ambient light level-high byte register */

 Second phototransistor ambient light level-low byte register */

 Second phototransistor ambient light level-high byte register */

 Analog Devices AD8870 Manufacturer and device ID */

 MDCR Device mode and status */

 ADP8870_ALS1_EN Main ALS comparator level enable */

/*

 * Independent sink / LED

	/*

	 * Use workqueue for IO since I2C operations can sleep.

 Disable Ambient Light auto adjust */

			/*

			 * MAX_BRIGHTNESS -> Enable Ambient Light auto adjust

			 * restore daylight l1 sysfs brightness

	/*

	 * ADP8870 Rev0 requires GDWN_DIS bit set

 Return 13-bit conversion value for the first light sensor */

 Enable automatic ambient light sensing */

 Disable automatic ambient light sensing */

 Set user supplied ambient light zone */

/*

 *  Backlight Driver for HP Jornada 680

 *

 *  Copyright (c) 2005 Andriy Skulysh

 *

 *  Based on Sharp's Corgi Backlight Driver

 *

 * This file is subject to the terms and conditions of the GNU General Public

 * License.  See the file "COPYING" in the main directory of this archive

 * for more details.

/*

 *  linux/drivers/video/console/sticon.c - console driver using HP's STI firmware

 *

 *	Copyright (C) 2000 Philipp Rumpf <prumpf@tux.org>

 *	Copyright (C) 2002-2020 Helge Deller <deller@gmx.de>

 *

 *  Based on linux/drivers/video/vgacon.c and linux/drivers/video/fbcon.c,

 *  which were

 *

 *	Created 28 Sep 1997 by Geert Uytterhoeven

 *	Rewritten by Martin Mares <mj@ucw.cz>, July 1998

 *	Copyright (C) 1991, 1992  Linus Torvalds

 *			    1995  Jay Estabrook

 *	Copyright (C) 1995 Geert Uytterhoeven

 *	Copyright (C) 1993 Bjoern Brauel

 *			   Roman Hodek

 *	Copyright (C) 1993 Hamish Macdonald

 *			   Greg Harp

 *	Copyright (C) 1994 David Carter [carter@compsci.bristol.ac.uk]

 *

 *	      with work by William Rucklidge (wjr@cs.cornell.edu)

 *			   Geert Uytterhoeven

 *			   Jes Sorensen (jds@kom.auc.dk)

 *			   Martin Apel

 *	      with work by Guenther Kelleter

 *			   Martin Schaller

 *			   Andreas Schwab

 *			   Emmanuel Marty (core@ggi-project.org)

 *			   Jakub Jelinek (jj@ultra.linux.cz)

 *			   Martin Mares <mj@ucw.cz>

 *

 *  This file is subject to the terms and conditions of the GNU General Public

 *  License.  See the file COPYING in the main directory of this archive for

 *  more details.

 *

 switching to graphics mode */

 borrowed from fbcon.c */

 this is the sti_struct used for this console */

 no cursor update if screen is blanked */

 usage counter */

 check if font is already used by other console */

 current font is the same as the new one */

 clear screen with old font: we now may have less rows */

 delete old font in case it is a user font */

 need to repaint screen if cols & rows are same as old font */

 free memory used by user font */

 needs refreshing */

 vga_can_do_color; */

 already initialized ? */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  linux/drivers/video/console/sticore.c -

 *	core code for console driver using HP's STI firmware

 *

 *	Copyright (C) 2000 Philipp Rumpf <prumpf@tux.org>

 *	Copyright (C) 2001-2020 Helge Deller <deller@gmx.de>

 *	Copyright (C) 2001-2002 Thomas Bogendoerfer <tsbogend@alpha.franken.de>

 * 

 * TODO:

 * - call STI in virtual mode rather than in real mode

 * - screen blanking with state_mgmt() in text mode STI ? 

 * - try to make it work on m68k hp workstations ;)

 * 

 number of STI ROMS found and their ptrs to each struct */

/* The colour indices used by STI are

 *   0 - Black

 *   1 - White

 *   2 - Red

 *   3 - Yellow/Brown

 *   4 - Green

 *   5 - Cyan

 *   6 - Blue

 *   7 - Magenta

 *

 * So we have the same colours as VGA (basically one bit each for R, G, B),

 # of text planes (max 3 for STI) */

 this still needs to be revisited (see arch/parisc/mm/init.c:246) ! */

/*	Assuming the machine has multiple STI consoles (=graphic cards) which

 *	all get detected by sticon, the user may define with the linux kernel

 *	parameter sti=<x> which of them will be the initial boot-console.

 *	<x> is a number between 0 and MAX_STI_ROMS, with 0 as the default 

 *	STI screen.

	/*

	 * The default font can be selected in various ways.

	 * a) sti_font=VGA8x16, sti_font=10x20, sti_font=10*20 selects

	 *    an built-in Linux framebuffer font.

	 * b) sti_font=<index>, where index is (1..x) with 1 selecting

	 *    the first HP STI ROM built-in font..

 fb font name */

/*	The optional linux kernel parameter "sti_font" defines which font

 *	should be used by the sticon driver to draw characters to the screen.

 *	Possible values are:

 *	- sti_font=<fb_fontname>:

 *		<fb_fontname> is the name of one of the linux-kernel built-in 

 *		framebuffer font names (e.g. VGA8x16, SUN22x18). 

 *		This is only available if the fonts have been statically compiled 

 *		in with e.g. the CONFIG_FONT_8x16 or CONFIG_FONT_SUN12x22 options.

 *	- sti_font=<number>	(<number> = 1,2,3,...)

 *		most STI ROMs have built-in HP specific fonts, which can be selected

 *		by giving the desired number to the sticon driver. 

 *		NOTE: This number is machine and STI ROM dependend.

 *	- sti_font=<height>x<width>  (e.g. sti_font=16x8)

 *		<height> and <width> gives hints to the height and width of the

 *		font which the user wants. The sticon driver will try to use

 *		a font with this height and width, but if no suitable font is

 *		found, sticon will use the default 8x8 font.

 dump extended cfg */ 

 STI default */

 last entry reached ? */

 check for framebuffer-font first */

 store new ptr to byte-mode font and delete old font */

 read the ROM size directly from the struct in ROM */ 

 check if the ROM routines in this card are compatible */

 HyperA or HyperB ? */

parisc.wiki.kernel.org/"

 fall through */

	/* if we can't read the ROM, bail out early.  Not being able

 check for a PCI ROM structure */

			/* The ROM could have multiple architecture 

 read 16 bytes from the pci region mapper array */

 not enough memory */

	/* disable STI PCI ROM. ROM and card RAM overlap and

	 * leaving it enabled would force HPMCs

/*

 * on newer systems PDC gives the address of the ROM 

 * in the additional address field addr[1] while on

 * older Systems the PDC stores it in page0->proc_sti 

 CONFIG_PCI */

 terminate list */

/*

 * sti_init_roms() - detects all STI ROMs and stores them in sti_roms[]

 Register drivers for native & PCI cards */

 if we didn't find the given default sti, take the first one */

/*

 * index = 0 gives default sti

 * index > 0 gives other stis in detection order

 Check for overflow when using 32bit STI on 64bit kernel. */

/*

 *  linux/drivers/video/mdacon.c -- Low level MDA based console driver

 *

 *	(c) 1998 Andrew Apted <ajapted@netspace.net.au>

 *

 *      including portions (c) 1995-1998 Patrick Caulfield.

 *

 *      slight improvements (c) 2000 Edward Betts <edward@debian.org>

 *

 *  This file is based on the VGA console driver (vgacon.c):

 *	

 *	Created 28 Sep 1997 by Geert Uytterhoeven

 *

 *	Rewritten by Martin Mares <mj@ucw.cz>, July 1998

 *

 *  and on the old console.c, vga.c and vesa_blank.c drivers:

 *

 *	Copyright (C) 1991, 1992  Linus Torvalds

 *			    1995  Jay Estabrook

 *

 *  This file is subject to the terms and conditions of the GNU General Public

 *  License.  See the file COPYING in the main directory of this archive for

 *  more details.

 *

 *  Changelog:

 *  Paul G. (03/2001) Fix mdacon= boot prompt to use __setup().

 description of the hardware layout */

 Base of video memory */

 Size of video memory */

 Number of text columns */

 Number of text lines */

 Register select port */

 Register value port */

 Mode control port */

 Status and Config port */

 Graphics control port */

 current hardware state */

 console information */

/* MDA register values

/*

 * MDA could easily be classified as "pre-dinosaur hardware".

 disable cursor */

 cursor start */

 cursor end */

 command line format: mdacon=<first>,<last> */

 do a memory check */

 check if we have 4K or 8K */

	/* Ok, there is definitely a card registering at the correct

	 * memory location, so now we do an I/O port test.

 Edward: These two mess `tests' mess up my cursor on bootup */

 cursor low register */

 cursor low register */

	/* See if the card is a Hercules, by checking whether the vsync

	 * bit of the status register is changing.  This test lasts for

	 * approximately 1/10th of a second.

 horizontal total */

 horizontal displayed */

 horizontal sync pos */

 horizontal sync width */

 vertical total */

 vertical total adjust */

 vertical displayed */

 vertical sync pos */

 interlace mode */

 maximum scanline */

 cursor start */

 cursor end */

 start address */

 cursor location */

 cursor looks ugly during boot-up, so turn it off */

 reverse video */

 make the first MDA console visible */

 con_set_default_unimap(c->vc_num); */

	/* Underline and reverse-video are mutually exclusive on MDA.

	 * Since reverse-video is used for cursors and selected areas,

	 * it takes precedence. 

 reverse */

 underline */

 intensity */ 

 blink */ 

	/* The attribute is just a bit vector:

	 *

	 *	Bit 0..1 : intensity (0..2)

	 *	Bit 2    : underline

	 *	Bit 3    : reverse

	 *	Bit 7    : blink

 redrawing needed */

 Tell console.c that it has to restore the screen itself */

 disable video */

 maximum realistic size */

/*

 *  The console `switch' structure for the MDA based console

/*

 *  linux/drivers/video/vgacon.c -- Low level VGA based console driver

 *

 *	Created 28 Sep 1997 by Geert Uytterhoeven

 *

 *	Rewritten by Martin Mares <mj@ucw.cz>, July 1998

 *

 *  This file is based on the old console.c, vga.c and vesa_blank.c drivers.

 *

 *	Copyright (C) 1991, 1992  Linus Torvalds

 *			    1995  Jay Estabrook

 *

 *	User definable mapping table and font loading by Eugene G. Crosser,

 *	<crosser@average.org>

 *

 *	Improved loadable font/UTF-8 support by H. Peter Anvin

 *	Feb-Sep 1995 <peter.anvin@linux.org>

 *

 *	Colour palette handling, by Simon Tatham

 *	17-Jun-95 <sgt20@cam.ac.uk>

 *

 *	if 512 char mode is already enabled don't re-enable it,

 *	because it causes screen to flicker, by Mitja Horvat

 *	5-May-96 <mitja.horvat@guest.arnes.si>

 *

 *	Use 2 outw instead of 4 outb_p to reduce erroneous text

 *	flashing on RHS of screen during heavy console scrolling .

 *	Oct 1996, Paul Gortmaker.

 *

 *

 *  This file is subject to the terms and conditions of the GNU General Public

 *  License.  See the file COPYING in the main directory of this archive for

 *  more details.

 VGA does not support fontwidths != 8 */

/*

 *  Interface used by the world

 Description of the hardware situation */

 Base of video memory */

 End of video memory */

 Size of video memory */

 Video register select port */

 Video register value port */

 Number of text columns */

 Number of text lines */

 Do we support colors? */

 Height of default screen font */

 Card type */

 last vc_origin offset before wrap */

 force text mode - used by kernel modesetting */

	/*

	 * Disabling scrollback is required for the Braillex ib80-piezo

	 * Braille reader made by F.H. Papenmeier (Germany).

	 * Use the "no-scroll" bootflag.

/*

 * By replacing the four outb_p with two back to back outw, we can reduce

 * the window of opportunity to see text mislocated to the RHS of the

 * console during heavy scrolling activity. However there is the remote

 * possibility that some pre-dinosaur hardware won't like the back to back

 * I/O. Since the Xservers get away with it, we should be able to as well.

	/*

	 * ddprintk might set the console position from interrupt

	 * handlers, thus the write has to be IRQ-atomic.

 boot_params.screen_info reasonably initialized? */

 VGA16 modes are not handled by VGACON */

 320x200/4 */

 640x200/4 */

 640x350/4 */

 640x480/4 */

 800x600/4 (VESA) */

 Monochrome display */

 If not, it is color. */

				/*

				 * Normalise the palette registers, to point

				 * the 16 screen colours to the first 16

				 * DAC entries.

				/*

				 * Now set the DAC registers back to their

				 * default values

	/*

	 *      Find out if there is a graphics card present.

	 *      Are there smarter methods around?

 This may be suboptimal but is a safe bet - go with it */

	/*

	 * We cannot be loaded as a module, therefore init is always 1,

	 * but vgacon_init can be called more than once, and init will

	 * not be 1.

 set dimensions manually if init != 0 since vc_resize() will fail */

 Only set the default if the user didn't deliberately override it */

 When closing the active console, reset video origin */

 deprotect registers */

 reprotect registers */

	/*

	 * We need to save screen size here as it's the only way

	 * we can spot the screen has been resized and we need to

	 * set size of freshly allocated screens ourselves.

	/* We can only copy out the size of the video buffer here,

 Redrawing not needed */

 structure holding original VGA register settings */

 Sequencer Index reg.   */

 CRT-Contr. Index reg.  */

 Miscellaneous register */

 CRT-Controller:00h */

 CRT-Controller:01h */

 CRT-Controller:04h */

 CRT-Controller:05h */

 CRT-Controller:07h */

 CRT-Controller:10h */

 CRT-Controller:11h */

 CRT-Controller:17h */

 Seq-Controller:01h */

 save original values of VGA controller registers */

 HorizontalTotal */

 HorizDisplayEnd */

 StartHorizRetrace */

 EndHorizRetrace */

 Overflow */

 StartVertRetrace */

 EndVertRetrace */

 ModeControl */

 assure that video is enabled */

 "0x20" is VIDEO_ENABLE_bit in register 01 of sequencer */

 test for vertical retrace in process.... */

	/*

	 * Set <End of vertical retrace> to minimum (0) and

	 * <Start of vertical Retrace> to maximum (incl. overflow)

	 * Result: turn off vertical sync (VSync) pulse.

 StartVertRetrace */

 maximum value */

 EndVertRetrace */

 minimum (bits 0..3)  */

 Overflow */

 bits 9,10 of vert. retrace */

		/*

		 * Set <End of horizontal retrace> to minimum (0) and

		 *  <Start of horizontal Retrace> to maximum

		 * Result: turn off horizontal sync (HSync) pulse.

 StartHorizRetrace */

 maximum */

 EndHorizRetrace */

 minimum (0) */

 restore both index registers */

 restore original values of VGA controller registers */

 HorizontalTotal */

 HorizDisplayEnd */

 StartHorizRetrace */

 EndHorizRetrace */

 Overflow */

 StartVertRetrace */

 EndVertRetrace */

 ModeControl */

 ClockingMode */

 restore index/control registers */

 Unblank */

 Tell console.c that it has to restore the screen itself */

 Normal blanking */

 Obsolete */

 VESA blanking */

/*

 * PIO_FONT support.

 *

 * The font loading code goes back to the codepage package by

 * Joel Hoffman (joel@wam.umd.edu). (He reports that the original

 * reference is: "From: p. 307 of _Programmer's Guide to PC & PS/2

 * Video Systems_ by Richard Wilton. 1987.  Microsoft Press".)

 *

 * Change for certain monochrome monitors by Yury Shevchuck

 * (sizif@botik.yaroslavl.su).

/* Pauline Middelink <middelin@polyware.iaf.nl> reports that we

	/*

	 * All fonts are loaded in slot 0 (0:1 for 512 ch)

 Return to default font not supported */

 First, the Sequencer */

 CPU writes only to map 2 */

 Sequential addressing */

 Clear synchronous reset */

 Now, the graphics controller, select map 2 */

 disable odd-even addressing */

 map start at A000:0000 */

		/*

		 * In 512-character mode, the character map is not contiguous if

		 * we want to remain EGA compatible -- which we do

 First, the sequencer, Synchronous reset */

 CPU writes to maps 0 and 1 */

 odd-even addressing */

 Character Map Select */

 clear synchronous reset */

 Now, the graphics controller, select map 0 for CPU */

 enable even-odd addressing */

 map starts at b800:0 or b000:0 */

 if 512 char mode is already enabled don't re-enable it. */

		/* 256-char: enable intensity bit

 clear address flip-flop */

 color plane enable register */

		/* Wilton (1987) mentions the following; I don't know what

				/* force hi font mask to 0, so we always clear

/*

 * Adjust the screen to fit a font of a certain height

 Number of video rows we end up with */

 Scan lines to actually display-1 */

	/* Reprogram the CRTC for the new font size

	   Note: the attempt to read the overflow register will fail

	   on an EGA, but using 0xff for the previous value appears to

	   be OK for EGA text modes in the range 257-512 scan lines, so I

	   guess we don't need to worry about it.



	   The same applies for the spill bits in the font size and cursor

	   registers; they are write-only on EGA, but it appears that they

 CRTC overflow register */

 Font size register */

 Vertical display end reg */

 Overflow register */

  Font size register */

 CRTC overflow register */

 Font size */

 Vertical display limit */

 void size to cause regs to be rewritten */

 Adjust console size */

		/*

		 * Ho ho!  Someone (svgatextmode, eh?) may have reprogrammed

		 * the video mode!  Set the new defaults then and go away.

 who knows */

 We don't play origin tricks in graphic modes */

 Nor we write to blanked screens */

		/* This is a gross hack, but here is the only place we can

		 * set bootup console parameters without messing up generic

		 * console initialization routines.

	/* We can't copy in more than the size of the video buffer,

/*

 *  The console `switch' structure for the VGA based console

 SPDX-License-Identifier: GPL-2.0-only

/*

 * newport_con.c: Abscon for newport hardware

 * 

 * (C) 1998 Thomas Bogendoerfer (tsbogend@alpha.franken.de)

 * (C) 1999 Ulf Carlsson (ulfc@thepuffingruop.com)

 * 

 * This driver is based on sgicons.c and cons_newport.

 * 

 * Copyright (C) 1996 David S. Miller (davem@davemloft.net)

 * Copyright (C) 1997 Miguel de Icaza (miguel@nuclecu.unam.mx)

 CONFIG_LOGO_SGI_CLUT224 */

 turn off popup plane */

 Clear the screen. */

/*

 * calculate the actual screen size by reading

 * the video timing out of the VC2

 should be enough */

 I don't know all affected revisions */

 free memory used by user font */

 Can't be __init, do_take_over_console may call it later */

 Set the color and drawing mode. */

 Set coordinates for bitmap operation. */

 Go, baby, go... */

 Clear the area behing the string */

 Set the color and drawing mode. */

 Set coordinates for bitmap operation. */

 Go, baby, go... */

 unblank console */

 blank console */

	/* ladis: when I grow up, there will be a day... and more sizes will

 usage counter */

 check if font is already used by other console */

 current font is the same as the new one */

 old font is user font */

 it's time to disable the logo now.. */

 we only support one Newport as console */

 ioremap cannot fail */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  linux/drivers/video/dummycon.c -- A dummy console driver

 *

 *  To be used if there's no other console driver (e.g. for plain VGA text)

 *  available, usually until fbcon takes console over.

/*

 *  Dummy console driver

 set by Kconfig. Use 80x25 for 640x480 and 160x64 for 1280x1024 */

 These are both protected by the console_lock */

 Ignore erases */

 Redraw, so that we get putc(s) for output done while blanked */

/*

 *  The console `switch' structure for the dummy console

 *

 *  Most of the operations are dummies.

/*

 *  Convert a logo in ASCII PNM format to C source suitable for inclusion in

 *  the Linux kernel

 *

 *  (C) Copyright 2001-2003 by Geert Uytterhoeven <geert@linux-m68k.org>

 *

 *  --------------------------------------------------------------------------

 *

 *  This file is subject to the terms and conditions of the GNU General Public

 *  License. See the file COPYING in the main directory of the Linux

 *  distribution for more details.

 monochrome black/white */

 16 colors VGA text palette */

 224 colors */

 256 levels grayscale */

 Skip leading whitespace */

 Ignore comments 'till end of line */

 Parse decimal number */

	/* some PBM are 'broken'; GiMP for example exports a PBM without space

	 * between the digits. This is Ok cause we know a PBM can only have a '1'

 open image file */

 check file type and read file header */

 Plain PBM/PGM/PPM */

 Binary PBM/PGM/PPM */

 allocate image data */

 read image data */

 Plain PBM */

 Plain PGM */

 Plain PPM */

 close file */

 open logo file */

    fputs("/*\n", out);

    fputs(" *  DO NOT EDIT THIS FILE!\n", out);

    fputs(" *\n", out);

    fprintf(out, " *  It was automatically generated from %s\n", filename);

    fputs(" *\n", out);

    fprintf(out, " *  Linux logo %s\n", logoname);

 close logo file */

 validate image */

 write file header */

 write logo data */

 write logo structure and file footer */

 validate image */

 write file header */

 write logo data */

 write logo structure and file footer */

 validate image */

 write file header */

 write logo data */

 write logo clut */

 write logo structure and file footer */

 validate image */

 write file header */

 write logo data */

 write logo structure and file footer */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  Linux logo to be displayed on boot

 *

 *  Copyright (C) 1996 Larry Ewing (lewing@isc.tamu.edu)

 *  Copyright (C) 1996,1998 Jakub Jelinek (jj@sunsite.mff.cuni.cz)

 *  Copyright (C) 2001 Greg Banks <gnb@alphalink.com.au>

 *  Copyright (C) 2001 Jan-Benedict Glaw <jbglaw@lug-owl.de>

 *  Copyright (C) 2003 Geert Uytterhoeven <geert@linux-m68k.org>

/*

 * Logos are located in the initdata, and will be freed in kernel_init.

 * Use late_init to mark the logos as freed to prevent any further use.

/* logo's are marked __initdata. Use __ref to tell

 * modpost that it is intended that this function uses data

 * marked __initdata.

 Generic Linux logo */

 SuperH Linux logo */

 Generic Linux logo */

 SuperH Linux logo */

 Generic Linux logo */

 DEC Linux logo on MIPS/MIPS64 or ALPHA */

 Macintosh Linux logo on m68k */

 PA-RISC Linux logo */

 SGI Linux logo on MIPS/MIPS64 */

 Sun Linux logo */

 SuperH Linux logo */

/*

 *  linux/drivers/video/tgafb.c -- DEC 21030 TGA frame buffer device

 *

 *	Copyright (C) 1995 Jay Estabrook

 *	Copyright (C) 1997 Geert Uytterhoeven

 *	Copyright (C) 1999,2000 Martin Lucina, Tom Zerucha

 *	Copyright (C) 2002 Richard Henderson

 *	Copyright (C) 2006, 2007  Maciej W. Rozycki

 *

 *  This file is subject to the terms and conditions of the GNU General Public

 *  License. See the file COPYING in the main directory of this archive for

 *  more details.

/*

 * Local functions.

/*

 *  Frame buffer operations

/*

 *  PCI registration operations

 CONFIG_PCI */

/*

 *  TC registration operations

 CONFIG_TC */

/**

 *      tgafb_check_var - Optional function.  Validates a var passed in.

 *      @var: frame buffer variable screen structure

 *      @info: frame buffer structure that represents a single frame buffer

	/* Some of the acceleration routines assume the line width is

/**

 *      tgafb_set_par - Optional function.  Alters the hardware state.

 *      @info: frame buffer structure that represents a single frame buffer

 Encode video timings.  */

 Store other useful values in par.  */

 First, disable video.  */

 Write the DEEP register.  */

 wait for not busy */

 wait for not busy */

 Write some more registers.  */

 Calculate & write the PLL.  */

 Write some more registers.  */

 Init video timing regs.  */

 Initialise RAMDAC. */

 Init BT485 RAMDAC registers.  */

 cursor 64x64 */

 cursor off, for now */

 Fill palette registers.  */

 Init BT459 RAMDAC registers.  */

 Fill the palette.  */

 24-plane or 24plusZ */

 Init BT463 RAMDAC registers.  */

 Fill the palette.  */

 Fill window type table after start of vertical retrace.  */

 Finally, enable video scan (and pray for the monitor... :-) */

/**

 *      tgafb_setcolreg - Optional function. Sets a color register.

 *      @regno: boolean, 0 copy local, 1 get_user() function

 *      @red: frame buffer colormap structure

 *      @green: The green value which can be up to 16 bits wide

 *      @blue:  The blue value which can be up to 16 bits wide.

 *      @transp: If supported the alpha value which can be up to 16 bits wide.

 *      @info: frame buffer info structure

/**

 *      tgafb_blank - Optional function.  Blanks the display.

 *      @blank: the blank mode we want.

 *      @info: frame buffer structure that represents a single frame buffer

 Unblanking */

 Normal blanking */

 VESA blank (vsync off) */

 VESA blank (hsync off) */

 Poweroff */

/*

 *  Acceleration.

 A shift below cannot cope with.  */

 Crop the image to the screen.  */

 Expand the color values to fill 32-bits.  */

	/* ??? Would be nice to notice colour changes elsewhere, so

	/* Acquire proper alignment; set up the PIXELMASK register

 Enable opaque stipple mode.  */

		/* Handle common case of imaging a single character, in

 Avoid a shift by 32; width > 0 implied.  */

			/* The image data is bit big endian; we need

		/* Handle another common case in which accel_putcs

		   generates a large bitmap, which happens to be aligned.

		   Allow the tail to be misaligned.  This case is 

		   interesting because we've not got to hold partial

		/* Finally, handle the generic case of misaligned start.

		   Here we split the write into 16-bit spans.  This allows

		   us to use only one pixel mask, instead of four as would

 Disable opaque stipple mode.  */

 Crop the image to the screen.  */

 Now copy the image, color_expanding via the palette. */

/**

 *      tgafb_imageblit - REQUIRED function. Can use generic routines if

 *                        non acclerated hardware and packed pixel based.

 *                        Copies a image from system memory to the screen.

 *

 *      @info: frame buffer structure that represents a single frame buffer

 *      @image: structure defining the image.

 If a mono image, regardless of FB depth, go do it. */

	/* For copies that aren't pixel expansion, there's little we

	/* ??? There is a DMA write mode; I wonder if that could be

 If 24-plane FB and the image is 8-plane with CLUT, we can do it. */

 Silently return... */

/**

 *      tgafb_fillrect - REQUIRED function. Can use generic routines if 

 *                       non acclerated hardware and packed pixel based.

 *                       Draws a rectangle on the screen.               

 *

 *      @info: frame buffer structure that represents a single frame buffer

 *      @rect: structure defining the rectagle and operation.

 Crop the rectangle to the screen.  */

	/* ??? We could implement ROP_XOR with opaque fill mode

	   and a RasterOp setting of GXxor, but as far as I can

	   tell, this mode is not actually used in the kernel.

 Expand the color value to fill 8 pixels.  */

	/* The DATA register holds the fill mask for block fill mode.

 Enable block fill mode.  */

	/* We can fill 2k pixels per operation.  Notice blocks that fit

	   the width of the screen so that we can take advantage of this

	/* The write into the frame buffer must be aligned to 4 bytes,

	   but we are allowed to encode the offset within the word in

 Disable block fill mode.  */

/*

 *      tgafb_copyarea - REQUIRED function. Can use generic routines if

 *                       non acclerated hardware and packed pixel based.

 *                       Copies on area of the screen to another area.

 *

 *      @info: frame buffer structure that represents a single frame buffer

 *      @area: structure defining the source and destination.

/* Handle the special case of copying entire lines, e.g. during scrolling.

   We can avoid a lot of needless computation in this case.  In the 8bpp

   case we need to use the COPY64 registers instead of mask writes into 

 Set up the MODE and PIXELSHIFT registers.  */

 Reset the MODE register to normal.  */

 Set up the MODE and PIXELSHIFT registers.  */

 Reset the MODE register to normal.  */

 The (almost) general case of backward copy in 8bpp mode.  */

 Do acceleration only if we are aligned on 8 pixels */

	/* Compute the offsets and alignments in the frame buffer.

 Next copy full words at a time.  */

 Finally copy the unaligned head of the span.  */

 Set up the MODE and PIXELSHIFT registers.  */

 Reset the MODE register to normal.  */

 The top left corners must be in the virtual screen.  */

 Clip the destination.  */

 The source must be completely inside the virtual screen.  */

 Detect copies of the entire line.  */

	/* ??? The documentation is unclear to me exactly how the pixelshift

	   register works in 32bpp mode.  Since I don't have hardware to test,

/*

 *  Initialisation

	/*

	 * These are needed by fb_set_logo_truepalette(), so we

	 * set them here for 24-plane cards.

 We just use this to catch switches out of graphics mode. */

 A bit of overkill for BASE_ADDR reset. */

 1280x1024 @ 72 Hz, 76.8 kHz hsync */

 Enable device in PCI config.  */

 Allocate the fb and par structures.  */

 Request the mem regions.  */

 Map the framebuffer.  */

 Grab info about the card.  */

 Setup framebuffer.  */

 This should give a reasonable default video mode.  */

 !MODULE */

/*

 *  Modularisation

 SPDX-License-Identifier: GPL-2.0-only

/*

 *	HP300 Topcat framebuffer support (derived from macfb of all things)

 *	Phil Blundell <philb@gnu.org> 1998

 *	DIO-II, colour map and Catseye support by

 *	Kars de Jong <jongk@linux-m68k.org>, May 2004.

 These defines match the X window system */

 blitter regs */

 use MSBs */

	/*

	 *  Set a single color register. The values supplied are

	 *  already rounded down to the hardware's capabilities

	 *  (according to the entries in the `var' structure). Return

	 *  != 0 for invalid regno.

 0 unblank, 1 blank, 2 no vsync, 3 no hsync, 4 off */

 Foreground */

 Background */

	/*

	 * Since we also access the framebuffer directly, we have to wait

	 * until the block mover is finished

 Common to all HP framebuffers */

 Frame buffer width 		*/

 Frame buffer height		*/

 Display width		*/

 Display height		*/

 Number of colour planes	*/

 Frame buffer offset		*/

 This is the magic incantation the HP X server uses to make Catseye boards work. */

 Catseye status */

 VB */

 TCNTRL */

 ACNTRL */

 PNCNTRL */

 RUG Command/Status */

 Overlay Mask */

 Ram Select */

	/*

	 *	Fill in the available video resolution

	/*

	 *	Give the hardware a bit of a prod and work out how many bits per

	 *	pixel are supported.

	/*

	 *	Enable reading/writing of all the planes.

	/*

	 *	Clear the screen.

	/*

	 *	Let there be consoles..

/* 

 * Check that the secondary ID indicates that we have some hope of working with this

 * framebuffer.  The catseye boards are pretty much like topcats and we can muddle through.

/* 

 * Initialise the framebuffer

	/* Topcats can be on the internal IO bus or real DIO devices.

	 * The internal variant sits at 0x560000; it has primary

	 * and secondary ID registers just like the DIO version.

	 * So we merge the two detection routines.

	 *

	 * Perhaps this #define should be in a global header file:

	 * I believe it's common to all internal fbs, not just topcat.

/*

 *  linux/drivers/video/offb.c -- Open Firmware based frame buffer device

 *

 *	Copyright (C) 1997 Geert Uytterhoeven

 *

 *  This driver is partly based on the PowerMac console driver:

 *

 *	Copyright (C) 1996 Paul Mackerras

 *

 *  This file is subject to the terms and conditions of the GNU General Public

 *  License. See the file COPYING in the main directory of this archive for

 *  more details.

 Supported palette hacks */

 ATI Mach64 */

 ATI Rage128 */

 ATI Rage Mobility M3 Head A */

 ATI Rage Mobility M3 Head B */

 ATI Radeon */

 IBM GXT2000 */

 ATI R5xx */

 qemu vga */

 Definitions used by the Avivo palette hack */

    /*

     *  Set a single color register. The values supplied are already

     *  rounded down to the hardware's capabilities (according to the

     *  entries in the var structure). Return != 0 for invalid regno.

 Clear PALETTE_ACCESS_CNTL in DAC_CNTL */

 Set palette index & data */

 Set PALETTE_ACCESS_CNTL in DAC_CNTL */

 Set palette index & data */

 Set palette index & data (could be smarter) */

 Write to both LUTs for now */

    /*

     *  Blank the display.

 Clear PALETTE_ACCESS_CNTL in DAC_CNTL */

 Set palette index & data */

 Set PALETTE_ACCESS_CNTL in DAC_CNTL */

 Set palette index & data */

 On avivo, initialize palette control */

 Look for AVIVO initialized by SLOF */

 This will match most R5xx */

 RGB 555 */

 RGB 565 */

 RGB 888 */

 set offb aperture size for generic probing */

	/* Ok, now we try to figure out the address of the framebuffer.

	 *

	 * Unfortunately, Open Firmware doesn't provide a standard way to do

	 * so. All we can do is a dodgy heuristic that happens to work in

	 * practice. On most machines, the "address" property contains what

	 * we need, though not on Matrox cards found in IBM machines. What I've

	 * found that appears to give good results is to go through the PCI

	 * ranges and pick one that is both big enough and if possible encloses

	 * the "address" property. If none match, we pick the biggest

 Hack for when BootX is passing us */

 kludge for valkyrie */

 Check if we have a MacOS display without a node spec */

		/* The old code tried to work out which node was the MacOS

		 * display based on the address. I'm dropping that since the

		 * lack of a node spec only happens with old BootX versions

		 * (users can update) and with this code, they'll still get

		 * a display (just not the palette hacks).

 SPDX-License-Identifier: GPL-2.0-only

/*

 * udlfb.c -- Framebuffer driver for DisplayLink USB controller

 *

 * Copyright (C) 2009 Roberto De Ioris <roberto@unbit.it>

 * Copyright (C) 2009 Jaya Kumar <jayakumar.lkml@gmail.com>

 * Copyright (C) 2009 Bernie Thompson <bernie@plugable.com>

 *

 * Layout is based on skeletonfb by James Simmons and Geert Uytterhoeven,

 * usb-skeleton by GregKH.

 *

 * Device-specific portions based on information from Displaylink, with work

 * from Florian Echtler, Henrik Bjerregaard Pedersen, and others.

/*

 * There are many DisplayLink-based graphics products, all with unique PIDs.

 * So we match on DisplayLink's VID + Vendor-Defined Interface Class (0xff)

 * We also require a match on SubClass (0x00) and Protocol (0x00),

 * which is compatible with all known USB 2.0 era graphics chips and firmware,

 * but allows DisplayLink to increment those for any future incompatible chips

 module options */

 Allow fbcon to open framebuffer */

 Detect mmap writes using page faults */

 Optionally disable shadow framebuffer */

 Optionally force a pixel resolution limit */

 dlfb keeps a list of urbs for efficient bulk transfers */

/*

 * All DisplayLink bulk operations start with 0xAF, followed by specific code

 * All operations are written to buffers which then later get sent to device

/*

 * Map FB_BLANK_* to DisplayLink register

 * DLReg FB_BLANK_*

 * ----- -----------------------------

 *  0x00 FB_BLANK_UNBLANK (0)

 *  0x01 FB_BLANK (1)

 *  0x03 FB_BLANK_VSYNC_SUSPEND (2)

 *  0x05 FB_BLANK_HSYNC_SUSPEND (3)

 *  0x07 FB_BLANK_POWERDOWN (4) Note: requires modeset to come back

 the base pointer is 16 bits wide, 0x20 is hi byte. */

/*

 * DisplayLink HW has separate 16bpp and 8bpp framebuffers.

 * In 24bpp modes, the low 323 RGB bits go in the 8bpp framebuffer

/*

 * This is kind of weird because the controller takes some

 * register values in a different byte order than other registers.

/*

 * LFSR is linear feedback shift register. The reason we have this is

 * because the display controller needs to minimize the clock depth of

 * various counters used in the display path. So this code reverses the

 * provided value into the lfsr16 value by counting backwards to get

 * the value that needs to be set in the hardware comparator to get the

 * same actual count. This makes sense once you read above a couple of

 * times and think about it from a hardware perspective.

 This is the lfsr value that the hw starts with */

/*

 * This does LFSR conversion on the value that is to be written.

 * See LFSR explanation above for more detail.

/*

 * This takes a standard fbdev screeninfo struct and all of its monitor mode

 * details and converts them into the DisplayLink equivalent register commands.

 x display start */

 x display end */

 y display start */

 y display end */

 x end count is active + blanking - 1 */

 libdlo hardcodes hsync start to 1 */

 hsync end is width of sync pulse + 1 */

 hpixels is active pixels */

 yendcount is vertical active + vertical blanking */

 libdlo hardcodes vsync start to 0 */

 vsync end is width of vsync pulse */

 vpixels is active pixels */

 convert picoseconds to 5kHz multiple for pclk5k = x * 1E12/5k */

/*

 * This takes a standard fbdev screeninfo struct that was fetched or prepared

 * and then generates the appropriate command sequence that then drives the

 * display controller.

	/*

	* This first section has to do with setting the base address on the

	* controller * associated with the display. There are 2 base

	* pointers, currently, we only * use the 16 bpp segment.

 set base for 16bpp segment to 0 */

 set base for 8bpp segment to end of fb */

/*

 * Trims identical data from front and back of line

 * Sets new front buffer address and width

 * And returns byte count of identical pixels

 * Assumes CPU natural alignment (unsigned long)

 * for back and front buffer ptrs and width

/*

 * Render a command stream for an encoded horizontal line segment of pixels.

 *

 * A command buffer holds several commands.

 * It always begins with a fresh command header

 * (the protocol doesn't require this, but we enforce it to allow

 * multiple buffers to be potentially encoded and sent in parallel).

 * A single command encodes one contiguous horizontal line of pixels

 *

 * The function relies on the client to do all allocation, so that

 * rendering can be done directly to output buffers (e.g. USB URBs).

 * The function fills the supplied command buffer, providing information

 * on where it left off, so the client may call in again with additional

 * buffers if the line will take several buffers to complete.

 *

 * A single command can transmit a maximum of 256 pixels,

 * regardless of the compression ratio (protocol design limit).

 * To the hardware, 0 for a size byte means 256

 *

 * Rather than 256 pixel commands which are either rl or raw encoded,

 * the rlx command simply assumes alternating raw and rl spans within one cmd.

 * This has a slightly larger header overhead, but produces more even results.

 * It also processes all data (read and write) in a single pass.

 * Performance benchmarks of common cases show it having just slightly better

 * compression than 256 pixel raw or rle commands, with similar CPU consumpion.

 * But for very rl friendly data, will compress not quite as well.

  we'll know this later */

  we'll know this later */

 note: the framebuffer may change under us, so we must test for underflow */

 go back and fill in raw pixel count */

 immediately after raw data is repeat byte */

 Then start another raw pixel span */

 finalize last RAW span */

 undo unused byte */

 Fill leftover bytes with no-ops */

/*

 * There are 3 copies of every pixel: The front buffer that the fbdev

 * client renders to, the actual framebuffer across the USB bus in hardware

 * (that we can only write to, slowly, and can never read), and (optionally)

 * our shadow copy that tracks what's been sent to that hardware buffer.

 lost pixels is set */

 lost_pixels is set */

 Send partial buffer remaining before exiting */

 Kcycles */

/*

 * Path triggered by usermode clients who write to filesystem

 * e.g. cat filename > /dev/fb1

 * Not used by X Windows or text-mode console. But useful for testing.

 * Slow because of extra copy and we must assume all pixels dirty.

 hardware has native COPY command (see libdlo), but not worth it for fbcon */

/*

 * NOTE: fb_defio.c is holding info->fbdefio.mutex

 *   Touching ANY framebuffer memory that triggers a page fault

 *   in fb_defio will cause a deadlock, when it also tries to

 *   grab the same mutex.

 walk the written page list and render each to device */

 Send partial buffer remaining before exiting */

 Kcycles */

 TODO: Update X server to get this from sysfs instead */

 TODO: Help propose a standard fb.h ioctl to report mmap damage */

		/*

		 * If we have a damage-aware client, turn fb_defio "off"

		 * To avoid perf imact of unnecessary page fault handling.

		 * Done by resetting the delay for this fb_info to a very

		 * long period. Pages will become writable and stay that way.

		 * Reset to normal value when all clients have closed this fb.

 taken from vesafb */

 1:5:5:5 */

 0:5:6:5 */

/*

 * It's common for several clients to have framebuffer open simultaneously.

 * e.g. both fbcon and X. Makes things interesting.

 * Assumes caller is holding info->lock (for open and release at least)

	/*

	 * fbcon aggressively connects to first framebuffer it finds,

	 * preventing other clients (X) from working properly. Usually

	 * not what the user wants. Fail by default with option to enable.

 If the USB device is gone, we don't accept new opens */

 enable defio at last moment if not disabled by client */

 Assume info structure is freed after this point */

/*

 * Assumes caller is holding info->lock mutex (for open and release at least)

/*

 * Check whether a video mode is supported by the DisplayLink chip

 * We start from monitor's modes, so don't need to filter that here

 set device-specific elements of var unrelated to mode */

 clear the activate field because it causes spurious miscompares */

 paint greenscreen */

 To fonzi the jukebox (e.g. make blanking changes take effect) */

 copy */

 from address*/

 one pixel */

 to address */

/*

 * In order to come back from full DPMS off, we need to set the mode again

 returning from powerdown requires a fresh modeset */

 seems like a render op is needed to have blank change take effect */

/*

 * Assumes &info->lock held by caller

 * Assumes no active clients have framebuffer open

		/*

		 * Alloc system memory for virtual framebuffer

		/*

		 * Second framebuffer copy to mirror the framebuffer state

		 * on the physical USB device. We can function without this.

		 * But with imperfect damage info we may send pixels over USB

		 * that were, in fact, unchanged - wasting limited USB bandwidth

/*

 * 1) Get EDID from hw, or use sw default

 * 2) Parse into various fb_info structs

 * 3) Allocate virtual framebuffer memory to back highest res mode

 *

 * Parses EDID into three places used by various parts of fbdev:

 * fb_var_screeninfo contains the timing of the monitor's preferred mode

 * fb_info.monspecs is full parsed EDID info, including monspecs.modedb

 * fb_info.modelist is a linked list of all monitor & VESA modes which work

 *

 * If EDID is not readable/valid, then modelist is all VESA modes,

 * monspecs is NULL, and fb_var_screeninfo is set to safe VESA mode

 * Returns 0 if successful

 only use mutex if info has been registered */

 parent device is used otherwise */

	/*

	 * Try to (re)read EDID from hardware first

	 * EDID data may return, but not parse as valid

	 * Try again a few times, in case of e.g. analog cable noise

 If that fails, use a previously returned EDID if available */

 If that fails, use the default EDID we were handed */

 If we've got modes, let's pick a best default mode */

 if we've removed top/best mode */

 If everything else has failed, fall back to safe default mode */

		/*

		 * Add the standard VESA modes to our modelist

		 * Since we don't have EDID, there may be modes that

		 * overspec monitor and/or are incorrect aspect ratio, etc.

		 * But at least the user has a chance to choose

		/*

		 * default to resolution safe for projectors

		 * (since they are most common case without EDID)

 If we have good mode and no active clients*/

		/*

		 * with mode size info, we can now alloc our framebuffer.

 We only support write of entire EDID at once, no offset*/

/*

 * This is necessary before we can communicate with the display controller.

 vendor specific */

 if not found, look in configuration descriptor */

 descriptor length */

 vendor descriptor type */

 version (2 bytes) */

 length after type */

 the fixed header we've already parsed */

 max_area */

 allow udlfb to load for now even if firmware unrecognized */

 usb initialization */

 default to maximum */

 allocates framebuffer driver structure, not framebuffer memory */

 We don't register a new USB class. Our client interface is dlfbev */

 ready to begin using device */

 we virtualize until all fb clients release. Then we free */

 When non-active we'll update virtual framebuffer, but no new urbs */

 this function will wait for all in-flight urbs to complete */

 remove udlfb's sysfs interfaces */

 success */

 sync/async unlink faults aren't errors */

 reset to actual */

 keep waiting and freeing, until we've got 'em all */

 have reserved one with sem */

 Free each separately allocated piece */

 urb->transfer_buffer_length set to actual before submit */

 Wait for an in-flight buffer to complete and get re-queued */

 reserved one with limit_sem */

 set to actual payload len */

 because no one else will */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2008-2009 MontaVista Software Inc.

 * Copyright (C) 2008-2009 Texas Instruments Inc

 *

 * Based on the LCD driver for TI Avalanche processors written by

 * Ajay Singh and Shalom Hai.

 LCD Status Register */

 LCD DMA Control Register */

 LCD Control Register */

 LCD Raster Control Register */

 LCD Raster Timing 2 Register */

 LCD Block */

 Interrupt Registers available only in Version 2 */

 Clock registers available only on Version 2 */

	/*

	 * LCDC has 2 ping pong DMA channels, channel 0

	 * and channel 1.

 Sharp LCD035Q3DG01 */

 Sharp LK043T1DG01 */

 Hitachi SP10Q010 */

 Densitron 84-0023-001T */

 Enable the Raster Engine of the LCD Controller */

 Put LCDC in reset for several cycles */

 Write 1 to reset LCDC */

 Bring LCDC out of reset */

 Above reset sequence doesnot reset register context */

 Disable the Raster Engine of the LCD Controller */

 return if already disabled */

 init reg to clear PLM (loading mode) fields */

	/*

	 * The Raster enable bit must be set after all other control fields are

	 * set.

 Configure the Burst Size and fifo threhold of DMA */

 Set the AC Bias Period and Number of Transisitons per Interrupt */

	/*

	 * LCDC Version 2 adds some extra bits that increase the allowable

	 * size of the horizontal timing registers.

	 * remember that the registers use 0 to represent 1 so all values

	 * that get set into register need to be decremented by 1

 Mask off the bits we want to change */

 AC bias applicable only for Pasive panels */

 enable additional interrupts here */

 Set the Panel Width */

 Pixels per line = (PPL + 1)*16 */

		/*

		 * 0x3F in bits 4..9 gives max horizontal resolution = 1024

		 * pixels.

		/*

		 * 0x7F in bits 4..10 gives max horizontal resolution = 2048

		 * pixels.

 Set the Panel Height */

 Set bits 9:0 of Lines Per Pixel */

 Set bit 10 of Lines Per Pixel */

 Set the Raster Order of the Frame Buffer */

 Truecolor has hardware independent palette */

 Update the palette in the h/w as needed. */

 DMA has to be disabled */

 Write 1 to reset */

 Configure the LCD clock divisor. */

 Configure the DMA burst size and fifo threshold. */

 Configure the vertical and horizontal sync properties. */

 Configure for disply */

 Configure FDD */

 IRQ handler for version 2 of LCDC */

		/*

		 * Must disable raster before changing state of any control bit.

		 * And also must be disabled before clearing the PL loading

		 * interrupt via the following write to the status register. If

		 * this is done after then one gets multiple PL done interrupts.

 Disable PL completion interrupt */

 Setup and start data loading mode */

		/* Set only when controller is disabled and at the end of

		 * active frame

 IRQ handler for version 1 LCDC */

		/*

		 * Must disable raster before changing state of any control bit.

		 * And also must be disabled before clearing the PL loading

		 * interrupt via the following write to the status register. If

		 * this is done after then one gets multiple PL done interrupts.

 Disable PL completion inerrupt */

 Setup and start data loading mode */

 RGB 565 */

 disable DMA  */

/*

 * Function to wait for vertical sync which for this LCD peripheral

 * translates into waiting for the current raster frame to complete.

	/*

	 * Set flag to 0 and wait for isr to set to 1. It would seem there is a

	 * race condition here where the ISR could have occurred just before or

	 * just after this set. But since we are just coarsely waiting for

	 * a frame to complete then that's OK. i.e. if the frame completed

	 * just before this code executed then we have to wait another full

	 * frame time but there is no way to avoid such a situation. On the

	 * other hand if the frame completed just after then we don't need

	 * to wait long at all. Either way we are guaranteed to return to the

	 * user immediately after a frame completion which is all that is

	 * required.

/*

 * Set new x,y offsets in the virtual display for the visible area and switch

 * to the new mode.

 Determine LCD IP Version */

 allocate frame buffer */

 allocate palette buffer */

 Initialize fbinfo */

 initialize var_screeninfo */

 initialize the vsync wait queue */

 Register the Frame Buffer  */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * linux/drivers/video/ep93xx-fb.c

 *

 * Framebuffer support for the EP93xx series.

 *

 * Copyright (C) 2007 Bluewater Systems Ltd

 * Author: Ryan Mallon

 *

 * Copyright (c) 2009 H Hartley Sweeten <hsweeten@visionengravers.com>

 *

 * Based on the Cirrus Logic ep93xxfb driver, and various other ep93xxfb

 * drivers.

 Vertical Frame Timing Registers */

 SW locked */

 SW locked */

 SW locked */

 SW locked */

 SW locked */

 Horizontal Frame Timing Registers */

 SW locked */

 SW locked */

 SW locked */

 SW locked */

 SW locked */

 Frame Buffer Memory Configuration Registers */

 SW locked */

 Other Video Registers */

 SW locked */

 SW locked */

 Blink Control Registers */

 Hardware Cursor Registers */

 LUT Registers */

 Video Signature Registers */

 Minimum / Maximum resolutions supported */

/*

 * Write to one of the locked raster registers.

	/*

	 * We don't need a lock or delay here since the raster register

	 * block will remain unlocked until the next access.

 Maximum 16bpp -> used memory is maximum x*y*2 bytes */

	/*

	 * There is a bug in the ep93xx framebuffer which causes problems

	 * if bit 27 of the physical address is set.

	 * See: https://marc.info/?l=linux-arm-kernel&m=110061245502000&w=2

	 * There does not seem to be any official errata for this, but I

	 * have confirmed the problem exists on my hardware (ep9315) at

	 * least.

	/*

	 * FIXME - We don't do a request_mem_region here because we are

	 * sharing the register space with the backlight driver (see

	 * drivers/video/backlight/ep93xx_bl.c) and doing so will cause

	 * the second loaded driver to return -EBUSY.

	 *

	 * NOTE: No locking is required; the backlight does not touch

	 * any of the framebuffer registers.

 SPDX-License-Identifier: GPL-2.0-only

 apollo video HW definitions */

/*

 * Control Registers.   IOBASE + $x

 *

 * Note: these are the Memory/IO BASE definitions for a mono card set to the

 * alternate address

 *

 * Control 3A and 3B serve identical functions except that 3A

 * deals with control 1 and 3b deals with Color LUT reg.

 Base address of 1 plane board. */

 Status register.  Read */

 Write Enable Register Write */

 Device ID Register. Read */

 Raster Operation reg. Write Word */

 Diagnostic Memory Request. Write Word */

 Control Register 0.  Read/Write */

 Control Register 1.  Read/Write */

 Control Register 3a. Read/Write */

 Control Register 2. Read/Write */

 CREG 0 */

 010x.xxxx */

 100x.xxxx */

 111x.xxxx */

 xxx1.1111 */

 other bits are Shift value */

 CREG 1 */

 1xxx.xxxx */

 1xxx.xxxx */	
 0xxx.xxxx */	
 0xxx.xxxx */

 xIxx.xxxx */

 xxx1.xxxx */

 xxx0.xxxx */

 xxxx.1xxx */

 xxxx.xx1x */

 xxxx.xxx0 */

 xxxx.xxx1 */

 no reset sync */

 CREG 2 */

/*

 * Following 3 defines are common to 1, 4 and 8 plane.

 00xx.xxxx */	
 01xx.xxxx */	
#define S_DATA_PLN  0xC0 /* 11xx.xxxx */	/* normal, each data access =16-bits in

 CREG 3A/CREG 3B */

 1000.0000 */

 ROP REG  -  all one nibble */

      ********* NOTE : this is used r0,r1,r2,r3 *********** */

 frame buffer operations */

/*

 * Initialization

 now we have registered we can safely setup the hardware */

/*

 *	linux/drivers/video/pmagb-b-fb.c

 *

 *	PMAGB-B TURBOchannel Smart Frame Buffer (SFB) card support,

 *	derived from:

 *	"HP300 Topcat framebuffer support (derived from macfb of all things)

 *	Phil Blundell <philb@gnu.org> 1998", the original code can be

 *	found in the file hpfb.c in the same directory.

 *

 *	DECstation related code Copyright (C) 1999, 2000, 2001 by

 *	Michael Engel <engel@unix-ag.org>,

 *	Karsten Merker <merker@linuxtag.org> and

 *	Harald Koerfgen.

 *	Copyright (c) 2005, 2006  Maciej W. Rozycki

 *

 *	This file is subject to the terms and conditions of the GNU General

 *	Public License.  See the file COPYING in the main directory of this

 *	archive for more details.

/*

 * Set the palette.

 The cmap fields are 16 bits    */

 wide, but the hardware colormap */

 registers are only 8 bits wide */

/*

 * Turn the hardware cursor off.

/*

 * Set up screen parameters.

/*

 * Determine oscillator configuration.

 select Osc0 */

 nominally max. 20.5us */

 select Osc1 */

 nominally max. 20.5us */

 reselect OscX */

 Request the I/O MEM resource.  */

 MMIO mapping setup.  */

 Frame buffer mapping setup.  */

/*

 * Initialize the framebuffer.

 SPDX-License-Identifier: GPL-2.0-only

/* tcx.c: TCX frame buffer driver

 *

 * Copyright (C) 2003, 2006 David S. Miller (davem@davemloft.net)

 * Copyright (C) 1996,1998 Jakub Jelinek (jj@ultra.linux.cz)

 * Copyright (C) 1996 Miguel de Icaza (miguel@nuclecu.unam.mx)

 * Copyright (C) 1996 Eddie C. Dost (ecd@skynet.be)

 *

 * Driver layout based loosely on tgafb.c, see that file for credits.

/*

 * Local functions.

/*

 *  Frame buffer operations

 THC definitions */

 The contents are unknown */

 hsync timing */

 vsync timing */

 cursor x,y position (16 bits each) */

 cursor mask bits */

 what to show where mask enabled */

 Reset control plane so that WID is 8-bit plane. */

/**

 *      tcx_setcolreg - Optional function. Sets a color register.

 *      @regno: boolean, 0 copy local, 1 get_user() function

 *      @red: frame buffer colormap structure

 *      @green: The green value which can be up to 16 bits wide

 *      @blue:  The blue value which can be up to 16 bits wide.

 *      @transp: If supported the alpha value which can be up to 16 bits wide.

 *      @info: frame buffer info structure

/**

 *      tcx_blank - Optional function.  Blanks the display.

 *      @blank: the blank mode we want.

 *      @info: frame buffer structure that represents a single frame buffer

 Unblanking */

 Normal blanking */

 VESA blank (vsync off) */

 VESA blank (hsync off) */

 Poweroff */

/*

 *  Initialisation

 Initialize brooktree DAC. */

 color planes */

 overlay plane */

/*

 *  controlfb.c -- frame buffer device for the PowerMac 'control' display

 *

 *  Created 12 July 1998 by Dan Jacobowitz <dan@debian.org>

 *  Copyright (C) 1998 Dan Jacobowitz

 *  Copyright (C) 2001 Takashi Oe

 *

 *  Mmap code by Michel Lanners <mlan@cpu.lu>

 *

 *  Frame buffer structure from:

 *    drivers/video/chipsfb.c -- frame buffer device for

 *    Chips & Technologies 65550 chip.

 *

 *    Copyright (C) 1998 Paul Mackerras

 *

 *    This file is derived from the Powermac "chips" driver:

 *    Copyright (C) 1997 Fabio Riccardi.

 *    And from the frame buffer device for Open Firmware-initialized devices:

 *    Copyright (C) 1997 Geert Uytterhoeven.

 *

 *  Hardware information from:

 *    control.c: Console support for PowerMac "control" display adaptor.

 *    Copyright (C) 1996 Paul Mackerras

 *

 *  Updated to 2.5 framebuffer API by Ben Herrenschmidt

 *  <benh@kernel.crashing.org>, Paul Mackerras <paulus@samba.org>,

 *  and James Simmons <jsimmons@infradead.org>.

 *

 *  This file is subject to the terms and conditions of the GNU General Public

 *  License. See the file COPYING in the main directory of this archive for

 *  more details.

 control register access macro */

************************* Internal variables *******************************/

 tell clut what addr to fill	*/

 send one color channel at	*/

 a time...			*/

*******************  End of controlfb_ops implementation  ******************/

/*

 * Set screen start address according to var offset values

 Now how about actually saying, Make it so! */

 Some things in here probably don't need to be done each time. */

		/*

		 * check if only xoffset or yoffset differs.

		 * this prevents flickers in typical VT switch case.

 Turn off display */

 Turn on display */

 CONFIG_BOOTX_TEXT */

 Work out which banks of VRAM we have installed. */

 danj: I guess the card just ignores writes to nonexistant VRAM... */

	/*

	 * Set VRAM in 2MB (bank 1) mode

	 * VRAM Bank 2 will be accessible through offset 0x600000 if present

	 * and VRAM Bank 1 will not respond at that offset even if present

	/*

	 * Set VRAM in 2MB (bank 2) mode

	 * VRAM Bank 1 will be accessible through offset 0x000000 if present

	 * and VRAM Bank 2 will not respond at that offset even if present

			/*

			 * vram bank 2 only

			/*

			 * 4 MB vram

		/*

		 * vram bank 1 only

/*

 * Get the monitor sense value.

 * Note that this can be called before calibrate_delay,

 * so we can't use udelay.

 drive all lines high */

 turn off drivers */

 drive each sense line low in turn and collect the other 2 */

 drive A low */

 drive B low */

 drive C low */

 turn off drivers */

*********************  Various translation functions  **********************/

 ~ 200 MHz dot clock */

/*

 * calculate the clock paramaters to be sent to CUDA according to given

 * pixclock in pico second.

/*

 * This routine takes a user-supplied var, and picks the best vmode/cmode

 * from it.

	/*

	 * adjust xres and vxres so that the corresponding memory widths are

	 * 32-byte aligned

/*

 * Convert hardware data in par to an fb_var_screeninfo

 RGB 555 */

 RGB 888 */

	/*

	 * 10^12 * clock_params[0] / (3906400 * clock_params[1]

	 *			      * 2^clock_params[2])

	 * (10^12 * clock_params[0] / (3906400 * clock_params[1]))

	 * >> clock_params[2]

 (255990.17 * clock_params[0] / clock_params[1]) >> clock_params[2] */

*******************  The functions for controlfb_ops ********************/

/*

 * Checks a var structure

/*

 * Applies current var to display

	/*

	 * make sure start addr will be 32-byte aligned

/*

 * Private mmap since we want to have a different caching on the framebuffer

 * for controlfb.

 * Note there's no locking in here; it's done in fb_mmap() in fbmem.c.

 framebuffer */

/*

 * Set misc info vars for this driver

 Fill fb_info */

 Fill fix common fields */

/*

 * Parse user specified options (`video=controlfb:')

/*

 * finish off the driver initialization and register

 Try to pick a video mode out of NVRAM if we have one. */

 Initialize info structure */

 Setup default var */

 This shouldn't happen! */

 Apply default var */

 Register with fbdev layer */

/*

 * find "control" and initialize

 save it for cleanups */

 Map in frame buffer and registers */

 use the big-endian aperture (??) */

 map at most 8MB for the frame buffer */

 XXX not in prom? */

 SPDX-License-Identifier: GPL-2.0-only

/* ffb.c: Creator/Elite3D frame buffer driver

 *

 * Copyright (C) 2003, 2006 David S. Miller (davem@davemloft.net)

 * Copyright (C) 1997,1998,1999 Jakub Jelinek (jj@ultra.linux.cz)

 *

 * Driver layout based loosely on tgafb.c, see that file for credits.

/*

 * Local functions.

/*

 *  Frame buffer operations

 Register layout and definitions */

 DFB 422 mode write to A */

 DFB 422 mode with line doubling */

 DFB 24bit mode write to B */

 DFB 422 mode write to B */

 DFB 422 mode with line doubling */

 16bit mode Z planes */

 8bit mode Z planes */

 SFB 422 mode write to A/B */

 SFB 422 mode with line doubling */

 Draw operations */

 Pixel processor control */

 Force WID */

 Auxiliary clip */

 Depth cue */

 Alpha blend */

 View clip */

 Area pattern */

 Transparent background */

 Z source */

 Y source */

 X source */

 Color (BGR) source */

 Next vertex registers */

 Setup unit vertex state register */

 Control registers */

 New 3dRAM III support regs */

 User Control */

 4-bit Manufacturing Revision */

 Timing Generator */

 Video Enable */

 Device Identification */

 Device Part Number */

 Device Revision */

 AFB m3 or m6 */

 screen is blanked */

 DAC has inverted cursor logic */

 Disable cursor.  */

	/* We just use this to catch switches out of

	 * graphics mode.

/**

 *	ffb_fillrect - Draws a rectangle on the screen.

 *

 *	@info: frame buffer structure that represents a single frame buffer

 *	@rect: structure defining the rectagle and operation.

/**

 *	ffb_copyarea - Copies on area of the screen to another area.

 *

 *	@info: frame buffer structure that represents a single frame buffer

 *	@area: structure defining the source and destination.

/**

 *	ffb_imageblit - Copies a image from system memory to the screen.

 *

 *	@info: frame buffer structure that represents a single frame buffer

 *	@image: structure defining the image.

/**

 *	ffb_setcolreg - Sets a color register.

 *

 *	@regno: boolean, 0 copy local, 1 get_user() function

 *	@red: frame buffer colormap structure

 *	@green: The green value which can be up to 16 bits wide

 *	@blue:  The blue value which can be up to 16 bits wide.

 *	@transp: If supported the alpha value which can be up to 16 bits wide.

 *	@info: frame buffer info structure

/**

 *	ffb_blank - Optional function.  Blanks the display.

 *	@blank: the blank mode we want.

 *	@info: frame buffer structure that represents a single frame buffer

 Unblanking */

 Normal blanking */

 VESA blank (vsync off) */

 VESA blank (hsync off) */

 Poweroff */

/*

 *  Initialisation

 Framebuffer length is the same regardless of resolution. */

	/* Don't mention copyarea, so SCROLL_REDRAW is always

	 * used.  It is the fastest on this chip.

 FBINFO_HWACCEL_COPYAREA | */

	/* Elite3D has different DAC revision numbering, and no DAC revisions

	 * have the reversed meaning of cursor enable.  Otherwise, Pacifica 1

	 * ramdacs with manufacturing revision less than 3 have inverted

	 * cursor logic.  We identify Pacifica 1 as not Pacifica 2, the

	 * latter having a part number value of 0x236e.

	/* Unblank it just to be sure.  When there are multiple

	 * FFB/AFB cards in the system, or it is not the OBP

	 * chosen console, it will have video outputs off in

	 * the DAC.

/*

 * drivers/video/cirrusfb.c - driver for Cirrus Logic chipsets

 *

 * Copyright 1999-2001 Jeff Garzik <jgarzik@pobox.com>

 *

 * Contributors (thanks, all!)

 *

 *	David Eger:

 *	Overhaul for Linux 2.6

 *

 *      Jeff Rugen:

 *      Major contributions;  Motorola PowerStack (PPC and PCI) support,

 *      GD54xx, 1280x1024 mode support, change MCLK based on VCLK.

 *

 *	Geert Uytterhoeven:

 *	Excellent code review.

 *

 *	Lars Hecking:

 *	Amiga updates and testing.

 *

 * Original cirrusfb author:  Frank Neumann

 *

 * Based on retz3fb.c and cirrusfb.c:

 *      Copyright (C) 1997 Jes Sorensen

 *      Copyright (C) 1996 Frank Neumann

 *

 ***************************************************************

 *

 * Format this code with GNU indent '-kr -i8 -pcs' options.

 *

 * This file is subject to the terms and conditions of the GNU General Public

 * License.  See the file COPYING in the main directory of this archive

 * for more details.

 *

/*****************************************************************

 *

 * debugging and utility macros

 *

 disable runtime assertions? */

 #define CIRRUSFB_NDEBUG */

 debugging assertions */

/*****************************************************************

 *

 * chipset information

 *

 board types */

 GD5434 */

 GD5426 */

 GD5426 or GD5428 */

 GD5426 or GD5428 */

 GD5446 */

 GD543x/4x */

 GD5462/64 */

 GD5465 */

/*

 * per-board-type information, used for enumerating and abstracting

 * chip-specific information

 * NOTE: MUST be in the same order as enum cirrus_board in order to

 * use direct indexing on this array

 * NOTE: '__initdata' cannot be used as some of this info

 * is required at runtime.  Maybe separate into an init-only and

 * a run-time table?

 ASCII name of chipset */

 maximum video clock */

 for  1/4bpp, 8bpp 15/16bpp, 24bpp, 32bpp - numbers from xorg code */

 init SR07 during init_vgachip() */

 write SR1F during init_vgachip() */

 construct bit 19 of screen start address */

 initial SR07 value, then for each mode */

 SR1F VGA initial register value */

 guess */

 the SD64/P4 have a higher max. videoclock */

 guess */

 guess */

 guess */

 for the GD5430.  GD5446 can do more... */

 taken from X11 code */

 taken from X11 code */

 GD-5440 is same id */

 MacPicasso likely */

 Picasso 4 is 5446 */

 CL Laguna */

 CL Laguna 3D */

 CL Laguna 3DA*/

 CONFIG_PCI */

 Board type */

 Offset of registers in first Zorro device */

 Size of video RAM in first Zorro device */

 If zero, use autoprobe on RAM device */

 Offset of video RAM in first Zorro device */

 Zorro ID of RAM device */

 Zorro ID of optional second RAM device */

 0x02000000 for 64 MiB boards */

 CONFIG_ZORRO */

 CIRRUSFB_DEBUG */

 info about board */

 Shadow of special function register */

***************************************************************************/

*** BEGIN PROTOTYPES ******************************************************/

--- Interface used by the world ------------------------------------------*/

--- Internal routines ----------------------------------------------------*/

 CIRRUSFB_DEBUG */

** END   PROTOTYPES ********************************************************/

****************************************************************************/

** BEGIN Interface Used by the World ***************************************/

--- Open /dev/fbx ---------------------------------------------------------*/

--- Close /dev/fbx --------------------------------------------------------*/

*** END   Interface used by the World *************************************/

***************************************************************************/

*** BEGIN Hardware specific Routines **************************************/

 Check if the MCLK is not a better clock source */

 Read MCLK value */

	/* Determine if we should use MCLK instead of VCLK, and if so, what we

	 * should divide it by to get VCLK

 convert from ps to kHz */

	/* If the frequency is greater than we can support, we might be able

	/*

	 * Additional constraint: 8bpp uses DAC clock doubling to allow maximum

	 * pixel clock

	/* If we have a 1MB 5434, we need to put ourselves in a mode where

 memory size in pixels */

 use highest possible virtual resolution */

 truncate xoffset and yoffset to maximum if too high */

/*************************************************************************

	cirrusfb_set_par_foo()



	actually writes the values for a new video mode into the hardware,

 unlock register VGA_CRTC_H_TOTAL..CRT7 */

 previously: 0x00) */

 if debugging is enabled, all parameters get output before writing */

  + 128: Compatible read */

 LineCompare bit #9 */

 LineCompare bit #8 */

 set VCLK0 */

 hardware RefClock: 14.31818 MHz */

 formula: VClk = (OSC * N) / (D * (1+P)) */

 Example: VClk = (14.31818 * 91) / (23 * (1+1)) = 28.325 MHz */

		/* if freq is close to mclk or mclk/2 select mclk

		 * as clock source

 6 bit denom; ONLY 5434!!! (bugged me 10 days) */

 Laguna chipset has reversed clock registers */

 1280x1024 */

		/* mode control: VGA_CRTC_START_HI enable, ROTATE(?), 16bit

 don't know if it would hurt to also program this if no interlaced */

 mode is used, but I feel better this way.. :-) */

 interlace control */

 adjust horizontal/vertical sync type (low/high), use VCLK3 */

 enable display memory & CRTC I/O address for color mode */

 text cursor on and start line */

 text cursor end line */

	/******************************************************

	 *

	 * 1 bpp

	 *

 programming for different color depths */

 mode register */

 SR07 */

 Extended Sequencer Mode */

 evtl d0 bei 1 bit? avoid FIFO underruns..? */

 ## vorher d0 avoid FIFO underruns..? */

 do nothing */

 pixel mask: pass-through for first plane */

 hidden dac reg: 1280x1024 */

 hidden dac: nothing */

 memory mode: odd/even, ext. memory */

 plane mask: only write to first plane */

	/******************************************************

	 *

	 * 8 bpp

	 *

 Fast Page-Mode writes */

 ### INCOMPLETE!! */

 do nothing */

 mode register: 256 color mode */

 hidden dac reg: 1280x1024 */

 hidden dac: nothing */

	/******************************************************

	 *

	 * 16 bpp

	 *

 Fast Page-Mode writes */

 Fast Page-Mode writes */

 Extended Sequencer Mode: 256c col. mode */

 We already set SRF and SR1F */

 mode register: 256 color mode */

 FIXME: CONFIG_PCI and CONFIG_ZORRO may be defined both */

 hidden dac reg: nothing special */

	/******************************************************

	 *

	 * 24 bpp

	 *

 Fast Page-Mode writes */

 Fast Page-Mode writes */

 Extended Sequencer Mode: 256c col. mode */

 We already set SRF and SR1F */

 mode register: 256 color mode */

 hidden dac reg: 8-8-8 mode (24 or 32) */

	/******************************************************

	 *

	 * unknown/unsupported bpp

	 *

 offset overflow bit */

 screen start addr #16-18, fastpagemode cycles */

 screen start address bit 19 */

 pixel panning */

 [ EGS: SetOffset(); ] */

 From SetOffset(): Turn on VideoEnable bit in Attribute controller */

 no tiles */

 finally, turn on everything - turn off "FullBandwidth" bit */

 also, set "DotClock%2" bit where requested */

/*** FB_VMODE_CLOCK_HALVE in linux/fb.h not defined anymore ?

    if (var->vmode & FB_VMODE_CLOCK_HALVE)

	tmp |= 0x08;

/* for some reason incomprehensible to me, cirrusfb requires that you write

/*************************************************************************

	cirrusfb_pan_display()



	performs display panning - provided hardware permits this

 no range checks for xoffset and yoffset,   */

 as fb_pan_display has already done this */

 base is already correct */

 lower 8 + 8 bits of screen start address */

 0xf2 is %11110010, exclude tmp bits */

 construct bits 16, 17 and 18 of screen start address */

 construct bit 19 of screen start address */

	/* write pixel panning value to AR33; this does not quite work in 8bpp

	 *

	 * ### Piccolo..? Will this work?

	/*

	 * Blank the screen if blank_mode != 0, else unblank. If blank == NULL

	 * then the caller blanks by setting the CLUT (Color Look Up Table)

	 * to all black. Return 0 if blanking succeeded, != 0 if un-/blanking

	 * failed due to e.g. a video mode which doesn't support it.

	 * Implements VESA suspend and powerdown modes on hardware that

	 * supports disabling hsync/vsync:

	 *   blank_mode == 2: suspend vsync

	 *   blank_mode == 3: suspend hsync

	 *   blank_mode == 4: powerdown

 Undo current */

 clear "FullBandwidth" bit */

 set "FullBandwidth" bit */

 Let fbcon do a soft blank for us */

*** END   Hardware specific Routines **************************************/

***************************************************************************/

*** BEGIN Internal Routines ***********************************************/

 reset board globally */

 disable flickerfixer */

 mode */

 from Klaus' NetBSD driver: */

 put blitter into 542x compat */

 Nothing to do to reset the board. */

 make sure RAM size set by this point */

 the P4 is not fully initialized here; I rely on it having been */

 inited under AmigaOS already, which seems to work just fine    */

 (Klaus advised to do it this way)			      */

 EGS: 0x16 */

 EGS: 0x0e */

 reset sequencer logic */

 FullBandwidth (video off) and 8/9 dot clock */

 "magic cookie" - doesn't make any sense to me.. */

      vga_wgfx(cinfo->regbase, CL_GRA, 0xce);   */

 unlock all extension registers */

 plane mask: nothing */

 character map select: doesn't even matter in gx mode */

 memory mode: chain4, ext. memory */

 controller-internal base address of video memory */

  vga_wseq(cinfo->regbase, CL_SEQR8, 0x00); */

 EEPROM control: shouldn't be necessary to write to this at all.. */

 graphics cursor X position (incomplete; position gives rem. 3 bits */

 graphics cursor Y position (..."... ) */

 graphics cursor attributes */

 graphics cursor pattern address */

 writing these on a P4 might give problems..  */

 configuration readback and ext. color */

 signature generator */

 Screen A preset row scan: none */

 Text cursor start: disable text cursor */

 Text cursor end: - */

 text cursor location high: 0 */

 text cursor location low: 0 */

 Underline Row scanline: - */

 ### add 0x40 for text modes with > 30 MHz pixclock */

 ext. display controls: ext.adr. wrap */

 Set/Reset registers: - */

 Set/Reset enable: - */

 Color Compare: - */

 Data Rotate: - */

 Read Map Select: - */

 Mode: conf. for 16/4/2 color mode, no odd/even, read/write mode 0 */

 Miscellaneous: memory map base address, graphics mode */

 Color Don't care: involve all planes */

 Bit Mask: no mask at all */

 (5434 can't have bit 3 set for bitblt) */

	/* Graphics controller mode extensions: finer granularity,

	 * 8byte data latches

 Color Key compare: - */

 Color Key compare mask: - */

 Miscellaneous control: - */

 Background color byte 1: - */

  vga_wgfx (cinfo->regbase, CL_GR10, 0x00); */

  vga_wgfx (cinfo->regbase, CL_GR11, 0x00); */

 Attribute Controller palette registers: "identity mapping" */

 Attribute Controller mode: graphics mode */

 Overscan color reg.: reg. 0 */

 Color Plane enable: Enable all 4 planes */

 Color Select: - */

 Pixel mask: no mask */

 BLT Start/status: Blitter reset */

 - " -	   : "end-of-reset" */

 misc... */

 Hidden DAC register: - */

 only works on Zorro boards */

 XXX not ok for multiple boards */

 nothing to switch */

 nothing to switch */

 nothing to switch */

 do nothing */ break;

 do nothing */

 CONFIG_ZORRO */

*****************************************/

 Linux 2.6-style  accelerated functions */

*****************************************/

 Alpine/SD64 does not work at 24bpp ??? */

 clear background first */

/* Pulled the logic from XFree86 Cirrus driver to get the memory size,

 * based on the DRAM bandwidth bit and DRAM bank switching bit.  This

 * works with 1MB, 2MB and 4MB configurations (which the Motorola boards

		/* 64-bit DRAM data bus width; assume 2MB.

		 * Also indicates 2MB memory on the 5430.

		/* If DRAM bank switching is enabled, there must be

		 * twice as much memory installed. (4MB on the 5434)

 TODO: Handling of GD5446/5480 (see XF86 sources ...) */

 This is a best-guess for now */

 if system didn't claim this region, we would... */

 CONFIG_PCI */

 CONFIG_ZORRO */

 function table of the above functions */

 Fill fix common fields */

 monochrome: only 1 memory plane */

 8 bit and above: Use whole memory area */

 FIXME: map region at 0xB8000 if available, fill in here */

 sanity checks */

 set all the vital stuff */

 should never happen */

 FIXME: this forces VGA.  alternatives? */

 if the system didn't claim this region, we would... */

 CONFIG_PCI */

 Quirk for 64 MiB Picasso IV */

 MCLK select etc. */

 CONFIG_ZORRO */

    /*

     *  Modularization

*********************************************************************/

 about the following functions - I have used the same names for the */

 functions as Markus Wild did in his Retina driver for NetBSD as    */

 they just made sense for this purpose. Apart from that, I wrote    */

 these functions myself.					    */

*********************************************************************/

** WGen() - write into one of the external/general registers ***/

 Picasso II specific hack */

/*	      if (regnum == VGA_PEL_IR || regnum == VGA_PEL_D ||

** RGen() - read out one of the external/general registers ***/

 Picasso II specific hack */

/*	      if (regnum == VGA_PEL_IR || regnum == VGA_PEL_D ||

** AttrOn() - turn on VideoEnable for Attribute controller ***/

 if we're just in "write value" mode, write back the */

 same value as before to not modify anything */

 turn on video bit */

      vga_w(cinfo->regbase, VGA_ATT_IW, 0x20); */

 dummy write on Reg0 to be on "write index" mode next time */

** WHDR() - write into the Hidden DAC register ***/

/* as the HDR is the only extension register that requires special treatment

 * (the other extension registers are accessible just like the "ordinary"

 * registers of their functional group) here is a specialized routine for

 * accessing the HDR

 Klaus' hint for correct access to HDR on some boards */

 first write 0 to pixel mask (3c6) */

 next read dummy from pixel address (3c8) */

 now do the usual stuff to access the HDR */

 now first reset HDR access counter */

 and at the end, restore the mask value */

 ## is this mask always 0xff? */

** WSFR() - write to the "special function register" (SFR) ***/

 The Picasso has a second register for switching the monitor bit */

 writing an arbitrary value to this one causes the monitor switcher */

 to flip to Amiga display */

** WClut - set CLUT entry (range: 0..63) ***/

 address write mode register is not translated.. */

 but DAC data register IS, at least for Picasso II */

** RClut - read CLUT entry (range 0..63) ***/

/*******************************************************************

	cirrusfb_WaitBLT()



	Wait for the BitBLT engine to complete a possible earlier job

 FIXME: use interrupts instead */

/*******************************************************************

	cirrusfb_BitBLT()



	perform accelerated "scrolling"

 pitch: set to line_length */

 dest pitch low */

 dest pitch hi */

 source pitch low */

 source pitch hi */

 BLT width: actual number of pixels - 1 */

 BLT width low */

 BLT width hi */

 BLT height: actual number of lines -1 */

 BLT height low */

 BLT width hi */

 BLT destination */

 BLT dest low */

 BLT dest mid */

 BLT dest hi */

 BLT source */

 BLT src low */

 BLT src mid */

 BLT src hi */

 BLT mode */

 BLT mode */

 BLT ROP: SrcCopy */

 BLT ROP */

 and finally: GO! */

 BLT Start/status */

/*******************************************************************

	cirrusfb_BitBLT()



	perform accelerated "scrolling"

 if source adr < dest addr, do the Blt backwards */

 if src and dest are on the same line, check x */

 standard case: forward blitting */

		/* this means start addresses are at the end,

		 * counting backwards

/*******************************************************************

	cirrusfb_RectFill()



	perform accelerated rectangle fill

 This is a ColorExpand Blt, using the */

 same color for foreground and background */

/**************************************************************************

 * bestclock() - determine closest possible clock lower(?) than the

 * desired pixel clock

/* -------------------------------------------------------------------------

 *

 * debugging functions

 *

 * -------------------------------------------------------------------------

/*

 * cirrusfb_dbg_print_regs

 * @regbase: If using newmmio, the newmmio base address, otherwise %NULL

 * @reg_class: type of registers to read: %CRT, or %SEQ

 *

 * DESCRIPTION:

 * Dumps the given list of VGA CRTC registers.  If @base is %NULL,

 * old-style I/O ports are queried for information, otherwise MMIO is

 * used at the given @base address to query the information.

 should never occur */

/*

 * cirrusfb_dbg_reg_dump

 * @base: If using newmmio, the newmmio base address, otherwise %NULL

 *

 * DESCRIPTION:

 * Dumps a list of interesting VGA and CIRRUSFB registers.  If @base is %NULL,

 * old-style I/O ports are queried for information, otherwise MMIO is

 * used at the given @base address to query the information.

 CIRRUSFB_DEBUG */

/*

 *  linux/drivers/video/pxafb.c

 *

 *  Copyright (C) 1999 Eric A. Thomas.

 *  Copyright (C) 2004 Jean-Frederic Clere.

 *  Copyright (C) 2004 Ian Campbell.

 *  Copyright (C) 2004 Jeff Lackey.

 *   Based on sa1100fb.c Copyright (C) 1999 Eric A. Thomas

 *  which in turn is

 *   Based on acornfb.c Copyright (C) Russell King.

 *

 * This file is subject to the terms and conditions of the GNU General Public

 * License.  See the file COPYING in the main directory of this archive for

 * more details.

 *

 *	        Intel PXA250/210 LCD Controller Frame Buffer Driver

 *

 * Please direct your questions and comments on this driver to the following

 * email address:

 *

 *	linux-arm-kernel@lists.arm.linux.org.uk

 *

 * Add support for overlay1 and overlay2 based on pxafb_overlay.c:

 *

 *   Copyright (C) 2004, Intel Corporation

 *

 *     2003/08/27: <yu.tang@intel.com>

 *     2004/03/10: <stanley.cai@intel.com>

 *     2004/10/28: <yan.yin@intel.com>

 *

 *   Copyright (C) 2006-2008 Marvell International Ltd.

 *   All Rights Reserved

/*

 * Complain if VAR is out of range.

 Bits which should not be set in machine configuration structures */

	/*

	 * We need to handle two requests being made at the same time.

	 * There are two important cases:

	 *  1. When we are changing VT (C_REENABLE) while unblanking

	 *     (C_ENABLE) We must perform the unblanking, which will

	 *     do our REENABLE for us.

	 *  2. When we are blanking, but immediately unblank before

	 *     we have blanked.  We do the "REENABLE" thing here as

	 *     well, just to be sure.

	/*

	 * If inverse mode was selected, invert all the colours

	 * rather than the register number.  The register number

	 * is what you poke into the framebuffer to produce the

	 * colour you requested.

	/*

	 * If greyscale is true, then we convert the RGB value

	 * to greyscale no matter what visual we are using.

		/*

		 * 16-bit True Colour.  We encode the RGB value

		 * according to the RGB bitfield information.

 calculate pixel depth, transparency bit included, >=16bpp formats _only_ */

 calculate 4-bit BPP value for LCCR3 and OVLxC1 */

 18-bits/pixel packed */

 19-bits/pixel packed */

 18-bits/pixel unpacked */

 19-bits/pixel unpacked */

/*

 *  pxafb_var_to_lccr3():

 *    Convert a bits per pixel value to the correct bit pattern for LCCR3

 *

 *  NOTE: for PXA27x with overlays support, the LCCR3_PDFOR_x bits have an

 *  implication of the acutal use of transparency bit,  which we handle it

 *  here separatedly. See PXA27x Developer's Manual, Section <<7.4.6 Pixel

 *  Formats>> for the valid combination of PDFOR, PAL_FOR for various BPP.

 *

 *  Transparency for palette pixel formats is not supported at the moment.

/* set the RGBT bitfields of fb_var_screeninf according to

 * var->bits_per_pixel and given depth

 indexed pixel formats */

 RGBT555 */

 RGB565 */

 RGB666 */

 RGBT666 */

 RGBT887 */

 RGB888 */

 RGBT888 */

/*

 *  pxafb_display_dma_period()

 *    Calculate the minimum period (in picoseconds) between two DMA

 *    requests for the LCD controller.  If we hit this, it means we're

 *    doing nothing but LCD DMA.

	/*

	 * Period = pixclock * bits_per_byte * bytes_per_transfer

	 *              / memory_bits_per_pixel;

/*

 * Select the smallest mode that allows the desired resolution to be

 * displayed. If desired parameters can be rounded up.

 set the initial RGBA bitfields */

 make sure each line is aligned on word boundary */

 we don't support xpan, force xres_virtual to be equal to xres */

 check for limits */

/*

 *  pxafb_check_var():

 *    Get the video params out of 'var'. If a value doesn't fit, round it up,

 *    if it's too big, return -EINVAL.

 *

 *    Round up in the following order: bits_per_pixel, xres,

 *    yres, xres_virtual, yres_virtual, xoffset, yoffset, grayscale,

 *    bitfields, horizontal timing, vertical timing.

 do a test conversion to BPP fields to check the color formats */

/*

 * pxafb_set_par():

 *	Set the user defined part of the display for the specified console

		/*

		 * Some people have weird ideas about wanting static

		 * pseudocolor maps.  I suspect their user space

		 * applications are broken.

	/* Only take .xoffset, .yoffset and .vmode & FB_VMODE_YWRAP from what

	 * was passed in and copy the rest from the old screeninfo.

/*

 * pxafb_blank():

 *	Blank the display by setting all palette values to zero.  Note, the

 * 	16 bpp mode does not really use the palette, so this will not

 *      blank the display in all modes.

 TODO if (pxafb_blank_helper) pxafb_blank_helper(blank); */

 TODO if (pxafb_blank_helper) pxafb_blank_helper(blank); */

/* Depending on the enable status of overlay1/2, the DMA should be

 * updated from FDADRx (when disabled) or FBRx (when enabled).

 no support for framebuffer console on overlay */

 unblank the base framebuffer */

 no support for YUV format on overlay1 */

 for YUV packed formats, bpp = 'minimum bpp of YUV components' */

 each line must start at a 32-bit word boundary */

 xres must align on 32-bit word boundary */

	/* We assume that user will use at most video_mem_size for overlay fb,

	 * anyway, it's useless to use 16bpp main plane and 24bpp overlay

 mask all IU/BS/EOF/SOF interrupts */

 CONFIG_FB_PXA_OVERLAY */

/*

 * Calculate the PCD value from the clock rate (in picoseconds).

 * We take account of the PPCR clock setting.

 * From PXA Developer's Manual:

 *

 *   PixelClock =      LCLK

 *                -------------

 *                2 ( PCD + 1 )

 *

 *   PCD =      LCLK

 *         ------------- - 1

 *         2(PixelClock)

 *

 * Where:

 *   LCLK = LCD/Memory Clock

 *   PCD = LCCR3[7:0]

 *

 * PixelClock here is in Hz while the pixclock argument given is the

 * period in picoseconds. Hence PixelClock = 1 / ( pixclock * 10^-12 )

 *

 * The function get_lclk_frequency_10khz returns LCLK in units of

 * 10khz. Calling the result of this function lclk gives us the

 * following

 *

 *    PCD = (lclk * 10^4 ) * ( pixclock * 10^-12 )

 *          -------------------------------------- - 1

 *                          2

 *

 * Factoring the 10^4 and 10^-12 out gives 10^-8 == 1 / 100000000 as used below.

	/* FIXME: Need to take into account Double Pixel Clock mode

	 * (DPC) bit? or perhaps set it based on the various clock

 no need for this, since we should subtract 1 anyway. they cancel */

 pcd += 1; */ 
/*

 * Some touchscreens need hsync information from the video driver to

 * function correctly. We export it here.  Note that 'hsync_time' and

 * the value returned from pxafb_get_hsync_time() is the *reciprocal*

 * of the hsync period in seconds.

 If display is blanked/suspended, hsync isn't active */

 flip back and forth between palette and frame buffer */

 disable controller until all registers are set up */

	/* 1. make it an even number of commands to align on 32-bit boundary

	 * 2. add the interrupt command to the end of the chain so we can

	 *    keep track of the end of the transfer

 continue to execute next command */

 stop the processor in case it executed "wait for sync" cmd */

 don't send interrupts for fifo underruns on channel 6 */

 begin sending */

 quick disable */

 if it is a software delay, flush and delay */

 leave 2 commands for INTERRUPT and WAIT_FOR_SYNC */

 FIXME: make this configurable */

 CONFIG_FB_PXA_SMARTPANEL */

	/*

	 * If we have a dual scan LCD, we need to halve

	 * the YRES parameter.

/*

 * pxafb_activate_var():

 *	Configures LCD Controller based on entries in var parameter.

 *	Settings are only written to the controller if changes were made.

 Update shadow copy atomically */

	/*

	 * Only update the registers if the controller is enabled

	 * and something has changed.

/*

 * NOTE!  The following functions are purely helpers for set_ctrlr_state.

 * Do not call them directly; set_ctrlr_state does the correct serialisation

 * to ensure that things happen in the right way 100% of time time.

 *	-- rmk

 enable LCD controller clock */

 Sequence from 11.7.10 */

 Clear LCD Status Register */

 disable LCD controller clock */

/*

 *  pxafb_handle_irq: Handle 'LCD DONE' interrupts.

/*

 * This function must be called from task context only, since it will

 * sleep when disabling the LCD controller, or if we get two contending

 * processes trying to alter state.

	/*

	 * Hack around fbcon initialisation.

		/*

		 * Disable controller for clock change.  If the

		 * controller is already disabled, then do nothing.

 TODO __pxafb_lcd_power(fbi, 0); */

		/*

		 * Disable controller

		/*

		 * Enable the controller after clock change.  Only

		 * do this if we were disabled for the clock change.

 TODO __pxafb_lcd_power(fbi, 1); */

		/*

		 * Re-enable the controller only if it was already

		 * enabled.  This is so we reprogram the control

		 * registers.

		/*

		 * Re-enable the controller after PM.  This is not

		 * perfect - think about the case where we were doing

		 * a clock change, and we suspended half-way through.

		/*

		 * Power up the LCD screen, enable controller, and

		 * turn on the backlight.

/*

 * Our LCD controller task (which is called when we blank or unblank)

 * via keventd.

/*

 * CPU clock speed change handler.  We need to adjust the LCD timing

 * parameters when the CPU clock is adjusted by the power management

 * subsystem.

 *

 * TODO: Determine why f->new != 10*get_lclk_frequency_10khz()

 TODO struct cpufreq_freqs *f = data; */

/*

 * Power management hooks.  Note that we won't be called from IRQ context,

 * unlike the blank functions above, so we may sleep.

 fall back to backward compatibility way */

	/* decide video memory size as follows:

	 * 1. default to mode of maximum resolution

	 * 2. allow platform to override

	 * 3. allow module parameter to override

 Alloc the pxafb_info and pseudo_palette in one step */

 place overlay(s) on top of base */

 could be made table driven or similar?... */

/* Check for various illegal bit-combinations. Currently only

	/*

	 * On purpose, neither lccrX registers nor video memory size can be

	 * specified through device-tree, they are considered more a debug hack

	 * available through command line.

	/*

	 * This makes sure that our colour bitfield

	 * descriptors are correctly initialised.

	/*

	 * Ok, now enable the LCD controller

 sentinel */ }

/* sunxvr1000.c: Sun XVR-1000 fb driver for sparc64 systems

 *

 * License: GPL

 *

 * Copyright (C) 2010 David S. Miller (davem@davemloft.net)

 Fill fix common fields */

 Framebuffer length is the same regardless of resolution. */

/* sunxvr2500.c: Sun 3DLABS XVR-2500 et al. fb driver for sparc64 systems

 *

 * License: GPL

 *

 * Copyright (C) 2007 David S. Miller (davem@davemloft.net)

 Fill fix common fields */

	/* XXX 'linebytes' is often wrong, it is equal to the width

	 * XXX with depth of 32 on my XVR-2500 which is clearly not

	 * XXX right.  So we don't try to use it.

/*

 * linux/drivers/video/arcfb.c -- FB driver for Arc monochrome LCD board

 *

 * Copyright (C) 2005, Jaya Kumar <jayalk@intworks.biz>

 *

 * This file is subject to the terms and conditions of the GNU General Public

 * License. See the file COPYING in the main directory of this archive for

 * more details.

 *

 * Layout is based on skeletonfb.c by James Simmons and Geert Uytterhoeven.

 *

 * This driver was written to be used with the Arc LCD board. Arc uses a

 * set of KS108 chips that control individual 64x64 LCD matrices. The board

 * can be paneled in a variety of setups such as 2x1=128x64, 4x4=256x256 and

 * so on. The interface between the board and the host is TTL based GPIO. The

 * GPIO requirements are 8 writable data lines and 4+n lines for control. On a

 * GPIO-less system, the board can be tested by connecting the respective sigs

 * up to a parallel port connector. The driver requires the IO addresses for

 * data and control GPIO at load time. It is unable to probe for the

 * existence of the LCD so it must be told at load time whether it should

 * be enabled or not.

 *

 * Todo:

 * - testing with 4x4

 * - testing with interrupt hw

 *

 * General notes:

 * - User must set tuhold. It's in microseconds. According to the 108 spec,

 *   the hold time is supposed to be at least 1 microsecond.

 * - User must set num_cols=x num_rows=y, eg: x=2 means 128

 * - User must set arcfb_enable=1 to enable it

 * - User must set dio_addr=0xIOADDR cio_addr=0xIOADDR

 *

 ks108 chipset specific defines and code */

 main arcfb functions */

 not arc generated interrupt */

/*

 * here we handle a specific page on the lcd. the complexity comes from

 * the fact that the fb is laidout in 8xX vertical columns. we extract

 * each write of 8 vertical pixels. then we shift out as we move along

 * X. That's what rightshift does. bitmask selects the desired input bit.

/*

 * here we handle the entire vertical page of the update. we write across

 * lcd chips. update_page uses the upper/left values to decide which

 * chip to select for the right. upper is needed for setting the page

 * desired for the write.

/*

 * here we handle horizontal blocks for the update. update_vert will

 * handle spaning multiple pages. we break out each horizontal

 * block in to individual blocks no taller than 64 pixels.

/*

 * here we start the process of splitting out the fb update into

 * individual blocks of pixels. we end up splitting into 64x64 blocks

 * and finally down to 64x8 pages.

 align the request first */

 update the physical lcd */

 update the physical lcd */

 update the physical lcd */

 illegal to wait on arc if no irq will occur */

			/* wait until the Arc has generated an interrupt

/*

 * this is the access path from userspace. they can seek and write to

 * the fb. it's inefficient for them to do anything less than 64*8

 * writes since we update the lcd in each write() anyway.

 modded from epson 1355 */

	/* We need a flat backing store for the Arc's

 this inits the lcd but doesn't clear dirty pixels */

 if we were told to splash the screen, we just clear it */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * framebuffer driver for VBE 2.0 compliant graphic boards

 *

 * switching to graphics mode happens at boot time (while

 * running in real mode, see arch/i386/boot/video.S).

 *

 * (c) 1998 Gerd Knorr <kraxel@goldbach.in-berlin.de>

 *

 --------------------------------------------------------------------- */

 disable mtrr */

 Set amount of memory to be used */

 Set total amount of memory */

 pmi for palette changes ??? */

 0..nothing, 1..ypan, 2..ywrap */

 --------------------------------------------------------------------- */

 no return value */

 EAX */

 EBX */

 ECX */

 EDX */

 EDI */

/*

 * Try VGA registers first...

/*

 * Fallback to the PMI....

 no return value */

 EAX */

 EBX */

 ECX */

 EDX */

 EDI */

 ESI */

	/*

	 *  Set a single color register. The values supplied are

	 *  already rounded down to the hardware's capabilities

	 *  (according to the entries in the `var' structure). Return

	 *  != 0 for invalid regno.

 1:5:5:5 */

 0:5:6:5 */

 ignore error return of fb_get_options */

	/*   size_vmode -- that is the amount of memory needed for the

	 *                 used video mode, i.e. the minimum amount of

	/*   size_total -- all video memory we have. Used for mtrr

	 *                 entries, resource allocation and bounds

	/*   size_remap -- the amount of video memory we are going to

	 *                 use for vesafb.  With modern cards it is no

	 *                 option to simply use size_total as that

		/* We cannot make this fatal. Sometimes this comes from magic

 set vesafb aperture size for generic probing */

 not available or some DOS TSR ... */

				/*

				 * memory areas not supported (yet?)

				 *

				 * Rules are: we have to set up a descriptor for the requested

				 * memory area and pass it in the ES register to the BIOS function.

 some dummy values for timing to make fbset happy */

	/* request failure does not faze us, as vgacon probably has this

 Find the largest power-of-two */

 Try and find a power of two to add */

/*

 * linux/drivers/video/hecubafb.c -- FB driver for Hecuba/Apollo controller

 *

 * Copyright (C) 2006, Jaya Kumar

 * This work was sponsored by CIS(M) Sdn Bhd

 *

 * This file is subject to the terms and conditions of the GNU General Public

 * License. See the file COPYING in the main directory of this archive for

 * more details.

 *

 * Layout is based on skeletonfb.c by James Simmons and Geert Uytterhoeven.

 * This work was possible because of apollo display code from E-Ink's website

 * http://support.eink.com/community

 * All information used to write this code is from public material made

 * available by E-Ink on its support site. Some commands such as 0xA4

 * were found by looping through cmd=0x00 thru 0xFF and supplying random

 * values. There are other commands that the display is capable of,

 * beyond the 5 used here but they are more complex.

 *

 * This driver is written to be used with the Hecuba display architecture.

 * The actual display chip is called Apollo and the interface electronics

 * it needs is called Hecuba.

 *

 * It is intended to be architecture independent. A board specific driver

 * must be used to perform all the physical IO interactions. An example

 * is provided as n411.c

 *

 Display specific information */

 main hecubafb functions */

 set data */

 set DS low */

 wait for ack */

 set DS hi */

 wait for ack to clear */

 command so set CD to high */

 actually strobe with command */

 clear CD back to low */

 this is called back from the deferred io workqueue */

/*

 * this is the slow path from userspace. they can seek and write to

 * the fb. it's inefficient to do anything less than a full screen draw

 pick up board specific routines */

 try to count device specific driver, if can't, platform recalls */

 this inits the dpy */

 SPDX-License-Identifier: GPL-2.0-only

/* cg3.c: CGTHREE frame buffer driver

 *

 * Copyright (C) 2003, 2006 David S. Miller (davem@davemloft.net)

 * Copyright (C) 1996,1998 Jakub Jelinek (jj@ultra.linux.cz)

 * Copyright (C) 1996 Miguel de Icaza (miguel@nuclecu.unam.mx)

 * Copyright (C) 1997 Eddie C. Dost (ecd@skynet.be)

 *

 * Driver layout based loosely on tgafb.c, see that file for credits.

/*

 * Local functions.

/*

 *  Frame buffer operations

 Control Register Constants */

 Status Register Constants */

 Offset of interesting structures in the OBIO space */

/**

 *      cg3_setcolreg - Optional function. Sets a color register.

 *      @regno: boolean, 0 copy local, 1 get_user() function

 *      @red: frame buffer colormap structure

 *      @green: The green value which can be up to 16 bits wide

 *      @blue:  The blue value which can be up to 16 bits wide.

 *      @transp: If supported the alpha value which can be up to 16 bits wide.

 *      @info: frame buffer info structure

 *

 * The cg3 palette is loaded with 4 color values at each time

 * so you end up with: (rgb)(r), (gb)(rg), (b)(rgb), and so on.

 * We keep a sw copy of the hw cmap to assist us in this esoteric

 * loading procedure.

 (x/4)*3 */

 (x/4)*4 */

/**

 *      cg3_blank - Optional function.  Blanks the display.

 *      @blank: the blank mode we want.

 *      @info: frame buffer structure that represents a single frame buffer

 Unblanking */

 Normal blanking */

 VESA blank (vsync off) */

 VESA blank (hsync off) */

 Poweroff */

/*

 *  Initialisation

 1152 x 900, 66 Hz */

 1152 x 900, 76 Hz */

 640 x 480, cgRDI */

 SPDX-License-Identifier: GPL-2.0

/* sbuslib.c: Helper library for SBUS framebuffer drivers.

 *

 * Copyright (C) 2003 David S. Miller (davem@redhat.com)

 VM_IO | VM_DONTEXPAND | VM_DONTDUMP are set by remap_pfn_range() */

 Each page, see which map applies */

	case FBIOGCURSOR32:	/* This is not implemented yet.

/*

 * linux/drivers/video/vga16.c -- VGA 16-color framebuffer driver

 * 

 * Copyright 1999 Ben Pfaff <pfaffben@debian.org> and Petr Vandrovec <VANDROVE@vc.cvut.cz>

 * Based on VGA info at http://www.goodnet.com/~tinara/FreeVGA/home.htm

 * Based on VESA framebuffer (c) 1998 Gerd Knorr <kraxel@goldbach.in-berlin.de>

 *

 * This file is subject to the terms and conditions of the GNU General

 * Public License.  See the file COPYING in the main directory of this

 * archive for more details.  

 --------------------------------------------------------------------- */

/*

 * card parameters

	/* structure holding original VGA register settings when the

 Sequencer Index reg.   */

 CRT-Contr. Index reg.  */

 Miscellaneous register */

 CRT-Controller:00h */

 CRT-Controller:01h */

 CRT-Controller:04h */

 CRT-Controller:05h */

 CRT-Controller:07h */

 CRT-Controller:10h */

 CRT-Controller:11h */

 CRT-Controller:17h */

 Seq-Controller:01h */

 --------------------------------------------------------------------- */

 name should not depend on EGA/VGA */

/* The VGA's weird architecture often requires that we read a byte and

   write a byte to the same location.  It doesn't matter *what* byte

   we write, however.  This is because all the action goes on behind

   the scenes in the VGA's 32-bit latch register, and reading and writing

   video memory just invokes latch behavior.



   To avoid race conditions (is this necessary?), reading and writing

   the memory byte should be done with a single instruction.  One

   suitable instruction is the x86 bitwise OR.  The following

   read-modify-write routine should optimize to one such bitwise

/* Set the Graphics Mode Register, and return its previous value.

 Select the Bit Mask Register and return its value. */

/* Set the value of the Bit Mask Register.  It must already have been

/* Set the Data Rotate Register and return its old value. 

   Bits 0-2 are rotate count, bits 3-4 are logical operation

/* Set the Enable Set/Reset Register and return its old value.  

 Set the Set/Reset Register and return its old value. */

 Return the value in the Graphics Address Register. */

 Set the value in the Graphics Address Register. */

 FIXME !!! font height. Fugde for now.

	/* if we support CFB4, then we must! support xoffset with pixel

 reset flip-flop */

 8bpp */

 12.587 */, 0x00, 0x08},

 14.161 */, 0x04, 0x08},

 25.175 */, 0x00, 0x00},

 28.322 */, 0x04, 0x00},

 bad */,    0x00, 0x00}};

 no support on EGA */

 blank_end + 2 <= total + 5 */

 disable linecompare */

 1 scanline, no linecmp */

 0x02 -> DISP_END, 0x08 -> BLANK_START */

 0x40 -> DISP_END */

 BLANK_START */

 disabled IRQ */

 blank_end + 1 <= ytotal + 2 */

	par->crtc[VGA_CRTC_V_BLANK_END] = pos & 0xFF; /* 0x7F for original VGA,

 256, cfb8 */

 16, vgap */

 3DA */

 enable CPU, ports 0x3Dx, positive sync */

 pixel clock == vga clock / 2 */

 pixel clock == vga clock */

 0 for EGA, 0xFF for VGA */

 FIXME !!! Fudge font height. 

 Enable graphics register modification */

 update misc output register */

 synchronous reset on */

 write sequencer registers */

 synchronous reset off */

 deprotect CRT registers 0-7 */

 write CRT registers */

 write graphics controller registers */

 write attribute controller registers */

 reset flip-flop */

 Wait for screen to stabilize. */

 ! 0x3BA */

 some clones need it */

 unblank screen */

	/*

	 *  Set a single color register. The values supplied are

	 *  already rounded down to the hardware's capabilities

	 *  (according to the entries in the `var' structure). Return

	 *  != 0 for invalid regno.

 gray = 0.30*R + 0.59*G + 0.11*B */

/* The following VESA blanking code is taken from vgacon.c.  The VGA

   blanking code was originally by Huang shi chao, and modified by

   Christoph Rimek (chrimek@toppoint.de) and todd j. derr

 save original values of VGA controller registers */

sti();

 HorizontalTotal */

 HorizDisplayEnd */

 StartHorizRetrace */

 EndHorizRetrace */

 Overflow */

 StartVertRetrace */

 EndVertRetrace */

 ModeControl */

 ClockingMode */

 assure that video is enabled */

 "0x20" is VIDEO_ENABLE_bit in register 01 of sequencer */

 test for vertical retrace in process.... */

	/*

	 * Set <End of vertical retrace> to minimum (0) and

	 * <Start of vertical Retrace> to maximum (incl. overflow)

	 * Result: turn off vertical sync (VSync) pulse.

 bits 9,10 of vert. retrace */

		/*

		 * Set <End of horizontal retrace> to minimum (0) and

		 *  <Start of horizontal Retrace> to maximum

		 * Result: turn off horizontal sync (HSync) pulse.

 restore both index registers */

 restore original values of VGA controller registers */

 HorizontalTotal */

 HorizDisplayEnd */

 StartHorizRetrace */

 EndHorizRetrace */

 Overflow */

 StartVertRetrace */

 EndVertRetrace */

 ModeControl */

 ClockingMode */

 restore index/control registers */

 0 unblank, 1 blank, 2 no vsync, 3 no hsync, 4 off */

 Unblank */

 blank */

 VESA blanking */

 we can do memset... */

	/* We could use hardware clipping but on many cards you get around

 clip the destination */

	/*

	 * We could use hardware clipping but on many cards you get around

	 * hardware clipping by writing to framebuffer directly.

 update sx1,sy1 */

 the source must be completely inside the virtual screen */

 fill latches */

	/*

	 * Draw logo 

 XXX unshare VGA regions */

 XXX share VGA_FB_PHYS and I/O region with vgacon and others */

 name should not depend on EGA/VGA */

 supports rectangles with widths of multiples of 8 */

/*

 * linux/drivers/video/skeletonfb.c -- Skeleton for a frame buffer device

 *

 *  Modified to new api Jan 2001 by James Simmons (jsimmons@transvirtual.com)

 *

 *  Created 28 Dec 1997 by Geert Uytterhoeven

 *

 *

 *  I have started rewriting this driver as a example of the upcoming new API

 *  The primary goal is to remove the console code from fbdev and place it

 *  into fbcon.c. This reduces the code and makes writing a new fbdev driver

 *  easy since the author doesn't need to worry about console internals. It

 *  also allows the ability to run fbdev without a console/tty system on top 

 *  of it. 

 *

 *  First the roles of struct fb_info and struct display have changed. Struct

 *  display will go away. The way the new framebuffer console code will

 *  work is that it will act to translate data about the tty/console in 

 *  struct vc_data to data in a device independent way in struct fb_info. Then

 *  various functions in struct fb_ops will be called to store the device 

 *  dependent state in the par field in struct fb_info and to change the 

 *  hardware to that state. This allows a very clean separation of the fbdev

 *  layer from the console layer. It also allows one to use fbdev on its own

 *  which is a bounus for embedded devices. The reason this approach works is  

 *  for each framebuffer device when used as a tty/console device is allocated

 *  a set of virtual terminals to it. Only one virtual terminal can be active 

 *  per framebuffer device. We already have all the data we need in struct 

 *  vc_data so why store a bunch of colormaps and other fbdev specific data

 *  per virtual terminal. 

 *

 *  As you can see doing this makes the con parameter pretty much useless

 *  for struct fb_ops functions, as it should be. Also having struct  

 *  fb_var_screeninfo and other data in fb_info pretty much eliminates the 

 *  need for get_fix and get_var. Once all drivers use the fix, var, and cmap

 *  fbcon can be written around these fields. This will also eliminate the

 *  need to regenerate struct fb_var_screeninfo, struct fb_fix_screeninfo

 *  struct fb_cmap every time get_var, get_fix, get_cmap functions are called

 *  as many drivers do now. 

 *

 *  This file is subject to the terms and conditions of the GNU General Public

 *  License. See the file COPYING in the main directory of this archive for

 *  more details.

    /*

     *  This is just simple sample code.

     *

     *  No warranty that it actually compiles.

     *  Even less warranty that it actually works :-)

/*

 * Driver data

/*

 *  If your driver supports multiple boards, you should make the  

 *  below data types arrays, or allocate them dynamically (using kmalloc()). 

/* 

 * This structure defines the hardware state of the graphics card. Normally

 * you place this in a header file in linux/include/video. This file usually

 * also includes register information. That allows other driver subsystems

 * and userland applications the ability to use the same header file to 

 * avoid duplicate work and easy porting of software. 

/*

 * Here we define the default structs fb_fix_screeninfo and fb_var_screeninfo

 * if we don't use modedb. If we do use modedb see xxxfb_init how to use it

 * to get a fb_var_screeninfo. Otherwise define a default var as well. 

    /*

     * 	Modern graphical hardware not only supports pipelines but some 

     *  also support multiple monitors where each display can have its  

     *  its own unique data. In this case each display could be  

     *  represented by a separate framebuffer device thus a separate 

     *  struct fb_info. Now the struct xxx_par represents the graphics

     *  hardware state thus only one exist per card. In this case the 

     *  struct xxx_par for each graphics card would be shared between 

     *  every struct fb_info that represents a framebuffer on that card. 

     *  This allows when one display changes it video resolution (info->var) 

     *  the other displays know instantly. Each display can always be

     *  aware of the entire hardware state that affects it because they share

     *  the same xxx_par struct. The other side of the coin is multiple

     *  graphics cards that pass data around until it is finally displayed

     *  on one monitor. Such examples are the voodoo 1 cards and high end

     *  NUMA graphics servers. For this case we have a bunch of pars, each

     *  one that represents a graphics state, that belong to one struct 

     *  fb_info. Their you would want to have *par point to a array of device

     *  states and have each struct fb_ops function deal with all those 

     *  states. I hope this covers every possible hardware design. If not

     *  feel free to send your ideas at jsimmons@users.sf.net 

    /*

     *  If your driver supports multiple boards or it supports multiple 

     *  framebuffers, you should make these arrays, or allocate them 

     *  dynamically using framebuffer_alloc() and free them with

     *  framebuffer_release().

    /* 

     * Each one represents the state of the hardware. Most hardware have

     * just one hardware state. These here represent the default state(s). 

/**

 *	xxxfb_open - Optional function. Called when the framebuffer is

 *		     first accessed.

 *	@info: frame buffer structure that represents a single frame buffer

 *	@user: tell us if the userland (value=1) or the console is accessing

 *	       the framebuffer. 

 *

 *	This function is the first function called in the framebuffer api.

 *	Usually you don't need to provide this function. The case where it 

 *	is used is to change from a text mode hardware state to a graphics

 * 	mode state. 

 *

 *	Returns negative errno on error, or zero on success.

/**

 *	xxxfb_release - Optional function. Called when the framebuffer 

 *			device is closed. 

 *	@info: frame buffer structure that represents a single frame buffer

 *	@user: tell us if the userland (value=1) or the console is accessing

 *	       the framebuffer. 

 *	

 *	Thus function is called when we close /dev/fb or the framebuffer 

 *	console system is released. Usually you don't need this function.

 *	The case where it is usually used is to go from a graphics state

 *	to a text mode state.

 *

 *	Returns negative errno on error, or zero on success.

/**

 *      xxxfb_check_var - Optional function. Validates a var passed in. 

 *      @var: frame buffer variable screen structure

 *      @info: frame buffer structure that represents a single frame buffer 

 *

 *	Checks to see if the hardware supports the state requested by

 *	var passed in. This function does not alter the hardware state!!! 

 *	This means the data stored in struct fb_info and struct xxx_par do 

 *      not change. This includes the var inside of struct fb_info. 

 *	Do NOT change these. This function can be called on its own if we

 *	intent to only test a mode and not actually set it. The stuff in 

 *	modedb.c is a example of this. If the var passed in is slightly 

 *	off by what the hardware can support then we alter the var PASSED in

 *	to what we can do.

 *

 *      For values that are off, this function must round them _up_ to the

 *      next value that is supported by the hardware.  If the value is

 *      greater than the highest value supported by the hardware, then this

 *      function must return -EINVAL.

 *

 *      Exception to the above rule:  Some drivers have a fixed mode, ie,

 *      the hardware is already set at boot up, and cannot be changed.  In

 *      this case, it is more acceptable that this function just return

 *      a copy of the currently working var (info->var). Better is to not

 *      implement this function, as the upper layer will do the copying

 *      of the current var for you.

 *

 *      Note:  This is the only function where the contents of var can be

 *      freely adjusted after the driver has been registered. If you find

 *      that you have code outside of this function that alters the content

 *      of var, then you are doing something wrong.  Note also that the

 *      contents of info->var must be left untouched at all times after

 *      driver registration.

 *

 *	Returns negative errno on error, or zero on success.

 ... */

/**

 *      xxxfb_set_par - Optional function. Alters the hardware state.

 *      @info: frame buffer structure that represents a single frame buffer

 *

 *	Using the fb_var_screeninfo in fb_info we set the resolution of the

 *	this particular framebuffer. This function alters the par AND the

 *	fb_fix_screeninfo stored in fb_info. It doesn't not alter var in 

 *	fb_info since we are using that data. This means we depend on the

 *	data in var inside fb_info to be supported by the hardware. 

 *

 *      This function is also used to recover/restore the hardware to a

 *      known working state.

 *

 *	xxxfb_check_var is always called before xxxfb_set_par to ensure that

 *      the contents of var is always valid.

 *

 *	Again if you can't change the resolution you don't need this function.

 *

 *      However, even if your hardware does not support mode changing,

 *      a set_par might be needed to at least initialize the hardware to

 *      a known working state, especially if it came back from another

 *      process that also modifies the same hardware, such as X.

 *

 *      If this is the case, a combination such as the following should work:

 *

 *      static int xxxfb_check_var(struct fb_var_screeninfo *var,

 *                                struct fb_info *info)

 *      {

 *              *var = info->var;

 *              return 0;

 *      }

 *

 *      static int xxxfb_set_par(struct fb_info *info)

 *      {

 *              init your hardware here

 *      }

 *

 *	Returns negative errno on error, or zero on success.

 ... */

/**

 *  	xxxfb_setcolreg - Optional function. Sets a color register.

 *      @regno: Which register in the CLUT we are programming 

 *      @red: The red value which can be up to 16 bits wide 

 *	@green: The green value which can be up to 16 bits wide 

 *	@blue:  The blue value which can be up to 16 bits wide.

 *	@transp: If supported, the alpha value which can be up to 16 bits wide.

 *      @info: frame buffer info structure

 * 

 *  	Set a single color register. The values supplied have a 16 bit

 *  	magnitude which needs to be scaled in this function for the hardware. 

 *	Things to take into consideration are how many color registers, if

 *	any, are supported with the current color visual. With truecolor mode

 *	no color palettes are supported. Here a pseudo palette is created

 *	which we store the value in pseudo_palette in struct fb_info. For

 *	pseudocolor mode we have a limited color palette. To deal with this

 *	we can program what color is displayed for a particular pixel value.

 *	DirectColor is similar in that we can program each color field. If

 *	we have a static colormap we don't need to implement this function. 

 * 

 *	Returns negative errno on error, or zero on success.

 no. of hw registers */

    /*

     * Program hardware... do anything you want with transp

 grayscale works only partially under directcolor */

 grayscale = 0.30*R + 0.59*G + 0.11*B */

    /* Directcolor:

     *   var->{color}.offset contains start of bitfield

     *   var->{color}.length contains length of bitfield

     *   {hardwarespecific} contains width of DAC

     *   pseudo_palette[X] is programmed to (X << red.offset) |

     *                                      (X << green.offset) |

     *                                      (X << blue.offset)

     *   RAMDAC[X] is programmed to (red, green, blue)

     *   color depth = SUM(var->{color}.length)

     *

     * Pseudocolor:

     *    var->{color}.offset is 0 unless the palette index takes less than

     *                        bits_per_pixel bits and is stored in the upper

     *                        bits of the pixel value

     *    var->{color}.length is set so that 1 << length is the number of

     *                        available palette entries

     *    pseudo_palette is not used

     *    RAMDAC[X] is programmed to (red, green, blue)

     *    color depth = var->{color}.length

     *

     * Static pseudocolor:

     *    same as Pseudocolor, but the RAMDAC is not programmed (read-only)

     *

     * Mono01/Mono10:

     *    Has only 2 values, black on white or white on black (fg on bg),

     *    var->{color}.offset is 0

     *    white = (1 << var->{color}.length) - 1, black = 0

     *    pseudo_palette is not used

     *    RAMDAC does not exist

     *    color depth is always 2

     *

     * Truecolor:

     *    does not use RAMDAC (usually has 3 of them).

     *    var->{color}.offset contains start of bitfield

     *    var->{color}.length contains length of bitfield

     *    pseudo_palette is programmed to (red << red.offset) |

     *                                    (green << green.offset) |

     *                                    (blue << blue.offset) |

     *                                    (transp << transp.offset)

     *    RAMDAC does not exist

     *    color depth = SUM(var->{color}.length})

     *

     *  The color depth is used by fbcon for choosing the logo and also

     *  for color palette transformation if color depth < 4

     *

     *  As can be seen from the above, the field bits_per_pixel is _NOT_

     *  a criteria for describing the color visual.

     *

     *  A common mistake is assuming that bits_per_pixel <= 8 is pseudocolor,

     *  and higher than that, true/directcolor.  This is incorrect, one needs

     *  to look at the fix->visual.

     *

     *  Another common mistake is using bits_per_pixel to calculate the color

     *  depth.  The bits_per_pixel field does not directly translate to color

     *  depth. You have to compute for the color depth (using the color

     *  bitfields) and fix->visual as seen above.

    /*

     * This is the point where the color is converted to something that

     * is acceptable by the hardware.

    /*

     * This is the point where the function feeds the color to the hardware

     * palette after converting the colors to something acceptable by

     * the hardware. Note, only FB_VISUAL_DIRECTCOLOR and

     * FB_VISUAL_PSEUDOCOLOR visuals need to write to the hardware palette.

     * If you have code that writes to the hardware CLUT, and it's not

     * any of the above visuals, then you are doing something wrong.

    /* This is the point were you need to fill up the contents of

     * info->pseudo_palette. This structure is used _only_ by fbcon, thus

     * it only contains 16 entries to match the number of colors supported

     * by the console. The pseudo_palette is used only if the visual is

     * in directcolor or truecolor mode.  With other visuals, the

     * pseudo_palette is not used. (This might change in the future.)

     *

     * The contents of the pseudo_palette is in raw pixel format.  Ie, each

     * entry can be written directly to the framebuffer without any conversion.

     * The pseudo_palette is (void *).  However, if using the generic

     * drawing functions (cfb_imageblit, cfb_fillrect), the pseudo_palette

     * must be casted to (u32 *) _regardless_ of the bits per pixel. If the

     * driver is using its own drawing functions, then it can use whatever

     * size it wants.

 ... */

/**

 *      xxxfb_pan_display - NOT a required function. Pans the display.

 *      @var: frame buffer variable screen structure

 *      @info: frame buffer structure that represents a single frame buffer

 *

 *	Pan (or wrap, depending on the `vmode' field) the display using the

 *  	`xoffset' and `yoffset' fields of the `var' structure.

 *  	If the values don't fit, return -EINVAL.

 *

 *      Returns negative errno on error, or zero on success.

    /*

     * If your hardware does not support panning, _do_ _not_ implement this

     * function. Creating a dummy function will just confuse user apps.

    /*

     * Note that even if this function is fully functional, a setting of

     * 0 in both xpanstep and ypanstep means that this function will never

     * get called.

 ... */

/**

 *      xxxfb_blank - NOT a required function. Blanks the display.

 *      @blank_mode: the blank mode we want. 

 *      @info: frame buffer structure that represents a single frame buffer

 *

 *      Blank the screen if blank_mode != FB_BLANK_UNBLANK, else unblank.

 *      Return 0 if blanking succeeded, != 0 if un-/blanking failed due to

 *      e.g. a video mode which doesn't support it.

 *

 *      Implements VESA suspend and powerdown modes on hardware that supports

 *      disabling hsync/vsync:

 *

 *      FB_BLANK_NORMAL = display is blanked, syncs are on.

 *      FB_BLANK_HSYNC_SUSPEND = hsync off

 *      FB_BLANK_VSYNC_SUSPEND = vsync off

 *      FB_BLANK_POWERDOWN =  hsync and vsync off

 *

 *      If implementing this function, at least support FB_BLANK_UNBLANK.

 *      Return !0 for any modes that are unimplemented.

 *

 ... */

 ------------ Accelerated Functions --------------------- */

/*

 * We provide our own functions if we have hardware acceleration

 * or non packed pixel format layouts. If we have no hardware 

 * acceleration, we can use a generic unaccelerated function. If using

 * a pack pixel format just use the functions in cfb_*.c. Each file 

 * has one of the three different accel functions we support.

/**

 *      xxxfb_fillrect - REQUIRED function. Can use generic routines if 

 *		 	 non acclerated hardware and packed pixel based.

 *			 Draws a rectangle on the screen.		

 *

 *      @info: frame buffer structure that represents a single frame buffer

 *	@region: The structure representing the rectangular region we 

 *		 wish to draw to.

 *

 *	This drawing operation places/removes a retangle on the screen 

 *	depending on the rastering operation with the value of color which

 *	is in the current color depth format.

/*	Meaning of struct fb_fillrect

 *

 *	@dx: The x and y corrdinates of the upper left hand corner of the 

 *	@dy: area we want to draw to. 

 *	@width: How wide the rectangle is we want to draw.

 *	@height: How tall the rectangle is we want to draw.

 *	@color:	The color to fill in the rectangle with. 

 *	@rop: The raster operation. We can draw the rectangle with a COPY

 *	      of XOR which provides erasing effect. 

/**

 *      xxxfb_copyarea - OBSOLETE function.

 *                       Copies one area of the screen to another area.

 *                       Will be deleted in a future version

 *

 *      @info: frame buffer structure that represents a single frame buffer

 *      @area: Structure providing the data to copy the framebuffer contents

 *	       from one region to another.

 *

 *      This drawing operation copied a rectangular area from one area of the

 *	screen to another area.

/*

 *      @dx: The x and y coordinates of the upper left hand corner of the

 *	@dy: destination area on the screen.

 *      @width: How wide the rectangle is we want to copy.

 *      @height: How tall the rectangle is we want to copy.

 *      @sx: The x and y coordinates of the upper left hand corner of the

 *      @sy: source area on the screen.

/**

 *      xxxfb_imageblit - REQUIRED function. Can use generic routines if

 *                        non acclerated hardware and packed pixel based.

 *                        Copies a image from system memory to the screen. 

 *

 *      @info: frame buffer structure that represents a single frame buffer

 *	@image:	structure defining the image.

 *

 *      This drawing operation draws a image on the screen. It can be a 

 *	mono image (needed for font handling) or a color image (needed for

 *	tux). 

/*

 *      @dx: The x and y coordinates of the upper left hand corner of the

 *	@dy: destination area to place the image on the screen.

 *      @width: How wide the image is we want to copy.

 *      @height: How tall the image is we want to copy.

 *      @fg_color: For mono bitmap images this is color data for     

 *      @bg_color: the foreground and background of the image to

 *		   write directly to the frmaebuffer.

 *	@depth:	How many bits represent a single pixel for this image.

 *	@data: The actual data used to construct the image on the display.

 *	@cmap: The colormap used for color images.   

/*

 * The generic function, cfb_imageblit, expects that the bitmap scanlines are

 * padded to the next byte.  Most hardware accelerators may require padding to

 * the next u16 or the next u32.  If that is the case, the driver can specify

 * this by setting info->pixmap.scan_align = 2 or 4.  See a more

 * comprehensive description of the pixmap below.

/**

 *	xxxfb_cursor - 	OPTIONAL. If your hardware lacks support

 *			for a cursor, leave this field NULL.

 *

 *      @info: frame buffer structure that represents a single frame buffer

 *	@cursor: structure defining the cursor to draw.

 *

 *      This operation is used to set or alter the properities of the

 *	cursor.

 *

 *	Returns negative errno on error, or zero on success.

/*

 *      @set: 	Which fields we are altering in struct fb_cursor 

 *	@enable: Disable or enable the cursor 

 *      @rop: 	The bit operation we want to do. 

 *      @mask:  This is the cursor mask bitmap. 

 *      @dest:  A image of the area we are going to display the cursor.

 *		Used internally by the driver.	 

 *      @hot:	The hot spot. 

 *	@image:	The actual data for the cursor image.

 *

 *      NOTES ON FLAGS (cursor->set):

 *

 *      FB_CUR_SETIMAGE - the cursor image has changed (cursor->image.data)

 *      FB_CUR_SETPOS   - the cursor position has changed (cursor->image.dx|dy)

 *      FB_CUR_SETHOT   - the cursor hot spot has changed (cursor->hot.dx|dy)

 *      FB_CUR_SETCMAP  - the cursor colors has changed (cursor->fg_color|bg_color)

 *      FB_CUR_SETSHAPE - the cursor bitmask has changed (cursor->mask)

 *      FB_CUR_SETSIZE  - the cursor size has changed (cursor->width|height)

 *      FB_CUR_SETALL   - everything has changed

 *

 *      NOTES ON ROPs (cursor->rop, Raster Operation)

 *

 *      ROP_XOR         - cursor->image.data XOR cursor->mask

 *      ROP_COPY        - curosr->image.data AND cursor->mask

 *

 *      OTHER NOTES:

 *

 *      - fbcon only supports a 2-color cursor (cursor->image.depth = 1)

 *      - The fb_cursor structure, @cursor, _will_ always contain valid

 *        fields, whether any particular bitfields in cursor->set is set

 *        or not.

/**

 *	xxxfb_sync - NOT a required function. Normally the accel engine 

 *		     for a graphics card take a specific amount of time.

 *		     Often we have to wait for the accelerator to finish

 *		     its operation before we can write to the framebuffer

 *		     so we can have consistent display output. 

 *

 *      @info: frame buffer structure that represents a single frame buffer

 *

 *      If the driver has implemented its own hardware-based drawing function,

 *      implementing this function is highly recommended.

    /*

     *  Frame buffer operations

 Needed !!!   */

 Obsolete     */

 Needed !!!   */

 Optional !!! */

 ------------------------------------------------------------------------- */

    /*

     *  Initialization

 static int __init xxfb_probe (struct platform_device *pdev) -- for platform devs */

 or &pdev->dev */

    /*

     * Dynamically allocate info and par

 goto error path */

    /* 

     * Here we set the screen_base to the virtual memory address

     * for the framebuffer. Usually we obtain the resource address

     * from the bus layer and then translate it to virtual memory

     * space via ioremap. Consult ioport.h. 

    info->pseudo_palette = pseudo_palette; /* The pseudopalette is an

					    * 16-member array

    /*

     * Set up flags to indicate what sort of acceleration your

     * driver can provide (pan/wrap/copyarea/etc.) and whether it

     * is a module -- see FBINFO_* in include/linux/fb.h

     *

     * If your hardware can support any of the hardware accelerated functions

     * fbcon performance will improve if info->flags is set properly.

     *

     * FBINFO_HWACCEL_COPYAREA - hardware moves

     * FBINFO_HWACCEL_FILLRECT - hardware fills

     * FBINFO_HWACCEL_IMAGEBLIT - hardware mono->color expansion

     * FBINFO_HWACCEL_YPAN - hardware can pan display in y-axis

     * FBINFO_HWACCEL_YWRAP - hardware can wrap display in y-axis

     * FBINFO_HWACCEL_DISABLED - supports hardware accels, but disabled

     * FBINFO_READS_FAST - if set, prefer moves over mono->color expansion

     * FBINFO_MISC_TILEBLITTING - hardware can do tile blits

     *

     * NOTE: These are for fbcon use only.

******************** This stage is optional ******************************/

     /*

     * The struct pixmap is a scratch pad for the drawing functions. This

     * is where the monochrome bitmap is constructed by the higher layers

     * and then passed to the accelerator.  For drivers that uses

     * cfb_imageblit, you can skip this part.  For those that have a more

     * rigorous requirement, this stage is needed

    /* PIXMAP_SIZE should be small enough to optimize drawing, but not

     * large enough that memory is wasted.  A safe size is

     * (max_xres * max_font_height/8). max_xres is driver dependent,

     * max_font_height is 32.

 goto error */

    /*

     * FB_PIXMAP_SYSTEM - memory is in system ram

     * FB_PIXMAP_IO     - memory is iomapped

     * FB_PIXMAP_SYNC   - if set, will call fb_sync() per access to pixmap,

     *                    usually if FB_PIXMAP_IO is set.

     *

     * Currently, FB_PIXMAP_IO is unimplemented.

    /*

     * scan_align is the number of padding for each scanline.  It is in bytes.

     * Thus for accelerators that need padding to the next u32, put 4 here.

    /*

     * buf_align is the amount to be padded for the buffer. For example,

     * the i810fb needs a scan_align of 2 but expects it to be fed with

     * dwords, so a buf_align = 4 is required.

    /* access_align is how many bits can be accessed from the framebuffer

     * ie. some epson cards allow 16-bit access only.  Most drivers will

     * be safe with u32 here.

     *

     * NOTE: This field is currently unused.

**************************** End optional stage ***************************/

    /*

     * This should give a reasonable default video mode. The following is

     * done when we can set a video mode. 

 This has to be done! */

    /* 

     * The following is done in the case of having hardware with a static 

     * mode. If we are setting the mode ourselves we don't call this. 

    /*

     * For drivers that can...

    /*

     * Does a call to fb_set_par() before register_framebuffer needed?  This

     * will depend on you and the hardware.  If you are sure that your driver

     * is the only device in the system, a call to fb_set_par() is safe.

     *

     * Hardware in x86 systems has a VGA core.  Calling set_par() at this

     * point will corrupt the VGA console, so it might be safer to skip a

     * call to set_par here and just allow fbcon to do it for you.

 xxxfb_set_par(info); */

 or platform_set_drvdata(pdev, info) */

    /*

     *  Cleanup

 static void xxxfb_remove(struct platform_device *pdev) */

 or platform_get_drvdata(pdev); */

 ... */

/**

 *	xxxfb_suspend - Optional but recommended function. Suspend the device.

 *	@dev: PCI device

 *	@msg: the suspend event code.

 *

 *      See Documentation/driver-api/pm/devices.rst for more information

 suspend here */

/**

 *	xxxfb_resume - Optional but recommended function. Resume the device.

 *	@dev: PCI device

 *

 *      See Documentation/driver-api/pm/devices.rst for more information

 resume here */

 CONFIG_PM */

 For PCI drivers */

 optional but recommended */

 optional but recommended */

	/*

	 *  For kernel boot options (in 'video=xxxfb:<options>' format)

 non PCI, platform drivers */

 for platform devices */

/**

 *	xxxfb_suspend - Optional but recommended function. Suspend the device.

 *	@dev: platform device

 *	@msg: the suspend event code.

 *

 *      See Documentation/driver-api/pm/devices.rst for more information

 suspend here */

/**

 *	xxxfb_resume - Optional but recommended function. Resume the device.

 *	@dev: platform device

 *

 *      See Documentation/driver-api/pm/devices.rst for more information

 resume here */

 CONFIG_PM */

 optional but recommended */

 optional but recommended */

    /*

     *  Setup

/*

 * Only necessary if your driver takes special options,

 * otherwise we fall back on the generic fb_setup().

 Parse user specified options (`video=xxxfb:') */

 MODULE */

	/*

	 *  For kernel boot options (in 'video=xxxfb:<options>' format)

 CONFIG_PCI */

 ------------------------------------------------------------------------- */

    /*

     *  Modularization

/*

 * linux/drivers/video/hgafb.c -- Hercules graphics adaptor frame buffer device

 * 

 *      Created 25 Nov 1999 by Ferenc Bakonyi (fero@drama.obuda.kando.hu)

 *      Based on skeletonfb.c by Geert Uytterhoeven and

 *               mdacon.c by Andrew Apted

 *

 * History:

 *

 * - Revision 0.1.8 (23 Oct 2002): Ported to new framebuffer api.

 * 

 * - Revision 0.1.7 (23 Jan 2001): fix crash resulting from MDA only cards 

 *				   being detected as Hercules.	 (Paul G.)

 * - Revision 0.1.6 (17 Aug 2000): new style structs

 *                                 documentation

 * - Revision 0.1.5 (13 Mar 2000): spinlocks instead of saveflags();cli();etc

 *                                 minor fixes

 * - Revision 0.1.4 (24 Jan 2000): fixed a bug in hga_card_detect() for 

 *                                  HGA-only systems

 * - Revision 0.1.3 (22 Jan 2000): modified for the new fb_info structure

 *                                 screen is cleared after rmmod

 *                                 virtual resolutions

 *                                 module parameter 'nologo={0|1}'

 *                                 the most important: boot logo :)

 * - Revision 0.1.0  (6 Dec 1999): faster scrolling and minor fixes

 * - First release  (25 Nov 1999)

 *

 * This file is subject to the terms and conditions of the GNU General Public

 * License.  See the file COPYING in the main directory of this archive

 * for more details.

 Description of the hardware layout */

 Base of video memory */

 Size of video memory */

 0 = txt, 1 = gfx mode */

 Register select port */

 Register value port */

 Mode control port */

 Status and Config port */

 Graphics control port */

 HGA register values */

 Global locks */

 Framebuffer driver structures */

 (not sure) */

 Don't assume that tty1 will be the initial current console. */

/* -------------------------------------------------------------------------

 *

 * Low level hardware functions

 *

 magic */

 horizontal total */

 horizontal displayed */

 horizontal sync pos */

 horizontal sync width */

 vertical total */

 vertical total adjust */

 vertical displayed */

 vertical sync pos */

 interlace mode */

 maximum scanline */

 cursor start */

 cursor end */

 start address */

 cursor location */

 horizontal total */

 horizontal displayed */

 horizontal sync pos */

 horizontal sync width */

 vertical total */

 vertical total adjust */

 vertical displayed */

 vertical sync pos */

 interlace mode */

 maximum scanline */

 cursor start */

 cursor end */

 start address */

 cursor location */

/*

	void __iomem *dest = hga_vram;

	char *logo = linux_logo_bw;

	int x, y;

	

	for (y = 134; y < 134 + 80 ; y++) * this needs some cleanup *

		for (x = 0; x < 10 ; x++)

			writeb(~*(logo++),(dest + HGA_ROWADDR(y) + x + 40));

 start address */

 disable video */

 do a memory check */

	/* Ok, there is definitely a card registering at the correct

	 * memory location, so now we do an I/O port test.

 cursor low register */

 cursor low register */

	/* See if the card is a Hercules, by checking whether the vsync

	 * bit of the status register is changing.  This test lasts for

	 * approximately 1/10th of a second.

/**

 *	hgafb_open - open the framebuffer device

 *	@info: pointer to fb_info object containing info for current hga board

 *	@init: open by console system or userland.

/**

 *	hgafb_release - open the framebuffer device

 *	@info: pointer to fb_info object containing info for current hga board

 *	@init: open by console system or userland.

/**

 *	hgafb_setcolreg - set color registers

 *	@regno:register index to set

 *	@red:red value, unused

 *	@green:green value, unused

 *	@blue:blue value, unused

 *	@transp:transparency value, unused

 *	@info:unused

 *

 *	This callback function is used to set the color registers of a HGA

 *	board. Since we have only two fixed colors only @regno is checked.

 *	A zero is returned on success and 1 for failure.

/**

 *	hga_pan_display - pan or wrap the display

 *	@var:contains new xoffset, yoffset and vmode values

 *	@info:pointer to fb_info object containing info for current hga board

 *

 *	This function looks only at xoffset, yoffset and the %FB_VMODE_YWRAP

 *	flag in @var. If input parameters are correct it calls hga_pan() to 

 *	program the hardware. @info->var is updated to the new values.

 *	A zero is returned on success and %-EINVAL for failure.

/**

 *	hgafb_blank - (un)blank the screen

 *	@blank_mode:blanking method to use

 *	@info:unused

 *	

 *	Blank the screen if blank_mode != 0, else unblank. 

 *	Implements VESA suspend and powerdown modes on hardware that supports 

 *	disabling hsync/vsync:

 *		@blank_mode == 2 means suspend vsync,

 *		@blank_mode == 3 means suspend hsync,

 *		@blank_mode == 4 means powerdown.

/*

 * Accel functions

/* ------------------------------------------------------------------------- *

 *

 * Functions in fb_info

 * 

 ------------------------------------------------------------------------- */

	/*

	 *  Initialization

/* -------------------------------------------------------------------------

 *

 *  Modularization

 *

 SPDX-License-Identifier: GPL-2.0

/*

 * Framebuffer driver for EFI/UEFI based system

 *

 * (c) 2006 Edgar Hucek <gimli@dark-green.com>

 * Original efi driver written by Gerd Knorr <kraxel@goldbach.in-berlin.de>

 *

 For drm_get_panel_orientation_quirk */

 For DRM_MODE_PANEL_ORIENTATION_* */

 dev with BAR covering the efifb */

	/*

	 *  Set a single color register. The values supplied are

	 *  already rounded down to the hardware's capabilities

	 *  (according to the entries in the `var' structure). Return

	 *  != 0 for invalid regno.

/*

 * If fbcon deffered console takeover is configured, the intent is for the

 * framebuffer to show the boot graphics (e.g. vendor logo) until there is some

 * (error) message to display. But the boot graphics may have been destroyed by

 * e.g. option ROM output, detect this and restore the boot graphics.

/*

 * On x86 some firmwares use a low non native resolution for the display when

 * they have shown some text messages. While keeping the bgrt filled with info

 * for the native resolution. If the bgrt image intended for the native

 * resolution still fits, it will be displayed very close to the right edge of

 * the display looking quite bad. This function checks for this.

	/*

	 * All x86 firmwares horizontally center the image (the yoffset

	 * calculations differ between boards, but xoffset is predictable).

 Avoid flashing the logo if we're going to print std probe messages */

 bgrt_tab.status is unreliable, so we don't check it */

 Only background? */

 Positive header height means upside down row order */

 FB base matches BAR of a disabled device */

	/*

	 * Generic drivers must not be registered if a framebuffer exists.

	 * If a native driver was probed, the display hardware was already

	 * taken and attempting to use the system framebuffer is dangerous.

	/* We don't get linelength from UGA Draw Protocol, only from

	 * EFI Graphics Protocol.  So if it's not in DMI, and it's not

	 * passed in from the user, we really can't use the framebuffer.

 just assume they're all unset if any are */

	/*   size_vmode -- that is the amount of memory needed for the

	 *                 used video mode, i.e. the minimum amount of

	/*   size_total -- all video memory we have. Used for

	 *                 entries, ressource allocation and bounds

	/*   size_remap -- the amount of video memory we are going to

	 *                 use for efifb.  With modern cards it is no

	 *                 option to simply use size_total as that

		/* We cannot make this fatal. Sometimes this comes from magic

		/*

		 * If the UEFI memory map covers the efifb region, we may only

		 * remap it using the attributes the memory map prescribes.

 some dummy values for timing to make fbset happy */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  linux/drivers/video/vt8500lcdfb.c

 *

 *  Copyright (C) 2010 Alexey Charkov <alchark@gmail.com>

 *

 * Based on skeletonfb.c and pxafb.c

 16bpp */

 palettized */

 non-palettized */

 RGB565 */

 Equal depths per channel */

 wait */;

 Unmask End of Frame interrupt */

 Mask back to reduce unwanted interrupt traffic */

/*

 * vt8500lcd_blank():

 *	Blank the display by setting all palette values to zero.  Note,

 * 	True Color modes do not really use the palette, so this will not

 *      blank the display in all modes.

 try allocating the framebuffer */

	/*

	 * Ok, now enable the LCD controller

/*

 *  Fast C2P (Chunky-to-Planar) Conversion

 *

 *  Copyright (C) 2003-2008 Geert Uytterhoeven

 *

 *  This file is subject to the terms and conditions of the GNU General Public

 *  License. See the file COPYING in the main directory of this archive

 *  for more details.

    /*

     *  Perform a full C2P step on 16 8-bit pixels, stored in 4 32-bit words

     *  containing

     *    - 16 8-bit chunky pixels on input

     *    - permutated planar data (2 planes per 32-bit word) on output

    /*

     *  Array containing the permutation indices of the planar data after c2p

    /*

     *  Store a full block of iplan2 data after c2p conversion

    /*

     *  Store a partial block of iplan2 data after c2p conversion

    /*

     *  c2p_iplan2 - Copy 8-bit chunky image data to an interleaved planar

     *  frame buffer with 2 bytes of interleave

     *  @dst: Starting address of the planar frame buffer

     *  @dx: Horizontal destination offset (in pixels)

     *  @dy: Vertical destination offset (in pixels)

     *  @width: Image width (in pixels)

     *  @height: Image height (in pixels)

     *  @dst_nextline: Frame buffer offset to the next line (in bytes)

     *  @src_nextline: Image offset to the next line (in bytes)

     *  @bpp: Bits per pixel of the planar frame buffer (2, 4, or 8)

 Single destination word */

 Multiple destination words */

 Leading bits */

 Main chunk */

 Trailing bits */

/*

 * SuperH Mobile LCDC Framebuffer

 *

 * Copyright (c) 2008 Magnus Damm

 *

 * This file is subject to the terms and conditions of the GNU General Public

 * License.  See the file "COPYING" in the main directory of this archive

 * for more details.

/* ----------------------------------------------------------------------------

 * Overlay register definitions

/*

 * struct sh_mobile_lcdc_overlay - LCDC display overlay

 *

 * @channel: LCDC channel this overlay belongs to

 * @cfg: Overlay configuration

 * @info: Frame buffer device

 * @index: Overlay index (0-3)

 * @base: Overlay registers base address

 * @enabled: True if the overlay is enabled

 * @mode: Overlay blending mode (alpha blend or ROP3)

 * @alpha: Global alpha blending value (0-255, for alpha blending mode)

 * @rop3: Raster operation (for ROP3 mode)

 * @fb_mem: Frame buffer virtual memory address

 * @fb_size: Frame buffer size in bytes

 * @dma_handle: Frame buffer DMA address

 * @base_addr_y: Overlay base address (RGB or luma component)

 * @base_addr_c: Overlay base address (chroma component)

 * @pan_y_offset: Panning linear offset in bytes (luma component)

 * @format: Current pixelf format

 * @xres: Horizontal visible resolution

 * @xres_virtual: Horizontal total resolution

 * @yres: Vertical visible resolution

 * @yres_virtual: Vertical total resolution

 * @pitch: Overlay line pitch

 * @pos_x: Horizontal overlay position

 * @pos_y: Vertical overlay position

 2 channel LCDC must share fourcc setting */

/* -----------------------------------------------------------------------------

 * Registers access

/* -----------------------------------------------------------------------------

 * Clock management

/* -----------------------------------------------------------------------------

 * Display, panel and deferred I/O

 enable clocks before accessing hardware */

	/*

	 * It's possible to get here without anything on the pagelist via

	 * sh_mobile_lcdc_deferred_io_touch() or via a userspace fsync()

	 * invocation. In the former case, the acceleration routines are

	 * stepped in to when using the framebuffer console causing the

	 * workqueue to be scheduled without any dirty pages on the list.

	 *

	 * Despite this, a panel update is still needed given that the

	 * acceleration routines have their own methods for writing in

	 * that still need to be updated.

	 *

	 * The fsync() and empty pagelist case could be optimized for,

	 * but we don't bother, as any application exhibiting such

	 * behaviour is fundamentally broken anyways.

 trigger panel update */

 HDMI must be enabled before LCDC configuration */

/* -----------------------------------------------------------------------------

 * Format helpers

/* -----------------------------------------------------------------------------

 * Start, stop and IRQ

 Acknowledge interrupts and disable further VSYNC End IRQs. */

 figure out if this interrupt is for main or sub lcd */

 wake up channel and disable clocks */

 Frame End */

 VSYNC End */

	/* Enable VSync End interrupt and be careful not to acknowledge any

	 * pending interrupt.

 start or stop the lcdc */

 wait until power is applied/stopped on all channels */

 stop dotclock */

 setup SYS bus */

 horizontal configuration */

 HTCN */

 HDCN */

 HSYNP */

 HSYNW */

 vertical configuration */

 VTLN */

 VDLN */

 VSYNP */

 VSYNW */

 Adjust horizontal synchronisation for HDMI */

/*

 * __sh_mobile_lcdc_start - Configure and start the LCDC

 * @priv: LCDC device

 *

 * Configure all enabled channels and start the LCDC device. All external

 * devices (clocks, MERAM, panels, ...) are not touched by this function.

	/* Enable LCDC channels. Read data from external memory, avoid using the

	 * BEU for now.

 Stop the LCDC first and disable all interrupts. */

 Configure power supply, dot clocks and start them. */

 Power supply */

		/* FIXME: sh7724 can only use 42, 48, 54 and 60 for the divider

		 * denominator.

 Setup geometry, format, frame buffer memory and operation mode. */

		/* When using deferred I/O mode, configure the LCDC for one-shot

		 * operation and enable the frame end interrupt. Otherwise use

		 * continuous read mode.

 Word and long word swap. */

 Enable the display output. */

 enable clocks before accessing the hardware */

 reset */

 Compute frame buffer base address and pitch for each channel. */

 Start the LCDC. */

	/* Setup deferred I/O, tell the board code to enable the panels, and

	 * turn backlight on.

 clean up deferred io and ask board code to disable panel */

		/* deferred io mode:

		 * flush frame, and wait for frame end interrupt

		 * clean up deferred io and enable clock

 stop the lcdc */

 stop clocks */

	/* Make sure the virtual resolution is at least as big as the visible

	 * resolution.

		/* Default to RGB and JPEG color-spaces for RGB and YUV formats

		 * respectively.

 RGB 565 */

 RGB 888 */

 RGBA 888 */

 Make sure we don't exceed our allocated memory. */

/* -----------------------------------------------------------------------------

 * Frame buffer operations - Overlays

	/* If the Y offset hasn't changed, the C offset hasn't either. There's

	 * nothing to do in that case.

 Set the source address for the next refresh */

 Overlay blanking. Disable the overlay when blanked. */

	/* Prevent the backlight from receiving a blanking event by returning

	 * a non-zero value.

 Allocate and initialize the frame buffer device. */

	/* Initialize fixed screen information. Restrict pan to 2 lines steps

	 * for NV12 and NV21.

 Initialize variable screen information. */

	/* Use the legacy API by default for RGB formats, and the FOURCC API

	 * for YUV formats.

/* -----------------------------------------------------------------------------

 * Frame buffer operations - main frame buffer

 only FB_VISUAL_TRUECOLOR supported */

	/* If the Y offset hasn't changed, the C offset hasn't either. There's

	 * nothing to do in that case.

 Set the source address for the next refresh */

 More framebuffer users are active */

 Display has been re-plugged, framebuffer is free now, reconfigure */

 Couldn't reconfigure, hopefully, can continue as before */

/*

 * Locking: both .fb_release() and .fb_open() are called with info->lock held if

 * user == 1, or with console sem held, if user == 0.

 Nothing to reconfigure, when called from fbcon */

	/* If board code provides us with a list of available modes, make sure

	 * we use one of them. Find the mode closest to the requested one. The

	 * distance between two modes is defined as the size of the

	 * non-overlapping parts of the two rectangles.

 We can only round up. */

 If no available mode can be used, return an error. */

 only accept the forced_fourcc for dual channel configurations */

/*

 * Screen blanking. Behavior is as follows:

 * FB_BLANK_UNBLANK: screen unblanked, clocks enabled

 * FB_BLANK_NORMAL: screen blanked, clocks enabled

 * FB_BLANK_VSYNC,

 * FB_BLANK_HSYNC,

 * FB_BLANK_POWEROFF: screen blanked, clocks disabled

 blank the screen? */

 turn clocks on? */

 turn clocks off? */

		/* make sure the screen is updated with the black fill before

		 * switching the clocks off. one vsync is not enough since

		 * blanking may occur in the middle of a refresh. deferred io

		 * mode will reenable the clocks and update the screen in time,

 deferred io mode: disable clock to save power */

	/* Allocate and initialize the frame buffer device. Create the modes

	 * list and allocate the color map.

	/* Initialize fixed screen information. Restrict pan to 2 lines steps

	 * for NV12 and NV21.

	/* Initialize variable screen information using the first mode as

	 * default.

	/* Use the legacy API by default for RGB formats, and the FOURCC API

	 * for YUV formats.

/* -----------------------------------------------------------------------------

 * Backlight

/* -----------------------------------------------------------------------------

 * Power management

 turn off LCDC hardware */

/* -----------------------------------------------------------------------------

 * Framebuffer notifier

/* -----------------------------------------------------------------------------

 * Probe/remove and driver init/exit

 SUBLCD only supports SYS interface */

 Validate the format. */

	/* The default Y virtual resolution is twice the panel size to allow for

	 * double-buffering.

 Allocate frame buffer memory. */

 Validate the format. */

	/* Iterate through the modes to validate them and find the highest

	 * resolution.

 NV12/NV21 buffers must have even number of lines */

	/* Use the first mode as default. The default Y virtual resolution is

	 * twice the panel size to allow for double-buffering.

 Allocate frame buffer memory. */

 Initialize the transmitter device if present. */

 probe the backlight is there is one defined */

 for dual channel LCDC (MAIN + SUB) force shared format setting */

 Enable runtime PM. */

/*

 *  linux/drivers/video/sa1100fb.c

 *

 *  Copyright (C) 1999 Eric A. Thomas

 *   Based on acornfb.c Copyright (C) Russell King.

 *

 * This file is subject to the terms and conditions of the GNU General Public

 * License.  See the file COPYING in the main directory of this archive for

 * more details.

 *

 *	        StrongARM 1100 LCD Controller Frame Buffer Driver

 *

 * Please direct your questions and comments on this driver to the following

 * email address:

 *

 *	linux-arm-kernel@lists.arm.linux.org.uk

 *

 * Clean patches should be sent to the ARM Linux Patch System.  Please see the

 * following web page for more information:

 *

 *	https://www.arm.linux.org.uk/developer/patches/info.shtml

 *

 * Thank you.

 *

 * Known problems:

 *	- With the Neponset plugged into an Assabet, LCD powerdown

 *	  doesn't work (LCD stays powered up).  Therefore we shouldn't

 *	  blank the screen.

 *	- We don't limit the CPU clock rate nor the mode selection

 *	  according to the available SDRAM bandwidth.

 *

 * Other notes:

 *	- Linear grayscale palettes and the kernel.

 *	  Such code does not belong in the kernel.  The kernel frame buffer

 *	  drivers do not expect a linear colourmap, but a colourmap based on

 *	  the VT100 standard mapping.

 *

 *	  If your _userspace_ requires a linear colourmap, then the setup of

 *	  such a colourmap belongs _in userspace_, not in the kernel.  Code

 *	  to set the colourmap correctly from user space has been sent to

 *	  David Neuer.  It's around 8 lines of C code, plus another 4 to

 *	  detect if we are using grayscale.

 *

 *	- The following must never be specified in a panel definition:

 *	     LCCR0_LtlEnd, LCCR3_PixClkDiv, LCCR3_VrtSnchL, LCCR3_HorSnchL

 *

 *	- The following should be specified:

 *	     either LCCR0_Color or LCCR0_Mono

 *	     either LCCR0_Sngl or LCCR0_Dual

 *	     either LCCR0_Act or LCCR0_Pas

 *	     either LCCR3_OutEnH or LCCD3_OutEnL

 *	     either LCCR3_PixRsEdg or LCCR3_PixFlEdg

 *	     either LCCR3_ACBsDiv or LCCR3_ACBsCntOff

 *

 * Code Status:

 * 1999/04/01:

 *	- Driver appears to be working for Brutus 320x200x8bpp mode.  Other

 *	  resolutions are working, but only the 8bpp mode is supported.

 *	  Changes need to be made to the palette encode and decode routines

 *	  to support 4 and 16 bpp modes.  

 *	  Driver is not designed to be a module.  The FrameBuffer is statically

 *	  allocated since dynamic allocation of a 300k buffer cannot be 

 *	  guaranteed. 

 *

 * 1999/06/17:

 *	- FrameBuffer memory is now allocated at run-time when the

 *	  driver is initialized.    

 *

 * 2000/04/10: Nicolas Pitre <nico@fluxnic.net>

 *	- Big cleanup for dynamic selection of machine type at run time.

 *

 * 2000/07/19: Jamey Hicks <jamey@crl.dec.com>

 *	- Support for Bitsy aka Compaq iPAQ H3600 added.

 *

 * 2000/08/07: Tak-Shing Chan <tchan.rd@idthk.com>

 *	       Jeff Sutherland <jsutherland@accelent.com>

 *	- Resolved an issue caused by a change made to the Assabet's PLD 

 *	  earlier this year which broke the framebuffer driver for newer 

 *	  Phase 4 Assabets.  Some other parameters were changed to optimize

 *	  for the Sharp display.

 *

 * 2000/08/09: Kunihiko IMAI <imai@vasara.co.jp>

 *	- XP860 support added

 *

 * 2000/08/19: Mark Huang <mhuang@livetoy.com>

 *	- Allows standard options to be passed on the kernel command line

 *	  for most common passive displays.

 *

 * 2000/08/29:

 *	- s/save_flags_cli/local_irq_save/

 *	- remove unneeded extra save_flags_cli in sa1100fb_enable_lcd_controller

 *

 * 2000/10/10: Erik Mouw <J.A.K.Mouw@its.tudelft.nl>

 *	- Updated LART stuff. Fixed some minor bugs.

 *

 * 2000/10/30: Murphy Chen <murphy@mail.dialogue.com.tw>

 *	- Pangolin support added

 *

 * 2000/10/31: Roman Jordan <jor@hoeft-wessel.de>

 *	- Huw Webpanel support added

 *

 * 2000/11/23: Eric Peng <ericpeng@coventive.com>

 *	- Freebird add

 *

 * 2001/02/07: Jamey Hicks <jamey.hicks@compaq.com> 

 *	       Cliff Brake <cbrake@accelent.com>

 *	- Added PM callback

 *

 * 2001/05/26: <rmk@arm.linux.org.uk>

 *	- Fix 16bpp so that (a) we use the right colours rather than some

 *	  totally random colour depending on what was in page 0, and (b)

 *	  we don't de-reference a NULL pointer.

 *	- remove duplicated implementation of consistent_alloc()

 *	- convert dma address types to dma_addr_t

 *	- remove unused 'montype' stuff

 *	- remove redundant zero inits of init_var after the initial

 *	  memset.

 *	- remove allow_modeset (acornfb idea does not belong here)

 *

 * 2001/05/28: <rmk@arm.linux.org.uk>

 *	- massive cleanup - move machine dependent data into structures

 *	- I've left various #warnings in - if you see one, and know

 *	  the hardware concerned, please get in contact with me.

 *

 * 2001/05/31: <rmk@arm.linux.org.uk>

 *	- Fix LCCR1 HSW value, fix all machine type specifications to

 *	  keep values in line.  (Please check your machine type specs)

 *

 * 2001/06/10: <rmk@arm.linux.org.uk>

 *	- Fiddle with the LCD controller from task context only; mainly

 *	  so that we can run with interrupts on, and sleep.

 *	- Convert #warnings into #errors.  No pain, no gain. ;)

 *

 * 2001/06/14: <rmk@arm.linux.org.uk>

 *	- Make the palette BPS value for 12bpp come out correctly.

 *	- Take notice of "greyscale" on any colour depth.

 *	- Make truecolor visuals use the RGB channel encoding information.

 *

 * 2001/07/02: <rmk@arm.linux.org.uk>

 *	- Fix colourmap problems.

 *

 * 2001/07/13: <abraham@2d3d.co.za>

 *	- Added support for the ICP LCD-Kit01 on LART. This LCD is

 *	  manufactured by Prime View, model no V16C6448AB

 *

 * 2001/07/23: <rmk@arm.linux.org.uk>

 *	- Hand merge version from handhelds.org CVS tree.  See patch

 *	  notes for 595/1 for more information.

 *	- Drop 12bpp (it's 16bpp with different colour register mappings).

 *	- This hardware can not do direct colour.  Therefore we don't

 *	  support it.

 *

 * 2001/07/27: <rmk@arm.linux.org.uk>

 *	- Halve YRES on dual scan LCDs.

 *

 * 2001/08/22: <rmk@arm.linux.org.uk>

 *	- Add b/w iPAQ pixclock value.

 *

 * 2001/10/12: <rmk@arm.linux.org.uk>

 *	- Add patch 681/1 and clean up stork definitions.

/*

 * Complain if VAR is out of range.

	/*

	 * We need to handle two requests being made at the same time.

	 * There are two important cases:

	 *  1. When we are changing VT (C_REENABLE) while unblanking (C_ENABLE)

	 *     We must perform the unblanking, which will do our REENABLE for us.

	 *  2. When we are blanking, but immediately unblank before we have

	 *     blanked.  We do the "REENABLE" thing here as well, just to be sure.

/*

 * Convert bits-per-pixel to a hardware palette PBS value.

	/*

	 * If inverse mode was selected, invert all the colours

	 * rather than the register number.  The register number

	 * is what you poke into the framebuffer to produce the

	 * colour you requested.

	/*

	 * If greyscale is true, then we convert the RGB value

	 * to greyscale no mater what visual we are using.

		/*

		 * 12 or 16-bit True Colour.  We encode the RGB value

		 * according to the RGB bitfield information.

/*

 *  sa1100fb_display_dma_period()

 *    Calculate the minimum period (in picoseconds) between two DMA

 *    requests for the LCD controller.  If we hit this, it means we're

 *    doing nothing but LCD DMA.

	/*

	 * Period = pixclock * bits_per_byte * bytes_per_transfer

	 *		/ memory_bits_per_pixel;

/*

 *  sa1100fb_check_var():

 *    Round up in the following order: bits_per_pixel, xres,

 *    yres, xres_virtual, yres_virtual, xoffset, yoffset, grayscale,

 *    bitfields, horizontal timing, vertical timing.

	/*

	 * Copy the RGB parameters for this display

	 * from the machine specific parameters.

/*

 * sa1100fb_set_par():

 *	Set the user defined part of the display for the specified console

		/*

		 * Some people have weird ideas about wanting static

		 * pseudocolor maps.  I suspect their user space

		 * applications are broken.

	/*

	 * Set (any) board control register to handle new color depth

	/*

	 * Make sure the user isn't doing something stupid.

/*

 * Formal definition of the VESA spec:

 *  On

 *  	This refers to the state of the display when it is in full operation

 *  Stand-By

 *  	This defines an optional operating state of minimal power reduction with

 *  	the shortest recovery time

 *  Suspend

 *  	This refers to a level of power management in which substantial power

 *  	reduction is achieved by the display.  The display can have a longer 

 *  	recovery time from this state than from the Stand-by state

 *  Off

 *  	This indicates that the display is consuming the lowest level of power

 *  	and is non-operational. Recovery from this state may optionally require

 *  	the user to manually power on the monitor

 *

 *  Now, the fbdev driver adds an additional state, (blank), where they

 *  turn off the video (maybe by colormap tricks), but don't mess with the

 *  video itself: think of it semantically between on and Stand-By.

 *

 *  So here's what we should do in our fbdev blank routine:

 *

 *  	VESA_NO_BLANKING (mode 0)	Video on,  front/back light on

 *  	VESA_VSYNC_SUSPEND (mode 1)  	Video on,  front/back light off

 *  	VESA_HSYNC_SUSPEND (mode 2)  	Video on,  front/back light off

 *  	VESA_POWERDOWN (mode 3)		Video off, front/back light off

 *

 *  This will match the matrox implementation.

/*

 * sa1100fb_blank():

 *	Blank the display by setting all palette values to zero.  Note, the 

 * 	12 and 16 bpp modes don't really use the palette, so this will not

 *      blank the display in all modes.  

 skip over the palette */

	.fb_set_cmap	= sa1100fb_set_cmap,

/*

 * Calculate the PCD value from the clock rate (in picoseconds).

 * We take account of the PPCR clock setting.

 make up for integer math truncations */

/*

 * sa1100fb_activate_var():

 *	Configures LCD Controller based on entries in var parameter.  Settings are      

 *	only written to the controller if changes were made.  

	/*

	 * If we have a dual scan LCD, then we need to halve

	 * the YRES parameter.

 Update shadow copy atomically */

	/*

	 * Only update the registers if the controller is enabled

	 * and something has changed.

/*

 * NOTE!  The following functions are purely helpers for set_ctrlr_state.

 * Do not call them directly; set_ctrlr_state does the correct serialisation

 * to ensure that things happen in the right way 100% of time time.

 *	-- rmk

	/*

	 * Enable GPIO<9:2> for LCD use if:

	 *  1. Active display, or

	 *  2. Color Dual Passive display

	 *

	 * see table 11.8 on page 11-27 in the SA1100 manual

	 *   -- Erik.

	 *

	 * SA1110 spec update nr. 25 says we can and should

	 * clear LDD15 to 12 for 4 or 8bpp modes with active

	 * panels.  

		/*

		 * SA-1100 requires the GPIO direction register set

		 * appropriately for the alternate function.  Hence

		 * we set it here via bitmask rather than excessive

		 * fiddling via the GPIO subsystem - and even then

		 * we'll still have to deal with GAFR.

	/*

	 * Make sure the mode bits are present in the first palette entry

 enable LCD controller clock */

 Sequence from 11.7.10 */

 Clear LCD Status Register */

 Enable LCD Disable Done Interrupt */

 Disable LCD Controller */

 disable LCD controller clock */

/*

 *  sa1100fb_handle_irq: Handle 'LCD DONE' interrupts.

/*

 * This function must be called from task context only, since it will

 * sleep when disabling the LCD controller, or if we get two contending

 * processes trying to alter state.

	/*

	 * Hack around fbcon initialisation.

		/*

		 * Disable controller for clock change.  If the

		 * controller is already disabled, then do nothing.

		/*

		 * Disable controller

		/*

		 * Enable the controller after clock change.  Only

		 * do this if we were disabled for the clock change.

		/*

		 * Re-enable the controller only if it was already

		 * enabled.  This is so we reprogram the control

		 * registers.

		/*

		 * Re-enable the controller after PM.  This is not

		 * perfect - think about the case where we were doing

		 * a clock change, and we suspended half-way through.

		/*

		 * Power up the LCD screen, enable controller, and

		 * turn on the backlight.

/*

 * Our LCD controller task (which is called when we blank or unblank)

 * via keventd.

/*

 * CPU clock speed change handler.  We need to adjust the LCD timing

 * parameters when the CPU clock is adjusted by the power management

 * subsystem.

/*

 * Power management hooks.  Note that we won't be called from IRQ context,

 * unlike the blank functions above, so we may sleep.

/*

 * sa1100fb_map_video_memory():

 *      Allocates the DRAM memory for the frame buffer.  This buffer is  

 *	remapped into a non-cached, non-buffered, memory region to  

 *      allow palette and pixel writes to occur without flushing the 

 *      cache.  Once this area is remapped, all virtual memory

 *      access to the video memory should occur at the new region.

	/*

	 * We reserve one page for the palette, plus the size

	 * of the framebuffer.

		/*

		 * FIXME: this is actually the wrong thing to place in

		 * smem_start.  But fbdev suffers from the problem that

		 * it needs an API which doesn't exist (in this case,

		 * dma_writecombine_mmap)

 Fake monspecs to fill in fbinfo structure */

	/*

	 * People just don't seem to get this.  We don't support

	 * anything but correct entries now, so panic if someone

	 * does something stupid.

 Copy the RGB bitfield overrides */

 Initialize video memory */

	/*

	 * This makes sure that our colour bitfield

	 * descriptors are correctly initialised.

 This driver cannot be unloaded at the moment */

/*

 * broadsheetfb.c -- FB driver for E-Ink Broadsheet controller

 *

 * Copyright (C) 2008, Jaya Kumar

 *

 * This file is subject to the terms and conditions of the GNU General Public

 * License. See the file COPYING in the main directory of this archive for

 * more details.

 *

 * Layout is based on skeletonfb.c by James Simmons and Geert Uytterhoeven.

 *

 * This driver is written to be used with the Broadsheet display controller.

 *

 * It is intended to be architecture independent. A board specific driver

 * must be used to perform all the physical IO interactions.

 *

 track panel specific parameters */

 table of panel specific parameters to be indexed into by the board drivers */

 standard 6" on TFT backplane */

 custom 3.7" flexible on PET or steel */

 standard 9.7" on TFT backplane */

 main broadsheetfb functions */

 wait for ready to go hi. (lo is busy) */

 cs lo, dc lo for cmd, we lo for each data, db as usual */

 strobe wr */

 wait for ready to go hi. (lo is busy) */

 cs lo, dc lo for cmd, we lo for each data, db as usual */

 functions for waveform manipulation */

 disable arral saemipu mode */

/*

 * The caller must guarantee that the data to be rewritten is entirely

 * contained within this sector. That is, data_start_addr + data_len

 * must be less than sector_start_addr + sector_size.

 the start address of the sector is the 0th byte of that sector */

	/*

	 * check if there is head data that we need to readback into our sector

	 * buffer first

		/*

		 * we need to read every byte up till the start address of our

		 * data and we put it into our sector buffer.

 now we copy our data into the right place in the sector buffer */

	/*

	 * now we check if there is a tail section of the sector that we need to

	 * readback.

 now we read this tail into our sector buffer */

 if we got here we have the full sector that we want to rewrite. */

 first erase the sector */

 now write it */

 try to enforce reasonable min max on waveform */

 upper level functions that manipulate the display and other stuff */

 did the controller really set it? */

 setup waveform */

 the controller needs a second */

 y1 must be a multiple of 4 so drop the lower bits */

 y2 must be a multiple of 4 , but - 1 so up the lower bits */

 this is called back from the deferred io workqueue */

 height increment is fixed per page */

 walk the written page list and swizzle the data */

 just starting so assign first page */

 this page is consecutive so increase our height */

 page not consecutive, issue previous update first */

 start over with our non consecutive page */

 if we still have any pages to update we do so now */

 its a full screen update, just do it */

/*

 * this is the slow path from userspace. they can seek and write to

 * the fb. it's inefficient to do anything less than a full screen draw

 pick up board specific routines */

 try to count device specific driver, if can't, platform recalls */

 set cmap */

 this inits the dpy */

/*

 *  linux/drivers/video/pm3fb.c -- 3DLabs Permedia3 frame buffer device

 *

 *  Copyright (C) 2001 Romain Dolbeau <romain@dolbeau.org>.

 *

 *  Ported to 2.6 kernel on 1 May 2007 by Krzysztof Helt <krzysztof.h1@wp.pl>

 *	based on pm2fb.c

 *

 *  Based on code written by:

 *	   Sven Luther, <luther@dpt-info.u-strasbg.fr>

 *	   Alan Hourihane, <alanh@fairlite.demon.co.uk>

 *	   Russell King, <rmk@arm.linux.org.uk>

 *  Based on linux/drivers/video/skeletonfb.c:

 *	Copyright (C) 1997 Geert Uytterhoeven

 *  Based on linux/driver/video/pm2fb.c:

 *	Copyright (C) 1998-1999 Ilario Nardinocchi (nardinoc@CS.UniBO.IT)

 *	Copyright (C) 1999 Jakub Jelinek (jakub@redhat.com)

 *

 *  This file is subject to the terms and conditions of the GNU General Public

 *  License. See the file COPYING in the main directory of this archive for

 *  more details.

 *

/*

 * Driver data

/*

 * This structure defines the hardware state of the graphics card. Normally

 * you place this in a header file in linux/include/video. This file usually

 * also includes register information. That allows other driver subsystems

 * and userland applications the ability to use the same header file to

 * avoid duplicate work and easy porting of software.

 virtual address of p_regs */

 video flags before blanking */

 screen base in 128 bits unit */

/*

 * Here we define the default structs fb_fix_screeninfo and fb_var_screeninfo

 * if we don't use modedb. If we do use modedb see pm3fb_init how to use it

 * to get a fb_var_screeninfo. Otherwise define a default var as well.

/*

 * Utility functions

 Calculating various clock parameters */

 acceleration */

 invert bits in bitmask */

 size in lines of FB */

 Disable LocalBuffer. better safe than sorry */

 GXcopy */

 GXxor */

 ROP Ox3 is GXcopy */

(sx > dx ) ? (sx - dx) : (dx - sx); */

(sy > dy ) ? (sy - dy) : (dy - sy); */

 Ox3 is GXcopy */

 ROP Ox3 is GXcopy */

 end of acceleration functions */

/*

 *	Hardware Cursor support.

 just to force soft_cursor() call */

 Too large of a cursor or wrong bpp :-( */

	/*

	 * If the cursor is not be changed this means either we want the

	 * current cursor state (if enable is set) or we want to query what

	 * we can do with the cursor (if enable is not set)

 the X11 driver says one should use these color registers */

 Upper 4 bits of bitmap data */

 Lower 4 bits of bitmap */

 write the mode to registers */

 ! __BIG_ENDIAN */

 ! __BIG_ENDIAN */

	/*

	 * Oxygen VX1 - it appears that setting PM3VideoControl and

	 * then PM3RD_SyncControl to the same SYNC settings undoes

	 * any net change - they seem to xor together.  Only set the

	 * sync options in PM3RD_SyncControl.  --rmk

 ClkPreScale */

 ClkFeedBackScale */

 ClkPostScale */

	/*

	   PM3_WRITE_DAC_REG(par, PM3RD_IndexControl, 0x00);

	/*

	   PM3_SLOW_WRITE_REG(par, PM3RD_IndexControl, 0x00);

/*

 * hardware independent functions

 set predefined mode for bits_per_pixel settings */

 it is assumed BGRA order */

 could sometimes be 8 */

 Can't mmap if this is on */

	pm3fb_clear_memory(info, 0);*/

 no. of hw registers */

 grayscale works only partially under directcolor */

 grayscale = 0.30*R + 0.59*G + 0.11*B */

	/* Directcolor:

	 *   var->{color}.offset contains start of bitfield

	 *   var->{color}.length contains length of bitfield

	 *   {hardwarespecific} contains width of DAC

	 *   pseudo_palette[X] is programmed to (X << red.offset) |

	 *					(X << green.offset) |

	 *					(X << blue.offset)

	 *   RAMDAC[X] is programmed to (red, green, blue)

	 *   color depth = SUM(var->{color}.length)

	 *

	 * Pseudocolor:

	 *	var->{color}.offset is 0

	 *	var->{color}.length contains width of DAC or the number

	 *			of unique colors available (color depth)

	 *	pseudo_palette is not used

	 *	RAMDAC[X] is programmed to (red, green, blue)

	 *	color depth = var->{color}.length

	/*

	 * This is the point where the color is converted to something that

	 * is acceptable by the hardware.

	/*

	 * Oxygen VX1 - it appears that setting PM3VideoControl and

	 * then PM3RD_SyncControl to the same SYNC settings undoes

	 * any net change - they seem to xor together.  Only set the

	 * sync options in PM3RD_SyncControl.  --rmk

	/*

	 *  Frame buffer operations

 ------------------------------------------------------------------------- */

	/*

	 *  Initialization

 mmio register are already mapped when this function is called */

 the pm3fb_fix.smem_start is also set */

 request full aperture size */

 Linear frame buffer - request region and map it. */

 TODO: card-specific stuff, *before* accessing *any* FB memory */

 For Appian Jeronimo 2000 board second head */

	/* pm3 split up memory, replicates, and do a lot of

	 * nasty stuff IMHO ;-)

 Let's check for wrapover, write will fail at 16MB boundary */

 Clear first 32MB ; 0 is 0, no need to byteswap */

 different value, different RAM... */

 for pci drivers */

	/*

	 * Dynamically allocate info and par

	/*

	 * Here we set the screen_base to the virtual memory address

	 * for the framebuffer.

 Registers - request region and map it. */

 Linear frame buffer - request region and map it. */

	/*

	 * This should give a reasonable default video mode. The following is

	 * done when we can set a video mode.

	/*

	 * For drivers that can...

	/*

	 *  Cleanup

 For PCI drivers */

	/*

	 *  Setup

/*

 * Only necessary if your driver takes special options,

 * otherwise we fall back on the generic fb_setup().

 Parse user specified options (`video=pm3fb:') */

 MODULE */

	/*

	 *  For kernel boot options (in 'video=pm3fb:<options>' format)

/*

 * linux/drivers/video/atafb.c -- Atari builtin chipset frame buffer device

 *

 *  Copyright (C) 1994 Martin Schaller & Roman Hodek

 *

 * This file is subject to the terms and conditions of the GNU General Public

 * License.  See the file COPYING in the main directory of this archive

 * for more details.

 *

 * History:

 *   - 03 Jan 95: Original version by Martin Schaller: The TT driver and

 *                all the device independent stuff

 *   - 09 Jan 95: Roman: I've added the hardware abstraction (hw_switch)

 *                and wrote the Falcon, ST(E), and External drivers

 *                based on the original TT driver.

 *   - 07 May 95: Martin: Added colormap operations for the external driver

 *   - 21 May 95: Martin: Added support for overscan

 *		  Andreas: some bug fixes for this

 *   -    Jul 95: Guenther Kelleter <guenther@pool.informatik.rwth-aachen.de>:

 *                Programmable Falcon video modes

 *                (thanks to Christian Cartus for documentation

 *                of VIDEL registers).

 *   - 27 Dec 95: Guenther: Implemented user definable video modes "user[0-7]"

 *                on minor 24...31. "user0" may be set on commandline by

 *                "R<x>;<y>;<depth>". (Makes sense only on Falcon)

 *                Video mode switch on Falcon now done at next VBL interrupt

 *                to avoid the annoying right shift of the screen.

 *   - 23 Sep 97: Juergen: added xres_virtual for cards like ProMST

 *                The external-part is legacy, therefore hardware-specific

 *                functions like panning/hardwarescrolling/blanking isn't

 *				  supported.

 *   - 29 Sep 97: Juergen: added Romans suggestion for pan_display

 *				  (var->xoffset was changed even if no set_screen_base avail.)

 *	 - 05 Oct 97: Juergen: extfb (PACKED_PIXEL) is FB_PSEUDOCOLOR 'cause

 *				  we know how to set the colors

 *				  ext_*palette: read from ext_colors (former MV300_colors)

 *							    write to ext_colors and RAMDAC

 *

 * To do:

 *   - For the Falcon it is not possible to set random video modes on

 *     SM124 and SC/TV, only the bootup resolution is supported.

 *

 modes for switch on OverScan */

 default resolution (0=none) */

	/*

	 * Hardware parameters for current mode

			/* Here are fields for storing a video mode, as direct

			 * parameters for the hardware.

 auxiliary information */

 Nothing needed for external mode */

/* Don't calculate an own resolution, and thus don't change the one found when

 * booting (currently used for the Falcon to keep settings for internal video

 base address of screen */

 (only for Overscan) */

 external video handling */

/*

 * not needed - atafb will never support panning/hardwarescroll with external

 * static unsigned int external_yres_virtual;

/*

 * JOE <joe@amber.dinoco.de>:

 * added card type for external driver, is only needed for

 * colormap handling.

/*

 * The MV300 mixes the color registers. So we need an array of munged

 * indices in order to access the correct reg.

 ATAFB_EXT */

/*

 * struct fb_ops {

 *	* open/release and usage marking

 *	struct module *owner;

 *	int (*fb_open)(struct fb_info *info, int user);

 *	int (*fb_release)(struct fb_info *info, int user);

 *

 *	* For framebuffers with strange non linear layouts or that do not

 *	* work with normal memory mapped access

 *	ssize_t (*fb_read)(struct file *file, char __user *buf, size_t count, loff_t *ppos);

 *	ssize_t (*fb_write)(struct file *file, const char __user *buf, size_t count, loff_t *ppos);

 *

 *	* checks var and eventually tweaks it to something supported,

 *	* DOES NOT MODIFY PAR *

 *	int (*fb_check_var)(struct fb_var_screeninfo *var, struct fb_info *info);

 *

 *	* set the video mode according to info->var *

 *	int (*fb_set_par)(struct fb_info *info);

 *

 *	* set color register *

 *	int (*fb_setcolreg)(unsigned int regno, unsigned int red, unsigned int green,

 *			    unsigned int blue, unsigned int transp, struct fb_info *info);

 *

 *	* set color registers in batch *

 *	int (*fb_setcmap)(struct fb_cmap *cmap, struct fb_info *info);

 *

 *	* blank display *

 *	int (*fb_blank)(int blank, struct fb_info *info);

 *

 *	* pan display *

 *	int (*fb_pan_display)(struct fb_var_screeninfo *var, struct fb_info *info);

 *

 *	*** The meat of the drawing engine ***

 *	* Draws a rectangle *

 *	void (*fb_fillrect) (struct fb_info *info, const struct fb_fillrect *rect);

 *	* Copy data from area to another *

 *	void (*fb_copyarea) (struct fb_info *info, const struct fb_copyarea *region);

 *	* Draws a image to the display *

 *	void (*fb_imageblit) (struct fb_info *info, const struct fb_image *image);

 *

 *	* Draws cursor *

 *	int (*fb_cursor) (struct fb_info *info, struct fb_cursor *cursor);

 *

 *	* wait for blit idle, optional *

 *	int (*fb_sync)(struct fb_info *info);

 *

 *	* perform fb specific ioctl (optional) *

 *	int (*fb_ioctl)(struct fb_info *info, unsigned int cmd,

 *			unsigned long arg);

 *

 *	* Handle 32bit compat ioctl (optional) *

 *	int (*fb_compat_ioctl)(struct fb_info *info, unsigned int cmd,

 *			unsigned long arg);

 *

 *	* perform fb specific mmap *

 *	int (*fb_mmap)(struct fb_info *info, struct vm_area_struct *vma);

 * } ;

/* ++roman: This structure abstracts from the underlying hardware (ST(e),

 * TT, or Falcon.

 *

 * int (*detect)(void)

 *   This function should detect the current video mode settings and

 *   store them in atafb_predefined[0] for later reference by the

 *   user. Return the index+1 of an equivalent predefined mode or 0

 *   if there is no such.

 *

 * int (*encode_fix)(struct fb_fix_screeninfo *fix,

 *                   struct atafb_par *par)

 *   This function should fill in the 'fix' structure based on the

 *   values in the 'par' structure.

 * !!! Obsolete, perhaps !!!

 *

 * int (*decode_var)(struct fb_var_screeninfo *var,

 *                   struct atafb_par *par)

 *   Get the video params out of 'var'. If a value doesn't fit, round

 *   it up, if it's too big, return EINVAL.

 *   Round up in the following order: bits_per_pixel, xres, yres,

 *   xres_virtual, yres_virtual, xoffset, yoffset, grayscale, bitfields,

 *   horizontal timing, vertical timing.

 *

 * int (*encode_var)(struct fb_var_screeninfo *var,

 *                   struct atafb_par *par);

 *   Fill the 'var' structure based on the values in 'par' and maybe

 *   other values read out of the hardware.

 *

 * void (*get_par)(struct atafb_par *par)

 *   Fill the hardware's 'par' structure.

 *   !!! Used only by detect() !!!

 *

 * void (*set_par)(struct atafb_par *par)

 *   Set the hardware according to 'par'.

 *

 * void (*set_screen_base)(void *s_base)

 *   Set the base address of the displayed frame buffer. Only called

 *   if yres_virtual > yres or xres_virtual > xres.

 *

 * int (*blank)(int blank_mode)

 *   Blank the screen if blank_mode != 0, else unblank. If blank == NULL then

 *   the caller blanks by setting the CLUT to all black. Return 0 if blanking

 *   succeeded, !=0 if un-/blanking failed due to e.g. a video mode which

 *   doesn't support it. Implements VESA suspend and powerdown modes on

 *   hardware that supports disabling hsync/vsync:

 *       blank_mode == 2: suspend vsync, 3:suspend hsync, 4: powerdown.

	/*

	 * yres_virtual == 0 means use hw-scrolling if possible, else yres

 autodetect */

 xres-grayscale */

 red green blue tran*/

 st low */

 st mid */

 st high */

 tt low */

 tt mid */

 tt high */

 vga2 */

 vga4 */

 vga16 */

 vga256 */

 falh2 */

 falh16 */

	/*

	 *  Atari Video Modes

	 *

	 *  If you change these, make sure to update DEFMODE_* as well!

	/*

	 *  ST/TT Video Modes

 320x200, 15 kHz, 60 Hz (ST low) */

 640x200, 15 kHz, 60 Hz (ST medium) */

 640x400, 30.25 kHz, 63.5 Hz (ST high) */

 320x480, 15 kHz, 60 Hz (TT low) */

 640x480, 29 kHz, 57 Hz (TT medium) */

 1280x960, 29 kHz, 60 Hz (TT high) */

	/*

	 *  VGA Video Modes

 640x480, 31 kHz, 60 Hz (VGA) */

 640x400, 31 kHz, 70 Hz (VGA) */

	/*

	 *  Falcon HiRes Video Modes

 896x608, 31 kHz, 60 Hz (Falcon High) */

 default modes */

 "tt-high" for TT */

 "vga70" for Falcon */

 "st-high" for ST/E */

 "vga" for external */

 ------------------- TT specific functions ---------------------- */

 these may be incorrect */

 yres_virtual == 0 means use maximum */

 only set screen_base if really necessary */

	/* Determine the connected monitor: The DMA sound must be

	 * disabled before reading the MFP GPIP, because the Sound

	 * Done Signal and the Monochrome Detect are XORed together!

	 *

	 * Even on a TT, we should look if there is a DMA sound. It was

	 * announced that the Eagle is TT compatible, but only the PCM is

	 * missing...

 wait a while for things to settle down */

 ATAFB_TT */

 ------------------- Falcon specific functions ---------------------- */

 Falcon connected monitor */

 Falcon ram bus width (for vid_control) */

 f/[Hz] */

 t/[ps] (=1/f) */

 standard timing in clock cycles, not pixel */

 hsync initialized in falcon_detect() */

 or-mask for hw.falcon.sync to set this clock */

 ditto, for hw.falcon.vid_control */

 VIDEL-prescale values [mon_type][pixel_length from VCO] */

 Default hsync timing [mon_type] in picoseconds */

 no smooth scrolling with longword aligned video mem */

 Is this ok or should it be DIRECTCOLOR? */

 width of pixel in clock cycles */

/*

	Get the video params out of 'var'. If a value doesn't fit, round

	it up, if it's too big, return EINVAL.

	Round up in the following order: bits_per_pixel, xres, yres,

	xres_virtual, yres_virtual, xoffset, yoffset, grayscale, bitfields,

	horizontal timing, vertical timing.



	There is a maximum of screen resolution determined by pixelclock

	and minimum frame rate -- (X+hmarg.)*(Y+vmarg.)*vfmin <= pixelclock.

	In interlace mode this is     "     *    "     *vfmin <= pixelclock.

	Additional constraints: hfreq.

	Frequency range for multisync monitors is given via command line.

	For TV and SM124 both frequencies are fixed.



	X % 16 == 0 to fit 8x?? font (except 1 bitplane modes must use X%32 == 0)

	Y % 16 == 0 to fit 8x16 font

	Y % 8 == 0 if Y<400



	Currently interlace and doubleline mode in var are ignored.

	On SM124 and TV only the standard resolutions can be used.

 Reject uninitialized mode */

 packed pixel mode */

 hicolor, no overlay */

 Skip all calculations. VGA/TV/SC1224 only supported. */

 Current par will be new par */

 Don't forget this */

 Only some fixed resolutions < 640x400 */

 2 planes must use STE compatibility mode */

	/* Total and visible scanline length must be a multiple of one longword,

	 * this and the console fontwidth yields the alignment for xres and

	 * xres_virtual.

	 * TODO: this way "odd" fontheights are not supported

	 *

	 * Special case in STE mode: blank and graphic positions don't align,

	 * avoid trash at right margin

 backward bug-compatibility */

 single or double pixel width */

 SM124 supports only 640x400, this is rejected above */

 SM124-mode is special */

 TODO set all margins */

 set some minimal margins which center the screen */

 F_MON_VGA */

 Double pixel width only for hicolor */

 Default values are used for vert./hor. timing if no pixelclock given. */

 Choose master pixelclock depending on hor. timing */

 Choose largest pixelclock <= wanted clock */

 Internal unit is [single lines per (half-)frame] */

 # lines in half frame */

 External unit is [lines per full frame] */

 External unit is [double lines per frame] */

 VIDEL doesn't synchronize on short offset */

 Is video bus bandwidth (32MB/s) too low for this resolution? */

 this is definitely wrong if bus clock != 32MHz */

 include sync lengths in right/lower margin for all calculations */

	/* ! In all calculations of margins we use # of lines in half frame

	 * (which is a full frame in non-interlace mode), so we can switch

	 * between interlace and non-interlace without messing around

	 * with these.

 Set base_offset 128 and video bus width */

 base_offset 64 */

 Pixelclock */

 External or internal clock */

 Pixellength and prescale */

	/*********************

	 * Horizontal timing: unit = [master clock cycles]

	 * unit of hxx-registers: [master clock cycles * prescale]

	 * Hxx-registers are 9 bit wide

	 *

	 * 1 line = ((hht + 2) * 2 * prescale) clock cycles

	 *

	 * graphic output = hdb & 0x200 ?

	 *        ((hht + 2) * 2 - hdb + hde) * prescale - hdboff + hdeoff:

	 *        (hht + 2  - hdb + hde) * prescale - hdboff + hdeoff

	 * (this must be a multiple of plen*128/bpp, on VGA pixels

	 *  to the right may be cut off with a bigger right margin)

	 *

	 * start of graphics relative to start of 1st halfline = hdb & 0x200 ?

	 *        (hdb - hht - 2) * prescale + hdboff :

	 *        hdb * prescale + hdboff

	 *

	 * end of graphics relative to start of 1st halfline =

	 *        (hde + hht + 2) * prescale + hdeoff

 Calculate VIDEL registers */

 Offsets depend on video mode */

	/* Offsets are in clock cycles, divide by prescale to

	 * calculate hd[be]-registers

 gend1 is for hde (gend-gstart multiple of align), shifter's xres */

 gend2 is for hbb, visible xres (rest to gend1 is cut off by hblank) */

	par->HHT = (gend2 + plen * right_margin / prescale) / 2 - 2;*/

 One more Videl constraint: data fetch of two lines must not overlap */

 if this happens increase margins, decrease hfreq. */

 compensate for non matching hde and hbb */

  check hor. frequency */

 ++guenther:   ^^^^^^^^^^^^^^^^^^^ can't remember why I did this */

 Too high -> enlarge margin */

 Vxx-registers */

	/* All Vxx must be odd in non-interlace, since frame starts in the middle

	 * of the first displayed line!

	 * One frame consists of VFT+1 half lines. VFT+1 must be even in

	 * non-interlace, odd in interlace mode for synchronisation.

	 * Vxx-registers are 11 bit wide

 must begin on odd halfline */

 VDE now half lines per (half-)frame */

 vbb,vss,vft must be even in interlace mode */

 V-frequency check, hope I didn't create any loop here. */

 Interlace and doubleline are mutually exclusive. */

 Too high -> try again with doubleline */

 Too low -> try again with interlace */

 Doubleline too low -> clear doubleline and enlarge margins */

 Doubleline too high -> enlarge margins */

 Interlace, too high -> enlarge margins */

 !!! only for VGA !!! */

 possible frequencies: 25.175 or 32MHz */

	/* visible y resolution:

	 * Graphics display starts at line VDB and ends at line

	 * VDE. If interlace mode off unit of VC-registers is

	 * half lines, else lines.

	/*

	 * to get bpp, we must examine f_shift and st_shift.

	 * f_shift is valid if any of bits no. 10, 8 or 4

	 * is set. Priority in f_shift is: 10 ">" 8 ">" 4, i.e.

	 * if bit 10 set then bit 8 and bit 4 don't care...

	 * If all these bits are 0 get display depth from st_shift

	 * (as for ST and STE)

 2 colors */

 hicolor */

 8 bitplanes */

 if (hw->st_shift == 0x200) */

 yres_virtual == 0 means use maximum */

 TODO change this */

 hdX-offsets */

 Right margin includes hsync */

 can't use this in ste_mode, because hbb is +1 off */

 Lower margin includes vsync */

 round down to full lines */

 round up */

 round up */

 what is this for? */

 derived parameters */

 only set screen_base if really necessary */

 Don't touch any other registers if we keep the default resolution */

	/* Tell vbl-handler to change video mode.

	 * We change modes only on next VBL, to avoid desynchronisation

	 * (a shift to the right and wrap around by a random number of pixels

	 * in all monochrome modes).

	 * This seems to work on my Falcon.

 Enable external pixelclock. This code only for ScreenWonder */

 Turn off external clocks. Read sets all output bits to 1. */

 write enables Falcon palette, 0: 4 planes */

 write enables STE palette */

			/* IMPORTANT:

			 * set st_shift 0, so we can tell the screen-depth if f_shift == 0.

			 * Writing 0 to f_shift enables 4 plane Falcon mode but

			 * doesn't set st_shift. st_shift != 0 (!= 4planes) is impossible

			 * with Falcon palette.

 now back to Falcon palette mode */

 writing to st_shift changed scn_width and vid_mode */

 shouldn't happen */

	/* ++guenther: we can switch off graphics by changing VDB and VDE,

	 * so VIDEL doesn't hog the bus while saving.

	 * (this may affect usleep()).

 this doesn't work on SM124 */

 disable graphics output (this speeds up the CPU) ... */

 ... and blank all lines */

 use VESA suspend modes on VGA monitors */

 Determine connected monitor and set monitor parameters */

 bit 1 of fhw: 1=32 bit ram bus, 0=16 bit */

 PAL...NTSC */

 not 50, since TOS defaults to 49.9x Hz */

 initialize hsync-len */

 Detected mode is always the "autodetect" slot */

 ATAFB_FALCON */

 ------------------- ST(E) specific functions ---------------------- */

 these are incorrect */

 yres_virtual == 0 means use maximum */

 only set screen_base if really necessary */

	/* Determine the connected monitor: The DMA sound must be

	 * disabled before reading the MFP GPIP, because the Sound

	 * Done Signal and the Monochrome Detect are XORed together!

 wait a while for things to settle down */

 Setup Screen Memory */

 ATAFB_STE */

/* Switching the screen size should be done during vsync, otherwise

 * the margins may get messed up. This is a well known problem of

 * the ST's video system.

 *

 * Unfortunately there is hardly any way to find the vsync, as the

 * vertical blank interrupt is no longer in time on machines with

 * overscan type modifications.

 *

 * We can, however, use Timer B to safely detect the black shoulder,

 * but then we've got to guess an appropriate delay to find the vsync.

 * This might not work on every machine.

 *

 * martin_rogge @ ki.maus.de, 8th Aug 1995

 SWITCH_ACIA may be used for Falcon (ScreenBlaster III internal!) */

 TOS does it this way, don't ask why */

 ------------------- External Video ---------------------- */

		/* The letters 'n' and 'i' in the "atavideo=external:" stand

 Use STATIC if we don't know how to access color registers */

 truecolor */

 these are surely incorrect */

 ATAFB_EXT */

 ------ This is the same for most hardware types -------- */

 Setup Screen Memory */

 ------------ Interfaces to hardware functions ------------ */

 =========================================================== */

 ============== Hardware Independent Functions ============= */

 =========================================================== */

 used for hardware scrolling */

/* fbhw->encode_fix() must be called with fb_info->mm_lock held

 * if it is called after the register_framebuffer() - not a case here

 Get fix directly (case con == -1 before)??

 No longer called by fbcon!

 Still called by set_var internally

 Note: smem_start derives from phys_screen_base, not screen_base! */

/*

 * generic drawing routines; imageblit needs updating for image depth > 1

	/*

	 * We could use hardware clipping but on many cards you get around

	 * hardware clipping by writing to framebuffer directly.

 clip the destination */

 update sx,sy */

 the source must be completely inside the virtual screen */

	/*

	 * We could use hardware clipping but on many cards you get around

	 * hardware clipping by writing to framebuffer directly like we are

	 * doing here.

 used for font data

/* (un)blank/poweroff

 * 0 = unblank

 * 1 = blank

 * 2 = suspend vsync

 * 3 = suspend hsync

 * 4 = off

	/*

	 * New fbcon interface ...

	 /* check var by decoding var into hw par, rounding if necessary,

 Validate wanted screen parameters */

 if ((err = ata_decode_var(var, &par)))

 Encode (possibly rounded) screen parameters */

	/* actually set hw par by decoding var, then setting hardware from

 Decode wanted screen parameters */

 Set new videomode */

 First try the user supplied mode */

 failed */

 Next is the autodetected one */

 autodetect */

 If that also failed, try some default modes... */

 try default1, default2... */

 ok */

	/* Format is: <xres>;<yres>;<depth>;<plane organ.>;

	 *            <screen mem addr>

	 *	      [;<screen mem length>[;<vgaiobase>[;<bits-per-col>[;<colorreg-type>

	 *	      [;<xres-virtual>]]]]]

	 *

	 * 09/23/97	Juergen

	 * <xres_virtual>:	hardware's x-resolution (f.e. ProMST)

	 *

	 * Even xres_virtual is available, we neither support panning nor hw-scrolling!

 true color */

 ATAFB_EXT */

	/* Format to config extended internal video hardware like OverScan:

	 * "internal:<xres>;<yres>;<xres_max>;<yres_max>;<offset>"

	 * Explanation:

	 * <xres>: x-resolution

	 * <yres>: y-resolution

	 * The following are only needed if you have an overscan which

	 * needs a black border:

	 * <xres_max>: max. length of a line in pixels your OverScan hardware would allow

	 * <yres_max>: max. number of lines your OverScan hardware would allow

	 * <offset>: Offset from physical beginning to visible beginning

	 *	  of screen in bytes

	/* Format for monitor capabilities is: <Vmin>;<Vmax>;<Hmin>;<Hmax>

	 * <V*> vertical freq. in Hz

	 * <H*> horizontal freq. in kHz

 ATAFB_FALCON */

	/* Format of user defined video mode is: <xres>;<yres>;<depth>

 external pixelclock in kHz --> ps */

 ATAFB_STE */

 no default driver included */

 Nobody will ever see this message :-) */

 Multisync monitor capabilities */

 Atari-TOS defaults if no boot option present */

 ATAFB_EXT */

			/* On a '040+, the cache mode of video RAM must be set to

		/* Map the video memory (physical address given) to somewhere

		 * in the kernel address space.

 ATAFB_EXT */

	strcpy(fb_info.mode->name, "Atari Builtin ");

 try to set default (detected; requested) var

 reads hw state into current par, which may not be sane yet

 tries to read from HW which may not be initialized yet

 so set sane var first, then call atafb_set_par

 TODO: This driver cannot be unloaded yet */

 Unblank before kexec */

/*

 * linux/drivers/video/amifb.c -- Amiga builtin chipset frame buffer device

 *

 *    Copyright (C) 1995-2003 Geert Uytterhoeven

 *

 *          with work by Roman Zippel

 *

 *

 * This file is based on the Atari frame buffer device (atafb.c):

 *

 *    Copyright (C) 1994 Martin Schaller

 *                       Roman Hodek

 *

 *          with work by Andreas Schwab

 *                       Guenther Kelleter

 *

 * and on the original Amiga console driver (amicon.c):

 *

 *    Copyright (C) 1993 Hamish Macdonald

 *                       Greg Harp

 *    Copyright (C) 1994 David Carter [carter@compsci.bristol.ac.uk]

 *

 *          with work by William Rucklidge (wjr@cs.cornell.edu)

 *                       Geert Uytterhoeven

 *                       Jes Sorensen (jds@kom.auc.dk)

 *

 *

 * History:

 *

 *   - 24 Jul 96: Copper generates now vblank interrupt and

 *                VESA Power Saving Protocol is fully implemented

 *   - 14 Jul 96: Rework and hopefully last ECS bugs fixed

 *   -  7 Mar 96: Hardware sprite support by Roman Zippel

 *   - 18 Feb 96: OCS and ECS support by Roman Zippel

 *                Hardware functions completely rewritten

 *   -  2 Dec 95: AGA version by Geert Uytterhoeven

 *

 * This file is subject to the terms and conditions of the GNU General Public

 * License. See the file COPYING in the main directory of this archive

 * for more details.

 define at least one fb driver, this will change later */

/*******************************************************************************





   Generic video timings

   ---------------------



   Timings used by the frame buffer interface:



   +----------+---------------------------------------------+----------+-------+

   |          |                ^                            |          |       |

   |          |                |upper_margin                |          |       |

   |          |                v                            |          |       |

   +----------###############################################----------+-------+

   |          #                ^                            #          |       |

   |          #                |                            #          |       |

   |          #                |                            #          |       |

   |          #                |                            #          |       |

   |   left   #                |                            #  right   | hsync |

   |  margin  #                |       xres                 #  margin  |  len  |

   |<-------->#<---------------+--------------------------->#<-------->|<----->|

   |          #                |                            #          |       |

   |          #                |                            #          |       |

   |          #                |                            #          |       |

   |          #                |yres                        #          |       |

   |          #                |                            #          |       |

   |          #                |                            #          |       |

   |          #                |                            #          |       |

   |          #                |                            #          |       |

   |          #                |                            #          |       |

   |          #                |                            #          |       |

   |          #                |                            #          |       |

   |          #                |                            #          |       |

   |          #                v                            #          |       |

   +----------###############################################----------+-------+

   |          |                ^                            |          |       |

   |          |                |lower_margin                |          |       |

   |          |                v                            |          |       |

   +----------+---------------------------------------------+----------+-------+

   |          |                ^                            |          |       |

   |          |                |vsync_len                   |          |       |

   |          |                v                            |          |       |

   +----------+---------------------------------------------+----------+-------+





   Amiga video timings

   -------------------



   The Amiga native chipsets uses another timing scheme:



      - hsstrt:   Start of horizontal synchronization pulse

      - hsstop:   End of horizontal synchronization pulse

      - htotal:   Last value on the line (i.e. line length = htotal + 1)

      - vsstrt:   Start of vertical synchronization pulse

      - vsstop:   End of vertical synchronization pulse

      - vtotal:   Last line value (i.e. number of lines = vtotal + 1)

      - hcenter:  Start of vertical retrace for interlace



   You can specify the blanking timings independently. Currently I just set

   them equal to the respective synchronization values:



      - hbstrt:   Start of horizontal blank

      - hbstop:   End of horizontal blank

      - vbstrt:   Start of vertical blank

      - vbstop:   End of vertical blank



   Horizontal values are in color clock cycles (280 ns), vertical values are in

   scanlines.



   (0, 0) is somewhere in the upper-left corner :-)





   Amiga visible window definitions

   --------------------------------



   Currently I only have values for AGA, SHRES (28 MHz dotclock). Feel free to

   make corrections and/or additions.



   Within the above synchronization specifications, the visible window is

   defined by the following parameters (actual register resolutions may be

   different; all horizontal values are normalized with respect to the pixel

   clock):



      - diwstrt_h:   Horizontal start of the visible window

      - diwstop_h:   Horizontal stop + 1(*) of the visible window

      - diwstrt_v:   Vertical start of the visible window

      - diwstop_v:   Vertical stop of the visible window

      - ddfstrt:     Horizontal start of display DMA

      - ddfstop:     Horizontal stop of display DMA

      - hscroll:     Horizontal display output delay



   Sprite positioning:



      - sprstrt_h:   Horizontal start - 4 of sprite

      - sprstrt_v:   Vertical start of sprite



   (*) Even Commodore did it wrong in the AGA monitor drivers by not adding 1.



   Horizontal values are in dotclock cycles (35 ns), vertical values are in

   scanlines.



   (0, 0) is somewhere in the upper-left corner :-)





   Dependencies (AGA, SHRES (35 ns dotclock))

   -------------------------------------------



   Since there are much more parameters for the Amiga display than for the

   frame buffer interface, there must be some dependencies among the Amiga

   display parameters. Here's what I found out:



      - ddfstrt and ddfstop are best aligned to 64 pixels.

      - the chipset needs 64 + 4 horizontal pixels after the DMA start before

	the first pixel is output, so diwstrt_h = ddfstrt + 64 + 4 if you want

	to display the first pixel on the line too. Increase diwstrt_h for

	virtual screen panning.

      - the display DMA always fetches 64 pixels at a time (fmode = 3).

      - ddfstop is ddfstrt+#pixels - 64.

      - diwstop_h = diwstrt_h + xres + 1. Because of the additional 1 this can

	be 1 more than htotal.

      - hscroll simply adds a delay to the display output. Smooth horizontal

	panning needs an extra 64 pixels on the left to prefetch the pixels that

	`fall off' on the left.

      - if ddfstrt < 192, the sprite DMA cycles are all stolen by the bitplane

	DMA, so it's best to make the DMA start as late as possible.

      - you really don't want to make ddfstrt < 128, since this will steal DMA

	cycles from the other DMA channels (audio, floppy and Chip RAM refresh).

      - I make diwstop_h and diwstop_v as large as possible.



   General dependencies

   --------------------



      - all values are SHRES pixel (35ns)



		  table 1:fetchstart  table 2:prefetch    table 3:fetchsize

		  ------------------  ----------------    -----------------

   Pixclock     # SHRES|HIRES|LORES # SHRES|HIRES|LORES # SHRES|HIRES|LORES

   -------------#------+-----+------#------+-----+------#------+-----+------

   Bus width 1x #   16 |  32 |  64  #   16 |  32 |  64  #   64 |  64 |  64

   Bus width 2x #   32 |  64 | 128  #   32 |  64 |  64  #   64 |  64 | 128

   Bus width 4x #   64 | 128 | 256  #   64 |  64 |  64  #   64 | 128 | 256



      - chipset needs 4 pixels before the first pixel is output

      - ddfstrt must be aligned to fetchstart (table 1)

      - chipset needs also prefetch (table 2) to get first pixel data, so

	ddfstrt = ((diwstrt_h - 4) & -fetchstart) - prefetch

      - for horizontal panning decrease diwstrt_h

      - the length of a fetchline must be aligned to fetchsize (table 3)

      - if fetchstart is smaller than fetchsize, then ddfstrt can a little bit

	moved to optimize use of dma (useful for OCS/ECS overscan displays)

      - ddfstop is ddfstrt + ddfsize - fetchsize

      - If C= didn't change anything for AGA, then at following positions the

	dma bus is already used:

	ddfstrt <  48 -> memory refresh

		<  96 -> disk dma

		< 160 -> audio dma

		< 192 -> sprite 0 dma

		< 416 -> sprite dma (32 per sprite)

      - in accordance with the hardware reference manual a hardware stop is at

	192, but AGA (ECS?) can go below this.



   DMA priorities

   --------------



   Since there are limits on the earliest start value for display DMA and the

   display of sprites, I use the following policy on horizontal panning and

   the hardware cursor:



      - if you want to start display DMA too early, you lose the ability to

	do smooth horizontal panning (xpanstep 1 -> 64).

      - if you want to go even further, you lose the hardware cursor too.



   IMHO a hardware cursor is more important for X than horizontal scrolling,

   so that's my motivation.





   Implementation

   --------------



   ami_decode_var() converts the frame buffer values to the Amiga values. It's

   just a `straightforward' implementation of the above rules.





   Standard VGA timings

   --------------------



	       xres  yres    left  right  upper  lower    hsync    vsync

	       ----  ----    ----  -----  -----  -----    -----    -----

      80x25     720   400      27     45     35     12      108        2

      80x30     720   480      27     45     30      9      108        2



   These were taken from a XFree86 configuration file, recalculated for a 28 MHz

   dotclock (Amigas don't have a 25 MHz dotclock) and converted to frame buffer

   generic timings.



   As a comparison, graphics/monitor.h suggests the following:



	       xres  yres    left  right  upper  lower    hsync    vsync

	       ----  ----    ----  -----  -----  -----    -----    -----



      VGA       640   480      52    112     24     19    112 -      2 +

      VGA70     640   400      52    112     27     21    112 -      2 -





   Sync polarities

   ---------------



      VSYNC    HSYNC    Vertical size    Vertical total

      -----    -----    -------------    --------------

	+        +           Reserved          Reserved

	+        -                400               414

	-        +                350               362

	-        -                480               496



   Source: CL-GD542X Technical Reference Manual, Cirrus Logic, Oct 1992





   Broadcast video timings

   -----------------------



   According to the CCIR and RETMA specifications, we have the following values:



   CCIR -> PAL

   -----------



      - a scanline is 64 µs long, of which 52.48 µs are visible. This is about

	736 visible 70 ns pixels per line.

      - we have 625 scanlines, of which 575 are visible (interlaced); after

	rounding this becomes 576.



   RETMA -> NTSC

   -------------



      - a scanline is 63.5 µs long, of which 53.5 µs are visible.  This is about

	736 visible 70 ns pixels per line.

      - we have 525 scanlines, of which 485 are visible (interlaced); after

	rounding this becomes 484.



   Thus if you want a PAL compatible display, you have to do the following:



      - set the FB_SYNC_BROADCAST flag to indicate that standard broadcast

	timings are to be used.

      - make sure upper_margin + yres + lower_margin + vsync_len = 625 for an

	interlaced, 312 for a non-interlaced and 156 for a doublescanned

	display.

      - make sure left_margin + xres + right_margin + hsync_len = 1816 for a

	SHRES, 908 for a HIRES and 454 for a LORES display.

      - the left visible part begins at 360 (SHRES; HIRES:180, LORES:90),

	left_margin + 2 * hsync_len must be greater or equal.

      - the upper visible part begins at 48 (interlaced; non-interlaced:24,

	doublescanned:12), upper_margin + 2 * vsync_len must be greater or

	equal.

      - ami_encode_var() calculates margins with a hsync of 5320 ns and a vsync

	of 4 scanlines



   The settings for a NTSC compatible display are straightforward.



   Note that in a strict sense the PAL and NTSC standards only define the

   encoding of the color part (chrominance) of the video signal and don't say

   anything about horizontal/vertical synchronization nor refresh rates.





							    -- Geert --



	/*

	 * Custom Chipset Definitions

	/*

	 * BPLCON0 -- Bitplane Control Register 0

 Bit plane used count */

 HAM mode */

 Double playfield */

 Enable colorburst */

 Genlock audio enable */

 Ultrahi res enable */

 Super hi res mode */

 Bypass LUT - AGA */

 AGA */

 Light pen enable */

 Interlace */

 External resync */

 ECS enable */

	/*

	 * BPLCON2 -- Bitplane Control Register 2

 Bitplane to be used for ZD - AGA */

 Enable ZD with ZDBPSELx - AGA */

 Enable ZD with palette bit #31 - AGA */

 Kill EHB mode - AGA */

 Color table accesses read, not write - AGA */

 SOG output pin high - AGA */

 PF2 priority over PF1 */

 PF2 priority wrt sprites */

 ditto PF1 */

	/*

	 * BPLCON3 -- Bitplane Control Register 3 (AGA)

 Bits to select color register bank */

 Bits for color table offset when PF2 */

 Color register writes go to low bits */

 Sprite resolution bits */

 Border blanked? */

 Border transparent? */

 ZD pin is 14 MHz (HIRES) clock output */

 Sprites in border? */

 BLANK programmable */

	/*

	 * BPLCON4 -- Bitplane Control Register 4 (AGA)

 bitplane color XOR field */

 4 high bits for even sprite colors */

 4 high bits for odd sprite colors */

	/*

	 * BEAMCON0 -- Beam Control Register

 Disable hardware limits */

 Disable light pen latch */

 Enable variable vertical blank */

 Disable long/short line toggle */

 Composite sync/blank */

 Enable variable vertical sync */

 Enable variable horizontal sync */

 Enable variable beam counters */

 Enable alternate horizontal beam counter */

 Set decodes for PAL */

 Enable variable composite sync */

 Blank enable (no longer used on AGA) */

 CSY polarity */

 VSY polarity */

 HSY polarity */

	/*

	 * FMODE -- Fetch Mode Control Register (AGA)

 Sprite scan-doubling */

 Use PF2 modulus every other line */

 Sprite page mode */

 Sprite 32 bit fetch */

 Bitplane page mode */

 Bitplane 32 bit fetch */

	/*

	 * Tags used to indicate a specific Pixel Clock

	 *

	 * clk_shift is the shift value to get the timings in 35 ns units

	/*

	 * Tags used to indicate the specific chipset

	/*

	 * Tags used to indicate the memory bandwidth

	/*

	 * Clock Definitions, Maximum Display Depth

	 *

	 * These depend on the E-Clock or the Chipset, so they are filled in

	 * dynamically

 SHRES/HIRES/LORES: index = clk_shift */

 SHRES/HIRES/LORES: index = clk_shift */

	/*

	 * Broadcast Video Timings

	 *

	 * Horizontal values are in 35 ns (SHRES) units

	 * Vertical values are in interlaced scanlines

 PAL Window Limits */

 NTSC Window Limits */

	/*

	 * Various macros

/*

 * FIXME: Use C variants of the code marked with #ifdef __mc68000__

 * in the driver. It shouldn't negatively affect the performance and

 * is required for APUS support (once it is re-added to the kernel).

 * Needs to be tested on the hardware though..

 if x1 is not a constant, this macro won't make real sense :-) */

 We know a bit about the numbers, so we can do it this way */

	/*

	 * Chip RAM we reserve for the Frame Buffer

	 *

	 * This defines the Maximum Virtual Screen Size

	 * (Setable per kernel options?)

 AGA (2MB) : max 1280*1024*256  */

 AGA (1MB) : max 1024*768*256   */

 ECS (2MB) : max 1280*1024*16   */

 ECS (1MB) : max 1024*768*16    */

 OCS       : max ca. 800*600*16 */

 max 64*64*4 */

	/*

	 * This is the earliest allowed start of fetching display data.

	 * Only if you really want no hardware cursor and audio,

	 * set this to 128, but let it better at 192

	/*

	 * Copper Instructions

	/*

	 * Hardware Cursor API Definitions

	 * These used to be in linux/fb.h, but were preliminary and used by

	 * amifb only anyway

 width and height of the cursor in */

 pixels (zero if no cursor)	*/

 cursor size in display pixels */

 colormap entry for cursor color1 */

 colormap entry for cursor color2 */

 field with [height][width]        */

	/*

	 * Hardware Cursor

 Number of frames/flash toggle */

	/*

	 * Current Video Mode

 General Values */

 vmode */

 vmode */

 vmode */

 vmode */

 vmode */

 vmode */

 vmode */

 vmode */

 vmode */

 vmode */

 vmode */

 vmode */

 vmode */

 vmode */

 modulo for next line */

 modulo for next plane */

 Cursor Values */

 movecursor */

 movecursor */

 OCS Hardware Registers */

 vmode, pan (Note: physical address) */

 vmode, pan (Note: physical address) */

 vmode */

 vmode */

 vmode */

 vmode */

 Additional ECS Hardware Registers */

 vmode */

 vmode */

 vmode */

 vmode */

 vmode */

 vmode */

 vmode */

 vmode */

 vmode */

 vmode */

 vmode */

 Additional AGA Hardware Registers */

 vmode */

	/*

	 *  Saved color entry 0 so we can restore it when unblanking

	/*

	 * Latches for Display Changes during VBlank

 Change the Video Mode */

 Update the Video Mode */

 (Un)Blank the Screen (±1) */

 Move the Cursor */

	/*

	 * Various Flags

 Screen is Blanked */

 Screen is laced */

	/*

	 * Predefined Video Modes

	 *

	/*

	 *  AmigaOS Video Modes

	 *

	 *  If you change these, make sure to update DEFMODE_* as well!

 640x200, 15 kHz, 60 Hz (NTSC) */

 640x400, 15 kHz, 60 Hz interlaced (NTSC) */

 640x256, 15 kHz, 50 Hz (PAL) */

 640x512, 15 kHz, 50 Hz interlaced (PAL) */

 640x480, 29 kHz, 57 Hz */

 640x960, 29 kHz, 57 Hz interlaced */

 640x200, 15 kHz, 72 Hz */

 640x400, 15 kHz, 72 Hz interlaced */

 640x400, 29 kHz, 68 Hz */

 640x800, 29 kHz, 68 Hz interlaced */

 800x300, 23 kHz, 70 Hz */

 800x600, 23 kHz, 70 Hz interlaced */

 640x200, 27 kHz, 57 Hz doublescan */

 640x400, 27 kHz, 57 Hz */

 640x800, 27 kHz, 57 Hz interlaced */

 640x256, 27 kHz, 47 Hz doublescan */

 640x512, 27 kHz, 47 Hz */

 640x1024, 27 kHz, 47 Hz interlaced */

	/*

	 *  VGA Video Modes

 640x480, 31 kHz, 60 Hz (VGA) */

 640x400, 31 kHz, 70 Hz (VGA) */

	/*

	 *  A2024 video modes

	 *  These modes don't work yet because there's no A2024 driver.

 1024x800, 10 Hz */

 1024x800, 15 Hz */

 for mode probing */

	/*

	 * Some default modes

 "pal" for PAL OCS/ECS */

 "ntsc" for NTSC OCS/ECS */

 "pal-lace" for flicker fixed PAL (A3000) */

 "ntsc-lace" for flicker fixed NTSC (A3000) */

 "vga70" for AGA */

 interleaved or normal bitplanes */

 monitor hfreq lower limit (Hz) */

 monitor hfreq upper limit (Hz) */

 monitor vfreq lower limit (Hz) */

 monitor vfreq upper limit (Hz) */

	/*

	 * Macros for the conversion from real world values to hardware register

	 * values

	 *

	 * This helps us to keep our attention on the real stuff...

	 *

	 * Hardware limits for AGA:

	 *

	 *	parameter  min    max  step

	 *	---------  ---   ----  ----

	 *	diwstrt_h    0   2047     1

	 *	diwstrt_v    0   2047     1

	 *	diwstop_h    0   4095     1

	 *	diwstop_v    0   4095     1

	 *

	 *	ddfstrt      0   2032    16

	 *	ddfstop      0   2032    16

	 *

	 *	htotal       8   2048     8

	 *	hsstrt       0   2040     8

	 *	hsstop       0   2040     8

	 *	vtotal       1   4096     1

	 *	vsstrt       0   4095     1

	 *	vsstop       0   4095     1

	 *	hcenter      0   2040     8

	 *

	 *	hbstrt       0   2047     1

	 *	hbstop       0   2047     1

	 *	vbstrt       0   4095     1

	 *	vbstop       0   4095     1

	 *

	 * Horizontal values are in 35 ns (SHRES) pixels

	 * Vertical values are in half scanlines

 bplcon1 (smooth scrolling) */

 diwstrt/diwstop/diwhigh (visible display window) */

 ddfstrt/ddfstop (display DMA) */

 hsstrt/hsstop/htotal/vsstrt/vsstop/vtotal/hcenter (sync timings) */

 hbstrt/hbstop/vbstrt/vbstop (blanking timings) */

 colour */

 sprpos/sprctl (sprite positioning) */

 get current vertical position of beam */

	/*

	 * Copper Initialisation List

	/*

	 * Long Frame/Short Frame Copper List

	 * Don't change the order, build_copper()/rebuild_copper() rely on this

	/*

	 * Pixel modes for Bitplanes and Sprites

  35 ns */

  70 ns */

 140 ns */

  35 ns */

  70 ns */

 140 ns */

	/*

	 * Fetch modes for Bitplanes and Sprites

 1x */

 2x */

 4x */

 1x */

 2x */

 4x */

 --------------------------- Hardware routines --------------------------- */

	/*

	 * Get the video params out of `var'. If a value doesn't fit, round

	 * it up, if it's too big, return -EINVAL.

	/*

	 * Find a matching Pixel Clock

	/*

	 * Check the Geometry Values

	/*

	 * FB_VMODE_SMOOTH_XPAN will be cleared, if one of the following

	 * checks failed and smooth scrolling is not possible

	/*

	 * Vertical and Horizontal Timings

 Initialize sync with some reasonable values for pwrsave */

 PAL video mode */

			/* NTSC video mode

			 * In the AGA chipset seems to be hardware bug with BPC3_BRDRBLNK

			 * and NTSC activated, so than better let diwstop_h <= 1812

 Programmable video mode */

	/*

	 * Checking the DMA timing

	/*

	 * smallest window start value without turn off other dma cycles

	 * than sprite1-7, unless you change min_fstrt

	/*

	 * smallest window start value where smooth scrolling is possible

	/*

	 * Check if there is enough time to update the bitplane pointers for ywrap

	/*

	 * Bitplane calculations and check the Memory Requirements

	/*

	 * Hardware Register Values

	/*

	 * Fill the `var' structure based on the values in `par' and maybe

	 * other values read out of the hardware.

	/*

	 * Update hardware

	/*

	 * Pan or Wrap the Display

	 *

	 * This call looks only at xoffset, yoffset and the FB_VMODE_YWRAP flag

	 * in `var'.

	/*

	 * Change the video mode (called by VBlank interrupt)

	/*

	 * The minimum period for audio depends on htotal

	/*

	 * (Un)Blank the screen (called by VBlank interrupt)

 FIXME: check the return value + test the change */

 FIXME: check the return value + test the change */

	/*

	 * Initialise the Copper Initialisation List

	/*

	 * Rebuild the Copper List

	 *

	 * We only change the things that are not static

	/*

	 * Build the Copper List

	/* Format for monitor capabilities is: <Vmin>;<Vmax>;<Hmin>;<Hmax>

	 * <V*> vertical freq. in Hz

	 * <H*> horizontal freq. in kHz

 Validate wanted screen parameters */

 Encode (possibly rounded) screen parameters */

 Decode wanted screen parameters */

 Set new videomode */

 Set VBlank trigger */

 Update fix for new screen parameters */

 override SCROLL_REDRAW */

	/*

	 * Set a single color register. The values supplied are already

	 * rounded down to the hardware's capabilities (according to the

	 * entries in the var structure). Return != 0 for invalid regno.

	/*

	 * Update the corresponding Hardware Color Register, unless it's Color

	 * Register 0 and the screen is blanked.

	 *

	 * VBlank is switched off to protect bplcon3 or ecs_palette[] from

	 * being changed by ami_do_blank() during the VBlank.

	/*

	 * Blank the display.

	/*

	 * Pan or Wrap the Display

	 *

	 * This call looks only at xoffset, yoffset and the FB_VMODE_YWRAP flag

		/*

		 * TODO: There will be problems when xpan!=1, so some columns

		 * on the right side will never be seen

	/*

	 *  Compose two values, using a bitmask as decision value

	 *  This is equivalent to (a & mask) | (b & ~mask)

	/*

	 *  Unaligned forward bit copy using 32-bit or 64-bit memory accesses

 Same alignment for source and dest

 Single word

 Multiple destination words

 Leading bits

 Main chunk

 Trailing bits

 Different alignment for source and dest

 Single destination word

 Single source word

 Single source word

 2 source words

 Multiple destination words

 Leading bits

 Single source word

 2 source words

 Main chunk

 Trailing bits

 Single source word

 2 source words

	/*

	 *  Unaligned reverse bit copy using 32-bit or 64-bit memory accesses

 Same alignment for source and dest

 Single word

 Multiple destination words

 Leading bits

 Main chunk

 Trailing bits

 Different alignment for source and dest

 Single destination word

 Single source word

 Single source word

 2 source words

 Multiple destination words

 Leading bits

 Single source word

 2 source words

 Main chunk

 Trailing bits

 Single source word

 2 source words

	/*

	 *  Unaligned forward inverting bit copy using 32-bit or 64-bit memory

	 *  accesses

 Same alignment for source and dest

 Single word

 Multiple destination words

 Leading bits

 Main chunk

 Trailing bits

 Different alignment for source and dest

 Single destination word

 Single source word

 Single source word

 2 source words

 Multiple destination words

 Leading bits

 Single source word

 2 source words

 Main chunk

 Trailing bits

 Single source word

 2 source words

	/*

	 *  Unaligned 32-bit pattern fill using 32/64-bit memory accesses

 Single word

 Multiple destination words

 Leading bits

 Main chunk

 Trailing bits

	/*

	 *  Unaligned 32-bit pattern xor using 32/64-bit memory accesses

 Single word

 Multiple destination words

 Leading bits

 Main chunk

 Trailing bits

	/*

	 * We could use hardware clipping but on many cards you get around

	 * hardware clipping by writing to framebuffer directly.

 clip the destination */

 update sx,sy */

 the source must be completely inside the virtual screen */

 set or clear */

	/*

	 * We could use hardware clipping but on many cards you get around

	 * hardware clipping by writing to framebuffer directly like we are

	 * doing here.

	/*

	 * Amiga Frame Buffer Specific ioctls

	/*

	 * Flash the cursor (called by VBlank interrupt)

	/*

	 * VBlank Display Interrupt

	/*

	 * Allocate, Clear and Align a Block of Chip Memory

	/*

	 * Initialisation

 OCS means no SHRES */

 CONFIG_FB_AMIGA_OCS */

 CONFIG_FB_AMIGA_ECS */

 CONFIG_FB_AMIGA_AGA */

 CONFIG_FB_AMIGA_OCS */

 CONFIG_FB_AMIGA_OCS */

	/*

	 * Calculate the Pixel Clock Values for this Machine

 SHRES:  35 ns / 28 MHz */

 HIRES:  70 ns / 14 MHz */

 LORES: 140 ns /  7 MHz */

	/*

	 * Replace the Tag Values with the Real Pixel Clock Values

		/*

		 *  These are for a typical Amiga monitor (e.g. A1960)

	/*

	 * access the videomem with writethrough cache

	/*

	 * Make sure the Copper has something to do

	/*

	 * Enable Display DMA

/*

 * linux/drivers/video/stifb.c - 

 * Low level Frame buffer driver for HP workstations with 

 * STI (standard text interface) video firmware.

 *

 * Copyright (C) 2001-2006 Helge Deller <deller@gmx.de>

 * Portions Copyright (C) 2001 Thomas Bogendoerfer <tsbogend@alpha.franken.de>

 * 

 * Based on:

 * - linux/drivers/video/artistfb.c -- Artist frame buffer driver

 *	Copyright (C) 2000 Philipp Rumpf <prumpf@tux.org>

 *   - based on skeletonfb, which was

 *	Created 28 Dec 1997 by Geert Uytterhoeven

 * - HP Xhp cfb-based X11 window driver for XFree86

 *	(c)Copyright 1992 Hewlett-Packard Co.

 *

 * 

 *  The following graphics display devices (NGLE family) are supported by this driver:

 *

 *  HPA4070A	known as "HCRX", a 1280x1024 color device with 8 planes

 *  HPA4071A	known as "HCRX24", a 1280x1024 color device with 24 planes,

 *		optionally available with a hardware accelerator as HPA4071A_Z

 *  HPA1659A	known as "CRX", a 1280x1024 color device with 8 planes

 *  HPA1439A	known as "CRX24", a 1280x1024 color device with 24 planes,

 *		optionally available with a hardware accelerator.

 *  HPA1924A	known as "GRX", a 1280x1024 grayscale device with 8 planes

 *  HPA2269A	known as "Dual CRX", a 1280x1024 color device with 8 planes,

 *		implements support for two displays on a single graphics card.

 *  HP710C	internal graphics support optionally available on the HP9000s710 SPU,

 *		supports 1280x1024 color displays with 8 planes.

 *  HP710G	same as HP710C, 1280x1024 grayscale only

 *  HP710L	same as HP710C, 1024x768 color only

 *  HP712	internal graphics support on HP9000s712 SPU, supports 640x480, 

 *		1024x768 or 1280x1024 color displays on 8 planes (Artist)

 *

 * This file is subject to the terms and conditions of the GNU General Public

 * License.  See the file COPYING in the main directory of this archive

 * for more details.

/* TODO:

 *	- 1bpp mode is completely untested

 *	- add support for h/w acceleration

 *	- add hardware cursor

 *	- automatically disable double buffering (e.g. on RDI precisionbook laptop)

/* on supported graphic devices you may:

 * #define FALLBACK_TO_1BPP to fall back to 1 bpp, or

 debug sti register accesses */

 for HP-UX compatibility */

 REGION_BASE(fb_info, index) returns the virtual address for region <index> */

 visible screen dim in pixels  */

 ------------------- chipset specific functions -------------------------- */

 offsets to graphic-chip internal registers */

 DEBUG_STIFB_REGS */

 for enabling/disabling screen */	

 Pixel data is indexed (pseudo) color */

 Pixels in each longword transfer (4) */

 Pixels in each longword transfer (32) */

 Each pixel is size (8)d transfer (1) */

 Each bit goes through FG/BG color(8) */

 FB address is Long aligned (pixel) */

 8 bit overlay */

 Application Buffer 0, Indexed */

 Application Buffer 1, Indexed */

 Application Buffer 0, Fractional 8-8-8 */

 Attribute Bitmap */

 Each write hits ( 8) bits in depth */

 Each write hits (32) bits in depth */

 Data register reloaded by direct access */

 Mask register reloaded by direct access */

 Mask contains Object Count valid bits */

 BufferNumbers used by SETUP_ATTR_ACCESS() */

	/* REG_6 seems to have special values when run on a 

	   RDI precisionbook parisc laptop (INTERNAL_EG_DX1024 or

	   INTERNAL_EG_X1024).  The values are:

		0x2f0: internal (LCD) & external display enabled

		0x2a0: external display only

		0x000: zero on standard artist graphic cards

 	/* Write RAMDAC pixel read mask register so all overlay

	 * planes are display-enabled.  (CRX24 uses Bt462 pixel

	 * read mask register for overlay planes, not image planes).

 change fb->id temporarily to fool SETUP_FB() */

 typedef of LUT (Colormap) BLT Control Register */

 Note assumption that fields are packed left-to-right */

 Within destination LUT */

 Cursor, image, overlay */

 set enable, zero reserved fields */

 CRX24 */

 Offset points to start of LUT.  Adjust for within LUT */

 set enable, zero reserved fields */

 Expect lutIndex to be 0 or 1 for image cmaps, 2 or 3 for overlay cmaps */

 Offset points to start of LUT.  Adjust for within LUT */

 Write overlay transparency mask so only entry 255 is transparent */

 Hardware setup for full-depth write to "magic" location */

 Now prepare to write to the "magic" location */

 Finally, write a zero to clear the mask */

 FIXME! */

 FIXME! */

	/*

	 * In order to work around an ELK hardware problem (Buffy doesn't

	 * always flush it's buffers when writing to the attribute

	 * planes), at least 4 pixels must be written to the attribute

	 * planes starting at (X == 1280) and (Y != to the last Y written

	 * by BIF):

 ELK_DEVICE_ID */

 It's safe to use scanline zero: */

 ELK Hardware Kludge */

*** Finally, set the Control Plane Register back to zero: ****/

 Hardware setup */

 Write foreground color */

 Write zeroes to overlay planes */		       

 0x00000800 should be enough, but lets clear all 4 bits */

 0x00000100 should be enough, but lets clear all 4 bits */

 clear screen */

		/* Paint attribute planes for default case.

 clear overlay planes */

		/**************************************************

		 ** Also need to counteract ITE settings 

 clear screen */

 RESET */

 Return pointer to in-memory structure holding ELK device-dependent ROM values. */

 data byte == LSB */

 Get pointer to unpacked byte/long data in ROM */

 Tomcat supports several resolutions: 1280x1024, 1024x768, 640x480 */

  jump to the correct ROM table  */

 Pack every fourth byte from ROM into structure */

 Pack every fourth byte from ROM into structure */

 HCRX specific boot-time initialization */

 Initialize Hyperbowl registers */

 First write to Hyperbowl must happen twice (bug) */

 Set lut 0 to be the direct color */

 First write to Hyperbowl must happen twice (bug) */

 ------------------- driver specific functions --------------------------- */

 gray = 0.30*R + 0.59*G + 0.11*B */

 Offset w/i LUT */

 Load entire LUT */

 0x100 is same as used in WRITE_IMAGE_COLOR() */

 cleanup colormap hardware */

 HCRX specific initialization */

	/*

	if (id == S9000_ID_HCRX)

		hyperInitSprite(fb);

	else

		ngleInitSprite(fb);

 Initialize the image planes. */ 

 Clear attribute planes on non HCRX devices. */

 0=enable screen */

 ------------ Interfaces to hardware functions ------------ */

/*

 *  Initialization

 set struct to a known state */

 store upper 32bits of the graphics id */

 only supported cards are allowed */

		/* Visualize cards can run either in "double buffer" or

 		  "standard" mode. Depending on the mode, the card reports

		  a different device name, e.g. "INTERNAL_EG_DX1024" in double

		  buffer mode and "INTERNAL_EG_X1024" in standard mode.

		  Since this driver only supports standard mode, we check

		  if the device name contains the string "DX" and tell the

 default to 8 bpp on most graphic chips */

 get (virtual) io region base addr */

 Reject any device not in the NGLE family */

 CRX/A1659A */

 GRX, grayscale but else same as A1659A */

 HP9000/710 Any (may be a grayscale device) */

 Dual CRX, behaves else like a CRX */

		/* FIXME: TomCat supports two heads:

		 * fb.iobase = REGION_BASE(fb_info,3);

		 * fb.screen_base = ioremap(REGION_BASE(fb_info,2),xxx);

 CRX24/A1439A */

 Hyperdrive/HCRX */

 Artist */

 default to 1 bpp */

 get framebuffer physical and virtual base addr & len (64bit ready) */

 default */

 limit fbsize to max visible screen size */

 well, sort of */

 This has to be done !!! */

 save for unregister_framebuffer() */

/*

 *  Cleanup

 SPDX-License-Identifier: GPL-2.0-only

/* cg14.c: CGFOURTEEN frame buffer driver

 *

 * Copyright (C) 2003, 2006 David S. Miller (davem@davemloft.net)

 * Copyright (C) 1996,1998 Jakub Jelinek (jj@ultra.linux.cz)

 * Copyright (C) 1995 Miguel de Icaza (miguel@nuclecu.unam.mx)

 *

 * Driver layout based loosely on tgafb.c, see that file for credits.

/*

 * Local functions.

/*

 *  Frame buffer operations

 Master Control Reg */

 Packed Pixel Reg */

 Test Mode Status Regs */

 Master Status Reg */

 Fault Status Reg */

 Revision & Impl */

 Clock Control Reg */

 Test Mode Read Back */

 Monitor Operation Data Reg */

 Aux Control */

 Hor Counter */

 Vert Counter */

 Hor Blank Start */

 Hor Blank Clear */

 Hor Sync Start */

 Hor Sync Clear */

 Composite Sync Clear */

 Vert Blank Start */

 Vert Blank Clear */

 Vert Sync Start */

 Vert Sync Clear */

 Fault Status Address */

 Address Registers */

 Pixel Clock Generator */

 Frame Base Row */

 VBC Master Control */

 VBC refresh */

 VBC Config */

 HW/Full screen */

 Enable plane 0 */

 Color selection plane */

 Cursor Control Reg */

 Cursor x,y position */

 Cursor x,y position */

 Enable plane 0 autoinc */

 Color selection autoinc */

 Address Register */

 Gamma table */

 Register Select */

 Mode Register */

 Color look up table (clut) */

/* Each one of these arrays hold the color lookup table (for 256

 * colors) for each MDI page (I assume then there should be 4 MDI

 * pages, I still wonder what they are.  I have seen NeXTStep split

 * the screen in four parts, while operating in 24 bits mode.  Each

 * integer holds 4 values: alpha value (transparency channel, thanks

 * go to John Stone (johns@umr.edu) from OpenBSD), red, green and blue

 *

 * I currently use the clut instead of the Xlut

 i wonder what the 'd' is for */

	/* We just use this to catch switches out of

	 * graphics mode.

/**

 *      cg14_setcolreg - Optional function. Sets a color register.

 *      @regno: boolean, 0 copy local, 1 get_user() function

 *      @red: frame buffer colormap structure

 *      @green: The green value which can be up to 16 bits wide

 *      @blue:  The blue value which can be up to 16 bits wide.

 *      @transp: If supported the alpha value which can be up to 16 bits wide.

 *      @info: frame buffer info structure

 FIXME */

/*

 *  Initialisation

/*

 *  linux/drivers/video/arkfb.c -- Frame buffer device driver for ARK 2000PV

 *  with ICS 5342 dac (it is easy to add support for different dacs).

 *

 *  Copyright (c) 2007 Ondrej Zajicek <santiago@crfreenet.org>

 *

 *  This file is subject to the terms and conditions of the GNU General Public

 *  License.  See the file COPYING in the main directory of this archive for

 *  more details.

 *

 *  Code is based on s3fb

 Why should fb driver call console functions? because console_lock() */

 ------------------------------------------------------------------------- */

 CRT timing register sets */

 const struct vga_regset ark_v_blank_end_regs[]    = {{0x16, 0, 6}, VGA_REGSET_END};

 ------------------------------------------------------------------------- */

 Module parameters */

 ------------------------------------------------------------------------- */

 ------------------------------------------------------------------------- */

 image data is MSB-first, fb structure is MSB-first too */

 arkfb_iplan_imageblit silently assumes that almost everything is 8-pixel aligned */

 arkfb_iplan_fillrect silently assumes that almost everything is 8-pixel aligned */

 image data is MSB-first, fb structure is high-nibble-in-low-byte-first */

 arkfb_cfb4_imageblit silently assumes that almost everything is 8-pixel aligned */

 ------------------------------------------------------------------------- */

 ------------------------------------------------------------------------- */

 ICS5342 DAC */

 LSB is set to distinguish unused slots */

 pd4 - allow only posdivider 4 (r=2) */

/* 270 MHz should be upper bound for VCO clock according to specs,

 only postdivider 4 (r=2) is valid in mode DAC_PSEUDO8_16 */

 estimation */

 ------------------------------------------------------------------------- */

 Set VGA misc register  */

 Open framebuffer */

 Close framebuffer */

 Validate passed in var */

 Find appropriate format */

 Do not allow to have real resoulution larger than virtual */

 Round up xres_virtual to have proper alignment of lines */

 Check whether have enough memory */

 Interlaced mode is broken */

 Set video mode from par */

 in 4bpp supports 8p wide tiles only, any tiles otherwise */

 supports 8x16 tiles only */

 Unlock registers */

 Blank screen and turn off sync */

 Set default values */

 ARK specific initialization */

 enable linear framebuffer and full memory access */

 4 MB linear framebuffer size */

 Set the FIFO threshold register */

 It is fascinating way to store 5-bit value in 8-bit register */

 Set the offset register */

 fix for hi-res textmode */

 Set mode-specific register values */

 basic VGA mode */

 8bit pixel path */

 basic VGA mode */

 8bit pixel path */

 basic VGA mode */

 8bit pixel path */

 8bpp accel mode */

 8bit pixel path */

 16bit pixel path */

 16bpp accel mode */

 16bit pixel path */

 16bpp accel mode */

 16bit pixel path */

 8bpp accel mode ??? */

 16bit pixel path */

 32bpp accel mode */

 16bit pixel path */

 Set interlaced mode start/end register */

 Device and screen back on */

 Set a colour register */

 Set the display blanking state */

 Pan the display */

 Calculate the offset */

 Set the offset */

 ------------------------------------------------------------------------- */

 Frame buffer operations */

 ------------------------------------------------------------------------- */

 PCI probe */

 Ignore secondary VGA device because there is no VGA arbitration */

 Allocate and fill driver data structure */

 Prepare PCI device */

 Map physical IO memory address into kernel space */

 FIXME get memsize */

 Prepare startup mode */

 Record a reference to the driver data */

 Error handling */

	pci_disable_device(dev); */

 PCI remove */

		pci_disable_device(dev); */

 PCI suspend */

 PCI resume */

 List of boards that we are trying to support */

 Cleanup */

 Driver Initialisation */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2012, Microsoft Corporation.

 *

 * Author:

 *   Haiyang Zhang <haiyangz@microsoft.com>

/*

 * Hyper-V Synthetic Video Frame Buffer Driver

 *

 * This is the driver for the Hyper-V Synthetic Video, which supports

 * screen resolution up to Full HD 1920x1080 with 32 bit color on Windows

 * Server 2012, and 1600x1200 with 16 bit color on Windows Server 2008 R2

 * or earlier.

 *

 * It also solves the double mouse cursor issue of the emulated video mode.

 *

 * The default screen resolution is 1152x864, which may be changed by a

 * kernel parameter:

 *     video=hyperv_fb:<width>x<height>

 *     For example: video=hyperv_fb:1280x1024

 *

 * Portrait orientation is also supported:

 *     For example: video=hyperv_fb:864x1152

 *

 * When a Windows 10 RS5+ host is used, the virtual machine screen

 * resolution is obtained from the host. The "video=hyperv_fb" option is

 * not needed, but still can be used to overwrite what the host specifies.

 * The VM resolution on the host could be set by executing the powershell

 * "set-vmvideo" command. For example

 *     set-vmvideo -vmname name -horizontalresolution:1920 \

 * -verticalresolution:1200 -resolutiontype single

 *

 * Gen 1 VMs also support direct using VM's physical memory for framebuffer.

 * It could improve the efficiency and performance for framebuffer and VM.

 * This requires to allocate contiguous physical memory from Linux kernel's

 * CMA memory allocator. To enable this, supply a kernel parameter to give

 * enough memory space to CMA allocator for framebuffer. For example:

 *    cma=130m

 * This gives 130MB memory to CMA allocator that can be allocated to

 * framebuffer. For reference, 8K resolution (7680x4320) takes about

 * 127MB memory.

 Hyper-V Synthetic Video Protocol definitions and structures */

 size of message after this field */

 size of this header + payload after this field*/

 CURSOR_MAX_X at most */

 CURSOR_MAX_Y at most */

 hotspot relative to upper-left of pointer image */

 top left corner */

 bottom right corner, exclusive */

 FB driver definitions and structures */

 default screen width */

 default screen height */

 fb device is ready */

 The value of 'update' before hibernation */

 If true, the VSC notifies the VSP on every framebuffer change */

 If true, need to copy from deferred IO mem to framebuffer mem */

 Memory for deferred IO and frame buffer itself */

 Dirty rectangle, protected by delayed_refresh_lock */

 FB size for deferred IO */

 Send message to Hyper-V host */

 Send screen resolution info to host */

 Send mouse pointer info to host */

 Send updated screen area (dirty rectangle) location to host */

 Deferred IO callback */

	/*

	 * Merge dirty pages. It is possible that last page cross

	 * over the end of frame buffer row yres. This is taken care of

	 * in synthvid_update function by clamping the y2

	 * value to yres.

 Copy from dio space to mmio address */

/*

 * Actions on received messages from host:

 * Complete the wait event.

 * Or, reply with screen and cursor info.

 Complete the wait event */

 Reply with screen and cursor info */

 Receive callback for messages from the host */

 Check if the ver1 version is equal or greater than ver2 */

 Check synthetic video protocol version with the host */

 Get current resolution from the host */

 Connect to VSP (Virtual Service Provider) on host */

 Negotiate the protocol version with host */

 Send VRAM and Situation messages to the host */

 Send VRAM location */

 Send pointer and situation update */

/*

 * Delayed work callback:

 * It is scheduled to call whenever update request is received and it has

 * not been called in last HVFB_ONDEMAND_THROTTLE time interval.

 Reset the request flag */

 Store the dirty rectangle to local variables */

 Clear dirty rectangle */

 Copy the dirty rectangle to frame buffer memory */

 Refresh */

/*

 * Control the on-demand refresh frequency. It schedules a delayed

 * screen update if it has not yet.

 Merge dirty rectangle */

 Schedule a delayed screen update if not yet */

 Framebuffer operation handlers */

 get fb_blank to set the colormap to all black */

 Get options from kernel paramenter "video=" */

/*

 * Allocate enough contiguous physical memory.

 * Return physical address if succeeded or -1 if failed.

 Call alloc_pages if the size is less than 2^MAX_ORDER */

 Allocate from CMA */

 Release contiguous physical memory */

 Get framebuffer memory from Hyper-V video pci space */

		/*

		 * For Gen 1 VM, we can directly use the contiguous memory

		 * from VM. If we succeed, deferred IO happens directly

		 * on this allocated framebuffer memory, avoiding extra

		 * memory copy.

	/*

	 * Cannot use the contiguous physical memory.

	 * Allocate mmio space for framebuffer.

	/*

	 * Map the VRAM cacheable for performance. This is also required for

	 * VM Connect to display properly for ARM64 Linux VM, as the host also

	 * maps the VRAM cacheable.

 Allocate memory for deferred IO */

 Physical address of FB device */

 Virtual address of FB device */

 framebuffer is reallocated, clear screen_info to avoid misuse from kexec */

 Release the framebuffer */

 Connect to VSP */

 Set up fb_info */

 Initialize deferred IO */

 Send config to host */

 1 means do suspend */

 0 means do resume */

 end of list */ }

 Synthetic Video Device GUID */

/*

 *	linux/drivers/video/pmag-ba-fb.c

 *

 *	PMAG-BA TURBOchannel Color Frame Buffer (CFB) card support,

 *	derived from:

 *	"HP300 Topcat framebuffer support (derived from macfb of all things)

 *	Phil Blundell <philb@gnu.org> 1998", the original code can be

 *	found in the file hpfb.c in the same directory.

 *

 *	Based on digital document:

 * 	"PMAG-BA TURBOchannel Color Frame Buffer

 *	 Functional Specification", Revision 1.2, August 27, 1990

 *

 *	DECstation related code Copyright (C) 1999, 2000, 2001 by

 *	Michael Engel <engel@unix-ag.org>,

 *	Karsten Merker <merker@linuxtag.org> and

 *	Harald Koerfgen.

 *	Copyright (c) 2005, 2006  Maciej W. Rozycki

 *	Copyright (c) 2005  James Simmons

 *

 *	This file is subject to the terms and conditions of the GNU General

 *	Public License.  See the file COPYING in the main directory of this

 *	archive for more details.

/*

 * Set the palette.

 The cmap fields are 16 bits    */

 wide, but the hardware colormap */

 registers are only 8 bits wide */

/*

 * Turn the hardware cursor off.

 Request the I/O MEM resource.  */

 MMIO mapping setup.  */

 Frame buffer mapping setup.  */

/*

 * Initialize the framebuffer.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * linux/drivers/video/sstfb.c -- voodoo graphics frame buffer

 *

 *     Copyright (c) 2000-2002 Ghozlane Toumi <gtoumi@laposte.net>

 *

 *     Created 15 Jan 2000 by Ghozlane Toumi

 *

 * Contributions (and many thanks) :

 *

 * 03/2001 James Simmons   <jsimmons@infradead.org>

 * 04/2001 Paul Mundt      <lethal@chaoticdreams.org>

 * 05/2001 Urs Ganse       <ursg@uni.de>

 *	(initial work on voodoo2 port, interlace)

 * 09/2002 Helge Deller    <deller@gmx.de>

 *	(enable driver on big-endian machines (hppa), ioctl fixes)

 * 12/2002 Helge Deller    <deller@gmx.de>

 *	(port driver to new frambuffer infrastructure)

 * 01/2003 Helge Deller    <deller@gmx.de>

 *	(initial work on fb hardware acceleration for voodoo2)

 * 08/2006 Alan Cox 	   <alan@redhat.com>

 *	Remove never finished and bogus 24/32bit support

 *	Clean up macro abuse

 *	Minor tidying for format.

 * 12/2006 Helge Deller    <deller@gmx.de>

 *	add /sys/class/graphics/fbX/vgapass sysfs-interface

 *	add module option "mode_option" to set initial screen mode

 *	use fbdev default videomode database

 *	remove debug functions from ioctl

/*

 * The voodoo1 has the following memory mapped address space:

 * 0x000000 - 0x3fffff : registers              (4MB)

 * 0x400000 - 0x7fffff : linear frame buffer    (4MB)

 * 0x800000 - 0xffffff : texture memory         (8MB)

/*

 * misc notes, TODOs, toASKs, and deep thoughts



-TODO: at one time or another test that the mode is acceptable by the monitor

-ASK: Can I choose different ordering for the color bitfields (rgba argb ...)

      which one should i use ? is there any preferred one ? It seems ARGB is

      the one ...

-TODO: in  set_var check the validity of timings (hsync vsync)...

-TODO: check and recheck the use of sst_wait_idle : we don't flush the fifo via

       a nop command. so it's ok as long as the commands we pass don't go

       through the fifo. warning: issuing a nop command seems to need pci_fifo

-FIXME: in case of failure in the init sequence, be sure we return to a safe

        state.

- FIXME: Use accelerator for 2D scroll

-FIXME: 4MB boards have banked memory (FbiInit2 bits 1 & 20)

/*

 * debug info

 * SST_DEBUG : enable debugging

 * SST_DEBUG_REG : debug registers

 *   0 :  no debug

 *   1 : dac calls, [un]set_bits, FbiInit

 *   2 : insane debug level (log every register read/write)

 * SST_DEBUG_FUNC : functions

 *   0 : no debug

 *   1 : function call / debug ioctl

 *   2 : variables

 *   3 : flood . you don't want to do that. trust me.

 * SST_DEBUG_VAR : debug display/var structs

 *   0 : no debug

 *   1 : dumps display, fb_var

 *

 * sstfb specific ioctls:

 *   		toggle vga (0x46db) : toggle vga_pass_through

/*

 * Includes

 initialized by setup */

 enable VGA passthrough cable */

 mem size in MB, 0 = autodetect */

 use clipping (slower, safer) */

 force FBI freq in Mhz . Dangerous */

 slow PCI settings */

/*

  Possible default video modes: 800x600@60, 640x480@75, 1024x768@76, 640x480@60

/*

 * debug functions

  (SST_DEBUG_REG > 0) */

  (SST_DEBUG_REG > 0) */

/*

 * hardware access functions

 register access */

/*

 * wait for the fbi chip. ASK: what happens if the fbi is stuck ?

 *

 * the FBI is supposed to be ready if we receive 5 time

 * in a row a "idle" answer to our requests

 if (doFBINOP) __sst_write(vbase, NOPCMD, 0); */

/* FIXME basically, this is a busy wait. maybe not that good. oh well;

 * this is a small loop after all.

 XXX  do something to avoid hanging the machine if the voodoo is out */

 dac access */

 dac_read should be remaped to FbiInit2 (via the pci reg init_enable) */

 udelay(10); */

 indexed access to ti/att dacs */

/* compute the m,n,p  , returns the real freq

 * (ics datasheet :  N <-> N1 , P <-> N2)

 *

 * Fout= Fref * (M+2)/( 2^P * (N+2))

 *  we try to get close to the asked freq

 *  with P as high, and M as low as possible

 * range:

 * ti/att : 0 <= M <= 255; 0 <= P <= 3; 0<= N <= 63

 * ics    : 1 <= M <= 127; 0 <= P <= 3; 1<= N <= 31

 * we'll use the lowest limitation, should be precise enouth

 f * 2^P = vco should be less than VCOmax ~ 250 MHz for ics*/

 calc 2 * m so we can round it later*/

 we get the lowest m , allowing 0.5% error in freq*/

 unlikely, but who knows ? */

/*

 * clear lfb screen

 clear screen */

/**

 *      sstfb_check_var - Optional function.  Validates a var passed in.

 *      @var: frame buffer variable screen structure

 *      @info: frame buffer structure that represents a single frame buffer

 *

 *	Limit to the abilities of a single chip as SLI is not supported

 *	by this driver.

 validity tests */

 Voodoo 2 limits */

 Voodoo limits */

 it seems that the fbi uses tiles of 64x16 pixels to "map" the mem */

 FIXME: i don't like this... looks wrong */

	/*

	 * correct the color bit fields

 var->{red|green|blue}.msb_right = 0; */

 RGB 565  LfbMode 0 */

/**

 *      sstfb_set_par - Optional function.  Alters the hardware state.

 *      @info: frame buffer structure that represents a single frame buffer

 We need par->pll */

		/* voodoo2 has 32 pixel wide tiles , BUT strange things

 voodoo1 has 64 pixels wide tiles. */

sst_unset_bits (FBIINIT0, FBI_RESET); / reenable FBI ? */

 everything is reset. we enable fbiinit2/3 remap : dac access ok */

 set video clock */

 disable fbiinit2/3 remap */

 restore fbiinit2/3 */

 | (15 << TILES_IN_X_SHIFT) */

		 /* | (2 << VCLK_2X_SEL_DEL_SHIFT)

/* try with vclk_in_delay =0 (bits 29:30) , vclk_out_delay =0 (bits(27:28)

 in (near) future set them accordingly to revision + resolution (cf glide)

 first understand what it stands for :)

 FIXME: there are some artefacts... check for the vclk_in_delay

 lets try with 6ns delay in both vclk_out & in...

 doh... they're still there :\

/* as the only value of importance for us in fbiinit6 is tiles in X (lsb),

   and as reading fbinit 6 will return crap (see FBIINIT6_DEFAULT) we just

   write our value. BTW due to the dac unable to read odd number of tiles, this

 disables fbiinit writes */

	/* set lfbmode : set mode + front buffer for reads/writes

	/* Enable byte-swizzle functionality in hardware.

	 * With this enabled, all our read- and write-accesses to

	 * the voodoo framebuffer can be done in native format, and

	 * the hardware will automatically convert it to little-endian.

	/*

	 * Set "clipping" dimensions. If clipping is disabled and

	 * writes to offscreen areas of the framebuffer are performed,

	 * the "behaviour is undefined" (_very_ undefined) - Urs

	/* btw, it requires enabling pixel pipeline in LFBMODE .

	   off screen read/writes will just wrap and read/print pixels

 no clipping : direct access, no pipeline */

/**

 *      sstfb_setcolreg - Optional function. Sets a color register.

 *      @regno: hardware colormap register

 *      @red: frame buffer colormap structure

 *      @green: The green value which can be up to 16 bits wide

 *      @blue:  The blue value which can be up to 16 bits wide.

 *      @transp: If supported the alpha value which can be up to 16 bits wide.

 *      @info: frame buffer info structure

 set/get VGA pass_through mode */

/*

 * Screen-to-Screen BitBlt 2D command (for the bmove fb op.) - Voodoo2 only

 | BIT(14) */ | BIT(15) );

/*

 * FillRect 2D command (solidfill or invert (via ROP_XOR)) - Voodoo2 only

 | BIT(14) */ | BIT(15) | BIT(16) );

/* 

 * get lfb size 

 force memsize */

 checks for 4mb lfb, then 2, then defaults to 1 */

/* 

 * DAC detection routines 

 fbi should be idle, and fifo emty and mem disabled */

 supposed to detect AT&T ATT20C409 and Ti TVP3409 ramdacs */

 backdoor */

 read 4 times RMR */

 the fifth time,  CR0 is read */

 the 6th, manufacturer id register */

the 7th, device ID register */

 backdoor */

 read 4 times RMR */

 the fifth time,  CR0 is read */

 the 6th, manufacturer id register */

the 7th, device ID register */

/*

 * try to detect ICS5342  ramdac

 * we get the 1st byte (M value) of preset f1,f7 and fB

 * why those 3 ? mmmh... for now, i'll do it the glide way...

 * and ask questions later. anyway, it seems that all the freq registers are

 * really at their default state (cf specs) so i ask again, why those 3 regs ?

 * mmmmh.. it seems that's much more ugly than i thought. we use f0 and fA for

 * pll programming, so in fact, we *hope* that the f1, f7 & fB won't be

 * touched...

 * is it really safe ? how can i reset this ramdac ? geee...

 f1 */

 f7 */

 fB */

/*

 * gfx, video, pci fifo should be reset, dram refresh disabled

 * see detect_dac

 enable indexed mode */

 backdoor */

 1 time:  RMR */

 2 RMR */

  */

  */

 5 CR0 */

	/* so, now we are in indexed mode . dunno if its common, but

 power up the dac & return to "normal" non-indexed mode */

 CLK0, f0 */

 selects freq f0 for clock 0 */

 CLK1, fA */

 selects freq fA for clock 1 */

 backdoor */

 read 4 times RMR */

 the fifth time,  CR0 is read */

 backdoor */

 read 4 times RMR */

 cr0 */

/*

 * detect dac type

 * prerequisite : write to FbiInitx enabled, video and fbi and pci fifo reset,

 * dram refresh disabled, FbiInit remaped.

 * TODO: mmh.. maybe i should put the "prerequisite" in the func ...

/*

 * Internal Routines

 disable video clock */

 enable writing to init registers, disable pci fifo */

 reset video */

 reset gfx + pci fifo */

 unreset fifo */

	/*sst_unset_bits(FBIINIT0, FIFO_RESET);

 unreset FBI */

	/*sst_unset_bits(FBIINIT0, FBI_RESET);

 disable dram refresh */

 remap fbinit2/3 to dac */

 detect dac type */

FIXME watch it: we are not in a safe state, bad bad bad.

 set graphic clock */

 disable fbiinit remap */

 defaults init registers */

 FbiInit0: unreset gfx, unreset fifo */

 reset video, gfx, fifo, disable dram + remap fbiinit2/3 */

 set 20Mhz gfx clock */

 TODO maybe shutdown the dac, vrefresh and so on... */

	/* maybe keep fbiinit* and PCI_INIT_enable in the fb_info struct

/*

 * Interface to the world

 sstfb_fillrect */

 sstfb_copyarea */

 Enable device in PCI config. */

 Allocate the fb and par structures.  */

 FIXME */

	/*

	 * According to the specs, the linelength must be of 1024 *pixels*

	 * and the 24bpp mode is in fact a 32 bpp mode (and both are in

	 * fact dithered to 16bit).

 default value, for 24 or 32bit: 4096 */

 register fb */

 no voodoo detected */

/*

 *      linux/drivers/video/maxinefb.c

 *

 *	DECstation 5000/xx onboard framebuffer support ... derived from:

 *	"HP300 Topcat framebuffer support (derived from macfb of all things)

 *	Phil Blundell <philb@gnu.org> 1998", the original code can be

 *      found in the file hpfb.c in the same directory.

 *

 *      DECstation related code Copyright (C) 1999,2000,2001 by

 *      Michael Engel <engel@unix-ag.org> and

 *      Karsten Merker <merker@linuxtag.org>.

 *      This file is subject to the terms and conditions of the GNU General

 *      Public License.  See the file COPYING in the main directory of this

 *      archive for more details.

 *

/*

 * Changes:

 * 2001/01/27 removed debugging and testing code, fixed fb_ops

 *            initialization which had caused a crash before,

 *            general cleanup, first official release (KM)

 *

 bootinfo.h defines the machine type values, needed when checking */

 whether are really running on a maxine, KM                       */

 Handle the funny Inmos RamDAC/video controller ... */

 Set the palette */

 value to be written into the palette reg. */

 The cmap fields are 16 bits    */

 wide, but the harware colormap */

 registers are only 8 bits wide */

 Validate we're on the proper machine type */

 Framebuffer display memory base address */

 Clear screen */

 erase hardware cursor */

		/*

		   if (i&0x8 == 0)

		   maxinefb_ims332_write_register (IMS332_REG_CURSOR_RAM + i, 0x0f);

		   else

		   maxinefb_ims332_write_register (IMS332_REG_CURSOR_RAM + i, 0xf0);

 SPDX-License-Identifier: GPL-2.0-only

/*

 * smscufx.c -- Framebuffer driver for SMSC UFX USB controller

 *

 * Copyright (C) 2011 Steve Glendinning <steve.glendinning@shawell.net>

 * Copyright (C) 2009 Roberto De Ioris <roberto@unbit.it>

 * Copyright (C) 2009 Jaya Kumar <jayakumar.lkml@gmail.com>

 * Copyright (C) 2009 Bernie Thompson <bernie@plugable.com>

 *

 * Based on udlfb, with work from Florian Echtler, Henrik Bjerregaard Pedersen,

 * and others.

 *

 * Works well with Bernie Thompson's X DAMAGE patch to xf86-video-fbdev

 * available from http://git.plugable.com

 *

 * Layout is based on skeletonfb by James Simmons and Geert Uytterhoeven,

 * usb-skeleton by GregKH.

/*

 * TODO: Propose standard fb.h ioctl for reporting damage,

 * using _IOWR() and one of the existing area structs from fb.h

 * Consider these ioctls deprecated, but they're still used by the

 * DisplayLink X server as yet - need both to be modified in tandem

 * when new ioctl(s) are ready.

 -BULK_SIZE as per usb-skeleton. Can we get full page and avoid overhead? */

 fb_deferred_io.delay in jiffies */

 "disable" with long delay */

 &udev->dev */

 true when physical usb device not present */

 0 = update virtual buffer, but no usb traffic */

 1 = a render op failed. Need screen refresh */

 null until we read edid from hw or get from sysfs */

 module options */

 Optionally allow fbcon to consume first framebuffer */

 Optionally enable fb_defio mmap support */

 ufx keeps a list of urbs for efficient bulk transfers */

 reads a control register */

 writes a control register */

 If display is unblanked, then blank it */

 return success if display is already blanked */

 request the DC to blank the display */

 return success immediately if we don't have to wait */

 timed out waiting for display to blank */

 If display is blanked, then unblank it */

 return success if display is already unblanked */

 request the DC to unblank the display */

 return success immediately if we don't have to wait */

 timed out waiting for display to unblank */

 If display is enabled, then disable it */

 return success if display is already disabled */

 request the DC to disable the display */

 return success immediately if we don't have to wait */

 timed out waiting for display to disable */

 If display is disabled, then enable it */

 return success if display is already enabled */

 request the DC to enable the display */

 return success immediately if we don't have to wait */

 timed out waiting for display to enable */

 calculates PLL divider settings for a desired target frequency */

								/* final returned value is equal to calculated value - 1

 sets analog bit PLL configuration values */

 convert pixclock (in ps) to frequency (in Hz) */

 clk_pixel = 1/2 clk_pixel_pll */

 Keep BYPASS and RESET signals asserted until configured */

 shut everything down before changing timing */

 set horizontal timings */

 set vertical timings */

 Set the frame length register (#pix * 2 bytes/pixel) */

 enable desired output interface & disable others */

 set the sync polarities & enable bit */

 start everything back up */

 Unblank the display */

 enable RGB pad */

 enable VDAC */

 command word */

 length word */

 frame base address */

 color mode and horizontal resolution */

 vertical resolution */

 packed data */

 assume we have enough space to transfer at least one line */

 calculate the maximum number of lines we could fit in */

 but we might not need this many */

/* Path triggered by usermode clients who write to filesystem

 * e.g. cat filename > /dev/fb1

 * Not used by X Windows or text-mode console. But useful for testing.

/* NOTE: fb_defio.c is holding info->fbdefio.mutex

 *   Touching ANY framebuffer memory that triggers a page fault

 *   in fb_defio will cause a deadlock, when it also tries to

 walk the written page list and render each to device */

		/* create a rectangle of full screen width that encloses the

 TODO: Update X server to get this from sysfs instead */

 TODO: Help propose a standard fb.h ioctl to report mmap damage */

		/* If we have a damage-aware client, turn fb_defio "off"

		 * To avoid perf imact of unnecessary page fault handling.

		 * Done by resetting the delay for this fb_info to a very

		 * long period. Pages will become writable and stay that way.

		 * Reset to normal value when all clients have closed this fb.

 taken from vesafb */

 1:5:5:5 */

 0:5:6:5 */

/* It's common for several clients to have framebuffer open simultaneously.

 * e.g. both fbcon and X. Makes things interesting.

	/* fbcon aggressively connects to first framebuffer it finds,

	 * preventing other clients (X) from working properly. Usually

 If the USB device is gone, we don't accept new opens */

 enable defio at last moment if not disabled by client */

/*

 * Called when all client interfaces to start transactions have been disabled,

 * and all references to our device instance (ufx_data) are released.

 * Every transaction must have a reference, so we know are fully spun down

 this function will wait for all in-flight urbs to complete */

 Assume info structure is freed after this point */

 ref taken in probe() as part of registering framebfufer */

/*

 * Assumes caller is holding info->lock mutex (for open and release at least)

 We can't free fb_info here - fbmem will touch it when we return */

/* Check whether a video mode is supported by the chip

 TODO: support dynamically changing framebuffer size */

 set device-specific elements of var unrelated to mode */

 paint greenscreen */

 re-enable defio if previously disabled by damage tracking */

 In order to come back from full DPMS off, we need to set the mode again */

/* Assumes &info->lock held by caller

		/*

		 * Alloc system memory for virtual framebuffer

/* sets up I2C Controller for 100 Kbps, std. speed, 7-bit addr, master,

 disable the controller before it can be reprogrammed */

	/* Setup the clock count registers

 (6+8) = 14 clks @ 2.5 MHz = 5.6 uS */

 set speed to std mode */

 7-bit (not 10-bit) addressing */

 enable restart conditions and master mode */

 Set normal tx using target address 0 */

 Enable the controller */

 sets the I2C port mux and target address */

 A0h is std for any EDID, right shifted by one */

/* wait for BUSY to clear, with a timeout of 50ms with 10ms sleeps. if no

 if BUSY is clear, check for error */

 perform the first 10 retries without delay */

 reads a 128-byte EDID block from the currently selected port and TAR */

 Read the 128-byte EDID as 2 bursts of 64 bytes */

 all FF's in the first 16 bytes indicates nothing is connected */

/* 1) use sw default

 * 2) Parse into various fb_info structs

 * 3) Allocate virtual framebuffer memory to back highest res mode

 *

 * Parses EDID into three places used by various parts of fbdev:

 * fb_var_screeninfo contains the timing of the monitor's preferred mode

 * fb_info.monspecs is full parsed EDID info, including monspecs.modedb

 * fb_info.modelist is a linked list of all monitor & VESA modes which work

 *

 * If EDID is not readable/valid, then modelist is all VESA modes,

 * monspecs is NULL, and fb_var_screeninfo is set to safe VESA mode

 only use mutex if info has been registered */

	/* Try to (re)read EDID from hardware first

	 * EDID data may return, but not parse as valid

 If that fails, use a previously returned EDID if available */

 If that fails, use the default EDID we were handed */

 If we've got modes, let's pick a best default mode */

 if we've removed top/best mode */

 If everything else has failed, fall back to safe default mode */

		/* Add the standard VESA modes to our modelist

		 * Since we don't have EDID, there may be modes that

		 * overspec monitor and/or are incorrect aspect ratio, etc.

		 * But at least the user has a chance to choose

		/* default to resolution safe for projectors

		 * (since they are most common case without EDID)

 If we have good mode and no active clients */

 with mode size info, we can now alloc our framebuffer */

 usb initialization */

 we need to wait for both usb and fbdev to spin down on disconnect */

 matching kref_put in usb .disconnect fn */

 matching kref_put in free_framebuffer_work */

 our generic struct device * */

 We don't register a new USB class. Our client interface is fbdev */

 allocates framebuffer driver structure, not framebuffer memory */

 ready to begin using device */

 ref for framebuffer */

 last ref from kref_init */

 we virtualize until all fb clients release. Then we free */

 When non-active we'll update virtual framebuffer, but no new urbs */

 if clients still have us open, will be freed on last close */

 release reference taken by kref_init in probe() */

 consider ufx_data freed */

 sync/async unlink faults aren't errors */

 reset to actual */

	/* When using fb_defio, we deadlock if up() is called

 keep waiting and freeing, until we've got 'em all */

 Getting interrupted means a leak, but ok at shutdown*/

 have reserved one with sem */

 Free each separately allocated piece */

 urb->transfer_buffer_length set to actual before submit */

 Wait for an in-flight buffer to complete and get re-queued */

 reserved one with limit_sem */

 set to actual payload len */

 because no one else will */

/* drivers/video/s1d13xxxfb.c

 *

 * (c) 2004 Simtec Electronics

 * (c) 2005 Thibaut VARENE <varenet@parisc-linux.org>

 * (c) 2009 Kristoffer Ericson <kristoffer.ericson@gmail.com>

 *

 * Driver for Epson S1D13xxx series framebuffer chips

 *

 * Adapted from

 *  linux/drivers/video/skeletonfb.c

 *  linux/drivers/video/epson1355fb.c

 *  linux/drivers/video/epson/s1d13xxxfb.c (2.4 driver by Epson)

 *

 * TODO: - handle dual screen display (CRT and LCD at the same time).

 *	 - check_var(), mode change, etc.

 *	 - probably not SMP safe :)

 *       - support all bitblt operations on all cards

 *

 * This file is subject to the terms and conditions of the GNU General Public

 * License. See the file COPYING in the main directory of this archive for

 * more details.

/*

 * set this to enable debugging on general functions

/*

 * set this to enable debugging on 2D acceleration

/*

 * we make sure only one bitblt operation is running

/*

 * list of card production ids

/*

 * List of card strings

/*

 * here we define the default struct fb_fix_screeninfo

 make sure the hardware can cope with us */

/*************************************************************

 framebuffer control functions

/**

 *      s1d13xxxfb_set_par - Alters the hardware state.

 *      @info: frame buffer structure

 *

 *	Using the fb_var_screeninfo in fb_info we set the depth of the

 *	framebuffer. This function alters the par AND the

 *	fb_fix_screeninfo stored in fb_info. It doesn't not alter var in

 *	fb_info since we are using that data. This means we depend on the

 *	data in var inside fb_info to be supported by the hardware.

 *	xxxfb_check_var is always called before xxxfb_set_par to ensure this.

 *

 *	XXX TODO: write proper s1d13xxxfb_check_var(), without which that

 *	function is quite useless.

 LCD */

 read colour control */

 CRT */

 read colour control */

 LCD */

 CRT */

/**

 *	s1d13xxxfb_setcolreg - sets a color register.

 *	@regno: Which register in the CLUT we are programming

 *	@red: The red value which can be up to 16 bits wide

 *	@green: The green value which can be up to 16 bits wide

 *	@blue:  The blue value which can be up to 16 bits wide.

 *	@transp: If supported the alpha value which can be up to 16 bits wide.

 *	@info: frame buffer info structure

 *

 *	Returns negative errno on error, or zero on success.

 deal with creating pseudo-palette entries */

/**

 *      s1d13xxxfb_blank - blanks the display.

 *      @blank_mode: the blank mode we want.

 *      @info: frame buffer structure that represents a single frame buffer

 *

 *      Blank the screen if blank_mode != 0, else unblank. Return 0 if

 *      blanking succeeded, != 0 if un-/blanking failed due to e.g. a

 *      video mode which doesn't support it. Implements VESA suspend

 *      and powerdown modes on hardware that supports disabling hsync/vsync:

 *      blank_mode == 2: suspend vsync

 *      blank_mode == 3: suspend hsync

 *      blank_mode == 4: powerdown

 *

 *      Returns negative errno on error, or zero on success.

 let fbcon do a soft blank for us */

/**

 *	s1d13xxxfb_pan_display - Pans the display.

 *	@var: frame buffer variable screen structure

 *	@info: frame buffer structure that represents a single frame buffer

 *

 *	Pan (or wrap, depending on the `vmode' field) the display using the

 *	`yoffset' field of the `var' structure (`xoffset'  not yet supported).

 *	If the values don't fit, return -EINVAL.

 *

 *	Returns negative errno on error, or zero on success.

 not yet ... */

 LCD */

 CRT */

/************************************************************

 functions to handle bitblt acceleration

/**

 *	bltbit_wait_bitclear - waits for change in register value

 *	@info : frambuffer structure

 *	@bit  : value currently in register

 *	@timeout : ...

 *

 *	waits until value changes FROM bit

 *

/*

 *	s1d13xxxfb_bitblt_copyarea - accelerated copyarea function

 *	@info : framebuffer structure

 *	@area : fb_copyarea structure

 *

 *	supports (atleast) S1D13506

 *

 bytes per xres line */

 reverse, calculate the last pixel in rectangle */

 not reverse, calculate the first pixel in rectangle */

 (y * xres) + (bpp * x) */

 set source address */

 set destination address */

 program height and width */

 negative direction ROP */

 positive direction ROP */ {

 set for rectangel mode and not linear */

 setup the bpp 1 = 16bpp, 0 = 8bpp*/

 set words per xres */

 initialize the engine */

 wait to complete */

/**

 *	s1d13xxxfb_bitblt_solidfill - accelerated solidfill function

 *	@info : framebuffer structure

 *	@rect : fb_fillrect structure

 *

 *	supports (atleast 13506)

 *

 grab spinlock */

 bytes per x width */

 bytes to starting point */

 We split the destination into the three registers */

 give information regarding rectangel width */

 give information regarding rectangel height */

 set foreground color */

 set rectangual region of memory (rectangle and not linear) */

 set operation mode SOLID_FILL */

 set bits per pixel (1 = 16bpp, 0 = 8bpp) */

 set the memory offset for the bblt in word sizes */

 and away we go.... */

 wait until its done */

 let others play */

 framebuffer information structures */

 gets replaced at chip detection time */

/**

 *	s1d13xxxfb_fetch_hw_state - Configure the framebuffer according to

 *	hardware setup.

 *	@info: frame buffer structure

 *

 *	We setup the framebuffer structures according to the current

 *	hardware setup. On some machines, the BIOS will have filled

 *	the chip registers with such info, on others, these values will

 *	have been written in some init procedure. In any case, the

 *	software values needs to match the hardware ones. This is what

 *	this function ensures.

 *

 *	Note: some of the hardcoded values here might need some love to

 *	work on various chips, and might need to no longer be hardcoded.

 general info */

 CRT */

 4 bpp */

 8 bpp */

 16 bpp */

 LCD info */

 crt */

 disable output & enable powersave */

 enable platform-dependent hardware glue, if any */

 resource[0] is VRAM, resource[1] is registers */

 production id is top 6 bits */

 revision id is lower 2 bits */

 looks like we got it in our list */

 activate acceleration */

 perform "manual" chip initialization, if needed */

 disable display */

 backup all registers */

 now activate power save mode */

 awaken the chip */

 do not let go until SDRAM "wakes up" */

 will write RO regs, *should* get away with it :) */

 XXX kmalloc()'d when? */

 CONFIG_PM */

 SPDX-License-Identifier: GPL-2.0

/*

 * SH7760/SH7763 LCDC Framebuffer driver.

 *

 * (c) 2006-2008 MSC Vertriebsges.m.b.H.,

 *             Manuel Lauss <mano@roarinelk.homelinux.net>

 * (c) 2008 Nobuhiro Iwamatsu <iwamatsu.nobuhiro@renesas.com>

 *

 * PLEASE HAVE A LOOK AT Documentation/fb/sh7760fb.rst!

 *

 * Thanks to Siegfried Schaefer <s.schaefer at schaefer-edv.de>

 *     for his original source and testing!

 *

 * sh7760_setcolreg get from drivers/video/sh_mobile_lcdcfb.c

 display information */

 physical address */

 rotation enabled? */

 vsync irq event */

 wait_for_lps - wait until power supply has reached a certain state. */

 en/disable the LCDC */

 only FB_VISUAL_TRUECOLOR supported */

 get color info from register value */

 TODO: add some more validation here */

/*

 * sh7760fb_set_par - set videomode.

 *

 * NOTE: The rotation, grayscale and DSTN codepaths are

 *     totally untested!

 rotate only works with xres <= 320 */

 calculate LCDC reg vals from display parameters */

 get color info from register value */

 shut down LCDC before changing display parameters */

 pixclock */

 polarities */

 color/depth */

 rotate */

 Power Management */

 Power Supply Ctrl */

 display resolution */

 h/v sync signals */

 AC modulation sig */

 6 bpp == 8 bpp */

 if rotated, stride must be power of 2 */

 not P-o-2, round up */

 set display mem start address */

	/*

	 * for DSTN need to set address for lower half.

	 * I (mlau) don't know which address to set it to,

	 * so I guessed at (stride * yres/2).

 mem for lower half of DSTN */

 panel on! */

/* allocate the framebuffer memory. This memory must be in Area3,

 * (dictated by the DMA engine) and contiguous, at a 512 byte boundary.

 get color info from register value */

	/* min VRAM: xres_min = 16, yres_min = 1, bpp = 1: 2byte -> 1 page

 disable vsync irq */

 fixup color register bitpositions. These are fixed by hardware */

	/* set the DON2 bit now, before cmap allocation, as it will randomize

	 * palette memory.

/*

 * Permedia2 framebuffer driver.

 *

 * 2.5/2.6 driver:

 * Copyright (c) 2003 Jim Hague (jim.hague@acm.org)

 *

 * based on 2.4 driver:

 * Copyright (c) 1998-2000 Ilario Nardinocchi (nardinoc@CS.UniBO.IT)

 * Copyright (c) 1999 Jakub Jelinek (jakub@redhat.com)

 *

 * and additional input from James Simmon's port of Hannu Mallat's tdfx

 * driver.

 *

 * I have a Creative Graphics Blaster Exxtreme card - pm2fb on x86. I

 * have no access to other pm2fb implementations. Sparc (and thus

 * hopefully other big-endian) devices now work, thanks to a lot of

 * testing work by Ron Murray. I have no access to CVision hardware,

 * and therefore for now I am omitting the CVision code.

 *

 * Multiple boards support has been on the TODO list for ages.

 * Don't expect this to change.

 *

 * This file is subject to the terms and conditions of the GNU General Public

 * License. See the file COPYING in the main directory of this archive for

 * more details.

 *

 *

/*

 * Driver data

/*

 * The XFree GLINT driver will (I think to implement hardware cursor

 * support on TVP4010 and similar where there is no RAMDAC - see

 * comment in set_video) always request +ve sync regardless of what

 * the mode requires. This screws me because I have a Sun

 * fixed-frequency monitor which absolutely has to have -ve sync. So

 * these flags allow the user to specify that requests for +ve sync

 * should be silently turned in -ve sync.

/*

 * The hardware state of the graphics card that isn't part of the

 * screeninfo.

 Board type */

 virtual address of p_regs */

 memclock */

 video flags before blanking */

 MemConfig reg at probe */

 MemControl reg at probe */

 BootAddress reg at probe */

/*

 * Here we define the default structs fb_fix_screeninfo and fb_var_screeninfo

 * if we don't use modedb.

/*

 * Default video mode. In case the modedb doesn't work.

 "640x480, 8 bpp @ 60 Hz */

/*

 * Utility functions

/*

 * partial products for the supported horizontal resolutions.

 Restore stashed memory config information from probe */

 no overlay */

 8bit */

	/*

	 * The hardware is little-endian. When used in big-endian

	 * hosts, the on-chip aperture settings are used where

	 * possible to translate from host to card byte order.

 RGB->BGR */

		/*

		 * We can't use the aperture to translate host to

		 * card byte order here, so we switch to BGR mode

		 * in pm2fb_set_par().

 B->B */

 HL->LH */

 RGBA->ABGR */

 We don't use aperture two, so this may be superflous */

	/*

	 * The hardware cursor needs +vsync to recognise vert retrace.

	 * We may not be using the hardware cursor, but the X Glint

	 * driver may well. So always set +hsync/+vsync and then set

	 * the RAMDAC to invert the sync if necessary.

 invert hsync */

 invert vsync */

 invert hsync */

 invert vsync */

/*

 *	pm2fb_check_var - Optional function. Validates a var passed in.

 *	@var: frame buffer variable screen structure

 *	@info: frame buffer structure that represents a single frame buffer

 *

 *	Checks to see if the hardware supports the state requested by

 *	var passed in.

 *

 *	Returns negative errno on error, or zero on success.

 permedia cannot blit over 2048 */

 could sometimes be 8 */

 Can't mmap if this is on */

/**

 *	pm2fb_set_par - Alters the hardware state.

 *	@info: frame buffer structure that represents a single frame buffer

 *

 *	Using the fb_var_screeninfo in fb_info we set the resolution of the

 *	this particular framebuffer.

 8-bit DAC */

 FIXME! */

	/*

	 * Settings calculated. Now write them out.

/**

 *	pm2fb_setcolreg - Sets a color register.

 *	@regno: boolean, 0 copy local, 1 get_user() function

 *	@red: frame buffer colormap structure

 *	@green: The green value which can be up to 16 bits wide

 *	@blue:  The blue value which can be up to 16 bits wide.

 *	@transp: If supported the alpha value which can be up to 16 bits wide.

 *	@info: frame buffer info structure

 *

 *	Set a single color register. The values supplied have a 16 bit

 *	magnitude which needs to be scaled in this function for the hardware.

 *	Pretty much a direct lift from tdfxfb.c.

 *

 *	Returns negative errno on error, or zero on success.

 no. of hw registers */

	/*

	 * Program hardware... do anything you want with transp

 grayscale works only partially under directcolor */

 grayscale = 0.30*R + 0.59*G + 0.11*B */

	/* Directcolor:

	 *   var->{color}.offset contains start of bitfield

	 *   var->{color}.length contains length of bitfield

	 *   {hardwarespecific} contains width of DAC

	 *   cmap[X] is programmed to

	 *   (X << red.offset) | (X << green.offset) | (X << blue.offset)

	 *   RAMDAC[X] is programmed to (red, green, blue)

	 *

	 * Pseudocolor:

	 *    uses offset = 0 && length = DAC register width.

	 *    var->{color}.offset is 0

	 *    var->{color}.length contains width of DAC

	 *    cmap is not used

	 *    DAC[X] is programmed to (red, green, blue)

	 * Truecolor:

	 *    does not use RAMDAC (usually has 3 of them).

	 *    var->{color}.offset contains start of bitfield

	 *    var->{color}.length contains length of bitfield

	 *    cmap is programmed to

	 *    (red << red.offset) | (green << green.offset) |

	 *    (blue << blue.offset) | (transp << transp.offset)

	 *    RAMDAC does not exist

		/* example here assumes 8 bit DAC. Might be different

 hey, there is bug in transp handling... */

 Truecolor has hardware independent palette */

/**

 *	pm2fb_pan_display - Pans the display.

 *	@var: frame buffer variable screen structure

 *	@info: frame buffer structure that represents a single frame buffer

 *

 *	Pan (or wrap, depending on the `vmode' field) the display using the

 *	`xoffset' and `yoffset' fields of the `var' structure.

 *	If the values don't fit, return -EINVAL.

 *

 *	Returns negative errno on error, or zero on success.

 *

/**

 *	pm2fb_blank - Blanks the display.

 *	@blank_mode: the blank mode we want.

 *	@info: frame buffer structure that represents a single frame buffer

 *

 *	Blank the screen if blank_mode != 0, else unblank. Return 0 if

 *	blanking succeeded, != 0 if un-/blanking failed due to e.g. a

 *	video mode which doesn't support it. Implements VESA suspend

 *	and powerdown modes on hardware that supports disabling hsync/vsync:

 *	blank_mode == 2: suspend vsync

 *	blank_mode == 3: suspend hsync

 *	blank_mode == 4: powerdown

 *

 *	Returns negative errno on error, or zero on success.

 *

 Screen: On */

 Screen: Off */

 VSync: Off */

 HSync: Off */

 HSync: Off, VSync: Off */

 invert bits */

 reverse byte order */

 GXcopy & UNIT_ENABLE */

 clear area */

 BitMapPackEachScanline */

 clear area */

/*

 *	Hardware cursor support.

 push it outside display */

	/*

	 * If the cursor is not be changed this means either we want the

	 * current cursor state (if enable is set) or we want to query what

	 * we can do with the cursor (if enable is not set)

 the X11 driver says one should use these color registers */

 Upper 4 bits of bitmap data */

 Lower 4 bits of bitmap */

 just to force soft_cursor() call */

 Too large of a cursor or wrong bpp :-( */

	/*

	 * If the cursor is not be changed this means either we want the

	 * current cursor state (if enable is set) or we want to query what

	 * we can do with the cursor (if enable is not set)

 bitmap data */

 mask */

 ------------ Hardware Independent Functions ------------ */

/*

 *  Frame buffer operations

/*

 * PCI stuff

/**

 * Device initialisation

 *

 * Initialise and allocate resource for PCI device.

 *

 * @pdev:	PCI device.

 * @id:		PCI device ID.

	/*

	 * PM2 has a 64k register file, mapped twice in 128k. Lower

	 * map is little-endian, upper map is big-endian.

 Registers - request region and map it. */

 Stash away memory register info for use when we reset the board */

 Now work out how big lfb is going to be. */

 Linear frame buffer - request region and map it. */

	/*

	 * Our driver data

/**

 * Device removal.

 *

 * Release all device resources.

 *

 * @pdev:	PCI device to clean up.

/*

 * Parse user specified options.

 *

 * This is, comma-separated options following `video=pm2fb:'.

/*

 *  Cleanup

/*

 *  drivers/video/chipsfb.c -- frame buffer device for

 *  Chips & Technologies 65550 chip.

 *

 *  Copyright (C) 1998-2002 Paul Mackerras

 *

 *  This file is derived from the Powermac "chips" driver:

 *  Copyright (C) 1997 Fabio Riccardi.

 *  And from the frame buffer device for Open Firmware-initialized devices:

 *  Copyright (C) 1997 Geert Uytterhoeven.

 *

 *  This file is subject to the terms and conditions of the GNU General Public

 *  License. See the file COPYING in the main directory of this archive for

 *  more details.

/*

 * Since we access the display with inb/outb to fixed port numbers,

 * we can only handle one 6555x chip.  -- paulus

 extension registers */

 flat panel registers */

 CRTC registers */

 graphics registers */

 sequencer registers */

 attribute registers - slightly strange */

/*

 * Exported functions

 Set line length (doublewords)

 15 bit (555) color mode

 Disable palettes

 16 bit blitter mode

 p->var.bits_per_pixel == 8 */

 Set line length (doublewords)

 8 bit color mode

 Graphics gamma enable

 8 bit blitter mode

 get fb_blank to set the colormap to all black */

 { 0x12, 0x40 }, -- 3400 needs 40, 2400 needs 48, no way to tell */

 set default memory clock */

 memory clock ratio */

 set misc output reg */

 FIXME: Assumes 1MB frame buffer, but 65550 supports 1MB or 2MB.

 * "3500" PowerBook G3 (the original PB G3) has 2MB.

 * 2400 has 1MB composed of 2 Mitsubishi M5M4V4265CTP DRAM chips.

   Motherboard actually supports 2MB -- there are two blank locations

   for a second pair of DRAMs.  (Thanks, Apple!)

 * 3400 has 1MB (I think).  Don't know if it's expandable.

 -- Tim Seufert

 1MB */

 Use big-endian aperture

	/* we should use pci_enable_device here, but,

	   the device doesn't declare its I/O ports in its BARs

 enable memory and IO space */

 turn on the backlight */

 CONFIG_PMAC_BACKLIGHT */

 CONFIG_PM */

/*

 *  linux/drivers/video/ps3fb.c -- PS3 GPU frame buffer device

 *

 *	Copyright (C) 2006 Sony Computer Entertainment Inc.

 *	Copyright 2006, 2007 Sony Corporation

 *

 *  This file is based on :

 *

 *  linux/drivers/video/vfb.c -- Virtual frame buffer device

 *

 *	Copyright (C) 2002 James Simmons

 *

 *	Copyright (C) 1997 Geert Uytterhoeven

 *

 *  This file is subject to the terms and conditions of the GNU General Public

 *  License. See the file COPYING in the main directory of this archive for

 *  more details.

 vsync on head A */

 vsync on head B */

 flip head A */

 flip head B */

 queue head A */

 queue head B */

 gpu internals */

 frame count */

 on/off flip with vsync */

 fb_open count */

 num of frame buffers */

 start of fullscreen DDR fb */

 start of actual DDR fb */

 60 Hz broadcast modes (modes "1" to "5") */

 480i */

 480p */

 720p */

 1080i */

 1080p */

 50 Hz broadcast modes (modes "6" to "10") */

 576i */

 576p */

 720p */

 1080i */

 1080p */

 60 Hz broadcast modes (full resolution versions of modes "1" to "5") */

 480if */

 480pf */

 720pf */

 1080if */

 1080pf */

 50 Hz broadcast modes (full resolution versions of modes "6" to "10") */

 576if */

 576pf */

 720pf */

 1080if */

 1080pf */

 VESA modes (modes "11" to "13") */

 WXGA */

 SXGA */

 WUXGA */

 number of bytes per pixel */

 maximum values */

 progressive/interlaced must match */

 minimum resolution */

 minimum margins */

 resolution + margins may not exceed native parameters */

 exact match */

 resolution difference */

 Non-fullscreen broadcast mode */

 minimum resolution */

 minimum virtual resolution */

 minimum margins */

 extra margins */

 fixed fields */

 Full broadcast modes have the full mode bit set */

 single buffer */

    /*

     *  Setting the video mode has been split into two parts.

     *  First part, xxxfb_check_var, must not write anything

     *  to hardware, it should only verify and adjust var.

     *  This means it doesn't alter par but it does use hardware

     *  data from it to check this var.

 Virtual screen */

 We support ARGB8888 only */

 Rotation is not supported */

 Memory limit */

    /*

     * This routine actually sets the video mode.

 Keep the special bits we cannot set using fb_var_screeninfo */

 Start of the virtual frame buffer (relative to fullscreen) */

 Clear XDR frame buffer memory */

 Clear DDR frame buffer memory */

    /*

     *  Set a single color register. The values supplied are already

     *  rounded down to the hardware's capabilities (according to the

     *  entries in the var structure). Return != 0 for invalid regno.

    /*

     *  As we have a virtual frame buffer, we need our own mmap function

    /*

     * Blank the display

 mute on */

 unblank */

 mute off */

    /*

     * ioctl

 Force, in case only special bits changed */

 single buffer */

 VSYNC */

 fbcon opens ps3fb */

 for flip with vsync */

 get gpu context handle */

 vsync interrupt */

 Clear memory to prevent kernel info leakage into userspace */

 != ps3fb_mode, to trigger change */

	/*

	 * The GPU command buffer is at the start of video memory

	 * As we don't use the full command buffer, we can put the actual

	 * frame buffer at offset GPU_FB_START and save some precious XDR

	 * memory

 flip off */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Frame Buffer Device for Toshiba Mobile IO(TMIO) controller

 *

 * Copyright(C) 2005-2006 Chris Humbert

 * Copyright(C) 2005 Dirk Opfer

 * Copytight(C) 2007,2008 Dmitry Baryshkov

 *

 * Based on:

 *	drivers/video/w100fb.c

 *	code written by Sharp/Lineo for 2.4 kernels

 Why should fb driver call console functions? because console_lock() */

/*

 * accelerator commands

 a FIFO is always allocated, even if acceleration is not used */

/*

 * LCD Host Controller Configuration Register

 *

 * This iomem area supports only 16-bit IO.

 Command				*/

 Revision ID			*/

 LCD Control Reg Base Addr Low	*/

 LCD Control Reg Base Addr High	*/

 Unified Gated Clock Control	*/

 Gated Clock Control		*/

 Unified Software Clear		*/

 VRAM Timing Control		*/

 0x61 VRAM Refresh Control		*/

 VRAM Access Control		*/

 0x63	VRAM Status			*/

 VRAM Block Control		*/

/*

 * LCD Control Register

 *

 * This iomem area supports only 16-bit IO.

 Unified Interrupt Status	*/

 VRAM Horizontal Pixel Number	*/

 Command FIFO Start Address Low	*/

 Command FIFO Start Address High */

 Command FIFO Size		*/

 Command FIFO Writeable Size	*/

 BitBLT Interrupt Enable	*/

 BitBLT Interrupt Status and Clear */

 Command Count Status		*/

 BitBLT Execution Status	*/

 Command Low			*/

 Command High			*/

 Command FIFO Clear		*/

 CMOS Camera IF Control		*/

 Hardware Test			*/

 LCDC Clock and Reset Control	*/

 LCDC Control			*/

 LCDC Output Pin Control	*/

 LCD Interrupt Status		*/

 LCD Interrupt Mask		*/

 LCD Interrupt Enable		*/

 Graphics Display Start Address Low */

 Graphics Display Start Address High */

 VRAM Horizontal Pixel Count Low */

 VRAM Horizontal Pixel Count High */

 Graphic Mode(VRAM access enable) */

 Horizontal Total		*/

 Horizontal Display Start	*/

 H-Sync Start			*/

 H-Sync End			*/

 Horizontal Number of Pixels	*/

 Vertical Total			*/

 Vertical Display Start		*/

 V-Sync Start			*/

 V-Sync End			*/

 Current Display Line Number	*/

 Interrupt Line Number		*/

 Sync Polarity			*/

 MISC(RGB565 mode)		*/

 Video Interface H-Sync Start	*/

 Video Interface Vertical Start	*/

 Video Interface Vertical End	*/

 Video Interface V-Sync Start	*/

 Video / CMOS Camera Interface Select */

 VI Data Write Start Address Low */

 VI Data Write Start Address High */

 VI Data Read Start Address Low	*/

 VI Data Read Start Address High */

 VI Picture Data Display Start Timing */

 VI Picture Data Display End Timing */

 Video Interface Enable		*/

 Video/Camera Select		*/

 Video Picture Horizontal Wait Count */

 Video Picture Horizontal Size	*/

 Video Picture Vertical Wait Count */

 Video Picture Vertical Size	*/

 PLHPIX				*/

 XStart				*/

 XCK High Width			*/

 STH Start			*/

 Vertical Total			*/

 YCK Start Wait			*/

 YST Start			*/

 #PPOL Start			*/

 PREC Width			*/

 VCLK High Width		*/

 Output Control			*/

--------------------------------------------------------------------------*/

/*

 * reasons for an interrupt:

 *	uis	bbisc	lcdis

 *	0100	0001	accelerator command completed

 * 	2000	0001	vsync start

 * 	2000	0002	display start

 * 	2000	0004	line number match(0x1ff mask???)

	/*

	 * We were in polling mode and now we got correct irq.

	 * Switch back to IRQ-based sync of command FIFO

--------------------------------------------------------------------------*/

/*

 * Turns off the LCD controller and LCD host controller.

/*

 * Initializes the LCD host controller.

 wait for device to settle */

 base address enable */

 VRAMRC, VRAMTC */

 VRAMSTS, VRAMAC */

 wait for device to settle */

/*

 * Sets the LCD controller's output resolution and pixel clock

 RGB565 mode */

 VRAM enable */

 sync polarity */

 wait for device to settle */

 STOP_CKP */

 wait for device to settle */

 STOP_CKP|SOFT_RESET*/

--------------------------------------------------------------------------*/

	/*

	 * This code can be called with interrupts disabled.

	 * So instead of relaying on irq to trigger the event,

	 * poll the state till the necessary command is executed.

/*

 * Writes an accelerator command to the accelerator's FIFO.

/*

 * Wait for the accelerator to finish its operations before writing

 * to the framebuffer for consistent display output.

 blit active */

--------------------------------------------------------------------------*/

/* Select the smallest mode that allows the desired resolution to be

 * displayed.  If desired, the x and y parameters can be rounded up to

 * match the selected mode.

 mm */

 mm */

	/*

	 * everything is done in lcd/bl drivers.

	 * this is purely to make sysfs happy and work.

--------------------------------------------------------------------------*/

	/*

	 * This is the only way ATM to disable the fb

err_set_par:*/

	/*

	 * The fb should be usable even if interrupts are disabled (and they are

	 * during suspend/resume). Switch temporary to forced polling.

--------------------------------------------------------------------------*/

		/*

		 * FIXME

/*

 * linux/drivers/video/vt8623fb.c - fbdev driver for

 * integrated graphic core in VIA VT8623 [CLE266] chipset

 *

 * Copyright (c) 2006-2007 Ondrej Zajicek <santiago@crfreenet.org>

 *

 * This file is subject to the terms and conditions of the GNU General Public

 * License.  See the file COPYING in the main directory of this archive for

 * more details.

 *

 * Code is based on s3fb, some parts are from David Boucher's viafb

 * (http://davesdomain.org.uk/viafb/)

 Why should fb driver call console functions? because console_lock() */

 ------------------------------------------------------------------------- */

/*	{16,  {10, 5, 0}, {5, 5, 0},  {0, 5, 0}, {0, 0, 0}, 0,

 CRT timing register sets */

 ------------------------------------------------------------------------- */

 Module parameters */

 ------------------------------------------------------------------------- */

 ------------------------------------------------------------------------- */

 image data is MSB-first, fb structure is MSB-first too */

 vt8623fb_iplan_imageblit silently assumes that almost everything is 8-pixel aligned */

 vt8623fb_iplan_fillrect silently assumes that almost everything is 8-pixel aligned */

 image data is MSB-first, fb structure is high-nibble-in-low-byte-first */

 vt8623fb_cfb4_imageblit silently assumes that almost everything is 8-pixel aligned */

 ------------------------------------------------------------------------- */

 Set VGA misc register  */

 Set clock registers */

 PLL reset */

 Find appropriate format */

 Do not allow to have real resoulution larger than virtual */

 Round up xres_virtual to have proper alignment of lines */

 Check whether have enough memory */

 Text mode is limited to 256 kB of memory */

 Interlaced mode not supported */

 in 4bpp supports 8p wide tiles only, any tiles otherwise */

 + 0 is OK */

 supports 8x16 tiles only */

 Unlock registers */

 Device, screen and sync off */

 Set default values */

 Clear H/V Skew */

 DI/DVP bus

 DI/DVP bus

 FIFO read threshold

 FIFO depth

 enable MMIO ?

 Set SR15 according to number of bits per pixel */

 Device and screen back on */

 ((transp & 0xFF00) << 16) */

 Calculate the offset */

 Set the offset */

 ------------------------------------------------------------------------- */

 Frame buffer operations */

 PCI probe */

 Ignore secondary VGA device because there is no VGA arbitration */

 Allocate and fill driver data structure */

 Prepare PCI device */

 Map physical IO memory address into kernel space */

 Find how many physical memory there is on card */

 Prepare startup mode */

 Record a reference to the driver data */

 Error handling */

	pci_disable_device(dev); */

 PCI remove */

		pci_disable_device(dev); */

 PCI suspend */

 PCI resume */

 CONFIG_PM_SLEEP */

 List of boards that we are trying to support */

 Cleanup */

 Driver Initialisation */

 ------------------------------------------------------------------------- */

 Modularization */

/*

 *  valkyriefb.c -- frame buffer device for the PowerMac 'valkyrie' display

 *

 *  Created 8 August 1998 by 

 *  Martin Costabel <costabel@wanadoo.fr> and Kevin Schoedel

 *

 *  Vmode-switching changes and vmode 15/17 modifications created 29 August

 *  1998 by Barry K. Nathan <barryn@pobox.com>.

 *

 *  Ported to m68k Macintosh by David Huggins-Daines <dhd@debian.org>

 *

 *  Derived directly from:

 *

 *   controlfb.c -- frame buffer device for the PowerMac 'control' display

 *   Copyright (C) 1998 Dan Jacobowitz <dan@debian.org>

 *

 *   pmc-valkyrie.c -- Console support for PowerMac "valkyrie" display adaptor.

 *   Copyright (C) 1997 Paul Mackerras.

 *

 *  and indirectly:

 *

 *  Frame buffer structure from:

 *    drivers/video/chipsfb.c -- frame buffer device for

 *    Chips & Technologies 65550 chip.

 *

 *    Copyright (C) 1998 Paul Mackerras

 *

 *    This file is derived from the Powermac "chips" driver:

 *    Copyright (C) 1997 Fabio Riccardi.

 *    And from the frame buffer device for Open Firmware-initialized devices:

 *    Copyright (C) 1997 Geert Uytterhoeven.

 *

 *  Hardware information from:

 *    control.c: Console support for PowerMac "control" display adaptor.

 *    Copyright (C) 1996 Paul Mackerras

 *

 *  This file is subject to the terms and conditions of the GNU General Public

 *  License. See the file COPYING in the main directory of this archive for

 *  more details.

/*

 * Exported functions

 Sets the video mode according to info->var */

 Reset the valkyrie */

 Initialize display timing registers */

 Turn on display */

/*

 *  Blank the screen if blank_mode != 0, else unblank. If blank_mode == NULL

 *  then the caller blanks by setting the CLUT (Color Look Up Table) to all

 *  black. Return 0 if blanking succeeded, != 0 if un-/blanking failed due

 *  to e.g. a video mode which doesn't support it. Implements VESA suspend

 *  and powerdown modes on hardware that supports disabling hsync/vsync:

 *    blank_mode == 2: suspend vsync

 *    blank_mode == 3: suspend hsync

 *    blank_mode == 4: powerdown

 unblank */

 get caller to set CLUT to all black */

		/*

		 * [kps] Value extracted from MacOS. I don't know

		 * whether this bit disables hsync or vsync, or

		 * whether the hardware can do the other as well.

 tell clut which address to fill */

 send one color channel at a time */

 Try to pick a video mode out of NVRAM if we have one. */

	/*

	 * Reduce the pixel size if we don't have enough VRAM or bandwidth.

 I'm not sure about this one */

 Hardcoded addresses... welcome to 68k Macintosh country :-) */

 ppc (!CONFIG_MAC) */

 ppc (!CONFIG_MAC) */

 Map in frame buffer and registers */

 "can't happen" */

/*

 * Get the monitor sense value.

 release all lines */

 drive each sense line low in turn and collect the other 2 */

 drive A low */

 drive B low */

 drive C low */

/*

 * This routine takes a user-supplied var,

 * and picks the best vmode/cmode from it.

/* [bkn] I did a major overhaul of this function.

 *

 * Much of the old code was "swiped by jonh from atyfb.c". Because

 * macmodes has mac_var_to_vmode, I felt that it would be better to

 * rework this function to use that, instead of reinventing the wheel to

 * add support for vmode 17. This was reinforced by the fact that

 * the previously swiped atyfb.c code is no longer there.

 *

 * So, I swiped and adapted platinum_var_to_par (from platinumfb.c), replacing

 * most, but not all, of the old code in the process. One side benefit of

 * swiping the platinumfb code is that we now have more comprehensible error

 * messages when a vmode/cmode switch fails. (Most of the error messages are

 * platinumfb.c, but I added two of my own, and I also changed some commas

 * into colons to make the messages more consistent with other Linux error

 * messages.) In addition, I think the new code *might* fix some vmode-

 * switching oddities, but I'm not sure.

 *

 * There may be some more opportunities for cleanup in here, but this is a

 * good start...

 Check if we know about the wanted video mode */

 Fix must already be inited above */

 ywrapstep, xpanstep, ypanstep */

/*

 * Parse user specified options (`video=valkyriefb:')

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Driver for Aeroflex Gaisler SVGACTRL framebuffer device.

 *

 * 2011 (c) Aeroflex Gaisler AB

 *

 * Full documentation of the core can be found here:

 * https://www.gaisler.com/products/grlib/grip.pdf

 *

 * Contributors: Kristoffer Glembo <kristoffer@gaisler.com>

 0x00 */

 0x04 */

 0x08 */

 0x0C */

 0x10 */

 0x14 */

 0x18 */

 0x20 */

 16 entry pseudo palette used by fbcon in true color mode */

 = 1 if framebuffer is allocated in main memory */

 640x480 @ 60 Hz */

 800x600 @ 60 Hz */

 800x600 @ 72 Hz */

 1024x768 @ 60 Hz */

 Which clocks that are available can be read out in these registers */

 offset, length, msb-right */

 Size of CLUT */

 grayscale = 0.30*R + 0.59*G + 0.11*B */

 In PSEUDOCOLOR we use the hardware CLUT */

 Truecolor uses the pseudo palette */

 Set framebuffer base address  */

	/* Expecting: "grvga: modestring, [addr:<framebuffer physical address>], [size:<framebuffer size>]

	 *

	 * If modestring is custom:<custom mode string> we parse the string which then contains all videoparameters

	 * If address is left out, we allocate memory,

	 * if size is left out we only allocate enough to support the given mode.

 Got framebuffer base address from argument list */

 Allocate frambuffer memory */

		/* Set page reserved so that mmap will work. This is necessary

		 * since we'll be remapping normal memory.

 Enable framebuffer */

/*

 *  linux/drivers/video/mfb.c -- Low level frame buffer operations for

 *				 monochrome

 *

 *	Created 5 Apr 1997 by Geert Uytterhoeven

 *

 *  This file is subject to the terms and conditions of the GNU General Public

 *  License.  See the file COPYING in the main directory of this archive for

 *  more details.

    /*

     *  Monochrome

 check margins */ ) {

 use fast_memmove or fb_memmove

/*

 *  linux/drivers/video/fm2fb.c -- BSC FrameMaster II/Rainbow II frame buffer

 *				   device

 *

 *	Copyright (C) 1998 Steffen A. Mork (linux-dev@morknet.de)

 *	Copyright (C) 1999 Geert Uytterhoeven

 *

 *  Written for 2.0.x by Steffen A. Mork

 *  Ported to 2.1.x by Geert Uytterhoeven

 *  Ported to new api by James Simmons

 *

 *  This file is subject to the terms and conditions of the GNU General Public

 *  License. See the file COPYING in the main directory of this archive for

 *  more details.

/*

 *	Some technical notes:

 *

 *	The BSC FrameMaster II (or Rainbow II) is a simple very dumb

 *	frame buffer which allows to display 24 bit true color images.

 *	Each pixel is 32 bit width so it's very easy to maintain the

 *	frame buffer. One long word has the following layout:

 *	AARRGGBB which means: AA the alpha channel byte, RR the red

 *	channel, GG the green channel and BB the blue channel.

 *

 *	The FrameMaster II supports the following video modes.

 *	- PAL/NTSC

 *	- interlaced/non interlaced

 *	- composite sync/sync/sync over green

 *

 *	The resolution is to the following both ones:

 *	- 768x576 (PAL)

 *	- 768x480 (NTSC)

 *

 *	This means that pixel access per line is fixed due to the

 *	fixed line width. In case of maximal resolution the frame

 *	buffer needs an amount of memory of 1.769.472 bytes which

 *	is near to 2 MByte (the allocated address space of Zorro2).

 *	The memory is channel interleaved. That means every channel

 *	owns four VRAMs. Unfortunately most FrameMasters II are

 *	not assembled with memory for the alpha channel. In this

 *	case it could be possible to add the frame buffer into the

 *	normal memory pool.

 *

 *	At relative address 0x1ffff8 of the frame buffers base address

 *	there exists a control register with the number of

 *	four control bits. They have the following meaning:

 *	bit value meaning

 *

 *	 0    1   0=interlaced/1=non interlaced

 *	 1    2   0=video out disabled/1=video out enabled

 *	 2    4   0=normal mode as jumpered via JP8/1=complement mode

 *	 3    8   0=read  onboard ROM/1 normal operation (required)

 *

 *	As mentioned above there are several jumper. I think there

 *	is not very much information about the FrameMaster II in

 *	the world so I add these information for completeness.

 *

 *	JP1  interlace selection (1-2 non interlaced/2-3 interlaced)

 *	JP2  wait state creation (leave as is!)

 *	JP3  wait state creation (leave as is!)

 *	JP4  modulate composite sync on green output (1-2 composite

 *	     sync on green channel/2-3 normal composite sync)

 *	JP5  create test signal, shorting this jumper will create

 *	     a white screen

 *	JP6  sync creation (1-2 composite sync/2-3 H-sync output)

 *	JP8  video mode (1-2 PAL/2-3 NTSC)

 *

 *	With the following jumpering table you can connect the

 *	FrameMaster II to a normal TV via SCART connector:

 *	JP1:  2-3

 *	JP4:  2-3

 *	JP6:  2-3

 *	JP8:  1-2 (means PAL for Europe)

 *

 *	NOTE:

 *	There is no other possibility to change the video timings

 *	except the interlaced/non interlaced, sync control and the

 *	video mode PAL (50 Hz)/NTSC (60 Hz). Inside this

 *	FrameMaster II driver are assumed values to avoid anomalies

 *	to a future X server. Except the pixel clock is really

 *	constant at 30 MHz.

 *

 *	9 pin female video connector:

 *

 *	1  analog red 0.7 Vss

 *	2  analog green 0.7 Vss

 *	3  analog blue 0.7 Vss

 *	4  H-sync TTL

 *	5  V-sync TTL

 *	6  ground

 *	7  ground

 *	8  ground

 *	9  ground

 *

 *	Some performance notes:

 *	The FrameMaster II was not designed to display a console

 *	this driver would do! It was designed to display still true

 *	color images. Imagine: When scroll up a text line there

 *	must copied ca. 1.7 MBytes to another place inside this

 *	frame buffer. This means 1.7 MByte read and 1.7 MByte write

 *	over the slow 16 bit wide Zorro2 bus! A scroll of one

 *	line needs 1 second so do not expect to much from this

 *	driver - he is at the limit!

 *

/*

 *	definitions

 768 x 576, 32 bpp (PAL) */

 768 x 480, 32 bpp (NTSC - not supported yet */

    /*

     *  Interface used by the world

    /*

     *  Blank the display.

    /*

     *  Set a single color register. The values supplied are already

     *  rounded down to the hardware's capabilities (according to the

     *  entries in the var structure). Return != 0 for invalid regno.

    /*

     *  Initialisation

 assigning memory to kernel space */

 make EBU color bars on display */

 white */

 yellow */

 cyan */

 green */

 magenta */

 red */

 blue */

 black */

/*

 *  linux/drivers/video/macmodes.c -- Standard MacOS video modes

 *

 *	Copyright (C) 1998 Geert Uytterhoeven

 *

 *      2000 - Removal of OpenFirmware dependencies by:

 *      - Ani Joshi

 *      - Brad Douglas <brad@neruo.com>

 *

 *	2001 - Documented with DocBook

 *	- Brad Douglas <brad@neruo.com>

 *

 *  This file is subject to the terms and conditions of the GNU General Public

 *  License. See the file COPYING in the main directory of this archive for

 *  more details.

    /*

     *  MacOS video mode definitions

     *

     *  Order IS important! If you change these, don't forget to update

     *  mac_modes[] below!

 512x384, 60Hz, Non-Interlaced (15.67 MHz dot clock) */

 640x480, 60 Hz, Non-Interlaced (25.175 MHz dotclock) */

 640x480, 67Hz, Non-Interlaced (30.0 MHz dotclock) */

 640x870, 75Hz (portrait), Non-Interlaced (57.28 MHz dot clock) */

 800x600, 56 Hz, Non-Interlaced (36.00 MHz dotclock) */

 800x600, 60 Hz, Non-Interlaced (40.00 MHz dotclock) */

 800x600, 72 Hz, Non-Interlaced (50.00 MHz dotclock) */

 800x600, 75 Hz, Non-Interlaced (49.50 MHz dotclock) */

 832x624, 75Hz, Non-Interlaced (57.6 MHz dotclock) */

 1024x768, 60 Hz, Non-Interlaced (65.00 MHz dotclock) */

 1024x768, 72 Hz, Non-Interlaced (75.00 MHz dotclock) */

 1024x768, 75 Hz, Non-Interlaced (78.75 MHz dotclock) */

 1024x768, 75 Hz, Non-Interlaced (78.75 MHz dotclock) */

 1152x870, 75 Hz, Non-Interlaced (100.0 MHz dotclock) */

 1280x960, 75 Hz, Non-Interlaced (126.00 MHz dotclock) */

 1280x1024, 75 Hz, Non-Interlaced (135.00 MHz dotclock) */

 1152x768, 60 Hz, Titanium PowerBook */

 1600x1024, 60 Hz, Non-Interlaced (112.27 MHz dotclock) */

 Anyone who has timings for these? */

 VMODE_512_384_60I: 512x384, 60Hz, Interlaced (NTSC) */

 VMODE_640_480_50I: 640x480, 50Hz, Interlaced (PAL) */

 VMODE_640_480_60I: 640x480, 60Hz, Interlaced (NTSC) */

 VMODE_768_576_50I: 768x576, 50Hz (PAL full frame), Interlaced */

    /*

     *  Mapping between MacOS video mode numbers and video mode definitions

     *

     *  These MUST be ordered in

     *    - increasing resolution

     *    - decreasing pixel clock period

 512x384 */

 640x480 */

 640x870 */

 800x600 */

 832x624 */

 1024x768 */

 1152x768 */

 1152x870 */

 1280x960 */

 1280x1024 */

 1600x1024 */

    /*

     *  Mapping between monitor sense values and MacOS video mode numbers

 21" RGB */

 Portrait Monochrome */

 12" RGB*/

 21" RGB (Radius) */

 21" mono (Radius) */

 21" mono */

 NTSC */

 Portrait RGB */

 12"-16" multiscan */

 13"-19" multiscan */

 13"-21" multiscan */

 13"/14" RGB */

 PAL */

 NTSC */

 VGA */

 16" RGB (Goldfish) */

 PAL (Alternate) */

 3rd party 19" */

 no sense lines connected at all */

 22" Apple Cinema Display */

 catch-all, must be last */

/**

 *	mac_vmode_to_var - converts vmode/cmode pair to var structure

 *	@vmode: MacOS video mode

 *	@cmode: MacOS color mode

 *	@var: frame buffer video mode structure

 *

 *	Converts a MacOS vmode/cmode pair to a frame buffer video

 *	mode structure.

 *

 *	Returns negative errno on error, or zero for success.

 *

/**

 *	mac_var_to_vmode - convert var structure to MacOS vmode/cmode pair

 *	@var: frame buffer video mode structure

 *	@vmode: MacOS video mode

 *	@cmode: MacOS color mode

 *

 *	Converts a frame buffer video mode structure to a MacOS

 *	vmode/cmode pair.

 *

 *	Returns negative errno on error, or zero for success.

 *

    /*

     * Find the mac_mode with a matching resolution or failing that, the

     * closest larger resolution. Skip modes with a shorter pixel clock period.

	/*

	 * Having found a good resolution, find the matching pixel clock

	 * or failing that, the closest longer pixel clock period.

/**

 *	mac_map_monitor_sense - Convert monitor sense to vmode

 *	@sense: Macintosh monitor sense number

 *

 *	Converts a Macintosh monitor sense number to a MacOS

 *	vmode number.

 *

 *	Returns MacOS vmode video mode number.

 *

/**

 *	mac_find_mode - find a video mode

 *	@var: frame buffer user defined part of display

 *	@info: frame buffer info structure

 *	@mode_option: video mode name (see mac_modedb[])

 *	@default_bpp: default color depth in bits per pixel

 *

 *	Finds a suitable video mode.  Tries to set mode specified

 *	by @mode_option.  If the name of the wanted mode begins with

 *	'mac', the Mac video mode database will be used, otherwise it

 *	will fall back to the standard video mode database.

 *

 *	Note: Function marked as __init and can only be used during

 *	system boot.

 *

 *	Returns error code from fb_find_mode (see fb_find_mode

 *	function).

 *

 SPDX-License-Identifier: GPL-2.0-only

/* linux/drivers/video/s3c-fb.c

 *

 * Copyright 2008 Openmoko Inc.

 * Copyright 2008-2010 Simtec Electronics

 *      Ben Dooks <ben@simtec.co.uk>

 *      http://armlinux.simtec.co.uk/

 *

 * Samsung SoC Framebuffer driver

/* This driver will export a number of framebuffer interfaces depending

 * on the configuration passed in via the platform data. Each fb instance

 * maps to a hardware window. Currently there is no support for runtime

 * setting of the alpha-blending functions that each window has, so only

 * window 0 is actually useful.

 *

 * Window 0 is treated specially, it is used for the basis of the LCD

 * output timings and as the control for the output power-down state.

/* note, the previous use of <mach/regs-fb.h> to get platform specific data

 * has been replaced by using the platform device name to pick the correct

 * configuration data for the system.

 FB_S3C_DEBUG_REGWRITE */

 irq_flags bits */

/**

 * struct s3c_fb_variant - fb variant information

 * @is_2443: Set if S3C2443/S3C2416 style hardware.

 * @nr_windows: The number of windows.

 * @vidtcon: The base for the VIDTCONx registers

 * @wincon: The base for the WINxCON registers.

 * @winmap: The base for the WINxMAP registers.

 * @keycon: The abse for the WxKEYCON registers.

 * @buf_start: Offset of buffer start registers.

 * @buf_size: Offset of buffer size registers.

 * @buf_end: Offset of buffer end registers.

 * @osd: The base for the OSD registers.

 * @osd_stride: stride of osd

 * @palette: Address of palette memory, or 0 if none.

 * @has_prtcon: Set if has PRTCON register.

 * @has_shadowcon: Set if has SHADOWCON register.

 * @has_blendcon: Set if has BLENDCON register.

 * @has_clksel: Set if VIDCON0 register has CLKSEL bit.

 * @has_fixvclk: Set if VIDCON1 register has FIXVCLK bits.

/**

 * struct s3c_fb_win_variant

 * @has_osd_c: Set if has OSD C register.

 * @has_osd_d: Set if has OSD D register.

 * @has_osd_alpha: Set if can change alpha transparency for a window.

 * @palette_sz: Size of palette in entries.

 * @palette_16bpp: Set if palette is 16bits wide.

 * @osd_size_off: If != 0, supports setting up OSD for a window; the appropriate

 *                register is located at the given offset from OSD_BASE.

 * @valid_bpp: 1 bit per BPP setting to show valid bits-per-pixel.

 *

 * valid_bpp bit x is set if (x+1)BPP is supported.

/**

 * struct s3c_fb_driverdata - per-device type driver data for init time.

 * @variant: The variant information for this driver.

 * @win: The window information for each window.

/**

 * struct s3c_fb_palette - palette information

 * @r: Red bitfield.

 * @g: Green bitfield.

 * @b: Blue bitfield.

 * @a: Alpha bitfield.

/**

 * struct s3c_fb_win - per window private data for each framebuffer.

 * @windata: The platform data supplied for the window configuration.

 * @parent: The hardware that this window is part of.

 * @fbinfo: Pointer pack to the framebuffer info for this window.

 * @variant: The variant information for this window.

 * @palette_buffer: Buffer/cache to hold palette entries.

 * @pseudo_palette: For use in TRUECOLOUR modes for entries 0..15/

 * @index: The window number of this window.

 * @palette: The bitfields for changing r/g/b into a hardware palette entry.

/**

 * struct s3c_fb_vsync - vsync information

 * @wait:	a queue for processes waiting for vsync

 * @count:	vsync interrupt count

/**

 * struct s3c_fb - overall hardware state of the hardware

 * @slock: The spinlock protection for this data structure.

 * @dev: The device that we bound to, for printing, etc.

 * @bus_clk: The clk (hclk) feeding our interface and possibly pixclk.

 * @lcd_clk: The clk (sclk) feeding pixclk.

 * @regs: The mapped hardware registers.

 * @variant: Variant information for this hardware.

 * @enabled: A bitmask of enabled hardware windows.

 * @output_on: Flag if the physical output is enabled.

 * @pdata: The platform configuration data passed with the device.

 * @windows: The hardware windows that have been claimed.

 * @irq_no: IRQ line number

 * @irq_flags: irq flags

 * @vsync_info: VSYNC-related information (count, queues...)

/**

 * s3c_fb_validate_win_bpp - validate the bits-per-pixel for this mode.

 * @win: The device window.

 * @bpp: The bit depth.

/**

 * s3c_fb_check_var() - framebuffer layer request to verify a given mode.

 * @var: The screen information to verify.

 * @info: The framebuffer device.

 *

 * Framebuffer layer call to verify the given information and allow us to

 * update various information depending on the hardware capabilities.

 always ensure these are zero, for drop through cases below */

 non palletised, A:1,R:2,G:3,B:2 mode */

 666 with one bit alpha/transparency */

 666 format */

 16 bpp, 565 format */

 our 24bpp is unpacked, so 32bpp */

/**

 * s3c_fb_calc_pixclk() - calculate the divider to create the pixel clock.

 * @sfb: The hardware state.

 * @pixclk: The pixel clock wanted, in picoseconds.

 *

 * Given the specified pixel clock, work out the necessary divider to get

 * close to the output frequency.

/**

 * s3c_fb_align_word() - align pixel count to word boundary

 * @bpp: The number of bits per pixel

 * @pix: The value to be aligned.

 *

 * Align the given pixel count so that it will start on an 32bit word

 * boundary.

/**

 * vidosd_set_size() - set OSD size for a window

 *

 * @win: the window to set OSD size for

 * @size: OSD size register value

 OSD can be set up if osd_size_off != 0 for this window */

/**

 * vidosd_set_alpha() - set alpha transparency for a window

 *

 * @win: the window to set OSD size for

 * @alpha: alpha register value

/**

 * shadow_protect_win() - disable updating values from shadow registers at vsync

 *

 * @win: window to protect registers for

 * @protect: 1 to protect (disable updates)

/**

 * s3c_fb_enable() - Set the state of the main LCD output

 * @sfb: The main framebuffer state.

 * @enable: The state to set.

		/* see the note in the framebuffer datasheet about

		 * why you cannot take both of these bits down at the

/**

 * s3c_fb_set_par() - framebuffer request to set new framebuffer state.

 * @info: The framebuffer to change.

 *

 * Framebuffer layer request to set a new mode for the specified framebuffer

 disable the window whilst we update it */

 write the buffer address */

 start and end registers stride is 8 */

 write 'OSD' registers to control position of framebuffer */

 Enable DMA channel for this window */

	/* note, since we have to round up the bits-per-pixel, we end up

	 * relying on the bitfield information for r/g/b/a to work out

 Enable the colour keying for the window below this one */

 Set alpha value width */

/**

 * s3c_fb_update_palette() - set or schedule a palette update.

 * @sfb: The hardware information.

 * @win: The window being updated.

 * @reg: The palette index being changed.

 * @value: The computed palette value.

 *

 * Change the value of a palette register, either by directly writing to

 * the palette (this requires the palette RAM to be disconnected from the

 * hardware whilst this is in progress) or schedule the update for later.

 *

 * At the moment, since we have no VSYNC interrupt support, we simply set

 * the palette entry directly.

/**

 * s3c_fb_setcolreg() - framebuffer layer request to change palette.

 * @regno: The palette index to change.

 * @red: The red field for the palette data.

 * @green: The green field for the palette data.

 * @blue: The blue field for the palette data.

 * @transp: The transparency (alpha) field for the palette data.

 * @info: The framebuffer being changed.

 true-colour, use pseudo-palette */

 unknown type */

/**

 * s3c_fb_blank() - blank or unblank the given window

 * @blank_mode: The blank state from FB_BLANK_*

 * @info: The framebuffer to blank.

 *

 * Framebuffer layer request to change the power state.

 to FB_BLANK_NORMAL */

 disable the DMA and display 0x0 (black) */

	/* Check the enabled state to see if we need to be running the

	 * main LCD interface, as if there are no active windows then

	 * it is highly likely that we also do not need to output

	 * anything.

/**

 * s3c_fb_pan_display() - Pan the display.

 *

 * Note that the offsets can be written to the device at any time, as their

 * values are latched at each vsync automatically. This also means that only

 * the last call to this function will have any effect on next vsync, but

 * there is no need to sleep waiting for it to prevent tearing.

 *

 * @var: The screen information to verify.

 * @info: The framebuffer device.

 Offset in bytes to the start of the displayed area */

 X offset depends on the current bpp */

 Offset in bytes to the end of the displayed area */

	/* Temporarily turn off per-vsync update from shadow registers until

/**

 * s3c_fb_enable_irq() - enable framebuffer interrupts

 * @sfb: main hardware state

 IRQ disabled, enable it */

/**

 * s3c_fb_disable_irq() - disable framebuffer interrupts

 * @sfb: main hardware state

 IRQ enabled, disable it */

 VSYNC interrupt, accept it */

	/* We only support waiting for VSYNC for now, so it's safe

	 * to always disable irqs here.

/**

 * s3c_fb_wait_for_vsync() - sleep until next VSYNC interrupt or timeout

 * @sfb: main hardware state

 * @crtc: head index.

/**

 * s3c_fb_missing_pixclock() - calculates pixel clock

 * @mode: The video mode to change.

 *

 * Calculate the pixel clock when none has been given through platform data.

/**

 * s3c_fb_alloc_memory() - allocate display memory for framebuffer window

 * @sfb: The base resources for the hardware.

 * @win: The window to initialise memory for.

 *

 * Allocate memory for the given framebuffer.

/**

 * s3c_fb_free_memory() - free the display memory for the given window

 * @sfb: The base resources for the hardware.

 * @win: The window to free the display memory for.

 *

 * Free the display memory allocated by s3c_fb_alloc_memory().

/**

 * s3c_fb_release_win() - release resources for a framebuffer window.

 * @sfb: The base resources for the hardware.

 * @win: The window to cleanup the resources for.

 *

 * Release the resources that where claimed for the hardware window,

 * such as the framebuffer instance and any memory claimed for it.

/**

 * s3c_fb_probe_win() - register an hardware window

 * @sfb: The base resources for the hardware

 * @win_no: The window number

 * @variant: The variant information for this window.

 * @res: Pointer to where to place the resultant window.

 *

 * Allocate and do the basic initialisation for one of the hardware's graphics

 * windows.

 setup the r/b/g positions for the window's palette */

 Set RGB 5:6:5 as default */

 Set 8bpp or 8bpp and 1bit alpha */

 setup the initial video mode from the window */

 prepare to actually start the framebuffer */

 create initial colour map */

 run the check_var and set_par on our configuration. */

/**

 * s3c_fb_set_rgb_timing() - set video timing for rgb interface.

 * @sfb: The base resources for the hardware.

 *

 * Set horizontal and vertical lcd rgb interface timing.

 1:1 clock */

/**

 * s3c_fb_clear_win() - clear hardware window registers.

 * @sfb: The base resources for the hardware.

 * @win: The window to process.

 *

 * Reset the specific window registers to a known state.

 setup gpio and output polarity controls */

 set video clock running at under-run */

 zero all windows before we do anything */

 initialise colour key controls */

 we have the register setup, start allocating framebuffers */

/**

 * s3c_fb_remove() - Cleanup on module finalisation

 * @pdev: The platform device we are bound to.

 *

 * Shutdown and then release all the resources that the driver allocated

 * on initialisation.

 use the blank function to push into power-down */

 setup gpio and output polarity controls */

 set video clock running at under-run */

 zero all windows before we do anything */

 restore framebuffers */

 setup gpio and output polarity controls */

 S3C2443/S3C2416 style hardware */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2007 Google, Inc.

 * Copyright (C) 2012 Intel, Inc.

 updates base */

/*

 *  Freescale i.MX Frame Buffer device driver

 *

 *  Copyright (C) 2004 Sascha Hauer, Pengutronix

 *   Based on acornfb.c Copyright (C) Russell King.

 *

 * This file is subject to the terms and conditions of the GNU General Public

 * License.  See the file COPYING in the main directory of this archive for

 * more details.

 *

 * Please direct your questions and comments on this driver to the following

 * email address:

 *

 *	linux-arm-kernel@lists.arm.linux.org.uk

/*

 * Complain if VAR is out of range.

 bit fields in imxfb.h */

 bit fields in imxfb.h */

 bit fields in imxfb.h */

 Used fb-mode. Can be set on kernel command line, therefore file-static. */

/*

 * These are the bitfields for each

 * display depth that we support.

	/*

	 * These are the addresses we mapped

	 * the framebuffer memory region to.

 sentinel */

 sentinel */

/*

 * Minimum X and Y resolutions

/* Actually this really is 18bit support, the lowest 2 bits of each colour

 * are unused in hardware. We claim to have 24bit support to make software

 * like X work, which does not support 18bit.

	/*

	 * If inverse mode was selected, invert all the colours

	 * rather than the register number.  The register number

	 * is what you poke into the framebuffer to produce the

	 * colour you requested.

	/*

	 * If greyscale is true, then we convert the RGB value

	 * to greyscale no mater what visual we are using.

		/*

		 * 12 or 16-bit True Colour.  We encode the RGB value

		 * according to the RGB bitfield information.

/*

 *  imxfb_check_var():

 *    Round up in the following order: bits_per_pixel, xres,

 *    yres, xres_virtual, yres_virtual, xoffset, yoffset, grayscale,

 *    bitfields, horizontal timing, vertical timing.

 add sync polarities */

	/*

	 * The LCDC AUS Mode Control Register does not exist on imx1.

	/*

	 * Copy the RGB parameters for this display

	 * from the machine specific parameters.

/*

 * imxfb_set_par():

 *	Set the user defined part of the display for the specified console

		/*

		 * Some people have weird ideas about wanting static

		 * pseudocolor maps.  I suspect their user space

		 * applications are broken.

 panning offset 0 (0 pixel offset)        */

 disable hardware cursor */

	/*

	 * RMCR_LCDC_EN_MX1 is present on i.MX1 only, but doesn't hurt

	 * on other SoCs

/*

 * imxfb_activate_var():

 *	Configures LCD Controller based on entries in var parameter.  Settings are

 *	only written to the controller if changes were made.

 physical screen start address	    */

 dmacr = 0 is no valid value, as we need DMA control marks. */

	/*

	 * fsl,aus-mode is optional

		/*

		 * imxfb does not support more modes, we choose only the native

		 * mode.

	/* Calculate maximum bytes used per pixel. In most cases this should

	/*

	 * The LCDC controller does not have an enable bit. The

	 * controller starts directly when the clocks are enabled.

	 * If the clocks are enabled when the controller is not yet

	 * programmed with proper register values (enabled at the

	 * bootloader, for example) then it just goes into some undefined

	 * state.

	 * To avoid this issue, let's enable and disable LCDC IPG clock

	 * so that we force some kind of 'reset' to the LCDC block.

	/*

	 * This makes sure that our colour bitfield

	 * descriptors are correctly initialised.

	/*

	 * For modes > 8bpp, the color map is bypassed.

	 * Therefore, 256 entries are enough.

/*

 * linux/drivers/video/q40fb.c -- Q40 frame buffer device

 *

 * Copyright (C) 2001

 *

 *      Richard Zidlicky <rz@linux-m68k.org>

 *

 *  This file is subject to the terms and conditions of the GNU General Public

 *  License. See the file COPYING in the main directory of this archive for

 *  more details.

    /*

     *  Set a single color register. The values supplied have a 16 bit

     *  magnitude.

     *  Return != 0 for invalid regno.

 mapped in q40/config.c */

 not as module for now */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Frame buffer driver for the Carmine GPU.

 *

 * The driver configures the GPU as follows

 * - FB0 is display 0 with unique memory area

 * - FB1 is display 1 with unique memory area

 * - both display use 32 bit colors

/*

 * The initial video mode can be supplied via two different ways:

 * - as a string that is passed to fb_find_mode() (module option fb_mode_str)

 * - as an integer that picks the video mode from carmine_modedb[] (module

 *   option fb_mode)

 *

 * If nothing is used than the initial video mode will be the

 * CARMINEFB_DEFAULT_VIDEO_MODE member of the carmine_modedb[].

/*

 * Carminefb displays:

 * 0b000 None

 * 0b001 Display 0

 * 0b010 Display 1

 640x480 */

 800x600 */

 Set default cursor position */

 Set default display mode */

 Set default frame size to layer mode register */

 Set default pos and size */

 Set default origin address */

 Set default display address */

 Set default display position */

 Set default blend mode */

 default transparency mode */

 Set default read skip parameter */

	/*

	 * display timing. Parameters are decreased by one because hardware

	 * spec is 0 to (n - 1)

 clock */

 enable video output and layer 0 */

 Initialize Carmine */

 Sets internal clock */

 Video signal output is turned off */

 Software reset */

 I/O mode settings */

 DRAM initial sequence */

 Executes DLL reset */

 Initialize the write back register */

 Initialize the Kottos registers */

 Set DC offsets */

	/* The memory area tends to be very large (256 MiB). Remap only what

	 * is required for that largest resolution to avoid remaps at run

	 * time

 disable clock, etc */

 in case we use only fb1 and not fb1 */

 deactivate display(s) and switch clocks */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * macfb.c: Generic framebuffer for Macs whose colourmaps/modes we

 * don't know how to set.

 *

 * (c) 1999 David Huggins-Daines <dhd@debian.org>

 *

 * Primarily based on vesafb.c, by Gerd Knorr

 * (c) 1998 Gerd Knorr <kraxel@cs.tu-berlin.de>

 *

 * Also uses information and code from:

 *

 * The original macfb.c from Linux/mac68k 2.0, by Alan Cox, Juergen

 * Mellinger, Mikael Forselius, Michael Schmitz, and others.

 *

 * valkyriefb.c, by Martin Costabel, Kevin Schoedel, Barry Nathan, Dan

 * Jacobowitz, Paul Mackerras, Fabio Riccardi, and Geert Uytterhoeven.

 *

 * The VideoToolbox "Bugs" web page at

 * http://rajsky.psych.nyu.edu/Tips/VideoBugs.html

 Common DAC base address for the LC, RBV, Valkyrie, and IIvx */

 Some addresses for the DAFB */

 Address for the built-in Civic framebuffer in Quadra AVs */

 GSC (Gray Scale Controller) base address */

 CSC (Color Screen Controller) base address */

 word aligned */

 word aligned */

 a guess as to purpose */

 OFFSET: 0x00 */

 OFFSET: 0x10 */

 OFFSET: 0x20 */

 OFFSET: 0x28 */

 OFFSET: 0x2C */

 0x40 */

 0x42 */

 0x46 */

 The registers in these structs are in NuBus slot space */

 TFBClutWDataReg, offset 0x90018 */

 TFBClutAddrReg, offset 0x9001C */

 width in mm at 72 dpi */

/*

 * Unlike the Valkyrie, the DAFB cannot set individual colormap

 * registers.  Therefore, we do what the MacOS driver does (no

 * kidding!) and simply set them one by one until we hit the one we

 * want.

	/*

	 * fbdev will set an entire colourmap, but X won't.  Hopefully

	 * this should accommodate both of them

 Stab in the dark trying to reset the CLUT pointer */

 Loop until we get to the register we want */

 V8 and Brazil seem to use the same DAC.  Sonora does as well. */

	/* On these chips, the CLUT register numbers are spread out

	 * across the register space.  Thus:

	 * In 8bpp, all regnos are valid.

	 * In 4bpp, the regnos are 0x0f, 0x1f, 0x2f, etc, etc

	 * In 2bpp, the regnos are 0x3f, 0x7f, 0xbf, 0xff

 send one color channel at a time */

 RAM-Based Video */

	/* From the VideoToolbox driver.  Seems to be saying that

	 * regno #254 and #255 are the important ones for 1-bit color,

	 * regno #252-255 are the important ones for 2-bit color, etc.

 reset clut? (VideoToolbox sez "not necessary") */

 tell clut which address to use. */

 send one color channel at a time. */

 Macintosh Display Card (8*24) */

 the nop's are there to order writes. */

 Toby frame buffer */

 Jet frame buffer */

/*

 * Civic framebuffer -- Quadra AV built-in video.  A chip

 * called Sebastian holds the actual color palettes, and

 * apparently, there are two different banks of 512K RAM

 * which can act as separate framebuffers for doing video

 * input and viewing the screen at the same time!  The 840AV

 * Can add another 1MB RAM to give the two framebuffers

 * 1MB RAM apiece.

 Set the register address */

	/*

	 * Grab a status word and do some checking;

	 * Then finally write the clut!

/*

 * The CSC is the framebuffer on the PowerBook 190 series

 * (and the 5300 too, but that's a PowerMac). This function

 * brought to you in part by the ECSC driver for MkLinux.

 mklinux on PB 5300 waits for 260 ns */

	/*

	 * Set a single color register. The values supplied are

	 * already rounded down to the hardware's capabilities

	 * (according to the entries in the `var' structure).

	 * Return non-zero for invalid regno.

 We shouldn't get here */

 1:5:5:5 */

 0:5:6:5 */

		/*

		 * 24-bit colour almost doesn't exist on 68k Macs --

		 * https://support.apple.com/kb/TA28634 (Old Article: 10992)

 enable experimental CLUT code */

 See valkyriefb.c */

 Note: physical address (since 2.1.127) */

	/*

	 * This is actually redundant with the initial mappings.

	 * However, there are some non-obvious aspects to the way

	 * those mappings are set up, so this is in fact the safest

	 * way to ensure that this driver will work on every possible Mac

 Fill in the available video resolution */

 Some dummy values for timing to make fbset happy */

		/*

		 * Should actually be FB_VISUAL_DIRECTCOLOR, but this

		 * works too

	/*

	 * We take a wild guess that if the video physical address is

	 * in nubus slot space, that the nubus card is driving video.

	 * Penguin really ought to tell us whether we are using internal

	 * video or not.

	 * Hopefully we only find one of them.  Otherwise our NuBus

	 * code is really broken :-)

 If it's not a NuBus card, it must be internal video */

		/*

		 * DAFB Quadras

		 * Note: these first four have the v7 DAFB, which is

		 * known to be rather unlike the ones used in the

		 * other models

		/*

		 * LC II uses the V8 framebuffer

		/*

		 * IIvi, IIvx use the "Brazil" framebuffer (which is

		 * very much like the V8, it seems, and probably uses

		 * the same DAC)

		/*

		 * LC III (and friends) use the Sonora framebuffer

		 * Incidentally this is also used in the non-AV models

		 * of the x100 PowerMacs

		 * These do in fact seem to use the same DAC interface

		 * as the LC II.

		/*

		 * IIci and IIsi use the infamous RBV chip

		 * (the IIsi is just a rebadged and crippled

		 * IIci in a different case, BTW)

		/*

		 * AVs use the Civic framebuffer

		/*

		 * Assorted weirdos

		 * We think this may be like the LC II

		/*

		 * We think this may be like the LC II

		/*

		 * And we *do* mean "weirdos"

		/*

		 * These don't have colour, so no need to worry

		/*

		 * Powerbooks are particularly difficult.  Many of

		 * them have separate framebuffers for external and

		 * internal video, which is admittedly pretty cool,

		 * but will be a bit of a headache to support here.

		 * Also, many of them are grayscale, and we don't

		 * really support that.

		/*

		 * Slot 0 ROM says TIM. No external video. B&W.

		/*

		 * Internal is GSC, External (if present) is ViSC

 no external video */

		/*

		 * Internal is TIM, External is ViSC

		/*

		 * Internal is CSC, External is Keystone+Ariel.

 external video is optional */

 SPDX-License-Identifier: GPL-2.0-only

/* linux/drivers/video/sm501fb.c

 *

 * Copyright (c) 2006 Simtec Electronics

 *	Vincent Sanders <vince@simtec.co.uk>

 *	Ben Dooks <ben@simtec.co.uk>

 *

 * Framebuffer driver for the Silicon Motion SM501

/* SM501 memory address.

 *

 * This structure is used to track memory usage within the SM501 framebuffer

 * allocation. The sm_addr field is stored as an offset as it is often used

 * against both the physical and mapped addresses.

 offset from base of sm501 fb. */

 private data that is shared between all frambuffers* */

 fb info for both heads */

 framebuffer resource */

 registers resource */

 2d registers resource */

 our platform data */

 pm: crt ctrl save */

 set to swap rgb=>bgr */

 remapped registers */

 2d remapped registers */

 remapped framebuffer */

 length of remapped region */

 per-framebuffer private data */

 Helper functions */

/* sm501fb_sync_regs()

 *

 * This call is mainly for PCI bus systems where we need to

 * ensure that any writes to the bus are completed before the

 * next phase, or after completing a function.

/* sm501_alloc_mem

 *

 * This is an attempt to lay out memory for the two framebuffers and

 * everything else

 *

 * |fbmem_res->start					       fbmem_res->end|

 * |									     |

 * |fb[0].fix.smem_start    |	      |fb[1].fix.smem_start    |     2K	     |

 * |-> fb[0].fix.smem_len <-| spare   |-> fb[1].fix.smem_len <-|-> cursors <-|

 *

 * The "spare" space is for the 2d engine data

 * the fixed is space for the cursors (2x1Kbyte)

 *

 * we need to allocate memory for the 2D acceleration engine

 * command list and the data for the engine to deal with.

 *

 * - all allocations must be 128bit aligned

 * - cursors are 64x64x2 bits (1Kbyte)

 *

 adjust available memory. */

		/* round down, some programs such as directfb do not draw

		 * 0,0 correctly unless the start is aligned to a page start.

		/* check to see if we have panel memory allocated

/* sm501fb_ps_to_hz

 *

 * Converts a period in picoseconds to Hz.

 *

 * Note, we try to keep this in Hz to minimise rounding with

 * the limited PLL settings on the SM501.

 10^12 / picosecond period gives frequency in Hz */

 sm501fb_hz_to_ps is identical to the opposite transform */

/* sm501fb_setup_gamma

 *

 * Programs a linear 1.0 gamma ramp in case the gamma

 * correction is enabled without programming anything else.

 set gamma values */

 Advance RGB by 1,1,1.*/

/* sm501fb_check_var

 *

 * check common variables for both panel and crt

 check we can fit these values into the registers */

 hdisplay end and hsync start */

 vdisplay end and vsync start */

 hard limits of device */

 check our line length is going to be 128 bit aligned */

 check the virtual size */

 can cope with 8,16 or 32bpp */

 set r/g/b positions and validate bpp */

/*

 * sm501fb_check_var_crt():

 *

 * check the parameters for the CRT head, and either bring them

 * back into range, or return -EINVAL.

/* sm501fb_check_var_pnl():

 *

 * check the parameters for the CRT head, and either bring them

 * back into range, or return -EINVAL.

/* sm501fb_set_par_common

 *

 * set common registers for framebuffers

 pixelclock in Hz */

 pixelclock the 501 can achieve in Hz */

 stop compiler warnings */

 allocate fb memory within 501 */

 set start of framebuffer to the screen */

 program CRT clock  */

 update fb layer with actual clock used */

/* sm501fb_set_par_geometry

 *

 * set the geometry registers for specified framebuffer.

 set framebuffer width and display width */

 program horizontal total */

 program horizontal sync */

 program vertical total */

 program vertical sync */

/* sm501fb_pan_crt

 *

 * pan the CRT display output within an virtual framebuffer

/* sm501fb_pan_pnl

 *

 * pan the panel display output within an virtual framebuffer

/* sm501fb_set_par_crt

 *

 * Set the CRT video mode from the fb_info structure

 control register */

 activate new configuration */

 enable CRT DAC - note 0 is on!*/

 set the sync polarities before we check data source  */

 the head is displaying panel data... */

 fill if >3 free slots */

 CRT displays CRT data */

 enable CRT timing */

 enable CRT plane */

 enable panel power */

 FPVDDEN */

 DATA */

 VBIASEN */

 disable panel power */

/* sm501fb_set_par_pnl

 *

 * Set the panel video mode from the fb_info structure

 activate this new configuration */

 update control register */

 fill if >3 free slots */

 panel plane top left and bottom right location */

 program panel control register */

 enable PANEL timing */

 enable PANEL gfx plane */

 ensure the panel interface is not tristated at this point */

 power the panel up */

/* chan_to_field

 *

 * convert a colour value into a field position

 *

 * from pxafb.c

/* sm501fb_setcolreg

 *

 * set the colour mapping for modes that support palettised data

 true-colour, use pseuo-palette */

 unknown type */

/* sm501fb_blank_pnl

 *

 * Blank or un-blank the panel interface

/* sm501fb_blank_crt

 *

 * Blank or un-blank the crt interface

/* sm501fb_cursor

 *

 * set or change the hardware cursor parameters

 check not being asked to exceed capabilities */

 set data */

y += cursor->image.height;

		/* SM501 cursor is a two bpp 64x64 bitmap this routine

		 * clears it to transparent then combines the cursor

		 * shape plane with the colour plane to set the

 ensure cursor data flushed */

/* sm501fb_crtsrc_show

 *

 * device attribute code to show where the crt output is sourced from

/* sm501fb_crtsrc_show

 *

 * device attribute code to set where the crt output is sourced from

 Prepare the device_attr for registration with sysfs later */

/* sm501fb_show_regs

 *

 * show the primary sm501 registers

/* sm501fb_debug_show_crt

 *

 * show the crt control and cursor registers

/* sm501fb_debug_show_pnl

 *

 * show the panel control and cursor registers

 acceleration operations */

 wait for the 2d engine to be ready */

 source clip */

 source Area not within virtual screen, skipping */

 dest clip */

 Destination Area not within virtual screen, skipping */

 set the base addresses */

 set the window width */

 set window stride */

 set data format */

 2d compare mask */

 2d mask */

 source and destination x y */

 w/h */

 do area move */

 Rectangle not within virtual screen, skipping */

 set the base addresses */

 set the window width */

 set window stride */

 set data format */

 2d compare mask */

 2d mask */

 colour */

 x y */

 w/h */

 do rectangle fill */

/* sm501_init_cursor

 *

 * initialise hw cursor parameters

 initialise the colour registers */

/* sm501fb_info_start

 *

 * fills the par structure claiming resources and remapping etc.

 we currently do not use the IRQ */

	/* allocate, reserve and remap resources for display

	/* allocate, reserve and remap resources for 2d

 allocate, reserve resources for framebuffer */

 clear framebuffer memory - avoids garbage data on unused fb */

 clear palette ram - undefined at power on */

 enable display controller */

 enable 2d controller */

 setup cursors */

 everything is setup */

 disable display controller */

 ensure we set the correct source register */

 stop compiler warnings */

 check to see if our routing allows this */

 update ops dependent on what we've been passed */

 fixed data */

 screenmode */

 Now build modedb from EDID */

 TODO read the mode from the current display */

 edid_data is no longer needed, free it */

 initialise and set the palette */

 default platform data if none is supplied (ie, PCI device) */

 Do not initialise if we've not been given any platform data */

 Free up anything allocated by sm501fb_init_fb */

 allocate our framebuffers */

 Get EDID */

 probe for the presence of each panel */

 get the resources for both of the framebuffers */

 we registered, return ok */

/*

 *  Cleanup

 blank the relevant interface to ensure unit power minimised */

 tell console/fb driver we are suspending */

 backup copies in case chip is powered down over suspend */

 re-activate the configuration */

 restore the data */

 suspend and resume support */

 store crt control to resume with */

 turn off the clocks, in case the device is not powered down */

 restore the items we want to be saved for crt control */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Simplest possible simple frame-buffer driver, as a platform device

 *

 * Copyright (c) 2013, Stephen Warren

 *

 * Based on q40fb.c, which was:

 * Copyright (C) 2001 Richard Zidlicky <rz@linux-m68k.org>

 *

 * Also based on offb.c, which was:

 * Copyright (C) 1997 Geert Uytterhoeven

 * Copyright (C) 1996 Paul Mackerras

/*

 * Clock handling code.

 *

 * Here we handle the clocks property of our "simple-framebuffer" dt node.

 * This is necessary so that we can make sure that any clocks needed by

 * the display engine that the bootloader set up for us (and for which it

 * provided a simplefb dt node), stay up, for the life of the simplefb

 * driver.

 *

 * When the driver unloads, we cleanly disable, and then release the clocks.

 *

 * We only complain about errors here, no action is taken as the most likely

 * error can only happen due to a mismatch between the bootloader which set

 * up simplefb, and the clock definitions in the device tree. Chances are

 * that there are no adverse effects, and if there are, a clean teardown of

 * the fb probe will not help us much either. So just complain and carry on,

 * and hope that the user actually gets a working fb at the end of things.

/*

 * Regulator handling code.

 *

 * Here we handle the num-supplies and vin*-supply properties of our

 * "simple-framebuffer" dt node. This is necessary so that we can make sure

 * that any regulators needed by the display hardware that the bootloader

 * set up for us (and for which it provided a simplefb dt node), stay up,

 * for the life of the simplefb driver.

 *

 * When the driver unloads, we cleanly disable, and then release the

 * regulators.

 *

 * We only complain about errors here, no action is taken as the most likely

 * error can only happen due to a mismatch between the bootloader which set

 * up simplefb, and the regulator definitions in the device tree. Chances are

 * that there are no adverse effects, and if there are, a clean teardown of

 * the fb probe will not help us much either. So just complain and carry on,

 * and hope that the user actually gets a working fb at the end of things.

 Count the number of regulator supplies */

 Get all the regulators */

 32 is max size of property name */

 Enable all the regulators */

	/*

	 * Generic drivers must not be registered if a framebuffer exists.

	 * If a native driver was probed, the display hardware was already

	 * taken and attempting to use the system framebuffer is dangerous.

/*

 * Xen para-virtual frame buffer device

 *

 * Copyright (C) 2005-2006 Anthony Liguori <aliguori@us.ibm.com>

 * Copyright (C) 2006-2008 Red Hat, Inc., Markus Armbruster <armbru@redhat.com>

 *

 *  Based on linux/drivers/video/q40fb.c

 *

 *  This file is subject to the terms and conditions of the GNU General Public

 *  License. See the file COPYING in the main directory of this archive for

 *  more details.

/*

 * TODO:

 *

 * Switch to grant tables when they become capable of dealing with the

 * frame buffer.

	int			x1, y1, x2, y2;	/* dirty rectangle,

 XENFB_TYPE_UPDATE wanted */

 XENFB_TYPE_RESIZE ok */

 protected by resize_lock */

 ditto */

 caller ensures !xenfb_queue_full() */

 ensure ring space available */

 ensure ring contents visible */

 caller ensures !xenfb_queue_full() */

 caller ensures !xenfb_queue_full() */

 Combine with dirty rectangle: */

 Can't send right now, stash it in the dirty rectangle */

 Clear dirty rectangle: */

 Can't resize past initial width and height */

	/*

	 * No in events recognized, simply ignore them all.

	 * If you need to recognize some, see xen-kbdfront's

	 * input_handler() for how to do that.

 Flush dirty rectangle: */

 Limit kernel param videoram amount to what is in xenstore */

 If requested res does not fit in available memory, use default */

 set up shared page */

 abusing framebuffer_alloc() to allocate pseudo_palette */

 complete the abuse: */

 don't print again */

 Prevent xenfb refresh */

		/*

		 * Work around xenbus race condition: If backend goes

		 * through InitWait to Connected fast enough, we can

		 * get Connected twice here.

 no InitWait seen yet, fudge it */

 Missed the backend's CLOSING state */

 Nothing to do if running in dom0. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  linux/drivers/video/wmt_ge_rops.c

 *

 *  Accelerators for raster operations using WonderMedia Graphics Engine

 *

 *  Copyright (C) 2010 Alexey Charkov <alchark@gmail.com>

 Pattern 0 color */

 Only one ROP engine is presently supported. */

 sentinel */ }

/*

 *  linux/drivers/video/iplan2p4.c -- Low level frame buffer operations for

 *				      interleaved bitplanes à la Atari (4

 *				      planes, 2 bytes interleave)

 *

 *	Created 5 Apr 1997 by Geert Uytterhoeven

 *

 *  This file is subject to the terms and conditions of the GNU General Public

 *  License.  See the file COPYING in the main directory of this archive for

 *  more details.

	/*  bmove() has to distinguish two major cases: If both, source and

	 *  destination, start at even addresses or both are at odd

	 *  addresses, just the first odd and last even column (if present)

	 *  require special treatment (memmove_col()). The rest between

	 *  then can be copied by normal operations, because all adjacent

	 *  bytes are affected and are to be stored in the same order.

	 *    The pathological case is when the move should go from an odd

	 *  address to an even or vice versa. Since the bytes in the plane

	 *  words must be assembled in new order, it seems wisest to make

	 *  all movements by memmove_col().

 odd->odd or even->even */

 odd->even or even->odd */

/*

 * BRIEF MODULE DESCRIPTION

 *	Au1100 LCD Driver.

 *

 * Rewritten for 2.6 by Embedded Alley Solutions

 * 	<source@embeddedalley.com>, based on submissions by

 *  	Karl Lessard <klessard@sunrisetelecom.com>

 *  	<c.pellegrin@exadron.com>

 *

 * PM support added by Rodolfo Giometti <giometti@linux.it>

 * Cursor enable/disable by Rodolfo Giometti <giometti@linux.it>

 *

 * Copyright 2002 MontaVista Software

 * Author: MontaVista Software, Inc.

 *		ppopov@mvista.com or source@mvista.com

 *

 * Copyright 2002 Alchemy Semiconductor

 * Author: Alchemy Semiconductor

 *

 * Based on:

 * linux/drivers/video/skeletonfb.c -- Skeleton for a frame buffer device

 *  Created 28 Dec 1997 by Geert Uytterhoeven

 *

 *  This program is free software; you can redistribute	 it and/or modify it

 *  under  the terms of	 the GNU General  Public License as published by the

 *  Free Software Foundation;  either version 2 of the	License, or (at your

 *  option) any later version.

 *

 *  THIS  SOFTWARE  IS PROVIDED	  ``AS	IS'' AND   ANY	EXPRESS OR IMPLIED

 *  WARRANTIES,	  INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF

 *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN

 *  NO	EVENT  SHALL   THE AUTHOR  BE	 LIABLE FOR ANY	  DIRECT, INDIRECT,

 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT

 *  NOT LIMITED	  TO, PROCUREMENT OF  SUBSTITUTE GOODS	OR SERVICES; LOSS OF

 *  USE, DATA,	OR PROFITS; OR	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON

 *  ANY THEORY OF LIABILITY, WHETHER IN	 CONTRACT, STRICT LIABILITY, OR TORT

 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF

 *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 *

 *  You should have received a copy of the  GNU General Public License along

 *  with this program; if not, write  to the Free Software Foundation, Inc.,

 *  675 Mass Ave, Cambridge, MA 02139, USA.

/* Bitfields format supported by the controller. Note that the order of formats

 * SHOULD be the same as in the LCD_CONTROL_SBPPF field, so we can retrieve the

 * right pixel format by doing rgb_bitfields[LCD_CONTROL_SBPPF_XXX >> LCD_CONTROL_SBPPF]

     Red, 	   Green, 	 Blue, 	     Transp   */

 The last is used to describe 12bpp format */

/* fb_blank

 * Blank the screen. Depending on the mode, the screen will be

 * activated with the backlight color, or desactivated

 Turn on panel */

 drain writebuffer */

 Turn off panel */

 drain writebuffer */

/*

 * Set hardware with var settings. This will enable the controller with a specific

 * mode, normally validated with the fb_check_var method

 Update var-dependent FB info */

 palettized */

 non-palettized */

 depth=16 */

 mono */

 Determine BPP mode and format */

		/* Second panel display seconf half of screen if possible,

 180 */) {

 should be divisable by 8 */

 Resume controller */

/* fb_setcolreg

 * Set color in LCD palette.

 Convert color to grayscale */

 Place color in the pseudopalette */

 COLOR TFT PALLETTIZED (use RGB 565) */

 COLOR STN MODE */

 MONOCHROME MODE */

/* fb_pan_display

 * Pan display in x and/or y as specified

 No support for X panning for now! */

 TODO: Wait for current frame to finished */

/* fb_mmap

 * Map video memory in user space. We don't use the generic fb_mmap method mainly

 * to allow the use of the TLB streaming flag (CCA=6)

CCA=6

-------------------------------------------------------------------------*/

 Panel option */

 Unsupported option */

 Allocate new device private */

 Allocate region for our registers and map them */

 Allocate the framebuffer to the maximum screen size * nbr of video buffers */

 load the panel info into the var struct */

 Set h/w registers */

 Register new framebuffer */

 Clean up all probe data */

 Blank the LCD */

 Unblank the LCD */

/*

 * linux/drivers/video/s3fb.c -- Frame buffer device driver for S3 Trio/Virge

 *

 * Copyright (c) 2006-2007 Ondrej Zajicek <santiago@crfreenet.org>

 *

 * This file is subject to the terms and conditions of the GNU General Public

 * License.  See the file COPYING in the main directory of this archive for

 * more details.

 *

 * Code is based on David Boucher's viafb (http://davesdomain.org.uk/viafb/)

 * which is based on the code of neofb.

 Why should fb driver call console functions? because console_lock() */

 ------------------------------------------------------------------------- */

 CRT timing register sets */

 set 0x43 bit 2 to 0 */

 ------------------------------------------------------------------------- */

 Module parameters */

 ------------------------------------------------------------------------- */

 Trio 3D/1X/2X */

 all other chips */

	/*

	 * some Virge cards have external MUX to switch chip I2C bus between

	 * DDC and extension pins - switch it do DDC

	vga_wseq(par->state.vgabase, 0x08, 0x06); - not needed, already unlocked */

 some Virge need this or the DDC is ignored */

 CONFIG_FB_S3_DDC */

 ------------------------------------------------------------------------- */

 Set font in S3 fast text mode */

 ------------------------------------------------------------------------- */

 image data is MSB-first, fb structure is MSB-first too */

 s3fb_iplan_imageblit silently assumes that almost everything is 8-pixel aligned */

 s3fb_iplan_fillrect silently assumes that almost everything is 8-pixel aligned */

 image data is MSB-first, fb structure is high-nibble-in-low-byte-first */

 s3fb_cfb4_imageblit silently assumes that almost everything is 8-pixel aligned */

 ------------------------------------------------------------------------- */

 Set VGA misc register  */

 Set S3 clock registers */

 n and two bits of r */

 remaining highest bit of r */

 Activate clock - write 0, 1, 0 to seq/15 bit 5 */

 | 0x80; */

 Open framebuffer */

 Close framebuffer */

 Validate passed in var */

 Find appropriate format */

	/* 32bpp mode is not supported on VIRGE VX,

 Do not allow to have real resoulution larger than virtual */

 Round up xres_virtual to have proper alignment of lines */

 Check whether have enough memory */

 Set video mode from par */

 in 4bpp supports 8p wide tiles only, any tiles otherwise */

 supports 8x16 tiles only */

 Unlock registers */

 Blank screen and turn off sync */

 Set default values */

 S3 specific initialization */

 enable linear framebuffer */

 enable sequencer access to framebuffer above 256 kB */

	svga_wcrt_mask(par->state.vgabase, 0x33, 0x08, 0x08); */ 
	svga_wcrt_mask(par->state.vgabase, 0x43, 0x01, 0x01); */ 
 no DDR ?	*/

 no DDR ?	*/

 Clear strange HSlen bits */

	svga_wcrt_mask(par->state.vgabase, 0x58, 0x03, 0x03); */

	svga_wcrt_mask(par->state.vgabase, 0x53, 0x12, 0x13); */ 
	svga_wcrt_mask(par->state.vgabase, 0x40, 0x08, 0x08); */ 
 Set the offset register */

 M parameter */

 N parameter */

 L parameter */

 L parameter */

 Disable hardware graphics cursor */

 Disable Streams engine */

 S3 virge DX hack */

 S3 virge VX hack */

 screen remains blank sometimes without this */

 enable Data Transfer Position Control (DTPC) */

 Set mode-specific register values */

 Set additional registers like in 8-bit mode */

 Disable enhanced mode */

 Set additional registers like in 8-bit mode */

 disable enhanced mode */

 Set additional registers like in 8-bit mode */

 disable enhanced mode */

 VIRGE VX case */

 Set interlaced mode start/end register */

 Set Data Transfer Position */

 + 2 is needed for Virge/VX, does no harm on other cards */

 Device and screen back on */

 Set a colour register */

 Set the display blanking state */

 Pan the display */

 Calculate the offset */

 Set the offset */

 ------------------------------------------------------------------------- */

 Frame buffer operations */

 ------------------------------------------------------------------------- */

 PCI probe */

 Ignore secondary VGA device because there is no VGA arbitration */

 Allocate and fill driver data structure */

 Prepare PCI device */

 Map physical IO memory address into kernel space */

 Unlock regs */

 Identify chip type */

 Find how many physical memory there is on card */

 0x36 register is accessible even if other registers are locked */

 8MB -- only 4MB usable for display */

 4MB with 32-bit bus */

 4MB */

 2MB on 365 Trio3D */

 2MB */

 4MB */

 2MB */

 2MB */

 4MB */

 6MB */

 8MB */

 off-screen memory */

 4MB */

 2MB */

 Find MCLK frequency */

 Restore locks */

 Enable MMIO if needed */

 enable MMIO */

 fill all other info->var's fields */

 Prepare startup mode */

 maximize virtual vertical size for fast scrolling */

 Record a reference to the driver data */

 Error handling */

	pci_disable_device(dev); */

 PCI remove */

		pci_disable_device(dev); */

 PCI suspend */

 PCI resume */

 List of boards that we are trying to support */

 Parse user specified options */

 Cleanup */

 Driver Initialisation */

 ------------------------------------------------------------------------- */

 Modularization */

/* sunxvr500.c: Sun 3DLABS XVR-500 Expert3D fb driver for sparc64 systems

 *

 * License: GPL

 *

 * Copyright (C) 2007 David S. Miller (davem@davemloft.net)

/* XXX This device has a 'dev-comm' property which apparently is

 * XXX a pointer into the openfirmware's address space which is

 * XXX a shared area the kernel driver can use to keep OBP

 * XXX informed about the current resolution setting.  The idea

 * XXX is that the kernel can change resolutions, and as long

 * XXX as the values in the 'dev-comm' area are accurate then

 * XXX OBP can still render text properly to the console.

 * XXX

 * XXX I'm still working out the layout of this and whether there

 * XXX are any signatures we need to look for etc.

/* My XVR-500 comes up, at 1280x768 and a FB base register value of

 * 0x04000000, the following video layout register values:

 *

 * RAMDAC_VID_WH	0x03ff04ff

 * RAMDAC_VID_CFG	0x1a0b0088

 * RAMDAC_VID_32FB_0	0x04000000

 * RAMDAC_VID_32FB_1	0x04800000

 * RAMDAC_VID_8FB_0	0x05000000

 * RAMDAC_VID_8FB_1	0x05200000

 * RAMDAC_VID_XXXFB	0x05400000

 * RAMDAC_VID_YYYFB	0x05c00000

 * RAMDAC_VID_ZZZFB	0x05e00000

 Video layout registers */

 (height-1)<<16 | (width-1) */

 0x1a000088|(linesz_log2<<16) */

 PCI base 32bpp FB buffer 0 */

 PCI base 32bpp FB buffer 1 */

 PCI base 8bpp FB buffer 0 */

 PCI base 8bpp FB buffer 1 */

 PCI base of XXX FB */

 PCI base of YYY FB */

 PCI base of ZZZ FB */

 CLUT registers */

/* XXX This is a bit of a hack.  I can't figure out exactly how the

 * XXX two 8bpp areas of the framebuffer work.  I imagine there is

 * XXX a WID attribute somewhere else in the framebuffer which tells

 * XXX the ramdac which of the two 8bpp framebuffer regions to take

 * XXX the pixel from.  So, for now, render into both regions to make

 * XXX sure the pixel shows up.

 Fill fix common fields */

	/* Read the PCI base register of the frame buffer, which we

	 * need in order to interpret the RAMDAC_VID_*FB* values in

	 * the ramdac correctly.

/*

 * linux/drivers/video/n411.c -- Platform device for N411 EPD kit

 *

 * Copyright (C) 2008, Jaya Kumar

 *

 * This file is subject to the terms and conditions of the GNU General Public

 * License. See the file COPYING in the main directory of this archive for

 * more details.

 *

 * Layout is based on skeletonfb.c by James Simmons and Geert Uytterhoeven.

 *

 * This driver is written to be used with the Hecuba display controller

 * board, and tested with the EInk 800x600 display in 1 bit mode.

 * The interface between Hecuba and the host is TTL based GPIO. The

 * GPIO requirements are 8 writable data lines and 6 lines for control.

 * Only 4 of the controls are actually used here but 6 for future use.

 * The driver requires the IO addresses for data and control GPIO at

 * load time. It is also possible to use this display with a standard

 * PC parallel port.

 *

 * General notes:

 * - User must set dio_addr=0xIOADDR cio_addr=0xIOADDR c2io_addr=0xIOADDR

 *

	/* for init, we want the following setup to be set:

	WUP = lo

	ACK = hi

	DS = hi

	RW = hi

	CD = lo

 write WUP to lo, DS to hi, RW to hi, CD to lo */

 check ACK is not lo */

 have to wait while display resets */

 if we were told to splash the screen, we just clear it */

 request our platform independent driver */

 this _add binds hecubafb to n411. hecubafb refcounts n411 */

 SPDX-License-Identifier: GPL-2.0-only

/* p9100.c: P9100 frame buffer driver

 *

 * Copyright (C) 2003, 2006 David S. Miller (davem@davemloft.net)

 * Copyright 1999 Derrick J Brashear (shadow@dementia.org)

 *

 * Driver layout based loosely on tgafb.c, see that file for credits.

/*

 * Local functions.

/*

 *  Frame buffer operations

 P9100 control registers */

 P9100 command registers */

 P9100 framebuffer memory */

 3 bits: 2=8bpp 3=16bpp 5=32bpp 7=24bpp */

 0 = off, 1 = on */

 Registers for the system control */

 Registers for the video control */

 Registers for the video control */

 Registers for IBM RGB528 Palette */

/**

 *      p9100_setcolreg - Optional function. Sets a color register.

 *      @regno: boolean, 0 copy local, 1 get_user() function

 *      @red: frame buffer colormap structure

 *      @green: The green value which can be up to 16 bits wide

 *      @blue:  The blue value which can be up to 16 bits wide.

 *      @transp: If supported the alpha value which can be up to 16 bits wide.

 *      @info: frame buffer info structure

/**

 *      p9100_blank - Optional function.  Blanks the display.

 *      @blank: the blank mode we want.

 *      @info: frame buffer structure that represents a single frame buffer

 Unblanking */

 Normal blanking */

 VESA blank (vsync off) */

 VESA blank (hsync off) */

 Poweroff */

 Make it look like a cg3. */

/*

 *  Initialisation

 This is the framebuffer and the only resource apps can mmap.  */

/*

 *  linux/drivers/video/amba-clcd.c

 *

 * Copyright (C) 2001 ARM Limited, by David A Rusling

 * Updated to 2.5, Deep Blue Solutions Ltd.

 *

 * This file is subject to the terms and conditions of the GNU General Public

 * License.  See the file COPYING in the main directory of this archive

 * for more details.

 *

 *  ARM PrimeCell PL110 Color LCD Controller

 This is limited to 16 characters when displayed by X startup */

	/*

	 * Disable CLCD clock source.

	/*

	 * Enable the CLCD clock source.

	/*

	 * Bring up by first enabling..

	/*

	 * and now apply power.

	/*

	 * Turn on backlight

	/*

	 * finally, enable the interface.

 Old way of specifying what can be used */

 But mask out 444 modes as they weren't supported */

 Only TFT panels can do RGB888/BGR888 */

 If we can't do 5551, reject */

 If we can't do 444, 5551 or 565, reject */

		/*

		 * Green length can be 4, 5 or 6 depending whether

		 * we're operating in 444, 5551 or 565 mode.

			/*

			 * PL110 officially only supports RGB555,

			 * but may be wired up to allow RGB565.

 If we can't do 888, reject */

	/*

	 * >= 16bpp displays have separate colour component bitfields

	 * encoded in the pixel data.  Calculate their position from

	 * the bitfield length defined above.

			/*

			 * The requested format was not possible, try just

			 * our capabilities.  One of BGR or RGB must be

			 * supported.

/*

 *  Set a single color register. The values supplied have a 16 bit

 *  magnitude.  Return != 0 for invalid regno.

		/*

		 * 3.2.11: if we're configured for big endian

		 * byte order, the palette entries are swapped.

/*

 *  Blank the screen if blank_mode != 0, else unblank. If blank == NULL

 *  then the caller blanks by setting the CLUT (Color Look Up Table) to all

 *  black. Return 0 if blanking succeeded, != 0 if un-/blanking failed due

 *  to e.g. a video mode which doesn't support it. Implements VESA suspend

 *  and powerdown modes on hardware that supports disabling hsync/vsync:

 *    blank_mode == 2: suspend vsync

 *    blank_mode == 3: suspend hsync

 *    blank_mode == 4: powerdown

	/*

	 * ARM PL111 always has IENB at 0x1c; it's only PL110

	 * which is reversed on some platforms.

	/*

	 * Make sure that the bitfields are set appropriately.

	/*

	 * Allocate colourmap.

	/*

	 * Ensure interrupts are disabled.

 Set up some inversion flags */

		/*

		 * To preserve backwards compatibility, the IPC (inverted

		 * pixel clock) flag needs to be set on any display that

		 * doesn't explicitly specify that the pixel clock is

		 * active on the negative or positive edge.

 Look up the optional backlight device */

 Only directly connected DPI panels supported for now */

 Bypass pixel clock divider */

 TFT display, vert. comp. interrupt at the start of the back porch */

 Match the setup with known variants */

	/*

	 * If we actually physically connected the R lines to B and

	 * vice versa

	/*

	 * Fetch the panel endpoint.

		/*

		 * max_bandwidth is in bytes per second and pixclock in

		 * pico-seconds, so the maximum allowed bits per pixel is

		 *   8 * max_bandwidth / (PICOS2KHZ(pixclock) * 1000)

		 * Rearrange this calculation to avoid overflow and then ensure

		 * result is a valid format.

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  WonderMedia WM8505 Frame Buffer device driver

 *

 *  Copyright (C) 2010 Ed Spiridonov <edo.rus@gmail.com>

 *    Based on vt8500lcdfb.c

 I know the purpose only of few registers, so clear unknown */

 Set frame buffer address */

	/*

	 * Set in-memory picture format to RGB

	 * 0x31C sets the correct color mode (RGB565) for WM8650

	 * Bit 8+9 (0x300) are ignored on WM8505 as reserved

 Virtual buffer size */

 black magic ;) */

 try allocating the framebuffer */

/*

 * Xilinx TFT frame buffer driver

 *

 * Author: MontaVista Software, Inc.

 *         source@mvista.com

 *

 * 2002-2007 (c) MontaVista Software, Inc.

 * 2007 (c) Secret Lab Technologies, Ltd.

 * 2009 (c) Xilinx Inc.

 *

 * This file is licensed under the terms of the GNU General Public License

 * version 2.  This program is licensed "as is" without any warranty of any

 * kind, whether express or implied.

/*

 * This driver was based on au1100fb.c by MontaVista rewritten for 2.6

 * by Embedded Alley Solutions <source@embeddedalley.com>, which in turn

 * was based on skeletonfb.c, Skeleton for a frame buffer device by

 * Geert Uytterhoeven.

/*

 * Xilinx calls it "TFT LCD Controller" though it can also be used for

 * the VGA port on the Xilinx ML40x board. This is a hardware display

 * controller for a 640x480 resolution TFT or VGA screen.

 *

 * The interface to the framebuffer is nice and simple.  There are two

 * control registers.  The first tells the LCD interface where in memory

 * the frame buffer is (only the 11 most significant bits are used, so

 * don't start thinking about scrolling).  The second allows the LCD to

 * be turned on or off as well as rotated 180 degrees.

 *

 * In case of direct BUS access the second control register will be at

 * an offset of 4 as compared to the DCR access where the offset is 1

 * i.e. REG_CTRL. So this is taken care in the function

 * xilinx_fb_out32 where it left shifts the offset 2 times in case of

 * direct BUS access.

/*

 * The hardware only handles a single mode: 640x480 24 bit true

 * color. Each pixel gets a word (32 bits) of memory.  Within each word,

 * the 8 most significant bits are ignored, the next 8 bits are the red

 * level, the next 8 bits are the green level and the 8 least

 * significant bits are the blue level.  Each row of the LCD uses 1024

 * words, but only the first 640 pixels are displayed with the other 384

 * words being ignored.  There are 480 rows.

 passed to fb_alloc_cmap() */

 ML300/403 reference design framebuffer driver platform data struct */

 Flag to rotate display 180 degrees */

 Physical dimensions of screen in mm */

 resolution of screen in pixels */

 resolution of memory buffer */

	/* Physical address of framebuffer memory; If non-zero, driver

	 * will use provided memory address instead of allocating one from

	 * the consistent pool.

/*

 * Default xilinxfb configuration

/*

 * Here are the default fb_fix_screeninfo and fb_var_screeninfo structures

 1 = BUS, 0 = DCR */

 LITTLE ENDIAN IO functions */

 FB driver info record */

	phys_addr_t	regs_phys;	/* phys. address of the control

					 * registers

	void __iomem	*regs;		/* virt. address of the control

					 * registers

 virt. address of the frame buffer */

 phys. address of the frame buffer */

 Flag, was the fb memory alloced? */

 features of the driver */

 Fake palette of 16 colors */

/*

 * The XPS TFT Controller can be accessed through BUS or DCR interface.

 * To perform the read/write on the registers we need to check on

 * which bus its connected and call the appropriate write API.

		/* Convert color to grayscale.

		 * grayscale = 0.30*R + 0.59*G + 0.11*B

 fbi->fix.visual is always FB_VISUAL_TRUECOLOR */

 We only handle 8 bits of each color. */

 turn on panel */

 turn off panel */

 success */

/* ---------------------------------------------------------------------

 * Bus independent setup/teardown

 Allocate the framebuffer memory */

 Clear (turn to black) the framebuffer */

 Tell the hardware where the frame buffer is */

 Endianness detection */

 Turn on the display */

 Fill struct fb_info */

 Allocate a colour map */

 Register new frame buffer */

 Put a banner in the log (for DEBUG) */

 Put a banner in the log (for DEBUG) */

 success */

 Turn off the display */

 Turn off the display */

 Release the resources, as allocated based on interface */

/* ---------------------------------------------------------------------

 * OF bus binding

 Copy with the default pdata (not a ptr reference!) */

 Allocate the driver data region */

	/*

	 * To check whether the core is connected directly to DCR or BUS

	 * interface and initialize the tft_access accordingly.

	/*

	 * Fill the resource structure if its direct BUS interface

	 * otherwise fill the dcr_host structure.

 Match table for of_platform binding */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  linux/drivers/video/cyber2000fb.c

 *

 *  Copyright (C) 1998-2002 Russell King

 *

 *  MIPS and 50xx clock support

 *  Copyright (C) 2001 Bradley D. LaRonde <brad@ltc.com>

 *

 *  32 bit support, text color and panning fixes for modes != 8 bit

 *  Copyright (C) 2002 Denis Oliver Kropp <dok@directfb.org>

 *

 * Integraphics CyberPro 2000, 2010 and 5000 frame buffer device

 *

 * Based on cyberfb.c.

 *

 * Note that we now use the new fbcon fix, var and cmap scheme.  We do

 * still have to check which console is the currently displayed one

 * however, especially for the colourmap stuff.

 *

 * We also use the new hotplug PCI subsystem.  I'm not sure if there

 * are any such cards, but I'm erring on the side of caution.  We don't

 * want to go pop just because someone does have one.

 *

 * Note that this doesn't work fully in the case of multiple CyberPro

 * cards with grabbers.  We currently can only attach to the first

 * CyberPro card found.

 *

 * When we're in truecolour mode, we power down the LUT RAM as a power

 * saving feature.  Also, when we enter any of the powersaving modes

 * (except soft blanking) we power down the RAMDACs.  This saves about

 * 1W, which is roughly 8% of the power consumption of a NetWinder

 * (which, incidentally, is about the same saving as a 2.5in hard disk

 * entering standby mode.)

	/*

	 * Clock divisors

	/*

	 * RAMDAC control register is both of these or'ed together

/*

 * Our access methods.

 -------------------- Hardware specific routines ------------------------- */

/*

 * Hardware Cyber2000 Acceleration

/*

 * ===========================================================================

/*

 *    Set a single color register. Return != 0 for invalid regno.

	/*

	 * Pseudocolour:

	 *	   8     8

	 * pixel --/--+--/-->  red lut  --> red dac

	 *	      |  8

	 *	      +--/--> green lut --> green dac

	 *	      |  8

	 *	      +--/-->  blue lut --> blue dac

	/*

	 * Direct colour:

	 *	   n     rl

	 * pixel --/--+--/-->  red lut  --> red dac

	 *	      |  gl

	 *	      +--/--> green lut --> green dac

	 *	      |  bl

	 *	      +--/-->  blue lut --> blue dac

	 * n = bpp, rl = red length, gl = green length, bl = blue length

			/*

			 * The 6 bits of the green component are applied

			 * to the high 6 bits of the LUT.

			/*

			 * The 5 bits of each colour component are

			 * applied to the high 5 bits of the LUT.

			/*

			 * The 5 bits of each colour component are

			 * applied to the high 5 bits of the LUT.

		/*

		 * Since this is only used for the first 16 colours, we

		 * don't have to care about overflowing for regno >= 32

	/*

	 * True colour:

	 *	   n     rl

	 * pixel --/--+--/--> red dac

	 *	      |  gl

	 *	      +--/--> green dac

	 *	      |  bl

	 *	      +--/--> blue dac

	 * n = bpp, rl = red length, gl = green length, bl = blue length

	/*

	 * Now set our pseudo palette for the CFB16/24/32 drivers.

	/*

	 * Hardware

	/*

	 * Other

 prevent card lock-up observed on x86 with CyberPro 2000 */

	/*

	 * Blank palette

 Attribute controller registers */

 PLL registers */

	/*

	 * Set up accelerator registers

	/*

	 * Convert to bytes and shift two extra bits because DAC

	 * can only start on 4 byte aligned data.

	/*

	 * overflow - graphics reg 0x11

	 * 0=VTOTAL:10 1=VDEND:10 2=VRSTART:10 3=VBSTART:10

	 * 4=LINECOMP:10 5-IVIDEO 6=FIXCNT

 woody: set the interlaced bit... */

 FIXME: what about doublescan? */

/*

 * The following was discovered by a good monitor, bit twiddling, theorising

 * and but mostly luck.  Strangely, it looks like everyone elses' PLL!

 *

 * Clock registers:

 *   fclock = fpll / div2

 *   fpll   = fref * mult / div1

 * where:

 *   fref = 14.318MHz (69842ps)

 *   mult = reg0xb0.7:0

 *   div1 = (reg0xb1.5:0 + 1)

 *   div2 =  2^(reg0xb1.7:6)

 *   fpll should be between 115 and 260 MHz

 *  (8696ps and 3846ps)

	/*

	 * Step 1:

	 *   find div2 such that 115MHz < fpll < 260MHz

	 *   and 0 <= div2 < 4

	/*

	 * Step 2:

	 *  Given pll_ps and ref_ps, find:

	 *    pll_ps * 0.995 < pll_ps_calc < pll_ps * 1.005

	 *  where { 1 < best_div1 < 32, 1 < best_mult < 256 }

	 *    pll_ps_calc = best_div1 / (ref_ps * best_mult)

		/*

		 * Find the multiplier for this divisor

		/*

		 * Is the multiplier within the correct range?

		/*

		 * Calculate the actual clock period from this multiplier

		 * and divisor, and estimate the error.

		/*

		 * If we hit an exact value, there is no point in continuing.

	/*

	 * Step 3:

	 *  combine values

 Set VFSEL when VCO > 180MHz (5.556 ps). */

/*

 *    Set the User Defined Part of the Display

 PSEUDOCOLOUR, 256 */

 DIRECTCOLOUR, 64k or 32k */

 RGB565, 64k */

 RGB555, 32k */

 RGB444, 4k + transparency? */

 TRUECOLOUR, 16m */

 TRUECOLOUR, 16m */

 RGB565, 64k */

 RGB555, 32k */

 RGB444, 4k + transparency? */

 TRUECOLOUR, 16m */

 TRUECOLOUR, 16m */

	/*

	 * Sigh, this is absolutely disgusting, but caused by

	 * the way the fbcon developers want to separate out

	 * the "checking" and the "setting" of the video mode.

	 *

	 * If the mode is not suitable for the hardware here,

	 * we can't prevent it being set by returning an error.

	 *

	 * In theory, since NetWinders contain just one VGA card,

	 * we should never end up hitting this problem.

	/*

	 * Same here - if the size of the video mode exceeds the

	 * available RAM, we can't prevent this mode being set.

	 *

	 * In theory, since NetWinders contain just one VGA card,

	 * we should never end up hitting this problem.

	/*

	 * 8bpp displays are always pseudo colour.  16bpp and above

	 * are direct colour or true colour, depending on whether

	 * the RAMDAC palettes are bypassed.  (Direct colour has

	 * palettes, true colour does not.)

/*

 *    Pan or Wrap the Display

/*

 *    (Un)Blank the display.

 *

 *  Blank the screen if blank_mode != 0, else unblank. If

 *  blank == NULL then the caller blanks by setting the CLUT

 *  (Color Look Up Table) to all black. Return 0 if blanking

 *  succeeded, != 0 if un-/blanking failed due to e.g. a

 *  video mode which doesn't support it. Implements VESA

 *  suspend and powerdown modes on hardware that supports

 *  disabling hsync/vsync:

 *    blank_mode == 2: suspend vsync

 *    blank_mode == 3: suspend hsync

 *    blank_mode == 4: powerdown

 *

 *  wms...Enable VESA DMPS compatible powerdown mode

 *  run "setterm -powersave powerdown" to take advantage

 powerdown - both sync lines down */

 hsync off */

 vsync off */

 soft blank */

 unblank */

 turn on ramdacs */

	/*

	 * Soft blank/unblank the display.

 soft blank */

 unblank */

 turn off ramdacs */

/*

 * This is the only "static" reference to the internal data structures

 * of this driver.  It is here solely at the moment to support the other

 * CyberPro modules external to this driver.

/*

 * Enable access to the extended registers

/*

 * Disable access to the extended registers

/*

 * Attach a capture/tv driver to the core CyberX0X0 driver.

/*

 * Detach a capture/tv driver from the core CyberX0X0 driver.

 bit is inverted */

 bit is inverted */

 CONFIG_FB_CYBER2000_DDC */

/*

 * These parameters give

 * 640x480, hsync 31.5kHz, vsync 60Hz

 some of these are questionable when we have a BIOS */

/*

 * Initialise the CyberPro hardware.  On the CyberPro5XXXX,

 * ensure that we're using the correct PLL (5XXX's may be

 * programmed to use an additional set of PLLs.)

 24.576 MHz */

 14.31818 MHz (69841?) */

		/*

		 * Free the colourmap

/*

 * Parse Cyber2000fb options.  Usage:

 *  video=cyber2000:font:fontname

  MODULE  */

/*

 * The CyberPro chips can be placed on many different bus types.

 * This probe function is common to all bus types.  The bus-specific

 * probe function is expected to have:

 *  - enabled access to the linear memory region

 *  - memory mapped access to the registers

 *  - initialised mem_ctl1 and mem_ctl2 appropriately.

	/*

	 * Get the video RAM size and width from the VGA register.

	 * This should have been already initialised by the BIOS,

	 * but if it's garbage, claim default 1MB VRAM (woody)

	/*

	 * Determine the size of the memory.

	fb_set_var(&cfb->fb.var, -1, &cfb->fb); */

	/*

	 * Calculate the hsync and vsync frequencies.  Note that

	 * we split the 1e12 constant up so that we can preserve

	 * the precision and fit the results into 32-bit registers.

	 *  (1953125000 * 512 = 1e12)

	/*

	 * Reprogram the MEM_CTL1 and MEM_CTL2 registers

	/*

	 * Restore the old video mode and the palette.

	 * We also need to tell fbcon to redraw the console.

/*

 * We need to wake up the CyberPro, and make sure its in linear memory

 * mode.  Unfortunately, this is specific to the platform and card that

 * we are running on.

 *

 * On x86 and ARM, should we be initialising the CyberPro first via the

 * IO registers, and then the MMIO registers to catch all cases?  Can we

 * end up in the situation where the chip is in MMIO mode, but not awake

 * on an x86 system?

	/*

	 * SPARC does not have an "outb" instruction, so we generate

	 * I/O cycles storing into a reserved memory space at

	 * physical address 0x3000000

	/*

	 * Most other machine types are "normal", so

	 * we use the standard IO-based wakeup.

	/*

	 * Allow the CyberPro to accept PCI burst accesses

	/*

	 * Bring up the hardware.  This is expected to enable access

	 * to the linear memory region, and allow access to the memory

	 * mapped registers.  Also, mem_ctl1 and mem_ctl2 must be

	 * initialised.

	/*

	 * Use MCLK from BIOS. FIXME: what about hotplug?

	/*

	 * MCLK on the NetWinder and the Shark is fixed at 75MHz

	/*

	 * Our driver data

/*

 * Re-initialise the CyberPro hardware

/*	Not yet

 *	{ PCI_VENDOR_ID_INTERG, PCI_DEVICE_ID_INTERG_1682,

 *		PCI_ANY_ID, PCI_ANY_ID, 0, 0, ID_IGA_1682 },

/*

 * I don't think we can use the "module_init" stuff here because

 * the fbcon stuff may not be initialised yet.  Hence the #ifdef

 * around module_init.

 *

 * Tony: "module_init" is now required

 SPDX-License-Identifier: GPL-2.0-only

/* cg6.c: CGSIX (GX, GXplus, TGX) frame buffer driver

 *

 * Copyright (C) 2003, 2006 David S. Miller (davem@davemloft.net)

 * Copyright (C) 1996,1998 Jakub Jelinek (jj@ultra.linux.cz)

 * Copyright (C) 1996 Miguel de Icaza (miguel@nuclecu.unam.mx)

 * Copyright (C) 1996 Eddie C. Dost (ecd@skynet.be)

 *

 * Driver layout based loosely on tgafb.c, see that file for credits.

/*

 * Local functions.

/*

 *  Frame buffer operations

 Offset of interesting structures in the OBIO space */

/*

 * Brooktree is the video dac and is funny to program on the cg6.

 * (it's even funnier on the cg3)

 * The FBC could be the frame buffer control

 * The FHC could is the frame buffer hardware control.

 FHC definitions */

 FBC mode definitions */

 THC definitions */

 The contents are unknown */

 hsync timing */

 vsync timing */

 cursor x,y position (16 bits each) */

 cursor mask bits */

 what to show where mask enabled */

 Hide the cursor. */

	/* We just use this to catch switches out of

	 * graphics mode.

/**

 *	cg6_fillrect -	Draws a rectangle on the screen.

 *

 *	@info: frame buffer structure that represents a single frame buffer

 *	@rect: structure defining the rectagle and operation.

 CG6 doesn't handle ROP_XOR */

/**

 *	cg6_copyarea - Copies one area of the screen to another area.

 *

 *	@info: frame buffer structure that represents a single frame buffer

 *	@area: Structure providing the data to copy the framebuffer contents

 *		from one region to another.

 *

 *	This drawing operation copies a rectangular area from one area of the

 *	screen to another area.

/**

 *	cg6_imageblit -	Copies a image from system memory to the screen.

 *

 *	@info: frame buffer structure that represents a single frame buffer

 *	@image: structure defining the image.

/**

 *	cg6_setcolreg - Sets a color register.

 *

 *	@regno: boolean, 0 copy local, 1 get_user() function

 *	@red: frame buffer colormap structure

 *	@green: The green value which can be up to 16 bits wide

 *	@blue:  The blue value which can be up to 16 bits wide.

 *	@transp: If supported the alpha value which can be up to 16 bits wide.

 *	@info: frame buffer info structure

/**

 *	cg6_blank - Blanks the display.

 *

 *	@blank: the blank mode we want.

 *	@info: frame buffer structure that represents a single frame buffer

 Unblanking */

 Normal blanking */

 VESA blank (vsync off) */

 VESA blank (hsync off) */

 Poweroff */

/*

 *  Initialisation

 Initialize Brooktree DAC */

 color planes */

 overlay plane */

 Hide the cursor. */

 Turn off stuff in the Transform Engine. */

 Take care of bugs in old revisions. */

	/* Set things in the FBC. Bad things appear to happen if we do

	 * back to back store/loads on the mode register, so copy it

/*

 *  drivers/video/imsttfb.c -- frame buffer device for IMS TwinTurbo

 *

 *  This file is derived from the powermac console "imstt" driver:

 *  Copyright (C) 1997 Sigurdur Asgeirsson

 *  With additional hacking by Jeffrey Kuskin (jsk@mojave.stanford.edu)

 *  Modified by Danilo Beuche 1998

 *  Some register values added by Damien Doligez, INRIA Rocquencourt

 *  Various cleanups by Paul Mundt (lethal@chaoticdreams.org)

 *

 *  This file was written by Ryan Nielsen (ran@krazynet.com)

 *  Most of the frame buffer device stuff was copied from atyfb.c

 *

 *  This file is subject to the terms and conditions of the GNU General Public

 *  License. See the file COPYING in the main directory of this archive for

 *  more details.

 Enforce In-order Execution of I/O */

 TwinTurbo (Cosmo) registers */

 0x00 */

 0x04 */

 0x08 */

 0x0C */

 0x10 */

 0x14 */

 0x18 */

 0x20 */

 0x24 */

 0x28 */

 Scan Timing Generator Registers */

 0x30 */

 0x34 */

 0x38 */

 0x3C */

 0x40 */

 0x44 */

 0x48 */

 0x4C */

 0x50 */

 0x54 */

 0x58 */

 0x5C */

 0x60 */

 Screen Refresh Generator Registers */

 0x64 */

 0x68 */

 0x6C */

 0x70 */

 0x74 */

 RAM Refresh Generator Registers */

 0x78 */

 0x7C */

 0x88 */

 System Registers */

 0x80 */

 0x84 */

 0x8C */

 0x90 */

 0x94 */

 PCI Registers */

 IBM 624 RAMDAC Direct Registers */

 IBM 624 RAMDAC Indirect Registers */

 (0x01) Miscellaneous Clock Control */

 (0x00) Sync Control */

 (0x00) Horizontal Sync Position */

 (0x00) Power Management */

 (0x02) DAC Operation */

 (0x00) Palette Control */

 (0x01) System Clock Control */

 () Pixel Format  [bpp >> 3 + 2] */

 () 8 Bits/Pixel Control */

 () 16 Bits/Pixel Control  [bit 1=1 for 565] */

 () 24 Bits/Pixel Control */

 () 32 Bits/Pixel Control */

 (0x05) Pixel PLL Control 1 */

 (0x00) Pixel PLL Control 2 */

 () System Clock N (System PLL Reference Divider) */

 () System Clock M (System PLL VCO Divider) */

 () System Clock P */

 () System Clock C */

	/*

	 * Dot clock rate is 20MHz * (m + 1) / ((n + 1) * (p ? 2 * p : 1)

	 * c is charge pump bias which depends on the VCO frequency  

 () Pixel M 0 */

 () Pixel N 0 */

 () Pixel P 0 */

 () Pixel C 0 */

 (0x00) Cursor Control */

 () Cursor X position, low 8 bits */

 () Cursor X position, high 8 bits */

 () Cursor Y position, low 8 bits */

 () Cursor Y position, high 8 bits */

 () Cursor Hot Spot X */

 () Cursor Hot Spot Y */

 () Advanced Cursor Control Enable */

 () Advanced Cursor Attribute */

 () Cursor 1 Red */

 () Cursor 1 Green */

 () Cursor 1 Blue */

 () Cursor 2 Red */

 () Cursor 2 Green */

 () Cursor 2 Blue */

 () Cursor 3 Red */

 () Cursor 3 Green */

 () Cursor 3 Blue */

 () Border Color Red */

 () Border Color Green */

 () Border Color Blue */

 (0x00) Miscellaneous Control 1 */

 (0x00) Miscellaneous Control 2 */

 (0x00) Miscellaneous Control 3 */

 (0x00) Key Control/DB Operation */

 TI TVP 3030 RAMDAC Direct Registers */

 0  Palette/Cursor RAM Write Address/Index */

 1  Palette Data RAM Data */

 2  Pixel Read-Mask */

 3  Palette/Cursor RAM Read Address */

 4  Cursor/Overscan Color Write Address */

 5  Cursor/Overscan Color Data */

 6  reserved */

 7  Cursor/Overscan Color Read Address */

 8  reserved */

 9  Direct Cursor Control */

 10 Index Data */

 11 Cursor RAM Data */

 12 Cursor-Position X LSB */

 13 Cursor-Position X MSB */

 14 Cursor-Position Y LSB */

 15 Cursor-Position Y MSB */

 TI TVP 3030 RAMDAC Indirect Registers */

 Silicon Revision [RO] */

 Indirect Cursor Control 	(0x00) */

 Byte Router Control 	(0xe4) */

 Latch Control 		(0x06) */

 True Color Control  	(0x80) */

 Multiplex Control		(0x98) */

 Clock Selection		(0x07) */

 Palette Page		(0x00) */

 General Control 		(0x00) */

 Miscellaneous Control	(0x00) */

 PLL Address */

 Pixel Clock PLL Data */

 Memory Clock PLL Data */

 Loop Clock PLL Data */

 Color-Key Overlay Low */

 Color-Key Overlay High */

 Color-Key Red Low */

 Color-Key Red High */

 Color-Key Green Low */

 Color-Key Green High */

 Color-Key Blue Low */

 Color-Key Blue High */

 Color-Key Control 		(0x00) */

 MCLK/Loop Clock Control	(0x18) */

 Sense Test			(0x00) */

 Test Mode Data */

 CRC Remainder LSB [RO] */

 CRC Remainder MSB [RO] */

 CRC  Bit Select [WO] */

 Device ID [RO] 		(0x30) */

 Software Reset [WO] */

	/*

	 * Note that colors in X are correct only if all video data is

	 * passed through the palette in the DAC.  That is, "indirect

	 * color" must be configured.  This is the case for the IBM DAC

	 * used in the 2MB and 4MB cards, at least.

 Values of the tvp which change depending on colormode x resolution */

 Memory Loop Config 0x39 */

 P value of LCKL PLL */

/*

 * PCI driver prototypes

/*

 * Register access

 .25 */ ;

 .27_ */ ;

 .6_ */ ;

  /*

   * From what I (jsk) can gather poking around with MacsBug,

   * bits 8 and 9 in the SCR register control endianness

   * correction (byte swapping).  These bits must be set according

   * to the color depth as follows:

   *     Color depth    Bit 9   Bit 8

   *     ==========     =====   =====

   *        8bpp          0       0

   *       16bpp          0       1

   *       32bpp          1       1

		/* case 0x400000:

 RGB 555 or 565 */

 RGB 888 */

 RGBA 8888 */

 PADDRW/PDATA are the same as TVPPADDRW/TVPPDATA */

 screws up X */

 0x200000 */

 initialize the card */

 set default values for DAC registers */

	if (par->ramdac == IBM)

		imstt_cursor_init(info);

 IMS,tt128mbA */

 IMS,tt3d */

 MODULE */

/*

 * Silicon Motion SM7XX frame buffer device

 *

 * Copyright (C) 2006 Silicon Motion Technology Corp.

 * Authors:  Ge Wang, gewang@siliconmotion.com

 *	     Boyod boyod.yang@siliconmotion.com.cn

 *

 * Copyright (C) 2009 Lemote, Inc.

 * Author:   Wu Zhangjin, wuzhangjin@gmail.com

 *

 * Copyright (C) 2011 Igalia, S.L.

 * Author:   Javier M. Mellid <jmunhoz@igalia.com>

 *

 * This file is subject to the terms and conditions of the GNU General Public

 * License. See the file COPYING in the main directory of this archive for

 * more details.

 *

 * Framebuffer driver for Silicon Motion SM710, SM712, SM721 and SM722 chips

/*

 * Private structure

 linear frame buffer */

 drawing processor control regs */

 video processor control regs */

 capture processor control regs */

 memory map IO port */

 Memory Map IO starting address */

/**********************************************************************

			 SM712 Mode table.

  mode#0: 640 x 480  16Bpp  60Hz */

  Init_MISC */

  Init_SR0_SR4 */

  Init_SR10_SR24 */

  Init_SR30_SR75 */

  Init_SR80_SR93 */

  Init_SRA0_SRAF */

  Init_GR00_GR08 */

  Init_AR00_AR14 */

  Init_CR00_CR18 */

  Init_CR30_CR4D */

  Init_CR90_CRA7 */

  mode#1: 640 x 480  24Bpp  60Hz */

  Init_MISC */

  Init_SR0_SR4 */

  Init_SR10_SR24 */

  Init_SR30_SR75 */

  Init_SR80_SR93 */

  Init_SRA0_SRAF */

  Init_GR00_GR08 */

  Init_AR00_AR14 */

  Init_CR00_CR18 */

  Init_CR30_CR4D */

  Init_CR90_CRA7 */

  mode#0: 640 x 480  32Bpp  60Hz */

  Init_MISC */

  Init_SR0_SR4 */

  Init_SR10_SR24 */

  Init_SR30_SR75 */

  Init_SR80_SR93 */

  Init_SRA0_SRAF */

  Init_GR00_GR08 */

  Init_AR00_AR14 */

  Init_CR00_CR18 */

  Init_CR30_CR4D */

  Init_CR90_CRA7 */

  mode#2: 800 x 600  16Bpp  60Hz */

  Init_MISC */

  Init_SR0_SR4 */

  Init_SR10_SR24 */

  Init_SR30_SR75 */

  Init_SR80_SR93 */

  Init_SRA0_SRAF */

  Init_GR00_GR08 */

  Init_AR00_AR14 */

  Init_CR00_CR18 */

  Init_CR30_CR4D */

  Init_CR90_CRA7 */

  mode#3: 800 x 600  24Bpp  60Hz */

  Init_SR0_SR4 */

  Init_SR10_SR24 */

  Init_SR30_SR75 */

  Init_SR80_SR93 */

  Init_SRA0_SRAF */

  Init_GR00_GR08 */

  Init_AR00_AR14 */

  Init_CR00_CR18 */

  Init_CR30_CR4D */

  Init_CR90_CRA7 */

  mode#7: 800 x 600  32Bpp  60Hz */

  Init_MISC */

  Init_SR0_SR4 */

  Init_SR10_SR24 */

  Init_SR30_SR75 */

  Init_SR80_SR93 */

  Init_SRA0_SRAF */

  Init_GR00_GR08 */

  Init_AR00_AR14 */

  Init_CR00_CR18 */

  Init_CR30_CR4D */

  Init_CR90_CRA7 */

 We use 1024x768 table to light 1024x600 panel for lemote */

  mode#4: 1024 x 600  16Bpp  60Hz  */

  Init_MISC */

  Init_SR0_SR4 */

  Init_SR10_SR24 */

  Init_SR30_SR75 */

  Init_SR80_SR93 */

  Init_SRA0_SRAF */

  Init_GR00_GR08 */

  Init_AR00_AR14 */

  Init_CR00_CR18 */

  Init_CR30_CR4D */

  Init_CR90_CRA7 */

  1024 x 768  16Bpp  60Hz */

  Init_MISC */

  Init_SR0_SR4 */

  Init_SR10_SR24 */

  Init_SR30_SR75 */

  Init_SR80_SR93 */

  Init_SRA0_SRAF */

  Init_GR00_GR08 */

  Init_AR00_AR14 */

  Init_CR00_CR18 */

  Init_CR30_CR4D */

  Init_CR90_CRA7 */

  mode#5: 1024 x 768  24Bpp  60Hz */

  Init_MISC */

  Init_SR0_SR4 */

  Init_SR10_SR24 */

  Init_SR30_SR75 */

  Init_SR80_SR93 */

  Init_SRA0_SRAF */

  Init_GR00_GR08 */

  Init_AR00_AR14 */

  Init_CR00_CR18 */

  Init_CR30_CR4D */

  Init_CR90_CRA7 */

  mode#4: 1024 x 768  32Bpp  60Hz */

  Init_MISC */

  Init_SR0_SR4 */

  Init_SR10_SR24 */

  Init_SR30_SR75 */

  Init_SR80_SR93 */

  Init_SRA0_SRAF */

  Init_GR00_GR08 */

  Init_AR00_AR14 */

  Init_CR00_CR18 */

  Init_CR30_CR4D */

  Init_CR90_CRA7 */

  mode#6: 320 x 240  16Bpp  60Hz */

  Init_MISC */

  Init_SR0_SR4 */

  Init_SR10_SR24 */

  Init_SR30_SR75 */

  Init_SR80_SR93 */

  Init_SRA0_SRAF */

  Init_GR00_GR08 */

  Init_AR00_AR14 */

  Init_CR00_CR18 */

  Init_CR30_CR4D */

  Init_CR90_CRA7 */

  mode#8: 320 x 240  32Bpp  60Hz */

  Init_MISC */

  Init_SR0_SR4 */

  Init_SR10_SR24 */

  Init_SR30_SR75 */

  Init_SR80_SR93 */

  Init_SRA0_SRAF */

  Init_GR00_GR08 */

  Init_AR00_AR14 */

  Init_CR00_CR18 */

  Init_CR30_CR4D */

  Init_CR90_CRA7 */

 process command line options, get vga parameter */

 set bit 5:4 = 01 (write LCD RAM only) */

/* chan_to_field

 *

 * convert a colour value into a field position

 *

 * from pxafb.c

 clear DPMS setting */

 Screen On: HSync: On, VSync : On */

 Screen Off: HSync: On, VSync : On   Soft blank */

 Screen On: HSync: On, VSync : Off */

 Screen On: HSync: Off, VSync : On */

 Screen On: HSync: Off, VSync : Off */

		/*

		 * 16/32 bit true-colour, use pseudo-palette for 16 base color

 color depth 8 bit */

 unknown type */

 init SEQ register SR00 - SR04 */

 init SEQ register SR10 - SR24 */

 init SEQ register SR30 - SR75 */

 init SEQ register SR80 - SR93 */

 init SEQ register SRA0 - SRAF */

 init Graphic register GR00 - GR08 */

 init Attribute register AR00 - AR14 */

 init CRTC register CR00 - CR18 */

 init CRTC register CR30 - CR4D */

 side-effect, don't write to CR3B-CR3F */

 init CRTC register CR90 - CRA7 */

 set VPR registers */

 set data width */

 sanity checks */

 set valid default bpp */

/*

 * Unmap in the memory mapped IO registers

/*

 * Map in the screen memory

 on SM720, the framebuffer starts at the 1 MB offset */

 XXX: is it safe for SM720 on Big-Endian? */

/*

 * Unmap in the screen memory

 *

/*

 * We need to wake up the device and make sure its in linear memory mode.

		/*

		 * Assume SM712 graphics chip has 4MB VRAM.

		 *

		 * FIXME: SM712 can have 2MB VRAM, which is used on earlier

		 * laptops, such as IBM Thinkpad 240X. This driver would

		 * probably crash on those machines. If anyone gets one of

		 * those and is willing to help, run "git blame" and send me

		 * an E-mail.

 8 MB */

 16 MB */

 illegal, fallback to 4 MB */

 4 MB */

 unknown hardware */

 get mode parameter from smtc_scr_info */

	/*

	 * No parameter, default resolution is 1024x768-16.

	 *

	 * FIXME: earlier laptops, such as IBM Thinkpad 240X, has a 800x600

	 * panel, also see the comments about Thinkpad 240X above.

	/*

	 * Loongson MIPS netbooks use 1024x600 LCD panels, which is the original

	 * target platform of this driver, but nearly all old x86 laptops have

	 * 1024x768. Lighting 768 panels using 600's timings would partially

	 * garble the display, so we don't want that. But it's not possible to

	 * distinguish them reliably.

	 *

	 * So we change the default to 768, but keep 600 as-is on MIPS.

 enable SMTC chip */

 Map address and memory detection */

 set MCLK = 14.31818 * (0x16 / 0x2) */

 enable PCI burst */

 enable word swap */

 probe and decide resolution */

 can support 32 bpp */

	/*

	 * The screen would be temporarily garbled when sm712fb takes over

	 * vesafb or VGA text mode. Zero the framebuffer.

/*

 * 0x710 (LynxEM)

 * 0x712 (LynxEM+)

 * 0x720 (Lynx3DM, Lynx3DM+)

	/* set the hw in sleep mode use external clock and self memory refresh

	 * so that we can turn off internal PLLs later on

 additionally turn off all function blocks including internal PLLs */

 reinit hardware */

 set MCLK = 14.31818 *  (0x16 / 0x2) */

 enable PCI burst */

/*

 * BRIEF MODULE DESCRIPTION

 *	Au1200 LCD Driver.

 *

 * Copyright 2004-2005 AMD

 * Author: AMD

 *

 * Based on:

 * linux/drivers/video/skeletonfb.c -- Skeleton for a frame buffer device

 *  Created 28 Dec 1997 by Geert Uytterhoeven

 *

 *  This program is free software; you can redistribute	 it and/or modify it

 *  under  the terms of	 the GNU General  Public License as published by the

 *  Free Software Foundation;  either version 2 of the	License, or (at your

 *  option) any later version.

 *

 *  THIS  SOFTWARE  IS PROVIDED	  ``AS	IS'' AND   ANY	EXPRESS OR IMPLIED

 *  WARRANTIES,	  INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF

 *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN

 *  NO	EVENT  SHALL   THE AUTHOR  BE	 LIABLE FOR ANY	  DIRECT, INDIRECT,

 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT

 *  NOT LIMITED	  TO, PROCUREMENT OF  SUBSTITUTE GOODS	OR SERVICES; LOSS OF

 *  USE, DATA,	OR PROFITS; OR	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON

 *  ANY THEORY OF LIABILITY, WHETHER IN	 CONTRACT, STRICT LIABILITY, OR TORT

 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF

 *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 *

 *  You should have received a copy of the  GNU General Public License along

 *  with this program; if not, write  to the Free Software Foundation, Inc.,

 *  675 Mass Ave, Cambridge, MA 02139, USA.

 platform_data */

 Private, per-framebuffer management information (independent of the panel itself) */

 FB driver info record */

 FrameBuffer memory map */

*******************************************************************/

 LCD controller restrictions */

 fixme: this needs to go away ? */

 Default number of visible screen buffer to allocate */

 Default maximum number of fb devices to create */

 Default window configuration entry to use (see windows[]) */

*******************************************************************/

 default is zero */

 default is zero */

 winctrl1[FRM,CCO,PO,PIPE] */

/*

 * Default window configurations

 Index 0 */

 mode_backcolor	*/ 0x006600ff,

 mode_colorkey,msk*/ 0, 0,

 xres, yres, xpos, ypos */ 0, 0, 0, 0,

 mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |

 mode_winenable*/ LCD_WINENABLE_WEN0,

 xres, yres, xpos, ypos */ 100, 100, 100, 100,

 mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |

 mode_winenable*/ LCD_WINENABLE_WEN1,

 xres, yres, xpos, ypos */ 0, 0, 0, 0,

 mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |

 mode_winenable*/ 0,

 xres, yres, xpos, ypos */ 0, 0, 0, 0,

 mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |

 mode_winenable*/ 0,

 Index 1 */

 mode_backcolor	*/ 0x006600ff,

 mode_colorkey,msk*/ 0, 0,

 xres, yres, xpos, ypos */ 320, 240, 5, 5,

 mode_winctrl1 */ LCD_WINCTRL1_FRM_24BPP |

 mode_winenable*/ LCD_WINENABLE_WEN0,

 xres, yres, xpos, ypos */ 0, 0, 0, 0,

 mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565

 mode_winenable*/ 0,

 xres, yres, xpos, ypos */ 100, 100, 0, 0,

 mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |

 mode_winenable*/ 0
 xres, yres, xpos, ypos */ 200, 25, 0, 0,

 mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |

 mode_winenable*/ 0,

 Index 2 */

 mode_backcolor	*/ 0x006600ff,

 mode_colorkey,msk*/ 0, 0,

 xres, yres, xpos, ypos */ 0, 0, 0, 0,

 mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |

 mode_winenable*/ LCD_WINENABLE_WEN0,

 xres, yres, xpos, ypos */ 0, 0, 0, 0,

 mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |

 mode_winenable*/ 0,

 xres, yres, xpos, ypos */ 0, 0, 0, 0,

 mode_winctrl1 */ LCD_WINCTRL1_FRM_32BPP |

 mode_winenable*/ 0
 xres, yres, xpos, ypos */ 0, 0, 0, 0,

 mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |

 mode_winenable*/ 0,

 Need VGA 640 @ 24bpp, @ 32bpp */

 Need VGA 800 @ 24bpp, @ 32bpp */

 Need VGA 1024 @ 24bpp, @ 32bpp */

/*

 * Controller configurations for various panels.

 Full name <vendor>_<model> */

 FB monitor specs */

 panel timings */

 Minimum horizontal resolution */

 Maximum horizontal resolution */

 Minimum vertical resolution */

 Maximum vertical resolution */

*******************************************************************/

 fixme: Maybe a modedb for the CRT ? otherwise panels should be as-is */

/* List of panels known to work with the AU1200 LCD controller.

 * To add a new panel, enter the same specifications as the

 * Generic_TFT one, and MAKE SURE that it doesn't conflicts

 * with the controller restrictions. Restrictions are:

 *

 * STN color panels: max_bpp <= 12

 * STN mono panels: max_bpp <= 4

 * TFT panels: max_bpp <= 16

 * max_xres <= 800

 * max_yres <= 600

 QVGA 320x240 H:33.3kHz V:110Hz */

 /4=24Mhz */

 VGA 640x480 H:30.3kHz V:58Hz */

 /4=24Mhz */

 SVGA 800x600 H:46.1kHz V:69Hz */

 /2=48Mhz */

 XVGA 1024x768 H:56.2kHz V:70Hz */

 /1 */

 XVGA XVGA 1280x1024 H:68.5kHz V:65Hz */

 /1 */

 Samsung 1024x768 TFT */

 SCB 0x1 /4=24Mhz */

 SCB 0x0 */

 SCB 0x0 */

 Toshiba 640x480 TFT */

 /4=24Mhz */

 Sharp 320x240 TFT */

16=6Mhz*/

 96MHz AUXPLL */

 Toppoly TD070WGCB2 7" 856x480 TFT */

 /4=24Mhz */

*******************************************************************/

 how many bits are needed for each pixel format */

 FIX!!! NOT CHECKING FOR COMPLETE OFFSCREEN YET */

 Check for off-screen adjustments */

 Off-screen to the right */

 off by 1 ??? */

printk("off screen right\n");*/

 Off-screen to the bottom */

 off by 1 ??? */

printk("off screen bottom\n");*/

 Off-screen to the left */

printk("off screen left\n");*/

 Off-screen to the top */

 fixme: fb_offset += ((0-ypos)*fb_pars[plane].line_length); */

printk("off screen top\n");*/

 record settings */

 Disable the window while making changes, then restore WINEN */

 drain writebuffer */

 select winbuf0 */

 drain writebuffer */

	/*

	 * Perform global setup/init of LCD controller

 Make sure all windows disabled */

 drain writebuffer */

	/*

	 * Ensure everything is disabled before reconfiguring

 Wait for vertical sync period */

disable the controller*/

clear interrupts*/

 drain writebuffer */

wait for controller to shut down*/

 Call shutdown of current panel (if up) */

		/* this must occur last, because if an external clock is driving

		    the controller, the clock cannot be turned off before first

			shutting down the controller.

 Newpanel == NULL indicates a shutdown operation only */

	/*

	 * Setup clocking if internal LCD clock source (assumes sys_auxpll valid)

 10% slack */

	/*

	 * Configure panel timings

 drain writebuffer */

	/* fixme: Check window settings to make sure still valid

	/*

	 * Re-enable screen now that it is configured

 drain writebuffer */

 Call init of panel */

 FIX!!!! not appropriate on panel change!!! Global setup/init */

 Setup Color Key - FIX!!! */

 Setup HWCursor - FIX!!! Need to support this eventually */

 Window/plane setup */

 FRM,CCO,PO,PIPE */

 drain writebuffer */

 Inline helpers */

#define panel_is_dual(panel)  ((panel->mode_screen & LCD_SCREEN_PT) == LCD_SCREEN_PT_010)*/

#define panel_is_active(panel)((panel->mode_screen & LCD_SCREEN_PT) == LCD_SCREEN_PT_010)*/

 Bitfields format supported by the controller. */

     Red, 	   Green, 	 Blue, 	     Transp   */

-------------------------------------------------------------------------*/

 Helpers */

 FIX!!!! This also needs to take the window pixel format into account!!! */

 Update var-dependent FB info */

 palettized */

 non-palettized */

 mono FIX!!! mono 8 and 4 bits */

-------------------------------------------------------------------------*/

 AU1200 framebuffer driver */

/* fb_check_var

 * Validate var settings with hardware restrictions and modify it if necessary

	/* Make sure that the mode respect all LCD controller and

 No need for virtual resolution support */

 Virtual screen is to big, abort */

 FIX!!!! what are the implicaitons of ignoring this for windows ??? */

	/* The max LCD clock is fixed to 48MHz (value of AUX_CLK). The pixel

	 * clock can only be obtain by dividing this value by an even integer.

 STN 8bit mono panel support is up to 6MHz pixclock */

 Other STN panel support is up to 12MHz  */

 Set bitfield accordingly */

			/* 16bpp True color.

			/* 32bpp True color.

/* fb_set_par

 * Set hardware with var settings. This will enable the controller with a

 * specific mode, normally validated with the fb_check_var method

/* fb_setcolreg

 * Set color in LCD palette.

 Convert color to grayscale */

 Place color in the pseudopalette */

FIX!!! panel_is_active(fbdev->panel)*/) {

 COLOR TFT PALLETTIZED (use RGB 565) */

panel_is_color(fbdev->panel)*/) {

 COLOR STN MODE */

 MONOCHROME MODE */

/* fb_blank

 * Blank the screen. Depending on the mode, the screen will be

 * activated with the backlight color, or desactivated

 Short-circuit screen blanking */

 printk("turn on panel\n"); */

 printk("turn off panel\n"); */

 FB_BLANK_NORMAL is a soft blank */

/* fb_mmap

 * Map video memory in user space. We don't use the generic fb_mmap

 * method mainly to allow the use of the TLB streaming flag (CCA=6)

 SCREEN_SIZE: user cannot reset size, must switch panel choice */

 limit brightness pwm duty to >= 30/1600

 drain writebuffer */

 brightness

 drain writebuffer */

 Window control register 0 */

 Window control register 1 */

 program buffer line width */

 Window control register 2 */

 Buffer line width programmed with WIN_SIZE */

 drain writebuffer */

 Window control register 0 */

 Window control register 1 */

 Window control register 2 */

 drain writebuffer */

-------------------------------------------------------------------------*/

 Nothing to do for now, just clear any pending interrupt */

 drain writebuffer */

-------------------------------------------------------------------------*/

 AU1200 LCD device probe helpers */

 Copy monitor specs from panel data */

	/* fixme: we're setting up LCD controller windows, so these dont give a

	damn as to what the monitor specs are (the panel itself does, but that

	/* We first try the user mode passed in argument. If that failed,

	 * or if no one has been specified, we default to the first mode of the

 drv_info.opt_mode, */

-------------------------------------------------------------------------*/

		/* Panel option - can be panel name,

			/* First check for index, which allows

 AU1200 LCD controller device driver */

 Setup driver with options */

 Point to the panel selected */

 Allocate the framebuffer to the maximum screen size */

 Init FB data */

 Register new framebuffer */

 Start display and show logo on boot */

 Now hook interrupt too */

 Kickstart the panel */

 Clean up all probe data */

 Turn off the panel */

 Clean up all probe data */

 drain writebuffer */

 Kickstart the panel */

 CONFIG_PM */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *

 * tdfxfb.c

 *

 * Author: Hannu Mallat <hmallat@cc.hut.fi>

 *

 * Copyright © 1999 Hannu Mallat

 * All rights reserved

 *

 * Created      : Thu Sep 23 18:17:43 1999, hmallat

 * Last modified: Tue Nov  2 21:19:47 1999, hmallat

 *

 * I2C part copied from the i2c-voodoo3.c driver by:

 * Frodo Looijaard <frodol@dds.nl>,

 * Philip Edelbrock <phil@netroedge.com>,

 * Ralph Metzler <rjkm@thp.uni-koeln.de>, and

 * Mark D. Studebaker <mdsxyz123@yahoo.com>

 *

 * Lots of the information here comes from the Daryll Strauss' Banshee

 * patches to the XF86 server, and the rest comes from the 3dfx

 * Banshee specification. I'm very much indebted to Daryll for his

 * work on the X server.

 *

 * Voodoo3 support was contributed Harold Oga. Lots of additions

 * (proper acceleration, 24 bpp, hardware cursor) and bug fixes by Attila

 * Kesmarki. Thanks guys!

 *

 * Voodoo1 and Voodoo2 support aren't relevant to this driver as they

 * behave very differently from the Voodoo3/4/5. For anyone wanting to

 * use frame buffer on the Voodoo1/2, see the sstfb driver (which is

 * located at http://www.sourceforge.net/projects/sstfb).

 *

 * While I _am_ grateful to 3Dfx for releasing the specs for Banshee,

 * I do wish the next version is a bit more complete. Without the XF86

 * patches I couldn't have gotten even this far... for instance, the

 * extensions to the VGA register set go completely unmentioned in the

 * spec! Also, lots of references are made to the 'SST core', but no

 * spec is publicly available, AFAIK.

 *

 * The structure of this driver comes pretty much from the Permedia

 * driver by Ilario Nardinocchi, which in turn is based on skeletonfb.

 *

 * TODO:

 * - multihead support (basically need to support an array of fb_infos)

 * - support other architectures (PPC, Alpha); does the fact that the VGA

 *   core can be accessed only thru I/O (not memory mapped) complicate

 *   things?

 *

 * Version history:

 *

 * 0.1.4 (released 2002-05-28)	ported over to new fbdev api by James Simmons

 *

 * 0.1.3 (released 1999-11-02)	added Attila's panning support, code

 *				reorg, hwcursor address page size alignment

 *				(for mmapping both frame buffer and regs),

 *				and my changes to get rid of hardcoded

 *				VGA i/o register locations (uses PCI

 *				configuration info now)

 * 0.1.2 (released 1999-10-19)	added Attila Kesmarki's bug fixes and

 *				improvements

 * 0.1.1 (released 1999-10-07)	added Voodoo3 support by Harold Oga.

 * 0.1.0 (released 1999-10-06)	initial version

 *

 "640x480, 8 bpp @ 60 Hz */

/*

 * PCI driver prototypes

/*

 * Driver data

 not implemented (yet) */

/* -------------------------------------------------------------------------

 *			Hardware-specific funcions

	/* Note: The Voodoo3's onboard FIFO has 32 slots. This loop

/*

 * Set the color of a palette entry in 8bpp mode

 read after write makes it working */

			/*

			 * Estimate value of n that produces target frequency

			 * with current m and k

 Search neighborhood of estimated n */

				/*

				 * Calculate PLL freqency with current m, k and

				 * estimated n

				/*

				 * If this is the closest we've come to the

				 * target frequency then remember n, m and k

 CRT unprotect */

 in MB */

 Banshee/Voodoo3 */

 Voodoo4/5 */

 disable block writes for SDRAM */

 ------------------------------------------------------------------------- */

	/*

	 * Banshee doesn't support interlace, but Voodoo4/5 and probably

	 * Voodoo3 do.

	 * no direct information about device id now?

	 *  use max_pixclock for this...

 could sometimes be 8 */

 PLL settings */

 this is all pretty standard VGA register stuffing */

 fixme: clkdiv2? */

 Banshee's nonvga stuff */

 Now change fb_fix_screeninfo according to changes in par */

 A handy macro shamelessly pinched from matroxfb */

 grayscale works only partially under directcolor */

 grayscale = 0.30*R + 0.59*G + 0.11*B */

 Truecolor has no hardware color palettes. */

 0 unblank, 1 blank, 2 no vsync, 3 no hsync, 4 off */

 Screen: On; HSync: On, VSync: On */

 Screen: Off; HSync: On, VSync: On */

 Screen: Off; HSync: On, VSync: Off */

 Screen: Off; HSync: Off, VSync: On */

 Screen: Off; HSync: Off, VSync: Off */

/*

 * Set the starting position of the visible screen to var->yoffset

/*

 * FillRect 2D command (solidfill or invert (via ROP_XOR))

 assume always rect->height < 4096 */

 assume always rect->width < 4096 */

 FB_VISUAL_TRUECOLOR */

/*

 * Screen-to-Screen BitBlt 2D command (for the bmove fb op.)

 assume always area->height < 4096 */

 assume always area->width < 4096 */

 assume always area->height < 4096 */

 assume always area->width < 4096 */

 -X */

 -Y */

 assume always image->height < 4096 */

 assume always image->width < 4096 */

	/* A count of how many free FIFO entries we've requested.

 Send four bytes at a time of data */

 Send the leftovers now */

 CONFIG_FB_3DFX_ACCEL */

 just to force soft_cursor() call */

 Too large of a cursor or wrong bpp :-( */

	/*

	 * If the cursor is not be changed this means either we want the

	 * current cursor state (if enable is set) or we want to query what

	 * we can do with the cursor (if enable is not set)

 fix cursor color - XFree86 forgets to restore it properly */

		/*

		 * Voodoo 3 and above cards use 2 monochrome cursor patterns.

		 *    The reason is so the card can fetch 8 words at a time

		 * and are stored on chip for use for the next 8 scanlines.

		 * This reduces the number of times for access to draw the

		 * cursor for each screen refresh.

		 *    Each pattern is a bitmap of 64 bit wide and 64 bit high

		 * (total of 8192 bits or 1024 bytes). The two patterns are

		 * stored in such a way that pattern 0 always resides in the

		 * lower half (least significant 64 bits) of a 128 bit word

		 * and pattern 1 the upper half. If you examine the data of

		 * the cursor image the graphics card uses then from the

		 * beginning you see line one of pattern 0, line one of

		 * pattern 1, line two of pattern 0, line two of pattern 1,

		 * etc etc. The linear stride for the cursor is always 16 bytes

		 * (128 bits) which is the maximum cursor width times two for

		 * the two monochrome patterns.

 Pattern 0. Copy the cursor mask to it */

 Pattern 1. Copy the cursor bitmap to it */

/* The voo GPIO registers don't have individual masks for each bit

 flush posted write */

 flush posted write */

/* The GPIO pins are open drain, so the pins always remain outputs.

   We rely on the i2c-algo-bit routines to set the pins high before

 flush posted write */

 flush posted write */

 CONFIG_FB_3DFX_I2C */

/**

 *      tdfxfb_probe - Device Initializiation

 *

 *      @pdev:  PCI Device to initialize

 *      @id:    PCI Device ID

 *

 *      Initializes and allocates resources for PCI device @pdev.

 *

 Configure the default fb_fix_screeninfo first */

 reserve 8192 bits for cursor */

 the 2.4 driver says PAGE_MASK boundary is not enough for Voodoo4 */

 fill all other info->var's fields */

 maximize virtual vertical length */

	/*

	 * Our driver data

	/*

	 * Cleanup after anything that was remapped/allocated.

/**

 *      tdfxfb_remove - Device removal

 *

 *      @pdev:  PCI Device to cleanup

 *

 *      Releases all resources allocated during the course of the driver's

 *      lifetime for the PCI device @pdev.

 *

 Clean up after reserved regions */

/*

 * linux/drivers/video/hitfb.c -- Hitachi LCD frame buffer device

 *

 * (C) 1999 Mihai Spatar

 * (C) 2000 YAEGASHI Takeshi

 * (C) 2003, 2004 Paul Mundt

 * (C) 2003, 2004, 2006 Andriy Skulysh

 *

 *  This file is subject to the terms and conditions of the GNU General Public

 *  License. See the file COPYING in the main directory of this archive for

 *  more details.

 RGB 565 */

 RGB 565 */

 SPDX-License-Identifier: GPL-2.0-only

/* leo.c: LEO frame buffer driver

 *

 * Copyright (C) 2003, 2006 David S. Miller (davem@davemloft.net)

 * Copyright (C) 1996-1999 Jakub Jelinek (jj@ultra.linux.cz)

 * Copyright (C) 1997 Michal Rehacek (Michal.Rehacek@st.mff.cuni.cz)

 *

 * Driver layout based loosely on tgafb.c, see that file for credits.

/*

 * Local functions.

/*

 *  Frame buffer operations

 SS1 only */

 SS1 only */

 Copy/Scroll (SS0 only) */

 Copy/Scroll/Fill (SS0 only) */

 Copy/Scroll/Fill size (SS0 only) */

 SS1 only */

 SS1 only */

 SS1 only */

 SS1 only */

 SS1 only */

 SS1 only */

 SS1 only */

 SS1 only */

 SS1 only */

 SS1 only */

 SS1 only */

 SS1 only */

 SS1 only */

 SS1 only */

 SS1 only */

 Busy wait at most 0.3 sec */

 setup screen buffer for cfb_* functions */

 hide cursor */

	/* We just use this to catch switches out of

	 * graphics mode.

/**

 *      leo_setcolreg - Optional function. Sets a color register.

 *      @regno: boolean, 0 copy local, 1 get_user() function

 *      @red: frame buffer colormap structure

 *      @green: The green value which can be up to 16 bits wide

 *      @blue:  The blue value which can be up to 16 bits wide.

 *      @transp: If supported the alpha value which can be up to 16 bits wide.

 *      @info: frame buffer info structure

/**

 *      leo_blank - Optional function.  Blanks the display.

 *      @blank: the blank mode we want.

 *      @info: frame buffer structure that represents a single frame buffer

 Unblanking */

 Normal blanking */

 VESA blank (vsync off) */

 VESA blank (hsync off) */

 Poweroff */

/*

 *  Initialisation

 SPDX-License-Identifier: GPL-2.0-only

/*

 * linux/drivers/video/w100fb.c

 *

 * Frame Buffer Device for ATI Imageon w100 (Wallaby)

 *

 * Copyright (C) 2002, ATI Corp.

 * Copyright (C) 2004-2006 Richard Purdie

 * Copyright (c) 2005 Ian Molton

 * Copyright (c) 2006 Alberto Mardegan

 *

 * Rewritten for 2.6 by Richard Purdie <rpurdie@rpsys.net>

 *

 * Generic platform support by Ian Molton <spyro@f2s.com>

 * and Richard Purdie <rpurdie@rpsys.net>

 *

 * w32xx support by Ian Molton

 *

 * Hardware acceleration support by Alberto Mardegan

 * <mardy@users.sourceforge.net>

/*

 * Prototypes

 Pseudo palette size */

 Remapped addresses for base cfg, memmapped regs and the frame buffer itself */

/* This is the offset in the w100's address space we map the current

   framebuffer memory to. We use the position of external memory as

/*

 * Sysfs functions

/*

 * Some touchscreens need hsync information from the video driver to

 * function correctly. We export it here.

 If display is blanked/suspended, hsync isn't active */

/*

 * Set a palette value from rgb components

	/*

	 * If greyscale is true, then we convert the RGB value

	 * to greyscale no matter what visual we are using.

	/*

	 * 16-bit True Colour.  We encode the RGB value

	 * according to the RGB bitfield information.

/*

 * Blank the display based on value in blank_mode

 Normal blanking */

 VESA blank (vsync off) */

 VESA blank (hsync off) */

 Poweroff */

 Unblanking */

 from DstType_16Bpp_444 */

/*

 *  Change the resolution by calling the appropriate hardware functions

/* Select the smallest mode that allows the desired resolution to be

 * displayed. If desired, the x and y parameters can be rounded up to

 * match the selected mode.

/*

 *  w100fb_check_var():

 *  Get the video params out of 'var'. If a value doesn't fit, round it up,

 *  if it's too big, return -EINVAL.

 171521; */

/*

 * w100fb_set_par():

 *	Set the user defined part of the display for the specified console

 *  by looking at the values in info.var

/*

 *  Frame buffer operations

 Remap the chip base address */

 Map the register space */

 Identify the chip */

 Remap the framebuffer */

 171521; */

 ------------------- chipset specific functions -------------------------- */

 Prevent display updates */

 Enable display updates */

/*

 * Initialization of critical w100 hardware

	/* This is what the fpga_init code does on reset. May be wrong

 Set up CIF */

 Setup cfgINTF_CNTL and cfgCPU defaults */

 set up the apertures */

 Set the hardware to 565 colour */

 Initialise the GPIO lines */

 system clock auto changing? */

 The PLL Fout is determined by (XtalFreq/(M+1)) * ((N_int+1) + (N_fac/8)) */

 12.5MHz Crystal PLL Table */

freq     M   N_int    N_fac  tfgoal  lock_time */

  50.00 MHz */

  75.00 MHz */

 100.00 MHz */

 125.00 MHz */

 150.00 MHz */

 Terminator */

 14.318MHz Crystal PLL Table */

freq     M   N_int    N_fac  tfgoal  lock_time */

 tfgoal guessed */

  50.05 MHz */

 tfgoal guessed */

  75.08 MHz */

 100.10 MHz */

 16MHz Crystal PLL Table */

freq     M   N_int    N_fac  tfgoal  lock_time */

 tfgoal guessed */

 tfgoal guessed */

 tfgoal guessed */

 tfgoal guessed */

 Select the test clock source and reset */

 set reset */

 clear reset */

 Run clock test */

 Give the test time to complete */

 Return the result */

 Initial Settings */

 power down */

 not reset */

 Hi-Z */

 VCO gain = 0 */

 VCO frequency range control = off */

 current offset inside VCO = 0 */

	/* Wai Ming 80 percent of VDD 1.3V gives 1.04V, minimum operating voltage is 1.08V

	 * therefore, commented out the following lines

	 * tf80 meant tf100

 set VCO input = 0.8 * VDD */

 set VCO input = 0.2 * VDD */

 Success */

 slow VCO config */

 Error */

/*

 * w100_pll_calibration

 PLL Reset And Lock */

 set VCO input = 0.5 * VDD */

 reset time */

 enable charge pump */

 normal */

 set VCO input = Hi-Z, disable DAC */

 lock time */

 PLL locked */

 auto mode */

 disable fast to normal */

 disable normal to fast */

 Set system clock source to XTAL whilst adjusting the PLL! */

 auto mode */

 reenable fast to normal */

 reenable normal to fast  */

 freq = target frequency of the PLL */

/* Set up an initial state.  Some values/fields set

 Pfast = 1 */

 Pslow = 1 */

 Dynamic */

 Dynamic */

 Dynamic */

 Dynamic */

 Dynamic */

 Dynamic */

 Dynamic */

 Dynamic */

 Dynamic */

 P = 2 */

 Dynamic */

 M = 1 */

 N = 1.0 */

 uses VCO clock */

 Hi-Z */

 normal mode (0, 1, 3) */

 PM4,ENG */

 PM4,ENG */

 manual mode */

/*

 * Setup the w100 clocks for the specified mode

 w3200 doesn't like undefined bits being set so zero register values first */

 Hack for overlay in ext memory */

 Map Internal Memory at FB Base */

		/* Unmap External Memory - value is *probably* irrelevant but may have meaning

 Map Internal Memory to its default location */

 Map External Memory at FB Base */

 See if the mode has been rotated */

 180 degree */

 else 0 degree */

 270 degree */

 90 degree */

 w32xx doesn't like undefined bits */

 Zaurus needs this */

 0 */

 180 */

 90 */

 270 */

 panel xres, not mode */

 Set the pixel clock source and divider */

/*

 * Work out how long the sync pulse lasts

 * Value is 1/(time in seconds)

 bit20=0 */

 bit31:24=0xff */

 bit18=0 */

 bit19=1 */

 wait 1us */

 CKE: Tri-State */

 bit30=1 */

 CLK: Stop */

 bit0=0 */

 bit2=1 */

 VSync timeout = 30[ms] > 16.8[ms] */

 set vline pos  */

 disable vline irq */

 clear vline irq status */

 enable vline irq */

 clear vline irq status */

 disable vline irq */

 clear vline irq status */

/*

 *  linux/drivers/video/vfb.c -- Virtual frame buffer device

 *

 *      Copyright (C) 2002 James Simmons

 *

 *	Copyright (C) 1997 Geert Uytterhoeven

 *

 *  This file is subject to the terms and conditions of the GNU General Public

 *  License. See the file COPYING in the main directory of this archive for

 *  more details.

    /*

     *  RAM we reserve for the frame buffer. This defines the maximum screen

     *  size

     *

     *  The default can be overridden if the driver is compiled as a module

 1 MB */

 disabled by default */

    /*

     *  Internal routines

    /*

     *  Setting the video mode has been split into two parts.

     *  First part, xxxfb_check_var, must not write anything

     *  to hardware, it should only verify and adjust var.

     *  This means it doesn't alter par but it does use hardware

     *  data from it to check this var. 

	/*

	 *  FB_VMODE_CONUPDATE and FB_VMODE_SMOOTH_XPAN are equal!

	 *  as FB_VMODE_SMOOTH_XPAN is only used internally

	/*

	 *  Some very basic checks

	/*

	 *  Memory limit

	/*

	 * Now that we checked it we alter var. The reason being is that the video

	 * mode passed in might not work but slight changes to it might make it 

	 * work. This way we let the user know what is acceptable.

 RGBA 5551 */

 RGB 565 */

 RGB 888 */

 RGBA 8888 */

/* This routine actually sets the video mode. It's in here where we

 * the hardware state info->par and fix which can be affected by the 

 * change in par. For this driver it doesn't do much. 

    /*

     *  Set a single color register. The values supplied are already

     *  rounded down to the hardware's capabilities (according to the

     *  entries in the var structure). Return != 0 for invalid regno.

 no. of hw registers */

	/*

	 * Program hardware... do anything you want with transp

 grayscale works only partially under directcolor */

 grayscale = 0.30*R + 0.59*G + 0.11*B */

	/* Directcolor:

	 *   var->{color}.offset contains start of bitfield

	 *   var->{color}.length contains length of bitfield

	 *   {hardwarespecific} contains width of RAMDAC

	 *   cmap[X] is programmed to (X << red.offset) | (X << green.offset) | (X << blue.offset)

	 *   RAMDAC[X] is programmed to (red, green, blue)

	 *

	 * Pseudocolor:

	 *    var->{color}.offset is 0 unless the palette index takes less than

	 *                        bits_per_pixel bits and is stored in the upper

	 *                        bits of the pixel value

	 *    var->{color}.length is set so that 1 << length is the number of available

	 *                        palette entries

	 *    cmap is not used

	 *    RAMDAC[X] is programmed to (red, green, blue)

	 *

	 * Truecolor:

	 *    does not use DAC. Usually 3 are present.

	 *    var->{color}.offset contains start of bitfield

	 *    var->{color}.length contains length of bitfield

	 *    cmap is programmed to (red << red.offset) | (green << green.offset) |

	 *                      (blue << blue.offset) | (transp << transp.offset)

	 *    RAMDAC does not exist

 expect 8 bit DAC */

 hey, there is bug in transp handling... */

 Truecolor has hardware independent palette */

    /*

     *  Pan or Wrap the Display

     *

     *  This call looks only at xoffset, yoffset and the FB_VMODE_YWRAP flag

    /*

     *  Most drivers don't need their own mmap function 

/*

 * The virtual framebuffer driver is only enabled if explicitly

 * requested by passing 'video=vfb:' (or any actual options).

 Test disable for backwards compatibility */

  MODULE  */

    /*

     *  Initialisation

	/*

	 * For real video cards we use ioremap.

 MODULE */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  linux/drivers/video/acornfb.c

 *

 *  Copyright (C) 1998-2001 Russell King

 *

 * Frame buffer code for Acorn platforms

 *

 * NOTE: Most of the modes with X!=640 will disappear shortly.

 * NOTE: Startup setting of HS & VS polarity not supported.

 *       (do we need to support it if we're coming up in 640x480?)

 *

 * FIXME: (things broken by the "new improved" FBCON API)

 *  - Blanking 8bpp displays with VIDC

/*

 * Default resolution.

 * NOTE that it has to be supported in the table towards

 * the end of this file.

/*

 * define this to debug the video mode selection

/*

 * Translation from RISC OS monitor types to actual

 * HSYNC and VSYNC frequency ranges.  These are

 * probably not right, but they're the best info I

 * have.  Allow 1% either way on the nominal for TVs.

 TV		*/

 Multi Freq	*/

 Hi-res mono	*/

 VGA		*/

 SVGA		*/

 set by setup.c */

/* VIDC20 has a different set of rules from the VIDC:

 *  hcr  : must be multiple of 4

 *  hswr : must be even

 *  hdsr : must be even

 *  hder : must be even

 *  vcr  : >= 2, (interlace, must be odd)

 *  vswr : >= 1

 *  vdsr : >= 1

 *  vder : >= vdsr

 should be FB_SYNC_COMP */

 RiscPC doesn't use the VIDC's VRAM control. */

	/* The data bus width is dependent on both the type

	 * and amount of video memory.

	 *     DRAM	32bit low

	 * 1MB VRAM	32bit

	 * 2MB VRAM	64bit

/*

 * We have to take note of the VIDC20's 16-bit palette here.

 * The VIDC20 looks up a 16 bit pixel as follows:

 *

 *   bits   111111

 *          5432109876543210

 *   red            ++++++++  (8 bits,  7 to 0)

 *  green       ++++++++      (8 bits, 11 to 4)

 *   blue   ++++++++          (8 bits, 15 to 8)

 *

 * We use a pixel which looks like:

 *

 *   bits   111111

 *          5432109876543210

 *   red               +++++  (5 bits,  4 to  0)

 *  green         +++++       (5 bits,  9 to  5)

 *   blue    +++++            (5 bits, 14 to 10)

 Palette register pointer auto-increments */

/*

 * Before selecting the timing parameters, adjust

 * the resolution to fit the rules.

 xres must be even */

	/*

	 * We don't allow xres_virtual to differ from xres

	/*

	 * Now, find a value for yres_virtual which allows

	 * us to do ywrap scrolling.  The value of

	 * yres_virtual must be such that the end of the

	 * displayable frame buffer must be aligned with

	 * the start of a font line.

	/*

	 * If minimum screen size is greater than that we have

	 * available, reject it.

	/* Find int 'y', such that y * fll == s * sam < maxsize

	 * y = s * sam / fll; s = maxsize / sam

			/*

			 * failed, use ypan

	/*

	 * Fix yres & yoffset if needed.

 hsync_len must be even */

 left_margin must be even */

 right_margin must be even */

	/*

	 * hs(Hz) = 10^12 / (pixclock * xtotal)

	 * vs(Hz) = hs(Hz) / ytotal

	 *

	 * No need to do long long divisions or anything

	 * like that if you factor it correctly

	/*

	 * FIXME: Find the font height

	/*

	 * Check to see if the pixel rate is valid.

	/*

	 * Validate and adjust the resolution to

	 * match the video generator hardware.

	/*

	 * Validate the timing against the

	 * monitor hardware.

/*

 * Everything after here is initialisation!!!

 320x256 @ 50Hz */

 640x250 @ 50Hz, 15.6 kHz hsync */

 640x256 @ 50Hz, 15.6 kHz hsync */

 640x512 @ 50Hz, 26.8 kHz hsync */

 640x250 @ 70Hz, 31.5 kHz hsync */

 640x256 @ 70Hz, 31.5 kHz hsync */

 640x352 @ 70Hz, 31.5 kHz hsync */

 640x480 @ 60Hz, 31.5 kHz hsync */

 800x600 @ 56Hz, 35.2 kHz hsync */

 896x352 @ 60Hz, 21.8 kHz hsync */

 1024x 768 @ 60Hz, 48.4 kHz hsync */

 1280x1024 @ 60Hz, 63.8 kHz hsync */

	/*

	 * setup initial parameters

/*

 * setup acornfb options:

 *

 *  mon:hmin-hmax:vmin-vmax:dpms:width:height

 *	Set monitor parameters:

 *		hmin   = horizontal minimum frequency (Hz)

 *		hmax   = horizontal maximum frequency (Hz)	(optional)

 *		vmin   = vertical minimum frequency (Hz)

 *		vmax   = vertical maximum frequency (Hz)	(optional)

 *		dpms   = DPMS supported?			(optional)

 *		width  = width of picture in mm.		(optional)

 *		height = height of picture in mm.		(optional)

 *

 * montype:type

 *	Set RISC-OS style monitor type:

 *		0 (or tv)	- TV frequency

 *		1 (or multi)	- Multi frequency

 *		2 (or hires)	- Hi-res monochrome

 *		3 (or vga)	- VGA

 *		4 (or svga)	- SVGA

 *		auto, or option missing

 *				- try hardware detect

 *

 * dram:size

 *	Set the amount of DRAM to use for the frame buffer

 *	(even if you have VRAM).

 *	size can optionally be followed by 'M' or 'K' for

 *	MB or KB respectively.

/*

 * Detect type of monitor connected

 *  For now, we just assume SVGA

	/*

	 * Try to select a suitable default mode

	/*

	 * If vram_size is set, we are using VRAM in

	 * a Risc PC.  However, if the user has specified

	 * an amount of DRAM then use that instead.

	/*

	 * Limit maximum screen size.

		/*

		 * RiscPC needs to allocate the DRAM memory

		 * for the framebuffer if we are not using

		 * VRAM.

	/*

	 * Lookup the timing for this resolution.  If we can't

	 * find it, then we can't restore it if we change

	 * the resolution, so we disable this feature.

		/*

		 * If we found an exact match, all ok.

		/*

		 * If we found an exact match, all ok.

	/*

	 * If we didn't find an exact match, try the

	 * generic database.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * drivers/video/pvr2fb.c

 *

 * Frame buffer and fbcon support for the NEC PowerVR2 found within the Sega

 * Dreamcast.

 *

 * Copyright (c) 2001 M. R. Brown <mrbrown@0xd6.org>

 * Copyright (c) 2001 - 2008  Paul Mundt <lethal@linux-sh.org>

 *

 * This driver is mostly based on the excellent amifb and vfb sources.  It uses

 * an odd scheme for converting hardware values to/from framebuffer values,

 * here are some hacked-up formulas:

 *

 *  The Dreamcast has screen offsets from each side of its four borders and

 *  the start offsets of the display window.  I used these values to calculate

 *  'pseudo' values (think of them as placeholders) for the fb video mode, so

 *  that when it came time to convert these values back into their hardware

 *  values, I could just add mode- specific offsets to get the correct mode

 *  settings:

 *

 *      left_margin = diwstart_h - borderstart_h;

 *      right_margin = borderstop_h - (diwstart_h + xres);

 *      upper_margin = diwstart_v - borderstart_v;

 *      lower_margin = borderstop_v - (diwstart_h + yres);

 *

 *      hsync_len = borderstart_h + (hsync_total - borderstop_h);

 *      vsync_len = borderstart_v + (vsync_total - borderstop_v);

 *

 *  Then, when it's time to convert back to hardware settings, the only

 *  constants are the borderstart_* offsets, all other values are derived from

 *  the fb video mode:

 *

 *      // PAL

 *      borderstart_h = 116;

 *      borderstart_v = 44;

 *      ...

 *      borderstop_h = borderstart_h + hsync_total - hsync_len;

 *      ...

 *      diwstart_v = borderstart_v - upper_margin;

 *

 *  However, in the current implementation, the borderstart values haven't had

 *  the benefit of being fully researched, so some modes may be broken.

 2D video registers */

 Pixel clocks, one for TV output, doubled for VGA output */

 This is for 60Hz - the VTOTAL is doubled for interlaced modes */

 Supported cable types */

 Supported video output types */

 Supported palette types */

/*

 * This describes the current video mode

 Clocks/line */

 Lines/field */

 Horizontal offset of the display field */

	unsigned int diwstart_v;	/* Vertical offset of the display field, for

 Address of image within VRAM */

 Is the display interlaced? */

 Are scanlines output twice? (doublescan) */

 Is horizontal pixel-doubling enabled? */

 MMIO base */

/*

 * We do all updating, blanking, etc. during the vertical retrace period

 Change the video mode */

 Update the video mode */

 (Un)Blank the screen */

 Is the screen blanked? */

    /*

     * Broadcast video modes (PAL and NTSC).  I'm unfamiliar with

     * PAL-M and PAL-N, but from what I've read both modes parallel PAL and

     * NTSC, so it shouldn't be a problem (I hope).

 640x480 @ 60Hz interlaced (NTSC) */

 640x240 @ 60Hz (NTSC) */

 XXX: Broken! Don't use... */

 640x480 @ 60hz (VGA) */

 RGB 565 */

 RGB 888 */

 ARGB 8888 */

	/*

	 * We only support the hardware palette for 16 and 32bpp. It's also

	 * expected that the palette format has been set by the time we get

	 * here, so we don't waste time setting it again.

 RGB 565 */

 RGB 888 */

 ARGB 8888 */

/*

 * Determine the cable type and initialize the cable output format.  Don't do

 * anything if the cable type has been overidden (via "cable:XX").

 Now select the output format (either composite or other) */

	/* XXX: Save the previous val first, as this reg is also AICA

	/*

	 * XXX: It's possible that a user could use a VGA box, change the cable

	 * type in hardware (i.e. switch from VGA<->composite), then change

	 * modes (i.e. switching to another VT).  If that happens we should

	 * automagically change the output format to cope, but currently I

	 * don't have a VGA box to make sure this works properly.

	/*

	 * XXX: Need to be more creative with this (i.e. allow doublecan for

	 * PAL/NTSC output).

 XXX: Check for start values here... */

 XXX: Check hardware for PAL-compatibility */

 NTSC video output */

 VGA mode */

 XXX: What else needs to be checked? */

		/*

		 * XXX: We have a little freedom in VGA modes, what ranges

		 * should be here (i.e. hsync/vsync totals, etc.)?

 Calculate the remainding offsets */

	/*

	 * XXX: Need to be more creative with this (i.e. allow doublecan for

	 * PAL/NTSC output).

 PAL video output */

 XXX: Should be using a range here ... ? */

 NTSC video output */

 Check memory sizes */

 Update the start address of the display image */

/*

 * Initialize the video mode.  Currently, the 16bpp and 24bpp modes aren't

 * very stable.  It's probably due to the fact that a lot of the 2D video

 * registers are still undocumented.

 hsync and vsync totals */

 column height, modulo, row width */

	/* since we're "panning" within vram, we need to offset things based

 display address, long and short fields */

 border horizontal, border vertical, border color */

 display window start position */

 misc. settings */

 clock doubler (for VGA), scan doubler, display enable */

 bits per pixel */

	/* video enable, color sync, interlace,

|4*/) << 4), DISP_SYNCCONF);

 Simulate blanking by making the border cover the entire screen */

			/*

			 *  Clamp the unsigned nr_pages to zero so that the

			 *  error handling works. And leave ret at whatever

			 *  -errno value was returned from GUP.

			/*

			 * Use -EINVAL to represent a mildly desperate guess at

			 * why we got fewer pages (maybe even zero pages) than

			 * requested.

 Half-assed contig check */

 As we do this in one shot, it's either all or nothing.. */

 Not contiguous, writeout per-page instead.. */

 CONFIG_PVR2_DMA */

/**

 * pvr2fb_common_init

 *

 * Common init code for the PVR2 chips.

 *

 * This mostly takes care of the common aspects of the fb setup and

 * registration. It's expected that the board-specific init code has

 * already setup pvr2_fix with something meaningful at this point.

 *

 * Device info reporting is also done here, as well as picking a sane

 * default from the modedb. For board-specific modelines, simply define

 * a per-board modedb.

 *

 * Also worth noting is that the cable and video output types are likely

 * always going to be VGA for the PCI-based PVR2 boards, but we leave this

 * in for flexibility anyways. Who knows, maybe someone has tv-out on a

 * PCI-based version of these things ;-)

Must write PIXDEPTH to register before anything is displayed - so force init */

 Make a guess at the monitor based on the attached cable */

 Not VGA, using a TV (taken from acornfb) */

	/*

	 * XXX: This needs to pull default video output via BIOS or other means

	/*

	 * Nothing exciting about the DC PVR2 .. only a measly 8MiB.

 RAM starts here */

 registers start here */

 CONFIG_SH_DREAMCAST */

	/*

	 * Slightly more exciting than the DC PVR2 .. 16MiB!

 CONFIG_PCI */

/*

 * Parse command arguments.  Supported arguments are:

 *    inverse                             Use inverse color maps

 *    cable:composite|rgb|vga             Override the video cable type

 *    output:NTSC|PAL|VGA                 Override the video output format

 *

 *    <xres>x<yres>[-<bpp>][@<refresh>]   or,

 *    <name>[-<bpp>][@<refresh>]          Startup using this video mode

/*

 *  linux/drivers/video/68328fb.c -- Low level implementation of the

 *                                   mc68x328 LCD frame buffer device

 *

 *	Copyright (C) 2003 Georges Menie

 *

 *  This driver assumes an already configured controller (e.g. from config.c)

 *  Keep the code clean of board specific initialization.

 *

 *  This code has not been tested with colors, colormap management functions

 *  are minimal (no colormap data written to the 68328 registers...)

 *

 *  initial version of this driver:

 *    Copyright (C) 1998,1999 Kenneth Albanowski <kjahds@kjahds.com>,

 *                            The Silver Hammer Group, Ltd.

 *

 *  this version is based on :

 *

 *  linux/drivers/video/vfb.c -- Virtual frame buffer device

 *

 *      Copyright (C) 2002 James Simmons

 *

 *	Copyright (C) 1997 Geert Uytterhoeven

 *

 *  This file is subject to the terms and conditions of the GNU General Public

 *  License. See the file COPYING in the main directory of this archive for

 *  more details.

    /*

     *  Interface used by the world

    /*

     *  Internal routines

    /*

     *  Setting the video mode has been split into two parts.

     *  First part, xxxfb_check_var, must not write anything

     *  to hardware, it should only verify and adjust var.

     *  This means it doesn't alter par but it does use hardware

     *  data from it to check this var. 

	/*

	 *  FB_VMODE_CONUPDATE and FB_VMODE_SMOOTH_XPAN are equal!

	 *  as FB_VMODE_SMOOTH_XPAN is only used internally

	/*

	 *  Some very basic checks

	/*

	 *  Memory limit

	/*

	 * Now that we checked it we alter var. The reason being is that the video

	 * mode passed in might not work but slight changes to it might make it 

	 * work. This way we let the user know what is acceptable.

 RGBA 5551 */

 RGB 565 */

 RGB 888 */

 RGBA 8888 */

/* This routine actually sets the video mode. It's in here where we

 * the hardware state info->par and fix which can be affected by the 

 * change in par. For this driver it doesn't do much. 

    /*

     *  Set a single color register. The values supplied are already

     *  rounded down to the hardware's capabilities (according to the

     *  entries in the var structure). Return != 0 for invalid regno.

 no. of hw registers */

	/*

	 * Program hardware... do anything you want with transp

 grayscale works only partially under directcolor */

 grayscale = 0.30*R + 0.59*G + 0.11*B */

	/* Directcolor:

	 *   var->{color}.offset contains start of bitfield

	 *   var->{color}.length contains length of bitfield

	 *   {hardwarespecific} contains width of RAMDAC

	 *   cmap[X] is programmed to (X << red.offset) | (X << green.offset) | (X << blue.offset)

	 *   RAMDAC[X] is programmed to (red, green, blue)

	 * 

	 * Pseudocolor:

	 *    uses offset = 0 && length = RAMDAC register width.

	 *    var->{color}.offset is 0

	 *    var->{color}.length contains width of DAC

	 *    cmap is not used

	 *    RAMDAC[X] is programmed to (red, green, blue)

	 * Truecolor:

	 *    does not use DAC. Usually 3 are present.

	 *    var->{color}.offset contains start of bitfield

	 *    var->{color}.length contains length of bitfield

	 *    cmap is programmed to (red << red.offset) | (green << green.offset) |

	 *                      (blue << blue.offset) | (transp << transp.offset)

	 *    RAMDAC does not exist

 expect 8 bit DAC */

 hey, there is bug in transp handling... */

 Truecolor has hardware independent palette */

    /*

     *  Pan or Wrap the Display

     *

     *  This call looks only at xoffset, yoffset and the FB_VMODE_YWRAP flag

    /*

     *  Most drivers don't need their own mmap function 

 this is uClinux (no MMU) specific code */

    /*

     *  Initialisation

	/*

	 *  initialize the default mode from the LCD controller registers

 MODULE */

/*

 * linux/drivers/video/metronomefb.c -- FB driver for Metronome controller

 *

 * Copyright (C) 2008, Jaya Kumar

 *

 * This file is subject to the terms and conditions of the GNU General Public

 * License. See the file COPYING in the main directory of this archive for

 * more details.

 *

 * Layout is based on skeletonfb.c by James Simmons and Geert Uytterhoeven.

 *

 * This work was made possible by help and equipment support from E-Ink

 * Corporation. https://www.eink.com/

 *

 * This driver is written to be used with the Metronome display controller.

 * It is intended to be architecture independent. A board specific driver

 * must be used to perform all the physical IO interactions. An example

 * is provided as am200epd.c

 *

 Display specific information */

 frame differs from image. frame includes non-visible pixels */

 frame width */

 frame height */

 sdlew */

 sdosz */

 sdor */

 sdces */

 sdcer */

 gdspl */

 gdr1 */

 sdshr */

 gdspp */

 gdspw */

 dispc */

 vdlc */

 dsi */

 dsic */

 the waveform structure that is coming from userspace firmware */

 main metronomefb functions */

 here we decode the incoming waveform file and populate metromem */

	/* calculating trn. trn is something used to index into

	the waveform. presumably selecting the right one for the

	desired temperature. it works out the offset of the first

 check temperature range table checksum */

 check waveform mode table address checksum */

 check waveform temperature table address checksum */

	/* here we do the real work of putting the waveform into the

	/* setup display command

	we can't immediately set the opcode since the controller

	will try parse the command before we've set it all up

 set the args ( 2 bytes ) for display */

 border update */

 the rest are 0 */

 display cmd */

 setup power up command */

 pwr up pseudo cmd */

 set pwr1,2,3 to 1024 */

 the rest are 0 */

	/* setup config command

	we can't immediately set the opcode since the controller

 the rest are 0 */

 config cmd */

	/* setup init command

	we can't immediately set the opcode since the controller

	will try parse the command before we've set it all up

 set the args ( 2 bytes ) for init */

 the rest are 0 */

 init cmd */

 copy from vm to metromem */

 swizzle from vm to metromem and recalc cksum at the same time*/

 this is called back from the deferred io workqueue */

 walk the written page list and swizzle the data */

/*

 * this is the slow path from userspace. they can seek and write to

 * the fb. it is based on fb_sys_write

 pick up board specific routines */

 try to count device specific driver, if can't, platform recalls */

	/* we have two blocks of memory.

	info->screen_base which is vm, and is the fb used by apps.

	par->metromem which is physically contiguous memory and

	contains the display controller commands, waveform,

	processed image data and padding. this is the data pulled

	by the device's LCD controller and pushed to Metronome.

	the metromem memory is allocated by the board driver and

	/* we need to add a spare page because our csum caching scheme walks

 this table caches per page csum values. */

	/* the physical framebuffer that we use is setup by

	 * the platform device driver. It will provide us

 after this point we should have a framebuffer */

	/* load the waveform in. assume mode 3, temp 31 for now

		a) request the waveform file from userspace

 set cmap */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  pxa3xx-gcu.c - Linux kernel module for PXA3xx graphics controllers

 *

 *  This driver needs a DirectFB counterpart in user space, communication

 *  is handled via mmap()ed memory areas and an ioctl.

 *

 *  Copyright (c) 2009 Daniel Mack <daniel@caiaq.de>

 *  Copyright (c) 2009 Janine Kropp <nin@directfb.org>

 *  Copyright (c) 2009 Denis Oliver Kropp <dok@directfb.org>

/*

 * WARNING: This controller is attached to System Bus 2 of the PXA which

 * needs its arbiter to be enabled explicitly (CKENB & 1<<9).

 * There is currently no way to do this from Linux, so you need to teach

 * your bootloader for now.

 #define PXA3XX_GCU_DEBUG */

 #define PXA3XX_GCU_DEBUG_TIMER */

 disable interrupts */

 reset hardware */

 set up the ring buffer pointers */

 enable all IRQs except EOB */

 ring base address */

 ring tail address */

 ring length */

			/* There is no more data prepared by the userspace.

			 * Set hw_running = 0 and wait for the next userspace

 set ring buffer length to zero */

 Clear the interrupt */

	/* Does not need to be atomic. There's a lock in user space,

	/* Does not need to be atomic. There's a lock in user space,

 Misc device layer */

/*

 * provide an empty .open callback, so the core sets file->private_data

 * for us.

	/* Does not need to be atomic. There's a lock in user space,

 Last word reserved for batch buffer end command */

 Wait for a free buffer */

	/*

	 * Get buffer from free list

 Copy data from user into buffer */

 Append batch buffer end command */

	/*

	 * Add buffer to ready list

 hand out the shared data area */

		/* hand out the MMIO base for direct register access

 init the timer structure */

	/* we allocate the misc device structure as part of our own allocation,

	 * so we can get a pointer to our priv structure later on with

	 * container_of(). This isn't really necessary as we have a fixed minor

 handle IO resources */

 enable the clock */

 request the IRQ */

 allocate dma memory */

 register misc device */

/*

 *  Driver for AT91 LCD Controller

 *

 *  Copyright (C) 2007 Atmel Corporation

 *

 * This file is subject to the terms and conditions of the GNU General Public

 * License.  See the file COPYING in the main directory of this archive for

 * more details.

 LCD Controller info data structure, stored in device platform_data */

 configurable parameters */

 words */

 words */

 some bl->props field just changed */

	/* REVISIT there may be a meaningful difference between

	 * fb_blank and power ... there seem to be some cases

	 * this doesn't handle correctly.

 contrast pwm can be 'inverted' */

 have some default contrast/backlight settings */

 STN display */

 Turn off the LCD controller and the DMA controller */

 Wait for the LCDC core to become idle */

 Wait for DMA engine to become idle... */

 Set framebuffer DMA base address and pixel offset */

/**

 *	atmel_lcdfb_alloc_video_memory - Allocate framebuffer memory

 *	@sinfo: the frame buffer to allocate memory for

 * 	

 * 	This function is called only from the atmel_lcdfb_probe()

 * 	so no locking by fb_info->mm_lock around smem_len setting is needed.

/**

 *      atmel_lcdfb_check_var - Validates a var passed in.

 *      @var: frame buffer variable screen structure

 *      @info: frame buffer structure that represents a single frame buffer

 *

 *	Checks to see if the hardware supports the state requested by

 *	var passed in. This function does not alter the hardware

 *	state!!!  This means the data stored in struct fb_info and

 *	struct atmel_lcdfb_info do not change. This includes the var

 *	inside of struct fb_info.  Do NOT change these. This function

 *	can be called on its own if we intent to only test a mode and

 *	not actually set it. The stuff in modedb.c is a example of

 *	this. If the var passed in is slightly off by what the

 *	hardware can support then we alter the var PASSED in to what

 *	we can do. If the hardware doesn't support mode change a

 *	-EINVAL will be returned by the upper layers. You don't need

 *	to implement this function then. If you hardware doesn't

 *	support changing the resolution then this function is not

 *	needed. In this case the driver would just provide a var that

 *	represents the static state the screen is in.

 *

 *	Returns negative errno on error, or zero on success.

 choose a suitable mode if possible */

 Do not allow to have real resoulution larger than virtual */

 Force same alignment for each line */

 Saturate vertical and horizontal timings at maximum values */

 Some parameters can't be zero */

 Older SOCs use IBGR:555 rather than BGR:565. */

 RGB:5X5 mode */

 BGR:5X5 mode */

 RGB:888 mode */

 BGR:888 mode */

/*

 * LCD reset sequence

/**

 *      atmel_lcdfb_set_par - Alters the hardware state.

 *      @info: frame buffer structure that represents a single frame buffer

 *

 *	Using the fb_var_screeninfo in fb_info we set the resolution

 *	of the this particular framebuffer. This function alters the

 *	par AND the fb_fix_screeninfo stored in fb_info. It doesn't

 *	not alter var in fb_info since we are using that data. This

 *	means we depend on the data in var inside fb_info to be

 *	supported by the hardware.  atmel_lcdfb_check_var is always called

 *	before atmel_lcdfb_set_par to ensure this.  Again if you can't

 *	change the resolution you don't need this function.

 *

 Re-initialize the DMA engine... */

 ...set frame size and burst length = 8 words (?) */

 Now, the LCDC core... */

 Set pixel clock */

 Initialize control register 2 */

 Vertical timing */

 Horizontal timing */

 Horizontal value (aka line size) */

 Display size */

 FIFO Threshold: Use formula from data sheet */

 Toggle LCD_MODE every frame */

 Disable all interrupts */

 Enable FIFO & DMA errors */

 ...wait for DMA engine to become idle... */

/**

 *  	atmel_lcdfb_setcolreg - Optional function. Sets a color register.

 *      @regno: Which register in the CLUT we are programming

 *      @red: The red value which can be up to 16 bits wide

 *	@green: The green value which can be up to 16 bits wide

 *	@blue:  The blue value which can be up to 16 bits wide.

 *	@transp: If supported the alpha value which can be up to 16 bits wide.

 *      @info: frame buffer info structure

 *

 *  	Set a single color register. The values supplied have a 16 bit

 *  	magnitude which needs to be scaled in this function for the hardware.

 *	Things to take into consideration are how many color registers, if

 *	any, are supported with the current color visual. With truecolor mode

 *	no color palettes are supported. Here a pseudo palette is created

 *	which we store the value in pseudo_palette in struct fb_info. For

 *	pseudocolor mode we have a limited color palette. To deal with this

 *	we can program what color is displayed for a particular pixel value.

 *	DirectColor is similar in that we can program each color field. If

 *	we have a static colormap we don't need to implement this function.

 *

 *	Returns negative errno on error, or zero on success. In an

 *	ideal world, this would have been the case, but as it turns

 *	out, the other drivers return 1 on failure, so that's what

 *	we're going to do.

 old style I+BGR:555 */

				/*

				 * TODO: intensity bit. Maybe something like

				 *   ~(red[10] ^ green[10] ^ blue[10]) & 1

 new style BGR:565 / RGB:565 */

 let fbcon do a soft blank for us */

 reset DMA and FIFO to avoid screen shifting */

/*

 * LCD controller task (to reset the LCD)

 Allocate colormap */

 sentinel */ }

 Enable LCDC Clocks */

 Initialize video memory */

 use a pre-allocated memory buffer */

		/*

		 * Don't clear the framebuffer -- someone may have set

		 * up a splash image.

 allocate memory buffer */

 LCDC registers */

 Initialize PWM for contrast or backlight ("off") */

 interrupt */

	/* Some operations on the LCDC might sleep and

	/*

	 * Tell the world that we're ready to go

 Power up the LCDC screen */

	/*

	 * We don't want to handle interrupts while the clock is

	 * stopped. It may take forever.

 Enable FIFO & DMA errors */

 SPDX-License-Identifier: GPL-2.0-only

/* bw2.c: BWTWO frame buffer driver

 *

 * Copyright (C) 2003, 2006 David S. Miller (davem@davemloft.net)

 * Copyright (C) 1996,1998 Jakub Jelinek (jj@ultra.linux.cz)

 * Copyright (C) 1996 Miguel de Icaza (miguel@nuclecu.unam.mx)

 * Copyright (C) 1997 Eddie C. Dost (ecd@skynet.be)

 *

 * Driver layout based loosely on tgafb.c, see that file for credits.

/*

 * Local functions.

/*

 *  Frame buffer operations

 OBio addresses for the bwtwo registers */

 Status Register Constants */

 Control Register Constants */

 Status Register Constants */

/**

 *      bw2_blank - Optional function.  Blanks the display.

 *      @blank: the blank mode we want.

 *      @info: frame buffer structure that represents a single frame buffer

 Unblanking */

 Normal blanking */

 VESA blank (vsync off) */

 VESA blank (hsync off) */

 Poweroff */

/*

 *  Initialisation

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Cirrus Logic CLPS711X FB driver

 *

 * Copyright (C) 2014 Alexander Shiyan <shc_work@mail.ru>

 * Based on driver by Russell King <rmk@arm.linux.org.uk>

 Registers relative to LCDCON */

 gray = 0.30*R + 0.58*G + 0.11*B */

 LCDCON must only be changed while the LCD is disabled */

 Return happy */

 Physical address should be aligned to 256 MiB */

 Force disable LCD on any mismatch */

 Setup start FB address */

 Clean FB memory */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.

 *

 *  Freescale DIU Frame Buffer device driver

 *

 *  Authors: Hongjun Chen <hong-jun.chen@freescale.com>

 *           Paul Widmer <paul.widmer@freescale.com>

 *           Srikanth Srinivasan <srikanth.srinivasan@freescale.com>

 *           York Sun <yorksun@freescale.com>

 *

 *   Based on imxfb.c Copyright (C) 2004 S.Hauer, Pengutronix

 1 for plane 0, 2 for planes 1 & 2 each */

 HW cursor parameters */

 INT_STATUS/INT_MASK field descriptions */

 Vsync interrupt  */

 Vsync interrupt for write back operation */

 Under run exception interrupt */

 Display parameters error interrupt */

 Lines before vsync. interrupt */

/*

 * List of supported video modes

 *

 * The first entry is the default video mode.  The remain entries are in

 * order if increasing resolution and frequency.  The 320x240-60 mode is

 * the initial AOI for the second and third planes.

 Plane 0, only one AOI that fills the screen */

 Plane 1, first AOI */

 Plane 1, second AOI */

 Plane 2, first AOI */

 Plane 2, second AOI */

 aoi display x offset to physical screen */

 aoi display y offset to physical screen */

/**

 * struct fsl_diu_data - per-DIU data structure

 * @dma_addr: DMA address of this structure

 * @fsl_diu_info: fb_info objects, one per AOI

 * @dev_attr: sysfs structure

 * @irq: IRQ

 * @monitor_port: the monitor port this DIU is connected to

 * @diu_reg: pointer to the DIU hardware registers

 * @reg_lock: spinlock for register access

 * @dummy_aoi: video buffer for the 4x4 32-bit dummy AOI

 * dummy_ad: DIU Area Descriptor for the dummy AOI

 * @ad[]: Area Descriptors for each real AOI

 * @gamma: gamma color table

 * @cursor: hardware cursor data

 * @blank_cursor: blank cursor for hiding cursor

 * @next_cursor: scratch space to build load cursor

 * @edid_data: EDID information buffer

 * @has_edid: whether or not the EDID buffer is valid

 *

 * This data structure must be allocated with 32-byte alignment, so that the

 * internal fields can be aligned properly.

 It's easier to parse the cursor data as little-endian */

 Blank cursor data -- used to hide the cursor */

 Scratch cursor data -- used to build new cursor */

 Determine the DMA address of a member of the fsl_diu_data structure */

/**

 * fsl_diu_name_to_port - convert a port name to a monitor port enum

 *

 * Takes the name of a monitor port ("dvi", "lvds", or "dlvds") and returns

 * the enum fsl_diu_monitor_port that corresponds to that string.

 *

 * For compatibility with older versions, a number ("0", "1", or "2") is also

 * supported.

 *

 * If the string is unknown, DVI is assumed.

 *

 * If the particular port is not supported by the platform, another port

 * (platform-specific) is chosen instead.

/*

 * Workaround for failed writing desc register of planes.

 * Needed with MPC5121 DIU rev 2.0 silicon.

 AOI0 closed */

 AOI1 open */

 AOI0 closed */

 AOI1 open */

 AOI0 open */

 AOI0 was open */

 AOI1 is open */

 move AOI1 to the first */

 AOI1 was closed */

 close AOI 0 */

 AOI1 is open */

 move AOI1 to the first */

 AOI1 was closed */

 close AOI 0 */

 AOI1 is not the first in the chain */

 AOI0 is open, must be the first */

 AOI1 is the first in the chain */

 close AOI 1 */

 AOI1 is not the first in the chain */

 AOI0 is open, must be the first */

 AOI1 is the first in the chain */

 close AOI 1 */

/*

 * Checks to see if the hardware supports the state requested by var passed

 * in. This function does not alter the hardware state! If the var passed in

 * is slightly off by what the hardware can support then we alter the var

 * PASSED in to what we can do. If the hardware doesn't support mode change

 * a -EINVAL will be returned by the upper layers.

 Copy nonstd field to/from sync for fbset usage */

 Prep for DIU init  - gamma table, cursor table */

 Program DIU registers */

 Set background to grey */

 Horizontal and vertical configuration register */

 BP_H */

 PW_H */

 FP_H */

 BP_V */

 PW_V  */

 FP_V  */

	/*

	 * The PLUT register is defined differently on the MPC5121 than it

	 * is on other SOCs.  Unfortunately, there's no documentation that

	 * explains how it's supposed to be programmed, so for now, we leave

	 * it at the default value on the MPC5121.

	 *

	 * For other SOCs, program it for the highest priority, which will

	 * reduce the chance of underrun. Technically, we should scale the

	 * priority to match the screen resolution, but doing that properly

	 * requires delicate fine-tuning for each use-case.

 Enable the DIU */

/*

 * Using the fb_var_screeninfo in fb_info we set the aoi of this

 * particular framebuffer. It is a light version of fsl_diu_set_par.

 AOI should not be greater than display size */

/**

 * fsl_diu_get_pixel_format: return the pixel format for a given color depth

 *

 * The pixel format is a 32-bit value that determine which bits in each

 * pixel are to be used for each color.  This is the default function used

 * if the platform does not define its own version.

 0x88883316 */

 0x88082219 */

 0x65053118 */

/*

 * Copies a cursor image from user space to the proper place in driver

 * memory so that the hardware can display the cursor image.

 *

 * Cursor data is represented as a sequence of 'width' bits packed into bytes.

 * That is, the first 8 bits are in the first byte, the second 8 bits in the

 * second byte, and so on.  Therefore, the each row of the cursor is (width +

 * 7) / 8 bytes of 'data'

 *

 * The DIU only supports cursors up to 32x32 (MAX_CURS).  We reject cursors

 * larger than this, so we already know that 'width' <= 32.  Therefore, we can

 * simplify our code by using a 32-bit big-endian integer ("line") to read in

 * a single line of pixels, and only look at the top 'width' bits of that

 * integer.

 *

 * This could result in an unaligned 32-bit read.  For example, if the cursor

 * is 24x24, then the first three bytes of 'image' contain the pixel data for

 * the top line of the cursor.  We do a 32-bit read of 'image', but we look

 * only at the top 24 bits.  Then we increment 'image' by 3 bytes.  The next

 * read is unaligned.  The only problem is that we might read past the end of

 * 'image' by 1-3 bytes, but that should not cause any problems.

/*

 * Set a hardware cursor.  The image data for the cursor is passed via the

 * fb_cursor object.

 The cursor size has changed */

		/*

		 * The DIU cursor is a fixed size, so when we get this

		 * message, instead of resizing the cursor, we just clear

		 * all the image data, in expectation of new data.  However,

		 * in tests this control does not appear to be normally

		 * called.

 The cursor position has changed (cursor->image.dx|dy) */

	/*

	 * FB_CUR_SETIMAGE - the cursor image has changed

	 * FB_CUR_SETCMAP  - the cursor colors has changed

	 * FB_CUR_SETSHAPE - the cursor bitmask has changed

		/*

		 * Determine the size of the cursor image data.  Normally,

		 * it's 8x16.

 Use 32-bit operations on the data to improve performance */

	/*

	 * Show or hide the cursor.  The cursor data is always stored in the

	 * 'cursor' memory block, and the actual cursor position is always in

	 * the DIU's CURS_POS register.  To hide the cursor, we redirect the

	 * CURSOR register to a blank cursor.  The show the cursor, we

	 * redirect the CURSOR register to the real cursor data.

/*

 * Using the fb_var_screeninfo in fb_info we set the resolution of this

 * particular framebuffer. This function alters the fb_fix_screeninfo stored

 * in fb_info. It does not alter var in fb_info since we are using that

 * data. This means we depend on the data in var inside fb_info to be

 * supported by the hardware. fsl_diu_check_var is always called before

 * fsl_diu_set_par to ensure this.

 Alloc & dealloc each time resolution/bpp change */

 Memory allocation for framebuffer */

 AOI should not be greater than display size */

 Disable chroma keying function */

/*

 * Set a single color register. The values supplied have a 16 bit magnitude

 * which needs to be scaled in this function for the hardware. Things to take

 * into consideration are how many color registers, if any, are supported with

 * the current color visual. With truecolor mode no color palettes are

 * supported. Here a pseudo palette is created which we store the value in

 * pseudo_palette in struct fb_info. For pseudocolor mode we have a limited

 * color palette.

	/*

	 * If greyscale is true, then we convert the RGB value

	 * to greyscale no matter what visual we are using.

		/*

		 * 16-bit True Colour.  We encode the RGB value

		 * according to the RGB bitfield information.

/*

 * Pan (or wrap, depending on the `vmode' field) the display using the

 * 'xoffset' and 'yoffset' fields of the 'var' structure. If the values

 * don't fit, return -EINVAL.

 No change, do nothing */

 set panel information */

 set panel winformation */

 Force table reload */

 enable underrun detection */

 enable vertical sync */

/* turn on fb if count == 1

 free boot splash memory on first /dev/fb0 open */

/* turn off fb if count == 0

 Disable interrupts only if all AOIs are closed */

 Now build modedb from EDID */

		/*

		 * For plane 0 we continue and look into

		 * driver's internal modedb.

 Still not found, use preferred mode from database if any */

		/*

		 * Get preferred timing. If not found,

		 * first mode in database will be used.

 This is the workaround for underrun */

/*

 * Power management hooks. Note that we won't be called from IRQ context,

 * unlike the blank functions above, so we may sleep.

 CONFIG_PM */

		/* All AOIs need adjust pixel format

		 * fsl_diu_set_par only change the pixsel format here

 DMA addr of fsl_diu_data struct */

	/*

	 * dma_alloc_coherent() uses a page allocator, so the address is

	 * always page-aligned.  We need the memory to be 32-byte aligned,

	 * so that's good.  However, if one day the allocator changes, we

	 * need to catch that.  It's not worth the effort to handle unaligned

	 * alloctions now because it's highly unlikely to ever be a problem.

		/*

		 * We store the physical address of the AD in the reserved

		 * 'paddr' field of the AD itself.

 Initialize the AOI data structure */

 Get the EDID data from the device tree, if present */

 Get the IRQ of the DIU */

 Initialize the dummy Area Descriptor */

	/*

	 * Let DIU continue to display splash screen if it was pre-initialized

	 * by the bootloader; otherwise, clear the display.

	/*

	 * Older versions of U-Boot leave interrupts enabled, so disable

	 * all of them and clear the status register.

	/*

	 * For kernel boot options (in 'video=xxxfb:<options>' format)

	/*

	 * Must to verify set_pixel_clock. If not implement on platform,

	 * then that means that there is no platform support for the DIU.

	/*

	 * Freescale PLRU requires 13/8 times the cache size to do a proper

	 * displacement flush

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Frame buffer driver for Trident TGUI, Blade and Image series

 *

 * Copyright 2001, 2002 - Jani Monoses   <jani@iv.ro>

 * Copyright 2009 Krzysztof Helt <krzysztof.h1@wp.pl>

 *

 * CREDITS:(in order of appearance)

 *	skeletonfb.c by Geert Uytterhoeven and other fb code in drivers/video

 *	Special thanks ;) to Mattia Crivellini <tia@mclink.it>

 *	much inspired by the XFree86 4.x Trident driver sources

 *	by Alan Hourihane the FreeVGA project

 *	Francesco Salvestrini <salvestrini@users.sf.net> XP support,

 *	code, suggestions

 * TODO:

 *	timing value tweaking so it looks good on every monitor in every mode

 iospace virtual memory address */

 engine operation... */

 defaults which are normally overriden by user values */

 video mode */

 VIA MPV4 integrated version */

 case CYBERBLDAEXPm8:  Strange */

 case CYBERBLDAEXPm16: Strange */

 disable drive - don't drive hi */

 drive low */

 disable drive - don't drive hi */

 drive low */

 not sure if this check is OK */

 no getscl */

/*

 * Blade specific acceleration.

/*

 * BladeXP specific acceleration functions

 Timeout */

 Reset engine */

/*

 * Image specific acceleration functions

/*

 * TGUI 9440/96XX acceleration

 disable clipping */

/*

 * Accel functions called by the upper layers

/*

 * Hardware access functions

 flip-flop to index */

 Goto New Mode */

 Unprotect registers */

 Enable MMIO */

 Goto New Mode */

 Unprotect registers */

 Disable MMIO */

  Return flat panel's maximum x resolution */

 Set pitch */

 chips older than TGUI9660 have only 1 width bit in AddColReg */

 touching the other one breaks I2C/DDC */

 For resolutions smaller than FP resolution stretch */

 For resolutions smaller than FP resolution center */

 Address of first shown pixel in display memory */

 Set dotclock frequency */

 Set number of lines for flat panels*/

/*

 * If we see that FP is active we assume we have one.

 * Otherwise we have a CRT display. User can override.

 Try detecting the video memory size */

 If memory size provided by user */

 XP */

 XP */

 XP */

 XP */

 XP */

 XP */

 See if we can handle the video mode described in var */

 230MHz for most 3D chips */

 check color depth */

 check whether resolution fits on panel and in memory */

 various resolution checks */

 prevent from position overflow for acceleration */

 acceleration requires line length to be power of 2 */

 datasheet specifies how to set panning only up to 4 MB */

 The clock is doubled for 32 bpp */

 Pan the display */

 Set the hardware to the requested video mode */

		/*

		 * on flat panels with native size larger

		 * than requested resolution decide whether

		 * we stretch or center

 vertical timing values */

 horizontal timing values */

 higher bits of vertical timing values */

 line compare bit 10 */

FIXME	if (info->var.vmode & FB_VMODE_DOUBLE) tmp |= 0x80;  /* double scan for 200 line modes */

 enable linear addressing */

 enable access extended memory */

 enable GE for text acceleration */

 both IO, linear enable */

 MMIO & PCI read and write burst enable */

 set char clock 8 dots wide */

 enable 4 maps because needed in chain4 mode */

 memory mode enable bitmaps ?? */

 convert from picoseconds to kHz */

 divide clock by 2 if 32bpp chain4 mode display and CPU path */

 no CGA compat, allow 256 col */

 graphics mode */

 planes? */

 graphics mode and support 256 color modes */

 planes */

 horizontal pel panning */

 colors */

 flip-flop to index */

 enable attr */

 Set one color register */

 RGB 565 */

 ARGB 8888 */

 Try blanking the screen. For flat panels it does nothing */

 Read DPMS Control */

 Screen: On, HSync: On, VSync: On */

 Screen: Off, HSync: On, VSync: On */

 Screen: Off, HSync: Off, VSync: On */

 Screen: Off, HSync: On, VSync: Off */

 Screen: Off, HSync: Off, VSync: Off */

 let fbcon do a softblank for us */

 If PCI id is 0x9660 then further detect chip type */

 3DImage family left */

 TGUI 9440/96XX family */

 setup MMIO region */

 setup framebuffer memory */

 fill all other info->var's fields */

 Prepare startup mode */

 List of boards that we are trying to support */

/*

 * Parse user specified options (`video=trident:')

 * example:

 *	video=trident:800x600,bpp=16,noaccel

/*

 *  platinumfb.c -- frame buffer device for the PowerMac 'platinum' display

 *

 *  Copyright (C) 1998 Franz Sirl

 *

 *  Frame buffer structure from:

 *    drivers/video/controlfb.c -- frame buffer device for

 *    Apple 'control' display chip.

 *    Copyright (C) 1998 Dan Jacobowitz

 *

 *  Hardware information from:

 *    platinum.c: Console support for PowerMac "platinum" display adaptor.

 *    Copyright (C) 1996 Paul Mackerras and Mark Abene

 *

 *  This file is subject to the terms and conditions of the GNU General Public

 *  License. See the file COPYING in the main directory of this archive for

 *  more details.

/*

 * Frame buffer device API

/*

 * internal functions

/*

 * Interface used by the world

/*

 * Checks a var structure

/*

 * Applies current var to display

/*

 *  Blank the screen if blank_mode != 0, else unblank. If blank == NULL

 *  then the caller blanks by setting the CLUT (Color Look Up Table) to all

 *  black. Return 0 if blanking succeeded, != 0 if un-/blanking failed due

 *  to e.g. a video mode which doesn't support it. Implements VESA suspend

 *  and powerdown modes on hardware that supports disabling hsync/vsync:

 *    blank_mode == 2: suspend vsync

 *    blank_mode == 3: suspend hsync

 *    blank_mode == 4: powerdown

 [danj] I think there's something fishy about those constants... */

/*

	struct fb_info_platinum *info = (struct fb_info_platinum *) fb;

	int	ctrl;



	ctrl = le32_to_cpup(&info->platinum_regs->ctrl.r) | 0x33;

	if (blank)

		--blank_mode;

	if (blank & VESA_VSYNC_SUSPEND)

		ctrl &= ~3;

	if (blank & VESA_HSYNC_SUSPEND)

		ctrl &= ~0x30;

	out_le32(&info->platinum_regs->ctrl.r, ctrl);

 TODO: Figure out how the heck to powerdown this thing! */

 tell clut what addr to fill	*/

 send one color channel at	*/

 a time...			*/

 Now how about actually saying, Make it so! */

 Some things in here probably don't need to be done each time. */

 Initialize display timing registers */

 turn display off */

 out_be32(&platinum_regs->reg[27].r, 0x2aa); */

 turn display on */

/*

 * Set misc info vars for this driver

 Fill fb_info */

 Fill fix common fields */

 will be updated later */

	/*

	 * Reduce the pixel size if we don't have enough VRAM.

 Setup default var */

 This shouldn't happen! */

 Initialize info structure */

 Apply default var */

 Register with fbdev layer */

/*

 * Get the monitor sense value.

 * Note that this can be called before calibrate_delay,

 * so we can't use udelay.

 turn off drivers */

 drive each sense line low in turn and collect the other 2 */

 drive A low */

 drive B low */

 drive C low */

 turn off drivers */

/*

 * This routine takes a user-supplied var, and picks the best vmode/cmode from it.

 * It also updates the var structure to the actual mode data obtained

/* 

 * Parse user specified options (`video=platinumfb:')

	/* Do not try to request register space, they overlap with the

	 * northbridge and that can fail. Only request framebuffer

 frame buffer - map only 4MB */

 registers */

 XXX not in prom? */

 Grok total video ram */

 select max vram */

 switch in vram */

 builtin 1MB vram, always there */

	/*

	 * Try to determine whether we have an old or a new DACula.

 Unmap frame buffer and registers */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Cobalt/SEAD3 LCD frame buffer driver.

 *

 *  Copyright (C) 2008  Yoichi Yuasa <yuasa@linux-mips.org>

 *  Copyright (C) 2012  MIPS Technologies, Inc.

/*

 * Cursor position address

 * \X  0    1    2  ...  14   15

 * Y+----+----+----+---+----+----+

 * 0|0x00|0x01|0x02|...|0x0e|0x0f|

 *  +----+----+----+---+----+----+

 * 1|0x40|0x41|0x42|...|0x4e|0x4f|

 *  +----+----+----+---+----+----+

 execute 4 times continuously */

/*

 *  linux/drivers/video/iplan2p2.c -- Low level frame buffer operations for

 *				      interleaved bitplanes à la Atari (2

 *				      planes, 2 bytes interleave)

 *

 *	Created 5 Apr 1997 by Geert Uytterhoeven

 *

 *  This file is subject to the terms and conditions of the GNU General Public

 *  License.  See the file COPYING in the main directory of this archive for

 *  more details.

	/*  bmove() has to distinguish two major cases: If both, source and

	 *  destination, start at even addresses or both are at odd

	 *  addresses, just the first odd and last even column (if present)

	 *  require special treatment (memmove_col()). The rest between

	 *  then can be copied by normal operations, because all adjacent

	 *  bytes are affected and are to be stored in the same order.

	 *    The pathological case is when the move should go from an odd

	 *  address to an even or vice versa. Since the bytes in the plane

	 *  words must be assembled in new order, it seems wisest to make

	 *  all movements by memmove_col().

 odd->odd or even->even */

 odd->even or even->odd */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2008

 * Guennadi Liakhovetski, DENX Software Engineering, <lg@denx.de>

 *

 * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.

 SDC Registers */

 Register bits */

 Display Interface registers */

 DI_DISP_SIG_POL bits */

 DI_DISP_IF_CONF bits */

 true = inverted */

 true = rising edge */

 true = active high */

 240x320 @ 60 Hz */

 240x33 @ 60 Hz */

 640x480 @ 60 Hz */

 NTSC TV output */

 PAL TV output */

 TV output VGA mode, 640x480 @ 65 Hz */

 MX3 specific framebuffer information. */

 Protects fb-ops */

 current var info */

 Used fb-mode and bpp. Can be set on kernel command line, therefore file-static. */

 Returns enabled flag before uninit */

 This enables the channel */

 Just re-activate the same buffer */

	/*

	 * Attention! Without this msleep the channel keeps generating

	 * interrupts. Next sdc_set_brightness() is going to be called

	 * from mx3fb_blank().

/**

 * sdc_set_window_pos() - set window position of the respective plane.

 * @mx3fb:	mx3fb context.

 * @channel:	IPU DMAC channel ID.

 * @x_pos:	X coordinate relative to the top left corner to place window at.

 * @y_pos:	Y coordinate relative to the top left corner to place window at.

 * @return:	0 on success or negative error code on failure.

/**

 * sdc_init_panel() - initialize a synchronous LCD panel.

 * @mx3fb:		mx3fb context.

 * @panel:		panel type.

 * @pixel_clk:		desired pixel clock frequency in Hz.

 * @width:		width of panel in pixels.

 * @height:		height of panel in pixels.

 * @h_start_width:	number of pixel clocks between the HSYNC signal pulse

 *			and the start of valid data.

 * @h_sync_width:	width of the HSYNC signal in units of pixel clocks.

 * @h_end_width:	number of pixel clocks between the end of valid data

 *			and the HSYNC signal for next line.

 * @v_start_width:	number of lines between the VSYNC signal pulse and the

 *			start of valid data.

 * @v_sync_width:	width of the VSYNC signal in units of lines

 * @v_end_width:	number of lines between the end of valid data and the

 *			VSYNC signal for next frame.

 * @sig:		bitfield of signal polarities for LCD interface.

 * @return:		0 on success or negative error code on failure.

 Init panel size and blanking periods */

 Init clocking */

	/*

	 * Calculate divider: fractional part is 4 bits so simply multiple by

	 * 2^4 to get fractional part, as long as we stay under ~250MHz and on

	 * i.MX31 it (HSP_CLK) is <= 178MHz. Currently 128.267MHz

 Divider less than 4 */

	/*

	 * DISP3_IF_CLK_DOWN_WR is half the divider value and 2 fraction bits

	 * fewer. Subtract 1 extra from DISP3_IF_CLK_DOWN_WR based on timing

	 * debug. DISP3_IF_CLK_UP_WR is 0

 DI settings */

/**

 * sdc_set_color_key() - set the transparent color key for SDC graphic plane.

 * @mx3fb:	mx3fb context.

 * @channel:	IPU DMAC channel ID.

 * @enable:	boolean to enable or disable color keyl.

 * @color_key:	24-bit RGB color to use as transparent color key.

 * @return:	0 on success or negative error code on failure.

/**

 * sdc_set_global_alpha() - set global alpha blending modes.

 * @mx3fb:	mx3fb context.

 * @enable:	boolean to enable or disable global alpha blending. If disabled,

 *		per pixel blending is used.

 * @alpha:	global alpha value.

 * @return:	0 on success or negative error code on failure.

 This might be board-specific */

/**

 * mx3fb_set_fix() - set fixed framebuffer parameters from variable settings.

 * @fbi:	framebuffer information pointer

 * @return:	0 on success or negative error code on failure.

 We only need one interrupt, it will be re-enabled as needed */

	/*

	 * Ignore xoffset and yoffset update,

	 * because pan display handles this case.

 Total cleanup */

		/*

		 * sg[0] points to fb smem_start address

		 * and is actually active in controller.

	/*

	 * Preserve xoffset and yoffest in case they are

	 * inactive in controller as fb is blanked.

/**

 * mx3fb_set_par() - set framebuffer parameters and change the operating mode.

 * @fbi:	framebuffer information pointer.

 * @return:	0 on success or negative error code on failure.

/**

 * mx3fb_check_var() - check and adjust framebuffer variable parameters.

 * @var:	framebuffer variable parameters

 * @fbi:	framebuffer information pointer

 Preserve sync flags */

	/*

	 * If greyscale is true, then we convert the RGB value

	 * to greyscale no matter what visual we are using.

		/*

		 * 16-bit True Colour.  We encode the RGB value

		 * according to the RGB bitfield information.

	/* Attention!

	 * Do not call sdc_disable_channel() for a channel that is disabled

	 * already! This will result in a kernel NULL pointer dereference

	 * (mx3_fbi->txd is NULL). Hide the fact, that all blank modes are

	 * handled equally by this driver.

 Give LCD time to update - enough for 50 and 60 Hz */

/**

 * mx3fb_blank() - blank the display.

 * @blank:	blank value for the panel

 * @fbi:	framebuffer information pointer

/**

 * mx3fb_pan_display() - pan or wrap the display

 * @var:	variable screen buffer information.

 * @fbi:	framebuffer information pointer.

 *

 * We look only at xoffset, yoffset and the FB_VMODE_YWRAP flag

 No change, do nothing */

	/*

	 * We enable the End of Frame interrupt, which will free a tx-descriptor,

	 * which we will need for the next dmaengine_prep_slave_sg(). The

	 * IRQ-handler will disable the IRQ again.

	/*

	 * Emulate original mx3fb behaviour: each new call to idmac_tx_submit()

	 * should switch to another buffer

/*

 * This structure contains the pointers to the control functions that are

 * invoked by the core framebuffer driver to perform operations like

 * blitting, rectangle filling, copy regions and cursor definition.

/*

 * Power management hooks.      Note that we won't be called from IRQ context,

 * unlike the blank functions above, so we may sleep.

/*

 * Suspends the framebuffer and blanks the screen. Power management support

/*

 * Resumes the framebuffer and unblanks the screen. Power management support

/*

 * Main framebuffer functions

/**

 * mx3fb_map_video_memory() - allocates the DRAM memory for the frame buffer.

 * @fbi:	framebuffer information pointer

 * @mem_len:	length of mapped memory

 * @lock:	do not lock during initialisation

 * @return:	Error code indicating success or failure

 *

 * This buffer is remapped into a non-cached, non-buffered, memory region to

 * allow palette and pixel writes to occur without flushing the cache. Once this

 * area is remapped, all virtual memory access to the video memory should occur

 * at the new region.

 Clear the screen */

/**

 * mx3fb_unmap_video_memory() - de-allocate frame buffer memory.

 * @fbi:	framebuffer information pointer

 * @return:	error code indicating success or failure

/**

 * mx3fb_init_fbinfo() - initialize framebuffer information object.

 * @dev: the device

 * @ops:	framebuffer device operations

 * @return:	initialized framebuffer structure.

 Allocate sufficient memory for the fb structure */

 Allocate colormap */

 Default Y virtual size is 2x panel size */

 set Display Interface clock period */

 Might need to trigger HSP clock change - see 44.3.3.8.5 */

	/*

	 * Display Interface (DI) and Synchronous Display Controller (SDC)

	 * registers

 IDMAC interface */

/*

 * Parse user specified options (`video=mx3fb:')

 * example:

 * 	video=mx3fb:bpp=16

/*

 * OpenCores VGA/LCD 2.0 core frame buffer driver

 *

 * Copyright (C) 2013 Stefan Kristiansson, stefan.kristiansson@saunalahti.fi

 *

 * This file is licensed under the terms of the GNU General Public License

 * version 2.  This program is licensed "as is" without any warranty of any

 * kind, whether express or implied.

 OCFB register defines */

 Video Enable */

 HSync Interrupt Enable */

 8-bit Pseudo Color Enable*/

 Color Depth 8 */

 Color Depth 16 */

 Color Depth 24 */

 Color Depth 32 */

 Burst Length 1 */

 Burst Length 2 */

 Burst Length 4 */

 Burst Length 8 */

 640x480 @ 60 Hz, 31.5 kHz hsync */

 flag indicating whether the regs are little endian accessed */

 Physical and virtual addresses of framebuffer */

 Disable display */

 Register framebuffer address */

 Detect endianess */

 Horizontal timings */

 Vertical timings */

 Total length of frame */

 enable palette */

 maximum (8) VBL (video memory burst length) */

 Enable output */

 grayscale = 0.30*R + 0.59*G + 0.11*B */

 Video mode setup */

 Allocate framebuffer memory */

 Clear framebuffer */

 Setup and enable the framebuffer */

 Allocate color map */

 Register framebuffer */

 Disable display */

/*

 * Init and exit routines

/*

 *  SGI GBE frame buffer driver

 *

 *  Copyright (C) 1999 Silicon Graphics, Inc. - Jeffrey Newquist

 *  Copyright (C) 2002 Vivien Chappelier <vivien.chappelier@linux-mips.org>

 *

 *  This file is subject to the terms and conditions of the GNU General Public

 *  License. See the file COPYING in the main directory of this archive for

 *  more details.

 SGI O2 */

 macro for fastest write-though access to the framebuffer */

/*

 *  RAM we reserve for the frame buffer. This defines the maximum screen

 *  size

 0 turned off, 1 turned on */

 default CRT mode */

 640x480, 60 Hz, Non-Interlaced (25.175 MHz dotclock) */

 picoseconds */

 default LCD mode */

 1600x1024, 8 bpp */

 default modedb mode */

 640x480, 60 Hz, Non-Interlaced (25.172 MHz dotclock) */

 1600x1024 SGI flatpanel 1600sw */

 1600x1024, 8 bpp */

 Turn on dotclock PLL */

/*

 * Function:	gbe_turn_off

 * Parameters:	(None)

 * Description:	This should turn off the monitor and gbe.  This is used

 *              when switching between the serial console and the graphics

 *              console.

 check if pixel counter is on */

 turn off DMA */

	/* We have to wait through two vertical retrace periods before

 wait for vpixen_off */

 turn off pixel counter */

 turn off dot clock */

 reset the frame DMA FIFO */

	/*

	 * Check if pixel counter is off, for unknown reason this

	 * code hangs Visual Workstations

 turn on dot clock */

 turn on pixel counter */

 turn on DMA */

/*

 *  Blank the display.

 0 unblank, 1 blank, 2 no vsync, 3 no hsync, 4 off */

 unblank */

 blank */

 Nothing */

/*

 *  Setup flatpanel related registers.

 Turn on the flat panel */

	/* Determine valid resolution and timing

	 * GBE crystal runs at 20Mhz or 27Mhz

	 * pll_m, pll_n, pll_p define the following frequencies

	 * fvco = pll_m * 20Mhz / pll_n

 Resolution to high */

 set video timing information */

 setup dot clock PLL */

 do not start yet */

 setup pixel counter */

 setup video timing signals */

 setup internal timing signals */

 allow blank to wrap around */

 turn off sync on green */

/*

 *  Set the hardware according to 'par'.

 Monitor resolution */

 Bytes per pixel */

 turn off GBE */

 set timing info */

 initialize DIDs */

 Initialize interrupts */

	/* HACK:

	   The GBE hardware uses a tiled memory to screen mapping. Tiles are

	   blocks of 512x128, 256x128 or 128x128 pixels, respectively for 8bit,

	   16bit and 32 bit modes (64 kB). They cover the screen with partial

	   tiles on the right and/or bottom of the screen if needed.

	   For example in 640x480 8 bit mode the mapping is:



	   <-------- 640 ----->

	   <---- 512 ----><128|384 offscreen>

	   ^  ^

	   | 128    [tile 0]        [tile 1]

	   |  v

	   ^

	   4 128    [tile 2]        [tile 3]

	   8  v

	   0  ^

	   128    [tile 4]        [tile 5]

	   |  v

	   |  ^

	   v  96    [tile 6]        [tile 7]

	   32 offscreen



	   Tiles have the advantage that they can be allocated individually in

	   memory. However, this mapping is not linear at all, which is not

	   really convenient. In order to support linear addressing, the GBE

	   DMA hardware is fooled into thinking the screen is only one tile

	   large and but has a greater height, so that the DMA transfer covers

	   the same region.

	   Tiles are still allocated as independent chunks of 64KB of

	   continuous physical memory and remapped so that the kernel sees the

	   framebuffer as a continuous virtual memory. The GBE tile table is

	   set up so that each tile references one of these 64k blocks:



	   GBE -> tile list    framebuffer           TLB   <------------ CPU

	          [ tile 0 ] -> [ 64KB ]  <- [ 16x 4KB page entries ]     ^

	             ...           ...              ...       linear virtual FB

	          [ tile n ] -> [ 64KB ]  <- [ 16x 4KB page entries ]     v





	   The GBE hardware is then told that the buffer is 512*tweaked_height,

	   with tweaked_height = real_width*real_height/pixels_per_tile.

	   Thus the GBE hardware will scan the first tile, filing the first 64k

	   covered region of the screen, and then will proceed to the next

	   tile, until the whole screen is covered.



	   Here is what would happen at 640x480 8bit:



	   normal tiling               linear

	   ^   11111111111111112222    11111111111111111111  ^

	   128 11111111111111112222    11111111111111111111 102 lines

	       11111111111111112222    11111111111111111111  v

	   V   11111111111111112222    11111111222222222222

	       33333333333333334444    22222222222222222222

	       33333333333333334444    22222222222222222222

	       <      512     >        <  256 >               102*640+256 = 64k



	   NOTE: The only mode for which this is not working is 800x600 8bit,

	   as 800*600/512 = 937.5 which is not integer and thus causes

	   flickering.

	   I guess this is not so important as one can use 640x480 8bit or

	   800x600 16bit anyway.

 Tell gbe about the tiles table location */

 tile_ptr -> [ tile 1 ] -> FB mem */

             [ tile 2 ] -> FB mem */

               ...                */

 do not start */

 Initialize the framebuffer */

 compute tweaked height */

 turn off DID and overlay DMA */

 Turn off mouse cursor */

 Turn on GBE */

 Initialize the gamma map */

 Initialize the color map */

/*

 *  Set a single color register. The values supplied are already

 *  rounded down to the hardware's capabilities (according to the

 *  entries in the var structure). Return != 0 for invalid regno.

 wait for the color map FIFO to have a free entry */

/*

 *  Check video mode validity, eventually modify var to best match.

 Limit bpp to 8, 16, and 32 */

 Check the mode can be mapped linearly with the tile table trick. */

 This requires width x height x bytes/pixel be a multiple of 512 */

 No grayscale for now */

 Adjust virtual resolution, if necessary */

 No grayscale for now */

 Memory limit */

 Virtual resolution too high */

 RGB 1555 */

 RGB 8888 */

 check range */

 remap using the fastest write-through mode on architecture */

 try not polluting the cache when possible */

 VM_IO | VM_DONTEXPAND | VM_DONTDUMP are set by remap_pfn_range() */

 look for the starting tile */

 remap each tile separately */

/*

 * sysfs

/*

 * Initialization

 memory was allocated at boot time */

		/* try to allocate memory with the classical allocator

 map framebuffer memory into tiles table */

 reset GBE */

 turn on default video mode */

/*

 *  linux/drivers/video/iplan2p8.c -- Low level frame buffer operations for

 *				      interleaved bitplanes à la Atari (8

 *				      planes, 2 bytes interleave)

 *

 *	Created 5 Apr 1997 by Geert Uytterhoeven

 *

 *  This file is subject to the terms and conditions of the GNU General Public

 *  License.  See the file COPYING in the main directory of this archive for

 *  more details.

 Copies a 8 plane column from 's', height 'h', to 'd'. */

/* This expands a 8 bit color into two longs for two movepl (8 plane)

 * operations.

	/*  bmove() has to distinguish two major cases: If both, source and

	 *  destination, start at even addresses or both are at odd

	 *  addresses, just the first odd and last even column (if present)

	 *  require special treatment (memmove_col()). The rest between

	 *  then can be copied by normal operations, because all adjacent

	 *  bytes are affected and are to be stored in the same order.

	 *    The pathological case is when the move should go from an odd

	 *  address to an even or vice versa. Since the bytes in the plane

	 *  words must be assembled in new order, it seems wisest to make

	 *  all movements by memmove_col().

 odd->odd or even->even */

 odd->even or even->odd */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Frame buffer device for IBM GXT4500P/6500P and GXT4000P/6000P

 * display adaptors

 *

 * Copyright (C) 2006 Paul Mackerras, IBM Corp. <paulus@samba.org>

 GXT4500P registers */

 Registers in PCI config space */

 Misc control/status registers */

 Framebuffer control registers */

 "Direct" framebuffer access registers */

 maps DFA_PIX_* to pixel size in bytes */

 Display timing generator registers */

 PLL/RAMDAC registers */

 Hardware cursor */

 Window attribute table */

 0 vs. 3 is a guess */

 ORd in to other values */

 4-bit value gets << 6 */

 select B buffer if 1 */

 disables gamma cmap */

 controls overlay */

 Indexed by DFA_PIX_* values */

 Colormap array; 1k entries of 4 bytes each */

 pixel format, see DFA_PIX_* values */

 PLL parameters */

 ref clock period in picoseconds */

 ref clock divisor */

 VCO divisor */

 first post-divisor */

 second post-divisor */

 used in color blits */

 mode requested by user */

 default mode: 1280x1024 @ 60 Hz, 8 bpp */

 List of supported cards */

 Card-specific information */

 period of PLL reference clock in ps */

/*

 * The refclk and VCO dividers appear to use a linear feedback shift

 * register, which gets reloaded when it reaches a terminal value, at

 * which point the divider output is toggled.  Thus one can obtain

 * whatever divisor is required by putting the appropriate value into

 * the reload register.  For a divisor of N, one puts the value from

 * the LFSR sequence that comes N-1 places before the terminal value

 * into the reload register.

 1 */		      0x3f, 0x00, 0x20, 0x10, 0x28, 0x14, 0x2a, 0x15, 0x0a,

 10 */	0x25, 0x32, 0x19, 0x0c, 0x26, 0x13, 0x09, 0x04, 0x22, 0x11,

 20 */	0x08, 0x24, 0x12, 0x29, 0x34, 0x1a, 0x2d, 0x36, 0x1b, 0x0d,

 30 */	0x06, 0x23, 0x31, 0x38, 0x1c, 0x2e, 0x17, 0x0b, 0x05, 0x02,

 40 */	0x21, 0x30, 0x18, 0x2c, 0x16, 0x2b, 0x35, 0x3a, 0x1d, 0x0e,

 50 */	0x27, 0x33, 0x39, 0x3c, 0x1e, 0x2f, 0x37, 0x3b, 0x3d, 0x3e,

 60 */	0x1f, 0x0f, 0x07, 0x03, 0x01,

 2 */		            0x00, 0x80, 0xc0, 0xe0, 0xf0, 0x78, 0xbc, 0x5e,

 10 */	0x2f, 0x17, 0x0b, 0x85, 0xc2, 0xe1, 0x70, 0x38, 0x9c, 0x4e,

 20 */	0xa7, 0xd3, 0xe9, 0xf4, 0xfa, 0xfd, 0xfe, 0x7f, 0xbf, 0xdf,

 30 */	0xef, 0x77, 0x3b, 0x1d, 0x8e, 0xc7, 0xe3, 0x71, 0xb8, 0xdc,

 40 */	0x6e, 0xb7, 0x5b, 0x2d, 0x16, 0x8b, 0xc5, 0xe2, 0xf1, 0xf8,

 50 */	0xfc, 0x7e, 0x3f, 0x9f, 0xcf, 0x67, 0xb3, 0xd9, 0x6c, 0xb6,

 60 */	0xdb, 0x6d, 0x36, 0x9b, 0x4d, 0x26, 0x13, 0x89, 0xc4, 0x62,

 70 */	0xb1, 0xd8, 0xec, 0xf6, 0xfb, 0x7d, 0xbe, 0x5f, 0xaf, 0x57,

 80 */	0x2b, 0x95, 0x4a, 0x25, 0x92, 0x49, 0xa4, 0x52, 0x29, 0x94,

 90 */	0xca, 0x65, 0xb2, 0x59, 0x2c, 0x96, 0xcb, 0xe5, 0xf2, 0x79,

 100 */	0x3c, 0x1e, 0x0f, 0x07, 0x83, 0x41, 0x20, 0x90, 0x48, 0x24,

 110 */	0x12, 0x09, 0x84, 0x42, 0xa1, 0x50, 0x28, 0x14, 0x8a, 0x45,

 120 */	0xa2, 0xd1, 0xe8, 0x74, 0xba, 0xdd, 0xee, 0xf7, 0x7b, 0x3d,

 130 */	0x9e, 0x4f, 0x27, 0x93, 0xc9, 0xe4, 0x72, 0x39, 0x1c, 0x0e,

 140 */	0x87, 0xc3, 0x61, 0x30, 0x18, 0x8c, 0xc6, 0x63, 0x31, 0x98,

 150 */	0xcc, 0xe6, 0x73, 0xb9, 0x5c, 0x2e, 0x97, 0x4b, 0xa5, 0xd2,

 160 */	0x69,

 only deal with range 5MHz - 300MHz */

 keep pll in range 350..600 MHz */

 turn off DTG for now */

 set PLL registers */

 work around erratum */

 turn off hardware cursor */

 reset raster engine */

 set display timing generator registers */

 calculate stride in DFA aperture */

 Set up framebuffer definition */

 XXX add proper FB allocation here someday */

 Set up framebuffer access by CPU */

	/*

	 * Set up window attribute table.

	 * We set all WAT entries the same so it doesn't matter what the

	 * window ID (WID) plane contains.

 Set sync polarity etc. */

 PCI functions */

 Set byte-swapping for DFA aperture for all pixel sizes */

 __LITTLE_ENDIAN */

 not sure what this means but fgl23 driver does that */

	pci_write_config_dword(pdev, CFG_ENDIAN0 + 4, 0x400000);*/

 supported chipsets */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * A framebuffer driver for VBE 2.0+ compliant video cards

 *

 * (c) 2007 Michal Januszewski <spock@gentoo.org>

 *     Loosely based upon the vesafb driver.

 *

 has v86d been started by uvesafb? */

 enable mtrr by default */

 enable blanking by default */

 0: scroll, 1: ypan, 2: ywrap */

 use PMI for palette changes */

 ignore CRTC settings */

 don't try DDC transfers */

 set amt. of memory to be used */

 set total amount of memory */

 maximum pixel clock */

 maximum vertical frequency */

 maximum horizontal frequency */

 force use of a specific VBE mode */

/*

 * A handler for replies from userspace.

 *

 * Make sure each message passes consistency checks and if it does,

 * find the kernel part of the task struct, copy the registers and

 * the buffer contents and then complete the task.

 Sanity checks for the buffer length. */

/*

 * Execute a uvesafb task.

 *

 * Returns 0 if the task is executed successfully.

 *

 * A message sent to the userspace consists of the uvesafb_task

 * struct and (optionally) a buffer. The uvesafb_task struct is

 * a simplified version of uvesafb_ktask (its kernel counterpart)

 * containing only the register values, flags and the length of

 * the buffer.

 *

 * Each message is assigned a sequence number (increased linearly)

 * and a random ack number. The sequence number is used as a key

 * for the uvfb_tasks array which holds pointers to uvesafb_ktask

 * structs for all requests.

	/*

	 * Check whether the message isn't longer than the maximum

	 * allowed by connector.

 uvesafb_task structure */

 Buffer */

	/*

	 * Save the message ack number so that we can find the kernel

	 * part of this task when a reply is received from userspace.

 If all slots are taken -- bail out. */

 Save a pointer to the kernel part of the task struct. */

		/*

		 * Try to start the userspace helper if sending

		 * the request failed the first time.

/*

 * Free a uvesafb_ktask struct.

/*

 * Prepare a uvesafb_ktask struct to be used again.

/*

 * Allocate and prepare a uvesafb_ktask struct.

		/*

		 * We have an exact match in terms of resolution

		 * and depth.

	/*

	 * Convert string pointers and the mode list pointer into

	 * usable addresses. Print informational messages about the

	 * video adapter and its vendor.

 Count available modes. */

 Get info about all available modes. */

		/*

		 * We only want modes that are supported with the current

		 * hardware configuration, color, graphics and that have

		 * support for the LFB.

		/*

		 * Handle 8bpp modes and modes with broken color component

		 * lengths.

/*

 * The Protected Mode Interface is 32-bit x86 code, so we only run it on

 * x86 and not x86_64.

 CONFIG_X86_32 */

/*

 * Check whether a video mode is supported by the Video BIOS and is

 * compatible with the monitor limits.

			/*

			 * If the maximum pixel clock wasn't specified in

			 * the EDID block, set it to 300 MHz.

	/*

	 * If we don't get all necessary data from the EDID block,

	 * mark it as incompatible with the GTF and set nocrtc so

	 * that we always use the default BIOS refresh rate.

 Kernel command line overrides. */

	/*

	 * In case DDC transfers are not supported, the user can provide

	 * monitor limits manually. Lower limits are set to "safe" values.

 Add VBE modes to the modelist. */

 Add valid VESA modes to our modelist. */

	/*

	 * Get the VBE state buffer size. We want all available

	 * hardware state data (CL = 0x0f).

 The protected mode interface is not available on non-x86. */

 Has the user requested a specific VESA mode? */

				/*

				 * With pixclock set to 0, the default BIOS

				 * timings will be used in set_par().

 Count the modes in the modelist */

	/*

	 * Convert the modelist into a modedb so that we can use it with

	 * fb_find_mode().

 fb_find_mode() failed */

 Look for a matching VBE mode. */

	/*

	 * If we are not VBE3.0+ compliant, we're done -- the BIOS will

	 * ignore our timings anyway.

	/*

	 * We support palette modifications for 8 bpp modes only, so

	 * there can never be more than 256 entries.

 Use VGA registers if mode is VGA-compatible. */

 no return value */

 EAX */

 EBX */

 ECX */

 EDX */

 EDI */

 ESI */

 CONFIG_X86_32 */

 CONFIG_X86 */

 1:5:5:5 */

 0:5:6:5 */

		/*

		 * For modes with bpp > 8, we only set the pseudo palette in

		 * the fb_info struct. We rely on uvesafb_setcolreg to do all

		 * sanity checking.

	/*

	 * It turns out it's not the best idea to do panning via vm86,

	 * so we only allow it if we have a PMI.

 no return value */

 EAX */

 EBX */

 ECX */

 EDX */

 EDI */

 CONFIG_X86 */

 standby */

 powerdown */

 First, try to set the standard 80x25 text mode. */

	/*

	 * Now try to restore whatever hardware state we might have

	 * saved when the fb device was first opened.

 use LFB */

 use CRTC data */

		/*

		 * The mode switch might have failed because we tried to

		 * use our own timings.  Try again with the default timings.

 For 8bpp modes, always try to set the DAC to 8 bits. */

	/*

	 * If pixclock is set to 0, then we're using default BIOS timings

	 * and thus don't have to perform any checks here.

 Use default refresh rate */

	/*

	 * Various apps will use bits_per_pixel to set the color depth,

	 * which is theoretically incorrect, but which we'll try to handle

	 * here.

	/*

	 * Check whether we have remapped enough memory for this mode.

	 * We might be called at an early stage, when we haven't remapped

	 * any memory yet, in which case we simply skip the check.

 Disable blanking if the user requested so. */

	/*

	 * Find out how much IO memory is required for the mode with

	 * the highest resolution.

	/*

	 *   size_vmode -- that is the amount of memory needed for the

	 *                 used video mode, i.e. the minimum amount of

	 *                 memory we need.

	/*

	 *   size_total -- all video memory we have. Used for mtrr

	 *                 entries, resource allocation and bounds

	 *                 checking.

	/*

	 *   size_remap -- the amount of video memory we are going to

	 *                 use for vesafb.  With modern cards it is no

	 *                 option to simply use size_total as th

	 *                 wastes plenty of kernel address space.

	/*

	 * We have to set yres_virtual here because when setup_var() was

	 * called, smem_len wasn't defined yet.

 Find the largest power-of-two */

 Try and find a power of two to add */

 !MODULE */

/*

 * drivers/video/asiliantfb.c

 *  frame buffer driver for Asiliant 69000 chip

 *  Copyright (C) 2001-2003 Saito.K & Jeanne

 *

 *  from driver/video/chipsfb.c and,

 *

 *  drivers/video/asiliantfb.c -- frame buffer device for

 *  Asiliant 69030 chip (formerly Intel, formerly Chips & Technologies)

 *  Author: apc@agelectronics.co.uk

 *  Copyright (C) 2000 AG Electronics

 *  Note: the data sheets don't seem to be available from Asiliant.

 *  They are available by searching developer.intel.com, but are not otherwise

 *  linked to.

 *

 *  This driver should be portable with minimal effort to the 69000 display

 *  chip, and to the twin-display mode of the 69030.

 *  Contains code from Thomas Hhenleitner <th@visuelle-maschinen.de> (thanks)

 *

 *  Derived from the CT65550 driver chipsfb.c:

 *  Copyright (C) 1998 Paul Mackerras

 *  ...which was derived from the Powermac "chips" driver:

 *  Copyright (C) 1997 Fabio Riccardi.

 *  And from the frame buffer device for Open Firmware-initialized devices:

 *  Copyright (C) 1997 Geert Uytterhoeven.

 *

 *  This file is subject to the terms and conditions of the GNU General Public

 *  License. See the file COPYING in the main directory of this archive for

 *  more details.

 Built in clock of the 69030 */

/* Calculate the ratios for the dot clocks without using a single long long

 Calculate the frequency required. This is hard enough. */

	/* This expresses the constraint that 150kHz <= Fref/n <= 5Mhz,

 3 <= m <= 257 */

 But if VLD = 4, then 4m <= 1028 */

			/* remember there are still only 8-bits of precision in m, so

 divide m by 4, and leave VCO loop divide at 4 */

 or set VCO loop divide to 1 */

 LCD */

 CRT */

 set misc output reg */

 set misc output reg */

	/* First check the constraint that the maximum post-VCO divisor is 32,

 Holds m-2 value for register */

 Holds n-2 value for register */

 Holds divisor bitmask */

 Set pixclock */

 Set color depth */

 24 bit packed color mode */

 Disable palettes */

 24 bit blitter mode */

 16 bit color mode */

 15 bit color mode */

 Disable palettes */

 16 bit blitter mode */

 Linear */

 8 bit color mode */

 Graphics gamma enable */

 8 bit blitter mode */

 Set up the CR registers */

 Set hardware palete */

 RGB 555 */

 RGB 565 */

 RGB 888 */

 Reset register */

 Clocking mode */

 Plane mask */

 Memory mode */

 Data rotate */

 Graphics mode */

 Miscellaneous */

 Bit mask */

 Mode control */

 Overscan */

 Memory plane enable */

 Horizontal pixel panning */

 Start address high */

 Start address low */

 Extended Start Address */

 Extended Start Address */

 Underline location */

 CRT mode control */

 Interlace control */

 set default memory clock */

 MCLK ratio M */

 MCLK ratio N */

 MCLK divisor = 2 */

 IO Control - CRT controller extensions */

 Frame buffer mapping */

 PCI burst write */

 Memory access control */

 Pixel pipeline configuration 0 */

 Pixel pipeline configuration 1 */

 Pixel pipeline configuration 2 */

 Enable video output in attribute index register */

 2MB */

/*

 * linux/drivers/video/pxa168fb.c -- Marvell PXA168 LCD Controller

 *

 *  Copyright (C) 2008 Marvell International Ltd.

 *  All rights reserved.

 *

 *  2009-02-16  adapted from original version for PXA168/910

 *              Jun Nie <njun@marvell.com>

 *

 * This file is subject to the terms and conditions of the GNU General Public

 * License. See the file COPYING in the main directory of this archive for

 * more details.

 Hz */

	/*

	 * Pseudocolor mode?

	/*

	 * Check for 565/1555.

	/*

	 * Check for 888/A888.

	/*

	 * Determine which pixel format we're going to use.

	/*

	 * Basic geometry sanity checks.

	/*

	 * Check size of framebuffer.

/*

 * The hardware clock divider has an integer and a fractional

 * stage:

 *

 *	clk2 = clk_in / integer_divider

 *	clk_out = clk2 * (1 - (fractional_divider >> 12))

 *

 * Calculate integer and fractional divider for given clk_in

 * and clk_out.

	/*

	 * Notice: The field pixclock is used by linux fb

	 * is in pixel second. E.g. struct fb_videomode &

	 * struct fb_var_screeninfo

	/*

	 * Check input values.

	/*

	 * Using PLL/AXI clock.

	/*

	 * Calc divider according to refresh rate.

 check whether divisor is too small. */

	/*

	 * Set setting to reg.

	/*

	 * Set bit to enable graphics DMA.

	/*

	 * If we are in a pseudo-color mode, we need to enable

	 * palette lookup.

	/*

	 * Configure hardware pixel format.

	/*

	 * Check red and blue pixel swap.

	 * 1. source data swap

	 * 2. panel output data swap

	/*

	 * Configure default bits: vsync triggers DMA, gated clock

	 * enable, power save enable, configure alpha registers to

	 * display 100% graphics, and set pixel command.

	/*

	 * We trigger DMA on the falling edge of vsync if vsync is

	 * active low, or on the rising edge if vsync is active high.

	/*

	 * Preserve enable flag.

	/*

	 * Set additional mode info.

	/*

	 * Disable panel output while we setup the display.

	/*

	 * Configure global panel parameters.

	/*

	 * convet var to video mode

 Calculate clock divisor. */

 Configure dma ctrl regs. */

	/*

	 * Configure graphics DMA parameters.

	/*

	 * Configure dumb panel ctrl regs & timings.

	/*

	 * Re-enable panel output.

	/*

	 * Set default value

 try to find best video mode. */

 Init settings. */

 correct pixclock. */

 Initialize private data */

	/*

	 * Initialise static fb parameters.

	/*

	 * Map LCD controller registers.

	/*

	 * Allocate framebuffer memory.

	/*

	 * Set video mode according to platform data.

	/*

	 * init video mode data.

	/*

	 * Fill in sane defaults.

	/*

	 * enable controller clock

	/*

	 * Configure default register values.

	/*

	 * Allocate color map.

	/*

	 * Register irq handler.

	/*

	 * Enable GFX interrupt

	/*

	 * Register framebuffer.

 disable DMA transfer */

/* $Id: g364fb.c,v 1.3 1998/08/28 22:43:00 tsbogend Exp $

 *

 * linux/drivers/video/g364fb.c -- Mips Magnum frame buffer device

 *

 * (C) 1998 Thomas Bogendoerfer

 *

 *  This driver is based on tgafb.c

 *

 *	Copyright (C) 1997 Geert Uytterhoeven 

 *	Copyright (C) 1995  Jay Estabrook

 *

 *  This file is subject to the terms and conditions of the GNU General Public

 *  License. See the file COPYING in the main directory of this archive for

 *  more details.

/* 

 * Various defines for the G364

 Read only */

 to 0x080170 - DON'T TOUCH! */

 bits 22 to 20 of Control A */

 bits 17 and 16 of Control A */

 same as above - don't ask me why */

 bits 13 and 12 of Control A */

 to 0x080518 */

 to 0x080610 - unused */

 to 0x080ff8 */

 to 0x081ff8 */

 unused */

 Write only */

 physical address */

/*

 *  Interface used by the world

/*

 *  Pan or Wrap the Display

 *

 *  This call looks only at xoffset, yoffset and the FB_VMODE_YWRAP flag

/*

 *  Blank the display.

/*

 *  Set a single color register. Return != 0 for invalid regno.

/*

 *  Initialisation

 TBD: G364 detection */

 get the resolution set by ARC console */

 setup cursor */

	/*

	 * first set the whole cursor to transparent

	/*

	 * switch the last two lines to cursor palette 3

	 * we assume here, that FONTSIZE_X is 8

 physical address */

 get size of video memory; this is special for the JAZZ hardware */

 virtual kernel address */

/*

 * linux/drivers/video/neofb.c -- NeoMagic Framebuffer Driver

 *

 * Copyright (c) 2001-2002  Denis Oliver Kropp <dok@directfb.org>

 *

 *

 * Card specific code is based on XFree86's neomagic driver.

 * Framebuffer framework code is based on code of cyber2000fb.

 *

 * This file is subject to the terms and conditions of the GNU General

 * Public License.  See the file COPYING in the main directory of this

 * archive for more details.

 *

 *

 * 0.4.1

 *  - Cosmetic changes (dok)

 *

 * 0.4

 *  - Toshiba Libretto support, allow modes larger than LCD size if

 *    LCD is disabled, keep BIOS settings if internal/external display

 *    haven't been enabled explicitly

 *                          (Thomas J. Moore <dark@mama.indstate.edu>)

 *

 * 0.3.3

 *  - Porting over to new fbdev api. (jsimmons)

 *  

 * 0.3.2

 *  - got rid of all floating point (dok) 

 *

 * 0.3.1

 *  - added module license (dok)

 *

 * 0.3

 *  - hardware accelerated clear and move for 2200 and above (dok)

 *  - maximum allowed dotclock is handled now (dok)

 *

 * 0.2.1

 *  - correct panning after X usage (dok)

 *  - added module and kernel parameters (dok)

 *  - no stretching if external display is enabled (dok)

 *

 * 0.2

 *  - initial version (dok)

 *

 *

 * TODO

 * - ioctl for internal/external switching

 * - blanking

 * - 32bit depth support, maybe impossible

 * - disable pan-on-sync, need specs

 *

 * BUGS

 * - white margin on bootup like with tdfxfb (colormap problem?)

 *

 --------------------------------------------------------------------- */

 --------------------------------------------------------------------- */

 FIXME: guessed values, wrong */

/*

 * neoCalcVCLK --

 *

 * Determine the closest clock frequency to the one requested.

		/* NOT_DONE:  We are trying the full range of the 2200 clock.

/*

 * vgaHWInit --

 *      Handle the initialization, etc. of a screen.

 *      Return FALSE on failure.

	/*

	 * Time Sequencer

 Font select */

 Misc */

	/*

	 * CRTC Controller

	/*

	 * are these unnecessary?

	 * vgaHWHBlankKGA(mode, regp, 0, KGA_FIX_OVERSCAN | KGA_ENABLE_ON_ZERO);

	 * vgaHWVBlankKGA(mode, regp, 0, KGA_FIX_OVERSCAN | KGA_ENABLE_ON_ZERO);

	/*

	 * Graphics Display Controller

 only map 64k VGA memory !!!! */

 standard colormap translation */

 Protect CRTC[0-7] */

 Unprotect CRTC[0-7] */

/*

 * VGA Palette management

		/*

		 * Turn off screen and disable sequencer.

 Synchronous Reset */

 disable the display */

		/*

		 * Reenable sequencer, then turn on screen.

 reenable display */

 clear synchronousreset */

 Ensure CRTC registers 0-7 are unlocked by clearing bit 7 or CRTC[17] */

 -------------------- Hardware specific routines ------------------------- */

/*

 * Hardware Acceleration for Neo2200+

  ndev->neo.waitfifo_calls++;

  ndev->neo.waitfifo_sum += requested_fifo_space;

	/* FIXME: does not work

	   if (neo_fifo_space < requested_fifo_space)

	   {

	   neo_fifo_waitcycles++;



	   while (1)

	   {

	   neo_fifo_space = (neo2200->bltStat >> 8);

	   if (neo_fifo_space >= requested_fifo_space)

	   break;

	   }

	   }

	   else

	   {

	   neo_fifo_cache_hits++;

	   }



	   neo_fifo_space -= requested_fifo_space;

 --------------------------------------------------------------------- */

 Is the mode larger than the LCD panel? */

 Is the mode one of the acceptable sizes? */

 PSEUDOCOLOUR, 256 */

 DIRECTCOLOUR, 64k */

 TRUECOLOUR, 16m */

 TRUECOLOUR, 16m */

	/* we must round yres/xres down, we already rounded y/xres_virtual up

 Blank the screen */

	/*

	 * This will allocate the datastructure and initialize all of the

	 * generic VGA registers.

	/*

	 * The default value assigned by vgaHW.c is 0x41, but this does

	 * not work for NeoMagic.

 FIXME: guessed values */

 Vertical Extension */

 Fast write bursts on unless disabled. */

 VESA Bios sets this to 0x80! */

 Initialize: by default, we want display config register to be read */

 Enable any user specified display devices. */

 If the user did not specify any display devices, then... */

 Default to internal (i.e., LCD) only. */

 If we are using a fixed mode, then tell the chip we are. */

 Setup shadow register locking. */

 External CRT only mode: */

 We need to program the VCLK for external display only mode. */

 Internal LCD only mode: */

 Simultaneous internal/external (LCD/CRT) mode: */

 Don't program the VCLK when using the LCD. */

	/*

	 * If the screen is to be stretched, turn on stretching for the

	 * various modes.

	 *

	 * OPTION_LCD_STRETCH means stretching should be turned off!

 LCD only */

 Needs testing.  KEM -- 24 May 98 */

 Needs testing.  KEM -- 24 May 98 */

 No stretching in these modes. */

	/*

	 * If the screen is to be centerd, turn on the centering for the

	 * various modes.

			/*

			 * No centering required when the requested display width

			 * equals the panel width.

 Calculate the horizontal and vertical offsets. */

 Stretched modes cannot be centered. */

 Needs testing.  KEM -- 24 May 98 */

 Needs testing.  KEM -- 24 May 98 */

 No centering in these modes. */

	/*

	 * Calculate the VCLK that most closely matches the requested dot

	 * clock.

 Since we program the clocks ourselves, always use VCLK3. */

 alread unlocked above */

 BOGUS  vga_wgfx(NULL, 0x09, 0x26); */

 don't know what this is, but it's 0 from bootup anyway */

 was set to 0x01 by my bios in text and vesa modes */

	/*

	 * The color mode needs to be set before calling vgaHWRestore

	 * to ensure the DAC is initialized properly.

	 *

	 * NOTE: Make sure we don't change bits make sure we don't change

	 * any reserved bits.

 Save bits 7:4 */

 Save bits 6:4 */

	/*

	 * In some rare cases a lockup might occur if we don't delay

	 * here. (Reported by Miles Lane)

mdelay(200);

	/*

	 * Disable horizontal and vertical graphics and text expansions so

	 * that vgaHWRestore works properly.

	/*

	 * Sleep for 200ms to make sure that the two operations above have

	 * had time to take effect.

	/*

 linear colormap for non palettized modes */

 PseudoColor, 256 */

 TrueColor, 64k */

 TrueColor, 16m */

 Save bits 3:0 */

 VESA Bios sets bit 1! */

par->SingleAddrPage */ );

par->DualAddrPage */ );

 Save bits 7:2 */

 Save bits 7:6,4:2 */

 Save bits 7,4:3 */

 Save bits 5:3 */

 Save bits 7:5 and bits 3:0 */

 Program VCLK3 if needed. */

 Save bits 3:0 */

 Gives 5x faster framebuffer writes !!! */

 Program vertical extension register */

 Turn on screen */

 Calling this also locks offset registers required in update_start */

/*

 *    Pan or Wrap the Display

	/*

	 * These are the generic starting address registers.

	/*

	 * Make sure we don't clobber some other bits that might already

	 * have been set. NOTE: NM2200 has a writable bit 3, but it shouldn't

	 * be needed.

/*

 *    (Un)Blank the display.

	/*

	 *  Blank the screen if blank_mode != 0, else unblank.

	 *  Return 0 if blanking succeeded, != 0 if un-/blanking failed due to

	 *  e.g. a video mode which doesn't support it. Implements VESA suspend

	 *  and powerdown modes for monitors, and backlight control on LCDs.

	 *    blank_mode == 0: unblanked (backlight on)

	 *    blank_mode == 1: blank (backlight on)

	 *    blank_mode == 2: suspend vsync (backlight off)

	 *    blank_mode == 3: suspend hsync (backlight off)

	 *    blank_mode == 4: powerdown (backlight off)

	 *

	 *  wms...Enable VESA DPMS compatible powerdown mode

	 *  run "setterm -powersave powerdown" to take advantage

	/*

	 * Read back the register bits related to display configuration. They might

	 * have been changed underneath the driver via Fn key stroke.

	/* In case we blank the screen, we want to store the possibly new

	 * configuration in the driver. During un-blank, we re-apply this setting,

	 * since the LCD bit will be cleared in order to switch off the backlight.

 powerdown - both sync lines down */

 Disable sequencer */

 LCD off */

 Do we still need this ? */

 attempt to turn off backlight on toshiba; also turns off external */

 HCI_SET */

 HCI_BACKLIGHT */

 HCI_DISABLE */

 hsync off */

 Disable sequencer */

 LCD off */

 vsync off */

 Disable sequencer */

 LCD off */

 just blank screen (backlight stays on) */

 Disable sequencer */

		/*

		 * During a blank operation with the LID shut, we might store "LCD off"

		 * by mistake. Due to timing issues, the BIOS may switch the lights

		 * back on, and we turn it back off once we "unblank".

		 *

		 * So here is an attempt to implement ">=" - if we are in the process

		 * of unblanking, and the LCD bit is unset in the driver but set in the

		 * register, we must keep it.

 LCD normal */

 no hsync/vsync suppression */

 unblank */

 Enable sequencer */

 LCD normal */

 no hsync/vsync suppression */

 Do we still need this ? */

 attempt to re-enable backlight/external on toshiba */

 HCI_SET */

 HCI_BACKLIGHT */

 HCI_ENABLE */

	default:	/* Anything else we don't understand; return 1 to tell

 set blt control */

               NEO_BC3_DST_XY_ADDR  |

               NEO_BC3_SRC_XY_ADDR  |

 Start with the lower right corner */

 set blt control */

 The data is padded for the hardware

			/* FIXME. There is a bug with accelerated color-expanded

			 * transfers in 24 bit mode if the image being transferred

			 * is less than 16 bits wide. This is due to insufficient

			 * padding when writing the image. We need to adjust

		/* We don't currently support hardware acceleration if image

 NEO_BC3_DST_XY_ADDR |

      par->neo2200->dstStart = (image->dy << 16) | (image->dx & 0xffff);

/*

static void

neofb_draw_cursor(struct fb_info *info, u8 *dst, u8 *src, unsigned int width)

{

	//memset_io(info->sprite.addr, 0xff, 1);

}



static int

neofb_cursor(struct fb_info *info, struct fb_cursor *cursor)

{

	struct neofb_par *par = (struct neofb_par *) info->par;



	* Disable cursor *

	write_le32(NEOREG_CURSCNTL, ~NEO_CURS_ENABLE, par);



	if (cursor->set & FB_CUR_SETPOS) {

		u32 x = cursor->image.dx;

		u32 y = cursor->image.dy;



		info->cursor.image.dx = x;

		info->cursor.image.dy = y;

		write_le32(NEOREG_CURSX, x, par);

		write_le32(NEOREG_CURSY, y, par);

	}



	if (cursor->set & FB_CUR_SETSIZE) {

		info->cursor.image.height = cursor->image.height;

		info->cursor.image.width = cursor->image.width;

	}



	if (cursor->set & FB_CUR_SETHOT)

		info->cursor.hot = cursor->hot;



	if (cursor->set & FB_CUR_SETCMAP) {

		if (cursor->image.depth == 1) {

			u32 fg = cursor->image.fg_color;

			u32 bg = cursor->image.bg_color;



			info->cursor.image.fg_color = fg;

			info->cursor.image.bg_color = bg;



			fg = ((fg & 0xff0000) >> 16) | ((fg & 0xff) << 16) | (fg & 0xff00);

			bg = ((bg & 0xff0000) >> 16) | ((bg & 0xff) << 16) | (bg & 0xff00);

			write_le32(NEOREG_CURSFGCOLOR, fg, par);

			write_le32(NEOREG_CURSBGCOLOR, bg, par);

		}

	}



	if (cursor->set & FB_CUR_SETSHAPE)

		fb_load_cursor_image(info);



	if (info->cursor.enable)

		write_le32(NEOREG_CURSCNTL, NEO_CURS_ENABLE, par);

	return 0;

}

 --------------------------------------------------------------------- */

unsigned long addr;

 Clear framebuffer, it's all white in memory after boot */

	/* Allocate Cursor drawing pad.

	info->fix.smem_len -= PAGE_SIZE;

	addr = info->fix.smem_start + info->fix.smem_len;

	write_le32(NEOREG_CURSMEMPOS, ((0x000f & (addr >> 10)) << 8) |

					((0x0ff0 & (addr >> 10)) >> 4), par);

	addr = (unsigned long) info->screen_base + info->fix.smem_len;

 Eventually we will have i2c support.

 Determine the panel type */

 Determine panel width -- used in NeoValidMode. */

 640x480@60

 800x600@60

 1024x768@60

 1280x1024@60 panel support needs to be added */

 640x480@60

/*

	info->sprite.size = CursorMem;

	info->sprite.scan_align = 1;

	info->sprite.buf_align = 1;

	info->sprite.flags = FB_PIXMAP_IO;

	info->sprite.outbuf = neofb_draw_cursor;

		/*

		 * Free the colourmap

 --------------------------------------------------------------------- */

	/*

	 * Calculate the hsync and vsync frequencies.  Note that

	 * we split the 1e12 constant up so that we can preserve

	 * the precision and fit the results into 32-bit registers.

	 *  (1953125000 * 512 = 1e12)

	/*

	 * Our driver data

 ************************* init in-kernel code ************************** */

  MODULE  */

 MODULE */

/* linux/drivers/video/s3c2410fb.c

 *	Copyright (c) 2004,2005 Arnaud Patard

 *	Copyright (c) 2004-2008 Ben Dooks

 *

 * S3C2410 LCD Framebuffer Driver

 *

 * This file is subject to the terms and conditions of the GNU General Public

 * License.  See the file COPYING in the main directory of this archive for

 * more details.

 *

 * Driver based on skeletonfb.c, sa1100fb.c and others.

 Debugging stuff */

 useful functions */

/* s3c2410fb_set_lcdaddr

 *

 * initialise lcd controller address pointers

/* s3c2410fb_calc_pixclk()

 *

 * calculate divisor for clk->pixclk

	/* pixclk is in picoseconds, our clock is in Hz

	 *

	 * Hz -> picoseconds is / 10^-12

 div / 2^12 */

 div / 5^12 */

/*

 *	s3c2410fb_check_var():

 *	Get the video params out of 'var'. If a value doesn't fit, round it up,

 *	if it's too big, return -EINVAL.

 *

 validate x/y resolution */

 choose default mode if possible */

 it is always the size as the display */

 copy lcd settings */

 set display type */

 set r/g/b positions */

 8 bpp 332 */

 12 bpp 444 */

 16 bpp, 565 format */

 16 bpp, 5551 format */

 24 bpp 888 and 8 dummy */

/* s3c2410fb_calculate_stn_lcd_regs

 *

 * calculate register values from var settings

 invalid pixel depth */

 update X/Y info */

/* s3c2410fb_calculate_tft_lcd_regs

 *

 * calculate register values from var settings

 invalid pixel depth */

 update X/Y info */

/* s3c2410fb_activate_var

 *

 * activate (set) the controller from the given framebuffer

 * information

 write new registers */

 set lcd address pointers */

/*

 *      s3c2410fb_set_par - Alters the hardware state.

 *      @info: frame buffer structure that represents a single frame buffer

 *

 activate this new configuration */

 enable IRQ */

 from pxafb.c */

	/* dprintk("setcol: regno=%d, rgb=%d,%d,%d\n",

 true-colour, use pseudo-palette */

 currently assume RGB 5-6-5 mode */

 unknown type */

/* s3c2410fb_lcd_enable

 *

 * shutdown the lcd controller

/*

 *      s3c2410fb_blank

 *	@blank_mode: the blank mode we want.

 *	@info: frame buffer structure that represents a single frame buffer

 *

 *	Blank the screen if blank_mode != 0, else unblank. Return 0 if

 *	blanking succeeded, != 0 if un-/blanking failed due to e.g. a

 *	video mode which doesn't support it. Implements VESA suspend

 *	and powerdown modes on hardware that supports disabling hsync/vsync:

 *

 *	Returns negative errno on error, or zero on success.

 *

/*

 * s3c2410fb_map_video_memory():

 *	Allocates the DRAM memory for the frame buffer.  This buffer is

 *	remapped into a non-cached, non-buffered, memory region to

 *	allow palette and pixel writes to occur without flushing the

 *	cache.  Once this area is remapped, all virtual memory

 *	access to the video memory should occur at the new region.

 prevent initial garbage on screen */

/*

 * s3c2410fb_init_registers - Initialise all LCD-related registers

 Initialise LCD with values from haret */

 modify the gpio(s) with interrupts set (bjd) */

 ensure temporary palette disabled */

		/* it seems the only way to know exactly

		 * if the palette wrote ok, is to check

		 * to see if the value verifies ok

 retry */

 work out change, <0 for speed-up */

 Stop the video */

 find maximum required memory size for display */

 Initialize video memory */

 create device files */

/*

 *  Cleanup

 suspend and resume support for the lcd controller */

	/* sleep before disabling the clock, we need to ensure

	 * the LCD DMA engine is not going to get back on the bus

 re-activate our display after resume */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * i740fb - framebuffer driver for Intel740

 * Copyright (c) 2011 Ondrej Zary

 *

 * Based on old i740fb driver (c) 2001-2002 Andrey Ulanov <drey@rt.mipt.ru>

 * which was partially based on:

 *  VGA 16-color framebuffer driver (c) 1999 Ben Pfaff <pfaffben@debian.org>

 *	and Petr Vandrovec <VANDROVE@vc.cvut.cz>

 *  i740 driver from XFree86 (c) 1998-1999 Precision Insight, Inc., Cedar Park,

 *	Texas.

 *  i740fb by Patrick LERDA, v0.9

 i740 specific registers */

	/*

	 * Would like to calculate these values automatically, but a generic

	 * algorithm does not seem possible.  Note: These FIFO water mark

	 * values were tested on several cards and seem to eliminate the

	 * all of the snow and vertical banding, but fine adjustments will

	 * probably be required for other cards.

 clock calculation from i740fb by Patrick LERDA */

 66.67 MHz */

 450 MHz */

	/*

	 * Get the video params out of 'var'.

	 * If a value doesn't fit, round it up, if it's too big, return -EINVAL.

 disable linecompare */

 1 scanline, no linecmp */

 disabled IRQ */

 0x7F for VGA, but some SVGA chips require all 8 bits to be set */

 3DA */

 0 for EGA, 0xFF for VGA */

 0rrrrrgg gggbbbbb */

 rrrrrggg gggbbbbb */

 ...ignore the last bit. */

 Unimplemented on i740 */

 Set the MCLK freq */

 100 MHz -- use as default */

 Calculate the extended CRTC regs */

 Set the overscan color to 0. (NOTE: This only affects >8bpp mode) */

 Calculate VCLK that most closely matches the requested dot clock */

 Since we program the clocks ourselves, always use VCLK2. */

 Calculate the FIFO Watermark and Burst Length. */

 disable the display */

 enable palette access */

 reenable display */

 disable palette access */

 update misc output register */

 synchronous reset on */

 write sequencer registers */

 synchronous reset off */

 deprotect CRT registers 0-7 */

 write CRT registers */

 write graphics controller registers */

 write attribute controller registers */

 reset flip-flop */

 Wait for screen to stabilize. */

		/*

		 * The last bit does not seem to have any effect on the start

		 * address register in 24bpp mode, so...

 ...ignore the last bit. */

 Turn the screen on/off */

 Set the DPMS mode */

 Let fbcon do a soft blank for us */

 ------------------------------------------------------------------------- */

 detect memory size */

 detect memory type */

 fill all other info->var's fields */

 maximize virtual vertical size for fast scrolling */

	pci_disable_device(dev); */

		pci_disable_device(dev); */

 do nothing if framebuffer is not active */

 CONFIG_PM_SLEEP */

/*

 *  Fast C2P (Chunky-to-Planar) Conversion

 *

 *  Copyright (C) 2003-2008 Geert Uytterhoeven

 *

 *  This file is subject to the terms and conditions of the GNU General Public

 *  License. See the file COPYING in the main directory of this archive

 *  for more details.

    /*

     *  Perform a full C2P step on 32 8-bit pixels, stored in 8 32-bit words

     *  containing

     *    - 32 8-bit chunky pixels on input

     *    - permutated planar data (1 plane per 32-bit word) on output

    /*

     *  Array containing the permutation indices of the planar data after c2p

    /*

     *  Store a full block of planar data after c2p conversion

    /*

     *  Store a partial block of planar data after c2p conversion

    /*

     *  c2p_planar - Copy 8-bit chunky image data to a planar frame buffer

     *  @dst: Starting address of the planar frame buffer

     *  @dx: Horizontal destination offset (in pixels)

     *  @dy: Vertical destination offset (in pixels)

     *  @width: Image width (in pixels)

     *  @height: Image height (in pixels)

     *  @dst_nextline: Frame buffer offset to the next line (in bytes)

     *  @dst_nextplane: Frame buffer offset to the next plane (in bytes)

     *  @src_nextline: Image offset to the next line (in bytes)

     *  @bpp: Bits per pixel of the planar frame buffer (1-8)

 Single destination word */

 Multiple destination words */

 Leading bits */

 Main chunk */

 Trailing bits */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Driver for the Solomon SSD1307 OLED controller

 *

 * Copyright 2012 Free Electrons

 Cached address ranges */

	/*

	 * The screen is divided in pages, each having a height of 8

	 * pixels, and the width of the screen. When sending a byte of

	 * data to the controller, it gives the 8 bits for the current

	 * column. I.e, the first byte are the 8 bits of the first

	 * column, then the 8 bits for the second column, etc.

	 *

	 *

	 * Representation of the screen, assuming it is 5 bits

	 * wide. Each letter-number combination is a bit that controls

	 * one pixel.

	 *

	 * A0 A1 A2 A3 A4

	 * B0 B1 B2 B3 B4

	 * C0 C1 C2 C3 C4

	 * D0 D1 D2 D3 D4

	 * E0 E1 E2 E3 E4

	 * F0 F1 F2 F3 F4

	 * G0 G1 G2 G3 G4

	 * H0 H1 H2 H3 H4

	 *

	 * If you want to update this screen, you need to send 5 bytes:

	 *  (1) A0 B0 C0 D0 E0 F0 G0 H0

	 *  (2) A1 B1 C1 D1 E1 F1 G1 H1

	 *  (3) A2 B2 C2 D2 E2 F2 G2 H2

	 *  (4) A3 B3 C3 D3 E3 F3 G3 H3

	 *  (5) A4 B4 C4 D4 E4 F4 G4 H4

 Last page may be partial */

 Enable the PWM */

 Set initial contrast */

 Set segment re-map */

 Set COM direction */

 Set multiplex ratio value */

 set display offset value */

 Set clock frequency */

 Set Set Area Color Mode ON/OFF & Low Power Display Mode */

 Set precharge period in number of ticks from the internal clock */

 Set COM pins configuration */

 Set VCOMH */

 Turn on the DC-DC Charge Pump */

 Set lookup table */

 Switch to horizontal addressing mode */

 Clear the screen */

 Turn on the display */

 Setup display timing */

 Reset the screen */

/*

 *	linux/drivers/video/pmag-aa-fb.c

 *	Copyright 2002 Karsten Merker <merker@debian.org>

 *

 *	PMAG-AA TurboChannel framebuffer card support ... derived from

 *	pmag-ba-fb.c, which is Copyright (C) 1999, 2000, 2001 by

 *	Michael Engel <engel@unix-ag.org>, Karsten Merker <merker@debian.org>

 *	and Harald Koerfgen <hkoerfg@web.de>, which itself is derived from

 *	"HP300 Topcat framebuffer support (derived from macfb of all things)

 *	Phil Blundell <philb@gnu.org> 1998"

 *	Copyright (c) 2016  Maciej W. Rozycki

 *

 *	This file is subject to the terms and conditions of the GNU General

 *	Public License.  See the file COPYING in the main directory of this

 *	archive for more details.

 *

 *	2002-09-28  Karsten Merker <merker@linuxtag.org>

 *		Version 0.01: First try to get a PMAG-AA running.

 *

 *	2003-02-24  Thiemo Seufer  <seufer@csv.ica.uni-stuttgart.de>

 *		Version 0.02: Major code cleanup.

 *

 *	2003-09-21  Thiemo Seufer  <seufer@csv.ica.uni-stuttgart.de>

 *		Hardware cursor support.

 *

 *	2016-02-21  Maciej W. Rozycki  <macro@linux-mips.org>

 *		Version 0.03: Rewritten for the new FB and TC APIs.

 Version information */

/*

 * Bt455 RAM DAC register base offset (rel. to TC slot base address).

/*

 * Bt431 cursor generator offset (rel. to TC slot base address).

/*

 * Begin of PMAG-AA framebuffer memory relative to TC slot address,

 * resolution is 1280x1024x1 (8 bits deep, but only LSB is used).

 0 unblanks, any other blanks. */

 Request the I/O MEM resource. */

 MMIO mapping setup. */

 Frame buffer mapping setup. */

 Init colormap. */

 Init hardware cursor. */

/*

 * Initialise the framebuffer.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * linux/drivers/video/omap2/omapfb-sysfs.c

 *

 * Copyright (C) 2008 Nokia Corporation

 * Author: Tomi Valkeinen <tomi.valkeinen@nokia.com>

 *

 * Some code and ideas taken from drivers/video/omap/ driver

 * by Imre Deak.

	/*

	 * Since the VRAM for this FB is not allocated at the moment we don't

	 * need to do any further parameter checking at this point.

 detach unused overlays */

 FIXME error handling? */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * linux/drivers/video/omap2/omapfb-ioctl.c

 *

 * Copyright (C) 2008 Nokia Corporation

 * Author: Tomi Valkeinen <tomi.valkeinen@nokia.com>

 *

 * Some code and ideas taken from drivers/video/omap/ driver

 * by Imre Deak.

 XXX uses only the first overlay */

 Take the locks in a specific order to keep lockdep happy */

		/*

		 * This plane's memory was freed, can't enable it

		 * until it's reallocated.

 Release the locks in a specific order to keep lockdep happy */

 Release the locks in a specific order to keep lockdep happy */

 xxx */

 MANUAL_UPDATE */

 AUTO_UPDATE */

 XXX this color key handling is a hack... */

		/*

		 * It's possible that the FB doesn't support a mode

		 * that is supported by the overlay, so call the

		 * following here.

 DSS1 never returns an error here, so we neither */

r = -EINVAL;*/

	/* LCD and CTRL tests do the same thing for backward

		/*

		 * We don't have the ability to get this vram info anymore.

		 * Fill in something that should keep the applications working.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * VRFB Rotation Engine

 *

 * Copyright (C) 2009 Nokia Corporation

 * Author: Tomi Valkeinen <tomi.valkeinen@nokia.com>

#define DEBUG*/

 Assuming SDRAM pagesize= 1024 */

 1024 = 2^5 * 2^5 */

 bitmap of reserved contexts */

/*

 * Access to this happens from client drivers or the PM core after wake-up.

 * For the first case we require locking at the driver level, for the second

 * we don't need locking, since no drivers will run until after the wake-up

 * has finished.

/*

 * This the extra space needed in the VRFB physical area for VRFB to safely wrap

 * any memory accesses to the invisible part of the virtual view to the physical

 * area.

 i=1..32 */

 Virtual views provided by VRFB are limited to 2048x2048. */

	/* For YUV2 and UYVY modes VRFB needs to handle pixels a bit

 first resource is the register res, the rest are vrfb contexts */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * linux/drivers/video/omap2/omapfb-main.c

 *

 * Copyright (C) 2008 Nokia Corporation

 * Author: Tomi Valkeinen <tomi.valkeinen@nokia.com>

 *

 * Some code and ideas taken from drivers/video/omap/ driver

 * by Imre Deak.

 first match with nonstd field */

 then try exact match of bpp and colors */

	/* match with bpp if user has not filled color fields

 XXX: some applications seem to set virtual res to 0. */

 One needs to check for both VRFB and OMAPFB limitations. */

/*

 * Consider if VRFB assisted rotation is in use and if the virtual space for

 * the zero degree view needs to be mapped. The need for mapping also acts as

 * the trigger for setting up the hardware on the context in question. This

 * ensures that one does not attempt to access the virtual view before the

 * hardware is serving the address translations.

	/* We need to reconfigure VRFB if the resolution changes, if yuv mode

 XXX we shouldn't allow this when framebuffer is mmapped */

 Now one can ioremap the 0 angle view */

 used by open/write in fbmem.c */

 used by open/write in fbmem.c */

 used by mmap in fbmem.c */

 12bpp is stored in 16 bits */

 check new var and possibly modify it to be ok */

 When no memory is allocated ignore the size check */

 pixclock in ps, the rest in pixclock */

/*

 * ---------------------------------------------------------------------------

 * fbdev framework callbacks

 * ---------------------------------------------------------------------------

 setup overlay according to the fb */

 apply var to the overlay */

 the fb is not available. disable the overlay */

/* checks var and eventually tweaks it to something supported,

 set the video mode according to info->var */

 vm_ops.open won't be called for mmap itself. */

/* Store a single color palette entry into a pseudo palette or the hardware

 * palette if one is available. For now we support only 16bpp and thus store

 * the entry only to the pseudo palette.

struct omapfb_info *ofbi = FB2OFB(fbi);*/

struct omapfb2_device *fbdev = ofbi->fbdev;*/

 XXX */

switch (plane->color_mode) {*/

		/*

		   if (fbdev->ctrl->setcolreg)

		   r = fbdev->ctrl->setcolreg(regno, red, green, blue,

		   transp, update_hw_pal);

		/* FB_BLANK_NORMAL could be implemented.

 XXX fb_read and fb_write are needed for VRFB */

 XXX needed for VRFB */

.fb_write	= omapfb_write,*/

 unmap the 0 angle rotation */

 allocate fbmem using display resolution as reference */

		/* allocate memory automatically only for fb0, or if

 initialize fb_info, var, fix to something sane based on the display */

 if there's no display, let's just guess some basic values */

 free the reserved fbmem */

 allocate fb_infos */

 assign these early, so that fb alloc can use them */

 assign overlays for the fbs */

 allocate fb memories */

 setup fb_infos */

 Enable fb0 */

	/* this is quite a hack, but I wanted to use the modedb and for

 If check_timings is not present compare xres and yres */

 skip repeated pixel modes */

		/*

		 * We don't care if the connect succeeds or not. We just want to

		 * connect as many displays as possible.

	/*

	 * Search with the display name from the user or the board file,

	 * comparing to display names and aliases

 def_name given but not found */

 then look for DT alias display0 */

 return the first display we have in the list */

 FIXME: wait till completion of pending events */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2009 Nokia Corporation

 * Author: Tomi Valkeinen <tomi.valkeinen@nokia.com>

 *

 * Some code and ideas taken from drivers/video/omap/ driver

 * by Imre Deak.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * OMAP5 HDMI CORE IP driver library

 *

 * Copyright (C) 2014 Texas Instruments Incorporated

 *

 * Authors:

 *	Yong Zhi

 *	Mythri pk

 *	Archit Taneja <archit@ti.com>

 *	Tomi Valkeinen <tomi.valkeinen@ti.com>

 only 24 bit color depth used for now */

 HDMI_DEEP_COLOR_24BIT */

 HDMI_DEEP_COLOR_30BIT */

 HDMI_DEEP_COLOR_36BIT */

 FULL RANGE */

 DSS L3 ICLK */

 ns */

 ns */

 ns */

 ns */

 ns */

 SFR_DIV */

 SFR clock in kHz */

 Reset */

 Standard (0) or Fast (1) Mode */

 Standard Mode SCL High counter */

 Standard Mode SCL Low counter */

 Fast Mode SCL High Counter */

 Fast Mode SCL Low Counter */

 SDA Hold Time */

 NACK_POL to high */

 NACK_MASK to unmasked */

 ARBITRATION_POL to high */

 ARBITRATION_MASK to unmasked */

 DONE_POL to high */

 DONE_MASK to unmasked */

 Mask I2C interrupts */

	/*

	 * TODO: We use polling here, although we probably should use proper

	 * interrupts.

 clear ERROR and DONE */

 I2CM_ERROR */

 I2CM_DONE */

 video core */

 It is always 1*/

 Always 0 - need to confirm */

 DSS_HDMI_CORE_VIDEO_CONFIG */

 Set hsync, vsync and data-enable polarity  */

 set x resolution */

 set y resolution */

 set horizontal blanking pixels */

 set vertial blanking pixels */

 set horizontal sync offset */

 set vertical sync offset */

 set horizontal sync pulse width */

  set vertical sync pulse width */

 select DVI mode */

 24 bit color depth */

 COLOR_DEPTH */

 BYPASS_EN */

 PP_EN */

 YCC422_EN */

 PP_STUFFING */

 YCC422_STUFFING */

 OUTPUT_SELECTOR */

 24 bit color depth */

 CSC_COLORDEPTH */

 for 24 bit color depth */

 VIDEO_MAPPING */

 support limited range with 24 bit color depth for now */

 Master IRQ mask */

 Mask all the interrupts in HDMI core */

 Clear all the current interrupt bits */

 Unmute interrupts */

 video config */

 support limited range with 24 bit color depth for now */

	/*

	 * configure core video part, set software reset in the core

 Mute audio before configuring */

 Set the N parameter */

	/*

	 * CTS manual mode. Automatic mode is not supported when using audio

	 * parallel interface.

 Layout of Audio Sample Packets: 2-channel or multichannels */

 Configure IEC-609580 Validity bits */

 Channel 0 is valid */

 Channels 1, 2 setting */

 Channel 3 setting */

 Configure IEC-60958 User bits */

 TODO: should be set by user. */

 Configure IEC-60958 Channel Status word */

 CGMSA */

 Copyright */

 Category */

 PCM audio mode */

 Source number */

 Channel number right 0  */

 Channel number right 1*/

 Channel number right 2  */

 Channel number right 3*/

 Channel number left 0  */

 Channel number left 1*/

 Channel number left 2  */

 Channel number left 3*/

 Clock accuracy and sample rate */

 Original sample rate and word length */

 Enable FIFO empty and full interrupts */

 Configure GPA */

 select HBR/SPDIF interfaces */

 select HBR/SPDIF interfaces */

 enable two channels in GPA */

 select HBR/SPDIF interfaces */

 enable six channels in GPA */

 select HBR/SPDIF interfaces */

 enable eight channels in GPA */

 disable HBR */

 enable PCUV */

 enable GPA FIFO full and empty mask */

 set polarity of GPA FIFO empty interrupts */

 unmute audio */

 channel count and coding type fields in AUDICONF0 are swapped */

 only 16-bit word length supported atm */

 Audio channels settings */

 DMA settings */

 in number of samples */

 audio FIFO format settings for 16-bit samples*/

 only LPCM atm */

 only allowed option */

 disable start/stop signals of IEC 60958 blocks */

 configure DMA and audio FIFO format*/

 configure the core */

 configure CEA 861 audio infoframe */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * linux/drivers/video/omap2/dss/dispc.c

 *

 * Copyright (C) 2009 Nokia Corporation

 * Author: Tomi Valkeinen <tomi.valkeinen@nokia.com>

 *

 * Some code and ideas taken from drivers/video/omap/ driver

 * by Imre Deak.

 DISPC */

 swap GFX & WB fifos */

 no DISPC_IRQ_FRAMEDONETV on this SoC */

 revert to the OMAP4 mechanism of DISPC Smart Standby operation */

 PIXEL_INC is not added to the last pixel of a line */

 POL_FREQ has ALIGN bit */

 maps which plane is using a fifo. fifo-id -> plane-id */

 DISPC_CONTROL & DISPC_CONFIG lock*/

	/* used for all color formats for OMAP3 and earlier

	 * and for RGB and Y color component on OMAP4

	/* used for UV component for

	 * OMAP_DSS_COLOR_YUV2, OMAP_DSS_COLOR_UYVY, OMAP_DSS_COLOR_NV12

	 * color formats on OMAP4

 used to maintain a count of the above fields */

RR(IRQENABLE);*/

RR(CONTROL);*/

 enable last, because LCD & DIGIT enable are here */

 clear spurious SYNC_LOST_DIGIT interrupts */

	/*

	 * enable last so IRQs won't trigger before

	 * the context is fully restored

 YUV -> RGB */

 RGB -> YUV */

 Configure burst size always to maximum size */

 burst multiplier is always x8 (see dispc_configure_burst_sizes()) */

	/*

	 * This is partially implemented to support only disabling of

	 * the gamma table.

		/*

		 * By default fifos are mapped directly to overlays, fifo 0 to

		 * ovl 0, fifo 1 to ovl 1, etc.

	/*

	 * The GFX fifo on OMAP4 is smaller than the other fifos. The small fifo

	 * causes problems with certain use cases, like using the tiler in 2D

	 * mode. The below hack swaps the fifos of GFX and WB planes, thus

	 * giving GFX plane a larger fifo. WB but should work fine with a

	 * smaller fifo.

 GFX BUF top to WB */

 GFX BUF bottom to WB */

 WB BUF top to GFX */

 WB BUF bottom to GFX */

	/*

	 * Setup default fifo thresholds.

	/*

	 * configure the preload to the pipeline's high threhold, if HT it's too

	 * large for the preload field, set the threshold to the maximum value

	 * that can be held by the preload register

	/*

	 * All sizes are in bytes. Both the buffer and burst are made of

	 * buffer_units, and the fifo thresholds must be buffer_unit aligned.

	/*

	 * We use the same low threshold for both fifomerge and non-fifomerge

	 * cases, but for fifomerge we calculate the high threshold using the

	 * combined fifo size

		/*

		 * Most optimal configuration for writeback is to push out data

		 * to the interconnect the moment writeback pushes enough pixels

		 * in the FIFO to form a burst

	/*

	 * HACK: NV12 color format and MFLAG seem to have problems working

	 * together: using two displays, and having an NV12 overlay on one of

	 * the displays will cause underflows/synclosts when MFLAG_CTRL=2.

	 * Changing MFLAG thresholds and PRELOAD to certain values seem to

	 * remove the errors, but there doesn't seem to be a clear logic on

	 * which values work and which not.

	 *

	 * As a work-around, set force MFLAG to always on.

 MFLAG_CTRL = force always on */

 MFLAG_START = disable */

		/*

		 * Simulation team suggests below thesholds:

		 * HT = fifosize * 5 / 8;

		 * LT = fifosize * 4 / 8;

		/*

		 * Simulation team suggests below thesholds:

		 * HT = fifosize * 5 / 8;

		 * LT = fifosize * 4 / 8;

 RESIZEENABLE and VERTICALTAPS */

 VRESIZECONF and HRESIZECONF */

 LINEBUFFERSPLIT */

	/*

	 * field 0 = even field = bottom field

	 * field 1 = odd field = top field

 reset chroma resampling for RGB formats  */

 UV is subsampled by 2 horizontally and vertically */

 UV is downsampled by 2 horizontally and vertically */

 For YUV422 with 90/270 rotation, we don't upsample chroma */

 UV is subsampled by 2 horizontally */

 UV is downsampled by 2 horizontally */

 must use FIR for YUV422 if rotated */

 set H scaling */

 set V scaling */

	/*

	 * OMAP4/5 Errata i631:

	 * NV12 in 1D mode must use ROTATION=1. Otherwise DSS will fetch extra

	 * rows beyond the framebuffer, which may cause OCP error.

 DOUBLESTRIDE */

 FIXME CLUT formats */

	/*

	 * field 0 = even field = bottom field

	 * field 1 = odd field = top field

		/*

		 * If the pixel format is YUV or UYVY divide the width

		 * of the image by 2 for 0 and 180 degree rotation.

		/* If the pixel format is YUV or UYVY divide the width

		 * of the image by 2  for 0 degree and 180 degree

 FIXME CLUT formats */

 width & height are overlay sizes, convert to fb sizes */

	/*

	 * field 0 = even field = bottom field

	 * field 1 = odd field = top field

 mirroring */

	/*

	 * field 0 = even field = bottom field

	 * field 1 = odd field = top field

/*

 * This function is used to avoid synclosts in OMAP3, because of some

 * undocumented horizontal position and timing related limitations.

 FIXME add checks for 3-tap filter once the limitations are known */

	/*

	 * Pixel data should be prepared before visible display point starts.

	 * So, atleast DS-2 lines must have already been fetched by DISPC

	 * during nonactive - pos_x period.

	/*

	 * All lines need to be refilled during the nonactive period of which

	 * only one line can be loaded during the active period. So, atleast

	 * DS - 1 lines should be loaded during nonactive period.

	/*

	 * FIXME how to determine the 'A' factor

	 * for the no downscaling case ?

	/*

	 * If the overlay/writeback is in mem to mem mode, there are no

	 * downscaling limitations with respect to pixel clock, return 1 as

	 * required core clock to represent that we have sufficient enough

	 * core clock to do maximum downscaling

 verify that we're inside the limits of scaler */

		/*

		 * when downscaling the bottom field may have to start several

		 * source lines below the top field. Unfortunately ACCUI

		 * registers will only hold the fractional part of the offset

		 * so the integer part must be added to the base address of the

		 * bottom field.

 Fields are independent but interleaved in memory. */

 flush posted write */

 TODO: OMAP4+ supports interlace for LCD outputs */

 always use the 'rf' setting */

 always set ALIGN bit when available */

 change name to mode? */

 DISPC common registers */

 DISPC channel specific registers */

 Video pipeline coefficient registers */

 start from OMAP_DSS_VIDEO1 */

 calculate clock rates using dividers in cinfo */

			/*

			 * For OMAP2/3 the DISPC fclk is the same as LCD's logic

			 * clock, which means we're configuring DISPC fclk here

			 * also. Thus we need to use the calculated lck. For

			 * OMAP4+ the DISPC fclk is a separate clock.

 clear the irqstatus for newly enabled irqs */

 SIDLEMODE: smart idle */

 SIDLEMODE: no idle */

 Exclusively enable DISPC_CORE_CLK and set divider to 1 */

 Use DISPC_DIVISOR.LCD, instead of DISPC_DIVISOR1.LCD */

 FUNCGATED */

 ensure the dispc_irq_handler sees the values above */

 DISPC HW IP initialisation */

 ensure the dispc_irq_handler sees the is_enabled value */

 wait for current handler to finish before turning the DISPC off */

	/*

	 * The reset value for load mode is 0 (OMAP_DSS_LOAD_CLUT_AND_FRAME)

	 * but we always initialize it to 2 (OMAP_DSS_LOAD_FRAME_ONLY) in

	 * _omap_dispc_initial_config(). We can thus use it to detect if

	 * we have lost register context.

 ensure the dispc_irq_handler sees the is_enabled value */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * linux/drivers/video/omap2/dss/venc.c

 *

 * Copyright (C) 2009 Nokia Corporation

 * Author: Tomi Valkeinen <tomi.valkeinen@nokia.com>

 *

 * VENC settings from TI's DSS driver

 Venc registers */

 from TRM */

 863 */

 624 */

 from TRM */

 the magical sleep that makes things work */

 XXX more info? What bug this circumvents? */

 S-Video */

 Reset WSS data when the TV standard changes. */

 Invert due to VENC_L21_WC_CTL:INV=1 */

 Invert due to VENC_L21_WC_CTL:INV=1 */

 VENC HW IP initialisation */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * HDMI driver for OMAP5

 *

 * Copyright (C) 2014 Texas Instruments Incorporated

 *

 * Authors:

 *	Yong Zhi

 *	Mythri pk

 *	Archit Taneja <archit@ti.com>

 *	Tomi Valkeinen <tomi.valkeinen@ti.com>

		/*

		 * If we get both connect and disconnect interrupts at the same

		 * time, turn off the PHY, clear interrupts, and restart, which

		 * raises connect interrupt if a cable is connected, or nothing

		 * if cable is not connected.

		/*

		 * We always get bogus CONNECT & DISCONNECT interrupts when

		 * setting the PHY to LDOON. To ignore those, we force the RXDET

		 * line to 0 until the PHY power state has been changed.

 FORCE_RXDET_HIGH */

 RXDET_LINE */

 Make selection of HDMI in DSS */

 disable and clear irqs */

 bypass TV gamma table */

 tv size */

 TODO: proper interlace support */

 No-idle mode */

 Audio callbacks */

 HDMI HW IP initialisation */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * linux/drivers/video/omap2/dss/display.c

 *

 * Copyright (C) 2009 Nokia Corporation

 * Author: Tomi Valkeinen <tomi.valkeinen@nokia.com>

 *

 * Some code and ideas taken from drivers/video/omap/ driver

 * by Imre Deak.

	/*

	 * Note: this presumes all the displays are either using DT or non-DT,

	 * which normally should be the case. This also presumes that all

	 * displays either have an DT alias, or none has.

 Use 'label' property for name, if it exists */

/*

 * ref count of the found device is incremented.

 * ref count of from-device is decremented.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * linux/drivers/video/omap2/dss/dispc_coefs.c

 *

 * Copyright (C) 2011 Texas Instruments

 * Author: Chandrabhanu Mahapatra <cmahapatra@ti.com>

		/*

		 * When upscaling more than two times, blockiness and outlines

		 * around the image are observed when M8 tables are used. M11,

		 * M16 and M19 tables are used to prevent this.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2012 Texas Instruments Ltd

 * Author: Archit Taneja <archit@ti.com>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * linux/drivers/video/omap2/dss/dsi.c

 *

 * Copyright (C) 2009 Nokia Corporation

 * Author: Tomi Valkeinen <tomi.valkeinen@nokia.com>

 DSI Protocol Engine */

 DSIPHY_SCP */

 DSI_PLL_CTRL_SCP */

 Global interrupts */

 Virtual channel interrupts */

 ComplexIO interrupts */

 DSI PLL HSDIV indices */

 inputs */

 outputs */

 space for a copy used by the interrupt handler */

 first busyloop to see if the bit changes right away */

 then loop for 500ms, sleeping for 1ms in between */

 IRQ is not for us */

 flush posted write */

 flush posted write */

 flush posted write */

	/* make a copy and unlock, so that isrs can unregister

 dsi->irq_lock has to be locked by the caller */

 clear the irqstatus for newly enabled irqs */

 flush posted writes */

 dsi->irq_lock has to be locked by the caller */

 dsi->irq_lock has to be locked by the caller */

 dsi->irq_lock has to be locked by the caller */

 check for duplicate entry and find a free slot */

	/* A dummy read using the SCP interface to any DSIPHY register is

	 * required after DSIPHY reset to complete the reset of the DSI complex

 IF_EN */

 DSI FCLK source is DSS_CLK_FCK */

 DSI FCLK source is dsi_pll_hsdiv_dsi_clk */

 LP_CLK_DIVISOR */

 LP_RX_SYNCHRO_ENABLE */

 CIO_CLK_ICG */

 CIO_CLK_ICG */

 DSI-PLL power command 0x3 is not working */

 PLL_PWR_CMD */

 PLL_PWR_STATUS */

	/*

	 * Note: SCP CLK is not required on OMAP3, but it is required on OMAP4.

 XXX PLL does not come out of reset without this... */

	/* XXX ... but if left on, we get problems when planes do not

 PWR_CMD */

 PWR_STATUS */

 line buffer on OMAP3 is 1024 x 24bits */

	/* XXX: for some reason using full buffer size causes

	 * considerable TX slowdown with update sizes that fill the

 VP1_LINE_BUFFER_SIZE */

 512x24 bits */

 682x24 bits */

 853x24 bits */

 1024x24 bits */

 1194x24 bits */

 1365x24 bits */

 1920x24 bits */

 clear the unused lanes */

 convert time in ns to ddr ticks, rounding up */

 calculate timings */

 1 * DDR_CLK = 2 * UI */

 min 40ns + 4*UI	max 85ns + 6*UI */

 min 145ns + 10*UI */

 min max(8*UI, 60ns+4*UI) */

 min 100ns */

 tlpx min 50n */

 min 60ns */

 min 38ns, max 95ns */

 min tclk-prepare + tclk-zero = 300ns */

 program timings */

 DCCEN = disable */

 CLKINP_DIVBY2EN = enable */

 CLKINP_SEL = enable */

 lane masks have lane 0 at lsb. mask_p for positive lines, n for negative */

	/*

	 * Bits in REGLPTXSCPDAT4TO0DXDY:

	 * 17: DY0 18: DX0

	 * 19: DY1 20: DX1

	 * 21: DY2 22: DX2

	 * 23: DY3 24: DX3

	 * 25: DY4 26: DX4

 Set the lane override configuration */

 REGLPTXSCPDAT4TO0DXDY */

 Enable lane override */

 ENLPTXSCPDAT */

 Disable lane override */

 ENLPTXSCPDAT */

 Reset the lane override configuration */

 REGLPTXSCPDAT4TO0DXDY */

 return bitmask of enabled lanes, lane0 being the lsb */

	/* A dummy read using the SCP interface to any DSIPHY register is

	 * required after DSIPHY reset to complete the reset of the DSI complex

 set TX STOP MODE timer to maximum for this operation */

 FORCE_TX_STOP_MODE_IO */

 STOP_STATE_X16_IO */

 STOP_STATE_X4_IO */

 STOP_STATE_COUNTER_IO */

		/* ULPS is exited by Mark-1 state for 1ms, followed by

		 * stop state. DSS HW cannot do this via the normal

		 * ULPS exit sequence, as after reset the DSS HW thinks

		 * that we are not in ULPS mode, and refuses to send the

		 * sequence. So we need to send the ULPS exit sequence

		 * manually by setting positive lines high and negative lines

		 * low for 1ms.

 LP_CLK_ENABLE */

 Keep Mark-1 state for 1ms (as per DSI spec) */

		/* Disable the override. The lanes should be set to Mark-11

 FORCE_TX_STOP_MODE_IO */

 DDR_CLK_ALWAYS_ON */

 LP_CLK_ENABLE */

 DDR_CLK_ALWAYS_ON */

DSSDBG("TX FIFO vc %d: size %d, add %d\n", i, size, add); */

DSSDBG("RX FIFO vc %d: size %d, add %d\n", i, size, add); */

 FORCE_TX_STOP_MODE_IO */

 Wait for completion only if TE_EN/TE_START is still set */

 Wait for completion only if TX_FIFO_NOT_EMPTY is still set */

 VC_BUSY */

 SOURCE, 0 = L4 */

 BTA_SHORT_EN  */

 BTA_LONG_EN */

 MODE, 0 = command */

 CS_TX_EN */

 ECC_TX_EN */

 MODE_SPEED, high speed on/off */

 OCP_WIDTH = 32 bit */

 DMA_RX_REQ_NB = no dma */

 DMA_TX_REQ_NB = no dma */

 VC_BUSY */

 SOURCE, 0 = L4, 1 = video port */

 DCS_CMD_ENABLE */

 start the DDR clock by sending a NULL packet */

 RX_FIFO_NOT_EMPTY */

 RX_FIFO_NOT_EMPTY */

 BTA_EN */

 flush posted write */

/*	DSSDBG("\twriting %02x, %02x, %02x, %02x (%#010x)\n",

u32 val; */

 len + header */

 RX_FIFO_NOT_EMPTY */

 RX_FIFO_NOT_EMPTY */

 two byte checksum ends the packet, not included in len */

 we discard the 2 byte checksum */

 DDR_CLK_ALWAYS_ON */

 HS_BUSY */

 LP_BUSY */

 Assert TxRequestEsc for data lanes and TxUlpsClk for clk lane */

 LANEx_ULPS_SIG2 */

 flush posted write and wait for SCP interface to finish the write */

 Reset LANEx_ULPS_SIG2 */

 flush posted write and wait for SCP interface to finish the write */

 ticks in DSI_FCK */

 LP_RX_TO */

 LP_RX_TO_X16 */

 LP_RX_TO_X4 */

 LP_RX_COUNTER */

 ticks in DSI_FCK */

 TA_TO */

 TA_TO_X16 */

 TA_TO_X8 */

 TA_TO_COUNTER */

 ticks in DSI_FCK */

 FORCE_TX_STOP_MODE_IO */

 STOP_STATE_X16_IO */

 STOP_STATE_X4_IO */

 STOP_STATE_COUNTER_IO */

 ticks in TxByteClkHS */

 HS_TX_TO */

 HS_TX_TO_X16 */

 HS_TX_TO_X8 (4 really) */

 HS_TX_TO_COUNTER */

		/*

		 * Don't use line buffers if width is greater than the video

		 * port's line buffer size

 Use maximum number of line buffers in command mode */

 LINE_BUFFER */

 VP_DE_POL */

 VP_HSYNC_POL */

 VP_VSYNC_POL */

 VP_VSYNC_START */

 VP_VSYNC_END */

 VP_HSYNC_START */

 VP_HSYNC_END */

	/*

	 * 0 = TX FIFO packets sent or LPS in corresponding blanking periods

	 * 1 = Long blanking packets are sent in corresponding blanking periods

 BLANKING_MODE */

 HFP_BLANKING */

 HBP_BLANKING */

 HSA_BLANKING */

/*

 * According to section 'HS Command Mode Interleaving' in OMAP TRM, Scenario 3

 * results in maximum transition time for data and clock lanes to enter and

 * exit HS mode. Hence, this is the scenario where the least amount of command

 * mode data can be interleaved. We program the minimum amount of TXBYTECLKHS

 * clock cycles that can be used to interleave command mode data in HS so that

 * all scenarios are satisfied.

	/*

	 * If DDR_CLK_ALWAYS_ON is set, we need to consider HS mode transition

	 * time of data lanes only, if it isn't set, we need to consider HS

	 * transition time of both data and clock lanes. HS transition time

	 * of Scenario 3 is considered.

/*

 * According to section 'LP Command Mode Interleaving' in OMAP TRM, Scenario 1

 * results in maximum transition time for data lanes to enter and exit LP mode.

 * Hence, this is the scenario where the least amount of command mode data can

 * be interleaved. We program the minimum amount of bytes that can be

 * interleaved in LP so that all scenarios are satisfied.

 time required for a LP transition, in TXBYTECLKHS */

 time left for interleaving commands, in CLKIN4DDR */

 period of LP transmit escape clock, in CLKIN4DDR */

 Period of TXBYTECLKHS clock, in CLKIN4DDR */

 cmd mode data that can be interleaved, in bytes */

 maximum LP transition time according to Scenario 1 */

 CLKIN4DDR = 16 * TXBYTECLKHS */

 XXX what values for the timeouts? */

 CS_RX_EN */

 ECC_RX_EN */

 TX_FIFO_ARBITRATION */

 VP_CLK_RATIO, always 1, see errata*/

 VP_DATA_BUS_WIDTH */

 VP_CLK_POL */

 TRIGGER_RESET_MODE */

 EOT_ENABLE */

 DCS_CMD_ENABLE */

 DCS_CMD_CODE, 1=start, 0=continue */

 min 8*UI */

 min 60ns + 52*UI */

 TODO: Implement a video mode check_timings function */

 TL = t_HS + HSA + t_HE + HFP + ceil((WC + 6) / NDL) + HBP */

 HBP */

 HFP */

 HSA */

 VBP */

 VFP */

 VSA */

 WINDOW_SYNC */

 VACT */

 TL */

 MODE, 1 = video mode */

 MODE, 0 = command mode */

	/* NOTE: packet_payload has to be equal to N * bytespl, where N is

 1 byte for DCS cmd */

 TE_SIZE */

 TE_EN */

 TE_START */

	/* We put SIDLEMODE to no-idle for the duration of the transfer,

	 * because DSS interrupts are not capable of waking up the CPU and the

	 * framedone interrupt could be delayed for quite a long time. I think

	 * the same goes for any DSS interrupts, but for some reason I have not

	 * seen the problem anywhere else than here.

		/* disable LP_RX_TO, so that we can receive TE.  Time to wait

 LP_RX_TO */

 SIDLEMODE back to smart-idle */

 enable LP_RX_TO again after the TE */

 LP_RX_TO */

	/* XXX While extremely unlikely, we could get FRAMEDONE interrupt after

	 * 250ms which would conflict with this timeout work. What should be

	 * done is first cancel the transfer on the HW, and then cancel the

	 * possibly scheduled framedone work. However, cancelling the transfer

	 * on the HW is buggy, and would probably require resetting the whole

	/* Note: We get FRAMEDONE when DISPC has finished sending pixels and

	 * turns itself off. However, DSI still has the pixels in its buffers,

	 * and is sending the data.

 Display funcs */

	/*

	 * override interlace, logic level and edge related parameters in

	 * omap_video_timings with default values

 enable interface */

 disable interface */

 pixel packet size */

 note: this is not quite accurate */

 PRINT_VERBOSE_VM_TIMINGS */

	/*

	 * Here we should calculate minimum txbyteclk to be able to send the

	 * frame in time, and also to handle TE. That's not very simple, though,

	 * especially as we go to LP between each pixel packet due to HW

	 * "feature". So let's just estimate very roughly and multiply by 1.5.

 pixels */

 pixels */

 byteclks */

	/*

	 * When there are no line buffers, DISPC and DSI must have the

	 * same tput. Otherwise DISPC tput needs to be higher than DSI's.

 DSI tput must be over the min requirement */

 When non-burst mode, DSI tput must be below max requirement. */

 DSI htot to match the panel's nominal pck */

 fail if there would be no time for blanking */

 total DSI blanking needed to achieve panel's TL */

 DISPC htot to match the DSI TL */

 verify that the DSI and DISPC TLs are the same */

 setup DSI videomode */

 we need to take cycles from hbp */

 we need to take cycles from hsa */

 setup DISPC videomode */

 we need to take cycles from hbp */

 we need to take cycles from hsa */

	/*

	 * In burst mode we can let the dispc pck be arbitrarily high, but it

	 * limits our scaling abilities. So for now, don't aim too high.

 these limits should come from the panel driver */

/*

 * Return a hardcoded channel for the DSI output. This should work for

 * current use cases, but this can be later expanded to either resolve

 * the channel in some more dynamic manner, or get the channel as a user

 * parameter.

 DSI1 HW IP initialisation */

 DSI VCs initialization */

	/* DSI on OMAP3 doesn't have register DSI_GNQ, set number

 NB_DATA_LANES */

 ensure the irq handler sees the is_enabled value */

 wait for current handler to finish before turning the DSI off */

 ensure the irq handler sees the is_enabled value */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * HDMI wrapper

 *

 * Copyright (C) 2013 Texas Instruments Incorporated

 flush posted write */

 PHY_PWR_CMD */

 Return if already the state */

 Command for power control of HDMI PHY */

 Status of the power control of HDMI PHY */

 PLL_PWR_CMD */

 Command for power control of HDMI PLL */

 wait till PHY_PWR_STATUS is set */

 HDMI_TIMING_MASTER_24BIT */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * HDMI PLL

 *

 * Copyright (C) 2013 Texas Instruments Incorporated

 Fint */

 adjust m2 so that the clkdco will be high enough */

 adjust clkdco with fractional mf */

 sigma-delta */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * linux/drivers/video/omap2/dss/manager.c

 *

 * Copyright (C) 2009 Nokia Corporation

 * Author: Tomi Valkeinen <tomi.valkeinen@nokia.com>

 *

 * Some code and ideas taken from drivers/video/omap/ driver

 * by Imre Deak.

		/*

		 * OMAP3 supports only graphics source transparency color key

		 * and alpha blending simultaneously. See TRM 15.4.2.4.2.2

		 * Alpha Mode.

 fifohandcheck should be used only with stallmode */

	/*

	 * io pad mode can be only checked by using dssdev connected to the

	 * manager. Ignore checking these for now, add checks when manager

	 * is capable of holding information related to the connected interface

 SPDX-License-Identifier: GPL-2.0-only

/*

* Copyright (C) 2014 Texas Instruments Ltd

 CIO_CLK_ICG */

 CIO_CLK_ICG */

 PLL_POWER_ON_ALL */

	/*

	 * DRA7x PLL CTRL's PLL_PWR_STATUS seems to always return 0,

	 * so we have to use fixed delay here.

 PLL_POWER_OFF */

 PLL CONTROL */

 CLOCK CONTROL */

 CLKIN */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * HDMI interface DSS driver for TI's OMAP4 family of SoCs.

 * Copyright (C) 2010-2011 Texas Instruments Incorporated - https://www.ti.com/

 * Authors: Yong Zhi

 *	Mythri pk <mythripk@ti.com>

		/*

		 * If we get both connect and disconnect interrupts at the same

		 * time, turn off the PHY, clear interrupts, and restart, which

		 * raises connect interrupt if a cable is connected, or nothing

		 * if cable is not connected.

 Make selection of HDMI in DSS */

 disable and clear irqs */

 bypass TV gamma table */

 tv size */

 Audio callbacks */

 HDMI HW IP initialisation */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2014 Texas Instruments

 * Author: Tomi Valkeinen <tomi.valkeinen@ti.com>

/*

 * As omapdss panel drivers are omapdss specific, but we want to define the

 * DT-data in generic manner, we convert the compatible strings of the panel and

 * encoder nodes from "panel-foo" to "omapdss,panel-foo". This way we can have

 * both correct DT data and omapdss specific drivers.

 *

 * When we get generic panel drivers to the kernel, this file will be removed.

 prepend compatible property strings with "omapdss," */

 is it already prefixed? */

	/*

	 * of_graph_get_remote_port_parent() prints an error if there is no

	 * port/ports node. To avoid that, check first that there's the node.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2012 Texas Instruments

 * Author: Tomi Valkeinen <tomi.valkeinen@ti.com>

 dispc.irq_lock has to be locked by the caller */

 check for duplicate entry */

 found the correct isr */

/* Called from dss.c. Note that we don't touch clocks here,

 * but we presume they are on because we got an IRQ. However,

 * an irq handler may turn the clocks off, so we may not have

 IRQ is not for us */

	/* Ack the interrupt. Do it here before clocks are possibly turned

 flush posted write */

	/* make a copy and unlock, so that isrs can unregister

	/*

	 * there's SYNC_LOST_DIGIT waiting after enabling the DSS,

	 * so clear it

	/*

	 * When we disable LCD output, we need to wait for FRAMEDONE to know

	 * that DISPC has finished with the LCD output.

 if we couldn't register for framedone, just sleep and exit */

 ignore any sync lost interrupts */

	/*

	 * Digit output produces some sync lost interrupts during the first

	 * frame when enabling. Those need to be ignored, so we register for the

	 * sync lost irq to prevent the error handler from triggering.

 wait for the first evsync */

	/*

	 * When we disable the digit output, we need to wait for FRAMEDONE to

	 * know that DISPC has finished with the output.

		/*

		 * omap 2/3 don't have framedone irq for TV, so we need to use

		 * vsyncs for this.

		/*

		 * We need to wait for both even and odd vsyncs. Note that this

		 * is not totally reliable, as we could get a vsync interrupt

		 * before we disable the output, which leads to timeout in the

		 * wait_for_completion.

 if we couldn't register the irq, just sleep and exit */

 SPDX-License-Identifier: GPL-2.0

 TODO: When implemented, query deep color mode here. */

	/*

	 * When using deep color, the default N value (as in the HDMI

	 * specification) yields to an non-integer CTS. Hence, we

	 * modify it while keeping the restrictions described in

	 * section 7.2.1 of the HDMI 1.4a specification.

 Calculate CTS. See HDMI 1.3a or 1.4a specifications */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * linux/drivers/video/omap2/dss/dss_features.c

 *

 * Copyright (C) 2010 Texas Instruments

 * Author: Archit Taneja <archit@ti.com>

 Defines a generic omap register field */

 This struct is assigned to one of the below during initialization */

 OMAP_DSS_CHANNEL_LCD */

 OMAP_DSS_CHANNEL_DIGIT */

 OMAP_DSS_CHANNEL_LCD */

 OMAP_DSS_CHANNEL_DIGIT */

 OMAP_DSS_CHANNEL_LCD */

 OMAP_DSS_CHANNEL_DIGIT */

 OMAP_DSS_CHANNEL_LCD */

 OMAP_DSS_CHANNEL_LCD */

 OMAP_DSS_CHANNEL_DIGIT */

 OMAP_DSS_CHANNEL_LCD2 */

 OMAP_DSS_CHANNEL_LCD */

 OMAP_DSS_CHANNEL_DIGIT */

 OMAP_DSS_CHANNEL_LCD2 */

 OMAP_DSS_CHANNEL_LCD */

 OMAP_DSS_CHANNEL_DIGIT */

 OMAP_DSS_CHANNEL_LCD */

 OMAP_DSS_CHANNEL_DIGIT */

 OMAP_DSS_CHANNEL_LCD */

 OMAP_DSS_CHANNEL_DIGIT */

 OMAP_DSS_CHANNEL_LCD */

 OMAP_DSS_CHANNEL_LCD */

 OMAP_DSS_CHANNEL_DIGIT */

 OMAP_DSS_CHANNEL_LCD2 */

 OMAP_DSS_CHANNEL_LCD */

 OMAP_DSS_CHANNEL_DIGIT */

 OMAP_DSS_CHANNEL_LCD2 */

 OMAP_DSS_CHANNEL_LCD3 */

 OMAP_DSS_GFX */

 OMAP_DSS_VIDEO1 */

 OMAP_DSS_VIDEO2 */

 OMAP_DSS_GFX */

 OMAP_DSS_VIDEO1 */

 OMAP_DSS_VIDEO2 */

 OMAP_DSS_GFX */

 OMAP_DSS_VIDEO1 */

 OMAP_DSS_VIDEO2 */

 OMAP_DSS_VIDEO3 */

 OMAP_DSS_WB */

 OMAP_DSS_GFX */

 OMAP_DSS_VIDEO1 */

 OMAP_DSS_VIDEO2 */

 OMAP_DSS_GFX */

 OMAP_DSS_VIDEO1 */

 OMAP_DSS_VIDEO2 */

 OMAP_DSS_GFX */

 OMAP_DSS_VIDEO1 */

 OMAP_DSS_VIDEO2 */

 OMAP_DSS_GFX */

 OMAP_DSS_VIDEO1 */

 OMAP_DSS_VIDEO2 */

 OMAP_DSS_VIDEO3 */

	/*

	 * Assuming the line width buffer to be 768 pixels as OMAP2 DISPC

	 * scaler cannot scale a image with width more than 768.

 OMAP2 DSS Features */

 OMAP3 DSS Features */

/*

 * AM35xx DSS Features. This is basically OMAP3 DSS Features without the

 * vdds_dsi regulator.

 OMAP4 DSS Features */

 For OMAP4430 ES 1.0 revision */

 For OMAP4430 ES 2.0, 2.1 and 2.2 revisions */

 For all the other OMAP4 versions */

 OMAP5 DSS Features */

 Functions returning values related to a DSS feature */

 DSS has_feature check */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * linux/drivers/video/omap2/dss/dss.c

 *

 * Copyright (C) 2009 Nokia Corporation

 * Author: Tomi Valkeinen <tomi.valkeinen@nokia.com>

 *

 * Some code and ideas taken from drivers/video/omap/ driver

 * by Imre Deak.

 SDI_PDIV */

 SDI_PRSEL */

 SDI_BWSEL */

 SDI_PLL_FREQSEL */

 SDI_PLL_REGN */

 SDI_PLL_REGM */

 Reset SDI PLL */

 SDI_PLL_SYSRESET */

 wait 2x PCLK */

 Lock SDI PLL */

 SDI_PLL_GOBIT */

 Waiting for PLL lock request to complete */

 Clearing PLL_GO bit */

 Waiting for PLL to lock */

 Waiting for SDI reset to complete */

 Reset SDI PLL */

 SDI_PLL_SYSRESET */

 Reset SDI PLL */

 SDI_PLL_SYSRESET */

 DISPC_CLK_SWITCH */

 DSIx_CLK_SWITCH */

 LCDx_CLK_SWITCH */

		/* LCD_CLK source is the same as DISPC_FCLK source for

 venc out selection. 0 = comp, 1 = svideo */

 DAC Power-Down Control */

 Complain about invalid selections */

 Select only if we have options */

 VENC_HDMI_SWITCH */

 DEBUGFS */

	/*

	 * fck div max is really 16, but the divider range has gaps. The range

	 * from 1 to 6 has no gaps, so let's use that as a max.

 DSS HW IP initialisation */

 Select DPLL */

 venc dac demen */

 venc clock 4x enable */

 venc clock mode = normal */

	/*

	 * HACK

	 * We don't have a working driver for rfbi, so skip it here always.

	 * Otherwise dss will never get probed successfully, as it will wait

	 * for rfbi to get probed.

 add all the child devices as components */

	/*

	 * Set an arbitrarily high tput request to ensure OPP100.

	 * What we should really do is to make a request to stay in OPP100,

	 * without any tput requirements, but that is not currently possible

	 * via the PM layer.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2011 Texas Instruments

 * Author: Tomi Valkeinen <tomi.valkeinen@ti.com>

/*

 * We have 4 levels of cache for the dispc settings. First two are in SW and

 * the latter two in HW.

 *

 *       set_info()

 *          v

 * +--------------------+

 * |     user_info      |

 * +--------------------+

 *          v

 *        apply()

 *          v

 * +--------------------+

 * |       info         |

 * +--------------------+

 *          v

 *      write_regs()

 *          v

 * +--------------------+

 * |  shadow registers  |

 * +--------------------+

 *          v

 * VFP or lcd/digit_enable

 *          v

 * +--------------------+

 * |      registers     |

 * +--------------------+

	/*

	 * True if overlay is to be enabled. Used to check and calculate configs

	 * for the overlay before it is enabled in the HW.

	/* If true, GO bit is up and shadow registers cannot be written.

 If true, dispc output is enabled */

 If true, a display is enabled using this manager */

 protects dss_data */

 lock for blocking functions */

	/*

	 * Initialize some of the lcd_config fields for TV manager, this lets

	 * us prevent checking if the manager is LCD or TV at some places

/*

 * A LCD manager's stallmode decides whether it is in manual or auto update. TV

 * manager is always auto update, stallmode field for TV manager is false by

 * default

 collect the infos to be tested into the array */

/*

 * check manager and overlay settings using overlay_info from data->info

/*

 * check manager and overlay settings using overlay_info from ovl->info if

 * dirty and from data->info otherwise

 to catch FRAMEDONE */

 to catch GO bit going down */

 to write new values to registers */

 to set GO bit */

			/*

			 * NOTE: we don't check extra_info flags for disabled

			 * managers, once the manager is enabled, the extra_info

			 * related manager changes will be taken in by HW.

 to write new values to registers */

 to set GO bit */

				/*

				 * NOTE: we check extra_info flags even for

				 * disabled overlays, as extra_infos need to be

				 * always written.

 to write new values to registers */

 to set GO bit */

 to write new values to registers */

 to set GO bit */

 returns true if an extra_info field is currently being updated */

 wait until no extra_info updates are pending */

		/* 4 iterations is the worst case:

		 * 1 - initial iteration, dirty = true (between VFP and VSYNC)

		 * 2 - first VSYNC, dirty = true

		 * 3 - dirty = false, shadow_dirty = true

		/* 4 iterations is the worst case:

		 * 1 - initial iteration, dirty = true (between VFP and VSYNC)

		 * 2 - first VSYNC, dirty = true

		 * 3 - dirty = false, shadow_dirty = true

		/*

		 * We can't do much here, as this function can be called from

		 * vsync interrupt.

 This will leave fifo configurations in a nonoptimal state */

	/* note: write also when op->enabled == false, so that the ovl gets

 Commit overlay settings */

 lcd_config parameters */

 clear busy, updating flags, shadow_dirty flags */

 call framedone handlers for manual update displays */

 Configure overlays */

 Configure manager */

 wait for pending extra_info updates to ensure the ovl is disabled */

	/*

	 * For a manual update display, there is no guarantee that the overlay

	 * is really disabled in HW, we may need an extra update from this

	 * manager before the configurations can go in. Return an error if the

	 * overlay needed an update from the manager.

	 *

	 * TODO: Instead of returning an error, try to do a dummy manager update

	 * here to disable the overlay in hardware. Use the *GATED fields in

	 * the DISPC_CONFIG registers to do a dummy update.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2009 Nokia Corporation

 * Author: Tomi Valkeinen <tomi.valkeinen@nokia.com>

 *

 * Some code and ideas taken from drivers/video/omap/ driver

 * by Imre Deak.

 detach old manager */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2009 Nokia Corporation

 * Author: Tomi Valkeinen <tomi.valkeinen@nokia.com>

 *

 * Some code and ideas taken from drivers/video/omap/ driver

 * by Imre Deak.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2014 Texas Instruments Incorporated

 first busyloop to see if the bit changes right away */

 then loop for 500ms, sleeping for 1ms in between */

 PLL_STOPMODE */

 PLL_REGN */

 PLL_REGM */

 M4 */

 M5 */

 M6 */

 M7 */

 PLL_FREQSEL */

 PLL_SELFREQDCO */

 PLL_REFEN */

 PHY_CLKINEN */

 M4_CLOCK_EN */

 M5_CLOCK_EN */

 HSDIVBYPASS */

 REFSEL = sysclk */

 M6_CLOCK_EN */

 M7_CLOCK_EN */

 PLL_GO */

 PHY_CLKINEN */

 M4_CLOCK_EN */

 M5_CLOCK_EN */

 HSDIVBYPASS */

 M6_CLOCK_EN */

 M7_CLOCK_EN */

 PLL_REGM */

 PLL_REGN */

 PLL_HIGHFREQ divide by 2 */

 PLL_REFEN */

 PHY_CLKINEN */

 REFSEL = SYSCLK */

 PLL_SELFREQDCO */

 PLL_REGSD */

 PLL_REGM2 */

 PLL_REGM_F */

 PLL_GO */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ti_hdmi_4xxx_ip.c

 *

 * HDMI TI81xx, TI38xx, TI OMAP4 etc IP driver Library

 * Copyright (C) 2010-2011 Texas Instruments Incorporated - https://www.ti.com/

 * Authors: Yong Zhi

 *	Mythri pk <mythripk@ti.com>

 Turn on CLK for DDC */

 IN_PROG */

 Abort transaction */

 IN_PROG */

 Clk SCL Devices */

 HDMI_CORE_DDC_STATUS_IN_PROG */

 Clear FIFO */

 HDMI_CORE_DDC_STATUS_IN_PROG */

 HDMI_CORE_DDC_STATUS_IN_PROG */

 Load Segment Address Register */

 Load Slave Address Register */

 Load Offset Address Register */

 Load Byte Count */

 Set DDC_CMD */

 HDMI_CORE_DDC_STATUS_BUS_LOW */

 HDMI_CORE_DDC_STATUS_NO_ACK */

 IN_PROG */

 FIFO_EMPTY */

 video core */

 HDMI_CORE_VIDEO_CONFIG */

 sys_ctrl1 default configuration not tunable */

 Vid_Mode */

 dither truncation configuration */

 HDMI_Ctrl */

 TMDS_CTRL */

 enable/repeat the infoframe */

 enable/repeat the packet */

 HDMI */

 HDMI core */

 video config */

	/*

	 * configure core video part

	 * set software reset in the core

 power down off */

 release software reset in the core */

 enable/repeat the infoframe */

 wakeup */

	/*

	 * Parameters for generation of Audio Clock Recovery packets

 Set ACR clock divisor */

	/*

	 * Use TMDS clock for ACR packets. For devices that use

	 * the MCLK, this is the first part of the MCLK initialization.

 For devices using MCLK, this completes its initialization. */

 Override of SPDIF sample frequency with value in I2S_CHST4 */

	/*

	 * Set IEC-60958-3 channel status word. It is passed to the IP

	 * just as it is received. The user of the driver is responsible

	 * for its contents.

 yes, this is correct: status[3] goes to CHST4 register */

 yes, this is correct: status[4] goes to CHST5 register */

 set I2S parameters */

 Audio channels and mode parameters */

 Audio channel mappings */

	/* TODO: Make channel mapping dynamic. For now, map channels

	 * in the ALSA order: FL/FR/RL/RR/C/LFE/SL/SR. Remapping is needed as

	 * HDMI speaker order is different. See CEA-861 Section 6.6.2.

	/*

	 * Set audio info frame type, version and length as

	 * described in HDMI 1.4a Section 8.2.2 specification.

	 * Checksum calculation is defined in Section 5.3.5.

	/*

	 * The OMAP HDMI IP requires to use the 8-channel channel code when

	 * transmitting more than two channels.

	/*

	 * TODO: Add MPEG and SPD enable and repeat cfg when EDID parsing

	 * is available.

	/*

	 * In the IEC-60958 status word, check if the audio sample word length

	 * is 16-bit as several optimizations can be performed in such case.

 I2S configuration. See Phillips' specification */

	/*

	 * The I2S input word length is twice the length given in the IEC-60958

	 * status word. If the word size is greater than

	 * 20 bits, increment by one.

 convert sample frequency to a number */

 Audio clock regeneration settings */

 Audio channels settings */

	/*

	 * the HDMI IP needs to enable four stereo channels when transmitting

	 * more than 2 audio channels.  Similarly, the channel count in the

	 * Audio InfoFrame has to match the sample_present bits (some channels

	 * are padded with zeroes)

 use sample frequency from channel status word */

 enable ACR packets */

 disable direct streaming digital audio */

 use parallel audio interface */

 DMA settings */

 in number of samples */

 audio FIFO format settings */

 disable start/stop signals of IEC 60958 blocks */

 configure DMA and audio FIFO format*/

 configure the core*/

 configure CEA 861 audio infoframe*/

 SPDX-License-Identifier: GPL-2.0-only

/*

 * linux/drivers/video/omap2/dss/core.c

 *

 * Copyright (C) 2009 Nokia Corporation

 * Author: Tomi Valkeinen <tomi.valkeinen@nokia.com>

 *

 * Some code and ideas taken from drivers/video/omap/ driver

 * by Imre Deak.

 CONFIG_FB_OMAP2_DSS_DEBUGFS */

 CONFIG_FB_OMAP2_DSS_DEBUGFS */

 PLATFORM DEVICE */

 INIT */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * linux/drivers/video/omap2/dss/overlay.c

 *

 * Copyright (C) 2009 Nokia Corporation

 * Author: Tomi Valkeinen <tomi.valkeinen@nokia.com>

 *

 * Some code and ideas taken from drivers/video/omap/ driver

 * by Imre Deak.

/*

 * Checks if replication logic should be used. Only use when overlay is in

 * RGB12U or RGB16 mode, and video port width interface is 18bpp or 24bpp

 SPDX-License-Identifier: GPL-2.0-only

/*

 * linux/drivers/video/omap2/dss/sdi.c

 *

 * Copyright (C) 2009 Nokia Corporation

 * Author: Tomi Valkeinen <tomi.valkeinen@nokia.com>

	/*

	 * DSS fclk gives us very few possibilities, so finding a good pixel

	 * clock may not be possible. We try multiple times to find the clock,

	 * each time widening the pixel clock range we look for, up to

	 * +/- 1MHz.

 15.5.9.1.2 */

	/*

	 * LCLK and PCLK divisors are located in shadow registers, and we

	 * normally write them to DISPC registers when enabling the output.

	 * However, SDI uses pck-free as source clock for its PLL, and pck-free

	 * is affected by the divisors. And as we need the PLL before enabling

	 * the output, we need to write the divisors early.

	 *

	 * It seems just writing to the DISPC register is enough, and we don't

	 * need to care about the shadow register mechanism for pck-free. The

	 * exact reason for this is unknown.

 We have SDI only on OMAP3, where it's on port 1 */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * HDMI PHY

 *

 * Copyright (C) 2013 Texas Instruments Incorporated

	/*

	 * Read address 0 in order to get the SCP reset done completed

	 * Dummy access performed to make sure reset is done

	/*

	 * In OMAP5+, the HFBITCLK must be divided by 2 before issuing the

	 * HDMI_PHYPWRCMD_LDOON command.

	/*

	 * If the hfbitclk != lfbitclk, it means the lfbitclk was configured

	 * to be used for TMDS.

	/*

	 * Write to phy address 0 to configure the clock

	 * use HFBITCLK write HDMI_TXPHY_TX_CONTROL_FREQOUT field

 Write to phy address 1 to start HDMI line (TXVALID and TMDSCLKEN) */

 Setup max LDO voltage */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * linux/drivers/video/omap2/dss/dpi.c

 *

 * Copyright (C) 2009 Nokia Corporation

 * Author: Tomi Valkeinen <tomi.valkeinen@nokia.com>

 *

 * Some code and ideas taken from drivers/video/omap/ driver

 * by Imre Deak.

 only used in non-DT mode */

	/*

	 * XXX we can't currently use DSI PLL for DPI with OMAP3, as the DSI PLL

	 * would also be used for DISPC fclk. Meaning, when the DPI output is

	 * disabled, DISPC clock will be disabled, and TV out will stop.

 this shouldn't happen */

 inputs */

 outputs */

	/*

	 * Odd dividers give us uneven duty cycle, causing problem when level

	 * shifted. So skip all odd dividers when the pixel clock is on the

	 * higher side.

	/*

	 * Odd dividers give us uneven duty cycle, causing problem when level

	 * shifted. So skip all odd dividers when the pixel clock is on the

	 * higher side.

	/*

	 * DSS fck gives us very few possibilities, so finding a good pixel

	 * clock may not be possible. We try multiple times to find the clock,

	 * each time widening the pixel clock range we look for, up to

	 * +/- ~15MHz.

 do initial setup with the PLL to see if it is operational */

 On DRA7 we need to set a mux to use the PLL */

/*

 * Return a hardcoded channel for the DPI output. This should work for

 * current use cases, but this can be later expanded to either resolve

 * the channel in some more dynamic manner, or get the channel as a user

 * parameter.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2013 Texas Instruments

 * Author: Tomi Valkeinen <tomi.valkeinen@ti.com>

		/*

		 * It's the first call, we have to find a port subnode

		 * within this node or within an optional 'ports' node.

 release the 'ports' node */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * TPO TD043MTEA1 Panel driver

 *

 * Author: Gražvydas Ignotas <notasas@gmail.com>

 * Converted to new DSS device model: Tomi Valkeinen <tomi.valkeinen@ti.com>

 gamma bits [9:8] */

 gamma bits [7:0] */

 wait for panel to stabilize */

 wait for at least 2 vsyncs before cutting off power */

	/*

	 * If we are resuming from system suspend, SPI clocks might not be

	 * enabled yet, so we'll program the LCD from SPI PM resume callback.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * TPD12S015 HDMI ESD protection & level shifter chip driver

 *

 * Copyright (C) 2013 Texas Instruments

 * Author: Tomi Valkeinen <tomi.valkeinen@ti.com>

 DC-DC converter needs at max 300us to get to 90% of 5V */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * HDMI Connector driver

 *

 * Copyright (C) 2013 Texas Instruments

 * Author: Tomi Valkeinen <tomi.valkeinen@ti.com>

 HPD GPIO */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * LCD panel driver for Sharp LS037V7DW01

 *

 * Copyright (C) 2013 Texas Instruments

 * Author: Tomi Valkeinen <tomi.valkeinen@ti.com>

 low = reset active min 20 us */

 high = power on */

 low = 480x640, high = 240x320 */

 high = conventional horizontal scanning */

 high = conventional vertical scanning */

 wait couple of vsyncs until enabling the LCD */

 wait at least 5 vsyncs after disabling the LCD */

 lcd INI */

 lcd RESB */

 lcd MO */

 lcd LR */

 lcd UD */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * LG.Philips LB035Q02 LCD Panel driver

 *

 * Copyright (C) 2013 Texas Instruments

 * Author: Tomi Valkeinen <tomi.valkeinen@ti.com>

 * Based on a driver by: Steve Sakoman <steve@sakoman.com>

 used for non-DT boot, to be removed */

 register index */

 register value */

 Init sequence from page 28 of the lb035q02 spec */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * TFP410 DPI-to-DVI encoder driver

 *

 * Copyright (C) 2013 Texas Instruments

 * Author: Tomi Valkeinen <tomi.valkeinen@ti.com>

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * NEC NL8048HL11 Panel driver

 *

 * Copyright (C) 2010 Texas Instruments Inc.

 * Author: Erik Gilling <konkers@android.com>

 * Converted to new DSS device model: Tomi Valkeinen <tomi.valkeinen@ti.com>

/*

 * NEC PIX Clock Ratings

 * MIN:21.8MHz TYP:23.8MHz MAX:25.7MHz

 register address write */

 register data write */

 Initialization Sequence */

 nec_8048_spi_send(spi, REG, VAL) */

 XXX the panel spec doesn't mention any QVGA pin?? */

 reinitialize the panel */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * OPA362 analog video amplifier with output/power control

 *

 * Copyright (C) 2014 Golden Delicious Computers

 * Author: H. Nikolaus Schaller <hns@goldelico.com>

 *

 * based on encoder-tfp410

 *

 * Copyright (C) 2013 Texas Instruments

 * Author: Tomi Valkeinen <tomi.valkeinen@ti.com>

 we can only drive a COMPOSITE output */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Generic MIPI DPI Panel Driver

 *

 * Copyright (C) 2013 Texas Instruments

 * Author: Tomi Valkeinen <tomi.valkeinen@ti.com>

 used for non-DT boot, to be removed */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Generic DSI Command Mode panel driver

 *

 * Copyright (C) 2013 Texas Instruments

 * Author: Tomi Valkeinen <tomi.valkeinen@ti.com>

 #define DEBUG */

 DSI Virtual channel. Hardcoded for now. */

	unsigned long	hw_guard_end;	/* next value of jiffies when we can

					 * issue the next sleep in/out command

 max guard time in jiffies */

 panel HW configuration from DT or platform data */

 runtime variables */

 dsicm_wake_up will restart the timer */

 reset the panel */

 assert reset */

 wait after releasing reset */

 BL | BCTRL */

 XXX no need to send this every frame, but dsi break if not done */

 note: no bus_unlock here. unlock is in framedone_cb */

 possible panel bug */

	/* plen 1 or 2 goes into short packet. until checksum error is fixed,

	 * use short packets. plen 32 works, but bigger packets seem to cause

 TODO: ulps, backlight */

 reset, to be sure that the panel is in a valid state */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Sony ACX565AKM LCD Panel driver

 *

 * Copyright (C) 2010 Nokia Corporation

 *

 * Original Driver Author: Imre Deak <imre.deak@nokia.com>

 * Based on panel-generic.c by Tomi Valkeinen <tomi.valkeinen@nokia.com>

 * Adapted to new DSS2 framework: Roger Quadros <roger.quadros@nokia.com>

	unsigned long	hw_guard_end;		/* next value of jiffies

						   when we can issue the

 max guard time in jiffies */

		/*

		 * Between the command and the response data there is a

		 * dummy clock cycle. Add an extra bit after the command

		 * word to account for this.

	/*

	 * We have to keep 120msec between sleep in/out commands.

	 * (8.2.15, 8.2.16).

----------------------Backlight Control-------------------------*/

--------------------Auto Brightness control via Sysfs---------------------*/

 always used when CABC is not supported */

FIXME tweak me */

	/*

	 * We have to meet all the following delay requirements:

	 * 1. tRW: reset pulse width 10usec (7.12.1)

	 * 2. tRT: reset cancel time 5msec (7.12.1)

	 * 3. Providing PCLK,HS,VS signals for 2 frames = ~50msec worst

	 *    case (7.6.2)

	 * 4. 120msec before the sleep out command (7.12.1)

 5msec between sleep out and the next command. (8.2.16) */

	/*

	 * We have to provide PCLK,HS,VS signals for 2 frames (worst case

	 * ~50msec) after sending the sleep in command and asserting the

	 * reset signal. We probably could assert the reset w/o the delay

	 * but we still delay to avoid possible artifacts. (7.6.1)

 FIXME need to tweak this delay */

	/*

	 * After reset we have to wait 5 msec before the first

	 * command can be sent.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Toppoly TD028TTEC1 panel support

 *

 * Copyright (C) 2008 Nokia Corporation

 * Author: Tomi Valkeinen <tomi.valkeinen@nokia.com>

 *

 * Neo 1973 code (jbt6k74.c):

 * Copyright (C) 2006-2007 by OpenMoko, Inc.

 * Author: Harald Welte <laforge@openmoko.org>

 *

 * Ported and adapted from Neo 1973 U-Boot by:

 * H. Nikolaus Schaller <hns@goldelico.com>

 three times command zero */

 deep standby out */

 RGB I/F on, RAM write off, QVGA through, SIGCON enable */

 Quad mode off */

 AVDD on, XVDD on */

 Output control */

 Sleep mode off */

 at this point we have like 50% grey */

 initialize register set */

	/*

	 * default of 0x02 in JBT_REG_ASW_SLEW responsible for 72Hz requirement

	 * to avoid red / blue flicker

 keep to not break older DTB */

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Generic DVI Connector driver

 *

 * Copyright (C) 2013 Texas Instruments

 * Author: Tomi Valkeinen <tomi.valkeinen@ti.com>

 if there are extensions, read second block */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Analog TV Connector driver

 *

 * Copyright (C) 2013 Texas Instruments

 * Author: Tomi Valkeinen <tomi.valkeinen@ti.com>

 $XFree86$ */

 $XdotOrg$ */

/*

 * Mode initializing code (CRT2 section)

 * for SiS 300/305/540/630/730,

 *     SiS 315/550/[M]650/651/[M]661[FGM]X/[M]74x[GX]/330/[M]76x[GX],

 *     XGI V3XT/V5/V8, Z7

 * (Universal module for Linux kernel framebuffer and X.org/XFree86 4.x)

 *

 * Copyright (C) 2001-2005 by Thomas Winischhofer, Vienna, Austria

 *

 * If distributed as part of the Linux kernel, the following license terms

 * apply:

 *

 * * This program is free software; you can redistribute it and/or modify

 * * it under the terms of the GNU General Public License as published by

 * * the Free Software Foundation; either version 2 of the named License,

 * * or any later version.

 * *

 * * This program is distributed in the hope that it will be useful,

 * * but WITHOUT ANY WARRANTY; without even the implied warranty of

 * * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the

 * * GNU General Public License for more details.

 * *

 * * You should have received a copy of the GNU General Public License

 * * along with this program; if not, write to the Free Software

 * * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA

 *

 * Otherwise, the following license terms apply:

 *

 * * Redistribution and use in source and binary forms, with or without

 * * modification, are permitted provided that the following conditions

 * * are met:

 * * 1) Redistributions of source code must retain the above copyright

 * *    notice, this list of conditions and the following disclaimer.

 * * 2) Redistributions in binary form must reproduce the above copyright

 * *    notice, this list of conditions and the following disclaimer in the

 * *    documentation and/or other materials provided with the distribution.

 * * 3) The name of the author may not be used to endorse or promote products

 * *    derived from this software without specific prior written permission.

 * *

 * * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR

 * * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES

 * * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.

 * * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,

 * * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT

 * * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,

 * * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY

 * * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT

 * * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF

 * * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 *

 * Author: 	Thomas Winischhofer <thomas@winischhofer.net>

 *

 * Formerly based on non-functional code-fragements for 300 series by SiS, Inc.

 * Used by permission.

 *

 302LV/ELV: Set EMI values */

 301/302LV: Set PWD */

 Needed for Compal 1400x1050 (EMI) */

 Needed for Inventec/Compaq 1280x1024 (EMI) */

 Needed for Asus A2H 1024x768 (EMI) */

0x8d*/,0x08,0x92,0x8f,0x40,

0x50*/,

 OK, but sticks to left edge */

0x2b*/,0x13,

0x6f*/,0x2f,0x63,0x92,0x0f,0x40,

 Perfect */

 0x00 SiS_NTSCPhase */

 0x01 SiS_PALPhase */

 0x02 SiS_PALMPhase */

 0x03 SiS_PALNPhase */

 0x05 SiS_SpecialPhaseM */

 0x08 SiS_NTSCPhase2 */

 0x09 SiS_PALPhase2 */

 0x0a SiS_PALMPhase2 */

 0x0b SiS_PALNPhase2 */

 0x0d SiS_SpecialPhaseM */

 0x10 SiS_SpecialPhase */

 0x11 SiS_SpecialPhaseJ */

 301C / 302ELV extended Part2 TV registers (4 tap scaler) */

 NTSC, 525i, 525p */

 PAL */

 750p */

 1080i */

 661 et al LCD data structure (2.03.00) */

 1024x768 */

  type|CR37|   HDE   |   VDE   |    HT   |    VT   |   hss    | hse   */

  | vss     |    vse  |clck|  clock  |CRT2DataP|CRT2DataP|idx     */

					      VESA    non-VESA  noscale */

 1280x1024 */

 1400x1050 */

 1600x1200 */

 1280x768 (_2) */

 1280x720 */

 1280x800 (_2) */

 1680x1050 */

 1280x800_3 */

 800x600 */

 1280x854 */

 variant 2 */

 315 */

********************************************/

         HELPER: Lock/Unlock CRT2          */

********************************************/

********************************************/

            HELPER: Write SR11             */

********************************************/

********************************************/

    HELPER: Get Pointer to LCD structure   */

********************************************/

   /* Use the BIOS tables only for LVDS panels; TMDS is unreliable

    * due to the variaty of panels the BIOS doesn't know about.

    * Exception: If the BIOS has better knowledge (such as in case

    * of machines with a 301C and a panel that does not support DDC)

    * use the BIOS data as well.

   /* Use the BIOS tables only for LVDS panels; TMDS is unreliable

    * due to the variaty of panels the BIOS doesn't know about.

    * Exception: If the BIOS has better knowledge (such as in case

    * of machines with a 301C and a panel that does not support DDC)

    * use the BIOS data as well.

********************************************/

           Adjust Rate for CRT2            */

********************************************/

 LVDS */

 Look backwards in table for matching CRT2 mode */

   /* Look through the whole mode-section of the table from the beginning

    * for a matching CRT2 mode if no mode was found yet.

********************************************/

              Get rate index               */

********************************************/

 Do NOT check for UseCustomMode here, will skrew up FIFO */

********************************************/

            STORE CRT2 INFO in CR34        */

********************************************/

 Store CRT1 ModeNo in CR34 */

********************************************/

    HELPER: GET SOME DATA FROM BIOS ROM    */

********************************************/

********************************************/

          HELPER: DELAY FUNCTIONS          */

********************************************/

 CONFIG_FB_SIS_300 */

 315 series, LVDS; Special */

 315 series, all bridges */

 CONFIG_FB_SIS_315 */

********************************************/

    HELPER: WAIT-FOR-RETRACE FUNCTIONS     */

********************************************/

********************************************/

               HELPER: MISC                */

********************************************/

 Check for revision != A0 only */

 YPrPb = 0x08 */

 Scart = 0x04 */

 = YPrPb = 0x08 */

 = Scart = 0x04 - TW */

********************************************/

       GET VIDEO BRIDGE CONFIG INFO        */

********************************************/

 Setup general purpose IO for Chrontel communication */

 ACPI register 0x3c: GP Event 1 I/O mode select */

 ACPI register 0x3a: GP Pin Level (low/high) */

 Mode 0x03 is never in driver mode */

 Reset LCDA setting if not driver mode */

 New CR layout */

 CONFIG_FB_SIS_315 */

 LVDS/CHRONTEL (LCD/TV) and 301BDH (LCD) can only be slave in 8bpp modes */

********************************************/

           DETERMINE YPbPr MODE            */

********************************************/

   /* Note: This variable is only used on 30xLV systems.

    * CR38 has a different meaning on LVDS/CH7019 systems.

    * On 661 and later, these bits moved to CR35.

    *

    * On 301, 301B, only HiVision 1080i is supported.

    * On 30xLV, 301C, only YPbPr 1080i is supported.

********************************************/

           DETERMINE TVMode flag           */

********************************************/

 0x40 */

 0x80 */

 0x40 */

 Translate HiVision/YPbPr to our new flags */

 661 and later */

********************************************/

               GET LCD INFO                */

********************************************/

 Translate my LCDResInfo to BIOS value */

 HSync start */

 HSync end */

 VSync start */

 VSync end */

 Alternative 1600x1200@60 timing for 1600x1200 LCDA */

 For broken BIOSes: Assume 1024x768 */

 Very old BIOSes only know 7 sizes (NetVista 2179, 1.01g) */

 Translate 300 series LCDRes to 315 series for unified usage */

 Translate to our internal types */

 Verified working */

 SiS LVDS */

 Need temp below! */

 These must/can't scale no matter what */

 Dual link, Pass 1:1 BIOS default, etc. */

 Pass 1:1 */

 Always center screen on LVDS (if scaling is disabled) */

 Always center screen on SiS LVDS (if scaling is disabled) */

 By default, pass 1:1 on SiS TMDS (if scaling is supported) */

 88 */ ; SiS_Pr->PanelVRE  =    6;

 Data above for TMDS (projector); get from BIOS for LVDS */

 ? */

 ? */

 Special cases */

 DontExpand overrule */

 No scaling for this mode on any panel (LCD=CRT2)*/

 TMDS only */

 LVDS only */

 SiS TMDS special (Averatec 6200 series) */

 SiS LVDS */

 SiS LVDS */

 neg h/v sync, RGB24(D0 = 0) */

 Special cases */

 Don't pass 1:1 by default (TMDS special) */

 (In)validate LCDPass11 flag */

 LVDS DDA */

 VESA timing */

********************************************/

                 GET VCLK                  */

********************************************/

 30x/B/LV */

  LCD */

 Correct those whose IndexGEN doesn't match VBVCLK array */

  TV */

 VGA2 */

 Better VGA2 clock for 1280x1024@75 */

 If not programming CRT2 */

   LVDS  */

 Special Timing: Barco iQ Pro R series */

 Special Timing: 848x480 and 856x480 parallel lvds panels */

 if(resinfo == SIS_RI_1360x768) VCLKIndex = ?; */

 if(resinfo == SIS_RI_1360x768) VCLKIndex = ?; */

 if not programming CRT2 */

 1024x768-70 */

 1024x768-75 */

********************************************/

        SET CRT2 MODE TYPE REGISTERS       */

********************************************/

 ---- 300 series ---- */

 For 301BDH: (with LCD via LVDS) */

 CONFIG_FB_SIS_300 */

 ------- 315/330 series ------ */

 CONFIG_FB_SIS_315 */

 LVDS */

 LVDS can only be slave in 8bpp modes */

 LCDA */

 unsigned char bridgerev = SiS_GetReg(SiS_Pr->SiS_Part4Port,0x01); */

	/* The following is nearly unpreditable and varies from machine

	 * to machine. Especially the 301DH seems to be a real trouble

	 * maker. Some BIOSes simply set the registers (like in the

	 * NoLCD-if-statements here), some set them according to the

	 * LCDA stuff. It is very likely that some machines are not

	 * treated correctly in the following, very case-orientated

	 * code. What do I do then...?

 740 variants match for 30xB, 301B-DH, 30xLV */

 For all bridges */

	/* The following two are responsible for eventually wrong colors

	 * in TV output. The DH (VB_NoLCD) conditions are unknown; the

	 * b0 was found in some 651 machine (Pim; P4_23=0xe5); the b1 version

	 * in a 650 box (Jake). What is the criteria?

	 * Addendum: Another combination 651+301B-DH(b1) (Rapo) needs same

	 * treatment like the 651+301B-DH(b0) case. Seems more to be the

	 * chipset than the bridge revision.

 Fixes "TV-blue-bug" on 315+301 */

 For 301   */

 For 30xLV */

 For 301B-DH */

 Set on 651/M650, clear on 315/650 */

 (bridgerev != 0xb0) */ {

 For 30xB, 301C */

 CONFIG_FB_SIS_315 */

 LVDS */

********************************************/

            GET RESOLUTION DATA            */

********************************************/

 DoubleScanMode-check done in CheckCalcCustomMode()! */

 BIOS bug - does this regardless of scaling */

********************************************/

           GET CRT2 TIMING DATA            */

********************************************/

 LCD */

 patch index */

 Pass 1:1 only (center-screen handled outside) */

 This is never called for the panel's native resolution */

 since Pass1:1 will not be set in this case */

 TV */

 if(SiS_Pr->SiS_VGAVDE > 480) SiS_Pr->SiS_TVMode &= (~TVSetTVSimuMode); */

 Not in NTSC or YPBPR mode (except 1080i)! */

 LVDS, 301B-DH (if running on LCD) */

 1600x1200 LCDA */

 1600x1200 LVDS */

 This handles custom modes and custom panels */

 301BDH needs LVDS Data */

 Need LVDS Data for LCD on 301B-DH */

********************************************/

         GET LVDS DES (SKEW) DATA          */

********************************************/

 Some special cases */

 Trumpion */

 640x480 on LVDS */

 LCD */

 non-pass 1:1 only, see above */

 Verified for Averatec 6240 */

 Verified for Asus A4L */

 Not verified yet FIXME */

 640x480 only? */

********************************************/

           DISABLE VIDEO BRIDGE            */

********************************************/

/* NEVER use any variables (VBInfo), this will be called

 * from outside the context of modeswitch!

 * MUST call getVBType before calling this

 ===== For 30xB/C/LV ===== */

 300 series */

 CONFIG_FB_SIS_300 */

 315 series */

 if(SiS_Pr->ChipType < SIS_340) {*/

}*/

 CONFIG_FB_SIS_315 */

 ============ For 301 ================ */

 disable VB */

 disable lock mode */

 disable CRT2 */

 ============ For LVDS =============*/

 300 series */

 CONFIG_FB_SIS_300 */

 315 series */

if(SiS_Pr->ChipType < SIS_340) { */ 
 } */

 SiS_SetRegAND(SiS_Pr->SiS_Part1Port,0x13,0xff); */

 DirectDVD PAL?*/

 VB clock / 4 ? */

 CONFIG_FB_SIS_315 */

 315 series */

 LVDS */

********************************************/

            ENABLE VIDEO BRIDGE            */

********************************************/

/* NEVER use any variables (VBInfo), this will be called

 * from outside the context of a mode switch!

 * MUST call getVBType before calling this

 ====== For 301B et al  ====== */

 300 series */

 Enable CRT2 */

 lock mode */

 enable VB processor */

 CONFIG_FB_SIS_300 */

 315 series */

 unsigned short  emidelay=0; */

if(SiS_Pr->ChipType < SIS_340) { */

}*/

 enable CRT2 */

 Enable "LVDS PLL power on" (even on 301C) */

 Enable "LVDS Driver Power on" (even on 301C) */

 Reset */

 emidelay = SISGETROMW((romptr + 0x22)); */

                                              (P4_30|0x40)  */

 Compal 1400x1050: 0x05, 0x60, 0x00                YES  (1.10.7w;  CR36=69)      */

 Compal 1400x1050: 0x0d, 0x70, 0x40                YES  (1.10.7x;  CR36=69)      */

 Acer   1280x1024: 0x12, 0xd0, 0x6b                NO   (1.10.9k;  CR36=73)      */

 Compaq 1280x1024: 0x0d, 0x70, 0x6b                YES  (1.12.04b; CR36=03)      */

 Clevo   1024x768: 0x05, 0x60, 0x33                NO   (1.10.8e;  CR36=12, DL!) */

 Clevo   1024x768: 0x0d, 0x70, 0x40 (if type == 3) YES  (1.10.8y;  CR36=?2)      */

 Clevo   1024x768: 0x05, 0x60, 0x33 (if type != 3) YES  (1.10.8y;  CR36=?2)      */

 Asus    1024x768: ?                                ?   (1.10.8o;  CR36=?2)      */

 Asus    1024x768: 0x08, 0x10, 0x3c (problematic)  YES  (1.10.8q;  CR36=22)      */

		  /* EMI_30 is read at driver start; however, the BIOS sets this

		   * (if it is used) only if the LCD is in use. In case we caught

		   * the machine while on TV output, this bit is not set and we

		   * don't know if it should be set - hence our detection is wrong.

		   * Work-around this here:

 1280x1024 */

 1400x1050 */

 BIOS values */

 1600x1200 - unknown */

 BIOS values don't work so well sometimes */

 r30 = 0x60; r31 = 0x05; r32 = 0x60; r33 = 0x33;  */   
 r30 = 0x20; r31 = 0x05; r32 = 0x60; r33 = 0x33;  */   
 r30 = 0x60; r31 = 0x0d; r32 = 0x70; r33 = 0x40;  */   
 r30 = 0x20; r31 = 0x0d; r32 = 0x70; r33 = 0x40;  */   
 Reset */

 SET_EMI */

SiS_SetRegOR(SiS_Pr->SiS_Part4Port,0x2a,0x80);*/

 Enable */

SiS_SetRegAND(SiS_Pr->SiS_Part4Port,0x2a,0x7f);*/

 CONFIG_FB_SIS_315 */

 ============  For 301 ================ */

 lock mode */

 enable CRT2 */

 BVBDOENABLE=1 */

 enable VB processor */

 =================== For LVDS ================== */

 300 series */

 CONFIG_FB_SIS_300 */

 315 series */

if(SiS_Pr->ChipType < SIS_340) {*/  
}*/

 CONFIG_FB_SIS_315 */

 310 series */

 LVDS */

********************************************/

         SET PART 1 REGISTER GROUP         */

********************************************/

 Set CRT2 OFFSET / PITCH */

 Set CRT2 sync and PanelLink mode */

 LVDS */

 Don't care about 12/18/24 bit mode - TV is via VGA, not PL */

 ---- 300 series --- */

 630 - 301B(-DH) */

 630 - 301 */

 CONFIG_FB_SIS_300 */

 ------- 315 series ------ */

 315 - LVDS */

 315 - TMDS */

 Imitate BIOS bug */

 CONFIG_FB_SIS_315 */

 Set CRT2 FIFO on 300/540/630/730 */

 get CRT1 ModeNo */

 Get VCLK */

 Get colordepth */

 Get VCLK */

 Get color depth */

 Get MCLK */

 BIOS BUG (2.04.5d, 2.04.6a use ah here, which is unset!) */

 -- do it like the BIOS anyway... */

 CRT1 Request Period */

 Get VCLK  */

 Get VCLK */

 Get colordepth */

 If mode <= 0x13, we just restore everything */

 Set CRT2 FIFO on 315/330 series */

 Set Part 1 / SiS bridge slave mode */

 CR0   CR1   CR2   CR3   CR4   CR5   CR6   CR7   */

 CR8   CR9   SR0A  SR0B  SR0C  SR0D  SR0E  CR0F  */

 CR10  CR11  CR12  CR13  CR14  CR15  CR16  CR17  */

 The following is only done if bridge is in slave mode: */

 BIOS: == 1600 */

 Max HT, 0x2020, results in 0x3ff in registers */

 results in 0x2000 in registers */

 Max VT, 0x0801, results in 0x7ff in registers */

 SR01: HalfDCLK[3], 8/9 div dotclock[0] */

 CR14: (text mode: underline location) */

 CR17: n/a */

 SR0E, dither[7] */

 ? */

/* Setup panel link

 * This is used for LVDS, LCDA and Chrontel TV output

 * 300/LVDS+TV, 300/301B-DH, 315/LVDS+TV, 315/LCDA

 is lvds if really LVDS, or 301B-DH with external LVDS transmitter */

 is really sis if sis bridge, but not 301B-DH */

 Horizontal */

 BPLHDESKEW[2:0]   */

 BPLHDESKEW[10:3]  */

 BPLHDEE  */

 BPLHRS */

 BPLHRE */

 Vertical */

 BPLVRS */

 BPLVRE  */

 Chrontel 701x operates in 24bit mode (8-8-8, 2x12bit multiplexed) via VGA2 */

 BPLVDEE */

 BPLVDES */

 Vertical scaling */

 300 series */

 BPLVCFACT */

 CONFIG_FB_SIS_300 */

 315 series */

 Horizontal scaling */

 1f = ( (VGAHDE * 65536) / ( (VGAHDE * 65536) / HDE ) ) - 1*/

 BPLHCFACT  */

 Blps = lcdhdee(lcdhdes+HDE) + 64 */

 Blpe = lBlps+32 */

 Bflml = 0 */

 BDxFIFOSTOP = (HDE*4)/128 */

 BDxWadrst0 */

 BDxWadroff = HDE*4/8/8 */

 BDxWadrst1 = BDxWadrst0 + BDxWadroff * VDE */

 CONFIG_FB_SIS_315 */

 Set Part 1 */

 1. Horizontal setup */

 ------------- 300 series --------------*/

 BTVGA2HT 0x08,0x09 */

 CRT2 Horizontal Total */

 CRT2 Horizontal Total Overflow [7:4] */

 BTVGA2HDEE 0x0A,0x0C */

 CRT2 Horizontal Display Enable End */

 bx  BTVGA2HRS 0x0B,0x0C */

 CONFIG_FB_SIS_300 */

 ------------------- 315/330 series --------------- */

 BTVGA2HT 0x08,0x09 */

 CRT2 Horizontal Total */

 CRT2 Horizontal Total Overflow [7:4] */

 BTVGA2HDEE 0x0A,0x0C */

 CRT2 Horizontal Display Enable End */

 CONFIG_FB_SIS_315 */

 315/330 series */

 (VGAHRS-3)*8 */

 (VGAHRE-3)*8 */

 HWCursor bug! */

 CRT2 Horizontal Retrace Start */

 CRT2 Horizontal Retrace End */

 Overflow */

 2. Vertical setup */

 CRT2 Vertical Total */

 CRT2 Vertical Display Enable End */

 Overflow */

  BTVGA2VRS     0x10,0x11   */

  BTVGA2VRE     0x11        */

 CRT2 Vertical Retrace Start */

 CRT2 Vert. Retrace End; Overflow */

 3. Panel delay compensation */

 ---------- 300 series -------------- */

 Panel Link Delay Compensation; (Software Command Reset; Power Saving) */

 CONFIG_FB_SIS_300 */

 --------------- 315/330 series ---------------*/

 Panel Link Delay Compensation */

 < 661 */

 CONFIG_FB_SIS_315 */

 Slavemode */

 For 301BDH with LCD, we set up the Panel Link */

********************************************/

         SET PART 2 REGISTER GROUP         */

********************************************/

 For ECS A907. Highly preliminary. */

 The BIOS code (1.16.51,56) is obviously a fragment! */

 15 */

 1b */

 21 */

 5a */

 21 */

 5a */

 Not always for LV, see SetGrp2 */

 651+301C, for 1280x768 - do I really need that? */

 SiS_PALPhase */

 SiS_NTSCPhase */

 SiS_PALPhase2 */

 SiS_PALPhase : SiS_NTSCPhase */

 SiS_PALPhase2 : SiS_NTSCPhase2 */

 SiS_PALMPhase : SiS_PALNPhase */

 SiS_PALMPhase2 : SiS_PALNPhase2 */

 SiS_SpecialPhaseM */

 SiS_SpecialPhaseJ */

 SiS_SpecialPhase */

 NTSC, YPbPr 525 */

 From 1.10.7w - doesn't make sense */

 OK */

 From here: Part2 LCD setup */

 RHACTE = HDE - 1 */

 Enable dithering; only do this for 32bpp mode */

 Checked for 1024x768, 1280x1024, 1400x1050, 1600x1200 */

             Clevo dual-link 1024x768 */

 		   Compaq 1280x1024 has HT 1696 sometimes (calculation OK, if given HT is correct)  */

		   Acer: OK, but uses different setting for VESA timing at 640/800/1024 and 640x400 */

 if(SiS_Pr->SiS_VGAVDE == 525) tempax += 0x3c;   */  
 lcdvdes */

 lcdvdee */

 Non-expanding: lcdvdes = tempcx = VT-1; lcdvdee = tempbx = VDE-1 */

 lcdvdes  */

 lcdvdee  */

 ? */

 non-expanding: lcdvrs = ((VT + VDE) / 2) - 10 */

 lcdvrs */

 OK for Averatec 1280x800 (301C) */

 OK for Asus A4L 1280x800 */

 Higher bridgeoffset shifts to the LEFT */

 lcdhdes */

 lcdhdee */

 lcdhrs */

 lcdhre */

 CRT2-LCD from table */

********************************************/

         SET PART 3 REGISTER GROUP         */

********************************************/

********************************************/

         SET PART 4 REGISTER GROUP         */

********************************************/

 ? why not 0x10? */

 ? */

 sic! */

 Calc Linebuffer max address and set/clear decimode */

 Correct */

 Otherwise white line or garbage at right edge */

 See En/DisableBridge() */

 LCD-too-dark-error-source, see FinalizeLCD() */

 301B */

********************************************/

         SET PART 5 REGISTER GROUP         */

********************************************/

********************************************/

     MODIFY CRT1 GROUP FOR SLAVE MODE      */

********************************************/

 Pass 1:1 not supported here */

 xSTN */

 xSTN */

 xSTN */

 xSTN */

 xSTN */

 Works better with calculated numbers */

********************************************/

              SET CRT2 ECLK                */

********************************************/

********************************************/

           SET UP CHRONTEL CHIPS           */

********************************************/

 Chrontel 7005 - I assume that it does not come with a 315 series chip */

 We don't support modes >800x600 */

 0x40=76uA (PAL); 0x03=15bit non-multi RGB*/

 Black level for PAL (105)*/

 upper nibble=71uA (NTSC), 0x03=15bit non-multi RGB*/

 Black level for NTSC (113)*/

 Mode register */

 Start active video register */

 Position overflow register */

 Horiz Position register */

 Vertical Position register */

      /* Set minimum flicker filter for Luma channel (SR1-0=00),

                minimum text enhancement (S3-2=10),

   	        maximum flicker filter for Chroma channel (S5-4=10)

	        =00101000=0x28 (When reading, S1-0->S3-2, and S3-2->S1-0!)

      /* Set video bandwidth

            High bandwidth Luma composite video filter(S0=1)

            low bandwidth Luma S-video filter (S2-1=00)

	    disable peak filter in S-video channel (S3=0)

	    high bandwidth Chroma Filter (S5-4=11)

	    =00110001=0x31

 old: 3103 */

      /* Register 0x3D does not exist in non-macrovision register map

            (Maybe this is a macrovision register?)

      /* Register 0x10 only contains 1 writable bit (S0) for sensing,

             all other bits a read-only. Macrovision?

      /* Register 0x11 only contains 3 writable bits (S0-S2) for

             contrast enhancement (set to 010 -> gain 1 Yout = 17/16*(Yin-30) )

      /* Clear DSEN

 ---- NTSC ---- */

 640x480 overscan: Mode 16 */

 loop filter off */

 ACIV on, no need to set FSCI */

 800x600 overscan: Mode 23 */

 0x18-0x1f: FSCI 469,762,048 */

 Loop filter on for mode 23 */

 ACIV off, need to set FSCI */

 ----- 640x480 underscan; Mode 17 */

 loop filter off */

 ----- 800x600 underscan: Mode 24 */

 (FSCI was 0x1f1c71c7 - this is for mode 22) */

 FSCI for mode 24 is 428,554,851 */

 198b3a63 */

 loop filter off for mode 24 */

               SiS_SetCH70xxANDOR(SiS_Pr,0x21,0x00,0xFE);	* ACIV off, need to set FSCI */

#endif         /* All alternatives wrong (datasheet wrong?), don't use FSCI */

	       SiS_SetCH70xxANDOR(SiS_Pr,0x20,0x00,0xEF);	 /* loop filter off */

               SiS_SetCH70xxANDOR(SiS_Pr,0x21,0x01,0xFE);

            }

         }

      } else {						/* ---- PAL ---- */

	/* We don't play around with FSCI in PAL mode */

	SiS_SetCH70xxANDOR(SiS_Pr, 0x20, 0x00, 0xEF);	/* loop filter off */

	SiS_SetCH70xxANDOR(SiS_Pr, 0x21, 0x01, 0xFE);	/* ACIV on */

      }



#endif  /* 300 */



   } else {



      /* Chrontel 7019 - assumed that it does not come with a 300 series chip */



#ifdef CONFIG_FB_SIS_315



      unsigned short temp;



      /* We don't support modes >1024x768 */

      if (resindex > 6) return;



      temp = CHTVRegData[resindex].Reg[0];

      if(SiS_Pr->SiS_TVMode & TVSetNTSCJ) temp |= 0x10;

      SiS_SetCH701x(SiS_Pr,0x00,temp);



      SiS_SetCH701x(SiS_Pr,0x01,CHTVRegData[resindex].Reg[1]);

      SiS_SetCH701x(SiS_Pr,0x02,CHTVRegData[resindex].Reg[2]);

      SiS_SetCH701x(SiS_Pr,0x04,CHTVRegData[resindex].Reg[3]);

      SiS_SetCH701x(SiS_Pr,0x03,CHTVRegData[resindex].Reg[4]);

      SiS_SetCH701x(SiS_Pr,0x05,CHTVRegData[resindex].Reg[5]);

      SiS_SetCH701x(SiS_Pr,0x06,CHTVRegData[resindex].Reg[6]);



      temp = CHTVRegData[resindex].Reg[7];

      if(SiS_Pr->SiS_TVMode & TVSetNTSCJ) temp = 0x66;

      SiS_SetCH701x(SiS_Pr,0x07,temp);



      SiS_SetCH701x(SiS_Pr,0x08,CHTVRegData[resindex].Reg[8]);

      SiS_SetCH701x(SiS_Pr,0x15,CHTVRegData[resindex].Reg[9]);

      SiS_SetCH701x(SiS_Pr,0x1f,CHTVRegData[resindex].Reg[10]);

      SiS_SetCH701x(SiS_Pr,0x0c,CHTVRegData[resindex].Reg[11]);

      SiS_SetCH701x(SiS_Pr,0x0d,CHTVRegData[resindex].Reg[12]);

      SiS_SetCH701x(SiS_Pr,0x0e,CHTVRegData[resindex].Reg[13]);

      SiS_SetCH701x(SiS_Pr,0x0f,CHTVRegData[resindex].Reg[14]);

      SiS_SetCH701x(SiS_Pr,0x10,CHTVRegData[resindex].Reg[15]);



      temp = SiS_GetCH701x(SiS_Pr,0x21) & ~0x02;

 D1 should be set for PAL, PAL-N and NTSC-J,

       */

      if(SiS_Pr->SiS_TVMode & (TVSetPALN | TVSetNTSCJ)) temp |= 0x02;

      SiS_SetCH701x(SiS_Pr,0x21,temp);



#endif	/* 315 */



   }



#ifdef SIS_CP

   SIS_CP_INIT301_CP3

#endif



}



#ifdef CONFIG_FB_SIS_315  /* ----------- 315 series only ---------- */



void

SiS_Chrontel701xBLOn(struct SiS_Private *SiS_Pr)

{

   unsigned short temp;



   /* Enable Chrontel 7019 LCD panel backlight */

   if(SiS_Pr->SiS_IF_DEF_CH70xx == 2) {

      if(SiS_Pr->ChipType == SIS_740) {

	 SiS_SetCH701x(SiS_Pr,0x66,0x65);

      } else {

	 temp = SiS_GetCH701x(SiS_Pr,0x66);

	 temp |= 0x20;

	 SiS_SetCH701x(SiS_Pr,0x66,temp);

      }

   }

}



void

SiS_Chrontel701xBLOff(struct SiS_Private *SiS_Pr)

{

   unsigned short temp;



   /* Disable Chrontel 7019 LCD panel backlight */

   if(SiS_Pr->SiS_IF_DEF_CH70xx == 2) {

      temp = SiS_GetCH701x(SiS_Pr,0x66);

      temp &= 0xDF;

      SiS_SetCH701x(SiS_Pr,0x66,temp);

   }

}



static void

SiS_ChrontelPowerSequencing(struct SiS_Private *SiS_Pr)

{

  static const unsigned char regtable[]      = { 0x67, 0x68, 0x69, 0x6a, 0x6b };

  static const unsigned char table1024_740[] = { 0x01, 0x02, 0x01, 0x01, 0x01 };

  static const unsigned char table1400_740[] = { 0x01, 0x6e, 0x01, 0x01, 0x01 };

  static const unsigned char asus1024_740[]  = { 0x19, 0x6e, 0x01, 0x19, 0x09 };

  static const unsigned char asus1400_740[]  = { 0x19, 0x6e, 0x01, 0x19, 0x09 };

  static const unsigned char table1024_650[] = { 0x01, 0x02, 0x01, 0x01, 0x02 };

  static const unsigned char table1400_650[] = { 0x01, 0x02, 0x01, 0x01, 0x02 };

  const unsigned char *tableptr = NULL;

  int i;



  /* Set up Power up/down timing */



  if(SiS_Pr->ChipType == SIS_740) {

     if(SiS_Pr->SiS_LCDResInfo == Panel_1024x768) {

	if(SiS_Pr->SiS_CustomT == CUT_ASUSL3000D) tableptr = asus1024_740;

	else    			          tableptr = table1024_740;

     } else if((SiS_Pr->SiS_LCDResInfo == Panel_1280x1024) ||

	       (SiS_Pr->SiS_LCDResInfo == Panel_1400x1050) ||

	       (SiS_Pr->SiS_LCDResInfo == Panel_1600x1200)) {

	if(SiS_Pr->SiS_CustomT == CUT_ASUSL3000D) tableptr = asus1400_740;

        else					  tableptr = table1400_740;

     } else return;

  } else {

     if(SiS_Pr->SiS_LCDResInfo == Panel_1024x768) {

	tableptr = table1024_650;

     } else if((SiS_Pr->SiS_LCDResInfo == Panel_1280x1024) ||

	       (SiS_Pr->SiS_LCDResInfo == Panel_1400x1050) ||

	       (SiS_Pr->SiS_LCDResInfo == Panel_1600x1200)) {

	tableptr = table1400_650;

     } else return;

  }



  for(i=0; i<5; i++) {

     SiS_SetCH701x(SiS_Pr, regtable[i], tableptr[i]);

  }

}



static void

SiS_SetCH701xForLCD(struct SiS_Private *SiS_Pr)

{

  const unsigned char *tableptr = NULL;

  unsigned short tempbh;

  int i;

  static const unsigned char regtable[] = {

		0x1c, 0x5f, 0x64, 0x6f, 0x70, 0x71,

		0x72, 0x73, 0x74, 0x76, 0x78, 0x7d, 0x66

  };

  static const unsigned char table1024_740[] = {

		0x60, 0x02, 0x00, 0x07, 0x40, 0xed,

		0xa3, 0xc8, 0xc7, 0xac, 0xe0, 0x02, 0x44

  };

  static const unsigned char table1280_740[] = {

		0x60, 0x03, 0x11, 0x00, 0x40, 0xe3,

		0xad, 0xdb, 0xf6, 0xac, 0xe0, 0x02, 0x44

  };

  static const unsigned char table1400_740[] = {

		0x60, 0x03, 0x11, 0x00, 0x40, 0xe3,

		0xad, 0xdb, 0xf6, 0xac, 0xe0, 0x02, 0x44

  };

  static const unsigned char table1600_740[] = {

		0x60, 0x04, 0x11, 0x00, 0x40, 0xe3,

		0xad, 0xde, 0xf6, 0xac, 0x60, 0x1a, 0x44

  };

  static const unsigned char table1024_650[] = {

		0x60, 0x02, 0x00, 0x07, 0x40, 0xed,

		0xa3, 0xc8, 0xc7, 0xac, 0x60, 0x02

  };

  static const unsigned char table1280_650[] = {

		0x60, 0x03, 0x11, 0x00, 0x40, 0xe3,

		0xad, 0xdb, 0xf6, 0xac, 0xe0, 0x02

  };

  static const unsigned char table1400_650[] = {

		0x60, 0x03, 0x11, 0x00, 0x40, 0xef,

		0xad, 0xdb, 0xf6, 0xac, 0x60, 0x02

  };

  static const unsigned char table1600_650[] = {

		0x60, 0x04, 0x11, 0x00, 0x40, 0xe3,

		0xad, 0xde, 0xf6, 0xac, 0x60, 0x1a

  };



  if(SiS_Pr->ChipType == SIS_740) {

     if(SiS_Pr->SiS_LCDResInfo == Panel_1024x768)       tableptr = table1024_740;

     else if(SiS_Pr->SiS_LCDResInfo == Panel_1280x1024) tableptr = table1280_740;

     else if(SiS_Pr->SiS_LCDResInfo == Panel_1400x1050) tableptr = table1400_740;

     else if(SiS_Pr->SiS_LCDResInfo == Panel_1600x1200) tableptr = table1600_740;

     else return;

  } else {

     if(SiS_Pr->SiS_LCDResInfo == Panel_1024x768)       tableptr = table1024_650;

     else if(SiS_Pr->SiS_LCDResInfo == Panel_1280x1024) tableptr = table1280_650;

     else if(SiS_Pr->SiS_LCDResInfo == Panel_1400x1050) tableptr = table1400_650;

     else if(SiS_Pr->SiS_LCDResInfo == Panel_1600x1200) tableptr = table1600_650;

     else return;

  }



  tempbh = SiS_GetCH701x(SiS_Pr,0x74);

  if((tempbh == 0xf6) || (tempbh == 0xc7)) {

     tempbh = SiS_GetCH701x(SiS_Pr,0x73);

     if(tempbh == 0xc8) {

        if(SiS_Pr->SiS_LCDResInfo == Panel_1024x768) return;

     } else if(tempbh == 0xdb) {

        if(SiS_Pr->SiS_LCDResInfo == Panel_1280x1024) return;

	if(SiS_Pr->SiS_LCDResInfo == Panel_1400x1050) return;

     } else if(tempbh == 0xde) {

        if(SiS_Pr->SiS_LCDResInfo == Panel_1600x1200) return;

     }

  }



  if(SiS_Pr->ChipType == SIS_740) tempbh = 0x0d;

  else     			  tempbh = 0x0c;



  for(i = 0; i < tempbh; i++) {

     SiS_SetCH701x(SiS_Pr, regtable[i], tableptr[i]);

  }

  SiS_ChrontelPowerSequencing(SiS_Pr);

  tempbh = SiS_GetCH701x(SiS_Pr,0x1e);

  tempbh |= 0xc0;

  SiS_SetCH701x(SiS_Pr,0x1e,tempbh);



  if(SiS_Pr->ChipType == SIS_740) {

     tempbh = SiS_GetCH701x(SiS_Pr,0x1c);

     tempbh &= 0xfb;

     SiS_SetCH701x(SiS_Pr,0x1c,tempbh);

     SiS_SetReg(SiS_Pr->SiS_Part1Port,0x2d,0x03);

     tempbh = SiS_GetCH701x(SiS_Pr,0x64);

     tempbh |= 0x40;

     SiS_SetCH701x(SiS_Pr,0x64,tempbh);

     tempbh = SiS_GetCH701x(SiS_Pr,0x03);

     tempbh &= 0x3f;

     SiS_SetCH701x(SiS_Pr,0x03,tempbh);

  }

}



static void

SiS_ChrontelResetVSync(struct SiS_Private *SiS_Pr)

{

  unsigned char temp, temp1;



  temp1 = SiS_GetCH701x(SiS_Pr,0x49);

  SiS_SetCH701x(SiS_Pr,0x49,0x3e);

  temp = SiS_GetCH701x(SiS_Pr,0x47);

  temp &= 0x7f;	/* Use external VSYNC */

  SiS_SetCH701x(SiS_Pr,0x47,temp);

  SiS_LongDelay(SiS_Pr, 3);

  temp = SiS_GetCH701x(SiS_Pr,0x47);

  temp |= 0x80;	/* Use internal VSYNC */

  SiS_SetCH701x(SiS_Pr,0x47,temp);

  SiS_SetCH701x(SiS_Pr,0x49,temp1);

}



static void

SiS_Chrontel701xOn(struct SiS_Private *SiS_Pr)

{

  unsigned short temp;



  if(SiS_Pr->SiS_IF_DEF_CH70xx == 2) {

     if(SiS_Pr->ChipType == SIS_740) {

        temp = SiS_GetCH701x(SiS_Pr,0x1c);

        temp |= 0x04;	/* Invert XCLK phase */

        SiS_SetCH701x(SiS_Pr,0x1c,temp);

     }

     if(SiS_IsYPbPr(SiS_Pr)) {

        temp = SiS_GetCH701x(SiS_Pr,0x01);

	temp &= 0x3f;

	temp |= 0x80;	/* Enable YPrPb (HDTV) */

	SiS_SetCH701x(SiS_Pr,0x01,temp);

     }

     if(SiS_IsChScart(SiS_Pr)) {

        temp = SiS_GetCH701x(SiS_Pr,0x01);

	temp &= 0x3f;

	temp |= 0xc0;	/* Enable SCART + CVBS */

	SiS_SetCH701x(SiS_Pr,0x01,temp);

     }

     if(SiS_Pr->ChipType == SIS_740) {

        SiS_ChrontelResetVSync(SiS_Pr);

        SiS_SetCH701x(SiS_Pr,0x49,0x20);   /* Enable TV path */

     } else {

        SiS_SetCH701x(SiS_Pr,0x49,0x20);   /* Enable TV path */

        temp = SiS_GetCH701x(SiS_Pr,0x49);

        if(SiS_IsYPbPr(SiS_Pr)) {

           temp = SiS_GetCH701x(SiS_Pr,0x73);

	   temp |= 0x60;

	   SiS_SetCH701x(SiS_Pr,0x73,temp);

        }

        temp = SiS_GetCH701x(SiS_Pr,0x47);

        temp &= 0x7f;

        SiS_SetCH701x(SiS_Pr,0x47,temp);

        SiS_LongDelay(SiS_Pr, 2);

        temp = SiS_GetCH701x(SiS_Pr,0x47);

        temp |= 0x80;

        SiS_SetCH701x(SiS_Pr,0x47,temp);

     }

  }

}



static void

SiS_Chrontel701xOff(struct SiS_Private *SiS_Pr)

{

  unsigned short temp;



  /* Complete power down of LVDS */

  if(SiS_Pr->SiS_IF_DEF_CH70xx == 2) {

     if(SiS_Pr->ChipType == SIS_740) {

        SiS_LongDelay(SiS_Pr, 1);

	SiS_GenericDelay(SiS_Pr, 5887);

	SiS_SetCH701x(SiS_Pr,0x76,0xac);

	SiS_SetCH701x(SiS_Pr,0x66,0x00);

     } else {

        SiS_LongDelay(SiS_Pr, 2);

	temp = SiS_GetCH701x(SiS_Pr,0x76);

	temp &= 0xfc;

	SiS_SetCH701x(SiS_Pr,0x76,temp);

	SiS_SetCH701x(SiS_Pr,0x66,0x00);

     }

  }

}



static void

SiS_ChrontelResetDB(struct SiS_Private *SiS_Pr)

{

     unsigned short temp;



     if(SiS_Pr->ChipType == SIS_740) {



        temp = SiS_GetCH701x(SiS_Pr,0x4a);  /* Version ID */

        temp &= 0x01;

        if(!temp) {



           if(SiS_WeHaveBacklightCtrl(SiS_Pr)) {

	      temp = SiS_GetCH701x(SiS_Pr,0x49);

	      SiS_SetCH701x(SiS_Pr,0x49,0x3e);

	   }



	   /* Reset Chrontel 7019 datapath */

           SiS_SetCH701x(SiS_Pr,0x48,0x10);

           SiS_LongDelay(SiS_Pr, 1);

           SiS_SetCH701x(SiS_Pr,0x48,0x18);



	   if(SiS_WeHaveBacklightCtrl(SiS_Pr)) {

	      SiS_ChrontelResetVSync(SiS_Pr);

	      SiS_SetCH701x(SiS_Pr,0x49,temp);

	   }



        } else {



	   /* Clear/set/clear GPIO */

           temp = SiS_GetCH701x(SiS_Pr,0x5c);

	   temp &= 0xef;

	   SiS_SetCH701x(SiS_Pr,0x5c,temp);

	   temp = SiS_GetCH701x(SiS_Pr,0x5c);

	   temp |= 0x10;

	   SiS_SetCH701x(SiS_Pr,0x5c,temp);

	   temp = SiS_GetCH701x(SiS_Pr,0x5c);

	   temp &= 0xef;

	   SiS_SetCH701x(SiS_Pr,0x5c,temp);

	   temp = SiS_GetCH701x(SiS_Pr,0x61);

	   if(!temp) {

	      SiS_SetCH701xForLCD(SiS_Pr);

	   }

        }



     } else { /* 650 */

        /* Reset Chrontel 7019 datapath */

        SiS_SetCH701x(SiS_Pr,0x48,0x10);

        SiS_LongDelay(SiS_Pr, 1);

        SiS_SetCH701x(SiS_Pr,0x48,0x18);

     }

}



static void

SiS_ChrontelInitTVVSync(struct SiS_Private *SiS_Pr)

{

     unsigned short temp;



     if(SiS_Pr->ChipType == SIS_740) {



        if(SiS_WeHaveBacklightCtrl(SiS_Pr)) {

           SiS_ChrontelResetVSync(SiS_Pr);

        }



     } else {



        SiS_SetCH701x(SiS_Pr,0x76,0xaf);  /* Power up LVDS block */

        temp = SiS_GetCH701x(SiS_Pr,0x49);

        temp &= 1;

        if(temp != 1) {  /* TV block powered? (0 = yes, 1 = no) */

	   temp = SiS_GetCH701x(SiS_Pr,0x47);

	   temp &= 0x70;

	   SiS_SetCH701x(SiS_Pr,0x47,temp);  /* enable VSYNC */

	   SiS_LongDelay(SiS_Pr, 3);

	   temp = SiS_GetCH701x(SiS_Pr,0x47);

	   temp |= 0x80;

	   SiS_SetCH701x(SiS_Pr,0x47,temp);  /* disable VSYNC */

        }



     }

}



static void

SiS_ChrontelDoSomething3(struct SiS_Private *SiS_Pr, unsigned short ModeNo)

{

     unsigned short temp,temp1;



     if(SiS_Pr->ChipType == SIS_740) {



        temp = SiS_GetCH701x(SiS_Pr,0x61);

        if(temp < 1) {

           temp++;

	   SiS_SetCH701x(SiS_Pr,0x61,temp);

        }

        SiS_SetCH701x(SiS_Pr,0x66,0x45);  /* Panel power on */

        SiS_SetCH701x(SiS_Pr,0x76,0xaf);  /* All power on */

        SiS_LongDelay(SiS_Pr, 1);

        SiS_GenericDelay(SiS_Pr, 5887);



     } else {  /* 650 */



        temp1 = 0;

        temp = SiS_GetCH701x(SiS_Pr,0x61);

        if(temp < 2) {

           temp++;

	   SiS_SetCH701x(SiS_Pr,0x61,temp);

	   temp1 = 1;

        }

        SiS_SetCH701x(SiS_Pr,0x76,0xac);

        temp = SiS_GetCH701x(SiS_Pr,0x66);

        temp |= 0x5f;

        SiS_SetCH701x(SiS_Pr,0x66,temp);

        if(ModeNo > 0x13) {

           if(SiS_WeHaveBacklightCtrl(SiS_Pr)) {

	      SiS_GenericDelay(SiS_Pr, 1023);

	   } else {

	      SiS_GenericDelay(SiS_Pr, 767);

	   }

        } else {

           if(!temp1)

	      SiS_GenericDelay(SiS_Pr, 767);

        }

        temp = SiS_GetCH701x(SiS_Pr,0x76);

        temp |= 0x03;

        SiS_SetCH701x(SiS_Pr,0x76,temp);

        temp = SiS_GetCH701x(SiS_Pr,0x66);

        temp &= 0x7f;

        SiS_SetCH701x(SiS_Pr,0x66,temp);

        SiS_LongDelay(SiS_Pr, 1);



     }

}



static void

SiS_ChrontelDoSomething2(struct SiS_Private *SiS_Pr)

{

     unsigned short temp;



     SiS_LongDelay(SiS_Pr, 1);



     do {

       temp = SiS_GetCH701x(SiS_Pr,0x66);

       temp &= 0x04;  /* PLL stable? -> bail out */

       if(temp == 0x04) break;



       if(SiS_Pr->ChipType == SIS_740) {

          /* Power down LVDS output, PLL normal operation */

          SiS_SetCH701x(SiS_Pr,0x76,0xac);

       }



       SiS_SetCH701xForLCD(SiS_Pr);



       temp = SiS_GetCH701x(SiS_Pr,0x76);

       temp &= 0xfb;  /* Reset PLL */

       SiS_SetCH701x(SiS_Pr,0x76,temp);

       SiS_LongDelay(SiS_Pr, 2);

       temp = SiS_GetCH701x(SiS_Pr,0x76);

       temp |= 0x04;  /* PLL normal operation */

       SiS_SetCH701x(SiS_Pr,0x76,temp);

       if(SiS_Pr->ChipType == SIS_740) {

          SiS_SetCH701x(SiS_Pr,0x78,0xe0);	/* PLL loop filter */

       } else {

          SiS_SetCH701x(SiS_Pr,0x78,0x60);

       }

       SiS_LongDelay(SiS_Pr, 2);

    } while(0);



    SiS_SetCH701x(SiS_Pr,0x77,0x00);  /* MV? */

}



static void

SiS_ChrontelDoSomething1(struct SiS_Private *SiS_Pr)

{

     unsigned short temp;



     temp = SiS_GetCH701x(SiS_Pr,0x03);

     temp |= 0x80;	/* Set datapath 1 to TV   */

     temp &= 0xbf;	/* Set datapath 2 to LVDS */

     SiS_SetCH701x(SiS_Pr,0x03,temp);



     if(SiS_Pr->ChipType == SIS_740) {



        temp = SiS_GetCH701x(SiS_Pr,0x1c);

        temp &= 0xfb;	/* Normal XCLK phase */

        SiS_SetCH701x(SiS_Pr,0x1c,temp);



        SiS_SetReg(SiS_Pr->SiS_Part1Port,0x2d,0x03);



        temp = SiS_GetCH701x(SiS_Pr,0x64);

        temp |= 0x40;	/* ? Bit not defined */

        SiS_SetCH701x(SiS_Pr,0x64,temp);



        temp = SiS_GetCH701x(SiS_Pr,0x03);

        temp &= 0x3f;	/* D1 input to both LVDS and TV */

        SiS_SetCH701x(SiS_Pr,0x03,temp);



	if(SiS_Pr->SiS_CustomT == CUT_ASUSL3000D) {

	   SiS_SetCH701x(SiS_Pr,0x63,0x40); /* LVDS off */

	   SiS_LongDelay(SiS_Pr, 1);

	   SiS_SetCH701x(SiS_Pr,0x63,0x00); /* LVDS on */

	   SiS_ChrontelResetDB(SiS_Pr);

	   SiS_ChrontelDoSomething2(SiS_Pr);

	   SiS_ChrontelDoSomething3(SiS_Pr, 0);

	} else {

           temp = SiS_GetCH701x(SiS_Pr,0x66);

           if(temp != 0x45) {

              SiS_ChrontelResetDB(SiS_Pr);

              SiS_ChrontelDoSomething2(SiS_Pr);

              SiS_ChrontelDoSomething3(SiS_Pr, 0);

           }

	}



     } else { /* 650 */



        SiS_ChrontelResetDB(SiS_Pr);

        SiS_ChrontelDoSomething2(SiS_Pr);

        temp = SiS_GetReg(SiS_Pr->SiS_P3d4,0x34);

        SiS_ChrontelDoSomething3(SiS_Pr,temp);

        SiS_SetCH701x(SiS_Pr,0x76,0xaf);  /* All power on, LVDS normal operation */



     }



}

#endif  /* 315 series  */



/*********************************************/

/*      MAIN: SET CRT2 REGISTER GROUP        */

/*********************************************/



bool

SiS_SetCRT2Group(struct SiS_Private *SiS_Pr, unsigned short ModeNo)

{

#ifdef CONFIG_FB_SIS_300

   unsigned char  *ROMAddr  = SiS_Pr->VirtualRomBase;

#endif

   unsigned short ModeIdIndex, RefreshRateTableIndex;



   SiS_Pr->SiS_SetFlag |= ProgrammingCRT2;



   if(!SiS_Pr->UseCustomMode) {

      SiS_SearchModeID(SiS_Pr, &ModeNo, &ModeIdIndex);

   } else {

      ModeIdIndex = 0;

   }



   /* Used for shifting CR33 */

   SiS_Pr->SiS_SelectCRT2Rate = 4;



   SiS_UnLockCRT2(SiS_Pr);



   RefreshRateTableIndex = SiS_GetRatePtr(SiS_Pr, ModeNo, ModeIdIndex);



   SiS_SaveCRT2Info(SiS_Pr,ModeNo);



   if(SiS_Pr->SiS_SetFlag & LowModeTests) {

      SiS_DisableBridge(SiS_Pr);

      if((SiS_Pr->SiS_IF_DEF_LVDS == 1) && (SiS_Pr->ChipType == SIS_730)) {

         SiS_SetReg(SiS_Pr->SiS_Part1Port,0x00,0x80);

      }

      SiS_SetCRT2ModeRegs(SiS_Pr, ModeNo, ModeIdIndex);

   }



   if(SiS_Pr->SiS_VBInfo & DisableCRT2Display) {

      SiS_LockCRT2(SiS_Pr);

      SiS_DisplayOn(SiS_Pr);

      return true;

   }



   SiS_GetCRT2Data(SiS_Pr, ModeNo, ModeIdIndex, RefreshRateTableIndex);



   /* Set up Panel Link for LVDS and LCDA */

   SiS_Pr->SiS_LCDHDES = SiS_Pr->SiS_LCDVDES = 0;

   if( (SiS_Pr->SiS_IF_DEF_LVDS == 1) ||

       ((SiS_Pr->SiS_VBType & VB_NoLCD) && (SiS_Pr->SiS_VBInfo & SetCRT2ToLCD)) ||

       ((SiS_Pr->ChipType >= SIS_315H) && (SiS_Pr->SiS_VBType & VB_SIS30xBLV)) ) {

      SiS_GetLVDSDesData(SiS_Pr, ModeNo, ModeIdIndex, RefreshRateTableIndex);

   }



   if(SiS_Pr->SiS_SetFlag & LowModeTests) {

      SiS_SetGroup1(SiS_Pr, ModeNo, ModeIdIndex, RefreshRateTableIndex);

   }



   if(SiS_Pr->SiS_VBType & VB_SISVB) {



      if(SiS_Pr->SiS_SetFlag & LowModeTests) {



	 SiS_SetGroup2(SiS_Pr, ModeNo, ModeIdIndex, RefreshRateTableIndex);

#ifdef CONFIG_FB_SIS_315

	 SiS_SetGroup2_C_ELV(SiS_Pr, ModeNo, ModeIdIndex, RefreshRateTableIndex);

#endif

	 SiS_SetGroup3(SiS_Pr, ModeNo, ModeIdIndex);

	 SiS_SetGroup4(SiS_Pr, ModeNo, ModeIdIndex, RefreshRateTableIndex);

#ifdef CONFIG_FB_SIS_315

	 SiS_SetGroup4_C_ELV(SiS_Pr, ModeNo, ModeIdIndex);

#endif

	 SiS_SetGroup5(SiS_Pr, ModeNo, ModeIdIndex);



	 SiS_SetCRT2Sync(SiS_Pr, ModeNo, RefreshRateTableIndex);



	 /* For 301BDH (Panel link initialization): */

	 if((SiS_Pr->SiS_VBType & VB_NoLCD) && (SiS_Pr->SiS_VBInfo & SetCRT2ToLCD)) {



	    if(!((SiS_Pr->SiS_SetFlag & SetDOSMode) && ((ModeNo == 0x03) || (ModeNo == 0x10)))) {

	       if(SiS_Pr->SiS_VBInfo & SetInSlaveMode) {

		  SiS_ModCRT1CRTC(SiS_Pr, ModeNo, ModeIdIndex, RefreshRateTableIndex);

	       }

            }

	    SiS_SetCRT2ECLK(SiS_Pr, ModeNo, ModeIdIndex, RefreshRateTableIndex);

	 }

      }



   } else {



      SiS_SetCRT2Sync(SiS_Pr, ModeNo, RefreshRateTableIndex);



      SiS_ModCRT1CRTC(SiS_Pr,ModeNo,ModeIdIndex,RefreshRateTableIndex);



      SiS_SetCRT2ECLK(SiS_Pr,ModeNo,ModeIdIndex,RefreshRateTableIndex);



      if(SiS_Pr->SiS_SetFlag & LowModeTests) {

	 if(SiS_Pr->SiS_IF_DEF_CH70xx != 0) {

	    if(SiS_Pr->SiS_VBInfo & (SetCRT2ToLCD | SetCRT2ToLCDA)) {

	       if(SiS_Pr->SiS_IF_DEF_CH70xx == 2) {

#ifdef CONFIG_FB_SIS_315

		  SiS_SetCH701xForLCD(SiS_Pr);

#endif

	       }

	    }

	    if(SiS_Pr->SiS_VBInfo & SetCRT2ToTV) {

	       SiS_SetCHTVReg(SiS_Pr,ModeNo,ModeIdIndex,RefreshRateTableIndex);

	    }

	 }

      }



   }



#ifdef CONFIG_FB_SIS_300

   if(SiS_Pr->ChipType < SIS_315H) {

      if(SiS_Pr->SiS_SetFlag & LowModeTests) {

	 if(SiS_Pr->SiS_UseOEM) {

	    if((SiS_Pr->SiS_UseROM) && (SiS_Pr->SiS_UseOEM == -1)) {

	       if((ROMAddr[0x233] == 0x12) && (ROMAddr[0x234] == 0x34)) {

		  SiS_OEM300Setting(SiS_Pr, ModeNo, ModeIdIndex, RefreshRateTableIndex);

	       }

	    } else {

	       SiS_OEM300Setting(SiS_Pr, ModeNo, ModeIdIndex, RefreshRateTableIndex);

	    }

	 }

	 if(SiS_Pr->SiS_IF_DEF_LVDS == 1) {

	    if((SiS_Pr->SiS_CustomT == CUT_BARCO1366) ||

	       (SiS_Pr->SiS_CustomT == CUT_BARCO1024)) {

	       SetOEMLCDData2(SiS_Pr, ModeNo, ModeIdIndex,RefreshRateTableIndex);

	    }

	    SiS_DisplayOn(SiS_Pr);

         }

      }

   }

#endif



#ifdef CONFIG_FB_SIS_315

   if(SiS_Pr->ChipType >= SIS_315H) {

      if(SiS_Pr->SiS_SetFlag & LowModeTests) {

	 if(SiS_Pr->ChipType < SIS_661) {

	    SiS_FinalizeLCD(SiS_Pr, ModeNo, ModeIdIndex);

	    SiS_OEM310Setting(SiS_Pr, ModeNo, ModeIdIndex, RefreshRateTableIndex);

	 } else {

	    SiS_OEM661Setting(SiS_Pr, ModeNo, ModeIdIndex, RefreshRateTableIndex);

	 }

	 SiS_SetRegOR(SiS_Pr->SiS_Part1Port,0x01,0x40);

      }

   }

#endif



   if(SiS_Pr->SiS_SetFlag & LowModeTests) {

      SiS_EnableBridge(SiS_Pr);

   }



   SiS_DisplayOn(SiS_Pr);



   if(SiS_Pr->SiS_IF_DEF_CH70xx == 1) {

      if(SiS_Pr->SiS_VBInfo & SetCRT2ToTV) {

	 /* Disable LCD panel when using TV */

	 SiS_SetRegSR11ANDOR(SiS_Pr,0xFF,0x0C);

      } else {

	 /* Disable TV when using LCD */

	 SiS_SetCH70xxANDOR(SiS_Pr,0x0e,0x01,0xf8);

      }

   }



   if(SiS_Pr->SiS_SetFlag & LowModeTests) {

      SiS_LockCRT2(SiS_Pr);

   }



   return true;

}





/*********************************************/

/*     ENABLE/DISABLE LCD BACKLIGHT (SIS)    */

/*********************************************/



void

SiS_SiS30xBLOn(struct SiS_Private *SiS_Pr)

{

  /* Switch on LCD backlight on SiS30xLV */

  SiS_DDC2Delay(SiS_Pr,0xff00);

  if(!(SiS_GetReg(SiS_Pr->SiS_Part4Port,0x26) & 0x02)) {

     SiS_SetRegOR(SiS_Pr->SiS_Part4Port,0x26,0x02);

     SiS_WaitVBRetrace(SiS_Pr);

  }

  if(!(SiS_GetReg(SiS_Pr->SiS_Part4Port,0x26) & 0x01)) {

     SiS_SetRegOR(SiS_Pr->SiS_Part4Port,0x26,0x01);

  }

}



void

SiS_SiS30xBLOff(struct SiS_Private *SiS_Pr)

{

  /* Switch off LCD backlight on SiS30xLV */

  SiS_SetRegAND(SiS_Pr->SiS_Part4Port,0x26,0xFE);

  SiS_DDC2Delay(SiS_Pr,0xff00);

}



/*********************************************/

/*          DDC RELATED FUNCTIONS            */

/*********************************************/



static void

SiS_SetupDDCN(struct SiS_Private *SiS_Pr)

{

  SiS_Pr->SiS_DDC_NData = ~SiS_Pr->SiS_DDC_Data;

  SiS_Pr->SiS_DDC_NClk  = ~SiS_Pr->SiS_DDC_Clk;

  if((SiS_Pr->SiS_DDC_Index == 0x11) && (SiS_Pr->SiS_SensibleSR11)) {

     SiS_Pr->SiS_DDC_NData &= 0x0f;

     SiS_Pr->SiS_DDC_NClk  &= 0x0f;

  }

}



#ifdef CONFIG_FB_SIS_300

static unsigned char *

SiS_SetTrumpBlockLoop(struct SiS_Private *SiS_Pr, unsigned char *dataptr)

{

  int i, j, num;

  unsigned short tempah,temp;

  unsigned char *mydataptr;



  for(i=0; i<20; i++) {				/* Do 20 attempts to write */

     mydataptr = dataptr;

     num = *mydataptr++;

     if(!num) return mydataptr;

     if(i) {

        SiS_SetStop(SiS_Pr);

	SiS_DDC2Delay(SiS_Pr,SiS_I2CDELAYSHORT * 2);

     }

     if(SiS_SetStart(SiS_Pr)) continue;		/* Set start condition */

     tempah = SiS_Pr->SiS_DDC_DeviceAddr;

     temp = SiS_WriteDDC2Data(SiS_Pr,tempah);	/* Write DAB (S0=0=write) */

     if(temp) continue;				/*    (ERROR: no ack) */

     tempah = *mydataptr++;

     temp = SiS_WriteDDC2Data(SiS_Pr,tempah);	/* Write register number */

     if(temp) continue;				/*    (ERROR: no ack) */

     for(j=0; j<num; j++) {

        tempah = *mydataptr++;

        temp = SiS_WriteDDC2Data(SiS_Pr,tempah);/* Write DAB (S0=0=write) */

	if(temp) break;

     }

     if(temp) continue;

     if(SiS_SetStop(SiS_Pr)) continue;

     return mydataptr;

  }

  return NULL;

}



static bool

SiS_SetTrumpionBlock(struct SiS_Private *SiS_Pr, unsigned char *dataptr)

{

  SiS_Pr->SiS_DDC_DeviceAddr = 0xF0;  		/* DAB (Device Address Byte) */

  SiS_Pr->SiS_DDC_Index = 0x11;			/* Bit 0 = SC;  Bit 1 = SD */

  SiS_Pr->SiS_DDC_Data  = 0x02;			/* Bitmask in IndexReg for Data */

  SiS_Pr->SiS_DDC_Clk   = 0x01;			/* Bitmask in IndexReg for Clk */

  SiS_SetupDDCN(SiS_Pr);



  SiS_SetSwitchDDC2(SiS_Pr);



  while(*dataptr) {

     dataptr = SiS_SetTrumpBlockLoop(SiS_Pr, dataptr);

     if(!dataptr) return false;

  }

  return true;

}

#endif



 The Chrontel 700x is connected to the 630/730 via

 */



static bool

SiS_SetChReg(struct SiS_Private *SiS_Pr, unsigned short reg, unsigned char val, unsigned short myor)

{

  unsigned short temp, i;



  for(i=0; i<20; i++) {				/* Do 20 attempts to write */

     if(i) {

	SiS_SetStop(SiS_Pr);

	SiS_DDC2Delay(SiS_Pr,SiS_I2CDELAYSHORT * 4);

     }

     if(SiS_SetStart(SiS_Pr)) continue;					/* Set start condition */

     temp = SiS_WriteDDC2Data(SiS_Pr, SiS_Pr->SiS_DDC_DeviceAddr);	/* Write DAB (S0=0=write) */

     if(temp) continue;							/*    (ERROR: no ack) */

     temp = SiS_WriteDDC2Data(SiS_Pr, (reg | myor));			/* Write RAB (700x: set bit 7, see datasheet) */

     if(temp) continue;							/*    (ERROR: no ack) */

     temp = SiS_WriteDDC2Data(SiS_Pr, val);				/* Write data */

     if(temp) continue;							/*    (ERROR: no ack) */

     if(SiS_SetStop(SiS_Pr)) continue;					/* Set stop condition */

     SiS_Pr->SiS_ChrontelInit = 1;

     return true;

  }

  return false;

}



/* Write to Chrontel 700x */

void

SiS_SetCH700x(struct SiS_Private *SiS_Pr, unsigned short reg, unsigned char val)

{

  SiS_Pr->SiS_DDC_DeviceAddr = 0xEA;  		/* DAB (Device Address Byte) */



  SiS_DDC2Delay(SiS_Pr,SiS_I2CDELAYSHORT);



  if(!(SiS_Pr->SiS_ChrontelInit)) {

     SiS_Pr->SiS_DDC_Index = 0x11;		/* Bit 0 = SC;  Bit 1 = SD */

     SiS_Pr->SiS_DDC_Data  = 0x02;		/* Bitmask in IndexReg for Data */

     SiS_Pr->SiS_DDC_Clk   = 0x01;		/* Bitmask in IndexReg for Clk */

     SiS_SetupDDCN(SiS_Pr);

  }



  if( (!(SiS_SetChReg(SiS_Pr, reg, val, 0x80))) &&

      (!(SiS_Pr->SiS_ChrontelInit)) ) {

     SiS_Pr->SiS_DDC_Index = 0x0a;

     SiS_Pr->SiS_DDC_Data  = 0x80;

     SiS_Pr->SiS_DDC_Clk   = 0x40;

     SiS_SetupDDCN(SiS_Pr);



     SiS_SetChReg(SiS_Pr, reg, val, 0x80);

  }

}



/* Write to Chrontel 701x */

/* Parameter is [Data (S15-S8) | Register no (S7-S0)] */

void

SiS_SetCH701x(struct SiS_Private *SiS_Pr, unsigned short reg, unsigned char val)

{

  SiS_Pr->SiS_DDC_Index = 0x11;			/* Bit 0 = SC;  Bit 1 = SD */

  SiS_Pr->SiS_DDC_Data  = 0x08;			/* Bitmask in IndexReg for Data */

  SiS_Pr->SiS_DDC_Clk   = 0x04;			/* Bitmask in IndexReg for Clk */

  SiS_SetupDDCN(SiS_Pr);

  SiS_Pr->SiS_DDC_DeviceAddr = 0xEA;		/* DAB (Device Address Byte) */

  SiS_SetChReg(SiS_Pr, reg, val, 0);

}



static

void

SiS_SetCH70xx(struct SiS_Private *SiS_Pr, unsigned short reg, unsigned char val)

{

  if(SiS_Pr->SiS_IF_DEF_CH70xx == 1)

     SiS_SetCH700x(SiS_Pr, reg, val);

  else

     SiS_SetCH701x(SiS_Pr, reg, val);

}



static unsigned short

SiS_GetChReg(struct SiS_Private *SiS_Pr, unsigned short myor)

{

  unsigned short tempah, temp, i;



  for(i=0; i<20; i++) {				/* Do 20 attempts to read */

     if(i) {

	SiS_SetStop(SiS_Pr);

	SiS_DDC2Delay(SiS_Pr,SiS_I2CDELAYSHORT * 4);

     }

     if(SiS_SetStart(SiS_Pr)) continue;					/* Set start condition */

     temp = SiS_WriteDDC2Data(SiS_Pr,SiS_Pr->SiS_DDC_DeviceAddr);	/* Write DAB (S0=0=write) */

     if(temp) continue;							/*        (ERROR: no ack) */

     temp = SiS_WriteDDC2Data(SiS_Pr,SiS_Pr->SiS_DDC_ReadAddr | myor);	/* Write RAB (700x: | 0x80) */

     if(temp) continue;							/*        (ERROR: no ack) */

     if (SiS_SetStart(SiS_Pr)) continue;				/* Re-start */

     temp = SiS_WriteDDC2Data(SiS_Pr,SiS_Pr->SiS_DDC_DeviceAddr | 0x01);/* DAB (S0=1=read) */

     if(temp) continue;							/*        (ERROR: no ack) */

     tempah = SiS_ReadDDC2Data(SiS_Pr);					/* Read byte */

     if(SiS_SetStop(SiS_Pr)) continue;					/* Stop condition */

     SiS_Pr->SiS_ChrontelInit = 1;

     return tempah;

  }

  return 0xFFFF;

}



/* Read from Chrontel 700x */

/* Parameter is [Register no (S7-S0)] */

unsigned short

SiS_GetCH700x(struct SiS_Private *SiS_Pr, unsigned short tempbx)

{

  unsigned short result;



  SiS_Pr->SiS_DDC_DeviceAddr = 0xEA;		/* DAB */



  SiS_DDC2Delay(SiS_Pr,SiS_I2CDELAYSHORT);



  if(!(SiS_Pr->SiS_ChrontelInit)) {

     SiS_Pr->SiS_DDC_Index = 0x11;		/* Bit 0 = SC;  Bit 1 = SD */

     SiS_Pr->SiS_DDC_Data  = 0x02;		/* Bitmask in IndexReg for Data */

     SiS_Pr->SiS_DDC_Clk   = 0x01;		/* Bitmask in IndexReg for Clk */

     SiS_SetupDDCN(SiS_Pr);

  }



  SiS_Pr->SiS_DDC_ReadAddr = tempbx;



  if( ((result = SiS_GetChReg(SiS_Pr,0x80)) == 0xFFFF) &&

      (!SiS_Pr->SiS_ChrontelInit) ) {



     SiS_Pr->SiS_DDC_Index = 0x0a;

     SiS_Pr->SiS_DDC_Data  = 0x80;

     SiS_Pr->SiS_DDC_Clk   = 0x40;

     SiS_SetupDDCN(SiS_Pr);



     result = SiS_GetChReg(SiS_Pr,0x80);

  }

  return result;

}



/* Read from Chrontel 701x */

/* Parameter is [Register no (S7-S0)] */

unsigned short

SiS_GetCH701x(struct SiS_Private *SiS_Pr, unsigned short tempbx)

{

  SiS_Pr->SiS_DDC_Index = 0x11;			/* Bit 0 = SC;  Bit 1 = SD */

  SiS_Pr->SiS_DDC_Data  = 0x08;			/* Bitmask in IndexReg for Data */

  SiS_Pr->SiS_DDC_Clk   = 0x04;			/* Bitmask in IndexReg for Clk */

  SiS_SetupDDCN(SiS_Pr);

  SiS_Pr->SiS_DDC_DeviceAddr = 0xEA;		/* DAB */



  SiS_Pr->SiS_DDC_ReadAddr = tempbx;



  return SiS_GetChReg(SiS_Pr,0);

}



/* Read from Chrontel 70xx */

/* Parameter is [Register no (S7-S0)] */

static

unsigned short

SiS_GetCH70xx(struct SiS_Private *SiS_Pr, unsigned short tempbx)

{

  if(SiS_Pr->SiS_IF_DEF_CH70xx == 1)

     return SiS_GetCH700x(SiS_Pr, tempbx);

  else

     return SiS_GetCH701x(SiS_Pr, tempbx);

}



void

SiS_SetCH70xxANDOR(struct SiS_Private *SiS_Pr, unsigned short reg,

		unsigned char myor, unsigned short myand)

{

  unsigned short tempbl;



  tempbl = (SiS_GetCH70xx(SiS_Pr, (reg & 0xFF)) & myand) | myor;

  SiS_SetCH70xx(SiS_Pr, reg, tempbl);

}



/* Our own DDC functions */

static

unsigned short

SiS_InitDDCRegs(struct SiS_Private *SiS_Pr, unsigned int VBFlags, int VGAEngine,

                unsigned short adaptnum, unsigned short DDCdatatype, bool checkcr32,

		unsigned int VBFlags2)

{

     unsigned char ddcdtype[] = { 0xa0, 0xa0, 0xa0, 0xa2, 0xa6 };

     unsigned char flag, cr32;

     unsigned short        temp = 0, myadaptnum = adaptnum;



     if(adaptnum != 0) {

	if(!(VBFlags2 & VB2_SISTMDSBRIDGE)) return 0xFFFF;

	if((VBFlags2 & VB2_30xBDH) && (adaptnum == 1)) return 0xFFFF;

     }



     /* adapternum for SiS bridges: 0 = CRT1, 1 = LCD, 2 = VGA2 */



     SiS_Pr->SiS_ChrontelInit = 0;   /* force re-detection! */



     SiS_Pr->SiS_DDC_SecAddr = 0;

     SiS_Pr->SiS_DDC_DeviceAddr = ddcdtype[DDCdatatype];

     SiS_Pr->SiS_DDC_Port = SiS_Pr->SiS_P3c4;

     SiS_Pr->SiS_DDC_Index = 0x11;

     flag = 0xff;



     cr32 = SiS_GetReg(SiS_Pr->SiS_P3d4,0x32);



#if 0

     if(VBFlags2 & VB2_SISBRIDGE) {

	if(myadaptnum == 0) {

	   if(!(cr32 & 0x20)) {

	      myadaptnum = 2;

	      if(!(cr32 & 0x10)) {

	         myadaptnum = 1;

		 if(!(cr32 & 0x08)) {

		    myadaptnum = 0;

		 }

	      }

	   }

        }

     }

#endif



     if(VGAEngine == SIS_300_VGA) {		/* 300 series */



        if(myadaptnum != 0) {

	   flag = 0;

	   if(VBFlags2 & VB2_SISBRIDGE) {

	      SiS_Pr->SiS_DDC_Port = SiS_Pr->SiS_Part4Port;

              SiS_Pr->SiS_DDC_Index = 0x0f;

	   }

        }



	if(!(VBFlags2 & VB2_301)) {

	   if((cr32 & 0x80) && (checkcr32)) {

              if(myadaptnum >= 1) {

	         if(!(cr32 & 0x08)) {

		     myadaptnum = 1;

		     if(!(cr32 & 0x10)) return 0xFFFF;

                 }

	      }

	   }

	}



	temp = 4 - (myadaptnum * 2);

	if(flag) temp = 0;



     } else {						/* 315/330 series */



	/* here we simplify: 0 = CRT1, 1 = CRT2 (VGA, LCD) */



	if(VBFlags2 & VB2_SISBRIDGE) {

	   if(myadaptnum == 2) {

	      myadaptnum = 1;

	   }

	}



        if(myadaptnum == 1) {

	   flag = 0;

	   if(VBFlags2 & VB2_SISBRIDGE) {

	      SiS_Pr->SiS_DDC_Port = SiS_Pr->SiS_Part4Port;

              SiS_Pr->SiS_DDC_Index = 0x0f;

	   }

        }



        if((cr32 & 0x80) && (checkcr32)) {

           if(myadaptnum >= 1) {

	      if(!(cr32 & 0x08)) {

	         myadaptnum = 1;

		 if(!(cr32 & 0x10)) return 0xFFFF;

	      }

	   }

        }



        temp = myadaptnum;

        if(myadaptnum == 1) {

           temp = 0;

	   if(VBFlags2 & VB2_LVDS) flag = 0xff;

        }



	if(flag) temp = 0;

    }



    SiS_Pr->SiS_DDC_Data = 0x02 << temp;

    SiS_Pr->SiS_DDC_Clk  = 0x01 << temp;



    SiS_SetupDDCN(SiS_Pr);



    return 0;

}



static unsigned short

SiS_WriteDABDDC(struct SiS_Private *SiS_Pr)

{

   if(SiS_SetStart(SiS_Pr)) return 0xFFFF;

   if(SiS_WriteDDC2Data(SiS_Pr, SiS_Pr->SiS_DDC_DeviceAddr)) {

      return 0xFFFF;

   }

   if(SiS_WriteDDC2Data(SiS_Pr, SiS_Pr->SiS_DDC_SecAddr)) {

      return 0xFFFF;

   }

   return 0;

}



static unsigned short

SiS_PrepareReadDDC(struct SiS_Private *SiS_Pr)

{

   if(SiS_SetStart(SiS_Pr)) return 0xFFFF;

   if(SiS_WriteDDC2Data(SiS_Pr, (SiS_Pr->SiS_DDC_DeviceAddr | 0x01))) {

      return 0xFFFF;

   }

   return 0;

}



static unsigned short

SiS_PrepareDDC(struct SiS_Private *SiS_Pr)

{

   if(SiS_WriteDABDDC(SiS_Pr)) SiS_WriteDABDDC(SiS_Pr);

   if(SiS_PrepareReadDDC(SiS_Pr)) return (SiS_PrepareReadDDC(SiS_Pr));

   return 0;

}



static void

SiS_SendACK(struct SiS_Private *SiS_Pr, unsigned short yesno)

{

   SiS_SetSCLKLow(SiS_Pr);

   if(yesno) {

      SiS_SetRegANDOR(SiS_Pr->SiS_DDC_Port,

		      SiS_Pr->SiS_DDC_Index,

		      SiS_Pr->SiS_DDC_NData,

		      SiS_Pr->SiS_DDC_Data);

   } else {

      SiS_SetRegANDOR(SiS_Pr->SiS_DDC_Port,

		      SiS_Pr->SiS_DDC_Index,

		      SiS_Pr->SiS_DDC_NData,

		      0);

   }

   SiS_SetSCLKHigh(SiS_Pr);

}



static unsigned short

SiS_DoProbeDDC(struct SiS_Private *SiS_Pr)

{

    unsigned char mask, value;

    unsigned short  temp, ret=0;

    bool failed = false;



    SiS_SetSwitchDDC2(SiS_Pr);

    if(SiS_PrepareDDC(SiS_Pr)) {

         SiS_SetStop(SiS_Pr);

         return 0xFFFF;

    }

    mask = 0xf0;

    value = 0x20;

    if(SiS_Pr->SiS_DDC_DeviceAddr == 0xa0) {

       temp = (unsigned char)SiS_ReadDDC2Data(SiS_Pr);

       SiS_SendACK(SiS_Pr, 0);

       if(temp == 0) {

           mask = 0xff;

	   value = 0xff;

       } else {

           failed = true;

	   ret = 0xFFFF;

       }

    }

    if(!failed) {

       temp = (unsigned char)SiS_ReadDDC2Data(SiS_Pr);

       SiS_SendACK(SiS_Pr, 1);

       temp &= mask;

       if(temp == value) ret = 0;

       else {

          ret = 0xFFFF;

          if(SiS_Pr->SiS_DDC_DeviceAddr == 0xa0) {

             if(temp == 0x30) ret = 0;

          }

       }

    }

    SiS_SetStop(SiS_Pr);

    return ret;

}



static

unsigned short

SiS_ProbeDDC(struct SiS_Private *SiS_Pr)

{

   unsigned short flag;



   flag = 0x180;

   SiS_Pr->SiS_DDC_DeviceAddr = 0xa0;

   if(!(SiS_DoProbeDDC(SiS_Pr))) flag |= 0x02;

   SiS_Pr->SiS_DDC_DeviceAddr = 0xa2;

   if(!(SiS_DoProbeDDC(SiS_Pr))) flag |= 0x08;

   SiS_Pr->SiS_DDC_DeviceAddr = 0xa6;

   if(!(SiS_DoProbeDDC(SiS_Pr))) flag |= 0x10;

   if(!(flag & 0x1a)) flag = 0;

   return flag;

}



static

unsigned short

SiS_ReadDDC(struct SiS_Private *SiS_Pr, unsigned short DDCdatatype, unsigned char *buffer)

{

   unsigned short flag, length, i;

   unsigned char chksum,gotcha;



   if(DDCdatatype > 4) return 0xFFFF;



   flag = 0;

   SiS_SetSwitchDDC2(SiS_Pr);

   if(!(SiS_PrepareDDC(SiS_Pr))) {

      length = 127;

      if(DDCdatatype != 1) length = 255;

      chksum = 0;

      gotcha = 0;

      for(i=0; i<length; i++) {

	 buffer[i] = (unsigned char)SiS_ReadDDC2Data(SiS_Pr);

	 chksum += buffer[i];

	 gotcha |= buffer[i];

	 SiS_SendACK(SiS_Pr, 0);

      }

      buffer[i] = (unsigned char)SiS_ReadDDC2Data(SiS_Pr);

      chksum += buffer[i];

      SiS_SendACK(SiS_Pr, 1);

      if(gotcha) flag = (unsigned short)chksum;

      else flag = 0xFFFF;

   } else {

      flag = 0xFFFF;

   }

   SiS_SetStop(SiS_Pr);

   return flag;

}



 Our private DDC functions

 */

unsigned short

SiS_HandleDDC(struct SiS_Private *SiS_Pr, unsigned int VBFlags, int VGAEngine,

              unsigned short adaptnum, unsigned short DDCdatatype, unsigned char *buffer,

	      unsigned int VBFlags2)

{

   unsigned char  sr1f, cr17=1;

   unsigned short result;



   if(adaptnum > 2)

      return 0xFFFF;



   if(DDCdatatype > 4)

      return 0xFFFF;



   if((!(VBFlags2 & VB2_VIDEOBRIDGE)) && (adaptnum > 0))

      return 0xFFFF;



   if(SiS_InitDDCRegs(SiS_Pr, VBFlags, VGAEngine, adaptnum, DDCdatatype, false, VBFlags2) == 0xFFFF)

      return 0xFFFF;



   sr1f = SiS_GetReg(SiS_Pr->SiS_P3c4,0x1f);

   SiS_SetRegANDOR(SiS_Pr->SiS_P3c4,0x1f,0x3f,0x04);

   if(VGAEngine == SIS_300_VGA) {

      cr17 = SiS_GetReg(SiS_Pr->SiS_P3d4,0x17) & 0x80;

      if(!cr17) {

         SiS_SetRegOR(SiS_Pr->SiS_P3d4,0x17,0x80);

         SiS_SetReg(SiS_Pr->SiS_P3c4,0x00,0x01);

         SiS_SetReg(SiS_Pr->SiS_P3c4,0x00,0x03);

      }

   }

   if((sr1f) || (!cr17)) {

      SiS_WaitRetrace1(SiS_Pr);

      SiS_WaitRetrace1(SiS_Pr);

      SiS_WaitRetrace1(SiS_Pr);

      SiS_WaitRetrace1(SiS_Pr);

   }



   if(DDCdatatype == 0) {

      result = SiS_ProbeDDC(SiS_Pr);

   } else {

      result = SiS_ReadDDC(SiS_Pr, DDCdatatype, buffer);

      if((!result) && (DDCdatatype == 1)) {

         if((buffer[0] == 0x00) && (buffer[1] == 0xff) &&

	    (buffer[2] == 0xff) && (buffer[3] == 0xff) &&

	    (buffer[4] == 0xff) && (buffer[5] == 0xff) &&

	    (buffer[6] == 0xff) && (buffer[7] == 0x00) &&

	    (buffer[0x12] == 1)) {

	    if(!SiS_Pr->DDCPortMixup) {

	       if(adaptnum == 1) {

	          if(!(buffer[0x14] & 0x80)) result = 0xFFFE;

	       } else {

	          if(buffer[0x14] & 0x80)    result = 0xFFFE;

	       }

	    }

	 }

      }

   }

   SiS_SetReg(SiS_Pr->SiS_P3c4,0x1f,sr1f);

   if(VGAEngine == SIS_300_VGA) {

      SiS_SetRegANDOR(SiS_Pr->SiS_P3d4,0x17,0x7f,cr17);

   }

   return result;

}



/* Generic I2C functions for Chrontel & DDC --------- */



static void

SiS_SetSwitchDDC2(struct SiS_Private *SiS_Pr)

{

  SiS_SetSCLKHigh(SiS_Pr);

  SiS_WaitRetrace1(SiS_Pr);



  SiS_SetSCLKLow(SiS_Pr);

  SiS_WaitRetrace1(SiS_Pr);

}



unsigned short

SiS_ReadDDC1Bit(struct SiS_Private *SiS_Pr)

{

   SiS_WaitRetrace1(SiS_Pr);

   return ((SiS_GetReg(SiS_Pr->SiS_P3c4,0x11) & 0x02) >> 1);

}



/* Set I2C start condition */

/* This is done by a SD high-to-low transition while SC is high */

static unsigned short

SiS_SetStart(struct SiS_Private *SiS_Pr)

{

  if(SiS_SetSCLKLow(SiS_Pr)) return 0xFFFF;			/* (SC->low)  */

  SiS_SetRegANDOR(SiS_Pr->SiS_DDC_Port,

		  SiS_Pr->SiS_DDC_Index,

		  SiS_Pr->SiS_DDC_NData,

		  SiS_Pr->SiS_DDC_Data);        		/* SD->high */

  if(SiS_SetSCLKHigh(SiS_Pr)) return 0xFFFF;			/* SC->high */

  SiS_SetRegANDOR(SiS_Pr->SiS_DDC_Port,

		  SiS_Pr->SiS_DDC_Index,

		  SiS_Pr->SiS_DDC_NData,

		  0x00);					/* SD->low = start condition */

  if(SiS_SetSCLKHigh(SiS_Pr)) return 0xFFFF;			/* (SC->low) */

  return 0;

}



/* Set I2C stop condition */

/* This is done by a SD low-to-high transition while SC is high */

static unsigned short

SiS_SetStop(struct SiS_Private *SiS_Pr)

{

  if(SiS_SetSCLKLow(SiS_Pr)) return 0xFFFF;			/* (SC->low) */

  SiS_SetRegANDOR(SiS_Pr->SiS_DDC_Port,

		  SiS_Pr->SiS_DDC_Index,

		  SiS_Pr->SiS_DDC_NData,

		  0x00);					/* SD->low   */

  if(SiS_SetSCLKHigh(SiS_Pr)) return 0xFFFF;			/* SC->high  */

  SiS_SetRegANDOR(SiS_Pr->SiS_DDC_Port,

		  SiS_Pr->SiS_DDC_Index,

		  SiS_Pr->SiS_DDC_NData,

		  SiS_Pr->SiS_DDC_Data);			/* SD->high = stop condition */

  if(SiS_SetSCLKHigh(SiS_Pr)) return 0xFFFF;			/* (SC->high) */

  return 0;

}



/* Write 8 bits of data */

static unsigned short

SiS_WriteDDC2Data(struct SiS_Private *SiS_Pr, unsigned short tempax)

{

  unsigned short i,flag,temp;



  flag = 0x80;

  for(i = 0; i < 8; i++) {

    SiS_SetSCLKLow(SiS_Pr);					/* SC->low */

    if(tempax & flag) {

      SiS_SetRegANDOR(SiS_Pr->SiS_DDC_Port,

		      SiS_Pr->SiS_DDC_Index,

		      SiS_Pr->SiS_DDC_NData,

		      SiS_Pr->SiS_DDC_Data);			/* Write bit (1) to SD */

    } else {

      SiS_SetRegANDOR(SiS_Pr->SiS_DDC_Port,

		      SiS_Pr->SiS_DDC_Index,

		      SiS_Pr->SiS_DDC_NData,

		      0x00);					/* Write bit (0) to SD */

    }

    SiS_SetSCLKHigh(SiS_Pr);					/* SC->high */

    flag >>= 1;

  }

  temp = SiS_CheckACK(SiS_Pr);					/* Check acknowledge */

  return temp;

}



static unsigned short

SiS_ReadDDC2Data(struct SiS_Private *SiS_Pr)

{

  unsigned short i, temp, getdata;



  getdata = 0;

  for(i = 0; i < 8; i++) {

    getdata <<= 1;

    SiS_SetSCLKLow(SiS_Pr);

    SiS_SetRegANDOR(SiS_Pr->SiS_DDC_Port,

		    SiS_Pr->SiS_DDC_Index,

		    SiS_Pr->SiS_DDC_NData,

		    SiS_Pr->SiS_DDC_Data);

    SiS_SetSCLKHigh(SiS_Pr);

    temp = SiS_GetReg(SiS_Pr->SiS_DDC_Port,SiS_Pr->SiS_DDC_Index);

    if(temp & SiS_Pr->SiS_DDC_Data) getdata |= 0x01;

  }

  return getdata;

}



static unsigned short

SiS_SetSCLKLow(struct SiS_Private *SiS_Pr)

{

  SiS_SetRegANDOR(SiS_Pr->SiS_DDC_Port,

		  SiS_Pr->SiS_DDC_Index,

		  SiS_Pr->SiS_DDC_NClk,

		  0x00);					/* SetSCLKLow()  */

  SiS_DDC2Delay(SiS_Pr,SiS_I2CDELAYSHORT);

  return 0;

}



static unsigned short

SiS_SetSCLKHigh(struct SiS_Private *SiS_Pr)

{

  unsigned short temp, watchdog=1000;



  SiS_SetRegANDOR(SiS_Pr->SiS_DDC_Port,

		  SiS_Pr->SiS_DDC_Index,

		  SiS_Pr->SiS_DDC_NClk,

		  SiS_Pr->SiS_DDC_Clk);  			/* SetSCLKHigh()  */

  do {

    temp = SiS_GetReg(SiS_Pr->SiS_DDC_Port,SiS_Pr->SiS_DDC_Index);

  } while((!(temp & SiS_Pr->SiS_DDC_Clk)) && --watchdog);

  if (!watchdog) {

  	return 0xFFFF;

  }

  SiS_DDC2Delay(SiS_Pr,SiS_I2CDELAYSHORT);

  return 0;

}



/* Check I2C acknowledge */

/* Returns 0 if ack ok, non-0 if ack not ok */

static unsigned short

SiS_CheckACK(struct SiS_Private *SiS_Pr)

{

  unsigned short tempah;



  SiS_SetSCLKLow(SiS_Pr);				           /* (SC->low) */

  SiS_SetRegANDOR(SiS_Pr->SiS_DDC_Port,

		  SiS_Pr->SiS_DDC_Index,

		  SiS_Pr->SiS_DDC_NData,

		  SiS_Pr->SiS_DDC_Data);			   /* (SD->high) */

  SiS_SetSCLKHigh(SiS_Pr);				           /* SC->high = clock impulse for ack */

  tempah = SiS_GetReg(SiS_Pr->SiS_DDC_Port,SiS_Pr->SiS_DDC_Index); /* Read SD */

  SiS_SetSCLKLow(SiS_Pr);				           /* SC->low = end of clock impulse */

  if(tempah & SiS_Pr->SiS_DDC_Data) return 1;			   /* Ack OK if bit = 0 */

  return 0;

}



/* End of I2C functions ----------------------- */





/* =============== SiS 315/330 O.E.M. ================= */



#ifdef CONFIG_FB_SIS_315



static unsigned short

GetRAMDACromptr(struct SiS_Private *SiS_Pr)

{

  unsigned char  *ROMAddr = SiS_Pr->VirtualRomBase;

  unsigned short romptr;



  if(SiS_Pr->ChipType < SIS_330) {

     romptr = SISGETROMW(0x128);

     if(SiS_Pr->SiS_VBType & VB_SIS30xB)

        romptr = SISGETROMW(0x12a);

  } else {

     romptr = SISGETROMW(0x1a8);

     if(SiS_Pr->SiS_VBType & VB_SIS30xB)

        romptr = SISGETROMW(0x1aa);

  }

  return romptr;

}



static unsigned short

GetLCDromptr(struct SiS_Private *SiS_Pr)

{

  unsigned char  *ROMAddr = SiS_Pr->VirtualRomBase;

  unsigned short romptr;



  if(SiS_Pr->ChipType < SIS_330) {

     romptr = SISGETROMW(0x120);

     if(SiS_Pr->SiS_VBType & VB_SIS30xBLV)

        romptr = SISGETROMW(0x122);

  } else {

     romptr = SISGETROMW(0x1a0);

     if(SiS_Pr->SiS_VBType & VB_SIS30xBLV)

        romptr = SISGETROMW(0x1a2);

  }

  return romptr;

}



static unsigned short

GetTVromptr(struct SiS_Private *SiS_Pr)

{

  unsigned char  *ROMAddr = SiS_Pr->VirtualRomBase;

  unsigned short romptr;



  if(SiS_Pr->ChipType < SIS_330) {

     romptr = SISGETROMW(0x114);

     if(SiS_Pr->SiS_VBType & VB_SIS30xBLV)

        romptr = SISGETROMW(0x11a);

  } else {

     romptr = SISGETROMW(0x194);

     if(SiS_Pr->SiS_VBType & VB_SIS30xBLV)

        romptr = SISGETROMW(0x19a);

  }

  return romptr;

}



static unsigned short

GetLCDPtrIndexBIOS(struct SiS_Private *SiS_Pr)

{

  unsigned short index;



  if((IS_SIS650) && (SiS_Pr->SiS_VBType & VB_SISLVDS)) {

     if(!(SiS_IsNotM650orLater(SiS_Pr))) {

        if((index = SiS_GetReg(SiS_Pr->SiS_P3d4,0x36) & 0xf0)) {

	   index >>= 4;

	   index *= 3;

	   if(SiS_Pr->SiS_LCDInfo & DontExpandLCD) index += 2;

           else if(!(SiS_Pr->SiS_SetFlag & LCDVESATiming)) index++;

           return index;

	}

     }

  }



  index = SiS_GetBIOSLCDResInfo(SiS_Pr) & 0x0F;

  if(SiS_Pr->SiS_LCDResInfo == Panel_1400x1050)      index -= 5;

  if(SiS_Pr->SiS_VBType & VB_SIS301C) {  /* 1.15.20 and later (not VB specific) */

     if(SiS_Pr->SiS_LCDResInfo == Panel_1600x1200) index -= 5;

     if(SiS_Pr->SiS_LCDResInfo == Panel_1280x768) index -= 5;

  } else {

     if(SiS_Pr->SiS_LCDResInfo == Panel_1600x1200) index -= 6;

  }

  index--;

  index *= 3;

  if(SiS_Pr->SiS_LCDInfo & DontExpandLCD) index += 2;

  else if(!(SiS_Pr->SiS_SetFlag & LCDVESATiming)) index++;

  return index;

}



static unsigned short

GetLCDPtrIndex(struct SiS_Private *SiS_Pr)

{

  unsigned short index;



  index = ((SiS_GetBIOSLCDResInfo(SiS_Pr) & 0x0F) - 1) * 3;

  if(SiS_Pr->SiS_LCDInfo & DontExpandLCD)         index += 2;

  else if(!(SiS_Pr->SiS_SetFlag & LCDVESATiming)) index++;

  return index;

}



static unsigned short

GetTVPtrIndex(struct SiS_Private *SiS_Pr)

{

  unsigned short index;



  index = 0;

  if(SiS_Pr->SiS_TVMode & TVSetPAL) index = 1;

  if(SiS_Pr->SiS_VBInfo & SetCRT2ToHiVision) index = 2;



  if(SiS_Pr->SiS_VBInfo & SetCRT2ToYPbPr525750) index = 0;



  index <<= 1;



  if((SiS_Pr->SiS_VBInfo & SetInSlaveMode) &&

     (SiS_Pr->SiS_TVMode & TVSetTVSimuMode)) {

     index++;

  }



  return index;

}



static unsigned int

GetOEMTVPtr661_2_GEN(struct SiS_Private *SiS_Pr, int addme)

{

   unsigned short index = 0, temp = 0;



   if(SiS_Pr->SiS_TVMode & TVSetPAL)   index = 1;

   if(SiS_Pr->SiS_TVMode & TVSetPALM)  index = 2;

   if(SiS_Pr->SiS_TVMode & TVSetPALN)  index = 3;

   if(SiS_Pr->SiS_TVMode & TVSetNTSCJ) index = 6;

   if(SiS_Pr->SiS_TVMode & TVSetNTSC1024) {

      index = 4;

      if(SiS_Pr->SiS_TVMode & TVSetPALM)  index++;

      if(SiS_Pr->SiS_TVMode & TVSetNTSCJ) index = 7;

   }



   if(SiS_Pr->SiS_VBType & VB_SIS30xBLV) {

      if((!(SiS_Pr->SiS_VBInfo & SetInSlaveMode)) ||

         (SiS_Pr->SiS_TVMode & TVSetTVSimuMode)) {

	 index += addme;

	 temp++;

      }

      temp += 0x0100;

   }

   return (unsigned int)(index | (temp << 16));

}



static unsigned int

GetOEMTVPtr661_2_OLD(struct SiS_Private *SiS_Pr)

{

   return (GetOEMTVPtr661_2_GEN(SiS_Pr, 8));

}



#if 0

static unsigned int

GetOEMTVPtr661_2_NEW(struct SiS_Private *SiS_Pr)

{

   return (GetOEMTVPtr661_2_GEN(SiS_Pr, 6));

}

#endif



static int

GetOEMTVPtr661(struct SiS_Private *SiS_Pr)

{

   int index = 0;



   if(SiS_Pr->SiS_TVMode & TVSetPAL)          index = 2;

   if(SiS_Pr->SiS_ROMNew) {

      if(SiS_Pr->SiS_TVMode & TVSetYPbPr525i) index = 4;

      if(SiS_Pr->SiS_TVMode & TVSetYPbPr525p) index = 6;

      if(SiS_Pr->SiS_TVMode & TVSetYPbPr750p) index = 8;

      if(SiS_Pr->SiS_TVMode & TVSetHiVision)  index = 10;

   } else {

      if(SiS_Pr->SiS_TVMode & TVSetHiVision)  index = 4;

      if(SiS_Pr->SiS_TVMode & TVSetYPbPr525i) index = 6;

      if(SiS_Pr->SiS_TVMode & TVSetYPbPr525p) index = 8;

      if(SiS_Pr->SiS_TVMode & TVSetYPbPr750p) index = 10;

   }



   if(SiS_Pr->SiS_TVMode & TVSetTVSimuMode) index++;



   return index;

}



static void

SetDelayComp(struct SiS_Private *SiS_Pr, unsigned short ModeNo)

{

  unsigned char  *ROMAddr = SiS_Pr->VirtualRomBase;

  unsigned short delay=0,index,myindex,temp,romptr=0;

  bool dochiptest = true;



  if(SiS_Pr->SiS_VBInfo & SetCRT2ToLCDA) {

     SiS_SetRegAND(SiS_Pr->SiS_Part1Port,0x20,0xbf);

  } else {

     SiS_SetRegAND(SiS_Pr->SiS_Part1Port,0x35,0x7f);

  }



  /* Find delay (from ROM, internal tables, PCI subsystem) */



  if(SiS_Pr->SiS_VBInfo & SetCRT2ToRAMDAC) {			/* ------------ VGA */



     if((SiS_Pr->SiS_UseROM) && (!(SiS_Pr->SiS_ROMNew))) {

        romptr = GetRAMDACromptr(SiS_Pr);

     }

     if(romptr) delay = ROMAddr[romptr];

     else {

        delay = 0x04;

        if(SiS_Pr->SiS_VBType & VB_SIS30xB) {

	   if(IS_SIS650) {

	      delay = 0x0a;

	   } else if(IS_SIS740) {

	      delay = 0x00;

	   } else {

	      delay = 0x0c;

	   }

	} else if(SiS_Pr->SiS_IF_DEF_LVDS == 1) {

           delay = 0x00;

	}

     }



  } else if(SiS_Pr->SiS_VBInfo & (SetCRT2ToLCD|SetCRT2ToLCDA)) {  /* ----------	LCD/LCDA */



     bool gotitfrompci = false;



     /* Could we detect a PDC for LCD or did we get a user-defined? If yes, use it */



     if(SiS_Pr->SiS_VBInfo & SetCRT2ToLCD) {

	if(SiS_Pr->PDC != -1) {

           SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x2d,0xf0,((SiS_Pr->PDC >> 1) & 0x0f));

	   SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x35,0x7f,((SiS_Pr->PDC & 0x01) << 7));

	   return;

	}

     } else {

	if(SiS_Pr->PDCA != -1) {

	   SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x2d,0x0f,((SiS_Pr->PDCA << 3) & 0xf0));

	   SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x20,0xbf,((SiS_Pr->PDCA & 0x01) << 6));

	   return;

	}

     }



     /* Custom Panel? */



     if(SiS_Pr->SiS_LCDResInfo == Panel_Custom) {

        if(SiS_Pr->SiS_VBInfo & SetCRT2ToLCDA) {

	   delay = 0x00;

	   if((SiS_Pr->PanelXRes <= 1280) && (SiS_Pr->PanelYRes <= 1024)) {

	      delay = 0x20;

	   }

	   SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x2d,0x0f,delay);

	} else {

	   delay = 0x0c;

	   if(SiS_Pr->SiS_VBType & VB_SIS301C) {

	      delay = 0x03;

	      if((SiS_Pr->PanelXRes > 1280) && (SiS_Pr->PanelYRes > 1024)) {

	         delay = 0x00;

	      }

	   } else if(SiS_Pr->SiS_VBType & VB_SISLVDS) {

	      if(IS_SIS740) delay = 0x01;

	      else          delay = 0x03;

	   }

	   SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x2d,0xf0,delay);

	}

        return;

     }



 This is a piece of typical SiS crap: They code the OEM LCD

      */



     switch(SiS_Pr->SiS_CustomT) {

     case CUT_COMPAQ1280:

     case CUT_COMPAQ12802:

	if(SiS_Pr->SiS_LCDResInfo == Panel_1280x1024) {

	   gotitfrompci = true;

	   dochiptest = false;

	   delay = 0x03;

	}

	break;

     case CUT_CLEVO1400:

     case CUT_CLEVO14002:

	gotitfrompci = true;

	dochiptest = false;

	delay = 0x02;

	break;

     case CUT_CLEVO1024:

     case CUT_CLEVO10242:

        if(SiS_Pr->SiS_LCDResInfo == Panel_1024x768) {

	   gotitfrompci = true;

	   dochiptest = false;

	   delay = 0x33;

	   SiS_SetReg(SiS_Pr->SiS_Part1Port,0x2D,delay);

	   delay &= 0x0f;

	}

	break;

     }



     /* Could we find it through the PCI ID? If no, use ROM or table */



     if(!gotitfrompci) {



        index = GetLCDPtrIndexBIOS(SiS_Pr);

        myindex = GetLCDPtrIndex(SiS_Pr);



        if(IS_SIS650 && (SiS_Pr->SiS_VBType & VB_SISLVDS)) {



           if(SiS_IsNotM650orLater(SiS_Pr)) {



              if((SiS_Pr->SiS_UseROM) && (!(SiS_Pr->SiS_ROMNew))) {

	         /* Always use the second pointer on 650; some BIOSes */

                 /* still carry old 301 data at the first location    */

	         /* romptr = SISGETROMW(0x120);                       */

	         /* if(SiS_Pr->SiS_VBType & VB_SIS302LV)              */

	         romptr = SISGETROMW(0x122);

	         if(!romptr) return;

	         delay = ROMAddr[(romptr + index)];

	      } else {

                 delay = SiS310_LCDDelayCompensation_650301LV[myindex];

	      }



          } else {



             delay = SiS310_LCDDelayCompensation_651301LV[myindex];

	     if(SiS_Pr->SiS_VBType & (VB_SIS302LV | VB_SIS302ELV))

	        delay = SiS310_LCDDelayCompensation_651302LV[myindex];



          }



        } else if(SiS_Pr->SiS_UseROM 			      &&

		  (!(SiS_Pr->SiS_ROMNew))		      &&

	          (SiS_Pr->SiS_LCDResInfo != Panel_1280x1024) &&

		  (SiS_Pr->SiS_LCDResInfo != Panel_1280x768)  &&

		  (SiS_Pr->SiS_LCDResInfo != Panel_1280x960)  &&

		  (SiS_Pr->SiS_LCDResInfo != Panel_1600x1200)  &&

		  ((romptr = GetLCDromptr(SiS_Pr)))) {



	   /* Data for 1280x1024 wrong in 301B BIOS */

	   /* Data for 1600x1200 wrong in 301C BIOS */

	   delay = ROMAddr[(romptr + index)];



        } else if(SiS_Pr->SiS_IF_DEF_LVDS == 1) {



	   if(IS_SIS740) delay = 0x03;

	   else          delay = 0x00;



	} else {



           delay = SiS310_LCDDelayCompensation_301[myindex];

	   if(SiS_Pr->SiS_VBType & VB_SISLVDS) {

	      if(IS_SIS740) delay = 0x01;

	      else if(SiS_Pr->ChipType <= SIS_315PRO) delay = SiS310_LCDDelayCompensation_3xx301LV[myindex];

	      else          delay = SiS310_LCDDelayCompensation_650301LV[myindex];

	   } else if(SiS_Pr->SiS_VBType & VB_SIS301C) {

	      if(IS_SIS740) delay = 0x01;  /* ? */

	      else          delay = 0x03;

	      if(SiS_Pr->SiS_LCDResInfo == Panel_1600x1200) delay = 0x00; /* experience */

	   } else if(SiS_Pr->SiS_VBType & VB_SIS30xB) {

	      if(IS_SIS740) delay = 0x01;

	      else          delay = SiS310_LCDDelayCompensation_3xx301B[myindex];

	   }



        }



     }  /* got it from PCI */



     if(SiS_Pr->SiS_VBInfo & SetCRT2ToLCDA) {

	SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x2D,0x0F,((delay << 4) & 0xf0));

	dochiptest = false;

     }



  } else if(SiS_Pr->SiS_VBInfo & SetCRT2ToTV) {			/* ------------ TV */



     index = GetTVPtrIndex(SiS_Pr);



     if(IS_SIS650 && (SiS_Pr->SiS_VBType & VB_SISLVDS)) {



        if(SiS_IsNotM650orLater(SiS_Pr)) {



           if((SiS_Pr->SiS_UseROM) && (!(SiS_Pr->SiS_ROMNew))) {

	      /* Always use the second pointer on 650; some BIOSes */

              /* still carry old 301 data at the first location    */

              /* romptr = SISGETROMW(0x114);			   */

	      /* if(SiS_Pr->SiS_VBType & VB_SIS302LV)              */

	      romptr = SISGETROMW(0x11a);

	      if(!romptr) return;

	      delay = ROMAddr[romptr + index];



	   } else {



	      delay = SiS310_TVDelayCompensation_301B[index];



	   }



        } else {



           switch(SiS_Pr->SiS_CustomT) {

	   case CUT_COMPAQ1280:

	   case CUT_COMPAQ12802:

	   case CUT_CLEVO1400:

	   case CUT_CLEVO14002:

	      delay = 0x02;

	      dochiptest = false;

	      break;

	   case CUT_CLEVO1024:

	   case CUT_CLEVO10242:

	      delay = 0x03;

	      dochiptest = false;

   	      break;

	   default:

              delay = SiS310_TVDelayCompensation_651301LV[index];

	      if(SiS_Pr->SiS_VBType & VB_SIS302LV) {

	         delay = SiS310_TVDelayCompensation_651302LV[index];

	      }

	   }

        }



     } else if((SiS_Pr->SiS_UseROM) && (!(SiS_Pr->SiS_ROMNew))) {



        romptr = GetTVromptr(SiS_Pr);

	if(!romptr) return;

	delay = ROMAddr[romptr + index];



     } else if(SiS_Pr->SiS_IF_DEF_LVDS == 1) {



        delay = SiS310_TVDelayCompensation_LVDS[index];



     } else {



	delay = SiS310_TVDelayCompensation_301[index];

        if(SiS_Pr->SiS_VBType & VB_SIS30xBLV) {

	   if(IS_SIS740) {

	      delay = SiS310_TVDelayCompensation_740301B[index];

	      /* LV: use 301 data? BIOS bug? */

	   } else {

              delay = SiS310_TVDelayCompensation_301B[index];

	      if(SiS_Pr->SiS_VBType & VB_SIS301C) delay = 0x02;

	   }

	}



     }



     if(SiS_LCDAEnabled(SiS_Pr)) {

	delay &= 0x0f;

	dochiptest = false;

     }



  } else return;



  /* Write delay */



  if(SiS_Pr->SiS_VBType & VB_SISVB) {



     if(IS_SIS650 && (SiS_Pr->SiS_VBType & VB_SISLVDS) && dochiptest) {



        temp = (SiS_GetReg(SiS_Pr->SiS_P3d4,0x36) & 0xf0) >> 4;

        if(temp == 8) {		/* 1400x1050 BIOS (COMPAL) */

	   delay &= 0x0f;

	   delay |= 0xb0;

        } else if(temp == 6) {

           delay &= 0x0f;

	   delay |= 0xc0;

        } else if(temp > 7) {	/* 1280x1024 BIOS (which one?) */

	   delay = 0x35;

        }

        SiS_SetReg(SiS_Pr->SiS_Part1Port,0x2D,delay);



     } else {



        SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x2D,0xF0,delay);



     }



  } else {  /* LVDS */



     if(SiS_Pr->SiS_VBInfo & SetCRT2ToTV) {

        SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x2D,0xF0,delay);

     } else {

        if(IS_SIS650 && (SiS_Pr->SiS_IF_DEF_CH70xx != 0)) {

           delay <<= 4;

           SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x2D,0x0F,delay);

        } else {

           SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x2D,0xF0,delay);

        }

     }



  }



}



static void

SetAntiFlicker(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned short ModeIdIndex)

{

  unsigned char  *ROMAddr = SiS_Pr->VirtualRomBase;

  unsigned short index,temp,temp1,romptr=0;



  if(SiS_Pr->SiS_TVMode & (TVSetYPbPr750p|TVSetYPbPr525p)) return;



  if(ModeNo<=0x13)

     index = SiS_Pr->SiS_SModeIDTable[ModeIdIndex].VB_StTVFlickerIndex;

  else

     index = SiS_Pr->SiS_EModeIDTable[ModeIdIndex].VB_ExtTVFlickerIndex;



  temp = GetTVPtrIndex(SiS_Pr);

  temp >>= 1;  	  /* 0: NTSC/YPbPr, 1: PAL, 2: HiTV */

  temp1 = temp;



  if(SiS_Pr->SiS_UseROM && (!(SiS_Pr->SiS_ROMNew))) {

     if(SiS_Pr->ChipType >= SIS_661) {

        temp1 = GetOEMTVPtr661(SiS_Pr);

        temp1 >>= 1;

        romptr = SISGETROMW(0x260);

        if(SiS_Pr->ChipType >= SIS_760) {

	   romptr = SISGETROMW(0x360);

	}

     } else if(SiS_Pr->ChipType >= SIS_330) {

        romptr = SISGETROMW(0x192);

     } else {

        romptr = SISGETROMW(0x112);

     }

  }



  if(romptr) {

     temp1 <<= 1;

     temp = ROMAddr[romptr + temp1 + index];

  } else {

     temp = SiS310_TVAntiFlick1[temp][index];

  }

  temp <<= 4;



  SiS_SetRegANDOR(SiS_Pr->SiS_Part2Port,0x0A,0x8f,temp);  /* index 0A D[6:4] */

}



static void

SetEdgeEnhance(struct SiS_Private *SiS_Pr, unsigned short ModeNo,unsigned short ModeIdIndex)

{

  unsigned char  *ROMAddr = SiS_Pr->VirtualRomBase;

  unsigned short index,temp,temp1,romptr=0;



  temp = temp1 = GetTVPtrIndex(SiS_Pr) >> 1; 	/* 0: NTSC/YPbPr, 1: PAL, 2: HiTV */



  if(ModeNo <= 0x13)

     index = SiS_Pr->SiS_SModeIDTable[ModeIdIndex].VB_StTVEdgeIndex;

  else

     index = SiS_Pr->SiS_EModeIDTable[ModeIdIndex].VB_ExtTVEdgeIndex;



  if(SiS_Pr->SiS_UseROM && (!(SiS_Pr->SiS_ROMNew))) {

     if(SiS_Pr->ChipType >= SIS_661) {

        romptr = SISGETROMW(0x26c);

        if(SiS_Pr->ChipType >= SIS_760) {

	   romptr = SISGETROMW(0x36c);

	}

	temp1 = GetOEMTVPtr661(SiS_Pr);

        temp1 >>= 1;

     } else if(SiS_Pr->ChipType >= SIS_330) {

        romptr = SISGETROMW(0x1a4);

     } else {

        romptr = SISGETROMW(0x124);

     }

  }



  if(romptr) {

     temp1 <<= 1;

     temp = ROMAddr[romptr + temp1 + index];

  } else {

     temp = SiS310_TVEdge1[temp][index];

  }

  temp <<= 5;

  SiS_SetRegANDOR(SiS_Pr->SiS_Part2Port,0x3A,0x1F,temp);  /* index 0A D[7:5] */

}



static void

SetYFilter(struct SiS_Private *SiS_Pr, unsigned short ModeNo,unsigned short ModeIdIndex)

{

  unsigned short index, temp, i, j;



  if(ModeNo <= 0x13) {

     index = SiS_Pr->SiS_SModeIDTable[ModeIdIndex].VB_StTVYFilterIndex;

  } else {

     index = SiS_Pr->SiS_EModeIDTable[ModeIdIndex].VB_ExtTVYFilterIndex;

  }



  temp = GetTVPtrIndex(SiS_Pr) >> 1;  /* 0: NTSC/YPbPr, 1: PAL, 2: HiTV */



  if(SiS_Pr->SiS_TVMode & TVSetNTSCJ)	     temp = 1;  /* NTSC-J uses PAL */

  else if(SiS_Pr->SiS_TVMode & TVSetPALM)    temp = 3;  /* PAL-M */

  else if(SiS_Pr->SiS_TVMode & TVSetPALN)    temp = 4;  /* PAL-N */

  if(SiS_Pr->SiS_VBInfo & SetCRT2ToHiVision) temp = 1;  /* HiVision uses PAL */



  if(SiS_Pr->SiS_VBType & VB_SIS30xBLV) {

     for(i=0x35, j=0; i<=0x38; i++, j++) {

        SiS_SetReg(SiS_Pr->SiS_Part2Port,i,SiS310_TVYFilter2[temp][index][j]);

     }

     for(i=0x48; i<=0x4A; i++, j++) {

        SiS_SetReg(SiS_Pr->SiS_Part2Port,i,SiS310_TVYFilter2[temp][index][j]);

     }

  } else {

     for(i=0x35, j=0; i<=0x38; i++, j++) {

        SiS_SetReg(SiS_Pr->SiS_Part2Port,i,SiS310_TVYFilter1[temp][index][j]);

     }

  }

}



static void

SetPhaseIncr(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned short ModeIdIndex)

{

  unsigned char  *ROMAddr = SiS_Pr->VirtualRomBase;

  unsigned short index,temp,i,j,resinfo,romptr=0;

  unsigned int  lindex;



  if(!(SiS_Pr->SiS_VBInfo & SetCRT2ToTV)) return;



  /* NTSC-J data not in BIOS, and already set in SetGroup2 */

  if(SiS_Pr->SiS_TVMode & TVSetNTSCJ) return;



  if((SiS_Pr->ChipType >= SIS_661) || SiS_Pr->SiS_ROMNew) {

     lindex = GetOEMTVPtr661_2_OLD(SiS_Pr) & 0xffff;

     lindex <<= 2;

     for(j=0, i=0x31; i<=0x34; i++, j++) {

        SiS_SetReg(SiS_Pr->SiS_Part2Port,i,SiS_TVPhase[lindex + j]);

     }

     return;

  }



  /* PAL-M, PAL-N not in BIOS, and already set in SetGroup2 */

  if(SiS_Pr->SiS_TVMode & (TVSetPALM | TVSetPALN)) return;



  if(ModeNo<=0x13) {

     resinfo = SiS_Pr->SiS_SModeIDTable[ModeIdIndex].St_ResInfo;

  } else {

     resinfo = SiS_Pr->SiS_EModeIDTable[ModeIdIndex].Ext_RESINFO;

  }



  temp = GetTVPtrIndex(SiS_Pr);

 0: NTSC Graphics, 1: NTSC Text,    2: PAL Graphics,

   */

  if(SiS_Pr->SiS_UseROM) {

     romptr = SISGETROMW(0x116);

     if(SiS_Pr->ChipType >= SIS_330) {

        romptr = SISGETROMW(0x196);

     }

     if(SiS_Pr->SiS_VBType & VB_SIS30xBLV) {

        romptr = SISGETROMW(0x11c);

	if(SiS_Pr->ChipType >= SIS_330) {

	   romptr = SISGETROMW(0x19c);

	}

	if((SiS_Pr->SiS_VBInfo & SetInSlaveMode) && (!(SiS_Pr->SiS_TVMode & TVSetTVSimuMode))) {

	   romptr = SISGETROMW(0x116);

	   if(SiS_Pr->ChipType >= SIS_330) {

              romptr = SISGETROMW(0x196);

           }

	}

     }

  }

  if(romptr) {

     romptr += (temp << 2);

     for(j=0, i=0x31; i<=0x34; i++, j++) {

        SiS_SetReg(SiS_Pr->SiS_Part2Port,i,ROMAddr[romptr + j]);

     }

  } else {

     index = temp % 2;

     temp >>= 1;          /* 0:NTSC, 1:PAL, 2:HiTV */

     for(j=0, i=0x31; i<=0x34; i++, j++) {

        if(!(SiS_Pr->SiS_VBType & VB_SIS30xBLV))

	   SiS_SetReg(SiS_Pr->SiS_Part2Port,i,SiS310_TVPhaseIncr1[temp][index][j]);

        else if((!(SiS_Pr->SiS_VBInfo & SetInSlaveMode)) || (SiS_Pr->SiS_TVMode & TVSetTVSimuMode))

           SiS_SetReg(SiS_Pr->SiS_Part2Port,i,SiS310_TVPhaseIncr2[temp][index][j]);

        else

           SiS_SetReg(SiS_Pr->SiS_Part2Port,i,SiS310_TVPhaseIncr1[temp][index][j]);

     }

  }



  if((SiS_Pr->SiS_VBType & VB_SIS30xBLV) && (!(SiS_Pr->SiS_VBInfo & SetCRT2ToHiVision))) {

     if((!(SiS_Pr->SiS_TVMode & (TVSetPAL | TVSetYPbPr525p | TVSetYPbPr750p))) && (ModeNo > 0x13)) {

        if((resinfo == SIS_RI_640x480) ||

	   (resinfo == SIS_RI_800x600)) {

	   SiS_SetReg(SiS_Pr->SiS_Part2Port,0x31,0x21);

	   SiS_SetReg(SiS_Pr->SiS_Part2Port,0x32,0xf0);

	   SiS_SetReg(SiS_Pr->SiS_Part2Port,0x33,0xf5);

	   SiS_SetReg(SiS_Pr->SiS_Part2Port,0x34,0x7f);

	} else if(resinfo == SIS_RI_1024x768) {

	   SiS_SetReg(SiS_Pr->SiS_Part2Port,0x31,0x1e);

	   SiS_SetReg(SiS_Pr->SiS_Part2Port,0x32,0x8b);

	   SiS_SetReg(SiS_Pr->SiS_Part2Port,0x33,0xfb);

	   SiS_SetReg(SiS_Pr->SiS_Part2Port,0x34,0x7b);

	}

     }

  }

}



static void

SetDelayComp661(struct SiS_Private *SiS_Pr, unsigned short ModeNo,

                unsigned short ModeIdIndex, unsigned short RTI)

{

   unsigned short delay = 0, romptr = 0, index, lcdpdcindex;

   unsigned char  *ROMAddr = SiS_Pr->VirtualRomBase;



   if(!(SiS_Pr->SiS_VBInfo & (SetCRT2ToTV | SetCRT2ToLCD | SetCRT2ToLCDA | SetCRT2ToRAMDAC)))

      return;



   /* 1. New ROM: VGA2 and LCD/LCDA-Pass1:1 */

   /* (If a custom mode is used, Pass1:1 is always set; hence we do this:) */



   if(SiS_Pr->SiS_ROMNew) {

      if((SiS_Pr->SiS_VBInfo & SetCRT2ToRAMDAC) 			||

         ((SiS_Pr->SiS_VBInfo & (SetCRT2ToLCD | SetCRT2ToLCDA)) &&

	  (SiS_Pr->SiS_LCDInfo & LCDPass11))) {

         index = 25;

         if(SiS_Pr->UseCustomMode) {

	    index = SiS_Pr->CSRClock;

         } else if(ModeNo > 0x13) {

            index = SiS_GetVCLK2Ptr(SiS_Pr,ModeNo,ModeIdIndex,RTI);

            index = SiS_Pr->SiS_VCLKData[index].CLOCK;

         }

	 if(index < 25) index = 25;

         index = ((index / 25) - 1) << 1;

         if((ROMAddr[0x5b] & 0x80) || (SiS_Pr->SiS_VBInfo & (SetCRT2ToRAMDAC | SetCRT2ToLCD))) {

	    index++;

	 }

	 romptr = SISGETROMW(0x104);

         delay = ROMAddr[romptr + index];

         if(SiS_Pr->SiS_VBInfo & (SetCRT2ToRAMDAC | SetCRT2ToLCD)) {

            SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x2d,0xf0,((delay >> 1) & 0x0f));

            SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x35,0x7f,((delay & 0x01) << 7));

         } else {

            SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x2d,0x0f,((delay << 3) & 0xf0));

	    SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x20,0xbf,((delay & 0x01) << 6));

         }

         return;

      }

   }



   /* 2. Old ROM: VGA2 and LCD/LCDA-Pass 1:1 */



   if(SiS_Pr->UseCustomMode) delay = 0x04;

   else if(ModeNo <= 0x13)   delay = 0x04;

   else                      delay = (SiS_Pr->SiS_RefIndex[RTI].Ext_PDC >> 4);

   delay |= (delay << 8);



   if(SiS_Pr->ChipType >= XGI_20) {



      delay = 0x0606;

      if(SiS_Pr->SiS_VBInfo & SetCRT2ToTV) {



	 delay = 0x0404;

         if(SiS_Pr->SiS_XGIROM) {

	     index = GetTVPtrIndex(SiS_Pr);

	     if((romptr = SISGETROMW(0x35e))) {

	        delay = (ROMAddr[romptr + index] & 0x0f) << 1;

		delay |= (delay << 8);

	     }

	 }



	 if(SiS_Pr->SiS_VBInfo & SetCRT2ToHiVision) {

	    if(SiS_Pr->ChipType == XGI_40 && SiS_Pr->ChipRevision == 0x02) {

	       delay -= 0x0404;

	    }

	 }

      }



   } else if(SiS_Pr->ChipType >= SIS_340) {



      delay = 0x0606;

      if(SiS_Pr->SiS_VBInfo & SetCRT2ToTV) {

         delay = 0x0404;

      }

      /* TODO (eventually) */



   } else if(SiS_Pr->SiS_VBInfo & SetCRT2ToTV) {



      /* 3. TV */



      index = GetOEMTVPtr661(SiS_Pr);

      if(SiS_Pr->SiS_ROMNew) {

         romptr = SISGETROMW(0x106);

	 if(SiS_Pr->SiS_VBType & VB_UMC) romptr += 12;

         delay = ROMAddr[romptr + index];

      } else {

         delay = 0x04;

	 if(index > 3) delay = 0;

      }



   } else if(SiS_Pr->SiS_VBInfo & (SetCRT2ToLCD | SetCRT2ToLCDA)) {



      /* 4. LCD, LCDA (for new ROM only LV and non-Pass 1:1) */



      if( (SiS_Pr->SiS_LCDResInfo != Panel_Custom) &&

          ((romptr = GetLCDStructPtr661_2(SiS_Pr))) ) {



	 lcdpdcindex = (SiS_Pr->SiS_VBType & VB_UMC) ? 14 : 12;



	 /* For LVDS (and sometimes TMDS), the BIOS must know about the correct value */

	 delay = ROMAddr[romptr + lcdpdcindex + 1];	/* LCD  */

	 delay |= (ROMAddr[romptr + lcdpdcindex] << 8);	/* LCDA */



      } else {



         /* TMDS: Set our own, since BIOS has no idea */

	 /* (This is done on >=661 only, since <661 is calling this only for LVDS) */

         if(!(SiS_Pr->SiS_LCDInfo & LCDPass11)) {

	    switch(SiS_Pr->SiS_LCDResInfo) {

	    case Panel_1024x768:  delay = 0x0008; break;

	    case Panel_1280x720:  delay = 0x0004; break;

	    case Panel_1280x768:

	    case Panel_1280x768_2:delay = 0x0004; break;

	    case Panel_1280x800:

	    case Panel_1280x800_2:delay = 0x0004; break; /* Verified for 1280x800 */

	    case Panel_1280x854:  delay = 0x0004; break; /* FIXME */

	    case Panel_1280x1024: delay = 0x1e04; break;

	    case Panel_1400x1050: delay = 0x0004; break;

	    case Panel_1600x1200: delay = 0x0400; break;

	    case Panel_1680x1050: delay = 0x0e04; break;

	    default:

               if((SiS_Pr->PanelXRes <= 1024) && (SiS_Pr->PanelYRes <= 768)) {

	          delay = 0x0008;

	       } else if((SiS_Pr->PanelXRes == 1280) && (SiS_Pr->PanelYRes == 1024)) {

	          delay = 0x1e04;

               } else if((SiS_Pr->PanelXRes <= 1400) && (SiS_Pr->PanelYRes <= 1050)) {

	          delay = 0x0004;

	       } else if((SiS_Pr->PanelXRes <= 1600) && (SiS_Pr->PanelYRes <= 1200)) {

	          delay = 0x0400;

               } else

	          delay = 0x0e04;

	       break;

	    }

         }



	 /* Override by detected or user-set values */

	 /* (but only if, for some reason, we can't read value from BIOS) */

         if((SiS_Pr->SiS_VBInfo & SetCRT2ToLCD) && (SiS_Pr->PDC != -1)) {

            delay = SiS_Pr->PDC & 0x1f;

         }

         if((SiS_Pr->SiS_VBInfo & SetCRT2ToLCDA) && (SiS_Pr->PDCA != -1)) {

            delay = (SiS_Pr->PDCA & 0x1f) << 8;

         }



      }



   }



   if(SiS_Pr->SiS_VBInfo & SetCRT2ToLCDA) {

      delay >>= 8;

      SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x2d,0x0f,((delay << 3) & 0xf0));

      SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x20,0xbf,((delay & 0x01) << 6));

   } else {

      SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x2d,0xf0,((delay >> 1) & 0x0f));

      SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x35,0x7f,((delay & 0x01) << 7));

   }

}



static void

SetCRT2SyncDither661(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned short RTI)

{

   unsigned short infoflag;

   unsigned char  temp;



   if(SiS_Pr->SiS_VBInfo & (SetCRT2ToLCD | SetCRT2ToLCDA)) {



      if(ModeNo <= 0x13) {

         infoflag = SiS_GetRegByte(SiS_Pr->SiS_P3ca+2);

      } else if(SiS_Pr->UseCustomMode) {

         infoflag = SiS_Pr->CInfoFlag;

      } else {

         infoflag = SiS_Pr->SiS_RefIndex[RTI].Ext_InfoFlag;

      }



      if(!(SiS_Pr->SiS_LCDInfo & LCDPass11)) {

         infoflag = SiS_GetReg(SiS_Pr->SiS_P3d4,0x37); /* No longer check D5 */

      }



      infoflag &= 0xc0;



      if(SiS_Pr->SiS_VBInfo & SetCRT2ToLCD) {

         temp = (infoflag >> 6) | 0x0c;

         if(SiS_Pr->SiS_LCDInfo & LCDRGB18Bit) {

	    temp ^= 0x04;

	    if(SiS_Pr->SiS_ModeType >= Mode24Bpp) temp |= 0x10;

	 }

         SiS_SetRegANDOR(SiS_Pr->SiS_Part2Port,0x1a,0xe0,temp);

      } else {

         temp = 0x30;

         if(SiS_Pr->SiS_LCDInfo & LCDRGB18Bit) temp = 0x20;

         temp |= infoflag;

         SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x19,0x0f,temp);

         temp = 0;

         if(SiS_Pr->SiS_LCDInfo & LCDRGB18Bit) {

	    if(SiS_Pr->SiS_ModeType >= Mode24Bpp) temp |= 0x80;

	 }

         SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x1a,0x7f,temp);

      }



   }

}



static void

SetPanelParms661(struct SiS_Private *SiS_Pr)

{

   unsigned char  *ROMAddr = SiS_Pr->VirtualRomBase;

   unsigned short romptr, temp1, temp2;



   if(SiS_Pr->SiS_VBType & (VB_SISLVDS | VB_SIS30xC)) {

      SiS_SetRegAND(SiS_Pr->SiS_Part4Port,0x24,0x0f);

   }



   if(SiS_Pr->SiS_VBType & VB_SISLVDS) {

      if(SiS_Pr->LVDSHL != -1) {

         SiS_SetRegANDOR(SiS_Pr->SiS_Part4Port,0x24,0xfc,SiS_Pr->LVDSHL);

      }

   }



   if(SiS_Pr->SiS_ROMNew) {



      if((romptr = GetLCDStructPtr661_2(SiS_Pr))) {

         if(SiS_Pr->SiS_VBType & VB_SISLVDS) {

            temp1 = (ROMAddr[romptr] & 0x03) | 0x0c;

	    temp2 = 0xfc;

	    if(SiS_Pr->LVDSHL != -1) {

	      temp1 &= 0xfc;

	      temp2 = 0xf3;

	    }

	    SiS_SetRegANDOR(SiS_Pr->SiS_Part4Port,0x24,temp2,temp1);

         }

	 if(SiS_Pr->SiS_VBInfo & SetCRT2ToLCD) {

            temp1 = (ROMAddr[romptr + 1] & 0x80) >> 1;

            SiS_SetRegANDOR(SiS_Pr->SiS_Part4Port,0x0d,0xbf,temp1);

	 }

      }



   }

}



static void

SiS_OEM310Setting(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned short ModeIdIndex, unsigned short RRTI)

{

   if((SiS_Pr->SiS_ROMNew) && (SiS_Pr->SiS_VBType & VB_SISLVDS)) {

      SetDelayComp661(SiS_Pr, ModeNo, ModeIdIndex, RRTI);

      if(SiS_Pr->SiS_VBInfo & (SetCRT2ToLCD | SetCRT2ToLCDA)) {

         SetCRT2SyncDither661(SiS_Pr, ModeNo, RRTI);

         SetPanelParms661(SiS_Pr);

      }

   } else {

      SetDelayComp(SiS_Pr,ModeNo);

   }



   if((SiS_Pr->SiS_VBType & VB_SISVB) && (SiS_Pr->SiS_VBInfo & SetCRT2ToTV)) {

      SetAntiFlicker(SiS_Pr,ModeNo,ModeIdIndex);

      SetPhaseIncr(SiS_Pr,ModeNo,ModeIdIndex);

      SetYFilter(SiS_Pr,ModeNo,ModeIdIndex);

      if(SiS_Pr->SiS_VBType & VB_SIS301) {

         SetEdgeEnhance(SiS_Pr,ModeNo,ModeIdIndex);

      }

   }

}



static void

SiS_OEM661Setting(struct SiS_Private *SiS_Pr, unsigned short ModeNo,

			unsigned short ModeIdIndex, unsigned short RRTI)

{

   if(SiS_Pr->SiS_VBType & VB_SISVB) {



      SetDelayComp661(SiS_Pr, ModeNo, ModeIdIndex, RRTI);



      if(SiS_Pr->SiS_VBInfo & (SetCRT2ToLCD | SetCRT2ToLCDA)) {

         SetCRT2SyncDither661(SiS_Pr, ModeNo, RRTI);

         SetPanelParms661(SiS_Pr);

      }



      if(SiS_Pr->SiS_VBInfo & SetCRT2ToTV) {

         SetPhaseIncr(SiS_Pr, ModeNo, ModeIdIndex);

         SetYFilter(SiS_Pr, ModeNo, ModeIdIndex);

         SetAntiFlicker(SiS_Pr, ModeNo, ModeIdIndex);

         if(SiS_Pr->SiS_VBType & VB_SIS301) {

            SetEdgeEnhance(SiS_Pr, ModeNo, ModeIdIndex);

         }

      }

   }

}



 FinalizeLCD

 */

static void

SiS_FinalizeLCD(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned short ModeIdIndex)

{

  unsigned short tempcl,tempch,tempbl,tempbh,tempbx,tempax,temp;

  unsigned short resinfo,modeflag;



  if(!(SiS_Pr->SiS_VBType & VB_SISLVDS)) return;

  if(SiS_Pr->SiS_ROMNew) return;



  if(SiS_Pr->SiS_VBInfo & (SetCRT2ToLCD | SetCRT2ToLCDA)) {

     if(SiS_Pr->LVDSHL != -1) {

        SiS_SetRegANDOR(SiS_Pr->SiS_Part4Port,0x24,0xfc,SiS_Pr->LVDSHL);

     }

  }



  if(SiS_Pr->SiS_LCDResInfo == Panel_Custom) return;

  if(SiS_Pr->UseCustomMode) return;



  switch(SiS_Pr->SiS_CustomT) {

  case CUT_COMPAQ1280:

  case CUT_COMPAQ12802:

  case CUT_CLEVO1400:

  case CUT_CLEVO14002:

     return;

  }



  if(ModeNo <= 0x13) {

     resinfo = SiS_Pr->SiS_SModeIDTable[ModeIdIndex].St_ResInfo;

     modeflag =  SiS_Pr->SiS_SModeIDTable[ModeIdIndex].St_ModeFlag;

  } else {

     resinfo = SiS_Pr->SiS_EModeIDTable[ModeIdIndex].Ext_RESINFO;

     modeflag =  SiS_Pr->SiS_EModeIDTable[ModeIdIndex].Ext_ModeFlag;

  }



  if(IS_SIS650) {

     if(!(SiS_GetReg(SiS_Pr->SiS_P3d4, 0x5f) & 0xf0)) {

        if(SiS_Pr->SiS_CustomT == CUT_CLEVO1024) {

	   SiS_SetRegOR(SiS_Pr->SiS_Part1Port,0x1e,0x02);

	} else {

           SiS_SetRegOR(SiS_Pr->SiS_Part1Port,0x1e,0x03);

	}

     }

  }



  if(SiS_Pr->SiS_CustomT == CUT_CLEVO1024) {

     if(SiS_Pr->SiS_LCDResInfo == Panel_1024x768) {

        /* Maybe all panels? */

        if(SiS_Pr->LVDSHL == -1) {

           SiS_SetRegANDOR(SiS_Pr->SiS_Part4Port,0x24,0xfc,0x01);

	}

	return;

     }

  }



  if(SiS_Pr->SiS_CustomT == CUT_CLEVO10242) {

     if(SiS_Pr->SiS_VBInfo & (SetCRT2ToLCD | SetCRT2ToLCDA)) {

        if(SiS_Pr->SiS_LCDResInfo == Panel_1024x768) {

	   if(SiS_Pr->LVDSHL == -1) {

	      /* Maybe all panels? */

              SiS_SetRegANDOR(SiS_Pr->SiS_Part4Port,0x24,0xfc,0x01);

	   }

	   if(SiS_Pr->SiS_VBInfo & SetCRT2ToLCDA) {

	      tempch = SiS_GetReg(SiS_Pr->SiS_P3d4,0x36) >> 4;

	      if(tempch == 3) {

	         SiS_SetReg(SiS_Pr->SiS_Part1Port,0x18,0x02);

	         SiS_SetReg(SiS_Pr->SiS_Part1Port,0x1b,0x25);

	         SiS_SetReg(SiS_Pr->SiS_Part1Port,0x1c,0x00);

	         SiS_SetReg(SiS_Pr->SiS_Part1Port,0x1d,0x1b);

	      }

	   }

	   return;

	}

     }

  }



  if(SiS_Pr->SiS_VBInfo & (SetCRT2ToLCD | SetCRT2ToLCDA)) {

     if(SiS_Pr->SiS_LCDResInfo == Panel_1024x768) {

	if(SiS_Pr->SiS_VBType & VB_SISEMI) {

	   SiS_SetReg(SiS_Pr->SiS_Part4Port,0x2a,0x00);

#ifdef SET_EMI

	   SiS_SetRegAND(SiS_Pr->SiS_Part4Port,0x30,0x0c);

#endif

	   SiS_SetReg(SiS_Pr->SiS_Part4Port,0x34,0x10);

	}

     } else if(SiS_Pr->SiS_LCDResInfo == Panel_1280x1024) {

        if(SiS_Pr->LVDSHL == -1) {

           /* Maybe ACER only? */

           SiS_SetRegANDOR(SiS_Pr->SiS_Part4Port,0x24,0xfc,0x01);

	}

     }

     tempch = SiS_GetReg(SiS_Pr->SiS_P3d4,0x36) >> 4;

     if(SiS_Pr->SiS_VBInfo & SetCRT2ToLCDA) {

	if(SiS_Pr->SiS_LCDResInfo == Panel_1400x1050) {

	   SiS_SetReg(SiS_Pr->SiS_Part1Port,0x1f,0x76);

	} else if(SiS_Pr->SiS_LCDResInfo == Panel_1024x768) {

	   if(tempch == 0x03) {

	      SiS_SetReg(SiS_Pr->SiS_Part1Port,0x18,0x02);

	      SiS_SetReg(SiS_Pr->SiS_Part1Port,0x1b,0x25);

	      SiS_SetReg(SiS_Pr->SiS_Part1Port,0x1c,0x00);

	      SiS_SetReg(SiS_Pr->SiS_Part1Port,0x1d,0x1b);

	   }

	   if(SiS_Pr->Backup && (SiS_Pr->Backup_Mode == ModeNo)) {

	      SiS_SetReg(SiS_Pr->SiS_Part1Port,0x14,SiS_Pr->Backup_14);

	      SiS_SetReg(SiS_Pr->SiS_Part1Port,0x15,SiS_Pr->Backup_15);

	      SiS_SetReg(SiS_Pr->SiS_Part1Port,0x16,SiS_Pr->Backup_16);

	      SiS_SetReg(SiS_Pr->SiS_Part1Port,0x17,SiS_Pr->Backup_17);

	      SiS_SetReg(SiS_Pr->SiS_Part1Port,0x18,SiS_Pr->Backup_18);

	      SiS_SetReg(SiS_Pr->SiS_Part1Port,0x19,SiS_Pr->Backup_19);

	      SiS_SetReg(SiS_Pr->SiS_Part1Port,0x1a,SiS_Pr->Backup_1a);

	      SiS_SetReg(SiS_Pr->SiS_Part1Port,0x1b,SiS_Pr->Backup_1b);

	      SiS_SetReg(SiS_Pr->SiS_Part1Port,0x1c,SiS_Pr->Backup_1c);

	      SiS_SetReg(SiS_Pr->SiS_Part1Port,0x1d,SiS_Pr->Backup_1d);

	   } else if(!(SiS_Pr->SiS_LCDInfo & DontExpandLCD)) {	/* 1.10.8w */

	      SiS_SetReg(SiS_Pr->SiS_Part1Port,0x14,0x90);

	      if(ModeNo <= 0x13) {

	         SiS_SetReg(SiS_Pr->SiS_Part1Port,0x18,0x11);

		 if((resinfo == 0) || (resinfo == 2)) return;

		 SiS_SetReg(SiS_Pr->SiS_Part1Port,0x18,0x18);

		 if((resinfo == 1) || (resinfo == 3)) return;

	      }

	      SiS_SetReg(SiS_Pr->SiS_Part1Port,0x18,0x02);

	      if((ModeNo > 0x13) && (resinfo == SIS_RI_1024x768)) {

	         SiS_SetReg(SiS_Pr->SiS_Part1Port,0x18,0x02);  /* 1.10.7u */

#if 0

	         tempbx = 806;  /* 0x326 */			 /* other older BIOSes */

		 tempbx--;

		 temp = tempbx & 0xff;

		 SiS_SetReg(SiS_Pr->SiS_Part1Port,0x1b,temp);

		 temp = (tempbx >> 8) & 0x03;

		 SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x1d,0xf8,temp);

#endif

	      }

	   } else if(ModeNo <= 0x13) {

	      if(ModeNo <= 1) {

		 SiS_SetReg(SiS_Pr->SiS_Part1Port,0x18,0x70);

		 SiS_SetReg(SiS_Pr->SiS_Part1Port,0x19,0xff);

		 SiS_SetReg(SiS_Pr->SiS_Part1Port,0x1b,0x48);

		 SiS_SetReg(SiS_Pr->SiS_Part1Port,0x1d,0x12);

	      }

	      if(!(modeflag & HalfDCLK)) {

		 SiS_SetReg(SiS_Pr->SiS_Part1Port,0x14,0x20);

		 SiS_SetReg(SiS_Pr->SiS_Part1Port,0x15,0x1a);

		 SiS_SetReg(SiS_Pr->SiS_Part1Port,0x16,0x28);

		 SiS_SetReg(SiS_Pr->SiS_Part1Port,0x17,0x00);

		 SiS_SetReg(SiS_Pr->SiS_Part1Port,0x18,0x4c);

		 SiS_SetReg(SiS_Pr->SiS_Part1Port,0x19,0xdc);

		 if(ModeNo == 0x12) {

		    switch(tempch) {

		       case 0:

			  SiS_SetReg(SiS_Pr->SiS_Part1Port,0x18,0x95);

			  SiS_SetReg(SiS_Pr->SiS_Part1Port,0x19,0xdc);

			  SiS_SetReg(SiS_Pr->SiS_Part1Port,0x1a,0x10);

			  SiS_SetReg(SiS_Pr->SiS_Part1Port,0x1b,0x95);

			  SiS_SetReg(SiS_Pr->SiS_Part1Port,0x1c,0x48);

			  SiS_SetReg(SiS_Pr->SiS_Part1Port,0x1d,0x12);

			  break;

		       case 2:

			  SiS_SetReg(SiS_Pr->SiS_Part1Port,0x18,0x95);

			  SiS_SetReg(SiS_Pr->SiS_Part1Port,0x1b,0x48);

			  break;

		       case 3:

			  SiS_SetReg(SiS_Pr->SiS_Part1Port,0x1b,0x95);

			  break;

		    }

		 }

	      }

	   }

	}

     } else {

        tempcl = tempbh = SiS_GetReg(SiS_Pr->SiS_Part2Port,0x01);

	tempcl &= 0x0f;

	tempbh &= 0x70;

	tempbh >>= 4;

	tempbl = SiS_GetReg(SiS_Pr->SiS_Part2Port,0x04);

	tempbx = (tempbh << 8) | tempbl;

	if(SiS_Pr->SiS_LCDResInfo == Panel_1024x768) {

	   if((resinfo == SIS_RI_1024x768) || (!(SiS_Pr->SiS_LCDInfo & DontExpandLCD))) {

	      if(SiS_Pr->SiS_SetFlag & LCDVESATiming) {

	      	 tempbx = 770;

	      } else {

	         if(tempbx > 770) tempbx = 770;

		 if(SiS_Pr->SiS_VGAVDE < 600) {

		    tempax = 768 - SiS_Pr->SiS_VGAVDE;

		    tempax >>= 4;  				 /* 1.10.7w; 1.10.6s: 3;  */

		    if(SiS_Pr->SiS_VGAVDE <= 480)  tempax >>= 4; /* 1.10.7w; 1.10.6s: < 480; >>=1; */

		    tempbx -= tempax;

		 }

	      }

	   } else return;

	}

	temp = tempbx & 0xff;

	SiS_SetReg(SiS_Pr->SiS_Part2Port,0x04,temp);

	temp = ((tempbx & 0xff00) >> 4) | tempcl;

	SiS_SetRegANDOR(SiS_Pr->SiS_Part2Port,0x01,0x80,temp);

     }

  }

}



#endif



/*  =================  SiS 300 O.E.M. ================== */



#ifdef CONFIG_FB_SIS_300



static void

SetOEMLCDData2(struct SiS_Private *SiS_Pr, unsigned short ModeNo,unsigned short ModeIdIndex,

		unsigned short RefTabIndex)

{

  unsigned short crt2crtc=0, modeflag, myindex=0;

  unsigned char  temp;

  int i;



  if(ModeNo <= 0x13) {

     modeflag = SiS_Pr->SiS_SModeIDTable[ModeIdIndex].St_ModeFlag;

     crt2crtc = SiS_Pr->SiS_SModeIDTable[ModeIdIndex].St_CRT2CRTC;

  } else {

     modeflag = SiS_Pr->SiS_EModeIDTable[ModeIdIndex].Ext_ModeFlag;

     crt2crtc = SiS_Pr->SiS_RefIndex[RefTabIndex].Ext_CRT2CRTC;

  }



  crt2crtc &= 0x3f;



  if(SiS_Pr->SiS_CustomT == CUT_BARCO1024) {

     SiS_SetRegAND(SiS_Pr->SiS_Part1Port,0x13,0xdf);

  }



  if(SiS_Pr->SiS_CustomT == CUT_BARCO1366) {

     if(modeflag & HalfDCLK) myindex = 1;



     if(SiS_Pr->SiS_SetFlag & LowModeTests) {

        for(i=0; i<7; i++) {

           if(barco_p1[myindex][crt2crtc][i][0]) {

	      SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,

	                      barco_p1[myindex][crt2crtc][i][0],

	   	   	      barco_p1[myindex][crt2crtc][i][2],

			      barco_p1[myindex][crt2crtc][i][1]);

	   }

        }

     }

     temp = SiS_GetReg(SiS_Pr->SiS_Part1Port,0x00);

     if(temp & 0x80) {

        temp = SiS_GetReg(SiS_Pr->SiS_Part1Port,0x18);

        temp++;

        SiS_SetReg(SiS_Pr->SiS_Part1Port,0x18,temp);

     }

  }

}



static unsigned short

GetOEMLCDPtr(struct SiS_Private *SiS_Pr, int Flag)

{

  unsigned char  *ROMAddr = SiS_Pr->VirtualRomBase;

  unsigned short tempbx=0,romptr=0;

  static const unsigned char customtable300[] = {

	0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,

	0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff

  };

  static const unsigned char customtable630[] = {

	0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,

	0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff

  };



  if(SiS_Pr->ChipType == SIS_300) {



    tempbx = SiS_GetReg(SiS_Pr->SiS_P3d4,0x36) & 0x0f;

    if(SiS_Pr->SiS_VBType & VB_SIS301) tempbx &= 0x07;

    tempbx -= 2;

    if(!(SiS_Pr->SiS_SetFlag & LCDVESATiming)) tempbx += 4;

    if(SiS_Pr->SiS_LCDResInfo == Panel_1024x768) {

       if(SiS_Pr->SiS_LCDInfo & DontExpandLCD) tempbx += 3;

    }

    if(SiS_Pr->SiS_UseROM) {

       if(ROMAddr[0x235] & 0x80) {

          tempbx = SiS_Pr->SiS_LCDTypeInfo;

          if(Flag) {

	     romptr = SISGETROMW(0x255);

	     if(romptr) tempbx = ROMAddr[romptr + SiS_Pr->SiS_LCDTypeInfo];

	     else       tempbx = customtable300[SiS_Pr->SiS_LCDTypeInfo];

             if(tempbx == 0xFF) return 0xFFFF;

          }

	  tempbx <<= 1;

	  if(!(SiS_Pr->SiS_SetFlag & LCDVESATiming)) tempbx++;

       }

    }



  } else {



    if(Flag) {

       if(SiS_Pr->SiS_UseROM) {

          romptr = SISGETROMW(0x255);

	  if(romptr) tempbx = ROMAddr[romptr + SiS_Pr->SiS_LCDTypeInfo];

	  else 	     tempbx = 0xff;

       } else {

          tempbx = customtable630[SiS_Pr->SiS_LCDTypeInfo];

       }

       if(tempbx == 0xFF) return 0xFFFF;

       tempbx <<= 2;

       if(SiS_Pr->SiS_VBInfo & SetInSlaveMode) tempbx += 2;

       if(SiS_Pr->SiS_LCDInfo & DontExpandLCD) tempbx++;

       return tempbx;

    }

    tempbx = SiS_Pr->SiS_LCDTypeInfo << 2;

    if(SiS_Pr->SiS_VBInfo & SetInSlaveMode) tempbx += 2;

    if(SiS_Pr->SiS_LCDInfo & DontExpandLCD) tempbx++;



  }



  return tempbx;

}



static void

SetOEMLCDDelay(struct SiS_Private *SiS_Pr, unsigned short ModeNo,unsigned short ModeIdIndex)

{

  unsigned char  *ROMAddr = SiS_Pr->VirtualRomBase;

  unsigned short index,temp,romptr=0;



  if(SiS_Pr->SiS_LCDResInfo == Panel_Custom) return;



  if(SiS_Pr->SiS_UseROM) {

     if(!(ROMAddr[0x237] & 0x01)) return;

     if(!(ROMAddr[0x237] & 0x02)) return;

     romptr = SISGETROMW(0x24b);

  }



 The Panel Compensation Delay should be set according to tables

   */

  if(SiS_Pr->PDC != -1) return;



  temp = GetOEMLCDPtr(SiS_Pr, 0);



  if(SiS_Pr->UseCustomMode)

     index = 0;

  else

     index = SiS_Pr->SiS_VBModeIDTable[ModeIdIndex].VB_LCDDelayIndex;



  if(SiS_Pr->ChipType != SIS_300) {

     if(romptr) {

	romptr += (temp * 2);

	romptr = SISGETROMW(romptr);

	romptr += index;

	temp = ROMAddr[romptr];

     } else {

	if(SiS_Pr->SiS_VBType & VB_SISVB) {

    	   temp = SiS300_OEMLCDDelay2[temp][index];

	} else {

           temp = SiS300_OEMLCDDelay3[temp][index];

        }

     }

  } else {

     if(SiS_Pr->SiS_UseROM && (ROMAddr[0x235] & 0x80)) {

	if(romptr) {

	   romptr += (temp * 2);

	   romptr = SISGETROMW(romptr);

	   romptr += index;

	   temp = ROMAddr[romptr];

	} else {

	   temp = SiS300_OEMLCDDelay5[temp][index];

	}

     } else {

        if(SiS_Pr->SiS_UseROM) {

	   romptr = ROMAddr[0x249] | (ROMAddr[0x24a] << 8);

	   if(romptr) {

	      romptr += (temp * 2);

	      romptr = SISGETROMW(romptr);

	      romptr += index;

	      temp = ROMAddr[romptr];

	   } else {

	      temp = SiS300_OEMLCDDelay4[temp][index];

	   }

	} else {

	   temp = SiS300_OEMLCDDelay4[temp][index];

	}

     }

  }

  temp &= 0x3c;

  SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x13,~0x3C,temp);  /* index 0A D[6:4] */

}



static void

SetOEMLCDData(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned short ModeIdIndex)

{

#if 0  /* Unfinished; Data table missing */

  unsigned char  *ROMAddr = SiS_Pr->VirtualRomBase;

  unsigned short index,temp;



  if((SiS_Pr->SiS_UseROM) {

     if(!(ROMAddr[0x237] & 0x01)) return;

     if(!(ROMAddr[0x237] & 0x04)) return;

     /* No rom pointer in BIOS header! */

  }



  temp = GetOEMLCDPtr(SiS_Pr, 1);

  if(temp == 0xFFFF) return;



  index = SiS_Pr->SiS_VBModeIDTable[ModeIdIndex]._VB_LCDHIndex;

  for(i=0x14, j=0; i<=0x17; i++, j++) {

      SiS_SetReg(SiS_Pr->SiS_Part1Port,i,SiS300_LCDHData[temp][index][j]);

  }

  SiS_SetRegANDOR(SiS_SiS_Part1Port,0x1a, 0xf8, (SiS300_LCDHData[temp][index][j] & 0x07));



  index = SiS_Pr->SiS_VBModeIDTable[ModeIdIndex]._VB_LCDVIndex;

  SiS_SetReg(SiS_SiS_Part1Port,0x18, SiS300_LCDVData[temp][index][0]);

  SiS_SetRegANDOR(SiS_SiS_Part1Port,0x19, 0xF0, SiS300_LCDVData[temp][index][1]);

  SiS_SetRegANDOR(SiS_SiS_Part1Port,0x1A, 0xC7, (SiS300_LCDVData[temp][index][2] & 0x38));

  for(i=0x1b, j=3; i<=0x1d; i++, j++) {

      SiS_SetReg(SiS_Pr->SiS_Part1Port,i,SiS300_LCDVData[temp][index][j]);

  }

#endif

}



static unsigned short

GetOEMTVPtr(struct SiS_Private *SiS_Pr)

{

  unsigned short index;



  index = 0;

  if(!(SiS_Pr->SiS_VBInfo & SetInSlaveMode))  index += 4;

  if(SiS_Pr->SiS_VBType & VB_SISVB) {

     if(SiS_Pr->SiS_VBInfo & SetCRT2ToSCART)  index += 2;

     else if(SiS_Pr->SiS_VBInfo & SetCRT2ToHiVision) index += 3;

     else if(SiS_Pr->SiS_TVMode & TVSetPAL)   index += 1;

  } else {

     if(SiS_Pr->SiS_TVMode & TVSetCHOverScan) index += 2;

     if(SiS_Pr->SiS_TVMode & TVSetPAL)        index += 1;

  }

  return index;

}



static void

SetOEMTVDelay(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned short ModeIdIndex)

{

  unsigned char  *ROMAddr = SiS_Pr->VirtualRomBase;

  unsigned short index,temp,romptr=0;



  if(SiS_Pr->SiS_UseROM) {

     if(!(ROMAddr[0x238] & 0x01)) return;

     if(!(ROMAddr[0x238] & 0x02)) return;

     romptr = SISGETROMW(0x241);

  }



  temp = GetOEMTVPtr(SiS_Pr);



  index = SiS_Pr->SiS_VBModeIDTable[ModeIdIndex].VB_TVDelayIndex;



  if(romptr) {

     romptr += (temp * 2);

     romptr = SISGETROMW(romptr);

     romptr += index;

     temp = ROMAddr[romptr];

  } else {

     if(SiS_Pr->SiS_VBType & VB_SISVB) {

        temp = SiS300_OEMTVDelay301[temp][index];

     } else {

        temp = SiS300_OEMTVDelayLVDS[temp][index];

     }

  }

  temp &= 0x3c;

  SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x13,~0x3C,temp);

}



static void

SetOEMAntiFlicker(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned short ModeIdIndex)

{

  unsigned char  *ROMAddr = SiS_Pr->VirtualRomBase;

  unsigned short index,temp,romptr=0;



  if(SiS_Pr->SiS_UseROM) {

     if(!(ROMAddr[0x238] & 0x01)) return;

     if(!(ROMAddr[0x238] & 0x04)) return;

     romptr = SISGETROMW(0x243);

  }



  temp = GetOEMTVPtr(SiS_Pr);



  index = SiS_Pr->SiS_VBModeIDTable[ModeIdIndex].VB_TVFlickerIndex;



  if(romptr) {

     romptr += (temp * 2);

     romptr = SISGETROMW(romptr);

     romptr += index;

     temp = ROMAddr[romptr];

  } else {

     temp = SiS300_OEMTVFlicker[temp][index];

  }

  temp &= 0x70;

  SiS_SetRegANDOR(SiS_Pr->SiS_Part2Port,0x0A,0x8F,temp);

}



static void

SetOEMPhaseIncr(struct SiS_Private *SiS_Pr, unsigned short ModeNo,unsigned short ModeIdIndex)

{

  unsigned char  *ROMAddr = SiS_Pr->VirtualRomBase;

  unsigned short index,i,j,temp,romptr=0;



  if(SiS_Pr->SiS_VBInfo & SetCRT2ToHiVision) return;



  if(SiS_Pr->SiS_TVMode & (TVSetNTSC1024 | TVSetNTSCJ | TVSetPALM | TVSetPALN)) return;



  if(SiS_Pr->SiS_UseROM) {

     if(!(ROMAddr[0x238] & 0x01)) return;

     if(!(ROMAddr[0x238] & 0x08)) return;

     romptr = SISGETROMW(0x245);

  }



  temp = GetOEMTVPtr(SiS_Pr);



  index = SiS_Pr->SiS_VBModeIDTable[ModeIdIndex].VB_TVPhaseIndex;



  if(SiS_Pr->SiS_VBType & VB_SIS30xBLV) {

     for(i=0x31, j=0; i<=0x34; i++, j++) {

        SiS_SetReg(SiS_Pr->SiS_Part2Port,i,SiS300_Phase2[temp][index][j]);

     }

  } else {

     if(romptr) {

        romptr += (temp * 2);

	romptr = SISGETROMW(romptr);

	romptr += (index * 4);

        for(i=0x31, j=0; i<=0x34; i++, j++) {

	   SiS_SetReg(SiS_Pr->SiS_Part2Port,i,ROMAddr[romptr + j]);

	}

     } else {

        for(i=0x31, j=0; i<=0x34; i++, j++) {

           SiS_SetReg(SiS_Pr->SiS_Part2Port,i,SiS300_Phase1[temp][index][j]);

	}

     }

  }

}



static void

SetOEMYFilter(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned short ModeIdIndex)

{

  unsigned char  *ROMAddr = SiS_Pr->VirtualRomBase;

  unsigned short index,temp,i,j,romptr=0;



  if(SiS_Pr->SiS_VBInfo & (SetCRT2ToSCART | SetCRT2ToHiVision | SetCRT2ToYPbPr525750)) return;



  if(SiS_Pr->SiS_UseROM) {

     if(!(ROMAddr[0x238] & 0x01)) return;

     if(!(ROMAddr[0x238] & 0x10)) return;

     romptr = SISGETROMW(0x247);

  }



  temp = GetOEMTVPtr(SiS_Pr);



  if(SiS_Pr->SiS_TVMode & TVSetPALM)      temp = 8;

  else if(SiS_Pr->SiS_TVMode & TVSetPALN) temp = 9;

  /* NTSCJ uses NTSC filters */



  index = SiS_Pr->SiS_VBModeIDTable[ModeIdIndex].VB_TVYFilterIndex;



  if(SiS_Pr->SiS_VBType & VB_SIS30xBLV) {

      for(i=0x35, j=0; i<=0x38; i++, j++) {

       	SiS_SetReg(SiS_Pr->SiS_Part2Port,i,SiS300_Filter2[temp][index][j]);

      }

      for(i=0x48; i<=0x4A; i++, j++) {

     	SiS_SetReg(SiS_Pr->SiS_Part2Port,i,SiS300_Filter2[temp][index][j]);

      }

  } else {

      if((romptr) && (!(SiS_Pr->SiS_TVMode & (TVSetPALM|TVSetPALN)))) {

         romptr += (temp * 2);

	 romptr = SISGETROMW(romptr);

	 romptr += (index * 4);

	 for(i=0x35, j=0; i<=0x38; i++, j++) {

       	    SiS_SetReg(SiS_Pr->SiS_Part2Port,i,ROMAddr[romptr + j]);

         }

      } else {

         for(i=0x35, j=0; i<=0x38; i++, j++) {

       	    SiS_SetReg(SiS_Pr->SiS_Part2Port,i,SiS300_Filter1[temp][index][j]);

         }

      }

  }

}



static unsigned short

SiS_SearchVBModeID(struct SiS_Private *SiS_Pr, unsigned short *ModeNo)

{

   unsigned short ModeIdIndex;

   unsigned char  VGAINFO = SiS_Pr->SiS_VGAINFO;



   if(*ModeNo <= 5) *ModeNo |= 1;



   for(ModeIdIndex=0; ; ModeIdIndex++) {

      if(SiS_Pr->SiS_VBModeIDTable[ModeIdIndex].ModeID == *ModeNo) break;

      if(SiS_Pr->SiS_VBModeIDTable[ModeIdIndex].ModeID == 0xFF)    return 0;

   }



   if(*ModeNo != 0x07) {

      if(*ModeNo > 0x03) return ModeIdIndex;

      if(VGAINFO & 0x80) return ModeIdIndex;

      ModeIdIndex++;

   }



   if(VGAINFO & 0x10) ModeIdIndex++;   /* 400 lines */

	                               /* else 350 lines */

   return ModeIdIndex;

}



static void

SiS_OEM300Setting(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned short ModeIdIndex,

		  unsigned short RefTableIndex)

{

  unsigned short OEMModeIdIndex = 0;



  if(!SiS_Pr->UseCustomMode) {

     OEMModeIdIndex = SiS_SearchVBModeID(SiS_Pr,&ModeNo);

     if(!(OEMModeIdIndex)) return;

  }



  if(SiS_Pr->SiS_VBInfo & SetCRT2ToLCD) {

     SetOEMLCDDelay(SiS_Pr, ModeNo, OEMModeIdIndex);

     if(SiS_Pr->SiS_IF_DEF_LVDS == 1) {

        SetOEMLCDData(SiS_Pr, ModeNo, OEMModeIdIndex);

     }

  }

  if(SiS_Pr->UseCustomMode) return;

  if(SiS_Pr->SiS_VBInfo & SetCRT2ToTV) {

     SetOEMTVDelay(SiS_Pr, ModeNo,OEMModeIdIndex);

     if(SiS_Pr->SiS_VBType & VB_SISVB) {

        SetOEMAntiFlicker(SiS_Pr, ModeNo, OEMModeIdIndex);

    	SetOEMPhaseIncr(SiS_Pr, ModeNo, OEMModeIdIndex);

       	SetOEMYFilter(SiS_Pr, ModeNo, OEMModeIdIndex);

     }

  }

}

#endif



 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * SiS 300/540/630[S]/730[S]

 * SiS 315[E|PRO]/550/[M]65x/[M]66x[F|M|G]X/[M]74x[GX]/330/[M]76x[GX]

 * XGI V3XT/V5/V8, Z7

 * frame buffer driver for Linux kernels >= 2.4.14 and >=2.6.3

 *

 * Linux kernel specific extensions to init.c/init301.c

 *

 * Copyright (C) 2001-2005 Thomas Winischhofer, Vienna, Austria.

 *

 * Author:	Thomas Winischhofer <thomas@winischhofer.net>

 Wide screen: Ignore rateindex */

 Wide screen: Ignore rateindex */

 Do this? */

 Wide screen: Ignore rateindex */

 $XFree86$ */

 $XdotOrg$ */

/*

 * Mode initializing code (CRT1 section) for

 * for SiS 300/305/540/630/730,

 *     SiS 315/550/[M]650/651/[M]661[FGM]X/[M]74x[GX]/330/[M]76x[GX],

 *     XGI Volari V3XT/V5/V8, Z7

 * (Universal module for Linux kernel framebuffer and X.org/XFree86 4.x)

 *

 * Copyright (C) 2001-2005 by Thomas Winischhofer, Vienna, Austria

 *

 * If distributed as part of the Linux kernel, the following license terms

 * apply:

 *

 * * This program is free software; you can redistribute it and/or modify

 * * it under the terms of the GNU General Public License as published by

 * * the Free Software Foundation; either version 2 of the named License,

 * * or any later version.

 * *

 * * This program is distributed in the hope that it will be useful,

 * * but WITHOUT ANY WARRANTY; without even the implied warranty of

 * * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the

 * * GNU General Public License for more details.

 * *

 * * You should have received a copy of the GNU General Public License

 * * along with this program; if not, write to the Free Software

 * * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA

 *

 * Otherwise, the following license terms apply:

 *

 * * Redistribution and use in source and binary forms, with or without

 * * modification, are permitted provided that the following conditions

 * * are met:

 * * 1) Redistributions of source code must retain the above copyright

 * *    notice, this list of conditions and the following disclaimer.

 * * 2) Redistributions in binary form must reproduce the above copyright

 * *    notice, this list of conditions and the following disclaimer in the

 * *    documentation and/or other materials provided with the distribution.

 * * 3) The name of the author may not be used to endorse or promote products

 * *    derived from this software without specific prior written permission.

 * *

 * * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR

 * * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES

 * * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.

 * * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,

 * * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT

 * * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,

 * * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY

 * * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT

 * * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF

 * * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 *

 * Author: 	Thomas Winischhofer <thomas@winischhofer.net>

 *

 * Formerly based on non-functional code-fragements for 300 series by SiS, Inc.

 * Used by permission.

********************************************/

         POINTER INITIALIZATION            */

********************************************/

 lowest value LVDS/LCDA */

 lowest value 301 */

 300 */

 630, 730 */

 not supported on 300 series */

 not supported on 300 series */

 not supported on 300 series */

 not supported on 300 series */

 not supported on 300 series */

 not supported on 300 series */

 not supported on 300 series */

 not supported on 300 series */

 not supported on 300 series */

 not supported on 300 series */

 not supported on 300 series */

 not supported on 300 series */

 340 + XGI */

 761 - preliminary */

 760 */

 661/741 */

 330 */

 550, 650, 740 */

 315 */

********************************************/

            HELPER: Get ModeID             */

********************************************/

 OVER1280 only? */

********************************************/

          HELPER: SetReg, GetReg           */

********************************************/

********************************************/

      HELPER: DisplayOn, DisplayOff        */

********************************************/

********************************************/

        HELPER: Init Port Addresses        */

********************************************/

********************************************/

             HELPER: GetSysFlags           */

********************************************/

 661 and newer: NEVER write non-zero to SR11[7:4] */

 (SR11 is used for DDC and in enable/disablebridge) */

 You should use the macros, not these flags directly */

********************************************/

         HELPER: Init PCI & Engines        */

********************************************/

      /* Set - PCI LINEAR ADDRESSING ENABLE (0x80)

       *     - RELOCATED VGA IO ENABLED (0x20)

       *     - MMIO ENABLED (0x01)

       * Leave other bits untouched.

      /*  - Enable 2D (0x40)

       *  - Enable 3D (0x02)

       *  - Enable 3D Vertex command fetch (0x10) ?

       *  - Enable 3D command parser (0x08) ?

 See above */

      /*  - Enable 3D G/L transformation engine (0x80)

       *  - Enable 2D (0x40)

       *  - Enable 3D vertex command fetch (0x10)

       *  - Enable 3D command parser (0x08)

       *  - Enable 3D (0x02)

 See above */

 No 3D engine ! */

      /*  - Enable 2D (0x40)

       *  - disable 3D

********************************************/

             HELPER: SetLVDSetc            */

********************************************/

 Check for SiS30x first */

 Save power status (and error check) - UNUSED */

 Not yet supported */

********************************************/

          HELPER: Enable DSTN/FSTN         */

********************************************/

********************************************/

            HELPER: Get modeflag           */

********************************************/

********************************************/

        HELPER: Determine ROM usage        */

********************************************/

 XGI ROMs don't qualify */

 I very much assume 761, 340 and newer will use new layout */

	 /* 300: We check if the code starts below 0x220 by

	  * checking the jmp instruction at the beginning

	  * of the BIOS image.

	 /* Sony's VAIO BIOS 1.09 follows the standard, so perhaps

	  * the others do as well

 315/330 series stick to the standard(s) */

 Find out about LCD data table entry size */

 0.94, 2.05.00+ */

 2.00.00 - 2.02.00 */

 2.03.00 - <2.05.00 */

 UMC data layout abandoned at 2.05.00 */

********************************************/

        HELPER: SET SEGMENT REGISTERS      */

********************************************/

********************************************/

             HELPER: GetVBType             */

********************************************/

 Check if 30xB DH version (no LCD support, use Panel Link instead) */

 VB_SIS302ELV; */

********************************************/

           HELPER: Check RAM size          */

********************************************/

********************************************/

           HELPER: Get DRAM type           */

********************************************/

 Do I need this? SR17 seems to be zero anyway... */

 TODO */

 315, 330 */

********************************************/

           HELPER: ClearBuffer             */

********************************************/

********************************************/

           HELPER: SearchModeID            */

********************************************/

 400 lines */

 else 350 lines */

 400 lines  */

 else 350 lines  */

 else 200 lines  */

********************************************/

            HELPER: GetModePtr             */

********************************************/

********************************************/

         HELPERS: Get some indices         */

********************************************/

********************************************/

           HELPER: LowModeTests            */

********************************************/

********************************************/

        HELPER: OPEN/CLOSE CRT1 CRTC       */

********************************************/

 This locks some CRTC registers. We don't want that. */

 Enable CRT1 gating */

********************************************/

           HELPER: GetColorDepth           */

********************************************/

 Do NOT check UseCustomMode, will skrew up FIFO */

********************************************/

             HELPER: GetOffset             */

********************************************/

********************************************/

                   SEQ                     */

********************************************/

 or "display off"  */

 determine whether to force x8 dotclock */

********************************************/

                  MISC                     */

********************************************/

********************************************/

                  CRTC                     */

********************************************/

 Unlock CRTC */

********************************************/

                   ATT                     */

********************************************/

	 /* Pixel shift. If screen on LCD or TV is shifted left or right,

	  * this might be the cause.

 315, 330 don't do this */

 reset 3da  */

 set index  */

 set data   */

 reset 3da  */

 set index  */

 set data   */

 Enable Attribute  */

********************************************/

                   GRC                     */

********************************************/

 256 color disable */

********************************************/

          CLEAR EXTENDED REGISTERS         */

********************************************/

********************************************/

                 RESET VCLK                */

********************************************/

********************************************/

                  SYNC                     */

********************************************/

********************************************/

                  CRTC/2                   */

********************************************/

 Alternate for 1600x1200 LCDA */

 unlock cr0-7 */

********************************************/

               OFFSET & PITCH              */

********************************************/

  (partly overruled by SetPitch() in XF86) */

********************************************/

********************************************/

                  VCLK                     */

********************************************/

 Alternate for 1600x1200 LCDA */

********************************************/

                  FIFO                     */

********************************************/

 Get VCLK  */

 Get half colordepth */

 Get MCLK  */

 Write CRT/CPU threshold low, CRT/Engine threshold high */

 What is this? */

 Write CRT/CPU threshold high */

 64  bit    BQ=2   */

 64  bit    BQ=1   */

 128 bit    BQ=2   */

 128 bit    BQ=1   */

 64  bit    BQ=2   */

 64  bit    BQ=1   */

 128 bit    BQ=2   */

 128 bit    BQ=1   */

 Get VCLK  */

 Get MCLK * 16 */

 Get half colordepth */

 Write CRT/CPU threshold low, CRT/Engine threshold high */

 What is this? */

 Write CRT/CPU threshold high (gap = 3) */

 Write foreground and background queue */

 GUI grant timer (PCI config 0xA3) */

 CONFIG_FB_SIS_300 */

 disable auto-threshold */

********************************************/

              MODE REGISTERS               */

********************************************/

 DAC speed */

 Was == 203 or < 234 which made no sense */

 Disable DPMS */

 data = (Hsync / 8) - ((Htotal / 8) / 2) + 3 */

 76x+LFB */

 XGI: Nothing. */

 TODO: Check SiS340 */

 TODO: Find out about IOAddress2 */

 SR00 - SR04 */

 GR00 - GR08 */

 SR06 */

 SR21 */

 MISC */

********************************************/

                 LOAD DAC                  */

********************************************/

 301B-DH LCD */

 LCDA */

 Programming CRT1 */

 for n < 3 */

 for m < 9 */

********************************************/

         SET CRT1 REGISTER GROUP           */

********************************************/

********************************************/

       HELPER: VIDEO BRIDGE PROG CLK       */

********************************************/

 VB programming clock */

 Can we do this on any chipset? */

********************************************/

    HELPER: SET VIDEO/CAPTURE REGISTERS    */

********************************************/

   /* SiS65x and XGI set up some sort of "lock mode" for text

    * which locks CRT2 in some way to CRT1 timing. Disable

    * this here.

 Fiddle with capture regs */

 (BIOS does NOT unlock) */

 Fiddle with video regs */

 !!! This does not support modes < 0x13 !!! */

********************************************/

     HELPER: SET AGP TIMING FOR SiS760     */

********************************************/

********************************************/

                 SiSSetMode()              */

********************************************/

 Don't use FSTN mode for CRT1 */

 Init/restore some VB registers */

 Get VB information (connectors, connected devices) */

 Check memory size (kernel framebuffer driver only) */

 Set mode on CRT1 */

 Set mode on CRT2 */

 We never lock registers in XF86 */

 Fix sync */

 CR0 */

 CR1 */

 CR2 */

 CR3 */

 CR4 */

 CR5 */

 CR6 */

 CR7 */

 CR9 */

 SRE */

 CR10 */

 CR11 */

 CR12 */

 CR15 */

 CR16 */

 SRA */

 SRB */

 SRC */

 1:1 data: use data set by setcrt1crtc() */

 OK for LCDA, LVDS */

 not /2 ! */

 Stupid hack for 640x400/320x200 */

 Horizontal display enable end */

 Horizontal retrace (=sync) start */

 Horizontal blank end */

 Horizontal retrace (=sync) end */

 Vertical */

 Vertical display enable end */

 Vertical retrace (=sync) start */

 Vertical blank end */

 Vertical retrace (=sync) end */

	/* Terrible hack, but correct CRTC data for

	 * these modes only produces a black screen...

	 * (HRE is 0, leading into a too large C and

	 * a negative D. The CRT controller does not

	 * seem to like correcting HRE to 50)

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * SiS 300/540/630[S]/730[S],

 * SiS 315[E|PRO]/550/[M]65x/[M]66x[F|M|G]X/[M]74x[GX]/330/[M]76x[GX],

 * XGI V3XT/V5/V8, Z7

 * frame buffer driver for Linux kernels >= 2.4.14 and >=2.6.3

 *

 * Copyright (C) 2001-2005 Thomas Winischhofer, Vienna, Austria.

 *

 * Author:	Thomas Winischhofer <thomas@winischhofer.net>

 *

 * Author of (practically wiped) code base:

 *		SiS (www.sis.com)

 *		Copyright (C) 1999 Silicon Integrated Systems, Inc.

 *

 * See http://www.winischhofer.net/ for more information and updates

 *

 * Originally based on the VBE 2.0 compliant graphic boards framebuffer driver,

 * which is (c) 1998 Gerd Knorr <kraxel@goldbach.in-berlin.de>

 ---------------------- Prototypes ------------------------- */

 Interface used by the world */

 Interface to the low level console driver */

 fbdev routines */

 Internal heap routines */

 ------------------ Internal helper routines ----------------- */

 ------------- Parameter parsing -------------- */

 We don't know the hardware specs yet and there is no ivideo */

 Clean VESA mode number from other flags */

 We don't know the hardware specs yet and there is no ivideo */

 This does some fuzzy mode naming detection */

 We don't know the hardware specs yet and there is no ivideo */

 We don't know the hardware specs yet and there is no ivideo */

 We don't know the hardware specs yet and there is no ivideo */

 ----------- Various detection routines ----------- */

	   /* EDID V1 rev 1 and 2: Search for monitor descriptor

	    * to extract ranges

	   /* Otherwise: Get a range from the list of supported

	    * Estabished Timings. This is not entirely accurate,

	    * because fixed frequency monitors are not supported

	    * that way.

 Number of retrys */

 -------------- Mode validation --------------- */

 Skip for 320x200, 320x240, 640x400 */

 30 */

 31 */

 32 */

 33 */

 on */

 blank */

 no vsync */

 no hsync */

 off */

 ------------- Callbacks from init.c/init301.c  -------------- */

 ----------- FBDev related routines for all series ----------- */

 We need to set pitch for CRT1 if bridge is in slave mode, too */

 We must not set the pitch for CRT2 if bridge is in slave mode */

 >=2.6.12's fbcon clears the screen anyway */

		/* If acceleration to be used? Need to know

		 * before pre/post_set_mode()

 calculate base bpp dep. */

 Slave modes on LVDS and 301B-DH */

 x=x & y=y & c=c -> assume depth change */

 x!=x | y!=y & c=c -> invalid pixclock */

 Sic, sisfb_parm_rate - want to know originally desired rate here */

 Eventually recalculate timing and clock */

 Adapt RGB settings */

 Truncate offsets to maximum if too high */

 Set everything else to 0 */

 ----------- FBDev related routines for all series ---------- */

 For communication with X driver */

 ----------------  fb_ops structures ----------------- */

 ---------------- Chip generation dependent routines ---------------- */

 for SiS 540 VGA */

 for SiS 630/730 VGA */

 for SiS 550 VGA */

 for SiS 650/651/740 VGA */

 for SiS 661/741/660/760/761 VGA */

 -------------- video bridge device detection --------------- */

 No CRT2 on XGI Z7 */

 PAL/NTSC is stored on SR16 on such machines */

	/* Check given parms for hardware compatibility.

	 * (Cannot do this in the search_xx routines since we don't

	 * know what hardware we are running on then)

 Detect/set TV plug & type */

 default: 480i */

 Copy forceCRT1 option to CRT1off if option is given */

 ------------------ Sensing routines ------------------ */

 Determine and detect attached devices on SiS30x */

 LCD detection only for TMDS bridges */

 If LCD already set up by BIOS, skip it */

 Check DDC capabilities */

 Read DDC data */

 Number of retrys */

 No digital device */

 First detailed timing preferred timing? */

 Determine and detect attached TV's on Chrontel */

 Chrontel 700x */

 Set general purpose IO for Chrontel communication */

 See Chrontel TB31 for explanation */

 Read power status */

 Power all outputs */

 Sense connected TV devices */

 Set general purpose IO for Chrontel communication */

 Chrontel 7019 */

 No CRT2 on XGI Z7 */

 Deprecated */

 Deprecated */

 Deprecated */

 Deprecated */

 Deprecated */

 Deprecated */

 Deprecated */

 Deprecated */

 Deprecated */

 Deprecated */

 Deprecated */

 Deprecated */

 Deprecated */

 Deprecated */

 Deprecated */

 Deprecated */

 Deprecated */

 Deprecated */

 ---------- Engine initialization routines ------------ */

 Initialize command queue (we use MMIO only) */

 BEFORE THIS IS CALLED, THE ENGINES *MUST* BE SYNC'ED */

			/* Must disable dual pipe on XGI_40. Can't do

			 * this in MMIO mode, because it requires

			 * setting/clearing a bit in the MMIO fire trigger

			 * register.

 For broken BIOSes: Assume 1024x768, RGB18 */

 Save the current PanelDelayCompensation if the LCD is currently used */

 Currently on LCD? If yes, read current pdc */

 Let option override detection */

 Try to find about LCDA */

 Save PDC */

 Currently on LCD? If yes, read current pdc */

 New ROM invalidates other PDC resp. */

 Save EMI */

 Let user override detected PDCs (all bridges) */

 -------------------- Memory manager routines ---------------------- */

	/* Calculate heap start = end of memory for console

	 *

	 * CCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDDDDDHHHHQQQQQQQQQQ

	 * C = console, D = heap, H = HWCursor, Q = cmd-queue

	 *

	 * On 76x in UMA+LFB mode, the layout is as follows:

	 * DDDDDDDDDDDCCCCCCCCCCCCCCCCCCCCCCCCHHHHQQQQQQQQQQQ

	 * where the heap is the entire UMA area, eventually

	 * into the LFB area if the given mem parameter is

	 * higher than the size of the UMA memory.

	 *

	 * Basically given by "mem" parameter

	 *

	 * maximum = videosize - cmd_queue - hwcursor

	 *           (results in a heap of size 0)

	 * default = SiS 300: depends on videosize

	 *           SiS 315/330/340/XGI: 32k below max

 Use default for secondary card for now (FIXME) */

		/* For the first card, make this heap the "global" one

		 * for old DRM (which could handle only one card)

 sis_free: u32 because "base" is offset inside video ram, can never be >4GB */

 --------------------- SetMode routines ------------------------- */

	/* Check if MMIO and engines are enabled,

	 * and sync in case they are. Can't use

	 * ivideo->accel here, as this might have

	 * been changed before this is called.

 MMIO and 2D/3D engine enabled? */

			/* Don't care about TurboQueue. It's

			 * enough to know that the engines

			 * are enabled

			/* Check that any queue mode is

			 * enabled, and that the queue

			 * is not in the state of "reset"

 Clear LCDA/DualEdge and YPbPr bits */

 Clear LCDA/DualEdge and YPbPr bits */

 Clear PAL-M / PAL-N bits */

 disable CRT2 */

 Clear PAL flag (now in CR35) */

 Leave overscan bit alone */

 Use only LCDA and HiVision/YPbPr bits */

 Fix SR11 for 661 and later */

 Not supported by hardware */

 Not supported by hardware */

 Now we actually HAVE changed the display mode */

 We can't switch off CRT1 if bridge is in slave mode */

 Eventually sync engines */

 (Re-)Initialize chip engines */

 arg[0]: 0 = off, 1 = on, 99 = query */

 Query */

 more to come */

 Need to check crt2 type first for fstn/dstn */

	/* First, try the official pci ROM functions (except

	 * on integrated chipsets which have no ROM).

 Otherwise do it the conventional way. */

 Channel A 128bit */

 Channel B 64bit */

 32bit */

 Rank No */

 Test */

 Test */

 Write data */

 Read data */

 Assume 125Mhz MCLK */

 Assume 125Mhz ECLK */

 DAC speed */

 DDC, power save */

 Ram type (assuming 0, BIOS 0xa5 step 8) */

 ---- */

 DAC pedestal (BIOS 0xe5) */

 linear & relocated io & disable a0000 */

 unlock crt2 */

 Lock CRT2 */

 ? */

 Need to map max FB size for finding out about RAM size */

 ? */

 8MB, 64bit default */

 PCI */

 AGP */

 Sense CRT1 */

 Set default mode, don't clear screen */

 Display off */

 Save mode number in CR34 */

 Let everyone know what the current mode is */

 TODO */

 Enable linear mode, disable 0xa0000 address decoding */

	/* We disable a0000 address decoding, because

	 * - if running on x86, if the card is disabled, it means

	 *   that another card is in the system. We don't want

	 *   to interphere with that primary card's textmode.

	 * - if running on non-x86, there usually is no VGA window

	 *   at a0000.

 Need to map max FB size for finding out about RAM size */

 TODO */

 Non-interleaving */

 No tiling */

 Single 32/16 */

 Dual 16/8 */

 XGI_40 */

 DDRII */

 DDR */

 ! */

 EMRS2 */

 EMRS3 */

 EMRS1 */

 MRS1 */

 MRS1 */

 DDR2 dual frequency mode */

 GPIO control */

 GPIOH EN */

 GPIOH */

 VGA enable */

 Misc */

 Unlock SR */

 Clear some regs */

 PCI linear mode, RelIO enabled, A0000 decoding disabled */

 40 *and* 20? */

 =0x28 Z7 ? */

				/* TODO: set CR5f &0xf1 | 0x01 for version 6570

				 * of nforce 2 ROM

	/* RAM type:

	 *

	 * 0 == DDR1, 1 == DDR2, 2..7 == reserved?

	 *

	 * The code seems to written so that regb should equal ramtype,

	 * however, so far it has been hardcoded to 0. Enable other values only

	 * on XGI Z9, as it passes the POST, and add a warning for others.

 reg = 0x00; */

 DDR2 */

 DDR1 */

 SiS_SetReg(SISSR, 0x16, 0x0c); */ 
 ! */

 RAM size */

 ! */

 Set default mode, don't clear screen */

 Disable read-cache */

 Enable read-cache */

 Sense CRT1 */

 Set default mode, don't clear screen */

 Display off */

 Save mode number in CR34 */

 Let everyone know what the current mode is */

 pdc(a), scalelcd, special timing, lvdshl handled below */

 Patch special cases */

 ivideo->chip is ok */

 Find PCI systems for Chrontel/GPIO communication setup */

 Find out about current video mode */

 Search and copy ROM image */

 Find systems for special custom timing */

 Check if our Z7 chip is actually Z9 */

 GPIOG EN */

 GPIOG */

 POST card in case this has not been done by the BIOS */

		/*	if((ivideo->chip == SIS_315H)   ||

			   (ivideo->chip == SIS_315)    ||

			   (ivideo->chip == SIS_315PRO) ||

			   (ivideo->chip == SIS_330)) {

				sisfb_post_sis315330(pdev);

 Find out about RAM size */

 Enable PCI addressing and MMIO */

 Enable PCI_LINEAR_ADDRESSING and MMIO_ENABLE  */

 Enable 2D accelerator engine */

 Determine the size of the command queue */

	/* Engines are no longer initialized here; this is

	 * now done after the first mode-switch (if the

	 * submitted var has its acceleration flags set).

 Calculate the base of the (unused) hw cursor */

 Initialize offscreen memory manager */

 Used for clearing the screen only, therefore respect our mem limit */

 Decide on which CRT2 device to use */

				/* Chrontel 700x TV detection often unreliable, therefore

				 * use a different default order on such machines

 Set up the default var according to chosen default display mode */

 Maximize regardless of sisfb_max at startup */

 Enlist us */

 if mode = "none" */

****************************************************/

                PCI DEVICE HANDLING                */

****************************************************/

 Unmap */

 Release mem regions */

	/* If device was disabled when starting, disable

	 * it when quitting.

 Unregister the framebuffer */

 OK, our ivideo is gone for good from here. */

	/* TODO: Restore the initial mode

	 * This sounds easy but is as good as impossible

	 * on many machines with SiS chip and video bridge

	 * since text modes are always set up differently

	 * from machine to machine. Depends on the type

	 * of integration between chipset and bridge.

****************************************************/

                      MODULE                       */

****************************************************/

 Need to check crt2 type first for fstn/dstn */

  /MODULE  */

 _GPL only for new symbols. */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * SiS 300/540/630[S]/730[S],

 * SiS 315[E|PRO]/550/[M]650/651/[M]661[F|M]X/740/[M]741[GX]/330/[M]760[GX],

 * XGI V3XT/V5/V8, Z7

 * frame buffer driver for Linux kernels >= 2.4.14 and >=2.6.3

 *

 * 2D acceleration part

 *

 * Based on the XFree86/X.org driver which is

 *     Copyright (C) 2001-2005 by Thomas Winischhofer, Vienna, Austria

 *

 * Author: Thomas Winischhofer <thomas@winischhofer.net>

 *			(see http://www.winischhofer.net/

 *			for more information and updates)

 dest = 0;            0,      GXclear,        0 */

 dest &= src;         DSa,    GXand,          0x1 */

 dest = src & ~dest;  SDna,   GXandReverse,   0x2 */

 dest = src;          S,      GXcopy,         0x3 */

 dest &= ~src;        DSna,   GXandInverted,  0x4 */

 dest = dest;         D,      GXnoop,         0x5 */

 dest = ^src;         DSx,    GXxor,          0x6 */

 dest |= src;         DSo,    GXor,           0x7 */

 dest = ~src & ~dest; DSon,   GXnor,          0x8 */

 dest ^= ~src ;       DSxn,   GXequiv,        0x9 */

 dest = ~dest;        Dn,     GXInvert,       0xA */

 dest = src|~dest ;   SDno,   GXorReverse,    0xB */

 dest = ~src;         Sn,     GXcopyInverted, 0xC */

 dest |= ~src;        DSno,   GXorInverted,   0xD */

 dest = ~src|~dest;   DSan,   GXnand,         0xE */

 dest = 0xFF;         1,      GXset,          0xF */

 same ROP but with Pattern as Source */

 dest = 0;            0,      GXclear,        0 */

 dest &= src;         DPa,    GXand,          0x1 */

 dest = src & ~dest;  PDna,   GXandReverse,   0x2 */

 dest = src;          P,      GXcopy,         0x3 */

 dest &= ~src;        DPna,   GXandInverted,  0x4 */

 dest = dest;         D,      GXnoop,         0x5 */

 dest = ^src;         DPx,    GXxor,          0x6 */

 dest |= src;         DPo,    GXor,           0x7 */

 dest = ~src & ~dest; DPon,   GXnor,          0x8 */

 dest ^= ~src ;       DPxn,   GXequiv,        0x9 */

 dest = ~dest;        Dn,     GXInvert,       0xA */

 dest = src|~dest ;   PDno,   GXorReverse,    0xB */

 dest = ~src;         Pn,     GXcopyInverted, 0xC */

 dest |= ~src;        DPno,   GXorInverted,   0xD */

 dest = ~src|~dest;   DPan,   GXnand,         0xE */

 dest = 0xFF;         1,      GXset,          0xF */

 300 series ----------------------------------------------------- */

 315/330/340 series ---------------------------------------------- */

 Set command - not needed, both 0 */

 SiSSetupCMDFlag(BITBLT | SRCVIDEO) */

 The chip is smart enough to know the direction */

	/* Although the chip knows the direction to use

	 * if the source and destination areas overlap,

	 * that logic fails if we fiddle with the bitmap

	 * addresses. Therefore, we check if the source

	 * and destination blitting areas overlap and

	 * adapt the bitmap addresses synchronously

	 * if the coordinates exceed the valid range.

	 * The the areas do not overlap, we do our

	 * normal check.

 --------------------------------------------------------------------- */

 The exported routines */

 Clipping */

 Clipping */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Geode GX framebuffer driver.

 *

 *   Copyright (C) 2006 Arcom Control Systems Ltd.

 *

 * This driver assumes that the BIOS has created a virtual PCI device header

 * for the video device. The PCI header is assumed to contain the following

 * BARs:

 *

 *    BAR0 - framebuffer memory

 *    BAR1 - graphics processor registers

 *    BAR2 - display controller registers

 *    BAR3 - video processor and flat panel control registers.

 *

 * 16 MiB of framebuffer memory is assumed to be available.

 Modes relevant to the GX (taken from modedb.c) */

 640x480-60 VESA */

 640x480-75 VESA */

 640x480-85 VESA */

 800x600-60 VESA */

 800x600-75 VESA */

 800x600-85 VESA */

 1024x768-60 VESA */

 1024x768-75 VESA */

 1024x768-85 VESA */

 1280x960-60 VESA */

 1280x960-85 VESA */

 1280x1024-60 VESA */

 1280x1024-75 VESA */

 1280x1024-85 VESA */

 1600x1200-60 VESA */

 1600x1200-75 VESA */

 1600x1200-85 VESA */

 The only mode the DCON has is 1200x900 */

 Enough video memory? */

 FIXME: Check timing parameters here? */

 grayscale = 0.30*R + 0.59*G + 0.11*B */

 Truecolor has hardware independent palette */

	/* Set the 16MiB aligned base address of the graphics memory region

 No HW acceleration for now. */

 Alloc enough space for the pseudo palette. */

	/* there's no point in setting PCI states; we emulate PCI, so

 Figure out if this is a TFT or CRT part */

 Clear the frame buffer of garbage. */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * drivers/video/geode/display_gx1.c

 *   -- Geode GX1 display controller

 *

 * Copyright (C) 2005 Arcom Control Systems Ltd.

 *

 * Based on AMD's original 2.4 driver:

 *   Copyright (C) 2004 Advanced Micro Devices, Inc.

 Calculate the total size of both DIMM0 and DIMM1. */

 look at DIMM1 next */

 Unlock the display controller registers. */

 Blank the display and disable the timing generator. */

 Wait for pending memory requests before disabling the FIFO load. */

 Disable FIFO load and compression. */

 Setup DCLK and its divisor. */

 FIXME: may need to divide DCLK by 2 sometimes? */

	/* Wait for the clock generatation to settle.  This is needed since

	 * some of the register writes that follow require that clock to be

 FIXME: seems a little long */

	/*

	 * Setup new mode.

 Clear all unused feature bits. */

 Set FIFO priority (default 6/5) and enable. */

 FIXME: increase fifo priority for 1280x1024 modes? */

 FIXME: Set pixel and line double bits if necessary. */

 Framebuffer start offset. */

 Line delta and line buffer length. */

 Output configuration. Enable panel data, set pixel format. */

 Enable timing generator, sync and FP data. */

 Horizontal and vertical timings. */

 Write final register values. */

 delay after TIMING_CFG. FIXME: perhaps a little long */

 Relock display controller registers */

	/* FIXME: write line_length and bpp to Graphics Pipeline GP_BLT_STATUS

 Hardware palette is in RGB 6-6-6 format. */

 SPDX-License-Identifier: GPL-2.0-or-later

/* Geode LX framebuffer driver

 *

 * Copyright (C) 2006-2007, Advanced Micro Devices,Inc.

/* TODO

 * Support panel scaling

 * Add acceleration

 * Add support for interlacing (TV out)

 * Support compression

/* This is the complete list of PLL frequencies that we can set -

 * we will choose the closest match to the incoming clock.

 * freq is the frequency of the dotclock * 1000 (for example,

 * 24823 = 24.983 Mhz).

 * pllval is the corresponding PLL value

 Wait 100us for the PLL to lock */

 Now, loop for the lock bit */

 Clear the reset bit */

 Set the clock based on the frequency specified by the current mode */

 Note:  This assumes that the video is in a quitet state */

 Turn off the VGA and video enable */

 turn off the panel */

 Turn off the display */

 Turn off the TGEN */

 Wait 1000 usecs to ensure that the TGEN is clear */

 Turn off the FIFO loader */

 Lastly, wait for the GP to go idle */

 Set the video request register */

 Set up the polarities */

 Turn the CRT dacs back on */

 Turn the panel on (if it isn't already) */

 The number of pages is (PMAX - PMIN)+1 */

 PMAX */

 PMIN */

 The page size is 4k */

 The frame buffer size is reported by a VSM in VSA II */

 Virtual Register Class    = 0x02                     */

 VG_MEM_SIZE (1MB units)   = 0x00                     */

 Unlock the DC registers */

 Set output mode */

 Clear the various buffers */

 FIXME:  Adjust for panning here */

 FIXME: Add support for interlacing */

 FIXME: Add support for scaling */

 Default scaling params */

 FIXME:  Support compression */

 Set default watermark values */

 Display fifo enable */

 default priority */

 Set the frame dirty mode */

 Enable video data */

 Enable graphics */

 Turn on the timing generator */

 Update timings immediately */

 Palette bypass in > 8 bpp modes */

 Always center the display */

 Set the current BPP mode */

 Now - set up the timings */

 And re-enable the graphics output */

 Write the two main configuration registers */

 Lock the DC registers */

 Hardware palette is in RGB 8-8-8 format. */

 CRT power saving modes. */

 Power on/off flat panel */

 wait for the BLT engine to stop being busy */

 save MSRs */

 save registers */

 save the display controller palette */

 save the video processor palette */

 save the horizontal filter coefficients */

 save the vertical filter coefficients */

 save video coeff ram */

 a bunch of registers require GP_RASTER_MODE to be set first */

 FIXME: restore LUT data */

 don't restore these registers */

 unlock the DC; runs first */

 disable all while restoring */

 set all ram to dirty */

 don't restore these registers */

 restore the palette */

 restore the horizontal filter coefficients */

 restore the vertical filter coefficients */

 case VP_VDC: */ 
 don't restore these registers */

 restore video processor palette */

 restore video coeff ram */

 Flat Panel */

 don't restore these registers */

 control the panel */

 power on the panel if not already power{ed,ing} on */

 power down the panel if not already power{ed,ing} down */

 turn everything on */

 do this last; it will enable the FIFO load */

 lock the door behind us */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *   Copyright (C) 2007 Advanced Micro Devices, Inc.

 *   Copyright (C) 2008 Andres Salomon <dilinger@debian.org>

 wait for the BLT engine to stop being busy */

 save MSRs */

 save registers */

 save the palette */

 wait for the PLL to lock */

 PLL set, unlock */

 don't restore these registers */

 unlock the DC; runs first */

 write without the enables */

 write without the enables */

 don't restore these registers */

 restore the palette */

 don't enable video yet */

 don't enable CRT yet */

 don't restore these registers */

 Flat Panel */

 shut down the engine */

 turn off the flat panel */

 turn off display */

 power on the panel if not already power{ed,ing} on */

 power down the panel if not already power{ed,ing} down */

 turn everything on */

 do this last; it will enable the FIFO load */

 lock the door behind us */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * drivers/video/geode/video_cs5530.c

 *   -- CS5530 video device

 *

 * Copyright (C) 2005 Arcom Control Systems Ltd.

 *

 * Based on AMD's original 2.4 driver:

 *   Copyright (C) 2004 Advanced Micro Devices, Inc.

/*

 * CS5530 PLL table. This maps pixclocks to the appropriate PLL register

 * value.

 ps */

  25.1750 MHz */

  28.3220 */

  31.5000 */

  36.0000 */

  37.5000 */

  40.0000 */

  44.9000 */

  49.5000 */

  50.0000 */

  50.3500 */

  54.0000 */

  56.2500 */

  56.3916 */

  56.6444 */

  59.0000 */

  63.0000 */

  65.0000 */

  67.5000 */

  70.8000 */

  72.0000 */

  75.0000 */

  78.7500 */

  80.0000 */

  89.8000 */

  94.5000 */

  99.0000 */

 100.0000 */

 108.0000 */

 112.5000 */

 130.0000 */

 135.0000 */

 157.5000 */

 162.0000 */

 175.0000 */

 189.0000 */

 202.0000 */

 232.0000 */

 Search the table for the closest pixclock. */

 set reset and bypass */

 wait for PLL to settle */

 clear reset */

 clear bypass */

 Clear bits from existing mode. */

 Set default sync skew and power sequence delays.  */

 Enable DACs, hsync and vsync for CRTs */

 Enable panel power and data if using a flat panel. */

 Sync polarities. */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Geode LX framebuffer driver.

 *

 * Copyright (C) 2007 Advanced Micro Devices, Inc.

 * Built from gxfb (which is Copyright (C) 2006 Arcom Control Systems Ltd.)

/* Most of these modes are sorted in ascending order, but

 * since the first entry in this table is the "default" mode,

 * we try to make it something sane - 640x480-60 is sane

 640x480-60 */

 640x400-70 */

 640x480-70 */

 640x480-72 */

 640x480-75 */

 640x480-85 */

 640x480-90 */

 640x480-100 */

 640x480-60 */

 800x600-56 */

 800x600-60 */

 800x600-70 */

 800x600-72 */

 800x600-75 */

 800x600-85 */

 800x600-90 */

 800x600-100 */

 800x600-60 */

 1024x768-60 */

 1024x768-70 */

 1024x768-72 */

 1024x768-75 */

 1024x768-85 */

 1024x768-90 */

 1024x768-100 */

 1024x768-60 */

 1152x864-60 */

 1152x864-70 */

 1152x864-72 */

 1152x864-75 */

 1152x864-85 */

 1152x864-90 */

 1152x864-100 */

 1152x864-60 */

 1280x1024-60 */

 1280x1024-70 */

 1280x1024-72 */

 1280x1024-75 */

 1280x1024-85 */

 1280x1024-90 */

 1280x1024-100 */

 1280x1024-60 */

 1600x1200-60 */

 1600x1200-70 */

 1600x1200-72 */

 1600x1200-75 */

 1600x1200-85 */

 1600x1200-90 */

 1600x1200-100 */

 1600x1200-60 */

 1920x1440-60 */

 1920x1440-70 */

 1920x1440-72 */

 1920x1440-75 */

 1920x1440-85 */

 The only mode the DCON has is 1200x900 */

 Enough video memory? */

 grayscale = 0.30*R + 0.59*G + 0.11*B */

 Truecolor has hardware independent palette */

 No HW acceleration for now. */

 Alloc enough space for the pseudo palette. */

	/* there's no point in setting PCI states; we emulate PCI, so

 Set up the desired outputs */

 Set up the mode database */

	/* Clear the screen of garbage, unless noclear was specified,

 Set the mode */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Geode GX video processor device.

 *

 *   Copyright (C) 2006 Arcom Control Systems Ltd.

 *

 *   Portions from AMD's original 2.4 driver:

 *     Copyright (C) 2004 Advanced Micro Devices, Inc.

/*

 * Tables of register settings for various DOTCLKs.

 ps */

  24.9230 */

  25.1750 */

  28.3220 */

  31.5000 */

  36.0000 */

  37.5000 */

  40.0000 */

  44.9000 */

  49.5000 */

  50.0000 */

  50.3500 */

  54.0000 */

  56.2500 */

  56.3916 */

  56.6444 */

  59.0000 */

  63.0000 */

  65.0000 */

  67.5000 */

  70.8000 */

  72.0000 */

  74.4810 */

  75.0000 */

  78.7500 */

  80.0000 */

  89.8000 */

  94.5000 */

  99.0000 */

 100.0000 */

 108.0000 */

 112.5000 */

 130.0000 */

 135.0000 */

 157.5000 */

 162.0000 */

 172.798  */

 175.5000 */

 189.0000 */

 202.5000 */

 229.5000 */

  25.1750 */

  28.3220 */

  31.5000 */

  36.0000 */

  37.5000 */

  40.0000 */

  44.9000 */

  49.5000 */

  50.0000 */

  50.3500 */

  54.0000 */

  56.2500 */

  56.3916 */

  56.6444 */

  59.0000 */

  63.0000 */

  65.0000 */

  67.5000 */

  70.8000 */

  72.0000 */

  75.0000 */

  78.7500 */

  80.0000 */

  89.8000 */

  94.5000 */

  99.0000 */

 100.0000 */

 108.0000 */

 112.5000 */

 130.0000 */

 135.0000 */

 157.5000 */

 162.0000 */

 175.5000 */

 189.0000 */

 202.5000 */

 229.5000 */

 Rev. 1 Geode GXs use a 14 MHz reference clock instead of 48 MHz. */

 Search the table for the closest pixclock. */

 Program new M, N and P. */

 Program dividers. */

 Clear reset bit to start PLL. */

 Wait for LOCK bit. */

 Set up the DF pad select MSR */

 Turn off the panel */

 Set timing 1 */

 Timing 2 */

 Set bits that are always on for TFT */

 Configure sync polarity */

  Set the dither control */

 Enable the FP data and power (in case the BIOS didn't) */

 Unblank the panel */

 Write the display configuration */

 Disable hsync and vsync */

 Clear bits from existing mode. */

 Set default sync skew.  */

 Enable hsync and vsync. */

 Disable gamma correction */

 Power up the CRT DACs */

		/* Only change the sync polarities if we are running

		 * in CRT mode.  The FP polarities will be handled in

 Power down the CRT DACs if in FP mode */

 Enable the display logic */

 Set up the DACS to blank normally */

 Enable the external DAC VREF? */

 Set up the flat panel (if it is enabled) */

 CRT power saving modes. */

 Power on/off flat panel. */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * drivers/video/geode/gx1fb_core.c

 *   -- Geode GX1 framebuffer driver

 *

 * Copyright (C) 2005 Arcom Control Systems Ltd.

 Modes relevant to the GX1 (taken from modedb.c) */

 640x480-60 VESA */

 640x480-75 VESA */

 640x480-85 VESA */

 800x600-60 VESA */

 800x600-75 VESA */

 800x600-85 VESA */

 1024x768-60 VESA */

 1024x768-75 VESA */

 1024x768-85 VESA */

 1280x960-60 VESA */

 1280x960-85 VESA */

 1280x1024-60 VESA */

 1280x1024-75 VESA */

 1280x1024-85 VESA */

 Maximum resolution is 1280x1024. */

 Only 16 bpp and 8 bpp is supported by the hardware. */

 Enough video memory? */

 FIXME: Check timing parameters here? */

 grayscale = 0.30*R + 0.59*G + 0.11*B */

 Truecolor has hardware independent palette */

 No HW acceleration for now. */

 Alloc enough space for the pseudo palette. */

 CRT and panel options */

 fall back to CRT if no panel is specified */

 GX1 display controller and CS5530 video device */

 Clear the frame buffer of garbage. */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Geode GX display controller.

 *

 *   Copyright (C) 2005 Arcom Control Systems Ltd.

 *

 *   Portions from AMD's original 2.4 driver:

 *     Copyright (C) 2004 Advanced Micro Devices, Inc.

 The number of pages is (PMAX - PMIN)+1 */

 PMAX */

 PMIN */

 The page size is 4k */

 FB size can be obtained from the VSA II */

 Virtual register class = 0x02 */

 VG_MEM_SIZE(512Kb units) = 0x00 */

 Must be a multiple of 8 bytes. */

 Unlock the display controller registers. */

 Disable the timing generator. */

 Wait for pending memory requests before disabling the FIFO load. */

 Disable FIFO load and compression. */

 Setup DCLK and its divisor. */

	/*

	 * Setup new mode.

 Clear all unused feature bits. */

 Set FIFO priority (default 6/5) and enable. */

 FIXME: increase fifo priority for 1280x1024 and higher modes? */

 Framebuffer start offset. */

 Line delta and line buffer length. */

 Enable graphics and video data and unmask address lines. */

 Set pixel format. */

 Enable timing generator. */

 Horizontal and vertical timings. */

 Write final register values. */

 Relock display controller registers */

 Hardware palette is in RGB 8-8-8 format. */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Framebuffer driver for TI OMAP boards

 *

 * Copyright (C) 2004 Nokia Corporation

 * Author: Imre Deak <imre.deak@nokia.com>

 *

 * Acknowledgements:

 *   Alex McMains <aam@ridgerun.com>       - Original driver

 *   Juha Yrjola <juha.yrjola@nokia.com>   - Original driver and improvements

 *   Dirk Behme <dirk.behme@de.bosch.com>  - changes for 2.6 kernel API

 *   Texas Instruments                     - H3 support

 dummy device for clocks */

/*

 * ---------------------------------------------------------------------------

 * LCD panel

 * ---------------------------------------------------------------------------

/*

 * ---------------------------------------------------------------------------

 * LCD controller and LCD DMA

 * ---------------------------------------------------------------------------

/*

 * Allocate resources needed for LCD controller and LCD DMA operations. Video

 * memory is allocated from system memory according to the virtual display

 * size, except if a bigger memory size is specified explicitly as a kernel

 * parameter.

 kernel/module vram parameters override boot tags/board config */

 12 bpp is packed in 16 bits */

 Must be called with fbdev->rqueue_mutex held. */

/*

 * ---------------------------------------------------------------------------

 * fbdev framework callbacks and the ioctl interface

 * ---------------------------------------------------------------------------

 Called each time the omapfb device is opened */

/* Called when the omapfb device is closed. We make sure that any pending

/* Store a single color palette entry into a pseudo palette or the hardware

 * palette if one is available. For now we support only 16bpp and thus store

 * the entry only to the pseudo palette.

/*

 * Set fb_info.fix fields and also updates fbdev.

 * When calling this fb_info.var must be set up already.

 12bpp is stored in 16 bits */

/*

 * Check the values in var against our capabilities and in case of out of

 * bound values try to adjust them.

 Try to keep yres_virtual first */

 Still doesn't fit. Shrink yres_virtual too */

 Recheck this, as the virtual size changed. */

 pixclock in ps, the rest in pixclock */

 TODO: get these from panel->config */

/*

 * Set new x,y offsets in the virtual display for the visible area and switch

 * to the new mode.

 Set mirror to vertical axis and switch to the new mode. */

/*

 * Check values in var, try to adjust them in case of out of bound values if

 * possible, or return error.

/*

 * Switch to a new mode. The parameters for it has been check already by

 * omapfb_check_var.

		/*

		 * This plane's memory was freed, can't enable it

		 * until it's reallocated.

		/*

		 * size == 0 is a special case, for which we

		 * don't check / adjust the screen parameters.

		 * This isn't a problem since the plane can't

		 * be reenabled unless its size is > 0.

 Revert changes. */

				/*

				 * Set these explicitly to indicate that the

				 * plane memory is dealloce'd, the other

				 * screen parameters in var / fix are invalid.

 no client registered yet */

 For lcd testing */

/*

 * Ioctl interface. Part of the kernel mode frame buffer API is duplicated

 * here to be accessible by user mode code.

/*

 * Callback table for the frame buffer framework. Some of these pointers

 * will be changed according to the current setting of fb_info->accel_flags.

/*

 * ---------------------------------------------------------------------------

 * Sysfs interface

 * ---------------------------------------------------------------------------

 omapfbX sysfs entries */

 panel sysfs entries */

 ctrl sysfs entries */

/*

 * ---------------------------------------------------------------------------

 * LDM callbacks

 * ---------------------------------------------------------------------------

/* Initialize system fb_info object and set the default video mode.

 * The frame buffer memory already allocated by lcddma_init

 Release the fb_info object */

/*

 * Free driver resources. Can be called to rollback an aborted initialization

 * sequence.

 nothing to free */

/*

 * Called by LDM binding to probe and attach a new device.

 * Initialization sequence:

 *   1. allocate system omapfb_device structure

 *   2. select controller type according to platform configuration

 *      init LCD panel

 *   3. init LCD controller and LCD DMA

 *   4. init system fb_info structure for all planes

 *   5. setup video mode for first plane and enable it

 *   6. enable LCD panel

 *   7. register sysfs attributes

 *   OMAPFB_ACTIVE: register system fb_info structure for all planes

 Set DMA priority for EMIFF access to highest */

 GFX plane is enabled by default */

 Delay actual initialization until the LCD is registered */

 Called when the device is being detached from the driver */

 FIXME: wait till completion of pending events */

 PM suspend */

 PM resume */

 Process kernel command line parameters */

 Register both the driver and the device */

 Register the driver with LDM */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * LCD panel support for the Palm Zire71

 *

 * Original version : Romain Goyet

 * Current version : Laurent Gonzalez

 * Modified for zire71 : Marek Vasut

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * File: drivers/video/omap/lcd-htcherald.c

 *

 * LCD panel support for the HTC Herald

 *

 * Copyright (C) 2009 Cory Maccarrone <darkstar6262@gmail.com>

 * Copyright (C) 2009 Wing Linux

 *

 * Based on the lcd_htcwizard.c file from the linwizard project:

 * Copyright (C) linwizard.sourceforge.net

 * Author: Angelo Arrifano <miknix@gmail.com>

 * Based on lcd_h4 by Imre Deak <imre.deak@nokia.com>

 Found on WIZ200 (miknix) and some HERA110 models (darkstar62) */

 15 */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * OMAP1 internal LCD controller

 *

 * Copyright (C) 2004 Nokia Corporation

 * Author: Imre Deak <imre.deak@nokia.com>

 enabled IRQs */

	/*

	 * Preserve the DONE mask, since we still want to get the

	 * final DONE irq. It will be disabled in the IRQ handler.

/*

 * Configure the LCD DMA according to the current mode specified by parameters

 * in lcdc.fbdev and fbdev->var.

		/*

		 * YUV support is only for external mode when we have the

		 * YUV window embedded in a 16bpp frame buffer.

 Set virtual xres elem size */

 Setup transformations */

			/*

			 * Disable IRQ_DONE. The status bit will be cleared

			 * only when the controller is reenabled and we don't

			 * want to get more interrupts.

	/*

	 * Clear these interrupt status bits.

	 * Sync_lost, FUF bits were cleared by disabling the LCD controller

	 * LOADED_PALETTE can be cleared this way only in palette only

	 * load mode. In other load modes it's cleared by disabling the

	 * controller.

/*

 * Change to a new video mode. We defer this to a later time to avoid any

 * flicker and not to mess up the current LCD DMA context. For this we disable

 * the LCD controller, which will generate a DONE irq after the last frame has

 * been transferred. Then it'll be safe to reconfigure both the LCD controller

 * as well as the LCD DMA.

		/* FIXME: other BPPs.

		 * bpp1: code  0,     size 256

		 * bpp2: code  0x1000 size 256

		 * bpp4: code  0x2000 size 256

		 * bpp12: code 0x4000 size 32

/*

 * Configure the LCD DMA for a palette load operation and do the palette

 * downloading synchronously. We don't use the frame+palette load mode of

 * the controller, since the palette can always be downloaded separately.

 The controller gets disabled in the irq handler */

 Used only in internal controller mode */

 FIXME: try to adjust logic clock divider as well */

 FIXME:if (machine_is_omap_palmte()) { */

 PalmTE uses alternate TFT setting in 8BPP mode */

	} */

 update panel info with the exact clock */

/*

 * Configure the LCD controller, download the color palette and start a looped

 * DMA transfer of the frame image data. Called only in internal

 * controller mode.

 Setup and start LCD DMA */

 This will start the actual DMA transfer */

 PM code called only in internal controller mode */

	/* FIXME:

	 * According to errata some platforms have a clock rate limitiation

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * LCD panel support for the TI OMAP H3 board

 *

 * Copyright (C) 2004 Nokia Corporation

 * Author: Imre Deak <imre.deak@nokia.com>

 GPIO1 and GPIO2 of TPS65010 send LCD_ENBKL and LCD_ENVDD signals */

 GPIO1 and GPIO2 of TPS65010 send LCD_ENBKL and LCD_ENVDD signals */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * LCD panel support for Palm Tungsten|T

 * Current version : Marek Vasut <marek.vasut@gmail.com>

 *

 * Modified from lcd_inn1510.c

/*

GPIO11 - backlight

GPIO12 - screen blanking

GPIO13 - screen blanking

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Epson HWA742 LCD controller driver

 *

 * Copyright (C) 2004-2005 Nokia Corporation

 * Authors:     Juha Yrjölä   <juha.yrjola@nokia.com>

 *	        Imre Deak     <imre.deak@nokia.com>

 * YUV support: Jussi Laako   <jussi.laako@nokia.com>

 Reserve 4 request slots for requests in irq context */

	/*

	 * @req_lock: protect request slots pool and its tracking lists

	 * @req_sema: counter; slot allocators from task contexts must

	 *            push it down before acquiring a slot. This

	 *            guarantees that atomic contexts will always have

	 *            a minimum of IRQ_REQ_POOL_SIZE slots available.

	/* CSOnTime 0, WEOnTime 2 ns, REOnTime 2 ns,

	 * AccessTime 2 ns + 12.2 ns (regs),

	 * WEOffTime = WEOnTime + 1 ns,

	 * REOffTime = REOnTime + 16 ns (regs),

	 * CSOffTime = REOffTime + 1 ns

	 * ReadCycle = 2ns + 2*SYSCLK  (regs),

	 * WriteCycle = 2*SYSCLK + 2 ns,

	/* CSOnTime 0, WEOnTime 2 ns, REOnTime 2 ns,

	 * AccessTime 2 ns + 4 * SYSCLK + 26 (lut),

	 * WEOffTime = WEOnTime + 1 ns,

	 * REOffTime = REOnTime + 4*SYSCLK + 26 ns (lut),

	 * CSOffTime = REOffTime + 1 ns

	 * ReadCycle = 2ns + 4*SYSCLK + 26 ns (lut),

	 * WriteCycle = 2*SYSCLK + 2 ns,

	 * CSPulseWidth = 10 ns

 Source is the PLL */

 else source is ext clk, or oscillator */

 HZ */

 time to transfer one pixel (16bpp) in ps */

		/*

		 * The external interface might have a rate limitation,

		 * if so, we have to maximize our transfer rate.

 ps */

 time to update one line in ps */

		/*

		 * transfer speed too low, we might have to use both

		 * HS and VS

 decent transfer speed, we'll always use only VS */

		/*

		 * HS or'ed with VS doesn't work, use the active high

		 * TE signal based on HNDP / VNDP

		/*

		 * Use HS or'ed with VS as a TE signal if both are needed

		 * or VNDP if only vsync is needed.

 ps */

 ps */

 set VS to 120% of HS to minimize VS detection time */

 minimize HS too */

 Enable sleep mode */

 Disable sleep mode */

 Loop until PLL output is stabilized */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * OMAP1 Special OptimiSed Screen Interface support

 *

 * Copyright (C) 2004-2005 Nokia Corporation

 * Author: Juha Yrjölä <juha.yrjola@nokia.com>

 timing for read and write access */

	/*

	 * if last_access is the same as current we don't have to change

	 * the timings

	/*

	 * Make sure that after conversion it still holds that:

	 * reoff > reon, recyc >= reoff, actim > reon

 reon will be exactly one sossi tick */

 values less then 3 result in the SOSSI block resetting itself */

	/*

	 * access time (data hold time) will be exactly one sossi

	 * tick

	/*

	 * Make sure that after conversion it still holds that:

	 * weoff > weon, wecyc >= weoff

 weon will be exactly one sossi tick */

 values less then 3 result in the SOSSI block resetting itself */

 TE logic */

 WE */

 CS active low */

 WE */

 CS active low */

 Before reading we must check if some writings are going on */

 no CS on SOSSI, so ignore cson, csoff, cs_pulsewidth */

	/*

	 * We set explicitly the the bus_pick_count as well, although

	 * with remapping/reordering disabled it will be calculated by HW

	 * as (32 / bus_pick_width).

 HS or VS */

 VS only */

 CMD#/DATA */

 CMD#/DATA */

 CMD#/DATA */

		/*

		 * Wait for the sync signal and start the transfer only

		 * then. We can't seem to be able to use HW sync DMA for

		 * this since LCD DMA shows huge latencies, as if it

		 * would ignore some of the DMA requests from SoSSI.

 Just start the transfer right away. */

 CMD#/DATA */

	/*

	 * We need the parent clock rate, which we might divide further

	 * depending on the timing requirements of the controller. See

	 * _set_timings.

 Reset and enable the SoSSI module */

 DMACK_REQ */

 Enable and reset the SoSSI block */

 Take SoSSI out of reset */

 Component code */

 DMA_MODE */

 REORDERING */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * LCD panel support for the Palm Tungsten E

 *

 * Original version : Romain Goyet <r.goyet@gmail.com>

 * Current version : Laurent Gonzalez <palmte.linux@free.fr>

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Based on drivers/video/omap/lcd_inn1510.c

 *

 * LCD panel support for the Amstrad E3 (Delta) videophone.

 *

 * Copyright (C) 2006 Jonathan McDowell <noodles@earth.li>

 LCD class device section */

 omapfb panel section */

 platform driver section */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * LCD panel support for the TI OMAP1510 Innovator board

 *

 * Copyright (C) 2004 Nokia Corporation

 * Author: Imre Deak <imre.deak@nokia.com>

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * LCD panel support for the TI OMAP OSK board

 *

 * Copyright (C) 2004 Nokia Corporation

 * Author: Imre Deak <imre.deak@nokia.com>

 * Adapted for OSK by <dirk.behme@de.bosch.com>

 configure PWL pin */

 Enable PWL unit */

 Set PWL level */

 set GPIO2 high (lcd power enabled) */

 Set PWL level to zero */

 Disable PWL unit */

 set GPIO2 low */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * LCD driver for MIPI DBI-C / DCS compatible LCDs

 *

 * Copyright (C) 2006 Nokia Corporation

 * Author: Imre Deak <imre.deak@nokia.com>

	unsigned long	hw_guard_end;		/* next value of jiffies

						   when we can issue the

 max guard time in jiffies */

			/* Arrange for the extra clock before the first

			 * data bit.

	/*

	 * When we enable the panel, it seems we _have_ to sleep

	 * 120 ms before sending the init string. When disabling the

	 * panel we'll sleep for the duration of 2 frames, so that the

	 * controller can still provide the PCLK,HS,VS signals.

 24 bit -> 16 bit */

	/* Each sleep out command will trigger a self diagnostic and flip

	* Bit6 if the test passes.

	/*

	 * A final ESD work might be called before returning,

	 * so do this without holding the lock.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * LCD panel support for the TI OMAP1610 Innovator board

 *

 * Copyright (C) 2004 Nokia Corporation

 * Author: Imre Deak <imre.deak@nokia.com>

 configure GPIO(14, 15) as outputs */

 set GPIO14 and GPIO15 high */

 set GPIO13, GPIO14 and GPIO15 low */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * linux/drivers/video/mmp/common.c

 * This driver is a common framework for Marvell Display Controller

 *

 * Copyright (C) 2012 Marvell Technology Group Ltd.

 * Authors: Zhou Zhu <zzhu3@marvell.com>

/*

 * Get modelist write pointer of modelist.

 * It also returns modelist number

 * this function fetches modelist from phy/panel:

 *   for HDMI/parallel or dsi to hdmi cases, get from phy

 *   or get from panel

/*

 * panel list is used to pair panel/path when path/panel registered

 * path list is used for both buffer driver and platdriver

 * plat driver do path register/unregister

 * panel driver do panel register/unregister

 * buffer driver get registered path

/*

 * mmp_register_panel - register panel to panel_list and connect to path

 * @p: panel to be registered

 *

 * this function provides interface for panel drivers to register panel

 * to panel_list and connect to path which matchs panel->plat_path_name.

 * no error returns when no matching path is found as path register after

 * panel register is permitted.

 add */

 try to register to path */

/*

 * mmp_unregister_panel - unregister panel from panel_list and disconnect

 * @p: panel to be unregistered

 *

 * this function provides interface for panel drivers to unregister panel

 * from panel_list and disconnect from path.

/*

 * mmp_get_path - get path by name

 * @p: path name

 *

 * this function checks path name in path_list and return matching path

 * return NULL if no matching path

/*

 * mmp_register_path - init and register path by path_info

 * @p: path info provided by display controller

 *

 * this function init by path info and register path to path_list

 * this function also try to connect path with panel by name

 path set */

 get panel */

 default op set: if already set by driver, never cover it */

 step3: init overlays */

 add to pathlist */

/*

 * mmp_unregister_path - unregister and destroy path

 * @p: path to be destroyed.

 *

 * this function registers path and destroys it.

 del from pathlist */

 deinit overlays */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * linux/drivers/video/mmp/panel/tpo_tj032md01bw.c

 * active panel using spi interface to do init

 *

 * Copyright (C) 2012 Marvell Technology Group Ltd.

 * Authors:  Guoqing Li <ligq@marvell.com>

 *          Lisa Du <cldu@marvell.com>

 *          Zhou Zhu <zzhu3@marvell.com>

 get configs from platform data */

 setup spi related info */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * linux/drivers/video/mmp/fb/mmpfb.c

 * Framebuffer driver for Marvell Display controller.

 *

 * Copyright (C) 2012 Marvell Technology Group Ltd.

 * Authors: Zhou Zhu <zzhu3@marvell.com>

	/*

	 * Pseudocolor mode?

	/*

	 * Check for YUV422PLANAR.

	/*

	 * Check for YUV420PLANAR.

	/*

	 * Check for YUV422PACK.

	/*

	 * Check for 565/1555.

	/*

	 * Check for 888/A888.

/*

 * fb framework has its limitation:

 * 1. input color/output color is not seprated

 * 2. fb_videomode not include output color

 * so for fb usage, we keep a output format which is not changed

 *  then it's added for mmpmode

 no defined flag in fb, use vmode>>3*/

	/*

	 * Basic geometry sanity checks.

	/*

	 * Check size of framebuffer.

 TODO */

 set pix_fmt */

 set var according to best video mode*/

 fix to 2* yres */

 set window/path according to new videomode */

 set window related info */

 set address always */

 for power on, always set address/window again */

 set window related info */

 set address always */

 get videomodes from path */

 put videomode list to info structure */

 set videomode[0] as default mode */

 Initialise static fb parameters.*/

 For FB framework: Allocate color map and Register framebuffer*/

 initialize fb */

 init fb */

 get display path by name */

 get overlay */

 set fetch used */

	/*

	 * if get modes success, means not hotplug panels, use caculated buffer

	 * or use default size

 fix to 2* yres */

 Allocate framebuffer memory: size = modes xy *4 */

 fb power on */

