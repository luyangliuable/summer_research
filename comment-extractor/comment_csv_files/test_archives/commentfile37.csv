 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2018 Netronome Systems, Inc. */

 Entries may be larger in future FW */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2016-2018 Netronome Systems, Inc. */

 Decode destination */

 Decode source operands */

 Decode destination */

 Decode source operands */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2019 Netronome Systems, Inc. */

/**

 * struct nfp_devlink_param_u8_arg - Devlink u8 parameter get/set arguments

 * @hwinfo_name:	HWinfo key name

 * @default_hi_val:	Default HWinfo value if HWinfo doesn't exist

 * @invalid_dl_val:	Devlink value to use if HWinfo is unknown/invalid.

 *			-errno if there is no unknown/invalid value available

 * @hi_to_dl:	HWinfo to devlink value mapping

 * @dl_to_hi:	Devlink to hwinfo value mapping

 * @max_dl_val:	Maximum devlink value supported, for validation only

 * @max_hi_val:	Maximum HWinfo value supported, for validation only

 Note the value has already been validated. */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2015-2018 Netronome Systems, Inc. */

 Create queue debugging sub-tree */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2015-2018 Netronome Systems, Inc. */

/*

 * nfp_net_main.c

 * Netronome network device driver: Main entry point

 * Authors: Jakub Kicinski <jakub.kicinski@netronome.com>

 *          Alejandro Lucero <alejandro.lucero@netronome.com>

 *          Jason McMullan <jason.mcmullan@netronome.com>

 *          Rolf Neugebauer <rolf.neugebauer@netronome.com>

/**

 * nfp_net_get_mac_addr() - Get the MAC address.

 * @pf:       NFP PF handle

 * @netdev:   net_device to set MAC address on

 * @port:     NFP port structure

 *

 * First try to get the MAC address from NSP ETH table. If that

 * fails generate a random address.

 Allocate and initialise the vNIC */

 Kill the vNIC if app init marked it as invalid */

 Get MSI-X vectors */

 Distribute IRQs to vNICs */

 Finish vNIC init and register */

 Check for nfp_net_pci_remove() racing against us */

 Update state of all ports */

 Resync repr state. This may cause reprs to be removed. */

 Shoot off the ports which became invalid */

/*

 * PCI device functions

 Determine stride */

 Allocate the vnics and do basic init */

 stop app first, to avoid double free of ctrl vNIC's ddir */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2018 Netronome Systems, Inc. */

 Ignore the legacy TLV if new one was already parsed */

 Advance past the header */

 Not reached */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2015-2018 Netronome Systems, Inc. */

/*

 * nfp_netvf_main.c

 * Netronome virtual function network device driver: Main entry point

 * Author: Jason McMullan <jason.mcmullan@netronome.com>

 *         Rolf Neugebauer <rolf.neugebauer@netronome.com>

/**

 * struct nfp_net_vf - NFP VF-specific device structure

 * @nn:		NFP Net structure for this device

 * @irq_entries: Pre-allocated array of MSI-X entries

 * @q_bar:	Pointer to mapped QC memory (NULL if TX/RX mapped directly)

 * @ddir:	Per-device debugfs directory

 Required last entry. */

	/* Map the Control BAR.

	 *

	 * Irrespective of the advertised BAR size we only map the

	 * first NFP_NET_CFG_BAR_SZ of the BAR.  This keeps the code

	 * the identical for PF and VF drivers.

 Determine stride */

 Find out how many rings are supported */

 Sanity checks */

 Allocate and initialise the netdev */

 Make a single overlapping BAR mapping */

 TX queues */

 RX queues */

 TX queues */

 RX queues */

	/* Note, the order is slightly different from above as we need

	 * to keep the nn pointer around till we have freed everything.

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2017-2019 Netronome Systems, Inc. */

 Write update info to mailbox in VF config symbol */

 Signal VF reconfiguration */

 Write MAC to VF entry in VF config symbol */

 Write VLAN tag to VF entry in VF config symbol */

 Write spoof check control bit to VF entry in VF config symbol */

 Write trust control bit to VF entry in VF config symbol */

 Write link state to VF entry in VF config symbol */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2017-2018 Netronome Systems, Inc. */

/**

 * nfp_port_configure() - helper to set the interface configured bit

 * @netdev:	net_device instance

 * @configed:	Desired state

 *

 * Helper to set the ifup/ifdown state on the PHY only if there is a physical

 * interface associated with the netdev.

 *

 * Return:

 * 0 - configuration successful (or no change);

 * -ERRNO - configuration failed.

 Check if vNIC has external port associated and cfg is OK */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2017-2018 Netronome Systems, Inc. */

/* The following structs must be carefully aligned so that they can be used to

 * interpret the binary dumpspec and populate the dump data in a deterministic

 * way.

 generic type plus length */

 chunk length to follow, aligned to 8 bytes */

 NFP CPP parameters */

 address to start dump */

 total bytes to dump, aligned to reg size */

 CSR dumpables */

 in bits */

 header for register dumpable */

 in bits */

 error code encountered while reading */

 offset being read when error occurred */

 error code encountered while reading */

 pad so data starts at 8 byte boundary */

 after padded_name_length, there is dump_length data */

 to track state through debug size calculation TLV traversal */

 input */

 output */

 to track state during debug dump creation TLV traversal */

 input param */

 adds up to size of dumped data */

 size of buffer pointer to by p */

 current point in dump buffer */

 Spec TLVs should be aligned to 4 bytes. */

 expected size of this buffer is in the order of tens of kilobytes */

/* Write context to CSRCtxPtr, then read from it. Then the value can be read

 * from IndCtxStatus.

	/* Set size of actual dump, to trigger warning if different from

	 * calculated size.

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2017-2018 Netronome Systems, Inc. */

 no change */

 Special case the 100G CXP -> 2x40G split */

 Special case the 100G CXP -> 2x40G unsplit */

 code name */		"assembly.model", },

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2015-2018 Netronome Systems, Inc. */

/*

 * nfp_net_ethtool.c

 * Netronome network device driver: ethtool support

 * Authors: Jakub Kicinski <jakub.kicinski@netronome.com>

 *          Jason McMullan <jason.mcmullan@netronome.com>

 *          Rolf Neugebauer <rolf.neugebauer@netronome.com>

 *          Brad Petrus <brad.petrus@netronome.com>

 Stats from the device */

	/* see comments in outro functions in nfp_bpf_jit.c to find out

	 * how different BPF modes use app-specific counters

/**

 * nfp_net_get_link_ksettings - Get Link Speed settings

 * @netdev:	network interface device structure

 * @cmd:	ethtool command

 *

 * Reports speed settings based on info in the BAR provided by the fw.

 Init to unknowns */

 Use link speed from ETH table if available, otherwise try the BAR */

 no change */

 We don't have separate queues/rings for small/large frames. */

 Round up to supported values */

	/* If repr is true first add SWITCH_STATS_LEN and then subtract it

	 * effectively swapping the RX and TX statistics (giving us the RX

	 * and TX from perspective of the switch).

 NSP only supports a single mode at a time */

 Only refresh if we did something */

/* RX network flow classification (RSS, filters, etc)

 RSS only supports IP SA/DA and L4 src/dst ports  */

 We need at least the IP SA/DA fields for hashing */

/* Dump BAR registers

/* Other debug dumps

/* Set the dump flag/level. Calculate the dump length for flag > 0 only (new TLV

 * based dumps), since flag 0 (default) calculates the length in

 * nfp_app_get_dump_flag(), and we need to support triggering a level 0 dump

 * without setting the flag first, for backward compatibility.

	/* Compute factor used to convert coalesce '_usecs' parameters to

	 * ME timestamp ticks.  There are 16 ME clock cycles for each timestamp

	 * count.

	/* Each pair of (usecs, max_frames) fields specifies that interrupts

	 * should be coalesced until

	 *      (usecs > 0 && time_since_first_completion >= usecs) ||

	 *      (max_frames > 0 && completed_frames >= max_frames)

	 *

	 * It is illegal to set both usecs and max_frames to zero as this would

	 * cause interrupts to never be generated.  To disable coalescing, set

	 * usecs = 0 and max_frames = 1.

	 *

	 * Some implementations ignore the value of max_frames and use the

	 * condition time_since_first_completion >= usecs

 ensure valid configuration */

 configuration is valid */

 write configuration to device */

 nfp_net_check_config() will catch num_tx_rings > nn->max_tx_rings */

 Reject unsupported */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2017-2018 Netronome Systems, Inc. */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2017-2018 Netronome Systems, Inc. */

 Handle events common code is interested in */

 Call offload specific handlers */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2019 Netronome Systems, Inc. */

/* CCM messages via the mailbox.  CMSGs get wrapped into simple TLVs

 * and copied into the mailbox.  Multiple messages can be copied to

 * form a batch.  Threads come in with CMSG formed in an skb, then

 * enqueue that skb onto the request queue.  If threads skb is first

 * in queue this thread will handle the mailbox operation.  It copies

 * up to 64 messages into the mailbox (making sure that both requests

 * and replies will fit.  After FW is done processing the batch it

 * copies the data out and wakes waiting threads.

 * If a thread is waiting it either gets its the message completed

 * (response is copied into the same skb as the request, overwriting

 * it), or becomes the first in queue.

 * Completions and next-to-run are signaled via the control buffer

 * to limit potential cache line bounces.

/**

 * struct nfp_ccm_mbox_cmsg_cb - CCM mailbox specific info

 * @state:	processing state (/stage) of the message

 * @err:	error encountered during processing if any

 * @max_len:	max(request_len, reply_len)

 * @exp_reply:	expected reply length (0 means don't validate)

 * @posted:	the message was posted and nobody waits for the reply

 common mbox command header */

 Msg TLV plus End TLV headers */

 Write data word by word, skb->data should be aligned */

 Reserve space if reply is bigger */

 Advance past the header */

			/* We overcopy here slightly, but that's okay,

			 * the skb is large enough, and the garbage will

			 * be ignored (beyond skb->len).

 order the skb->data vs. cb->state */

 order the cb->err vs. cb->state */

 order the cb->err vs. cb->state */

 for End TLV */

 First skb must fit, because it's ours and we checked it fits */

	/* Now we own all skb's marked in progress, new requests may arrive

	 * at the end of the queue.

/* If wait timed out but the command is already in progress we have

 * to wait until it finishes.  Runners has ownership of the skbs marked

 * as busy.

 pairs with smp_wmb() after data is written */

	/* If the reply size is unknown assume it will take the entire

	 * mailbox, the callers should do their best for this to never

	 * happen.

	/* Make sure we can fit the entire reply into the skb,

	 * and that we don't have to slow down the mbox handler

	 * with allocations.

 Make sure that request and response both fit into the mailbox */

 First in queue takes the mailbox lock and processes the batch */

 fast path for those completed by another thread */

 pairs with wmb after data is written */

 run queue expects the lock held */

 Should never happen so it's unclear what to do here.. */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2018 Netronome Systems, Inc. */

	/* Limit the frequency of updates - stats of non-leaf qdiscs are a sum

	 * of all their leafs, so we would read the same stat multiple times

	 * for every dump.

 Don't complain when qdisc is getting unlinked */

	/* Don't touch the backlog, backlog can only be reset after it has

	 * been reported back to the tc qdisc stats.

 If we are starting offload init prev_stats */

 Mark all thresholds as unconfigured */

 Clear offload marks */

 Refresh offload status */

 Reset the unconfigured thresholds */

	/* MQ doesn't notify well on destruction, we need special handling of

	 * MQ's children.

 Count refs held by MQ instances and clear pointers */

 We don't get TC_SETUP_ROOT_QDISC w/ MQ when netdev is unregistered */

		/* Only root change matters, other changes are acted upon on

		 * the graft notification.

	/* If the qdisc offload has stopped we may need to adjust the backlog

	 * counters back so carry on even if qdisc is not currently offloaded.

	/* If the qdisc offload has stopped we may need to adjust the backlog

	 * counters back so carry on even if qdisc is not currently offloaded.

 If limit != 0 child gets reset */

		/* Qdisc was just allocated without a limit will use noop_qdisc,

		 * i.e. a block hole.

	/* MQ stats are summed over the children in the core, so we need

	 * to add up the unreported child values.

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2018 Netronome Systems, Inc. */

/* This filter list -> map conversion is O(n * m), we expect single digit or

 * low double digit number of prios and likewise for the filters.  Also u32

 * doesn't report stats, so it's really only setup time cost.

 FW mask applies from top bits */

 Qdisc offload status may change if has_prio changed */

 Extract the DSCP Class Selector bits */

 Check if there is no conflicting mapping and find match by handle */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2018 Netronome Systems, Inc. */

 Write data_len and wipe reserved */

 Check if Qdisc offloads are supported */

 Read count of prios and prio bands */

 Read available actions */

 Check values are sane, U16_MAX is arbitrarily chosen as max */

 Find level and stat symbols */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2018 Netronome Systems, Inc. */

 Cast to make sure nfp_repr_clean_and_free() takes a nfp_repr */

	/* This is a multi-host app, make sure MAC/PHY is up, but don't

	 * make the MAC/PHY state follow the state of any of the ports.

 We start in legacy mode, make sure advanced queuing is disabled */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2015-2018 Netronome Systems, Inc. */

 If you need more than 65536 recursive locks, please rethink your code. */

 Not permitted on invalid interfaces */

 Address must be 64-bit aligned */

/**

 * nfp_cpp_mutex_init() - Initialize a mutex location

 * @cpp:	NFP CPP handle

 * @target:	NFP CPP target ID (ie NFP_CPP_TARGET_CLS or NFP_CPP_TARGET_MU)

 * @address:	Offset into the address space of the NFP CPP target ID

 * @key:	Unique 32-bit value for this mutex

 *

 * The CPP target:address must point to a 64-bit aligned location, and

 * will initialize 64 bits of data at the location.

 *

 * This creates the initial mutex state, as locked by this

 * nfp_cpp_interface().

 *

 * This function should only be called when setting up

 * the initial lock state upon boot-up of the system.

 *

 * Return: 0 on success, or -errno on failure

 atomic_write */

/**

 * nfp_cpp_mutex_alloc() - Create a mutex handle

 * @cpp:	NFP CPP handle

 * @target:	NFP CPP target ID (ie NFP_CPP_TARGET_CLS or NFP_CPP_TARGET_MU)

 * @address:	Offset into the address space of the NFP CPP target ID

 * @key:	32-bit unique key (must match the key at this location)

 *

 * The CPP target:address must point to a 64-bit aligned location, and

 * reserve 64 bits of data at the location for use by the handle.

 *

 * Only target/address pairs that point to entities that support the

 * MU Atomic Engine's CmpAndSwap32 command are supported.

 *

 * Return:	A non-NULL struct nfp_cpp_mutex * on success, NULL on failure.

 atomic_read */

/**

 * nfp_cpp_mutex_free() - Free a mutex handle - does not alter the lock state

 * @mutex:	NFP CPP Mutex handle

/**

 * nfp_cpp_mutex_lock() - Lock a mutex handle, using the NFP MU Atomic Engine

 * @mutex:	NFP CPP Mutex handle

 *

 * Return: 0 on success, or -errno on failure

	/* We can't use a waitqueue here, because the unlocker

	 * might be on a separate CPU.

	 *

	 * So just wait for now.

/**

 * nfp_cpp_mutex_unlock() - Unlock a mutex handle, using the MU Atomic Engine

 * @mutex:	NFP CPP Mutex handle

 *

 * Return: 0 on success, or -errno on failure

 atomic_write */

 atomic_read */

/**

 * nfp_cpp_mutex_trylock() - Attempt to lock a mutex handle

 * @mutex:	NFP CPP Mutex handle

 *

 * Return:      0 if the lock succeeded, -errno on failure

 atomic_write */

 test_set_imm */

 atomic_read */

 Verify that the lock marker is not damaged */

	/* Compare against the unlocked state, and if true,

	 * write the interface id into the top 16 bits, and

	 * mark as locked.

	/* We use test_set_imm here, as it implies a read

	 * of the current state, and sets the bits in the

	 * bytemask of the command to 1s. Since the mutex

	 * is guaranteed to be 64-bit aligned, the bytemask

	 * of this 32-bit command is ensured to be 8'b00001111,

	 * which implies that the lower 4 bits will be set to

	 * ones regardless of the initial state.

	 *

	 * Since this is a 'Readback' operation, with no Pull

	 * data, we can treat this as a normal Push (read)

	 * atomic, which returns the original value.

 Was it unlocked? */

		/* The read value can only be 0x....0000 in the unlocked state.

		 * If there was another contending for this lock, then

		 * the lock state would be 0x....000f

		/* Write our owner ID into the lock

		 * While not strictly necessary, this helps with

		 * debug and bookkeeping.

/**

 * nfp_cpp_mutex_reclaim() - Unlock mutex if held by local endpoint

 * @cpp:	NFP CPP handle

 * @target:	NFP CPP target ID (ie NFP_CPP_TARGET_CLS or NFP_CPP_TARGET_MU)

 * @address:	Offset into the address space of the NFP CPP target ID

 *

 * Release lock if held by local system.  Extreme care is advised, call only

 * when no local lock users can exist.

 *

 * Return:      0 if the lock was OK, 1 if locked by us, -errno on invalid mutex

 atomic_read */

 atomic_write */

 Check lock */

 Bust the lock */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2015-2018 Netronome Systems, Inc. */

/*

 * nfp_nffw.c

 * Authors: Jakub Kicinski <jakub.kicinski@netronome.com>

 *          Jason McMullan <jason.mcmullan@netronome.com>

 *          Francois H. Theron <francois.theron@netronome.com>

/* Init-CSR owner IDs for firmware map to firmware IDs which start at 4.

 * Lower IDs are reserved for target and loader IDs.

 For active MEs that we didn't load. */

/*

 * NFFW_INFO_VERSION history:

 * 0: This was never actually used (before versioning), but it refers to

 *    the previous struct which had FWINFO_CNT = MEINFO_CNT = 120 that later

 *    changed to 200.

 * 1: First versioned struct, with

 *     FWINFO_CNT = 120

 *     MEINFO_CNT = 120

 * 2:  FWINFO_CNT = 200

 *     MEINFO_CNT = 200

 Enough for all current chip families */

 Work in 32-bit words to make cross-platform endianness easier to handle */

* nfp.nffw meinfo **/

 0 means no MIP */

* Resource: nfp.nffw main **/

/* flg_info_version = flags[0]<27:16>

 * This is a small version counter intended only to detect if the current

 * implementation can read the current struct. Struct changes should be very

 * rare and as such a 12-bit counter should cover large spans of time. By the

 * time it wraps around, we don't expect to have 4096 versions of this struct

 * to be in use at the same time.

 flg_init = flags[0]<0> */

 loaded = loaded__mu_da__mip_off_hi<31:31> */

 mip_cppid = mip_cppid */

 loaded = loaded__mu_da__mip_off_hi<8:8> */

 mip_offset = (loaded__mu_da__mip_off_hi<7:0> << 8) | mip_offset_lo */

	/* For the this code, version 0 is most likely to be

	 * version 1 in this case. Since the kernel driver

	 * does not take responsibility for initialising the

	 * nfp.nffw resource, any previous code (CA firmware or

	 * userspace) that left the version 0 and did set

	 * the init flag is going to be version 1.

/**

 * nfp_nffw_info_open() - Acquire the lock on the NFFW table

 * @cpp:	NFP CPP handle

 *

 * Return: pointer to nfp_nffw_info object or ERR_PTR()

/**

 * nfp_nffw_info_close() - Release the lock on the NFFW table and free state

 * @state:	NFP FW info state

/**

 * nfp_nffw_info_fwid_first() - Return the first firmware ID in the NFFW

 * @state:	NFP FW info state

 *

 * Return: First NFFW firmware info, NULL on failure

/**

 * nfp_nffw_info_mip_first() - Retrieve the location of the first FW's MIP

 * @state:	NFP FW info state

 * @cpp_id:	Pointer to the CPP ID of the MIP

 * @off:	Pointer to the CPP Address of the MIP

 *

 * Return: 0, or -ERRNO

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2015-2017 Netronome Systems, Inc. */

/* Parse the hwinfo table that the ARM firmware builds in the ARM scratch SRAM

 * after chip reset.

 *

 * Examples of the fields:

 *   me.count = 40

 *   me.mask = 0x7f_ffff_ffff

 *

 *   me.count is the total number of MEs on the system.

 *   me.mask is the bitmask of MEs that are available for application usage.

 *

 *   (ie, in this example, ME 39 has been reserved by boardconfig.)

 seconds */

/* The Hardware Info Table defines the properties of the system.

 *

 * HWInfo v1 Table (fixed size)

 *

 * 0x0000: u32 version	        Hardware Info Table version (1.0)

 * 0x0004: u32 size	        Total size of the table, including

 *			        the CRC32 (IEEE 802.3)

 * 0x0008: u32 jumptab	        Offset of key/value table

 * 0x000c: u32 keys	        Total number of keys in the key/value table

 * NNNNNN:		        Key/value jump table and string data

 * (size - 4): u32 crc32	CRC32 (same as IEEE 802.3, POSIX csum, etc)

 *				CRC32("",0) = ~0, CRC32("a",1) = 0x48C279FE

 *

 * HWInfo v2 Table (variable size)

 *

 * 0x0000: u32 version	        Hardware Info Table version (2.0)

 * 0x0004: u32 size	        Current size of the data area, excluding CRC32

 * 0x0008: u32 limit	        Maximum size of the table

 * 0x000c: u32 reserved	        Unused, set to zero

 * NNNNNN:			Key/value data

 * (size - 4): u32 crc32	CRC32 (same as IEEE 802.3, POSIX csum, etc)

 *				CRC32("",0) = ~0, CRC32("a",1) = 0x48C279FE

 *

 * If the HWInfo table is in the process of being updated, the low bit

 * of version will be set.

 *

 * HWInfo v1 Key/Value Table

 * -------------------------

 *

 *  The key/value table is a set of offsets to ASCIIZ strings which have

 *  been strcmp(3) sorted (yes, please use bsearch(3) on the table).

 *

 *  All keys are guaranteed to be unique.

 *

 * N+0:	u32 key_1		Offset to the first key

 * N+4:	u32 val_1		Offset to the first value

 * N+8: u32 key_2		Offset to the second key

 * N+c: u32 val_2		Offset to the second value

 * ...

 *

 * HWInfo v2 Key/Value Table

 * -------------------------

 *

 * Packed UTF8Z strings, ie 'key1\000value1\000key2\000value2\000'

 *

 * Unsorted.

 v2 specific fields */

 Try getting the HWInfo table from the 'classic' location */

 NULL-terminate for safety */

/**

 * nfp_hwinfo_lookup() - Find a value in the HWInfo table by name

 * @hwinfo:	NFP HWinfo table

 * @lookup:	HWInfo name to search for

 *

 * Return: Value of the HWInfo name, or NULL

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2017 Netronome Systems, Inc. */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2015-2017 Netronome Systems, Inc. */

/* Authors: David Brunecz <david.brunecz@netronome.com>

 *          Jakub Kicinski <jakub.kicinski@netronome.com>

 *          Jason Mcmullan <jason.mcmullan@netronome.com>

/**

 * nfp_eth_read_ports() - retrieve port information

 * @cpp:	NFP CPP handle

 *

 * Read the port information from the device.  Returned structure should

 * be freed with kfree() once no longer needed.

 *

 * Return: populated ETH table or NULL on error.

	/* Some versions of flash will give us 0 instead of port count.

	 * For those that give a port count, verify it against the value

	 * calculated above.

/**

 * nfp_eth_config_commit_end() - perform recorded configuration changes

 * @nsp:	NFP NSP handle returned from nfp_eth_config_start()

 *

 * Perform the configuration which was requested with __nfp_eth_set_*()

 * helpers and recorded in @nsp state.  If device was already configured

 * as requested or no __nfp_eth_set_*() operations were made no NSP command

 * will be performed.

 *

 * Return:

 * 0 - configuration successful;

 * 1 - no changes were needed;

 * -ERRNO - configuration failed.

/**

 * nfp_eth_set_mod_enable() - set PHY module enable control bit

 * @cpp:	NFP CPP handle

 * @idx:	NFP chip-wide port index

 * @enable:	Desired state

 *

 * Enable or disable PHY module (this usually means setting the TX lanes

 * disable bits).

 *

 * Return:

 * 0 - configuration successful;

 * 1 - no changes were needed;

 * -ERRNO - configuration failed.

 Check if we are already in requested state */

/**

 * nfp_eth_set_configured() - set PHY module configured control bit

 * @cpp:	NFP CPP handle

 * @idx:	NFP chip-wide port index

 * @configed:	Desired state

 *

 * Set the ifup/ifdown state on the PHY.

 *

 * Return:

 * 0 - configuration successful;

 * 1 - no changes were needed;

 * -ERRNO - configuration failed.

	/* Older ABI versions did support this feature, however this has only

	 * been reliable since ABI 20.

 Check if we are already in requested state */

	/* Note: set features were added in ABI 0.14 but the error

	 *	 codes were initially not populated correctly.

 Check if we are already in requested state */

/**

 * __nfp_eth_set_aneg() - set PHY autonegotiation control bit

 * @nsp:	NFP NSP handle returned from nfp_eth_config_start()

 * @mode:	Desired autonegotiation mode

 *

 * Allow/disallow PHY module to advertise/perform autonegotiation.

 * Will write to hwinfo overrides in the flash (persistent config).

 *

 * Return: 0 or -ERRNO.

/**

 * __nfp_eth_set_fec() - set PHY forward error correction control bit

 * @nsp:	NFP NSP handle returned from nfp_eth_config_start()

 * @mode:	Desired fec mode

 *

 * Set the PHY module forward error correction mode.

 * Will write to hwinfo overrides in the flash (persistent config).

 *

 * Return: 0 or -ERRNO.

/**

 * nfp_eth_set_fec() - set PHY forward error correction control mode

 * @cpp:	NFP CPP handle

 * @idx:	NFP chip-wide port index

 * @mode:	Desired fec mode

 *

 * Return:

 * 0 - configuration successful;

 * 1 - no changes were needed;

 * -ERRNO - configuration failed.

/**

 * __nfp_eth_set_speed() - set interface speed/rate

 * @nsp:	NFP NSP handle returned from nfp_eth_config_start()

 * @speed:	Desired speed (per lane)

 *

 * Set lane speed.  Provided @speed value should be subport speed divided

 * by number of lanes this subport is spanning (i.e. 10000 for 40G, 25000 for

 * 50G, etc.)

 * Will write to hwinfo overrides in the flash (persistent config).

 *

 * Return: 0 or -ERRNO.

/**

 * __nfp_eth_set_split() - set interface lane split

 * @nsp:	NFP NSP handle returned from nfp_eth_config_start()

 * @lanes:	Desired lanes per port

 *

 * Set number of lanes in the port.

 * Will write to hwinfo overrides in the flash (persistent config).

 *

 * Return: 0 or -ERRNO.

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2015-2018 Netronome Systems, Inc. */

/*

 * nfp_resource.c

 * Author: Jakub Kicinski <jakub.kicinski@netronome.com>

 *         Jason McMullan <jason.mcmullan@netronome.com>

 NFP Resource Table self-identifier */

 Special key for entry 0 */

/**

 * struct nfp_resource_entry - Resource table entry

 * @mutex:	NFP CPP Lock

 * @mutex.owner:	NFP CPP Lock, interface owner

 * @mutex.key:		NFP CPP Lock, posix_crc32(name, 8)

 * @region:	Memory region descriptor

 * @region.name:	ASCII, zero padded name

 * @region.reserved:	padding

 * @region.cpp_action:	CPP Action

 * @region.cpp_token:	CPP Token

 * @region.cpp_target:	CPP Target ID

 * @region.page_offset:	256-byte page offset into target's CPP address

 * @region.page_size:	size, in 256-byte pages

 Atomic read */

 Search for a matching entry */

 Found key! */

/**

 * nfp_resource_acquire() - Acquire a resource handle

 * @cpp:	NFP CPP handle

 * @name:	Name of the resource

 *

 * NOTE: This function locks the acquired resource

 *

 * Return: NFP Resource handle, or ERR_PTR()

/**

 * nfp_resource_release() - Release a NFP Resource handle

 * @res:	NFP Resource handle

 *

 * NOTE: This function implictly unlocks the resource handle

/**

 * nfp_resource_wait() - Wait for resource to appear

 * @cpp:	NFP CPP handle

 * @name:	Name of the resource

 * @secs:	Number of seconds to wait

 *

 * Wait for resource to appear in the resource table, grab and release

 * its lock.  The wait is jiffies-based, don't expect fine granularity.

 *

 * Return: 0 on success, errno otherwise.

/**

 * nfp_resource_cpp_id() - Return the cpp_id of a resource handle

 * @res:	NFP Resource handle

 *

 * Return: NFP CPP ID

/**

 * nfp_resource_name() - Return the name of a resource handle

 * @res:	NFP Resource handle

 *

 * Return: const char pointer to the name of the resource

/**

 * nfp_resource_address() - Return the address of a resource handle

 * @res:	NFP Resource handle

 *

 * Return: Address of the resource

/**

 * nfp_resource_size() - Return the size in bytes of a resource handle

 * @res:	NFP Resource handle

 *

 * Return: Size of the resource in bytes

/**

 * nfp_resource_table_init() - Run initial checks on the resource table

 * @cpp:	NFP CPP handle

 *

 * Start-of-day init procedure for resource table.  Must be called before

 * any local resource table users may exist.

 *

 * Return: 0 on success, -errno on failure

 Resource 0 is the dev_mutex, start from 1 */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2015-2018 Netronome Systems, Inc. */

/*

 * nfp_rtsym.c

 * Interface for accessing run-time symbol table

 * Authors: Jakub Kicinski <jakub.kicinski@netronome.com>

 *          Jason McMullan <jason.mcmullan@netronome.com>

 *          Espen Skoglund <espen.skoglund@netronome.com>

 *          Francois H. Theron <francois.theron@netronome.com>

 These need to match the linker */

 Align to 64 bits */

/**

 * nfp_rtsym_count() - Get the number of RTSYM descriptors

 * @rtbl:	NFP RTsym table

 *

 * Return: Number of RTSYM descriptors

/**

 * nfp_rtsym_get() - Get the Nth RTSYM descriptor

 * @rtbl:	NFP RTsym table

 * @idx:	Index (0-based) of the RTSYM descriptor

 *

 * Return: const pointer to a struct nfp_rtsym descriptor, or NULL

/**

 * nfp_rtsym_lookup() - Return the RTSYM descriptor for a symbol name

 * @rtbl:	NFP RTsym table

 * @name:	Symbol name

 *

 * Return: const pointer to a struct nfp_rtsym descriptor, or NULL

/**

 * nfp_rtsym_read_le() - Read a simple unsigned scalar value from symbol

 * @rtbl:	NFP RTsym table

 * @name:	Symbol name

 * @error:	Poniter to error code (optional)

 *

 * Lookup a symbol, map, read it and return it's value. Value of the symbol

 * will be interpreted as a simple little-endian unsigned value. Symbol can

 * be 4 or 8 bytes in size.

 *

 * Return: value read, on error sets the error and returns ~0ULL.

/**

 * nfp_rtsym_write_le() - Write an unsigned scalar value to a symbol

 * @rtbl:	NFP RTsym table

 * @name:	Symbol name

 * @value:	Value to write

 *

 * Lookup a symbol and write a value to it. Symbol can be 4 or 8 bytes in size.

 * If 4 bytes then the lower 32-bits of 'value' are used. Value will be

 * written as simple little-endian unsigned value.

 *

 * Return: 0 on success or error code.

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2015-2018 Netronome Systems, Inc. */

/*

 * nfp6000_pcie.c

 * Authors: Jakub Kicinski <jakub.kicinski@netronome.com>

 *          Jason McMullan <jason.mcmullan@netronome.com>

 *          Rolf Neugebauer <rolf.neugebauer@netronome.com>

 *

 * Multiplexes the NFP BARs between NFP internal resources and

 * implements the PCIe specific interface for generic CPP bus access.

 *

 * The BARs are managed with refcounts and are allocated/acquired

 * using target, token and offset/size matching.  The generic CPP bus

 * abstraction builds upon this BAR interface.

/* Minimal size of the PCIe cfg memory we depend on being mapped,

 * queue controller and DMA controller don't have to be covered.

/* The number of explicit BARs to reserve.

 * Minimum is 0, maximum is 4 on the NFP6000.

 * The NFP3800 can have only one per PF.

/**

 * struct nfp_bar - describes BAR configuration and usage

 * @nfp:	backlink to owner

 * @barcfg:	cached contents of BAR config CSR

 * @base:	the BAR's base CPP offset

 * @mask:       mask for the BAR aperture (read only)

 * @bitsize:	bitsize of BAR aperture (read only)

 * @index:	index of the BAR

 * @refcnt:	number of current users

 * @iomem:	mapped IO memory

 * @resource:	iomem resource window

 CPP address base */

 Bit mask of the bar */

 Bit size of the bar */

 PCI BAR management */

 Protect the PCI2CPP BAR cache */

 Reserved BAR access */

 Explicit IO access */

 Lock access to this explicit group */

 Fixed CPP mapping with specific action */

 Bulk mapping */

 Readback to ensure BAR is flushed */

 Check if BAR can be used with the given parameters. */

 We don't match explicit bars through the area interface */

 Make sure to match up the width */

 No match */

 Return EAGAIN if no resource is available */

 Just check to see if we can make it fit... */

 Found a perfect match. */

		/* Wait until a BAR becomes available.  The

		 * find_unused_bar function will reclaim the bar_lock

		 * if a free BAR is found.

/* Map all PCI bars and fetch the actual BAR configurations from the

 * board.  We assume that the BAR with the PCIe config block is

 * already mapped.

 *

 * BAR0.0: Reserved for General Mapping (for MSI-X access to PCIe SRAM)

 * BAR0.1: Reserved for XPB access (for MSI-X access to PCIe PBA)

 * BAR0.2: --

 * BAR0.3: --

 * BAR0.4: Reserved for Explicit 0.0-0.3 access

 * BAR0.5: Reserved for Explicit 1.0-1.3 access

 * BAR0.6: Reserved for Explicit 2.0-2.3 access

 * BAR0.7: Reserved for Explicit 3.0-3.3 access

 *

 * BAR1.0-BAR1.7: --

 * BAR2.0-BAR2.7: --

 Skip over BARs that are not IORESOURCE_MEM */

	/* Convert unit ID (0..3) to signal master/data master ID (0x40..0x70)

 Configure, and lock, BAR0.0 for General Target use (MSI-X SRAM) */

 Configure, and lock, BAR0.1 for PCIe XPB (MSI-X PBA) */

 Use BAR0.4..BAR0.7 for EXPL IO */

 Sort bars by bit size - use the smallest possible first. */

/*

 * Generic CPP bus access interface.

 Already allocated. */

 Calculate offset into BAR. */

	/* We don't actually try to acquire the resource area using

	 * request_resource.  This would prevent sharing the mapped

	 * BAR between multiple CPP areas and prevent us from

	 * effectively utilizing the limited amount of BAR resources.

 If the bar is already mapped in, use its mapping */

 Must have been too big. Sub-allocate. */

	/* Use the BAR resource as the resource for the CPP area.

	 * This enables us to share the BAR among multiple CPP areas

	 * without resource conflicts.

 MU reads via a PCIe2CPP BAR support 32bit (and other) lengths */

 Unaligned? Translate to an explicit access */

 MU writes via a PCIe2CPP BAR support 32bit (and other) lengths */

 Unaligned? Translate to an explicit access */

 Readback to ensure BAR is flushed */

 Issue the 'kickoff' transaction */

/**

 * nfp_cpp_from_nfp6000_pcie() - Build a NFP CPP bus from a NFP6000 PCI device

 * @pdev:	NFP6000 PCI device

 *

 * Return: NFP CPP handle

  Finished with card initialization. */

 Probe for all the common NFP devices */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2015-2018 Netronome Systems, Inc. */

/*

 * nfp_nsp.c

 * Author: Jakub Kicinski <jakub.kicinski@netronome.com>

 *         Jason McMullan <jason.mcmullan@netronome.com>

 Offsets relative to the CSR base */

 CPP address to retrieve the data from */

 No operation */

 Soft reset the NFP */

 Load default (UNDI) FW */

 Initialize the PHY */

 Initialize the MAC */

 Re-run PHY RX Adaptation */

 Load fw from buffer, len in option */

 Rescan ETHs, write ETH_TABLE to buf */

 Update media config from buffer */

 Load and flash image from buffer */

 Read NSP sensor(s) */

 Read NSP version */

 If no FW loaded, load flash app FW */

 Lookup HWinfo with overwrites etc. */

 Set HWinfo entry */

 Is application firmware loaded */

 Report FW versions */

 Read module EEPROM */

 Eth table config state */

/**

 * struct nfp_nsp_command_arg - NFP command argument structure

 * @code:	NFP SP Command Code

 * @dma:	@buf points to a host buffer, not NSP buffer

 * @timeout_sec:Timeout value to wait for completion in seconds

 * @option:	NFP SP Command Argument

 * @buf:	NFP SP Buffer Address

 * @error_cb:	Callback for interpreting option if error occurred

 * @error_quiet:Don't print command error/warning. Protocol errors are still

 *		    logged.

/**

 * struct nfp_nsp_command_buf_arg - NFP command with buffer argument structure

 * @arg:	NFP command argument structure

 * @in_buf:	Buffer with data for input

 * @in_size:	Size of @in_buf

 * @out_buf:	Buffer for output data

 * @out_size:	Size of @out_buf

/**

 * nfp_nsp_open() - Prepare for communication and lock the NSP resource.

 * @cpp:	NFP CPP Handle

/**

 * nfp_nsp_close() - Clean up and unlock the NSP resource.

 * @state:	NFP SP state

/**

 * __nfp_nsp_command() - Execute a command on the NFP Service Processor

 * @state:	NFP SP state

 * @arg:	NFP command argument structure

 *

 * Return: 0 for success with no result

 *

 *	 positive value for NSP completion with a result code

 *

 *	-EAGAIN if the NSP is not yet present

 *	-ENODEV if the NSP is not a supported model

 *	-EBUSY if the NSP is stuck

 *	-EINTR if interrupted while waiting for completion

 *	-ETIMEDOUT if the NSP took longer than @timeout_sec seconds to complete

 Wait for NSP_COMMAND_START to go to 0 */

 Wait for NSP_STATUS_BUSY to go to 0 */

 Zero out remaining part of the buffer */

 Zero out undefined part of the out buffer */

 0 */ "Firmware from driver loaded",

 1 */ "Firmware from flash loaded",

 2 */ "Firmware loading failure",

  0 */ "",

  1 */ "no named partition on flash",

  2 */ "error reading from flash",

  3 */ "can not deflate",

  4 */ "not a trusted file",

  5 */ "can not parse FW file",

  6 */ "MIP not found in FW file",

  7 */ "null firmware name in MIP",

  8 */ "FW version none",

  9 */ "FW build number none",

 10 */ "no FW selection policy HWInfo key found",

 11 */ "static FW selection policy",

 12 */ "FW version has precedence",

 13 */ "different FW application load requested",

 14 */ "development build",

 Lower the message level in legacy case */

	/* Ensure that the default value is usable irrespective of whether

	 * it is actually going to be used.

 Buffer must be large enough and rounded to the next block size. */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2015-2018 Netronome Systems, Inc. */

/*

 * nfp_cpplib.c

 * Library of functions to access the NFP's CPP bus

 * Authors: Jakub Kicinski <jakub.kicinski@netronome.com>

 *          Jason McMullan <jason.mcmullan@netronome.com>

 *          Rolf Neugebauer <rolf.neugebauer@netronome.com>

 NFP6000 PL */

/**

 * nfp_cpp_readl() - Read a u32 word from a CPP location

 * @cpp:	CPP device handle

 * @cpp_id:	CPP ID for operation

 * @address:	Address for operation

 * @value:	Pointer to read buffer

 *

 * Return: 0 on success, or -ERRNO

/**

 * nfp_cpp_writel() - Write a u32 word to a CPP location

 * @cpp:	CPP device handle

 * @cpp_id:	CPP ID for operation

 * @address:	Address for operation

 * @value:	Value to write

 *

 * Return: 0 on success, or -ERRNO

/**

 * nfp_cpp_readq() - Read a u64 word from a CPP location

 * @cpp:	CPP device handle

 * @cpp_id:	CPP ID for operation

 * @address:	Address for operation

 * @value:	Pointer to read buffer

 *

 * Return: 0 on success, or -ERRNO

/**

 * nfp_cpp_writeq() - Write a u64 word to a CPP location

 * @cpp:	CPP device handle

 * @cpp_id:	CPP ID for operation

 * @address:	Address for operation

 * @value:	Value to write

 *

 * Return: 0 on success, or -ERRNO

/* NOTE: This code should not use nfp_xpb_* functions,

 * as those are model-specific

 Translate a NFP_CPP_ACTION_RW to action 0 */

 Translate a NFP_CPP_ACTION_RW to action 1 */

/**

 * nfp_cpp_map_area() - Helper function to map an area

 * @cpp:    NFP CPP handler

 * @name:   Name for the area

 * @cpp_id: CPP ID for operation

 * @addr:   CPP address

 * @size:   Size of the area

 * @area:   Area handle (output)

 *

 * Map an area of IOMEM access.  To undo the effect of this function call

 * @nfp_cpp_area_release_free(*area).

 *

 * Return: Pointer to memory mapped area or ERR_PTR

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2015-2017 Netronome Systems, Inc. */

/*

 * nfp_mip.c

 * Authors: Jakub Kicinski <jakub.kicinski@netronome.com>

 *          Jason McMullan <jason.mcmullan@netronome.com>

 *          Espen Skoglund <espen.skoglund@netronome.com>

 "MIP\0" */

 Read memory and check if it could be a valid MIP */

 Try to locate MIP using the resource table */

/**

 * nfp_mip_open() - Get device MIP structure

 * @cpp:	NFP CPP Handle

 *

 * Copy MIP structure from NFP device and return it.  The returned

 * structure is handled internally by the library and should be

 * freed by calling nfp_mip_close().

 *

 * Return: pointer to mip, NULL on failure.

/**

 * nfp_mip_symtab() - Get the address and size of the MIP symbol table

 * @mip:	MIP handle

 * @addr:	Location for NFP DDR address of MIP symbol table

 * @size:	Location for size of MIP symbol table

/**

 * nfp_mip_strtab() - Get the address and size of the MIP symbol name table

 * @mip:	MIP handle

 * @addr:	Location for NFP DDR address of MIP symbol name table

 * @size:	Location for size of MIP symbol name table

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2015-2018 Netronome Systems, Inc. */

/*

 * nfp_cppcore.c

 * Provides low-level access to the NFP's internal CPP bus

 * Authors: Jakub Kicinski <jakub.kicinski@netronome.com>

 *          Jason McMullan <jason.mcmullan@netronome.com>

 *          Rolf Neugebauer <rolf.neugebauer@netronome.com>

/**

 * struct nfp_cpp - main nfpcore device structure

 * Following fields are read-only after probe() exits or netdevs are spawned.

 * @dev:		embedded device structure

 * @op:			low-level implementation ops

 * @priv:		private data of the low-level implementation

 * @model:		chip model

 * @interface:		chip interface id we are using to reach it

 * @serial:		chip serial number

 * @imb_cat_table:	CPP Mapping Table

 * @mu_locality_lsb:	MU access type bit offset

 *

 * Following fields use explicit locking:

 * @resource_list:	NFP CPP resource list

 * @resource_lock:	protects @resource_list

 *

 * @area_cache_list:	cached areas for cpp/xpb read/write speed up

 * @area_cache_mutex:	protects @area_cache_list

 *

 * @waitq:		area wait queue

 Element of the area_cache_list */

 Lock for the area's refcount */

 Here follows the 'priv' part of nfp_cpp_area. */

 Here follows the 'priv' part of nfp_cpp_area. */

/**

 * nfp_cpp_free() - free the CPP handle

 * @cpp:	CPP handle

 Remove all caches */

 There should be no dangling areas at this point */

 .. but if they weren't, try to clean up. */

/**

 * nfp_cpp_model() - Retrieve the Model ID of the NFP

 * @cpp:	NFP CPP handle

 *

 * Return: NFP CPP Model ID

/**

 * nfp_cpp_interface() - Retrieve the Interface ID of the NFP

 * @cpp:	NFP CPP handle

 *

 * Return: NFP CPP Interface ID

/**

 * nfp_cpp_serial() - Retrieve the Serial ID of the NFP

 * @cpp:	NFP CPP handle

 * @serial:	Pointer to NFP serial number

 *

 * Return:  Length of NFP serial number

/**

 * nfp_cpp_area_alloc_with_name() - allocate a new CPP area

 * @cpp:	CPP device handle

 * @dest:	NFP CPP ID

 * @name:	Name of region

 * @address:	Address of region

 * @size:	Size of region

 *

 * Allocate and initialize a CPP area structure.  The area must later

 * be locked down with an 'acquire' before it can be safely accessed.

 *

 * NOTE: @address and @size must be 32-bit aligned values.

 *

 * Return: NFP CPP area handle, or NULL

 Remap from cpp_island to cpp_target */

/**

 * nfp_cpp_area_alloc() - allocate a new CPP area

 * @cpp:	CPP handle

 * @dest:	CPP id

 * @address:	Start address on CPP target

 * @size:	Size of area in bytes

 *

 * Allocate and initialize a CPP area structure.  The area must later

 * be locked down with an 'acquire' before it can be safely accessed.

 *

 * NOTE: @address and @size must be 32-bit aligned values.

 *

 * Return: NFP CPP Area handle, or NULL

/**

 * nfp_cpp_area_alloc_acquire() - allocate a new CPP area and lock it down

 * @cpp:	CPP handle

 * @name:	Name of region

 * @dest:	CPP id

 * @address:	Start address on CPP target

 * @size:	Size of area

 *

 * Allocate and initialize a CPP area structure, and lock it down so

 * that it can be accessed directly.

 *

 * NOTE: @address and @size must be 32-bit aligned values.

 * The area must also be 'released' when the structure is freed.

 *

 * Return: NFP CPP Area handle, or NULL

/**

 * nfp_cpp_area_free() - free up the CPP area

 * @area:	CPP area handle

 *

 * Frees up memory resources held by the CPP area.

/**

 * nfp_cpp_area_acquire() - lock down a CPP area for access

 * @area:	CPP area handle

 *

 * Locks down the CPP area for a potential long term activity.  Area

 * must always be locked down before being accessed.

 *

 * Return: 0, or -ERRNO

/**

 * nfp_cpp_area_acquire_nonblocking() - lock down a CPP area for access

 * @area:	CPP area handle

 *

 * Locks down the CPP area for a potential long term activity.  Area

 * must always be locked down before being accessed.

 *

 * NOTE: Returns -EAGAIN is no area is available

 *

 * Return: 0, or -ERRNO

/**

 * nfp_cpp_area_release() - release a locked down CPP area

 * @area:	CPP area handle

 *

 * Releases a previously locked down CPP area.

 Only call the release on refcount == 0 */

 Let anyone waiting for a BAR try to get one.. */

/**

 * nfp_cpp_area_release_free() - release CPP area and free it

 * @area:	CPP area handle

 *

 * Releases CPP area and frees up memory resources held by the it.

/**

 * nfp_cpp_area_read() - read data from CPP area

 * @area:	  CPP area handle

 * @offset:	  offset into CPP area

 * @kernel_vaddr: kernel address to put data into

 * @length:	  number of bytes to read

 *

 * Read data from indicated CPP region.

 *

 * NOTE: @offset and @length must be 32-bit aligned values.

 * Area must have been locked down with an 'acquire'.

 *

 * Return: length of io, or -ERRNO

/**

 * nfp_cpp_area_write() - write data to CPP area

 * @area:	CPP area handle

 * @offset:	offset into CPP area

 * @kernel_vaddr: kernel address to read data from

 * @length:	number of bytes to write

 *

 * Write data to indicated CPP region.

 *

 * NOTE: @offset and @length must be 32-bit aligned values.

 * Area must have been locked down with an 'acquire'.

 *

 * Return: length of io, or -ERRNO

/**

 * nfp_cpp_area_size() - return size of a CPP area

 * @cpp_area:	CPP area handle

 *

 * Return: Size of the area

/**

 * nfp_cpp_area_name() - return name of a CPP area

 * @cpp_area:	CPP area handle

 *

 * Return: Name of the area, or NULL

/**

 * nfp_cpp_area_priv() - return private struct for CPP area

 * @cpp_area:	CPP area handle

 *

 * Return: Private data for the CPP area

/**

 * nfp_cpp_area_cpp() - return CPP handle for CPP area

 * @cpp_area:	CPP area handle

 *

 * Return: NFP CPP handle

/**

 * nfp_cpp_area_resource() - get resource

 * @area:	CPP area handle

 *

 * NOTE: Area must have been locked down with an 'acquire'.

 *

 * Return: struct resource pointer, or NULL

/**

 * nfp_cpp_area_phys() - get physical address of CPP area

 * @area:	CPP area handle

 *

 * NOTE: Area must have been locked down with an 'acquire'.

 *

 * Return: phy_addr_t of the area, or NULL

/**

 * nfp_cpp_area_iomem() - get IOMEM region for CPP area

 * @area:	CPP area handle

 *

 * Returns an iomem pointer for use with readl()/writel() style

 * operations.

 *

 * NOTE: Area must have been locked down with an 'acquire'.

 *

 * Return: __iomem pointer to the area, or NULL

/**

 * nfp_cpp_area_readl() - Read a u32 word from an area

 * @area:	CPP Area handle

 * @offset:	Offset into area

 * @value:	Pointer to read buffer

 *

 * Return: 0 on success, or -ERRNO

/**

 * nfp_cpp_area_writel() - Write a u32 word to an area

 * @area:	CPP Area handle

 * @offset:	Offset into area

 * @value:	Value to write

 *

 * Return: 0 on success, or -ERRNO

/**

 * nfp_cpp_area_readq() - Read a u64 word from an area

 * @area:	CPP Area handle

 * @offset:	Offset into area

 * @value:	Pointer to read buffer

 *

 * Return: 0 on success, or -ERRNO

/**

 * nfp_cpp_area_writeq() - Write a u64 word to an area

 * @area:	CPP Area handle

 * @offset:	Offset into area

 * @value:	Value to write

 *

 * Return: 0 on success, or -ERRNO

/**

 * nfp_cpp_area_fill() - fill a CPP area with a value

 * @area:	CPP area

 * @offset:	offset into CPP area

 * @value:	value to fill with

 * @length:	length of area to fill

 *

 * Fill indicated area with given value.

 *

 * Return: length of io, or -ERRNO

/**

 * nfp_cpp_area_cache_add() - Permanently reserve and area for the hot cache

 * @cpp:	NFP CPP handle

 * @size:	Size of the area - MUST BE A POWER OF 2.

	/* Allocate an area - we use the MU target's base as a placeholder,

	 * as all supported chips have a MU.

	/* Early exit when length == 0, which prevents

	 * the need for special case code below when

	 * checking against available cache size.

 Remap from cpp_island to cpp_target */

 See if we have a match */

 No matches - inspect the tail of the LRU */

 Can we fit in the cache entry? */

 If id != 0, we will need to release it */

 Adjust the start address to be cache size aligned */

 Re-init to the new ID and address */

 Attempt to acquire */

 Adjust offset */

 Move to front of LRU */

/**

 * nfp_cpp_read() - read from CPP target

 * @cpp:		CPP handle

 * @destination:	CPP id

 * @address:		offset into CPP target

 * @kernel_vaddr:	kernel buffer for result

 * @length:		number of bytes to read

 *

 * Return: length of io, or -ERRNO

 make first read smaller to align to safe window */

/**

 * nfp_cpp_write() - write to CPP target

 * @cpp:		CPP handle

 * @destination:	CPP id

 * @address:		offset into CPP target

 * @kernel_vaddr:	kernel buffer to read from

 * @length:		number of bytes to write

 *

 * Return: length of io, or -ERRNO

 make first write smaller to align to safe window */

 Return the correct CPP address, and fixup xpb_addr as needed. */

	/* Ensure that non-local XPB accesses go

	 * out through the global XPBM bus.

 Accesses to the ARM Island overlay uses Island 0 / Global Bit */

 And only non-ARM interfaces use the island id = 1 */

/**

 * nfp_xpb_readl() - Read a u32 word from a XPB location

 * @cpp:	CPP device handle

 * @xpb_addr:	Address for operation

 * @value:	Pointer to read buffer

 *

 * Return: 0 on success, or -ERRNO

/**

 * nfp_xpb_writel() - Write a u32 word to a XPB location

 * @cpp:	CPP device handle

 * @xpb_addr:	Address for operation

 * @value:	Value to write

 *

 * Return: 0 on success, or -ERRNO

/**

 * nfp_xpb_writelm() - Modify bits of a 32-bit value from the XPB bus

 * @cpp:	NFP CPP device handle

 * @xpb_tgt:	XPB target and address

 * @mask:	mask of bits to alter

 * @value:	value to modify

 *

 * KERNEL: This operation is safe to call in interrupt or softirq context.

 *

 * Return: 0 on success, or -ERRNO

 Lockdep markers */

 Nothing to do here - it just makes the kernel happy */

/**

 * nfp_cpp_from_operations() - Create a NFP CPP handle

 *                             from an operations structure

 * @ops:	NFP CPP operations structure

 * @parent:	Parent device

 * @priv:	Private data of low-level implementation

 *

 * NOTE: On failure, cpp_ops->free will be called!

 *

 * Return: NFP CPP handle on success, ERR_PTR on failure

	/* NOTE: cpp_lock is NOT locked for op->init,

	 * since it may call NFP CPP API operations

 Hardcoded XPB IMB Base, island 0 */

/**

 * nfp_cpp_priv() - Get the operations private data of a CPP handle

 * @cpp:	CPP handle

 *

 * Return: Private data for the NFP CPP handle

/**

 * nfp_cpp_device() - Get the Linux device handle of a CPP handle

 * @cpp:	CPP handle

 *

 * Return: Device for the NFP CPP bus

/**

 * nfp_cpp_explicit_acquire() - Acquire explicit access handle

 * @cpp:	NFP CPP handle

 *

 * The 'data_ref' and 'signal_ref' values are useful when

 * constructing the NFP_EXPL_CSR1 and NFP_EXPL_POST values.

 *

 * Return: NFP CPP explicit handle

/**

 * nfp_cpp_explicit_set_target() - Set target fields for explicit

 * @expl:	Explicit handle

 * @cpp_id:	CPP ID field

 * @len:	CPP Length field

 * @mask:	CPP Mask field

 *

 * Return: 0, or -ERRNO

/**

 * nfp_cpp_explicit_set_data() - Set data fields for explicit

 * @expl:	Explicit handle

 * @data_master: CPP Data Master field

 * @data_ref:	CPP Data Ref field

 *

 * Return: 0, or -ERRNO

/**

 * nfp_cpp_explicit_set_signal() - Set signal fields for explicit

 * @expl:	Explicit handle

 * @signal_master: CPP Signal Master field

 * @signal_ref:	CPP Signal Ref field

 *

 * Return: 0, or -ERRNO

/**

 * nfp_cpp_explicit_set_posted() - Set completion fields for explicit

 * @expl:	Explicit handle

 * @posted:	True for signaled completion, false otherwise

 * @siga:	CPP Signal A field

 * @siga_mode:	CPP Signal A Mode field

 * @sigb:	CPP Signal B field

 * @sigb_mode:	CPP Signal B Mode field

 *

 * Return: 0, or -ERRNO

/**

 * nfp_cpp_explicit_put() - Set up the write (pull) data for a explicit access

 * @expl:	NFP CPP Explicit handle

 * @buff:	Data to have the target pull in the transaction

 * @len:	Length of data, in bytes

 *

 * The 'len' parameter must be less than or equal to 128 bytes.

 *

 * If this function is called before the configuration

 * registers are set, it will return -EINVAL.

 *

 * Return: 0, or -ERRNO

/**

 * nfp_cpp_explicit_do() - Execute a transaction, and wait for it to complete

 * @expl:	NFP CPP Explicit handle

 * @address:	Address to send in the explicit transaction

 *

 * If this function is called before the configuration

 * registers are set, it will return -1, with an errno of EINVAL.

 *

 * Return: 0, or -ERRNO

/**

 * nfp_cpp_explicit_get() - Get the 'push' (read) data from a explicit access

 * @expl:	NFP CPP Explicit handle

 * @buff:	Data that the target pushed in the transaction

 * @len:	Length of data, in bytes

 *

 * The 'len' parameter must be less than or equal to 128 bytes.

 *

 * If this function is called before all three configuration

 * registers are set, it will return -1, with an errno of EINVAL.

 *

 * If this function is called before nfp_cpp_explicit_do()

 * has completed, it will return -1, with an errno of EBUSY.

 *

 * Return: 0, or -ERRNO

/**

 * nfp_cpp_explicit_release() - Release explicit access handle

 * @expl:	NFP CPP Explicit handle

 *

/**

 * nfp_cpp_explicit_cpp() - return CPP handle for CPP explicit

 * @cpp_explicit:	CPP explicit handle

 *

 * Return: NFP CPP handle of the explicit

/**

 * nfp_cpp_explicit_priv() - return private struct for CPP explicit

 * @cpp_explicit:	CPP explicit handle

 *

 * Return: private data of the explicit, or NULL

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2015-2018 Netronome Systems, Inc. */

/*

 * nfp_target.c

 * CPP Access Width Decoder

 * Authors: Jakub Kicinski <jakub.kicinski@netronome.com>

 *          Jason McMullan <jason.mcmullan@netronome.com>

 *          Francois H. Theron <francois.theron@netronome.com>

/* This structure ONLY includes items that can be done with a read or write of

 * 32-bit or 64-bit words. All others are not listed.

 ReadNbiDma */

 WriteNbiDma */

 ReadNbiStats */

 WriteNbiStats */

 ReadNbiTM */

 WriteNbiTM */

 ReadNbiPreclassifier */

 WriteNbiPreclassifier */

/* This structure ONLY includes items that can be done with a read or write of

 * 32-bit or 64-bit words. All others are not listed.

 read_be/write_be */

 read_le/write_le */

 read_swap_be/write_swap_be */

 read_swap_le/write_swap_le */

 read_be */

 read_le */

 read_swap_be */

 read_swap_le */

 write_be */

 write_le */

 write_swap_be */

 write_swap_le */

 atomic_read */

 mask_compare_write */

 atomic_write */

 atomic_write_imm */

 swap_imm */

 set */

 test_set_imm */

 clr */

 test_clr_imm */

 add */

 test_add_imm */

 addsat */

 test_subsat_imm */

 sub */

 test_sub_imm */

 subsat */

 test_subsat_imm */

 microq128_get */

 microq128_pop */

 microq128_put */

 xor */

 test_xor_imm */

 read32_be */

 read32_le */

 read32_swap_be */

 read32_swap_le */

 write32_be */

 write32_le */

 write32_swap_be */

 write32_swap_le */

 packet_read_packet_status */

 packet_credit_get */

 packet_add_thread */

 packet_free_and_return_pointer */

 packet_return_pointer */

 pe_dma_to_memory_indirect */

 pe_dma_to_memory_indirect_swap */

 pe_dma_to_memory_indirect_free */

 pe_dma_to_memory_indirect_free_swap */

 read_queue */

 read_queue_ring */

 write_queue */

 write_queue_ring */

 journal */

 get */

 get_eop */

 get_freely */

 pop */

 pop_eop */

 pop_freely */

 read_check_error */

 read_int */

 write_int */

 RingGet */

 Interthread Signal */

 RingPut */

 CTNNWr */

 ReflectRd, signal none */

 ReflectRd, signal self */

 ReflectRd, signal remote */

 ReflectRd, signal both */

 ReflectWr, signal none */

 ReflectWr, signal self */

 ReflectWr, signal remote */

 ReflectWr, signal both */

 xor */

 set */

 clr */

 add */

 add64 */

 sub */

 sub64 */

 subsat */

 hash_mask */

 hash_clear */

 ring_get */

 ring_pop */

 ring_get_freely */

 ring_pop_freely */

 ring_put */

 ring_journal */

 reflect_write_sig_local */

 reflect_read_sig_local */

 statisic */

 ring_read */

 ring_write */

 ring_workq_add_thread */

 ring_workq_add_work */

/* All magic NFP-6xxx IMB 'mode' numbers here are from:

 * Databook (1 August 2013)

 * - System Overview and Connectivity

 * -- Internal Connectivity

 * --- Distributed Switch Fabric - Command Push/Pull (DSF-CPP) Bus

 * ---- CPP addressing

 * ----- Table 3.6. CPP Address Translation Mode Commands

 This function doesn't handle MU or CTXBP */

		/* For VQDR, in this mode for 32-bit addressing

		 * it would be islands 0, 16, 32 and 48 depending on channel

		 * and upper address bits.

		 * Since those are not all valid islands, most decode

		 * cases would result in bad island IDs, but we do them

		 * anyway since this is decoding an address that is already

		 * assumed to be used as-is to get to sram.

		/* For VQDR 32-bit, this would decode as:

		 * Channel 0: island#0

		 * Channel 1: island#0

		 * Channel 2: island#1

		 * Channel 3: island#1

		 * That would be valid as long as both islands

		 * have VQDR. Let's allow this.

		/* For VQDR 32-bit:

		 * Channel 0: (island#0 | 0)

		 * Channel 1: (island#0 | 1)

		 * Channel 2: (island#1 | 0)

		 * Channel 3: (island#1 | 1)

		 *

		 * Make sure we compare against isldN values

		 * by clearing the LSB.

		 * This is what the silicon does.

		/* In this mode the data address starts to affect the island ID

		 * so rather not allow it. In some really specific case

		 * one could use this to send the upper half of the

		 * VQDR channel to another MU, but this is getting very

		 * specific.

		 * However, as above for mode 0, this is the decoder

		 * and the caller should validate the resulting IID.

		 * This blindly does what the silicon would do.

 Full Island ID and channel bits overlap? */

 The current address won't go where expected? */

 If dest_island was -1, we don't care where it goes. */

/* Try each option, take first one that fits.

 * Not sure if we would want to do some smarter

 * searching and prefer 0 or non-0 island IDs.

/* For VQDR, we may not modify the Channel bits, which might overlap

 *  with the Index bit. When it does, we need to ensure that isld0 == isld1.

 This function doesn't handle MU or CTXBP */

			/* In this specific mode we'd rather not modify

			 * the address but we can verify if the existing

			 * contents will point to a valid island.

 <39:34> or <31:26> */

 Only need to clear the Index bit */

 Only need to set the Index bit */

		/* iid<0> = addr<30> = channel<0>

		 * channel<1> = addr<31> = Index

			/* Special case where we allow channel bits to

			 * be set before hand and with them select an island.

			 * So we need to confirm that it's at least plausible.

		/* Make sure we compare against isldN values

		 * by clearing the LSB.

		 * This is what the silicon does.

			/* iid<0> = addr<29> = data

			 * iid<1> = addr<30> = channel<0>

			 * channel<1> = addr<31> = Index

		/* Make sure we compare against isldN values

		 * by clearing the LSB.

		 * This is what the silicon does.

		/* Only the EMU will use 40 bit addressing. Silently

		 * set the direct locality bit for everyone else.

		 * The SDK toolchain uses dest_island <= 0 to test

		 * for atypical address encodings to support access

		 * to local-island CTM with a 32-but address (high-locality

		 * is effewctively ignored and just used for

		 * routing to island #0).

 Already translated */

 CPP + Island only allowed on systems with IMB tables */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2017-2018 Netronome Systems, Inc. */

	/* Convert to long words as firmware expects

	 * lengths in units of NFP_FL_LW_SIZ.

	/* Convert back to bytes as software expects

	 * lengths in units of bytes.

 If any tun dissector is used then the required set must be used. */

 check if GRE, which has no enc_ports */

			/* Ensure the ingress netdev matches the expected

			 * tun type.

 Ethernet type is present in the key. */

		/* Currently we do not offload ARP

		 * because we rely on it to get to the host.

 Will be included in layer 2. */

		/* We only support PSH and URG flags when either

		 * FIN, SYN or RST is present as well.

		/* We need to store TCP flags in the either the IPv4 or IPv6 key

		 * space, thus we need to ensure we include a IPv4/IPv6 key

		 * layer if we have not done so already.

 New tunnel header means l2 to l4 can be matched. */

	/* Two flows can be merged if sub_flow2 only matches on bits that are

	 * either matched by sub_flow1 or set by a sub_flow1 action. This

	 * ensures that every packet that hits sub_flow1 and recirculates is

	 * guaranteed to hit sub_flow2.

 Must only be 1 output action and it must be the last in sequence. */

	/* Reject merge if sub_flow2 matches on something that is not matched

	 * on or set in an action by sub_flow1.

 Ensure any VLAN push also has an egress action. */

 Return error if no tunnel action is found. */

 The last action of sub_flow1 must be output - do not merge this. */

 A shortcut can only be applied if there is a single action. */

 Copy any pre-actions to the start of merge flow action list. */

	/* FW does a tunnel push when egressing, therefore, if sub_flow 1 pushes

	 * a tunnel, there are restrictions on what sub_flow 2 actions lead to a

	 * valid merge.

 Copy remaining actions from sub_flows 1 and 2. */

 Update tunnel action in merge to include VLAN push. */

 Flow link code should only be accessed under RTNL. */

/**

 * nfp_flower_merge_offloaded_flows() - Merge 2 existing flows to single flow.

 * @app:	Pointer to the APP handle

 * @sub_flow1:	Initial flow matched to produce merge hint

 * @sub_flow2:	Post recirculation flow matched in merge hint

 *

 * Combines 2 flows (if valid) to a single flow, removing the initial from hw

 * and offloading the new, merged flow.

 *

 * Return: negative value on error, 0 in success.

 check if the two flows are already merged */

/**

 * nfp_flower_validate_pre_tun_rule()

 * @app:	Pointer to the APP handle

 * @flow:	Pointer to NFP flow representation of rule

 * @key_ls:	Pointer to NFP key layers structure

 * @extack:	Netlink extended ACK report

 *

 * Verifies the flow as a pre-tunnel rule.

 *

 * Return: negative value on error, 0 if verified.

 Skip fields known to exist. */

 Ensure destination MAC address matches pre_tun_dev. */

 Ensure destination MAC address is fully matched. */

 Flags and proto fields have same offset in IPv4 and IPv6. */

 Ensure proto and flags are the only IP layer fields. */

 Action must be a single egress or pop_vlan and egress. */

 Ensure there are no more actions after egress. */

/**

 * nfp_flower_add_offload() - Adds a new flow to hardware.

 * @app:	Pointer to the APP handle

 * @netdev:	netdev structure.

 * @flow:	TC flower classifier offload structure.

 *

 * Adds a new flow to the repeated hash structure and action payload.

 *

 * Return: negative value on error, 0 if configured successfully.

 Deallocate flow payload when flower rule has been destroyed. */

 Re-add rule the merge had overwritten if it has not been deleted. */

 Clean any links connected with the merged flow. */

 Remove any merge flow formed from the deleted sub_flow. */

/**

 * nfp_flower_del_offload() - Removes a flow from hardware.

 * @app:	Pointer to the APP handle

 * @netdev:	netdev structure.

 * @flow:	TC flower classifier offload structure

 *

 * Removes a flow from the repeated hash structure and clears the

 * action payload. Any flows merged from this are also deleted.

 *

 * Return: negative value on error, 0 if removed successfully.

 Check ct_map_table */

 Fall through on error. */

 Do not cycle subflows if no stats to distribute. */

 Reset stats for the merge flow. */

	/* The merge flow has received stats updates from firmware.

	 * Distribute these stats to all subflows that form the merge.

	 * The stats will collected from TC via the subflows.

 Get merge flows that the subflow forms to distribute their stats. */

/**

 * nfp_flower_get_stats() - Populates flow stats obtained from hardware.

 * @app:	Pointer to the APP handle

 * @netdev:	Netdev structure.

 * @flow:	TC flower classifier offload structure

 *

 * Populates a flow statistics structure which which corresponds to a

 * specific flow.

 *

 * Return: negative value on error, 0 if stats populated successfully.

 Check ct_map table first */

 If request is for a sub_flow, update stats from merged flows. */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2021 Corigine, Inc. */

/**

 * get_hashentry() - Wrapper around hashtable lookup.

 * @ht:		hashtable where entry could be found

 * @key:	key to lookup

 * @params:	hashtable params

 * @size:	size of entry to allocate if not in table

 *

 * Returns an entry from a hashtable. If entry does not exist

 * yet allocate the memory for it and return the new entry.

	/* check the overlapped fields one by one, the unmasked part

	 * should not conflict with each other.

 for ipv6, tos and flow_lbl are in the same word */

 currently only can modify ports */

 Check for pre_ct->action conflicts */

 Check for nft->action conflicts */

 This field must always be present */

 Actions need a BASIC dissector. */

 Copy actions */

			/* ip_proto is the only field that needed in later compile_action,

			 * needed to set the correct checksum flags. It doesn't really matter

			 * which input rule's ip_proto field we take as the earlier merge checks

			 * would have made sure that they don't conflict. We do not know which

			 * of the subflows would have the ip_proto filled in, so we need to iterate

			 * through the subflows and assign the proper subflow to a_rule

			/* Ignore CT related actions as these would already have

			 * been taken care of by previous checks, and we do not send

			 * any CT actions to the firmware.

 Some actions would have been ignored, so update the num_entries field */

 Calculate the resultant key layer and size for offload */

	/* Using in_port from the -trk rule. The tc merge checks should already

	 * be checking that the ingress netdevs are the same

	/* This following part works on the assumption that previous checks has

	 * already filtered out flows that has different values for the different

	 * layers. Here we iterate through all three rules and merge their respective

	 * masked value(cared bits), basic method is:

	 * final_key = (r1_key & r1_mask) | (r2_key & r2_mask) | (r3_key & r3_mask)

	 * final_mask = r1_mask | r2_mask | r3_mask

	 * If none of the rules contains a match that is also fine, that simply means

	 * that the layer is not present.

			/* Store the tunnel destination in the rule data.

			 * This must be present and be an exact match.

			/* Store the tunnel destination in the rule data.

			 * This must be present and be an exact match.

 Merge actions into flow_pay */

	/* Use the pointer address as the cookie, but set the last bit to 1.

	 * This is to avoid the 'is_merge_flow' check from detecting this as

	 * an already merged flow. This works since address alignment means

	 * that the last bit for pointer addresses will be 0.

	/* Check that the two tc flows are also compatible with

	 * the nft entry. No need to check the pre_ct and post_ct

	 * entries as that was already done during pre_merge.

	 * The nft entry does not have a netdev or chain populated, so

	 * skip this check.

 Combine tc_merge and nft cookies for this cookie. */

 nft_m_entry already present, not merging again */

	/* Copy the netdev from one the pre_ct entry. When the tc_m_entry was created

	 * it only combined them if the netdevs were the same, so can use any of them.

 Add this entry to the tc_m_list and nft_flow lists */

 Generate offload structure and send to nfp */

	/* Checks that the chain_index of the filter matches the

	 * chain_index of the GOTO action.

 m_entry already present, not merging again */

 Add this entry to the pre_ct and post_ct lists */

 Merge with existing nft flows */

 If priv is set this is an existing entry, just return it */

 init the various hash tables and lists*/

	/* nft flows gets destroyed after callback return, so need

	 * to do a full copy instead of just a reference.

	/* Copy over action data. Unfortunately we do not get a handle to the

	 * original tcf_action data, and the flow objects gets destroyed, so we

	 * cannot just save a pointer to this either, so need to copy over the

	 * data unfortunately.

		/* Entunnel is a special case, need to allocate and copy

		 * tunnel info.

 Now add a ct map entry to flower-priv */

 Flow is in HW, need to delete */

	/* These post entries are parts of two lists, one is a list of nft_entries

	 * and the other is of from a list of tc_merge structures. Iterate

	 * through the relevant list and cleanup the entries.

 Need to iterate through list of nft_flow entries*/

 Need to iterate through list of tc_merged_flow entries*/

 Add entry to pre_ct_list */

 Need to check and merge with tables in the wc_zone as well */

 Add entry to post_ct_list */

		/* Iterate through all zone tables if not empty, look for merges with

		 * pre_ct entries and merge them.

	/* If request is for a sub_flow which is part of a tunnel merged

	 * flow then update stats from tunnel merged flows first.

 Update nft cached stats */

 Update pre_ct cached stats */

 Update post_ct cached stats */

 Reset stats from the nfp */

 Iterate tc_merge entries associated with this flow */

 Iterate nft_merge entries associated with this tc_merge flow */

 Update post_ct partner */

 Iterate tc_merge entries associated with this flow */

 Iterate nft_merge entries associated with this tc_merge flow */

 Update pre_ct partner */

 Iterate nft_merge entries associated with this nft flow */

	/* Add stats from this request to stats potentially cached by

	 * previous requests.

 Finally update the flow stats from the original stats request */

	/* Stats has been synced to original flow, can now clear

	 * the cache.

		/* Netfilter can request offload multiple times for the same

		 * flow - protect against adding duplicates.

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2015-2018 Netronome Systems, Inc. */

 Not an ack for requested MTU change. */

 An MTU of 0 from the firmware should be ignored */

 msg->count starts at 0 and always assumes at least 1 entry. */

 Only warn on memory fail. Hint veto will not break functionality. */

 We need to deal with stats updates from HW asap */

 Handle MTU acks outside wq to prevent RTNL conflict. */

 Acks from the NFP that the route is added - ignore. */

 Handle REIFY acks outside wq to prevent RTNL conflict. */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2019 Netronome Systems, Inc. */

/* Police cmsg for configuring a trTCM traffic conditioner (8W/32B)

 * See RFC 2698 for more details.

 * ----------------------------------------------------------------

 *    3                   2                   1

 *  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0

 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

 * |             Reserved          |p|         Reserved            |

 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

 * |                          Port Ingress                         |

 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

 * |                        Token Bucket Peak                      |

 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

 * |                     Token Bucket Committed                    |

 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

 * |                         Peak Burst Size                       |

 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

 * |                      Committed Burst Size                     |

 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

 * |                      Peak Information Rate                    |

 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

 * |                    Committed Information Rate                 |

 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

 * Word[0](FLag options):

 * [15] p(pps) 1 for pps ,0 for bps

 *

 Set QoS data for this interface */

		/* 0:bps 1:pps

		 * Clear QoS data for this interface.

		 * There is no need to check if a specific QOS_TYPE was

		 * configured as the firmware handles clearing a QoS entry

		 * safely, even if it wasn't explicitly added.

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2017-2018 Netronome Systems, Inc. */

 Check if buffer is full. */

 Check for unallocated entries first. */

 Check if buffer is empty. */

 Must be called with either RTNL or rcu_read_lock */

 Checking if buffer is full. */

 Checking for unallocated entries first. */

 Checking if buffer is empty. */

 Casting u8 to int for later use. */

	/* Do net allocate a mask-id for pre_tun_rules. These flows are used to

	 * configure the pre_tun table and are never actually send to the

	 * firmware as an add-flow message. This causes the mask-id allocation

	 * on the firmware to get out of sync if allocated here.

 Update flow payload with mask ids. */

 Update flow payload with mask ids. */

 Release the stats ctx id and ctx to flow table entry. */

 Init ring buffer and unallocated mask_ids. */

 Init timestamps for mask id*/

 Init ring buffer and unallocated stats_ids. */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2017-2018 Netronome Systems, Inc. */

/* The kernel versions of TUNNEL_* are not ABI and therefore vulnerable

 * to change. Such changes will break our FW ABI.

 BOS is optional in the TC action but required for offload. */

 Leave MPLS TC as a default value of 0 if not explicitly set. */

 Proto, label and TTL are enforced and verified for MPLS push. */

	/* Pre_lag action must be first on action list.

	 * If other actions already exist they need pushed forward.

 Verify the egress netdev matches the tunnel type. */

 Set action output parameters. */

 Confirm ingress and egress are on same device. */

 Preparse action list for next mirred or redirect action */

	/* Determine the tunnel type based on the egress netdev

	 * in the mirred action for tunnels without l4.

	/* Pre_tunnel action must be first on action list.

	 * If other actions already exist they need to be pushed forward.

	/* We need to populate the options in reverse order for HW.

	 * Therefore we go through the options, calculating the

	 * number of options and the total size, then we populate

	 * them in reverse order in the action list.

 Currently support one pre-tunnel so index is always 0. */

 Set tunnel type and pre-tunnel index. */

		/* Do a route lookup to determine ttl - if fails then use

		 * default. Note that CONFIG_INET is a requirement of

		 * CONFIG_NET_SWITCHDEV so must be defined here.

 Complete pre_tunnel action. */

 We are expecting tcf_pedit to return a big endian value */

 We are expecting tcf_pedit to return a big endian value */

		/* Filter doesn't force proto match,

		 * both TCP and UDP will be updated if encountered

 All other protocols will be ignored by FW */

 Hardware will automatically fix IPv4 and TCP/UDP checksum. */

 Hardware will automatically fix IPv4 and TCP/UDP checksum. */

 Hardware will automatically fix TCP/UDP checksum. */

		/* TC compiles set src and dst IPv6 address as a single action,

		 * the hardware requires this to be 2 separate actions.

 Hardware will automatically fix TCP/UDP checksum. */

 Hardware will automatically fix TCP/UDP checksum. */

 Hardware will automatically fix TCP/UDP checksum. */

 Hardware will automatically fix TCP/UDP checksum. */

	/* If csum_updated has not been reset by now, it means HW will

	 * incorrectly update csums when they are not requested.

		/* nfp_fl_pre_lag returns -err or size of prelag action added.

		 * This will be 0 if it is not egressing to a lag dev.

		/* Pre-tunnel action is required for tunnel encap.

		 * This checks for next hop entries on NFP.

		 * If none, the packet falls back before applying other actions.

 Tunnel decap is handled by default so accept action. */

 csum action requests recalc of something we have not fixed */

		/* If we will correctly fix the csum we can remove it from the

		 * csum update list. Which will later be used to check support.

 TC ptype skbedit sets PACKET_HOST for ingress redirect. */

 Currently we do not handle any other actions. */

	/* We optimise when the action list is small, this can unfortunately

	 * not happen once we have more than one action in the action list.

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2017-2018 Netronome Systems, Inc. */

 Populate the metadata frame. */

 Populate the tci field. */

 Populate mac frame. */

 Only support matching the first LSE */

		/* Check for mpls ether type and set NFP_FLOWER_MASK_MPLS_Q

		 * bit, which indicates an mpls ether type but without any

		 * mpls fields.

 NVGRE is the only supported GRE tunnel type */

 NVGRE is the only supported GRE tunnel type */

 Populate Extended Metadata if Required. */

 Populate Exact Port data. */

 Populate Mask Port Data. */

			/* Store the tunnel destination in the rule data.

			 * This must be present and be an exact match.

			/* Store the tunnel destination in the rule data.

			 * This must be present and be an exact match.

	/* Check that the flow key does not exceed the maximum limit.

	 * All structures in the key is multiples of 4 bytes, so use u32.

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2017-2018 Netronome Systems, Inc. */

/**

 * struct nfp_tun_pre_tun_rule - rule matched before decap

 * @flags:		options for the rule offset

 * @port_idx:		index of destination MAC address for the rule

 * @vlan_tci:		VLAN info associated with MAC

 * @host_ctx_id:	stats context of rule to update

/**

 * struct nfp_tun_active_tuns - periodic message of active tunnels

 * @seq:		sequence number of the message

 * @count:		number of tunnels report in message

 * @flags:		options part of the request

 * @tun_info.ipv4:		dest IPv4 address of active route

 * @tun_info.egress_port:	port the encapsulated packet egressed

 * @tun_info.extra:		reserved for future use

 * @tun_info:		tunnels that have sent traffic in reported period

/**

 * struct nfp_tun_active_tuns_v6 - periodic message of active IPv6 tunnels

 * @seq:		sequence number of the message

 * @count:		number of tunnels report in message

 * @flags:		options part of the request

 * @tun_info.ipv6:		dest IPv6 address of active route

 * @tun_info.egress_port:	port the encapsulated packet egressed

 * @tun_info.extra:		reserved for future use

 * @tun_info:		tunnels that have sent traffic in reported period

/**

 * struct nfp_tun_neigh - neighbour/route entry on the NFP

 * @dst_ipv4:	destination IPv4 address

 * @src_ipv4:	source IPv4 address

 * @dst_addr:	destination MAC address

 * @src_addr:	source MAC address

 * @port_id:	NFP port to output packet on - associated with source IPv4

/**

 * struct nfp_tun_neigh_v6 - neighbour/route entry on the NFP

 * @dst_ipv6:	destination IPv6 address

 * @src_ipv6:	source IPv6 address

 * @dst_addr:	destination MAC address

 * @src_addr:	source MAC address

 * @port_id:	NFP port to output packet on - associated with source IPv6

/**

 * struct nfp_tun_req_route_ipv4 - NFP requests a route/neighbour lookup

 * @ingress_port:	ingress port of packet that signalled request

 * @ipv4_addr:		destination ipv4 address for route

 * @reserved:		reserved for future use

/**

 * struct nfp_tun_req_route_ipv6 - NFP requests an IPv6 route/neighbour lookup

 * @ingress_port:	ingress port of packet that signalled request

 * @ipv6_addr:		destination ipv6 address for route

/**

 * struct nfp_offloaded_route - routes that are offloaded to the NFP

 * @list:	list pointer

 * @ip_add:	destination of route - can be IPv4 or IPv6

/**

 * struct nfp_tun_ipv4_addr - set the IP address list on the NFP

 * @count:	number of IPs populated in the array

 * @ipv4_addr:	array of IPV4_ADDRS_MAX 32 bit IPv4 addresses

/**

 * struct nfp_ipv4_addr_entry - cached IPv4 addresses

 * @ipv4_addr:	IP address

 * @ref_count:	number of rules currently using this IP

 * @list:	list pointer

/**

 * struct nfp_tun_ipv6_addr - set the IP address list on the NFP

 * @count:	number of IPs populated in the array

 * @ipv6_addr:	array of IPV6_ADDRS_MAX 128 bit IPv6 addresses

/**

 * struct nfp_tun_mac_addr_offload - configure MAC address of tunnel EP on NFP

 * @flags:	MAC address offload options

 * @count:	number of MAC addresses in the message (should be 1)

 * @index:	index of MAC address in the lookup table

 * @addr:	interface MAC address

/**

 * struct nfp_tun_offloaded_mac - hashtable entry for an offloaded MAC

 * @ht_node:		Hashtable entry

 * @addr:		Offloaded MAC address

 * @index:		Offloaded index for given MAC address

 * @ref_count:		Number of devs using this MAC address

 * @repr_list:		List of reprs sharing this MAC address

 * @bridge_count:	Number of bridge/internal devs with MAC

 Update the used timestamp of neighbour */

 Update the used timestamp of neighbour */

 If entry has expired send dst IP with all other fields 0. */

 Trigger ARP to verify invalid neighbour state. */

 Have a valid neighbour so populate rest of entry. */

 Add destination of new route to NFP cache. */

 If entry has expired send dst IP with all other fields 0. */

 Trigger probe to verify invalid neighbour state. */

 Have a valid neighbour so populate rest of entry. */

 Add destination of new route to NFP cache. */

 Only concerned with changes to routes already added to NFP. */

 CONFIG_IPV6 */

 Do a route lookup to populate flow data. */

 CONFIG_INET */

 Do a route lookup on same namespace as ingress port. */

 Get the neighbour entry for the lookup */

 FW supports multiple MACs per cmsg but restrict to single. */

 If modifing MAC, remove repr from old list first. */

 MAC is global but matches need to go to pre_tun table. */

 Assign a global index if non-repr or MAC is now shared. */

 If not shared then free. */

 If del is part of a mod then mac_list is still in use elsewheree. */

 If MAC is now used by 1 repr set the offloaded MAC index to port. */

 If MAC has global ID then extract and free the ida entry. */

 Only attempt delete if add was successful. */

 Ignore if changing to the same address. */

 Delete the previous MAC address. */

 Only offload addr change if netdev is already up. */

		/* If a repr is attached to a bridge then tunnel packets

		 * entering the physical port are directed through the bridge

		 * datapath and cannot be directly detunneled. Therefore,

		 * associated offloaded MACs and indexes should not be used

		 * by fw for detunneling.

	/* Lookup MAC index for the pre-tunnel rule egress device.

	 * Note that because the device is always an internal port, it will

	 * have a constant global index so does not need to be tracked.

	/* Set/clear IPV6 bit. cpu_to_be16() swap will lead to MSB being

	 * set/clear for port_idx.

 Copy mac id and vlan to flow - dev may not exist at delete time. */

 Initialise rhash for MAC offload tracking. */

 Initialise priv data for IPv4/v6 offloading. */

 Initialise priv data for neighbour offloading. */

 Free any memory that may be occupied by ipv4 list. */

 Free memory in the route list and remove entries from fw cache. */

 Destroy rhash. Entries should be cleaned on netdev notifier unreg. */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2018 Netronome Systems, Inc. */

 LAG group config flags. */

 LAG port state flags. */

/**

 * struct nfp_flower_cmsg_lag_config - control message payload for LAG config

 * @ctrl_flags:	Configuration flags

 * @reserved:	Reserved for future use

 * @ttl:	Time to live of packet - host always sets to 0xff

 * @pkt_number:	Config message packet number - increment for each message

 * @batch_ver:	Batch version of messages - increment for each batch of messages

 * @group_id:	Group ID applicable

 * @group_inst:	Group instance number - increment when group is reused

 * @members:	Array of 32-bit words listing all active group members

/**

 * struct nfp_fl_lag_group - list entry for each LAG group

 * @group_id:		Assigned group ID for host/kernel sync

 * @group_inst:		Group instance in case of ID reuse

 * @list:		List entry

 * @master_ndev:	Group master Netdev

 * @dirty:		Marked if the group needs synced to HW

 * @offloaded:		Marked if the group is currently offloaded to NIC

 * @to_remove:		Marked if the group should be removed from NIC

 * @to_destroy:		Marked if the group should be removed from driver

 * @slave_cnt:		Number of slaves in group

 Use this ID with zero members to ack a batch config */

 ID 0 reserved */

 IDs 1 to 31 are valid */

 wait for more config */

 max retrans cmsgs to store */

 LSB is not considered by firmware so add 2 for each increment. */

 Zero is reserved by firmware. */

 Increment batch version for each new batch of config messages. */

 If it is a reset msg then it is also the end of the batch. */

	/* To signal the end of a batch, both the switch and last flags are set

	 * and the the reserved SYNC group ID is used.

 Active count of 0 deletes group on hw. */

		/* Include sanity check in the loop. It may be that a bond has

		 * changed between processing the last notification and the

		 * work queue triggering. If the number of slaves has changed

		 * or it now contains netdevs that cannot be offloaded, ignore

		 * the group until pending notifications are processed.

 Check the ports for state changes. */

 End the config batch if at least one packet has been batched. */

	/* Drop cmsg retrans if storage limit is exceeded to prevent

	 * overloading. If the fw notices that expected messages have not been

	 * received in a given time block, it will request a full resync.

	/* Note the intentional fall through below. If DATA and XON are both

	 * set, the message will stored and sent again with the rest of the

	 * unprocessed messages list.

 Store */

 Send stored */

 Resend all */

		/* To resend all config:

		 * 1) Clear all unprocessed messages

		 * 2) Mark all groups dirty

		 * 3) Reset NFP group config

		 * 4) Schedule a LAG config update

 Ensure all ports are created by the same app/on same card. */

 Firmware supports active/backup and L3/L4 hash bonds. */

 Cannot offload the group - remove if previously offloaded. */

 Group may have been on queue for removal but is now offfloable. */

 Verify that the repr is associated with this app. */

 0 is a reserved batch version so increment to first valid value. */

 Remove all groups. */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2017-2018 Netronome Systems, Inc. */

 Check if the port is internal. */

 For now we only support 1 PF */

	/* The REIFY/MAC_REPR control messages should be sent after the MAC

	 * representors are registered using nfp_app_reprs_set().  This is

	 * because the firmware may respond with control messages for the

	 * MAC representors, f.e. to provide the driver with information

	 * about their state, and without registration the driver will drop

	 * any such messages.

 Wait for HOST_ACK flag bit to propagate */

 Tell the firmware of the host supported features. */

 Tell the firmware that the driver supports lag. */

 Tell the firmware that the driver supports flow merging. */

 We need to ensure hardware has enough flower capabilities. */

 Extract the extra features supported by the firmware. */

 Only need to config FW for physical port MTU change. */

 Wait for fw to ack the change. */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2017 Netronome Systems, Inc. */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2019 Netronome Systems, Inc. */

 Care only about 0 -> 1 and 1 -> 0 transitions */

 Use the BAR lock to protect the connection counts */

 Undo the cnt adjustment if failed */

 Get an extra ref on the skb so we can wipe the key after */

	/* We depend on CCM MBOX code not reallocating skb we sent

	 * so we can clear the key material out of the memory.

 the extra ref from skb_get() above */

 communicate frees skb on error */

 some FW versions can't report the handle and report 0s */

 copy to ensure alignment */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2016-2018 Netronome Systems, Inc. */

/*

 * nfp_net_offload.c

 * Netronome network device driver: TC offload functions for PF and VF

 Reuse path - other offloaded program is already tracking this map. */

	/* Grab a single ref to the map for our record.  The prog destroy ndo

	 * happens after free_used_maps().

 Quickly count the maps we will have to remember */

 We depend on dead code elimination succeeding */

/* Atomic engine requires values to be in big endian, we need to byte swap

 * the value words used with xadd.

/* Mark value as unsafely initialized in case it becomes atomic later

 * and we didn't byte swap something non-byte swap neutral.

 Load up the JITed code */

 Enable passing packets through BPF function */

 Something else is loaded, different program type? */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2017-2018 Netronome Systems, Inc. */

 FW messages have no space for more than 32 bits of flags */

 Handle op cache */

 Copy inputs */

	/* FW responds with message sized to hold the good entries,

	 * plus one extra entry if there was an error.

 Copy outputs */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2016-2018 Netronome Systems, Inc. */

 --- NFP prog --- */

/* Foreach "multiple" entries macros provide pos and next<n> pointers.

 * It's safe to modify the next pointers (but not pos).

	/* If there is a recorded error we may have dropped instructions;

	 * that doesn't have to be due to translator bug, and the translation

	 * will fail anyway, so just return OK.

 --- Emitters --- */

	/* NOTE: The bit to test is specified as an rotation amount, such that

	 *	 the bit to test will be placed on the MSB of the result when

	 *	 doing a rotate right. For bit X, we need right rotate X + 1.

 Use reg.dst when destination is No-Dest. */

	/* NFP shift instruction has something special. If shift direction is

	 * left then shift amount of 1 to 31 is specified as 32 minus the amount

	 * to shift.

	 *

	 * But no need to do this for indirect shift which has shift amount be

	 * 0. Even after we do this subtraction, shift amount 0 will be turned

	 * into 32 which will eventually be encoded the same as 0 because only

	 * low 5 bits are encoded, but shift amount be 32 will fail the

	 * FIELD_PREP check done later on shift mask (0x1f), due to 32 is out of

	 * mask range.

		/* When type is step and step Number is LAST or LAST2, left

		 * source is used as destination.

 Note: ld_field is special as it uses one of the src regs as dst */

	/* This instruction takes immeds instead of reg_none() for the ignored

	 * operand, but we can't encode 2 immeds in one instr with our normal

	 * swreg infra so if param is an immed, we encode as reg_none() and

	 * copy the immed to both operands.

 CSR value is read in following immed[gpr, 0] */

 --- Wrappers --- */

/* ur_load_imm_any() - encode immediate or use tmp register (unrestricted)

 * If the @imm is small enough encode it directly in operand and return

 * otherwise load @imm to a spare register and return its encoding.

/* re_load_imm_any() - encode immediate or use tmp register (restricted)

 * If the @imm is small enough encode it directly in operand and return

 * otherwise load @imm to a spare register and return its encoding.

/* wrp_reg_subpart() - load @field_len bytes from @offset of @src, write the

 * result to @dst from low end.

/* wrp_reg_or_subpart() - load @field_len bytes from low end of @src, or the

 * result to @dst from offset, there is no change on the other bits of @dst.

 NFP has Command Push Pull bus which supports bluk memory operations. */

 Setup PREV_ALU fields to override memory read length. */

 Memory read from source addr into transfer-in registers. */

 Move from transfer-in to transfer-out. */

 Use single direct_ref write8. */

 Use single direct_ref write32. */

 Use single indirect_ref write8. */

 Use single indirect_ref write32. */

		/* Use one direct_ref write32 to write the first 32-bytes, then

		 * another direct_ref write8 to write the remaining bytes.

		/* Use one indirect_ref write32 to write 4-bytes aligned length,

		 * then another direct_ref write8 to write the remaining bytes.

	/* TODO: The following extra load is to make sure data flow be identical

	 *  before and after we do memory copy optimization.

	 *

	 *  The load destination register is not guaranteed to be dead, so we

	 *  need to make sure it is loaded with the value the same as before

	 *  this transformation.

	 *

	 *  These extra loads could be removed once we have accurate register

	 *  usage information.

	/* We load the value from the address indicated in @offset and then

	 * shift out the data we don't need.  Note: this is big endian!

	/* We load the value from the address indicated in rreg + lreg and then

	 * mask out the data we don't need.  Note: this is little endian!

 Calculate the true offset (src_reg + imm) */

 Check packet length (size guaranteed to fit b/c it's u8) */

 Load data */

 Check packet length */

 Load data */

 Move the entire word */

	/* ld_field can address fewer indexes, if offset too large do RMW.

	 * Because we RMV twice we waste 2 cycles on unaligned 8 byte writes.

		/* If it's not the first part of the load and we start a new GPR

		 * that means we are loading a second part of the LMEM word into

		 * a new GPR.  IOW we've already looked that LMEM word and

		 * therefore it has been loaded into imm_a().

 Move the entire word */

	/* ld_field can address fewer indexes, if offset too large do RMW.

	 * Because we RMV twice we waste 2 cycles on unaligned 8 byte writes.

		/* Only first and last LMEM locations are going to need RMW,

		 * the middle location will be overwritten fully.

		/* Use of the last encountered ptr_off is OK, they all have

		 * the same alignment.  Depend on low bits of value being

		 * discarded when written to LMaddr register.

 We can reach bottom 64B with LMaddr0 */

		/* We have to set up a new pointer.  If we know the offset

		 * and the entire access falls into a single 32 byte aligned

		 * window we won't have to increment the LM pointer.

		 * The 32 byte alignment is imporant because offset is ORed in

		 * not added when doing *l$indexN[off].

		/* For size < 4 one slot will be filled by zeroing of upper,

		 * but be careful, that zeroing could be eliminated by zext

		 * optimization.

 sign extend */

 br_mask of 0 is BR_BEQ which we don't use in jump code table */

 sign extend */

	/* NOTE: because we are using "reciprocal_value_adv" which doesn't

	 * support "divisor > (1u << 31)", we need to JIT separate NFP sequence

	 * to handle such case which actually equals to the result of unsigned

	 * comparison "dst >= imm" which could be calculated using the following

	 * NFP sequence:

	 *

	 *  alu[--, dst, -, imm]

	 *  immed[imm, 0]

	 *  alu[dst, imm, +carry, 0]

	 *

 Optimized version - 5 vs 14 cycles */

		/* TODO: when adjust head is guaranteed to succeed we can

		 * also eliminate the following if (r0 == 0) branch.

 We need to use a temp because offset is just a part of the pkt ptr */

 Validate result will fit within FW datapath constraints */

 Validate the length is at least ETH_HLEN */

 Load the ret code */

 Modify the packet metadata */

 Skip over the -EINVAL ret code (defer 2) */

 return -EINVAL target */

 Calculate resulting length */

	/* delta == 0 is not allowed by the kernel, add must overflow to make

	 * length smaller.

 if (new_len < 14) then -EINVAL */

 We only have to reload LM0 if the key is not at start of stack */

 Set LM0 to start of key */

 Load map ID into A0 */

 Load the return address into B0 */

 Reset the LM0 pointer */

 CSR value is read in following immed[gpr, 0] */

 Load ptr type into A1 */

 Load the return address into B0 */

 Make sure the queue id fits into FW field */

 Set the 'queue selected' bit and the queue value */

	/* Delay slots end here, we will jump over next instruction if queue

	 * value fits into the field.

 --- Callbacks --- */

 sign extend */

 sign extend */

 sign extend */

	/* NOTE: verifier hook has rejected cases for which verifier doesn't

	 * know whether the source operand is constant or not.

/* Pseudo code:

 *   if shift_amt >= 32

 *     dst_high = dst_low << shift_amt[4:0]

 *     dst_low = 0;

 *   else

 *     dst_high = (dst_high, dst_low) >> (32 - shift_amt)

 *     dst_low = dst_low << shift_amt

 *

 * The indirect shift will use the same logic at runtime.

 NOTE: for indirect left shift, HIGH part should be calculated first. */

		/* Generate different instruction sequences depending on runtime

		 * value of shift amount.

 shl_reg64_lt32_low packed in delay slot. */

/* Pseudo code:

 *   if shift_amt >= 32

 *     dst_high = 0;

 *     dst_low = dst_high >> shift_amt[4:0]

 *   else

 *     dst_high = dst_high >> shift_amt

 *     dst_low = (dst_high, dst_low) >> shift_amt

 *

 * The indirect shift will use the same logic at runtime.

 NOTE: for indirect right shift, LOW part should be calculated first. */

		/* Generate different instruction sequences depending on runtime

		 * value of shift amount.

 shr_reg64_lt32_high packed in delay slot. */

/* Code logic is the same as __shr_imm64 except ashr requires signedness bit

 * told through PREV_ALU result.

 Set signedness bit. */

 NOTE: this also helps setting signedness bit. */

	/* NOTE: the first insn will set both indirect shift amount (source A)

	 * and signedness bit (MSB of result).

	/* NOTE: it is the same as logic shift because we don't need to shift in

	 * signedness bit when the shift amount is less than 32.

 Like ashr_imm64, but need to use indirect shift. */

 ashr_reg64_lt32_high packed in delay slot. */

 Set signedness bit (MSB of result). */

	/* NOTE: the first insn will set both indirect shift amount (source A)

	 * and signedness bit (MSB of result).

 mov is always 1 insn, load imm may be two, so try to use mov */

 Setup PREV_ALU for indirect mode. */

 Cache memory into transfer-in registers. */

 The read length could involve as many as three registers. */

 Calculate the part in the second register. */

 Calculate the part in the third register. */

 sign extend */

 verifier should have rejected bad accesses */

	/* We can fit 16 bits into command immediate, if we know the immediate

	 * is guaranteed to either always or never fit into 16 bit we only

	 * generate code to handle that particular case, otherwise generate

	 * code for both.

 Generate the branch for choosing add_imm vs add */

 defer for add */

 If insn has an offset add to the address */

 Generate the add_imm if 16 bits are possible */

 Generate the add if 16 bits are not guaranteed */

 sign extend */

 sign extend */

	/* Upper word of the mask can only be 0 or ~0 from sign extension,

	 * so either ignore it or OR the whole thing in.

 sign extend */

	/* Space for saving the return address is accounted for by the callee,

	 * so stack_depth can be zero for the main function.

	/* Two cases for jumping to the callee:

	 *

	 * - If callee uses and needs to save R6~R9 then:

	 *     1. Put the start offset of the callee into imm_b(). This will

	 *        require a fixup step, as we do not necessarily know this

	 *        address yet.

	 *     2. Put the return address from the callee to the caller into

	 *        register ret_reg().

	 *     3. (After defer slots are consumed) Jump to the subroutine that

	 *        pushes the registers to the stack.

	 *   The subroutine acts as a trampoline, and returns to the address in

	 *   imm_b(), i.e. jumps to the callee.

	 *

	 * - If callee does not need to save R6~R9 then just load return

	 *   address to the caller in ret_reg(), and jump to the callee

	 *   directly.

	 *

	 * Using ret_reg() to pass the return address to the callee is set here

	 * as a convention. The callee can then push this address onto its

	 * stack frame in its prologue. The advantages of passing the return

	 * address through ret_reg(), instead of pushing it to the stack right

	 * here, are the following:

	 * - It looks cleaner.

	 * - If the called function is called multiple time, we get a lower

	 *   program size.

	 * - We save two no-op instructions that should be added just before

	 *   the emit_br() when stack depth is not null otherwise.

	 * - If we ever find a register to hold the return address during whole

	 *   execution of the callee, we will not have to push the return

	 *   address to the stack for leaf functions.

		/* Pop R6~R9 to the stack via related subroutine.

		 * We loaded the return address to the caller into ret_reg().

		 * This means that the subroutine does not come back here, we

		 * make it jump back to the subprogram caller directly!

 Pop return address from the stack. */

 Pop return address from the stack. */

		/* Jump back to caller if no callee-saved registers were used

		 * by the subprogram.

 --- Assembler logic --- */

		/* For BPF-to-BPF function call, a stack adjustment sequence is

		 * generated after the return instruction. Therefore, we must

		 * withdraw the length of this sequence to have br_idx pointing

		 * to where the "branch" NFP instruction is expected to be.

 Leave special branches for later */

 Save return address into the stack. */

	/* TC direct-action mode:

	 *   0,1   ok        NOT SUPPORTED[1]

	 *   2   drop  0x22 -> drop,  count as stat1

	 *   4,5 nuke  0x02 -> drop

	 *   7  redir  0x44 -> redir, count as stat2

	 *   * unspec  0x11 -> pass,  count as stat0

	 *

	 * [1] We can't support OK and RECLASSIFY because we can't tell TC

	 *     the exact decision made.  We are forced to support UNSPEC

	 *     to handle aborts so that's the only one we handle for passing

	 *     packets up the stack.

 Target for aborts */

 Target for normal exits */

 if R0 > 7 jump to abort */

	/* XDP return codes:

	 *   0 aborted  0x82 -> drop,  count as stat3

	 *   1    drop  0x22 -> drop,  count as stat1

	 *   2    pass  0x11 -> pass,  count as stat0

	 *   3      tx  0x44 -> redir, count as stat2

	 *   * unknown  0x82 -> drop,  count as stat3

 Target for aborts */

 Target for normal exits */

 if R0 > 3 jump to abort */

	/* Subroutine: Save all callee saved registers (R6 ~ R9).

	 * imm_b() holds the return address.

		/* The first slot in the stack frame is used to push the return

		 * address in bpf_to_bpf_call(), start just after.

 Prepare to jump back, last 3 insns use defer slots */

	/* Subroutine: Restore all callee saved registers (R6 ~ R9).

	 * ret_reg() holds the return address.

		/* The first slot in the stack frame holds the return address,

		 * start popping just after that.

 Prepare to jump back, last 3 insns use defer slots */

 --- Optimizations --- */

 Programs converted from cBPF start with register xoring */

 Programs start with R6 = R1 but we ignore the skb pointer */

 Return as soon as something doesn't match */

/* abs(insn.imm) will fit better into unrestricted reg immediate -

 * convert add/sub of a negative number into a sub/add of a positive one.

 Remove masking after load since our load guarantees this is not needed */

/* load/store pair that forms memory copy sould look like the following:

 *

 *   ld_width R, [addr_src + offset_src]

 *   st_width [addr_dest + offset_dest], R

 *

 * The destination register of load and source register of store should

 * be the same, load and store should also perform at the same width.

 * If either of addr_src or addr_dest is stack pointer, we don't do the

 * CPP optimization as stack is modelled by registers on NFP.

 There is jump to the store insn in this pair. */

/* Currently, we only support chaining load/store pairs if:

 *

 *  - Their address base registers are the same.

 *  - Their address offsets are in the same order.

 *  - They operate at the same memory width.

 *  - There is no jump into the middle of them.

 This pair is the start pair. */

 There is jump to the head of this pair. */

 Both in ascending order. */

 Both in descending order. */

/* Return TRUE if cross memory access happens. Cross memory access means

 * store area is overlapping with load area that a later load might load

 * the value from previous store, for this case we can't treat the sequence

 * as an memory copy.

 Different pointer types does not overlap. */

 load and store are both PTR_TO_PACKET, check ID info.  */

	/* Canonicalize the offsets. Turn all of them against the original

	 * base register.

 Ascending order cross. */

 Descending order cross. */

/* This pass try to identify the following instructoin sequences.

 *

 *   load R, [regA + offA]

 *   store [regB + offB], R

 *   load R, [regA + offA + const_imm_A]

 *   store [regB + offB + const_imm_A], R

 *   load R, [regA + offA + 2 * const_imm_A]

 *   store [regB + offB + 2 * const_imm_A], R

 *   ...

 *

 * Above sequence is typically generated by compiler when lowering

 * memcpy. NFP prefer using CPP instructions to accelerate it.

		/* Reset record status if any of the following if true:

		 *   - The current insn pair is not load/store.

		 *   - The load/store pair doesn't chain with previous one.

		 *   - The chained load/store pair crossed with previous pair.

		 *   - The chained load/store pair has a total size of memory

		 *     copy beyond 128 bytes which is the maximum length a

		 *     single NFP CPP command can transfer.

			/* If the chain is ended by an load/store pair then this

			 * could serve as the new head of the the next chain.

		/* Check ID to make sure two reads share the same

		 * variable offset against PTR_TO_PACKET, and check OFF

		 * to make sure they also share the same constant

		 * offset.

		 *

		 * OFFs don't really need to be the same, because they

		 * are the constant offsets against PTR_TO_PACKET, so

		 * for different OFFs, we could canonicalize them to

		 * offsets against original packet pointer. We don't

		 * support this.

 Install new range. */

 Another pass to record jump information. */

		/* If opcode is BPF_CALL at this point, this can only be a

		 * BPF-to-BPF call (a.k.a pseudo call).

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2016-2018 Netronome Systems, Inc. */

	/* Datapath usually can give us guarantees on how much adjust head

	 * can be done without the need for any checks.  Optimize the simple

	 * case where there is only one adjust head by a constant.

 Translator will skip all checks, we need to guarantee min pkt len */

 Only one call per program allowed */

	/* We need to record each time update happens with non-zero words,

	 * in case such word is used in atomic operations.

	 * Implicitly depend on nfp_bpf_stack_arg_ok(reg3) being run before.

 Rest of the checks is only if we re-parse the same insn */

		/* Force current CPU to make sure we can report the event

		 * wherever we get the control message from FW.

		/* Save space in meta, we don't care about arguments other

		 * than 4th meta, shove it into arg1.

 NULL ptr */ &&

		/* Warn user that on offload NFP may return success even if map

		 * is not going to accept the event, since the event output is

		 * fully async and device won't know the state of the map.

		 * There is also FW limitation on the event length.

		 *

		 * Lost events will not show up on the perf ring, driver

		 * won't see them at all.  Events may also get reordered.

 XDP ctx accesses must be 4B in size */

	/* NFP supports u16 and u32 multiplication.

	 *

	 * For ALU64, if either operand is beyond u32's value range, we reject

	 * it. One thing to note, if the source operand is BPF_K, then we need

	 * to check "imm" field directly, and we'd reject it if it is negative.

	 * Because for ALU64, "imm" (with s32 type) is expected to be sign

	 * extended to s64 which NFP mul doesn't support.

	 *

	 * For ALU32, it is fine for "imm" be negative though, because the

	 * result is 32-bits and there is no difference on the low halve of

	 * the result for signed/unsigned mul, so we will get correct result.

	/* NFP doesn't have divide instructions, we support divide by constant

	 * through reciprocal multiplication. Given NFP support multiplication

	 * no bigger than u32, we'd require divisor and dividend no bigger than

	 * that as well.

	 *

	 * Also eBPF doesn't support signed divide and has enforced this on C

	 * language level by failing compilation. However LLVM assembler hasn't

	 * enforced this, so it is possible for negative constant to leak in as

	 * a BPF_K operand through assembly code, we reject such cases as well.

	/* Inspired from check_max_stack_depth() from kernel verifier.

	 * Starting from main subprogram, walk all instructions and recursively

	 * walk all callees that given subprogram can call. Since recursion is

	 * prevented by the kernel verifier, this algorithm only needs a local

	 * stack of MAX_CALL_FRAMES to remember callsites.

		/* We found a call to a subprogram. Remember instruction to

		 * return to and subprog id.

 Find the callee and start processing it. */

	/* End of for() loop means the last instruction of the subprog was

	 * reached. If we popped all stack frames, return; otherwise, go on

	 * processing remaining instructions from the caller.

 Account for size of return address. */

 Account for size of saved registers, if necessary. */

 conditional jump to jump conversion */

 doesn't count if it already has the flag */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2017-2018 Netronome Systems, Inc. */

 Only support TC direct action */

 Don't remove if oldprog doesn't match driver's state */

 Original BPF ABI version */

/*------------------------------------------------------------------------

 . smc9194.c

 . This is a driver for SMC's 9000 series of Ethernet cards.

 .

 . Copyright (C) 1996 by Erik Stahlman

 . This software may be used and distributed according to the terms

 . of the GNU General Public License, incorporated herein by reference.

 .

 . "Features" of the SMC chip:

 .   4608 byte packet memory. ( for the 91C92.  Others have more )

 .   EEPROM for configuration

 .   AUI/TP selection  ( mine has 10Base2/10BaseT select )

 .

 . Arguments:

 . 	io		 = for the base address

 .	irq	 = for the IRQ

 .	ifport = 0 for autodetect, 1 for TP, 2 for AUI ( or 10base2 )

 .

 . author:

 . 	Erik Stahlman				( erik@vt.edu )

 . contributors:

 .      Arnaldo Carvalho de Melo <acme@conectiva.com.br>

 .

 . Hardware multicast code from Peter Cammaert ( pc@denkart.be )

 .

 . Sources:

 .    o   SMC databook

 .    o   skeleton.c by Donald Becker ( becker@scyld.com )

 .    o   ( a LOT of advice from Becker as well )

 .

 . History:

 .	12/07/95  Erik Stahlman  written, got receive/xmit handled

 . 	01/03/96  Erik Stahlman  worked out some bugs, actually usable!!! :-)

 .	01/06/96  Erik Stahlman	 cleaned up some, better testing, etc

 .	01/29/96  Erik Stahlman	 fixed autoirq, added multicast

 . 	02/01/96  Erik Stahlman	 1. disabled all interrupts in smc_reset

 .		   		 2. got rid of post-decrementing bug -- UGH.

 .	02/13/96  Erik Stahlman  Tried to fix autoirq failure.  Added more

 .				 descriptive error messages.

 .	02/15/96  Erik Stahlman  Fixed typo that caused detection failure

 . 	02/23/96  Erik Stahlman	 Modified it to fit into kernel tree

 .				 Added support to change hardware address

 .				 Cleared stats on opens

 .	02/26/96  Erik Stahlman	 Trial support for Kernel 1.2.13

 .				 Kludge for automatic IRQ detection

 .	03/04/96  Erik Stahlman	 Fixed kernel 1.3.70 +

 .				 Fixed bug reported by Gardner Buchanan in

 .				   smc_enable, with outw instead of outb

 .	03/06/96  Erik Stahlman  Added hardware multicast from Peter Cammaert

 .	04/14/00  Heiko Pruessing (SMA Regelsysteme)  Fixed bug in chip memory

 .				 allocation

 .      08/20/00  Arnaldo Melo   fix kfree(skb) in smc_hardware_send_packet

 .      12/15/00  Christian Jullien fix "Warning: kfree_skb on hard IRQ"

 .      11/08/01 Matt Domsch     Use common crc32 function

/*------------------------------------------------------------------------

 .

 . Configuration options, for the experienced user to change.

 .

/*

 . Do you want to use 32 bit xfers?  This should work on all chips, as

 . the chipset is designed to accommodate them.

/*

 .the SMC9194 can be at any of the following port addresses.  To change,

 .for a slightly different card, you can add it to the array.  Keep in

 .mind that the array must end in zero.

/*

 . Wait time for memory to be free.  This probably shouldn't be

 . tuned that much, as waiting for this means nothing else happens

 . in the system

/*

 . DEBUGGING LEVELS

 .

 . 0 for normal operation

 . 1 for slightly more details

 . >2 for various levels of increasingly useless information

 .    2 for interrupt tracking, status flags

 .    3 for packet dumps, etc.

/*------------------------------------------------------------------------

 .

 . The internal workings of the driver.  If you are changing anything

 . here with the SMC stuff, you should have the datasheet and known

 . what you are doing.

 .

 store this information for the driver.. */

	/*

	   If I have to wait until memory is available to send

	   a packet, I will store the skbuff here, until I get the

	   desired memory.  Then, I'll send it out and free it.

	/*

	 . This keeps track of how many packets that I have

	 . sent out.  When an TX_EMPTY interrupt comes, I know

	 . that all of these have been sent.

/*-----------------------------------------------------------------

 .

 .  The driver can be entered at any of the following entry points.

 .

/*

 . This is called by  register_netdev().  It is responsible for

 . checking the portlist for the SMC9000 series chipset.  If it finds

 . one, then it will initialize the device, find the hardware information,

 . and sets up the appropriate device parameters.

 . NOTE: Interrupts are *OFF* when this procedure is called.

 .

 . NB:This shouldn't be static since it is referred to externally.

/*

 . The kernel calls this function when someone wants to use the device,

 . typically 'ifconfig ethX up'.

/*

 . Our watchdog timed out. Called by the networking layer

/*

 . This is called by the kernel in response to 'ifconfig ethX down'.  It

 . is responsible for cleaning up everything that the open routine

 . does, and maybe putting the card into a powerdown state.

/*

 . Finally, a call to set promiscuous mode ( for TCPDUMP and related

 . programs ) and multicast modes.

/*---------------------------------------------------------------

 .

 . Interrupt level calls..

 .

/*

 . Handles the actual interrupt

/*

 . This is a separate procedure to handle the receipt of a packet, to

 . leave the interrupt code looking slightly cleaner

/*

 . This handles a TX interrupt, which is only called when an error

 . relating to a packet is sent.

/*

 ------------------------------------------------------------

 .

 . Internal routines

 .

 ------------------------------------------------------------

/*

 . Test if a given location contains a chip, trying to cause as

 . little damage as possible if it's not a SMC chip.

/*

 . A rather simple routine to print out a packet for debugging purposes.

 this is called to actually send the packet to the chip */

/* Since I am not sure if I will have enough room in the chip's ram

 . to store the packet, I call this routine, which either sends it

 . now, or generates an interrupt when the card is ready for the

 this does a soft reset on the device */

 Enable Interrupts, Receive, and Transmit */

 this puts the device in an inactive state */

/* This routine will find the IRQ of the driver if one is not

/*

 . Function: smc_reset( int ioaddr )

 . Purpose:

 .  	This sets the SMC91xx chip to its normal state, hopefully from whatever

 . 	mess that any other DOS driver has put it in.

 .

 . Maybe I should reset more registers to defaults in here?  SOFTRESET  should

 . do that for me.

 .

 . Method:

 .	1.  send a SOFT RESET

 .	2.  wait for it to finish

 .	3.  enable autorelease mode

 .	4.  reset the memory management unit

 .	5.  clear all interrupts

 .

	/* This resets the registers mostly to defaults, but doesn't

 this should pause enough for the chip to be happy */

	/* Set the transmit and receive configuration registers to

	/* set the control register to automatically

	   release successfully transmitted packets, to make the best

 Reset the MMU */

	/* Note:  It doesn't seem that waiting for the MMU busy is needed here,

	   but this is a place where future chipsets _COULD_ break.  Be wary

/*

 . Function: smc_enable

 . Purpose: let the chip talk to the outside work

 . Method:

 .	1.  Enable the transmitter

 .	2.  Enable the receiver

 .	3.  Enable interrupts

 see the header file for options in TCR/RCR NORMAL*/

 now, enable interrupts */

/*

 . Function: smc_shutdown

 . Purpose:  closes down the SMC91xxx chip.

 . Method:

 .	1. zero the interrupt mask

 .	2. clear the enable receive flag

 .	3. clear the enable xmit flags

 .

 . TODO:

 .   (1) maybe utilize power down mode.

 .	Why not yet?  Because while the chip will go into power down mode,

 .	the manual says that it will wake up in response to any I/O requests

 .	in the register space.   Empirical results do not show this working.

 no more interrupts for me */

 and tell the card to stay away from that nasty outside world */

 finally, shut the chip down */

/*

 . Function: smc_setmulticast( int ioaddr, struct net_device *dev )

 . Purpose:

 .    This sets the internal hardware table to filter out unwanted multicast

 .    packets before they take up memory.

 .

 .    The SMC chip uses a hash table where the high 6 bits of the CRC of

 .    address are the offset into the table.  If that bit is 1, then the

 .    multicast packet is accepted.  Otherwise, it's dropped silently.

 .

 .    To use the 6 bits as an offset into the table, the high 3 bits are the

 .    number of the 8 bit register, while the low 3 bits are the bit within

 .    that register.

 .

 . This routine is based very heavily on the one provided by Peter Cammaert.

 table for flipping the order of 3 bits */

 start with a table of all zeros: reject all */

 only use the low order bits */

 do some messy swapping to put the bit in the right spot */

 now, the table can be loaded into the chipset */

/*

 . Function: smc_wait_to_send_packet( struct sk_buff * skb, struct net_device * )

 . Purpose:

 .    Attempt to allocate memory for a packet, if chip-memory is not

 .    available, then tell the card to generate an interrupt when it

 .    is available.

 .

 . Algorithm:

 .

 . o	if the saved_skb is not currently null, then drop this packet

 .	on the floor.  This should never happen, because of TBUSY.

 . o	if the saved_skb is null, then replace it with the current packet,

 . o	See if I can sending it now.

 . o 	(NO): Enable interrupts and let the interrupt handler deal with it.

 . o	(YES):Send it now.

	/* Well, I want to send the packet.. but I don't know

 THIS SHOULD NEVER HAPPEN. */

	/*

	** The MMU wants the number of pages to be the number of 256 bytes

	** 'pages', minus 1 ( since a packet can't ever have 0 pages :) )

	**

	** Pkt size for allocating is data length +6 (for additional status words,

	** length and ctl!) If odd size last byte is included in this header.

		/* freeing the packet is a good thing here... but should

 this IS an error, but, i don't want the skb saved */

 either way, a packet is waiting now */

 now, try to allocate the memory */

	/*

	. Performance Hack

	.

	. wait a short amount of time.. if I can send a packet now, I send

	. it now.  Otherwise, I enable an interrupt and wait for one to be

	. available.

	.

	. I could have handled this a slightly different way, by checking to

	. see if any memory was available in the FREE MEMORY register.  However,

	. either way, I need to generate an allocation, and the allocation works

	. no matter what, so I saw no point in checking free memory.

 acknowledge the interrupt */

 oh well, wait until the chip finds memory later */

 it's deferred, but I'll handle it later */

 or YES! I can send the packet now.. */

/*

 . Function:  smc_hardware_send_packet(struct net_device * )

 . Purpose:

 .	This sends the actual packet to the SMC9xxx chip.

 .

 . Algorithm:

 . 	First, see if a saved_skb is available.

 .		( this should NOT be called if there is no 'saved_skb'

 .	Now, find the packet number that the chip allocated

 .	Point the data pointers at it in memory

 .	Set the length word in the chip's memory

 .	Dump the packet to chip memory

 .	Check if a last byte is needed ( odd length packet )

 .		if so, set the control flag right

 . 	Tell the card to send it

 .	Enable the transmit interrupt, so I know if it failed

 . 	Free the kernel data if I actually sent it.

 If I get here, I _know_ there is a packet slot waiting for me */

 or isn't there?  BAD CHIP! */

 we have a packet address, so tell the card to use it */

 point to the beginning of the packet */

	/* send the packet length ( +6 for status, length and ctl byte )

 send the packet length ( +6 for status words, length, and ctl*/

	/* send the actual data

	 . I _think_ it's faster to send the longs first, and then

	 . mop up by sending the last word.  It depends heavily

	 . on alignment, at least on the 486.  Maybe it would be

	 . a good idea to check which is optimal?  But that could take

	 . almost as much time as is saved?

 Send the last byte, if there is one.   */

 enable the interrupts */

 and let the chipset deal with it */

 we can send another packet */

/*-------------------------------------------------------------------------

 |

 | smc_init(int unit)

 |   Input parameters:

 |	dev->base_addr == 0, try to find all possible locations

 |	dev->base_addr == 1, return failure code

 |	dev->base_addr == 2, always allocate space,  and return success

 |	dev->base_addr == <anything else>   this is the address to check

 |

 |   Output:

 |	pointer to net_device or ERR_PTR(error)

 |

 ---------------------------------------------------------------------------

 Check a single specified location. */

 Don't probe at all. */

/*----------------------------------------------------------------------

 . smc_findirq

 .

 . This routine has a simple purpose -- make the SMC chip generate an

 . interrupt, so an auto-detect routine can detect it, and find the IRQ,

 ------------------------------------------------------------------------

	/*

	 * What I try to do here is trigger an ALLOC_INT. This is done

	 * by allocating a small chunk of memory, which will give an interrupt

	 * when done.

 enable ALLOCation interrupts ONLY */

	/*

	 . Allocate 512 bytes of memory.  Note that the chip was just

	 . reset so all the memory is available

	/*

	 . Wait until positive that the interrupt has been generated

 got the interrupt */

	/* there is really nothing that I can do here if timeout fails,

	   as probe_irq_off will return a 0 anyway, which is what I

	   want in this case.   Plus, the clean up is needed in both

	/* DELAY HERE!

	   On a fast machine, the status might change before the interrupt

	   is given to the processor.  This means that the interrupt was

	   never detected, and probe_irq_off fails to report anything.

	   This should fix probe_irq_* problems.

 and disable all interrupts again */

 and return what I found */

 NO_AUTOPROBE */

/*----------------------------------------------------------------------

 . Function: smc_probe( int ioaddr )

 .

 . Purpose:

 .	Tests to see if a given ioaddr points to an SMC9xxx chip.

 .	Returns a 0 on success

 .

 . Algorithm:

 .	(1) see if the high byte of BANK_SELECT is 0x33

 . 	(2) compare the ioaddr with the base register's address

 .	(3) see if I recognize the chip ID in the appropriate register

 .

 .---------------------------------------------------------------------

/*---------------------------------------------------------------

 . Here I do typical initialization tasks.

 .

 . o  Initialize the structure if needed

 . o  print out my vanity message if not done so already

 . o  print out what type of hardware is detected

 . o  print out the ethernet address

 . o  find the IRQ

 . o  set up my private data

 . o  configure the dev structure with my subroutines

 . o  actually GRAB the irq.

 . o  GRAB the region

 .-----------------------------------------------------------------

 registers */

 Grab the region so that no one else tries to probe our ioports. */

 First, see if the high byte is 0x33 */

	/* The above MIGHT indicate a device, but I need to write to further

	/* well, we've already written once, so hopefully another time won't

	   hurt.  This time, I need to switch the bank register to bank 1,

		/* well, the base address register didn't match.  Must not have

	/*  check if the revision register is something that I recognize.

	    These might need to be added to later, as future revisions

 I don't recognize this chip, so... */

	/* at this point I'll assume that the chip is an SMC9xxx.

	   It might be prudent to check a listing of MAC addresses

 fill in some of the fields */

	/*

	 . Get the MAC address ( bank 1, regs 4 - 9 )

 get the memory information */

 multiplier */

	/*

	 Now, I want to find out more about the chip.  This is sort of

	 redundant, but it's cleaner to have it in both, rather than having

	 one VERY long probe procedure.

 I shouldn't get here because this call was done before.... */

 is it using AUI or 10BaseT ? */

 now, reset the chip, and put it into a known state */

	/*

	 . If dev->irq is 0, then the device has to be banged on to see

	 . what the IRQ is.

	 .

	 . This banging doesn't always detect the IRQ, for unknown reasons.

	 . a workaround is to reset the chip and try again.

	 .

	 . Interestingly, the DOS packet driver *SETS* the IRQ on the card to

	 . be what is requested on the command line.   I don't do that, mostly

	 . because the card that I have uses a non-standard method of accessing

	 . the IRQs, and because this _should_ work in most configurations.

	 .

	 . Specifying an IRQ is done with the assumption that the user knows

	 . what (s)he is doing.  No checking is done!!!!

	 .

 kick the card and try again */

 now, print out the card info, in a short format.. */

	/*

	 . Print the Ethernet address

 Grab the IRQ */

/*

 * Open and Initialize the board

 *

 * Set up everything, reset the card, etc ..

 *

 used to set hw ethernet address */

 clear out all the junk that was put here before... */

 reset the hardware */

 Select which interface to use */

	/*

		According to Becker, I have to set the hardware address

		at this point, because the (l)user can set it with an

		ioctl.  Easily done...

/*--------------------------------------------------------

 . Called by the kernel to send a packet out into the void

 . of the net.  This routine is largely based on

 . skeleton.c, from Becker.

 .--------------------------------------------------------

	/* If we get here, some higher level has decided we are broken.

 "kick" the adaptor */

 prevent tx timeout */

 clear anything saved */

/*-------------------------------------------------------------

 .

 . smc_rcv -  receive a packet from the card

 .

 . There is ( at least ) a packet waiting to be read from

 . chip-memory.

 .

 . o Read the status

 . o If an error, record it

 . o otherwise, read in the packet

 --------------------------------------------------------------

 assume bank 2 */

 we got called , but nothing was on the FIFO */

 don't need to restore anything */

  start reading from the start of the packet */

 First two words are status and packet_length */

 mask off top bits */

	/*

	 . the packet length contains 3 extra words :

	 . status, length, and an extra word with an odd byte .

 do stuff to make a new packet */

 read one extra byte */

 set multicast stats */

		/*

		 ! This should work without alignment, but it could be

		 ! in the worse case

 16 bit alignment */

		/* QUESTION:  Like in the TX routine, do I want

		   to send the DWORDs or the bytes first, or some

		   mixture.  A mixture might improve already slow PIO

 read the left over bytes */

 error ... */

  error or good, tell the card to get rid of this packet */

/*************************************************************************

 . smc_tx

 .

 . Purpose:  Handle a transmit error message.   This will only be called

 .   when an error, because of the AUTO_RELEASE mode.

 .

 . Algorithm:

 .	Save pointer and packet no

 .	Get the packet no from the top of the queue

 .	check if it's valid ( if not, is this an error??? )

 .	read the status word

 .	record the error

 .	( resend?  Not really, since we don't want old packets around )

 .	Restore saved values

 assume bank 2  */

 select this as the packet to read from */

 read the first word from this packet */

 re-enable transmit */

 kill the packet */

 one less packet waiting for me */

/*--------------------------------------------------------------------

 .

 . This is the main routine of the driver, to handle the device when

 . it needs some attention.

 .

 . So:

 .   first, save state of the chipset

 .   branch off into routines to handle each case, and acknowledge

 .	    each to the interrupt register

 .   and finally restore state.

 .

 state registers */

 clear all interrupts */

 set a timeout value, so I don't stay here forever */

 read the status flag, and mask it */

 Got a packet(s). */

 update stats */

 single collisions */

 multiple collisions */

 these are for when linux supports these statistics */

 clear this interrupt so it doesn't happen again */

 enable xmit interrupts based on this */

 and let the card send more packets to me */

 restore state register */

/*----------------------------------------------------

 . smc_close

 .

 . this makes the board clean up everything that it can

 . and not talk to the outside world.   Caused by

 . an 'ifconfig ethX down'

 .

 clear everything */

 Update the statistics here. */

/*-----------------------------------------------------------

 . smc_set_multicast_list

 .

 . This routine will, depending on the values passed to it,

 . either make it accept multicast packets, go into

 . promiscuous mode ( for TCPDUMP and cousins ) or accept

 . a select set of multicast packets

/* BUG?  I never disable promiscuous mode if multicasting was turned on.

   Now, I turn off promiscuous mode, but I don't do anything to multicasting

   when promiscuous mode is turned on.

	/* Here, I am setting this to accept all multicast packets.

	   I don't need to zero the multicast table, because the flag is

	   checked before the table is

	/* We just get all multicast packets even if we only want them

	 . from one source.  This will be changed at some future

 support hardware multicasting */

 be sure I get rid of flags I might have set */

		/* NOTE: this has to set the bank, so make sure it is the

		/*

		  since I'm disabling all multicast entirely, I need to

		  clear the multicast list

 copy the parameters from insmod into the device structure */

 MODULE */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * smc91x.c

 * This is a driver for SMSC's 91C9x/91C1xx single-chip Ethernet devices.

 *

 * Copyright (C) 1996 by Erik Stahlman

 * Copyright (C) 2001 Standard Microsystems Corporation

 *	Developed by Simple Network Magic Corporation

 * Copyright (C) 2003 Monta Vista Software, Inc.

 *	Unified SMC91x driver by Nicolas Pitre

 *

 * Arguments:

 * 	io	= for the base address

 *	irq	= for the IRQ

 *	nowait	= 0 for normal wait states, 1 eliminates additional wait states

 *

 * original author:

 * 	Erik Stahlman <erik@vt.edu>

 *

 * hardware multicast code:

 *    Peter Cammaert <pc@denkart.be>

 *

 * contributors:

 * 	Daris A Nevil <dnevil@snmc.com>

 *      Nicolas Pitre <nico@fluxnic.net>

 *	Russell King <rmk@arm.linux.org.uk>

 *

 * History:

 *   08/20/00  Arnaldo Melo       fix kfree(skb) in smc_hardware_send_packet

 *   12/15/00  Christian Jullien  fix "Warning: kfree_skb on hard IRQ"

 *   03/16/01  Daris A Nevil      modified smc9194.c for use with LAN91C111

 *   08/22/01  Scott Anderson     merge changes from smc9194 to smc91111

 *   08/21/01  Pramod B Bhardwaj  added support for RevB of LAN91C111

 *   12/20/01  Jeff Sutherland    initial port to Xscale PXA with DMA support

 *   04/07/03  Nicolas Pitre      unified SMC91x driver, killed irq races,

 *                                more bus abstraction, big cleanup, etc.

 *   29/09/03  Russell King       - add driver model support

 *                                - ethtool support

 *                                - convert to use generic MII interface

 *                                - add link up/down notification

 *                                - don't try to handle full negotiation in

 *                                  smc_phy_configure

 *                                - clean up (and fix stack overrun) in PHY

 *                                  MII read/write functions

 *   22/09/04  Nicolas Pitre      big update (see commit log for details)

 Debugging level */

/*

 * Transmit timeout, default 5 seconds.

/*

 * The internal workings of the driver.  If you are changing anything

 * here with the SMC stuff, you should have the datasheet and know

 * what you are doing.

/*

 * Use power-down feature of the chip

/*

 * Wait time for memory to be free.  This probably shouldn't be

 * tuned that much, as waiting for this means nothing else happens

 * in the system

/*

 * The maximum number of processing loops allowed for each call to the

 * IRQ handler.

/*

 * This selects whether TX packets are sent one by one to the SMC91x internal

 * memory and throttled until transmission completes.  This may prevent

 * RX overruns a litle by keeping much of the memory free for RX packets

 * but to the expense of reduced TX throughput and increased IRQ overhead.

 * Note this is not a cure for a too slow data bus or too high IRQ latency.

/*

 * The MII clock high/low times.  2x this number gives the MII clock period

 * in microseconds. (was 50, but this gives 6.4ms for each MII transaction!)

 this enables an interrupt in the interrupt mask register */

 this disables an interrupt from the interrupt mask register */

/*

 * Wait while MMU is busy.  This is usually in the order of a few nanosecs

 * if at all, but let's avoid deadlocking the system if the hardware

 * decides to go south.

/*

 * this does a soft reset on the device

 Disable all interrupts, block TX tasklet */

 free any pending tx skb */

	/*

	 * This resets the registers mostly to defaults, but doesn't

	 * affect EEPROM.  That seems unnecessary

	/*

	 * Setup the Configuration Register

	 * This is necessary because the CONFIG_REG is not affected

	 * by a soft reset

	/*

	 * Setup for fast accesses if requested.  If the card/system

	 * can't handle it then there will be no recovery except for

	 * a hard reset or power cycle

	/*

	 * Release from possible power-down state

	 * Configuration register is not affected by Soft Reset

 this should pause enough for the chip to be happy */

	/*

	 * elaborate?  What does the chip _need_? --jgarzik

	 *

	 * This seems to be undocumented, but something the original

	 * driver(s) have always done.  Suspect undocumented timing

	 * info/determined empirically. --rmk

 Disable transmit and receive functionality */

	/*

	 * Set the control register to automatically release successfully

	 * transmitted packets, to make the best use out of our limited

	 * memory

 Reset the MMU */

/*

 * Enable Interrupts, Receive, and Transmit

 see the header file for options in TCR/RCR DEFAULT */

 now, enable interrupts */

	/*

	 * From this point the register bank must _NOT_ be switched away

	 * to something else than bank 2 without proper locking against

	 * races with any tasklet or interrupt handlers until smc_shutdown()

	 * or smc_reset() is called.

/*

 * this puts the device in an inactive state

 no more interrupts for me */

 and tell the card to stay away from that nasty outside world */

 finally, shut the chip down */

/*

 * This is the procedure to handle the receipt of a packet.

 read from start of packet */

 First two words are status and packet length */

 mask off top bits */

 accept VLAN packets */

 bloody hardware */

 set multicast stats */

		/*

		 * Actual payload is packet_len - 6 (or 5 if odd byte).

		 * We want skb_reserve(2) and the final ctrl word

		 * (2 bytes, possibly containing the payload odd byte).

		 * Furthermore, we add 2 bytes to allow rounding up to

		 * multiple of 4 bytes on 32 bit buses.

		 * Hence packet_len - 6 + 2 + 2 + 2.

 Align IP header to 32 bits */

 BUG: the LAN91C111 rev A never sets this bit. Force it. */

		/*

		 * If odd length: packet_len - 5,

		 * otherwise packet_len - 6.

		 * With the trailing ctrl byte it's packet_len - 4.

/*

 * On SMP we have the following problem:

 *

 * 	A = smc_hardware_send_pkt()

 * 	B = smc_hard_start_xmit()

 * 	C = smc_interrupt()

 *

 * A and B can never be executed simultaneously.  However, at least on UP,

 * it is possible (and even desirable) for C to interrupt execution of

 * A or B in order to have better RX reliability and avoid overruns.

 * C, just like A and B, must have exclusive access to the chip and

 * each of them must lock against any other concurrent access.

 * Unfortunately this is not possible to have C suspend execution of A or

 * B taking place on another CPU. On UP this is no an issue since A and B

 * are run from softirq context and C from hard IRQ context, and there is

 * no other CPU where concurrent access can happen.

 * If ever there is a way to force at least B and C to always be executed

 * on the same CPU then we could use read/write locks to protect against

 * any other concurrent access and C would always interrupt B. But life

 * isn't that easy in a SMP world...

/*

 * This is called to actually send a packet to the chip.

 point to the beginning of the packet */

	/*

	 * Send the packet length (+6 for status words, length, and ctl.

	 * The card will pad to 64 bytes with zeroes if packet is too small.

 send the actual data */

 Send final ctl word with the last byte if there is one */

	/*

	 * If THROTTLE_TX_PKTS is set, we stop the queue here. This will

	 * have the effect of having at most one packet queued for TX

	 * in the chip's memory at all time.

	 *

	 * If THROTTLE_TX_PKTS is not set then the queue is stopped only

	 * when memory allocation (MC_ALLOC) does not succeed right away.

 queue the packet for TX */

/*

 * Since I am not sure if I will have enough room in the chip's ram

 * to store the packet, I call this routine which either sends it

 * now, or set the card to generates an interrupt when ready

 * for the packet.

	/*

	 * The MMU wants the number of pages to be the number of 256 bytes

	 * 'pages', minus 1 (since a packet can't ever have 0 pages :))

	 *

	 * The 91C111 ignores the size bits, but earlier models don't.

	 *

	 * Pkt size for allocating is data length +6 (for additional status

	 * words, length and ctl)

	 *

	 * If odd size then last byte is included in ctl word.

 now, try to allocate the memory */

	/*

	 * Poll the chip for a short amount of time in case the

	 * allocation succeeds quickly.

 oh well, wait until the chip finds memory later */

		/*

		 * Allocation succeeded: push packet to the chip's own memory

		 * immediately.

/*

 * This handles a TX interrupt, which is only called when:

 * - a TX error occurred, or

 * - CTL_AUTO_RELEASE is not set and TX of a packet completed.

 If the TX FIFO is empty then nothing to do */

 select packet to read from */

 read the first word (status word) from this packet */

 kill the packet */

 Don't restore Packet Number Reg until busy bit is cleared */

 re-enable transmit */

---PHY CONTROL AND CONFIGURATION-----------------------------------------*/

/*

 * Reads a register from the MII Management serial interface

 Idle - 32 ones */

 Start code (01) + read (10) + phyaddr + phyreg */

 Turnaround (2bits) + phydata */

 Return to idle state */

/*

 * Writes a register to the MII Management serial interface

 Idle - 32 ones */

 Start code (01) + write (01) + phyaddr + phyreg + turnaround + phydata */

 Return to idle state */

/*

 * Finds and reports the PHY address

	/*

	 * Scan all 32 PHY addresses if necessary, starting at

	 * PHY#1 to PHY#31, and then PHY#0 last.

 Read the PHY identifiers */

 Make sure it is a valid identifier */

 Save the PHY's address */

/*

 * Sets the PHY to a configuration as determined by the user

 Enter Link Disable state */

	/*

	 * Set our fixed capabilities

	 * Disable auto-negotiation

 Write our capabilities to the phy control register */

 Re-Configure the Receive/Phy Control register */

/**

 * smc_phy_reset - reset the phy

 * @dev: net device

 * @phy: phy address

 *

 * Issue a software reset for the specified PHY and

 * wait up to 100ms for the reset to complete.  We should

 * not access the PHY for 50ms after issuing the reset.

 *

 * The time to wait appears to be dependent on the PHY.

 *

 * Must be called with lp->lock locked.

/**

 * smc_phy_powerdown - powerdown phy

 * @dev: net device

 *

 * Power down the specified PHY

	/* We need to ensure that no calls to smc_phy_configure are

	   pending.

/**

 * smc_phy_check_media - check the media status and adjust TCR

 * @dev: net device

 * @init: set true for initialisation

 *

 * Select duplex mode depending on negotiation state.  This

 * also updates our carrier state.

 duplex state has changed */

/*

 * Configures the specified PHY through the MII management interface

 * using Autonegotiation.

 * Calls smc_phy_fixed() if the user has requested a certain config.

 * If RPC ANEG bit is set, the media selection is dependent purely on

 * the selection by the MII (either in the MII BMCR reg or the result

 * of autonegotiation.)  If the RPC ANEG bit is cleared, the selection

 * is controlled by the RPC SPEED and RPC DPLX bits.

 My PHY capabilities */

 My Advertised capabilities */

	/*

	 * We should not be called if phy_type is zero.

	/*

	 * Enable PHY Interrupts (for register 18)

	 * Interrupts listed here are disabled

 Configure the Receive/Phy Control register */

 If the user requested no auto neg, then go set his request */

 Copy our capabilities from MII_BMSR to MII_ADVERTISE */

 I am CSMA capable */

 Disable capabilities not selected by our user */

 Update our Auto-Neg Advertisement Register */

	/*

	 * Read the register back.  Without this, it appears that when

	 * auto-negotiation is restarted, sometimes it isn't ready and

	 * the link does not come up.

 Restart auto-negotiation process in order to advertise my caps */

/*

 * smc_phy_interrupt

 *

 * Purpose:  Handle interrupts relating to PHY register 18. This is

 *  called from the "hard" interrupt handler under our private spinlock.

 Read PHY Register 18, Status Output */

--- END PHY CONTROL AND CONFIGURATION-------------------------------------*/

/*

 * This is the main routine of the driver, to handle the device when

 * it needs some attention.

	/* A preamble may be used when there is a potential race

	 * between the interruptible transmit functions and this

 set a timeout value, so I don't stay here forever */

 do this before RX as it will free memory quickly */

 update stats */

 single collisions */

 multiple collisions */

 restore register states */

	/*

	 * We return IRQ_HANDLED unconditionally here even if there was

	 * nothing to do.  There is a possibility that a packet might

	 * get enqueued into the chip right after TX_EMPTY_INT is raised

	 * but just before the CPU acknowledges the IRQ.

	 * Better take an unneeded IRQ in some occasions than complexifying

	 * the code for all cases.

/*

 * Polling receive - used by netconsole and other diagnostic tools

 * to allow network i/o with interrupts disabled.

 Our watchdog timed out. Called by the networking layer */

	/*

	 * Reconfiguring the PHY doesn't seem like a bad idea here, but

	 * smc_phy_configure() calls msleep() which calls schedule_timeout()

	 * which calls schedule().  Hence we use a work queue.

 We can accept TX packets again */

 prevent tx timeout */

/*

 * This routine will, depending on the values passed to it,

 * either make it accept multicast packets, go into

 * promiscuous mode (for TCPDUMP and cousins) or accept

 * a select set of multicast packets

/* BUG?  I never disable promiscuous mode if multicasting was turned on.

   Now, I turn off promiscuous mode, but I don't do anything to multicasting

   when promiscuous mode is turned on.

	/*

	 * Here, I am setting this to accept all multicast packets.

	 * I don't need to zero the multicast table, because the flag is

	 * checked before the table is

	/*

	 * This sets the internal hardware table to filter out unwanted

	 * multicast packets before they take up memory.

	 *

	 * The SMC chip uses a hash table where the high 6 bits of the CRC of

	 * address are the offset into the table.  If that bit is 1, then the

	 * multicast packet is accepted.  Otherwise, it's dropped silently.

	 *

	 * To use the 6 bits as an offset into the table, the high 3 bits are

	 * the number of the 8 bit register, while the low 3 bits are the bit

	 * within that register.

 table for flipping the order of 3 bits */

 start with a table of all zeros: reject all */

 only use the low order bits */

 do some messy swapping to put the bit in the right spot */

 be sure I get rid of flags I might have set */

 now, the table can be loaded into the chipset */

		/*

		 * since I'm disabling all multicast entirely, I need to

		 * clear the multicast list

/*

 * Open and Initialize the board

 *

 * Set up everything, reset the card, etc..

 Setup the default Register Modes */

	/*

	 * If we are not using a MII interface, we need to

	 * monitor our own carrier signal to detect faults.

 reset the hardware */

 Configure the PHY, initialize the link state */

/*

 * smc_close

 *

 * this makes the board clean up everything that it can

 * and not talk to the outside world.   Caused by

 * an 'ifconfig ethX down'

 clear everything */

/*

 * Ethtool support

		lp->port = cmd->base.port;

		if (netif_running(dev))

			smc_set_port(dev);

 load word into GP register */

 set the address to put the data in EEPROM */

 tell it to write */

 wait for it to finish */

 clean up */

 set the EEPROM address to get the data from */

 tell it to load */

 init to known */

 wait for it to finish */

 read word from GP register */

 clean up */

/*

 * smc_findirq

 *

 * This routine has a simple purpose -- make the SMC chip generate an

 * interrupt, so an auto-detect routine can detect it, and find the IRQ,

/*

 * does this still work?

 *

 * I just deleted auto_irq.c, since it was never built...

 *   --jgarzik

	/*

	 * What I try to do here is trigger an ALLOC_INT. This is done

	 * by allocating a small chunk of memory, which will give an interrupt

	 * when done.

 enable ALLOCation interrupts ONLY */

	/*

	 * Allocate 512 bytes of memory.  Note that the chip was just

	 * reset so all the memory is available

	/*

	 * Wait until positive that the interrupt has been generated

 got the interrupt */

	/*

	 * there is really nothing that I can do here if timeout fails,

	 * as autoirq_report will return a 0 anyway, which is what I

	 * want in this case.   Plus, the clean up is needed in both

	 * cases.

 and disable all interrupts again */

 and return what I found */

/*

 * Function: smc_probe(unsigned long ioaddr)

 *

 * Purpose:

 *	Tests to see if a given ioaddr points to an SMC91x chip.

 *	Returns a 0 on success

 *

 * Algorithm:

 *	(1) see if the high byte of BANK_SELECT is 0x33

 * 	(2) compare the ioaddr with the base register's address

 *	(3) see if I recognize the chip ID in the appropriate register

 *

 * Here I do typical initialization tasks.

 *

 * o  Initialize the structure if needed

 * o  print out my vanity message if not done so already

 * o  print out what type of hardware is detected

 * o  print out the ethernet address

 * o  find the IRQ

 * o  set up my private data

 * o  configure the dev structure with my subroutines

 * o  actually GRAB the irq.

 * o  GRAB the region

 First, see if the high byte is 0x33 */

	/*

	 * The above MIGHT indicate a device, but I need to write to

	 * further test this.

	/*

	 * well, we've already written once, so hopefully another

	 * time won't hurt.  This time, I need to switch the bank

	 * register to bank 1, so I can access the base address

	 * register

	/*

	 * check if the revision register is something that I

	 * recognize.  These might need to be added to later,

	 * as future revisions could be added.

 I don't recognize this chip, so... */

 At this point I'll assume that the chip is an SMC91x. */

 fill in some of the fields */

 Get the MAC address */

 now, reset the chip, and put it into a known state */

	/*

	 * If dev->irq is 0, then the device has to be banged on to see

	 * what the IRQ is.

	 *

	 * This banging doesn't always detect the IRQ, for unknown reasons.

	 * a workaround is to reset the chip and try again.

	 *

	 * Interestingly, the DOS packet driver *SETS* the IRQ on the card to

	 * be what is requested on the command line.   I don't do that, mostly

	 * because the card that I have uses a non-standard method of accessing

	 * the IRQs, and because this _should_ work in most configurations.

	 *

	 * Specifying an IRQ is done with the assumption that the user knows

	 * what (s)he is doing.  No checking is done!!!!

 kick the card and try again */

	/*

	 * Locate the phy, if any.

 then shut everything down to save power */

 Set default parameters */

 Grab the IRQ */

 now, print out the card info, in a short format.. */

 Print the Ethernet address */

	/*

	 * Map the attribute space.  This is overkill, but clean.

	/*

	 * Reset the device.  We must disable IRQs around this

	 * since a reset causes the IRQ line become active.

	/*

	 * Wait 100us for the chip to reset.

	/*

	 * The device will ignore all writes to the enable bit while

	 * reset is asserted, even if the reset bit is cleared in the

	 * same write.  Must clear reset first, then enable the device.

	/*

	 * Set the appropriate byte/word mode.

	/*

	 * Wait for the chip to wake up.  We could poll the control

	 * register in the main register space, but that isn't mapped

	 * yet.  We know this is going to take 750us.

/**

 * try_toggle_control_gpio - configure a gpio if it exists

 * @dev: net device

 * @desc: where to store the GPIO descriptor, if it exists

 * @name: name of the GPIO in DT

 * @index: index of the GPIO in DT

 * @value: set the GPIO to this value

 * @nsdelay: delay before setting the GPIO

/*

 * smc_init(void)

 *   Input parameters:

 *	dev->base_addr == 0, try to find all possible locations

 *	dev->base_addr > 0x1ff, this is the address to check

 *	dev->base_addr == <anything else>, return failure code

 *

 *   Output:

 *	0 --> there is a device

 *	anything else, error

	/* get configuration from platform data, only allow use of

	 * bus width if both SMC_CAN_USE_xxx and SMC91X_USE_xxx are set.

 Optional pwrdwn GPIO configured? */

		/*

		 * Optional reset GPIO configured? Minimum 100 ns reset needed

		 * according to LAN91C96 datasheet page 14.

		/*

		 * Need to wait for optional EEPROM to load, max 750 us according

		 * to LAN91C96 datasheet page 55.

 Combination of IO widths supported, default to 16-bit */

	/*

	 * If this platform does not specify any special irqflags, or if

	 * the resource supplies a trigger, override the irqflags with

	 * the trigger flags from the resource.

 SPDX-License-Identifier: GPL-2.0-or-later

/***************************************************************************

 *

 * Copyright (C) 2004-2008 SMSC

 * Copyright (C) 2005-2008 ARM

 *

 ***************************************************************************

 * Rewritten, heavily based on smsc911x simple driver by SMSC.

 * Partly uses io macros from smc91x.c by Nicolas Pitre

 *

 * Supported devices:

 *   LAN9115, LAN9116, LAN9117, LAN9118

 *   LAN9215, LAN9216, LAN9217, LAN9218

 *   LAN9210, LAN9211

 *   LAN9220, LAN9221

 *   LAN89218,LAN9250

 used to decide which workarounds apply */

 device configuration (copied from platform_data during probe) */

	/* This needs to be acquired before calling any of below:

	 * smsc911x_mac_read(), smsc911x_mac_write()

 spinlock to ensure register accesses are serialised */

 Members for Multicast filter workaround */

 register access functions */

 regulators */

 Reset GPIO */

 clock */

 Easy access to information */

 Writes a packet to the TX_DATA_FIFO */

 Writes a packet to the TX_DATA_FIFO - shifted version */

 Reads a packet out of the RX_DATA_FIFO */

 Reads a packet out of the RX_DATA_FIFO - shifted version */

/*

 * enable regulator and clock resources.

/*

 * disable resources, currently just regulators.

/*

 * Request resources, currently just regulators.

 *

 * The SMSC911x has two power pins: vddvario and vdd33a, in designs where

 * these are not always-on we need to request regulators to be turned on

 * before we can try to access the device registers.

 Request regulators */

		/*

		 * Retry on deferrals, else just report the error

		 * and try to continue.

 Request optional RESET GPIO */

 Request clock */

/*

 * Free resources, currently just regulators.

 *

 Free regulators */

 Free clock */

/* waits for MAC not busy, with timeout.  Only called by smsc911x_mac_read

 Fetches a MAC register value. Assumes mac_lock is acquired */

 Send the MAC cmd */

 Workaround for hardware read-after-write restriction */

 Wait for the read to complete */

 Set a mac register, mac_lock must be acquired before calling */

 Send data to write */

 Write the actual data */

 Workaround for hardware read-after-write restriction */

 Wait for the write to complete */

 Get a phy register */

 Confirm MII not busy */

 Set the address, index & direction (read from PHY) */

 Wait for read to complete w/ timeout */

 Set a phy register */

 Confirm MII not busy */

 Put the data to write in the MAC */

 Set the address, index & direction (write to PHY) */

 Wait for write to complete w/ timeout */

 Switch to external phy. Assumes tx and rx are stopped. */

 Disable phy clocks to the MAC */

 Enough time for clocks to stop */

 Switch to external phy */

 Enable phy clocks to the MAC */

 Enough time for clocks to restart */

/* Autodetects and enables external phy if present on supported chips.

 * autodetection can be overridden by specifying SMSC911X_FORCE_INTERNAL_PHY

 Fetches a tx status out of the status fifo */

 Fetches the next rx status */

 Zero-out rx packet memory */

 Write tx packet to 118 */

 Wait till transmit is done */

 Wait till receive is done */

	/* Extra delay required because the phy may not be completed with

	* its reset when BMCR_RESET is cleared. Specs say 256 uS is

 Initialise tx packet using broadcast destination address */

 Use incrementing source address */

 Set length type field */

 Set PHY to 10/FD, no ANEG, and loopback mode */

 Enable MAC tx/rx, FD */

 Disable MAC rx */

 Disable MAC */

 Cancel PHY loopback mode */

 USE_PHY_WORK_AROUND */

/* Update link mode if anything has changed.  Called periodically when the

 Restore original GPIO configuration */

			/* Check global setting that LED1

				/* Force 10/100 LED off, after saving

 find the first phy */

 mask with MAC supported features */

 USE_PHY_WORK_AROUND */

 External PHY supported, try to autodetect */

 Mask all PHYs except ID 1 (internal) */

 Gets the number of tx statuses in the fifo */

 Reads tx statuses and increments counters where necessary */

			/* In this driver the packet tag is used as the packet

			 * length. Since a packet length can never reach the

			 * size of 0x8000, this bit is reserved. It is worth

			 * noting that the "reserved bit" in the warning above

			 * does not reference a hardware defined reserved bit

			 * but rather a driver defined one.

 Increments the Rx error counters */

 Quickly dumps bad packets */

 NAPI poll function */

			/* We processed all packets available.  Tell NAPI it can

		/* Count packet for NAPI scheduling, even if it has an error.

			/* Packet has an error, discard it and continue with

 Drop the packet and stop this polling iteration */

 Align IP on 16B boundary */

 Update counters */

 Return total received packets */

/* Returns hash bit number for given MAC address

 * Example:

	/* Performs the multicast & mac_cr update.  This is called when

	/* This function is only called for older LAN911x devices

	 * (revA or revB), where MAC_CR, HASHH and HASHL should not

	 * be modified during Rx - newer devices immediately update the

	 * registers.

	 *

 Check Rx has stopped */

 Perform the update - safe to do now Rx has stopped */

 Re-enable Rx */

	/* If the internal PHY is in General Power-Down mode, all, except the

	 * management interface, is powered-down and stays in that condition as

	 * long as Phy register bit 0.11 is HIGH.

	 *

	 * In that case, clear the bit 0.11, so the PHY powers up and we can

	 * access to the phy registers.

	/* If the PHY general power-down bit is not set is not necessary to

	 * disable the general power down-mode.

 Only disable if energy detect mode is already enabled */

 Disable energy detect mode for this SMSC Transceivers */

 Allow PHY to wakeup */

 Only enable if energy detect mode is already disabled */

 Enable energy detect mode for this SMSC Transceivers */

	/*

	 * Make sure to power-up the PHY chip before doing a reset, otherwise

	 * the reset fails.

	/*

	 * LAN9210/LAN9211/LAN9220/LAN9221 chips have an internal PHY that

	 * are initialized in a Energy Detect Power-Down mode that prevents

	 * the MAC chip to be software reseted. So we have to wakeup the PHY

	 * before.

 special reset for  LAN9250 */

 Reset the LAN911x */

 verify reset bit is cleared */

 Sets the device MAC address to dev_addr, called with mac_lock held */

		/* Called when there is a multicast update scheduled and

 Disable Rx interrupts */

 Schedule a NAPI poll */

 find and start the given phy */

 Reset the LAN911x */

 Increase the legal frame size of VLAN tagged frames to 1522 bytes */

 Make sure EEPROM has finished loading before setting GPIO_CFG */

	/* The soft reset above cleared the device's MAC address,

 Initialise irqs, but leave all sources disabled */

 Set interrupt deassertion to 100uS */

 Reset the last known duplex and carrier */

 Bring the PHY up */

 Preserve TX FIFO size and external PHY configuration */

 set RX Data offset to 2 bytes for alignment */

 enable NAPI polling before enabling RX interrupts */

 Entry point for stopping the interface */

 Disable all device interrupts */

 Stop Tx and Rx polling */

 At this point all Rx and Tx activity is stopped */

 Bring the PHY down */

 Entry point for transmitting a packet */

 Word alignment adjustment */

 Entry point for getting status counters */

 Entry point for setting addressing modes */

 Enabling promiscuous mode */

 Enabling all multicast mode */

 Enabling specific multicast addresses */

 Enabling local MAC address only */

		/* Older hardware revision - cannot change these flags while

			/* Request the hardware to stop, then perform the

			/* There is another update pending, this should now

 Newer hardware revision - can write immediately */

 CONFIG_NET_POLL_CONTROLLER */

	/* On older hardware revisions we cannot change the mac address

	 * registers while receiving data.  Newer devices can safely change

 Workaround for hardware read-after-write restriction */

 Single byte write, according to man page */

 copies the current mac address from hardware to dev->dev_addr */

 Initializing private device structures, only called from probe */

	/*

	 * poll the READY bit in PMT_CTRL. Any other access to the device is

	 * forbidden while this bit isn't set. Try for 100ms

	 *

	 * Note that this test is done before the WORD_SWAP register is

	 * programmed. So in some configurations the READY bit is at 16 before

	 * WORD_SWAP is written to. This issue is worked around by waiting

	 * until either bit 0 or bit 16 gets set in PMT_CTRL.

	 *

	 * SMSC has confirmed that checking bit 16 (marked as reserved in

	 * the datasheet) is fine since these bits "will either never be set

	 * or can only go high after READY does (so also indicate the device

	 * is ready)".

 Check byte ordering */

		/* 1 dummy read of BYTE_TEST is needed after a write to

 Default generation to zero (all workarounds apply) */

 LAN911[5678] family */

 LAN921[5678] family */

 LAN9210/LAN9211/LAN9220/LAN9221/LAN9250 */

	/* workaround for platforms without an eeprom, where the mac address

	 * is stored elsewhere and set by the bootloader.  This saves the

 Reset the LAN911x */

 standard register acces */

 shifted register access */

 copy config parameters across to pdata */

 assume standard, non-shifted, access to HW registers */

 apply the right access if shifting is needed */

 Check if mac address has been specified when bringing interface up */

		/* Try reading mac address from device. if EEPROM is present

 eeprom values are valid  so use them */

 eeprom values are invalid, generate random MAC */

/* This implementation assumes the devices remains powered on its VDDVARIO

 TODO: implement freeze/thaw callbacks for hibernation.*/

	/* enable wake on LAN, energy detection and the external PME

	/* Note 3.11 from the datasheet:

	 * 	"When the LAN9220 is in a power saving state, a write of any

	 * 	 data to the BYTE_TEST register will wake-up the device."

	/* poll the READY bit in PMT_CTRL. Any other access to the device is

	 * forbidden while this bit isn't set. Try for 100ms and return -EIO

 sentinel */ }

 Entry point for loading the module */

 entry point for unloading the module */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * smc911x.c

 * This is a driver for SMSC's LAN911{5,6,7,8} single-chip Ethernet devices.

 *

 * Copyright (C) 2005 Sensoria Corp

 *	   Derived from the unified SMC91x driver by Nicolas Pitre

 *	   and the smsc911x.c reference driver by SMSC

 *

 * Arguments:

 *	 watchdog  = TX watchdog timeout

 *	 tx_fifo_kb = Size of TX FIFO in KB

 *

 * History:

 *	  04/16/05	Dustin McIntire		 Initial version

 Debugging options */

/*

 * Transmit timeout, default 5 seconds.

/*

 * The internal workings of the driver.  If you are changing anything

 * here with the SMC stuff, you should have the datasheet and know

 * what you are doing.

/*

 * Use power-down feature of the chip

 this enables an interrupt in the interrupt mask register */

 this disables an interrupt from the interrupt mask register */

/*

 * this does a soft reset on the device

	 Take out of PM setting first */

 Write to the bytetest will take out of powerdown */

 Disable all interrupts */

 If chip indicates reset timeout then try again */

 make sure EEPROM has finished loading before setting GPIO_CFG */

 Initialize interrupts */

 Reset the FIFO level and flow control settings */

TODO: Figure out what appropriate pause time is

 Set to LED outputs */

	/*

	 * Deassert IRQ for 1*10us for edge type interrupts

	 * and drive IRQ pin push-pull

 clear anything saved */

/*

 * Enable Interrupts, Receive, and Transmit

 Enable TX */

 Update TX stats on every 64 packets received or every 1 sec */

 Add 2 byte padding to start of packets */

 Turn on receiver and enable RX */

 Interrupt on every received packet */

 now, enable interrupts */

/*

 * this puts the device in an inactive state

 Disable IRQ's */

 Turn of Rx and TX */

 Manually dump the packet data */

 Fast forward through the bad packet */

/*

 * This is the procedure to handle the receipt of a packet.

 * It should be called after checking for packet presence in

 * the RX status FIFO.	 It must be called with the spin lock

 * already held.

 Deal with a bad packet */

 Remove the bad packet data from the RX FIFO */

 Receive a valid packet */

 Alloc a buffer with extra room for DMA alignment */

		/* Align IP header to 32 bits

		 * Note that the device is configured to add a 2

		 * byte padding to the packet start, so we really

 Lower the FIFO threshold if possible */

 Setup RX DMA */

 Packet processing deferred to DMA RX interrupt */

/*

 * This is called to actually send a packet to the chip.

 cmdA {25:24] data alignment [20:16] start offset [10:0] buffer length */

 cmdB {31:16] pkt tag [10:0] length */

 16 byte buffer alignment mode */

 tag is packet length so we can use this in stats update later */

 Send pkt via PIO or DMA */

 DMA complete IRQ will free buffer and set jiffies */

/*

 * Since I am not sure if I will have enough room in the chip's ram

 * to store the packet, I call this routine which either sends it

 * now, or set the card to generates an interrupt when ready

 * for the packet.

 Turn off the flow when running out of space in FIFO */

 Reenable when at least 1 packet of size MTU present */

	/* Drop packets when we run out of space in TX FIFO

	 * Account for overhead required for:

	 *

	 *	  Tx command words			 8 bytes

	 *	  Start offset				 15 bytes

	 *	  End padding				 15 bytes

		/* If the DMA is already running then defer this packet Tx until

		 * the DMA IRQ starts it

/*

 * This handles a TX status interrupt, which is only called when:

 * - a TX error occurred, or

 * - TX of a packet completed.

 Collect the TX status */

		/* count Tx errors, but ignore lost carrier errors when in

 carrier error only has meaning for half-duplex communication */

---PHY CONTROL AND CONFIGURATION-----------------------------------------*/

/*

 * Reads a register from the MII Management serial interface

/*

 * Writes a register to the MII Management serial interface

/*

 * Finds and reports the PHY address (115 and 117 have external

 * PHY interface 118 has internal only

	/*

	 * Scan all 32 PHY addresses if necessary, starting at

	 * PHY#1 to PHY#31, and then PHY#0 last.

 Wait for clocks to stop */

 Wait for clocks to stop */

 Wait for clocks to stop */

 Read the PHY identifiers */

 Make sure it is a valid identifier */

 Save the PHY's address */

 Found an external PHY */

 Internal media only */

 Save the PHY's address */

/*

 * Sets the PHY to a configuration as determined by the user.

 * Called with spin_lock held.

 Enter Link Disable state */

	/*

	 * Set our fixed capabilities

	 * Disable auto-negotiation

 Write our capabilities to the phy control register */

 Re-Configure the Receive/Phy Control register */

/**

 * smc911x_phy_reset - reset the phy

 * @dev: net device

 * @phy: phy address

 *

 * Issue a software reset for the specified PHY and

 * wait up to 100ms for the reset to complete.	 We should

 * not access the PHY for 50ms after issuing the reset.

 *

 * The time to wait appears to be dependent on the PHY.

 *

			/* extra delay required because the phy may

			 * not be completed with its reset

			 * when PHY_BCR_RESET_ is cleared. 256us

			 * should suffice, but use 500us to be safe

/**

 * smc911x_phy_powerdown - powerdown phy

 * @dev: net device

 * @phy: phy address

 *

 * Power down the specified PHY

 Enter Link Disable state */

/**

 * smc911x_phy_check_media - check the media status and adjust BMCR

 * @dev: net device

 * @init: set true for initialisation

 *

 * Select duplex mode depending on negotiation state.	This

 * also updates our carrier state.

 duplex state has changed */

/*

 * Configures the specified PHY through the MII management interface

 * using Autonegotiation.

 * Calls smc911x_phy_fixed() if the user has requested a certain config.

 * If RPC ANEG bit is set, the media selection is dependent purely on

 * the selection by the MII (either in the MII BMCR reg or the result

 * of autonegotiation.)  If the RPC ANEG bit is cleared, the selection

 * is controlled by the RPC SPEED and RPC DPLX bits.

 My PHY capabilities */

 My Advertised capabilities */

	/*

	 * We should not be called if phy_type is zero.

	/*

	 * Enable PHY Interrupts (for register 18)

	 * Interrupts listed here are enabled

 If the user requested no auto neg, then go set his request */

 Copy our capabilities from MII_BMSR to MII_ADVERTISE */

 CSMA capable w/ both pauses */

 Disable capabilities not selected by our user */

 Update our Auto-Neg Advertisement Register */

	/*

	 * Read the register back.	 Without this, it appears that when

	 * auto-negotiation is restarted, sometimes it isn't ready and

	 * the link does not come up.

 Restart auto-negotiation process in order to advertise my caps */

/*

 * smc911x_phy_interrupt

 *

 * Purpose:  Handle interrupts relating to PHY register 18. This is

 *	 called from the "hard" interrupt handler under our private spinlock.

 read to clear status bits */

--- END PHY CONTROL AND CONFIGURATION-------------------------------------*/

/*

 * This is the main routine of the driver, to handle the device when

 * it needs some attention.

 Spurious interrupt check */

 set a timeout value, so I don't stay here forever */

 Handle SW interrupt condition */

 Handle various error conditions */

 Undocumented interrupt-what is the right thing to do here? */

 Rx Data FIFO exceeds set level */

 Handle receive condition */

 The DMA is already running so up the IRQ threshold */

 Handle transmit FIFO available */

 Handle transmit done condition */

 Handle PHY interrupt condition */

 restore mask state */

 SMC_USE_DMA */

/*

 * Polling receive - used by netconsole and other diagnostic tools

 * to allow network i/o with interrupts disabled.

 Our watchdog timed out. Called by the networking layer */

 Dump the current TX FIFO contents and restart */

	/*

	 * Reconfiguring the PHY doesn't seem like a bad idea here, but

	 * smc911x_phy_configure() calls msleep() which calls schedule_timeout()

	 * which calls schedule().	 Hence we use a work queue.

 We can accept TX packets again */

 prevent tx timeout */

/*

 * This routine will, depending on the values passed to it,

 * either make it accept multicast packets, go into

 * promiscuous mode (for TCPDUMP and cousins) or accept

 * a select set of multicast packets

	/*

	 * Here, I am setting this to accept all multicast packets.

	 * I don't need to zero the multicast table, because the flag is

	 * checked before the table is

	/*

	 * This sets the internal hardware table to filter out unwanted

	 * multicast packets before they take up memory.

	 *

	 * The SMC chip uses a hash table where the high 6 bits of the CRC of

	 * address are the offset into the table.	If that bit is 1, then the

	 * multicast packet is accepted.  Otherwise, it's dropped silently.

	 *

	 * To use the 6 bits as an offset into the table, the high 1 bit is

	 * the number of the 32 bit register, while the low 5 bits are the bit

	 * within that register.

 Set the Hash perfec mode */

 start with a table of all zeros: reject all */

 upper 6 bits are used as hash index */

 be sure I get rid of flags I might have set */

 now, the table can be loaded into the chipset */

		/*

		 * since I'm disabling all multicast entirely, I need to

		 * clear the multicast list

/*

 * Open and Initialize the board

 *

 * Set up everything, reset the card, etc..

 reset the hardware */

 Configure the PHY, initialize the link state */

 Turn on Tx + Rx */

/*

 * smc911x_close

 *

 * this makes the board clean up everything that it can

 * and not talk to the outside world.	 Caused by

 * an 'ifconfig ethX down'

 clear everything */

		/* We need to ensure that no calls to

		 * smc911x_phy_configure are pending.

/*

 * Ethtool support

 System regs + MAC regs + PHY regs */

 Enable erase */

 erase byte */

 write byte */

/*

 * smc911x_findirq

 *

 * This routine has a simple purpose -- make the SMC chip generate an

 * interrupt, so an auto-detect routine can detect it, and find the IRQ,

	/*

	 * Force a SW interrupt

	/*

	 * Wait until positive that the interrupt has been generated

 got the interrupt */

	/*

	 * there is really nothing that I can do here if timeout fails,

	 * as autoirq_report will return a 0 anyway, which is what I

	 * want in this case.	 Plus, the clean up is needed in both

	 * cases.

 and disable all interrupts again */

 and return what I found */

/*

 * Function: smc911x_probe(unsigned long ioaddr)

 *

 * Purpose:

 *	 Tests to see if a given ioaddr points to an SMC911x chip.

 *	 Returns a 0 on success

 *

 * Algorithm:

 *	 (1) see if the endian word is OK

 *	 (1) see if I recognize the chip ID in the appropriate register

 *

 * Here I do typical initialization tasks.

 *

 * o  Initialize the structure if needed

 * o  print out my vanity message if not done so already

 * o  print out what type of hardware is detected

 * o  print out the ethernet address

 * o  find the IRQ

 * o  set up my private data

 * o  configure the dev structure with my subroutines

 * o  actually GRAB the irq.

 * o  GRAB the region

 First, see if the endian word is recognized */

	/*

	 * check if the revision register is something that I

	 * recognize.	These might need to be added to later,

	 * as future revisions could be added.

 At this point I'll assume that the chip is an SMC911x. */

 Validate the TX FIFO size requested */

 fill in some of the fields */

 Reverse calculate the RX FIFO size from the TX */

 Set the automatic flow control values */

		/*

		 *	 AFC_HI is about ((Rx Data Fifo Size)*2/3)/64

		 *	 AFC_LO is AFC_HI/2

		 *	 BACK_DUR is about 5uS*(AFC_LO) rounded down

 13440 Rx Data Fifo Size */

 12480 Rx Data Fifo Size */

 11520 Rx Data Fifo Size */

 10560 Rx Data Fifo Size */

 9600 Rx Data Fifo Size */

 8640 Rx Data Fifo Size */

 7680 Rx Data Fifo Size */

 6720 Rx Data Fifo Size */

 5760 Rx Data Fifo Size */

 4800 Rx Data Fifo Size */

		/*

		 *	 AFC_HI is ~1520 bytes less than RX Data Fifo Size

		 *	 AFC_LO is AFC_HI/2

		 *	 BACK_DUR is about 5uS*(AFC_LO) rounded down

 3840 Rx Data Fifo Size */

 2880 Rx Data Fifo Size */

 1920 Rx Data Fifo Size */

 Get the MAC address */

 now, reset the chip, and put it into a known state */

	/*

	 * If dev->irq is 0, then the device has to be banged on to see

	 * what the IRQ is.

	 *

	 * Specifying an IRQ is done with the assumption that the user knows

	 * what (s)he is doing.  No checking is done!!!!

 kick the card and try again */

	/*

	 * Locate the phy, if any.

 Set default parameters */

 Grab the IRQ */

 now, print out the card info, in a short format.. */

 Print the Ethernet address */

/*

 * smc911x_drv_probe(void)

 *

 *	  Output:

 *	 0 --> there is a device

 *	 anything else, error

	/*

	 * Request the regions.

 Set D2 - Energy detect only setting */

 epic100.c: A SMC 83c170 EPIC/100 Fast Ethernet driver for Linux. */

/*

	Written/copyright 1997-2001 by Donald Becker.



	This software may be used and distributed according to the terms of

	the GNU General Public License (GPL), incorporated herein by reference.

	Drivers based on or derived from this code fall under the GPL and must

	retain the authorship, copyright and license notice.  This file is not

	a complete program and may only be used when the entire operating

	system is licensed under the GPL.



	This driver is for the SMC83c170/175 "EPIC" series, as used on the

	SMC EtherPower II 9432 PCI adapter, and several CardBus cards.



	The author may be reached as becker@scyld.com, or C/O

	Scyld Computing Corporation

	410 Severn Ave., Suite 210

	Annapolis MD 21403



	Information and updates available at

	http://www.scyld.com/network/epic100.html

	[this link no longer provides anything useful -jgarzik]



	---------------------------------------------------------------------



/* The user-configurable values.

 1 normal messages, 0 quiet .. 7 verbose. */

 Used to pass the full-duplex flag, etc. */

 More are supported, limit only on options */

/* Set the copy breakpoint for the copy-only-tiny-frames scheme.

 Operational parameters that are set at compile time. */

/* Keep the ring sizes a power of two for operational efficiency.

   The compiler will convert <unsigned>'%'<2^N> into a bit mask.

   Making the Tx ring too large decreases the effectiveness of channel

   bonding and packet priority.

 Limit ring entries actually used.  */

 Operational parameters that usually are not changed. */

 Time in jiffies before concluding the transmitter is hung. */

 Size of each temporary Rx buffer.*/

 Bytes transferred to chip before transmission starts. */

 Initial threshold, increased on underflow, rounded down to 4 byte units. */

 0-3, 0==32, 64,96, or 3==128 bytes  */

 These identify the driver base version and may not be removed. */

/*

				Theory of Operation



I. Board Compatibility



This device driver is designed for the SMC "EPIC/100", the SMC

single-chip Ethernet controllers for PCI.  This chip is used on

the SMC EtherPower II boards.



II. Board-specific settings



PCI bus devices are configured by the system at boot time, so no jumpers

need to be set on the board.  The system BIOS will assign the

PCI INTA signal to a (preferably otherwise unused) system IRQ line.

Note: Kernel versions earlier than 1.3.73 do not support shared PCI

interrupt lines.



III. Driver operation



IIIa. Ring buffers



IVb. References



http://www.smsc.com/media/Downloads_Public/discontinued/83c171.pdf

http://www.smsc.com/media/Downloads_Public/discontinued/83c175.pdf

http://scyld.com/expert/NWay.html

http://www.national.com/pf/DP/DP83840A.html



IVc. Errata



 Driver use, intended as capability flags. */

 indexed by chip_t */

 Offsets to registers, using the (ugh) SMC names. */

 Rx error counters. */

 MAC address. */

 Multicast filter table. */

 Interrupt register bits, using my own meaningful names. */

 Chip failed or removed (CardBus) */

/*

 * The EPIC100 Rx and Tx buffer descriptors.  Note that these

 * really ARE host-endian; it's not a misannotation.  We tell

 * the card to byteswap them internally on big-endian hosts -

 * look for #ifdef __BIG_ENDIAN in epic_open().

 Required alignment mask */

 The saved address of a sent-in-place packet/buffer, for skfree(). */

 The addresses of receive-in-place skbuffs. */

 Ring pointers. */

 Group with Tx control cache line. */

 Based on MTU+slack. */

 PCI bus location. */

 Media selection timer. */

 MII device addresses. */

 NWay media advertisement */

 The Tx queue is full. */

 Last dev->if_port value. */

 when built into the kernel, we only print version if device is found */

 Bring the chip out of low-power mode. */

 Magic?!  If we don't set this bit the MII interface won't work. */

 This magic is documented in SMSC app note 7.15 */

 Turn on the MII transceiver. */

 Note: the '175 does not have a serial EEPROM. */

	/* Find the connected MII xcvrs.

	   Doing this in open() would allow detecting external xcvrs later, but

 Use the known PHY address of the EPII. */

 Turn off the MII xcvr (175 only!), leave the chip in low-power mode. */

 The lower four bits are the media type. */

 The Epic-specific entries in the device structure. */

 Serial EEPROM section. */

  EEPROM_Ctrl bits. */

 EEPROM shift clock. */

 EEPROM chip select. */

 EEPROM chip data in. */

 EEPROM chip data out. */

/* Delay between EEPROM clock transitions.

   This serves to flush the operation to the PCI bus.

 The EEPROM commands include the alway-set leading bit. */

 No need to commit possible posted write */

 Shift the read command bits out. */

 Terminate the EEPROM access. */

 Typical operation takes 25 loops. */

 Work around read failure bug. */

 Soft reset the chip. */

 This magic is documented in SMSC app note 7.15 */

	/* Pull the chip out of low-power mode, enable interrupts, and set for

	   PCI read multiple.  The MIIcfg setting and strange write order are

	   required by the details of which bits are reset and the transceiver

	   wiring on the Ositech CardBus card.

 Tell the chip to byteswap descriptors on big-endian hosts */

 Looks like EPII needs that if you want reliable RX init. FIXME: pci posting bug? */

 Start the chip's Rx process. */

 Enable interrupts by setting the interrupt mask. */

	/* Set the timer to switch to check for link beat and perhaps switch

/* Reset the chip to recover from a PCI transaction error.

 Disable interrupts by clearing the interrupt mask. */

 Stop the chip's Tx and Rx DMA processes. */

 Update the error counts. */

 Remove the packets on the Rx queue. */

 Soft reset the chip. */

 This magic is documented in SMSC app note 7.15 */

 Start the chip's Rx process. */

 Enable interrupts by setting the interrupt mask. */

 Bogus read */

 Tx FIFO underflow. */

 prevent tx timeout */

 Initialize the Rx and Tx rings, along with various 'dev' bits. */

 Initialize all Rx descriptors. */

 Mark the last entry as wrapping the ring. */

 Fill in the Rx buffers.  Handle allocation failure gracefully. */

 16 byte align the IP header. */

	/* The Tx buffer descriptor is filled in as needed, but we

	/* Caution: the write order is important here, set the field with the

 Calculate the next Tx descriptor entry. */

 Typical path */

 No interrupt */

 Tx-done intr. */

 No Tx-done intr. */

 Leave room for an additional entry. */

 Tx-done intr. */

 Trigger an immediate transmit demand. */

 There was an major error, log it. */

	/*

	 * Note: if this lock becomes a problem we can narrow the locked

	 * region at the cost of occasionally grabbing the lock more times.

 It still hasn't been Txed */

 Free the original skb. */

 The ring is no longer full, allow new TX entries. */

/* The interrupt handler does all of the Rx thread work and cleans up

 Acknowledge all of the current interrupt sources ASAP. */

 Check uncommon events all at once. */

 Always update the error counts to avoid overhead later. */

 Tx FIFO underflow. */

 Restart the transmit process. */

 Clear all error sources. */

 If we own the next entry, it's a new packet. Send it up. */

 Rx Frame errors are counted in hardware. */

 Malloc up new buffer, compatible with net-2e. */

 Omit the four octet CRC from the length. */

			/* Check if the packet is long enough to accept without copying

 16 byte align the IP header */

 Refill the Rx ring buffers. */

 Align IP on 16 byte boundaries */

 AV: shouldn't we add a barrier here? */

 Missed a Rx frame. */

 Free all the skbuffs in the Rx queue. */

 Not owned by Epic chip. */

 An invalid address. */

 Green! Leave the chip in low-power mode. */

/* Set or clear the multicast filter for this adaptor.

   Note that we only use exclusion around actually queueing the

   new frame, not around filling ep->setup_frame.  This is non-deterministic

 Multicast hash filter */

 Set promiscuous. */

 Unconditionally log net taps. */

		/* There is apparently a chip bug, so the multicast filter

 Too many to filter perfectly -- accept all multicasts. */

 Never executed, for now. */

 ToDo: perhaps we need to stop the Tx and Rx process here? */

 power-up, if interface is down */

 power-down, if interface is down */

 power-up, if interface is down */

 all non-ethtool ioctls (the SIOC[GS]MIIxxx ioctls) */

 power-down, if interface is down */

 pci_power_off(pdev, -1); */

 Put the chip into low-power mode. */

 pci_power_off(pdev, -1); */

 pci_power_on(pdev); */

 when a module, this is printed whether or not devices are found in probe */

 SPDX-License-Identifier: GPL-2.0-or-later

 /***************************************************************************

 *

 * Copyright (C) 2007,2008  SMSC

 *

 ***************************************************************************

 to ensure PCI write completion, we must perform a PCI read */

  confirm MII not busy */

 set the address, index & direction (read from PHY) */

 wait for read to complete with 50us timeout */

 confirm MII not busy */

 put the data to write in the MAC */

 set the address, index & direction (write to PHY) */

 wait for write to complete with 50us timeout */

/* Returns hash bit number for given MAC address

 * Example:

 all smsc9420 registers plus all phy registers */

 cannot read phy registers if the net device is down

 Single byte write, according to man page */

 Sets the device MAC address to dev_addr */

 Check if mac address has been specified when bringing interface up */

		/* Try reading mac address from device. if EEPROM is present

 eeprom values are valid  so use them */

 eeprom values are invalid, generate random MAC */

 disable TX DMAC */

 Wait max 10ms for transmit process to stop */

 ACK Tx DMAC stop bit */

 mask TX DMAC interrupts */

 stop MAC TX */

 mask RX DMAC interrupts */

 stop RX MAC prior to stoping DMA */

 stop RX DMAC */

 wait up to 10ms for receive to stop */

 ACK the Rx DMAC stop bit */

 check if it's our interrupt */

 mask RX DMAC interrupts */

 mask software interrupt */

 to ensure PCI write completion, we must perform a PCI read */

 CONFIG_NET_POLL_CONTROLLER */

 disable master interrupt */

 remove crc from packet lendth */

 stop if DMAC owns this dma descriptor */

 Kick RXDMA */

 re-enable RX DMA interrupts */

 Check for completed dma transfers, update stats and free skbs */

 Check if DMA still owns this descriptor */

 check if we are at the last descriptor and need to set EOR */

 increment head */

 assign ownership to DMAC */

 kick the DMA */

/* Update link mode if anything has changed.  Called periodically when the

 Device only supports internal PHY at address 1 */

 mask with MAC supported features */

 Mask all PHYs except ID 1 (internal) */

 Initialize the TX Ring */

 initialize the rx ring */

 now allocate the entire ring of skbs */

 Enable RX COE */

 disable, mask and acknowledge all interrupts */

 make sure MAC_CR is sane */

 Configure GPIO pins to drive LEDs */

 set bus master bridge arbitration priority for Rx and TX DMA */

 test the IRQ connection to the ISR */

 configure interrupt deassertion timer and enable interrupts */

 unmask software interrupt */

 disable interrupts */

 Bring the PHY up */

 start tx and rx */

 enable interrupts */

 disable interrupts */

 FIXME: gross. It looks like ancient PM relic.*/

 CONFIG_NET_POLL_CONTROLLER */

 First do the PCI initialisation */

 registers are double mapped with 0 offset for LE and 0x200 for BE */

 pci descriptors are created in the PCI consistent area */

 descriptors are aligned due to the nature of dma_alloc_coherent */

 tx_buffers and rx_buffers are freed in stop */

/*======================================================================



    A PCMCIA ethernet driver for SMC91c92-based cards.



    This driver supports Megahertz PCMCIA ethernet cards; and

    Megahertz, Motorola, Ositech, and Psion Dacom ethernet/modem

    multifunction cards.



    Copyright (C) 1999 David A. Hinds -- dahinds@users.sourceforge.net



    smc91c92_cs.c 1.122 2002/10/25 06:26:39



    This driver contains code written by Donald Becker

    (becker@scyld.com), Rowan Hughes (x-csrdh@jcu.edu.au),

    David Hinds (dahinds@users.sourceforge.net), and Erik Stahlman

    (erik@vt.edu).  Donald wrote the SMC 91c92 code using parts of

    Erik's SMC 91c94 driver.  Rowan wrote a similar driver, and I've

    incorporated some parts of his driver here.  I (Dave) wrote most

    of the PCMCIA glue code, and the Ositech support code.  Kelly

    Stephens (kstephen@holli.com) added support for the Motorola

    Mariner, with help from Allen Brost.



    This software may be used and distributed according to the terms of

    the GNU General Public License, incorporated herein by reference.



====================================================================*/

 Firmware name */

 Module parameters */

/*

  Transceiver/media type.

   0 = auto

   1 = 10baseT (and autoselect if #define AUTOSELECT),

   2 = AUI/10base2,

====================================================================*/

 Operational parameter that usually are not changed. */

 Time in jiffies before concluding Tx hung */

 Maximum events (Rx packets, etc.) to handle at each interrupt. */

/* Times to check the check the chip before concluding that it doesn't

 Special definitions for Megahertz multifunction cards */

 Special function registers for Motorola Mariner */

 Special function registers for Ositech cards */

 Symbolic constants for the SMC91c9* series chips, from Erik Stahlman. */

 Window select register. */

 Bank 0 registers. */

 transmit control register */

 do NOTHING */

 if this is 1, we can transmit */

 pads short packets to 64 bytes */

 Monitor Carrier. */

 Full duplex mode. */

 Ethernet Protocol Handler report. */

 Memory Information Register */

 Memory Configuration Register */

 Bank 1 registers. */

 91C100 only */

 Bank 2 registers. */

 or with number of 256 byte packets */

 remove and release the current rx packet */

 Release packet in PNR register */

 Enqueue the packet for transmit */

 resets the chip */

 strips CRC */

 IFF this is set, we can receive packets */

 receive all multicast packets */

 enable promiscuous mode */

 the normal settings for the RCR register : */

 set it to a base state */

 BANK 3 -- not the same values as in smc9194! */

 Transmit status bits. */

 Receive status bits. */

====================================================================*/

 Create new ethernet device */

 The SMC91c92-specific entries in the device structure. */

 smc91c92_attach */

 smc91c92_detach */

====================================================================*/

/*====================================================================



    Configuration stuff for Megahertz cards



    mhz_3288_power() is used to power up a 3288's ethernet chip.

    mhz_mfc_config() handles socket setup for multifunction (1144

    and 3288) cards.  mhz_setup() gets a card's hardware ethernet

    address.



 Read the ISR twice... */

 Pause 200ms... */

 Now read and write the COR... */

    /* The Megahertz combo cards have modem-like CIS entries, so

 Allocate a memory window, for accessing the ISR */

    /* Read the station address from the CIS.  It is stored as the last

 Workarounds for broken cards start here. */

 Ugh -- the EM1144 card has two VERS_1 tuples!?! */

 Another possibility: for the EM3288, in a special tuple */

/*======================================================================



    Configuration stuff for the Motorola Mariner



    mot_config() writes directly to the Mariner configuration

    registers because the CIS is just bogus.



 Set UART base address and force map with COR bit 1 */

 Set SMC base address and force map with COR bit 1 */

 Wait for things to settle down */

 Read Ethernet address from Serial EEPROM */

====================================================================*/

 Check for a LAN function extension tuple */

 Try the third string in the Version 1 Version/ID tuple. */

====================================================================*/

 Enable Hard Decode, LAN, Modem */

 Fallback: turn off hard decode */

 Download the Seven of Diamonds firmware */

 Read the station address from tuple 0x90, subtuple 0x04 */

 Make sure both functions are powered up */

 Now, turn on the interrupt for both card functions */

 Power up the card and enable interrupts */

/*======================================================================



    This verifies that the chip is some SMC91cXX variant, and returns

    the revision code if successful.  Otherwise, it returns -ENODEV.



 Try powering up the chip */

 Try setting bus width */

 Check Base Address Register to make sure bus width is OK */

 For broken Megahertz cards */

 get the hw address from EEPROM */

 Get scale factor for memory size */

 smc91c92_config */

/*======================================================================



    MII interface support for SMC91cXX based cards

/*======================================================================



    The driver core code, most of which should be common with a

    non-PCMCIA implementation.



 Check that the PCMCIA card is still here. */

 Physical device present signature. */

 smc_open */

====================================================================*/

    /* Shut off all interrupts, and turn off the Tx and Rx sections.

 Nominally paranoia, but do no assume... */

 Put the chip into power-down mode. */

 smc_close */

/*======================================================================



   Transfer a packet to the hardware and trigger the packet send.

   This may be called at either from either the Tx queue code

   or the interrupt handler.



 There should be a packet slot waiting. */

 If not, there is a hardware problem!  Likely an ejected card. */

 The card should use the just-allocated buffer. */

 point to the beginning of the packet */

    /* Send the packet length (+6 for status, length and ctl byte)

 The chip will pad to ethernet min. */

 send the packet length: +6 for status word, length, and ctl */

 The odd last byte, if there is one, goes in the control word. */

 Enable the Tx interrupts, both Tx (TxErr) and TxEmpty. */

 The chip does the rest of the work. */

====================================================================*/

 prevent tx timeout */

 THIS SHOULD NEVER HAPPEN. */

 Do not re-queue this packet. */

 A packet is now waiting. */

 Paranoia, we should always be in window 2 */

 need MC_RESET to keep the memory consistent. errata? */

 Allocate the memory; send the packet now if we win. */

 Acknowledge the interrupt, send the packet. */

 Send the packet now.. */

 Otherwise defer until the Tx-space-allocated interrupt. */

/*======================================================================



    Handle a Tx anomalous event.  Entered while in Window 2.



 select this as the packet to read from */

 read the first word from this packet */

 re-enable transmit */

 Free the packet memory. */

 one less packet waiting for me */

====================================================================*/

 Could be a counter roll-over warning: update stats. */

 single collisions */

 multiple collisions */

 These are for when linux supports these statistics */

 deferred */

 excess deferred */

 If we had a transmit error we must re-enable the transmitter. */

 Clear a link error interrupt. */

====================================================================*/

 Work we are willing to do. */

	/* The device does not exist -- the card could be off-line, or

 clear all interrupts */

 read the status flag, and mask it */

 Got a packet(s). */

 Clear this interrupt so it doesn't happen again */

 enable xmit interrupts based on this */

 and let the card send more packets to me */

 need MC_RESET outside smc_interrupt */

 restore state register */

 Retrigger interrupt if needed */

 Megahertz MFC's */

 Retrigger interrupt if needed */

====================================================================*/

    int packet_length;	/* Caution: not frame length, rather words

 Assertion: we are in Window 2. */

  Reset the read pointer, and read the status and packet length. */

 do stuff to make a new packet */

 Note: packet_length adds 5 or 6 extra bytes here! */

 error ... */

 Let the MMU free the memory of this packet. */

/*======================================================================



    Set the receive mode.



    This routine is used by both the protocol level to notify us of

    promiscuous/multicast mode changes, and by the open/reset code to

    initialize the Rx registers.  We always set the multicast list and

    leave the receiver running.



 Load MC table and Rx setting into the chip without interrupts. */

/*======================================================================



    Senses when a card's config changes. Here, it's coax or TP.



/*======================================================================



    Reset the chip, reloading every register that might be corrupted.



/*

  Set transceiver type, perhaps to something other than what the user

  specified in dev->if_port.

    /* The first interaction must be a write to bring the chip out

 Reset the chip. */

 Clear the transmit and receive configuration registers. */

    /* Set the Window 1 control, configuration and station addr registers.

    /* Automatically release successfully transmitted packets,

 Fill in the physical address.  The databook is wrong about the order! */

 Reset the MMU */

 Re-enable the chip. */

 Reset MII */

 Advertise 100F, 100H, 10F, 10H */

 Restart MII autonegotiation */

 Enable interrupts. */

/*======================================================================



    Media selection timer routine



 need MC_RESET to keep the memory consistent. errata? */

    /* Check for pending interrupt with watchdog flag set: with

 Ignore collisions unless we've had no rx's recently */

 These conflict with other cards! */

 PCMCIA_DEVICE_MANF_CARD(0x0186, 0x0100), */

 PCMCIA_DEVICE_MANF_CARD(0x8a01, 0xc1ab), */

/* [xirc2ps_cs.c wk 03.11.99] (1.40 1999/11/18 00:06:03)

 * Xircom CreditCard Ethernet Adapter IIps driver

 * Xircom Realport 10/100 (RE-100) driver 

 *

 * This driver supports various Xircom CreditCard Ethernet adapters

 * including the CE2, CE IIps, RE-10, CEM28, CEM33, CE33, CEM56,

 * CE3-100, CE3B, RE-100, REM10BT, and REM56G-100.

 *

 * 2000-09-24 <psheer@icon.co.za> The Xircom CE3B-100 may not

 * autodetect the media properly. In this case use the

 * if_port=1 (for 10BaseT) or if_port=4 (for 100BaseT) options

 * to force the media type.

 * 

 * Written originally by Werner Koch based on David Hinds' skeleton of the

 * PCMCIA driver.

 *

 * Copyright (c) 1997,1998 Werner Koch (dd9jn)

 *

 * This driver is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License as published by

 * the Free Software Foundation; either version 2 of the License, or

 * (at your option) any later version.

 *

 * It is distributed in the hope that it will be useful,

 * but WITHOUT ANY WARRANTY; without even the implied warranty of

 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

 *

 * You should have received a copy of the GNU General Public License

 * along with this program; if not, see <http://www.gnu.org/licenses/>.

 *

 *

 * ALTERNATIVELY, this driver may be distributed under the terms of

 * the following license, in which case the provisions of this license

 * are required INSTEAD OF the GNU General Public License.  (This clause

 * is necessary due to a potential bad interaction between the GPL and

 * the restrictions contained in a BSD-style copyright.)

 *

 * Redistribution and use in source and binary forms, with or without

 * modification, are permitted provided that the following conditions

 * are met:

 * 1. Redistributions of source code must retain the above copyright

 *    notice, and the entire permission notice in its entirety,

 *    including the disclaimer of warranties.

 * 2. Redistributions in binary form must reproduce the above copyright

 *    notice, this list of conditions and the following disclaimer in the

 *    documentation and/or other materials provided with the distribution.

 * 3. The name of the author may not be used to endorse or promote

 *    products derived from this software without specific prior

 *    written permission.

 *

 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED

 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES

 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE

 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,

 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES

 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR

 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)

 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,

 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)

 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED

 * OF THE POSSIBILITY OF SUCH DAMAGE.

 is this correct? */

 Time in jiffies before concluding Tx hung */

/****************

 * Some constants used to access the hardware

 Register offsets and value constans */

 Command register (wr) */

 Ethernet status register (rd) */

 full packet in receive buffer */

 a packet has been rejected */

 TX Packet Pending */

 set if TP, clear if AUI */

 Page Register select */

 Ethernet Data Port Register */

 Ethernet Interrupt Status Register */

 TX Buffer Overflow */

 Packet Transmitted */

 MAC Interrupt occurred */

 Tx Reservation Granted */

 Rx Full Packet */

 Rx Packet Rejected */

 Forced Interrupt */

 Ethernet Interrupt Mask Register (on page 1)*/

 Transmit Space Open Register (on page 0)*/

 Transmit reservation Size Register (page 0)*/

 Data Offset Register (page 0) (wr) */

 Receive Status Register (page 0) (rd) */

 set:physical packet, clear: multicast packet */

 set if it is a broadcast packet */

 set if packet length > 1518 */

 incorrect CRC and last octet not complete */

 incorrect CRC and last octet is complete */

 received ok */

 packets transmitted register (rd) */

 receive byte count regsister (rd) */

 ethernet configurationn register */

 enable full duplex mode */

 adjust for longer lengths of TP cable */

 disable auto polarity correction */

 disable link pulse generation */

 disable auto-transmit */

 receive buffer start register */

 LED Configuration register */

/* values for the leds:    Bits 2-0 for led 1

 *  0 disabled		   Bits 5-3 for led 2

 *  1 collision

 *  2 noncollision

 *  3 link_detected

 *  4 incor_polarity

 *  5 jabber

 *  6 auto_assertion

 *  7 rx_tx_activity

 Mohawk specific register */

 General Purpose Register 0 */

 General Purpose Register 1 */

 General Purpose Register 2 (page2!)*/

 Bonding Version Register */

 Local Memory Address Register */

 Local Memory Data Port */

 MAC register can only by accessed with 8 bit operations */

 Command Register (wr) */

 Commands */

 Rx Host Start Address */

 Receive Status Register */

 Transmit Status Register 0 */

 Transmit Status Register 10 */

 Receive Mask Register */

 Transmit Mask Register 0 */

 Transmit Mask Register 0 */

 Software Configuration 0 */

 Software Configuration 1 */

 Back-Off Configuration */

 Time Domain Reflectometry 0 */

 Time Domain Reflectometry 1 */

 Rx Byte Count 0 (rd) */

 Rx Byte Count 1 (rd) */

 Revision Register (rd) */

 Individual Address (8-13) */

 card types */

 unknown: not supported */

 (prodid 1) different hardware: not supported */

 (prodid 2) */

 (prodid 3) */

 (prodid 1) different hardware: not supported */

 (prodid 2) */

 (prodid 3) */

 (prodid 4) */

 (prodid 5) */

 (prodid 6) */

 (prodid 3) modem only: not supported here */

 (prodid 4) modem only: not supported here */

 (prodid 5) modem only: not supported here */

 (prodid 1) GSM modem only: not supported */

 (prodid 1) cardbus ethernet: not supported */

====================================================================*/

 Module parameters */

 anti lockup hack */

====================================================================*/

/* We do not process more than these number of bytes during one

 * interrupt. (Of course we receive complete packets, so this is not

 * an exact value).

 * Something between 2000..22000; first value gives best interrupt latency,

 * the second enables the usage of the complete on-chip buffer. We use the

 * high value as the initial value.

 MII management prototypes */

 silicon revision. 0=old CE2, 1=Scipper, 4=Mohawk */

 a CE3 type card */

 a CEM56 type card */

 has full 10baseT/100baseT MII */

 is a multi function card (i.e with a modem) */

 only used for CEM56 cards */

 last packets transmitted value */

/****************

 * Some more prototypes

=============== Helper functions =========================*/

====== Functions used for debugging =================================*/

 reading regs may change system status */

 0 */

============== MII Management functions ===============*/

/****************

 * Turn around for read

 drive MDCK low */

 and drive MDCK high */

/****************

 * Write a bit to MDI/O

 set MDIO */

 and drive MDCK high */

 clear MDIO */

 and drive MDCK high */

/****************

 * Get a bit from MDI/O

 drive MDCK low */

 read MDIO */

 drive MDCK high again */

 read MDIO */

 32 bit preamble */

 Start and opcode for read */

 PHY address to be accessed */

 PHY register to read */

 turn around */

 32 bit preamble */

 Start and opcode for write */

 PHY address to be accessed */

 PHY Register to write */

 turn around */

 And write the data */

============= Main bulk of functions	=========================*/

 Allocate the device structure */

 General socket configuration */

 Fill in card specific entries */

 xirc2ps_attach */

 xirc2ps_detach */

/****************

 * Detect the type of the card. s is the buffer with the data of tuple 0x20

 * Returns: 0 := not supported

 *		       mediaid=11 and prodid=47

 * Media-Id bits:

 *  Ethernet	    0x01

 *  Tokenring	    0x02

 *  Arcnet	    0x04

 *  Wireless	    0x08

 *  Modem	    0x10

 *  GSM only	    0x20

 * Prod-Id bits:

 *  Pocket	    0x10

 *  External	    0x20

 *  Creditcard	    0x40

 *  Cardbus	    0x80

 *

 7 is the RealPort 10/56 */

/****************

 * There are some CE2 cards out which claim to be a CE card.

 * This function looks for a "CE2" in the 3rd version field.

 * Returns: true if this is a CE2

 another try	(James Lehmer's CE2 version 4.1)*/

 Is this a valid	card */

 get the ethernet address from the CIS */

 not found: try to get the node-id from tuple 0x89 */

 data layout looks like tuple 0x22 */

	    /* Take the Modem IO port from the CIS and scan for a free

	    /* We do 2 passes here: The first one uses the regular mapping and

	     * the second tries again, thereby considering that the 32 ports are

	     * mirrored every 32 bytes. Actually we use a mirrored port for

	     * the Mako if (on the first pass) the COR bit 5 is set.

	    /* if special option:

	     * try to configure as Ethernet only.

 let CS decide */

    /****************

     * Now allocate an interrupt line.	Note that this does not

     * actually assign a handler to the interrupt.

	/* Reset the modem's BAR to the correct value

	 * This is necessary because in the RequestConfiguration call,

	 * the base address of the ethernet port (BasePort1) is written

	 * to the BAR registers of the modem.

	/* There is no config entry for the Ethernet part which

	 * is at 0x0800. So we allocate a window into the attribute

	 * memory and write direct to the CIS registers

	/* Setup the CCRs; there are no infos in the CIS about the Ethernet

	 * part.

 The if_port symbol can be set when the module is loaded */

 we can now register the device with the net subsystem */

 a kludge to make the cem56 work */

 give some infos about the hardware */

 xirc2ps_config */

 xirc2ps_release */

====================================================================*/

====================================================================*/

/****************

 * This is the Interrupt service route.

    ulong start_ticks = jiffies; /* fixme: jiffies rollover every 497 days

				  * is this something to worry about?

				  * -- on a laptop?

 must disable the interrupt */

    /* Read the ISR to see whats the cause for the interrupt.

     * This also clears the interrupt flags on CE2 cards

 card may be ejected */

**** receive section ******/

	    /* too many bytes received during this int, drop the rest of the

 1 extra so we can use insw */

 okay get the packet */

 work around a hardware bug */

 receive start address */

 skip control infos */

		    /* To use this 32 bit access we should use

		     * a manual optimized loop

		     * Also the words are swapped, we can get more

		     * performance by using 32 bit access and swapping

		     * the words in a register. Will need this for cardbus

		     *

		     * Note: don't forget to change the ALLOC_SKB to .. +3

 bad packet */

 okay ? */

 clear the received/dropped/error packet */

 issue cmd: skip_rx_packet */

 get the new ethernet status */

 Receive overrun */

**** transmit section ******/

 rollover */

 happens sometimes - don't know why */

 Excessive collisions */

 restart transmitter process */

    /* recalculate our work chunk so that we limit the duration of this

     * ISR to about 1/10 of a second.

     * Calculate only if we received a reasonable amount of bytes.

 if more than about 1/10 second */

 now much faster */

 re-enable interrupts */

    /* Instead of dropping packets during a receive, we could

     * force an interrupt with this command:

     *	  PutByte(XIRCREG_CR, EnableIntr|ForceIntr);

 xirc2ps_interrupt */

====================================================================*/

 reset the card */

 prevent tx timeout */

    /* adjust the packet length to min. required

     * and hope that the buffer is large enough

     * to provide some random data.

     * fixme: For Mohawk we can change this by sending

     * a larger packetlen than we actually have; the chip will

     * pad this in his buffer with random bytes

 TRS doesn't work - (indeed it is eliminated with sil-rev 1) */

 not enough space */

 upper layer may decide to requeue this packet */

 send the packet */

/****************

 * Set all addresses: This first one is the individual address,

 * the next 9 addresses are taken from the multicast list and

 * the rest is filled with the individual address.

	/*

	 * Setup the info structure so that by first set_address call it will do

	 * SelectPage with the right page number. Hence these ones here.

/****************

 * Set or clear the multicast filter for this adaptor.

 * We can filter up to 9 addresses, if more are requested we set

 * multicast promiscuous mode.

 snoop */

 set MPE and PME */

 set MPE */

 the chip can filter 9 addresses perfectly */

 standard usage */

 not the fine way :-) */

/****************

 * Open the driver

 Check that the PCMCIA card is still here. */

 Physical device present signature. */

 okay */

 Get the address of the PHY in use. */

 we have only this address */

 Read the specified MII register. */

 Write the specified MII register */

 clear bit 0: power down */

 wait 40 msec */

 set bit 0: power up */

 set bit 0: power up, bit 2: AIC */

 wait 20 msec */

 set */

 wait 20 msec */

 clear */

 wait 40 msec */

	/* set pin GP1 and GP2 to output  (0x0c)

	 * set GP1 to low to power up the ML6692 (0x00)

	 * set GP2 to high to power up the 10Mhz chip  (0x02)

 give the circuits some time to power up */

 about 500ms */

 enable 10Base2 */

 enable 10BaseT */

 wait 40 msec to let it complete */

 read the ESR */

 setup the ECR */

 allow all ints */

 and Set TxUnderrunDetect */

 disable source insertion */

	/* set the local memory dividing line.

	 * The comments in the sample code say that this is only

	 * settable with the scipper version 2 which is revision 0.

	 * Always for CE3 cards

    /* Hardware workaround:

     * The receive byte pointer after reset is off by 1 so we need

     * to move the offset pointer back to 0.

 change offset command, off=0 */

 setup MAC IMRs and clear status registers */

 Bit 7 ... bit 0 */

 ROK, RAB, rsv, RO, CRC, AE, PTL, MP */

 TOK, TAB, SQE, LL, TU, JAB, EXC, CRS */

 rsv, rsv, PTD, EXT, rsv,rsv,rsv, rsv*/

 ROK, RAB, REN, RO, CRC, AE, PTL, MP */

 TOK, TAB, SQE, LL, TU, JAB, EXC, CRS */

 TEN, rsv, PTD, EXT, retry_counter:4  */

 enable 10Base2 */

 enable 10BaseT */

 wait 40 msec to let it complete */

 No MII */

 read the ESR */

 configure the LEDs */

 TP: Link and Activity */

 Coax: Not-Collision and Activity */

 100 Mbit LED */

 enable receiver and put the mac online */

 setup Ethernet IMR and enable interrupts */

 do some magic */

 unmask master-int bit */

    /* We should switch back to page 0 to avoid a bug in revision 0

     * where regs with offset below 8 can't be read after an access

/****************

 * Initialize the Media-Independent-Interface

 * Returns: True if we have a good MII

 force 100BaseT or 10BaseT */

 No MII */

 auto neg */

 no auto neg, 100mbs mode */

 no auto neg, 10mbs mode */

	/* according to the DP83840A specs the auto negotiation process

	 * may take up to 3.5 sec, so we use this also for our ML6692

	 * Fixme: Better to use a timer here!

 wait 100 msec */

 clear bit 0: power down */

 disable interrupts */

 forbid all ints */

 clear bit 0: power down */

 also matches CFE-10 cards! */

 PCMCIA_DEVICE_MANF_CARD(0x0105, 0x010a), */

	/* if_port, full_duplex, do_sound, lockup_hack

 SPDX-License-Identifier: GPL-2.0-or-later

/* Copyright (c) 2014 Linaro Ltd.

 * Copyright (c) 2014 Hisilicon Limited.

 CONFIG_HI13X1_GMAC */

 REG_INTERRUPT */

 TX descriptor config */

 RX error */

 buf unit size is cache_line_size, which is 64, so the shift is 6 */

 buf unit size is 1, so the shift is 6 */

 CONFIG_HI13X1_GMAC */

 written only by tx cleanup */

 enable tx & rx */

 clear rx int */

 config recv int */

 enable interrupt */

 disable int */

 disable tx & rx */

 Ensure tx_tail visible to xmit */

 allow timer to fire after half the time at the earliest */

 Ensure tx_head update visible to tx reclaim */

 queue is getting full, better start cleaning up now */

 disable rx interrupt and timer */

 cleanup not pending yet, start a new timer */

 clean up tx descriptors */

 enable rx interrupt */

 start a new timer if necessary */

 disable rx interrupt */

 disable rx interrupt */

	/* BQL will try to keep the TX queue as short as possible, but it can't

	 * be faster than tx_coalesce_usecs, so we need a fast timeout here,

	 * but also long enough to gather up enough frames to ensure we don't

	 * get more interrupts than necessary.

	 * 200us is enough for 16 frames of 1500 bytes at gigabit ethernet rate

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) 2014-2015 Hisilicon Limited.

 mdio reg base address */

 mdio reg */

 cfg phy bit map */

 peri subctrl reg */

 waitting for MDIO_COMMAND_REG 's mdio_start==0 */

 after that can do read or write*/

/**

 * hns_mdio_write - access phy register

 * @bus: mdio bus

 * @phy_id: phy id

 * @regnum: register num

 * @data: register value

 *

 * Return 0 on success, negative on failure

 wait for ready */

 config the cmd-reg to write addr*/

 check for read or write opt is finished */

 config the data needed writing */

/**

 * hns_mdio_read - access phy register

 * @bus: mdio bus

 * @phy_id: phy id

 * @regnum: register num

 *

 * Return phy register value

 Step 1: wait for ready */

 Step 2; config the cmd-reg to write addr*/

 Step 3: check for read or write opt is finished */

 Step 5: waitting for MDIO_COMMAND_REG 's mdio_start==0,*/

 check for read or write opt is finished */

 Step 6; get out data*/

/**

 * hns_mdio_reset - reset mdio bus

 * @bus: mdio bus

 *

 * Return 0 on success, negative on failure

 1. reset req, and read reset st check */

 2. dis clk, and read clk st check */

 3. reset dreq, and read reset st check */

 4. en clk, and read clk st check */

/**

 * hns_mdio_probe - probe mdio device

 * @pdev: mdio platform device

 *

 * Return 0 on success, negative on failure

 for compatible */

 Clear all the IRQ properties */

 Mask out all PHYs from auto probing. */

 Register the MDIO bus */

/**

 * hns_mdio_remove - remove mdio device

 * @pdev: mdio platform device

 *

 * Return 0 on success, negative on failure

 SPDX-License-Identifier: GPL-2.0-or-later

/* Copyright (c) 2014 Linaro Ltd.

 * Copyright (c) 2014 Hisilicon Limited.

 DMA descriptor ring helpers */

 hardware supported max skb frags num */

 reserve one more frags for memory alignment */

 disable and clear all interrupts */

 software write pointer */

 logic read pointer */

 ensure desc updated */

 software read pointer */

 logic write pointer */

 ensure get updated desc */

 software read */

 logic write */

 software write pointer */

 ensure desc updated */

	/* To make sure PHY hardware reset success,

	 * we must keep PHY in deassert state first and

	 * then complete the hardware reset operation

	/* delay some time to ensure reset ok,

	 * this depends on PHY hardware feature

 delay some time to ensure later MDIO access */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Hisilicon Fast Ethernet MAC Driver

 *

 * Copyright (c) 2016 HiSilicon Technologies Co., Ltd.

 MAC control register list */

 global control register list */

 software tx and rx queue number, should be power of 2 */

 tell hardware we will deal with this packet */

 Handle multiple multicast addresses (perfect filtering)*/

 Handle multiple unicast addresses (perfect filtering)*/

	/* To make sure PHY hardware reset success,

	 * we must keep PHY in deassert state first and

	 * then complete the hardware reset operation

	/* delay some time to ensure reset ok,

	 * this depends on PHY hardware feature

 delay some time to ensure later MDIO access */

 MAC gets link status info and phy mode by software config */

clear all interrupt status */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) 2014-2015 Hisilicon Limited.

/**

 * hns_ppe_common_get_cfg - get ppe common config

 * @dsaf_dev: dasf device

 * @comm_index: common index

 * return 0 - success , negative --fail

/**

 * hns_ppe_checksum_hw - set ppe checksum caculate

 * @ppe_cb: ppe device

 * @value: value

/**

 * hns_ppe_set_qid - set ppe qid

 * @ppe_common: ppe common device

 * @qid: queue id

/**

 * hns_ppe_set_port_mode - set port mode

 * @ppe_cb: ppe device

 * @mode: port mode

/**

 * hns_ppe_common_init_hw - init ppe common device

 * @ppe_common: ppe common device

 *

 * Return 0 on success, negative on failure

clr ppe exception irq*/

1 is en, 0 is dis*/

only care bit 0,1,7*/

clr sts**/

for some reserved bits, so set 0**/

/**

 * hns_ppe_init_hw - init ppe

 * @ppe_cb: ppe device

 get default RSS key */

 clr and msk except irq*/

 set default RSS key in h/w */

 Set default indrection table in h/w */

/**

 * hns_ppe_uninit_hw - uninit ppe

 * @ppe_cb: ppe device

/**

 * hns_ppe_reset_common - reinit ppe/rcb hw

 * @dsaf_dev: dasf device

 * @ppe_common_index: the index

 * return void

 We only need to initiate ppe when the port exists */

/**

 * hns_ppe_get_strings - get ppe srting

 * @ppe_cb: ppe device

 * @stringset: string set type

 * @data: output string

/**

 * hns_ppe_init - init ppe device

 * @dsaf_dev: dasf device

 * return 0 - success , negative --fail

 ppe common registers */

 mark end of ppe regs */

 ppe channel registers */

 ppe static */

 mark end of ppe regs */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) 2014-2015 Hisilicon Limited.

/**

 *hns_mac_need_adjust_link - check is need change mac speed and duplex register

 *@mac_cb: mac device

 *@speed: phy device speed

 *@duplex:phy device duplex

 *

/**

 *hns_mac_get_inner_port_num - get mac table inner port number

 *@mac_cb: mac device

 *@vmid: vm id

 *@port_num:port number

 *

/**

 *hns_mac_change_vf_addr - change vf mac address

 *@mac_cb: mac device

 *@vmid: vmid

 *@addr:mac address

vlan_id;*/

/**

 * hns_mac_port_config_bc_en - set broadcast rx&tx enable

 * @mac_cb: mac device

 * @port_num: queue number

 * @vlan_id: vlan id`

 * @enable: enable

 * return 0 - success , negative --fail

 directy return ok in debug network mode */

/**

 * hns_mac_vm_config_bc_en - set broadcast rx&tx enable

 * @mac_cb: mac device

 * @vmid: vm id

 * @enable: enable

 * return 0 - success , negative --fail

 mac rx must disable, dsaf pfc close instead of it*/

 adjust max frame to be at least the size of a standard frame */

 for virt */

plus 1 when the virtual mac has been enabled */

modified for virtualization */

/**

 * hns_mac_get_autoneg - get auto autonegotiation

 * @mac_cb: mac control block

 * @auto_neg: output pointer to autoneg result

 * return 0 - success , negative --fail

/**

 * hns_mac_get_pauseparam - set rx & tx pause parameter

 * @mac_cb: mac control block

 * @rx_en: rx enable status

 * @tx_en: tx enable status

 * return 0 - success , negative --fail

/**

 * hns_mac_set_autoneg - set auto autonegotiation

 * @mac_cb: mac control block

 * @enable: enable or not

 * return 0 - success , negative --fail

/**

 * hns_mac_set_pauseparam - set rx & tx pause parameter

 * @mac_cb: mac control block

 * @rx_en: rx enable or not

 * @tx_en: tx enable or not

 * return 0 - success , negative --fail

/**

 * hns_mac_init_ex - mac init

 * @mac_cb: mac control block

 * return 0 - success , negative --fail

	/* All data is now stored in the phy struct;

	 * register it

 Loop over the child nodes and register a phy_device for each one */

 dev address in adev */

/**

 *hns_mac_get_info  - get mac information from device node

 *@mac_cb: mac device

 * return: 0 --success, negative --fail

	/* if the dsaf node doesn't contain a port subnode, get phy-handle

	 * from dsaf node

			/* refcount is held by of_phy_find_device()

			 * if the phy_dev is found

 parse property from port subnode in dsaf */

			/* refcount is held by of_phy_find_device()

			 * if the phy_dev is found

		/* Mac can work well if there is phy or not.If the port don't

		 * connect with phy, the return value will be ignored. Only

		 * when there is phy but can't find mdio bus, the return value

		 * will be handled.

/**

 * hns_mac_get_mode - get mac mode

 * @phy_if: phy interface

 * return 0 - gmac, 1 - xgmac , negative --fail

/**

 * hns_mac_get_cfg - get mac cfg from dtb or acpi table

 * @dsaf_dev: dsa fabric device struct pointer

 * @mac_cb: mac control block

 * return 0 - success , negative --fail

/**

 * hns_mac_init - init mac

 * @dsaf_dev: dsa fabric device struct pointer

 * return 0 - success , negative --fail

	/* if don't get any port subnode from dsaf node

	 * will init all port then, this is compatible with the old dts

 init mac_cb for all port */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) 2014-2015 Hisilicon Limited.

/**

 *hns_xgmac_tx_enable - xgmac port tx enable

 *@drv: mac driver

 *@value: value of enable

/**

 *hns_xgmac_rx_enable - xgmac port rx enable

 *@drv: mac driver

 *@value: value of enable

/**

 * hns_xgmac_lf_rf_insert - insert lf rf control about xgmac

 * @mac_drv: mac driver

 * @mode: inserf rf or lf

/**

 * hns_xgmac_lf_rf_control_init - initial the lf rf control register

 * @mac_drv: mac driver

/**

 *hns_xgmac_enable - enable xgmac port

 *@mac_drv: mac driver

 *@mode: mode of mac port

enable XGE rX/tX */

/**

 *hns_xgmac_disable - disable xgmac port

 *@mac_drv: mac driver

 *@mode: mode of mac port

/**

 *hns_xgmac_pma_fec_enable - xgmac PMA FEC enable

 *@drv: mac driver

 *@tx_value: tx value

 *@rx_value: rx value

 *return status

 clr exc irq for xge*/

1 is en, 0 is dis*/

/**

 *hns_xgmac_init - initialize XGE

 *@mac_drv: mac driver

/**

 *hns_xgmac_config_pad_and_crc - set xgmac pad and crc enable the same time

 *@mac_drv: mac driver

 *@newval:enable of pad and crc

/**

 *hns_xgmac_pausefrm_cfg - set pause param about xgmac

 *@mac_drv: mac driver

 *@rx_en: enable receive

 *@tx_en: enable transmit

/**

 *hns_xgmac_set_tx_auto_pause_frames - set tx pause param about xgmac

 *@mac_drv: mac driver

 *@enable:enable tx pause param

if enable is not zero ,set tx pause time */

/**

 *hns_xgmac_config_max_frame_length - set xgmac max frame length

 *@mac_drv: mac driver

 *@newval:xgmac max frame length

 TX */

 RX */

/**

 *hns_xgmac_free - free xgmac driver

 *@mac_drv: mac driver

/**

 *hns_xgmac_get_info - get xgmac information

 *@mac_drv: mac driver

 *@mac_info:mac information

/**

 *hns_xgmac_get_pausefrm_cfg - get xgmac pause param

 *@mac_drv: mac driver

 *@rx_en:xgmac rx pause enable

 *@tx_en:xgmac tx pause enable

/**

 *hns_xgmac_get_link_status - get xgmac link status

 *@mac_drv: mac driver

 *@link_stat: xgmac link stat

/**

 *hns_xgmac_get_regs - dump xgmac regs

 *@mac_drv: mac driver

 *@data:data for value of regs

 base config registers */

 status registers */

 RX */

 mark end of mac regs */

/**

 *hns_xgmac_get_stats - get xgmac statistic

 *@mac_drv: mac driver

 *@data:data for value of stats regs

/**

 *hns_xgmac_get_strings - get xgmac strings name

 *@stringset: type of values in data

 *@data:data for value of string name

/**

 *hns_xgmac_get_sset_count - get xgmac string set count

 *@stringset: type of values in data

 *return xgmac string set count

/**

 *hns_xgmac_get_regs_count - get xgmac regs count

 *return xgmac regs count

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) 2014-2015 Hisilicon Limited.

/**

 * hns_dsaf_srst_chns - reset dsaf channels

 * @dsaf_dev: dsaf device struct pointer

 * @msk: xbar channels mask value:

 * @dereset: false - request reset , true - drop reset

 *

 * bit0-5 for xge0-5

 * bit6-11 for ppe0-5

 * bit12-17 for roce0-5

 * bit18-19 for com/dfx

/**

 * hns_dsaf_srst_chns_acpi - reset dsaf channels

 * @dsaf_dev: dsaf device struct pointer

 * @msk: xbar channels mask value:

 * @dereset: false - request reset , true - drop reset

 *

 * bit0-5 for xge0-5

 * bit6-11 for ppe0-5

 * bit12-17 for roce0-5

 * bit18-19 for com/dfx

		/* DSAF_MAX_PORT_NUM is 6, but DSAF_GE_NUM is 8.

 there is difference between V1 and V2 in register.*/

/**

 * hns_mac_get_phy_if - get phy ifterface form serdes mode

 * @mac_cb: mac control block

 * retuen phy interface

/**

 * hns_mac_config_sds_loopback - set loop back for serdes

 * @mac_cb: mac control block

 * @en: enable or disable

 * return 0 == success

 mac 0 -> lane 0 */

 mac 1 -> lane 1 */

 mac 2 -> lane 2 */

 mac 3 -> lane 3 */

 mac 4 -> lane 2 */

 mac 5 -> lane 3 */

 mac 6 -> lane 0 */

 mac 7 -> lane 1 */

			/* hilink4 & hilink3 use the same xge training and

			 * xge u adaptor. There is a hilink access sel cfg

			 * register to select which one to be configed

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) 2014-2015 Hisilicon Limited.

enable GE rX/tX */

 enable rx pcs */

disable GE rX/tX */

 disable rx pcs */

/* hns_gmac_get_en - get port enable

 * @mac_drv:mac device

 * @rx:rx enable

 * @tx:tx enable

 bit5~bit0 is not send complete pkts */

	/* reduce gmac tx water line to avoid gmac hang-up

	 * in speed 100M and duplex half.

 RX */

 TX */

 base config registers */

 rx static registers */

 tx static registers */

 mark end of mac regs */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) 2014-2015 Hisilicon Limited.

/**

 * hns_dsaf_sbm_link_sram_init_en - config dsaf_sbm_init_en

 * @dsaf_dev: dsa fabric id

/**

 * hns_dsaf_reg_cnt_clr_ce - config hns_dsaf_reg_cnt_clr_ce

 * @dsaf_dev: dsa fabric id

 * @reg_cnt_clr_ce: config value

/**

 * hns_dsaf_ppe_qid_cfg - config ppe qid

 * @dsaf_dev: dsa fabric id

 * @qid_cfg: value array

/**

 * hns_dsaf_sw_port_type_cfg - cfg sw type

 * @dsaf_dev: dsa fabric id

 * @port_type: array

/**

 * hns_dsaf_stp_port_type_cfg - cfg stp type

 * @dsaf_dev: dsa fabric id

 * @port_type: array

/**

 * hns_dsaf_sbm_cfg - config sbm

 * @dsaf_dev: dsa fabric id

/**

 * hns_dsaf_sbm_cfg_mib_en - config sbm

 * @dsaf_dev: dsa fabric id

 validate configure by setting SBM_CFG_MIB_EN bit from 0 to 1. */

 waitint for all sbm enable finished */

/**

 * hns_dsaf_sbm_bp_wl_cfg - config sbm

 * @dsaf_dev: dsa fabric id

 XGE */

 for no enable pfc mode */

 PPE */

 RoCEE */

 XGE */

 for no enable pfc mode */

 PPE */

 RoCEE */

/**

 * hns_dsaf_voq_bp_all_thrd_cfg -  voq

 * @dsaf_dev: dsa fabric id

/**

 * hns_dsaf_tbl_tcam_data_cfg - tbl

 * @dsaf_dev: dsa fabric id

 * @ptbl_tcam_data: addr

/**

 * hns_dsaf_tbl_tcam_mcast_cfg - tbl

 * @dsaf_dev: dsa fabric id

 * @mcast: addr

/**

 * hns_dsaf_tbl_tcam_ucast_cfg - tbl

 * @dsaf_dev: dsa fabric id

 * @tbl_tcam_ucast: addr

/**

 * hns_dsaf_tbl_line_cfg - tbl

 * @dsaf_dev: dsa fabric id

 * @tbl_lin: addr

/**

 * hns_dsaf_tbl_tcam_mcast_pul - tbl

 * @dsaf_dev: dsa fabric id

/**

 * hns_dsaf_tbl_line_pul - tbl

 * @dsaf_dev: dsa fabric id

/**

 * hns_dsaf_tbl_tcam_data_mcast_pul - tbl

 * @dsaf_dev: dsa fabric id

/**

 * hns_dsaf_tbl_tcam_data_ucast_pul - tbl

 * @dsaf_dev: dsa fabric id

/**

 * hns_dsaf_tbl_stat_en - tbl

 * @dsaf_dev: dsa fabric id

/**

 * hns_dsaf_rocee_bp_en - rocee back press enable

 * @dsaf_dev: dsa fabric id

 set msk for dsaf exception irq*/

 clr dsaf exception irq*/

/**

 * hns_dsaf_single_line_tbl_cfg - INT

 * @dsaf_dev: dsa fabric id

 * @address: the address

 * @ptbl_line: the line

Write Addr*/

Write Line*/

Write Plus*/

/**

 * hns_dsaf_tcam_uc_cfg - INT

 * @dsaf_dev: dsa fabric id

 * @address: the address

 * @ptbl_tcam_data: the data

 * @ptbl_tcam_ucast: unicast

Write Addr*/

Write Tcam Data*/

Write Tcam Ucast*/

Write Plus*/

/**

 * hns_dsaf_tcam_mc_cfg - cfg the tcam for mc

 * @dsaf_dev: dsa fabric device struct pointer

 * @address: tcam index

 * @ptbl_tcam_data: tcam data struct pointer

 * @ptbl_tcam_mask: tcam mask struct pointer, it must be null for HNSv1

 * @ptbl_tcam_mcast: tcam data struct pointer

Write Addr*/

Write Tcam Data*/

Write Tcam Mcast*/

 Write Match Data */

 Write Puls */

/**

 * hns_dsaf_tcam_uc_cfg_vague - INT

 * @dsaf_dev: dsa fabric device struct pointer

 * @address: the address

 * @tcam_data: the data

 * @tcam_mask: the mask

 * @tcam_uc: the unicast data

Restore Match Data*/

/**

 * hns_dsaf_tcam_mc_cfg_vague - INT

 * @dsaf_dev: dsa fabric device struct pointer

 * @address: the address

 * @tcam_data: the data

 * @tcam_mask: the mask

 * @tcam_mc: the multicast data

Restore Match Data*/

/**

 * hns_dsaf_tcam_mc_invld - INT

 * @dsaf_dev: dsa fabric id

 * @address: the address

Write Addr*/

write tcam mcast*/

Write Plus*/

/**

 * hns_dsaf_tcam_uc_get - INT

 * @dsaf_dev: dsa fabric id

 * @address: the address

 * @ptbl_tcam_data: the data

 * @ptbl_tcam_ucast: unicast

Write Addr*/

read tcam item puls*/

read tcam data*/

read tcam mcast*/

/**

 * hns_dsaf_tcam_mc_get - INT

 * @dsaf_dev: dsa fabric id

 * @address: the address

 * @ptbl_tcam_data: the data

 * @ptbl_tcam_mcast: tcam multicast data

Write Addr*/

read tcam item puls*/

read tcam data*/

read tcam mcast*/

/**

 * hns_dsaf_tbl_line_init - INT

 * @dsaf_dev: dsa fabric id

 defaultly set all lineal mac table entry resulting discard */

/**

 * hns_dsaf_tbl_tcam_init - INT

 * @dsaf_dev: dsa fabric id

tcam tbl*/

/**

 * hns_dsaf_pfc_en_cfg - dsaf pfc pause cfg

 * @dsaf_dev: dsa fabric id

 * @mac_id: mac contrl block

 * @tc_en: traffic class

/**

 * hns_dsaf_comm_init - INT

 * @dsaf_dev: dsa fabric id

 set 22 queue per tx ppe engine, only used in switch mode */

 set promisc def queue id */

 set inner loopback queue id */

 in non switch mode, set all port to access mode */

set dsaf pfc  to 0 for parseing rx pause*/

msk and  clr exception irqs */

/**

 * hns_dsaf_inode_init - INT

 * @dsaf_dev: dsa fabric id

/**

 * hns_dsaf_sbm_init - INT

 * @dsaf_dev: dsa fabric id

 enable sbm chanel, disable sbm chanel shcut function*/

 enable sbm mib */

 enable sbm initial link sram */

udelay(200);*/

/**

 * hns_dsaf_tbl_init - INT

 * @dsaf_dev: dsa fabric id

/**

 * hns_dsaf_voq_init - INT

 * @dsaf_dev: dsa fabric id

/**

 * hns_dsaf_init_hw - init dsa fabric hardware

 * @dsaf_dev: dsa fabric device struct pointer

init XBAR_INODE*/

init SBM*/

init TBL*/

init VOQ*/

/**

 * hns_dsaf_remove_hw - uninit dsa fabric hardware

 * @dsaf_dev: dsa fabric device struct pointer

reset*/

/**

 * hns_dsaf_init - init dsa fabric

 * @dsaf_dev: dsa fabric device struct pointer

 * return 0 - success , negative --fail

 malloc mem for tcam mac key(vlan+mac) */

all entry invall */

/**

 * hns_dsaf_free - free dsa fabric

 * @dsaf_dev: dsa fabric device struct pointer

 free all mac mem */

/**

 * hns_dsaf_find_soft_mac_entry - find dsa fabric soft entry

 * @dsaf_dev: dsa fabric device struct pointer

 * @mac_key: mac entry struct pointer

 invall tab entry */

 return find result --soft index */

/**

 * hns_dsaf_find_empty_mac_entry - search dsa fabric soft empty-entry

 * @dsaf_dev: dsa fabric device struct pointer

 inv all entry */

 return find result --soft index */

/**

 * hns_dsaf_find_empty_mac_entry_reverse

 * search dsa fabric soft empty-entry from the end

 * @dsaf_dev: dsa fabric device struct pointer

 search all entry from end to start.*/

/**

 * hns_dsaf_set_mac_key - set mac key

 * @dsaf_dev: dsa fabric device struct pointer

 * @mac_key: tcam key pointer

 * @vlan_id: vlan id

 * @in_port_num: input port num

 * @addr: mac addr

DSAF mode : in port id fixed 0*/

non-dsaf mode*/

/**

 * hns_dsaf_set_mac_uc_entry - set mac uc-entry

 * @dsaf_dev: dsa fabric device struct pointer

 * @mac_entry: uc-mac entry

 mac addr check */

 config key */

 entry ie exist? */

if has not inv entry,find a empty entry */

 has not empty,return error */

 config hardware entry */

 default config dvc to 0 */

 config software entry */

 mac addr check */

 config key */

 can not find the tcam entry, return 0 */

 unicast entry not used locally should not clear */

/**

 * hns_dsaf_add_mac_mc_port - add mac mc-port

 * @dsaf_dev: dsa fabric device struct pointer

 * @mac_entry: mc-mac entry

chechk mac addr */

 prepare for key data setting */

 config key mask */

config key */

 check if the tcam is exist */

if hasnot , find a empty*/

if hasnot empty, error*/

 if exist, add in */

 config hardware entry */

 config mc entry with mask */

config software entry */

/**

 * hns_dsaf_del_mac_entry - del mac mc-port

 * @dsaf_dev: dsa fabric device struct pointer

 * @vlan_id: vlian id

 * @in_port_num: input port num

 * @addr : mac addr

check mac addr */

config key */

exist ?*/

not exist, error */

do del opt*/

del soft emtry */

/**

 * hns_dsaf_del_mac_mc_port - del mac mc- port

 * @dsaf_dev: dsa fabric device struct pointer

 * @mac_entry: mac entry

check mac addr */

 always mask vlan_id field */

 prepare for key data setting */

 config key mask */

 get key info */

 config key */

 check if the tcam entry is exist */

find none */

 read entry */

del the port*/

check non port, do del entry */

 del soft entry */

 not zero, just del port, update */

 check valid tcam mc entry */

			/* disable receiving of this multicast address for

			 * the VF.

			/* disable receiving of this multicast address for

			 * the mac port if all VF are disable

/**

 * hns_dsaf_free_dev - free dev mem

 * @dsaf_dev: struct device pointer

/**

 * hns_dsaf_pfc_unit_cnt - set pfc unit count

 * @dsaf_dev: dsa fabric id

 * @mac_id: id in use

 * @rate:  value array

/**

 * hns_dsaf_port_work_rate_cfg - fifo

 * @dsaf_dev: dsa fabric id

 * @mac_id: mac contrl block

 * @rate_mode: value array

/**

 * hns_dsaf_fix_mac_mode - dsaf modify mac mode

 * @mac_cb: mac contrl block

 pfc pause frame statistics stored in dsaf inode*/

/**

 *hns_dsaf_get_regs - dump dsaf regs

 *@ddev: dsaf device

 *@port: port

 *@data:data for value of regs

 dsaf common registers */

 dsaf inode registers */

 dsaf inode registers */

 dsaf onode registers */

 dsaf voq registers */

 dsaf tbl registers */

 dsaf other registers */

 mark end of dsaf regs */

/**

 *hns_dsaf_get_stats - get dsaf statistic

 *@ddev: dsaf device

 *@data:statistic value

 *@port: port num

 for ge/xge node info */

 for ppe node info */

/**

 *hns_dsaf_get_sset_count - get dsaf string set count

 *@dsaf_dev: dsaf device

 *@stringset: type of values in data

 *return dsaf string name count

/**

 *hns_dsaf_get_strings - get dsaf string set

 *@stringset:srting set index

 *@data:strings name value

 *@port:port index

 *@dsaf_dev: dsaf device

 for ge/xge node info */

 for ppe node info */

/**

 *hns_dsaf_get_regs_count - get dsaf regs count

 *return dsaf regs count

 promisc use vague table match with vlanid = 0 & macaddr = 0 */

 put promisc tcam entry in the end. */

 1. set promisc unicast vague tcam entry. */

 config uc vague table */

 update software entry */

 step back to the START for mc. */

 2. set promisc multicast vague tcam entry. */

 set MAC port to handle multicast */

 set pool bit map to handle multicast */

 update software entry */

 1. delete uc vague tcam entry. */

 promisc use vague table match with vlanid = 0 & macaddr = 0 */

 config uc vague table */

 update soft management table. */

 step back to the START for mc. */

 2. delete mc vague tcam entry. */

 config mc vague table */

 update soft management table. */

 Reserve the last TCAM entry for promisc support */

/**

 * hns_dsaf_probe - probo dsaf dev

 * @pdev: dasf platform device

 * return 0 - success , negative --fail

/**

 * hns_dsaf_remove - remove dsaf dev

 * @pdev: dasf platform device

/**

 * hns_dsaf_roce_reset - reset dsaf and roce

 * @dsaf_fwnode: Pointer to framework node for the dasf

 * @dereset: false - request reset , true - drop reset

 * return 0 - success , negative -fail

 find the platform device corresponding to fwnode */

 check if we were a success in fetching pdev */

 retrieve the dsaf_device from the driver data */

 now, make sure we are running on compatible SoC */

 do reset or de-reset according to the flag */

 reset rocee-channels in dsaf and rocee */

 configure dsaf tx roce correspond to port map and sl map */

 de-reset rocee-channels in dsaf and rocee */

 enable dsaf channel rocee credit */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) 2014-2015 Hisilicon Limited.

 Because default mtu is 1500, rcb buffer size is set to 2048 enough */

/**

 *hns_rcb_wait_fbd_clean - clean fbd

 *@qs: ring struct pointer array

 *@q_num: num of array

 *@flag: tx or rx flag

/**

 *hns_rcb_reset_ring_hw - ring reset

 *@q: ring struct pointer

/**

 *hns_rcb_int_ctrl_hw - rcb irq enable control

 *@q: hnae queue struct pointer

 *@flag:ring flag tx or rx

 *@mask:mask

/**

 *hns_rcb_ring_enable_hw - enable ring

 *@q: rcb ring

 *@val: value to write

/**

 *hns_rcb_common_init_commit_hw - make rcb common init completed

 *@rcb_common: rcb common device

 Sync point before breakpoint */

 Sync point after breakpoint */

/* hns_rcb_set_tx_ring_bs - init rcb ring buf size regester

 *@q: hnae_queue

 *@buf_size: buffer size set to hw

/* hns_rcb_set_rx_ring_bs - init rcb ring buf size regester

 *@q: hnae_queue

 *@buf_size: buffer size set to hw

/**

 *hns_rcb_ring_init - init rcb ring

 *@ring_pair: ring pair control block

 *@ring_type: ring type, RX_RING or TX_RING

/**

 *hns_rcb_init_hw - init rcb hardware

 *@ring: rcb ring

/**

 *hns_rcb_set_port_desc_cnt - set rcb port description num

 *@rcb_common: rcb_common device

 *@port_idx:port index

 *@desc_cnt:BD num

clr rcb comm exception irq**/

 clr int*/

en msk*/

for tx bd neednot cacheline, so msk sf_txring_fbd_intmask (bit 1)**/

/**

 *hns_rcb_common_init_hw - init rcb common hardware

 *@rcb_common: rcb_common device

 *retuen 0 - success , negative --fail

/**

 *hns_rcb_get_cfg - get rcb config

 *@rcb_common: rcb common device

/**

 *hns_rcb_get_rx_coalesced_frames - get rcb port rx coalesced frames

 *@rcb_common: rcb_common device

 *@port_idx:port id in comm

 *

 *Returns: coalesced_frames

/**

 *hns_rcb_get_tx_coalesced_frames - get rcb port tx coalesced frames

 *@rcb_common: rcb_common device

 *@port_idx:port id in comm

 *

 *Returns: coalesced_frames

/**

 *hns_rcb_get_coalesce_usecs - get rcb port coalesced time_out

 *@rcb_common: rcb_common device

 *@port_idx:port id in comm

 *

 *Returns: time_out

/**

 *hns_rcb_set_coalesce_usecs - set rcb port coalesced time_out

 *@rcb_common: rcb_common device

 *@port_idx:port id in comm

 *@timeout:tx/rx time for coalesced time_out

 *

 * Returns:

 * Zero for success, or an error code in case of failure

/**

 *hns_rcb_set_tx_coalesced_frames - set rcb coalesced frames

 *@rcb_common: rcb_common device

 *@port_idx:port id in comm

 *@coalesced_frames:tx/rx BD num for coalesced frames

 *

 * Returns:

 * Zero for success, or an error code in case of failure

/**

 *hns_rcb_set_rx_coalesced_frames - set rcb rx coalesced frames

 *@rcb_common: rcb_common device

 *@port_idx:port id in comm

 *@coalesced_frames:tx/rx BD num for coalesced frames

 *

 * Returns:

 * Zero for success, or an error code in case of failure

/**

 *hns_rcb_get_queue_mode - get max VM number and max ring number per VM

 *						accordding to dsaf mode

 *@dsaf_mode: dsaf mode

 *@max_vfn : max vfn number

 *@max_q_per_vf:max ring number per vm

/**

 *hns_rcb_get_stats - get rcb statistic

 *@queue: rcb ring

 *@data:statistic value

/**

 *hns_rcb_get_ring_sset_count - rcb string set count

 *@stringset:ethtool cmd

 *return rcb ring string set count

/**

 *hns_rcb_get_common_regs_count - rcb common regs count

 *return regs count

/**

 *hns_rcb_get_ring_regs_count - rcb ring regs count

 *return regs count

/**

 *hns_rcb_get_strings - get rcb string set

 *@stringset:string set index

 *@data:strings name value

 *@index:queue index

rcb common registers */

 rcb common entry registers */

 total 16 model registers */

 mark end of rcb common regs */

rcb ring registers */

 mark end of ring regs */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) 2014-2015 Hisilicon Limited.

 ae_handle Init  */

 find ring pair, and set vf id*/

 when buf_size is 2048, max mtu is 6K for rx ring max bd num is 3. */

 reinit ring buf_size */

 just clean tx fbd, neednot rx fbd*/

 clean rx fbd. */

 chip need to clear all pkt inside */

 Service port's pause feature is provided by DSAF, not mac */

 Service port's pause feature is provided by DSAF, not mac */

 for port upline direction, i.e., rx. */

 for port downline direction, i.e., tx. */

 currently we support only one type of hash function i.e. Toep hash */

 get the RSS Key required by the user */

 update the current hash->queue mappings from the shadow RSS table */

 set the RSS Hash Key if specififed by the user */

 update the shadow RSS table with user specified qids */

 now update the hardware */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) 2014-2015 Hisilicon Limited.

 Allocate memory for raw pkg, and map with dma */

 free desc along with its attached buffer */

 alloc desc, without buffer attached */

 fini ring, also free the buffer for the ring */

 init ring, and with buffer for rx ring */

 not matter for tx or rx ring, the ntc and ntc start from 0 */

/*

 * ae_chain - define ae chain head

 free ring*/

 reinit ring*/

/* hnae_get_handle - get a handle from the AE

 * @owner_dev: the dev use this handle

 * @ae_id: the id of the ae to be used

 * @ae_opts: the options set for the handle

 * @bops: the callbacks for buffer management

 *

 * return handle ptr or ERR_PTR

/**

 * hnae_ae_register - register a AE engine to hnae framework

 * @hdev: the hnae ae engine device

 * @owner:  the module who provides this dev

 * NOTE: the duplicated name will not be checked

/**

 * hnae_ae_unregister - unregisters a HNAE AE engine

 * @hdev: the device to unregister

 vi: set tw=78 noet: */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) 2014-2015 Hisilicon Limited.

 Page Selection Reg. */

 Copper Specific Control Register */

 Copper Specific Status Register */

 LED Function Control Reg. */

/**

 *hns_nic_get_link - get current link status

 *@net_dev: net_device

 *retuen 0 - success , negative --fail

/**

 *hns_nic_get_link_ksettings - implement ethtool get link ksettings

 *@net_dev: net_device

 *@cmd: ethtool_link_ksettings

 *retuen 0 - success , negative --fail

 When there is no phy, autoneg is off. */

/**

 *hns_nic_set_link_ksettings - implement ethtool set link ksettings

 *@net_dev: net_device

 *@cmd: ethtool_link_ksettings

 *retuen 0 - success , negative --fail

		/* Doing phy loopback in offline state, phy resuming is

		 * needed to power up the device.

 link adjust duplex*/

 wait adjust link done and phy ready */

 32B data and the last character '\0' */

 Just for doing create frame*/

 for tx queue reset*/

 for mutl buffer*/

 for rx check frame*/

 tailing \0*/

/**

 * __lb_run_test -  run loopback test

 * @ndev: net device

 * @loop_mode: loopback mode

 nic loopback test err  */

 allocate test skb */

 place data into test skb */

 reset count of good packets */

 place 64 packets on the transmit queue*/

 allow 100 milliseconds for packets to go from Tx to Rx */

 free the original skb */

/**

 * hns_nic_self_test - self test

 * @ndev: net device

 * @eth_test: test cmd

 * @data: test result

 XGE not supported lb */

serdes must exist*/

 only supporte phy node*/

 NEXT testing */

 Online tests aren't run; pass by default */

/**

 * hns_nic_get_drvinfo - get net driver info

 * @net_dev: net device

 * @drvinfo: driver info

/**

 * hns_get_ringparam - get ring parameter

 * @net_dev: net device

 * @param: ethtool parameter

/**

 * hns_get_pauseparam - get pause parameter

 * @net_dev: net device

 * @param: pause parameter

/**

 * hns_set_pauseparam - set pause parameter

 * @net_dev: net device

 * @param: pause parameter

 *

 * Return 0 on success, negative on failure

/**

 * hns_get_coalesce - get coalesce info.

 * @net_dev: net device

 * @ec: coalesce info.

 * @kernel_coal: ethtool CQE mode setting structure

 * @extack: extack for reporting error messages

 *

 * Return 0 on success, negative on failure.

/**

 * hns_set_coalesce - set coalesce info.

 * @net_dev: net device

 * @ec: coalesce info.

 * @kernel_coal: ethtool CQE mode setting structure

 * @extack: extack for reporting error messages

 *

 * Return 0 on success, negative on failure.

/**

 * hns_get_channels - get channel info.

 * @net_dev: net device

 * @ch: channel info.

/**

 * hns_get_ethtool_stats - get detail statistics.

 * @netdev: net device

 * @stats: statistics info.

 * @data: statistics data.

 get netdev statistics */

 get driver statistics */

/**

 * hns_get_strings: Return a set of strings that describe the requested objects

 * @netdev: net device

 * @stringset: string set ID.

 * @data: objects data.

/**

 * hns_get_sset_count - get string set count returned by nic_get_strings

 * @netdev: net device

 * @stringset: string set index, 0: self test string; 1: statistics string.

 *

 * Return string set count.

/**

 * hns_phy_led_set - set phy LED status.

 * @netdev: net device

 * @value: LED state.

 *

 * Return 0 on success, negative on failure.

/**

 * hns_set_phys_id - set phy identify LED.

 * @netdev: net device

 * @state: LED state.

 *

 * Return 0 on success, negative on failure.

/**

 * hns_get_regs - get net device register

 * @net_dev: net device

 * @cmd: ethtool cmd

 * @data: register data

/**

 * hns_get_regs_len - get total register len.

 * @net_dev: net device

 *

 * Return total register len.

 error code */

/**

 * hns_nic_nway_reset - nway reset

 * @netdev: net device

 *

 * Return 0 on success, negative on failure

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) 2014-2015 Hisilicon Limited.

 config bd buffer end */

 fill port_id in the tx bd for sending management pkts */

 check for tcp/udp header */

 check for tcp/udp header */

config bd buffer end */

if it is a SW VLAN check the next protocol*/

 check for tcp/udp header */

 ipv6 has not l3 cs, check for L4 header */

 no. of segments (plus a header) */

 manual split the send packet */

 when the frag size is bigger than hardware, split this frag */

 no. of segments (plus a header) */

 fill the first part */

 fill the fragments */

complete translate all packets*/

 commit all data before submit */

	/* Herbert's original patch had:

	 *  smp_mb__after_netif_stop_queue();

	 * but since that doesn't exist yet, just open code it.

 avoid re-using remote pages,flag default unreuse */

 if we are only owner of page we can reuse it */

 flip page offset to other buffer */

 bump ref count on page before it is given*/

 move offset up to the next cache line */

 bump ref count on page before it is given*/

 check if RX checksum offload is enabled */

	/* In hardware, we only support checksum for the following protocols:

	 * 1) IPv4,

	 * 2) TCP(over IPv4 or IPv6),

	 * 3) UDP(over IPv4 or IPv6),

	 * 4) SCTP(over IPv4 or IPv6)

	 * but we support many L3(IPv4, IPv6, MPLS, PPPoE etc) and L4(TCP,

	 * UDP, GRE, SCTP, IGMP, ICMP etc.) protocols.

	 *

	 * Hardware limitation:

	 * Our present hardware RX Descriptor lacks L3/L4 checksum "Status &

	 * Error" bit (which usually can be used to indicate whether checksum

	 * was calculated by the hardware and if there was any error encountered

	 * during checksum calculation).

	 *

	 * Software workaround:

	 * We do get info within the RX descriptor about the kind of L3/L4

	 * protocol coming in the packet and the error status. These errors

	 * might not just be checksum errors but could be related to version,

	 * length of IPv4, UDP, TCP etc.

	 * Because there is no-way of knowing if it is a L3/L4 error due to bad

	 * checksum or any other L3/L4 error, we will not (cannot) convey

	 * checksum status for such cases to upper stack and will not maintain

	 * the RX L3/L4 checksum counters as well.

  check L3 protocol for which checksum is supported */

 check for any(not just checksum)flagged L3 protocol errors */

 we do not support checksum of fragmented packets */

  check L4 protocol for which checksum is supported */

 check for any(not just checksum)flagged L4 protocol errors */

 now, this has to be a packet with valid RX checksum */

 prefetch first cache line of first page */

 we can reuse buffer as-is, just make sure it is local */

 this page cannot be reused so discard it */

 check err*/

 check err*/

 check except process, free skb and jump the desc */

 ntc moved,cannot 0*/

	/* indicate to upper stack if our hardware has already calculated

	 * the RX checksum

 make all data has been write before submit */

/* return error number for error or number of desc left to take

 27 MB/s */

 80 MB/s */

 ring->stats.rx_bytes overflowed */

/**

 * smooth_alg - smoothing algrithm for adjusting coalesce parameter

 * @new_param: new value

 * @old_param: old value

/**

 * hns_nic_adpt_coalesce - self adapte coalesce according to rx rate

 * @ring_data: pointer to hns_nic_ring_data

	/**

	 * Because all ring in one port has one coalesce param, when one ring

	 * calculate its own coalesce param, it cannot write to hardware at

	 * once. There are three conditions as follows:

	 *       1. current ring's coalesce param is larger than the hardware.

	 *       2. or ring which adapt last time can change again.

	 *       3. timeout.

 make sure num taken effect before the other data is touched */

 reuse or realloc buffers */

 poll one pkt */

 this fault cannot be repaired */

 do jump the err */

 do update ip stack process*/

 make all data has been write before submit */

 for hardware bug fixed */

 desc_cb will be cleaned, after hnae_free_buffer_detach*/

 must be checked before call this func */

/* reclaim all desc in one budget

 * return error or number of desc left

 make sure head is ready before touch any data */

 no data to poll */

 issue prefetch for next Tx descriptor */

 update tx ring statistics. */

		/* Make sure that anybody stopping the queue after this

		 * sees the new next_to_clean.

 ntu :soft setted ring position*/

/**

 *hns_nic_adjust_link - adjust net work mode by the phy stat or new param

 *@ndev: net device

 If there is no phy, do not need adjust link */

 When phy link down, do nothing */

			/* because Hi161X chip don't support to change gmac

			 * speed and duplex with traffic. Delay 200ms to

			 * make sure there is no more data in chip FIFO.

/**

 *hns_nic_init_phy - init phy

 *@ndev: net device

 *@h: ae handle

 * Return 0 on success, negative on failure

 set mac addr if it is configed. or leave it to the AE driver */

	/* Different irq balance between 16core and 32core.

	 * The cpu mask set by ring index according to the ring flag

	 * which indicate the ring is tx or rx.

 clean tx buffers*/

	/* Only do hns_nic_net_reset in debug mode

	 * because of hardware limitation.

 allocate test skb */

 must be tcp/ip package */

 link adjust duplex*/

 wait h/w ready */

/**

 *hns_nic_clear_all_rx_fetch - clear the chip fetched descriptions. The

 *function as follows:

 *    1. if one rx ring has found the page_offset is not equal 0 between head

 *       and tail, it means that the chip fetched the wrong descs for the ring

 *       which buffer size is 4096.

 *    2. we set the chip serdes loopback and set rss indirection to the ring.

 *    3. construct 64-bytes ip broadcast packages, wait the associated rx ring

 *       receiving all packages and it will fetch new descriptions.

 *    4. recover to the original state.

 *

 *@ndev: net device

 alloc indir memory */

 store the original indirection */

 set loopback */

 foreach every rx ring to clear fetch desc */

 alloc one skb and init */

 clean rx */

 clean tx ring 0 send package */

 restore everything */

 MTU < 68 is an error and causes problems on some kernels */

 MTU no change */

 update desc */

 clear the package which the chip has fetched */

 the page offset must be consist with desc */

 finally, set new mtu to netdevice */

 The chip only support 7*4096 */

/**

 * hns_set_multicast_list - set mutl mac address

 * @ndev: net device

 *

 * return void

 fix hardware broadcast/multicast packets queue loopback */

 for dumping key regs*/

 for resetting subtask */

 If we're already down, removing or resetting, just bail */

 put off any impending NetWatchDogTimeout */

 for doing service complete*/

 make sure to commit the things */

/**

 * hns_tx_timeout_reset - initiate reset due to Tx timeout

 * @priv: driver private struct

 Do the reset outside of interrupt context */

 This chip only support 7*4096 */

		/* enable tso when init

		 * control tso on/off through TSE bit in bd

 try to find port-idx-in-ae first */

 only for old code compatible */

 for old dts, we need to caculate the port offset */

 MTU range: 68 - 9578 (v1) or 9706 (v2) */

 carrier off reporting is important to ethtool even BEFORE open */

 safe for ACPI FW */

 safe for ACPI FW */

 SPDX-License-Identifier: GPL-2.0+

 Copyright (c) 2016-2017 Hisilicon Limited.

 DCBX configuration */

 return 0 if successful, otherwise fail */

/* hclge_dcbnl_setup - DCBNL setup

 * @handle: the corresponding vport handle

 * Set up DCBNL

 SPDX-License-Identifier: GPL-2.0+

 Copyright (c) 2016-2017 Hisilicon Limited.

/* we are keeping things simple and using single lock for all the

 * list. This is a non-critical code so other updations, if happen

 * in parallel, can wait.

 check if this client matches the type of ae_dev */

 check if this client matches the type of ae_dev */

 one system should only have one client for every type */

 initialize the client on every matched port */

		/* if the client could not be initialized on current port, for

		 * any error reasons, move on to next available port

 one system should only have one client for every type */

 un-initialize the client on every matched port */

/* hnae3_register_ae_algo - register a AE algorithm to hnae3 framework

 * @ae_algo: AE algorithm

 * NOTE: the duplicated name will not be checked

 Check if this algo/ops matches the list of ae_devs */

 ae_dev init should set flag */

		/* check the client list for the match with this ae_dev type and

		 * initialize the figure out client instance

/* hnae3_unregister_ae_algo - unregisters a AE algorithm

 * @ae_algo: the AE algorithm to unregister

 Check if there are matched ae_dev */

		/* check the client list for the match with this ae_dev type and

		 * un-initialize the figure out client instance

/* hnae3_register_ae_dev - registers a AE device to hnae3 framework

 * @ae_dev: the AE device

 * NOTE: the duplicated name will not be checked

 Check if there are matched ae_algo */

 ae_dev init should set flag */

	/* check the client list for the match with this ae_dev type and

	 * initialize the figure out client instance

/* hnae3_unregister_ae_dev - unregisters a AE device

 * @ae_dev: the AE device to unregister

 Check if there are matched ae_algo */

 SPDX-License-Identifier: GPL-2.0+

 Copyright (c) 2018-2019 Hisilicon Limited. */

 keep common at the bottom and add new directory above */

		/* Each cycle needs to determine whether the instance is reset,

		 * to prevent reference to invalid memory. And need to ensure

		 * that the following code is executed within 100ms.

		/* Each cycle needs to determine whether the instance is reset,

		 * to prevent reference to invalid memory. And need to ensure

		 * that the following code is executed within 100ms.

 save the buffer addr until the last read operation */

 get data ready for the first time to read */

 free the buffer for the last read operation */

 SPDX-License-Identifier: GPL-2.0+

 Copyright (c) 2016-2017 Hisilicon Limited.

/* All hns3 tracepoints are defined by the include below, which

 * must be included exactly once across the whole kernel with

 * CREATE_TRACE_POINTS defined

/* hns3_pci_tbl - PCI Device ID Table

 *

 * Last entry must be all 0s

 *

 * { Vendor ID, Device ID, SubVendor ID, SubDevice ID,

 *   Class, Class Mask, private data (not used) }

 required last entry */

 clear the affinity mask */

 release the irq resource */

 Skip this unused q_vector */

 enable vector */

 disable vector */

	/* this defines the configuration for RL (Interrupt Rate Limiter).

	 * Rl defines rate of interrupts i.e. number of interrupts-per-second

	 * GL and RL(Rate Limiter) are 2 ways to acheive interrupt coalescing

		/* According to the hardware, the range of rl_reg is

		 * 0-59 and the unit is 4.

	/* device version above V3(include V3), GL can configure 1us

	 * unit, so uses 1us unit.

 enable the vectors */

 enable rcb */

 start the ae_dev */

 disable vectors */

 disable rcb */

 stop ae_dev */

	/* delay ring buffer clearing to hns3_reset_notify_uninit_enet

	 * during reset process, because driver may not be able

	 * to disable the ring through firmware when downing the netdev.

	/* need ignore the request of removing device address, because

	 * we store the device address and other addresses of uc list

	 * in the function's mac filter list.

	/* User mode Promisc mode enable and vlan filtering is disabled to

	 * let all packets in.

	/* This smp_load_acquire() pairs with smp_store_release() in

	 * hns3_tx_spare_update() called in tx desc cleaning process.

	/* The free tx buffer is divided into two part, so pick the

	 * larger one.

	/* This smp_store_release() pairs with smp_load_acquire() in

	 * hns3_tx_spare_space() called in xmit process.

 The driver still work without the tx spare buffer */

/* Use hns3_tx_spare_space() to make sure there is enough buffer

 * before calling below function to allocate tx buffer.

	/* Tx spare buffer wraps back here because the end of

	 * freed tx buffer is not enough.

	/* This tx spare buffer is only really reclaimed after calling

	 * hns3_tx_spare_update(), so it is still safe to use the info in

	 * the tx buffer to do the dma sync or sg unmapping after

	 * tx_spare->next_to_clean is moved forword.

	/* Software should clear the IPv4's checksum field when tso is

	 * needed.

 tunnel packet */

 reset l3&l4 pointers from outer to inner headers */

		/* Software should clear the IPv4's checksum field when

		 * tso is needed.

 normal or tunnel packet */

 remove payload length from inner pseudo checksum when tso */

 find the txbd field values */

 offload outer UDP header checksum */

 get MSS for TSO */

 find outer header point */

 tunnel packet */

 find inner header point */

/* when skb->encapsulation is 0, skb->ip_summed is CHECKSUM_PARTIAL

 * and it is udp packet, which has a dest port as the IANA assigned.

 * the hardware is expected to do the checksum offload, but the

 * hardware will not do the checksum offload when udp dest port is

 * 4789, 4790 or 6081.

	/* device version above V3(include V3), the hardware can

	 * do this checksum offload.

 compute OL2 header size, defined in 2 Bytes */

 compute OL3 header size, defined in 4 Bytes */

 compute OL4 header size, defined in 4 Bytes */

 define outer network header type */

 handle encapsulation skb */

 If this is a not UDP/GRE encapsulation skb */

			/* drop the skb tunnel packet if hardware don't support,

			 * because hardware can't calculate csum when TSO.

			/* the stack computes the IP header already,

			 * driver calculate l4 checksum when not TSO.

 switch to inner header */

		/* the stack computes the IP header already, the only time we

		 * need the hardware to recompute it is in the case of TSO.

 compute inner(/normal) L2 header size, defined in 2 Bytes */

 compute inner(/normal) L3 header size, defined in 4 Bytes */

 compute inner(/normal) L4 header size, defined in 4 Bytes */

		/* drop the skb tunnel packet if hardware don't support,

		 * because hardware can't calculate csum when TSO.

		/* the stack computes the IP header already,

		 * driver calculate l4 checksum when not TSO.

	/* For HW limitation on HNAE3_DEVICE_VERSION_V2, if port based insert

	 * VLAN enabled, only one VLAN header is allowed in skb, otherwise it

	 * will cause RAS error.

		/* When HW VLAN acceleration is turned off, and the stack

		 * sets the protocol to 802.1q, the driver just need to

		 * set the protocol to the encapsulated ethertype.

		/* Based on hw strategy, use out_vtag in two layer tag case,

		 * and use inner_vtag in one tag case.

 check if the hardware is capable of checksum offloading */

	/* Kindly note, due to backward compatibility of the TX descriptor,

	 * HW checksum of the non-IP packets and GSO packets is handled at

	 * different place in the following code

 set checksum start and offset, defined in 2 Bytes */

 Set txbd */

 When frag size is bigger than hardware limit, split this frag */

 now, fill the descriptor */

 move ring pointer to next */

		/* Head data has been filled in hns3_handle_tx_bounce(),

		 * just return 0 here.

 If the total len is within the max bd limit */

/* HW need every continuous max_non_tso_bd_num buffer data to be larger

 * than MSS, we simplify it by ensuring skb_headlen + the first continuous

 * max_non_tso_bd_num - 1 frags to be larger than gso header len + mss,

 * and the remaining continuous max_non_tso_bd_num - 1 frags to be larger

 * than MSS except the last max_non_tso_bd_num - 1 frags.

	/* ensure the first max_non_tso_bd_num frags is greater than

	 * mss + header

	/* ensure every continuous max_non_tso_bd_num - 1 buffer is greater

	 * than mss except the last one.

	/* 'bd_num == UINT_MAX' means the skb' fraglist has a

	 * recursion level of over HNS3_MAX_RECURSION_LEVEL.

	/* The skb->len has exceeded the hw limitation, linearization

	 * will not help.

 Memory barrier before checking ring_space */

	/* Start queue in case hns3_clean_tx_ring has just made room

	 * available and has not seen the queue stopped state performed

	 * by netif_stop_subqueue above.

 check if this is where we started */

 rollback one */

 unmap the descriptor dma address */

	/* hns3_can_use_tx_bounce() is called to ensure the below

	 * function can always return the tx buffer.

	/* hns3_can_use_tx_sgl() is called to ensure the below

	 * function can always return the tx buffer.

 scatterlist follows by the sg table */

 Hardware can only handle short frames above 32 bytes */

 Prefetch the data used later */

	/* 'ret < 0' means filling error, 'ret == 0' means skb->len is

	 * zero, which is unlikely, and 'ret > 0' means how many tx desc

	 * need to be notified to the hw.

 Complete translate all packets */

	/* For VF device, if there is a perm_addr, then the user will not

	 * be allowed to change the address.

	/* Assume L4 is 60 byte as TCP is the only protocol with a

	 * a flexible value, and it's max len is 60 bytes.

	/* Hardware only supports checksum on the skb with a max header

	 * len of 480 bytes.

 fetch the tx stats */

 fetch the rx stats */

 Find the stopped queue the same way the stack does */

	/* When mac received many pause frames continuous, it's unable to send

	 * packets, which may cause tx timeout

	/* request the reset, and let the hclge to determine

	 * which reset level should be done

	/* If our VFs are assigned we cannot shut down SR-IOV

	 * without causing issues, so just leave the hardware

	 * available but disabled

/* hns3_probe - Device initialization routine

 * @pdev: PCI device information struct

 * @ent: entry in hns3_pci_tbl

 *

 * hns3_probe initializes a PF identified by a pci_dev structure.

 * The OS initialization, configuring of the PF private structure,

 * and a hardware reset occur.

 *

 * Returns 0 on success, negative on failure

/* hns3_remove - Device removal routine

 * @pdev: PCI device information struct

/**

 * hns3_pci_sriov_configure

 * @pdev: pointer to a pci_dev structure

 * @num_vfs: number of VFs to allocate

 *

 * Enable or change the number of VFs. Called when the user updates the number

 * of VFs in sysfs.

 request the reset */

 set default feature to hns3 */

 free desc along with its attached buffer */

 Allocate memory for raw pkg, and map with dma */

 detach a in-used buffer and replace with a reserved one */

	/* pair with ring->last_to_use update in hns3_tx_doorbell(),

	 * smp_store_release() is not used in hns3_tx_doorbell() because

	 * the doorbell operation already have the needed barrier operation.

 desc_cb will be cleaned, after hnae3_free_buffer_detach */

 Issue prefetch for next Tx descriptor */

	/* This smp_store_release() pairs with smp_load_acquire() in

	 * ring_space called by hns3_nic_net_xmit.

		/* Make sure that anybody stopping the queue after this

		 * sees the new next_to_clean.

 Return true if there is any allocation failure */

 Avoid re-using remote or pfmem page */

	/* Rx page can be reused when:

	 * 1. Rx page is only owned by the driver when page_offset

	 *    is zero, which means 0 @ truesize will be used by

	 *    stack after skb_add_rx_frag() is called, and the rest

	 *    of rx page can be reused by driver.

	 * Or

	 * 2. Rx page is only owned by the driver when page_offset

	 *    is non-zero, which means page_offset @ truesize will

	 *    be used by stack after skb_add_rx_frag() is called,

	 *    and 0 @ truesize can be reused by driver.

 Can checksum ipv4 or ipv6 + UDP/TCP/SCTP packets */

 check if hardware has done checksum */

	/* Hardware always insert VLAN tag into RX descriptor when

	 * remove the tag from packet, driver needs to determine

	 * reporting which tag to stack.

 We can reuse buffer as-is, just make sure it is reusable */

 This page cannot be reused so discard it */

 make sure HW write desc complete */

 if there is no HW GRO, do not set gro params */

	/* bdinfo handled below is only valid on the last BD of the

	 * current packet, and ring->next_to_clean indicates the first

	 * descriptor of next packet, so need - 1 below.

	/* Based on hw strategy, the tag offloaded will be stored at

	 * ot_vlan_tag in two layer tag case, and stored at vlan_tag

	 * in one layer tag case.

 Do update ip stack process */

 This is needed in order to enable forwarding support */

 Check valid BD */

		/* Prefetch first cache line of first page.

		 * Idea is to cache few bytes of the header of the packet.

		 * Our L1 Cache line size is 64B so need to prefetch twice to make

		 * it 128B. But in actual we can have greater size of caches with

		 * 128B Level 1 cache lines. In such a case, single fetch would

		 * suffice to cache in the relevant part of the header.

 alloc buffer fail */

 need add frag */

	/* As the head data may be changed when GRO enable, copy

	 * the head data in after other data rx completed

 Reuse or realloc buffers */

 Poll one pkt */

 Do not get FE for the packet or failed to alloc skb */

	/* sync head pointer before exiting, since hardware will calculate

	 * FBD number with head pointer

	/* Since the actual Tx work is minimal, we can give the Tx a larger

	 * budget and be more aggressive about cleaning up the Tx descriptors.

 make sure rx ring budget not smaller than 1 */

	/* initialize the configuration for interrupt coalescing.

	 * 1. GL (Interrupt Gap Limiter)

	 * 2. RL (Interrupt Rate Limiter)

	 * 3. QL (Interrupt Quantity Limiter)

	 *

	 * Default: enable interrupt coalescing self-adaptive and GL

 RSS size, cpu online and vector_num should be the same */

 Should consider 2p/4p later */

 save the actual available vector number */

		/* Since the mapping can be overwritten, when fail to get the

		 * chain between vector and ring, we should go on to deal with

		 * the remaining options.

 Set mac addr if it is configured. or leave it to the AE driver */

 Check if the MAC address is valid, if not get a random one */

	/* only device version above V3(include V3), GL can switch CQ/EQ

	 * period mode.

 Carrier off reporting is important to ethtool even BEFORE open */

 the device can work without cpu rmap, only aRFS needs it */

		/* When a buffer is not reused, it's memory has been

		 * freed in hns3_handle_rx_bd or will be freed by

		 * stack, so we need to replace the buffer here.

				/* if alloc new buffer fail, exit directly

				 * and reclear in up flow.

 Free the pending skb in rx ring */

		/* When a buffer is not reused, it's memory has been

		 * freed in hns3_handle_rx_bd or will be freed by

		 * stack, so only need to unmap the buffer here.

		/* Continue to clear other rings even if clearing some

		 * rings failed.

		/* We need to clear tx ring here because self test will

		 * use the ring and will not run down before up

		/* We can not know the hardware head and tail when this

		 * function is called in reset flow, so we reuse all desc.

 Carrier off reporting is important to ethtool even BEFORE open */

 the device can work without cpu rmap, only aRFS needs it */

/* hns3_init_module - Driver registration routine

 * hns3_init_module is the first routine called when the driver is

 * loaded. All it does is register with the PCI subsystem.

/* hns3_exit_module - Driver exit cleanup routine

 * hns3_exit_module is called just before the driver is removed

 * from memory.

 SPDX-License-Identifier: GPL-2.0+

 Copyright (c) 2016-2017 Hisilicon Limited.

 tqp related stats */

 Tx per-queue statistics */

 Rx per-queue statistics */

 Nic loopback test err  */

 recover promisc mode before loopback test */

	/* The dst mac addr of loopback packet is the same as the host'

	 * mac addr, the SSU component may loop back the packet to host

	 * before the packet reaches mac or serdes, which will defect

	 * the purpose of mac or serdes selftest.

 The packet is correctly received */

/**

 * hns3_lp_run_test - run loopback test

 * @ndev: net device

 * @mode: loopback type

 *

 * Return: %0 for success or a NIC loopback test error code on failure

 Allow 200 milliseconds for packets to go from Tx to Rx */

 Disable the vlan filter for selftest does not support it */

	/* Tell firmware to stop mac autoneg before loopback test start,

	 * otherwise loopback test may be failed when the port is still

	 * negotiating.

/**

 * hns3_self_test - self test

 * @ndev: net device

 * @eth_test: test cmd

 * @data: test result

 Only do offline selftest, or pass by default */

 first, prepend the prefix string */

 now, concatenate the stats string to it */

 get strings for Tx */

 get strings for Rx */

 get stats for Tx */

 get stats for Rx */

/* hns3_get_stats - get detail statistics.

 * @netdev: net device

 * @stats: statistics info.

 * @data: statistics data.

 get per-queue stats */

 get MAC & other misc hardware stats */

 1.auto_neg & speed & duplex from cmd */

 2.get link mode */

 3.mdix_ctrl&mdix get from phy reg */

 mdio_support */

	/* hw doesn't support use specified speed and duplex to negotiate,

	 * unnecessary to check them when autoneg on.

 Chip don't support this mode. */

 Only support ksettings_set for netdev with phy attached for now */

	/* hw doesn't support use specified speed and duplex to negotiate,

	 * ignore them when autoneg on.

 Hardware requires that its descriptors must be multiple of eight */

	/* device version above V3(include V3), GL uses 1us unit,

	 * so the round down is not needed.

 Translate local fec value into ethtool value. */

 if nothing is set, then FEC is off */

 Translate ethtool fec value into local value. */

 all the tx rings have the same tx_copybreak */

 SPDX-License-Identifier: GPL-2.0+

 Copyright (c) 2021 Hisilicon Limited. */

 SPDX-License-Identifier: GPL-2.0+

 Copyright (c) 2016-2017 Hisilicon Limited.

	/* The status for pf to vf msg cmd is u16, constrainted by HW.

	 * We need to keep the same type with it.

	 * The intput errno is the stander error code, it's safely to

	 * use a u16 to store the abs(errno).

/* hclge_gen_resp_to_vf: used to generate a synchronous response to VF when PF

 * receives a mailbox message from VF.

 * @vport: pointer to struct hclge_vport

 * @vf_to_pf_req: pointer to hclge_mbx_vf_to_pf_cmd of the original mailbox

 *		  message

 * @resp_status: indicate to VF whether its request success(0) or failed.

		/* If resp_msg->len is too long, set the value to max length

		 * and return the msg to VF

 send this requested info to VF */

/* hclge_get_ring_chain_from_mbx: get ring type & tqp id & int_gl idx

 * from mailbox message

 * msg[0]: opcode

 * msg[1]: <not relevant to this function>

 * msg[2]: ring_num

 * msg[3]: first ring type (TX|RX)

 * msg[4]: first tqp id

 * msg[5]: first int_gl idx

 * msg[6] ~ msg[14]: other ring type, tqp id and int_gl idx

		/* If VF MAC has been configured by the host then it

		 * cannot be overridden by the MAC specified by the VM.

		/* vf does not need to know about the port based VLAN state

		 * on device HNAE3_DEVICE_VERSION_V3. So always return disable

		 * on device HNAE3_DEVICE_VERSION_V3 if vf queries the port

		 * based VLAN state.

 get the queue related info */

 get the queue depth info */

 mac.link can only be 0 or 1 */

 send this requested info to VF */

	/* pf will reset vf's all queues at a time. So it is unnecessary

	 * to reset queues if queue_id > 0, just return success.

	/* Check the query index of rss_hash_key from VF, make sure no

	 * more than the size of rss_hash_key.

 handle all the mailbox requests in the queue */

 dropping/not processing this invalid message */

 clear the resp_msg before processing every mailbox message */

 PF driver should not reply IMP */

 reinitialize ret after complete the mbx message processing */

 Write back CMDQ_RQ header pointer, M7 need this pointer */

 SPDX-License-Identifier: GPL-2.0+

 Copyright (c) 2018-2019 Hisilicon Limited. */

 tcam_data0 ~ tcam_data1 */

 tcam_data2 ~ tcam_data7 */

 tcam_data8 ~ tcam_data12 */

 pf and enabled vf num */

/* hclge_dbg_dump_mac_tnl_status: print message about mac tnl interrupt

 * @hdev: pointer to struct hclge_dev

 pf and enabled vf num */

 pf and enabled vf num */

 SPDX-License-Identifier: GPL-2.0+

 Copyright (c) 2016-2017 Hisilicon Limited.

 Make sure head is ready before touch any data */

	/* these commands have several descriptors,

	 * and use the first one to save opcode and return value

	/**

	 * If the command is sync, wait for the firmware to write back,

	 * if multi descriptors to be sent, use the first one to check

 Clean the command send queue */

/**

 * hclge_cmd_send - send command to command queue

 * @hw: pointer to the hw struct

 * @desc: prefilled descriptor for describing the command

 * @num : the number of descriptors to be sent

 *

 * This is the main send command for command queue, it

 * sends the queue, cleans the queue, etc

		/* If CMDQ ring is full, SW HEAD and HW HEAD may be different,

		 * need update the SW HEAD pointer csq->next_to_clean

	/**

	 * Record the location of desc in the ring for this time

	 * which will be use for hardware to write back

 Write to hardware */

 Setup the lock for command queue */

 Setup the queue entries for use cmd queue */

 Setup Tx write back timeout */

 Setup queue rings */

	/* Check if there is new reset pending, because the higher level

	 * reset may happen when lower level reset is being processed.

 get version and device capabilities */

	/* ask the firmware to enable some features, driver can work without

	 * it.

	/* wait to ensure that the firmware completes the possible left

	 * over commands.

 SPDX-License-Identifier: GPL-2.0+

 Copyright (c) 2016-2017 Hisilicon Limited.

 Get DFX BD number offset */

 required last entry */

 The first desc has a 64-bit header, so data size need to minus 1 */

		/* data memory is continuous becase only the first desc has a

		 * header in this command

 The first desc has a 64-bit header, so need to consider it */

	/* This may be called inside atomic sections,

	 * so GFP_ATOMIC is more suitalbe here

		/* data memory is continuous becase only the first desc has a

		 * header in this command

	/* Driver needs total register number of both valid registers and

	 * reserved registers, but the old firmware only returns number

	 * of valid registers in device V2. To be compatible with these

	 * devices, driver uses a fixed value.

 The firmware supports the new statistics acquisition method */

 command : HCLGE_OPC_QUERY_IGU_STAT */

 command : HCLGE_OPC_QUERY_IGU_STAT */

 each tqp has TX & RX two queues */

	/* Loopback test support rules:

	 * mac: only GE mode support

	 * serdes: all mac mode will support include GE/XGE/LGE/CGE

	 * phy: only support when phy device exist on board

 clear loopback bit flags at first */

 Set the pf to main pf */

 Check pf reset is done */

		/* PF should have NIC vectors and Roce vectors,

		 * NIC vectors are queued before Roce vectors.

 default to support all speed for GE port */

 get the configuration */

 get mac_address */

	/* HCLGE_CFG_PF_RSS_SIZE_M is the PF max rss size, which is a

	 * power of 2, instead of reading out directly. This would

	 * be more flexible for future changes and expansions.

	 * When VF max  rss size field is HCLGE_CFG_RSS_SIZE_S,

	 * it does not make sense if PF's field is 0. In this case, PF and VF

	 * has the same max rss size filed: HCLGE_CFG_RSS_SIZE_S.

	/* The unit of the tx spare buffer size queried from configuration

	 * file is HCLGE_TX_SPARE_SIZE_UNIT(4096) bytes, so a conversion is

	 * needed here.

/* hclge_get_cfg: query the static parameter from flash

 * @hdev: pointer to struct hclge_dev

 * @hcfg: the config structure to be getted

 Len should be united by 4 bytes when send to hardware */

	/* set default specifications as devices lower than version V3 do not

	 * support querying specifications from firmware.

 get pf resource */

 minimal queue pairs equals to the number of vports */

 Dev does not support DCB */

 Currently not support uncontiuous tc */

 Set the affinity based on numa node */

		/* need an extended offset to configure queues >=

		 * HCLGE_TQP_MAX_SIZE_DEV_V2

 ensure one to one mapping between irq and queue at default */

 We need to alloc a vport for main NIC of PF */

 Alloc the same number of TQPs for every vport */

 TX buffer size is unit by 128 byte */

 Get the number of pfc enabled TCs, which have private buffer */

 Get the number of pfc disabled TCs, which have private buffer */

 alloc tx buffer for all enabled tc */

 let the last to be cleared first */

 Clear the no pfc TC private buffer */

 let the last to be cleared first */

 Reduce the number of pfc TC with private buffer */

/* hclge_rx_buffer_calc: calculate the rx private buffer size for all TCs

 * @hdev: pointer to struct hclge_dev

 * @buf_alloc: pointer to buffer calculation data

 * @return: 0: calculate successful, negative: fail

 When DCB is not supported, rx private buffer is not allocated. */

 try to decrease the buffer size */

 Alloc private buffer TCs */

 The first descriptor set the NEXT bit to 1 */

 Send 2 descriptor at one time */

 The first descriptor set the NEXT bit to 1 */

 Send 2 descriptors at one time */

 update fec ability by speed */

	/* firmware can not identify back plane type, the media type

	 * read from configuration can help deal it

	/* In some case, mac speed get from IMP may be 0, it shouldn't be

	 * set to mac->speed.

	/* if resp->speed_ability is 0, it means it's an old version

	 * firmware, do not update these params

 get the port info from SFP cmd if not copper port */

 if IMP does not support get SFP/qSFP info, return directly */

 do nothing if no SFP */

 must config full duplex for SFP */

 VF start from 1 in vport */

 fetch the events from their corresponding regs */

	/* Assumption: If by any chance reset and mailbox events are reported

	 * together then we will only process reset event in this go and will

	 * defer the processing of the mailbox events. Since, we would have not

	 * cleared RX CMDQ event this time we would receive again another

	 * interrupt from H/W just for the mailbox.

	 *

	 * check for vector0 reset event sources

 check for vector0 msix event and hardware error event source */

 check for vector0 ptp event source */

 check for vector0 mailbox(=CMDQ RX) event source */

 print other vector0 event source */

 vector 0 interrupt is shared with reset and mailbox source events. */

		/* If we are here then,

		 * 1. Either we are not handling any mbx task and we are not

		 *    scheduled as well

		 *                        OR

		 * 2. We could be handling a mbx task but nothing more is

		 *    scheduled.

		 * In both cases, we should schedule mbx task as there are more

		 * mbx messages reported by this interrupt.

 Enable interrupt if it is not caused by reset event or error event */

 this would be explicitly freed in the end */

 Send cmd to set/clear VF's FUNC_RST_ING */

		/* Inform VF to process the reset.

		 * hclge_inform_reset_assert_to_vf may fail if VF

		 * driver is not loaded.

 vf need to down netdev by mbx during PF or FLR reset */

		/* for compatible with old firmware, wait

		 * 100 ms for VF to stop IO

 schedule again to check later */

 return the highest priority reset level amongst all */

	/* For revision 0x20, the reset interrupt source

	 * can only be cleared after hardware reset done

		/* After performaning pf reset, it is not necessary to do the

		 * mailbox handling or send any command to firmware, because

		 * any mailbox handling or command to firmware is only valid

		 * after hclge_cmd_init is called.

 inform hardware that preparatory work is done */

 recover the handshake status when reset fail */

	/* reset request will not be set during reset, so clear

	 * pending reset request to avoid unnecessary reset

	 * caused by the same reason.

	/* if default_reset_request has a higher level reset request,

	 * it should be handled as soon as possible. since some errors

	 * need this kind of reset to fix.

	/* To be compatible with the old firmware, which does not support

	 * command HCLGE_OPC_PF_RST_DONE, just print a warning and

	 * return success

 clear up the handshake status after re-initialize done */

 perform reset of the stack & ae device for a client */

	/* ignore RoCE notify error if it fails HCLGE_RESET_MAX_FAIL_CNT - 1

	 * times

	/* We might end up getting called broadly because of 2 below cases:

	 * 1. Recoverable error was conveyed through APEI and only way to bring

	 *    normalcy is to reset.

	 * 2. A new reset request from the stack due to timeout

	 *

	 * check if this is a new reset request and we are not here just because

	 * last reset attempt did not succeed and watchdog hit us again. We will

	 * know this if last reset request did not occur very recently (watchdog

	 * timer = 5*HZ, let us check after sufficiently large time, say 4*5*Hz)

	 * In case of new request we reset the "reset level" to PF reset.

	 * And if it is a repeat reset request of the most recent one then we

	 * want to make sure we throttle the reset request. Therefore, we will

	 * not allow it again before 3*HZ times.

 request reset & schedule reset task */

	/* if default_reset_request has no value, it means that this reset

	 * request has already be handled, so just return here

	/* check if there is any ongoing reset in the hardware. This status can

	 * be checked from reset_pending. If there is then, we need to wait for

	 * hardware to complete reset.

	 *    a. If we are able to figure out in reasonable time that hardware

	 *       has fully resetted then, we can proceed with driver, client

	 *       reset.

	 *    b. else, we can come back later to check this status so re-sched

	 *       now.

 check if we got any *new* reset requests to be honored */

 enable interrupt after error handling complete */

 start from vport 1 for PF is always alive */

 If vf is not alive, set to default value */

	/* Always handle the link updating to make sure link state is

	 * updated when it is triggered by mbx.

 to prevent concurrence with the irq handler */

	/* check HCLGE_STATE_PTP_TX_HANDLING here again, since the irq

	 * handler may handle it just before spin_lock_irqsave().

	/* Handle error recovery, reset and mbx again in case periodical task

	 * delays the handling by calling hclge_task_schedule() in

	 * hclge_periodic_service_task().

 VF handle has no client */

 need an extend offset to config vector >= 64 */

 Get the tuple cfg from pf */

 Get hash algorithm */

 Get the RSS Key required by the user */

 Get indirect table */

 Set the RSS Hash Key if specififed by the user */

 Update the shadow RSS key with user specified qids */

 Update the shadow RSS table with user specified qids */

 Update the hardware */

		/* tc_size set to hardware is the log2 of roundup power of two

		 * of rss_size, the acutal queue size is limited by indirection

		 * table.

 to be compatible with DEVICE_VERSION_V1/2 */

	/* For device whose version below V2, if broadcast promisc enabled,

	 * vlan filter is always bypassed. So broadcast promisc should be

	 * disabled until user enable promisc mode

		/* 1) if the new state is TO_ADD, just replace the old rule

		 * with the same location, no matter its state, because the

		 * new rule will be configured to the hardware.

		 * 2) if the new state is ACTIVE, it means the new rule

		 * has been configured to the hardware, so just replace

		 * the old rule node with the same location.

		 * 3) for it doesn't add a new node to the list, so it's

		 * unnecessary to update the rule number and fd_bmap.

		/* if new request is TO_DEL, and old rule is existent

		 * 1) the state of old rule is TO_DEL, we need do nothing,

		 * because we delete rule by location, other rule content

		 * is unncessary.

		 * 2) the state of old rule is ACTIVE, we need to change its

		 * state to TO_DEL, so the rule will be deleted when periodic

		 * task being scheduled.

		 * 3) the state of old rule is TO_ADD, it means the rule hasn't

		 * been added to hardware, so we just delete the rule node from

		 * fd_rule_list directly.

		/* record the parent node, use to keep the nodes in fd_rule_list

		 * in ascend order.

 insert fd rule node in ascend order according to rule->location */

 for valid layer is start from 1, so need minus 1 to get the cfg */

	/* it's unlikely to fail here, because we have checked the rule

	 * exist before.

 If use max 400bit key, we can support tuples for ether type */

	/* roce_type is used to filter roce frames

	 * dst_vport is used to specify the rule

/* A complete key is combined with meta data key and tuple key.

 * Meta data key is stored at the MSB region, and tuple key is stored at

 * the LSB region, unused bits will be filled 0.

 check whether src/dst ip address used */

 check whether src/dst ip address used */

	/* user-def data from ethtool is 64 bit value, the bit0~15 is used

	 * for data, and bit32~47 is used for offset.

		/* To keep consistent with user's configuration, minus 1 when

		 * printing 'vf', because vf id from ethtool is added 1 for vf.

	/* Return ok here, because reset error handling will check this

	 * return value. If error is returned here, the reset process will

	 * fail.

 if fd is disabled, should not restore it when reset */

	/* The flow type of fd rule has been checked before adding in to rule

	 * list. As other flow types have been handled, it must be ETHER_FLOW

	 * for the default case

 traverse all rules, check whether an existed rule has the same tuples */

	/* when there is already fd rule existed add by user,

	 * arfs should not work

	/* check is there flow director filter existed for this flow,

	 * if not, create a new filter for it;

	 * if filter exist with different queue id, modify the filter;

	 * if filter exist with same queue id, do nothing

 make sure being called after lock up with fd_rule_lock */

 read current config parameter */

 modify and write new config parameter */

 1 Read out the MAC mode config at first */

 2 Then setup the loopback flag */

	/* 3 Config mac work mode with loopback flag

	 * and its original configure parameters

	/* Loopback can be enabled in three places: SSU, MAC, and serdes. By

	 * default, SSU loopback is enabled, so if the SMAC and the DMAC are

	 * the same, the packets are looped back in the SSU. If SSU loopback

	 * is disabled, packets can reach MAC even if SMAC is the same as DMAC.

 Set the DOWN flag here to disable link updating */

 flush memory to make sure DOWN is seen by service task */

 mac enable */

 reset tqp stats */

	/* If it is not PF reset or FLR, the firmware will disable the MAC,

	 * so it only need to stop phy here.

 Mac disable */

 reset tqp stats */

 from set_rx_mode or tmp_add_list */

 only from set_rx_mode */

	/* only from tmp_add_list, the mac_node->state won't be

	 * ACTIVE.

	/* if the mac addr is already in the mac list, no need to add a new

	 * one into it, just check the mac addr state, convert it to a new

	 * state, or just remove it, or do nothing.

 if this address is never added, unnecessary to delete */

 mac addr check */

	/* Lookup the mac address in the mac_vlan table, and add

	 * it if the entry is inexistent. Repeated unicast entry

	 * is not allowed in the mac vlan table.

 check if we just hit the duplicate */

 mac addr check */

 mac addr check */

 This mac addr do not exist, add new entry for it */

 if already overflow, not to print each time */

 mac addr check */

 This mac addr exist, remove this handle's VFID for it */

 All the vfid is zero, so need to delete this entry */

 Not all the vfid is zero, update the vfid */

			/* If one unicast mac address is existing in hardware,

			 * we need to try whether other unicast mac addresses

			 * are new addresses that can be added.

			 * Multicast mac address can be reusable, even though

			 * there is no space to add new multicast mac address,

			 * we should check whether other mac addresses are

			 * existing in hardware for reuse.

		/* if the mac address from tmp_add_list is not in the

		 * uc/mc_mac_list, it means have received a TO_DEL request

		 * during the time window of adding the mac address into mac

		 * table. if mac_node state is ACTIVE, then change it to TO_DEL,

		 * then it will be removed at next time. else it must be TO_ADD,

		 * this address hasn't been added into mac table,

		 * so just remove the mac node.

			/* If the mac addr exists in the mac list, it means

			 * received a new TO_ADD request during the time window

			 * of configuring the mac address. For the mac node

			 * state is TO_ADD, and the address is already in the

			 * in the hardware(due to delete fail), so we just need

			 * to change the mac node state to ACTIVE.

	/* move the mac addr to the tmp_add_list and tmp_del_list, then

	 * we can add/delete these mac addr outside the spin lock

 delete first, in order to get max mac table space for adding */

	/* if some mac addresses were added/deleted fail, move back to the

	 * mac_list, and retry at next time.

			/* clear all mac addr from hardware, but remain these

			 * mac addr in the mac list, and restore them after

			 * vf reset finished.

 remove all mac address when uninitailize */

		/* make sure the new addr is in the list head, avoid dev

		 * addr may be not re-added into mac table for the umv space

		 * limitation after global/imp reset which will clear mac

		 * table by hardware.

 mac addr check */

	/* we must update dev addr with spin lock protect, preventing dev addr

	 * being removed by set_rx_mode path.

 this command reads phy id and register at the same time */

 read current vlan filter parameter */

 modify and write new config parameter */

 compatible with former device, always enable vlan filter */

		/* vf vlan filter is disabled when vf vlan table is full,

		 * then new vlan id will not be added into vf vlan table.

		 * Just return 0 without warning, avoid massive verbose

		 * print logs when unload.

	/* if vf vlan table is full, firmware will close vf vlan filter, it

	 * is unable and unnecessary to add new vlan id to vf vlan filter.

	 * If spoof check is enable, and vf vlan is full, it shouldn't add

	 * new vlan, because tx packets with these vlan id will be dropped.

 vlan 0 may be added twice when 8021q module is enabled */

	/* accept_tag2 and accept_untag2 are not supported on

	 * pdev revision(0x20), new revision support them,

	 * this two fields can not be configured by user.

 for revision 0x21, vf vlan filter is per function */

/* For global reset and imp reset, hardware will clear the mac table,

 * so we change the mac address state from ACTIVE to TO_ADD, then they

 * can be restored in the service task after reset complete. Furtherly,

 * the mac addresses with state TO_DEL or DEL_FAIL are unnecessary to

 * be restored after reset, so just remove these mac nodes from mac_list.

 force clear VLAN 0 */

 force add VLAN 0 */

 add new VLAN tag */

 remove old VLAN tag */

 qos is a 3 bits value, so can not be bigger than 7 */

	/* for DEVICE_VERSION_V3, vf doesn't need to know about the port based

	 * VLAN state.

 clear port base vlan for all vf */

	/* When device is resetting or reset failed, firmware is unable to

	 * handle mailbox. Just record the vlan id, and remove it after

	 * reset finished.

	/* when port base vlan enabled, we use port base vlan as the vlan

	 * filter entry. In this case, we don't update vlan filter table

	 * when user add new vlan or remove exist vlan, just update the vport

	 * vlan list. The vlan id in vlan list will be writen in vlan filter

	 * table until port base vlan disabled

		/* when remove hw vlan filter failed, record the vlan id,

		 * and try to remove it from hw later, to be consistence

		 * with stack

 start from vport 1 for PF is always alive */

 HW supprt 2 layer vlan */

 VF's mps must fit within hdev->mps */

 PF's mps must be greater then VF's mps */

 Wait for tqp hw reset */

	/* if reset rcb cmd is unsupported, we need to send reset tqp cmd

	 * again to reset all tqps

 only need to disable PF's tqp */

	/* When nic is down, the service task is not running, doesn't update

	 * the port information per second. Query the port information before

	 * return the media type, ensure getting the correct media information.

 Enable nic hw error interrupts */

 Enable roce ras interrupts */

 for device does not have device memory, return directly */

 disable misc vector before reset done */

 Send cmd to clear vport's FUNC_RST_ING */

	/* This new command is only supported by new firmware, it will

	 * fail with older firmware. Error value -EOPNOSUPP can only be

	 * returned by older firmware running this command, to keep code

	 * backward compatible we will override this value and return

	 * success.

 HW supprt 2 layer vlan */

 Firmware command queue initialize */

 Firmware command initialize */

	/* Setup affinity after service timer setup because add_timer_on

	 * is called in affinity notify.

 Log and clear the hw errors those already occurred */

	/* request delayed reset for the error recovery because an immediate

	 * global reset on a PF affecting pending initialization of other PFs

 Enable MISC vector(vector0) */

 resume the vf spoof check state after reset */

 reset vf rate to default value */

 resume the vf max_tx_rate after reset */

		/* zero means max rate, after reset, firmware already set it to

		 * max rate, so just continue.

	/* NOTE: pf reset needn't to clear or restore pf and vf table entry.

	 * so here should not clean table in memory.

 Log and clear the hw errors those already occurred */

	/* Re-enable the hw error interrupts because

	 * the interrupts get disabled on global reset.

 Disable MISC vector(vector0) */

 Disable all hw interrupts */

 Set the RSS TC mode according to the new RSS size */

 RSS indirection table has been configured by user */

 Reinitializes the rss indirect table according to the new RSS size */

 initialize command BD except the last one */

 initialize the last command BD */

 fetching per-PF registers valus from PF PCIe register space */

/* need 6 bds(total 140 bytes) in one reading

 * return the number of bytes actually read, 0 means read failed.

 setup all 6 bds to read module eeprom info. */

 bd0~bd4 need next flag */

 setup bd0, this bd contains offset and read length. */

 copy sfp info from bd0 to out buffer. */

 copy sfp info from bd1~bd5 to out buffer if needed. */

 SPDX-License-Identifier: GPL-2.0+

 Copyright (c) 2016-2017 Hisilicon Limited. */

 sentinel */

 sentinel */

 sentinel */

 sentinel */

 sentinel */

 sentinel */

 sentinel */

 sentinel */

 sentinel */

 sentinel */

 sentinel */

 sentinel */

 sentinel */

 sentinel */

 sentinel */

 sentinel */

 sentinel */

 sentinel */

 sentinel */ }

 sentinel */

 sentinel */

 sentinel */

 sentinel */

 sentinel */

/* hclge_cmd_query_error: read the error information

 * @hdev: pointer to struct hclge_dev

 * @desc: descriptor for describing the command

 * @cmd:  command opcode

 * @flag: flag for extended command structure

 *

 * This function query the error info from hw register/s using command

 configure common error interrupts */

 configure NCSI error interrupts */

 configure IGU,EGU error interrupts */

 configure PPP error interrupts */

 configure TM SCH hw errors */

 configure TM QCN hw errors */

 configure MAC common error interrupts */

 configure PPU error interrupts */

 configure SSU ecc error interrupts */

 configure SSU common error interrupts */

/* hclge_query_bd_num: query number of buffer descriptors

 * @hdev: pointer to struct hclge_dev

 * @is_ras: true for ras, false for msix

 * @mpf_bd_num: number of main PF interrupt buffer descriptors

 * @pf_bd_num: number of not main PF interrupt buffer descriptors

 *

 * This function querys number of mpf and pf buffer descriptors.

/* hclge_handle_mpf_ras_error: handle all main PF RAS errors

 * @hdev: pointer to struct hclge_dev

 * @desc: descriptor for describing the command

 * @num:  number of extended command structures

 *

 * This function handles all the main PF RAS errors in the

 * hw register/s using command.

 query all main PF RAS errors */

 log HNS common errors */

 log SSU(Storage Switch Unit) errors */

 log IGU(Ingress Unit) errors */

 log PPP(Programmable Packet Process) errors */

 log PPU(RCB) errors */

 log TM(Traffic Manager) errors */

 log QCN(Quantized Congestion Control) errors */

 log NCSI errors */

 clear all main PF RAS errors */

/* hclge_handle_pf_ras_error: handle all PF RAS errors

 * @hdev: pointer to struct hclge_dev

 * @desc: descriptor for describing the command

 * @num:  number of extended command structures

 *

 * This function handles all the PF RAS errors in the

 * hw register/s using command.

 query all PF RAS errors */

 log SSU(Storage Switch Unit) errors */

 log IGU(Ingress Unit) EGU(Egress Unit) TNL errors */

 log PPU(RCB) errors */

 clear all PF RAS errors */

 query the number of registers in the RAS int status */

 handle all main PF RAS errors */

 handle all PF RAS errors */

 read overflow error status */

 log overflow error */

 read RAS error interrupt status */

 reset everything for now */

 reset everything for now */

 clear error status */

 reset everything for now */

 enable ROCEE hw error interrupts */

 sentinel */

 Handling Non-fatal HNS RAS errors */

 Handling Non-fatal Rocee RAS errors */

/* hclge_query_8bd_info: query information about over_8bd_nfe_err

 * @hdev: pointer to struct hclge_dev

 * @vf_id: Index of the virtual function with error

 * @q_id: Physical index of the queue with error

 *

 * This function get specific index of queue and function which causes

 * over_8bd_nfe_err by using command. If vf_id is 0, it means error is

 * caused by PF instead of VF.

/* hclge_handle_over_8bd_err: handle MSI-X error named over_8bd_nfe_err

 * @hdev: pointer to struct hclge_dev

 * @reset_requests: reset level that we need to trigger later

 *

 * over_8bd_nfe_err is a special MSI-X because it may caused by a VF, in

 * that case, we need to trigger VF reset. Otherwise, a PF reset is needed.

		/* If we need to trigger other reset whose level is higher

		 * than HNAE3_VF_FUNC_RESET, no need to trigger a VF reset

		 * here.

/* hclge_handle_mpf_msix_error: handle all main PF MSI-X errors

 * @hdev: pointer to struct hclge_dev

 * @desc: descriptor for describing the command

 * @mpf_bd_num: number of extended command structures

 * @reset_requests: record of the reset level that we need

 *

 * This function handles all the main PF MSI-X errors in the hw register/s

 * using command.

 query all main PF MSIx errors */

 log MAC errors */

 log PPU(RCB) MPF errors */

 clear all main PF MSIx errors */

/* hclge_handle_pf_msix_error: handle all PF MSI-X errors

 * @hdev: pointer to struct hclge_dev

 * @desc: descriptor for describing the command

 * @mpf_bd_num: number of extended command structures

 * @reset_requests: record of the reset level that we need

 *

 * This function handles all the PF MSI-X errors in the hw register/s using

 * command.

 query all PF MSIx errors */

 log SSU PF errors */

 read and log PPP PF errors */

 log PPU(RCB) PF errors */

 clear all PF MSIx errors */

 query the number of bds for the MSIx int status */

 query and clear mac tnl interruptions */

		/* When mac tnl interrupt occurs, we record current time and

		 * register status here in a fifo, then clear the status. So

		 * that if link status changes suddenly at some time, we can

		 * query them by debugfs.

 query the number of bds for the MSIx int status */

 Clear HNS hw errors reported through msix  */

 Handle Non-fatal HNS RAS errors */

 SPDX-License-Identifier: GPL-2.0+

 Copyright (c) 2021 Hisilicon Limited.

	/* This clock cycle is defined by three part: quotient, numerator

	 * and denominator. For example, 2.5ns, the quotient is 2,

	 * denominator is fixed to ptp->cycle.den, and numerator

	 * is 0.5 * ptp->cycle.den.

	/* Since the BD does not have enough space for the higher 16 bits of

	 * second, and this part will not change frequently, so read it

	 * from register.

 synchronize the time of phc */

 SPDX-License-Identifier: GPL-2.0+

 Copyright (c) 2016-2017 Hisilicon Limited.

 Read out phy data */

 When phy link down, do nothing */

	/* supported flag is Pause and Asym Pause, but default advertising

	 * should be rx on, tx on, so need clear Asym Pause in advertising

	 * flag

 SPDX-License-Identifier: GPL-2.0+

 Copyright (c) 2016-2017 Hisilicon Limited.

			/* Hardware only supports SP (strict priority)

			 * or ETS (enhanced transmission selection)

			 * algorithms, if we receive some other value

			 * from dcbnl, then throw an error.

 IEEE std */

 return max tc number, max tc id need to plus 1 */

			/* The hardware will switch to sp mode if bandwidth is

			 * 0, so limit ets bandwidth must be greater than 0.

 DCBX configuration */

 No support for LLD_MANAGED modes or CEE */

 Set up TC for hardware offloaded mqprio in channel mode */

	/* if client unregistered, it's not allowed to change

	 * mqprio configuration, which may cause uninit ring

	 * fail.

 roll-back */

	/* Hdev does not support DCB or vport is

	 * not a pf, then dcb_ops is not set.

 SPDX-License-Identifier: GPL-2.0+

 Copyright (c) 2016-2017 Hisilicon Limited.

/* hclge_shaper_para_calc: calculate ir parameter for the shaper

 * @ir: Rate to be config, its unit is Mbps

 * @shaper_level: the shaper level. eg: port, pg, priority, queueset

 * @ir_para: parameters of IR shaper

 * @max_tm_rate: max tm rate is available to config

 *

 * the formula:

 *

 *		IR_b * (2 ^ IR_u) * 8

 * IR(Mbps) = -------------------------  *  CLOCK(1000Mbps)

 *		Tick * (2 ^ IR_s)

 *

 * @return: 0: calculate sucessful, negative: fail

 Prioriy level */

 Prioriy group level */

 Port level */

 Qset level */

 Calc tick */

	/**

	 * Calc the speed if ir_b = 126, ir_u = 0 and ir_s = 0

	 * the formula is changed to:

	 *		126 * 1 * 8

	 * ir_calc = ---------------- * 1000

	 *		tick * 1

 Increasing the denominator to select ir_s value */

 Increasing the numerator to select ir_u value */

	/**

	 * the register for priority has four bytes, the first bytes includes

	 *  priority0 and priority1, the higher 4bit stands for priority1

	 *  while the lower 4bit stands for priority0, as below:

	 * first byte:	| pri_1 | pri_0 |

	 * second byte:	| pri_3 | pri_2 |

	 * third byte:	| pri_5 | pri_4 |

	 * fourth byte:	| pri_7 | pri_6 |

	/* convert qs_id to the following format to support qset_id >= 1024

	 * qs_id: | 15 | 14 ~ 10 |  9 ~ 0   |

	 *            /         / \         \

	 *           /         /   \         \

	 * qset_id: | 15 ~ 11 |  10 |  9 ~ 0  |

	 *          | qs_id_h | vld | qs_id_l |

	/* TC configuration is shared by PF/VF in one port, only allow

	 * one tc for VF for simplicity. VF's vport_id is non zero.

 Set to user value, no larger than max_rss_size. */

 Set to the maximum specification value (max_rss_size). */

 100 percent as init */

 when enable mqprio, the tc_info has been updated. */

 Set to default queue if TC is disable */

		/* fc_mode_last_time record the last fc_mode when

		 * DCB is enabled, so that fc_mode can be set to

		 * the correct value when DCB is disabled.

 Cfg mapping */

 Cfg pg schd */

 Pg to pri */

 Calc shaper para */

 cfg pg schd */

 pg to prio */

 Cfg dwrr */

 Cfg qs -> pri mapping, one by one mapping */

 Cfg qs -> pri mapping,  qs = tc, pri = vf, 8 qs -> 1 pri */

 Cfg q -> qs mapping */

 Need config vport shaper */

 Vf dwrr */

 Qset dwrr */

 Only being config on TC-Based scheduler mode */

 Cfg tm mapping  */

 Cfg tm shaper */

 Cfg dwrr */

 Cfg schd mode for each level schd */

/* for the queues that use for backpress, divides to several groups,

 * each group contains 32 queue sets, which can be represented by u32 bitmap.

 Only DCB-supported dev supports qset back pressure and pfc cmd */

	/* GE MAC does not support PFC, when driver is initializing and MAC

	 * is in GE Mode, ignore the error here, otherwise initialization

	 * will fail.

 fc_mode is HCLGE_FC_FULL on reset */

 Each PF has 8 qsets and each VF has 1 qset */

	/* convert qset_id to the following format, drop the vld bit

	 *            | qs_id_h | vld | qs_id_l |

	 * qset_id:   | 15 ~ 11 |  10 |  9 ~ 0  |

	 *             \         \   /         /

	 *              \         \ /         /

	 * qset_id: | 15 | 14 ~ 10 |  9 ~ 0  |

 SPDX-License-Identifier: GPL-2.0+

 Copyright (c) 2016-2017 Hisilicon Limited.

 required last entry */

		/* need an extended offset to configure queues >=

		 * HCLGEVF_TQP_MAX_SIZE_DEV_V2.

	/* after init the max rss_size and tqps, adjust the default tqp numbers

	 * and rss size with the actual vector numbers

 for revision 0x20, vf shared the same rss config with pf */

 Get hash algorithm */

 Get the RSS Key required by the user */

 Set the RSS Hash Key if specififed by the user */

 Update the shadow RSS key with user specified qids */

 update the shadow RSS table with user specified qids */

 update the hardware */

 from set_rx_mode or tmp_add_list */

 only from set_rx_mode */

	/* only from tmp_add_list, the mac_node->state won't be

	 * HCLGEVF_MAC_ACTIVE

	/* if the mac addr is already in the mac list, no need to add a new

	 * one into it, just check the mac addr state, convert it to a new

	 * new state, or just remove it, or do nothing.

 if this address is never added, unnecessary to delete */

		/* if the mac address from tmp_add_list is not in the

		 * uc/mc_mac_list, it means have received a TO_DEL request

		 * during the time window of sending mac config request to PF

		 * If mac_node state is ACTIVE, then change its state to TO_DEL,

		 * then it will be removed at next time. If is TO_ADD, it means

		 * send TO_ADD request failed, so just remove the mac node.

			/* If the mac addr is exist in the mac list, it means

			 * received a new request TO_ADD during the time window

			 * of sending mac addr configurrequest to PF, so just

			 * change the mac state to ACTIVE.

	/* move the mac addr to the tmp_add_list and tmp_del_list, then

	 * we can add/delete these mac addr outside the spin lock

 delete first, in order to get max mac table space for adding */

	/* if some mac addresses were added/deleted fail, move back to the

	 * mac_list, and retry at next time.

	/* When device is resetting or reset failed, firmware is unable to

	 * handle mailbox. Just record the vlan id, and remove it after

	 * reset finished.

	/* when remove hw vlan filter failed, record the vlan id,

	 * and try to remove it from hw later, to be consistence

	 * with stack.

 disable vf queue before send queue reset msg to PF */

 hardware completion status should be available by this time */

	/* we will wait a bit more to let reset of the stack to complete. This

	 * might happen in case reset assertion was made by PF. Yes, this also

	 * means we might end up waiting bit more even for VF reset.

 uninitialize the nic client */

 re-initialize the hclge device */

 bring up the nic client again */

 clear handshake status with IMP */

 bring up the nic to enable TX/RX again */

 inform hardware that preparatory work is done */

 recover handshake status with IMP when reset fail */

 perform reset of the stack & ae device for a client */

 bring down the nic to stop any ongoing TX/RX */

 now, re-initialize the nic client and ae device */

	/* ignore RoCE notify error if it fails HCLGEVF_RESET_MAX_FAIL_CNT - 1

	 * times

	/* check if VF could successfully fetch the hardware reset completion

	 * status from the hardware

 can't do much in this situation, will disable VF */

 return the highest priority reset level amongst all */

 reset of this VF requested */

 disable misc vector before reset done */

 vector status always valid for Vector 0 */

		/* PF has intimated that it is about to reset the hardware.

		 * We now have to poll & check if hardware has actually

		 * completed the reset sequence. On hardware reset completion,

		 * VF needs to reset the client and ae device.

		/* we could be here when either of below happens:

		 * 1. reset was initiated due to watchdog timeout caused by

		 *    a. IMP was earlier reset and our TX got choked down and

		 *       which resulted in watchdog reacting and inducing VF

		 *       reset. This also means our cmdq would be unreliable.

		 *    b. problem in TX due to other lower layer(example link

		 *       layer not functioning properly etc.)

		 * 2. VF reset might have been initiated due to some config

		 *    change.

		 *

		 * NOTE: Theres no clear way to detect above cases than to react

		 * to the response of PF for this reset request. PF will ack the

		 * 1b and 2. cases but we will not get any intimation about 1a

		 * from PF as cmdq would be in unreliable state i.e. mailbox

		 * communication between PF and VF would be broken.

		 *

		 * if we are never geting into pending state it means either:

		 * 1. PF is not receiving our request which could be due to IMP

		 *    reset

		 * 2. PF is screwed

		 * We cannot do much for 2. but to check first we can try reset

		 * our PCIe + stack and see if it alleviates the problem.

 prepare for full reset of stack + pcie interface */

 "defer" schedule the reset task again */

	/* VF does not need to request link status when this bit is set, because

	 * PF will push its link status to VFs when link status changed.

	/* Handle reset and mbx again in case periodical task delays the

	 * handling by calling hclgevf_task_schedule() in

	 * hclgevf_periodic_service_task()

 fetch the events from their corresponding regs */

		/* set up VF hardware reset status, its PF will clear

		 * this status when PF has initialized done.

 check for vector0 mailbox(=CMDQ RX) event source */

		/* for revision 0x21, clearing interrupt is writing bit 0

		 * to the clear register, writing bit 1 means to keep the

		 * old value.

		 * for revision 0x20, the clear register is a read & write

		 * register, so we should just write 0 to the bit we are

		 * handling, and keep other bits as cmdq_stat_reg.

 print other vector0 event source */

 get current port based vlan state from PF */

 get queue configuration from PF */

 get queue depth info from PF */

 Initialize RSS indirect table */

 flush memory to make sure DOWN is seen by service task */

 bring the device down */

 enable misc. vector(vector 0) */

 disable misc vector(vector 0) */

 un-init roce, if it exists */

 un-init nic/unic, if this was not called by roce client */

 for device does not have device memory, return directly */

 nic's msix numbers is always equals to the roce's. */

		/* VF should have NIC vectors and Roce vectors, NIC vectors

		 * are queued before Roce vectors. The offset is fixed to 64.

	/* set default specifications as devices lower than version V3 do not

	 * support querying specifications from firmware.

 Get vf resource */

 Initialize RSS for this VF */

 ensure vf tbl list as empty before init*/

/**

 * hclgevf_get_channels - Get the current channels enabled and max supported.

 * @handle: hardware information for network interface

 * @ch: ethtool channels structure

 *

 * We don't support separate tx and rx queues as channels. The other count

 * represents how many queues are being used for control. max_combined counts

 * how many queue pairs we can support. They may not be mapped 1 to 1 with

 * q_vectors since we support a lot more queue pairs than q_vectors.

	/* Use the user's configuration when it is not larger than

	 * max_rss_size, otherwise, use the maximum specification value.

 RSS indirection table has been configured by user */

 Reinitializes the rss indirect table according to the new RSS size */

 fetching per-VF registers values from VF PCIe register space */

 send msg to PF and wait update port based vlan info */

 SPDX-License-Identifier: GPL-2.0+

 Copyright (c) 2016-2017 Hisilicon Limited.

	/* this function should be called with mbx_resp.mbx_mutex held

	 * to prtect the received_response from race condition

 Update match_id and ensure the value of match_id is not zero */

/* hclgevf_get_mbx_resp: used to get a response from PF after VF sends a mailbox

 * message to PF.

 * @hdev: pointer to struct hclgevf_dev

 * @resp_msg: pointer to store the original message type and response status

 * @len: the resp_msg data array length.

 synchronous send */

 asynchronous send */

		/* If match_id is not zero, it means PF support match_id.

		 * if the match_id is right, VF get the right response, or

		 * ignore the response. and driver will clear hdev->mbx_resp

		 * when send next message which need response.

	/* we will drop the async msg if we find ARQ as full

	 * and continue with next message

 tail the async message in arq */

 dropping/not processing this invalid message */

		/* synchronous messages are time critical and need preferential

		 * treatment. Therefore, we need to acknowledge all the sync

		 * responses as quickly as possible so that waiting tasks do not

		 * timeout and simultaneously queue the async messages for later

		 * prcessing in context of mailbox task i.e. the slow path.

 Write back CMDQ_RQ header pointer, M7 need this pointer */

 process all the async queue messages */

 update upper layer with new link link status */

			/* PF has asserted reset hence VF should go in pending

			 * state and poll for the hardware reset status till it

			 * has been completely reset. After this stack should

			 * eventually be re-initialized.

 SPDX-License-Identifier: GPL-2.0+

 Copyright (c) 2021 Hisilicon Limited. */

 SPDX-License-Identifier: GPL-2.0+

 Copyright (c) 2016-2017 Hisilicon Limited.

 Make sure head is ready before touch any data */

 allocate CSQ/CRQ descriptor */

 Get the result of hardware write back */

	/* If the command is sync, wait for the firmware to write back,

	 * if multi descriptors to be sent, use the first one to check

 Clean the command send queue */

/* hclgevf_cmd_send - send command to command queue

 * @hw: pointer to the hw struct

 * @desc: prefilled descriptor for describing the command

 * @num : the number of descriptors to be sent

 *

 * This is the main send command for command queue, it

 * sends the queue, cleans the queue, etc

		/* If CMDQ ring is full, SW HEAD and HW HEAD may be different,

		 * need update the SW HEAD pointer csq->next_to_clean

	/* Record the location of desc in the ring for this time

	 * which will be use for hardware to write back

 Write to hardware */

 Setup the lock for command queue */

 initialize the pointers of async rx queue of mailbox */

	/* Check if there is new reset pending, because the higher level

	 * reset may happen when lower level reset is being processed.

 get version and device capabilities */

		/* ask the firmware to enable some features, driver can work

		 * without it.

	/* wait to ensure that the firmware completes the possible left

	 * over commands.

 SPDX-License-Identifier: GPL-2.0

/*

 * sni_ave.c - Socionext UniPhier AVE ethernet driver

 * Copyright 2014 Panasonic Corporation

 * Copyright 2015-2017 Socionext Inc.

 General Register Group */

 ID */

 Version */

 Global Reset */

 Configuration */

 Interrupt Register Group */

 Global Interrupt Mask */

 Global Interrupt Status */

 MAC Register Group */

 TX Setup */

 RX Setup */

 MAC address (lower) */

 MAC address (upper) */

 MDIO Control */

 MDIO Address */

 MDIO Data */

 MDIO Status */

 MDIO Rd Data */

 Descriptor Control Register Group */

 Descriptor Control */

 TX Descriptor Configuration */

 RX Descriptor Ring0 Configuration */

 Interval IRQ Control */

 Packet Filter Register Group */

 PF Base Address */

 PF Mask Byte Base Address */

 PF Mask Bit Base Address */

 PF Selector Base Address */

 Packet Filter Enable */

 64bit descriptor memory */

 Descriptor Size */

 Tx Descriptor Memory */

 Rx Descriptor Memory */

 Tx Descriptor Memory Size 3KB */

 Rx Descriptor Memory Size 24KB */

 32bit descriptor memory */

 Descriptor Size */

 Tx Descriptor Memory */

 Rx Descriptor Memory */

 Tx Descriptor Memory Size 2KB */

 Rx Descriptor Memory Size 16KB */

 RMII Bridge Register Group */

 Reset control */

 Link speed setting */

 AVE_GRR */

 Reset RxFIFO */

 Reset external PHY */

 Reset all MAC */

 AVE_CFGR */

 Filter Function */

 Checksum Function */

 Func mode (1:MII/RMII, 0:RGMII) */

 IP fragment sum Enable */

 AVE_GISR (common with GIMR) */

 PHY interrupt */

 Tx complete */

 Receive frame more than max size */

 Overflow at the RxFIFO */

 Drop packet */

 Interval interrupt */

 AVE_TXCR */

 Flow control */

 AVE_RXCR */

 Rx enable */

 Interface mode */

 Flow control */

 MAC address filter */

 Drop pause frame */

 AVE_MDIOCTR */

 Read request */

 Write request */

 AVE_MDIOSR */

 access status */

 AVE_DESCC */

 Enable Rx descriptor Ring0 */

 Pause Rx descriptor */

 Enable Tx descriptor */

 AVE_TXDC */

 Size of Tx descriptor */

 Start address */

 AVE_RXDC0 */

 Size of Rx descriptor */

 Start address */

 AVE_IIRQC */

 Enable interval interrupt Ring0 */

 Interval count unit */

 Command status for descriptor */

 Descriptor ownership */

 Request for interrupt */

 Normal transmit */

 TX */

 No use HW checksum */

 Head of buffer chain */

 Tail of buffer chain */

 Out of window,Late Collision */

 Excess collision occurred */

 RX */

 Checksum check performed */

 Checksum error detected */

 Packet filter */

 Number of all packet filter */

 Number of multicast filter */

 No.0 */

 No.1 */

 No.2 */

 No.11-17 */

 NETIF Message control */

 Parameter for descriptor */

 Tx descriptor */

 Rx descriptor */

 Parameter for ethernet frame */

 Parameter for interrupt */

 SG */

 for LD11 */

 number of descriptor */

 start address of descriptor */

 index of processing packet */

 index of processed packet */

 skb info related descriptor */

 stats */

 NAPI support */

 descriptor */

 flow control */

 write address */

 read request */

 write address */

 write data */

 write request */

 Prepare Rx descriptor and memory */

 set disable to cmdsts */

	/* map Rx buffer

	 * Rx buffer set to the Rx descriptor has two restrictions:

	 * - Rx buffer address is 4 byte aligned.

	 * - Rx buffer begins with 2 byte headroom, and data will be put from

	 *   (buffer + 2).

	 * To satisfy this, specify the address to put back the buffer

	 * pointer advanced by AVE_FRAME_HEADROOM, and expand the map size

	 * by AVE_FRAME_HEADROOM.

 set buffer pointer */

 set enable to cmdsts */

 Switch state of descriptor */

 free pre-stored skb from done_idx to proc_idx */

 do nothing if owner is HW (==1 for Tx) */

 check Tx status and updates statistics */

 success */

 error */

 release skb */

 update stats */

 wake queue for freeing buffer */

 we can't receive more packet, so fill desc quickly */

 do nothing if owner is HW (==0 for Rx) */

 get skbuff for rx */

 update stats */

 refill the Rx buffers */

 enable Rx interrupt when NAPI finishes */

 enable Tx interrupt when NAPI finishes */

 set config register */

 reset RMII register */

 assert reset */

 1st, negate PHY reset only */

 negate reset */

 negate RMII register */

 save and disable MAC receive op */

 suspend Rx descriptor */

 receive all packets before descriptor starts */

 assert reset */

 negate reset */

 negate interrupt status */

 permit descriptor */

 restore MAC reccieve op */

 get interrupt status */

 PHY */

 check exceeding packet */

 RxFIFO overflow */

 Rx drop */

 Rx interval */

 still force to disable Rx interrupt until NAPI finishes */

 Tx completed */

 still force to disable Tx interrupt until NAPI finishes */

 set MAC address for the filter */

 set byte mask */

 set bit mask filter */

 set selector to ring 0 */

 restart filter */

 set byte mask */

 set bit mask filter */

 set selector to rxring */

 promiscious entry, select ring 0 */

 unicast entry */

 broadcast entry */

 set RGMII speed */

 set RMII speed (100M/10M only) */

 check current RXCR/TXCR */

 disable Rx mac */

 change and enable TX/Rx mac */

 pfsel unicast entry */

 enable clk because of hw access until ndo_open */

 set wol initial state disabled */

 disable clk because of hw access after ndo_stop */

 initialize Tx work and descriptor */

 initialize Rx work and descriptor */

 set Rx configuration */

 full duplex, enable pause drop, enalbe flow control */

 set Tx configuration */

 enable flow control, disable loopback */

 enable timer, clear EN,INTM, and mask interval unit(BSCK) */

 free Tx buffer */

 free Rx buffer */

 stop queue when not enough entry */

 add padding for short packet */

	/* map Tx buffer

	 * Tx buffer set to the Tx descriptor doesn't have any restriction.

 set interrupt per AVE_FORCE_TXINTCNT or when queue is stopped */

 disable checksum calculation when skb doesn't calurate checksum */

 MAC addr filter enable for promiscious mode */

 set all multicast address */

 stop all multicast filter */

 set multicast addresses */

 if the mac address is invalid, use random mac address */

 Register as a NAPI supported driver */

 get ID and version */

 Sentinel */ }

 SPDX-License-Identifier: GPL-2.0+

 netsec_xdp_xmit packets */

 XDP tx queue locking */

 protect reg access */

 Netsec Descriptor layout */

************ MDIO BUS OPS FOLLOW *************/

	/* Developerbox implements RTL8211E PHY and there is

	 * a compatibility problem with F_GMAC4.

	 * RTL8211E expects MDC clock must be kept toggling for several

	 * clock cycle with MDIO high before entering the IDLE state.

	 * To meet this requirement, netsec driver needs to issue dummy

	 * read(e.g. read PHYID1(offset 0x2) register) right after write.

************ ETHTOOL_OPS FOLLOW *************/

************ NETDEV_OPS FOLLOW *************/

 need for xdp_return_frame_bulk */

		/* if buf_type is either TYPE_NETSEC_SKB or

		 * TYPE_NETSEC_XDP_NDO we mapped it

		/* clean up so netsec_uninit_pkt_dring() won't free the skb

		 * again

		/* entry->attr is not going to be accessed by the NIC until

		 * netsec_set_tx_de() is called. No need for a dma_wmb() here

 move tail ahead */

 reading the register clears the irq */

		/* Make sure we update the value, anyone stopping the queue

		 * after this will read the proper consumer idx

	/* We allocate the same buffer length for XDP and non-XDP cases.

	 * page_pool API will map the whole page, skip what's needed for

	 * network payloads and/or XDP

	/* Make sure the incoming payload fits in the page for XDP and non-XDP

	 * cases and reserve enough space for headroom + skb_shared_info

 move head ahead */

 The current driver only supports 1 Txq, this should run under spin_lock() */

		/* this is for ndo_xdp_xmit, the buffer needs mapping before

		 * sending

		/* This is the device Rx buffer from page_pool. No need to remap

		 * just sync and send it

 Due xdp_adjust_tail: DMA sync for_device cover max len CPU touch */

 handle aborts by dropping packet */

 reading the register clears the irq */

		/* This  barrier is needed to keep us from reading

		 * any other fields out of the netsec_de until we have

		 * verified the descriptor has been written back

 reuse buffer page frag */

		/* allocate a fresh buffer and map it to the hardware.

		 * This will eventually replace the old buffer in the hardware

			/* If skb fails recycle_direct will either unmap and

			 * free the page or refill the cache depending on the

			 * cache state. Since we paid the allocation cost if

			 * building an skb fails try to put the page into cache

 Update the descriptor with fresh buffers */

 keep tail from touching the queue */

		/* Make sure we read the updated value in case

		 * descriptors got freed

 submit another tx */

 Rx is currently using page_pool */

		/* de->attr is not going to be accessed by the NIC

		 * until netsec_set_tx_de() is called.

		 * No need for a dma_wmb() here

 internal DMA mapping in page_pool */

 stop DMA engines */

 set desc_start addr */

 set normal tx dring ring config */

 start DMA engines */

 change to normal mode */

 clear any pending EMPTY/ERR irq status */

 Disable TX & RX intr */

 Wait soft reset */

 disable all interrupts */

 Disable interrupts */

 Enable TX+RX intr. */

 set phy power down */

 Restore phy power state */

 For now just support only the usual MTU sized frames */

 Detach old prog, if any */

 get by 'phy_ref_clk' */

	/* ACPI systems are assumed to configure the PHY in firmware, so

	 * there is really no need to discover the PHY mode from the DSDT.

	 * Since firmware is known to exist in the field that configures the

	 * PHY correctly but passes the wrong mode string in the phy-mode

	 * device property, we have no choice but to ignore it.

			/* older f/w doesn't populate the mdio subnode,

			 * allow relaxed upgrade of f/w in due time.

 Mask out all PHYs from auto probing. */

 default for throughput */

 runtime_pm coverage just for probe, open/close also cover it */

 this driver only supports F_TAIKI style NETSEC */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  Copyright (C) 2018 Chelsio Communications.  All rights reserved.

 Write compression header to output buffer before compression */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  Copyright (C) 2017 Chelsio Communications.  All rights reserved.

 *

 *  Written by: Ganesh Goudar (ganeshgr@chelsio.com)

	/* on older firmwares we may not get the trip temperature,

	 * set the num of trips to 0.

 could not get trip temperature */

/*

 * This file is part of the Chelsio T4 Ethernet driver for Linux.

 *

 * Copyright (c) 2003-2016 Chelsio Communications, Inc. All rights reserved.

 *

 * This software is available to you under a choice of one of two

 * licenses.  You may choose to be licensed under the terms of the GNU

 * General Public License (GPL) Version 2, available from the file

 * COPYING in the main directory of this source tree, or the

 * OpenIB.org BSD license below:

 *

 *     Redistribution and use in source and binary forms, with or

 *     without modification, are permitted provided that the following

 *     conditions are met:

 *

 *      - Redistributions of source code must retain the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer.

 *

 *      - Redistributions in binary form must reproduce the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer in the documentation and/or other materials

 *        provided with the distribution.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS

 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN

 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN

 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

/**

 *	t4_wait_op_done_val - wait until an operation is completed

 *	@adapter: the adapter performing the operation

 *	@reg: the register to check for completion

 *	@mask: a single-bit field within @reg that indicates completion

 *	@polarity: the value of the field when the operation is completed

 *	@attempts: number of check iterations

 *	@delay: delay in usecs between iterations

 *	@valp: where to store the value of the register at completion time

 *

 *	Wait until an operation is completed by checking a bit in a register

 *	up to @attempts times.  If @valp is not NULL the value of the register

 *	at the time it indicated completion is stored there.  Returns 0 if the

 *	operation completes and	-EAGAIN	otherwise.

/**

 *	t4_set_reg_field - set a register field to a value

 *	@adapter: the adapter to program

 *	@addr: the register address

 *	@mask: specifies the portion of the register to modify

 *	@val: the new value for the register field

 *

 *	Sets a register field specified by the supplied mask to the

 *	given value.

 flush */

/**

 *	t4_read_indirect - read indirectly addressed registers

 *	@adap: the adapter

 *	@addr_reg: register holding the indirect address

 *	@data_reg: register holding the value of the indirect register

 *	@vals: where the read register values are stored

 *	@nregs: how many indirect registers to read

 *	@start_idx: index of first indirect register to read

 *

 *	Reads registers that are accessed indirectly through an address/data

 *	register pair.

/**

 *	t4_write_indirect - write indirectly addressed registers

 *	@adap: the adapter

 *	@addr_reg: register holding the indirect addresses

 *	@data_reg: register holding the value for the indirect registers

 *	@vals: values to write

 *	@nregs: how many indirect registers to write

 *	@start_idx: address of first indirect register to write

 *

 *	Writes a sequential block of registers that are accessed indirectly

 *	through an address/data register pair.

/*

 * Read a 32-bit PCI Configuration Space register via the PCI-E backdoor

 * mechanism.  This guarantees that we get the real value even if we're

 * operating within a Virtual Machine and the Hypervisor is trapping our

 * Configuration Space accesses.

	/* Reset ENABLE to 0 so reads of PCIE_CFG_SPACE_DATA won't cause a

	 * Configuration Space read.  (None of the other fields matter when

	 * ENABLE is 0 so a simple register write is easier than a

	 * read-modify-write via t4_set_reg_field().)

/*

 * t4_report_fw_error - report firmware error

 * @adap: the adapter

 *

 * The adapter firmware can indicate error conditions to the host.

 * If the firmware has indicated an error, print out the reason for

 * the firmware error.

 PCIE_FW_EVAL_CRASH */

 PCIE_FW_EVAL_PREP */

 PCIE_FW_EVAL_CONF */

 PCIE_FW_EVAL_INIT */

 PCIE_FW_EVAL_UNEXPECTEDEVENT */

 PCIE_FW_EVAL_OVERHEAT */

 PCIE_FW_EVAL_DEVICESHUTDOWN */

 reserved */

/*

 * Get the reply to a mailbox command and store it in @rpl in big-endian order.

/*

 * Handle a FW assertion reported in a mailbox.

/**

 *	t4_record_mbox - record a Firmware Mailbox Command/Reply in the log

 *	@adapter: the adapter

 *	@cmd: the Firmware Mailbox Command or Reply

 *	@size: command length in bytes

 *	@access: the time (ms) needed to access the Firmware Mailbox

 *	@execute: the time (ms) the command spent being executed

/**

 *	t4_wr_mbox_meat_timeout - send a command to FW through the given mailbox

 *	@adap: the adapter

 *	@mbox: index of the mailbox to use

 *	@cmd: the command to write

 *	@size: command length in bytes

 *	@rpl: where to optionally store the reply

 *	@sleep_ok: if true we may sleep while awaiting command completion

 *	@timeout: time to wait for command to finish before timing out

 *

 *	Sends the given command to FW through the selected mailbox and waits

 *	for the FW to execute the command.  If @rpl is not %NULL it is used to

 *	store the FW's reply to the command.  The command and its optional

 *	reply are of the same length.  FW can take up to %FW_CMD_MAX_TIMEOUT ms

 *	to respond.  @sleep_ok determines whether we may sleep while awaiting

 *	the response.  If sleeping is allowed we use progressive backoff

 *	otherwise we spin.

 *

 *	The return value is 0 on success or a negative errno on failure.  A

 *	failure can happen either because we are not able to execute the

 *	command or FW executes it but signals an error.  In the latter case

 *	the return value is the error code indicated by FW (negated).

	/*

	 * If the device is off-line, as in EEH, commands will time out.

	 * Fail them early so we don't waste time waiting.

 If we have a negative timeout, that implies that we can't sleep. */

	/* Queue ourselves onto the mailbox access list.  When our entry is at

	 * the front of the list, we have rights to access the mailbox.  So we

	 * wait [for a while] till we're at the front [or bail out with an

	 * EBUSY] ...

		/* If we've waited too long, return a busy indication.  This

		 * really ought to be based on our initial position in the

		 * mailbox access list but this is a start.  We very rarely

		 * contend on access to the mailbox ...

		/* If we're at the head, break out and start the mailbox

		 * protocol.

 Delay for a bit before checking again ... */

 last element may repeat */

	/* Loop trying to get ownership of the mailbox.  Return an error

	 * if we can't gain ownership.

 Copy in the new mailbox command and send it on its way ... */

 flush write */

 last element may repeat */

/**

 * t4_memory_rw_init - Get memory window relative offset, base, and size.

 * @adap: the adapter

 * @win: PCI-E Memory Window to use

 * @mtype: memory type: MEM_EDC0, MEM_EDC1, MEM_HMA or MEM_MC

 * @mem_off: memory relative offset with respect to @mtype.

 * @mem_base: configured memory base address.

 * @mem_aperture: configured memory window aperture.

 *

 * Get the configured memory window's relative offset, base, and size.

	/* Offset into the region of memory which is being accessed

	 * MEM_EDC0 = 0

	 * MEM_EDC1 = 1

	 * MEM_MC   = 2 -- MEM_MC for chips with only 1 memory controller

	 * MEM_MC1  = 3 -- for chips with 2 memory controllers (e.g. T5)

	 * MEM_HMA  = 4

	/* Each PCI-E Memory Window is programmed with a window size -- or

	 * "aperture" -- which controls the granularity of its mapping onto

	 * adapter memory.  We need to grab that aperture in order to know

	 * how to use the specified window.  The window is also programmed

	 * with the base address of the Memory Window in BAR0's address

	 * space.  For T4 this is an absolute PCI-E Bus Address.  For T5

	 * the address is relative to BAR0.

 a dead adapter will return 0xffffffff for PIO reads */

/**

 * t4_memory_update_win - Move memory window to specified address.

 * @adap: the adapter

 * @win: PCI-E Memory Window to use

 * @addr: location to move.

 *

 * Move memory window to specified address.

	/* Read it back to ensure that changes propagate before we

	 * attempt to use the new value.

/**

 * t4_memory_rw_residual - Read/Write residual data.

 * @adap: the adapter

 * @off: relative offset within residual to start read/write.

 * @addr: address within indicated memory type.

 * @buf: host memory buffer

 * @dir: direction of transfer T4_MEMORY_READ (1) or T4_MEMORY_WRITE (0)

 *

 * Read/Write residual data less than 32-bits.

/**

 *	t4_memory_rw - read/write EDC 0, EDC 1 or MC via PCIE memory window

 *	@adap: the adapter

 *	@win: PCI-E Memory Window to use

 *	@mtype: memory type: MEM_EDC0, MEM_EDC1 or MEM_MC

 *	@addr: address within indicated memory type

 *	@len: amount of memory to transfer

 *	@hbuf: host memory buffer

 *	@dir: direction of transfer T4_MEMORY_READ (1) or T4_MEMORY_WRITE (0)

 *

 *	Reads/writes an [almost] arbitrary memory region in the firmware: the

 *	firmware memory address and host buffer must be aligned on 32-bit

 *	boundaries; the length may be arbitrary.  The memory is transferred as

 *	a raw byte sequence from/to the firmware's memory.  If this memory

 *	contains data structures which contain multi-byte integers, it's the

 *	caller's responsibility to perform appropriate byte order conversions.

	/* Argument sanity checks ...

	/* It's convenient to be able to handle lengths which aren't a

	 * multiple of 32-bits because we often end up transferring files to

	 * the firmware.  So we'll handle that by normalizing the length here

	 * and then handling any residual transfer at the end.

 Determine the PCIE_MEM_ACCESS_OFFSET */

	/* Calculate our initial PCI-E Memory Window Position and Offset into

	 * that Window.

	/* Set up initial PCI-E Memory Window to cover the start of our

	 * transfer.

	/* Transfer data to/from the adapter as long as there's an integral

	 * number of 32-bit transfers to complete.

	 *

	 * A note on Endianness issues:

	 *

	 * The "register" reads and writes below from/to the PCI-E Memory

	 * Window invoke the standard adapter Big-Endian to PCI-E Link

	 * Little-Endian "swizzel."  As a result, if we have the following

	 * data in adapter memory:

	 *

	 *     Memory:  ... | b0 | b1 | b2 | b3 | ...

	 *     Address:      i+0  i+1  i+2  i+3

	 *

	 * Then a read of the adapter memory via the PCI-E Memory Window

	 * will yield:

	 *

	 *     x = readl(i)

	 *         31                  0

	 *         [ b3 | b2 | b1 | b0 ]

	 *

	 * If this value is stored into local memory on a Little-Endian system

	 * it will show up correctly in local memory as:

	 *

	 *     ( ..., b0, b1, b2, b3, ... )

	 *

	 * But on a Big-Endian system, the store will show up in memory

	 * incorrectly swizzled as:

	 *

	 *     ( ..., b3, b2, b1, b0, ... )

	 *

	 * So we need to account for this in the reads and writes to the

	 * PCI-E Memory Window below by undoing the register read/write

	 * swizzels.

		/* If we've reached the end of our current window aperture,

		 * move the PCI-E Memory Window on to the next.  Note that

		 * doing this here after "len" may be 0 allows us to set up

		 * the PCI-E Memory Window for a possible final residual

		 * transfer below ...

	/* If the original transfer had a length which wasn't a multiple of

	 * 32-bits, now's where we need to finish off the transfer of the

	 * residual amount.  The PCI-E Memory Window has already been moved

	 * above (if necessary) to cover this final transfer.

/* Return the specified PCI-E Configuration Space register from our Physical

 * Function.  We try first via a Firmware LDST Command since we prefer to let

 * the firmware own all of these registers, but if that fails we go for it

 * directly ourselves.

	/* If fw_attach != 0, construct and send the Firmware LDST Command to

	 * retrieve the specified PCI-E Configuration Space register.

	/* If the LDST Command succeeds, return the result, otherwise

	 * fall through to reading it directly ourselves ...

		/* Read the desired Configuration Space register via the PCI-E

		 * Backdoor mechanism.

/* Get the window based on base passed to it.

 * Window aperture is currently unhandled, but there is no use case for it

 * right now

		/* Truncation intentional: we only read the bottom 32-bits of

		 * the 64-bit BAR0/BAR1 ...  We use the hardware backdoor

		 * mechanism to read BAR0 instead of using

		 * pci_resource_start() because we could be operating from

		 * within a Virtual Machine which is trapping our accesses to

		 * our Configuration Space and we need to set up the PCI-E

		 * Memory Window decoders with the actual addresses which will

		 * be coming across the PCI-E link.

 For T5, only relative offset inside the PCIe BAR is passed */

 Get the default utility window (win0) used by everyone */

/* Set up memory window for accessing adapter memory ranges.  (Read

 * back MA register to ensure that changes propagate before we attempt

 * to use the new values.)

/**

 *	t4_get_regs_len - return the size of the chips register set

 *	@adapter: the adapter

 *

 *	Returns the size of the chip's BAR0 register space.

/**

 *	t4_get_regs - read chip registers into provided buffer

 *	@adap: the adapter

 *	@buf: register buffer

 *	@buf_size: size (in bytes) of register buffer

 *

 *	If the provided register buffer isn't large enough for the chip's

 *	full register range, the register dump will be truncated to the

 *	register buffer's size.

	/* Select the right set of register ranges to dump depending on the

	 * adapter chip type.

	/* Clear the register buffer and insert the appropriate register

	 * values selected by the above register ranges.

		/* Iterate across the register range filling in the register

		 * buffer but don't write past the end of the register buffer.

/**

 * t4_eeprom_ptov - translate a physical EEPROM address to virtual

 * @phys_addr: the physical EEPROM address

 * @fn: the PCI function number

 * @sz: size of function-specific area

 *

 * Translate a physical EEPROM address to virtual.  The first 1K is

 * accessed through virtual addresses starting at 31K, the rest is

 * accessed through virtual addresses starting at 0.

 *

 * The mapping is as follows:

 * [0..1K) -> [31K..32K)

 * [1K..1K+A) -> [31K-A..31K)

 * [1K+A..ES) -> [0..ES-A-1K)

 *

 * where A = @fn * @sz, and ES = EEPROM size.

/**

 *	t4_seeprom_wp - enable/disable EEPROM write protection

 *	@adapter: the adapter

 *	@enable: whether to enable or disable write protection

 *

 *	Enables or disables write protection on the serial EEPROM.

/**

 *	t4_get_raw_vpd_params - read VPD parameters from VPD EEPROM

 *	@adapter: adapter to read

 *	@p: where to store the parameters

 *

 *	Reads card parameters stored in VPD EEPROM.

	/* Card information normally starts at VPD_BASE but early cards had

	 * it at 0.

/**

 *	t4_get_vpd_params - read VPD parameters & retrieve Core Clock

 *	@adapter: adapter to read

 *	@p: where to store the parameters

 *

 *	Reads card parameters stored in VPD EEPROM and retrieves the Core

 *	Clock.  This can only be called after a connection to the firmware

 *	is established.

	/* Grab the raw VPD parameters.

	/* Ask firmware for the Core Clock since it knows how to translate the

	 * Reference Clock ('V2') VPD field into a Core Clock value ...

/**

 *	t4_get_pfres - retrieve VF resource limits

 *	@adapter: the adapter

 *

 *	Retrieves configured resource limits and capabilities for a physical

 *	function.  The results are stored in @adapter->pfres.

	/* Execute PFVF Read command to get VF resource limits; bail out early

	 * with error on command failure.

	/* Extract PF resource limits and return success.

 serial flash and firmware constants */

 max retries for SF operations */

 flash command opcodes */

 program page */

 disable writes */

 read status register */

 enable writes */

 read flash */

 read ID */

 erase sector */

/**

 *	sf1_read - read data from the serial flash

 *	@adapter: the adapter

 *	@byte_cnt: number of bytes to read

 *	@cont: whether another operation will be chained

 *	@lock: whether to lock SF for PL access only

 *	@valp: where to store the read data

 *

 *	Reads up to 4 bytes of data from the serial flash.  The location of

 *	the read needs to be specified prior to calling this by issuing the

 *	appropriate commands to the serial flash.

/**

 *	sf1_write - write data to the serial flash

 *	@adapter: the adapter

 *	@byte_cnt: number of bytes to write

 *	@cont: whether another operation will be chained

 *	@lock: whether to lock SF for PL access only

 *	@val: value to write

 *

 *	Writes up to 4 bytes of data to the serial flash.  The location of

 *	the write needs to be specified prior to calling this by issuing the

 *	appropriate commands to the serial flash.

/**

 *	flash_wait_op - wait for a flash operation to complete

 *	@adapter: the adapter

 *	@attempts: max number of polls of the status register

 *	@delay: delay between polls in ms

 *

 *	Wait for a flash operation to complete by polling the status register.

/**

 *	t4_read_flash - read words from serial flash

 *	@adapter: the adapter

 *	@addr: the start address for the read

 *	@nwords: how many 32-bit words to read

 *	@data: where to store the read data

 *	@byte_oriented: whether to store data as bytes or as words

 *

 *	Read the specified number of 32-bit words from the serial flash.

 *	If @byte_oriented is set the read data is stored as a byte array

 *	(i.e., big-endian), otherwise as 32-bit words in the platform's

 *	natural endianness.

 unlock SF */

/**

 *	t4_write_flash - write up to a page of data to the serial flash

 *	@adapter: the adapter

 *	@addr: the start address to write

 *	@n: length of data to write in bytes

 *	@data: the data to write

 *	@byte_oriented: whether to store data as bytes or as words

 *

 *	Writes up to a page of data (256 bytes) to the serial flash starting

 *	at the given address.  All the data must be written to the same page.

 *	If @byte_oriented is set the write data is stored as byte stream

 *	(i.e. matches what on disk), otherwise in big-endian.

 unlock SF */

 Read the page to verify the write succeeded */

 unlock SF */

/**

 *	t4_get_fw_version - read the firmware version

 *	@adapter: the adapter

 *	@vers: where to place the version

 *

 *	Reads the FW version from flash.

/**

 *	t4_get_bs_version - read the firmware bootstrap version

 *	@adapter: the adapter

 *	@vers: where to place the version

 *

 *	Reads the FW Bootstrap version from flash.

/**

 *	t4_get_tp_version - read the TP microcode version

 *	@adapter: the adapter

 *	@vers: where to place the version

 *

 *	Reads the TP microcode version from flash.

/**

 *	t4_get_exprom_version - return the Expansion ROM version (if any)

 *	@adap: the adapter

 *	@vers: where to place the version

 *

 *	Reads the Expansion ROM header from FLASH and returns the version

 *	number (if present) through the @vers return value pointer.  We return

 *	this in the Firmware Version Format since it's convenient.  Return

 *	0 on success, -ENOENT if no Expansion ROM is present.

 must start with 0x55aa */

 Expansion ROM version */

/**

 *      t4_get_vpd_version - return the VPD version

 *      @adapter: the adapter

 *      @vers: where to place the version

 *

 *      Reads the VPD via the Firmware interface (thus this can only be called

 *      once we're ready to issue Firmware commands).  The format of the

 *      VPD version is adapter specific.  Returns 0 on success, an error on

 *      failure.

 *

 *      Note that early versions of the Firmware didn't include the ability

 *      to retrieve the VPD version, so we zero-out the return-value parameter

 *      in that case to avoid leaving it with garbage in it.

 *

 *      Also note that the Firmware will return its cached copy of the VPD

 *      Revision ID, not the actual Revision ID as written in the Serial

 *      EEPROM.  This is only an issue if a new VPD has been written and the

 *      Firmware/Chip haven't yet gone through a RESET sequence.  So it's best

 *      to defer calling this routine till after a FW_RESET_CMD has been issued

 *      if the Host Driver will be performing a full adapter initialization.

/**

 *      t4_get_scfg_version - return the Serial Configuration version

 *      @adapter: the adapter

 *      @vers: where to place the version

 *

 *      Reads the Serial Configuration Version via the Firmware interface

 *      (thus this can only be called once we're ready to issue Firmware

 *      commands).  The format of the Serial Configuration version is

 *      adapter specific.  Returns 0 on success, an error on failure.

 *

 *      Note that early versions of the Firmware didn't include the ability

 *      to retrieve the Serial Configuration version, so we zero-out the

 *      return-value parameter in that case to avoid leaving it with

 *      garbage in it.

 *

 *      Also note that the Firmware will return its cached copy of the Serial

 *      Initialization Revision ID, not the actual Revision ID as written in

 *      the Serial EEPROM.  This is only an issue if a new VPD has been written

 *      and the Firmware/Chip haven't yet gone through a RESET sequence.  So

 *      it's best to defer calling this routine till after a FW_RESET_CMD has

 *      been issued if the Host Driver will be performing a full adapter

 *      initialization.

/**

 *      t4_get_version_info - extract various chip/firmware version information

 *      @adapter: the adapter

 *

 *      Reads various chip/firmware version numbers and stores them into the

 *      adapter Adapter Parameters structure.  If any of the efforts fails

 *      the first failure will be returned, but all of the version numbers

 *      will be read.

/**

 *      t4_dump_version_info - dump all of the adapter configuration IDs

 *      @adapter: the adapter

 *

 *      Dumps all of the various bits of adapter configuration version/revision

 *      IDs information.  This is typically called at some point after

 *      t4_get_version_info() has been called.

 Device information */

 Firmware Version */

	/* Bootstrap Firmware Version. (Some adapters don't have Bootstrap

	 * Firmware, so dev_info() is more appropriate here.)

 TP Microcode Version */

 Expansion ROM version */

 Serial Configuration version */

 VPD Version */

/**

 *	t4_check_fw_version - check if the FW is supported with this driver

 *	@adap: the adapter

 *

 *	Checks if an adapter's FW is compatible with the driver.  Returns 0

 *	if there's exact match, a negative error if the version could not be

 *	read or there's a major version mismatch

 Try multiple times before returning error */

/* Is the given firmware API compatible with the one the driver was compiled

 * with?

 short circuit if it's the exact same firmware version */

/* The firmware in the filesystem is usable, but should it be installed?

 * This routine explains itself in detail if it indicates the filesystem

 * firmware should be installed.

 Read the header of the firmware on the card */

		/* Common case: the firmware on the card is an exact match and

		 * the filesystem one is an exact match too, or the filesystem

		 * one is absent/incompatible.

 Installed successfully, update the cached header too. */

 already reset as part of load_fw */

 We're using whatever's on the card and it's known to be good. */

/**

 *	t4_flash_erase_sectors - erase a range of flash sectors

 *	@adapter: the adapter

 *	@start: the first sector to erase

 *	@end: the last sector to erase

 *

 *	Erases the sectors in the given inclusive range.

 unlock SF */

/**

 *	t4_flash_cfg_addr - return the address of the flash configuration file

 *	@adapter: the adapter

 *

 *	Return the address within the flash where the Firmware Configuration

 *	File is stored.

/* Return TRUE if the specified firmware matches the adapter.  I.e. T4

 * firmware for T4 adapters, T5 firmware for T5 adapters, etc.  We go ahead

 * and emit an error message for mismatched firmware to save our caller the

 * effort ...

	/* The expression below will return FALSE for any unsupported adapter

	 * which will keep us "honest" in the future ...

/**

 *	t4_load_fw - download firmware

 *	@adap: the adapter

 *	@fw_data: the firmware image to write

 *	@size: image size

 *

 *	Write the supplied firmware image to the card's serial flash.

 # of sectors spanned */

	/*

	 * We write the correct version at the end so the driver can see a bad

	 * version if the FW write fails.  Start by writing a copy of the

	 * first page with a bad version.

/**

 *	t4_phy_fw_ver - return current PHY firmware version

 *	@adap: the adapter

 *	@phy_fw_ver: return value buffer for PHY firmware version

 *

 *	Returns the current version of external PHY firmware on the

 *	adapter.

/**

 *	t4_load_phy_fw - download port PHY firmware

 *	@adap: the adapter

 *	@win: the PCI-E Memory Window index to use for t4_memory_rw()

 *	@phy_fw_version: function to check PHY firmware versions

 *	@phy_fw_data: the PHY firmware image to write

 *	@phy_fw_size: image size

 *

 *	Transfer the specified PHY firmware to the adapter.  If a non-NULL

 *	@phy_fw_version is supplied, then it will be used to determine if

 *	it's necessary to perform the transfer by comparing the version

 *	of any existing adapter PHY firmware with that of the passed in

 *	PHY firmware image.

 *

 *	A negative error number will be returned if an error occurs.  If

 *	version number support is available and there's no need to upgrade

 *	the firmware, 0 will be returned.  If firmware is successfully

 *	transferred to the adapter, 1 will be returned.

 *

 *	NOTE: some adapters only have local RAM to store the PHY firmware.  As

 *	a result, a RESET of the adapter would cause that RAM to lose its

 *	contents.  Thus, loading PHY firmware on such adapters must happen

 *	after any FW_RESET_CMDs ...

	/* If we have version number support, then check to see if the adapter

	 * already has up-to-date PHY firmware loaded.

	/* Ask the firmware where it wants us to copy the PHY firmware image.

	 * The size of the file requires a special version of the READ command

	 * which will pass the file size via the values field in PARAMS_CMD and

	 * retrieve the return value from firmware and place it in the same

	 * buffer values

	/* Copy the supplied PHY Firmware image to the adapter memory location

	 * allocated by the adapter firmware.

	/* Tell the firmware that the PHY firmware image has been written to

	 * RAM and it can now start copying it over to the PHYs.  The chip

	 * firmware will RESET the affected PHYs as part of this operation

	 * leaving them running the new PHY firmware image.

	/* If we have version number support, then check to see that the new

	 * firmware got loaded properly.

/**

 *	t4_fwcache - firmware cache operation

 *	@adap: the adapter

 *	@op  : the operation (flush or flush and invalidate)

/* The ADVERT_MASK is used to mask out all of the Advertised Firmware Port

 * Capabilities which we control with separate controls -- see, for instance,

 * Pause Frames and Forward Error Correction.  In order to determine what the

 * full set of Advertised Port Capabilities are, the base Advertised Port

 * Capabilities (masked by ADVERT_MASK) must be combined with the Advertised

 * Port Capabilities associated with those other controls.  See

 * t4_link_acaps() for how this is done.

/**

 *	fwcaps16_to_caps32 - convert 16-bit Port Capabilities to 32-bits

 *	@caps16: a 16-bit Port Capabilities value

 *

 *	Returns the equivalent 32-bit Port Capabilities value.

/**

 *	fwcaps32_to_caps16 - convert 32-bit Port Capabilities to 16-bits

 *	@caps32: a 32-bit Port Capabilities value

 *

 *	Returns the equivalent 16-bit Port Capabilities value.  Note that

 *	not all 32-bit Port Capabilities can be represented in the 16-bit

 *	Port Capabilities and some fields/values may not make it.

 Translate Firmware Port Capabilities Pause specification to Common Code */

 Translate Common Code Pause specification into Firmware Port Capabilities */

	/* Translate orthogonal RX/TX Pause Controls for L1 Configure

	 * commands, etc.

	/* Translate orthogonal Pause controls into IEEE 802.3 Pause,

	 * Asymmetrical Pause for use in reporting to upper layer OS code, etc.

	 * Note that these bits are ignored in L1 Configure commands.

 Translate Firmware Forward Error Correction specification to Common Code */

 Translate Common Code Forward Error Correction specification to Firmware */

/**

 *	t4_link_acaps - compute Link Advertised Port Capabilities

 *	@adapter: the adapter

 *	@port: the Port ID

 *	@lc: the Port's Link Configuration

 *

 *	Synthesize the Advertised Port Capabilities we'll be using based on

 *	the base Advertised Port Capabilities (which have been filtered by

 *	ADVERT_MASK) plus the individual controls for things like Pause

 *	Frames, Forward Error Correction, MDI, etc.

	/* Convert driver coding of Pause Frame Flow Control settings into the

	 * Firmware's API.

	/* Convert Common Code Forward Error Control settings into the

	 * Firmware's API.  If the current Requested FEC has "Automatic"

	 * (IEEE 802.3) specified, then we use whatever the Firmware

	 * sent us as part of its IEEE 802.3-based interpretation of

	 * the Transceiver Module EPROM FEC parameters.  Otherwise we

	 * use whatever is in the current Requested FEC settings.

	/* Figure out what our Requested Port Capabilities are going to be.

	 * Note parallel structure in t4_handle_get_port_info() and

	 * init_link_config().

	/* Some Requested Port Capabilities are trivially wrong if they exceed

	 * the Physical Port Capabilities.  We can check that here and provide

	 * moderately useful feedback in the system log.

	 *

	 * Note that older Firmware doesn't have FW_PORT_CAP32_FORCE_PAUSE, so

	 * we need to exclude this from this check in order to maintain

	 * compatibility ...

/**

 *	t4_link_l1cfg_core - apply link configuration to MAC/PHY

 *	@adapter: the adapter

 *	@mbox: the Firmware Mailbox to use

 *	@port: the Port ID

 *	@lc: the Port's Link Configuration

 *	@sleep_ok: if true we may sleep while awaiting command completion

 *	@timeout: time to wait for command to finish before timing out

 *		(negative implies @sleep_ok=false)

 *

 *	Set up a port's MAC and PHY according to a desired link configuration.

 *	- If the PHY can auto-negotiate first decide what to advertise, then

 *	  enable/disable auto-negotiation as desired, and reset.

 *	- If the PHY does not auto-negotiate just reset it.

 *	- If auto-negotiation is off set the MAC to the proper speed/duplex/FC,

 *	  otherwise do it later based on the outcome of auto-negotiation.

	/* Compute our Requested Port Capabilities and send that on to the

	 * Firmware.

	/* Unfortunately, even if the Requested Port Capabilities "fit" within

	 * the Physical Port Capabilities, some combinations of features may

	 * still not be legal.  For example, 40Gb/s and Reed-Solomon Forward

	 * Error Correction.  So if the Firmware rejects the L1 Configure

	 * request, flag that here.

/**

 *	t4_restart_aneg - restart autonegotiation

 *	@adap: the adapter

 *	@mbox: mbox to use for the FW command

 *	@port: the port id

 *

 *	Restarts autonegotiation for the selected port.

 bits to check in interrupt status */

 message to print or NULL */

 stat counter to increment or -1 */

 whether the condition reported is fatal */

 platform-specific int handler */

/**

 *	t4_handle_intr_status - table driven interrupt handler

 *	@adapter: the adapter that generated the interrupt

 *	@reg: the interrupt status register to process

 *	@acts: table of interrupt actions

 *

 *	A table driven interrupt handler that applies a set of masks to an

 *	interrupt status word and performs the corresponding actions if the

 *	interrupts described by the mask have occurred.  The actions include

 *	optionally emitting a warning or alert message.  The table is terminated

 *	by an entry specifying mask 0.  Returns the number of fatal interrupt

 *	conditions.

 clear processed interrupts */

/*

 * Interrupt handler for the PCIE module.

/*

 * TP interrupt handler.

/*

 * SGE interrupt handler.

 Parity error (CRC) for err_T_RxCRC is trivial, ignore it */

/*

 * CIM interrupt handler.

	/* When the Firmware detects an internal error which normally

	 * wouldn't raise a Host Interrupt, it forces a CIM Timer0 interrupt

	 * in order to make sure the Host sees the Firmware Crash.  So

	 * if we have a Timer0 interrupt and don't see a Firmware Crash,

	 * ignore the Timer0 interrupt.

/*

 * ULP RX interrupt handler.

/*

 * ULP TX interrupt handler.

/*

 * PM TX interrupt handler.

/*

 * PM RX interrupt handler.

/*

 * CPL switch interrupt handler.

/*

 * LE interrupt handler.

/*

 * MPS interrupt handler.

 MPS Tx Bubble is normal for T6 */

 flush */

/*

 * EDC/MC interrupt handler.

/*

 * MA interrupt handler.

/*

 * SMB interrupt handler.

/*

 * NC-SI interrupt handler.

/*

 * XGMAC interrupt handler.

/*

 * PL interrupt handler.

/**

 *	t4_slow_intr_handler - control path interrupt handler

 *	@adapter: the adapter

 *

 *	T4 interrupt handler for non-data global interrupt events, e.g., errors.

 *	The designation 'slow' is because it involves register reads, while

 *	data interrupts typically don't involve any MMIOs.

	/* There are rare cases where a PL_INT_CAUSE bit may end up getting

	 * set when the corresponding PL_INT_ENABLE bit isn't set.  It's

	 * easiest just to mask that case here.

 Clear the interrupts just processed for which we are the master. */

 flush */

/**

 *	t4_intr_enable - enable interrupts

 *	@adapter: the adapter whose interrupts should be enabled

 *

 *	Enable PF-specific interrupts for the calling function and the top-level

 *	interrupt concentrator for global interrupts.  Interrupts are already

 *	enabled at each module,	here we just enable the roots of the interrupt

 *	hierarchies.

 *

 *	Note: this function should be called only when the driver manages

 *	non PF-specific interrupts from the various HW modules.  Only one PCI

 *	function at a time should be doing this.

/**

 *	t4_intr_disable - disable interrupts

 *	@adapter: the adapter whose interrupts should be disabled

 *

 *	Disable interrupts.  We only disable the top-level interrupt

 *	concentrators.  The caller must be a PCI function managing global

 *	interrupts.

/**

 *	t4_config_rss_range - configure a portion of the RSS mapping table

 *	@adapter: the adapter

 *	@mbox: mbox to use for the FW command

 *	@viid: virtual interface whose RSS subtable is to be written

 *	@start: start entry in the table to write

 *	@n: how many table entries to write

 *	@rspq: values for the response queue lookup table

 *	@nrspq: number of values in @rspq

 *

 *	Programs the selected part of the VI's RSS mapping table with the

 *	provided values.  If @nrspq < @n the supplied values are used repeatedly

 *	until the full table range is populated.

 *

 *	The caller must ensure the values in @rspq are in the range allowed for

 *	@viid.

 each fw_rss_ind_tbl_cmd takes up to 32 entries */

/**

 *	t4_config_glbl_rss - configure the global RSS mode

 *	@adapter: the adapter

 *	@mbox: mbox to use for the FW command

 *	@mode: global RSS mode

 *	@flags: mode-specific flags

 *

 *	Sets the global RSS mode.

/**

 *	t4_config_vi_rss - configure per VI RSS settings

 *	@adapter: the adapter

 *	@mbox: mbox to use for the FW command

 *	@viid: the VI id

 *	@flags: RSS flags

 *	@defq: id of the default RSS queue for the VI.

 *

 *	Configures VI-specific RSS properties.

 Read an RSS table row */

/**

 *	t4_read_rss - read the contents of the RSS mapping table

 *	@adapter: the adapter

 *	@map: holds the contents of the RSS mapping table

 *

 *	Reads the contents of the RSS hash->queue mapping table.

/**

 * t4_tp_fw_ldst_rw - Access TP indirect register through LDST

 * @adap: the adapter

 * @cmd: TP fw ldst address space type

 * @vals: where the indirect register values are stored/written

 * @nregs: how many indirect registers to read/write

 * @start_index: index of first indirect register to read/write

 * @rw: Read (1) or Write (0)

 * @sleep_ok: if true we may sleep while awaiting command completion

 *

 * Access TP indirect registers through LDST

/**

 * t4_tp_indirect_rw - Read/Write TP indirect register through LDST or backdoor

 * @adap: the adapter

 * @reg_addr: Address Register

 * @reg_data: Data register

 * @buff: where the indirect register values are stored/written

 * @nregs: how many indirect registers to read/write

 * @start_index: index of first indirect register to read/write

 * @rw: READ(1) or WRITE(0)

 * @sleep_ok: if true we may sleep while awaiting command completion

 *

 * Read/Write TP indirect registers through LDST if possible.

 * Else, use backdoor access

/**

 * t4_tp_pio_read - Read TP PIO registers

 * @adap: the adapter

 * @buff: where the indirect register values are written

 * @nregs: how many indirect registers to read

 * @start_index: index of first indirect register to read

 * @sleep_ok: if true we may sleep while awaiting command completion

 *

 * Read TP PIO Registers

/**

 * t4_tp_pio_write - Write TP PIO registers

 * @adap: the adapter

 * @buff: where the indirect register values are stored

 * @nregs: how many indirect registers to write

 * @start_index: index of first indirect register to write

 * @sleep_ok: if true we may sleep while awaiting command completion

 *

 * Write TP PIO Registers

/**

 * t4_tp_tm_pio_read - Read TP TM PIO registers

 * @adap: the adapter

 * @buff: where the indirect register values are written

 * @nregs: how many indirect registers to read

 * @start_index: index of first indirect register to read

 * @sleep_ok: if true we may sleep while awaiting command completion

 *

 * Read TP TM PIO Registers

/**

 * t4_tp_mib_read - Read TP MIB registers

 * @adap: the adapter

 * @buff: where the indirect register values are written

 * @nregs: how many indirect registers to read

 * @start_index: index of first indirect register to read

 * @sleep_ok: if true we may sleep while awaiting command completion

 *

 * Read TP MIB Registers

/**

 *	t4_read_rss_key - read the global RSS key

 *	@adap: the adapter

 *	@key: 10-entry array holding the 320-bit RSS key

 *      @sleep_ok: if true we may sleep while awaiting command completion

 *

 *	Reads the global 320-bit RSS key.

/**

 *	t4_write_rss_key - program one of the RSS keys

 *	@adap: the adapter

 *	@key: 10-entry array holding the 320-bit RSS key

 *	@idx: which RSS key to write

 *      @sleep_ok: if true we may sleep while awaiting command completion

 *

 *	Writes one of the RSS keys with the given 320-bit value.  If @idx is

 *	0..15 the corresponding entry in the RSS key table is written,

 *	otherwise the global RSS key is written.

	/* T6 and later: for KeyMode 3 (per-vf and per-vf scramble),

	 * allows access to key addresses 16-63 by using KeyWrAddrX

	 * as index[5:4](upper 2) into key table

/**

 *	t4_read_rss_pf_config - read PF RSS Configuration Table

 *	@adapter: the adapter

 *	@index: the entry in the PF RSS table to read

 *	@valp: where to store the returned value

 *      @sleep_ok: if true we may sleep while awaiting command completion

 *

 *	Reads the PF RSS Configuration Table at the specified index and returns

 *	the value found there.

/**

 *	t4_read_rss_vf_config - read VF RSS Configuration Table

 *	@adapter: the adapter

 *	@index: the entry in the VF RSS table to read

 *	@vfl: where to store the returned VFL

 *	@vfh: where to store the returned VFH

 *      @sleep_ok: if true we may sleep while awaiting command completion

 *

 *	Reads the VF RSS Configuration Table at the specified index and returns

 *	the (VFL, VFH) values found there.

	/* Request that the index'th VF Table values be read into VFL/VFH.

	/* Grab the VFL/VFH values ...

/**

 *	t4_read_rss_pf_map - read PF RSS Map

 *	@adapter: the adapter

 *      @sleep_ok: if true we may sleep while awaiting command completion

 *

 *	Reads the PF RSS Map register and returns its value.

/**

 *	t4_read_rss_pf_mask - read PF RSS Mask

 *	@adapter: the adapter

 *      @sleep_ok: if true we may sleep while awaiting command completion

 *

 *	Reads the PF RSS Mask register and returns its value.

/**

 *	t4_tp_get_tcp_stats - read TP's TCP MIB counters

 *	@adap: the adapter

 *	@v4: holds the TCP/IP counter values

 *	@v6: holds the TCP/IPv6 counter values

 *      @sleep_ok: if true we may sleep while awaiting command completion

 *

 *	Returns the values of TP's TCP/IP and TCP/IPv6 MIB counters.

 *	Either @v4 or @v6 may be %NULL to skip the corresponding stats.

/**

 *	t4_tp_get_err_stats - read TP's error MIB counters

 *	@adap: the adapter

 *	@st: holds the counter values

 *      @sleep_ok: if true we may sleep while awaiting command completion

 *

 *	Returns the values of TP's error counters.

/**

 *	t4_tp_get_cpl_stats - read TP's CPL MIB counters

 *	@adap: the adapter

 *	@st: holds the counter values

 *      @sleep_ok: if true we may sleep while awaiting command completion

 *

 *	Returns the values of TP's CPL counters.

/**

 *	t4_tp_get_rdma_stats - read TP's RDMA MIB counters

 *	@adap: the adapter

 *	@st: holds the counter values

 *      @sleep_ok: if true we may sleep while awaiting command completion

 *

 *	Returns the values of TP's RDMA counters.

/**

 *	t4_get_fcoe_stats - read TP's FCoE MIB counters for a port

 *	@adap: the adapter

 *	@idx: the port index

 *	@st: holds the counter values

 *      @sleep_ok: if true we may sleep while awaiting command completion

 *

 *	Returns the values of TP's FCoE counters for the selected port.

/**

 *	t4_get_usm_stats - read TP's non-TCP DDP MIB counters

 *	@adap: the adapter

 *	@st: holds the counter values

 *      @sleep_ok: if true we may sleep while awaiting command completion

 *

 *	Returns the values of TP's counters for non-TCP directly-placed packets.

/**

 *	t4_read_mtu_tbl - returns the values in the HW path MTU table

 *	@adap: the adapter

 *	@mtus: where to store the MTU values

 *	@mtu_log: where to store the MTU base-2 log (may be %NULL)

 *

 *	Reads the HW path MTU table.

/**

 *	t4_read_cong_tbl - reads the congestion control table

 *	@adap: the adapter

 *	@incr: where to store the alpha values

 *

 *	Reads the additive increments programmed into the HW congestion

 *	control table.

/**

 *	t4_tp_wr_bits_indirect - set/clear bits in an indirect TP register

 *	@adap: the adapter

 *	@addr: the indirect TP register address

 *	@mask: specifies the field within the register to modify

 *	@val: new value for the field

 *

 *	Sets a field of an indirect TP register to the given value.

/**

 *	init_cong_ctrl - initialize congestion control parameters

 *	@a: the alpha values for congestion control

 *	@b: the beta values for congestion control

 *

 *	Initialize the congestion control parameters.

 The minimum additive increment value for the congestion control table */

/**

 *	t4_load_mtus - write the MTU and congestion control HW tables

 *	@adap: the adapter

 *	@mtus: the values for the MTU table

 *	@alpha: the values for the congestion control alpha parameter

 *	@beta: the values for the congestion control beta parameter

 *

 *	Write the HW MTU table with the supplied MTUs and the high-speed

 *	congestion control table with the supplied alpha, beta, and MTUs.

 *	We write the two tables together because the additive increments

 *	depend on the MTUs.

 round */

/* Calculates a rate in bytes/s given the number of 256-byte units per 4K core

 * clocks.  The formula is

 *

 * bytes/s = bytes256 * 256 * ClkFreq / 4096

 *

 * which is equivalent to

 *

 * bytes/s = 62.5 * bytes256 * ClkFreq_ms

/**

 *	t4_get_chan_txrate - get the current per channel Tx rates

 *	@adap: the adapter

 *	@nic_rate: rates for NIC traffic

 *	@ofld_rate: rates for offloaded traffic

 *

 *	Return the current Tx rates in bytes/s for NIC and offloaded traffic

 *	for each channel.

/**

 *	t4_set_trace_filter - configure one of the tracing filters

 *	@adap: the adapter

 *	@tp: the desired trace filter parameters

 *	@idx: which filter to configure

 *	@enable: whether to enable or disable the filter

 *

 *	Configures one of the tracing filters available in HW.  If @enable is

 *	%0 @tp is not examined and may be %NULL. The user is responsible to

 *	set the single/multiple trace mode by writing to MPS_TRC_CFG_A register

		/* If multiple tracers are enabled, then maximum

		 * capture size is 2.5KB (FIFO size of a single channel)

		 * minus 2 flits for CPL_TRACE_PKT header.

		/* If multiple tracers are disabled, to avoid deadlocks

		 * maximum packet capture size of 9600 bytes is recommended.

		 * Also in this mode, only trace0 can be enabled and running.

 stop the tracer we'll be changing */

/**

 *	t4_get_trace_filter - query one of the tracing filters

 *	@adap: the adapter

 *	@tp: the current trace filter parameters

 *	@idx: which trace filter to query

 *	@enabled: non-zero if the filter is enabled

 *

 *	Returns the current settings of one of the HW tracing filters.

/**

 *	t4_pmtx_get_stats - returns the HW stats from PMTX

 *	@adap: the adapter

 *	@cnt: where to store the count statistics

 *	@cycles: where to store the cycle statistics

 *

 *	Returns performance statistics from PMTX.

/**

 *	t4_pmrx_get_stats - returns the HW stats from PMRX

 *	@adap: the adapter

 *	@cnt: where to store the count statistics

 *	@cycles: where to store the cycle statistics

 *

 *	Returns performance statistics from PMRX.

/**

 *	compute_mps_bg_map - compute the MPS Buffer Group Map for a Port

 *	@adapter: the adapter

 *	@pidx: the port index

 *

 *	Computes and returns a bitmap indicating which MPS buffer groups are

 *	associated with the given Port.  Bit i is set if buffer group i is

 *	used by the Port.

/**

 *	t4_get_mps_bg_map - return the buffer groups associated with a port

 *	@adapter: the adapter

 *	@pidx: the port index

 *

 *	Returns a bitmap indicating which MPS buffer groups are associated

 *	with the given Port.  Bit i is set if buffer group i is used by the

 *	Port.

	/* If we've already retrieved/computed this, just return the result.

	/* Newer Firmware can tell us what the MPS Buffer Group Map is.

	 * If we're talking to such Firmware, let it tell us.  If the new

	 * API isn't supported, revert back to old hardcoded way.  The value

	 * obtained from Firmware is encoded in below format:

	 *

	 * val = (( MPSBGMAP[Port 3] << 24 ) |

	 *        ( MPSBGMAP[Port 2] << 16 ) |

	 *        ( MPSBGMAP[Port 1] <<  8 ) |

	 *        ( MPSBGMAP[Port 0] <<  0 ))

			/* Store the BG Map for all of the Ports in order to

			 * avoid more calls to the Firmware in the future.

	/* Either we're not talking to the Firmware or we're dealing with

	 * older Firmware which doesn't support the new API to get the MPS

	 * Buffer Group Map.  Fall back to computing it ourselves.

/**

 *      t4_get_tp_e2c_map - return the E2C channel map associated with a port

 *      @adapter: the adapter

 *      @pidx: the port index

	/* FW version >= 1.16.44.0 can determine E2C channel map using

	 * FW_PARAMS_PARAM_DEV_TPCHMAP API.

/**

 *	t4_get_tp_ch_map - return TP ingress channels associated with a port

 *	@adap: the adapter

 *	@pidx: the port index

 *

 *	Returns a bitmap indicating which TP Ingress Channels are associated

 *	with a given Port.  Bit i is set if TP Ingress Channel i is used by

 *	the Port.

		/* Note that this happens to be the same values as the MPS

		 * Buffer Group Map for these Chips.  But we replicate the code

		 * here because they're really separate concepts.

/**

 *      t4_get_port_type_description - return Port Type string description

 *      @port_type: firmware Port Type enumeration

/**

 *      t4_get_port_stats_offset - collect port stats relative to a previous

 *                                 snapshot

 *      @adap: The adapter

 *      @idx: The port

 *      @stats: Current stats to fill

 *      @offset: Previous stats snapshot

/**

 *	t4_get_port_stats - collect port statistics

 *	@adap: the adapter

 *	@idx: the port index

 *	@p: the stats structure to fill

 *

 *	Collect statistics related to the given port from HW.

/**

 *	t4_get_lb_stats - collect loopback port statistics

 *	@adap: the adapter

 *	@idx: the loopback port index

 *	@p: the stats structure to fill

 *

 *	Return HW statistics for the given loopback port.

/*     t4_mk_filtdelwr - create a delete filter WR

 *     @ftid: the filter ID

 *     @wr: the filter work request to populate

 *     @qid: ingress queue to receive the delete notification

 *

 *     Creates a filter work request to delete the supplied filter.  If @qid is

 *     negative the delete notification is suppressed.

/**

 *	t4_mdio_rd - read a PHY register through MDIO

 *	@adap: the adapter

 *	@mbox: mailbox to use for the FW command

 *	@phy_addr: the PHY address

 *	@mmd: the PHY MMD to access (0 for clause 22 PHYs)

 *	@reg: the register to read

 *	@valp: where to store the value

 *

 *	Issues a FW command through the given mailbox to read a PHY register.

/**

 *	t4_mdio_wr - write a PHY register through MDIO

 *	@adap: the adapter

 *	@mbox: mailbox to use for the FW command

 *	@phy_addr: the PHY address

 *	@mmd: the PHY MMD to access (0 for clause 22 PHYs)

 *	@reg: the register to write

 *	@val: value to write

 *

 *	Issues a FW command through the given mailbox to write a PHY register.

/**

 *	t4_sge_decode_idma_state - decode the idma state

 *	@adapter: the adapter

 *	@state: the state idma is stuck in

	/* Select the right set of decode strings to dump depending on the

	 * adapter chip type.

/**

 *      t4_sge_ctxt_flush - flush the SGE context cache

 *      @adap: the adapter

 *      @mbox: mailbox to use for the FW command

 *      @ctxt_type: Egress or Ingress

 *

 *      Issues a FW command through the given mailbox to flush the

 *      SGE context cache.

/**

 *	t4_read_sge_dbqtimers - read SGE Doorbell Queue Timer values

 *	@adap: the adapter

 *	@ndbqtimers: size of the provided SGE Doorbell Queue Timer table

 *	@dbqtimers: SGE Doorbell Queue Timer table

 *

 *	Reads the SGE Doorbell Queue Timer values into the provided table.

 *	Returns 0 on success (Firmware and Hardware support this feature),

 *	an error on failure.

/**

 *      t4_fw_hello - establish communication with FW

 *      @adap: the adapter

 *      @mbox: mailbox to use for the FW command

 *      @evt_mbox: mailbox to receive async FW events

 *      @master: specifies the caller's willingness to be the device master

 *	@state: returns the current device state (if non-NULL)

 *

 *	Issues a command to establish communication with FW.  Returns either

 *	an error (negative integer) or the mailbox of the Master PF.

	/*

	 * Issue the HELLO command to the firmware.  If it's not successful

	 * but indicates that we got a "busy" or "timeout" condition, retry

	 * the HELLO until we exhaust our retry limit.  If we do exceed our

	 * retry limit, check to see if the firmware left us any error

	 * information and report that if so.

	/*

	 * If we're not the Master PF then we need to wait around for the

	 * Master PF Driver to finish setting up the adapter.

	 *

	 * Note that we also do this wait if we're a non-Master-capable PF and

	 * there is no current Master PF; a Master PF may show up momentarily

	 * and we wouldn't want to fail pointlessly.  (This can happen when an

	 * OS loads lots of different drivers rapidly at the same time).  In

	 * this case, the Master PF returned by the firmware will be

	 * PCIE_FW_MASTER_M so the test below will work ...

		/*

		 * Wait for the firmware to either indicate an error or

		 * initialized state.  If we see either of these we bail out

		 * and report the issue to the caller.  If we exhaust the

		 * "hello timeout" and we haven't exhausted our retries, try

		 * again.  Otherwise bail with a timeout error.

			/*

			 * If neither Error nor Initialized are indicated

			 * by the firmware keep waiting till we exhaust our

			 * timeout ... and then retry if we haven't exhausted

			 * our retries ...

			/*

			 * We either have an Error or Initialized condition

			 * report errors preferentially.

			/*

			 * If we arrived before a Master PF was selected and

			 * there's not a valid Master PF, grab its identity

			 * for our caller.

/**

 *	t4_fw_bye - end communication with FW

 *	@adap: the adapter

 *	@mbox: mailbox to use for the FW command

 *

 *	Issues a command to terminate communication with FW.

/**

 *	t4_early_init - ask FW to initialize the device

 *	@adap: the adapter

 *	@mbox: mailbox to use for the FW command

 *

 *	Issues a command to FW to partially initialize the device.  This

 *	performs initialization that generally doesn't depend on user input.

/**

 *	t4_fw_reset - issue a reset to FW

 *	@adap: the adapter

 *	@mbox: mailbox to use for the FW command

 *	@reset: specifies the type of reset to perform

 *

 *	Issues a reset command of the specified type to FW.

/**

 *	t4_fw_halt - issue a reset/halt to FW and put uP into RESET

 *	@adap: the adapter

 *	@mbox: mailbox to use for the FW RESET command (if desired)

 *	@force: force uP into RESET even if FW RESET command fails

 *

 *	Issues a RESET command to firmware (if desired) with a HALT indication

 *	and then puts the microprocessor into RESET state.  The RESET command

 *	will only be issued if a legitimate mailbox is provided (mbox <=

 *	PCIE_FW_MASTER_M).

 *

 *	This is generally used in order for the host to safely manipulate the

 *	adapter without fear of conflicting with whatever the firmware might

 *	be doing.  The only way out of this state is to RESTART the firmware

 *	...

	/*

	 * If a legitimate mailbox is provided, issue a RESET command

	 * with a HALT indication.

	/*

	 * Normally we won't complete the operation if the firmware RESET

	 * command fails but if our caller insists we'll go ahead and put the

	 * uP into RESET.  This can be useful if the firmware is hung or even

	 * missing ...  We'll have to take the risk of putting the uP into

	 * RESET without the cooperation of firmware in that case.

	 *

	 * We also force the firmware's HALT flag to be on in case we bypassed

	 * the firmware RESET command above or we're dealing with old firmware

	 * which doesn't have the HALT capability.  This will serve as a flag

	 * for the incoming firmware to know that it's coming out of a HALT

	 * rather than a RESET ... if it's new enough to understand that ...

	/*

	 * And we always return the result of the firmware RESET command

	 * even when we force the uP into RESET ...

/**

 *	t4_fw_restart - restart the firmware by taking the uP out of RESET

 *	@adap: the adapter

 *	@mbox: mailbox to use for the FW command

 *	@reset: if we want to do a RESET to restart things

 *

 *	Restart firmware previously halted by t4_fw_halt().  On successful

 *	return the previous PF Master remains as the new PF Master and there

 *	is no need to issue a new HELLO command, etc.

 *

 *	We do this in two ways:

 *

 *	 1. If we're dealing with newer firmware we'll simply want to take

 *	    the chip's microprocessor out of RESET.  This will cause the

 *	    firmware to start up from its start vector.  And then we'll loop

 *	    until the firmware indicates it's started again (PCIE_FW.HALT

 *	    reset to 0) or we timeout.

 *

 *	 2. If we're dealing with older firmware then we'll need to RESET

 *	    the chip since older firmware won't recognize the PCIE_FW.HALT

 *	    flag and automatically RESET itself on startup.

		/*

		 * Since we're directing the RESET instead of the firmware

		 * doing it automatically, we need to clear the PCIE_FW.HALT

		 * bit.

		/*

		 * If we've been given a valid mailbox, first try to get the

		 * firmware to do the RESET.  If that works, great and we can

		 * return success.  Otherwise, if we haven't been given a

		 * valid mailbox or the RESET command failed, fall back to

		 * hitting the chip with a hammer.

/**

 *	t4_fw_upgrade - perform all of the steps necessary to upgrade FW

 *	@adap: the adapter

 *	@mbox: mailbox to use for the FW RESET command (if desired)

 *	@fw_data: the firmware image to write

 *	@size: image size

 *	@force: force upgrade even if firmware doesn't cooperate

 *

 *	Perform all of the steps necessary for upgrading an adapter's

 *	firmware image.  Normally this requires the cooperation of the

 *	existing firmware in order to halt all existing activities

 *	but if an invalid mailbox token is passed in we skip that step

 *	(though we'll still put the adapter microprocessor into RESET in

 *	that case).

 *

 *	On successful return the new firmware will have been loaded and

 *	the adapter will have been fully RESET losing all previous setup

 *	state.  On unsuccessful return the adapter may be completely hosed ...

 *	positive errno indicates that the adapter is ~probably~ intact, a

 *	negative errno indicates that things are looking bad ...

	/* Disable CXGB4_FW_OK flag so that mbox commands with CXGB4_FW_OK flag

	 * set wont be sent when we are flashing FW.

	/*

	 * If there was a Firmware Configuration File stored in FLASH,

	 * there's a good chance that it won't be compatible with the new

	 * Firmware.  In order to prevent difficult to diagnose adapter

	 * initialization issues, we clear out the Firmware Configuration File

	 * portion of the FLASH .  The user will need to re-FLASH a new

	 * Firmware Configuration File which is compatible with the new

	 * Firmware if that's desired.

	/*

	 * Older versions of the firmware don't understand the new

	 * PCIE_FW.HALT flag and so won't know to perform a RESET when they

	 * restart.  So for newly loaded older firmware we'll have to do the

	 * RESET for it so it starts up on a clean slate.  We can tell if

	 * the newly loaded firmware will handle this right by checking

	 * its header flags to see if it advertises the capability.

	/* Grab potentially new Firmware Device Log parameters so we can see

	 * how healthy the new Firmware is.  It's okay to contact the new

	 * Firmware for these parameters even though, as far as it's

	 * concerned, we've never said "HELLO" to it ...

/**

 *	t4_fl_pkt_align - return the fl packet alignment

 *	@adap: the adapter

 *

 *	T4 has a single field to specify the packing and padding boundary.

 *	T5 onwards has separate fields for this and hence the alignment for

 *	next packet offset is maximum of these two.

 *

	/* T4 uses a single control field to specify both the PCIe Padding and

	 * Packing Boundary.  T5 introduced the ability to specify these

	 * separately.  The actual Ingress Packet Data alignment boundary

	 * within Packed Buffer Mode is the maximum of these two

	 * specifications.  (Note that it makes no real practical sense to

	 * have the Padding Boundary be larger than the Packing Boundary but you

	 * could set the chip up that way and, in fact, legacy T4 code would

	 * end doing this because it would initialize the Padding Boundary and

	 * leave the Packing Boundary initialized to 0 (16 bytes).)

	 * Padding Boundary values in T6 starts from 8B,

	 * where as it is 32B for T4 and T5.

		/* T5 has a weird interpretation of one of the PCIe Packing

		 * Boundary values.  No idea why ...

/**

 *	t4_fixup_host_params - fix up host-dependent parameters

 *	@adap: the adapter

 *	@page_size: the host's Base Page Size

 *	@cache_line_size: the host's Cache Line Size

 *

 *	Various registers in T4 contain values which are dependent on the

 *	host's Base Page and Cache Line Sizes.  This function will fix all of

 *	those registers with the appropriate values as passed in ...

		/* T5 introduced the separation of the Free List Padding and

		 * Packing Boundaries.  Thus, we can select a smaller Padding

		 * Boundary to avoid uselessly chewing up PCIe Link and Memory

		 * Bandwidth, and use a Packing Boundary which is large enough

		 * to avoid false sharing between CPUs, etc.

		 *

		 * For the PCI Link, the smaller the Padding Boundary the

		 * better.  For the Memory Controller, a smaller Padding

		 * Boundary is better until we cross under the Memory Line

		 * Size (the minimum unit of transfer to/from Memory).  If we

		 * have a Padding Boundary which is smaller than the Memory

		 * Line Size, that'll involve a Read-Modify-Write cycle on the

		 * Memory Controller which is never good.

		/* We want the Packing Boundary to be based on the Cache Line

		 * Size in order to help avoid False Sharing performance

		 * issues between CPUs, etc.  We also want the Packing

		 * Boundary to incorporate the PCI-E Maximum Payload Size.  We

		 * get best performance when the Packing Boundary is a

		 * multiple of the Maximum Payload Size.

			/* The PCIe Device Control Maximum Payload Size field

			 * [bits 7:5] encodes sizes as powers of 2 starting at

			 * 128 bytes.

		/* N.B. T5/T6 have a crazy special interpretation of the "0"

		 * value for the Packing Boundary.  This corresponds to 16

		 * bytes instead of the expected 32 bytes.  So if we want 32

		 * bytes, the best we can really do is 64 bytes ...

		/* Use the smallest Ingress Padding which isn't smaller than

		 * the Memory Controller Read/Write Size.  We'll take that as

		 * being 8 bytes since we don't know of any system with a

		 * wider Memory Controller Bus Width.

	/*

	 * Adjust various SGE Free List Host Buffer Sizes.

	 *

	 * This is something of a crock since we're using fixed indices into

	 * the array which are also known by the sge.c code and the T4

	 * Firmware Configuration File.  We need to come up with a much better

	 * approach to managing this array.  For now, the first four entries

	 * are:

	 *

	 *   0: Host Page Size

	 *   1: 64KB

	 *   2: Buffer size corresponding to 1500 byte MTU (unpacked mode)

	 *   3: Buffer size corresponding to 9000 byte MTU (unpacked mode)

	 *

	 * For the single-MTU buffers in unpacked mode we need to include

	 * space for the SGE Control Packet Shift, 14 byte Ethernet header,

	 * possible 4 byte VLAN tag, all rounded up to the next Ingress Packet

	 * Padding boundary.  All of these are accommodated in the Factory

	 * Default Firmware Configuration File but we need to adjust it for

	 * this host's cache line size.

/**

 *	t4_fw_initialize - ask FW to initialize the device

 *	@adap: the adapter

 *	@mbox: mailbox to use for the FW command

 *

 *	Issues a command to FW to partially initialize the device.  This

 *	performs initialization that generally doesn't depend on user input.

/**

 *	t4_query_params_rw - query FW or device parameters

 *	@adap: the adapter

 *	@mbox: mailbox to use for the FW command

 *	@pf: the PF

 *	@vf: the VF

 *	@nparams: the number of parameters

 *	@params: the parameter names

 *	@val: the parameter values

 *	@rw: Write and read flag

 *	@sleep_ok: if true, we may sleep awaiting mbox cmd completion

 *

 *	Reads the value of FW or device parameters.  Up to 7 parameters can be

 *	queried at once.

/**

 *      t4_set_params_timeout - sets FW or device parameters

 *      @adap: the adapter

 *      @mbox: mailbox to use for the FW command

 *      @pf: the PF

 *      @vf: the VF

 *      @nparams: the number of parameters

 *      @params: the parameter names

 *      @val: the parameter values

 *      @timeout: the timeout time

 *

 *      Sets the value of FW or device parameters.  Up to 7 parameters can be

 *      specified at once.

/**

 *	t4_set_params - sets FW or device parameters

 *	@adap: the adapter

 *	@mbox: mailbox to use for the FW command

 *	@pf: the PF

 *	@vf: the VF

 *	@nparams: the number of parameters

 *	@params: the parameter names

 *	@val: the parameter values

 *

 *	Sets the value of FW or device parameters.  Up to 7 parameters can be

 *	specified at once.

/**

 *	t4_cfg_pfvf - configure PF/VF resource limits

 *	@adap: the adapter

 *	@mbox: mailbox to use for the FW command

 *	@pf: the PF being configured

 *	@vf: the VF being configured

 *	@txq: the max number of egress queues

 *	@txq_eth_ctrl: the max number of egress Ethernet or control queues

 *	@rxqi: the max number of interrupt-capable ingress queues

 *	@rxq: the max number of interruptless ingress queues

 *	@tc: the PCI traffic class

 *	@vi: the max number of virtual interfaces

 *	@cmask: the channel access rights mask for the PF/VF

 *	@pmask: the port access rights mask for the PF/VF

 *	@nexact: the maximum number of exact MPS filters

 *	@rcaps: read capabilities

 *	@wxcaps: write/execute capabilities

 *

 *	Configures resource limits and capabilities for a physical or virtual

 *	function.

/**

 *	t4_alloc_vi - allocate a virtual interface

 *	@adap: the adapter

 *	@mbox: mailbox to use for the FW command

 *	@port: physical port associated with the VI

 *	@pf: the PF owning the VI

 *	@vf: the VF owning the VI

 *	@nmac: number of MAC addresses needed (1 to 5)

 *	@mac: the MAC addresses of the VI

 *	@rss_size: size of RSS table slice associated with this VI

 *	@vivld: the destination to store the VI Valid value.

 *	@vin: the destination to store the VIN value.

 *

 *	Allocates a virtual interface for the given physical port.  If @mac is

 *	not %NULL it contains the MAC addresses of the VI as assigned by FW.

 *	@mac should be large enough to hold @nmac Ethernet addresses, they are

 *	stored consecutively so the space needed is @nmac * 6 bytes.

 *	Returns a negative error number or the non-negative VI id.

/**

 *	t4_free_vi - free a virtual interface

 *	@adap: the adapter

 *	@mbox: mailbox to use for the FW command

 *	@pf: the PF owning the VI

 *	@vf: the VF owning the VI

 *	@viid: virtual interface identifiler

 *

 *	Free a previously allocated virtual interface.

/**

 *	t4_set_rxmode - set Rx properties of a virtual interface

 *	@adap: the adapter

 *	@mbox: mailbox to use for the FW command

 *	@viid: the VI id

 *	@viid_mirror: the mirror VI id

 *	@mtu: the new MTU or -1

 *	@promisc: 1 to enable promiscuous mode, 0 to disable it, -1 no change

 *	@all_multi: 1 to enable all-multi mode, 0 to disable it, -1 no change

 *	@bcast: 1 to enable broadcast Rx, 0 to disable it, -1 no change

 *	@vlanex: 1 to enable HW VLAN extraction, 0 to disable it, -1 no change

 *	@sleep_ok: if true we may sleep while awaiting command completion

 *

 *	Sets Rx properties of a virtual interface.

 convert to FW values */

/**

 *      t4_free_encap_mac_filt - frees MPS entry at given index

 *      @adap: the adapter

 *      @viid: the VI id

 *      @idx: index of MPS entry to be freed

 *      @sleep_ok: call is allowed to sleep

 *

 *      Frees the MPS entry at supplied index

 *

 *      Returns a negative error number or zero on success

/**

 *	t4_free_raw_mac_filt - Frees a raw mac entry in mps tcam

 *	@adap: the adapter

 *	@viid: the VI id

 *	@addr: the MAC address

 *	@mask: the mask

 *	@idx: index of the entry in mps tcam

 *	@lookup_type: MAC address for inner (1) or outer (0) header

 *	@port_id: the port index

 *	@sleep_ok: call is allowed to sleep

 *

 *	Removes the mac entry at the specified index using raw mac interface.

 *

 *	Returns a negative error number on failure.

 Lookup Type. Outer header: 0, Inner header: 1 */

 Lookup mask and port mask */

 Copy the address and the mask */

/**

 *      t4_alloc_encap_mac_filt - Adds a mac entry in mps tcam with VNI support

 *      @adap: the adapter

 *      @viid: the VI id

 *      @addr: the MAC address

 *      @mask: the mask

 *      @vni: the VNI id for the tunnel protocol

 *      @vni_mask: mask for the VNI id

 *      @dip_hit: to enable DIP match for the MPS entry

 *      @lookup_type: MAC address for inner (1) or outer (0) header

 *      @sleep_ok: call is allowed to sleep

 *

 *      Allocates an MPS entry with specified MAC address and VNI value.

 *

 *      Returns a negative error number or the allocated index for this mac.

/**

 *	t4_alloc_raw_mac_filt - Adds a mac entry in mps tcam

 *	@adap: the adapter

 *	@viid: the VI id

 *	@addr: the MAC address

 *	@mask: the mask

 *	@idx: index at which to add this entry

 *	@lookup_type: MAC address for inner (1) or outer (0) header

 *	@port_id: the port index

 *	@sleep_ok: call is allowed to sleep

 *

 *	Adds the mac entry at the specified index using raw mac interface.

 *

 *	Returns a negative error number or the allocated index for this mac.

 Specify that this is an inner mac address */

 Lookup Type. Outer header: 0, Inner header: 1 */

 Lookup mask and port mask */

 Copy the address and the mask */

/**

 *	t4_alloc_mac_filt - allocates exact-match filters for MAC addresses

 *	@adap: the adapter

 *	@mbox: mailbox to use for the FW command

 *	@viid: the VI id

 *	@free: if true any existing filters for this VI id are first removed

 *	@naddr: the number of MAC addresses to allocate filters for (up to 7)

 *	@addr: the MAC address(es)

 *	@idx: where to store the index of each allocated filter

 *	@hash: pointer to hash address filter bitmap

 *	@sleep_ok: call is allowed to sleep

 *

 *	Allocates an exact-match filter for each of the supplied addresses and

 *	sets it to the corresponding address.  If @idx is not %NULL it should

 *	have at least @naddr entries, each of which will be set to the index of

 *	the filter allocated for the corresponding MAC address.  If a filter

 *	could not be allocated for an address its index is set to 0xffff.

 *	If @hash is not %NULL addresses that fail to allocate an exact filter

 *	are hashed and update the hash filter bitmap pointed at by @hash.

 *

 *	Returns a negative error number or the number of filters allocated.

*/) {

		/* It's okay if we run out of space in our MAC address arena.

		 * Some of the addresses we submit may get stored so we need

		 * to run through the reply to see what the results were ...

/**

 *	t4_free_mac_filt - frees exact-match filters of given MAC addresses

 *	@adap: the adapter

 *	@mbox: mailbox to use for the FW command

 *	@viid: the VI id

 *	@naddr: the number of MAC addresses to allocate filters for (up to 7)

 *	@addr: the MAC address(es)

 *	@sleep_ok: call is allowed to sleep

 *

 *	Frees the exact-match filter for each of the supplied addresses

 *

 *	Returns a negative error number or the number of filters freed.

*/) {

/**

 *	t4_change_mac - modifies the exact-match filter for a MAC address

 *	@adap: the adapter

 *	@mbox: mailbox to use for the FW command

 *	@viid: the VI id

 *	@idx: index of existing filter for old value of MAC address, or -1

 *	@addr: the new MAC address value

 *	@persist: whether a new MAC allocation should be persistent

 *	@smt_idx: the destination to store the new SMT index.

 *

 *	Modifies an exact-match filter and sets it to the new MAC address.

 *	Note that in general it is not possible to modify the value of a given

 *	filter so the generic way to modify an address filter is to free the one

 *	being used by the old address value and allocate a new filter for the

 *	new address value.  @idx can be -1 if the address is a new addition.

 *

 *	Returns a negative error number or the index of the filter with the new

 *	MAC value.

 new allocation */

				/* In T4/T5, SMT contains 256 SMAC entries

				 * organized in 128 rows of 2 entries each.

				 * In T6, SMT contains 256 SMAC entries in

				 * 256 rows.

/**

 *	t4_set_addr_hash - program the MAC inexact-match hash filter

 *	@adap: the adapter

 *	@mbox: mailbox to use for the FW command

 *	@viid: the VI id

 *	@ucast: whether the hash filter should also match unicast addresses

 *	@vec: the value to be written to the hash filter

 *	@sleep_ok: call is allowed to sleep

 *

 *	Sets the 64-bit inexact-match hash filter for a virtual interface.

/**

 *      t4_enable_vi_params - enable/disable a virtual interface

 *      @adap: the adapter

 *      @mbox: mailbox to use for the FW command

 *      @viid: the VI id

 *      @rx_en: 1=enable Rx, 0=disable Rx

 *      @tx_en: 1=enable Tx, 0=disable Tx

 *      @dcb_en: 1=enable delivery of Data Center Bridging messages.

 *

 *      Enables/disables a virtual interface.  Note that setting DCB Enable

 *      only makes sense when enabling a Virtual Interface ...

/**

 *	t4_enable_vi - enable/disable a virtual interface

 *	@adap: the adapter

 *	@mbox: mailbox to use for the FW command

 *	@viid: the VI id

 *	@rx_en: 1=enable Rx, 0=disable Rx

 *	@tx_en: 1=enable Tx, 0=disable Tx

 *

 *	Enables/disables a virtual interface.

/**

 *	t4_enable_pi_params - enable/disable a Port's Virtual Interface

 *      @adap: the adapter

 *      @mbox: mailbox to use for the FW command

 *      @pi: the Port Information structure

 *      @rx_en: 1=enable Rx, 0=disable Rx

 *      @tx_en: 1=enable Tx, 0=disable Tx

 *      @dcb_en: 1=enable delivery of Data Center Bridging messages.

 *

 *      Enables/disables a Port's Virtual Interface.  Note that setting DCB

 *	Enable only makes sense when enabling a Virtual Interface ...

 *	If the Virtual Interface enable/disable operation is successful,

 *	we notify the OS-specific code of a potential Link Status change

 *	via the OS Contract API t4_os_link_changed().

/**

 *	t4_identify_port - identify a VI's port by blinking its LED

 *	@adap: the adapter

 *	@mbox: mailbox to use for the FW command

 *	@viid: the VI id

 *	@nblinks: how many times to blink LED at 2.5 Hz

 *

 *	Identifies a VI's port by blinking its LED.

/**

 *	t4_iq_stop - stop an ingress queue and its FLs

 *	@adap: the adapter

 *	@mbox: mailbox to use for the FW command

 *	@pf: the PF owning the queues

 *	@vf: the VF owning the queues

 *	@iqtype: the ingress queue type (FW_IQ_TYPE_FL_INT_CAP, etc.)

 *	@iqid: ingress queue id

 *	@fl0id: FL0 queue id or 0xffff if no attached FL0

 *	@fl1id: FL1 queue id or 0xffff if no attached FL1

 *

 *	Stops an ingress queue and its associated FLs, if any.  This causes

 *	any current or future data/messages destined for these queues to be

 *	tossed.

/**

 *	t4_iq_free - free an ingress queue and its FLs

 *	@adap: the adapter

 *	@mbox: mailbox to use for the FW command

 *	@pf: the PF owning the queues

 *	@vf: the VF owning the queues

 *	@iqtype: the ingress queue type

 *	@iqid: ingress queue id

 *	@fl0id: FL0 queue id or 0xffff if no attached FL0

 *	@fl1id: FL1 queue id or 0xffff if no attached FL1

 *

 *	Frees an ingress queue and its associated FLs, if any.

/**

 *	t4_eth_eq_free - free an Ethernet egress queue

 *	@adap: the adapter

 *	@mbox: mailbox to use for the FW command

 *	@pf: the PF owning the queue

 *	@vf: the VF owning the queue

 *	@eqid: egress queue id

 *

 *	Frees an Ethernet egress queue.

/**

 *	t4_ctrl_eq_free - free a control egress queue

 *	@adap: the adapter

 *	@mbox: mailbox to use for the FW command

 *	@pf: the PF owning the queue

 *	@vf: the VF owning the queue

 *	@eqid: egress queue id

 *

 *	Frees a control egress queue.

/**

 *	t4_ofld_eq_free - free an offload egress queue

 *	@adap: the adapter

 *	@mbox: mailbox to use for the FW command

 *	@pf: the PF owning the queue

 *	@vf: the VF owning the queue

 *	@eqid: egress queue id

 *

 *	Frees a control egress queue.

/**

 *	t4_link_down_rc_str - return a string for a Link Down Reason Code

 *	@link_down_rc: Link Down Reason Code

 *

 *	Returns a string representation of the Link Down Reason Code.

 Return the highest speed set in the port capabilities, in Mb/s. */

/**

 *	fwcap_to_fwspeed - return highest speed in Port Capabilities

 *	@acaps: advertised Port Capabilities

 *

 *	Get the highest speed for the port from the advertised Port

 *	Capabilities.  It will be either the highest speed from the list of

 *	speeds or whatever user has set using ethtool.

/**

 *	lstatus_to_fwcap - translate old lstatus to 32-bit Port Capabilities

 *	@lstatus: old FW_PORT_ACTION_GET_PORT_INFO lstatus value

 *

 *	Translates old FW_PORT_ACTION_GET_PORT_INFO lstatus field into new

 *	32-bit Port Capabilities value.

	/* Unfortunately the format of the Link Status in the old

	 * 16-bit Port Information message isn't the same as the

	 * 16-bit Port Capabilities bitfield used everywhere else ...

/**

 *	t4_handle_get_port_info - process a FW reply message

 *	@pi: the port info

 *	@rpl: start of the FW message

 *

 *	Processes a GET_PORT_INFO FW reply message.

	/* Extract the various fields from the Port Information message.

	/* Reset state for communicating new Transceiver Module status and

	 * whether the OS-dependent layer wants us to redo the current

	 * "sticky" L1 Configure Link Parameters.

		/* With the newer SFP28 and QSFP28 Transceiver Module Types,

		 * various fundamental Port Capabilities which used to be

		 * immutable can now change radically.  We can now have

		 * Speeds, Auto-Negotiation, Forward Error Correction, etc.

		 * all change based on what Transceiver Module is inserted.

		 * So we need to record the Physical "Port" Capabilities on

		 * every Transceiver Module change.

		/* When a new Transceiver Module is inserted, the Firmware

		 * will examine its i2c EPROM to determine its type and

		 * general operating parameters including things like Forward

		 * Error Control, etc.  Various IEEE 802.3 standards dictate

		 * how to interpret these i2c values to determine default

		 * "sutomatic" settings.  We record these for future use when

		 * the user explicitly requests these standards-based values.

		/* Some versions of the early T6 Firmware "cheated" when

		 * handling different Transceiver Modules by changing the

		 * underlaying Port Type reported to the Host Drivers.  As

		 * such we need to capture whatever Port Type the Firmware

		 * sends us and record it in case it's different from what we

		 * were told earlier.  Unfortunately, since Firmware is

		 * forever, we'll need to keep this code here forever, but in

		 * later T6 Firmware it should just be an assignment of the

		 * same value already recorded.

		/* Record new Module Type information.

		/* Let the OS-dependent layer know if we have a new

		 * Transceiver Module inserted.

 something changed */

		/* If we're not physically capable of Auto-Negotiation, note

		 * this as Auto-Negotiation disabled.  Otherwise, we track

		 * what Auto-Negotiation settings we have.  Note parallel

		 * structure in t4_link_l1cfg_core() and init_link_config().

			/* When Autoneg is disabled, user needs to set

			 * single speed.

			 * Similar to cxgb4_ethtool.c: set_link_ksettings

	/* If we have a new Transceiver Module and the OS-dependent code has

	 * told us that it wants us to redo whatever "sticky" L1 Configuration

	 * Link Parameters are set, do that now.

		/* Save the current L1 Configuration and restore it if an

		 * error occurs.  We probably should fix the l1_cfg*()

		 * routines not to change the link_config when an error

		 * occurs ...

/**

 *	t4_update_port_info - retrieve and update port information if changed

 *	@pi: the port_info

 *

 *	We issue a Get Port Information Command to the Firmware and, if

 *	successful, we check to see if anything is different from what we

 *	last recorded and update things accordingly.

/**

 *	t4_get_link_params - retrieve basic link parameters for given port

 *	@pi: the port

 *	@link_okp: value return pointer for link up/down

 *	@speedp: value return pointer for speed (Mb/s)

 *	@mtup: value return pointer for mtu

 *

 *	Retrieves basic link parameters for a port: link up/down, speed (Mb/s),

 *	and MTU for a specified port.  A negative error is returned on

 *	failure; 0 on success.

/**

 *      t4_handle_fw_rpl - process a FW reply message

 *      @adap: the adapter

 *      @rpl: start of the FW message

 *

 *      Processes a FW message, such as link state change messages.

	/* This might be a port command ... this simplifies the following

	 * conditionals ...  We can get away with pre-dereferencing

	 * action_to_len16 because it's in the first 16 bytes and all messages

	 * will be at least that long.

/**

 *	init_link_config - initialize a link's SW state

 *	@lc: pointer to structure holding the link state

 *	@pcaps: link Port Capabilities

 *	@acaps: link current Advertised Port Capabilities

 *

 *	Initializes the SW state maintained for each link, including the link's

 *	capabilities and default speed/flow-control/autonegotiation settings.

	/* For Forward Error Control, we default to whatever the Firmware

	 * tells us the Link is currently advertising.

	/* If the Port is capable of Auto-Negtotiation, initialize it as

	 * "enabled" and copy over all of the Physical Port Capabilities

	 * to the Advertised Port Capabilities.  Otherwise mark it as

	 * Auto-Negotiate disabled and select the highest supported speed

	 * for the link.  Note parallel structure in t4_link_l1cfg_core()

	 * and t4_handle_get_port_info().

	/* Table for non-Numonix supported flash parts.  Numonix parts are left

	 * to the preexisting code.  All flash parts have 64KB sectors.

 Spansion 4MB S25FL032P */

	/* Issue a Read ID Command to the Flash part.  We decode supported

	 * Flash parts and their sizes from this.  There's a newer Query

	 * Command which can retrieve detailed geometry information but many

	 * Flash parts don't support it.

 unlock SF */

	/* Check to see if it's one of our non-standard supported Flash parts.

	/* Decode Flash part size.  The code below looks repetitive with

	 * common encodings, but that's not guaranteed in the JEDEC

	 * specification for the Read JEDEC ID command.  The only thing that

	 * we're guaranteed by the JEDEC specification is where the

	 * Manufacturer ID is in the returned result.  After that each

	 * Manufacturer ~could~ encode things completely differently.

	 * Note, all Flash parts must have 64KB sectors.

 Micron/Numonix */

		/* This Density -> Size decoding table is taken from Micron

		 * Data Sheets.

 1MB */

 2MB */

 4MB */

 8MB */

 16MB */

 32MB */

 64MB */

 128MB */

 256MB */

 ISSI -- Integrated Silicon Solution, Inc. */

		/* This Density -> Size decoding table is taken from ISSI

		 * Data Sheets.

 32 MB */

 64MB */

 Macronix */

		/* This Density -> Size decoding table is taken from Macronix

		 * Data Sheets.

 8MB */

 16MB */

 Winbond */

		/* This Density -> Size decoding table is taken from Winbond

		 * Data Sheets.

 8MB */

 16MB */

	/* If we didn't recognize the FLASH part, that's no real issue: the

	 * Hardware/Software contract says that Hardware will _*ALWAYS*_

	 * use a FLASH part which is at least 4MB in size and has 64KB

	 * sectors.  The unrecognized FLASH part is likely to be much larger

	 * than 4MB, but that's all we really need.

 Store decoded Flash size and fall through into vetting code. */

/**

 *	t4_prep_adapter - prepare SW and HW for operation

 *	@adapter: the adapter

 *

 *	Initialize adapter SW state for the various HW modules, set initial

 *	values for some adapter tunables, take PHYs out of reset, and

 *	initialize the MDIO interface.

	/* Retrieve adapter's device ID

		/* Congestion map is for 4 channels so that

		 * MPS can have 4 priority per port.

		/* Congestion map will be for 2 channels so that

		 * MPS can have 8 priority per port.

	/*

	 * Default port for debugging in case we can't reach FW.

 Set PCIe completion timeout to 4 seconds. */

/**

 *	t4_shutdown_adapter - shut down adapter, host & wire

 *	@adapter: the adapter

 *

 *	Perform an emergency shutdown of the adapter and stop it from

 *	continuing any further communication on the ports or DMA to the

 *	host.  This is typically used when the adapter and/or firmware

 *	have crashed and we want to prevent any further accidental

 *	communication with the rest of the world.  This will also force

 *	the port Link Status to go down -- if register writes work --

 *	which should help our peers figure out that we're down.

/**

 *	t4_bar2_sge_qregs - return BAR2 SGE Queue register information

 *	@adapter: the adapter

 *	@qid: the Queue ID

 *	@qtype: the Ingress or Egress type for @qid

 *	@user: true if this request is for a user mode queue

 *	@pbar2_qoffset: BAR2 Queue Offset

 *	@pbar2_qid: BAR2 Queue ID or 0 for Queue ID inferred SGE Queues

 *

 *	Returns the BAR2 SGE Queue Registers information associated with the

 *	indicated Absolute Queue ID.  These are passed back in return value

 *	pointers.  @qtype should be T4_BAR2_QTYPE_EGRESS for Egress Queue

 *	and T4_BAR2_QTYPE_INGRESS for Ingress Queues.

 *

 *	This may return an error which indicates that BAR2 SGE Queue

 *	registers aren't available.  If an error is not returned, then the

 *	following values are returned:

 *

 *	  *@pbar2_qoffset: the BAR2 Offset of the @qid Registers

 *	  *@pbar2_qid: the BAR2 SGE Queue ID or 0 of @qid

 *

 *	If the returned BAR2 Queue ID is 0, then BAR2 SGE registers which

 *	require the "Inferred Queue ID" ability may be used.  E.g. the

 *	Write Combining Doorbell Buffer. If the BAR2 Queue ID is not 0,

 *	then these "Inferred Queue ID" register may not be used.

 T4 doesn't support BAR2 SGE Queue registers for kernel mode queues */

	/* Get our SGE Page Size parameters.

	/* Get the right Queues per Page parameters for our Queue.

	/*  Calculate the basics of the BAR2 SGE Queue register area:

	 *  o The BAR2 page the Queue registers will be in.

	 *  o The BAR2 Queue ID.

	 *  o The BAR2 Queue ID Offset into the BAR2 page.

	/* If the BAR2 Queue ID Offset is less than the Page Size, then the

	 * hardware will infer the Absolute Queue ID simply from the writes to

	 * the BAR2 Queue ID Offset within the BAR2 Page (and we need to use a

	 * BAR2 Queue ID of 0 for those writes).  Otherwise, we'll simply

	 * write to the first BAR2 SGE Queue Area within the BAR2 Page with

	 * the BAR2 Queue ID and the hardware will infer the Absolute Queue ID

	 * from the BAR2 Page and BAR2 Queue ID.

	 *

	 * One important censequence of this is that some BAR2 SGE registers

	 * have a "Queue ID" field and we can write the BAR2 SGE Queue ID

	 * there.  But other registers synthesize the SGE Queue ID purely

	 * from the writes to the registers -- the Write Combined Doorbell

	 * Buffer is a good example.  These BAR2 SGE Registers are only

	 * available for those BAR2 SGE Register areas where the SGE Absolute

	 * Queue ID can be inferred from simple writes.

/**

 *	t4_init_devlog_params - initialize adapter->params.devlog

 *	@adap: the adapter

 *

 *	Initialize various fields of the adapter's Firmware Device Log

 *	Parameters structure.

	/* If we're dealing with newer firmware, the Device Log Parameters

	 * are stored in a designated register which allows us to access the

	 * Device Log even if we can't talk to the firmware.

	/* Otherwise, ask the firmware for it's Device Log Parameters.

/**

 *	t4_init_sge_params - initialize adap->params.sge

 *	@adapter: the adapter

 *

 *	Initialize various fields of the adapter's SGE Parameters structure.

	/* Extract the SGE Page Size for our PF.

	/* Extract the SGE Egress and Ingess Queues Per Page for our PF.

/**

 *      t4_init_tp_params - initialize adap->params.tp

 *      @adap: the adapter

 *      @sleep_ok: if true we may sleep while awaiting command completion

 *

 *      Initialize various fields of the adapter's TP Parameters structure.

 MODQ_REQ_MAP defaults to setting queues 0-3 to chan 0-3 */

	/* Cache the adapter's Compressed Filter Mode/Mask and global Ingress

	 * Configuration.

 Read current value */

		/* Incase of older-fw (which doesn't expose the api

		 * FW_PARAM_DEV_FILTER_MODE_MASK) and newer-driver (which uses

		 * the fw api) combination, fall-back to older method of reading

		 * the filter mode from indirect-register

		/* With the older-fw and newer-driver combination we might run

		 * into an issue when user wants to use hash filter region but

		 * the filter_mask is zero, in this case filter_mask validation

		 * is tough. To avoid that we set the filter_mask same as filter

		 * mode, which will behave exactly as the older way of ignoring

		 * the filter mask validation.

	/* For T6, cache the adapter's compressed error vector

	 * and passing outer header info for encapsulated packets.

	/* Now that we have TP_VLAN_PRI_MAP cached, we can calculate the field

	 * shift positions of several elements of the Compressed Filter Tuple

	 * for this adapter which we need frequently ...

	/* If TP_INGRESS_CONFIG.VNID == 0, then TP_VLAN_PRI_MAP.VNIC_ID

	 * represents the presence of an Outer VLAN instead of a VNIC ID.

/**

 *      t4_filter_field_shift - calculate filter field shift

 *      @adap: the adapter

 *      @filter_sel: the desired field (from TP_VLAN_PRI_MAP bits)

 *

 *      Return the shift position of a filter field within the Compressed

 *      Filter Tuple.  The filter field is specified via its selection bit

 *      within TP_VLAN_PRI_MAL (filter mode).  E.g. F_VLAN.

/**

 *	t4_init_portinfo - allocate a virtual interface and initialize port_info

 *	@pi: the port_info

 *	@mbox: mailbox to use for the FW command

 *	@port: physical port associated with the VI

 *	@pf: the PF owning the VI

 *	@vf: the VF owning the VI

 *	@mac: the MAC address of the VI

 *

 *	Allocates a virtual interface for the given physical port.  If @mac is

 *	not %NULL it contains the MAC address of the VI as assigned by FW.

 *	@mac should be large enough to hold an Ethernet address.

 *	Returns < 0 on error.

	/* If we haven't yet determined whether we're talking to Firmware

	 * which knows the new 32-bit Port Capabilities, it's time to find

	 * out now.  This will also tell new Firmware to send us Port Status

	 * Updates using the new 32-bit Port Capabilities version of the

	 * Port Information message.

	/* Extract the various fields from the Port Information message.

	/* If fw supports returning the VIN as part of FW_VI_CMD,

	 * save the returned values.

 Retrieve the values from VIID */

/**

 *	t4_read_cimq_cfg - read CIM queue configuration

 *	@adap: the adapter

 *	@base: holds the queue base addresses in bytes

 *	@size: holds the queue sizes in bytes

 *	@thres: holds the queue full thresholds in bytes

 *

 *	Returns the current configuration of the CIM queues, starting with

 *	the IBQs, then the OBQs.

 value is in 256-byte units */

 8-byte unit */

 value is in 256-byte units */

/**

 *	t4_read_cim_ibq - read the contents of a CIM inbound queue

 *	@adap: the adapter

 *	@qid: the queue index

 *	@data: where to store the queue contents

 *	@n: capacity of @data in 32-bit words

 *

 *	Reads the contents of the selected CIM queue starting at address 0 up

 *	to the capacity of @data.  @n must be a multiple of 4.  Returns < 0 on

 *	error and the number of 32-bit words actually read on success.

	/* It might take 3-10ms before the IBQ debug read access is allowed.

	 * Wait for 1 Sec with a delay of 1 usec.

/**

 *	t4_read_cim_obq - read the contents of a CIM outbound queue

 *	@adap: the adapter

 *	@qid: the queue index

 *	@data: where to store the queue contents

 *	@n: capacity of @data in 32-bit words

 *

 *	Reads the contents of the selected CIM queue starting at address 0 up

 *	to the capacity of @data.  @n must be a multiple of 4.  Returns < 0 on

 *	error and the number of 32-bit words actually read on success.

 muliple of 256 -> muliple of 4 */

 same */

/**

 *	t4_cim_read - read a block from CIM internal address space

 *	@adap: the adapter

 *	@addr: the start address within the CIM address space

 *	@n: number of words to read

 *	@valp: where to store the result

 *

 *	Reads a block of 4-byte words from the CIM intenal address space.

/**

 *	t4_cim_write - write a block into CIM internal address space

 *	@adap: the adapter

 *	@addr: the start address within the CIM address space

 *	@n: number of words to write

 *	@valp: set of values to write

 *

 *	Writes a block of 4-byte words into the CIM intenal address space.

/**

 *	t4_cim_read_la - read CIM LA capture buffer

 *	@adap: the adapter

 *	@la_buf: where to store the LA data

 *	@wrptr: the HW write pointer within the capture buffer

 *

 *	Reads the contents of the CIM LA buffer with the most recent entry at

 *	the end	of the returned data and with the entry at @wrptr first.

 *	We try to leave the LA in the running state we find it in.

 LA is running, freeze it */

		/* Bits 0-3 of UpDbgLaRdPtr can be between 0000 to 1001 to

		 * identify the 32-bit portion of the full 312-bit data

 address can't exceed 0xfff */

/**

 *	t4_tp_read_la - read TP LA capture buffer

 *	@adap: the adapter

 *	@la_buf: where to store the LA data

 *	@wrptr: the HW write pointer within the capture buffer

 *

 *	Reads the contents of the TP LA buffer with the most recent entry at

 *	the end	of the returned data and with the entry at @wrptr first.

 *	We leave the LA in the running state we find it in.

 freeze LA */

 Wipe out last entry if it isn't valid */

 restore running state */

/* SGE Hung Ingress DMA Warning Threshold time and Warning Repeat Rate (in

 * seconds).  If we find one of the SGE Ingress DMA State Machines in the same

 * state for more than the Warning Threshold then we'll issue a warning about

 * a potential hang.  We'll repeat the warning as the SGE Ingress DMA Channel

 * appears to be hung every Warning Repeat second till the situation clears.

 * If the situation clears, we'll note that as well.

/**

 *	t4_idma_monitor_init - initialize SGE Ingress DMA Monitor

 *	@adapter: the adapter

 *	@idma: the adapter IDMA Monitor state

 *

 *	Initialize the state of an SGE Ingress DMA Monitor.

	/* Initialize the state variables for detecting an SGE Ingress DMA

	 * hang.  The SGE has internal counters which count up on each clock

	 * tick whenever the SGE finds its Ingress DMA State Engines in the

	 * same state they were on the previous clock tick.  The clock used is

	 * the Core Clock so we have a limit on the maximum "time" they can

	 * record; typically a very small number of seconds.  For instance,

	 * with a 600MHz Core Clock, we can only count up to a bit more than

	 * 7s.  So we'll synthesize a larger counter in order to not run the

	 * risk of having the "timers" overflow and give us the flexibility to

	 * maintain a Hung SGE State Machine of our own which operates across

	 * a longer time frame.

 1s */

/**

 *	t4_idma_monitor - monitor SGE Ingress DMA state

 *	@adapter: the adapter

 *	@idma: the adapter IDMA Monitor state

 *	@hz: number of ticks/second

 *	@ticks: number of ticks since the last IDMA Monitor call

	 /* Read the SGE Debug Ingress DMA Same State Count registers.  These

	  * are counters inside the SGE which count up on each clock when the

	  * SGE finds its Ingress DMA State Engines in the same states they

	  * were in the previous clock.  The counters will peg out at

	  * 0xffffffff without wrapping around so once they pass the 1s

	  * threshold they'll stay above that till the IDMA state changes.

		/* If the Ingress DMA Same State Counter ("timer") is less

		 * than 1s, then we can reset our synthesized Stall Timer and

		 * continue.  If we have previously emitted warnings about a

		 * potential stalled Ingress Queue, issue a note indicating

		 * that the Ingress Queue has resumed forward progress.

		/* Synthesize an SGE Ingress DMA Same State Timer in the Hz

		 * domain.  The first time we get here it'll be because we

		 * passed the 1s Threshold; each additional time it'll be

		 * because the RX Timer Callback is being fired on its regular

		 * schedule.

		 *

		 * If the stall is below our Potential Hung Ingress Queue

		 * Warning Threshold, continue.

		/* We'll issue a warning every SGE_IDMA_WARN_REPEAT seconds.

		/* Read and save the SGE IDMA State and Queue ID information.

		 * We do this every time in case it changes across time ...

		 * can't be too careful ...

/**

 *	t4_load_cfg - download config file

 *	@adap: the adapter

 *	@cfg_data: the cfg text file to write

 *	@size: text file size

 *

 *	Write the supplied config text file to the card's serial flash.

 # of sectors spanned */

	/* If size == 0 then we're simply erasing the FLASH sectors associated

	 * with the on-adapter Firmware Configuration File.

 this will write to the flash up to SF_PAGE_SIZE at a time */

/**

 *	t4_set_vf_mac_acl - Set MAC address for the specified VF

 *	@adapter: The adapter

 *	@vf: one of the VFs instantiated by the specified PF

 *	@naddr: the number of MAC addresses

 *	@addr: the MAC address(es) to be set to the specified VF

 Note: Do not enable the ACL */

/**

 * t4_read_pace_tbl - read the pace table

 * @adap: the adapter

 * @pace_vals: holds the returned values

 *

 * Returns the values of TP's pace table in microseconds.

/**

 * t4_get_tx_sched - get the configuration of a Tx HW traffic scheduler

 * @adap: the adapter

 * @sched: the scheduler index

 * @kbps: the byte rate in Kbps

 * @ipg: the interpacket delay in tenths of nanoseconds

 * @sleep_ok: if true we may sleep while awaiting command completion

 *

 * Return the current configuration of a HW Tx scheduler.

 scheduler disabled */

 ticks/s */

/* t4_sge_ctxt_rd - read an SGE context through FW

 * @adap: the adapter

 * @mbox: mailbox to use for the FW command

 * @cid: the context id

 * @ctype: the context type

 * @data: where to store the context data

 *

 * Issues a FW command through the given mailbox to read an SGE context.

/**

 * t4_sge_ctxt_rd_bd - read an SGE context bypassing FW

 * @adap: the adapter

 * @cid: the context id

 * @ctype: the context type

 * @data: where to store the context data

 *

 * Reads an SGE context directly, bypassing FW.  This is only for

 * debugging when FW is unavailable.

/**

 *	t4_i2c_rd - read I2C data from adapter

 *	@adap: the adapter

 *	@mbox: mailbox to use for the FW command

 *	@port: Port number if per-port device; <0 if not

 *	@devid: per-port device ID or absolute device ID

 *	@offset: byte offset into device I2C space

 *	@len: byte length of I2C space data

 *	@buf: buffer in which to return I2C data

 *

 *	Reads the I2C data from the indicated device and location.

 Dont allow reads that spans multiple pages */

/**

 *      t4_set_vlan_acl - Set a VLAN id for the specified VF

 *      @adap: the adapter

 *      @mbox: mailbox to use for the FW command

 *      @vf: one of the VFs instantiated by the specified PF

 *      @vlan: The vlanid to be set

 Drop all packets that donot match vlan id */

/**

 *	modify_device_id - Modifies the device ID of the Boot BIOS image

 *	@device_id: the device ID to write.

 *	@boot_data: the boot image to modify.

 *

 *	Write the supplied device ID to the boot BIOS image.

 Loop through all chained images and change the device ID's */

		/**

		 * Only modify the Device ID if code type is Legacy or HP.

		 * 0x00: Okay to modify

		 * 0x01: FCODE. Do not modify

		 * 0x03: Okay to modify

		 * 0x04-0xFF: Do not modify

			/**

			 * Modify Device ID to match current adatper

			/**

			 * Set checksum temporarily to 0.

			 * We will recalculate it later.

			/**

			 * Calculate and update checksum

			/**

			 * Invert summed value to create the checksum

			 * Writing new checksum value directly to the boot data

			/**

			 * Modify Device ID to match current adatper

		/**

		 * Move header pointer up to the next image in the ROM.

/**

 *	t4_load_boot - download boot flash

 *	@adap: the adapter

 *	@boot_data: the boot image to write

 *	@boot_addr: offset in flash to write boot_data

 *	@size: image size

 *

 *	Write the supplied boot image to the card's serial flash.

 *	The boot image has the following sections: a 28-byte header and the

 *	boot image.

	/**

	 * Make sure the boot image does not encroach on the firmware region

 Get boot header */

 PCIR Data Structure */

	/**

	 * Perform some primitive sanity testing to avoid accidentally

	 * writing garbage over the boot sectors.  We ought to check for

	 * more but it's not worth it for now ...

 Check PCI header signature */

 Check Vendor ID matches Chelsio ID*/

	/**

	 * The boot sector is comprised of the Expansion-ROM boot, iSCSI boot,

	 * and Boot configuration data sections. These 3 boot sections span

	 * sectors 0 to 7 in flash and live right before the FW image location.

	/**

	 * If size == 0 then we're simply erasing the FLASH sectors associated

	 * with the on-adapter option ROM file

 Retrieve adapter's device ID */

 Want to deal with PF 0 so I strip off PF 4 indicator */

 Check PCIE Device ID */

		/**

		 * Change the device ID in the Boot BIOS image to match

		 * the Device ID of the current adapter.

	/**

	 * Skip over the first SF_PAGE_SIZE worth of data and write it after

	 * we finish copying the rest of the boot image. This will ensure

	 * that the BIOS boot header will only be written if the boot image

	 * was written in full.

/**

 *	t4_flash_bootcfg_addr - return the address of the flash

 *	optionrom configuration

 *	@adapter: the adapter

 *

 *	Return the address within the flash where the OptionROM Configuration

 *	is stored, or an error if the device FLASH is too small to contain

 *	a OptionROM Configuration.

	/**

	 * If the device FLASH isn't large enough to hold a Firmware

	 * Configuration File, return an error.

	/**

	 * If size == 0 then we're simply erasing the FLASH sectors associated

	 * with the on-adapter OptionROM Configuration File.

 this will write to the flash up to SF_PAGE_SIZE at a time */

/*

 * This file is part of the Chelsio T4 Ethernet driver for Linux.

 *

 * Copyright (c) 2003-2016 Chelsio Communications, Inc. All rights reserved.

 *

 * This software is available to you under a choice of one of two

 * licenses.  You may choose to be licensed under the terms of the GNU

 * General Public License (GPL) Version 2, available from the file

 * COPYING in the main directory of this source tree, or the

 * OpenIB.org BSD license below:

 *

 *     Redistribution and use in source and binary forms, with or

 *     without modification, are permitted provided that the following

 *     conditions are met:

 *

 *      - Redistributions of source code must retain the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer.

 *

 *      - Redistributions in binary form must reproduce the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer in the documentation and/or other materials

 *        provided with the distribution.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS

 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN

 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN

 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

/* Set one of the t_flags bits in the TCB.

 do a set-tcb for smac-sel and CWR bit.. */

 Validate filter spec against configuration done on the card. */

 Check for unconfigured fields being used. */

	/* T4 inconveniently uses the same FT_VNIC_ID_W bits for both the Outer

	 * VLAN Tag and PF/VF/VFvld fields based on VNIC_F being set

	 * in TP_INGRESS_CONFIG.  Hense the somewhat crazy checks

	 * below.  Additionally, since the T4 firmware interface also

	 * carries that overlap, we need to translate any PF/VF

	 * specification into that internal format below.

	/* If the user is requesting that the filter action loop

	 * matching packets back out one of our ports, make sure that

	 * the egress port is in range.

 Don't allow various trivially obvious bogus out-of-range values... */

 T4 doesn't support removing VLAN Tags for loop back filters. */

	/* If the user has requested steering matching Ingress Packets

	 * to a specific Queue Set, we need to make sure it's in range

	 * for the port and map that into the Absolute Queue ID of the

	 * Queue Set's Response Queue.

		/* If the iq id is greater than the number of qsets,

		 * then assume it is an absolute qid.

 T4 doesn't maintain byte counts in hw */

 Get pkts */

 Get bytes */

 Get pkts */

	/* Only insert the rule if both of the following conditions

	 * are met:

	 * 1. The immediate previous rule has priority <= @prio.

	 * 2. The immediate next rule has priority >= @prio.

	/* High Priority (HPFILTER) region always has higher priority

	 * than normal FILTER region. So, all rules in HPFILTER region

	 * must have prio value <= rules in normal FILTER region.

		/* Don't insert if there's a rule already present at @idx

		 * in HPFILTER region.

			/* No next entry found in HPFILTER region.

			 * See if there's any next entry in normal

			 * FILTER region.

		/* Search for the closest previous filter entry in HPFILTER

		 * region. No need to search in normal FILTER region because

		 * there can never be any entry in normal FILTER region whose

		 * prio value is < last entry in HPFILTER region.

		/* Don't insert if there's a rule already present at @idx

		 * in normal FILTER region.

			/* No previous entry found in normal FILTER

			 * region. See if there's any previous entry

			 * in HPFILTER region.

		/* Search for the closest next filter entry in normal

		 * FILTER region. No need to search in HPFILTER region

		 * because there can never be any entry in HPFILTER

		 * region whose prio value is > first entry in normal

		 * FILTER region.

	/* See if the filter entry belongs to an IPv6 rule, which

	 * occupy 4 slots on T5 and 2 slots on T6. Adjust the

	 * reference to the previously inserted filter entry

	 * accordingly.

	/* IPv4 occupy 1 slot. IPv6 occupy 2 slots on T6 and 4 slots

	 * on T5.

	/* There are 3 filter regions available in hardware in

	 * following order of priority:

	 *

	 * 1. High Priority (HPFILTER) region (Highest Priority).

	 * 2. HASH region.

	 * 3. Normal FILTER region (Lowest Priority).

	 *

	 * Entries in HPFILTER and normal FILTER region have index

	 * 0 as the highest priority and the rules will be scanned

	 * in ascending order until either a rule hits or end of

	 * the region is reached.

	 *

	 * All HASH region entries have same priority. The set of

	 * fields to match in headers are pre-determined. The same

	 * set of header match fields must be compulsorily specified

	 * in all the rules wanting to get inserted in HASH region.

	 * Hence, HASH region is an exact-match region. A HASH is

	 * generated for a rule based on the values in the

	 * pre-determined set of header match fields. The generated

	 * HASH serves as an index into the HASH region. There can

	 * never be 2 rules having the same HASH. Hardware will

	 * compute a HASH for every incoming packet based on the

	 * values in the pre-determined set of header match fields

	 * and uses it as an index to check if there's a rule

	 * inserted in the HASH region at the specified index. If

	 * there's a rule inserted, then it's considered as a filter

	 * hit. Otherwise, it's a filter miss and normal FILTER region

	 * is scanned afterwards.

			/* If the new rule wants to get inserted into

			 * HPFILTER region, but its prio is greater

			 * than the rule with the highest prio in HASH

			 * region, or if there's not enough slots

			 * available in HPFILTER region, then skip

			 * trying to insert this rule into HPFILTER

			 * region and directly go to the next region.

			/* Ensure priority is >= last rule in HPFILTER

			 * region.

			/* Ensure priority is <= first rule in normal

			 * FILTER region.

			/* If the new rule wants to get inserted into

			 * normal FILTER region, but its prio is less

			 * than the rule with the highest prio in HASH

			 * region, then reject the rule.

			/* Ensure the new rule's prio doesn't conflict

			 * with existing rules.

 Delete the filter at a specified index. */

	/* Mark the filter as "pending" and ship off the Filter Work Request.

	 * When we get the Work Request Reply we'll clear the pending status.

/* Send a Work Request to write the filter at a specified index.  We construct

 * a Firmware Filter Work Request to have the work done and put the indicated

 * filter into "pending" mode which will prevent any further actions against

 * it till we get a reply from the firmware on the completion status of the

 * request.

	/* If the new filter requires loopback Destination MAC and/or VLAN

	 * rewriting then we need to allocate a Layer 2 Table (L2T) entry for

	 * the filter.

 allocate L2T entry for new filter */

	/* If the new filter requires loopback Source MAC rewriting then

	 * we need to allocate a SMT entry for the filter.

	/* It would be nice to put most of the following in t4_hw.c but most

	 * of the work is translating the cxgbtool ch_filter_specification

	 * into the Work Request and the definition of that structure is

	 * currently in cxgbtool.h which isn't appropriate to pull into the

	 * common code.  We may eventually try to come up with a more neutral

	 * filter specification structure but for now it's easiest to simply

	 * put this fairly direct code in line ...

	/* Mark the filter as "pending" and ship off the Filter Work Request.

	 * When we get the Work Request Reply we'll clear the pending status.

 Return an error number if the indicated filter isn't writable ... */

/* Delete the filter at the specified index (if valid).  The checks for all

 * the common problems with doing this like the filter being locked, currently

 * pending in another operation, etc.

/* Clear a filter and release any of its resources that we own.  This also

 * clears the filter's "pending" status.

	/* If the new or old filter have loopback rewriting rules then we'll

	 * need to free any existing L2T, SMT, CLIP entries of filter

	 * rule.

	/* The zeroing of the filter rule below clears the filter valid,

	 * pending, locked flags, l2t pointer, etc. so it's all we need for

	 * this operation.

 Clear all TCAM filters */

 Clear all hash filters */

 Fill up default masks for set match fields. */

 Keep tunnel VNI match disabled for hash-filters for now */

 calculate tuple mask and compare with mask configured in hw */

	/* Initialize each of the fields which we care about which are present

	 * in the Compressed Filter Tuple.

	/* If the new filter requires loopback Destination MAC and/or VLAN

	 * rewriting then we need to allocate a Layer 2 Table (L2T) entry for

	 * the filter.

 allocate L2T entry for new filter */

	/* If the new filter requires loopback Source MAC rewriting then

	 * we need to allocate a SMT entry for the filter.

 allocate MPS TCAM entry */

/* Check a Chelsio Filter Request for validity, convert it into our internal

 * format and send it to the hardware.  Return 0 on success, an error number

 * otherwise.  We attach any provided filter operation context to the internal

 * filter specification in order to facilitate signaling completion of the

 * operation.

	/* IPv6 filters occupy four slots and must be aligned on

	 * four-slot boundaries.  IPv4 filters only occupy a single

	 * slot and have no alignment requirements but writing a new

	 * IPv4 filter into the middle of an existing IPv6 filter

	 * requires clearing the old IPv6 filter and hence we prevent

	 * insertion.

 IPv4 */

		/* For T6, If our IPv4 filter isn't being written to a

		 * multiple of two filter index and there's an IPv6

		 * filter at the multiple of 2 base slot, then we need

		 * to delete that IPv6 filter ...

		 * For adapters below T6, IPv6 filter occupies 4 entries.

		 * Hence we need to delete the filter in multiple of 4 slot.

 IPv6 */

			/* Ensure that the IPv6 filter is aligned on a

			 * multiple of 4 boundary.

			/* Check all except the base overlapping IPv4 filter

			 * slots.

			/* For T6, CLIP being enabled, IPv6 filter would occupy

			 * 2 entries.

 Check overlapping IPv4 filter slot */

	/* Check to make sure that provided filter index is not

	 * already in use by someone else

 Check t  make sure the filter requested is writable ... */

	/* Convert the filter specification into our internal format.

	 * We copy the PF/VF specification into the Outer VLAN field

	 * here so the rest of the code -- including the interface to

	 * the firmware -- doesn't have to constantly do these checks.

 allocate MPS TCAM entry */

	/* Attempt to set the filter.  If we don't succeed, we clear

	 * it and return the failure.

 Save the actual tid */

/* Check a delete filter request for validity and send it to the hardware.

 * Return 0 on success, an error number otherwise.  We attach any provided

 * filter operation context to the internal filter specification in order to

 * facilitate signaling completion of the operation.

	/* If the caller has passed in a Completion Context then we need to

	 * mark it as a successful completion so they don't stall waiting

	 * for it.

 Wait for reply */

 Wait for reply */

 Handle a filter write/deletion reply. */

 Get the corresponding filter entry for this tid */

 Check this in normal filter region */

 We found the filter entry for this tid */

		/* Pull off any filter operation context attached to the

		 * filter.

			/* Clear the filter when we get confirmation from the

			 * hardware that the filter has been deleted.

 async setup completed */

			/* Something went wrong.  Issue a warning about the

			 * problem and clear everything out.

	/* On T6, verify the necessary register configs and warn the user in

	 * case of improper config

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  Copyright (C) 2017 Chelsio Communications.  All rights reserved.

 Clear compression buffer for re-use */

	/* We already write to buffer provided by ethool, so just

	 * increment offset to next free space.

/*

 * This file is part of the Chelsio T6 Ethernet driver for Linux.

 *

 * Copyright (c) 2017-2018 Chelsio Communications, Inc. All rights reserved.

 *

 * This software is available to you under a choice of one of two

 * licenses.  You may choose to be licensed under the terms of the GNU

 * General Public License (GPL) Version 2, available from the file

 * COPYING in the main directory of this source tree, or the

 * OpenIB.org BSD license below:

 *

 *     Redistribution and use in source and binary forms, with or

 *     without modification, are permitted provided that the following

 *     conditions are met:

 *

 *      - Redistributions of source code must retain the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer.

 *

 *      - Redistributions in binary form must reproduce the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer in the documentation and/or other materials

 *        provided with the distribution.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS

 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN

 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN

 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

/* cxgb4_get_srq_entry: read the SRQ table entry

 * @dev: Pointer to the net_device

 * @idx: Index to the srq

 * @entryp: pointer to the srq entry

 *

 * Sends CPL_SRQ_TABLE_REQ message for the given index.

 * Contents will be returned in CPL_SRQ_TABLE_RPL message.

 *

 * Returns zero if the read is successful, else a error

 * number will be returned. Caller should not use the srq

 * entry if the return value is non-zero.

 *

 *

 !rc means we timed out */

 Store the read entry */

/*

 *  This file is part of the Chelsio T4 Ethernet driver for Linux.

 *  Copyright (C) 2003-2014 Chelsio Communications.  All rights reserved.

 *

 *  Written by Deepak (deepak.s@chelsio.com)

 *

 *  This program is distributed in the hope that it will be useful, but WITHOUT

 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or

 *  FITNESS FOR A PARTICULAR PURPOSE.  See the LICENSE file included in this

 *  release for licensing terms and conditions.

/* Retrieves IPv6 addresses from a root device (bond, vlan) associated with

 * a physical device.

 * The physical device reference is needed to send the actul CLIP command.

 First populate the real net device's IPv6 addresses */

 Parse all bond and vlan devices layered on top of the physical dev */

/*

 * This file is part of the Chelsio T4 Ethernet driver for Linux.

 *

 * Copyright (c) 2016 Chelsio Communications, Inc. All rights reserved.

 *

 * This software is available to you under a choice of one of two

 * licenses.  You may choose to be licensed under the terms of the GNU

 * General Public License (GPL) Version 2, available from the file

 * COPYING in the main directory of this source tree, or the

 * OpenIB.org BSD license below:

 *

 *     Redistribution and use in source and binary forms, with or

 *     without modification, are permitted provided that the following

 *     conditions are met:

 *

 *      - Redistributions of source code must retain the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer.

 *

 *      - Redistributions in binary form must reproduce the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer in the documentation and/or other materials

 *        provided with the distribution.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS

 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN

 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN

 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

		/* Create a template for the FW_PARAMS_CMD mnemonic and

		 * value (TX Scheduling Class in this case).

 Look for an entry with matching @val */

 Find the existing entry that the queue is bound to */

 Unbind queue from any existing class */

 Bind queue to specified class */

 Find the existing entry that the flowc is bound to */

 Unbind flowc from any existing class */

 Bind flowc to specified class */

/**

 * cxgb4_sched_class_bind - Bind an entity to a scheduling class

 * @dev: net_device pointer

 * @arg: Entity opaque data

 * @type: Entity type (Queue)

 *

 * Binds an entity (queue) to a scheduling class.  If the entity

 * is bound to another class, it will be unbound from the other class

 * and bound to the class specified in @arg.

/**

 * cxgb4_sched_class_unbind - Unbind an entity from a scheduling class

 * @dev: net_device pointer

 * @arg: Entity opaque data

 * @type: Entity type (Queue)

 *

 * Unbinds an entity (queue) from a scheduling class.

 If @p is NULL, fetch any available unused class */

 Get any available unused class */

 Look for a class with matching scheduling parameters */

 Don't try to match class parameter */

 Don't try to match class parameter */

	/* Only accept search for existing class with matching params

	 * or allocation of new class with specified params

	/* See if there's an exisiting class with same requested sched

	 * params. Classes can only be shared among FLOWC types. For

	 * other types, always request a new class.

 Fetch any available unused class */

 New class */

/**

 * cxgb4_sched_class_alloc - allocate a scheduling class

 * @dev: net_device pointer

 * @p: new scheduling class to create.

 *

 * Returns pointer to the scheduling class created.  If @p is NULL, then

 * it allocates and returns any available unused scheduling class. If a

 * scheduling class with matching @p is found, then the matching class is

 * returned.

/**

 * cxgb4_sched_class_free - free a scheduling class

 * @dev: net_device pointer

 * @classid: scheduling class id to free

 *

 * Frees a scheduling class if there are no users.

		/* Port based rate limiting needs explicit reset back

		 * to max rate. But, we'll do explicit reset for all

		 * types, instead of just port based type, to be on

		 * the safer side.

		/* Always reset mode to 0. Otherwise, FLOWC mode will

		 * still be enabled even after resetting the traffic

		 * class.

 Mbps to Kbps */

/*

 * This file is part of the Chelsio T4 Ethernet driver for Linux.

 *

 * Copyright (c) 2003-2014 Chelsio Communications, Inc. All rights reserved.

 *

 * This software is available to you under a choice of one of two

 * licenses.  You may choose to be licensed under the terms of the GNU

 * General Public License (GPL) Version 2, available from the file

 * COPYING in the main directory of this source tree, or the

 * OpenIB.org BSD license below:

 *

 *     Redistribution and use in source and binary forms, with or

 *     without modification, are permitted provided that the following

 *     conditions are met:

 *

 *      - Redistributions of source code must retain the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer.

 *

 *      - Redistributions in binary form must reproduce the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer in the documentation and/or other materials

 *        provided with the distribution.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS

 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN

 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN

 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

 identifies sync vs async L2T_WRITE_REQs */

 start index of our piece of the L2T */

 number of entries in l2tab */

 number of free entries */

 starting point for next allocation */

 MUST BE LAST */

 0 -> 1 transition */

/*

 * To avoid having to check address families we do not allow v4 and v6

 * neighbors to be on the same hash chain.  We keep v4 entries in the first

 * half of available hash buckets and v6 in the second.  We need at least two

 * entries in our L2T for this scheme to work.

/*

 * Checks if an L2T entry is for the given IP/IPv6 address.  It does not check

 * whether the L2T entry and the address are of the same address family.

 * Callers ensure an address is only checked against L2T entries of the same

 * family, something made trivial by the separation of IP and IPv6 hash chains

 * mentioned above.  Returns 0 if there's a match,

/*

 * Write an L2T entry.  Must be called with the entry locked.

 * The write may be synchronous or asynchronous.

/*

 * Send packets waiting in an L2T entry's ARP queue.  Must be called with the

 * entry locked.

/*

 * Process a CPL_L2T_WRITE_RPL.  Wake up the ARP queue if it completes a

 * synchronous L2T_WRITE.  Note that the TID in the reply is really the L2T

 * index it refers to.

/*

 * Add a packet to an L2T entry's queue of packets awaiting resolution.

 * Must be called with the entry's lock held.

 entry is stale, kick off revalidation */

 fast-path, send the packet on */

/*

 * Allocate a free L2T entry.  Must be called with l2t_data.lock held.

 there's definitely a free entry */

	/*

	 * The entry we found may be an inactive entry that is

	 * presently in the hash table.  We need to remove it.

	/* The entry we found may be an inactive entry that is

	 * presently in the hash table.  We need to remove it.

/* Called when an L2T entry has no more users.  The entry is left in the hash

 * table since it is likely to be reused but we also bump nfree to indicate

 * that the entry can be reallocated for a different neighbor.  We also drop

 * the existing neighbor reference in case the neighbor is going away and is

 * waiting on our reference.

 *

 * Because entries can be reallocated to other neighbors once their ref count

 * drops to 0 we need to take the entry's lock to avoid races with a new

 * incarnation.

 hasn't been recycled */

 Locked version of _t4_l2e_free */

 hasn't been recycled */

/*

 * Update an L2T entry that was previously used for the same next hop as neigh.

 * Must be called with softirqs disabled.

 avoid race with t4_l2t_free */

 Need to allocate a new entry */

 avoid race with t4_l2t_free */

	/* Initialize each of the fields which we care about which are present

	 * in the Compressed Filter Tuple.

/*

 * Called when the host's neighbor layer makes a change to some entry that is

 * loaded into the HW L2 table.

		/* Called when address resolution fails for an L2T

		 * entry to handle packets on the arpq head. If a

		 * packet specifies a failure handler it is invoked,

		 * otherwise the packet is sent to the device.

/* Allocate an L2T entry for use by a switching rule.  Such need to be

 * explicitly freed and while busy they are not on any hash chain, so normal

 * address resolution updates do not see them.

 avoid race with t4_l2t_free */

/**

 * cxgb4_l2t_alloc_switching - Allocates an L2T entry for switch filters

 * @dev: net_device pointer

 * @vlan: VLAN Id

 * @port: Associated port

 * @dmac: Destination MAC address to add to L2T

 * Returns pointer to the allocated l2t entry

 *

 * Allocates an L2T entry for use by switching rule of a filter

 SPDX-License-Identifier: GPL-2.0-only

 Copyright (C) 2019 Chelsio Communications.  All rights reserved. */

 Convert from Mbps to bps */

			/* If queue count is 0, then the traffic

			 * belonging to this class will not use

			 * ETHOFLD queues. So, no need to validate

			 * further.

 Convert byte per second to bits per second */

 Allocate ETHOFLD hardware queue structures if not done already */

 Allocate Rxqs for receiving ETHOFLD Tx completions */

 Allocate ETHOFLD hardware Txqs */

 Allocate IRQs, set IRQ affinity, and start Rx */

 Return if no ETHOFLD structures have been allocated yet */

 Return if no hardware queues have been allocated */

		/* Device removal path will already disable NAPI

		 * before unregistering netdevice. So, only disable

		 * NAPI if we're not in device removal path

 Free up ETHOFLD structures if there are no users */

 Convert from bytes per second to Kbps */

		/* Request larger burst buffer for smaller MTU, so

		 * that hardware can work on more data per burst

		 * cycle.

	/* If we're shutting down, interrupts are disabled and no completions

	 * come back. So, skip waiting for completions in this scenario.

	/* Inform the stack about the configured tc params.

	 *

	 * Set the correct queue map. If no queue count has been

	 * specified, then send the traffic through default NIC

	 * queues; instead of ETHOFLD queues.

 Free up the traffic classes */

	/* To configure tc params, the current allocated EOTIDs must

	 * be freed up. However, they can't be freed up if there's

	 * traffic running on the interface. So, ensure interface is

	 * down before configuring tc params.

	/* If requested for clear, then just return since resources are

	 * already freed up by now.

	/* Allocate free available traffic classes and configure

	 * their rate parameters.

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  Copyright (C) 2017 Chelsio Communications.  All rights reserved.

 t6_tp_pio_regs_20_to_3b */

 t6_tp_pio_regs_40_to_49 */

 t6_tp_pio_regs_50_to_59 */

 t6_tp_pio_regs_60_to_6d */

 t6_tp_pio_regs_6f */

 t6_tp_pio_regs_70_to_75 */

 t6_tp_pio_regs_130_to_141 */

 t6_tp_pio_regs_145_to_157 */

 t6_tp_pio_regs_160 */

 t6_tp_pio_regs_230_to_248 */

 t6_tp_pio_regs_24c */

 t6_tp_pio_regs_8c0 */

 t5_tp_pio_regs_20_to_3b */

 t5_tp_pio_regs_40_to_52 */

 t5_tp_pio_regs_54_to_55 */

 t5_tp_pio_regs_60_to_6c */

 t5_tp_pio_regs_6f */

 t5_tp_pio_regs_120_to_123 */

 t5_tp_pio_regs_12b_to_12c */

 t5_tp_pio_regs_12f_to_143 */

 t5_tp_pio_regs_145_to_157 */

 t5_tp_pio_regs_230_to_248 */

 t5_tp_pio_regs_8c0 */

 1 addr reg SGE_QBASE_INDEX and 4 data reg SGE_QBASE_MAP[0-3] */

 t5_pcie_pdbg_regs_00_to_20 */

 t5_pcie_pdbg_regs_21_to_40 */

 t5_pcie_pdbg_regs_41_to_50 */

 t5_pcie_cdbg_regs_00_to_20 */

 t5_pcie_cdbg_regs_21_to_37 */

 t5_pm_rx_regs_10000_to_10020 */

 t5_pm_rx_regs_10021_to_1002c */

 t5_pm_tx_regs_10000_to_10020 */

 t5_pm_tx_regs_10021_to_1003c */

 t6_ma_regs_a000_to_a016 */

 t6_ma_regs_a400_to_a41e */

 t6_ma_regs_a800_to_a813 */

 t6_ma_regs_e400_to_e600 */

 t6_ma_regs_e640_to_e7c0 */

 up_cim_2000_to_207c */

 up_cim_2080_to_20fc */

 up_cim_00_to_7c */

 up_cim_80_to_fc */

 up_cim_100_to_14c */

 up_cim_200_to_23c */

 up_cim_240_to_244 */

 up_cim_250_to_254 */

 up_cim_260_to_264 */

 up_cim_270_to_274 */

 up_cim_280_to_2fc */

 up_cim_300_to_37c */

 up_cim_380_to_3cc */

 up_cim_4900_to_4c60 */

 up_cim_4904_to_4c64 */

 up_cim_4908_to_4c68 */

 up_cim_4910_to_4c70 */

 up_cim_4914_to_4c74 */

 up_cim_4920_to_4a10 */

 up_cim_4924_to_4a14 */

 up_cim_4928_to_4a18 */

 up_cim_492c_to_4a1c */

 up_cim_2000_to_207c */

 up_cim_2080_to_20ec */

 up_cim_00_to_7c */

 up_cim_80_to_fc */

 up_cim_100_to_14c */

 up_cim_200_to_23c */

 up_cim_240_to_244 */

 up_cim_250_to_254 */

 up_cim_260_to_264 */

 up_cim_270_to_274 */

 up_cim_280_to_2fc */

 up_cim_300_to_37c */

 up_cim_380_to_3cc */

 t6_hma_regs_a000_to_a01f */

 for reading CIM LA configuration */

			/* In T6, there's no MC1.  So, HMA shares MC1

			 * address space.

 Do compression in smaller chunks */

/* This function will add additional padding bytes into debug_buffer to make it

 * 4 byte aligned.

 Find and sort the populated memory ranges */

 no memory available */

 the next few have explicit upper bounds */

 hide it */

 hide it */

 add any address-space holes, there can be up to 3 */

 Collect FW devlog */

 collect CIM IBQ */

 t4_read_cim_ibq will return no. of read words or error */

 no_of_read_words is less than or equal to 0 means error */

 size in number of words */

 collect CIM OBQ */

 t4_read_cim_obq will return no. of read words or error */

 no_of_read_words is less than or equal to 0 means error */

 Some T5 cards have both MC0 and MC1. */

 Fetch the @region_name's start and end from @meminfo. */

 Skip holes */

 Check if the region exists in @mem_type memory */

/* Fetch and update the start and end of the requested memory region w.r.t 0

 * in the corresponding EDC/MC/HMA.

 Get TX and RX Payload region */

	/* Argument sanity checks ...

 Try to do 64-bit reads.  Residual will be handled later. */

	/* Set up initial PCI-E Memory Window to cover the start of our

	 * transfer.

 Transfer data from the adapter */

		/* If we've reached the end of our current window aperture,

		 * move the PCI-E Memory Window on to the next.

 Read residual in 32-bit multiples */

		/* If we've reached the end of our current window aperture,

		 * move the PCI-E Memory Window on to the next.

 Transfer residual < 32-bits */

 Get TX/RX Payload region range if they exist */

 Align start and end to avoid wrap around */

		/* As MC size is huge and read through PIO access, this

		 * loop will hold cpu for a longer time. OS may think that

		 * the process is hanged and will generate CPU stall traces.

		 * So yield the cpu regularly.

 TX and RX Payload regions can't overlap */

 Flush uP dcache before reading edcX/mcX  */

 TP_PIO */

 TP_TM_PIO */

 TP_MIB_INDEX */

		/* In SGE_QBASE_INDEX,

		 * Entries 0->7 are PF0->7, Entries 8->263 are VFID0->256.

	/* Accessing SGE_QBASE_MAP[0-3] and SGE_QBASE_INDEX regs can

	 * lead to SGE missing doorbells under heavy traffic. So, only

	 * collect them when adapter is idle.

		/* 1 addr reg SGE_QBASE_INDEX and 4 data reg

		 * SGE_QBASE_MAP[0-3]

 psec */

 PCIE_PDBG */

 PCIE_CDBG */

 PM_RX */

 PM_TX */

	/* If firmware is not attached/alive, use backdoor register

	 * access to collect dump.

 Get EGRESS and INGRESS context region size */

 Get FLM and CNM max qid. */

 Get number of data freelist queues */

	/* The number of CONM contexts are same as number of freelist

	 * queues.

 Get max valid qid for each type of queue */

	/* Under heavy traffic, the SGE Queue contexts registers will be

	 * frequently accessed by firmware.

	 *

	 * To avoid conflicts with firmware, always ask firmware to fetch

	 * the SGE Queue contexts via mailbox. On failure, fallback to

	 * accessing hardware registers directly.

 Get max valid qid for each type of queue */

	/* Get buffer with enough space to read the biggest context

	 * region in memory.

	/* Collect EGRESS and INGRESS context data.

	 * In case of failures, fallback to collecting via FW or

	 * backdoor access.

		/* If firmware is not attached/alive, use backdoor register

		 * access to collect dump.

			/* The data is stored in 64-bit cpu order.  Convert it

			 * to big endian before parsing.

 Collect FREELIST and CONGESTION MANAGER contexts */

	/* Since FLM and CONM are 1-to-1 mapped, the below function

	 * will fetch both FLM and CONM contexts.

		/* CtlReqID   - 1: use Host Driver Requester ID

		 * CtlCmdType - 0: Read, 1: Write

		 * CtlTcamSel - 0: TCAM0, 1: TCAM1

		 * CtlXYBitSel- 0: Y bit, 1: X bit

 Read tcamy */

		/* 0 - Outer header, 1 - Inner header

		 * [71:48] bit locations are overloaded for

		 * outer vs. inner lookup types.

 Inner header VNI */

 Read tcamx. Change the control param */

 Inner header VNI mask */

 If no entry, return */

		/* If firmware is not attached/alive, use backdoor register

		 * access to collect dump.

			/* Ignore error since we collected directly from

			 * reading registers.

 Fill REQ_DATA regs with 0's */

 Write DBIG command */

 LE mode */

 Poll the DBGICMDBUSY bit */

 Check RESP status */

 Read RESP data */

 Get the LE regions */

 hash base index */

 Get routing table index */

 Get clip table index. For T6 there is separate CLIP TCAM */

 Get filter table index */

 Get server table index */

 Check whether hash is enabled and calculate the max tids */

 hash not enabled */

 read all tid */

 Update tcam header and exit */

 T6 CLIP TCAM: ipv6 takes 4 entries */

 Main TCAM: ipv6 takes two tids */

 PBT dynamic entries */

 PBT static entries */

 static entries start when bit 6 is set */

 LRF entries */

 PBT data entries */

 skip over unused entries */

 NIC TXQ, RXQ, FLQ, and CTRLQ */

 FW_EVTQ and INTRQ */

 PTP_TXQ */

 ULD TXQ, RXQ, and FLQ */

 ULD CIQ */

 ETHOFLD TXQ, RXQ, and FLQ */

 NIC TXQ */

 NIC RXQ */

 NIC FLQ */

 NIC CTRLQ */

 FW_EVTQ */

 INTRQ */

 PTP_TXQ */

 ULD Queues */

 ULD TXQ */

 ULD RXQ */

 ULD FLQ */

 ULD CIQ */

 ETHOFLD TXQ */

 ETHOFLD RXQ and FLQ */

/*

 * This file is part of the Chelsio T4 Ethernet driver for Linux.

 *

 * Copyright (c) 2003-2014 Chelsio Communications, Inc. All rights reserved.

 *

 * This software is available to you under a choice of one of two

 * licenses.  You may choose to be licensed under the terms of the GNU

 * General Public License (GPL) Version 2, available from the file

 * COPYING in the main directory of this source tree, or the

 * OpenIB.org BSD license below:

 *

 *     Redistribution and use in source and binary forms, with or

 *     without modification, are permitted provided that the following

 *     conditions are met:

 *

 *      - Redistributions of source code must retain the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer.

 *

 *      - Redistributions in binary form must reproduce the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer in the documentation and/or other materials

 *        provided with the distribution.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS

 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN

 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN

 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

 CONFIG_CHELSIO_T4_FCOE */

/*

 * Rx buffer size.  We use largish buffers if possible but settle for single

 * pages under memory shortage.

 RX_PULL_LEN should be <= RX_COPY_THRES */

/*

 * Main body length for sk_buffs used for Rx Ethernet packets with fragments.

 * Should be >= RX_PULL_LEN but possibly bigger to give pskb_may_pull some room.

/*

 * Max number of Tx descriptors we clean up at a time.  Should be modest as

 * freeing skbs isn't cheap and it happens while holding locks.  We just need

 * to free packets faster than they arrive, we eventually catch up and keep

 * the amortized cost reasonable.  Must be >= 2 * TXQ_STOP_THRES.  It should

 * also match the CIDX Flush Threshold.

/*

 * Max number of Rx buffers we replenish at a time.  Again keep this modest,

 * allocating buffers isn't cheap either.

/*

 * Period of the Rx queue check timer.  This timer is infrequent as it has

 * something to do only when the system experiences severe memory shortage.

/*

 * Period of the Tx queue check timer.

/*

 * Max number of Tx descriptors to be reclaimed by the Tx timer.

/*

 * Timer index used when backing off due to memory shortage.

/*

 * Suspension threshold for non-Ethernet Tx queues.  We require enough room

 * for a full sized WR.

/*

 * Max Tx descriptor space we allow for an Ethernet packet to be inlined

 * into a WR.

/*

 * Max size of a WR sent through a control Tx queue.

 SW state per Rx descriptor */

/*

 * Rx buffer sizes for "useskbs" Free List buffers (one ingress packet pe skb

 * buffer).  We currently only support two sizes for 1500- and 9000-byte MTUs.

 * We could easily support more but there doesn't seem to be much need for

 * that ...

/*

 * Bits 0..3 of rx_sw_desc.dma_addr have special meaning.  The hardware uses

 * these to specify the buffer size as an index into the SGE Free List Buffer

 * Size register array.  We also use bit 4, when the buffer has been unmapped

 * for DMA, but this is of course never sent to the hardware and is only used

 * to prevent double unmappings.  All of the above requires that the Free List

 * Buffers which we allocate have the bottom 5 bits free (0) -- i.e. are

 * 32-byte or or a power of 2 greater in alignment.  Since the SGE's minimal

 * Free List Buffer alignment is 32 bytes, this works out for us ...

 bottom five bits are special */

 bottom three bits are for buf sizes */

 buffer is not mapped */

	/*

	 * XXX We shouldn't depend on being able to use these indices.

	 * XXX Especially when some other Master PF has initialized the

	 * XXX adapter or we use the Firmware Configuration File.  We

	 * XXX should really search through the Host Buffer Size register

	 * XXX array for the appropriately sized buffer indices.

 small (PAGE_SIZE) page buffer */

 buffer large (FL_PG_ORDER) page buffer */

 small MTU buffer */

 large MTU buffer */

/**

 *	txq_avail - return the number of available slots in a Tx queue

 *	@q: the Tx queue

 *

 *	Returns the number of descriptors in a Tx queue available to write new

 *	packets.

/**

 *	fl_cap - return the capacity of a free-buffer list

 *	@fl: the FL

 *

 *	Returns the capacity of a free-buffer list.  The capacity is less than

 *	the size because one descriptor needs to be left unpopulated, otherwise

 *	HW will think the FL is empty.

 1 descriptor = 8 buffers */

/**

 *	fl_starving - return whether a Free List is starving.

 *	@adapter: pointer to the adapter

 *	@fl: the Free List

 *

 *	Tests specified Free List to see whether the number of buffers

 *	available to the hardware has falled below our "starvation"

 *	threshold.

/**

 *	deferred_unmap_destructor - unmap a packet when it is freed

 *	@skb: the packet

 *

 *	This is the packet destructor used for Tx packets that need to remain

 *	mapped until they are freed rather than until their Tx descriptors are

 *	freed.

/**

 *	free_tx_desc - reclaims Tx descriptors and their buffers

 *	@adap: the adapter

 *	@q: the Tx queue to reclaim descriptors from

 *	@n: the number of descriptors to reclaim

 *	@unmap: whether the buffers should be unmapped for DMA

 *

 *	Reclaims Tx descriptors from an SGE Tx queue and frees the associated

 *	Tx buffers.  Called with the Tx queue lock held.

 an SGL is present */

/*

 * Return the number of reclaimable descriptors in a Tx queue.

/**

 *	reclaim_completed_tx - reclaims completed TX Descriptors

 *	@adap: the adapter

 *	@q: the Tx queue to reclaim completed descriptors from

 *	@maxreclaim: the maximum number of TX Descriptors to reclaim or -1

 *	@unmap: whether the buffers should be unmapped for DMA

 *

 *	Reclaims Tx Descriptors that the SGE has indicated it has processed,

 *	and frees the associated buffers if possible.  If @max == -1, then

 *	we'll use a defaiult maximum.  Called with the TX Queue locked.

		/*

		 * Limit the amount of clean up work we do at a time to keep

		 * the Tx lock hold time O(1).

/**

 *	cxgb4_reclaim_completed_tx - reclaims completed Tx descriptors

 *	@adap: the adapter

 *	@q: the Tx queue to reclaim completed descriptors from

 *	@unmap: whether the buffers should be unmapped for DMA

 *

 *	Reclaims Tx descriptors that the SGE has indicated it has processed,

 *	and frees the associated buffers if possible.  Called with the Tx

 *	queue locked.

/**

 *	free_rx_bufs - free the Rx buffers on an SGE free list

 *	@adap: the adapter

 *	@q: the SGE free list to free buffers from

 *	@n: how many buffers to free

 *

 *	Release the next @n buffers on an SGE free-buffer Rx queue.   The

 *	buffers must be made inaccessible to HW before calling this function.

/**

 *	unmap_rx_buf - unmap the current Rx buffer on an SGE free list

 *	@adap: the adapter

 *	@q: the SGE free list

 *

 *	Unmap the current buffer on an SGE free-buffer Rx queue.   The

 *	buffer must be made inaccessible to HW before calling this function.

 *

 *	This is similar to @free_rx_bufs above but does not free the buffer.

 *	Do note that the FL still loses any further access to the buffer.

		/* Make sure all memory writes to the Free List queue are

		 * committed before we tell the hardware about them.

		/* If we don't have access to the new User Doorbell (T5+), use

		 * the old doorbell mechanism; otherwise use the new BAR2

		 * mechanism.

			/* This Write memory Barrier will force the write to

			 * the User Doorbell area to be flushed.

 includes size low bits */

/**

 *	refill_fl - refill an SGE Rx buffer ring

 *	@adap: the adapter

 *	@q: the ring to refill

 *	@n: the number of new buffers to allocate

 *	@gfp: the gfp flags for the allocations

 *

 *	(Re)populate an SGE free-buffer queue with up to @n new packet buffers,

 *	allocated with the supplied gfp flags.  The caller must assure that

 *	@n does not exceed the queue's capacity.  If afterwards the queue is

 *	found critically low mark it as starving in the bitmap of starving FLs.

 *

 *	Returns the number of buffers allocated.

	/*

	 * Prefer large buffers

 fall back to single pages */

 do not try small pages for this error */

/**

 *	alloc_ring - allocate resources for an SGE descriptor ring

 *	@dev: the PCI device's core device

 *	@nelem: the number of descriptors

 *	@elem_size: the size of each descriptor

 *	@sw_size: the size of the SW state associated with each ring element

 *	@phys: the physical address of the allocated ring

 *	@metadata: address of the array holding the SW state for the ring

 *	@stat_size: extra space in HW ring for status information

 *	@node: preferred node for memory allocations

 *

 *	Allocates resources for an SGE descriptor ring, such as Tx queues,

 *	free buffer lists, or response queues.  Each SGE ring requires

 *	space for its HW descriptors plus, optionally, space for the SW state

 *	associated with each HW entry (the metadata).  The function returns

 *	three values: the virtual address for the HW ring (the return value

 *	of the function), the bus address of the HW ring, and the address

 *	of the SW ring.

/**

 *	sgl_len - calculates the size of an SGL of the given capacity

 *	@n: the number of SGL entries

 *

 *	Calculates the number of flits needed for a scatter/gather list that

 *	can hold the given number of entries.

	/* A Direct Scatter Gather List uses 32-bit lengths and 64-bit PCI DMA

	 * addresses.  The DSGL Work Request starts off with a 32-bit DSGL

	 * ULPTX header, then Length0, then Address0, then, for 1 <= i <= N,

	 * repeated sequences of { Length[i], Length[i+1], Address[i],

	 * Address[i+1] } (this ensures that all addresses are on 64-bit

	 * boundaries).  If N is even, then Length[N+1] should be set to 0 and

	 * Address[N+1] is omitted.

	 *

	 * The following calculation incorporates all of the above.  It's

	 * somewhat hard to follow but, briefly: the "+2" accounts for the

	 * first two flits which include the DSGL header, Length0 and

	 * Address0; the "(3*(n-1))/2" covers the main body of list entries (3

	 * flits for every pair of the remaining N) +1 if (n-1) is odd; and

	 * finally the "+((n-1)&1)" adds the one remaining flit needed if

	 * (n-1) is odd ...

/**

 *	flits_to_desc - returns the num of Tx descriptors for the given flits

 *	@n: the number of flits

 *

 *	Returns the number of Tx descriptors needed for the supplied number

 *	of flits.

/**

 *	is_eth_imm - can an Ethernet packet be sent as immediate data?

 *	@skb: the packet

 *	@chip_ver: chip version

 *

 *	Returns whether an Ethernet packet is small enough to fit as

 *	immediate data. Return value corresponds to headroom required.

/**

 *	calc_tx_flits - calculate the number of flits for a packet Tx WR

 *	@skb: the packet

 *	@chip_ver: chip version

 *

 *	Returns the number of flits needed for a Tx WR for the given Ethernet

 *	packet, including the needed WR and CPL headers.

	/* If the skb is small enough, we can pump it out as a work request

	 * with only immediate data.  In that case we just have to have the

	 * TX Packet header plus the skb data in the Work Request.

	/* Otherwise, we're going to have to construct a Scatter gather list

	 * of the skb body and fragments.  We also include the flits necessary

	 * for the TX Packet Work Request and CPL.  We always have a firmware

	 * Write Header (incorporated as part of the cpl_tx_pkt_lso and

	 * cpl_tx_pkt structures), followed by either a TX Packet Write CPL

	 * message or, if we're doing a Large Send Offload, an LSO CPL message

	 * with an embedded TX Packet Write CPL message.

/**

 *	calc_tx_descs - calculate the number of Tx descriptors for a packet

 *	@skb: the packet

 *	@chip_ver: chip version

 *

 *	Returns the number of Tx descriptors needed for the given Ethernet

 *	packet, including the needed WR and CPL headers.

/**

 *	cxgb4_write_sgl - populate a scatter/gather list for a packet

 *	@skb: the packet

 *	@q: the Tx queue we are writing into

 *	@sgl: starting location for writing the SGL

 *	@end: points right after the end of the SGL

 *	@start: start offset into skb main-body data to include in the SGL

 *	@addr: the list of bus addresses for the SGL elements

 *

 *	Generates a gather list for the buffers that make up a packet.

 *	The caller must provide adequate space for the SGL that will be written.

 *	The SGL includes all of the packet's page fragments and the data in its

 *	main body except for the first @start bytes.  @sgl must be 16-byte

 *	aligned and within a Tx descriptor with available space.  @end points

 *	right after the end of the SGL but does not account for any potential

 *	wrap around, i.e., @end > @sgl.

	/*

	 * Most of the complexity below deals with the possibility we hit the

	 * end of the queue in the middle of writing the SGL.  For this case

	 * only we create the SGL in a temporary buffer and then copy it.

 0-pad to multiple of 16 */

/*	cxgb4_write_partial_sgl - populate SGL for partial packet

 *	@skb: the packet

 *	@q: the Tx queue we are writing into

 *	@sgl: starting location for writing the SGL

 *	@end: points right after the end of the SGL

 *	@addr: the list of bus addresses for the SGL elements

 *	@start: start offset in the SKB where partial data starts

 *	@len: length of data from @start to send out

 *

 *	This API will handle sending out partial data of a skb if required.

 *	Unlike cxgb4_write_sgl, @start can be any offset into the skb data,

 *	and @len will decide how much data after @start offset to send out.

	/* Fill the first SGL either from linear data or from partial

	 * frag based on @start.

 find the first frag */

	/* If the entire partial data fit in one SGL, then send it out

	 * now.

	/* Most of the complexity below deals with the possibility we hit the

	 * end of the queue in the middle of writing the SGL.  For this case

	 * only we create the SGL in a temporary buffer and then copy it.

	/* If the skb couldn't fit in first SGL completely, fill the

	 * rest of the frags in subsequent SGLs. Note that each SGL

	 * pair can store 2 frags.

	/* If we ended in an odd boundary, then set the second SGL's

	 * length in the pair to 0.

	/* Copy from temporary buffer to Tx ring, in case we hit the

	 * end of the queue in the middle of writing the SGL.

 0-pad to multiple of 16 */

/* This function copies 64 byte coalesced work request to

 * memory mapped BAR2 space. For coalesced WR SGE fetches

 * data from the FIFO instead of from Host.

/**

 *	cxgb4_ring_tx_db - check and potentially ring a Tx queue's doorbell

 *	@adap: the adapter

 *	@q: the Tx queue

 *	@n: number of new descriptors to give to HW

 *

 *	Ring the doorbel for a Tx queue.

	/* Make sure that all writes to the TX Descriptors are committed

	 * before we tell the hardware about them.

	/* If we don't have access to the new User Doorbell (T5+), use the old

	 * doorbell mechanism; otherwise use the new BAR2 mechanism.

		/* For T4 we need to participate in the Doorbell Recovery

		 * mechanism.

		/* T4 and later chips share the same PIDX field offset within

		 * the doorbell, but T5 and later shrank the field in order to

		 * gain a bit for Doorbell Priority.  The field was absurdly

		 * large in the first place (14 bits) so we just use the T5

		 * and later limits and warn if a Queue ID is too large.

		/* If we're only writing a single TX Descriptor and we can use

		 * Inferred QID registers, we can use the Write Combining

		 * Gather Buffer; otherwise we use the simple doorbell.

		/* This Write Memory Barrier will force the write to the User

		 * Doorbell area to be flushed.  This is needed to prevent

		 * writes on different CPUs for the same queue from hitting

		 * the adapter out of order.  This is required when some Work

		 * Requests take the Write Combine Gather Buffer path (user

		 * doorbell area offset [SGE_UDB_WCDOORBELL..+63]) and some

		 * take the traditional path where we simply increment the

		 * PIDX (User Doorbell area SGE_UDB_KDOORBELL) and have the

		 * hardware DMA read the actual Work Request.

/**

 *	cxgb4_inline_tx_skb - inline a packet's data into Tx descriptors

 *	@skb: the packet

 *	@q: the Tx queue where the packet will be inlined

 *	@pos: starting position in the Tx queue where to inline the packet

 *

 *	Inline a packet's contents directly into Tx descriptors, starting at

 *	the given position within the Tx DMA ring.

 *	Most of the complexity of this operation is dealing with wrap arounds

 *	in the middle of the packet we want to inline.

 0-pad to multiple of 16 */

 0-pad to multiple of 16 */

/*

 * Figure out what HW csum a packet wants and return the appropriate control

 * bits.

nocsum:			/*

			 * unknown protocol, disable HW csum

			 * and hope a bad packet is detected

		/*

		 * this doesn't work with extension headers

			/* This allows checksum offload for all encapsulated

			 * packets like GRE etc..

 FC CRC offload */

 CONFIG_CHELSIO_T4_FCOE */

/* Returns tunnel type if hardware supports offloading of the same.

 * It is called only for T5 and onwards.

 Get the tunnel header length */

/**

 *	t4_sge_eth_txq_egress_update - handle Ethernet TX Queue update

 *	@adap: the adapter

 *	@eq: the Ethernet TX Queue

 *	@maxreclaim: the maximum number of TX Descriptors to reclaim or -1

 *

 *	We're typically called here to update the state of an Ethernet TX

 *	Queue with respect to the hardware's progress in consuming the TX

 *	Work Requests that we've put on that Egress Queue.  This happens

 *	when we get Egress Queue Update messages and also prophylactically

 *	in regular timer-based Ethernet TX Queue maintenance.

 Reclaim pending completed TX Descriptors. */

	/* If the TX Queue is currently stopped and there's now more than half

	 * the queue available, restart it.  Otherwise bail out since the rest

	 * of what we want do here is with the possibility of shipping any

	 * currently buffered Coalesced TX Work Request.

	/* The chip min packet length is 10 octets but some firmware

	 * commands have a minimum packet length requirement. So, play

	 * safe and reject anything shorter than @min_pkt_len.

 Discard the packet if the length is greater than mtu */

/**

 *	cxgb4_eth_xmit - add a packet to an Ethernet Tx queue

 *	@skb: the packet

 *	@dev: the egress net device

 *

 *	Add a packet to an SGE Ethernet Tx queue.  Runs with softirqs disabled.

 CHELSIO_IPSEC_INLINE */

 CHELSIO_TLS_DEVICE */

 CONFIG_CHELSIO_T4_FCOE */

		/* After we're done injecting the Work Request for this

		 * packet, we'll be below our "stop threshold" so stop the TX

		 * Queue now and schedule a request for an SGE Egress Queue

		 * Update message. The queue will get started later on when

		 * the firmware processes this Work Request and sends us an

		 * Egress Queue Status Update message indicating that space

		 * has opened up.

			/* Driver is expected to compute partial checksum that

			 * does not include the IP Total Length.

 sgl start here */

		/* If current position is already at the end of the

		 * txq, reset the current to point to start of the queue

		 * and update the end ptr as well.

 CONFIG_CHELSIO_T4_FCOE */

 Constants ... */

	/* Egress Queue sizes, producer and consumer indices are all in units

	 * of Egress Context Units bytes.  Note that as far as the hardware is

	 * concerned, the free list is an Egress Queue (the host produces free

	 * buffers which the hardware consumes) and free list entries are

	 * 64-bit PCI DMA addresses.

/**

 *	t4vf_is_eth_imm - can an Ethernet packet be sent as immediate data?

 *	@skb: the packet

 *

 *	Returns whether an Ethernet packet is small enough to fit completely as

 *	immediate data.

	/* The VF Driver uses the FW_ETH_TX_PKT_VM_WR firmware Work Request

	 * which does not accommodate immediate data.  We could dike out all

	 * of the support code for immediate data but that would tie our hands

	 * too much if we ever want to enhace the firmware.  It would also

	 * create more differences between the PF and VF Drivers.

/**

 *	t4vf_calc_tx_flits - calculate the number of flits for a packet TX WR

 *	@skb: the packet

 *

 *	Returns the number of flits needed for a TX Work Request for the

 *	given Ethernet packet, including the needed WR and CPL headers.

	/* If the skb is small enough, we can pump it out as a work request

	 * with only immediate data.  In that case we just have to have the

	 * TX Packet header plus the skb data in the Work Request.

	/* Otherwise, we're going to have to construct a Scatter gather list

	 * of the skb body and fragments.  We also include the flits necessary

	 * for the TX Packet Work Request and CPL.  We always have a firmware

	 * Write Header (incorporated as part of the cpl_tx_pkt_lso and

	 * cpl_tx_pkt structures), followed by either a TX Packet Write CPL

	 * message or, if we're doing a Large Send Offload, an LSO CPL message

	 * with an embedded TX Packet Write CPL message.

/**

 *	cxgb4_vf_eth_xmit - add a packet to an Ethernet TX queue

 *	@skb: the packet

 *	@dev: the egress net device

 *

 *	Add a packet to an SGE Ethernet TX queue.  Runs with softirqs disabled.

	/* The chip minimum packet length is 10 octets but the firmware

	 * command that we are using requires that we copy the Ethernet header

	 * (including the VLAN tag) into the header so we reject anything

	 * smaller than that ...

 Figure out which TX Queue we're going to use. */

	/* Take this opportunity to reclaim any TX Descriptors whose DMA

	 * transfers have completed.

	/* Calculate the number of flits and TX Descriptors we're going to

	 * need along with how many TX Descriptors will be left over after

	 * we inject our Work Request.

		/* Not enough room for this packet's Work Request.  Stop the

		 * TX Queue and return a "busy" condition.  The queue will get

		 * started later on when the firmware informs us that space

		 * has opened up.

		/* We need to map the skb into PCI DMA space (because it can't

		 * be in-lined directly into the Work Request) and the mapping

		 * operation failed.  Record the error and drop the packet.

		/* After we're done injecting the Work Request for this

		 * packet, we'll be below our "stop threshold" so stop the TX

		 * Queue now and schedule a request for an SGE Egress Queue

		 * Update message.  The queue will get started later on when

		 * the firmware processes this Work Request and sends us an

		 * Egress Queue Status Update message indicating that space

		 * has opened up.

	/* Start filling in our Work Request.  Note that we do _not_ handle

	 * the WR Header wrapping around the TX Descriptor Ring.  If our

	 * maximum header size ever exceeds one TX Descriptor, we'll need to

	 * do something else here.

	/* If this is a Large Send Offload packet we'll put in an LSO CPL

	 * message with an encapsulated TX Packet CPL message.  Otherwise we

	 * just use a TX Packet CPL message.

 Fill in the LSO CPL message. */

		/* Set up TX Packet CPL pointer, control word and perform

		 * accounting.

		/* Set up TX Packet CPL pointer, control word and perform

		 * accounting.

	/* If there's a VLAN tag present, add that to the list of things to

	 * do in this Work Request.

 Fill in the TX Packet CPL message header. */

	/* Fill in the body of the TX Packet CPL message with either in-lined

	 * data or a Scatter/Gather List.

		/* In-line the packet's data and free the skb since we don't

		 * need it any longer.

		/* Write the skb's Scatter/Gather list into the TX Packet CPL

		 * message and retain a pointer to the skb so we can free it

		 * later when its DMA completes.  (We store the skb pointer

		 * in the Software Descriptor corresponding to the last TX

		 * Descriptor used by the Work Request.)

		 *

		 * The retained skb will be freed when the corresponding TX

		 * Descriptors are reclaimed after their DMAs complete.

		 * However, this could take quite a while since, in general,

		 * the hardware is set up to be lazy about sending DMA

		 * completion notifications to us and we mostly perform TX

		 * reclaims in the transmit routine.

		 *

		 * This is good for performamce but means that we rely on new

		 * TX packets arriving to run the destructors of completed

		 * packets, which open up space in their sockets' send queues.

		 * Sometimes we do not get such new packets causing TX to

		 * stall.  A single UDP transmitter is a good example of this

		 * situation.  We have a clean up timer that periodically

		 * reclaims completed packets but it doesn't run often enough

		 * (nor do we want it to) to prevent lengthy stalls.  A

		 * solution to this problem is to run the destructor early,

		 * after the packet is queued but before it's DMAd.  A con is

		 * that we lie to socket memory accounting, but the amount of

		 * extra memory is reasonable (limited by the number of TX

		 * descriptors), the packets do actually get freed quickly by

		 * new packets almost always, and for protocols like TCP that

		 * wait for acks to really free up the data the extra memory

		 * is even less.  On the positive side we run the destructors

		 * on the sending CPU rather than on a potentially different

		 * completing CPU, usually a good thing.

		 *

		 * Run the destructor before telling the DMA engine about the

		 * packet to make sure it doesn't complete and get freed

		 * prematurely.

		/* If the Work Request header was an exact multiple of our TX

		 * Descriptor length, then it's possible that the starting SGL

		 * pointer lines up exactly with the end of our TX Descriptor

		 * ring.  If that's the case, wrap around to the beginning

		 * here ...

	/* Advance our internal TX Queue state, tell the hardware about

	 * the new TX descriptors and return success.

	/* An error of some sort happened.  Free the TX skb and tell the

	 * OS that we've "dealt" with the packet ...

/**

 * reclaim_completed_tx_imm - reclaim completed control-queue Tx descs

 * @q: the SGE control Tx queue

 *

 * This is a variant of cxgb4_reclaim_completed_tx() that is used

 * for Tx queues that send only immediate data (presently just

 * the control queues) and	thus do not have any sk_buffs to release.

 Packet headers + WR + CPLs */

	/* If there are no descriptors left in hardware queues or no

	 * CPL credits left in software queues, then wait for them

	 * to come back and retry again. Note that we always request

	 * for credits update via interrupt for every half credits

	 * consumed. So, the interrupt will eventually restore the

	 * credits and invoke the Tx path again.

			/* If current position is already at the end of the

			 * txq, reset the current to point to start of the queue

			 * and update the end ptr as well.

	/* SKB is queued for processing until credits are available.

	 * So, call the destructor now and we'll free the skb later

	 * after it has been successfully transmitted.

/**

 * cxgb4_ethofld_send_flowc - Send ETHOFLD flowc request to bind eotid to tc.

 * @dev: netdevice

 * @eotid: ETHOFLD tid to bind/unbind

 * @tc: traffic class. If set to FW_SCHED_CLS_NONE, then unbinds the @eotid

 *

 * Send a FLOWC work request to bind an ETHOFLD TID to a traffic class.

 * If @tc is set to FW_SCHED_CLS_NONE, then the @eotid is unbound from

 * a traffic class.

 Don't stall caller when access to FW is lost */

	/* Free up any pending skbs to ensure there's room for

	 * termination FLOWC.

/**

 *	is_imm - check whether a packet can be sent as immediate data

 *	@skb: the packet

 *

 *	Returns true if a packet can be sent as a WR with immediate data.

/**

 *	ctrlq_check_stop - check if a control queue is full and should stop

 *	@q: the queue

 *	@wr: most recent WR written to the queue

 *

 *	Check if a control queue has become full and should be stopped.

 *	We clean up control queue descriptors very lazily, only when we are out.

 *	If the queue is still full after reclaiming any completed descriptors

 *	we suspend it and have the last WR wake it up.

 wait for the pkt to return */

/**

 *	ctrl_xmit - send a packet through an SGE control Tx queue

 *	@q: the control queue

 *	@skb: the packet

 *

 *	Send a packet through an SGE control Tx queue.  Packets sent through

 *	a control queue must fit entirely as immediate data.

 save for restart */

/**

 *	restart_ctrlq - restart a suspended control queue

 *	@t: pointer to the tasklet associated with this handler

 *

 *	Resumes transmission on a suspended Tx control queue.

 q should be empty */

 previously saved */

		/* Write descriptors and free skbs outside the lock to limit

		 * wait times.  q->full is still set so new skbs will be queued.

 suspended anew */

/**

 *	t4_mgmt_tx - send a management message

 *	@adap: the adapter

 *	@skb: the packet containing the management message

 *

 *	Send a management message through control queue 0.

/**

 *	is_ofld_imm - check whether a packet can be sent as immediate data

 *	@skb: the packet

 *

 *	Returns true if a packet can be sent as an offload WR with immediate

 *	data.

 *	FW_OFLD_TX_DATA_WR limits the payload to 255 bytes due to 8-bit field.

 *      However, FW_ULPTX_WR commands have a 256 byte immediate only

 *      payload limit.

/**

 *	calc_tx_flits_ofld - calculate # of flits for an offload packet

 *	@skb: the packet

 *

 *	Returns the number of flits needed for the given offload packet.

 *	These packets are already fully constructed and no additional headers

 *	will be added.

 headers */

/**

 *	txq_stop_maperr - stop a Tx queue due to I/O MMU exhaustion

 *	@q: the queue to stop

 *

 *	Mark a Tx queue stopped due to I/O MMU exhaustion and resulting

 *	inability to map packets.  A periodic timer attempts to restart

 *	queues so marked.

/**

 *	ofldtxq_stop - stop an offload Tx queue that has become full

 *	@q: the queue to stop

 *	@wr: the Work Request causing the queue to become full

 *

 *	Stops an offload Tx queue that has become full and modifies the packet

 *	being written to request a wakeup.

/**

 *	service_ofldq - service/restart a suspended offload queue

 *	@q: the offload queue

 *

 *	Services an offload Tx queue by moving packets from its Pending Send

 *	Queue to the Hardware TX ring.  The function starts and ends with the

 *	Send Queue locked, but drops the lock while putting the skb at the

 *	head of the Send Queue onto the Hardware TX Ring.  Dropping the lock

 *	allows more skbs to be added to the Send Queue by other threads.

 *	The packet being processed at the head of the Pending Send Queue is

 *	left on the queue in case we experience DMA Mapping errors, etc.

 *	and need to give up and restart later.

 *

 *	service_ofldq() can be thought of as a task which opportunistically

 *	uses other threads execution contexts.  We use the Offload Queue

 *	boolean "service_ofldq_running" to make sure that only one instance

 *	is ever running at a time ...

	/* If another thread is currently in service_ofldq() processing the

	 * Pending Send Queue then there's nothing to do. Otherwise, flag

	 * that we're doing the work and continue.  Examining/modifying

	 * the Offload Queue boolean "service_ofldq_running" must be done

	 * while holding the Pending Send Queue Lock.

		/* We drop the lock while we're working with the skb at the

		 * head of the Pending Send Queue.  This allows more skbs to

		 * be added to the Pending Send Queue while we're working on

		 * this one.  We don't need to lock to guard the TX Ring

		 * updates because only one thread of execution is ever

		 * allowed into service_ofldq() at a time.

 previously saved */

			/* The WR headers  may not fit within one descriptor.

			 * So we need to deal with wrap-around here.

			/* If current position is already at the end of the

			 * ofld queue, reset the current to point to

			 * start of the queue and update the end ptr as well.

		/* Reacquire the Pending Send Queue Lock so we can unlink the

		 * skb we've just successfully transferred to the TX Ring and

		 * loop for the next skb which may be at the head of the

		 * Pending Send Queue.

	/*Indicate that no thread is processing the Pending Send Queue

	 * currently.

/**

 *	ofld_xmit - send a packet through an offload queue

 *	@q: the Tx offload queue

 *	@skb: the packet

 *

 *	Send an offload packet through an SGE offload queue.

 save for restart */

	/* Queue the new skb onto the Offload Queue's Pending Send Queue.  If

	 * that results in this new skb being the only one on the queue, start

	 * servicing it.  If there are other skbs already on the list, then

	 * either the queue is currently being processed or it's been stopped

	 * for some reason and it'll be restarted at a later time.  Restart

	 * paths are triggered by events like experiencing a DMA Mapping Error

	 * or filling the Hardware TX Ring.

/**

 *	restart_ofldq - restart a suspended offload queue

 *	@t: pointer to the tasklet associated with this handler

 *

 *	Resumes transmission on a suspended Tx offload queue.

 the queue actually is completely empty now */

/**

 *	skb_txq - return the Tx queue an offload packet should use

 *	@skb: the packet

 *

 *	Returns the Tx queue an offload packet should use as indicated by bits

 *	1-15 in the packet's queue_mapping.

/**

 *	is_ctrl_pkt - return whether an offload packet is a control packet

 *	@skb: the packet

 *

 *	Returns whether an offload packet should use an OFLD or a CTRL

 *	Tx queue as indicated by bit 0 in the packet's queue_mapping.

 Single ctrl queue is a requirement for LE workaround path */

/**

 *	t4_ofld_send - send an offload packet

 *	@adap: the adapter

 *	@skb: the packet

 *

 *	Sends an offload packet.  We use the packet queue_mapping to select the

 *	appropriate Tx queue as follows: bit 0 indicates whether the packet

 *	should be sent as regular or control, bits 1-15 select the queue.

/**

 *	cxgb4_ofld_send - send an offload packet

 *	@dev: the net device

 *	@skb: the packet

 *

 *	Sends an offload packet.  This is an exported version of @t4_ofld_send,

 *	intended for ULDs.

 0-pad to multiple of 16 */

/**

 *      ofld_xmit_direct - copy a WR into offload queue

 *      @q: the Tx offload queue

 *      @src: location of WR

 *      @len: WR length

 *

 *      Copy an immediate WR into an uncontended SGE offload queue.

 Use the lower limit as the cut-off */

	/* Don't return NET_XMIT_CN here as the current

	 * implementation doesn't queue the request

	 * using an skb when the following conditions not met

 ofldtxq_stop modifies WR header in-situ */

/**

 *	t4_crypto_send - send crypto packet

 *	@adap: the adapter

 *	@skb: the packet

 *

 *	Sends crypto packet.  We use the packet queue_mapping to select the

 *	appropriate Tx queue as follows: bit 0 indicates whether the packet

 *	should be sent as regular or control, bits 1-15 select the queue.

/**

 *	cxgb4_crypto_send - send crypto packet

 *	@dev: the net device

 *	@skb: the packet

 *

 *	Sends crypto packet.  This is an exported version of @t4_crypto_send,

 *	intended for ULDs.

 usually there's just one frag */

 get a reference to the last page, we don't own it */

/**

 *	cxgb4_pktgl_to_skb - build an sk_buff from a packet gather list

 *	@gl: the gather list

 *	@skb_len: size of sk_buff main body if it carries fragments

 *	@pull_len: amount of data to move to the sk_buff's main body

 *

 *	Builds an sk_buff from the given packet gather list.  Returns the

 *	sk_buff or %NULL if sk_buff allocation failed.

	/*

	 * Below we rely on RX_COPY_THRES being less than the smallest Rx buffer

	 * size, which is expected since buffers are at least PAGE_SIZEd.

	 * In this case packets up to RX_COPY_THRES have only one fragment.

/**

 *	t4_pktgl_free - free a packet gather list

 *	@gl: the gather list

 *

 *	Releases the pages of a packet gather list.  We do not own the last

 *	page on the list and do not free it.

/*

 * Process an MPS trace packet.  Give it an unused protocol number so it won't

 * be delivered to anyone and send it to the stack for capture.

/**

 * cxgb4_sgetim_to_hwtstamp - convert sge time stamp to hw time stamp

 * @adap: the adapter

 * @hwtstamps: time stamp structure to update

 * @sgetstamp: 60bit iqe timestamp

 *

 * Every ingress queue entry has the 60-bit timestamp, convert that timestamp

 * which is in Core Clock ticks into ktime_t and assign it

/**

 *     t4_systim_to_hwstamp - read hardware time stamp

 *     @adapter: the adapter

 *     @skb: the packet

 *

 *     Read Time Stamp from MPS packet and insert in skb which

 *     is forwarded to PTP application

/**

 *     t4_rx_hststamp - Recv PTP Event Message

 *     @adapter: the adapter

 *     @rsp: the response queue descriptor holding the RX_PKT message

 *     @rxq: the response queue holding the RX_PKT message

 *     @skb: the packet

 *

 *     PTP enabled and MPS packet, read HW timestamp

/**

 *      t4_tx_hststamp - Loopback PTP Transmit Event Message

 *      @adapter: the adapter

 *      @skb: the packet

 *      @dev: the ingress net device

 *

 *      Read hardware timestamp for the loopback PTP Tx event message

/**

 *	t4_tx_completion_handler - handle CPL_SGE_EGR_UPDATE messages

 *	@rspq: Ethernet RX Response Queue associated with Ethernet TX Queue

 *	@rsp: Response Entry pointer into Response Queue

 *	@gl: Gather List pointer

 *

 *	For adapters which support the SGE Doorbell Queue Timer facility,

 *	we configure the Ethernet TX Queues to send CIDX Updates to the

 *	Associated Ethernet RX Response Queue with CPL_SGE_EGR_UPDATE

 *	messages.  This adds a small load to PCIe Link RX bandwidth and,

 *	potentially, higher CPU Interrupt load, but allows us to respond

 *	much more quickly to the CIDX Updates.  This is important for

 *	Upper Layer Software which isn't willing to have a large amount

 *	of TX Data outstanding before receiving DMA Completions.

 skip RSS header */

	/* FW can send EGR_UPDATEs encapsulated in a CPL_FW4_MSG.

	/* We've got the Hardware Consumer Index Update in the Egress Update

	 * message. These Egress Update messages will be our sole CIDX Updates

	 * we get since we don't want to chew up PCIe bandwidth for both Ingress

	 * Messages and Status Page writes.  However, The code which manages

	 * reclaiming successfully DMA'ed TX Work Requests uses the CIDX value

	 * stored in the Status Page at the end of the TX Queue.  It's easiest

	 * to simply copy the CIDX Update value from the Egress Update message

	 * to the Status Page.  Also note that no Endian issues need to be

	 * considered here since both are Big Endian and we're just copying

	 * bytes consistently ...

/**

 *	t4_ethrx_handler - process an ingress ethernet packet

 *	@q: the response queue that received the packet

 *	@rsp: the response queue descriptor holding the RX_PKT message

 *	@si: the gather list of packet fragments

 *

 *	Process an ingress ethernet packet and deliver it to the stack.

	/* If we're looking at TX Queue CIDX Update, handle that separately

	 * and return.

 Compressed error vector is enabled for T6 only */

 Handle PTP Event Rx packet */

 remove ethernet header pad */

 Handle the PTP Event Tx Loopback packet */

 CONFIG_CHELSIO_T4_FCOE */

/**

 *	restore_rx_bufs - put back a packet's Rx buffers

 *	@si: the packet gather list

 *	@q: the SGE free list

 *	@frags: number of FL buffers to restore

 *

 *	Puts back on an FL the Rx buffers associated with @si.  The buffers

 *	have already been unmapped and are left unmapped, we mark them so to

 *	prevent further unmapping attempts.

 *

 *	This function undoes a series of @unmap_rx_buf calls when we find out

 *	that the current packet can't be processed right away afterall and we

 *	need to come back to it later.  This is a very rare event and there's

 *	no effort to make this particularly efficient.

/**

 *	is_new_response - check if a response is newly written

 *	@r: the response descriptor

 *	@q: the response queue

 *

 *	Returns true if a response descriptor contains a yet unprocessed

 *	response.

/**

 *	rspq_next - advance to the next entry in a response queue

 *	@q: the queue

 *

 *	Updates the state of a response queue to advance it to the next entry.

/**

 *	process_responses - process responses from an SGE response queue

 *	@q: the ingress queue to process

 *	@budget: how many responses can be processed in this round

 *

 *	Process responses from an SGE response queue up to the supplied budget.

 *	Responses include received packets as well as control messages from FW

 *	or HW.

 *

 *	Additionally choose the interrupt holdoff time for the next interrupt

 *	on this queue.  If the system is under memory shortage use a fairly

 *	long delay to help recovery.

 gather packet fragments */

			/*

			 * Last buffer remains mapped so explicitly make it

			 * coherent for CPU access.

 couldn't process descriptor, back off for recovery */

/**

 *	napi_rx_handler - the NAPI handler for Rx processing

 *	@napi: the napi instance

 *	@budget: how many packets we can process in this round

 *

 *	Handler for new data events when using NAPI.  This does not need any

 *	locking or protection from interrupts as data interrupts are off at

 *	this point and other adapter interrupts do not interfere (the latter

 *	in not a concern at all with MSI-X as non-data interrupts then have

 *	a separate handler).

	/* If we don't have access to the new User GTS (T5+), use the old

	 * doorbell mechanism; otherwise use the new BAR2 mechanism.

	/* There may be some packets waiting for completions. So,

	 * attempt to send these packets now.

/* cxgb4_ethofld_rx_handler - Process ETHOFLD Tx completions

 * @q: the response queue that received the packet

 * @rsp: the response queue descriptor holding the CPL message

 * @si: the gather list of packet fragments

 *

 * Process a ETHOFLD Tx completion. Increment the cidx here, but

 * free up the descriptors in a tasklet later.

 skip RSS header */

		/* Schedule a tasklet to reclaim SKBs and restart ETHOFLD Tx,

		 * if there were packets waiting for completion.

/*

 * The MSI-X interrupt handler for an SGE response queue.

/*

 * Process the indirect interrupt entries in the interrupt queue and kick off

 * NAPI for each queue that has generated an entry.

	/* If we don't have access to the new User GTS (T5+), use the old

	 * doorbell mechanism; otherwise use the new BAR2 mechanism.

/*

 * The MSI interrupt handler, which handles data events from SGE response queues

 * as well as error and other async events as they all use the same MSI vector.

/*

 * Interrupt handler for legacy INTx interrupts.

 * Handles data events from SGE response queues as well as error and other

 * async events as they all use the same interrupt line.

 probably shared interrupt */

/**

 *	t4_intr_handler - select the top-level interrupt handler

 *	@adap: the adapter

 *

 *	Selects the top-level interrupt handler based on the type of interrupts

 *	(MSI-X, MSI, or INTx).

	/* The remainder of the SGE RX Timer Callback routine is dedicated to

	 * global Master PF activities like checking for chip ingress stalls,

	 * etc.

		/* If we found too many reclaimable packets schedule a timer

		 * in the near future to continue where we left off.

		/* We reclaimed all reclaimable TX Descriptors, so reschedule

		 * at the normal period.

/**

 *	bar2_address - return the BAR2 address for an SGE Queue's Registers

 *	@adapter: the adapter

 *	@qid: the SGE Queue ID

 *	@qtype: the SGE Queue Type (Egress or Ingress)

 *	@pbar2_qid: BAR2 Queue ID or 0 for Queue ID inferred SGE Queues

 *

 *	Returns the BAR2 address for the SGE Queue Registers associated with

 *	@qid.  If BAR2 SGE Registers aren't available, returns NULL.  Also

 *	returns the BAR2 Queue ID to be used with writes to the BAR2 SGE

 *	Queue Registers.  If the BAR2 Queue ID is 0, then "Inferred Queue ID"

 *	Registers are supported (e.g. the Write Combining Doorbell Buffer).

/* @intr_idx: MSI/MSI-X vector if >=0, -(absolute qid + 1) if < 0

 * @cong: < 0 -> no congestion feedback, >= 0 -> congestion channel map

 Size needs to be multiple of 16, including status entry. */

		/* Allocate the ring for the hardware free list (with space

		 * for its status page) along with the associated software

		 * descriptor ring.  The free list size needs to be a multiple

		 * of the Egress Queue Unit and at least 2 Egress Units larger

		 * than the SGE's Egress Congrestion Threshold

		 * (fl_starve_thres - 1).

		/* In T6, for egress queue type FL there is internal overhead

		 * of 16B for header going into FLM module.  Hence the maximum

		 * allowed burst size is 448 bytes.  For T4/T5, the hardware

		 * doesn't coalesce fetch requests if more than 64 bytes of

		 * Free List pointers are provided, so we use a 128-byte Fetch

		 * Burst Minimum there (T6 implements coalescing so we can use

		 * the smaller 64-byte value there).

 subtract status entry */

 set offset to -1 to distinguish ingress queues without FL */

		/* Note, we must initialize the BAR2 Free List User Doorbell

		 * information before refilling the Free List!

	/* For T5 and later we attempt to set up the Congestion Manager values

	 * of the new RX Ethernet Queue.  This should really be handled by

	 * firmware because it's more complex than any host driver wants to

	 * get involved with and it's different per chip and this is almost

	 * certainly wrong.  Firmware would be wrong as well, but it would be

	 * a lot easier to fix in one place ...  For now we do something very

	 * simple (and hopefully less wrong).

/**

 *	t4_sge_alloc_eth_txq - allocate an Ethernet TX Queue

 *	@adap: the adapter

 *	@txq: the SGE Ethernet TX Queue to initialize

 *	@dev: the Linux Network Device

 *	@netdevq: the corresponding Linux TX Queue

 *	@iqid: the Ingress Queue to which to deliver CIDX Update messages

 *	@dbqt: whether this TX Queue will use the SGE Doorbell Queue Timers

 Add status entries */

	/* For TX Ethernet Queues using the SGE Doorbell Queue Timer

	 * mechanism, we use Ingress Queue messages for Hardware Consumer

	 * Index Updates on the TX Queue.  Otherwise we have the Hardware

	 * write the CIDX Updates into the Status Page at the end of the

	 * TX Queue.

 Note that the CIDX Flush Threshold should match MAX_TX_RECLAIM. */

	/* If we're using the SGE Doorbell Queue Timer mechanism, pass in the

	 * currently configured Timer Index.  THis can be changed later via an

	 * ethtool -C tx-usecs {Timer Val} command.  Note that the SGE

	 * Doorbell Queue mode is currently automatically enabled in the

	 * Firmware by setting either AUTOEQUEQE or AUTOEQUIQE ...

 Add status entries */

 Add status entries */

/**

 *      t4_free_ofld_rxqs - free a block of consecutive Rx queues

 *      @adap: the adapter

 *      @n: number of queues

 *      @q: pointer to first queue

 *

 *      Release the resources of a consecutive block of offload Rx queues.

/**

 *	t4_free_sge_resources - free SGE resources

 *	@adap: the adapter

 *

 *	Frees resources used by the SGE queue sets.

 stop all Rx queues in order to start them draining */

 clean up Ethernet Tx/Rx queues */

 clean up control Tx queues */

 clear the reverse egress queue map */

/**

 *	t4_sge_stop - disable SGE operation

 *	@adap: the adapter

 *

 *	Stop tasklets and timers associated with the DMA engine.  Note that

 *	this is effective only if measures have been taken to disable any HW

 *	events that may restart them.

/**

 *	t4_sge_init_soft - grab core SGE values needed by SGE code

 *	@adap: the adapter

 *

 *	We need to grab the SGE operating parameters that we need to have

 *	in order to do our job and make sure we can live with them.

	/*

	 * Verify that CPL messages are going to the Ingress Queue for

	 * process_responses() and that only packet data is going to the

	 * Free Lists.

	/*

	 * Validate the Host Buffer Register Array indices that we want to

	 * use ...

	 *

	 * XXX Note that we should really read through the Host Buffer Size

	 * XXX register array and find the indices of the Buffer Sizes which

	 * XXX meet our needs!

	/* We only bother using the Large Page logic if the Large Page Buffer

	 * is larger than our Page Size Buffer.

	/* The Page Size Buffer must be exactly equal to our Page Size and the

	 * Large Page Size Buffer should be 0 (per above) or a power of 2.

	/*

	 * Retrieve our RX interrupt holdoff timer values and counter

	 * threshold values from the SGE parameters.

/**

 *     t4_sge_init - initialize SGE

 *     @adap: the adapter

 *

 *     Perform low-level SGE code initialization needed every time after a

 *     chip reset.

	/*

	 * Ingress Padding Boundary and Egress Status Page Size are set up by

	 * t4_fixup_host_params().

	/*

	 * A FL with <= fl_starve_thres buffers is starving and a periodic

	 * timer will attempt to refill it.  This needs to be larger than the

	 * SGE's Egress Congestion Threshold.  If it isn't, then we can get

	 * stuck waiting for new packets while the SGE is waiting for us to

	 * give it more Free List entries.  (Note that the SGE's Egress

	 * Congestion Threshold is in units of 2 Free List pointers.) For T4,

	 * there was only a single field to control this.  For T5 there's the

	 * original field which now only applies to Unpacked Mode Free List

	 * buffers and a new field which only applies to Packed Mode Free List

	 * buffers.

	/* Set up timers used for recuring callbacks to process RX and TX

	 * administrative tasks.

 SPDX-License-Identifier: GPL-2.0-only

 Copyright (C) 2019 Chelsio Communications.  All rights reserved. */

 Convert from Mbps to bps */

 Convert bytes per second to bits per second */

 Convert from bytes per second to Kbps */

	/* Get a free filter entry TID, where we can insert this new

	 * rule. Only insert rule if its prio doesn't conflict with

	 * existing rules.

		/* All the filter types of this matchall rule save the

		 * same cookie. So, checking for the first one is

		 * enough.

/*

 * cxgb4_uld.c:Chelsio Upper Layer Driver Interface for T4/T5/T6 SGE management

 *

 * Copyright (c) 2016 Chelsio Communications, Inc. All rights reserved.

 *

 * This software is available to you under a choice of one of two

 * licenses.  You may choose to be licensed under the terms of the GNU

 * General Public License (GPL) Version 2, available from the file

 * COPYING in the main directory of this source tree, or the

 * OpenIB.org BSD license below:

 *

 *     Redistribution and use in source and binary forms, with or

 *     without modification, are permitted provided that the following

 *     conditions are met:

 *

 *      - Redistributions of source code must retain the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer.

 *

 *      - Redistributions in binary form must reproduce the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer in the documentation and/or other materials

 *        provided with the distribution.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS

 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN

 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN

 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

 *

 *  Written by: Atul Gupta (atul.gupta@chelsio.com)

 *  Written by: Hariprasad Shenai (hariprasad@chelsio.com)

 Flush the aggregated lro sessions */

/**

 *	uldrx_handler - response queue handler for ULD queues

 *	@q: the response queue that received the packet

 *	@rsp: the response queue descriptor holding the offload message

 *	@gl: the gather list of packet fragments

 *

 *	Deliver an ingress offload packet to a ULD.  All processing is done by

 *	the ULD, we just maintain statistics.

 FW can send CPLs encapsulated in a CPL_FW4_MSG */

 start allocation of concentrator queues */

 Tell uP to route control queue completions to rdma rspq */

 total rxq's */

 This function should be called with uld_mutex taken. */

 MODQ_REQ_MAP sets queues 0-3 to chan 0-3 */

/* cxgb4_set_ktls_feature: request FW to enable/disable ktls settings.

 * @adap: adapter info

 * @enable: 1 to enable / 0 to disable ktls settings.

			/* At this moment if ULD connection are up means, other

			 * ULD is/are already active, return failure.

 ktls settings already up, just increment refcount. */

 return failure if refcount is already 0. */

		/* decrement refcount and test, if 0, disable ktls feature,

		 * else return command success.

/* cxgb4_register_uld - register an upper-layer driver

 * @type: the ULD type

 * @p: the ULD methods

 *

 * Registers an upper-layer driver with this driver and notifies the ULD

 * about any presently available devices that support its type.

/**

 *	cxgb4_unregister_uld - unregister an upper-layer driver

 *	@type: the ULD type

 *

 *	Unregisters an existing upper-layer driver.

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  Copyright (C) 2017 Chelsio Communications.  All rights reserved.

 If compression is enabled, a smaller destination buffer is enough */

 Log error and continue with next entity */

 Zlib available.  So, use zlib deflate */

 Ignore error and continue without compression. */

/*

 * This file is part of the Chelsio T4 Ethernet driver for Linux.

 *

 * Copyright (c) 2003-2016 Chelsio Communications, Inc. All rights reserved.

 *

 * This software is available to you under a choice of one of two

 * licenses.  You may choose to be licensed under the terms of the GNU

 * General Public License (GPL) Version 2, available from the file

 * COPYING in the main directory of this source tree, or the

 * OpenIB.org BSD license below:

 *

 *     Redistribution and use in source and binary forms, with or

 *     without modification, are permitted provided that the following

 *     conditions are met:

 *

 *      - Redistributions of source code must retain the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer.

 *

 *      - Redistributions in binary form must reproduce the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer in the documentation and/or other materials

 *        provided with the distribution.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS

 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN

 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN

 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

/* Macros needed to support the PCI Device ID Table ...

/* Include PCI Device IDs for both PF4 and PF0-3 so our PCI probe() routine is

 * called for both.

/*

 * The driver uses the best interrupt scheme available on a platform in the

 * order MSI-X, MSI, legacy INTx interrupts.  This parameter determines which

 * of these schemes the driver may consider as follows:

 *

 * msi = 2: choose from among all three options

 * msi = 1: only consider MSI and INTx interrupts

 * msi = 0: force INTx interrupts

/*

 * Normally we tell the chip to deliver Ingress Packets into our DMA buffers

 * offset by 2 bytes in order to have the IP headers line up on 4-byte

 * boundaries.  This is a requirement for many architectures which will throw

 * a machine check fault if an attempt is made to access one of the 4-byte IP

 * header fields on a non-4-byte boundary.  And it's a major performance issue

 * even on some architectures which allow it like some implementations of the

 * x86 ISA.  However, some architectures don't mind this and for some very

 * edge-case performance sensitive applications (like forwarding large volumes

 * of small packets), setting this DMA offset to 0 will decrease the number of

 * PCI-E Bus transfers enough to measurably affect performance.

/* TX Queue select used to determine what algorithm to use for selecting TX

 * queue. Select between the kernel provided function (select_queue=0) or user

 * cxgb_select_queue function (select_queue=1)

 *

 * Default: select_queue=0

 Set up/tear down Data Center Bridging Priority mapping for a net device. */

	/* We use a simple mapping of Port TX Queue Index to DCB

	 * Priority when we're enabling DCB.

		/* Since we can be called while atomic (from "interrupt

		 * level") we need to issue the Set Parameters Commannd

		 * without sleeping (timeout < 0).

 CONFIG_CHELSIO_T4_DCB */

 Skip changes from disabled ports. */

 CONFIG_CHELSIO_T4_DCB */

	/* If the interface is running, then we'll need any "sticky" Link

	 * Parameters redone with a new Transceiver Module.

 10 == 640 entry threshold */

/*

 * usecs to sleep while draining the dbfifo

 Calculate the hash vector for the updated list and program it */

	/* idx stores the index of allocated filters,

	 * its size should be modified based on the number of

	 * MAC addresses that we allocate filters for

	/* if hash != 0, then add the addr to hash addr list

	 * so on the end we will calculate the hash for the

	 * list and program it

	/* If the MAC address to be removed is in the hash addr

	 * list, delete it from the list and update hash vector

/*

 * Set Rx properties of a port, such as promiscruity, address filters, and MTU.

 * If @mtu is -1 it is left unchanged.

/**

 *	cxgb4_change_mac - Update match filter for a MAC address.

 *	@pi: the port_info

 *	@viid: the VI id

 *	@tcam_idx: TCAM index of existing filter for old value of MAC address,

 *		   or -1

 *	@addr: the new MAC address value

 *	@persist: whether a new MAC allocation should be persistent

 *	@smt_idx: the destination to store the new SMT index.

 *

 *	Modifies an MPS filter and sets it to the new MAC address if

 *	@tcam_idx >= 0, or adds the MAC address to a new filter if

 *	@tcam_idx < 0. In the latter case the address is added persistently

 *	if @persist is %true.

 *	Addresses are programmed to hash region, if tcam runs out of entries.

 *

 We ran out of TCAM entries. try programming hash region. */

		/* If the MAC address to be updated is in the hash addr

		 * list, update it from the list

/*

 *	link_start - enable a port

 *	@dev: the port to enable

 *

 *	Performs the MAC and PHY actions needed to enable a port.

	/*

	 * We do not set address filters and promiscuity here, the stack does

	 * that step explicitly.

 Handle a Data Center Bridging update message from the firmware. */

	/* If the DCB has become enabled or disabled on the port then we're

	 * going to need to set up/tear down DCB Priority parameters for the

	 * TX Queues associated with the port.

 CONFIG_CHELSIO_T4_DCB */

/* Response queue handler for the FW event queue.

 skip RSS header */

	/* FW can send EGR_UPDATEs encapsulated in a CPL_FW4_MSG.

/*

 * Interrupt handler for non-data events used with MSI-X.

	/* Driver sends FW_PARAMS_PARAM_DEV_PPOD_EDRAM read command to check

	 * if firmware supports ppod edram feature or not. If firmware

	 * returns 1, then driver can enable this feature by sending

	 * FW_PARAMS_PARAM_DEV_PPOD_EDRAM write command with value 1 to

	 * enable ppod edram feature.

	/* Enable HP filter region. Older fw will fail this request and

	 * it is fine.

	/* An error means FW doesn't know about HP filter support,

	 * it's not a problem, don't return an error.

	/* If Tunnel All Lookup isn't specified in the global RSS

	 * Configuration, then we need to specify a default Ingress

	 * Queue for any ingress packets which aren't hashed.  We'll

	 * use our first ingress queue ...

/**

 *	cxgb4_write_rss - write the RSS table for a given port

 *	@pi: the port

 *	@queues: array of queue indices for RSS

 *

 *	Sets up the portion of the HW RSS table for the port's VI to distribute

 *	packets to the Rx queues in @queues.

 *	Should never be called before setting up sge eth rx queues

 map the queue indices to queue ids */

/**

 *	setup_rss - configure RSS

 *	@adap: the adapter

 *

 *	Sets up RSS for each port.

 Fill default values with equal distribution */

/*

 * Return the channel of the ingress queue with the given qid.

/*

 * Wait until all NAPI handlers are descheduled.

 Disable interrupt and napi handler */

 0-increment GTS to start the timer and enable interrupts */

/*

 * Enable NAPI scheduling and interrupt generation for all Rx queues.

 Request MSI-X vector for non-data interrupt */

/**

 *	setup_sge_queues - configure SGE Tx/Rx/response queues

 *	@adap: the adapter

 *

 *	Determines how many sets of SGE queues to use and initializes them.

 *	We support multiple queue sets per port if we have MSI-X, otherwise

 *	just one queue set per port.

		/* Note that cmplqid below is 0 if we don't

		 * have RDMA queues, and that's the right value.

	/* If a Data Center Bridging has been successfully negotiated on this

	 * link then we'll use the skb's priority to map it to a TX Queue.

	 * The skb's priority is determined via the VLAN Tag Priority Code

	 * Point field.

 CONFIG_CHELSIO_T4_FCOE */

 CONFIG_CHELSIO_T4_DCB */

 Send unsupported traffic pattern to normal NIC queues. */

/**

 *	cxgb4_set_rspq_intr_params - set a queue's interrupt holdoff parameters

 *	@q: the Rx queue

 *	@us: the hold-off time in us, or 0 to disable timer

 *	@cnt: the hold-off packet count, or 0 to disable counter

 *

 *	Sets an Rx queue's interrupt hold-off time and packet count.  At least

 *	one of the two needs to be enabled for the queue to generate interrupts.

 the queue has already been created, update it */

 Allocate Mirror Rxqs */

 Setup MSI-X vectors for Mirror Rxqs */

 Start NAPI for Mirror Rxqs */

 Setup RSS for Mirror Rxqs */

	/* Mirror VIs can be created dynamically after stack had

	 * already setup Rx modes like MTU, promisc, allmulti, etc.

	 * on main VI. So, parse what the stack had setup on the

	 * main VI and update the same on the mirror VI.

	/* Enable replication bit for the device's MAC address

	 * in MPS TCAM, so that the packets for the main VI are

	 * replicated to mirror VI.

	/* Enabling a Virtual Interface can result in an interrupt

	 * during the processing of the VI Enable command and, in some

	 * paths, result in an attempt to issue another command in the

	 * interrupt context. Thus, we disable interrupts during the

	 * course of the VI Enable command ...

/*

 * upper-layer driver support

/*

 * Allocate an active-open TID and set it to the supplied value.

/*

 * Release an active-open TID.

/*

 * Allocate a server TID and set it to the supplied value.

		/* IPv6 requires max of 520 bits or 16 cells in TCAM

		 * This is equivalent to 4 TIDs. With CLIP enabled it

		 * needs 2 TIDs.

/* Allocate a server filter TID and set it to the supplied value.

/* Release a server TID.

 Is it a server filter TID? */

/*

 * Populate a TID_RELEASE WR.  Caller must properly size the skb.

/*

 * Queue a TID release request and if necessary schedule a work queue to

 * process it.

 Low 2 bits encode the Tx channel number */

/*

 * Process the list of pending TID release requests.

/*

 * Release a TID and inform HW.  If we are unable to allocate the release

 * message we defer to a work queue.

/*

 * Allocate and initialize the TID tables.  Returns 0 on success.

 Setup the free list for atid_tab and clear the stid bitmap. */

 Reserve stid 0 for T4/T5 adapters */

/**

 *	cxgb4_create_server - create an IP server

 *	@dev: the device

 *	@stid: the server TID

 *	@sip: local IP address to bind server to

 *	@sport: the server's TCP port

 *	@vlan: the VLAN header information

 *	@queue: queue to direct messages from this server to

 *

 *	Create an IP server for the given port and address.

 *	Returns <0 on error and one of the %NET_XMIT_* values on success.

/*	cxgb4_create_server6 - create an IPv6 server

 *	@dev: the device

 *	@stid: the server TID

 *	@sip: local IPv6 address to bind server to

 *	@sport: the server's TCP port

 *	@queue: queue to direct messages from this server to

 *

 *	Create an IPv6 server for the given port and address.

 *	Returns <0 on error and one of the %NET_XMIT_* values on success.

/**

 *	cxgb4_best_mtu - find the entry in the MTU table closest to an MTU

 *	@mtus: the HW MTU table

 *	@mtu: the target MTU

 *	@idx: index of selected entry in the MTU table

 *

 *	Returns the index and the value in the HW MTU table that is closest to

 *	but does not exceed @mtu, unless @mtu is smaller than any value in the

 *	table, in which case that smallest available value is selected.

/**

 *     cxgb4_best_aligned_mtu - find best MTU, [hopefully] data size aligned

 *     @mtus: the HW MTU table

 *     @header_size: Header Size

 *     @data_size_max: maximum Data Segment Size

 *     @data_size_align: desired Data Segment Size Alignment (2^N)

 *     @mtu_idxp: HW MTU Table Index return value pointer (possibly NULL)

 *

 *     Similar to cxgb4_best_mtu() but instead of searching the Hardware

 *     MTU Table based solely on a Maximum MTU parameter, we break that

 *     parameter up into a Header Size and Maximum Data Segment Size, and

 *     provide a desired Data Segment Size Alignment.  If we find an MTU in

 *     the Hardware MTU Table which will result in a Data Segment Size with

 *     the requested alignment _and_ that MTU isn't "too far" from the

 *     closest MTU, then we'll return that rather than the closest MTU.

	/* Scan the MTU Table till we find an MTU which is larger than our

	 * Maximum MTU or we reach the end of the table.  Along the way,

	 * record the last MTU found, if any, which will result in a Data

	 * Segment Length matching the requested alignment.

		/* If this MTU minus the Header Size would result in a

		 * Data Segment Size of the desired alignment, remember it.

		/* If we're not at the end of the Hardware MTU Table and the

		 * next element is larger than our Maximum MTU, drop out of

		 * the loop.

	/* If we fell out of the loop because we ran to the end of the table,

	 * then we just have to use the last [largest] entry.

	/* If we found an MTU which resulted in the requested Data Segment

	 * Length alignment and that's "not far" from the largest MTU which is

	 * less than or equal to the maximum MTU, then use that.

	/* If the caller has passed in an MTU Index pointer, pass the

	 * MTU Index back.  Return the MTU value.

/**

 *	cxgb4_port_chan - get the HW channel of a port

 *	@dev: the net device for the port

 *

 *	Return the HW Tx channel of the given port.

/**

 *      cxgb4_port_e2cchan - get the HW c-channel of a port

 *      @dev: the net device for the port

 *

 *      Return the HW RX c-channel of the given port.

/**

 *	cxgb4_port_viid - get the VI id of a port

 *	@dev: the net device for the port

 *

 *	Return the VI id of the given port.

/**

 *	cxgb4_port_idx - get the index of a port

 *	@dev: the net device for the port

 *

 *	Return the index of the given port.

	/* Figure out where the offset lands in the Memory Type/Address scheme.

	 * This code assumes that the memory is laid out starting at offset 0

	 * with no breaks as: EDC0, EDC1, MC0, MC1. All cards have both EDC0

	 * and EDC1.  Some cards will have neither MC0 nor MC1, most cards have

	 * MC0, and some have both MC0 and MC1.

 offset beyond the end of any memory */

 T4/T6 only has a single memory channel */

		/* Make sure that all writes to the TX descriptors

		 * are committed before we tell HW about them.

 Re-enable BAR2 WC */

 IS_ENABLED(CONFIG_IPV6) */

/**

 *	cxgb_up - enable the adapter

 *	@adap: adapter being enabled

 *

 *	Called when the first port is enabled, this function performs the

 *	actions necessary to make an adapter operational, such as completing

 *	the initialization of HW modules, and enabling interrupts.

 *

 *	Must be called with the rtnl lock held.

/*

 * net_device operations

	/* It's possible that the basic port information could have

	 * changed since we first read it.

 Adjust stid to correct filter index */

	/* Check to make sure the filter requested is writable ...

	/* Clear out any old resources being used by the filter before

	 * we start constructing the new filter.

 Clear out filter specifications */

 Mark filter as locked */

	/* Save the actual tid. We need this to get the corresponding

	 * filter entry structure in filter_rpl.

 Adjust stid to correct filter index */

 Unlock the filter */

	/* Block retrieving statistics during EEH error

	 * recovery. Otherwise, the recovery might fail

	 * and the PCI device will be removed permanently

 detailed rx_errors */

 detailed tx_errors */

 For T4 Adapters */

 unfortunately we can't return errors to the stack */

	/* Turn carrier off since we don't have to transmit anything on this

	 * interface.

 Fill MAC address that will be assigned by the FW */

 locally assigned Ethernet MAC address */

 not a multicast Ethernet MAC address */

 verify MAC addr is valid */

 unbind VF to to any Traffic Class */

 subtract ethhdr size and 4 bytes crc since, f/w appends it */

 subtract ipv4 hdr size, tcp hdr size to get typical IPv4 MSS size */

 configure Traffic Class for rate-limiting */

 bind VF to configured Traffic Class */

 CONFIG_PCI_IOV */

 Convert from Mbps to Kbps */

 Max rate is 100 Gbps */

 First unbind the queue from any existing class */

 Queue already unbound */

 Fetch any available unused or matching scheduling class */

 Bind the queue to a scheduling class */

	/* Matchall mac entries can be deleted only after all tunnel ports

	 * are brought down or removed.

	/* Create a 'match all' mac filter entry for inner mac,

	 * if raw mac interface is supported. Once the linux kernel provides

	 * driver entry points for adding/deleting the inner mac addresses,

	 * we will remove this 'match all' entry and fallback to adding

	 * exact match filters.

 Check if hw supports offload for this packet */

 Offload is not supported for this encapsulated packet */

 Disable GRO, if RX_CSUM is disabled */

 CONFIG_CHELSIO_T4_FCOE */

	/* Disable the SGE since ULDs are going to free resources that

	 * could be exposed to the adapter.  RDMA MWs for example...

		/* If we get here in very early initialization the network

		 * devices may not have been set up yet.

 HMA Definitions */

 The maximum number of address that can be send in a single FW cmd */

 FW supports 16K addresses */

/* The minimum and maximum possible HMA sizes that can be specified in the FW

 * configuration(in units of MB).

	/* HMA is supported only for T6+ cards.

	 * Avoid initializing HMA in kdump kernels.

 Get the HMA region size required by fw */

	/* An error means card has its own memory or HMA is not supported by

	 * the firmware. Return without any errors.

	/* FW returned value will be in MB's

 Pass on the addresses to firmware */

 Presently we support only Page table mode */

		/* For last cmd, set naddr corresponding to remaining

		 * addresses

 HMA cmd size specified in MB's */

 Total Page size specified in units of 4K */

 Fill the 5 addresses */

	/* Now that we've successfully configured and initialized the adapter

	 * can ask the Firmware what resources it has provisioned for us.

 get device capabilities */

 tweak some settings */

 first 4 Tx modulation queues point to consecutive Tx channels */

 associate each Tx modulation queue with consecutive Tx channels */

 in KB units */

 get basic stuff going */

/*

 * Max # of ATIDs.  The absolute HW max is 16K but we keep it lower.

/*

 * Phase 0 of initialization: contact FW, obtain config, perform basic init.

 *

 * If the firmware we're dealing with has Configuration File support, then

 * we use that to perform all configuration

/*

 * Tweak configuration based on module parameters, etc.  Most of these have

 * defaults assigned to them by Firmware Configuration Files (if we're using

 * them) but need to be explicitly set if we're using hard-coded

 * initialization.  But even in the case of using Firmware Configuration

 * Files, we'd like to expose the ability to change these via module

 * parameters so these are essentially common tweaks/settings for

 * Configuration Files and hard-coded initialization ...

	/*

	 * Fix up various Host-Dependent Parameters like Page Size, Cache

	 * Line Size, etc.  The firmware default is for a 4KB Page Size and

	 * 64B Cache Line Size ...

	/*

	 * Process module parameters which affect early initialization.

	/*

	 * Don't include the "IP Pseudo Header" in CPL_RX_PKT checksums: Linux

	 * adds the pseudo header itself.

/* 10Gb/s-BT PHY Support. chip-external 10Gb/s-BT PHYs are complex chips

 * unto themselves and they contain their own firmware to perform their

 * tasks ...

	/* At offset 0x8 you're looking for the primary image's

	 * starting offset which is 3 Bytes wide

	 *

	 * At offset 0xa of the primary image, you look for the offset

	 * of the DRAM segment which is 3 Bytes wide.

	 *

	 * The FW version is at offset 0x27e of the DRAM and is 2 Bytes

	 * wide

 PCI Device ID */

 /lib/firmware/ PHY Firmware file */

 Has FLASH for PHY Firmware */

/* Handle updating of chip-external 10Gb/s-BT PHY firmware.  This needs to

 * happen after the FW_RESET_CMD but before the FW_INITIALIZE_CMD.  On error

 * we return a negative error number.  If we transfer new firmware we return 1

 * (from t4_load_phy_fw()).  If we don't do anything we return 0.

	/* Use the device ID to determine which PHY file to flash.

	/* If we have a T4 PHY firmware file under /lib/firmware/cxgb4/, then

	 * use that. The adapter firmware provides us with a memory buffer

	 * where we can load a PHY firmware file from the host if we want to

	 * override the PHY firmware File in flash.

		/* For adapters without FLASH attached to PHY for their

		 * firmware, it's obviously a fatal error if we can't get the

		 * firmware to the adapter.  For adapters with PHY firmware

		 * FLASH storage, it's worth a warning if we can't find the

		 * PHY Firmware but we'll neuter the error ...

	/* Load PHY Firmware onto adapter.

/*

 * Attempt to initialize the adapter via a Firmware Configuration File.

	/*

	 * Reset device if necessary.

	/* If this is a 10Gb/s-BT adapter make sure the chip-external

	 * 10Gb/s-BT PHYs have up-to-date firmware.  Note that this step needs

	 * to be performed after any global adapter RESET above since some

	 * PHYs only have local RAM copies of the PHY firmware.

	/*

	 * If we have a T4 configuration file under /lib/firmware/cxgb4/,

	 * then use that.  Otherwise, use the configuration file stored

	 * in the adapter flash ...

				/*

				 * For t4_memory_rw() below addresses and

				 * sizes have to be in terms of multiples of 4

				 * bytes.  So, if the Configuration File isn't

				 * a multiple of 4 bytes in length we'll have

				 * to write that out separately since we can't

				 * guarantee that the bytes following the

				 * residual byte in the buffer returned by

				 * request_firmware() are zeroed out ...

	/* Ofld + Hash filter is supported. Older fw will fail this request and

	 * it is fine.

	/* FW doesn't know about Hash filter + ofld support,

	 * it's not a problem, don't return an error.

	/*

	 * Issue a Capability Configuration command to the firmware to get it

	 * to parse the Configuration File.  We don't use t4_fw_config_file()

	 * because we want the ability to modify various features after we've

	 * processed the configuration file ...

	/* If the CAPS_CONFIG failed with an ENOENT (for a Firmware

	 * Configuration File in FLASH), our last gasp effort is to use the

	 * Firmware Configuration File which is embedded in the firmware.  A

	 * very few early versions of the firmware didn't have one embedded

	 * but we can ignore those.

	/*

	 * And now tell the firmware to use the configuration we just loaded.

	/*

	 * Tweak configuration based on system architecture, module

	 * parameters, etc.

 We will proceed even if HMA init fails. */

	/*

	 * And finally tell the firmware to initialize itself using the

	 * parameters from the Configuration File.

	/* Emit Firmware Configuration File information and return

	 * successfully.

	/*

	 * Something bad happened.  Return the error ...  (If the "error"

	 * is that there's no Configuration File on the adapter we don't

	 * want to issue a warning since this is fairly common.)

/*

 * Phase 0 of initialization: contact FW, obtain config, perform basic init.

	/* Grab Firmware Device Log parameters as early as possible so we have

	 * access to it for debugging, etc.

 Contact FW, advertising Master capability */

	/*

	 * If we're the Master PF Driver and the device is uninitialized,

	 * then let's consider upgrading the firmware ...  (We always want

	 * to check the firmware version number in order to A. get it for

	 * later reporting and B. to warn if the currently loaded firmware

	 * is excessively mismatched relative to the driver.)

 If firmware is too old (not supported by driver) force an update. */

		/* This is the firmware whose headers the driver was compiled

		 * against

		/* allocate memory to read the header of the firmware on the

		 * card

 Get FW from from /lib/firmware/ */

 upgrade FW logic */

 Cleaning up */

	/* If the firmware is initialized already, emit a simply note to that

	 * effect. Otherwise, it's time to try initializing the adapter.

		/* Find out whether we're dealing with a version of the

		 * firmware which has configuration file support.

		/* If the firmware doesn't support Configuration Files,

		 * return an error.

		/* The firmware provides us with a memory buffer where we can

		 * load a Configuration File from the host if we want to

		 * override the Configuration File in flash.

	/* Now that we've successfully configured and initialized the adapter

	 * (or found it already initialized), we can ask the Firmware what

	 * resources it has provisioned for us.

	/* Grab VPD parameters.  This should be done after we establish a

	 * connection to the firmware since some of the VPD parameters

	 * (notably the Core Clock frequency) are retrieved via requests to

	 * the firmware.  On the other hand, we need these fairly early on

	 * so we do this right after getting ahold of the firmware.

	 *

	 * We need to do this after initializing the adapter because someone

	 * could have FLASHed a new VPD which won't be read by the firmware

	 * until we do the RESET ...

	/* Find out what ports are available to us.  Note that we need to do

	 * this before calling adap_init0_no_config() since it needs nports

	 * and portvec ...

	/* Give the SGE code a chance to pull in anything that it needs ...

	 * Note that this must be called after we retrieve our VPD parameters

	 * in order to know how to convert core ticks to seconds, etc.

	/* Grab the SGE Doorbell Queue Timer values.  If successful, that

	 * indicates that the Firmware and Hardware support this.

	/*

	 * Grab some of our basic fundamental operating parameters.

		/* Read the raw mps entries. In T6, the last 2 tcam entries

		 * are reserved for raw mac addresses (rawf = 2, one per port).

	/* qids (ingress/egress) returned from firmware can be anywhere

	 * in the range from EQ(IQFLINT)_START to EQ(IQFLINT)_END.

	 * Hence driver needs to allocate memory for this range to

	 * store the queue info. Get the highest IQFLINT/EQ index returned

	 * in FW_EQ_*_CMD.alloc command.

	/* Allocate the memory for the vaious egress queue bitmaps

	 * ie starving_fl, txq_maperr and blocked_fl.

 Get the supported number of traffic classes */

		/* We couldn't retrieve the number of Traffic Classes

		 * supported by the hardware/firmware. So we hard

		 * code it here.

 query params related to active filter region */

	/* If Active filter size is set we enable establishing

	 * offload connection through firmware work request

	/* If we're running on newer firmware, let it know that we're

	 * prepared to deal with encapsulated CPL messages.  Older

	 * firmware won't understand this and we'll just get

	 * unencapsulated messages ...

	/*

	 * Find out whether we're allowed to use the T5+ ULPTX MEMWRITE DSGL

	 * capability.  Earlier versions of the firmware didn't have the

	 * ULPTX_MEMWRITE_DSGL so we'll interpret a query failure as no

	 * permission to use ULPTX MEMWRITE DSGL.

 See if FW supports FW_RI_FR_NSMR_TPTE_WR work request */

 See if FW supports FW_FILTER2 work request */

	/* Check if FW supports returning vin and smt index.

	 * If this is not supported, driver will interpret

	 * these values from viid.

	/*

	 * Get device capabilities so we can determine what resources we need

	 * to manage.

	/* hash filter has some mandatory register settings to be tested and for

	 * that it needs to test whether offload is enabled or not, hence

	 * checking and setting it here.

 query offload-related parameters */

		/*

		 * Setup server filter region. Divide the available filter

		 * region into two parts. Regular filters get 1/3rd and server

		 * filters get 2/3rd part. This is only enabled if workarond

		 * path is enabled.

		 * 1. For regular filters.

		 * 2. Server filter: This are special filters which are used

		 * to redirect SYN packets to offload queue.

 Enable write_with_immediate if FW supports it */

 Enable write_cmpl if FW supports it */

 LIO target and cxgb4i initiaitor */

	/* The MTU/MSS Table is initialized by now, so load their values.  If

	 * we're initializing the adapter, then we'll make any modifications

	 * we want to the MTU/MSS Table and also initialize the congestion

	 * parameters.

		/* The default MTU Table contains values 1492 and 1500.

		 * However, for TCP, it's better to have two values which are

		 * a multiple of 8 +/- 4 bytes apart near this popular MTU.

		 * This allows us to have a TCP Data Payload which is a

		 * multiple of 8 regardless of what combination of TCP Options

		 * are in use (always a multiple of 4 bytes) which is

		 * important for performance reasons.  For instance, if no

		 * options are in use, then we have a 20-byte IP header and a

		 * 20-byte TCP header.  In this case, a 1500-byte MSS would

		 * result in a TCP Data Payload of 1500 - 40 == 1460 bytes

		 * which is not a multiple of 8.  So using an MSS of 1488 in

		 * this case results in a TCP Data Payload of 1448 bytes which

		 * is a multiple of 8.  On the other hand, if 12-byte TCP Time

		 * Stamps have been negotiated, then an MTU of 1500 bytes

		 * results in a TCP Data Payload of 1448 bytes which, as

		 * above, is a multiple of 8 bytes ...

	/*

	 * Something bad happened.  If a command timed out or failed with EIO

	 * FW does not operate within its spec or something catastrophic

	 * happened to HW/FW, stop issuing commands.

 EEH callbacks */

		/* If fw supports returning the VIN as part of FW_VI_CMD,

		 * save the returned values.

 Retrieve the values from VIID */

/* Return true if the Link Configuration supports "High Speeds" (those greater

 * than 1Gb/s).

/* Perform default configuration of DMA queues depending on the number and type

 * of ports we found and the number of available CPUs.  Most settings can be

 * modified by the admin prior to actual use.

 Reduce memory usage in kdump environment, disable all offload. */

	/* Calculate the number of Ethernet Queue Sets available based on

	 * resources provisioned for us.  We always have an Asynchronous

	 * Firmware Event Ingress Queue.  If we're operating in MSI or Legacy

	 * IRQ Pin Interrupt mode, then we'll also have a Forwarded Interrupt

	 * Ingress Queue.  Meanwhile, we need two Egress Queues for each

	 * Queue Set: one for the Free List and one for the Ethernet TX Queue.

	 *

	 * Note that we should also take into account all of the various

	 * Offload Queues.  But, in any situation where we're operating in

	 * a Resource Constrained Provisioning environment, doing any Offload

	 * at all is problematic ...

 Count the number of 10Gb/s or better ports */

	/* We default to 1 queue per non-10G port and up to # of cores queues

	 * per 10G port.

	/* For Data Center Bridging support we need to be able to support up

	 * to 8 Traffic Priorities; each of which will be assigned to its

	 * own TX Queue in order to prevent Head-Of-Line Blocking.

 !CONFIG_CHELSIO_T4_DCB */

 !CONFIG_CHELSIO_T4_DCB */

 MSI-X may lower it later */

		/* For offload we use 1 queue/channel if all ports are up to 1G,

		 * otherwise we divide all available queues amongst the channels

		 * capped by the number of available cores.

	/* ETHOFLD Queues used for QoS offload should follow same

	 * allocation scheme as normal Ethernet Queues.

	/* Mirror queues must follow same scheme as normal Ethernet

	 * Queues, when there are enough queues available. Otherwise,

	 * allocate at least 1 queue per port. If even 1 queue is not

	 * available, then disable mirror queues support.

/*

 * Reduce the number of Ethernet queues across all ports to at most n.

 * n provides at least one queue per port.

 2 MSI-X vectors needed for the FW queue and non-data interrupts */

	/* For Data Center Bridging we need 8 Ethernet TX Priority Queues for

	 * each port.

		/* Disable offload and attempt to get vectors for NIC

		 * only mode.

		/* Distribute available vectors to the various queue groups.

		 * Every group gets its minimum requirement and NIC gets top

		 * priority for leftovers.

 map for msix */

 Dump basic information about the adapter */

 Hardware/Firmware/etc. Version/Revision IDs */

 Software/Hardware configuration */

/*

 * Free the following resources:

 * - memory used for tables

 * - MSI/MSI-X

 * - net devices

 * - resources FW is holding for us

 Initialize the device structure. */

 Check if fw is initialized */

	/* If any of the VF's is already assigned to Guest OS, then

	 * SRIOV for the same cannot be modified

	/* Note that the upper-level code ensures that we're never called with

	 * a non-zero "num_vfs" when we already have VFs instantiated.  But

	 * it never hurts to code defensively.

 Nothing to do for no change. */

 Disable SRIOV when zero is passed. */

 free VF Management Interface */

 free VF resources */

		/* If we want to instantiate Virtual Functions, then our

		 * parent bridge's PCI-E needs to support Alternative Routing

		 * ID (ARI) because our VFs will show up at function offset 8

		 * and above.

			/* Our parent bridge does not support ARI so issue a

			 * warning and skip instantiating the VFs.  They

			 * won't be reachable.

 Allocate VF Management Interface. */

 Allocate and set up VF Information. */

 Instantiate the requested number of VFs. */

 CONFIG_PCI_IOV */

 CONFIG_CHELSIO_TLS_DEVICE */

 CONFIG_CHELSIO_IPSEC_INLINE */

 CONFIG_CHELSIO_TLS_DEVICE || CONFIG_CHELSIO_IPSEC_INLINE */

 if there is a failure, clear the refcount */

 CONFIG_CHELSIO_TLS_DEVICE */

 CONFIG_CHELSIO_IPSEC_INLINE */

 Just info, some other driver may have claimed the device. */

 We control everything through one PF */

 to restore SR-IOV later */

 PCI device has been enabled */

	/* If possible, we use PCIe Relaxed Ordering Attribute to deliver

	 * Ingress Packet Data to Free List Buffers in order to allow for

	 * chipset performance optimizations between the Root Complex and

	 * Memory Controllers.  (Messages to the associated Ingress Queue

	 * notifying new Packet Placement in the Free Lists Buffers will be

	 * send without the Relaxed Ordering Attribute thus guaranteeing that

	 * all preceding PCIe Transaction Layer Packets will be processed

	 * first.)  But some Root Complexes have various issues with Upstream

	 * Transaction Layer Packets with the Relaxed Ordering Attribute set.

	 * The PCIe devices which under the Root Complexes will be cleared the

	 * Relaxed Ordering bit in the configuration space, So we check our

	 * PCIe configuration space to see if it's flagged with advice against

	 * using Relaxed Ordering.

 Collect hardware state and append to /proc/vmcore */

		/* Each segment size is 128B. Write coalescing is enabled only

		 * when SGE_EGRESS_QUEUES_PER_PAGE_PF reg value for the

		 * queue is less no of segments that can be accommodated in

		 * a page size.

 configure SGE_STAT_CFG_A to read WC stats */

 Initialize hash mac addr list */

		/* For supporting MQPRIO Offload, need some extra

		 * queues for each ETHOFLD TIDs. Keep it equal to

		 * MAX_ATIDs for now. Once we connect to firmware

		 * later and query the EOTID params, we'll come to

		 * know the actual # of EOTIDs supported.

 initialize the refcount */

 CONFIG_CHELSIO_TLS_DEVICE */

 CONFIG_CHELSIO_IPSEC_INLINE */

 MTU range: 81 - 9600 */

 accommodate SACK */

		/* If we don't have a connection to the firmware -- possibly

		 * because of an error -- grab the raw VPD parameters so we

		 * can set the proper MAC Address on the debug network

		 * interface that we've created.

	/* Configure queues and allocate tables now, they can be needed as

	 * soon as the first register_netdev completes.

 We tolerate a lack of SMT, giving up some functionality */

 We tolerate a lack of L2T, giving up some functionality */

		/* CLIP functionality is not present in hardware,

		 * hence disable all offload features

			/* We tolerate a lack of clip_table, giving up

			 * some functionality

 See what interrupts we'll be using */

 check for PCI Express bandwidth capabiltites */

	/*

	 * The card is now ready to go.  If any errors occur during device

	 * registration we do not fail the whole card but rather proceed only

	 * with the ports we manage to register successfully.  However we must

	 * register at least one net device.

 PCIe EEH recovery on powerpc platforms needs fundamental reset */

	/* If we allocated filters, free up state associated with any

	 * valid filters ...

		/* Tear down per-adapter Work Queue first since it can contain

		 * references to our adapter data structure.

/* "Shutdown" quiesces the device, stopping Ingress Packet and Interrupt

 * delivery.  This is essentially a stripped down version of the PCI remove()

 * function where we do the minimal amount of work necessary to shutdown any

 * further activity.

	/* As with remove_one() above (see extended comment), we only want do

	 * do cleanup on PCI Devices which went all the way through init_one()

	 * ...

 NULL ok */

/*

 * This file is part of the Chelsio T4 Ethernet driver for Linux.

 *

 * Copyright (c) 2016 Chelsio Communications, Inc. All rights reserved.

 *

 * This software is available to you under a choice of one of two

 * licenses.  You may choose to be licensed under the terms of the GNU

 * General Public License (GPL) Version 2, available from the file

 * COPYING in the main directory of this source tree, or the

 * OpenIB.org BSD license below:

 *

 *     Redistribution and use in source and binary forms, with or

 *     without modification, are permitted provided that the following

 *     conditions are met:

 *

 *      - Redistributions of source code must retain the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer.

 *

 *      - Redistributions in binary form must reproduce the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer in the documentation and/or other materials

 *        provided with the distribution.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS

 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN

 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN

 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

 Fill ch_filter_specification with parsed match value/mask pair. */

 For next headers, parse only keys with offmask */

 For the remaining, parse only keys without offmask */

 Fill ch_filter_specification with parsed action. */

 Don't allow more than one action per rule. */

 Drop in hardware. */

 Re-direct to specified port in hardware. */

			/* Interface doesn't belong to any port of

			 * the underlying hardware.

 Un-supported action. */

	/* Get a free filter entry TID, where we can insert this new

	 * rule. Only insert rule if its prio doesn't conflict with

	 * existing rules.

	/* Ensure that uhtid is either root u32 (i.e. 0x800)

	 * or a a valid linked bucket.

 Ensure link handle uhtid is sane, if specified. */

 Link must exist from root node before insertion. */

 Link must have a valid supported next header. */

	/* Parse links and record them for subsequent jumps to valid

	 * next headers.

 Try to find matches that allow jumps to next header. */

			/* Found a possible candidate.  Find a key that

			 * matches the corresponding offset, value, and

			 * mask to jump to next header.

 Try next candidate. */

			/* Candidate to jump to next header found.

			 * Translate all keys to internal specification

			 * and store them in jump table. This spec is copied

			 * later to set the actual filters.

 No candidate found to jump to next header. */

	/* Fill ch_filter_specification match fields to be shipped to hardware.

	 * Copy the linked spec (if any) first.  And then update the spec as

	 * needed.

 Copy linked ch_filter_specification */

	/* Fill ch_filter_specification action fields to be shipped to

	 * hardware.

	/* The filter spec has been completely built from the info

	 * provided from u32.  We now set some default fields in the

	 * spec for sanity.

	/* Match only packets coming from the ingress port where this

	 * filter will be created.

 Enable filter hit counts. */

 Set type of filter - IPv6 or IPv4 */

 Set the filter */

	/* If this is a linked bucket, then set the corresponding

	 * entry in the bitmap to mark it as belonging to this linked

	 * bucket.

 Fetch the location to delete the filter. */

	/* Ensure that uhtid is either root u32 (i.e. 0x800)

	 * or a a valid linked bucket.

 Delete the specified filter */

	/* If a link is being deleted, then delete all filters

	 * associated with the link.

 Clear the link state */

 Free up all allocated memory. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  Copyright (C) 2013-2015 Chelsio Communications.  All rights reserved.

/* port stats maintained per queue of the port. They should be in the same

 * order as in stats_strings above.

/**

 *	from_fw_port_mod_type - translate Firmware Port/Module type to Ethtool

 *	@port_type: Firmware Port Type

 *	@mod_type: Firmware Module Type

 *

 *	Translate Firmware Port/Module type to Ethtool Port Type.

/**

 *	speed_to_fw_caps - translate Port Speed to Firmware Port Capabilities

 *	@speed: speed in Kb/s

 *

 *	Translates a specific Port Speed into a Firmware Port Capabilities

 *	value.

/**

 *	fw_caps_to_lmm - translate Firmware to ethtool Link Mode Mask

 *	@port_type: Firmware Port Type

 *	@fw_caps: Firmware Port Capabilities

 *	@link_mode_mask: ethtool Link Mode Mask

 *

 *	Translate a Firmware Port Capabilities specification to an ethtool

 *	Link Mode Mask.

/**

 *	lmm_to_fw_caps - translate ethtool Link Mode Mask to Firmware

 *	capabilities

 *	@link_mode_mask: ethtool Link Mode Mask

 *

 *	Translate ethtool Link Mode Mask into a Firmware Port capabilities

 *	value.

	/* For the nonce, the Firmware doesn't send up Port State changes

	 * when the Virtual Interface attached to the Port is down.  So

	 * if it's down, let's grab any changes.

 only full-duplex supported */

 Speed must be supported by Physical Port Capabilities. */

	/* If the firmware rejects the Link Configuration request, back out

	 * the changes and report the error.

 Translate the Firmware FEC value into the ethtool value. */

 if nothing is set, then FEC is off */

 Translate Common Code FEC value into ethtool value. */

 if nothing is set, then FEC is off */

 Translate ethtool FEC value into Common Code value. */

	/* Translate the Firmware FEC Support into the ethtool value.  We

	 * always support IEEE 802.3 "automatic" selection of Link FEC type if

	 * any FEC is supported.

	/* Translate the current internal FEC parameters into the

	 * ethtool values.

	/* Save old Link Configuration in case the L1 Configure below

	 * fails.

	/* Try to perform the L1 Configure and return the result of that

	 * effort.  If it fails, revert the attempted change.

/**

 * set_rx_intr_params - set a net devices's RX interrupt holdoff paramete!

 * @dev: the network device

 * @us: the hold-off time in us, or 0 to disable timer

 * @cnt: the hold-off packet count, or 0 to disable counter

 *

 * Set the RX interrupt hold-off parameters for a network device.

/* Return the current global Adapter SGE Doorbell Queue Timer Tick for all

 * Ethernet TX Queues.

/* Return the SGE Doorbell Queue Timer Value for the Ethernet TX Queues

 * associated with a Network Device.

 all of the TX Queues use the same Timer Index */

/* Set the global Adapter SGE Doorbell Queue Timer Tick for all Ethernet TX

 * Queues.  This is the fundamental "Tick" that sets the scale of values which

 * can be used.  Individual Ethernet TX Queues index into a relatively small

 * array of Tick Multipliers.  Changing the base Tick will thus change all of

 * the resulting Timer Values associated with those multipliers for all

 * Ethernet TX Queues.

 return early if it's the same Timer Tick we're already using */

 attempt to set the new Timer Tick value */

 if successful, reread resulting dependent Timer values */

/* Set the SGE Doorbell Queue Timer Value for the Ethernet TX Queues

 * associated with a Network Device.  There is a relatively small array of

 * possible Timer Values so we need to pick the closest value available.

	/* Find the SGE Doorbell Timer Value that's closest to the requested

	 * value.

	/* Return early if it's the same Timer Index we're already using.

	 * We use the same Timer Index for all of the TX Queues for an

	 * interface so it's only necessary to check the first one.

/* Set the global Adapter SGE Doorbell Queue Timer Tick for all Ethernet TX

 * Queues and the Timer Value for the Ethernet TX Queues associated with a

 * Network Device.  Since changing the global Tick changes all of the

 * available Timer Values, we need to do this first before selecting the

 * resulting closest Timer Value.  Moreover, since the Tick is global,

 * changing it affects the Timer Values for all Network Devices on the

 * adapter.  So, before changing the Tick, we grab all of the current Timer

 * Values for other Network Devices on this Adapter and then attempt to select

 * new Timer Values which are close to the old values ...

	/* Grab the other adapter Network Interface current timers and fill in

	 * the new one for this Network Interface.

 Change the global Tick first ... */

 ... and then set all of the Network Interface Timer Values ... */

/* The next two routines implement eeprom read/write from physical addresses.

		/* RMW possibly needed for first or last words.

	/* We have to RESET the chip/firmware because we need the

	 * chip in uninitialized state for loading new PHY image.

	 * Otherwise, the running firmware will only store the PHY

	 * image in local RAM which will be lost after next reset.

	/* If the adapter has been fully initialized then we'll go ahead and

	 * try to get the firmware's cooperation in upgrading to the new

	 * firmware image otherwise we'll try to do the entire job from the

	 * host ... and we always "force" the operation in this path.

 if csiostor is the master return */

	/* We require at least one supported parameter to be changed and no

	 * change in any of the unsupported parameters

 Interface must be brought up atleast once */

 Check for maximum filter range */

 Fetch filter_entry */

 can still change nfilters */

 Add Ethtool n-tuple filters. */

 can still change nfilters */

		/* For QSFP type ports, revision value >= 3

		 * means the SFP is 8636 compliant.

 offset + len spans 0xa0 and 0xa1 pages */

 read 0xa0 page */

		/* Remaining bytes to be read from second page =

		 * Total length - bytes read from first page

 Read additional optical diagnostics from page 0xa2 if supported */

/**

 *	set_flags - set/unset specified flags if passed in new_flags

 *	@cur_flags: pointer to current flags

 *	@new_flags: new incoming flags

 *	@flags: set of flags to set/unset

/*

 * This file is part of the Chelsio T4/T5/T6 Ethernet driver for Linux.

 *

 * Copyright (c) 2017 Chelsio Communications, Inc. All rights reserved.

 *

 * This software is available to you under a choice of one of two

 * licenses.  You may choose to be licensed under the terms of the GNU

 * General Public License (GPL) Version 2, available from the file

 * COPYING in the main directory of this source tree, or the

 * OpenIB.org BSD license below:

 *

 *     Redistribution and use in source and binary forms, with or

 *     without modification, are permitted provided that the following

 *     conditions are met:

 *

 *      - Redistributions of source code must retain the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer.

 *

 *      - Redistributions in binary form must reproduce the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer in the documentation and/or other materials

 *        provided with the distribution.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS

 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN

 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN

 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

 Default supported NAT modes */

 T6+ can ignore L4 ports when they're disabled. */

	/* Translate the enabled NAT 4-tuple fields to one of the

	 * hardware supported NAT mode configurations. This ensures

	 * that we pick a valid combination, where the disabled fields

	 * do not get overwritten to 0.

 Must be called with either RTNL or rcu_read_lock */

 also initialize nat_lip/fip to same values */

 also initialize nat_lip/fip to same values */

 also initialize nat_lport/fport to same values */

		/* Chelsio adapters use ivlan_vld bit to match vlan packets

		 * as 802.1Q. Also, when vlan tag is present in packets,

		 * ethtype match is used then to match on ethtype of inner

		 * header ie. the header following the vlan header.

		 * So, set the ivlan_vld based on ethtype info supplied by

		 * TC for vlan packets if its 802.1Q. And then reset the

		 * ethtype value else, hw will try to match the supplied

		 * ethtype value with ethtype of inner header.

	/* Match only packets coming from the ingress port where this

	 * filter will be created.

	/* Extract the NAT mode to enable based on what 4-tuple fields

	 * are enabled to be overwritten. This ensures that the

	 * disabled fields don't get overwritten to 0.

	/* Either the upper 16-bits (SPORT) OR the lower

	 * 16-bits (DPORT) can be set, but NOT BOTH.

 Do nothing */

			/* If interface doesn't belong to our hw, then

			 * the provided output port is not valid

 Do nothing. cxgb4_set_filter will validate */

	/* Bail if the current rule is not the one with the max

	 * prio.

	/* Search for the next rule having the same or next lower

	 * max prio.

				/* Bail if we found another rule

				 * having the same prio as the

				 * current max one.

	/* Get a free filter entry TID, where we can insert this new

	 * rule. Only insert rule if its prio doesn't conflict with

	 * existing rules.

	/* If the rule can be inserted into HASH region, then ignore

	 * the index to normal FILTER region.

 Wait for reply */

 Check if hw returned error for filter creation */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Chelsio Communications, Inc. All rights reserved. */

 return number of filters freed */

 Returns a negative error number or the number of filters allocated */

/*

 * cxgb4_ptp.c:Chelsio PTP support for T5/T6

 *

 * Copyright (c) 2003-2017 Chelsio Communications, Inc. All rights reserved.

 *

 * This software is available to you under a choice of one of two

 * licenses.  You may choose to be licensed under the terms of the GNU

 * General Public License (GPL) Version 2, available from the file

 * COPYING in the main directory of this source tree, or the

 * OpenIB.org BSD license below:

 *

 *     Redistribution and use in source and binary forms, with or

 *     without modification, are permitted provided that the following

 *     conditions are met:

 *

 *      - Redistributions of source code must retain the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer.

 *

 *      - Redistributions in binary form must reproduce the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer in the documentation and/or other materials

 *        provided with the distribution.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS

 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN

 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN

 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

 *

 * Written by: Atul Gupta (atul.gupta@chelsio.com)

/**

 * cxgb4_ptp_is_ptp_tx - determine whether TX packet is PTP or not

 * @skb: skb of outgoing ptp request

 *

/**

 * cxgb4_ptp_is_ptp_rx - determine whether RX packet is PTP or not

 * @skb: skb of incoming ptp request

 *

/**

 * cxgb4_ptp_read_hwstamp - read timestamp for TX event PTP message

 * @adapter: board private structure

 * @pi: port private structure

 *

/**

 * cxgb4_ptprx_timestamping - Enable Timestamp for RX PTP event message

 * @pi: port private structure

 * @port: pot number

 * @mode: RX mode

 *

/**

 * cxgb4_ptp_adjfreq - Adjust frequency of PHC cycle counter

 * @ptp: ptp clock structure

 * @ppb: Desired frequency change in parts per billion

 *

 * Adjust the frequency of the PHC cycle counter by the indicated ppb from

 * the base frequency.

/**

 * cxgb4_ptp_fineadjtime - Shift the time of the hardware clock

 * @adapter: board private structure

 * @delta: Desired change in nanoseconds

 *

 * Adjust the timer by resetting the timecounter structure.

/**

 * cxgb4_ptp_adjtime - Shift the time of the hardware clock

 * @ptp: ptp clock structure

 * @delta: Desired change in nanoseconds

 *

 * Adjust the timer by resetting the timecounter structure.

/**

 * cxgb4_ptp_gettime - Reads the current time from the hardware clock

 * @ptp: ptp clock structure

 * @ts: timespec structure to hold the current time value

 *

 * Read the timecounter and return the correct value in ns after converting

 * it into a struct timespec.

 convert to timespec*/

/**

 *  cxgb4_ptp_settime - Set the current time on the hardware clock

 *  @ptp: ptp clock structure

 *  @ts: timespec containing the new time for the cycle counter

 *

 *  Reset value to new base value instead of the kernel

 *  wall timer value.

/**

 * cxgb4_ptp_enable - enable or disable an ancillary feature

 * @ptp: ptp clock structure

 * @request: Desired resource to enable or disable

 * @on: Caller passes one to enable or zero to disable

 *

 * Enable (or disable) ancillary features of the PHC subsystem.

 * Currently, no ancillary features are supported.

/**

 * cxgb4_ptp_init - initialize PTP for devices which support it

 * @adapter: board private structure

 *

 * This function performs the required steps for enabling PTP support.

 no need to create a clock device if we already have one */

/**

 * cxgb4_ptp_stop - disable PTP device and stop the overflow check

 * @adapter: board private structure

 *

 * Stop the PTP support.

/*

 * This file is part of the Chelsio T4 Ethernet driver for Linux.

 *

 * Copyright (c) 2015 Chelsio Communications, Inc. All rights reserved.

 *

 * This software is available to you under a choice of one of two

 * licenses.  You may choose to be licensed under the terms of the GNU

 * General Public License (GPL) Version 2, available from the file

 * COPYING in the main directory of this source tree, or the

 * OpenIB.org BSD license below:

 *

 *     Redistribution and use in source and binary forms, with or

 *     without modification, are permitted provided that the following

 *     conditions are met:

 *

 *      - Redistributions of source code must retain the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer.

 *

 *      - Redistributions in binary form must reproduce the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer in the documentation and/or other materials

 *        provided with the distribution.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS

 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN

 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN

 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

/**

 * cxgb_fcoe_enable - enable FCoE offload features

 * @netdev: net device

 *

 * Returns 0 on success or -EINVAL on failure.

/**

 * cxgb_fcoe_disable - disable FCoE offload

 * @netdev: net device

 *

 * Returns 0 on success or -EINVAL on failure.

 CONFIG_CHELSIO_T4_FCOE */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  Copyright (C) 2013-2014 Chelsio Communications.  All rights reserved.

 *

 *  Written by Anish Bhatt (anish@chelsio.com)

 *	       Casey Leedom (leedom@chelsio.com)

/* DCBx version control

/* Initialize a port's Data Center Bridging state.

	/* Any writes here are only done on kernels that exlicitly need

	 * a specific version, say < 2.6.38 which only support CEE

 zero priority implies remove */

 Check if app list is exhausted */

/* Reset a port's Data Center Bridging state.  Typically used after a

 * Link Down event.

/* update the dcb port support, if version is IEEE then set it to

 * FW_PORT_DCB_VER_IEEE and if DCB_CAP_DCBX_VER_CEE is already set then

 * clear that. and if it is set to CEE then set dcb supported to

 * DCB_CAP_DCBX_VER_CEE & if DCB_CAP_DCBX_VER_IEEE is set, clear it

/* Finite State machine for Data Center Bridging.

 we're going to use Host DCB */

 we're going to use Firmware DCB */

 expected transition */

			/* during this CXGB4_DCB_STATE_FW_INCOMPLETE state,

			 * check if the dcb version is changed (there can be

			 * mismatch in default config & the negotiated switch

			 * configuration at FW, so update the dcb support

			 * accordingly.

 we're alreaady in firmware DCB mode */

 we're already incomplete */

 we're alreaady in firmware DCB mode */

			/* We were successfully running with firmware DCB but

			 * now it's telling us that it's in an "incomplete

			 * state.  We need to reset back to a ground state

			 * of incomplete.

			/* we're already all sync'ed

			 * this is only applicable for IEEE or

			 * when another VI already completed negotiaton

 we're alreaady in Host DCB mode */

/* Handle a DCB/DCBX update message from the firmware.

	/* Handle Firmware DCB Control messages separately since they drive

	 * our state machine.

	/* It's weird, and almost certainly an error, to get Firmware DCB

	 * messages when we either haven't been told whether we're going to be

	 * doing Host or Firmware DCB; and even worse when we've been told

	 * that we're doing Host DCB!

	/* Now handle the general Firmware DCB update messages ...

		/* Convert from firmware format to relevant format

		 * when using app selector

 Default is CEE */

/* Data Center Bridging netlink operations.

/* Get current DCB enabled/disabled state.

/* Set DCB enabled/disabled.

 If DCBx is host-managed, dcb is enabled by outside lldp agents */

	/* Firmware doesn't provide any mechanism to control the DCB state.

 prio_type is link strict */

 tc 0 is written at MSB position */

 tc 0 is written at MSB position */

/* Return whether the specified Traffic Class Priority has Priority Pause

 * Frames enabled.

/* Enable/disable Priority Pause Frames for the specified Traffic Class

 * Priority.

/* Return DCB capabilities.

 8 priorities for PG represented by bitmap */

 8 priorities for PFC represented by bitmap */

/* Return the number of Traffic Classes for the indicated Traffic Class ID.

/* Set the number of Traffic Classes supported for the indicated Traffic Class

 * ID.

	/* Setting the number of Traffic Classes isn't supported.

 Return whether Priority Flow Control is enabled.  */

 Enable/disable Priority Flow Control. */

	/* We can't enable/disable Priority Flow Control but we also can't

	 * return an error ...

/* Return the Application User Priority Map associated with the specified

 * Application ID.

 exhausted app list */

/* Return the Application User Priority Map associated with the specified

 * Application ID.

 Convert app_idtype to firmware format before querying */

/* Write a new Application User Priority Map for the specified Application ID

 DCB info gets thrown away on link up */

 overwrite existing app table */

 find first empty slot */

 no empty slots available */

 write out new app table entry */

 Priority for CEE inside dcb_app is bitmask, with 0 being an invalid value */

 Convert app_idtype to a format that firmware understands */

/* Return whether IEEE Data Center Bridging has been negotiated.

 We reuse this for peer PFC as well, as we can't have it enabled one way */

/* Fill in the Application User Priority Map associated with the

 * specified Application.

 * Priority for IEEE dcb_app is an integer, with 0 being a valid value

 Try querying firmware first, use firmware format */

/* Write a new Application User Priority Map for the specified Application ID.

 * Priority for IEEE dcb_app is an integer, with 0 being a valid value

 change selector to a format that firmware understands */

/* Return our DCBX parameters.

 This is already set by cxgb4_set_dcb_caps, so just return it */

/* Set our DCBX parameters.

	/* Filter out requests which exceed our capabilities.

	/* Can't enable DCB if we haven't successfully negotiated it.

	/* There's currently no mechanism to allow for the firmware DCBX

	 * negotiation to be changed from the Host Driver.  If the caller

	 * requests exactly the same parameters that we already have then

	 * we'll allow them to be successfully "set" ...

 find first empty slot */

 find first empty slot */

/* Return Priority Group information.

	/* We're always "willing" -- the Switch Fabric always dictates the

	 * DCBX parameters to us.

/* Return Priority Flow Control information.

	/* Firmware sends this to us in a formwat that is a bit flipped version

	 * of spec, correct it before we send it to host. This is taken care of

	 * by bit shifting in other uses of pfcen

 CEE std */

 DCBX configuration */

 peer apps */

 CEE peer */

/*

 * This file is part of the Chelsio T4 Ethernet driver for Linux.

 *

 * Copyright (c) 2003-2014 Chelsio Communications, Inc. All rights reserved.

 *

 * This software is available to you under a choice of one of two

 * licenses.  You may choose to be licensed under the terms of the GNU

 * General Public License (GPL) Version 2, available from the file

 * COPYING in the main directory of this source tree, or the

 * OpenIB.org BSD license below:

 *

 *     Redistribution and use in source and binary forms, with or

 *     without modification, are permitted provided that the following

 *     conditions are met:

 *

 *      - Redistributions of source code must retain the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer.

 *

 *      - Redistributions in binary form must reproduce the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer in the documentation and/or other materials

 *        provided with the distribution.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS

 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN

 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN

 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

 generic seq_file support for showing a table of size rows x width. */

/* Trim the size of a seq_tab to the supplied number of rows.  The operation is

 * irreversible.

 Status */

 Inst */

 Data */

 PC */

 LS0 Stat, Addr and Data */

 LS1 Stat, Addr and Data */

 +1 to account for integer division of CIMLA_SIZE/10 */

/* Show the PM memory stats.  These stats include:

 *

 * TX:

 *   Read: memory read operation

 *   Write Bypass: cut-through

 *   Bypass + mem: cut-through and save copy

 *

 * RX:

 *   Read: memory read

 *   Write Bypass: cut-through

 *   Flush: payload trim or drop

		/* In T5 the granularity of the total wait is too fine.

		 * It is not useful as it reaches the max value too fast.

		 * Hence display this Input FIFO wait for T6 onwards.

 Skip index 6 as there is nothing useful ihere */

		/* At index 7, a new stat for read latency (count, total wait)

		 * is added.

/* Format a value in a unit that differs from the value's native unit by the

 * given factor.

 in ps */

 in us */

 Firmware Device Log dump. */

/* Information gathered by Device Log Open routine for the display routine.

 number of entries in log[] */

 first [temporal] entry in log[] */

 Firmware Device Log */

/* Dump a Firmaware Device Log entry.

		/* Get a pointer to the log entry to display.  Skip unused log

		 * entries.

		/* Print the message.  This depends on the firmware using

		 * exactly the same formating strings as the kernel so we may

		 * eventually have to put a format interpreter in here ...

/* Sequential File Operations for Device Log.

/* Set up for reading the firmware's device log.  We read the entire log here

 * and then display it incrementally in devlog_show().

	/* If we don't know where the log is we can't do anything.

	/* Allocate the space to read in the firmware's device log and set up

	 * for the iterated call to our display function.

	/* Record the basic log buffer information and read in the raw log.

	/* Find the earliest (lowest Sequence Number) log entry in the

	 * circular Device Log.

/* Show Firmware Mailbox Command/Reply Log

 *

 * Note that we don't do any locking when dumping the Firmware Mailbox Log so

 * it's possible that we can catch things during a log update and therefore

 * see partially corrupted log entries.  But it's probably Good Enough(tm).

 * If we ever decide that we want to make sure that we're dumping a coherent

 * log, we'd need to perform locking in the mailbox logging and in

 * mboxlog_open() where we'd need to grab the entire mailbox log in one go

 * like we do for the Firmware Device Log.

 skip over unused entries */

	/* For T4 we don't have a shadow copy of the Mailbox Control register.

	 * And since reading that real register causes a side effect of

	 * granting ownership, we're best of simply not reading it at all.

 index of "<unread>" */

/* Set an MPS trace filter.  Syntax is:

 *

 * disable

 *

 * to disable tracing, or

 *

 * interface qid=<qid no> [snaplen=<val>] [minlen=<val>] [not] [<pattern>]...

 *

 * where interface is one of rxN, txN, or loopbackN, N = 0..3, qid can be one

 * of the NIC's response qid obtained from sge_qinfo and pattern has the form

 *

 * <pattern data>[/<pattern mask>][@<anchor>]

 *

 * Up to 2 filter patterns can be specified.  If 2 are supplied the first one

 * must be anchored at 0.  An omitted mask is taken as a mask of 1s, an omitted

 * anchor is taken as 0.

	/* Don't accept input more than 1K, can't be anything valid except lots

	 * of whitespace.  Well, use less.

 enable or disable trace multi rss filter */

 counts pattern nibbles */

 we have found a trace pattern */

 split pattern */

 too many splits */

 mask longer than data */

 mask shorter than data */

 no mask, use all 1s */

 doesn't start at multiple of 8 */

 overlaps earlier pattern */

 skip too big */

 8-byte align */

			/* CtlCmdType - 0: Read, 1: Write

			 * CtlTcamSel - 0: TCAM0, 1: TCAM1

			 * CtlXYBitSel- 0: Y bit, 1: X bit

 Read tcamy */

			/* 0 - Outer header, 1 - Inner header

			 * [71:48] bit locations are overloaded for

			 * outer vs. inner lookup types.

 Inner header VNI */

 Read tcamx. Change the control param */

 Inner header VNI mask */

 Inner header lookup */

/* Display various sensor information.

	/* Note that if the sensors haven't been initialized and turned on

	 * we'll get values of 0, so treat those as "<unknown>" ...

/*RSS Table.

/* RSS Configuration.

/* Small utility function to return the strings "yes" or "no" if the supplied

 * argument is non-zero.

/* RSS Secret Key.

/* PF RSS Configuration.

 use the 0th entry to dump the PF Map Index Size */

/* VF RSS Configuration.

/* Data Center Briging information for each port.

 skip empty slots */

 CONFIG_CHELSIO_T4_DCB */

/**

 * ethqset2pinfo - return port_info of an Ethernet Queue Set

 * @adap: the adapter

 * @qset: Ethernet Queue Set

 should never happen! */

 includes ,/\n/\0 */

 skip holes */

 For T6 these are MAC buffer groups */

 For T6 these are MAC buffer groups */

/* Add an array of Debug FS files.

 debugfs support is best effort */

	/* Debug FS nodes common to all T5 and later adapters.

/*

 * This file is part of the Chelsio T4/T5/T6 Ethernet driver for Linux.

 *

 * Copyright (c) 2017 Chelsio Communications, Inc. All rights reserved.

 *

 * This software is available to you under a choice of one of two

 * licenses.  You may choose to be licensed under the terms of the GNU

 * General Public License (GPL) Version 2, available from the file

 * COPYING in the main directory of this source tree, or the

 * OpenIB.org BSD license below:

 *

 *     Redistribution and use in source and binary forms, with or

 *     without modification, are permitted provided that the following

 *     conditions are met:

 *

 *      - Redistributions of source code must retain the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer.

 *

 *      - Redistributions in binary form must reproduce the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer in the documentation and/or other materials

 *        provided with the distribution.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS

 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN

 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN

 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

				/* This entry is actually in use. See if we can

				 * re-use it ?

 hasn't been recycled */

/**

 * cxgb4_smt_release - Release SMT entry

 * @e: smt entry to release

 *

 * Releases ref count and frees up an smt entry from SMT table

		/* Source MAC Table (SMT) contains 256 SMAC entries

		 * organized in 128 rows of 2 entries each.

		/* Each row contains an SMAC pair.

		 * LSB selects the SMAC entry within a row

			/* fill pfvf0/src_mac0 with entry

			 * at prev index from smt-tab.

			/* fill pfvf1/src_mac1 with entry

			 * at next index from smt-tab

 Source MAC Table (SMT) contains 256 SMAC entries */

 fill pfvf0/src_mac0 from smt-tab */

/**

 * cxgb4_smt_alloc_switching - Allocates an SMT entry for switch filters.

 * @dev: net_device pointer

 * @smac: MAC address to add to SMT

 * Returns pointer to the SMT entry created

 *

 * Allocates an SMT entry to be used by switching rule of a filter.

/*

 * libcxgb_ppm.c: Chelsio common library for T3/T4/T5 iSCSI PagePod Manager

 *

 * Copyright (c) 2016 Chelsio Communications, Inc. All rights reserved.

 *

 * This software is available to you under a choice of one of two

 * licenses.  You may choose to be licensed under the terms of the GNU

 * General Public License (GPL) Version 2, available from the file

 * COPYING in the main directory of this source tree, or the

 * OpenIB.org BSD license below:

 *

 *     Redistribution and use in source and binary forms, with or

 *     without modification, are permitted provided that the following

 *     conditions are met:

 *

 *      - Redistributions of source code must retain the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer.

 *

 *      - Redistributions in binary form must reproduce the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer in the documentation and/or other materials

 *        provided with the distribution.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS

 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN

 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN

 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

 *

 * Written by: Karen Xie (kxie@chelsio.com)

/* Direct Data Placement -

 * Directly place the iSCSI Data-In or Data-Out PDU's payload into

 * pre-posted final destination host-memory buffers based on the

 * Initiator Task Tag (ITT) in Data-In or Target Task Tag (TTT)

 * in Data-Out PDUs. The host memory address is programmed into

 * h/w in the format of pagepod entries. The location of the

 * pagepod entry is encoded into ddp tag which is used as the base

 * for ITT/TTT.

/* Direct-Data Placement page size adjustment

/* DDP setup & teardown

 grab from cpu pool first */

 try the general pool */

	/* The ddp tag in pagepod should be with bit 31:30 set to 0.

	 * The ddp Tag on the wire should be with non-zero 31:30 to the peer

 make sure per cpu pool fits into PCPU_MIN_UNIT_SIZE */

 pool size must be multiple of unsigned long */

 check one more time */

/*

 * Copyright (c) 2016 Chelsio Communications, Inc. All rights reserved.

 *

 * This software is available to you under a choice of one of two

 * licenses.  You may choose to be licensed under the terms of the GNU

 * General Public License (GPL) Version 2, available from the file

 * COPYING in the main directory of this source tree, or the

 * OpenIB.org BSD license below:

 *

 *     Redistribution and use in source and binary forms, with or

 *     without modification, are permitted provided that the following

 *     conditions are met:

 *

 *      - Redistributions of source code must retain the above

 *	  copyright notice, this list of conditions and the following

 *	  disclaimer.

 *

 *      - Redistributions in binary form must reproduce the above

 *	  copyright notice, this list of conditions and the following

 *	  disclaimer in the documentation and/or other materials

 *	  provided with the distribution.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS

 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN

 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN

 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

/*

 * This file is part of the Chelsio T4 PCI-E SR-IOV Virtual Function Ethernet

 * driver for Linux.

 *

 * Copyright (c) 2009-2010 Chelsio Communications, Inc. All rights reserved.

 *

 * This software is available to you under a choice of one of two

 * licenses.  You may choose to be licensed under the terms of the GNU

 * General Public License (GPL) Version 2, available from the file

 * COPYING in the main directory of this source tree, or the

 * OpenIB.org BSD license below:

 *

 *     Redistribution and use in source and binary forms, with or

 *     without modification, are permitted provided that the following

 *     conditions are met:

 *

 *      - Redistributions of source code must retain the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer.

 *

 *      - Redistributions in binary form must reproduce the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer in the documentation and/or other materials

 *        provided with the distribution.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS

 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN

 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN

 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

/*

 * Wait for the device to become ready (signified by our "who am I" register

 * returning a value other than all 1's).  Return an error if it doesn't

 * become ready ...

/*

 * Get the reply to a mailbox command and store it in @rpl in big-endian order

 * (since the firmware data structures are specified in a big-endian layout).

/**

 *	t4vf_record_mbox - record a Firmware Mailbox Command/Reply in the log

 *	@adapter: the adapter

 *	@cmd: the Firmware Mailbox Command or Reply

 *	@size: command length in bytes

 *	@access: the time (ms) needed to access the Firmware Mailbox

 *	@execute: the time (ms) the command spent being executed

/**

 *	t4vf_wr_mbox_core - send a command to FW through the mailbox

 *	@adapter: the adapter

 *	@cmd: the command to write

 *	@size: command length in bytes

 *	@rpl: where to optionally store the reply

 *	@sleep_ok: if true we may sleep while awaiting command completion

 *

 *	Sends the given command to FW through the mailbox and waits for the

 *	FW to execute the command.  If @rpl is not %NULL it is used to store

 *	the FW's reply to the command.  The command and its optional reply

 *	are of the same length.  FW can take up to 500 ms to respond.

 *	@sleep_ok determines whether we may sleep while awaiting the response.

 *	If sleeping is allowed we use progressive backoff otherwise we spin.

 *

 *	The return value is 0 on success or a negative errno on failure.  A

 *	failure can happen either because we are not able to execute the

 *	command or FW executes it but signals an error.  In the latter case

 *	the return value is the error code indicated by FW (negated).

	/* In T6, mailbox size is changed to 128 bytes to avoid

	 * invalidating the entire prefetch buffer.

	/*

	 * Commands must be multiples of 16 bytes in length and may not be

	 * larger than the size of the Mailbox Data register array.

	/* Queue ourselves onto the mailbox access list.  When our entry is at

	 * the front of the list, we have rights to access the mailbox.  So we

	 * wait [for a while] till we're at the front [or bail out with an

	 * EBUSY] ...

		/* If we've waited too long, return a busy indication.  This

		 * really ought to be based on our initial position in the

		 * mailbox access list but this is a start.  We very rearely

		 * contend on access to the mailbox ...

		/* If we're at the head, break out and start the mailbox

		 * protocol.

 Delay for a bit before checking again ... */

 last element may repeat */

	/*

	 * Loop trying to get ownership of the mailbox.  Return an error

	 * if we can't gain ownership.

	/*

	 * Write the command array into the Mailbox Data register array and

	 * transfer ownership of the mailbox to the firmware.

	 *

	 * For the VFs, the Mailbox Data "registers" are actually backed by

	 * T4's "MA" interface rather than PL Registers (as is the case for

	 * the PFs).  Because these are in different coherency domains, the

	 * write to the VF's PL-register-backed Mailbox Control can race in

	 * front of the writes to the MA-backed VF Mailbox Data "registers".

	 * So we need to do a read-back on at least one byte of the VF Mailbox

	 * Data registers before doing the write to the VF Mailbox Control

	 * register.

 flush write */

 flush write */

	/*

	 * Spin waiting for firmware to acknowledge processing our command.

		/*

		 * If we're the owner, see if this is the reply we wanted.

			/*

			 * If the Message Valid bit isn't on, revoke ownership

			 * of the mailbox and continue waiting for our reply.

			/*

			 * We now have our reply.  Extract the command return

			 * value, copy the reply back to our caller's buffer

			 * (if specified) and revoke ownership of the mailbox.

			 * We return the (negated) firmware command return

			 * code (this depends on FW_SUCCESS == 0).

 return value in low-order little-endian word */

 request bit in high-order BE word */

 We timed out.  Return the error ... */

/* In the Physical Function Driver Common Code, the ADVERT_MASK is used to

 * mask out bits in the Advertised Port Capabilities which are managed via

 * separate controls, like Pause Frames and Forward Error Correction.  In the

 * Virtual Function Common Code, since we never perform L1 Configuration on

 * the Link, the only things we really need to filter out are things which

 * we decode and report separately like Speed.

/**

 *	fwcaps16_to_caps32 - convert 16-bit Port Capabilities to 32-bits

 *	@caps16: a 16-bit Port Capabilities value

 *

 *	Returns the equivalent 32-bit Port Capabilities value.

 Translate Firmware Pause specification to Common Code */

 Translate Firmware Forward Error Correction specification to Common Code */

 Return the highest speed set in the port capabilities, in Mb/s. */

/**

 *      fwcap_to_fwspeed - return highest speed in Port Capabilities

 *      @acaps: advertised Port Capabilities

 *

 *      Get the highest speed for the port from the advertised Port

 *      Capabilities.  It will be either the highest speed from the list of

 *      speeds or whatever user has set using ethtool.

/*

 *	init_link_config - initialize a link's SW state

 *	@lc: structure holding the link state

 *	@pcaps: link Port Capabilities

 *	@acaps: link current Advertised Port Capabilities

 *

 *	Initializes the SW state maintained for each link, including the link's

 *	capabilities and default speed/flow-control/autonegotiation settings.

	/* For Forward Error Control, we default to whatever the Firmware

	 * tells us the Link is currently advertising.

	/* If the Port is capable of Auto-Negtotiation, initialize it as

	 * "enabled" and copy over all of the Physical Port Capabilities

	 * to the Advertised Port Capabilities.  Otherwise mark it as

	 * Auto-Negotiate disabled and select the highest supported speed

	 * for the link.  Note parallel structure in t4_link_l1cfg_core()

	 * and t4_handle_get_port_info().

/**

 *	t4vf_port_init - initialize port hardware/software state

 *	@adapter: the adapter

 *	@pidx: the adapter port index

	/* If we haven't yet determined whether we're talking to Firmware

	 * which knows the new 32-bit Port Capabilities, it's time to find

	 * out now.  This will also tell new Firmware to send us Port Status

	 * Updates using the new 32-bit Port Capabilities version of the

	 * Port Information message.

	/*

	 * Execute a VI Read command to get our Virtual Interface information

	 * like MAC address, etc.

	/*

	 * If we don't have read access to our port information, we're done

	 * now.  Otherwise, execute a PORT Read command to get it ...

 Extract the various fields from the Port Information message. */

/**

 *      t4vf_fw_reset - issue a reset to FW

 *      @adapter: the adapter

 *

 *	Issues a reset command to FW.  For a Physical Function this would

 *	result in the Firmware resetting all of its state.  For a Virtual

 *	Function this just resets the state associated with the VF.

/**

 *	t4vf_query_params - query FW or device parameters

 *	@adapter: the adapter

 *	@nparams: the number of parameters

 *	@params: the parameter names

 *	@vals: the parameter values

 *

 *	Reads the values of firmware or device parameters.  Up to 7 parameters

 *	can be queried at once.

/**

 *	t4vf_set_params - sets FW or device parameters

 *	@adapter: the adapter

 *	@nparams: the number of parameters

 *	@params: the parameter names

 *	@vals: the parameter values

 *

 *	Sets the values of firmware or device parameters.  Up to 7 parameters

 *	can be specified at once.

/**

 *	t4vf_fl_pkt_align - return the fl packet alignment

 *	@adapter: the adapter

 *

 *	T4 has a single field to specify the packing and padding boundary.

 *	T5 onwards has separate fields for this and hence the alignment for

 *	next packet offset is maximum of these two.  And T6 changes the

 *	Ingress Padding Boundary Shift, so it's all a mess and it's best

 *	if we put this in low-level Common Code ...

 *

	/* T4 uses a single control field to specify both the PCIe Padding and

	 * Packing Boundary.  T5 introduced the ability to specify these

	 * separately.  The actual Ingress Packet Data alignment boundary

	 * within Packed Buffer Mode is the maximum of these two

	 * specifications.  (Note that it makes no real practical sense to

	 * have the Pading Boudary be larger than the Packing Boundary but you

	 * could set the chip up that way and, in fact, legacy T4 code would

	 * end doing this because it would initialize the Padding Boundary and

	 * leave the Packing Boundary initialized to 0 (16 bytes).)

	 * Padding Boundary values in T6 starts from 8B,

	 * where as it is 32B for T4 and T5.

		/* T5 has a different interpretation of one of the PCIe Packing

		 * Boundary values.

/**

 *	t4vf_bar2_sge_qregs - return BAR2 SGE Queue register information

 *	@adapter: the adapter

 *	@qid: the Queue ID

 *	@qtype: the Ingress or Egress type for @qid

 *	@pbar2_qoffset: BAR2 Queue Offset

 *	@pbar2_qid: BAR2 Queue ID or 0 for Queue ID inferred SGE Queues

 *

 *	Returns the BAR2 SGE Queue Registers information associated with the

 *	indicated Absolute Queue ID.  These are passed back in return value

 *	pointers.  @qtype should be T4_BAR2_QTYPE_EGRESS for Egress Queue

 *	and T4_BAR2_QTYPE_INGRESS for Ingress Queues.

 *

 *	This may return an error which indicates that BAR2 SGE Queue

 *	registers aren't available.  If an error is not returned, then the

 *	following values are returned:

 *

 *	  *@pbar2_qoffset: the BAR2 Offset of the @qid Registers

 *	  *@pbar2_qid: the BAR2 SGE Queue ID or 0 of @qid

 *

 *	If the returned BAR2 Queue ID is 0, then BAR2 SGE registers which

 *	require the "Inferred Queue ID" ability may be used.  E.g. the

 *	Write Combining Doorbell Buffer. If the BAR2 Queue ID is not 0,

 *	then these "Inferred Queue ID" register may not be used.

	/* T4 doesn't support BAR2 SGE Queue registers.

	/* Get our SGE Page Size parameters.

	/* Get the right Queues per Page parameters for our Queue.

	/* Calculate the basics of the BAR2 SGE Queue register area:

	 *  o The BAR2 page the Queue registers will be in.

	 *  o The BAR2 Queue ID.

	 *  o The BAR2 Queue ID Offset into the BAR2 page.

	/* If the BAR2 Queue ID Offset is less than the Page Size, then the

	 * hardware will infer the Absolute Queue ID simply from the writes to

	 * the BAR2 Queue ID Offset within the BAR2 Page (and we need to use a

	 * BAR2 Queue ID of 0 for those writes).  Otherwise, we'll simply

	 * write to the first BAR2 SGE Queue Area within the BAR2 Page with

	 * the BAR2 Queue ID and the hardware will infer the Absolute Queue ID

	 * from the BAR2 Page and BAR2 Queue ID.

	 *

	 * One important censequence of this is that some BAR2 SGE registers

	 * have a "Queue ID" field and we can write the BAR2 SGE Queue ID

	 * there.  But other registers synthesize the SGE Queue ID purely

	 * from the writes to the registers -- the Write Combined Doorbell

	 * Buffer is a good example.  These BAR2 SGE Registers are only

	 * available for those BAR2 SGE Register areas where the SGE Absolute

	 * Queue ID can be inferred from simple writes.

/**

 *	t4vf_get_sge_params - retrieve adapter Scatter gather Engine parameters

 *	@adapter: the adapter

 *

 *	Retrieves various core SGE parameters in the form of hardware SGE

 *	register values.  The caller is responsible for decoding these as

 *	needed.  The SGE parameters are stored in @adapter->params.sge.

	/* T4 uses a single control field to specify both the PCIe Padding and

	 * Packing Boundary.  T5 introduced the ability to specify these

	 * separately with the Padding Boundary in SGE_CONTROL and and Packing

	 * Boundary in SGE_CONTROL2.  So for T5 and later we need to grab

	 * SGE_CONTROL in order to determine how ingress packet data will be

	 * laid out in Packed Buffer Mode.  Unfortunately, older versions of

	 * the firmware won't let us retrieve SGE_CONTROL2 so if we get a

	 * failure grabbing it we throw an error since we can't figure out the

	 * right value.

	/* For T5 and later we want to use the new BAR2 Doorbells.

	 * Unfortunately, older firmware didn't allow the this register to be

	 * read.

		/* We need the Queues/Page for our VF.  This is based on the

		 * PF from which we're instantiated and is indexed in the

		 * register we just read. Do it once here so other code in

		 * the driver can just use it.

/**

 *	t4vf_get_vpd_params - retrieve device VPD paremeters

 *	@adapter: the adapter

 *

 *	Retrives various device Vital Product Data parameters.  The parameters

 *	are stored in @adapter->params.vpd.

/**

 *	t4vf_get_dev_params - retrieve device paremeters

 *	@adapter: the adapter

 *

 *	Retrives various device parameters.  The parameters are stored in

 *	@adapter->params.dev.

/**

 *	t4vf_get_rss_glb_config - retrieve adapter RSS Global Configuration

 *	@adapter: the adapter

 *

 *	Retrieves global RSS mode and parameters with which we have to live

 *	and stores them in the @adapter's RSS parameters.

	/*

	 * Execute an RSS Global Configuration read command to retrieve

	 * our RSS configuration.

	/*

	 * Transate the big-endian RSS Global Configuration into our

	 * cpu-endian format based on the RSS mode.  We also do first level

	 * filtering at this point to weed out modes which don't support

	 * VF Drivers ...

 we need at least Tunnel Map Enable to be set */

 all unknown/unsupported RSS modes result in an error */

/**

 *	t4vf_get_vfres - retrieve VF resource limits

 *	@adapter: the adapter

 *

 *	Retrieves configured resource limits and capabilities for a virtual

 *	function.  The results are stored in @adapter->vfres.

	/*

	 * Execute PFVF Read command to get VF resource limits; bail out early

	 * with error on command failure.

	/*

	 * Extract VF resource limits and return success.

/**

 *	t4vf_read_rss_vi_config - read a VI's RSS configuration

 *	@adapter: the adapter

 *	@viid: Virtual Interface ID

 *	@config: pointer to host-native VI RSS Configuration buffer

 *

 *	Reads the Virtual Interface's RSS configuration information and

 *	translates it into CPU-native format.

/**

 *	t4vf_write_rss_vi_config - write a VI's RSS configuration

 *	@adapter: the adapter

 *	@viid: Virtual Interface ID

 *	@config: pointer to host-native VI RSS Configuration buffer

 *

 *	Write the Virtual Interface's RSS configuration information

 *	(translating it into firmware-native format before writing).

/**

 *	t4vf_config_rss_range - configure a portion of the RSS mapping table

 *	@adapter: the adapter

 *	@viid: Virtual Interface of RSS Table Slice

 *	@start: starting entry in the table to write

 *	@n: how many table entries to write

 *	@rspq: values for the "Response Queue" (Ingress Queue) lookup table

 *	@nrspq: number of values in @rspq

 *

 *	Programs the selected part of the VI's RSS mapping table with the

 *	provided values.  If @nrspq < @n the supplied values are used repeatedly

 *	until the full table range is populated.

 *

 *	The caller must ensure the values in @rspq are in the range 0..1023.

	/*

	 * Initialize firmware command template to write the RSS table.

	/*

	 * Each firmware RSS command can accommodate up to 32 RSS Ingress

	 * Queue Identifiers.  These Ingress Queue IDs are packed three to

	 * a 32-bit word as 10-bit values with the upper remaining 2 bits

	 * reserved.

		/*

		 * Set up the firmware RSS command header to send the next

		 * "nq" Ingress Queue IDs to the firmware.

		/*

		 * "nq" more done for the start of the next loop.

		/*

		 * While there are still Ingress Queue IDs to stuff into the

		 * current firmware RSS command, retrieve them from the

		 * Ingress Queue ID array and insert them into the command.

			/*

			 * Grab up to the next 3 Ingress Queue IDs (wrapping

			 * around the Ingress Queue ID array if necessary) and

			 * insert them into the firmware RSS command at the

			 * current 3-tuple position within the commad.

		/*

		 * Send this portion of the RRS table update to the firmware;

		 * bail out on any errors.

/**

 *	t4vf_alloc_vi - allocate a virtual interface on a port

 *	@adapter: the adapter

 *	@port_id: physical port associated with the VI

 *

 *	Allocate a new Virtual Interface and bind it to the indicated

 *	physical port.  Return the new Virtual Interface Identifier on

 *	success, or a [negative] error number on failure.

	/*

	 * Execute a VI command to allocate Virtual Interface and return its

	 * VIID.

/**

 *	t4vf_free_vi -- free a virtual interface

 *	@adapter: the adapter

 *	@viid: the virtual interface identifier

 *

 *	Free a previously allocated Virtual Interface.  Return an error on

 *	failure.

	/*

	 * Execute a VI command to free the Virtual Interface.

/**

 *	t4vf_enable_vi - enable/disable a virtual interface

 *	@adapter: the adapter

 *	@viid: the Virtual Interface ID

 *	@rx_en: 1=enable Rx, 0=disable Rx

 *	@tx_en: 1=enable Tx, 0=disable Tx

 *

 *	Enables/disables a virtual interface.

/**

 *	t4vf_enable_pi - enable/disable a Port's virtual interface

 *	@adapter: the adapter

 *	@pi: the Port Information structure

 *	@rx_en: 1=enable Rx, 0=disable Rx

 *	@tx_en: 1=enable Tx, 0=disable Tx

 *

 *	Enables/disables a Port's virtual interface.  If the Virtual

 *	Interface enable/disable operation is successful, we notify the

 *	OS-specific code of a potential Link Status change via the OS Contract

 *	API t4vf_os_link_changed().

/**

 *	t4vf_identify_port - identify a VI's port by blinking its LED

 *	@adapter: the adapter

 *	@viid: the Virtual Interface ID

 *	@nblinks: how many times to blink LED at 2.5 Hz

 *

 *	Identifies a VI's port by blinking its LED.

/**

 *	t4vf_set_rxmode - set Rx properties of a virtual interface

 *	@adapter: the adapter

 *	@viid: the VI id

 *	@mtu: the new MTU or -1 for no change

 *	@promisc: 1 to enable promiscuous mode, 0 to disable it, -1 no change

 *	@all_multi: 1 to enable all-multi mode, 0 to disable it, -1 no change

 *	@bcast: 1 to enable broadcast Rx, 0 to disable it, -1 no change

 *	@vlanex: 1 to enable hardware VLAN Tag extraction, 0 to disable it,

 *		-1 no change

 *	@sleep_ok: call is allowed to sleep

 *

 *	Sets Rx properties of a virtual interface.

 convert to FW values */

/**

 *	t4vf_alloc_mac_filt - allocates exact-match filters for MAC addresses

 *	@adapter: the adapter

 *	@viid: the Virtual Interface Identifier

 *	@free: if true any existing filters for this VI id are first removed

 *	@naddr: the number of MAC addresses to allocate filters for (up to 7)

 *	@addr: the MAC address(es)

 *	@idx: where to store the index of each allocated filter

 *	@hash: pointer to hash address filter bitmap

 *	@sleep_ok: call is allowed to sleep

 *

 *	Allocates an exact-match filter for each of the supplied addresses and

 *	sets it to the corresponding address.  If @idx is not %NULL it should

 *	have at least @naddr entries, each of which will be set to the index of

 *	the filter allocated for the corresponding MAC address.  If a filter

 *	could not be allocated for an address its index is set to 0xffff.

 *	If @hash is not %NULL addresses that fail to allocate an exact filter

 *	are hashed and update the hash filter bitmap pointed at by @hash.

 *

 *	Returns a negative error number or the number of filters allocated.

*/) {

	/*

	 * If there were no errors or we merely ran out of room in our MAC

	 * address arena, return the number of filters actually written.

/**

 *	t4vf_free_mac_filt - frees exact-match filters of given MAC addresses

 *	@adapter: the adapter

 *	@viid: the VI id

 *	@naddr: the number of MAC addresses to allocate filters for (up to 7)

 *	@addr: the MAC address(es)

 *	@sleep_ok: call is allowed to sleep

 *

 *	Frees the exact-match filter for each of the supplied addresses

 *

 *	Returns a negative error number or the number of filters freed.

*/) {

/**

 *	t4vf_change_mac - modifies the exact-match filter for a MAC address

 *	@adapter: the adapter

 *	@viid: the Virtual Interface ID

 *	@idx: index of existing filter for old value of MAC address, or -1

 *	@addr: the new MAC address value

 *	@persist: if idx < 0, the new MAC allocation should be persistent

 *

 *	Modifies an exact-match filter and sets it to the new MAC address.

 *	Note that in general it is not possible to modify the value of a given

 *	filter so the generic way to modify an address filter is to free the

 *	one being used by the old address value and allocate a new filter for

 *	the new address value.  @idx can be -1 if the address is a new

 *	addition.

 *

 *	Returns a negative error number or the index of the filter with the new

 *	MAC value.

	/*

	 * If this is a new allocation, determine whether it should be

	 * persistent (across a "freemacs" operation) or not.

/**

 *	t4vf_set_addr_hash - program the MAC inexact-match hash filter

 *	@adapter: the adapter

 *	@viid: the Virtual Interface Identifier

 *	@ucast: whether the hash filter should also match unicast addresses

 *	@vec: the value to be written to the hash filter

 *	@sleep_ok: call is allowed to sleep

 *

 *	Sets the 64-bit inexact-match hash filter for a virtual interface.

/**

 *	t4vf_get_port_stats - collect "port" statistics

 *	@adapter: the adapter

 *	@pidx: the port index

 *	@s: the stats structure to fill

 *

 *	Collect statistics for the "port"'s Virtual Interface.

	/*

	 * Grab the Virtual Interface statistics a chunk at a time via mailbox

	 * commands.  We could use a Work Request and get all of them at once

	 * but that's an asynchronous interface which is awkward to use.

	/*

	 * Translate firmware statistics into host native statistics.

/**

 *	t4vf_iq_free - free an ingress queue and its free lists

 *	@adapter: the adapter

 *	@iqtype: the ingress queue type (FW_IQ_TYPE_FL_INT_CAP, etc.)

 *	@iqid: ingress queue ID

 *	@fl0id: FL0 queue ID or 0xffff if no attached FL0

 *	@fl1id: FL1 queue ID or 0xffff if no attached FL1

 *

 *	Frees an ingress queue and its associated free lists, if any.

/**

 *	t4vf_eth_eq_free - free an Ethernet egress queue

 *	@adapter: the adapter

 *	@eqid: egress queue ID

 *

 *	Frees an Ethernet egress queue.

/**

 *	t4vf_link_down_rc_str - return a string for a Link Down Reason Code

 *	@link_down_rc: Link Down Reason Code

 *

 *	Returns a string representation of the Link Down Reason Code.

/**

 *	t4vf_handle_get_port_info - process a FW reply message

 *	@pi: the port info

 *	@cmd: start of the FW message

 *

 *	Processes a GET_PORT_INFO FW reply message.

 Extract the various fields from the Port Information message. */

		/* Unfortunately the format of the Link Status in the old

		 * 16-bit Port Information message isn't the same as the

		 * 16-bit Port Capabilities bitfield used everywhere else ...

		/* When a new Transceiver Module is inserted, the Firmware

		 * will examine any Forward Error Correction parameters

		 * present in the Transceiver Module i2c EPROM and determine

		 * the supported and recommended FEC settings from those

		 * based on IEEE 802.3 standards.  We always record the

		 * IEEE 802.3 recommended "automatic" settings.

		/* Some versions of the early T6 Firmware "cheated" when

		 * handling different Transceiver Modules by changing the

		 * underlaying Port Type reported to the Host Drivers.  As

		 * such we need to capture whatever Port Type the Firmware

		 * sends us and record it in case it's different from what we

		 * were told earlier.  Unfortunately, since Firmware is

		 * forever, we'll need to keep this code here forever, but in

		 * later T6 Firmware it should just be an assignment of the

		 * same value already recorded.

 something changed */

		/* If we're not physically capable of Auto-Negotiation, note

		 * this as Auto-Negotiation disabled.  Otherwise, we track

		 * what Auto-Negotiation settings we have.  Note parallel

		 * structure in init_link_config().

			/* When Autoneg is disabled, user needs to set

			 * single speed.

			 * Similar to cxgb4_ethtool.c: set_link_ksettings

/**

 *	t4vf_update_port_info - retrieve and update port information if changed

 *	@pi: the port_info

 *

 *	We issue a Get Port Information Command to the Firmware and, if

 *	successful, we check to see if anything is different from what we

 *	last recorded and update things accordingly.

/**

 *	t4vf_handle_fw_rpl - process a firmware reply message

 *	@adapter: the adapter

 *	@rpl: start of the firmware message

 *

 *	Processes a firmware message, such as link state change messages.

		/*

		 * Link/module state change message.

	/* Wait for the device to become ready before proceeding ...

	/* Default port and clock for debugging in case we can't reach

	 * firmware.

/**

 *	t4vf_get_vf_mac_acl - Get the MAC address to be set to

 *			      the VI of this VF.

 *	@adapter: The adapter

 *	@port: The port associated with vf

 *	@naddr: the number of ACL MAC addresses returned in addr

 *	@addr: Placeholder for MAC addresses

 *

 *	Find the MAC address to be set to the VF's VI. The requested MAC address

 *	is from the host OS via callback in the PF driver.

/**

 *	t4vf_get_vf_vlan_acl - Get the VLAN ID to be set to

 *                             the VI of this VF.

 *	@adapter: The adapter

 *

 *	Find the VLAN ID to be set to the VF's VI. The requested VLAN ID

 *	is from the host OS via callback in the PF driver.

 Note: Do not enable the ACL */

/*

 * This file is part of the Chelsio T4 PCI-E SR-IOV Virtual Function Ethernet

 * driver for Linux.

 *

 * Copyright (c) 2009-2010 Chelsio Communications, Inc. All rights reserved.

 *

 * This software is available to you under a choice of one of two

 * licenses.  You may choose to be licensed under the terms of the GNU

 * General Public License (GPL) Version 2, available from the file

 * COPYING in the main directory of this source tree, or the

 * OpenIB.org BSD license below:

 *

 *     Redistribution and use in source and binary forms, with or

 *     without modification, are permitted provided that the following

 *     conditions are met:

 *

 *      - Redistributions of source code must retain the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer.

 *

 *      - Redistributions in binary form must reproduce the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer in the documentation and/or other materials

 *        provided with the distribution.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS

 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN

 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN

 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

/*

 * Constants ...

	/*

	 * Egress Queue sizes, producer and consumer indices are all in units

	 * of Egress Context Units bytes.  Note that as far as the hardware is

	 * concerned, the free list is an Egress Queue (the host produces free

	 * buffers which the hardware consumes) and free list entries are

	 * 64-bit PCI DMA addresses.

	/*

	 * Max number of TX descriptors we clean up at a time.  Should be

	 * modest as freeing skbs isn't cheap and it happens while holding

	 * locks.  We just need to free packets faster than they arrive, we

	 * eventually catch up and keep the amortized cost reasonable.

	/*

	 * Max number of Rx buffers we replenish at a time.  Again keep this

	 * modest, allocating buffers isn't cheap either.

	/*

	 * Period of the Rx queue check timer.  This timer is infrequent as it

	 * has something to do only when the system experiences severe memory

	 * shortage.

	/*

	 * Period of the TX queue check timer and the maximum number of TX

	 * descriptors to be reclaimed by the TX timer.

	/*

	 * Suspend an Ethernet TX queue with fewer available descriptors than

	 * this.  We always want to have room for a maximum sized packet:

	 * inline immediate data + MAX_SKB_FRAGS. This is the same as

	 * calc_tx_flits() for a TSO packet with nr_frags == MAX_SKB_FRAGS

	 * (see that function and its helpers for a description of the

	 * calculation).

	/*

	 * Max TX descriptor space we allow for an Ethernet packet to be

	 * inlined into a WR.  This is limited by the maximum value which

	 * we can specify for immediate data in the firmware Ethernet TX

	 * Work Request.

	/*

	 * Max size of a WR sent through a control TX queue.

	/*

	 * Maximum amount of data which we'll ever need to inline into a

	 * TX ring: max(MAX_IMM_TX_PKT_LEN, MAX_CTRL_WR_LEN).

	/*

	 * For incoming packets less than RX_COPY_THRES, we copy the data into

	 * an skb rather than referencing the data.  We allocate enough

	 * in-line room in skb's to accommodate pulling in RX_PULL_LEN bytes

	 * of the data (header).

	/*

	 * Main body length for sk_buffs used for RX Ethernet packets with

	 * fragments.  Should be >= RX_PULL_LEN but possibly bigger to give

	 * pskb_may_pull() some room.

/*

 * Software state per TX descriptor.

 socket buffer of TX data source */

 scatter/gather list in TX Queue */

/*

 * Software state per RX Free List descriptor.  We keep track of the allocated

 * FL page, its size, and its PCI DMA address (if the page is mapped).  The FL

 * page size and its PCI DMA mapped state are stored in the low bits of the

 * PCI DMA address as per below.

 Free List page buffer */

 PCI DMA address (if mapped) */

   and flags (see below) */

/*

 * The low bits of rx_sw_desc.dma_addr have special meaning.  Note that the

 * SGE also uses the low 4 bits to determine the size of the buffer.  It uses

 * those bits to index into the SGE_FL_BUFFER_SIZE[index] register array.

 * Since we only use SGE_FL_BUFFER_SIZE0 and SGE_FL_BUFFER_SIZE1, these low 4

 * bits can only contain a 0 or a 1 to indicate which size buffer we're giving

 * to the SGE.  Thus, our software state of "is the buffer mapped for DMA" is

 * maintained in an inverse sense so the hardware never sees that bit high.

 buffer is SGE_FL_BUFFER_SIZE[1] */

 buffer is not mapped */

/**

 *	get_buf_addr - return DMA buffer address of software descriptor

 *	@sdesc: pointer to the software buffer descriptor

 *

 *	Return the DMA buffer address of a software descriptor (stripping out

 *	our low-order flag bits).

/**

 *	is_buf_mapped - is buffer mapped for DMA?

 *	@sdesc: pointer to the software buffer descriptor

 *

 *	Determine whether the buffer associated with a software descriptor in

 *	mapped for DMA or not.

/**

 *	need_skb_unmap - does the platform need unmapping of sk_buffs?

 *

 *	Returns true if the platform needs sk_buff unmapping.  The compiler

 *	optimizes away unnecessary code if this returns true.

/**

 *	txq_avail - return the number of available slots in a TX queue

 *	@tq: the TX queue

 *

 *	Returns the number of available descriptors in a TX queue.

/**

 *	fl_cap - return the capacity of a Free List

 *	@fl: the Free List

 *

 *	Returns the capacity of a Free List.  The capacity is less than the

 *	size because an Egress Queue Index Unit worth of descriptors needs to

 *	be left unpopulated, otherwise the Producer and Consumer indices PIDX

 *	and CIDX will match and the hardware will think the FL is empty.

/**

 *	fl_starving - return whether a Free List is starving.

 *	@adapter: pointer to the adapter

 *	@fl: the Free List

 *

 *	Tests specified Free List to see whether the number of buffers

 *	available to the hardware has falled below our "starvation"

 *	threshold.

/**

 *	map_skb -  map an skb for DMA to the device

 *	@dev: the egress net device

 *	@skb: the packet to map

 *	@addr: a pointer to the base of the DMA mapping array

 *

 *	Map an skb for DMA to the device and return an array of DMA addresses.

	/*

	 * the complexity below is because of the possibility of a wrap-around

	 * in the middle of an SGL

/**

 *	free_tx_desc - reclaims TX descriptors and their buffers

 *	@adapter: the adapter

 *	@tq: the TX queue to reclaim descriptors from

 *	@n: the number of descriptors to reclaim

 *	@unmap: whether the buffers should be unmapped for DMA

 *

 *	Reclaims TX descriptors from an SGE TX queue and frees the associated

 *	TX buffers.  Called with the TX queue lock held.

		/*

		 * If we kept a reference to the original TX skb, we need to

		 * unmap it from PCI DMA space (if required) and free it.

/*

 * Return the number of reclaimable descriptors in a TX queue.

/**

 *	reclaim_completed_tx - reclaims completed TX descriptors

 *	@adapter: the adapter

 *	@tq: the TX queue to reclaim completed descriptors from

 *	@unmap: whether the buffers should be unmapped for DMA

 *

 *	Reclaims TX descriptors that the SGE has indicated it has processed,

 *	and frees the associated buffers if possible.  Called with the TX

 *	queue locked.

		/*

		 * Limit the amount of clean up work we do at a time to keep

		 * the TX lock hold time O(1).

/**

 *	get_buf_size - return the size of an RX Free List buffer.

 *	@adapter: pointer to the associated adapter

 *	@sdesc: pointer to the software buffer descriptor

/**

 *	free_rx_bufs - free RX buffers on an SGE Free List

 *	@adapter: the adapter

 *	@fl: the SGE Free List to free buffers from

 *	@n: how many buffers to free

 *

 *	Release the next @n buffers on an SGE Free List RX queue.   The

 *	buffers must be made inaccessible to hardware before calling this

 *	function.

/**

 *	unmap_rx_buf - unmap the current RX buffer on an SGE Free List

 *	@adapter: the adapter

 *	@fl: the SGE Free List

 *

 *	Unmap the current buffer on an SGE Free List RX queue.   The

 *	buffer must be made inaccessible to HW before calling this function.

 *

 *	This is similar to @free_rx_bufs above but does not free the buffer.

 *	Do note that the FL still loses any further access to the buffer.

 *	This is used predominantly to "transfer ownership" of an FL buffer

 *	to another entity (typically an skb's fragment list).

/**

 *	ring_fl_db - righ doorbell on free list

 *	@adapter: the adapter

 *	@fl: the Free List whose doorbell should be rung ...

 *

 *	Tell the Scatter Gather Engine that there are new free list entries

 *	available.

	/* The SGE keeps track of its Producer and Consumer Indices in terms

	 * of Egress Queue Units so we can only tell it about integral numbers

	 * of multiples of Free List Entries per Egress Queue Units ...

		/* Make sure all memory writes to the Free List queue are

		 * committed before we tell the hardware about them.

		/* If we don't have access to the new User Doorbell (T5+), use

		 * the old doorbell mechanism; otherwise use the new BAR2

		 * mechanism.

			/* This Write memory Barrier will force the write to

			 * the User Doorbell area to be flushed.

/**

 *	set_rx_sw_desc - initialize software RX buffer descriptor

 *	@sdesc: pointer to the softwore RX buffer descriptor

 *	@page: pointer to the page data structure backing the RX buffer

 *	@dma_addr: PCI DMA address (possibly with low-bit flags)

/*

 * Support for poisoning RX buffers ...

/**

 *	refill_fl - refill an SGE RX buffer ring

 *	@adapter: the adapter

 *	@fl: the Free List ring to refill

 *	@n: the number of new buffers to allocate

 *	@gfp: the gfp flags for the allocations

 *

 *	(Re)populate an SGE free-buffer queue with up to @n new packet buffers,

 *	allocated with the supplied gfp flags.  The caller must assure that

 *	@n does not exceed the queue's capacity -- i.e. (cidx == pidx) _IN

 *	EGRESS QUEUE UNITS_ indicates an empty Free List!  Returns the number

 *	of buffers allocated.  If afterwards the queue is found critically low,

 *	mark it as starving in the bitmap of starving FLs.

	/*

	 * Sanity: ensure that the result of adding n Free List buffers

	 * won't result in wrapping the SGE's Producer Index around to

	 * it's Consumer Index thereby indicating an empty Free List ...

	/*

	 * If we support large pages, prefer large buffers and fail over to

	 * small pages if we can't allocate large pages to satisfy the refill.

	 * If we don't support large pages, drop directly into the small page

	 * allocation code.

			/*

			 * We've failed inour attempt to allocate a "large

			 * page".  Fail over to the "small page" allocation

			 * below.

			/*

			 * We've run out of DMA mapping space.  Free up the

			 * buffer and return with what we've managed to put

			 * into the free list.  We don't want to fail over to

			 * the small page allocation below in this case

			 * because DMA mapping resources are typically

			 * critical resources once they become scarse.

	/*

	 * Update our accounting state to incorporate the new Free List

	 * buffers, tell the hardware about them and return the number of

	 * buffers which we were able to allocate.

/*

 * Refill a Free List to its capacity or the Maximum Refill Increment,

 * whichever is smaller ...

/**

 *	alloc_ring - allocate resources for an SGE descriptor ring

 *	@dev: the PCI device's core device

 *	@nelem: the number of descriptors

 *	@hwsize: the size of each hardware descriptor

 *	@swsize: the size of each software descriptor

 *	@busaddrp: the physical PCI bus address of the allocated ring

 *	@swringp: return address pointer for software ring

 *	@stat_size: extra space in hardware ring for status information

 *

 *	Allocates resources for an SGE descriptor ring, such as TX queues,

 *	free buffer lists, response queues, etc.  Each SGE ring requires

 *	space for its hardware descriptors plus, optionally, space for software

 *	state associated with each hardware entry (the metadata).  The function

 *	returns three values: the virtual address for the hardware ring (the

 *	return value of the function), the PCI bus address of the hardware

 *	ring (in *busaddrp), and the address of the software ring (in swringp).

 *	Both the hardware and software rings are returned zeroed out.

	/*

	 * Allocate the hardware ring and PCI DMA bus address space for said.

	/*

	 * If the caller wants a software ring, allocate it and return a

	 * pointer to it in *swringp.

/**

 *	sgl_len - calculates the size of an SGL of the given capacity

 *	@n: the number of SGL entries

 *

 *	Calculates the number of flits (8-byte units) needed for a Direct

 *	Scatter/Gather List that can hold the given number of entries.

	/*

	 * A Direct Scatter Gather List uses 32-bit lengths and 64-bit PCI DMA

	 * addresses.  The DSGL Work Request starts off with a 32-bit DSGL

	 * ULPTX header, then Length0, then Address0, then, for 1 <= i <= N,

	 * repeated sequences of { Length[i], Length[i+1], Address[i],

	 * Address[i+1] } (this ensures that all addresses are on 64-bit

	 * boundaries).  If N is even, then Length[N+1] should be set to 0 and

	 * Address[N+1] is omitted.

	 *

	 * The following calculation incorporates all of the above.  It's

	 * somewhat hard to follow but, briefly: the "+2" accounts for the

	 * first two flits which include the DSGL header, Length0 and

	 * Address0; the "(3*(n-1))/2" covers the main body of list entries (3

	 * flits for every pair of the remaining N) +1 if (n-1) is odd; and

	 * finally the "+((n-1)&1)" adds the one remaining flit needed if

	 * (n-1) is odd ...

/**

 *	flits_to_desc - returns the num of TX descriptors for the given flits

 *	@flits: the number of flits

 *

 *	Returns the number of TX descriptors needed for the supplied number

 *	of flits.

/**

 *	is_eth_imm - can an Ethernet packet be sent as immediate data?

 *	@skb: the packet

 *

 *	Returns whether an Ethernet packet is small enough to fit completely as

 *	immediate data.

	/*

	 * The VF Driver uses the FW_ETH_TX_PKT_VM_WR firmware Work Request

	 * which does not accommodate immediate data.  We could dike out all

	 * of the support code for immediate data but that would tie our hands

	 * too much if we ever want to enhace the firmware.  It would also

	 * create more differences between the PF and VF Drivers.

/**

 *	calc_tx_flits - calculate the number of flits for a packet TX WR

 *	@skb: the packet

 *

 *	Returns the number of flits needed for a TX Work Request for the

 *	given Ethernet packet, including the needed WR and CPL headers.

	/*

	 * If the skb is small enough, we can pump it out as a work request

	 * with only immediate data.  In that case we just have to have the

	 * TX Packet header plus the skb data in the Work Request.

	/*

	 * Otherwise, we're going to have to construct a Scatter gather list

	 * of the skb body and fragments.  We also include the flits necessary

	 * for the TX Packet Work Request and CPL.  We always have a firmware

	 * Write Header (incorporated as part of the cpl_tx_pkt_lso and

	 * cpl_tx_pkt structures), followed by either a TX Packet Write CPL

	 * message or, if we're doing a Large Send Offload, an LSO CPL message

	 * with an embedded TX Packet Write CPL message.

/**

 *	write_sgl - populate a Scatter/Gather List for a packet

 *	@skb: the packet

 *	@tq: the TX queue we are writing into

 *	@sgl: starting location for writing the SGL

 *	@end: points right after the end of the SGL

 *	@start: start offset into skb main-body data to include in the SGL

 *	@addr: the list of DMA bus addresses for the SGL elements

 *

 *	Generates a Scatter/Gather List for the buffers that make up a packet.

 *	The caller must provide adequate space for the SGL that will be written.

 *	The SGL includes all of the packet's page fragments and the data in its

 *	main body except for the first @start bytes.  @pos must be 16-byte

 *	aligned and within a TX descriptor with available space.  @end points

 *	write after the end of the SGL but does not account for any potential

 *	wrap around, i.e., @end > @tq->stat.

	/*

	 * Most of the complexity below deals with the possibility we hit the

	 * end of the queue in the middle of writing the SGL.  For this case

	 * only we create the SGL in a temporary buffer and then copy it.

 0-pad to multiple of 16 */

/**

 *	ring_tx_db - check and potentially ring a TX queue's doorbell

 *	@adapter: the adapter

 *	@tq: the TX queue

 *	@n: number of new descriptors to give to HW

 *

 *	Ring the doorbel for a TX queue.

	/* Make sure that all writes to the TX Descriptors are committed

	 * before we tell the hardware about them.

	/* If we don't have access to the new User Doorbell (T5+), use the old

	 * doorbell mechanism; otherwise use the new BAR2 mechanism.

		/* T4 and later chips share the same PIDX field offset within

		 * the doorbell, but T5 and later shrank the field in order to

		 * gain a bit for Doorbell Priority.  The field was absurdly

		 * large in the first place (14 bits) so we just use the T5

		 * and later limits and warn if a Queue ID is too large.

		/* If we're only writing a single Egress Unit and the BAR2

		 * Queue ID is 0, we can use the Write Combining Doorbell

		 * Gather Buffer; otherwise we use the simple doorbell.

			/* Copy the TX Descriptor in a tight loop in order to

			 * try to get it to the adapter in a single Write

			 * Combined transfer on the PCI-E Bus.  If the Write

			 * Combine fails (say because of an interrupt, etc.)

			 * the hardware will simply take the last write as a

			 * simple doorbell write with a PIDX Increment of 1

			 * and will fetch the TX Descriptor from memory via

			 * DMA.

				/* the (__force u64) is because the compiler

				 * doesn't understand the endian swizzling

				 * going on

		/* This Write Memory Barrier will force the write to the User

		 * Doorbell area to be flushed.  This is needed to prevent

		 * writes on different CPUs for the same queue from hitting

		 * the adapter out of order.  This is required when some Work

		 * Requests take the Write Combine Gather Buffer path (user

		 * doorbell area offset [SGE_UDB_WCDOORBELL..+63]) and some

		 * take the traditional path where we simply increment the

		 * PIDX (User Doorbell area SGE_UDB_KDOORBELL) and have the

		 * hardware DMA read the actual Work Request.

/**

 *	inline_tx_skb - inline a packet's data into TX descriptors

 *	@skb: the packet

 *	@tq: the TX queue where the packet will be inlined

 *	@pos: starting position in the TX queue to inline the packet

 *

 *	Inline a packet's contents directly into TX descriptors, starting at

 *	the given position within the TX DMA ring.

 *	Most of the complexity of this operation is dealing with wrap arounds

 *	in the middle of the packet we want to inline.

 0-pad to multiple of 16 */

/*

 * Figure out what HW csum a packet wants and return the appropriate control

 * bits.

			/*

			 * unknown protocol, disable HW csum

			 * and hope a bad packet is detected

		/*

		 * this doesn't work with extension headers

/*

 * Stop an Ethernet TX queue and record that state change.

/*

 * Advance our software state for a TX queue by adding n in use descriptors.

/**

 *	t4vf_eth_xmit - add a packet to an Ethernet TX queue

 *	@skb: the packet

 *	@dev: the egress net device

 *

 *	Add a packet to an SGE Ethernet TX queue.  Runs with softirqs disabled.

	/*

	 * The chip minimum packet length is 10 octets but the firmware

	 * command that we are using requires that we copy the Ethernet header

	 * (including the VLAN tag) into the header so we reject anything

	 * smaller than that ...

 Discard the packet if the length is greater than mtu */

	/*

	 * Figure out which TX Queue we're going to use.

	/*

	 * Take this opportunity to reclaim any TX Descriptors whose DMA

	 * transfers have completed.

	/*

	 * Calculate the number of flits and TX Descriptors we're going to

	 * need along with how many TX Descriptors will be left over after

	 * we inject our Work Request.

		/*

		 * Not enough room for this packet's Work Request.  Stop the

		 * TX Queue and return a "busy" condition.  The queue will get

		 * started later on when the firmware informs us that space

		 * has opened up.

		/*

		 * We need to map the skb into PCI DMA space (because it can't

		 * be in-lined directly into the Work Request) and the mapping

		 * operation failed.  Record the error and drop the packet.

		/*

		 * After we're done injecting the Work Request for this

		 * packet, we'll be below our "stop threshold" so stop the TX

		 * Queue now and schedule a request for an SGE Egress Queue

		 * Update message.  The queue will get started later on when

		 * the firmware processes this Work Request and sends us an

		 * Egress Queue Status Update message indicating that space

		 * has opened up.

	/*

	 * Start filling in our Work Request.  Note that we do _not_ handle

	 * the WR Header wrapping around the TX Descriptor Ring.  If our

	 * maximum header size ever exceeds one TX Descriptor, we'll need to

	 * do something else here.

	/*

	 * If this is a Large Send Offload packet we'll put in an LSO CPL

	 * message with an encapsulated TX Packet CPL message.  Otherwise we

	 * just use a TX Packet CPL message.

		/*

		 * Fill in the LSO CPL message.

		/*

		 * Set up TX Packet CPL pointer, control word and perform

		 * accounting.

		/*

		 * Set up TX Packet CPL pointer, control word and perform

		 * accounting.

	/*

	 * If there's a VLAN tag present, add that to the list of things to

	 * do in this Work Request.

	/*

	 * Fill in the TX Packet CPL message header.

	/*

	 * Fill in the body of the TX Packet CPL message with either in-lined

	 * data or a Scatter/Gather List.

		/*

		 * In-line the packet's data and free the skb since we don't

		 * need it any longer.

		/*

		 * Write the skb's Scatter/Gather list into the TX Packet CPL

		 * message and retain a pointer to the skb so we can free it

		 * later when its DMA completes.  (We store the skb pointer

		 * in the Software Descriptor corresponding to the last TX

		 * Descriptor used by the Work Request.)

		 *

		 * The retained skb will be freed when the corresponding TX

		 * Descriptors are reclaimed after their DMAs complete.

		 * However, this could take quite a while since, in general,

		 * the hardware is set up to be lazy about sending DMA

		 * completion notifications to us and we mostly perform TX

		 * reclaims in the transmit routine.

		 *

		 * This is good for performamce but means that we rely on new

		 * TX packets arriving to run the destructors of completed

		 * packets, which open up space in their sockets' send queues.

		 * Sometimes we do not get such new packets causing TX to

		 * stall.  A single UDP transmitter is a good example of this

		 * situation.  We have a clean up timer that periodically

		 * reclaims completed packets but it doesn't run often enough

		 * (nor do we want it to) to prevent lengthy stalls.  A

		 * solution to this problem is to run the destructor early,

		 * after the packet is queued but before it's DMAd.  A con is

		 * that we lie to socket memory accounting, but the amount of

		 * extra memory is reasonable (limited by the number of TX

		 * descriptors), the packets do actually get freed quickly by

		 * new packets almost always, and for protocols like TCP that

		 * wait for acks to really free up the data the extra memory

		 * is even less.  On the positive side we run the destructors

		 * on the sending CPU rather than on a potentially different

		 * completing CPU, usually a good thing.

		 *

		 * Run the destructor before telling the DMA engine about the

		 * packet to make sure it doesn't complete and get freed

		 * prematurely.

		/*

		 * If the Work Request header was an exact multiple of our TX

		 * Descriptor length, then it's possible that the starting SGL

		 * pointer lines up exactly with the end of our TX Descriptor

		 * ring.  If that's the case, wrap around to the beginning

		 * here ...

	/*

	 * Advance our internal TX Queue state, tell the hardware about

	 * the new TX descriptors and return success.

	/*

	 * An error of some sort happened.  Free the TX skb and tell the

	 * OS that we've "dealt" with the packet ...

/**

 *	copy_frags - copy fragments from gather list into skb_shared_info

 *	@skb: destination skb

 *	@gl: source internal packet gather list

 *	@offset: packet start offset in first page

 *

 *	Copy an internal packet gather list into a Linux skb_shared_info

 *	structure.

 usually there's just one frag */

 get a reference to the last page, we don't own it */

/**

 *	t4vf_pktgl_to_skb - build an sk_buff from a packet gather list

 *	@gl: the gather list

 *	@skb_len: size of sk_buff main body if it carries fragments

 *	@pull_len: amount of data to move to the sk_buff's main body

 *

 *	Builds an sk_buff from the given packet gather list.  Returns the

 *	sk_buff or %NULL if sk_buff allocation failed.

	/*

	 * If the ingress packet is small enough, allocate an skb large enough

	 * for all of the data and copy it inline.  Otherwise, allocate an skb

	 * with enough room to pull in the header and reference the rest of

	 * the data via the skb fragment list.

	 *

	 * Below we rely on RX_COPY_THRES being less than the smallest Rx

	 * buff!  size, which is expected since buffers are at least

	 * PAGE_SIZEd.  In this case packets up to RX_COPY_THRES have only one

	 * fragment.

 small packets have only one fragment */

/**

 *	t4vf_pktgl_free - free a packet gather list

 *	@gl: the gather list

 *

 *	Releases the pages of a packet gather list.  We do not own the last

 *	page on the list and do not free it.

/**

 *	do_gro - perform Generic Receive Offload ingress packet processing

 *	@rxq: ingress RX Ethernet Queue

 *	@gl: gather list for ingress packet

 *	@pkt: CPL header for last packet fragment

 *

 *	Perform Generic Receive Offload (GRO) ingress packet processing.

 *	We use the standard Linux GRO interfaces for this.

/**

 *	t4vf_ethrx_handler - process an ingress ethernet packet

 *	@rspq: the response queue that received the packet

 *	@rsp: the response queue descriptor holding the RX_PKT message

 *	@gl: the gather list of packet fragments

 *

 *	Process an ingress ethernet packet and deliver it to the stack.

	/*

	 * If this is a good TCP packet and we have Generic Receive Offload

	 * enabled, handle the packet in the GRO path.

	/*

	 * Convert the Packet Gather List into an skb.

/**

 *	is_new_response - check if a response is newly written

 *	@rc: the response control descriptor

 *	@rspq: the response queue

 *

 *	Returns true if a response descriptor contains a yet unprocessed

 *	response.

/**

 *	restore_rx_bufs - put back a packet's RX buffers

 *	@gl: the packet gather list

 *	@fl: the SGE Free List

 *	@frags: how many fragments in @si

 *

 *	Called when we find out that the current packet, @si, can't be

 *	processed right away for some reason.  This is a very rare event and

 *	there's no effort to make this suspension/resumption process

 *	particularly efficient.

 *

 *	We implement the suspension by putting all of the RX buffers associated

 *	with the current packet back on the original Free List.  The buffers

 *	have already been unmapped and are left unmapped, we mark them as

 *	unmapped in order to prevent further unmapping attempts.  (Effectively

 *	this function undoes the series of @unmap_rx_buf calls which were done

 *	to create the current packet's gather list.)  This leaves us ready to

 *	restart processing of the packet the next time we start processing the

 *	RX Queue ...

/**

 *	rspq_next - advance to the next entry in a response queue

 *	@rspq: the queue

 *

 *	Updates the state of a response queue to advance it to the next entry.

/**

 *	process_responses - process responses from an SGE response queue

 *	@rspq: the ingress response queue to process

 *	@budget: how many responses can be processed in this round

 *

 *	Process responses from a Scatter Gather Engine response queue up to

 *	the supplied budget.  Responses include received packets as well as

 *	control messages from firmware or hardware.

 *

 *	Additionally choose the interrupt holdoff time for the next interrupt

 *	on this queue.  If the system is under memory shortage use a fairly

 *	long delay to help recovery.

		/*

		 * Figure out what kind of response we've received from the

		 * SGE.

			/*

			 * If we get a "new buffer" message from the SGE we

			 * need to move on to the next Free List buffer.

				/*

				 * We get one "new buffer" message when we

				 * first start up a queue so we need to ignore

				 * it when our offset into the buffer is 0.

			/*

			 * Gather packet fragments.

*/; frag++, fp++) {

			/*

			 * Last buffer remains mapped so explicitly make it

			 * coherent for CPU access and start preloading first

			 * cache line ...

			/*

			 * Hand the new ingress packet to the handler for

			 * this Response Queue.

			/*

			 * Couldn't process descriptor, back off for recovery.

			 * We use the SGE's last timer which has the longest

			 * interrupt coalescing value ...

	/*

	 * If this is a Response Queue with an associated Free List and

	 * at least two Egress Queue units available in the Free List

	 * for new buffer pointers, refill the Free List.

/**

 *	napi_rx_handler - the NAPI handler for RX processing

 *	@napi: the napi instance

 *	@budget: how many packets we can process in this round

 *

 *	Handler for new data events when using NAPI.  This does not need any

 *	locking or protection from interrupts as data interrupts are off at

 *	this point and other adapter interrupts do not interfere (the latter

 *	in not a concern at all with MSI-X as non-data interrupts then have

 *	a separate handler).

	/* If we don't have access to the new User GTS (T5+), use the old

	 * doorbell mechanism; otherwise use the new BAR2 mechanism.

/*

 * The MSI-X interrupt handler for an SGE response queue for the NAPI case

 * (i.e., response queue serviced by NAPI polling).

/*

 * Process the indirect interrupt entries in the interrupt queue and kick off

 * NAPI for each queue that has generated an entry.

		/*

		 * Grab the next response from the interrupt queue and bail

		 * out if it's not a new response.

		/*

		 * If the response isn't a forwarded interrupt message issue a

		 * error and go on to the next response message.  This should

		 * never happen ...

		/*

		 * Extract the Queue ID from the interrupt message and perform

		 * sanity checking to make sure it really refers to one of our

		 * Ingress Queues which is active and matches the queue's ID.

		 * None of these error conditions should ever happen so we may

		 * want to either make them fatal and/or conditionalized under

		 * DEBUG.

		/*

		 * Schedule NAPI processing on the indicated Response Queue

		 * and move on to the next entry in the Forwarded Interrupt

		 * Queue.

	/* If we don't have access to the new User GTS (T5+), use the old

	 * doorbell mechanism; otherwise use the new BAR2 mechanism.

/*

 * The MSI interrupt handler handles data events from SGE response queues as

 * well as error and other async events as they all use the same MSI vector.

/**

 *	t4vf_intr_handler - select the top-level interrupt handler

 *	@adapter: the adapter

 *

 *	Selects the top-level interrupt handler based on the type of interrupts

 *	(MSI-X or MSI).

/**

 *	sge_rx_timer_cb - perform periodic maintenance of SGE RX queues

 *	@t: Rx timer

 *

 *	Runs periodically from a timer to perform maintenance of SGE RX queues.

 *

 *	a) Replenishes RX queues that have run out due to memory shortage.

 *	Normally new RX buffers are added when existing ones are consumed but

 *	when out of memory a queue can become empty.  We schedule NAPI to do

 *	the actual refill.

	/*

	 * Scan the "Starving Free Lists" flag array looking for any Free

	 * Lists in need of more free buffers.  If we find one and it's not

	 * being actively polled, then bump its "starving" counter and attempt

	 * to refill it.  If we're successful in adding enough buffers to push

	 * the Free List over the starving threshold, then we can clear its

	 * "starving" status.

			/*

			 * Since we are accessing fl without a lock there's a

			 * small probability of a false positive where we

			 * schedule napi but the FL is no longer starving.

			 * No biggie.

	/*

	 * Reschedule the next scan for starving Free Lists ...

/**

 *	sge_tx_timer_cb - perform periodic maintenance of SGE Tx queues

 *	@t: Tx timer

 *

 *	Runs periodically from a timer to perform maintenance of SGE TX queues.

 *

 *	b) Reclaims completed Tx packets for the Ethernet queues.  Normally

 *	packets are cleaned up by new Tx packets, this timer cleans up packets

 *	when no new packets are being submitted.  This is essential for pktgen,

 *	at least.

	/*

	 * If we found too many reclaimable packets schedule a timer in the

	 * near future to continue where we left off.  Otherwise the next timer

	 * will be at its normal interval.

/**

 *	bar2_address - return the BAR2 address for an SGE Queue's Registers

 *	@adapter: the adapter

 *	@qid: the SGE Queue ID

 *	@qtype: the SGE Queue Type (Egress or Ingress)

 *	@pbar2_qid: BAR2 Queue ID or 0 for Queue ID inferred SGE Queues

 *

 *	Returns the BAR2 address for the SGE Queue Registers associated with

 *	@qid.  If BAR2 SGE Registers aren't available, returns NULL.  Also

 *	returns the BAR2 Queue ID to be used with writes to the BAR2 SGE

 *	Queue Registers.  If the BAR2 Queue ID is 0, then "Inferred Queue ID"

 *	Registers are supported (e.g. the Write Combining Doorbell Buffer).

/**

 *	t4vf_sge_alloc_rxq - allocate an SGE RX Queue

 *	@adapter: the adapter

 *	@rspq: pointer to to the new rxq's Response Queue to be filled in

 *	@iqasynch: if 0, a normal rspq; if 1, an asynchronous event queue

 *	@dev: the network device associated with the new rspq

 *	@intr_dest: MSI-X vector index (overriden in MSI mode)

 *	@fl: pointer to the new rxq's Free List to be filled in

 *	@hnd: the interrupt handler to invoke for the rspq

	/*

	 * If we're using MSI interrupts and we're not initializing the

	 * Forwarded Interrupt Queue itself, then set up this queue for

	 * indirect interrupts to the Forwarded Interrupt Queue.  Obviously

	 * the Forwarded Interrupt Queue must be set up before any other

	 * ingress queue ...

	/*

	 * Allocate the hardware ring for the Response Queue.  The size needs

	 * to be a multiple of 16 which includes the mandatory status entry

	 * (regardless of whether the Status Page capabilities are enabled or

	 * not).

	/*

	 * Fill in the Ingress Queue Command.  Note: Ideally this code would

	 * be in t4vf_hw.c but there are so many parameters and dependencies

	 * on our Linux SGE state that we would end up having to pass tons of

	 * parameters.  We'll have to think about how this might be migrated

	 * into OS-independent common code ...

		/*

		 * Allocate the ring for the hardware free list (with space

		 * for its status page) along with the associated software

		 * descriptor ring.  The free list size needs to be a multiple

		 * of the Egress Queue Unit and at least 2 Egress Units larger

		 * than the SGE's Egress Congrestion Threshold

		 * (fl_starve_thres - 1).

		/*

		 * Calculate the size of the hardware free list ring plus

		 * Status Page (which the SGE will place after the end of the

		 * free list ring) in Egress Queue Units.

		/*

		 * Fill in all the relevant firmware Ingress Queue Command

		 * fields for the free list.

		/* In T6, for egress queue type FL there is internal overhead

		 * of 16B for header going into FLM module.  Hence the maximum

		 * allowed burst size is 448 bytes.  For T4/T5, the hardware

		 * doesn't coalesce fetch requests if more than 64 bytes of

		 * Free List pointers are provided, so we use a 128-byte Fetch

		 * Burst Minimum there (T6 implements coalescing so we can use

		 * the smaller 64-byte value there).

	/*

	 * Issue the firmware Ingress Queue Command and extract the results if

	 * it completes successfully.

 subtract status entry */

 set offset to -1 to distinguish ingress queues without FL */

		/* Note, we must initialize the BAR2 Free List User Doorbell

		 * information before refilling the Free List!

	/*

	 * An error occurred.  Clean up our partial allocation state and

	 * return the error.

/**

 *	t4vf_sge_alloc_eth_txq - allocate an SGE Ethernet TX Queue

 *	@adapter: the adapter

 *	@txq: pointer to the new txq to be filled in

 *	@dev: the network device

 *	@devq: the network TX queue associated with the new txq

 *	@iqid: the relative ingress queue ID to which events relating to

 *		the new txq should be directed

	/*

	 * Calculate the size of the hardware TX Queue (including the Status

	 * Page on the end of the TX Queue) in units of TX Descriptors.

	/*

	 * Allocate the hardware ring for the TX ring (with space for its

	 * status page) along with the associated software descriptor ring.

	/*

	 * Fill in the Egress Queue Command.  Note: As with the direct use of

	 * the firmware Ingress Queue COmmand above in our RXQ allocation

	 * routine, ideally, this code would be in t4vf_hw.c.  Again, we'll

	 * have to see if there's some reasonable way to parameterize it

	 * into the common code ...

	/*

	 * Issue the firmware Egress Queue Command and extract the results if

	 * it completes successfully.

		/*

		 * The girmware Ingress Queue Command failed for some reason.

		 * Free up our partial allocation state and return the error.

/*

 * Free the DMA map resources associated with a TX queue.

/*

 * Free the resources associated with a response queue (possibly including a

 * free list).

/**

 *	t4vf_free_sge_resources - free SGE resources

 *	@adapter: the adapter

 *

 *	Frees resources used by the SGE queue sets.

/**

 *	t4vf_sge_start - enable SGE operation

 *	@adapter: the adapter

 *

 *	Start tasklets and timers associated with the DMA engine.

/**

 *	t4vf_sge_stop - disable SGE operation

 *	@adapter: the adapter

 *

 *	Stop tasklets and timers associated with the DMA engine.  Note that

 *	this is effective only if measures have been taken to disable any HW

 *	events that may restart them.

/**

 *	t4vf_sge_init - initialize SGE

 *	@adapter: the adapter

 *

 *	Performs SGE initialization needed every time after a chip reset.

 *	We do not initialize any of the queue sets here, instead the driver

 *	top-level must request those individually.  We also do not enable DMA

 *	here, that should be done after the queues have been set up.

	/*

	 * Start by vetting the basic SGE parameters which have been set up by

	 * the Physical Function Driver.  Ideally we should be able to deal

	 * with _any_ configuration.  Practice is different ...

	/* We only bother using the Large Page logic if the Large Page Buffer

	 * is larger than our Page Size Buffer.

	/* The Page Size Buffer must be exactly equal to our Page Size and the

	 * Large Page Size Buffer should be 0 (per above) or a power of 2.

	/*

	 * Now translate the adapter parameters into our internal forms.

	/* A FL with <= fl_starve_thres buffers is starving and a periodic

	 * timer will attempt to refill it.  This needs to be larger than the

	 * SGE's Egress Congestion Threshold.  If it isn't, then we can get

	 * stuck waiting for new packets while the SGE is waiting for us to

	 * give it more Free List entries.  (Note that the SGE's Egress

	 * Congestion Threshold is in units of 2 Free List pointers.)

	/*

	 * Set up tasklet timers.

	/*

	 * Initialize Forwarded Interrupt Queue lock.

/*

 * This file is part of the Chelsio T4 PCI-E SR-IOV Virtual Function Ethernet

 * driver for Linux.

 *

 * Copyright (c) 2009-2010 Chelsio Communications, Inc. All rights reserved.

 *

 * This software is available to you under a choice of one of two

 * licenses.  You may choose to be licensed under the terms of the GNU

 * General Public License (GPL) Version 2, available from the file

 * COPYING in the main directory of this source tree, or the

 * OpenIB.org BSD license below:

 *

 *     Redistribution and use in source and binary forms, with or

 *     without modification, are permitted provided that the following

 *     conditions are met:

 *

 *      - Redistributions of source code must retain the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer.

 *

 *      - Redistributions in binary form must reproduce the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer in the documentation and/or other materials

 *        provided with the distribution.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS

 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN

 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN

 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

/*

 * Generic information about the driver.

/*

 * Module Parameters.

 * ==================

/*

 * Default ethtool "message level" for adapters.

/*

 * The driver uses the best interrupt scheme available on a platform in the

 * order MSI-X then MSI.  This parameter determines which of these schemes the

 * driver may consider as follows:

 *

 *     msi = 2: choose from among MSI-X and MSI

 *     msi = 1: only consider MSI interrupts

 *

 * Note that unlike the Physical Function driver, this Virtual Function driver

 * does _not_ support legacy INTx interrupts (this limitation is mandated by

 * the PCI-E SR-IOV standard).

/*

 * Fundamental constants.

 * ======================

	/*

	 * For purposes of manipulating the Free List size we need to

	 * recognize that Free Lists are actually Egress Queues (the host

	 * produces free buffers which the hardware consumes), Egress Queues

	 * indices are all in units of Egress Context Units bytes, and free

	 * list entries are 64-bit PCI DMA addresses.  And since the state of

	 * the Producer Index == the Consumer Index implies an EMPTY list, we

	 * always have at least one Egress Unit's worth of Free List entries

	 * unused.  See sge.c for more details ...

/*

 * Global driver state.

 * ====================

/*

 * OS "Callback" functions.

 * ========================

/*

 * The link status has changed on the indicated "port" (Virtual Interface).

	/*

	 * If the port is disabled or the current recorded "link up"

	 * status matches the new status, just return.

	/*

	 * Tell the OS that the link status has changed and print a short

	 * informative message on the console about the event.

/*

 * THe port module type has changed on the indicated "port" (Virtual

 * Interface).

 Calculate the hash vector for the updated list and program it */

/**

 *	cxgb4vf_change_mac - Update match filter for a MAC address.

 *	@pi: the port_info

 *	@viid: the VI id

 *	@tcam_idx: TCAM index of existing filter for old value of MAC address,

 *		   or -1

 *	@addr: the new MAC address value

 *	@persistent: whether a new MAC allocation should be persistent

 *

 *	Modifies an MPS filter and sets it to the new MAC address if

 *	@tcam_idx >= 0, or adds the MAC address to a new filter if

 *	@tcam_idx < 0. In the latter case the address is added persistently

 *	if @persist is %true.

 *	Addresses are programmed to hash region, if tcam runs out of entries.

 *

 We ran out of TCAM entries. try programming hash region. */

		/* If the MAC address to be updated is in the hash addr

		 * list, update it from the list

/*

 * Net device operations.

 * ======================

/*

 * Perform the MAC and PHY actions needed to enable a "port" (Virtual

 * Interface).

	/*

	 * We do not set address filters and promiscuity here, the stack does

	 * that step explicitly. Enable vlan accel.

	/*

	 * We don't need to actually "start the link" itself since the

	 * firmware will do that for us when the first Virtual Interface

	 * is enabled on a port.

/*

 * Name the MSI-X interrupts.

	/*

	 * Firmware events.

	/*

	 * Ethernet queues.

/*

 * Request all of our MSI-X resources.

	/*

	 * Firmware events.

	/*

	 * Ethernet queues.

/*

 * Free our MSI-X resources.

/*

 * Turn on NAPI and start up interrupts on a response queue.

	/*

	 * 0-increment the Going To Sleep register to start the timer and

	 * enable interrupts.

/*

 * Enable NAPI scheduling and interrupt generation for all Receive Queues.

	/*

	 * The interrupt queue doesn't use NAPI so we do the 0-increment of

	 * its Going To Sleep register here to get it started.

/*

 * Wait until all NAPI handlers are descheduled.

/*

 * Response queue handler for the firmware event queue.

	/*

	 * Extract response opcode and get pointer to CPL message body.

		/*

		 * We've received an asynchronous message from the firmware.

		/* FW can send EGR_UPDATEs encapsulated in a CPL_FW4_MSG.

		/*

		 * We've received an Egress Queue Status Update message.  We

		 * get these, if the SGE is configured to send these when the

		 * firmware passes certain points in processing our TX

		 * Ethernet Queue or if we make an explicit request for one.

		 * We use these updates to determine when we may need to

		 * restart a TX Ethernet Queue which was stopped for lack of

		 * free TX Queue Descriptors ...

		/*

		 * Perform sanity checking on the Queue ID to make sure it

		 * really refers to one of our TX Ethernet Egress Queues which

		 * is active and matches the queue's ID.  None of these error

		 * conditions should ever happen so we may want to either make

		 * them fatal and/or conditionalized under DEBUG.

		/*

		 * Restart a stopped TX Queue which has less than half of its

		 * TX ring in use ...

/*

 * Allocate SGE TX/RX response queues.  Determine how many sets of SGE queues

 * to use and initializes them.  We support multiple "Queue Sets" per port if

 * we have MSI-X, otherwise just one queue set per port.

	/*

	 * Clear "Queue Set" Free List Starving and TX Queue Mapping Error

	 * state.

	/*

	 * If we're using MSI interrupt mode we need to set up a "forwarded

	 * interrupt" queue which we'll set up with our MSI vector.  The rest

	 * of the ingress queues will be set up to forward their interrupts to

	 * this queue ...  This must be first since t4vf_sge_alloc_rxq() uses

	 * the intrq's queue ID as the interrupt forwarding queue for the

	 * subsequent calls ...

	/*

	 * Allocate our ingress queue for asynchronous firmware messages.

	/*

	 * Allocate each "port"'s initial Queue Sets.  These can be changed

	 * later on ... up to the point where any interface on the adapter is

	 * brought up at which point lots of things get nailed down

	 * permanently ...

	/*

	 * Create the reverse mappings for the queues.

			/*

			 * The FW_IQ_CMD doesn't return the Absolute Queue IDs

			 * for Free Lists but since all of the Egress Queues

			 * (including Free Lists) have Relative Queue IDs

			 * which are computed as Absolute - Base Queue ID, we

			 * can synthesize the Absolute Queue IDs for the Free

			 * Lists.  This is useful for debugging purposes when

			 * we want to dump Queue Contexts via the PF Driver.

/*

 * Set up Receive Side Scaling (RSS) to distribute packets to multiple receive

 * queues.  We configure the RSS CPU lookup table to distribute to the number

 * of HW receive queues, and the response queue lookup table to narrow that

 * down to the response queues actually configured for each "port" (Virtual

 * Interface).  We always configure the RSS mapping for all ports since the

 * mapping table has plenty of entries.

		/*

		 * Perform Global RSS Mode-specific initialization.

			/*

			 * If Tunnel All Lookup isn't specified in the global

			 * RSS Configuration, then we need to specify a

			 * default Ingress Queue for any ingress packets which

			 * aren't hashed.  We'll use our first ingress queue

			 * ...

/*

 * Bring the adapter up.  Called whenever we go from no "ports" open to having

 * one open.  This function performs the actions necessary to make an adapter

 * operational, such as completing the initialization of HW modules, and

 * enabling interrupts.  Must be called with the rtnl lock held.  (Note that

 * this is called "cxgb_up" in the PF Driver.)

	/*

	 * If this is the first time we've been called, perform basic

	 * adapter setup.  Once we've done this, many of our adapter

	 * parameters can no longer be changed ...

	/*

	 * Acquire our interrupt resources.  We only support MSI-X and MSI.

	/*

	 * Enable NAPI ingress processing and return success.

/*

 * Bring the adapter down.  Called whenever the last "port" (Virtual

 * Interface) closed.  (Note that this routine is called "cxgb_down" in the PF

 * Driver.)

	/*

	 * Free interrupt resources.

	/*

	 * Wait for NAPI handlers to finish.

/*

 * Start up a net device.

	/*

	 * If we don't have a connection to the firmware there's nothing we

	 * can do.

	/*

	 * If this is the first interface that we're opening on the "adapter",

	 * bring the "adapter" up now.

	/* It's possible that the basic port information could have

	 * changed since we first read it.

	/*

	 * Note that this interface is up and start everything up ...

/*

 * Shut down a net device.  This routine is called "cxgb_close" in the PF

 * Driver ...

/*

 * Translate our basic statistics into the standard "ifconfig" statistics.

	/* if hash != 0, then add the addr to hash addr list

	 * so on the end we will calculate the hash for the

	 * list and program it

	/* If the MAC address to be removed is in the hash addr

	 * list, delete it from the list and update hash vector

/*

 * Set RX properties of a port, such as promiscruity, address filters, and MTU.

 * If @mtu is -1 it is left unchanged.

/*

 * Set the current receive modes on the device.

 unfortunately we can't return errors to the stack */

/*

 * Find the entry in the interrupt holdoff timer value array which comes

 * closest to the specified interrupt holdoff value.

/*

 * Return a queue's interrupt hold-off time in us.  0 means no timer.

/**

 *	set_rxq_intr_params - set a queue's interrupt holdoff parameters

 *	@adapter: the adapter

 *	@rspq: the RX response queue

 *	@us: the hold-off time in us, or 0 to disable timer

 *	@cnt: the hold-off packet count, or 0 to disable counter

 *

 *	Sets an RX response queue's interrupt hold-off time and packet count.

 *	At least one of the two needs to be enabled for the queue to generate

 *	interrupts.

	/*

	 * If both the interrupt holdoff timer and count are specified as

	 * zero, default to a holdoff count of 1 ...

	/*

	 * If an interrupt holdoff count has been specified, then find the

	 * closest configured holdoff count and use that.  If the response

	 * queue has already been created, then update its queue context

	 * parameters ...

	/*

	 * Compute the closest holdoff timer index from the supplied holdoff

	 * timer value.

	/*

	 * Update the response queue's interrupt coalescing parameters and

	 * return success.

/*

 * Return a version number to identify the type of adapter.  The scheme is:

 * - bits 0..9: chip version

 * - bits 10..15: chip revision

	/*

	 * Chip version 4, revision 0x3f (cxgb4vf).

/*

 * Execute the specified ioctl command.

	    /*

	     * The VF Driver doesn't have access to any of the other

	     * common Ethernet device ioctl()'s (like reading/writing

	     * PHY registers, etc.

/*

 * Change the device's MTU.

	/*

	 * Since there is no support for separate rx/tx vlan accel

	 * enable/disable make sure tx flag is always in same state as rx.

/*

 * Change the devices MAC address.

/*

 * Poll all of our receive queues.  This is called outside of normal interrupt

 * context.

/*

 * Ethtool operations.

 * ===================

 *

 * Note that we don't support any ethtool operations which change the physical

 * state of the port to which we're linked.

/**

 *	from_fw_port_mod_type - translate Firmware Port/Module type to Ethtool

 *	@port_type: Firmware Port Type

 *	@mod_type: Firmware Module Type

 *

 *	Translate Firmware Port/Module type to Ethtool Port Type.

/**

 *	fw_caps_to_lmm - translate Firmware to ethtool Link Mode Mask

 *	@port_type: Firmware Port Type

 *	@fw_caps: Firmware Port Capabilities

 *	@link_mode_mask: ethtool Link Mode Mask

 *

 *	Translate a Firmware Port Capabilities specification to an ethtool

 *	Link Mode Mask.

	/* For the nonce, the Firmware doesn't send up Port State changes

	 * when the Virtual Interface attached to the Port is down.  So

	 * if it's down, let's grab any changes.

 Translate the Firmware FEC value into the ethtool value. */

 if nothing is set, then FEC is off */

 Translate Common Code FEC value into ethtool value. */

 if nothing is set, then FEC is off */

	/* Translate the Firmware FEC Support into the ethtool value.  We

	 * always support IEEE 802.3 "automatic" selection of Link FEC type if

	 * any FEC is supported.

	/* Translate the current internal FEC parameters into the

	 * ethtool values.

/*

 * Return our driver information.

/*

 * Return current adapter message level.

/*

 * Set current adapter message level.

/*

 * Return the device's current Queue Set ring size parameters along with the

 * allowed maximum values.  Since ethtool doesn't understand the concept of

 * multi-queue devices, we just return the current values associated with the

 * first Queue Set.

/*

 * Set the Queue Set ring size parameters for the device.  Again, since

 * ethtool doesn't allow for the concept of multiple queues per device, we'll

 * apply these new values across all of the Queue Sets associated with the

 * device -- after vetting them of course!

/*

 * Return the interrupt holdoff timer and count for the first Queue Set on the

 * device.  Our extension ioctl() (the cxgbtool interface) allows the

 * interrupt holdoff timer to be read on all of the device's Queue Sets.

/*

 * Set the RX interrupt holdoff timer and count for the first Queue Set on the

 * interface.  Our extension ioctl() (the cxgbtool interface) allows us to set

 * the interrupt holdoff timer on any of the device's Queue Sets.

/*

 * Report current port link pause parameter settings.

/*

 * Identify the port by blinking the port's LED.

/*

 * Port stats maintained per queue of the port.

/*

 * Strings for the ETH_SS_STATS statistics set ("ethtool -S").  Note that

 * these need to match the order of statistics returned by

 * t4vf_get_port_stats().

	/*

	 * These must match the layout of the t4vf_port_stats structure.

	/*

	 * These are accumulated per-queue statistics and must match the

	 * order of the fields in the queue_port_stats structure.

/*

 * Return the number of statistics in the specified statistics set.

NOTREACHED*/

/*

 * Return the strings for the specified statistics set.

/*

 * Small utility routine to accumulate queue statistics across the queues of

 * a "port".

/*

 * Return the ETH_SS_STATS statistics set.

/*

 * Return the size of our register map.

/*

 * Dump a block of registers, start to end inclusive, into a buffer.

		/*

		 * Avoid reading the Mailbox Control register since that

		 * can trigger a Mailbox Ownership Arbitration cycle and

		 * interfere with communication with the firmware.

/*

 * Copy our entire register map into the provided buffer.

	/*

	 * Fill in register buffer with our register map.

	/* T5 adds new registers in the PL Register map.

/*

 * Report current Wake On LAN settings.

/*

 * TCP Segmentation Offload flags which we support.

/*

 * /sys/kernel/debug/cxgb4vf support code and data.

 * ================================================

/*

 * Show Firmware Mailbox Command/Reply Log

 *

 * Note that we don't do any locking when dumping the Firmware Mailbox Log so

 * it's possible that we can catch things during a log update and therefore

 * see partially corrupted log entries.  But i9t's probably Good Enough(tm).

 * If we ever decide that we want to make sure that we're dumping a coherent

 * log, we'd need to perform locking in the mailbox logging and in

 * mboxlog_open() where we'd need to grab the entire mailbox log in one go

 * like we do for the Firmware Device Log.  But as stated above, meh ...

 skip over unused entries */

/*

 * Show SGE Queue Set information.  We display QPL Queues Sets per line.

/*

 * Return the number of "entries" in our "file".  We group the multi-Queue

 * sections with QPL Queue Sets per "entry".  The sections of the output are:

 *

 *     Ethernet RX/TX Queue Sets

 *     Firmware Event Queue

 *     Forwarded Interrupt Queue (if in MSI mode)

/*

 * Show SGE Queue Set statistics.  We display QPL Queues Sets per line.

/*

 * Return the number of "entries" in our "file".  We group the multi-Queue

 * sections with QPL Queue Sets per "entry".  The sections of the output are:

 *

 *     Ethernet RX/TX Queue Sets

 *     Firmware Event Queue

 *     Forwarded Interrupt Queue (if in MSI mode)

/*

 * Show PCI-E SR-IOV Virtual Function Resource Limits.

/*

 * Show Virtual Interfaces.

/*

 * /sys/kernel/debugfs/cxgb4vf/ files list.

 name of debugfs node */

 file system mode */

/*

 * Module and device initialization and cleanup code.

 * ==================================================

/*

 * Set up out /sys/kernel/debug/cxgb4vf sub-nodes.  We assume that the

 * directory (debugfs_root) has already been set up.

	/*

	 * Debugfs support is best effort.

/*

 * Tear down the /sys/kernel/debug/cxgb4vf sub-nodes created above.  We leave

 * it to our caller to tear down the directory (debugfs_root).

	/*

	 * Unlike our sister routine cleanup_proc(), we don't need to remove

	 * individual entries because a call will be made to

	 * debugfs_remove_recursive().  We just need to clean up any ancillary

	 * persistent state.

 nothing to do */

/* Figure out how many Ports and Queue Sets we can support.  This depends on

 * knowing our Virtual Function Resources and may be called a second time if

 * we fall back from MSI-X to MSI Interrupt Mode.

	/* The number of "ports" which we support is equal to the number of

	 * Virtual Interfaces with which we've been provisioned.

	/* We may have been provisioned with more VIs than the number of

	 * ports we're allowed to access (our Port Access Rights Mask).

	 * This is obviously a configuration conflict but we don't want to

	 * crash the kernel or anything silly just because of that.

	/* We need to reserve an Ingress Queue for the Asynchronous Firmware

	 * Event Queue.  And if we're using MSI Interrupts, we'll also need to

	 * reserve an Ingress Queue for a Forwarded Interrupts.

	 *

	 * The rest of the FL/Intr-capable ingress queues will be matched up

	 * one-for-one with Ethernet/Control egress queues in order to form

	 * "Queue Sets" which will be aportioned between the "ports".  For

	 * each Queue Set, we'll need the ability to allocate two Egress

	 * Contexts -- one for the Ingress Queue Free List and one for the TX

	 * Ethernet Queue.

	 *

	 * Note that even if we're currently configured to use MSI-X

	 * Interrupts (module variable msi == MSI_MSIX) we may get downgraded

	 * to MSI Interrupts if we can't get enough MSI-X Interrupts.  If that

	 * happens we'll need to adjust things later.

/*

 * Perform early "adapter" initialization.  This is where we discover what

 * adapter parameters we're going to be using and initialize basic adapter

 * hardware support.

	/*

	 * Some environments do not properly handle PCIE FLRs -- e.g. in Linux

	 * 2.6.31 and later we can't call pci_reset_function() in order to

	 * issue an FLR because of a self- deadlock on the device semaphore.

	 * Meanwhile, the OS infrastructure doesn't issue FLRs in all the

	 * cases where they're needed -- for instance, some versions of KVM

	 * fail to reset "Assigned Devices" when the VM reboots.  Therefore we

	 * use the firmware based reset in order to reset any per function

	 * state.

	/*

	 * Grab basic operational parameters.  These will predominantly have

	 * been set up by the Physical Function Driver or will be hard coded

	 * into the adapter.  We just have to live with them ...  Note that

	 * we _must_ get our VPD parameters before our SGE parameters because

	 * we need to know the adapter's core clock from the VPD in order to

	 * properly decode the SGE Timer Values.

	/* If we're running on newer firmware, let it know that we're

	 * prepared to deal with encapsulated CPL messages.  Older

	 * firmware won't understand this and we'll just get

	 * unencapsulated messages ...

	/*

	 * Retrieve our RX interrupt holdoff timer values and counter

	 * threshold values from the SGE parameters.

	/*

	 * Grab our Virtual Interface resource allocation, extract the

	 * features that we're interested in and do a bit of sanity testing on

	 * what we discover.

 Check for various parameter sanity issues */

	/* Initialize nports and max_ethqsets now that we have our Virtual

	 * Function Resources.

/*

 * Perform default configuration of DMA queues depending on the number and

 * type of ports we found and the number of available CPUs.  Most settings can

 * be modified by the admin via ethtool and cxgbtool prior to the adapter

 * being brought up for the first time.

	/*

	 * We should not be called till we know how many Queue Sets we can

	 * support.  In particular, this means that we need to know what kind

	 * of interrupts we'll be using ...

	/*

	 * Count the number of 10GbE Virtual Interfaces that we have.

	/*

	 * We default to 1 queue per non-10G port and up to # of cores queues

	 * per 10G port.

	/*

	 * Allocate the "Queue Sets" to the various Virtual Interfaces.

	 * The layout will be established in setup_sge_queues() when the

	 * adapter is brough up for the first time.

	/*

	 * The Ingress Queue Entry Size for our various Response Queues needs

	 * to be big enough to accommodate the largest message we can receive

	 * from the chip/firmware; which is 64 bytes ...

	/*

	 * Set up default Queue Set parameters ...  Start off with the

	 * shortest interrupt holdoff timer.

	/*

	 * The firmware event queue is used for link state changes and

	 * notifications of TX DMA completions.

	/*

	 * The forwarded interrupt queue is used when we're in MSI interrupt

	 * mode.  In this mode all interrupts associated with RX queues will

	 * be forwarded to a single queue which we'll associate with our MSI

	 * interrupt vector.  The messages dropped in the forwarded interrupt

	 * queue will indicate which ingress queue needs servicing ...  This

	 * queue needs to be large enough to accommodate all of the ingress

	 * queues which are forwarding their interrupt (+1 to prevent the PIDX

	 * from equalling the CIDX if every ingress queue has an outstanding

	 * interrupt).  The queue doesn't need to be any larger because no

	 * ingress queue will ever have more than one outstanding interrupt at

	 * any time ...

/*

 * Reduce the number of Ethernet queues across all ports to at most n.

 * n provides at least one queue per port.

	/*

	 * While we have too many active Ether Queue Sets, interate across the

	 * "ports" and reduce their individual Queue Set allocations.

	/*

	 * Reassign the starting Queue Sets for each of the "ports" ...

/*

 * We need to grab enough MSI-X vectors to cover our interrupt needs.  Ideally

 * we get a separate MSI-X vector for every "Queue Set" plus any extras we

 * need.  Minimally we need one for every Virtual Interface plus those needed

 * for our "extras".  Note that this process may lower the maximum number of

 * allowed Queue Sets ...

	/*

	 * We _want_ enough MSI-X interrupts to cover all of our "Queue Sets"

	 * plus those needed for our "extras" (for example, the firmware

	 * message queue).  We _need_ at least one "Queue Set" per Virtual

	 * Interface plus those needed for our "extras".  So now we get to see

	 * if the song is right ...

/**

 *	cxgb4vf_get_port_mask - Get port mask for the VF based on mac

 *				address stored on the adapter

 *	@adapter: The adapter

 *

 *	Find the the port mask for the VF based on the index of mac

 *	address stored in the adapter. If no mac address is stored on

 *	the adapter for the VF, use the port mask received from the

 *	firmware.

/*

 * "Probe" a device: initialize a device and construct all kernel and driver

 * state needed to manage the device.  This routine is called "init_one" in

 * the PF Driver ...

	/*

	 * Initialize generic PCI device state.

	/*

	 * Reserve PCI resources for the device.  If we can't get them some

	 * other driver may have already claimed the device ...

	/*

	 * Set up our DMA mask: try for 64-bit address masking first and

	 * fall back to 32-bit if we can't get 64 bits ...

	/*

	 * Enable bus mastering for the device ...

	/*

	 * Allocate our adapter data structure and attach it to the device.

	/*

	 * Initialize SMP data synchronization resources.

	/*

	 * Map our I/O registers in BAR0.

	/* Wait for the device to become ready before proceeding ...

	/* For T5 and later we want to use the new BAR-based User Doorbells,

	 * so we need to map BAR2 here ...

	/*

	 * Initialize adapter level features.

	/* If possible, we use PCIe Relaxed Ordering Attribute to deliver

	 * Ingress Packet Data to Free List Buffers in order to allow for

	 * chipset performance optimizations between the Root Complex and

	 * Memory Controllers.  (Messages to the associated Ingress Queue

	 * notifying new Packet Placement in the Free Lists Buffers will be

	 * send without the Relaxed Ordering Attribute thus guaranteeing that

	 * all preceding PCIe Transaction Layer Packets will be processed

	 * first.)  But some Root Complexes have various issues with Upstream

	 * Transaction Layer Packets with the Relaxed Ordering Attribute set.

	 * The PCIe devices which under the Root Complexes will be cleared the

	 * Relaxed Ordering bit in the configuration space, So we check our

	 * PCIe configuration space to see if it's flagged with advice against

	 * using Relaxed Ordering.

 Initialize hash mac addr list */

	/*

	 * Allocate our "adapter ports" and stitch everything together.

		/*

		 * We simplistically allocate our virtual interfaces

		 * sequentially across the port numbers to which we have

		 * access rights.  This should be configurable in some manner

		 * ...

		/*

		 * Allocate our network device and stitch things together.

		/*

		 * Initialize the starting state of our "port" and register

		 * it.

		/*

		 * If we haven't been able to contact the firmware, there's

		 * nothing else we can do for this "port" ...

		/*

		 * Initialize the hardware/software state for the port.

	/* See what interrupts we'll be using.  If we've been configured to

	 * use MSI-X interrupts, try to enable them but fall back to using

	 * MSI interrupts if we can't enable MSI-X interrupts.  If we can't

	 * get MSI interrupts we bail with the error.

			/* We're going to need a Forwarded Interrupt Queue so

			 * that may cut into how many Queue Sets we can

			 * support.

	/* Now that we know how many "ports" we have and what interrupt

	 * mechanism we're going to use, we can configure our queue resources.

	/*

	 * The "card" is now ready to go.  If any errors occur during device

	 * registration we do not fail the whole "card" but rather proceed

	 * only with the ports we manage to register successfully.  However we

	 * must register at least one net device.

	/*

	 * Set up our debugfs entries.

	/*

	 * Print a short notice on the existence and configuration of the new

	 * VF network device ...

	/*

	 * Return success!

	/*

	 * Error recovery and exit code.  Unwind state that's been created

	 * so far and return the error.

/*

 * "Remove" a device: tear down all kernel and driver state created in the

 * "probe" routine and quiesce the device (disable interrupts, etc.).  (Note

 * that this is called "remove_one" in the PF Driver.)

	/*

	 * Tear down driver state associated with device.

		/*

		 * Stop all of our activity.  Unregister network port,

		 * disable interrupts, etc.

		/*

		 * Tear down our debugfs entries.

		/*

		 * Free all of the various resources which we've acquired ...

	/*

	 * Disable the device and release its PCI resources.

/*

 * "Shutdown" quiesce the device, stopping Ingress Packet and Interrupt

 * delivery.

	/* Disable all Virtual Interfaces.  This will shut down the

	 * delivery of all ingress packets into the chip for these

	 * Virtual Interfaces.

	/* Free up all Queues which will prevent further DMA and

	 * Interrupts allowing various internal pathways to drain.

	/*

	 * Free up all Queues which will prevent further DMA and

	 * Interrupts allowing various internal pathways to drain.

/* Macros needed to support the PCI Device ID Table ...

/*

 * Initialize global driver state.

	/*

	 * Vet our module parameters.

 Debugfs support is optional, debugfs will warn if this fails */

/*

 * Tear down global driver state.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2018 Chelsio Communications, Inc.

 *

 * Written by: Atul Gupta (atul.gupta@chelsio.com)

/*

 * Send control message to HW, message go as immediate data and packet

 * is freed immediately.

/*

 * Set one of the t_flags bits in the TCB.

 TLS Key bitmap processing */

	/* GCM mode of AES supports 128 and 256 bit encryption, so

	 * prepare key context base on GCM cipher type

	/* Calculate the H = CIPH(K, 0 repeated 16 times).

	 * It will go in key context

 Copy the Key context */

 erase key info from driver */

 Flush out-standing data before new key takes effect */

 ulptx command */

 sub command */

 key info */

 Clear quiesce for Rx key */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2018 Chelsio Communications, Inc.

 *

 * Written by: Atul Gupta (atul.gupta@chelsio.com)

 Copy IVs to WR */

 generate the  IVs */

 send the IVs as immediate data in the WR */

 Send the IVs as sgls */

 Already accounted IV DSGL for credits */

 Copy Key to WR */

/*

 * Returns true if an sk_buff carries urgent data.

 TLS content type for CPL SFO */

 Fill in the length */

 create the s-command */

/*

 * Calculate the TLS data expansion size

 WR with IV, KEY and CPL SFO added */

 frags counted for IV dsgl */

 Check TLS header len for Immediate */

 headers */

 TLS data len before IV/key */

 length [ulp bytes] inserted by hw */

/*

 * Returns true if a connection should send more data to TCP engine

	/*

	 * If we've released our offload resources there's nothing to do ...

	/*

	 * If there aren't any work requests in flight, or there isn't enough

	 * data in flight, or Nagle is off then send the current TX_DATA

	 * otherwise hold it and wait to accumulate more data.

/*

 * Returns true if a TCP socket is corked.

/*

 * Returns true if a send should try to push new data.

/*

 * Calculate the size for a new send sk_buff.  It's maximum size so we can

 * pack lots of data into it, unless we plan to send it immediately, in which

 * case we size it more tightly.

 *

 * Note: we don't bother compensating for MSS < PAGE_SIZE because it doesn't

 * arise in normal cases and when it does we are just wasting memory.

	/*

	 * If the data wouldn't fit in the main body anyway, put only the

	 * header in the main body so it can use immediate data and place all

	 * the payload in page fragments.

	/*

	 * If we will be accumulating payload get a large main body.

 Avoid appending tls handshake, alert to tls data */

 Update the skb. */

 space left keep page */

/*

 * Check if we need to grow the receive window in response to an increase in

 * the socket's receive buffer size.  Some applications increase the buffer

 * size dynamically and rely on the window to grow accordingly.

 Mark the receive window as updated */

/*

 * Send RX credits through an RX_DATA_ACK CPL message.  We are permitted

 * to return without sending the message in case we cannot allocate

 * an sk_buff.  Returns the number of credits sent.

/*

 * Called after some received data has been read.  It returns RX credits

 * to the HW for the amount of data processed.

/*

 * For coalescing to work effectively ensure the receive window has

 * at least 16KB left.

 First byte is urgent, skip */

		/* Set record type if not already done. For a non-data record,

		 * do not proceed if record type could not be copied.

  don't send tls header, skip copy */

/*

 * Peek at data in a socket's receive buffer.

 amount of available data in current skb */

 empty receive queue */

 Do not sleep, just process backlog. */

		/*

		 * Do we have urgent data here?  We need to skip over the

		 * urgent byte.

				/*

				 * The amount of data we are preparing to copy

				 * contains urgent data.

 First byte is urgent */

 stop short of the urgent data */

		/*

		 * If MSG_TRUNC is specified the data is discarded.

 amount of available data in current skb */

 Read at least this many bytes */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2018 Chelsio Communications, Inc.

 *

 * Written by: Atul Gupta (atul.gupta@chelsio.com)

/*

 * chtls device management

 * maintains a list of the chtls devices

 Reset tls rx/tx stats */

	/* Allocate space for cpl_pass_accpet_req which will be synthesized by

	 * driver. Once driver synthesizes cpl_pass_accpet_req the skb will go

	 * through the regular cpl_pass_accept_req processing in TOM.

 For now we will copy  cpl_rx_pkt in the skb */

 check version */

	/* GCM mode of AES supports 128 and 256 bit encryption, so

	 * copy keys from user based on GCM cipher type.

 Obtain version and type from previous copy */

 Now copy the following data */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2018 Chelsio Communications, Inc.

 *

 * Written by: Atul Gupta (atul.gupta@chelsio.com)

/*

 * State transitions and actions for close.  Note that if we are in SYN_SENT

 * we remain in that state as we cannot control a connection while it's in

 * SYN_SENT; such connections are allowed to establish and are then aborted.

 current state:     new state:      action: */

 (Invalid)       */ TCP_CLOSE,

 TCP_ESTABLISHED */ TCP_FIN_WAIT1 | TCP_ACTION_FIN,

 TCP_SYN_SENT    */ TCP_SYN_SENT,

 TCP_SYN_RECV    */ TCP_FIN_WAIT1 | TCP_ACTION_FIN,

 TCP_FIN_WAIT1   */ TCP_FIN_WAIT1,

 TCP_FIN_WAIT2   */ TCP_FIN_WAIT2,

 TCP_TIME_WAIT   */ TCP_CLOSE,

 TCP_CLOSE       */ TCP_CLOSE,

 TCP_CLOSE_WAIT  */ TCP_LAST_ACK | TCP_ACTION_FIN,

 TCP_LAST_ACK    */ TCP_LAST_ACK,

 TCP_LISTEN      */ TCP_CLOSE,

 TCP_CLOSING     */ TCP_CLOSING,

/*

 * Perform a state transition during close and return the actions indicated

 * for the transition.  Do not make this function inline, the main reason

 * it exists at all is to avoid multiple inlining of tcp_set_state.

/*

 * Wait until a socket enters on of the given states.

	/*

	 * We want this to work even when there's no associated struct socket.

	 * In that case we provide a temporary wait_queue_head_t.

 already have it */

	/*

	 * If the server is still open we clean up the child connection,

	 * otherwise the server already did the clean up as it was purging

	 * its SYN queue and the skb was just sitting in its backlog.

		/* Without the below call to sock_orphan,

		 * we leak the socket resource with syn_flood test

		 * as inet_csk_destroy_sock will not be called

		 * in tcp_done since SOCK_DEAD flag is not set.

		 * Kernel handles this differently where new socket is

		 * created only after 3 way handshake is done.

	/*

	 * If the connection is being aborted due to the parent listening

	 * socket going away there's nothing to do, the ABORT_REQ will close

	 * the connection.

 tcp_create_openreq_child ->sk_clone_lock */

/*

 * Populate a TID_RELEASE WR.  The skb must be already propely sized.

 IPv4 tos or IPv6 dsfield */

/*

 * Handle a CPL_PASS_ACCEPT_REQ message.

/*

 * Completes some final bits of initialization for just established connections

 * and changes their state to TCP_ESTABLISHED.

 *

 * snd_isn here is the ISN after the SYN, i.e., the true ISN + 1.

/*

 * Process the reap list.

 release the port immediately */

 listening server close */

 removed from synq */

/*

 * Handle receipt of an urgent pointer.

 duplicate pointer */

/*

 * Handles Rx data that arrives in a state where the socket isn't accepting

 * new data.

 Do not send POLL_HUP for half duplex close. */

 exclude FIN */

/*

 * Add an skb to the deferred skb queue for processing from process context.

/*

 * This is run from a listener's backlog to abort a child connection in

 * SYN_RCV state (i.e., one on the listener's SYN queue).

		/*

		 * Save the offload device in the skb, we may process this

		 * message after the socket has closed.

 return EINVAL if socket doesn't exist */

	/* Reusing the skb as size of cpl_set_tcb_field structure

	 * is greater than cpl_abort_req

/*

 * This file is part of the Chelsio T6 Crypto driver for Linux.

 *

 * Copyright (c) 2003-2017 Chelsio Communications, Inc. All rights reserved.

 *

 * This software is available to you under a choice of one of two

 * licenses.  You may choose to be licensed under the terms of the GNU

 * General Public License (GPL) Version 2, available from the file

 * COPYING in the main directory of this source tree, or the

 * OpenIB.org BSD license below:

 *

 *     Redistribution and use in source and binary forms, with or

 *     without modification, are permitted provided that the following

 *     conditions are met:

 *

 *      - Redistributions of source code must retain the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer.

 *

 *      - Redistributions in binary form must reproduce the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer in the documentation and/or other materials

 *        provided with the distribution.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS

 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN

 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN

 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

 *

 * Written and Maintained by:

 *	Atul Gupta (atul.gupta@chelsio.com)

/*

 * Max Tx descriptor space we allow for an Ethernet packet to be inlined

 * into a WR.

 nonce/salt is present in the last 4 bytes */

	/* Calculate the H = CIPH(K, 0 repeated 16 times).

	 * It will go in key context

/*

 * ch_ipsec_xfrm_add_state

 * returns 0 on success, negative error if failed to send message to FPGA

 * positive error if FPGA returned a bad response

 do nothing */

 Offload with IP options is not supported yet */

 Offload with IPv6 extension headers is not support yet */

 do nothing */

	/* If the skb is small enough, we can pump it out as a work request

	 * with only immediate data.  In that case we just have to have the

	 * TX Packet header plus the skb data in the Work Request.

	/* Otherwise, we're going to have to construct a Scatter gather list

	 * of the skb body and fragments.  We also include the flits necessary

	 * for the TX Packet Work Request and CPL.  We always have a firmware

	 * Write Header (incorporated as part of the cpl_tx_pkt_lso and

	 * cpl_tx_pkt structures), followed by either a TX Packet Write CPL

	 * message or, if we're doing a Large Send Offload, an LSO CPL message

	 * with an embedded TX Packet Write CPL message.

 end of queue, reset pos to start of queue */

 Copy ESN info for HW */

 end of queue, reset pos to start of queue */

 Copy the Key context header */

 Copy CPL TX PKT XT */

 WR Header */

 ULPTX */

 Sub-command */

 CPL_SEC_PDU */

/**

 *      flits_to_desc - returns the num of Tx descriptors for the given flits

 *      @n: the number of flits

 *

 *      Returns the number of Tx descriptors needed for the supplied number

 *      of flits.

/*

 *      ch_ipsec_xmit called from ULD Tx handler

 Setup IPSec CPL */

 SPDX-License-Identifier: GPL-2.0-only

 Copyright (C) 2020 Chelsio Communications.  All rights reserved. */

/* chcr_get_nfrags_to_send: get the remaining nfrags after start offset

 * @skb: skb

 * @start: start offset.

 * @len: how much data to send after @start

 if its a linear skb then return 1 */

/*

 * chcr_ktls_save_keys: calculate and save crypto keys.

 * @tx_info - driver specific tls info.

 * @crypto_info - tls crypto information.

 * @direction - TX/RX direction.

 * return - SUCCESS/FAILURE.

		/* The SCMD fields used when encrypting a full TLS

		 * record. Its a one time calculation till the

		 * connection exists.

 keys will be sent inline. */

		/* The SCMD fields used when encrypting a partial TLS

		 * record (no trailer and possibly a truncated payload).

	/* Calculate the H = CIPH(K, 0 repeated 16 times).

	 * It will go in key context

 fill the Key context */

/*

 * chcr_ktls_act_open_req: creates TCB entry for ipv4 connection.

 * @sk - tcp socket.

 * @tx_info - driver specific tls info.

 * @atid - connection active tid.

 * return - send success/failure.

 mark it a control pkt */

 fill first 64 bit option field. */

 next 64 bit option field. */

/*

 * chcr_ktls_act_open_req6: creates TCB entry for ipv6 connection.

 * @sk - tcp socket.

 * @tx_info - driver specific tls info.

 * @atid - connection active tid.

 * return - send success/failure.

 mark it a control pkt */

 first 64 bit option field. */

 next 64 bit option field. */

 #if IS_ENABLED(CONFIG_IPV6) */

/*

 * chcr_setup_connection:  create a TCB entry so that TP will form tcp packets.

 * @sk - tcp socket.

 * @tx_info - driver specific tls info.

 * return: NET_TX_OK/NET_XMIT_DROP

	/* if return type is NET_XMIT_CN, msg will be sent but delayed, mark ret

	 * success, if any other return type clear atid and return that failure.

 clear clip entry */

/*

 * chcr_set_tcb_field: update tcb fields.

 * @tx_info - driver specific tls info.

 * @word - TCB word.

 * @mask - TCB word related mask.

 * @val - TCB word related value.

 * @no_reply - set 1 if not looking for TP response.

/*

 * chcr_ktls_dev_del:  call back for tls_dev_del.

 * Remove the tid and l2t entry and close the connection.

 * it per connection basis.

 * @netdev - net device.

 * @tls_cts - tls context.

 * @direction - TX/RX crypto direction

 clear l2t entry */

 clear clip entry */

 clear tid */

 release module refcount */

/*

 * chcr_ktls_dev_add:  call back for tls_dev_add.

 * Create a tcb entry for TP. Also add l2t entry for the connection. And

 * generate keys & save those keys locally.

 * @netdev - net device.

 * @tls_cts - tls context.

 * @direction - TX/RX crypto direction

 * return: SUCCESS/FAILURE.

 initialize tid and atid to -1, 0 is a also a valid id. */

 save crypto keys */

 get peer ip */

 get the l2t index */

 Driver shouldn't be removed until any single connection exists */

	/* create a filter and call cxgb4_l2t_send to send the packet out, which

	 * will take care of updating l2t entry in hw if not already done.

 Wait for reply */

 need to wait for hw response, can't free tx_info yet. */

 if in pending close, free the lock after the cleanup */

 initialize tcb */

 mark it pending for hw response */

 Wait for reply */

 need to wait for hw response, can't free tx_info yet. */

 free the lock after cleanup */

 clear clip entry */

 release module refcount */

/*

 * chcr_init_tcb_fields:  Initialize tcb fields to handle TCP seq number

 *			  handling.

 * @tx_info - driver specific tls info.

 * return: NET_TX_OK/NET_XMIT_DROP

 set tcb in offload and bypass */

 reset snd_una and snd_next fields in tcb */

 reset send max */

	/* update l2t index and request for tp reply to confirm tcb is

	 * initialised to handle tx traffic.

/*

 * chcr_ktls_cpl_act_open_rpl: connection reply received from TP.

 HW response is very close, finish pending cleanup */

 Adding tid */

/*

 * chcr_ktls_cpl_set_tcb_rpl: TCB reply received from TP.

 ULP_TXPKT */

 ULPTX_IDATA sub-command */

 CPL_SET_TCB_FIELD */

 ULPTX_NOOP */

/*

 * chcr_write_cpl_set_tcb_ulp: update tcb values.

 * TCB is responsible to create tcp headers, so all the related values

 * should be correctly updated.

 * @tx_info - driver specific tls info.

 * @q - tx queue on which packet is going out.

 * @tid - TCB identifier.

 * @pos - current index where should we start writing.

 * @word - TCB word.

 * @mask - TCB word related mask.

 * @val - TCB word related value.

 * @reply - set 1 if looking for TP response.

 * return - next position to write.

 check again if we are at the end of the queue */

/*

 * chcr_ktls_xmit_tcb_cpls: update tcb entry so that TP will create the header

 * with updated values like tcp seq, ack, window etc.

 * @tx_info - driver specific tls info.

 * @q - TX queue.

 * @tcp_seq

 * @tcp_ack

 * @tcp_win

 * return: NETDEV_TX_BUSY/NET_TX_OK.

 there can be max 4 cpls, check if we have enough credits */

	/* make space for WR, we'll fill it later when we know all the cpls

	 * being sent out and have complete length.

 update tx_max if its a re-transmit or the first wr */

 reset snd una if it's a re-transmit pkt */

 reset snd_una */

 update ack */

 update receive window */

 get the actual length */

 ULPTX wr */

 fill len in wr field */

/*

 * chcr_ktls_get_tx_flits

 * returns number of flits to be sent out, it includes key context length, WR

 * size and skb fragments.

/*

 * chcr_ktls_check_tcp_options: To check if there is any TCP option available

 * other than timestamp.

 * @skb - skb contains partial record..

 * return: 1 / 0

/*

 * chcr_ktls_write_tcp_options : TP can't send out all the options, we need to

 * send out separately.

 * @tx_info - driver specific tls info.

 * @skb - skb contains partial record..

 * @q - TX queue.

 * @tx_chan - channel number.

 * return: NETDEV_TX_OK/NETDEV_TX_BUSY.

	/* packet length = eth hdr len + ip hdr len + tcp hdr len

	 * (including options).

 check how many descriptors needed */

 Firmware work request header */

 CPL header */

 we need to correct ip header len */

 checksum offload */

	/* now take care of the tcp header, if fin is not set then clear push

	 * bit as well, and if fin is set, it will be sent at the last so we

	 * need to update the tcp sequence number as per the last packet.

/*

 * chcr_ktls_xmit_wr_complete: This sends out the complete record. If an skb

 * received has partial end part of the record, send out the complete record, so

 * that crypto block will be able to generate TAG/HASH.

 * @skb - segment which has complete or partial end part.

 * @tx_info - driver specific tls info.

 * @q - TX queue.

 * @tcp_seq

 * @tcp_push - tcp push bit.

 * @mss - segment size.

 * return: NETDEV_TX_BUSY/NET_TX_OK.

 get the number of flits required */

 number of descriptors */

 check if enough credits available */

		/* Credits are below the threshold values, stop the queue after

		 * injecting the Work Request for this packet.

 FW_ULPTX_WR */

 WR will need len16 */

 ULP_TXPKT */

 ULPTX_IDATA sub-command */

	/* idata length will include cpl_tx_sec_pdu + key context size +

	 * cpl_tx_data header.

 SEC CPL */

 encryption should start after tls header size + iv size */

 authentication will also start after tls header + iv size */

 These two flits are actually a CPL_TLS_TX_SCMD_FMT. */

 check if space left to fill the keys */

 CPL_TX_DATA */

 check left again, it might go beyond queue limit */

 check the position again */

 send the complete packet except the header */

/*

 * chcr_ktls_xmit_wr_short: This is to send out partial records. If its

 * a middle part of a record, fetch the prior data to make it 16 byte aligned

 * and then only send it out.

 *

 * @skb - skb contains partial record..

 * @tx_info - driver specific tls info.

 * @q - TX queue.

 * @tcp_seq

 * @tcp_push - tcp push bit.

 * @mss - segment size.

 * @tls_rec_offset - offset from start of the tls record.

 * @perior_data - data before the current segment, required to make this record

 *		  16 byte aligned.

 * @prior_data_len - prior_data length (less than 16)

 * return: NETDEV_TX_BUSY/NET_TX_OK.

	/* get the number of flits required, it's a partial record so 2 flits

	 * (AES_BLOCK_SIZE) will be added.

 get the correct 8 byte IV of this record */

	/* If it's a middle record and not 16 byte aligned to run AES CTR, need

	 * to make it 16 byte aligned. So atleadt 2 extra flits of immediate

	 * data will be added.

 number of descriptors */

 check if enough credits available */

 FW_ULPTX_WR */

 WR will need len16 */

 ULP_TXPKT */

 ULPTX_IDATA sub-command */

	/* idata length will include cpl_tx_sec_pdu + key context size +

	 * cpl_tx_data header.

 SEC CPL */

	/* cipher start will have tls header + iv size extra if its a header

	 * part of tls record. else only 16 byte IV will be added.

 These two flits are actually a CPL_TLS_TX_SCMD_FMT. */

 check if space left to fill the keys */

 CPL_TX_DATA */

 check left again, it might go beyond queue limit */

 check the position again */

	/* copy the 16 byte IV for AES-CTR, which includes 4 bytes of salt, 8

	 * bytes of actual IV and 4 bytes of 16 byte-sequence.

	/* Prior_data_len will always be less than 16 bytes, fill the

	 * prio_data_len after AES_CTRL_BLOCK and clear the remaining length

	 * to 0.

 send the complete packet except the header */

/*

 * chcr_ktls_tx_plaintxt: This handler will take care of the records which has

 * only plain text (only tls header and iv)

 * @tx_info - driver specific tls info.

 * @skb - skb contains partial record..

 * @tcp_seq

 * @mss - segment size.

 * @tcp_push - tcp push bit.

 * @q - TX queue.

 * @port_id : port number

 * @perior_data - data before the current segment, required to make this record

 *		 16 byte aligned.

 * @prior_data_len - prior_data length (less than 16)

 * return: NETDEV_TX_BUSY/NET_TX_OK.

 WR will need len16 */

 check how many descriptors needed */

 FW_ULPTX_WR */

 ULP_TXPKT */

 ULPTX_IDATA sub-command */

 CPL_TX_DATA */

 set tcp seq number */

	/* apart from prior_data_len, we should set remaining part of 16 bytes

	 * to be zero.

 check left again, it might go beyond queue limit */

 check the position again */

 send the complete packet including the header */

 check how many descriptors needed */

 Firmware work request header */

 CPL header */

 checksum offload */

/*

 * chcr_ktls_copy_record_in_skb

 * @nskb - new skb where the frags to be added.

 * @skb - old skb, to copy socket and destructor details.

 * @record - specific record which has complete 16k record in frags.

 increase the frag ref count */

/*

 * chcr_end_part_handler: This handler will handle the record which

 * is complete or if record's end part is received. T6 adapter has a issue that

 * it can't send out TAG with partial record so if its an end part then we have

 * to send TAG as well and for which we need to fetch the complete record and

 * send it to crypto module.

 * @tx_info - driver specific tls info.

 * @skb - skb contains partial record.

 * @record - complete record of 16K size.

 * @tcp_seq

 * @mss - segment size in which TP needs to chop a packet.

 * @tcp_push_no_fin - tcp push if fin is not set.

 * @q - TX queue.

 * @tls_end_offset - offset from end of the record.

 * @last wr : check if this is the last part of the skb going out.

 * return: NETDEV_TX_OK/NETDEV_TX_BUSY.

 check if it is a complete record */

 copy complete record in skb */

		/* packet is being sent from the beginning, update the tcp_seq

		 * accordingly.

 reset skb offset */

/*

 * chcr_short_record_handler: This handler will take care of the records which

 * doesn't have end part (1st part or the middle part(/s) of a record). In such

 * cases, AES CTR will be used in place of AES GCM to send out partial packet.

 * This partial record might be the first part of the record, or the middle

 * part. In case of middle record we should fetch the prior data to make it 16

 * byte aligned. If it has a partial tls header or iv then get to the start of

 * tls header. And if it has partial TAG, then remove the complete TAG and send

 * only the payload.

 * There is one more possibility that it gets a partial header, send that

 * portion as a plaintext.

 * @tx_info - driver specific tls info.

 * @skb - skb contains partial record..

 * @record - complete record of 16K size.

 * @tcp_seq

 * @mss - segment size in which TP needs to chop a packet.

 * @tcp_push_no_fin - tcp push if fin is not set.

 * @q - TX queue.

 * @tls_end_offset - offset from end of the record.

 * return: NETDEV_TX_OK/NETDEV_TX_BUSY.

	/* check if the skb is ending in middle of tag/HASH, its a big

	 * trouble, send the packet before the HASH.

 check if it is only the header part. */

	/* check if the middle record's start point is 16 byte aligned. CTR

	 * needs 16 byte aligned start point to start encryption.

 there is an offset from start, means its a middle record */

		/* if prior_data_len is not zero, means we need to fetch prior

		 * data to make this record 16 byte aligned, or we need to reach

		 * to start offset.

 get the next page */

 reset tcp_seq as per the prior_data_required len */

 nic tls TX handler */

 if tcp options are set but finish is not send the options first */

	/* TCP segments can be in received either complete or partial.

	 * chcr_end_part_handler will handle cases if complete record or end

	 * part of the record is received. In case of partial end part of record,

	 * we will send the complete record again.

 fetch the tls record */

		/* By the time packet reached to us, ACK is received, and record

		 * won't be found in that case, handle it gracefully.

 update tcb for the skb */

			/* If tls_end_offset < data_len, means there is some

			 * data after start marker, which needs encryption, send

			 * plaintext first and take skb refcount. else send out

			 * complete pkt as plaintext.

 free the refcount taken earlier */

 if a tls record is finishing in this SKB */

			/* tcp_seq increment is required to handle next record.

 if any failure, come out from the loop. */

 length should never be less than 0 */

	/* tcp finish is set, send a separate tcp msg including all the options

	 * as well.

 clear l2t entry */

 clear clip entry */

 clear tid */

 release module refcount */

/*

 * Copyright (c) 2003-2008 Chelsio, Inc. All rights reserved.

 *

 * This software is available to you under a choice of one of two

 * licenses.  You may choose to be licensed under the terms of the GNU

 * General Public License (GPL) Version 2, available from the file

 * COPYING in the main directory of this source tree, or the

 * OpenIB.org BSD license below:

 *

 *     Redistribution and use in source and binary forms, with or

 *     without modification, are permitted provided that the following

 *     conditions are met:

 *

 *      - Redistributions of source code must retain the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer.

 *

 *      - Redistributions in binary form must reproduce the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer in the documentation and/or other materials

 *        provided with the distribution.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS

 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN

 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN

 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

/**

 *	t3_wait_op_done_val - wait until an operation is completed

 *	@adapter: the adapter performing the operation

 *	@reg: the register to check for completion

 *	@mask: a single-bit field within @reg that indicates completion

 *	@polarity: the value of the field when the operation is completed

 *	@attempts: number of check iterations

 *	@delay: delay in usecs between iterations

 *	@valp: where to store the value of the register at completion time

 *

 *	Wait until an operation is completed by checking a bit in a register

 *	up to @attempts times.  If @valp is not NULL the value of the register

 *	at the time it indicated completion is stored there.  Returns 0 if the

 *	operation completes and -EAGAIN otherwise.

/**

 *	t3_write_regs - write a bunch of registers

 *	@adapter: the adapter to program

 *	@p: an array of register address/register value pairs

 *	@n: the number of address/value pairs

 *	@offset: register address offset

 *

 *	Takes an array of register address/register value pairs and writes each

 *	value to the corresponding register.  Register addresses are adjusted

 *	by the supplied offset.

/**

 *	t3_set_reg_field - set a register field to a value

 *	@adapter: the adapter to program

 *	@addr: the register address

 *	@mask: specifies the portion of the register to modify

 *	@val: the new value for the register field

 *

 *	Sets a register field specified by the supplied mask to the

 *	given value.

 flush */

/**

 *	t3_read_indirect - read indirectly addressed registers

 *	@adap: the adapter

 *	@addr_reg: register holding the indirect address

 *	@data_reg: register holding the value of the indirect register

 *	@vals: where the read register values are stored

 *	@start_idx: index of first indirect register to read

 *	@nregs: how many indirect registers to read

 *

 *	Reads registers that are accessed indirectly through an address/data

 *	register pair.

/**

 *	t3_mc7_bd_read - read from MC7 through backdoor accesses

 *	@mc7: identifies MC7 to read from

 *	@start: index of first 64-bit word to read

 *	@n: number of 64-bit words to read

 *	@buf: where to store the read result

 *

 *	Read n 64-bit words from MC7 starting at word start, using backdoor

 *	accesses.

 # of 64-bit words */

/*

 * Initialize MI1.

/*

 * MI1 read/write operations for clause 22 PHYs.

/*

 * Performs the address cycle for clause 45 PHYs.

 * Must be called with the MDIO_LOCK held.

/*

 * MI1 read/write operations for indirect-addressed PHYs.

/**

 *	t3_mdio_change_bits - modify the value of a PHY register

 *	@phy: the PHY to operate on

 *	@mmd: the device address

 *	@reg: the register address

 *	@clear: what part of the register value to mask off

 *	@set: what part of the register value to set

 *

 *	Changes the value of a PHY register by applying a mask to its current

 *	value and ORing the result with a new value.

/**

 *	t3_phy_reset - reset a PHY block

 *	@phy: the PHY to operate on

 *	@mmd: the device address of the PHY block to reset

 *	@wait: how long to wait for the reset to complete in 1ms increments

 *

 *	Resets a PHY block and optionally waits for the reset to complete.

 *	@mmd should be 0 for 10/100/1000 PHYs and the device address to reset

 *	for 10G PHYs.

/**

 *	t3_phy_advertise - set the PHY advertisement registers for autoneg

 *	@phy: the PHY to operate on

 *	@advert: bitmap of capabilities the PHY should advertise

 *

 *	Sets a 10/100/1000 PHY's advertisement registers to advertise the

 *	requested capabilities.

/**

 *	t3_phy_advertise_fiber - set fiber PHY advertisement register

 *	@phy: the PHY to operate on

 *	@advert: bitmap of capabilities the PHY should advertise

 *

 *	Sets a fiber PHY's advertisement register to advertise the

 *	requested capabilities.

/**

 *	t3_set_phy_speed_duplex - force PHY speed and duplex

 *	@phy: the PHY to operate on

 *	@speed: requested PHY speed

 *	@duplex: requested PHY duplex

 *

 *	Force a 10/100/1000 PHY's speed and duplex.  This also disables

 *	auto-negotiation except for GigE, where auto-negotiation is mandatory.

 auto-negotiation required for GigE */

/*

 * Return the adapter_info structure with a given index.  Out-of-range indices

 * return NULL.

/*

 * Partial EEPROM Vital Product Data structure.  Includes only the ID and

 * VPD-R sections.

 part number */

 EC level */

 serial number */

 MAC address base */

 core clock */

 mem clock */

 uP clk */

 MDIO clk */

 mem timing */

 XAUI0 config */

 XAUI1 config */

 PHY0 complex */

 PHY1 complex */

 PHY2 complex */

 PHY3 complex */

 csum */

 for multiple-of-4 sizing and alignment */

/**

 *	t3_seeprom_wp - enable/disable EEPROM write protection

 *	@adapter: the adapter

 *	@enable: 1 to enable write protection, 0 to disable it

 *

 *	Enables or disables write protection on the serial EEPROM.

 EEPROM_STAT_ADDR is outside VPD area, use pci_write_vpd_any() */

/**

 *	get_vpd_params - read VPD parameters from VPD EEPROM

 *	@adapter: adapter to read

 *	@p: where to store the parameters

 *

 *	Reads card parameters stored in VPD EEPROM.

	/*

	 * Card information is normally at VPD_BASE but some early cards had

	 * it at 0.

 Old eeproms didn't have port information */

 serial flash and firmware constants */

 max retries for SF1 operations */

 serial flash sector size */

 serial flash size */

 flash command opcodes */

 program page */

 disable writes */

 read status register */

 enable writes */

 read flash */

 erase sector */

 start address of FW in flash */

 flash address holding FW version */

 at least version and csum */

/**

 *	sf1_read - read data from the serial flash

 *	@adapter: the adapter

 *	@byte_cnt: number of bytes to read

 *	@cont: whether another operation will be chained

 *	@valp: where to store the read data

 *

 *	Reads up to 4 bytes of data from the serial flash.  The location of

 *	the read needs to be specified prior to calling this by issuing the

 *	appropriate commands to the serial flash.

/**

 *	sf1_write - write data to the serial flash

 *	@adapter: the adapter

 *	@byte_cnt: number of bytes to write

 *	@cont: whether another operation will be chained

 *	@val: value to write

 *

 *	Writes up to 4 bytes of data to the serial flash.  The location of

 *	the write needs to be specified prior to calling this by issuing the

 *	appropriate commands to the serial flash.

/**

 *	flash_wait_op - wait for a flash operation to complete

 *	@adapter: the adapter

 *	@attempts: max number of polls of the status register

 *	@delay: delay between polls in ms

 *

 *	Wait for a flash operation to complete by polling the status register.

/**

 *	t3_read_flash - read words from serial flash

 *	@adapter: the adapter

 *	@addr: the start address for the read

 *	@nwords: how many 32-bit words to read

 *	@data: where to store the read data

 *	@byte_oriented: whether to store data as bytes or as words

 *

 *	Read the specified number of 32-bit words from the serial flash.

 *	If @byte_oriented is set the read data is stored as a byte array

 *	(i.e., big-endian), otherwise as 32-bit words in the platform's

 *	natural endianness.

/**

 *	t3_write_flash - write up to a page of data to the serial flash

 *	@adapter: the adapter

 *	@addr: the start address to write

 *	@n: length of data to write

 *	@data: the data to write

 *

 *	Writes up to a page of data (256 bytes) to the serial flash starting

 *	at the given address.

 Read the page to verify the write succeeded */

/**

 *	t3_get_tp_version - read the tp sram version

 *	@adapter: the adapter

 *	@vers: where to place the version

 *

 *	Reads the protocol sram version from sram.

 Get version loaded in SRAM */

/**

 *	t3_check_tpsram_version - read the tp sram version

 *	@adapter: the adapter

 *

 *	Reads the protocol sram version from flash.

/**

 *	t3_check_tpsram - check if provided protocol SRAM

 *			  is compatible with this driver

 *	@adapter: the adapter

 *	@tp_sram: the firmware image to write

 *	@size: image size

 *

 *	Checks if an adapter's tp sram is compatible with the driver.

 *	Returns 0 if the versions are compatible, a negative error otherwise.

 Verify checksum */

/**

 *	t3_get_fw_version - read the firmware version

 *	@adapter: the adapter

 *	@vers: where to place the version

 *

 *	Reads the FW version from flash.

/**

 *	t3_check_fw_version - check if the FW is compatible with this driver

 *	@adapter: the adapter

 *

 *	Checks if an adapter's FW is compatible with the driver.  Returns 0

 *	if the versions are compatible, a negative error otherwise.

/**

 *	t3_flash_erase_sectors - erase a range of flash sectors

 *	@adapter: the adapter

 *	@start: the first sector to erase

 *	@end: the last sector to erase

 *

 *	Erases the sectors in the given range.

/**

 *	t3_load_fw - download firmware

 *	@adapter: the adapter

 *	@fw_data: the firmware image to write

 *	@size: image size

 *

 *	Write the supplied firmware image to the card's serial flash.

 *	The FW image has the following sections: @size - 8 bytes of code and

 *	data, followed by 4 bytes of FW version, followed by the 32-bit

 *	1's complement checksum of the whole image.

 trim off version and checksum */

/**

 *      t3_cim_ctl_blk_read - read a block from CIM control region

 *

 *      @adap: the adapter

 *      @addr: the start address within the CIM control region

 *      @n: number of words to read

 *      @valp: where to store the result

 *

 *      Reads a block of 4-byte words from the CIM control region.

 stop Rx unicast traffic */

 stop broadcast, multicast, promiscuous mode traffic */

 Leave time to drain max RX fifo */

/**

 *	t3_link_changed - handle interface link changes

 *	@adapter: the adapter

 *	@port_id: the port index that changed link state

 *

 *	Called when a port's link settings change to propagate the new values

 *	to the associated PHY and MAC.  After performing the common tasks it

 *	invokes an OS-specific handler.

 nothing changed */

 Set MAC speed, duplex, and flow control to match PHY. */

 Account link faults only when the phy reports a link up */

/**

 *	t3_link_start - apply link configuration to MAC/PHY

 *	@phy: the PHY to setup

 *	@mac: the MAC to setup

 *	@lc: the requested link configuration

 *

 *	Set up a port's MAC and PHY according to a desired link configuration.

 *	- If the PHY can auto-negotiate first decide what to advertise, then

 *	  enable/disable auto-negotiation as desired, and reset.

 *	- If the PHY does not auto-negotiate just reset it.

 *	- If auto-negotiation is off set the MAC to the proper speed/duplex/FC,

 *	  otherwise do it later based on the outcome of auto-negotiation.

 Also disables autoneg */

/**

 *	t3_set_vlan_accel - control HW VLAN extraction

 *	@adapter: the adapter

 *	@ports: bitmap of adapter ports to operate on

 *	@on: enable (1) or disable (0) HW VLAN extraction

 *

 *	Enables or disables HW extraction of VLAN tags for the given port.

 bits to check in interrupt status */

 message to print or NULL */

 stat counter to increment or -1 */

 whether the condition reported is fatal */

/**

 *	t3_handle_intr_status - table driven interrupt handler

 *	@adapter: the adapter that generated the interrupt

 *	@reg: the interrupt status register to process

 *	@mask: a mask to apply to the interrupt status

 *	@acts: table of interrupt actions

 *	@stats: statistics counters tracking interrupt occurrences

 *

 *	A table driven interrupt handler that applies a set of masks to an

 *	interrupt status word and performs the corresponding actions if the

 *	interrupts described by the mask have occurred.  The actions include

 *	optionally printing a warning or alert message, and optionally

 *	incrementing a stat counter.  The table is terminated by an entry

 *	specifying mask 0.  Returns the number of fatal interrupt conditions.

 clear processed interrupts */

 | V_MSIXPARERR(M_MSIXPARERR) */)

 V_PCIE_MSIXPARERR(M_PCIE_MSIXPARERR) | */ \

/*

 * Interrupt handler for the PCIX1 module.

/*

 * Interrupt handler for the PCIE module.

/*

 * TP interrupt handler.

/*

 * CIM interrupt handler.

/*

 * ULP RX interrupt handler.

/*

 * ULP TX interrupt handler.

/*

 * PM TX interrupt handler.

/*

 * PM RX interrupt handler.

/*

 * CPL switch interrupt handler.

/*

 * MPS interrupt handler.

/*

 * MC7 interrupt handler.

/*

 * XGMAC interrupt handler.

	/*

	 * We mask out interrupt causes for which we're not taking interrupts.

	 * This allows us to use polling logic to monitor some of the other

	 * conditions when taking interrupts would impose too much load on the

	 * system.

/*

 * Interrupt handler for PHY events.

/*

 * T3 slow path (non-data) interrupt handler.

 Clear the interrupts just processed. */

 flush */

/**

 *	t3_intr_enable - enable interrupts

 *	@adapter: the adapter whose interrupts should be enabled

 *

 *	Enable interrupts by setting the interrupt enable registers of the

 *	various HW modules and then enabling the top-level interrupt

 *	concentrator.

 flush */

/**

 *	t3_intr_disable - disable a card's interrupts

 *	@adapter: the adapter whose interrupts should be disabled

 *

 *	Disable interrupts.  We only disable the top-level interrupt

 *	concentrator and the SGE data interrupts.

 flush */

/**

 *	t3_intr_clear - clear all interrupts

 *	@adapter: the adapter whose interrupts should be cleared

 *

 *	Clears all interrupts.

 Clear PHY and MAC interrupts for each port. */

 flush */

/**

 *	t3_port_intr_enable - enable port-specific interrupts

 *	@adapter: associated adapter

 *	@idx: index of port whose interrupts should be enabled

 *

 *	Enable port-specific (i.e., MAC and PHY) interrupts for the given

 *	adapter port.

 flush */

/**

 *	t3_port_intr_disable - disable port-specific interrupts

 *	@adapter: associated adapter

 *	@idx: index of port whose interrupts should be disabled

 *

 *	Disable port-specific (i.e., MAC and PHY) interrupts for the given

 *	adapter port.

 flush */

/**

 *	t3_port_intr_clear - clear port-specific interrupts

 *	@adapter: associated adapter

 *	@idx: index of port whose interrupts to clear

 *

 *	Clear port-specific (i.e., MAC and PHY) interrupts for the given

 *	adapter port.

 flush */

/**

 * 	t3_sge_write_context - write an SGE context

 * 	@adapter: the adapter

 * 	@id: the context id

 * 	@type: the context type

 *

 * 	Program an SGE context with the values already loaded in the

 * 	CONTEXT_DATA? registers.

		/*

		 * Can't write the Response Queue Context bits for

		 * Interrupt Armed or the Reserve bits after the chip

		 * has been initialized out of reset.  Writing to these

		 * bits can confuse the hardware.

/**

 *	clear_sge_ctxt - completely clear an SGE context

 *	@adap: the adapter

 *	@id: the context id

 *	@type: the context type

 *

 *	Completely clear an SGE context.  Used predominantly at post-reset

 *	initialization.  Note in particular that we don't skip writing to any

 *	"sensitive bits" in the contexts the way that t3_sge_write_context()

 *	does ...

/**

 *	t3_sge_init_ecntxt - initialize an SGE egress context

 *	@adapter: the adapter to configure

 *	@id: the context id

 *	@gts_enable: whether to enable GTS for the context

 *	@type: the egress context type

 *	@respq: associated response queue

 *	@base_addr: base address of queue

 *	@size: number of queue entries

 *	@token: uP token

 *	@gen: initial generation value for the context

 *	@cidx: consumer pointer

 *

 *	Initialize an SGE egress context and make it ready for use.  If the

 *	platform allows concurrent context operations, the caller is

 *	responsible for appropriate locking.

 must be 4K aligned */

/**

 *	t3_sge_init_flcntxt - initialize an SGE free-buffer list context

 *	@adapter: the adapter to configure

 *	@id: the context id

 *	@gts_enable: whether to enable GTS for the context

 *	@base_addr: base address of queue

 *	@size: number of queue entries

 *	@bsize: size of each buffer for this queue

 *	@cong_thres: threshold to signal congestion to upstream producers

 *	@gen: initial generation value for the context

 *	@cidx: consumer pointer

 *

 *	Initialize an SGE free list context and make it ready for use.  The

 *	caller is responsible for ensuring only one context operation occurs

 *	at a time.

 must be 4K aligned */

/**

 *	t3_sge_init_rspcntxt - initialize an SGE response queue context

 *	@adapter: the adapter to configure

 *	@id: the context id

 *	@irq_vec_idx: MSI-X interrupt vector index, 0 if no MSI-X, -1 if no IRQ

 *	@base_addr: base address of queue

 *	@size: number of queue entries

 *	@fl_thres: threshold for selecting the normal or jumbo free list

 *	@gen: initial generation value for the context

 *	@cidx: consumer pointer

 *

 *	Initialize an SGE response queue context and make it ready for use.

 *	The caller is responsible for ensuring only one context operation

 *	occurs at a time.

 must be 4K aligned */

/**

 *	t3_sge_init_cqcntxt - initialize an SGE completion queue context

 *	@adapter: the adapter to configure

 *	@id: the context id

 *	@base_addr: base address of queue

 *	@size: number of queue entries

 *	@rspq: response queue for async notifications

 *	@ovfl_mode: CQ overflow mode

 *	@credits: completion queue credits

 *	@credit_thres: the credit threshold

 *

 *	Initialize an SGE completion queue context and make it ready for use.

 *	The caller is responsible for ensuring only one context operation

 *	occurs at a time.

 must be 4K aligned */

/**

 *	t3_sge_enable_ecntxt - enable/disable an SGE egress context

 *	@adapter: the adapter

 *	@id: the egress context id

 *	@enable: enable (1) or disable (0) the context

 *

 *	Enable or disable an SGE egress context.  The caller is responsible for

 *	ensuring only one context operation occurs at a time.

/**

 *	t3_sge_disable_fl - disable an SGE free-buffer list

 *	@adapter: the adapter

 *	@id: the free list context id

 *

 *	Disable an SGE free-buffer list.  The caller is responsible for

 *	ensuring only one context operation occurs at a time.

/**

 *	t3_sge_disable_rspcntxt - disable an SGE response queue

 *	@adapter: the adapter

 *	@id: the response queue context id

 *

 *	Disable an SGE response queue.  The caller is responsible for

 *	ensuring only one context operation occurs at a time.

/**

 *	t3_sge_disable_cqcntxt - disable an SGE completion queue

 *	@adapter: the adapter

 *	@id: the completion queue context id

 *

 *	Disable an SGE completion queue.  The caller is responsible for

 *	ensuring only one context operation occurs at a time.

/**

 *	t3_sge_cqcntxt_op - perform an operation on a completion queue context

 *	@adapter: the adapter

 *	@id: the context id

 *	@op: the operation to perform

 *	@credits: credit value to write

 *

 *	Perform the selected operation on an SGE completion queue context.

 *	The caller is responsible for ensuring only one context operation

 *	occurs at a time.

/**

 *	t3_config_rss - configure Rx packet steering

 *	@adapter: the adapter

 *	@rss_config: RSS settings (written to TP_RSS_CONFIG)

 *	@cpus: values for the CPU lookup table (0xff terminated)

 *	@rspq: values for the response queue lookup table (0xffff terminated)

 *

 *	Programs the receive packet steering logic.  @cpus and @rspq provide

 *	the values for the CPU and response queue lookup tables.  If they

 *	provide fewer values than the size of the tables the supplied values

 *	are used repeatedly until the tables are fully populated.

/**

 *	t3_tp_set_offload_mode - put TP in NIC/offload mode

 *	@adap: the adapter

 *	@enable: 1 to select offload mode, 0 for regular NIC

 *

 *	Switches TP to NIC/offload mode.

/**

 *	pm_num_pages - calculate the number of pages of the payload memory

 *	@mem_size: the size of the payload memory

 *	@pg_size: the size of each payload memory page

 *

 *	Calculate the number of pages, each of the given size, that fit in a

 *	memory of the specified size, respecting the HW requirement that the

 *	number of pages must be a multiple of 24.

/**

 *	partition_mem - partition memory and configure TP memory settings

 *	@adap: the adapter

 *	@p: the TP parameters

 *

 *	Partitions context and payload memory and configures TP's memory

 *	registers.

 Add a bit of headroom and make multiple of 24 */

 Desired TP timer resolution in usec */

 TCP timer values in ms */

/**

 *	tp_set_timers - set TP timing parameters

 *	@adap: the adapter to set

 *	@core_clk: the core clock frequency in Hz

 *

 *	Set TP's timing parameters, such as the various timer resolutions and

 *	the TCP timer values.

 200us */

 1ms, at least */

/**

 *	t3_tp_set_coalescing_size - set receive coalescing size

 *	@adap: the adapter

 *	@size: the receive coalescing size

 *	@psh: whether a set PSH bit should deliver coalesced data

 *

 *	Set the receive coalescing size and PSH bit handling.

/**

 *	t3_tp_set_max_rxsize - set the max receive size

 *	@adap: the adapter

 *	@size: the max receive size

 *

 *	Set TP's max receive size.  This is the limit that applies when

 *	receive coalescing is disabled.

	/*

	 * See draft-mathis-plpmtud-00.txt for the values.  The min is 88 so

	 * it can accommodate max size TCP/IP headers when SACK and timestamps

	 * are enabled and still have at least 8 bytes of payload.

/*

 * Initial congestion control parameters.

 The minimum additive increment value for the congestion control table */

/**

 *	t3_load_mtus - write the MTU and congestion control HW tables

 *	@adap: the adapter

 *	@mtus: the unrestricted values for the MTU table

 *	@alpha: the values for the congestion control alpha parameter

 *	@beta: the values for the congestion control beta parameter

 *	@mtu_cap: the maximum permitted effective MTU

 *

 *	Write the MTU table with the supplied MTUs capping each at &mtu_cap.

 *	Update the high-speed congestion control table with the supplied alpha,

 * 	beta, and MTUs.

 round */

/**

 *	t3_tp_get_mib_stats - read TP's MIB counters

 *	@adap: the adapter

 *	@tps: holds the returned counter values

 *

 *	Returns the values of TP's MIB counters.

/**

 *	t3_set_proto_sram - set the contents of the protocol sram

 *	@adap: the adapter

 *	@data: the protocol image

 *

 *	Write the contents of the protocol SRAM.

/**

 *	t3_config_sched - configure a HW traffic scheduler

 *	@adap: the adapter

 *	@kbps: target rate in Kbps

 *	@sched: the scheduler index

 *

 *	Configure a HW scheduler for the target rate

 -> bytes */

/*

 * Perform the bits of HW initialization that are dependent on the Tx

 * channels being used.

 one channel */

 two channels */

/*

 * Write a value to a register and check that the write completed.  These

 * writes normally complete in a cycle or two, so one read should suffice.

 * The very first read exists to flush the posted write to the device.

 flush */

 flush */

 flush */

 clock value is in KHz */

 ns */

 KHz->MHz, ns->us */

 flush */

 flush */

 Enable normal memory accesses. */

 check LOsEnable */

/*

 * Initialize and configure T3 HW modules.  This performs the

 * initialization steps that need to be done once after a card is reset.

 * MAC and PHY initialization is handled separarely whenever a port is enabled.

 *

 * fw_params are passed to FW and their value is platform dependent.  Only the

 * top 8 bits are available for use, the rest must be 0.

 flush */

 wait for uP to initialize */

/**

 *	get_pci_mode - determine a card's PCI mode

 *	@adapter: the adapter

 *	@p: where to store the PCI settings

 *

 *	Determines a card's PCI mode and associated parameters, such as speed

 *	and width.

/**

 *	init_link_config - initialize a link's SW state

 *	@lc: structure holding the link state

 *	@caps: information about the current card

 *

 *	Initializes the SW state maintained for each link, including the link's

 *	capabilities and default speed/duplex/flow-control/autonegotiation

 *	settings.

/**

 *	mc7_calc_size - calculate MC7 memory size

 *	@cfg: the MC7 configuration

 *

 *	Calculates the size of an MC7 memory in bytes from the value of its

 *	configuration register.

 set for 80KHz */

 Enable MAC clocks so we can access the registers */

/*

 * Reset the adapter.

 * Older PCIe cards lose their config space during reset, PCI-X

 * ones don't.

	/*

	 * Delay. Give Some time to device to reset fully.

	 * XXX The delay time should be modified.

/*

 * Initialize adapter SW state for the various HW modules, set initial values

 * for some adapter tunables, take PHYs out of reset, and initialize the MDIO

 * interface.

	/*

	 * We used to only run the "adapter check task" once a second if

	 * we had PHYs which didn't support interrupts (we would check

	 * their link status once a second).  Now we check other conditions

	 * in that routine which could potentially impose a very high

	 * interrupt load on the system.  As such, we now always scan the

	 * adapter state once a second ...

 only 1 Rx channel */

		/*

		 * The VPD EEPROM stores the base Ethernet address for the

		 * card.  A port's address is derived from the base by adding

		 * the port's index to the base's low octet.

		/*

		 * If the PHY doesn't support interrupts for link status

		 * changes, schedule a scan of the adapter links at least

		 * once a second.

/*

 * Copyright (c) 2003-2008 Chelsio, Inc. All rights reserved.

 *

 * This software is available to you under a choice of one of two

 * licenses.  You may choose to be licensed under the terms of the GNU

 * General Public License (GPL) Version 2, available from the file

 * COPYING in the main directory of this source tree, or the

 * OpenIB.org BSD license below:

 *

 *     Redistribution and use in source and binary forms, with or

 *     without modification, are permitted provided that the following

 *     conditions are met:

 *

 *      - Redistributions of source code must retain the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer.

 *

 *      - Redistributions in binary form must reproduce the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer in the documentation and/or other materials

 *        provided with the distribution.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS

 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN

 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN

 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

 PE9000 */

 T302E */

 T310E */

 T320X */

 T302X */

 T320E */

 T310X */

 T3B10 */

 T3B20 */

 T3B02 */

 T3C20-derived T3C10 */

 S320E-CR */

 N320E-G2 */

/*

 * The driver uses the best interrupt scheme available on a platform in the

 * order MSI-X, MSI, legacy pin interrupts.  This parameter determines which

 * of these schemes the driver may consider as follows:

 *

 * msi = 2: choose from among all three options

 * msi = 1: only consider MSI and pin interrupts

 * msi = 0: force pin interrupts

/*

 * The driver enables offload as a default.

 * To disable it, use ofld_disable = 1.

/*

 * We have work elements that we need to cancel when an interface is taken

 * down.  Normally the work elements would be executed by keventd but that

 * can deadlock because of linkwatch.  If our close method takes the rtnl

 * lock and linkwatch is ahead of our work elements in keventd, linkwatch

 * will block keventd as it needs the rtnl lock, and we'll deadlock waiting

 * for our work to complete.  Get our own work queue to solve this.

/**

 *	link_report - show link status and link speed/duplex

 *	@dev: the port whose settings are to be reported

 *

 *	Shows the link status, speed, and duplex of a port.

 Clear local faults */

 Flush TX FIFO */

/**

 *	t3_os_link_changed - handle link status changes

 *	@adapter: the adapter associated with the link change

 *	@port_id: the port index whose limk status has changed

 *	@link_stat: the new status of the link

 *	@speed: the new speed setting

 *	@duplex: the new duplex setting

 *	@pause: the new flow-control setting

 *

 *	This is the OS-dependent handler for link status changes.  The OS

 *	neutral handler takes care of most of the processing for these events,

 *	then calls this handler for any OS-specific processing.

 Skip changes from disabled ports. */

 Clear local faults */

 Flush TX FIFO */

/**

 *	t3_os_phymod_changed - handle PHY module changes

 *	@adap: the adapter associated with the link change

 *	@port_id: the port index whose limk status has changed

 *

 *	This is the OS-dependent handler for PHY module changes.  It is

 *	invoked when a PHY module is removed or inserted for any OS-specific

 *	processing.

/**

 *	link_start - enable a port

 *	@dev: the device to enable

 *

 *	Performs the MAC and PHY actions needed to enable a port.

/*

 * Interrupt handler for asynchronous events used with MSI-X.

/*

 * Name the MSI-X interrupts.

/**

 *	setup_rss - configure RSS

 *	@adap: the adapter

 *

 *	Sets up RSS to distribute packets to multiple receive queues.  We

 *	configure the RSS CPU lookup table to distribute to the number of HW

 *	receive queues, and the response queue lookup table to narrow that

 *	down to the response queues actually configured for each port.

 *	We always configure the RSS mapping for two ports since the mapping

 *	table has plenty of entries.

 terminator */

 terminator */

	/*

	 * netif_napi_add() can be called only once per napi_struct because it

	 * adds each new napi_struct to a list.  Be careful not to call it a

	 * second time, e.g., during EEH recovery, by making a note of it.

/*

 * Wait until all NAPI handlers are descheduled.  This includes the handlers of

 * both netdevices representing interfaces and the dummy ones for the extra

 * queues.

/**

 *	setup_sge_qsets - configure SGE Tx/Rx/response queues

 *	@adap: the adapter

 *

 *	Determines how many sets of SGE queues to use and initializes them.

 *	We support multiple queue sets per port if we have MSI-X, otherwise

 *	just one queue set per port.

 Synchronize with ioctls that may shut down the device */

/*

 * Sends an sk_buff to an offload queue driver

 * after dealing with any active network taps.

 should be 0 but there's a T3 bug */

 check size, take checksum in account */

 compute checksum */

/**

 * t3_synchronize_rx - wait for current Rx processing on a port to complete

 * @adap: the adapter

 * @p: the port

 *

 * Ensures that current Rx processing on any of the queues associated with

 * the given port completes before returning.  We do this by acquiring and

 * releasing the locks of the response queues associated with the port.

 single control for all ports */

/**

 *	cxgb_up - enable the adapter

 *	@adap: adapter being enabled

 *

 *	Called when the first port is enabled, this function performs the

 *	actions necessary to make an adapter operational, such as completing

 *	the initialization of HW modules, and enabling interrupts.

 *

 *	Must be called with the rtnl lock held.

		/*

		 * Clear interrupts now to catch errors if t3_init_hw fails.

		 * We clear them again later as initialization may trigger

		 * conditions that can interrupt.

/*

 * Release resources when all the ports and offloading have been stopped.

 sync with PHY intr task */

 wait for external IRQ handler */

 Call back all registered clients */

 restore them in case the offload module has changed them */

 Call back all registered clients */

 Flush work scheduled while releasing TIDs */

 Stop link fault interrupts */

 sync with update task */

 detailed rx_errors */

 detailed tx_errors */

	/*

	 * Version scheme:

	 * bits 0..9: chip version

	 * bits 10..15: chip revision

	 * bit 31: set for PCIe cards

	/*

	 * We skip the MAC statistics registers because they are clear-on-read.

	 * Also reading multi-register stats would need to synchronize with the

	 * periodic mac stats accumulation.  Hard to justify the complexity.

 cycle on/off once per second */

		/*

		 * PHY offers a single speed/duplex.  See if that's what's

		 * being requested.

 Allow setting of any available qset when offload enabled */

 No polling with INTx for T3A */

 Display qsets for all ports when offload enabled */

 Check t.len sanity ? */

 accommodate SACK */

 MTUs must be in ascending order */

 not power of 2 */

 not 16KB or 64KB */

 need the memory controllers */

		/*

		 * Version scheme:

		 * bits 0..9: chip version

		 * bits 10..15: chip revision

		/*

		 * Read 256 bytes at a time as len can be large and we don't

		 * want to use huge intermediate buffers.

 advance to start of buffer */

 Convert phy_id from older PRTAD/DEVAD format */

	/*

	 * Since there is no support for separate rx/tx vlan accel

	 * enable/disable make sure tx flag is always in same state as rx.

/*

 * Periodic accumulation of MAC statistics.

 synchronize with ifdown */

 Accumulate MAC stats if needed */

	/*

	 * Scan the XGMAC's to check for various conditions which we want to

	 * monitor in a periodic polling manner rather than via an interrupt

	 * condition.  This is used for conditions which would otherwise flood

	 * the system with interrupts and we only really need to know that the

	 * conditions are "happening" ...  For each condition we count the

	 * detection of the condition and reset it for the next polling loop.

	/*

	 * We do the same as above for FL_EMPTY interrupts.

 Schedule the next check update if any port is active. */

	/*

	 * Sleep a while before ringing the driver qset dbs.

	 * The delay is between 1000-2023 usecs.

/*

 * Processes external (PHY) interrupts in process context.

 Disable link fault interrupts */

 Re-enable link fault interrupts */

 Now reenable external interrupts */

/*

 * Interrupt-context handler for external (PHY) interrupts.

	/*

	 * Schedule a task to handle external interrupts as they may be slow

	 * and we use a mutex to protect MDIO registers.  We disable PHY

	 * interrupts in the meantime and let the task reenable them when

	 * it's done.

 Stop all ports */

 Stop SGE timers */

 Free sge resources */

 Restart the ports */

/*

 * processes a fatal error.

 * Bring the ports down, reset the chip, bring the ports back up.

/**

 * t3_io_error_detected - called when PCI error is detected

 * @pdev: Pointer to PCI device

 * @state: The current pci connection state

 *

 * This function is called after a PCI bus error affecting

 * this device has been detected.

 Request a slot reset. */

/**

 * t3_io_slot_reset - called after the pci bus has been reset.

 * @pdev: Pointer to PCI device

 *

 * Restart the card from scratch, as if from a cold-boot.

/**

 * t3_io_resume - called when traffic can start flowing again.

 * @pdev: Pointer to PCI device

 *

 * This callback is called when the error recovery driver tells us that

 * its OK to resume normal operation.

/*

 * Set the number of qsets based on the number of CPUs and the number of ports,

 * not to exceed the number of available qsets, assuming there are enough qsets

 * per port in HW.

 Just info, some other driver may have claimed the device. */

	/*

	 * The card is now ready to go.  If any errors occur during device

	 * registration we do not fail the whole card but rather proceed only

	 * with the ports we manage to register successfully.  However we must

	 * register at least one net device.

			/*

			 * Change the name we use for messages to the name of

			 * the first successfully registered interface.

 Driver's ready. Reflect it on LEDs */

 See what interrupts we'll be using */

/*

 * Copyright (c) 2003-2008 Chelsio, Inc. All rights reserved.

 *

 * This software is available to you under a choice of one of two

 * licenses.  You may choose to be licensed under the terms of the GNU

 * General Public License (GPL) Version 2, available from the file

 * COPYING in the main directory of this source tree, or the

 * OpenIB.org BSD license below:

 *

 *     Redistribution and use in source and binary forms, with or

 *     without modification, are permitted provided that the following

 *     conditions are met:

 *

 *      - Redistributions of source code must retain the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer.

 *

 *      - Redistributions in binary form must reproduce the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer in the documentation and/or other materials

 *        provided with the distribution.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS

 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN

 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN

 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

/*

 * Module locking notes:  There is a RW lock protecting the L2 table as a

 * whole plus a spinlock per L2T entry.  Entry lookups and allocations happen

 * under the protection of the table lock, individual entry changes happen

 * while holding that entry's spinlock.  The table lock nests outside the

 * entry locks.  Allocations of new entries take the table lock as writers so

 * no other lookups can happen while allocating new entries.  Entry updates

 * take the table lock as readers so multiple entries can be updated in

 * parallel.  An L2T entry can be dropped by decrementing its reference count

 * and therefore can happen in parallel with entry allocation but no entry

 * can change state or increment its ref count during allocation as both of

 * these perform lookups.

/*

 * Set up an L2T entry and send any packets waiting in the arp queue.  The

 * supplied skb is used for the CPL_L2T_WRITE_REQ.  Must be called with the

 * entry locked.

/*

 * Add a packet to the an L2T entry's queue of packets awaiting resolution.

 * Must be called with the entry's lock held.

 entry is stale, kick off revalidation */

 fast-path, send the packet on */

 ARP already completed */

		/*

		 * Only the first packet added to the arpq should kick off

		 * resolution.  However, because the alloc_skb below can fail,

		 * we allow each packet added to the arpq to retry resolution

		 * as a way of recovering from transient memory exhaustion.

		 * A better way would be to use a work request to retry L2T

		 * entries when there's no memory.

 we lost the race */

 entry is stale, kick off revalidation */

 fast-path, send the packet on */

 ARP already completed */

		/*

		 * Only the first packet added to the arpq should kick off

		 * resolution.  However, because the alloc_skb below can fail,

		 * we allow each packet added to the arpq to retry resolution

		 * as a way of recovering from transient memory exhaustion.

		 * A better way would be to use a work request to retry L2T

		 * entries when there's no memory.

/*

 * Allocate a free L2T entry.  Must be called with l2t_data.lock held.

 there's definitely a free entry */

	/*

	 * The entry we found may be an inactive entry that is

	 * presently in the hash table.  We need to remove it.

/*

 * Called when an L2T entry has no more users.  The entry is left in the hash

 * table since it is likely to be reused but we also bump nfree to indicate

 * that the entry can be reallocated for a different neighbor.  We also drop

 * the existing neighbor reference in case the neighbor is going away and is

 * waiting on our reference.

 *

 * Because entries can be reallocated to other neighbors once their ref count

 * drops to 0 we need to take the entry's lock to avoid races with a new

 * incarnation.

 hasn't been recycled */

/*

 * Update an L2T entry that was previously used for the same next hop as neigh.

 * Must be called with softirqs disabled.

 avoid race with t3_l2t_free */

 Need to allocate a new entry */

 avoid race with t3_l2t_free */

/*

 * Called when address resolution fails for an L2T entry to handle packets

 * on the arpq head.  If a packet specifies a failure handler it is invoked,

 * otherwise the packets is sent to the offload device.

 *

 * XXX: maybe we should abandon the latter behavior and just require a failure

 * handler.

/*

 * Called when the host's ARP layer makes a change to some entry that is

 * loaded into the HW L2 table.

 entry 0 is not used */

/*

 * Copyright (c) 2005-2008 Chelsio, Inc. All rights reserved.

 *

 * This software is available to you under a choice of one of two

 * licenses.  You may choose to be licensed under the terms of the GNU

 * General Public License (GPL) Version 2, available from the file

 * COPYING in the main directory of this source tree, or the

 * OpenIB.org BSD license below:

 *

 *     Redistribution and use in source and binary forms, with or

 *     without modification, are permitted provided that the following

 *     conditions are met:

 *

 *      - Redistributions of source code must retain the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer.

 *

 *      - Redistributions in binary form must reproduce the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer in the documentation and/or other materials

 *        provided with the distribution.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS

 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN

 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN

 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

/*

 * # of exact address filters.  The first one is used for the station address,

 * the rest are available for multicast addresses.

 flush */

 flush */

 Stop NIC traffic to reduce the number of TXTOGGLES */

 Ensure TX drains */

 flush */

 Store A_TP_TX_DROP_CFG_CH0 */

 Change DROP_CFG to 0xc0000011 */

 Check for xgm Rx fifo empty */

 Increased loop count to 1000 from 5 cover 1G and 100Mbps case */

 flush */

 flush */

 Restore the DROP_CFG */

 re-enable nic traffic */

  Set: re-enable NIC traffic */

/*

 * Set the exact match register 'idx' to recognize the given Ethernet address.

 Set one of the station's unicast MAC addresses. */

/*

 * Specify the number of exact address filters that should be reserved for

 * unicast addresses.  Caller should reload the unicast and multicast addresses

 * after calling this.

 flush */

 flush */

 Calculate the RX hash filter index of an Ethernet address */

	/*

	 * MAX_FRAME_SIZE inludes header + FCS, mtu doesn't.  The HW max

	 * packet size register includes header, but not FCS.

 drain RX FIFO */

	/*

	 * Adjust the PAUSE frame watermarks.  We always set the LWM, and the

	 * HWM only if flow-control is enabled.

 Adjust the TX FIFO threshold based on the MTU */

 need at least 8 */

 By default tx_xcnt is making progress */

 If tx_mcnt is progressing ignore tx_tcnt */

 flush */

 flush */

/*

 * This function is called periodically to accumulate the current values of the

 * RMON counters into the port statistics.  Since the packet counters are only

 * 32 bits they can overflow in ~286 secs at 10G, so the function should be

 * called more frequently than that.  The byte counters are 45-bit wide, they

 * would overflow in ~7.8 hours.

 This counts error frames in general (bad FCS, underrun, etc). */

 The next stat isn't clear-on-read. */

/*

 * Copyright (c) 2005-2008 Chelsio, Inc. All rights reserved.

 *

 * This software is available to you under a choice of one of two

 * licenses.  You may choose to be licensed under the terms of the GNU

 * General Public License (GPL) Version 2, available from the file

 * COPYING in the main directory of this source tree, or the

 * OpenIB.org BSD license below:

 *

 *     Redistribution and use in source and binary forms, with or

 *     without modification, are permitted provided that the following

 *     conditions are met:

 *

 *      - Redistributions of source code must retain the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer.

 *

 *      - Redistributions in binary form must reproduce the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer in the documentation and/or other materials

 *        provided with the distribution.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS

 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN

 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN

 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

/*

 * Page chunk size for FL0 buffers if FL0 is to be populated with page chunks.

 * It must be a divisor of PAGE_SIZE.  If set to 0 FL0 will use sk_buffs

 * directly.

/*

 * Max number of Rx buffers we replenish at a time.

/*

 * Period of the Tx buffer reclaim timer.  This timer does not need to run

 * frequently as Tx buffers are usually reclaimed by new Tx packets.

 WR size in bytes */

/*

 * Types of Tx queues in each queue set.  Order here matters, do not change.

 Values for sge_txq.flags */

 fetch engine is running */

 last packet rang the doorbell */

 SW state per Tx descriptor */

 set if last descriptor for packet */

 buffer index of first SGL entry in descriptor */

 first page fragment associated with descriptor */

 start flit of first SGL entry in descriptor */

 SW state per Rx descriptor */

 response queue descriptor */

/*

 * Holds unmapping information for Tx packets that need deferred unmapping.

 * This structure lives at skb->head and must be allocated by callers.

/*

 * Maps a number of flits to the number of Tx descriptors that can hold them.

 * The formula is

 *

 * desc = 1 + (flits - 2) / (WR_FLITS - 1).

 *

 * HW allows up to 4 descriptors to be combined into a WR.

/**

 *	refill_rspq - replenish an SGE response queue

 *	@adapter: the adapter

 *	@q: the response queue to replenish

 *	@credits: how many new responses to make available

 *

 *	Replenishes a response queue by making the supplied number of responses

 *	available to HW.

/**

 *	need_skb_unmap - does the platform need unmapping of sk_buffs?

 *

 *	Returns true if the platform needs sk_buff unmapping.  The compiler

 *	optimizes away unnecessary code if this returns true.

/**

 *	unmap_skb - unmap a packet main body and its page fragments

 *	@skb: the packet

 *	@q: the Tx queue containing Tx descriptors for the packet

 *	@cidx: index of Tx descriptor

 *	@pdev: the PCI device

 *

 *	Unmap the main body of an sk_buff and its page fragments, if any.

 *	Because of the fairly complicated structure of our SGLs and the desire

 *	to conserve space for metadata, the information necessary to unmap an

 *	sk_buff is spread across the sk_buff itself (buffer lengths), the HW Tx

 *	descriptors (the physical addresses of the various data buffers), and

 *	the SW descriptor state (assorted indices).  The send functions

 *	initialize the indices for the first packet descriptor so we can unmap

 *	the buffers held in the first Tx descriptor here, and we have enough

 *	information at this point to set the state for the next Tx descriptor.

 *

 *	Note that it is possible to clean up the first descriptor of a packet

 *	before the send routines have written the next descriptors, but this

 *	race does not cause any problem.  We just end up writing the unmapping

 *	info for the descriptor first.

 SGL continues into next Tx descriptor */

 sflit can be -1 */

/**

 *	free_tx_desc - reclaims Tx descriptors and their buffers

 *	@adapter: the adapter

 *	@q: the Tx queue to reclaim descriptors from

 *	@n: the number of descriptors to reclaim

 *

 *	Reclaims Tx descriptors from an SGE Tx queue and frees the associated

 *	Tx buffers.  Called with the Tx queue lock held.

 an SGL is present */

/**

 *	reclaim_completed_tx - reclaims completed Tx descriptors

 *	@adapter: the adapter

 *	@q: the Tx queue to reclaim completed descriptors from

 *	@chunk: maximum number of descriptors to reclaim

 *

 *	Reclaims Tx descriptors that the SGE has indicated it has processed,

 *	and frees the associated buffers if possible.  Called with the Tx

 *	queue's lock held.

/**

 *	should_restart_tx - are there enough resources to restart a Tx queue?

 *	@q: the Tx queue

 *

 *	Checks if there are enough descriptors to restart a suspended Tx queue.

/**

 *	free_rx_bufs - free the Rx buffers on an SGE free list

 *	@pdev: the PCI device associated with the adapter

 *	@q: the SGE free list to clean up

 *

 *	Release the buffers on an SGE free-buffer Rx queue.  HW fetching from

 *	this queue should be stopped before calling this function.

/**

 *	add_one_rx_buf - add a packet buffer to a free-buffer list

 *	@va:  buffer start VA

 *	@len: the buffer length

 *	@d: the HW Rx descriptor to write

 *	@sd: the SW Rx descriptor to write

 *	@gen: the generation bit value

 *	@pdev: the PCI device associated with the adapter

 *

 *	Add a buffer of the given length to the supplied HW and SW Rx

 *	descriptors.

/**

 *	refill_fl - refill an SGE free-buffer list

 *	@adap: the adapter

 *	@q: the free-list to refill

 *	@n: the number of new buffers to allocate

 *	@gfp: the gfp flags for allocating new buffers

 *

 *	(Re)populate an SGE free-buffer list with up to @n new packet buffers,

 *	allocated with the supplied gfp flags.  The caller must assure that

 *	@n does not exceed the queue's capacity.

/**

 *	recycle_rx_buf - recycle a receive buffer

 *	@adap: the adapter

 *	@q: the SGE free list

 *	@idx: index of buffer to recycle

 *

 *	Recycles the specified buffer on the given free list by adding it at

 *	the next available slot on the list.

 already big endian */

 likewise */

/**

 *	alloc_ring - allocate resources for an SGE descriptor ring

 *	@pdev: the PCI device

 *	@nelem: the number of descriptors

 *	@elem_size: the size of each descriptor

 *	@sw_size: the size of the SW state associated with each ring element

 *	@phys: the physical address of the allocated ring

 *	@metadata: address of the array holding the SW state for the ring

 *

 *	Allocates resources for an SGE descriptor ring, such as Tx queues,

 *	free buffer lists, or response queues.  Each SGE ring requires

 *	space for its HW descriptors plus, optionally, space for the SW state

 *	associated with each HW entry (the metadata).  The function returns

 *	three values: the virtual address for the HW ring (the return value

 *	of the function), the physical address of the HW ring, and the address

 *	of the SW ring.

/**

 *	t3_reset_qset - reset a sge qset

 *	@q: the queue set

 *

 *	Reset the qset structure.

 *	the NAPI structure is preserved in the event of

 *	the qset's reincarnation, for example during EEH recovery.

 for t3_stop_sge_timers() */

/**

 *	t3_free_qset - free the resources of an SGE queue set

 *	@adapter: the adapter owning the queue set

 *	@q: the queue set

 *

 *	Release the HW and SW resources associated with an SGE queue set, such

 *	as HW contexts, packet buffers, and descriptor rings.  Traffic to the

 *	queue set must be quiesced prior to calling this.

/**

 *	init_qset_cntxt - initialize an SGE queue set context info

 *	@qs: the queue set

 *	@id: the queue set id

 *

 *	Initializes the TIDs and context ids for the queues of a queue set.

/**

 *	sgl_len - calculates the size of an SGL of the given capacity

 *	@n: the number of SGL entries

 *

 *	Calculates the number of flits needed for a scatter/gather list that

 *	can hold the given number of entries.

 alternatively: 3 * (n / 2) + 2 * (n & 1) */

/**

 *	flits_to_desc - returns the num of Tx descriptors for the given flits

 *	@n: the number of flits

 *

 *	Calculates the number of Tx descriptors needed for the supplied number

 *	of flits.

/**

 *	get_packet - return the next ingress packet buffer from a free list

 *	@adap: the adapter that received the packet

 *	@fl: the SGE free list holding the packet

 *	@len: the packet length including any SGE padding

 *	@drop_thres: # of remaining buffers before we start dropping packets

 *

 *	Get the next packet from a free list and complete setup of the

 *	sk_buff.  If the packet is small we make a copy and recycle the

 *	original buffer, otherwise we use the original buffer itself.  If a

 *	positive drop threshold is supplied packets are dropped and their

 *	buffers recycled if (a) the number of remaining buffers is under the

 *	threshold and the packet is too big to copy, or (b) the packet should

 *	be copied but there is no memory for the copy.

/**

 *	get_packet_pg - return the next ingress packet buffer from a free list

 *	@adap: the adapter that received the packet

 *	@fl: the SGE free list holding the packet

 *	@q: the queue

 *	@len: the packet length including any SGE padding

 *	@drop_thres: # of remaining buffers before we start dropping packets

 *

 *	Get the next packet from a free list populated with page chunks.

 *	If the packet is small we make a copy and recycle the original buffer,

 *	otherwise we attach the original buffer as a page fragment to a fresh

 *	sk_buff.  If a positive drop threshold is supplied packets are dropped

 *	and their buffers recycled if (a) the number of remaining buffers is

 *	under the threshold and the packet is too big to copy, or (b) there's

 *	no system memory.

 *

 * 	Note: this function is similar to @get_packet but deals with Rx buffers

 * 	that are page chunks rather than sk_buffs.

	/*

	 * We do not refill FLs here, we let the caller do it to overlap a

	 * prefetch.

/**

 *	get_imm_packet - return the next ingress packet buffer from a response

 *	@resp: the response descriptor containing the packet data

 *

 *	Return a packet containing the immediate data of the given response.

/**

 *	calc_tx_descs - calculate the number of Tx descriptors for a packet

 *	@skb: the packet

 *

 * 	Returns the number of Tx descriptors needed for the given Ethernet

 * 	packet.  Ethernet packets require addition of WR and CPL headers.

/*	map_skb - map a packet main body and its page fragments

 *	@pdev: the PCI device

 *	@skb: the packet

 *	@addr: placeholder to save the mapped addresses

 *

 *	map the main body of an sk_buff and its page fragments, if any.

/**

 *	write_sgl - populate a scatter/gather list for a packet

 *	@skb: the packet

 *	@sgp: the SGL to populate

 *	@start: start address of skb main body data to include in the SGL

 *	@len: length of skb main body data to include in the SGL

 *	@addr: the list of the mapped addresses

 *

 *	Copies the scatter/gather list for the buffers that make up a packet

 *	and returns the SGL size in 8-byte words.  The caller must size the SGL

 *	appropriately.

/**

 *	check_ring_tx_db - check and potentially ring a Tx queue's doorbell

 *	@adap: the adapter

 *	@q: the Tx queue

 *

 *	Ring the doorbel if a Tx queue is asleep.  There is a natural race,

 *	where the HW is going to sleep just after we checked, however,

 *	then the interrupt handler will detect the outstanding TX packet

 *	and ring the doorbell for us.

 *

 *	When GTS is disabled we unconditionally ring the doorbell.

 write descriptors before telling HW */

/**

 *	write_wr_hdr_sgl - write a WR header and, optionally, SGL

 *	@ndesc: number of Tx descriptors spanned by the SGL

 *	@skb: the packet corresponding to the WR

 *	@d: first Tx descriptor to be written

 *	@pidx: index of above descriptors

 *	@q: the SGE Tx queue

 *	@sgl: the SGL

 *	@flits: number of flits to the start of the SGL in the first descriptor

 *	@sgl_flits: the SGL size in flits

 *	@gen: the Tx descriptor generation

 *	@wr_hi: top 32 bits of WR header based on WR type (big endian)

 *	@wr_lo: low 32 bits of WR header based on WR type (big endian)

 *

 *	Write a work request header and an associated SGL.  If the SGL is

 *	small enough to fit into one Tx descriptor it has already been written

 *	and we just need to write the WR header.  Otherwise we distribute the

 *	SGL across the number of descriptors it spans.

/**

 *	write_tx_pkt_wr - write a TX_PKT work request

 *	@adap: the adapter

 *	@skb: the packet to send

 *	@pi: the egress interface

 *	@pidx: index of the first Tx descriptor to write

 *	@gen: the generation value to use

 *	@q: the Tx queue

 *	@ndesc: number of descriptors the packet will occupy

 *	@compl: the value of the COMPL bit to use

 *	@addr: address

 *

 *	Generate a TX_PKT work request to send the supplied packet.

 SW calculates IP csum */

/**

 *	t3_eth_xmit - add a packet to the Ethernet Tx queue

 *	@skb: the packet

 *	@dev: the egress net device

 *

 *	Add a packet to an SGE Tx queue.  Runs with softirqs disabled.

	/*

	 * The chip min packet length is 9 octets but play safe and reject

	 * anything shorter than an Ethernet header.

 Check if ethernet packet can't be sent as immediate data */

 update port statistics */

	/*

	 * We do not use Tx completion interrupts to free DMAd Tx packets.

	 * This is good for performance but means that we rely on new Tx

	 * packets arriving to run the destructors of completed packets,

	 * which open up space in their sockets' send queues.  Sometimes

	 * we do not get such new packets causing Tx to stall.  A single

	 * UDP transmitter is a good example of this situation.  We have

	 * a clean up timer that periodically reclaims completed packets

	 * but it doesn't run often enough (nor do we want it to) to prevent

	 * lengthy stalls.  A solution to this problem is to run the

	 * destructor early, after the packet is queued but before it's DMAd.

	 * A cons is that we lie to socket memory accounting, but the amount

	 * of extra memory is reasonable (limited by the number of Tx

	 * descriptors), the packets do actually get freed quickly by new

	 * packets almost always, and for protocols like TCP that wait for

	 * acks to really free up the data the extra memory is even less.

	 * On the positive side we run the destructors on the sending CPU

	 * rather than on a potentially different completing CPU, usually a

	 * good thing.  We also run them without holding our Tx queue lock,

	 * unlike what reclaim_completed_tx() would otherwise do.

	 *

	 * Run the destructor before telling the DMA engine about the packet

	 * to make sure it doesn't complete and get freed prematurely.

/**

 *	write_imm - write a packet into a Tx descriptor as immediate data

 *	@d: the Tx descriptor to write

 *	@skb: the packet

 *	@len: the length of packet data to write as immediate data

 *	@gen: the generation bit value to write

 *

 *	Writes a packet as immediate data into a Tx descriptor.  The packet

 *	contains a work request at its beginning.  We must write the packet

 *	carefully so the SGE doesn't read it accidentally before it's written

 *	in its entirety.

/**

 *	check_desc_avail - check descriptor availability on a send queue

 *	@adap: the adapter

 *	@q: the send queue

 *	@skb: the packet needing the descriptors

 *	@ndesc: the number of Tx descriptors needed

 *	@qid: the Tx queue number in its queue set (TXQ_OFLD or TXQ_CTRL)

 *

 *	Checks if the requested number of Tx descriptors is available on an

 *	SGE send queue.  If the queue is already suspended or not enough

 *	descriptors are available the packet is queued for later transmission.

 *	Must be called with the Tx queue locked.

 *

 *	Returns 0 if enough descriptors are available, 1 if there aren't

 *	enough descriptors and the packet has been queued, and 2 if the caller

 *	needs to retry because there weren't enough descriptors at the

 *	beginning of the call but some freed up in the mean time.

/**

 *	reclaim_completed_tx_imm - reclaim completed control-queue Tx descs

 *	@q: the SGE control Tx queue

 *

 *	This is a variant of reclaim_completed_tx() that is used for Tx queues

 *	that send only immediate data (presently just the control queues) and

 *	thus do not have any sk_buffs to release.

/**

 *	ctrl_xmit - send a packet through an SGE control Tx queue

 *	@adap: the adapter

 *	@q: the control queue

 *	@skb: the packet

 *

 *	Send a packet through an SGE control Tx queue.  Packets sent through

 *	a control queue must fit entirely as immediate data in a single Tx

 *	descriptor and have no page fragments.

/**

 *	restart_ctrlq - restart a suspended control queue

 *	@w: pointer to the work associated with this handler

 *

 *	Resumes transmission on a suspended Tx control queue.

/*

 * Send a management message through control queue 0

/**

 *	deferred_unmap_destructor - unmap a packet when it is freed

 *	@skb: the packet

 *

 *	This is the packet destructor used for Tx packets that need to remain

 *	mapped until they are freed rather than until their Tx descriptors are

 *	freed.

/**

 *	write_ofld_wr - write an offload work request

 *	@adap: the adapter

 *	@skb: the packet to send

 *	@q: the Tx queue

 *	@pidx: index of the first Tx descriptor to write

 *	@gen: the generation value to use

 *	@ndesc: number of descriptors the packet will occupy

 *	@addr: the address

 *

 *	Write an offload work request to send the supplied packet.  The packet

 *	data already carry the work request with most fields populated.

 Only TX_DATA builds SGLs */

/**

 *	calc_tx_descs_ofld - calculate # of Tx descriptors for an offload packet

 *	@skb: the packet

 *

 * 	Returns the number of Tx descriptors needed for the given offload

 * 	packet.  These packets are already fully constructed.

 packet fits as immediate data */

 headers */

/**

 *	ofld_xmit - send a packet through an offload queue

 *	@adap: the adapter

 *	@q: the Tx offload queue

 *	@skb: the packet

 *

 *	Send an offload packet through an SGE offload queue.

 save for restart */

/**

 *	restart_offloadq - restart a suspended offload queue

 *	@w: pointer to the work associated with this handler

 *

 *	Resumes transmission on a suspended Tx offload queue.

/**

 *	queue_set - return the queue set a packet should use

 *	@skb: the packet

 *

 *	Maps a packet to the SGE queue set it should use.  The desired queue

 *	set is carried in bits 1-3 in the packet's priority.

/**

 *	is_ctrl_pkt - return whether an offload packet is a control packet

 *	@skb: the packet

 *

 *	Determines whether an offload packet should use an OFLD or a CTRL

 *	Tx queue.  This is indicated by bit 0 in the packet's priority.

/**

 *	t3_offload_tx - send an offload packet

 *	@tdev: the offload device to send to

 *	@skb: the packet

 *

 *	Sends an offload packet.  We use the packet priority to select the

 *	appropriate Tx queue as follows: bit 0 indicates whether the packet

 *	should be sent as regular or control, bits 1-3 select the queue set.

/**

 *	offload_enqueue - add an offload packet to an SGE offload receive queue

 *	@q: the SGE response queue

 *	@skb: the packet

 *

 *	Add a new offload packet to an SGE response queue's offload packet

 *	queue.  If the packet is the first on the queue it schedules the RX

 *	softirq to process the queue.

/**

 *	deliver_partial_bundle - deliver a (partial) bundle of Rx offload pkts

 *	@tdev: the offload device that will be receiving the packets

 *	@q: the SGE response queue that assembled the bundle

 *	@skbs: the partial bundle

 *	@n: the number of packets in the bundle

 *

 *	Delivers a (partial) bundle of Rx offload packets to an offload device.

/**

 *	ofld_poll - NAPI handler for offload packets in interrupt mode

 *	@napi: the network device doing the polling

 *	@budget: polling budget

 *

 *	The NAPI handler for offload packets when a response queue is serviced

 *	by the hard interrupt handler, i.e., when it's operating in non-polling

 *	mode.  Creates small packet batches and sends them through the offload

 *	receive handler.  Batches need to be of modest size as we do prefetches

 *	on the packets in each.

 splice remaining packets back onto Rx queue */

/**

 *	rx_offload - process a received offload packet

 *	@tdev: the offload device receiving the packet

 *	@rq: the response queue that received the packet

 *	@skb: the packet

 *	@rx_gather: a gather list of packets if we are building a bundle

 *	@gather_idx: index of the next available slot in the bundle

 *

 *	Process an ingress offload pakcet and add it to the offload ingress

 *	queue. 	Returns the index of the next available slot in the bundle.

/**

 *	restart_tx - check whether to restart suspended Tx queues

 *	@qs: the queue set to resume

 *

 *	Restarts suspended Tx queues of an SGE queue set if they have enough

 *	free resources to resume operation.

 The work can be quite lengthy so we use driver's own queue */

 The work can be quite lengthy so we use driver's own queue */

/**

 *	cxgb3_arp_process - process an ARP request probing a private IP address

 *	@pi: the port info

 *	@skb: the skbuff containing the ARP request

 *

 *	Check if the ARP request is probing the private IP address

 *	dedicated to iSCSI, generate an ARP reply if so.

/**

 *	rx_eth - process an ingress ethernet packet

 *	@adap: the adapter

 *	@rq: the response queue that received the packet

 *	@skb: the packet

 *	@pad: padding

 *	@lro: large receive offload

 *

 *	Process an ingress ethernet pakcet and deliver it to the stack.

 *	The padding is 2 if the packet was delivered in an Rx buffer and 0

 *	if it was immediate data in a response.

/**

 *	lro_add_page - add a page chunk to an LRO session

 *	@adap: the adapter

 *	@qs: the associated queue set

 *	@fl: the free list containing the page chunk to add

 *	@len: packet length

 *	@complete: Indicates the last fragment of a frame

 *

 *	Add a received packet contained in a page chunk to an existing LRO

 *	session.

/**

 *	handle_rsp_cntrl_info - handles control information in a response

 *	@qs: the queue set corresponding to the response

 *	@flags: the response control flags

 *

 *	Handles the control information of an SGE response, such as GTS

 *	indications and completion credits for the queue set's Tx queues.

 *	HW coalesces credits, we don't do any extra SW coalescing.

/**

 *	check_ring_db - check if we need to ring any doorbells

 *	@adap: the adapter

 *	@qs: the queue set whose Tx queues are to be examined

 *	@sleeping: indicates which Tx queue sent GTS

 *

 *	Checks if some of a queue set's Tx queues need to ring their doorbells

 *	to resume transmission after idling while they still have unprocessed

 *	descriptors.

/**

 *	is_new_response - check if a response is newly written

 *	@r: the response descriptor

 *	@q: the response queue

 *

 *	Returns true if a response descriptor contains a yet unprocessed

 *	response.

 How long to delay the next interrupt in case of memory shortage, in 0.1us. */

/**

 *	process_responses - process responses from an SGE response queue

 *	@adap: the adapter

 *	@qs: the queue set to which the response queue belongs

 *	@budget: how many responses can be processed in this round

 *

 *	Process responses from an SGE response queue up to the supplied budget.

 *	Responses include received packets as well as credits and other events

 *	for the queues that belong to the response queue's queue set.

 *	A negative budget is effectively unlimited.

 *

 *	Additionally choose the interrupt holdoff time for the next interrupt

 *	on this queue.  If the system is under memory shortage use a fairly

 *	long delay to help recovery.

 consume one credit since we tried */

 Preserve the RSS info in csum & priority */

 commit Tx queue .processed updates */

/**

 *	napi_rx_handler - the NAPI handler for Rx processing

 *	@napi: the napi instance

 *	@budget: how many packets we can process in this round

 *

 *	Handler for new data events when using NAPI.

		/*

		 * Because we don't atomically flush the following

		 * write it is possible that in very rare cases it can

		 * reach the device in a way that races with a new

		 * response being written plus an error interrupt

		 * causing the NAPI interrupt handler below to return

		 * unhandled status to the OS.  To protect against

		 * this would require flushing the write and doing

		 * both the write and the flush with interrupts off.

		 * Way too expensive and unjustifiable given the

		 * rarity of the race.

		 *

		 * The race cannot happen at all with MSI-X.

/*

 * Returns true if the device is already scheduled for polling.

/**

 *	process_pure_responses - process pure responses from a response queue

 *	@adap: the adapter

 *	@qs: the queue set owning the response queue

 *	@r: the first pure response to process

 *

 *	A simpler version of process_responses() that handles only pure (i.e.,

 *	non data-carrying) responses.  Such respones are too light-weight to

 *	justify calling a softirq under NAPI, so we handle them specially in

 *	the interrupt handler.  The function is called with a pointer to a

 *	response, which the caller must ensure is a valid pure response.

 *

 *	Returns 1 if it encounters a valid data-carrying response, 0 otherwise.

 commit Tx queue .processed updates */

/**

 *	handle_responses - decide what to do with new responses in NAPI mode

 *	@adap: the adapter

 *	@q: the response queue

 *

 *	This is used by the NAPI interrupt handlers to decide what to do with

 *	new SGE responses.  If there are no new responses it returns -1.  If

 *	there are new responses and they are pure (i.e., non-data carrying)

 *	it handles them straight in hard interrupt context as they are very

 *	cheap and don't deliver any packets.  Finally, if there are any data

 *	signaling responses it schedules the NAPI handler.  Returns 1 if it

 *	schedules NAPI, 0 if all new responses were pure.

 *

 *	The caller must ascertain NAPI is not already running.

/*

 * The MSI-X interrupt handler for an SGE response queue for the non-NAPI case

 * (i.e., response queue serviced in hard interrupt).

/*

 * The MSI-X interrupt handler for an SGE response queue for the NAPI case

 * (i.e., response queue serviced by NAPI polling).

/*

 * The non-NAPI MSI interrupt handler.  This needs to handle data events from

 * SGE response queues as well as error and other async events as they all use

 * the same MSI vector.  We use one SGE response queue per port in this mode

 * and protect all response queues with queue 0's lock.

/*

 * The MSI interrupt handler for the NAPI case (i.e., response queues serviced

 * by NAPI polling).  Handles data events from SGE response queues as well as

 * error and other async events as they all use the same MSI vector.  We use

 * one SGE response queue per port in this mode and protect all response

 * queues with queue 0's lock.

/*

 * A helper function that processes responses and issues GTS.

/*

 * The legacy INTx interrupt handler.  This needs to handle data events from

 * SGE response queues as well as error and other async events as they all use

 * the same interrupt pin.  We use one SGE response queue per port in this mode

 * and protect all response queues with queue 0's lock.

 flush */

/*

 * Interrupt handler for legacy INTx interrupts for T3B-based cards.

 * Handles data events from SGE response queues as well as error and other

 * async events as they all use the same interrupt pin.  We use one SGE

 * response queue per port in this mode and protect all response queues with

 * queue 0's lock.

 shared interrupt, most likely */

/*

 * NAPI interrupt handler for legacy INTx interrupts for T3B-based cards.

 * Handles data events from SGE response queues as well as error and other

 * async events as they all use the same interrupt pin.  We use one SGE

 * response queue per port in this mode and protect all response queues with

 * queue 0's lock.

 shared interrupt, most likely */

/**

 *	t3_intr_handler - select the top-level interrupt handler

 *	@adap: the adapter

 *	@polling: whether using NAPI to service response queues

 *

 *	Selects the top-level interrupt handler based on the type of interrupts

 *	(MSI-X, MSI, or legacy) and whether NAPI will be used to service the

 *	response queues.

/**

 *	t3_sge_err_intr_handler - SGE async event interrupt handler

 *	@adapter: the adapter

 *

 *	Interrupt handler for SGE asynchronous (non-data) events.

/**

 *	sge_timer_tx - perform periodic maintenance of an SGE qset

 *	@t: a timer list containing the SGE queue set to maintain

 *

 *	Runs periodically from a timer to perform maintenance of an SGE queue

 *	set.  It performs two tasks:

 *

 *	Cleans up any completed Tx descriptors that may still be pending.

 *	Normal descriptor cleanup happens when new packets are added to a Tx

 *	queue so this timer is relatively infrequent and does any cleanup only

 *	if the Tx queue has not seen any new packets in a while.  We make a

 *	best effort attempt to reclaim descriptors, in that we don't wait

 *	around if we cannot get a queue's lock (which most likely is because

 *	someone else is queueing new packets and so will also handle the clean

 *	up).  Since control queues use immediate data exclusively we don't

 *	bother cleaning them up here.

 *

/**

 *	sge_timer_rx - perform periodic maintenance of an SGE qset

 *	@t: the timer list containing the SGE queue set to maintain

 *

 *	a) Replenishes Rx queues that have run out due to memory shortage.

 *	Normally new Rx buffers are added when existing ones are consumed but

 *	when out of memory a queue can become empty.  We try to add only a few

 *	buffers here, the queue will be replenished fully as these new buffers

 *	are used up if memory shortage has subsided.

 *

 *	b) Return coalesced response queue credits in case a response queue is

 *	starved.

 *

/**

 *	t3_update_qset_coalesce - update coalescing settings for a queue set

 *	@qs: the SGE queue set

 *	@p: new queue set parameters

 *

 *	Update the coalescing settings for an SGE queue set.  Nothing is done

 *	if the queue set is not initialized yet.

 can't be 0 */

/**

 *	t3_sge_alloc_qset - initialize an SGE queue set

 *	@adapter: the adapter

 *	@id: the queue set id

 *	@nports: how many Ethernet ports will be using this queue set

 *	@irq_vec_idx: the IRQ vector index for response queue interrupts

 *	@p: configuration parameters for this queue set

 *	@ntxq: number of Tx queues for the queue set

 *	@dev: net device associated with this queue set

 *	@netdevq: net device TX queue associated with this queue set

 *

 *	Allocate resources and initialize an SGE queue set.  A queue set

 *	comprises a response queue, two Rx free-buffer queues, and up to 3

 *	Tx queues.  The Tx queues are assigned roles in the order Ethernet

 *	queue, offload queue, and control queue.

		/*

		 * The control queue always uses immediate data so does not

		 * need to keep track of any sk_buffs.

 FL threshold comparison uses < */

/**

 *      t3_start_sge_timers - start SGE timer call backs

 *      @adap: the adapter

 *

 *      Starts each SGE queue set's timer call back

/**

 *	t3_stop_sge_timers - stop SGE timer call backs

 *	@adap: the adapter

 *

 *	Stops each SGE queue set's timer call back

/**

 *	t3_free_sge_resources - free SGE resources

 *	@adap: the adapter

 *

 *	Frees resources used by the SGE queue sets.

/**

 *	t3_sge_start - enable SGE

 *	@adap: the adapter

 *

 *	Enables the SGE for DMAs.  This is the last step in starting packet

 *	transfers.

/**

 *	t3_sge_stop_dma - Disable SGE DMA engine operation

 *	@adap: the adapter

 *

 *	Can be invoked from interrupt context e.g.  error handler.

 *

 *	Note that this function cannot disable the restart of works as

 *	it cannot wait if called from interrupt context, however the

 *	works will have no effect since the doorbells are disabled. The

 *	driver will call tg3_sge_stop() later from process context, at

 *	which time the works will be stopped if they are still running.

/**

 *	t3_sge_stop - disable SGE operation completly

 *	@adap: the adapter

 *

 *	Called from process context. Disables the DMA engine and any

 *	pending queue restart works.

 workqueues aren't initialized otherwise */

/**

 *	t3_sge_init - initialize SGE

 *	@adap: the adapter

 *	@p: the SGE parameters

 *

 *	Performs SGE initialization needed every time after a chip reset.

 *	We do not initialize any of the queue sets here, instead the driver

 *	top-level must request those individually.  We also do not enable DMA

 *	here, that should be done after the queues have been set up.

/**

 *	t3_sge_prep - one-time SGE initialization

 *	@adap: the associated adapter

 *	@p: SGE parameters

 *

 *	Performs one-time initialization of SGE SW state.  Includes determining

 *	defaults for the assorted SGE parameters, which admins can change until

 *	they are used to initialize the SGE.

/*

 * Copyright (c) 2005-2008 Chelsio, Inc. All rights reserved.

 *

 * This software is available to you under a choice of one of two

 * licenses.  You may choose to be licensed under the terms of the GNU

 * General Public License (GPL) Version 2, available from the file

 * COPYING in the main directory of this source tree, or the

 * OpenIB.org BSD license below:

 *

 *     Redistribution and use in source and binary forms, with or

 *     without modification, are permitted provided that the following

 *     conditions are met:

 *

 *      - Redistributions of source code must retain the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer.

 *

 *      - Redistributions in binary form must reproduce the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer in the documentation and/or other materials

 *        provided with the distribution.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS

 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN

 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN

 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

 VSC8211 PHY specific registers. */

 master/slave resolution error */

 cable impairment */

 false carrier */

 AMS media change */

 Rx FIFO over/underflow */

 Tx FIFO over/underflow */

 descrambler lock-lost */

 symbol error */

 autoneg done */

 autoneg error */

 duplex change */

 link change */

 speed change */

 interrupt enable */

 Switch to Clause 37 view */

 High part of media mode select */

 PHY specific auxiliary control & status register fields */

/*

 * Reset the PHY.  This PHY completes reset immediately so we never wait.

 Clear PHY interrupts by reading the register. */

		/*

		 * BMSR_LSTATUS is latch-low, so if it is 0 we need to read it

		 * once more to get the current link state.

		/*

		 * BMSR_LSTATUS is latch-low, so if it is 0 we need to read it

		 * once more to get the current link state.

/*

 * Enable/disable auto MDI/MDI-X in forced link speed mode.

 UNUSED */

 PHY needs ~10ms to start responding to MDIO */

 copper interface, just need to configure the LEDs */

 delay after reset before next SMI */

/*

 * Copyright (c) 2005-2008 Chelsio, Inc. All rights reserved.

 *

 * This software is available to you under a choice of one of two

 * licenses.  You may choose to be licensed under the terms of the GNU

 * General Public License (GPL) Version 2, available from the file

 * COPYING in the main directory of this source tree, or the

 * OpenIB.org BSD license below:

 *

 *     Redistribution and use in source and binary forms, with or

 *     without modification, are permitted provided that the following

 *     conditions are met:

 *

 *      - Redistributions of source code must retain the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer.

 *

 *      - Redistributions in binary form must reproduce the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer in the documentation and/or other materials

 *        provided with the distribution.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS

 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN

 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN

 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

 Latch High (LH) */

 Store Clear (SC) */

 Read Only (RO) */

 Read Write (RW) */

 IN: i2c serial data */

 IN: Module Detect */

 IN: unassigned */

 OUT: unassigned */

 wired to link status LED */

 PHY module I2C device address */

 PHY transceiver type */

/*

 * Read an 8-bit word from a device attached to the PHY's i2c bus.

/*

 * Get link status for a 10GBASE-R device.

/*

 * Decode our module type.

 see SFF-8472 for below */

/*

 * Code to support the Aeluros/NetLogic 2005 10Gb PHY.

 module absent */

 reset wipes out interrupts, reenable them if they were on */

 modules have max 300 ms init time after hot plug */

 on unplug retain EDC */

/*

 * Setup EDC and other parameters for operation with an optical module.

 set CDR offset to 10 */

 adjust 10G RX bias current */

 end */

/*

 * Setup EDC and other parameters for operation with an TWINAX module.

 set uC to 40MHz */

 activate uC clock */

 set PC to start of SRAM and activate uC */

 set uC clock and activate it */

 activate uC */

/*

 * Return Module Type.

 module absent */

/*

 * Enable PHY interrupts.  We enable "Module Detection" interrupts (on any

 * state transition) and then generic Link Alarm Status Interrupt (LASI).

 output Module's Loss Of Signal (LOS) to LED */

 enable module detect status change interrupts */

 end */

 set up "link status" LED and enable module change interrupts */

/*

 * Disable PHY interrupts.  The mirror of the above ...

 reset "link status" LED to "off" */

 disable module detect status change interrupts */

 end */

 turn off "link status" LED and disable module change interrupts */

/*

 * Clear PHY interrupt state.

	/*

	 * The GPIO Interrupt register on the AEL2020 is a "Latching High"

	 * (LH) register which is cleared to the current state when it's read.

	 * Thus, we simply read the register and discard the result.

 Erratum #2: CDRLOL asserted, causing PMA link down status */

 force XAUI to send LF when RX_LOS is asserted */

 allow writes to transceiver module EEPROM on i2c bus */

 end */

/*

 * Reset the PHY and put it into a canonical operating state.

 grab current interrupt state */

 basic initialization for all module types */

 determine module type and perform appropriate initialization */

 reset wipes out interrupts, reenable them if they were on */

/*

 * Handle a PHY interrupt.

 modules have max 300 ms init time after hot plug */

 on unplug retain EDC */

/*

 * Get link status for a 10GBASE-X device.

	/*

	 * Some cards where the PHY is supposed to be at address 0 actually

	 * have it at 1.

/*

 * Copyright (c) 2003-2008 Chelsio, Inc. All rights reserved.

 *

 * This software is available to you under a choice of one of two

 * licenses.  You may choose to be licensed under the terms of the GNU

 * General Public License (GPL) Version 2, available from the file

 * COPYING in the main directory of this source tree, or the

 * OpenIB.org BSD license below:

 *

 *     Redistribution and use in source and binary forms, with or

 *     without modification, are permitted provided that the following

 *     conditions are met:

 *

 *      - Redistributions of source code must retain the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer.

 *

 *      - Redistributions in binary form must reproduce the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer in the documentation and/or other materials

 *        provided with the distribution.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS

 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN

 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN

 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

 DBGI command mode */

 IDT 75P52100 commands */

 IDT LAR register address and value for 144-bit mode (low 32 bits) */

 IDT SCR and SSR addresses (low 32 bits) */

 IDT GMR base address (low 32 bits) */

 IDT data and mask array base addresses (low 32 bits) */

 IDT 75N43102 commands */

 IDT 75N43102 SCR address (low 32 bits) */

 IDT 75N43102 GMR base addresses (low 32 bits) */

 IDT 75N43102 data and mask array base addresses (low 32 bits) */

/*

 * Issue a command to the TCAM and wait for its completion.  The address and

 * any data required by the command must have been setup by the caller.

/*

 * Write data to the TCAM register at address (0, 0, addr_lo) using the TCAM

 * command cmd.  The data to be written must have been set up by the caller.

 * Returns -1 on failure, 0 on success.

	/*

	 * We need the size of the TCAM data and mask arrays in terms of

	 * 72-bit entries.

 1 144-bit entry is 2 72-bit entries */

 Clear the data array */

 Initialize the mask array. */

 entering server or routing region */

	/*

	 * Use GMRs 14-15 for ELOOKUP, GMRs 12-13 for SYN lookups, and

	 * GMRs 8-9 for ACK- and AOPEN searches.

 Set DBGI command mode for IDT TCAM. */

 Set up LAR */

 Set up SSRs */

 Set up GMRs */

 Set up SCR */

	/*

	 * Use GMRs 24-25 for ELOOKUP, GMRs 20-21 for SYN lookups, and no mask

	 * for ACK- and AOPEN searches.

 Set DBGI command mode for IDT TCAM. */

 Set up GMRs */

 Set up SCR */

 Put MC5 in DBGI mode. */

 Put MC5 in M-Bus mode. */

/*

 * Initialization that requires the OS and protocol layers to already

 * be initialized goes here.

 Reset the TCAM */

 All the TCAM addresses we access have only the low 32 bits non 0 */

/*

 * MC5 interrupt handler

 in K 72-bit entries */

/*

 * Copyright (c) 2005-2008 Chelsio, Inc. All rights reserved.

 *

 * This software is available to you under a choice of one of two

 * licenses.  You may choose to be licensed under the terms of the GNU

 * General Public License (GPL) Version 2, available from the file

 * COPYING in the main directory of this source tree, or the

 * OpenIB.org BSD license below:

 *

 *     Redistribution and use in source and binary forms, with or

 *     without modification, are permitted provided that the following

 *     conditions are met:

 *

 *      - Redistributions of source code must retain the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer.

 *

 *      - Redistributions in binary form must reproduce the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer in the documentation and/or other materials

 *        provided with the distribution.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS

 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN

 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN

 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

 MDIO_DEV_PMA_PMD registers */

 MDIO_DEV_XGXS registers */

 MDIO_DEV_ANEG registers */

 MDIO_DEV_VEND1 registers */

	/*

	 * Ignore the caller specified wait time; always wait for the reset to

	 * complete. Can take up to 3s.

 Read (and reset) the latching version of the status */

 10G advertisement */

 1G advertisement */

 100M, pause advertisement */

 no can do */

	/*

	 * The PHY has been out of reset ever since the system powered up.  So

	 * we do a hard reset over here.

	/*

	 * Give it enough time to load the firmware and get ready for mdio.

 in 10ms increments */

 Allow prep_adapter to succeed when ffff is read */

 let prep_adapter succeed */

 Datasheet says 3s max but this has been observed */

 Firmware version check. */

	/*

	 * The PHY should start in really-low-power mode.  Prepare it for normal

	 * operations.

	/*

	 * Verify XAUI settings, but let prep succeed no matter what.

/*

 * Copyright (c) 2006-2008 Chelsio, Inc. All rights reserved.

 *

 * This software is available to you under a choice of one of two

 * licenses.  You may choose to be licensed under the terms of the GNU

 * General Public License (GPL) Version 2, available from the file

 * COPYING in the main directory of this source tree, or the

 * OpenIB.org BSD license below:

 *

 *     Redistribution and use in source and binary forms, with or

 *     without modification, are permitted provided that the following

 *     conditions are met:

 *

 *      - Redistributions of source code must retain the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer.

 *

 *      - Redistributions in binary form must reproduce the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer in the documentation and/or other materials

 *        provided with the distribution.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS

 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN

 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN

 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

/**

 *	cxgb3_register_client - register an offload client

 *	@client: the client

 *

 *	Add the client to the client list,

 *	and call backs the client for each activated offload device

/**

 *	cxgb3_unregister_client - unregister an offload client

 *	@client: the client

 *

 *	Remove the client to the client list,

 *	and call backs the client for each activated offload device.

/**

 *	cxgb3_add_clients - activate registered clients for an offload device

 *	@tdev: the offload device

 *

 *	Call backs all registered clients once a offload device is activated

/**

 *	cxgb3_remove_clients - deactivates registered clients

 *			       for an offload device

 *	@tdev: the offload device

 *

 *	Call backs all registered clients once a offload device is deactivated

		/*

		 * On tx, the iscsi pdu has to be <= tx page size and has to

		 * fit into the Tx PM FIFO.

 set MaxRxData to 16224 */

		/*

		 * on rx, the iscsi pdu has to be < rx page size and the

		 * the max rx data length programmed in TP

 program the ddp page sizes */

 Response queue used for RDMA events. */

 may be called in any context */

 1MB */

/*

 * Dummy handler for Rx offload packets in case we get an offload packet before

 * proper processing is setup.  This complains and drops the packet as it isn't

 * normal to get offload packets at this stage.

/*

 * Free an active-open TID.

/*

 * Free a server TID and return it to the free pool.

/*

 * Populate a TID_RELEASE WR.  The skb must be already propely sized.

 use ctx as a next pointer in the tid release list */

/*

 * Remove a tid from the TID table.  A client may defer processing its last

 * CPL message if it is locked at the time it arrives, and while the message

 * sits in the client's backlog the TID may be reused for another connection.

 * To handle this we atomically switch the TID association if it still points

 * to the original client context.

 Get the t3cdev associated with a net_device */

/*

 * Returns an sk_buff for a reply CPL message of size len.  If the input

 * sk_buff has no other users it is trimmed and reused, otherwise a new buffer

 * is allocated.  The input skb must be of size at least len.  Note that this

 * operation does not destroy the original skb data even if it decides to reuse

 * the buffer.

/*

 * That skb would better have come from process_responses() where we abuse

 * ->priority and ->csum to carry our data.  NB: if we get to per-arch

 * ->csum, the things might get really interesting here.

/*

 * Process a received packet with an unknown/unexpected CPL opcode.

/*

 * Handlers for each CPL opcode

/*

 * Add a new handler to the CPL dispatch table.  A NULL handler may be supplied

 * to unregister an existing handler.

/*

 * T3CDEV's receive method.

/*

 * Sends an sk_buff to a T3C driver after dealing with any active network taps.

 Add new L2T entry */

 Walk tid table and notify clients of dst change. */

/*

 * Allocate and initialize the TID tables.  Returns 0 on success.

	/*

	 * Setup the free lists for stid_tab and atid_tab.

 Register netevent handler once */

 SPDX-License-Identifier: GPL-2.0

 $Date: 2005/11/12 02:13:49 $ $RCSfile: my3126.c,v $ $Revision: 1.15 $ */

 Port Reset */

	/*

	 * This can be done through registers.  It is not required since

	 * a full chip reset is used.

		/* We have only enabled link change interrupts so it

		   must be that

 Populate elmer_gpo with the register value */

 To check the activity LED */

 Populate elmer_gpo with the register value */

 Turn on the LED. */

 Turn off the LED. */

 need to add flow control */

 Chip Reset */

 Now lets enable the Laser. Delay 100us */

/*****************************************************************************

 *                                                                           *

 * File: pm3393.c                                                            *

 * $Revision: 1.16 $                                                         *

 * $Date: 2005/05/14 00:59:32 $                                              *

 * Description:                                                              *

 *  PMC/SIERRA (pm3393) MAC-PHY functionality.                               *

 *  part of the Chelsio 10Gb Ethernet Driver.                                *

 *                                                                           *

 * This program is free software; you can redistribute it and/or modify      *

 * it under the terms of the GNU General Public License, version 2, as       *

 * published by the Free Software Foundation.                                *

 *                                                                           *

 * You should have received a copy of the GNU General Public License along   *

 * with this program; if not, see <http://www.gnu.org/licenses/>.            *

 *                                                                           *

 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED    *

 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF      *

 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.                     *

 *                                                                           *

 * http://www.chelsio.com                                                    *

 *                                                                           *

 * Copyright (c) 2003 - 2005 Chelsio Communications, Inc.                    *

 * All rights reserved.                                                      *

 *                                                                           *

 * Maintainers: maintainers@chelsio.com                                      *

 *                                                                           *

 * Authors: Dimitrios Michailidis   <dm@chelsio.com>                         *

 *          Tina Yang               <tainay@chelsio.com>                     *

 *          Felix Marti             <felix@chelsio.com>                      *

 *          Scott Bardone           <sbardone@chelsio.com>                   *

 *          Kurt Ottaway            <kottaway@chelsio.com>                   *

 *          Frank DiMambro          <frank@chelsio.com>                      *

 *                                                                           *

 * History:                                                                  *

 *                                                                           *

 Update statistics every 15 minutes */

 RMON registers */

 Port reset. */

/*

 * Enable interrupts for the PM3393

 *

 *	1. Enable PM3393 BLOCK interrupts.

 *	2. Enable PM3393 Master Interrupt bit(INTE)

 *	3. Enable ELMER's PM3393 bit.

 *	4. Enable Terminator external interrupt.

	/* PM3393 - Enabling all hardware block interrupts.

 Don't interrupt on statistics overflow, we are polling */

	/* PM3393 - Global interrupt enable

 TBD XXX Disable for now until we figure out why error interrupts keep asserting. */

SUNI1x10GEXP_BITMSK_TOP_INTE */ );

 TERMINATOR - PL_INTERUPTS_EXT */

 PM3393 - Enabling HW interrupt blocks. */

 PM3393 - Global interrupt enable */

 ELMER - External chip interrupts. */

 TERMINATOR - PL_INTERUPTS_EXT */

	/* DO NOT DISABLE TERMINATOR's EXTERNAL INTERRUPTS. ANOTHER CHIP

	 * COULD WANT THEM ENABLED. We disable PM3393 at the ELMER level.

	/* PM3393 - Clearing HW interrupt blocks. Note, this assumes

	 *          bit WCIMODE=0 for a clear-on-read.

	/* PM3393 - Global interrupt status

	/* ELMER - External chip interrupts.

	/* TERMINATOR - PL_INTERUPTS_EXT

 Interrupt handler */

 Read the master interrupt status register. */

 TBD XXX Lets just clear everything for now */

 Clear port statistics */

	/*

	 * XXX This should be done by the PHY and preferably not at all.

	 * The PHY doesn't give us link status indication on its own so have

	 * the link management code query it instead.

	/*

	 * The disable is graceful. Give the PM3393 time.  Can't wait very

	 * long here, we may be holding locks.

 Disable Rx/Tx MAC before configuring it. */

 Disable MAC RX before reconfiguring it */

 Promiscuous mode. */

 Accept all multicast. */

 Accept one or more multicast(s). */

 bit[23:28] */

 Snap the counters */

 Counter rollover, clear on read */

 Rx stats */

 Tx stats */

	/*

	 * MAC addr: 00:07:43:00:13:09

	 *

	 * ma[5] = 0x09

	 * ma[4] = 0x13

	 * ma[3] = 0x00

	 * ma[2] = 0x43

	 * ma[1] = 0x07

	 * ma[0] = 0x00

	 *

	 * The PM3393 requires byte swapping and reverse order entry

	 * when programming MAC addresses:

	 *

	 * low_bits[15:0]    = ma[1]:ma[0]

	 * mid_bits[31:16]   = ma[3]:ma[2]

	 * high_bits[47:32]  = ma[5]:ma[4]

 Store local copy */

 Disable Rx/Tx MAC before configuring it. */

 Set RXXG Station Address */

 Set TXXG Station Address */

	/* Setup Exact Match Filter 1 with our MAC address

	 *

	 * Must disable exact match filter before configuring it.

 PL4IO Enable */

 PL4IO Calendar Repetitions */

 EFLX Enable */

 EFLX Channel Deprovision */

 EFLX Low Limit */

 EFLX High Limit */

 EFLX Almost Full */

 EFLX Almost Empty */

 EFLX Cut Through Threshold */

 EFLX Indirect Register Update */

 EFLX Channel Provision */

 EFLX Undocumented */

 EFLX Undocumented */

 EFLX enable overflow interrupt The other bit are undocumented */

 EFLX Undocumented */

 IFLX Configuration - enable */

 IFLX Channel Deprovision */

 IFLX Low Limit */

 IFLX High Limit */

 IFLX Almost Full Limit */

 IFLX Almost Empty Limit */

 IFLX Indirect Register Update */

 IFLX Channel Provision */

 IFLX Undocumented */

 IFLX Undocumented */

 IFLX Enable overflow interrupt.  The other bit are undocumented */

 PL4MOS Undocumented */

 PL4MOS Undocumented */

 PL4MOS Starving Burst Size */

 PL4MOS Hungry Burst Size */

 PL4MOS Transfer Size */

 PL4MOS Disable */

 PL4ODP Training Repeat and SOP rule */

 PL4ODP MAX_T setting */

 PL4IDU Enable data forward, port state machine. Set ALLOW_NON_ZERO_OLB */

 PL4IDU Enable Dip4 check error interrupts */

 # TXXG Config */

 For T1 use timer based Mac flow control. */

 # RXXG Config */

 # RXXG Cut Through */

 # Disable promiscuous mode */

	/* Setup Exact Match Filter 0 to allow broadcast packets.

 # Disable Match Enable bit */

 # low addr */

 # mid addr */

 # high addr */

 # Enable Match Enable bit */

 # NO SOP/ PAD_EN setup */

 # RXEQB disabled */

 # No Preemphasis */

	/* The following steps are required to properly reset

	 * the PM3393. This information is provided in the

	 * PM3393 datasheet (Issue 2: November 2002)

	 * section 13.1 -- Device Reset.

	 *

	 * The PM3393 has three types of components that are

	 * individually reset:

	 *

	 * DRESETB      - Digital circuitry

	 * PL4_ARESETB  - PL4 analog circuitry

	 * XAUI_ARESETB - XAUI bus analog circuitry

	 *

	 * Steps to reset PM3393 using RSTB pin:

	 *

	 * 1. Assert RSTB pin low ( write 0 )

	 * 2. Wait at least 1ms to initiate a complete initialization of device.

	 * 3. Wait until all external clocks and REFSEL are stable.

	 * 4. Wait minimum of 1ms. (after external clocks and REFEL are stable)

	 * 5. De-assert RSTB ( write 1 )

	 * 6. Wait until internal timers to expires after ~14ms.

	 *    - Allows analog clock synthesizer(PL4CSU) to stabilize to

	 *      selected reference frequency before allowing the digital

	 *      portion of the device to operate.

	 * 7. Wait at least 200us for XAUI interface to stabilize.

	 * 8. Verify the PM3393 came out of reset successfully.

	 *    Set successful reset flag if everything worked else try again

	 *    a few more times.

 1 */

 2 */

 3 */

 4 */

1 extra ms for safety */ );

 5 */

 6 */

1 extra ms for safety */ );

 7 */

 8 */

 Has PL4 analog block come out of reset correctly? */

		/* TBD XXX SUNI1x10GEXP_BITMSK_TOP_PL4_IS_DOOL gets locked later in the init sequence

 Have all PL4 block clocks locked? */

| SUNI1x10GEXP_BITMSK_TOP_PL4_IS_DOOL */  |

		/* ??? If this fails, might be able to software reset the XAUI part

 Has the XAUI MABC PLL circuitry stablized? */

/*****************************************************************************

 *                                                                           *

 * File: sge.c                                                               *

 * $Revision: 1.26 $                                                         *

 * $Date: 2005/06/21 18:29:48 $                                              *

 * Description:                                                              *

 *  DMA engine.                                                              *

 *  part of the Chelsio 10Gb Ethernet Driver.                                *

 *                                                                           *

 * This program is free software; you can redistribute it and/or modify      *

 * it under the terms of the GNU General Public License, version 2, as       *

 * published by the Free Software Foundation.                                *

 *                                                                           *

 * You should have received a copy of the GNU General Public License along   *

 * with this program; if not, see <http://www.gnu.org/licenses/>.            *

 *                                                                           *

 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED    *

 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF      *

 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.                     *

 *                                                                           *

 * http://www.chelsio.com                                                    *

 *                                                                           *

 * Copyright (c) 2003 - 2005 Chelsio Communications, Inc.                    *

 * All rights reserved.                                                      *

 *                                                                           *

 * Maintainers: maintainers@chelsio.com                                      *

 *                                                                           *

 * Authors: Dimitrios Michailidis   <dm@chelsio.com>                         *

 *          Tina Yang               <tainay@chelsio.com>                     *

 *          Felix Marti             <felix@chelsio.com>                      *

 *          Scott Bardone           <sbardone@chelsio.com>                   *

 *          Kurt Ottaway            <kottaway@chelsio.com>                   *

 *          Frank DiMambro          <frank@chelsio.com>                      *

 *                                                                           *

 * History:                                                                  *

 *                                                                           *

 This belongs in if_ether.h */

/*

 * Period of the TX buffer reclaim timer.  This timer does not need to run

 * frequently as TX buffers are usually reclaimed by new TX packets.

/*

 * Command queue, receive buffer list, and response queue descriptors.

/*

 * SW Context Command and Freelist Queue Descriptors

/*

 * SW command, freelist and response rings

 HW DMA fetch status */

 # of in-use command descriptors */

 # of descriptors */

 total # of descs HW has processed */

 total # of descs SW has reclaimed */

 SW TX queue suspend threshold */

 producer index (SW) */

 consumer index (HW) */

 current generation (=valid) bit */

 is next entry start of packet? */

 HW command descriptor Q */

 SW command context descriptor Q */

 DMA addr HW command descriptor Q */

 Lock to protect cmdQ enqueuing */

 # of available RX buffers */

 free list capacity */

 producer index (SW) */

 consumer index (HW) */

 Buffer size on this free list */

 DMA offset to align IP headers */

 skb recycle q to use */

 current generation (=valid) bit */

 HW freelist descriptor Q */

 SW freelist context descriptor Q */

 DMA addr HW freelist descriptor Q */

 credits to be returned to SGE */

 # of response Q descriptors */

 consumer index (SW) */

 current generation(=valid) bit */

 HW response descriptor Q */

 DMA addr HW response descriptor Q */

 Bit flags for cmdQ.status */

 fetch engine is running */

 last packet rung the doorbell */

 T204 TX SW scheduler */

 Per T204 TX port */

 available bits - quota */

 drain rate */

 drain rate, mbps */

 mtu size */

 pending skbs */

 Per T204 device */

 last time quotas were computed */

 max bits to be sent to any port */

 port index (round robin ports) */

 num skbs in per port queues */

 tasklet used to run scheduler */

/*

 * Main SGE data structure

 *

 * Interrupts are handled by a single CPU and it is likely that on a MP system

 * the application is migrated to another CPU. In that scenario, we try to

 * separate the RX(in irq context) and TX state in order to decrease memory

 * contention.

 adapter backpointer */

 netdevice backpointer */

 buffer free lists */

 response Q */

 bitmap of suspended Tx queues */

 RX padding for L2 packets */

 jumbo freelist Q index */

 no-resource interrupt timer */

 non-adaptive interrupt timer */

 reclaims TX buffers */

 shadow value of sge control reg */

/*

 * stop tasklet and free all pending skb's

/*

 * t1_sched_update_parms() is called when the MTU or link speed changes. It

 * re-computes scheduler parameters to scope with the change.

/*

 * t1_sched_max_avail_bytes() tells the scheduler the maximum amount of

 * data that can be pushed per port.

/*

 * t1_sched_set_drain_bits_per_us() tells the scheduler at which rate a port

 * is draining.

  0  */

/*

 * tx_sched_init() allocates resources and does basic initialization.

/*

 * sched_update_avail() computes the delta since the last time it was called

 * and updates the per port quota (number of bits that can be sent to the any

 * port).

/*

 * sched_skb() is called from two different places. In the tx path, any

 * packet generating load on an output port will call sched_skb()

 * (skb != NULL). In addition, sched_skb() is called from the irq/soft irq

 * context (skb == NULL).

 * The scheduler only returns a skb (which will then be sent) if the

 * length of the skb is <= the current quota of the output port.

	/* If there are more pending skbs, we use the hardware to schedule us

	 * again.

/*

 * PIO to indicate that memory mapped Q contains valid descriptor(s).

/*

 * Frees all RX buffers on the freelist Q. The caller must make sure that

 * the SGE is turned off before calling this function.

/*

 * Free RX free list and response queue resources.

/*

 * Allocates basic RX resources, consisting of memory mapped freelist Qs and a

 * response queue.

	/*

	 * Calculate the buffer sizes for the two free lists.  FL0 accommodates

	 * regular sized Ethernet frames, FL1 is sized not to exceed 16K,

	 * including all the sk_buff overhead.

	 *

	 * Note: For T2 FL0 and FL1 are reversed.

	/*

	 * Setup which skb recycle Q should be used when recycling buffers from

	 * each free list.

/*

 * Reclaims n TX descriptors and frees the buffers associated with them.

/*

 * Free TX resources.

 *

 * Assumes that SGE is stopped and all interrupts are disabled.

/*

 * Allocates basic TX resources, consisting of memory mapped command Qs.

	/*

	 * CommandQ 0 handles Ethernet and TOE packets, while queue 1 is TOE

	 * only.  For queue 0 set the stop threshold so we can handle one more

	 * packet from each port, plus reserve an additional 24 entries for

	 * Ethernet packets only.  Queue 1 never suspends nor do we reserve

	 * space for Ethernet packets.

/*

 * Enable/disable VLAN acceleration.

 flush */

/*

 * Programs the various SGE registers. However, the engine is not yet enabled,

 * but sge->sge_control is setup and ready to go.

 The threshold comparison uses <. */

 Initialize no-resource timer */

/*

 * Return the payload capacity of the jumbo free-list buffers.

/*

 * Frees all SGE related resources and the sge structure itself

/*

 * Allocates new RX buffers on the freelist Q (and tracks them on the freelist

 * context Q) until the Q is full or alloc_skb fails.

 *

 * It is possible that the generation bits already match, indicating that the

 * buffer is already valid and nothing needs to be done. This happens when we

 * copied a received buffer into a new sk_buff during the interrupt processing.

 *

 * If the SGE doesn't automatically align packets properly (!sge->rx_pkt_pad),

 * we specify a RX_OFFSET in order to make sure that the IP header is 4B

 * aligned.

/*

 * Calls refill_free_list for both free lists. If we cannot fill at least 1/4

 * of both rings, we go into 'few interrupt mode' in order to give the system

 * time to free up resources.

 Clear the F_FL_EXHAUSTED interrupts for now */

 We reenable the Qs to force a freelist GTS interrupt later */

/*

 * Disable SGE Interrupts

/*

 * Enable SGE interrupts.

/*

 * Clear SGE interrupts.

/*

 * SGE 'Error' interrupt handler

/**

 *	recycle_fl_buf - recycle a free list buffer

 *	@fl: the free list

 *	@idx: index of buffer to recycle

 *

 *	Recycles the specified buffer on the given free list by adding it at

 *	the next available slot on the list.

/**

 *	get_packet - return the next ingress packet buffer

 *	@adapter: the adapter that received the packet

 *	@fl: the SGE free list holding the packet

 *	@len: the actual packet length, excluding any SGE padding

 *

 *	Get the next packet from a free list and complete setup of the

 *	sk_buff.  If the packet is small we make a copy and recycle the

 *	original buffer, otherwise we use the original buffer itself.  If a

 *	positive drop threshold is supplied packets are dropped and their

 *	buffers recycled if (a) the number of remaining buffers is under the

 *	threshold and the packet is too big to copy, or (b) the packet should

 *	be copied but there is no memory for the copy.

/**

 *	unexpected_offload - handle an unexpected offload packet

 *	@adapter: the adapter

 *	@fl: the free list that received the packet

 *

 *	Called when we receive an unexpected offload packet (e.g., the TOE

 *	function is disabled or the card is a NIC).  Prints a message and

 *	recycles the buffer.

/*

 * T1/T2 SGE limits the maximum DMA size per TX descriptor to

 * SGE_TX_DESC_MAX_PLEN (16KB). If the PAGE_SIZE is larger than 16KB, the

 * stack might send more than SGE_TX_DESC_MAX_PLEN in a contiguous manner.

 * Note that the *_large_page_tx_descs stuff will be optimized out when

 * PAGE_SIZE <= SGE_TX_DESC_MAX_PLEN.

 *

 * compute_large_page_descs() computes how many additional descriptors are

 * required to break down the stack's request.

/*

 * Write a cmdQ entry.

 *

 * Since this function writes the 'flags' field, it must not be used to

 * write the first cmdQ entry.

/*

 * See comment for previous function.

 *

 * write_tx_descs_large_page() writes additional SGE tx descriptors if

 * *desc_len exceeds HW's capability.

/*

 * Write the command descriptors to transmit the given skb starting at

 * descriptor pidx with the given generation.

/*

 * Clean up completed Tx buffers.

/*

 * Called from tasklet. Checks the scheduler for any

 * pending skbs that can be sent.

/**

 *	sge_rx - process an ingress ethernet packet

 *	@sge: the sge structure

 *	@fl: the free list that contains the packet buffer

 *	@len: the packet length

 *

 *	Process an ingress ethernet pakcet and deliver it to the stack.

/*

 * Returns true if a command queue has enough available descriptors that

 * we can resume Tx operation after temporarily disabling its packet queue.

/*

 * Called when sufficient space has become available in the SGE command queues

 * after the Tx packet schedulers have been suspended to restart the Tx path.

/*

 * update_tx_info is called from the interrupt handler/NAPI to return cmdQ0

 * information.

/*

 * Process SGE responses, up to the supplied budget.  Returns the number of

 * responses processed.  A negative budget is effectively unlimited.

		/* We batch updates to the TX side to avoid cacheline

		 * ping-pong of TX state information on MP where the sender

		 * might run on a different CPU than this function...

			/*

			 * Note: this depends on each packet consuming a

			 * single free-list buffer; cf. the BUG above.

/*

 * A simpler version of process_responses() that handles only pure (i.e.,

 * non data-carrying) responses.  Such respones are too light-weight to justify

 * calling a softirq when using NAPI, so we handle them specially in hard

 * interrupt context.  The function is called with a pointer to a response,

 * which the caller must ensure is a valid pure response.  Returns 1 if it

 * encounters a valid data-carrying response, 0 otherwise.

/*

 * Handler for new data events when using NAPI.  This does not need any locking

 * or protection from interrupts as data interrupts are off at this point and

 * other adapter interrupts do not interfere.

 This error is fatal, interrupts remain off */

 no data, no NAPI needed */

 undo schedule_prep */

/*

 * Enqueues the sk_buff onto the cmdQ[qid] and has hardware fetch it.

 *

 * The code figures out how many entries the sk_buff will require in the

 * cmdQ and updates the cmdQ data structure with the state once the enqueue

 * has complete. Then, it doesn't access the global structure anymore, but

 * uses the corresponding fields on the stack. In conjunction with a spinlock

 * around that code, we can make the function reentrant without holding the

 * lock when we actually enqueue (which might be expensive, especially on

 * architectures with IO MMUs).

 *

 * This runs with softirqs disabled.

 Ethernet packet */

	/* T204 cmdQ0 skbs that are destined for a certain port have to go

	 * through the scheduler.

		/* Note that the scheduler might return a different skb than

		 * the one passed in.

	/*

	 * We always ring the doorbell for cmdQ1.  For cmdQ0, we only ring

	 * the doorbell if the Q is asleep. There is a natural race, where

	 * the hardware is going to sleep just after we checked, however,

	 * then the interrupt handler will detect the outstanding TX packet

	 * and ring the doorbell for us.

/*

 *	eth_hdr_len - return the length of an Ethernet header

 *	@data: pointer to the start of the Ethernet header

 *

 *	Returns the length of an Ethernet header, including optional VLAN tag.

/*

 * Adds the CPL header to the sk_buff and passes it to t1_sge_tx.

	/*

	 * We are using a non-standard hard_header_len.

	 * Allocate more header room in the rare cases it is not big enough.

		/*

		 * Packets shorter than ETH_HLEN can break the MAC, drop them

		 * early.  Also, we may get oversized packets because some

		 * parts of the kernel don't handle our unusual hard_header_len

		 * right, drop those too.

		/* Hmmm, assuming to catch the gratious arp... and we'll use

		 * it to flush out stuck espi packets...

				/* We want to re-use this skb later. We

				 * simply bump the reference count and it

				 * will not be freed...

 SW calculates IP csum */

 the length field isn't used so don't bother setting it */

	/* If transmit busy, and we reallocated skb's due to headroom limit,

	 * then silently discard to avoid leak.

/*

 * Callback for the Tx buffer reclaim timer.  Runs with softirqs disabled.

 flush pending credits */

/*

 * Propagate changes of the SGE coalescing parameters to the HW.

/*

 * Allocates both RX and TX resources and configures the SGE. However,

 * the hardware is not enabled yet.

	/*

	 * Now that we have sized the free lists calculate the payload

	 * capacity of the large buffers.  Other parts of the driver use

	 * this to set the max offload coalescing size so that RX packets

	 * do not overflow our large buffers.

/*

 * Disables the DMA engine.

 flush */

/*

 * Enables the DMA engine.

 flush */

/*

 * Callback for the T2 ESPI 'stuck packet feature' workaorund

			/* bump the reference count to avoid freeing of

			 * the skb once the DMA has completed.

	                /* bump the reference count to avoid freeing of the

	                 * skb once the DMA has completed.

/*

 * Creates a t1_sge structure and returns suggested resource parameters.

 for T204, every 10ms */

/*****************************************************************************

 *                                                                           *

 * File: cxgb2.c                                                             *

 * $Revision: 1.25 $                                                         *

 * $Date: 2005/06/22 00:43:25 $                                              *

 * Description:                                                              *

 *  Chelsio 10Gb Ethernet Driver.                                            *

 *                                                                           *

 * This program is free software; you can redistribute it and/or modify      *

 * it under the terms of the GNU General Public License, version 2, as       *

 * published by the Free Software Foundation.                                *

 *                                                                           *

 * You should have received a copy of the GNU General Public License along   *

 * with this program; if not, see <http://www.gnu.org/licenses/>.            *

 *                                                                           *

 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED    *

 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF      *

 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.                     *

 *                                                                           *

 * http://www.chelsio.com                                                    *

 *                                                                           *

 * Copyright (c) 2003 - 2005 Chelsio Communications, Inc.                    *

 * All rights reserved.                                                      *

 *                                                                           *

 * Maintainers: maintainers@chelsio.com                                      *

 *                                                                           *

 * Authors: Dimitrios Michailidis   <dm@chelsio.com>                         *

 *          Tina Yang               <tainay@chelsio.com>                     *

 *          Felix Marti             <felix@chelsio.com>                      *

 *          Scott Bardone           <sbardone@chelsio.com>                   *

 *          Kurt Ottaway            <kottaway@chelsio.com>                   *

 *          Frank DiMambro          <frank@chelsio.com>                      *

 *                                                                           *

 * History:                                                                  *

 *                                                                           *

/*

 * The EEPROM is actually bigger but only the first few bytes are used so we

 * only report those.

 T1 cards powersave mode */

 HW default is powersave mode. */

/*

 * Setup MAC to receive the types of packets we want.

 multi-ports: inform toe */

 for TSO only */

/*

 * Things to do upon first use of a card.

 * This must run with the rtnl lock held.

/*

 * Release resources when all the ports have been stopped.

 Stop statistics accumulation. */

 sync with update task */

 Do a full update of the MAC stats */

 detailed rx_errors */

 detailed tx_errors */

 Port stats */

 Interrupt stats */

	/*

	 * Version scheme: bits 0..9: chip version, bits 10..15: chip revision

 can't change speed/duplex */

	/*

	 * Since there is no support for separate rx/tx vlan accel

	 * enable/disable make sure tx flag is always in same state as rx.

/*

 * Periodic accumulation of MAC statistics.  This is used only if the MAC

 * does not have any other way to prevent stats counter overflow.

 Schedule the next statistics update if any port is active. */

 so we don't leak it */

 Can't handle this chip rev */

 T204: disable TSO */

	/*

	 * The card is now ready to go.  If any errors occur during device

	 * registration we do not fail the whole card but rather proceed only

	 * with the ports we manage to register successfully.  However we must

	 * register at least one net device.

			/*

			 * Change the name we use for messages to the name of

			 * the first successfully registered interface.

	/*

	 * Set the T1B ASIC and memory clocks.

 HW default is powersave mode. */

 Set SCLOCK low */

 Write SCLOCK high */

 Can't re-clock this chip. */

 show current mode. */

 ASIC already running in mode. */

 overclock */

 underclock */

 Don't interrupt this serial stream! */

 Initialize for ASIC core */

 Serial program the ASIC clock synthesizer */

 Finish ASIC core */

 Initialize for memory */

 Serial program the memory clock synthesizer */

 Finish memory */

 SPDX-License-Identifier: GPL-2.0

 $Date: 2006/04/28 19:20:06 $ $RCSfile: vsc7326.c,v $ $Revision: 1.19 $ */

 Driver for Vitesse VSC7326 (Schaumburg) MAC */

 Update fast changing statistics every 15 seconds */

 30 minutes for full statistics update */

/* The egress WM value 0x01a01fff should be used only when the

 * interface is down (MAC port disabled). This is a workaround

 * for disabling the T2/MAC flow-control. When the interface is

 * enabled, the WM value should be set to 0x014a03F0.

	/* pr_err("rd: block: 0x%x  sublock: 0x%x  reg: 0x%x  data: 0x%x\n",

		((addr&0xe000)>>13), ((addr&0x1e00)>>9),

	/* pr_err("wr: block: 0x%x  sublock: 0x%x  reg: 0x%x  data: 0x%x\n",

		((addr&0xe000)>>13), ((addr&0x1e00)>>9),

 Hard reset the MAC.  This wipes out *all* configuration. */

 Enable mac MAC itself */

 Turn off the red LED */

 Port 0 */

 FIFO setup */

 Port config */

 Port 1 */

 FIFO setup */

 Port config */

 Port 2 */

 FIFO setup */

 Port config */

 Port 3 */

 FIFO setup */

 Port config */

run bist*/

check bist*/

enable mem*/

 Expect MAC address to be in network byte order. */

 This is intended to reset a port, not the whole MAC */

 max_len includes header and FCS */

 save tx/rx enables */

 full duplex */

 GigE */

 SPEED_10 */

 reset */

 SPEED_10 */

 100 or 10 */

 SPEED_100 or 10 */

 IFG1 */

 IFG2 */

 VLAN */

 RX/TX EN */

 xon/xoff */

 Write the correct WM value when the port is enabled. */

 Reset the port, this also writes the correct WM value */

 Clear stats */

 Clear software counters */

 Rx stats */

 Tx stats (skip collision stats as we are full-duplex only) */

/*

 * This function is called periodically to accumulate the current values of the

 * RMON counters into the port statistics.  Since the counters are only 32 bits

 * some of them can overflow in less than a minute at GigE speeds, so this

 * function should be called every 30 seconds or so.

 *

 * To cut down on reading costs we update only the octet counters at each tick

 * and do a full update at major ticks, which can be every 30 minutes or more.

/*****************************************************************************

 *                                                                           *

 * File: espi.c                                                              *

 * $Revision: 1.14 $                                                         *

 * $Date: 2005/05/14 00:59:32 $                                              *

 * Description:                                                              *

 *  Ethernet SPI functionality.                                              *

 *  part of the Chelsio 10Gb Ethernet Driver.                                *

 *                                                                           *

 * This program is free software; you can redistribute it and/or modify      *

 * it under the terms of the GNU General Public License, version 2, as       *

 * published by the Free Software Foundation.                                *

 *                                                                           *

 * You should have received a copy of the GNU General Public License along   *

 * with this program; if not, see <http://www.gnu.org/licenses/>.            *

 *                                                                           *

 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED    *

 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF      *

 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.                     *

 *                                                                           *

 * http://www.chelsio.com                                                    *

 *                                                                           *

 * Copyright (c) 2003 - 2005 Chelsio Communications, Inc.                    *

 * All rights reserved.                                                      *

 *                                                                           *

 * Maintainers: maintainers@chelsio.com                                      *

 *                                                                           *

 * Authors: Dimitrios Michailidis   <dm@chelsio.com>                         *

 *          Tina Yang               <tainay@chelsio.com>                     *

 *          Felix Marti             <felix@chelsio.com>                      *

 *          Scott Bardone           <sbardone@chelsio.com>                   *

 *          Kurt Ottaway            <kottaway@chelsio.com>                   *

 *          Frank DiMambro          <frank@chelsio.com>                      *

 *                                                                           *

 * History:                                                                  *

 *                                                                           *

	/*

	 * Cannot enable ESPI interrupts on T1B because HW asserts the

	 * interrupt incorrectly, namely the driver gets ESPI interrupts

	 * but no data is actually dropped (can verify this reading the ESPI

	 * drop registers).  Also, once the ESPI interrupt is asserted it

	 * cannot be cleared (HW bug).

		/*

		 * Must read the error count to clear the interrupt

		 * that it causes.

	/*

	 * For T1B we need to write 1 to clear ESPI interrupts.  For T2+ we

	 * write the status as is.

/*

 * Note that T1B requires at least 2 ports for IXF1010 due to a HW bug.

 Disable ESPI training.  MACs that can handle it enable it below. */

		/*

		 * Always position the control at the 1st port egress IN

		 * (sop,eop) counter to reduce PIOs for T/N210 workaround.

  0  */

/*

 * This function is for T204 only.

 * compare with t1_espi_get_mon(), it reads espiInTxSop[0 ~ 3] in

 * one shot, since there is no per port counter on the out side.

/*****************************************************************************

 *                                                                           *

 * File: subr.c                                                              *

 * $Revision: 1.27 $                                                         *

 * $Date: 2005/06/22 01:08:36 $                                              *

 * Description:                                                              *

 *  Various subroutines (intr,pio,etc.) used by Chelsio 10G Ethernet driver. *

 *  part of the Chelsio 10Gb Ethernet Driver.                                *

 *                                                                           *

 * This program is free software; you can redistribute it and/or modify      *

 * it under the terms of the GNU General Public License, version 2, as       *

 * published by the Free Software Foundation.                                *

 *                                                                           *

 * You should have received a copy of the GNU General Public License along   *

 * with this program; if not, see <http://www.gnu.org/licenses/>.            *

 *                                                                           *

 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED    *

 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF      *

 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.                     *

 *                                                                           *

 * http://www.chelsio.com                                                    *

 *                                                                           *

 * Copyright (c) 2003 - 2005 Chelsio Communications, Inc.                    *

 * All rights reserved.                                                      *

 *                                                                           *

 * Maintainers: maintainers@chelsio.com                                      *

 *                                                                           *

 * Authors: Dimitrios Michailidis   <dm@chelsio.com>                         *

 *          Tina Yang               <tainay@chelsio.com>                     *

 *          Felix Marti             <felix@chelsio.com>                      *

 *          Scott Bardone           <sbardone@chelsio.com>                   *

 *          Kurt Ottaway            <kottaway@chelsio.com>                   *

 *          Frank DiMambro          <frank@chelsio.com>                      *

 *                                                                           *

 * History:                                                                  *

 *                                                                           *

/**

 *	t1_wait_op_done - wait until an operation is completed

 *	@adapter: the adapter performing the operation

 *	@reg: the register to check for completion

 *	@mask: a single-bit field within @reg that indicates completion

 *	@polarity: the value of the field when the operation is completed

 *	@attempts: number of check iterations

 *      @delay: delay in usecs between iterations

 *

 *	Wait until an operation is completed by checking a bit in a register

 *	up to @attempts times.  Returns %0 if the operation completes and %1

 *	otherwise.

/*

 * Write a register over the TPI interface (unlocked and locked versions).

/*

 * Read a register over the TPI interface (unlocked and locked versions).

/*

 * Set a TPI parameter.

/*

 * Called when a port's link settings change to propagate the new values to the

 * associated PHY and MAC.  After performing the common tasks it invokes an

 * OS-specific handler.

 Set MAC speed, duplex, and flow control to match PHY. */

 PCI errors are fatal */

/*

 * PHY interrupt handler for FPGA boards.

/*

 * Slow path interrupt handler for FPGAs.

		/*

		 * FPGA doesn't support MC4 interrupts and it requires

		 * this odd layer of indirection for MC5.

 Clear TP interrupt */

 Clear the interrupts just processed. */

/*

 * Wait until Elmer's MI1 interface is ready for new operations.

/*

 * MI1 MDIO initialization.

/*

 * Elmer MI1 MDIO read/write operations.

 Write the address we want. */

 Write the operation we want. */

 Read the data. */

 Write the address we want. */

 Write the data. */

/*

 * Return the board_info structure with a given index.  Out-of-range indices

 * return NULL.

 make multiple-of-4 size requirement explicit */

/*

 * Read SEEPROM. A zero is written to the flag register when the address is

 * written to the Control register. The hardware device will set the flag to a

 * one when 4B have been transferred to the Data register.

/*

 * Read a port's MAC address from the VPD ROM.

/*

 * Set up the MAC/PHY according to the requested link settings.

 *

 * If the PHY can auto-negotiate first decide what to advertise, then

 * enable/disable auto-negotiation as desired and reset.

 *

 * If the PHY does not auto-negotiate we just reset it.

 *

 * If auto-negotiation is off set the MAC to the proper speed/duplex/FC,

 * otherwise do it later based on the outcome of auto-negotiation.

 Also disables autoneg */

 also resets PHY */

/*

 * External interrupt handler for boards using elmer0.

 Marvell 88E1111 interrupt */

		/*

		 * Elmer0's interrupt cause isn't useful here because there is

		 * only one bit that can be set for all 4 ports.  This means

		 * we are forced to check every PHY's interrupt status

		 * register to see who initiated the interrupt.

 Marvell 88x2010 interrupt */

 PMC3393 INTB */

 XPAK MOD_DETECT */

 Enables all interrupts. */

 Enable MAC/PHY interrupts for each port. */

 Enable PCIX & external chip interrupts on ASIC boards. */

 PCI-X interrupts */

 Disables all interrupts. */

 Disable MAC/PHY interrupts for each port. */

 Disable PCIX & external chip interrupts. */

 PCI-X interrupts */

 Clears all interrupts */

 Clear MAC/PHY interrupts for each port. */

 Enable interrupts for external devices. */

 PCI-X interrupts */

/*

 * Slow path interrupt handler for ASICs.

		/* Wake the threaded interrupt to handle external interrupts as

		 * we require a process context. We disable EXT interrupts in

		 * the interim and let the thread reenable them when it's done.

 Clear the interrupts just processed. */

 flush writes */

 Power sequencing is a work-around for Intel's XPAKs. */

 Check for XPAK */

 XPAK is present */

/*

 * Enable board components other than the Chelsio chip, such as external MAC

 * and PHY.

		/* TBD XXX Might not need.  This fixes a problem

		 *         described in the Intel SR XPAK errata.

 add config space write here */

/*

 * Initialize and configure the Terminator HW modules.  Note that external

 * MAC and PHYs are initialized separately.

/*

 * Determine a card's PCI mode.

/*

 * Release the structures holding the SW per-Terminator-HW-module state.

/*

 * Allocate and initialize the data structures that hold the SW state of

 * the Terminator HW modules.

		/*

		 * Get the port's MAC addresses either from the EEPROM if one

		 * exists or the one hardcoded in the MAC.

 SPDX-License-Identifier: GPL-2.0

 $Date: 2006/02/07 04:21:54 $ $RCSfile: tp.c,v $ $Revision: 1.73 $ */

 Pause deadlock avoidance parameters */

 IP DF bit */  |

	/*

	 * Enable pause frame deadlock prevention.

 FPGA */

 We don't use any TP interrupts */

 FPGA */

 FPGA doesn't support TP interrupts. */

/*

 * Initialize TP state.  tp_params contains initial settings for some TP

 * parameters, particularly the one-time PM and CM settings.

/*****************************************************************************

 *                                                                           *

 * File: mv88x201x.c                                                         *

 * $Revision: 1.12 $                                                         *

 * $Date: 2005/04/15 19:27:14 $                                              *

 * Description:                                                              *

 *  Marvell PHY (mv88x201x) functionality.                                   *

 *  part of the Chelsio 10Gb Ethernet Driver.                                *

 *                                                                           *

 * This program is free software; you can redistribute it and/or modify      *

 * it under the terms of the GNU General Public License, version 2, as       *

 * published by the Free Software Foundation.                                *

 *                                                                           *

 * You should have received a copy of the GNU General Public License along   *

 * with this program; if not, see <http://www.gnu.org/licenses/>.            *

 *                                                                           *

 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED    *

 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF      *

 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.                     *

 *                                                                           *

 * http://www.chelsio.com                                                    *

 *                                                                           *

 * Copyright (c) 2003 - 2005 Chelsio Communications, Inc.                    *

 * All rights reserved.                                                      *

 *                                                                           *

 * Maintainers: maintainers@chelsio.com                                      *

 *                                                                           *

 * Authors: Dimitrios Michailidis   <dm@chelsio.com>                         *

 *          Tina Yang               <tainay@chelsio.com>                     *

 *          Felix Marti             <felix@chelsio.com>                      *

 *          Scott Bardone           <sbardone@chelsio.com>                   *

 *          Kurt Ottaway            <kottaway@chelsio.com>                   *

 *          Frank DiMambro          <frank@chelsio.com>                      *

 *                                                                           *

 * History:                                                                  *

 *                                                                           *

/*

 * The 88x2010 Rev C. requires some link status registers * to be read

 * twice in order to get the right values. Future * revisions will fix

 * this problem and then this macro * can disappear.

	/* Setup the LED registers so we can turn on/off.

	 * Writing these bits maps control to another

	 * register. mmd(0x1) addr(0x7)

 Port Reset */

	/* This can be done through registers.  It is not required since

	 * a full chip reset is used.

 Enable PHY LASI interrupts. */

 Enable Marvell interrupts through Elmer0. */

 Disable PHY LASI interrupts. */

 Disable Marvell interrupts through Elmer0. */

 Required to read twice before clear takes affect. */

	/* Read this register after the others above it else

	 * the register doesn't clear correctly.

 Clear link status. */

 Clear PHY LASI interrupts. */

 Do it again. */

 Clear Marvell interrupts through Elmer0. */

 Clear interrupts */

	/* We have only enabled link change interrupts and so

	 * cphy_cause must be a link change interrupt.

 Read link status. */

 Turn on/off Link LED */

 Commands the PHY to enable XFP's clock. */

 Clear link status. Required because of a bug in the PHY.  */

 Allows for Link,Ack LED turn on/off */

 Chip Reset */

 Now lets enable the Laser. Delay 100us */

 SPDX-License-Identifier: GPL-2.0

 $Date: 2005/10/24 23:18:13 $ $RCSfile: mv88e1xxx.c,v $ $Revision: 1.49 $ */

 MV88E1XXX MDI crossover register values */

/*

 * Set the bits given by 'bitval' in PHY register 'reg'.

/*

 * Clear the bits given by 'bitval' in PHY register 'reg'.

/*

 * NAME:   phy_reset

 *

 * DESC:   Reset the given PHY's port. NOTE: This is not a global

 *         chip reset.

 *

 * PARAMS: cphy     - Pointer to PHY instance data.

 *

 * RETURN:  0 - Successful reset.

 *         -1 - Timeout.

 Enable PHY interrupts. */

 Enable Marvell interrupts through Elmer0. */

 Disable all phy interrupts. */

 Disable Marvell interrupts through Elmer0. */

 Clear PHY interrupts by reading the register. */

 Clear Marvell interrupts through Elmer0. */

/*

 * Set the PHY speed and duplex.  This also disables auto-negotiation, except

 * for 1Gb/s, where auto-negotiation is mandatory.

 auto-negotiation required for 1Gb/s */

 restart autoneg for change to take effect */

	/*

	 * Crossover *must* be set to manual in order to disable auto-neg.

	 * The Alaska FAQs document highlights this point.

	/*

	 * Must include autoneg reset when disabling auto-neg. This

	 * is described in the Alaska FAQ document.

	/*

	 * Set the downshift counter to 2 so we try to establish Gb link

	 * twice before downshifting.

	/*

	 * Loop until cause reads zero. Need to handle bouncing interrupts.

 Configure particular PHY's to run in a different mode. */

		/*

		 * Configure the PHY transmitter as class A to reduce EMI.

 Enable downshift */

 LED */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Faraday FTMAC100 10/100 Ethernet

 *

 * (C) Copyright 2009-2011 Faraday Technology

 * Po-Yu Chuang <ratbert@faraday-tech.com>

 must be power of 2 */

 must be power of 2 */

 must be smaller than 0x7ff */

/******************************************************************************

 * private data

/******************************************************************************

 * internal functions (hardware register access)

 NOTE: reset clears all registers */

			/*

			 * FTMAC100_MACCR_SW_RST cleared does not indicate

			 * that hardware reset completed (what the f*ck).

			 * We still need to wait for a while.

 setup ring buffer base registers */

/******************************************************************************

 * internal functions (receive descriptor)

 clear status bits */

/*

 * rxdes3 is not used by hardware. We use it to keep track of page.

 * Since hardware does not touch it, we can skip cpu_to_le32()/le32_to_cpu().

/******************************************************************************

 * internal functions (receive)

	/*

	 * It is impossible to get multi-segment packets

	 * because we always provide big enough receive buffers.

 start processing */

 We pull the minimum amount into linear part */

 Small frames are copied into linear part to free one page */

 push packet to protocol stack */

/******************************************************************************

 * internal functions (transmit descriptor)

 clear all except end of ring bit */

	/*

	 * Make sure dma own bit will not be set before any other

	 * descriptor fields.

/*

 * txdes3 is not used by hardware. We use it to keep track of socket buffer.

 * Since hardware does not touch it, we can skip cpu_to_le32()/le32_to_cpu().

/******************************************************************************

 * internal functions (transmit)

		/*

		 * packet transmitted to ethernet lost due to late collision

		 * or excessive collision

 setup TX descriptor */

 start transmit */

/******************************************************************************

 * internal functions (buffer)

 initialize RX ring */

 initialize TX ring */

/******************************************************************************

 * struct mii_if_info functions

/******************************************************************************

 * struct ethtool_ops functions

/******************************************************************************

 * interrupt handler

 Disable interrupts for polling */

/******************************************************************************

 * struct napi_struct functions

		/*

		 * FTMAC100_INT_RPKT_FINISH:

		 *	RX DMA has received packets into RX buffer successfully

		 *

		 * FTMAC100_INT_NORXBUF:

		 *	RX buffer unavailable

		/*

		 * FTMAC100_INT_XPKT_OK:

		 *	packet transmitted to ethernet successfully

		 *

		 * FTMAC100_INT_XPKT_LOST:

		 *	packet transmitted to ethernet lost due to late

		 *	collision or excessive collision

 RX buffer unavailable */

 received packet lost due to RX FIFO full */

 PHY link status change */

 stop polling */

/******************************************************************************

 * struct net_device_ops functions

 drop packet */

 optional */

/******************************************************************************

 * struct platform_driver functions

 setup net_device */

 setup private data */

 initialize NAPI */

 map io memory */

 initialize struct mii_if_info */

 register network device */

/******************************************************************************

 * initialization / finalization

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Faraday FTGMAC100 Gigabit Ethernet

 *

 * (C) Copyright 2009-2011 Faraday Technology

 * Po-Yu Chuang <ratbert@faraday-tech.com>

 Arbitrary values, I am not sure the HW has limits */

 Defaults */

 must be smaller than 0x3fff */

 Min number of tx ring entries before stopping queue */

 Registers */

 Rx ring */

 Tx ring */

 Used to signal the reset task of ring change request */

 Scratch page to use when rx skb alloc fails */

 Component structures */

 AST2500/AST2600 RMII ref clock gate */

 Link management */

 Multicast filter settings */

 Flow control settings */

 Misc */

 NOTE: reset clears all registers */

 no link */

 (Re)initialize the queue pointers */

 The doc says reset twice with 10us interval */

 Throttle tx queue when receiving pause frames */

	/* Enables sending pause frames when the RX queue is past a

	 * certain threshold.

 Clear stale interrupts */

 Setup RX ring buffer base */

 Setup TX ring buffer base */

 Configure RX buffer size */

 Set RX descriptor autopoll */

 Write MAC address */

 Write multicast filter */

	/* Configure descriptor sizes and increase burst sizes according

	 * to values in Aspeed SDK. The FIFO arbitration is enabled and

	 * the thresholds set based on the recommended values in the

	 * AST2400 specification.

 2*8 bytes RX descs */

 2*8 bytes TX descs */

 512 bytes max RX bursts */

 512 bytes max TX bursts */

 Enable fifo threshold arb */

 6/8 of FIFO high threshold */

 2/8 of FIFO low threshold */

	/* Interrupt mitigation configured for 1 interrupt/packet. HW interrupt

	 * mitigation doesn't seem to provide any benefit with NAPI so leave

	 * it at that.

 Configure FIFO sizes in the TPAFCR register */

 Keep the original GMAC and FAST bits */

 Add all the main enable bits */

 Add other bits as needed */

 Vlan filtering enabled */

 Hit the HW */

 Setup the hash filter */

 Interface down ? that's all there is to do */

 Update the HW */

 Reconfigure MACCR */

 Store skb */

 Store DMA address into RX desc */

 Ensure the above is ordered vs clearing the OWN bit */

 Clean status (which resets own bit) */

 Grab next RX descriptor */

 Grab descriptor status */

 Do we have a packet ? */

 Order subsequent reads with the test for the ready bit */

 We don't cope with fragmented RX packets */

 Grab received size and csum vlan field in the descriptor */

 Any error (other than csum offload) flagged ? */

		/* Correct for incorrect flagging of runt packets

		 * with vlan tags... Just accept a runt packet that

		 * has been flagged as vlan and whose size is at

		 * least 60 bytes.

 Any error still in there ? */

	/* If the packet had no skb (failed to allocate earlier)

	 * then try to allocate one and skip

	/* If the HW found checksum errors, bounce it to software.

	 *

	 * If we didn't, we need to see if the packet was recognized

	 * by HW as one of the supported checksummed protocols before

	 * we accept the HW test results.

 Transfer received size to skb */

 Extract vlan tag */

 Tear down DMA mapping, do necessary cache management */

	/* When we don't have an iommu, we can save cycles by not

	 * invalidating the cache for the part of the packet that

	 * wasn't received.

 Resplenish rx ring */

 push packet to protocol stack */

 Clean rxdes0 (which resets own bit) */

	/* Returns the number of available slots in the TX queue

	 *

	 * This always leaves one free slot so we don't have to

	 * worry about empty vs. full, and this simplifies the

	 * test for ftgmac100_tx_buf_cleanable() below

 Free SKB on last segment */

 Process all completed packets */

 Restart queue if needed */

 The HW doesn't pad small frames */

 Reject oversize packets */

	/* Do we have a limit on #fragments ? I yet have to get a reply

	 * from Aspeed. If there's one I haven't hit it.

 Setup HW checksumming */

 Add VLAN tag */

 Get header len */

 Map the packet head */

 Grab the next free tx descriptor */

	/* Setup it up with the packet head. Don't write the head to the

	 * ring just yet

 Next descriptor */

 Add the fragments */

 Map it */

 Setup descriptor */

 Next one */

	/* Order the previous packet and descriptor udpates

	 * before setting the OWN bit on the first descriptor.

 Update next TX pointer */

	/* If there isn't enough room for all the fragments of a new packet

	 * in the TX ring, stop the queue. The sequence below is race free

	 * vs. a concurrent restart in ftgmac100_poll()

 Order the queue stop with the test below */

 Poke transmitter to read the updated TX descriptors */

 Free head */

 Then all fragments */

	/* This cannot be reached if we successfully mapped the

	 * last fragment, so we know ftgmac100_free_tx_packet()

	 * hasn't freed the skb yet.

 Drop the packet */

 Free all RX buffers */

 Free all TX buffers */

 Free skb arrays */

 Free descriptors */

 Free scratch packet buffer */

 Allocate skb arrays */

 Allocate descriptors */

 Allocate scratch packet buffer */

 Update entries counts */

 Initialize RX ring */

 Mark the end of the ring */

 Initialize TX ring */

 We store "no link" as speed 0 */

 Grab pause settings from PHY if configured to do so */

 Link hasn't changed, do nothing */

	/* Print status if we have a link or we had one and just lost it,

	 * don't print otherwise.

 Link is down, do nothing else */

 Disable all interrupts */

 Reset the adapter asynchronously */

 Default to RGMII. It's a gigabit part after all */

	/* Aspeed only supports these. I don't know about other IP

	 * block vendors so I'm going to just let them through for

	 * now. Note that this is only a warning if for some obscure

	 * reason the DT really means to lie about it or it's a newer

	 * part we don't know about.

	 *

	 * On the Aspeed SoC there are additionally straps and SCU

	 * control bits that could tell us what the interface is

	 * (or allow us to configure it while the IP block is held

	 * in reset). For now I chose to keep this driver away from

	 * those SoC specific bits and assume the device-tree is

	 * right and the SCU has been configured properly by pinmux

	 * or the firmware.

	/* Indicate that we support PAUSE frames (see comment in

	 * Documentation/networking/phy.rst)

 Display what we found */

 preserve MDC cycle threshold */

 preserve MDC cycle threshold */

 Fetch and clear interrupt bits, process abnormal ones */

 RX buffer unavailable */

 received packet lost due to RX FIFO full */

 sent packet lost due to excessive TX collision */

 AHB error -> Reset the chip */

		/* We may need to restart the MAC after such errors, delay

		 * this until after we have freed some Rx buffers though

 Disable those errors until we restart */

 Only enable "bad" interrupts while NAPI is on */

 Schedule NAPI bh */

 Do we have a packet ? */

 Handle TX completions */

 Handle RX packets */

	/* The interrupt is telling us to kick the MAC back to life

	 * after an RX overflow

 Re-enable "bad" interrupts */

	/* As long as we are waiting for transmit packets to be

	 * completed we keep NAPI going

		/* We are about to re-enable all interrupts. However

		 * the HW has been latching RX/TX packet interrupts while

		 * they were masked. So we clear them first, then we need

		 * to re-check if there's something to process

		/* Push the above (and provides a barrier vs. subsequent

		 * reads of the descriptor).

 Check RX and TX descriptors for more work to do */

 deschedule NAPI */

 enable all interrupts */

 Re-init descriptors (adjust queue sizes) */

 Realloc rx descriptors */

 Reinit and restart HW */

 Re-enable the device */

 Enable all interrupts */

 Lock the world */

 Check if the interface is still up */

 Stop the network stack */

 Stop and reset the MAC */

 Not much we can do ... it might come back... */

 Free all rx and tx buffers */

 Setup everything again and restart chip */

 Allocate ring buffers  */

	/* When using NC-SI we force the speed to 100Mbit/s full duplex,

	 *

	 * Otherwise we leave it set to 0 (no link), the link

	 * message from the PHY layer will handle setting it up to

	 * something else if needed.

 Reset the hardware */

 Initialize NAPI */

 Grab our interrupt */

 Start things up */

 If we have a PHY, start polling */

 If using NC-SI, set our carrier on and start the stack */

 Start the NCSI device */

	/* Note about the reset task: We are called with the rtnl lock

	 * held, so we are synchronized against the core of the reset

	 * task. We must not try to synchronously cancel it otherwise

	 * we can deadlock. But since it will test for netif_running()

	 * which has already been cleared by the net core, we don't

	 * anything special to do.

 disable all interrupts */

 Disable all interrupts */

 Do the reset outside of interrupt context */

 Update the vlan filtering bit */

 initialize mdio bus */

 The AST2600 has a separate MDIO controller */

		/* For the AST2400 and AST2500 this driver only supports the

		 * old MDIO interface

 MACCLK */);

	/* Aspeed specifies a 100MHz clock is required for up to

	 * 1000Mbit link speeds. As NCSI is limited to 100Mbit, 25MHz

	 * is sufficient

	/* RCLK is for RMII, typically used for NCSI. Optional because it's not

	 * necessary if it's the AST2400 MAC, or the MAC is configured for

	 * RGMII, or the controller is not an ASPEED-based controller.

 setup net_device */

 setup private data */

 map io memory */

 Enable pause */

 MAC address from chip or random one */

 Disable ast2600 problematic HW arbitration */

		/* Support "mdio"/"phy" child nodes for ast2400/2500 with

		 * an embedded MDIO controller. Automatically scan the DTS for

		 * available PHYs and register them.

		/* Indicate that we support PAUSE frames (see comment in

		 * Documentation/networking/phy.rst)

 Display what we found */

		/* Support legacy ASPEED devicetree descriptions that decribe a

		 * MAC with an embedded MDIO controller but have no "mdio"

		 * child node. Automatically scan the MDIO bus for available

		 * PHYs.

 Default ring sizes */

 Base feature set */

 AST2400  doesn't have working HW checksum generation */

 register network device */

	/* There's a small chance the reset task will have been re-queued,

	 * during stop, make sure it's gone before we free the structure.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Actions Semi Owl SoCs Ethernet MAC driver

 *

 * Copyright (c) 2012 Actions Semi Inc.

 * Copyright (c) 2021 Cristian Ciocaltea <cristian.ciocaltea@gmail.com>

	/* Enable all interrupts except TU.

	 *

	 * Note the NIE and AIE bits shall also be set in order to actually

	 * enable the selected interrupts.

	/* Disable all interrupts.

	 *

	 * WARNING: Unset only the NIE and AIE bits in CSR7 to workaround an

	 * unexpected side effect (MAC hardware bug?!) where some bits in the

	 * status register (CSR5) are cleared automatically before being able

	 * to read them via owl_emac_irq_clear().

 Buffer pointer for the RX DMA descriptor must be word aligned. */

 Ensure 4 bytes DMA alignment. */

 Update flow control. */

 Temporarily stop DMA TX & RX. */

 Update operation modes. */

 Restore DMA TX & RX status. */

 Fill multicast addresses. */

/* The setup frame is a special descriptor which is used to provide physical

 * addresses (i.e. mac, broadcast and multicast) to the MAC hardware for

 * filtering purposes. To be recognized as a setup frame, the TDES1_SET bit

 * must be set in the TX descriptor control field.

 Ensure data has been read before used. */

 Maintain bits */

 Flush descriptor before changing ownership. */

 Temporarily enable DMA TX. */

 Trigger setup frame processing. */

 Restore DMA TX status. */

 Stop regular TX until setup frame is processed. */

 Ensure data has been read before used. */

 Maintain bits */

 Flush descriptor before changing ownership. */

	/* FIXME: The transmission is currently restricted to a single frame

	 * at a time as a workaround for a MAC hardware bug that causes random

	 * freeze of the TX queue processor.

 Ensure data has been read before used. */

 Check for errors. */

 Some collisions occurred, but pkt has been transmitted. */

	/* FIXME: This is a workaround for a MAC hardware bug not clearing

	 * (sometimes) the OWN bit for a transmitted frame descriptor.

	 *

	 * At this point, when TX queue is full, the tail descriptor has the

	 * OWN bit set, which normally means the frame has not been processed

	 * or transmitted yet. But if there is at least one descriptor in the

	 * queue having the OWN bit cleared, we can safely assume the tail

	 * frame has been also processed by the MAC hardware.

	 *

	 * If that's the case, let's force the frame completion by manually

	 * clearing the OWN bit.

 Ensure data has been read before used. */

 Ensure data has been read before used. */

 Ensure data has been read before used. */

 Prepare new skb before receiving the current one. */

 Reuse the current skb. */

 Flush descriptor before changing ownership. */

 TX setup frame raises ETI instead of TI. */

 Count MAC internal RX errors. */

 Count MAC internal TX errors. */

			/* MAC AHB is in suspended state, will return to RX

			 * descriptor processing when the host changes ownership

			 * of the descriptor and either an RX poll demand CMD is

			 * issued or a new frame is recognized by the MAC AHB.

 Guard against too many RU interrupts. */

 Reset MAC when getting too many internal TX or RX errors. */

	/* Enable MDC clock generation by adjusting CLKDIV according to

	 * the vendor implementation of the original driver.

 Trigger hardware reset. */

 Trigger software reset. */

 Enable RMII and use the 50MHz rmii clk as output to PHY. */

		/* Enable SMII and use the 125MHz rmii clk as output to PHY.

		 * Additionally set SMII SYNC delay to 4 half cycle.

 MDC is disabled after reset. */

 Set FIFO pause & restart threshold levels. */

 Set flow control pause quanta time to ~100 ms. */

 Setup interrupt mitigation. */

 Set RX/TX rings base addresses. */

 Setup initial operation mode. */

 Temporarily stop DMA TX & RX. */

 Update operation modes. */

 Restore DMA TX & RX status. */

 Set/reset multicast addr list. */

	/* FIXME: If possible, try to get stats from MAC hardware registers

	 * instead of tracking them manually in the driver.

 Wait while data transfer is in progress. */

 Mask out all PHYs from auto probing. */

/* Agere Systems Inc.

 * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs

 *

 * Copyright © 2005 Agere Systems Inc.

 * All rights reserved.

 *   http://www.agere.com

 *

 * Copyright (c) 2011 Mark Einon <mark.einon@gmail.com>

 *

 *------------------------------------------------------------------------------

 *

 * SOFTWARE LICENSE

 *

 * This software is provided subject to the following terms and conditions,

 * which you should read carefully before using the software.  Using this

 * software indicates your acceptance of these terms and conditions.  If you do

 * not agree with these terms and conditions, do not use the software.

 *

 * Copyright © 2005 Agere Systems Inc.

 * All rights reserved.

 *

 * Redistribution and use in source or binary forms, with or without

 * modifications, are permitted provided that the following conditions are met:

 *

 * . Redistributions of source code must retain the above copyright notice, this

 *    list of conditions and the following Disclaimer as comments in the code as

 *    well as in the documentation and/or other materials provided with the

 *    distribution.

 *

 * . Redistributions in binary form must reproduce the above copyright notice,

 *    this list of conditions and the following Disclaimer in the documentation

 *    and/or other materials provided with the distribution.

 *

 * . Neither the name of Agere Systems Inc. nor the names of the contributors

 *    may be used to endorse or promote products derived from this software

 *    without specific prior written permission.

 *

 * Disclaimer

 *

 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,

 * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF

 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY

 * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN

 * RISK. IN NO EVENT SHALL AGERE SYSTEMS INC. OR CONTRIBUTORS BE LIABLE FOR ANY

 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES

 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;

 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND

 * ON ANY THEORY OF LIABILITY, INCLUDING, BUT NOT LIMITED TO, CONTRACT, STRICT

 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT

 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH

 * DAMAGE.

 EEPROM defines */

 MAC defines */

 PCI defines */

 1024 of internal memory */

 50%   Tx, 50%   Rx */

 ISR defines */

/* For interrupts, normal running is:

 *       rxdma_xfr_done, phy_interrupt, mac_stat_interrupt,

 *       watchdog_interrupt & txdma_xfer_done

 *

 * In both cases, when flow control is enabled for either Tx or bi-direction,

 * we additional enable rx_fbr0_low and rx_fbr1_low, so we know when the

 * buffer rings are running low.

/* NOTE: Masking out MAC_STAT Interrupt for now...

 * #define INT_MASK_ENABLE             0xfff6bf17

 * #define INT_MASK_ENABLE_NO_FLOW     0xfff6bfd7

 General defines */

 Packet and header sizes */

 Multicast list size */

 Supported Filters */

 Tx Timeout */

 MP_ADAPTER flags */

 MP_SHARED flags */

 Some offsets in PCI config space that are actually used. */

 PCI Product IDs */

 ET1310 1000 Base-T 8 */

 ET1310 100  Base-T */

 Define order of magnitude converter */

 RX defines */

 number of RFDs - default and min */

 typedefs for Free Buffer Descriptors */

 Bits 10-31 reserved, 0-9 descriptor */

/* Packet Status Ring Descriptors

 *

 * Word 0:

 *

 * top 16 bits are from the Alcatel Status Word as enumerated in

 * PE-MCXMAC Data Sheet IPD DS54 0210-1 (also IPD-DS80 0205-2)

 *

 * 0: hp			hash pass

 * 1: ipa			IP checksum assist

 * 2: ipp			IP checksum pass

 * 3: tcpa			TCP checksum assist

 * 4: tcpp			TCP checksum pass

 * 5: wol			WOL Event

 * 6: rxmac_error		RXMAC Error Indicator

 * 7: drop			Drop packet

 * 8: ft			Frame Truncated

 * 9: jp			Jumbo Packet

 * 10: vp			VLAN Packet

 * 11-15: unused

 * 16: asw_prev_pkt_dropped	e.g. IFG too small on previous

 * 17: asw_RX_DV_event		short receive event detected

 * 18: asw_false_carrier_event	bad carrier since last good packet

 * 19: asw_code_err		one or more nibbles signalled as errors

 * 20: asw_CRC_err		CRC error

 * 21: asw_len_chk_err		frame length field incorrect

 * 22: asw_too_long		frame length > 1518 bytes

 * 23: asw_OK			valid CRC + no code error

 * 24: asw_multicast		has a multicast address

 * 25: asw_broadcast		has a broadcast address

 * 26: asw_dribble_nibble	spurious bits after EOP

 * 27: asw_control_frame	is a control frame

 * 28: asw_pause_frame		is a pause frame

 * 29: asw_unsupported_op	unsupported OP code

 * 30: asw_VLAN_tag		VLAN tag detected

 * 31: asw_long_evt		Rx long event

 *

 * Word 1:

 * 0-15: length			length in bytes

 * 16-25: bi			Buffer Index

 * 26-27: ri			Ring Index

 * 28-31: reserved

 Typedefs for the RX DMA status word */

/* rx status word 0 holds part of the status bits of the Rx DMA engine

 * that get copied out to memory by the ET-1310.  Word 0 is a 32 bit word

 * which contains the Free Buffer ring 0 and 1 available offset.

 *

 * bit 0-9 FBR1 offset

 * bit 10 Wrap flag for FBR1

 * bit 16-25 FBR0 offset

 * bit 26 Wrap flag for FBR0

/* RXSTAT_WORD1_t structure holds part of the status bits of the Rx DMA engine

 * that get copied out to memory by the ET-1310.  Word 3 is a 32 bit word

 * which contains the Packet Status Ring available offset.

 *

 * bit 0-15 reserved

 * bit 16-27 PSRoffset

 * bit 28 PSRwrap

 * bit 29-31 unused

/* struct rx_status_block is a structure representing the status of the Rx

 * DMA engine it sits in free memory, and is pointed to by 0x101c / 0x1020

/* Structure for look-up table holding free buffer ring pointers, addresses

 * and state.

/* struct rx_ring is the structure representing the adaptor's local

 * reference(s) to the rings

 TX defines */

/* word 2 of the control bits in the Tx Descriptor ring for the ET-1310

 *

 * 0-15: length of packet

 * 16-27: VLAN tag

 * 28: VLAN CFI

 * 29-31: VLAN priority

 *

 * word 3 of the control bits in the Tx Descriptor ring for the ET-1310

 *

 * 0: last packet in the sequence

 * 1: first packet in the sequence

 * 2: interrupt the processor when this pkt sent

 * 3: Control word - no packet data

 * 4: Issue half-duplex backpressure : XON/XOFF

 * 5: send pause frame

 * 6: Tx frame has error

 * 7: append CRC

 * 8: MAC override

 * 9: pad packet

 * 10: Packet is a Huge packet

 * 11: append VLAN tag

 * 12: IP checksum assist

 * 13: TCP checksum assist

 * 14: UDP checksum assist

 struct tx_desc represents each descriptor on the ring */

 control words how to xmit the */

 data (detailed above) */

/* The status of the Tx DMA engine it sits in free memory, and is pointed to

 * by 0x101c / 0x1020. This is a DMA10 type

 TCB (Transmit Control Block: Host Side) */

 Next entry in ring */

 Used to spot stuck/lost packets */

 Used to spot stuck/lost packets */

 Network skb we are tied to */

 Ring indexes */

 Structure representing our local reference(s) to the ring */

 TCB (Transmit Control Block) memory and lists */

 List of TCBs that are ready to be used */

 list of TCBs that are currently being sent. */

 The actual descriptor ring */

 send_idx indicates where we last wrote to in the descriptor ring. */

 The location of the write-back status block */

 Packets since the last IRQ: used for interrupt coalescing */

/* Do not change these values: if changed, then change also in respective

 * TXdma and Rxdma engines

 TX Do not change these values */

/* These values are all superseded by registry entries to facilitate tuning.

 * Once the desired performance has been achieved, the optimal registry values

 * should be re-populated to these #defines:

 RFD (Receive Frame Descriptor) */

 total size of receive frame */

 Flow Control */

 Struct to define some device statistics */

 The private adapter structure */

 Flags that indicate current state of the adapter */

 local link state, to determine if a state change has occurred */

 Configuration  */

 protects the tx_ring send tcb list */

 protects the tx_ring ready tcb list */

 protects the rx_ring receive list */

 Packet Filter and look ahead size */

 multicast list */

 Pointer to the device's PCI register space */

 Registry parameters */

 Flow we want for 802.3x flow control */

 Max supported ethernet packet size */

 Derived from the registry: */

 flow control validated by the far-end */

 Minimize init-time */

	/* variable putting the phy into coma mode when boot up with no cable

	 * plugged in after 5 seconds

 Tx Memory Variables */

 Rx Memory Variables */

	/* 1. Check LBCIF Status Register for bits 6 & 3:2 all equal to 0 and

	 *    bits 7,1:0 both equal to 1, at least once after reset.

	 *    Subsequent operations need only to check that bits 1:0 are equal

	 *    to 1 prior to starting a single byte read/write

 I2C idle and Phy Queue Avail both true */

	/* For an EEPROM, an I2C single byte write is defined as a START

	 * condition followed by the device address, EEPROM address, one byte

	 * of data and a STOP condition.  The STOP condition will trigger the

	 * EEPROM's internally timed write cycle to the nonvolatile memory.

	 * All inputs are disabled during this write cycle and the EEPROM will

	 * not respond to any access until the internal write is complete.

	 /* 2. Write to the LBCIF Control Register:  bit 7=1, bit 6=1, bit 3=0,

	  *    and bits 1:0 both =0.  Bit 5 should be set according to the

	  *    type of EEPROM being accessed (1=two byte addressing, 0=one

	  *    byte addressing).

 Prepare EEPROM address for Step 3 */

		/* Write the data to the LBCIF Data Register (the I2C write

		 * will begin).

		/* Monitor bit 1:0 of the LBCIF Status Register.  When bits

		 * 1:0 are both equal to 1, the I2C write has completed and the

		 * internal write cycle of the EEPROM is about to start.

		 * (bits 1:0 = 01 is a legal state while waiting from both

		 * equal to 1, but bits 1:0 = 10 is invalid and implies that

		 * something is broken).

		/* Check bit 3 of the LBCIF Status Register.  If  equal to 1,

		 * an error has occurred.Don't break here if we are revision

		 * 1, this is so we do a blind write for load bug.

		/* Check bit 2 of the LBCIF Status Register.  If equal to 1 an

		 * ACK error has occurred on the address phase of the write.

		 * This could be due to an actual hardware failure or the

		 * EEPROM may still be in its internal write cycle from a

		 * previous write. This write operation was ignored and must be

		  *repeated later.

			/* This could be due to an actual hardware failure

			 * or the EEPROM may still be in its internal write

			 * cycle from a previous write. This write operation

			 * was ignored and must be repeated later.

		/* Do read until internal ACK_ERROR goes away meaning write

		 * completed

	/* A single byte read is similar to the single byte write, with the

	 * exception of the data flow:

	/* Write to the LBCIF Control Register:  bit 7=1, bit 6=0, bit 3=0,

	 * and bits 1:0 both =0.  Bit 5 should be set according to the type

	 * of EEPROM being accessed (1=two byte addressing, 0=one byte

	 * addressing).

	/* Write the address to the LBCIF Address Register (I2C read will

	 * begin).

	/* Monitor bit 0 of the LBCIF Status Register.  When = 1, I2C read

	 * is complete. (if bit 1 =1 and bit 0 stays = 0, a hardware failure

	 * has occurred).

	/* Regardless of error status, read data byte from LBCIF Data

	 * Register.

	/* THIS IS A WORKAROUND:

	 * I need to call this function twice to get my card in a

	 * LG M1 Express Dual running. I tried also a msleep before this

	 * function, because I thought there could be some time conditions

	 * but it didn't work. Call the whole function twice also work.

	/* Determine if the error(s) we care about are present. If they are

	 * present we need to fail.

			/* Re-write the first 4 bytes if we have an eeprom

			 * present and the revision id is 1, this fixes the

			 * corruption seen with 1310 B Silicon

			/* This error could mean that there was an error

			 * reading the eeprom or that the eeprom doesn't exist.

			 * We will treat each case the same and not try to

			 * gather additional information that normally would

			 * come from the eeprom, like MAC Address

	/* Read the EEPROM for information regarding LED behavior. Refer to

	 * et131x_xcvr_init() for its use.

 Disable all optional features */

 Setup the receive dma configuration register for normal operation */

 Setup the receive dma configuration register */

	/* Setup the transmit dma configuration register for normal

	 * operation

	/* First we need to reset everything.  Write to MAC configuration

	 * register 1 to perform reset.

 Next lets configure the MAC Inter-packet gap register */

 IPG1 0x38 IPG2 0x58 B2B 0x60 */

 ifg enforce 0x50 */

 Next lets configure the MAC Half Duplex register */

 BEB trunc 0xA, Ex Defer, Rexmit 0xF Coll 0x37 */

 Next lets configure the MAC Interface Control register */

	/* Next lets configure the MAC Station Address register.  These

	 * values are read from the EEPROM during initialization and stored

	 * in the adapter structure.  We write what is stored in the adapter

	 * structure to the MAC Station Address registers high and low.  This

	 * station address is used for generating and checking pause control

	 * packets.

	/* Max ethernet packet in bytes that will be passed by the mac without

	 * being truncated.  Allow the MAC to pass 4 more than our max packet

	 * size.  This is 4 for the Ethernet CRC.

	 *

	 * Packets larger than (registry_jumbo_packet) that do not contain a

	 * VLAN ID will be dropped by the Rx function.

 clear out MAC config reset */

 Set up the if mode bits */

 Now we need to initialize the MAC Configuration 2 register */

	/* preamble 7, check length, huge frame off, pad crc, crc enable

	 * full duplex off

	/* If ET131X_PACKET_TYPE_MULTICAST is specified, then we provision

	 * the multi-cast LIST.  If it is NOT specified, (and "ALL" is not

	 * specified) then we should pass NO multi-cast addresses to the

	 * driver.

 Loop through our multicast array and set up the device */

 Write out the new hash to the device */

	/* Set up unicast packet filter reg 3 to be the first two octets of

	 * the MAC address for both address

	 *

	 * Set up unicast packet filter reg 2 to be the octets 2 - 5 of the

	 * MAC address for second address

	 *

	 * Set up unicast packet filter reg 3 to be the octets 2 - 5 of the

	 * MAC address for first address

 Disable the MAC while it is being configured (also disable WOL) */

 Initialize WOL to disabled. */

	/* We need to set the WOL mask0 - mask4 next.  We initialize it to

	 * its default Values of 0x00000000 because there are not WOL masks

	 * as of this time.

 Lets setup the WOL Source Address */

 Disable all Packet Filtering */

 Let's initialize the Unicast Packet filtering address */

 Let's initialize the Multicast hash */

 Runt packet filtering.  Didn't work in version A silicon. */

		/* In order to transmit jumbo packets greater than 8k, the

		 * FIFO between RxMAC and RxDMA needs to be reduced in size

		 * to (16k - Jumbo packet size).  In order to implement this,

		 * we must use "cut through" mode in the RxMAC, which chops

		 * packets down into segments which are (max_size * 16).  In

		 * this case we selected 256 bytes, since this is the size of

		 * the PCI-Express TLP's that the 1310 uses.

		 *

		 * seg_en on, fc_en off, size 0x10

	/* Initialize the the mif_ctrl register

	 * bit 3:  Receive code error. One or more nibbles were signaled as

	 *	   errors  during the reception of the packet.  Clear this

	 *	   bit in Gigabit, set it in 100Mbit.  This was derived

	 *	   experimentally at UNH.

	 * bit 4:  Receive CRC error. The packet's CRC did not match the

	 *	   internally generated CRC.

	 * bit 5:  Receive length check error. Indicates that frame length

	 *	   field value in the packet does not match the actual data

	 *	   byte length and is not a type field.

	 * bit 16: Receive frame truncated.

	 * bit 17: Drop packet enable

	/* Finally we initialize RxMac to be enabled & WOL disabled.  Packet

	 * filter is always enabled since it is where the runt packets are

	 * supposed to be dropped.  For version A silicon, runt packet

	 * dropping doesn't work, so it is disabled in the pf_ctrl register,

	 * but we still leave the packet filter on.

	/* We need to update the Control Frame Parameters

	 * cfpt - control frame pause timer set to 64 (0x40)

	 * cfep - control frame extended pause timer set to 0x0

 initialize all the macstat registers to zero on the device  */

	/* Unmask any counters that we want to track the overflow of.

	 * Initially this will be all counters.  It may become clear later

	 * that we do not need to track all counters.

	/* Save a local copy of the registers we are dealing with so we can

	 * set them back

 Stop the current operation */

 Set up the register we need to read from on the correct PHY */

 If we hit the max delay, we could not read the register */

	/* If we hit here we were able to read the register and we need to

	 * return the value to the caller

 Stop the read operation */

	/* set the registers we touched back to the state at which we entered

	 * this function

	/* Save a local copy of the registers we are dealing with so we can

	 * set them back

 Stop the current operation */

 Set up the register we need to write to on the correct PHY */

 Add the value to write to the registers to the mac */

 If we hit the max delay, we could not write the register */

 Stop the write operation */

	/* set the registers we touched back to the state at which we entered

	 * this function

 et1310_update_macstat_host_counters - Update local copy of the statistics */

/* et1310_handle_macstat_interrupt

 *

 * One of the MACSTAT counters has wrapped.  Update the local copy of

 * the statistics held in the adapter structure, checking the "wrap"

 * bit for each counter.

	/* Read the interrupt bits from the register(s).  These are Clear On

	 * Write.

	/* We need to do update the host copy of all the MAC_STAT counters.

	 * For each counter, check it's overflow bit.  If the overflow bit is

	 * set, then increment the host version of the count by one complete

	 * revolution of the counter.  This routine is called when the counter

	 * block indicates that one of the counters has wrapped.

/*	et1310_phy_power_switch	-	PHY power control

 *	@adapter: device to control

 *	@down: true for off/false for back on

 *

 *	one hundred, ten, one thousand megs

 *	How would you like to have your LAN accessed

 *	Can't you see that this code processed

 *	Phy power, phy power..

 et131x_xcvr_init - Init the phy if we are setting it into force mode */

	/* Set the LED behavior such that LED 1 indicates speed (off =

	 * 10Mbits, blink = 100Mbits, on = 1000Mbits) and LED 2 indicates

	 * link and activity (on for link, blink off for activity).

	 *

	 * NOTE: Some customizations have been added here for specific

	 * vendors; The LED behavior is now determined by vendor data in the

	 * EEPROM. However, the above description is the default.

 et131x_configure_global_regs	- configure JAGCore global regs */

		/* Tx / RxDMA and Tx/Rx MAC interfaces have a 1k word

		 * block of RAM that the driver can split between Tx

		 * and Rx as it desires.  Our default is to split it

		 * 50/50:

 For jumbo packets > 2k but < 8k, split 50-50. */

		/* 9216 is the only packet size greater than 8k that

		 * is available. The Tx buffer has to be big enough

		 * for one whole packet on the Tx side. We'll make

		 * the Tx 9408, and give the rest to Rx

 Initialize the loopback register. Disable all loopbacks. */

	/* By default, disable the watchdog timer.  It will be enabled when

	 * a packet is queued.

 et131x_config_rx_dma_regs - Start of Rx_DMA init sequence */

 Load the completion writeback physical address */

 Set the address and parameters of the packet status ring */

 These local variables track the PSR in the adapter structure */

 Now's the best time to initialize FBR contents */

 Set the address and parameters of Free buffer ring 1 and 0 */

		/* This variable tracks the free buffer ring 1 full position,

		 * so it has to match the above.

	/* Program the number of packets we will receive before generating an

	 * interrupt.

	 * For version B silicon, this value gets updated once autoneg is

	 *complete.

	/* The "time_done" is not working correctly to coalesce interrupts

	 * after a given time period, but rather is giving us an interrupt

	 * regardless of whether we have received packets.

	 * This value gets updated once autoneg is complete.

/* et131x_config_tx_dma_regs - Set up the tx dma section of the JAGCore.

 *

 * Configure the transmit engine with the ring buffers we have created

 * and prepare it for use.

 Load the hardware with the start of the transmit descriptor ring. */

 Initialise the transmit DMA engine */

 Load the completion writeback physical address */

 et131x_adapter_setup - Set the adapter up as per cassini+ documentation */

 Configure the MMC registers */

 All we need to do is initialize the Memory Control Register */

 et131x_soft_reset - Issue soft reset to the hardware, complete for ET1310 */

 Disable MAC Core */

 Setup the transmit dma configuration register */

 Curr send queue should now be empty */

/* et1310_enable_phy_coma

 *

 * driver receive an phy status change interrupt while in D0 and check that

 * phy_status is down.

 *

 *          -- gate off JAGCore;

 *          -- set gigE PHY in Coma mode

 *          -- wake on phy_interrupt; Perform software reset JAGCore,

 *             re-initialize jagcore and gigE PHY

 Stop sending packets. */

 Wait for outstanding Receive packets */

 Gate off JAGCore 3 clock domains */

 Program gigE PHY in to Coma mode */

 Disable phy_sw_coma register and re-enable JAGCore clocks */

	/* Restore the GbE PHY speed and duplex modes;

	 * Reset JAGCore; re-configure and initialize JAGCore and gigE PHY

 Re-initialize the send structures */

	/* Bring the device back to the state it was during init prior to

	 * autonegotiation being complete.  This way, when we get the auto-neg

	 * complete interrupt, we can complete init by calling ConfigMacREGS2.

 Allow Tx to restart */

	/* This works for all cases where limit < 1024. The 1023 case

	 * works because 1023++ is 1024 which means the if condition is not

	 * taken but the carry of the bit into the wrap bit toggles the wrap

	 * value correctly

 For the 1023 case */

/* et131x_rx_dma_memory_alloc

 *

 * Allocates Free buffer ring 1 for sure, free buffer ring 0 if required,

 * and the Packet Status Ring.

 Alloc memory for the lookup table */

	/* The first thing we will do is configure the sizes of the buffer

	 * rings. These will change based on jumbo packet support.  Larger

	 * jumbo packets increases the size of each entry in FBR0, and the

	 * number of entries in FBR0, while at the same time decreasing the

	 * number of entries in FBR1.

	 *

	 * FBR1 holds "large" frames, FBR0 holds "small" frames.  If FBR1

	 * entries are huge in order to accommodate a "jumbo" frame, then it

	 * will have less entries.  Conversely, FBR1 will now be relied upon

	 * to carry more "normal" frames, thus it's entry size also increases

	 * and the number of entries goes up too (since it now carries

	 * "small" + "regular" packets.

	 *

	 * In this scheme, we try to maintain 512 entries between the two

	 * rings. Also, FBR1 remains a constant size - when it's size doubles

	 * the number of entries halves.  FBR0 increases in size, however.

 Allocate an area of memory for Free Buffer Ring */

 See NOTE in "Save Physical Address" comment above */

				/* Save the Virtual address of this index for

				 * quick access later

				/* now store the physical address in the

				 * descriptor so the device can access it

 Allocate an area of memory for FIFO of Packet Status ring entries */

 Allocate an area of memory for writeback of status information */

	/* The RFDs are going to be put on lists later on, so initialize the

	 * lists now.

 Free RFDs and associated packet descriptors */

 Free Free Buffer Rings */

 First the packet memory */

 Free Packet Status Ring */

 Free area of memory for the writeback of status information */

 Free the FBR Lookup Table */

 Reset Counters */

 et131x_init_recv - Initialize receive data structures */

 Setup each RFD */

 Add this RFD to the recv_list */

 Increment the available RFD's */

 et131x_set_rx_dma_timer - Set the heartbeat timer according to line rate */

	/* For version B silicon, we do not use the RxDMA timer for 10 and 100

	 * Mbits/s line rates. We do not enable and RxDMA interrupt coalescing.

 nic_return_rfd - Recycle a RFD and put it back onto the receive list */

	/* We don't use any of the OOB data besides status. Otherwise, we

	 * need to clean up OOB data

		/* Handle the Free Buffer Ring advancement here. Write

		 * the PA / Buffer Index for the returned buffer into

		 * the oldest (next to be freed)FBR entry

	/* The processing on this RFD is done, so put it back on the tail of

	 * our list

/* nic_rx_pkts - Checks the hardware for available packets

 *

 * Checks the hardware for available packets, using completion ring

 * If packets are available, it gets an RFD from the recv_list, attaches

 * the packet to it, puts the RFD in the RecvPendList, and also returns

 * the pointer to the RFD.

	/* RX Status block is written by the DMA engine prior to every

	 * interrupt. It contains the next to be used entry in the Packet

	 * Status Ring, and also the two Free Buffer rings.

 Check the PSR and wrap bits do not match */

 Looks like this ring is not updated yet */

 The packet status ring indicates that data is available. */

	/* Grab any information that is required once the PSR is advanced,

	 * since we can no longer rely on the memory being accurate

 Indicate that we have used this PSR entry. */

 FIXME wrap 12 */

 Clear psr full and toggle the wrap bit */

 Illegal buffer or ring index cannot be used by S/W*/

 Get and fill the RFD. */

	/* In V1 silicon, there is a bug which screws up filtering of runt

	 * packets. Therefore runt packet filtering is disabled in the MAC and

	 * the packets are dropped here. They are also counted here.

 Process up to available RFD's */

		/* Do not receive any packets until a filter has been set.

		 * Do not receive any packets until we have link.

		 * If length is zero, return the RFD in order to advance the

		 * Free buffer ring.

 Watchdog timer will disable itself if appropriate. */

/* et131x_tx_dma_memory_alloc

 *

 * Allocates memory that will be visible both to the device and to the CPU.

 * The OS will pass us packets, pointers to which we will insert in the Tx

 * Descriptor queue. The device will read this queue to find the packets in

 * memory. The device will update the "status" in memory each time it xmits a

 * packet.

 Allocate memory for the TCB's (Transmit Control Block) */

 Free memory relating to Tx rings here */

 Free memory for the Tx status block */

 Free the memory for the tcb structures */

 nic_send_packet - NIC specific send handler for version B silicon. */

	/* Part of the optimizations of this send routine restrict us to

	 * sending 24 fragments at a pass.  In practice we should never see

	 * more than 5 fragments.

 nr_frags should be no more than 18. */

		/* If there is something in this element, lets get a

		 * descriptor from the ring and get the necessary data

			/* If the fragments are smaller than a standard MTU,

			 * then map them to a single descriptor in the Tx

			 * Desc ring. However, if they're larger, as is

			 * possible with support for jumbo packets, then

			 * split them each across 2 descriptors.

			 *

			 * This will work until we determine why the hardware

			 * doesn't seem to like large fragments.

				/* Low 16bits are length, high is vlan and

				 * unused currently so zero

 Last element & Interrupt flag */

 Last element */

 Write the new write pointer back to the device. */

	/* For Gig only, we use Tx Interrupt coalescing.  Enable the software

	 * timer to wake us up if this packet isn't followed by N more.

 All packets must have at least a MAC address and a protocol type */

 Apparently ready Q is empty. */

 free_send_packet - Recycle a struct tcb */

		/* Iterate through the TX descriptors on the ring

		 * corresponding to this packet and umap the fragments

		 * they point to

 Add the TCB to the Ready Q */

 Apparently ready Q is empty. */

 et131x_free_busy_send_packets - Free and complete the stopped active sends */

 Any packets being sent? Check the first TCB on the send list */

/* et131x_handle_send_pkts

 *

 * Re-claim the send resources, complete sends and get more to send from

 * the send wait queue.

	/* Has the ring wrapped?  Process any descriptors that do not have

	 * the same "wrap" indicator as the current completion indicator

 Goto the next packet */

 Goto the next packet */

 Wake up the queue when we hit a low-water mark */

 PHY regs */

 Autoneg next page transmit reg */

 Link partner next page reg */

 Global regs */

 TXDMA regs */

 RXDMA regs */

 et131x_hwaddr_init - set up the MAC Address */

	/* If have our default mac from init and no mac address from

	 * EEPROM then we need to generate the last octet and set it on the

	 * device

		/* We need to randomly generate the last octet so we

		 * decrease our chances of setting the mac address to

		 * same as another one of our cards in the system

		/* We have the default value in the register we are

		 * working with so we need to copy the current

		 * address into the permanent address

		/* We do not have an override address, so set the

		 * current address to the permanent address and add

		 * it to the device

 Program the Ack/Nak latency and replay timers */

	/* l0s and l1 latency timers.  We are using default values.

	 * Representing 001 for L0s and 010 for L1

 Change the max read size to 2k */

	/* Get MAC address from config space if an eeprom exists, otherwise

	 * the MAC address there will not be valid

/* et131x_error_timer_handler

 * @data: timer-specific variable; here a pointer to our adapter structure

 *

 * The routine called when the error timer expires, to track the number of

 * recurring errors.

		/* Bring the device immediately out of coma, to

		 * prevent it from sleeping indefinitely, this

		 * mechanism could be improved!

				/* NOTE - This was originally a 'sync with

				 *  interrupt'. How to do that under Linux?

 This is a periodic timer, so reschedule */

	/* Check to see if we are in coma mode and if

	 * so, disable it because we will not be able

	 * to read PHY values until we are out.

		/* Bring the device back to the state it was during

		 * init prior to autonegotiation being complete. This

		 * way, when we get the auto-neg complete interrupt,

		 * we can complete init by calling config_mac_regs2.

 1514-9216 */

 Save the timestamp for the TX watchdog, prevent a timeout */

 Make sure this is our interrupt */

 This is our interrupt, so process accordingly */

 Following read also clears the register (COR) */

		/* This indicates the number of unused buffers in RXDMA free

		 * buffer ring 0 is <= the limit you programmed. Free buffer

		 * resources need to be returned.  Free buffers are consumed as

		 * packets are passed from the network to the host. The host

		 * becomes aware of the packets from the contents of the packet

		 * status ring. This ring is queried when the packet done

		 * interrupt occurs. Packets are then passed to the OS. When

		 * the OS is done with the packets the resources can be

		 * returned to the ET1310 for re-use. This interrupt is one

		 * method of returning resources.

		/*  If the user has flow control on, then we will

		 * send a pause packet, otherwise just exit

			/* Tell the device to send a pause packet via the back

			 * pressure register (bp req and bp xon/xoff)

 Handle Packet Status Ring Low Interrupt */

		/* Same idea as with the two Free Buffer Rings. Packets going

		 * from the network to the host each consume a free buffer

		 * resource and a packet status resource. These resources are

		 * passed to the OS. When the OS is done with the resources,

		 * they need to be returned to the ET1310. This is one method

		 * of returning the resources.

		/* The rxdma_error interrupt is sent when a time-out on a

		 * request issued by the JAGCore has occurred or a completion is

		 * returned with an un-successful status. In both cases the

		 * request is considered complete. The JAGCore will

		 * automatically re-try the request in question. Normally

		 * information on events like these are sent to the host using

		 * the "Advanced Error Reporting" capability. This interrupt is

		 * another way of getting similar information. The only thing

		 * required is to clear the interrupt by reading the ISR in the

		 * global resources. The JAGCore will do a re-try on the

		 * request. Normally you should never see this interrupt. If

		 * you start to see this interrupt occurring frequently then

		 * something bad has occurred. A reset might be the thing to do.

 TRAP();*/

 Handle the Wake on LAN Event */

		/* This is a secondary interrupt for wake on LAN. The driver

		 * should never see this, if it does, something serious is

		 * wrong.

		/* When any of the errors occur and TXMAC generates an

		 * interrupt to report these errors, it usually means that

		 * TXMAC has detected an error in the data stream retrieved

		 * from the on-chip Tx Q. All of these errors are catastrophic

		 * and TXMAC won't be able to recover data when these errors

		 * occur. In a nutshell, the whole Tx path will have to be reset

		 * and re-configured afterwards.

		/* If we are debugging, we want to see this error, otherwise we

		 * just want the device to be reset and continue

		/* These interrupts are catastrophic to the device, what we need

		 * to do is disable the interrupts and set the flag to cause us

		 * to reset so we can solve this issue.

		/* If we are debugging, we want to see this error, otherwise we

		 * just want the device to be reset and continue

		/* This means at least one of the un-masked counters in the

		 * MAC_STAT block has rolled over. Use this to maintain the top,

		 * software managed bits of the counter(s).

		/* This means a timeout has occurred on a read or write request

		 * to one of the JAGCore registers. The Global Resources block

		 * has terminated the request and on a read request, returned a

		 * "fake" value. The most likely reasons are: Bad Address or the

		 * addressed module is in a power-down state and can't respond.

 et131x_stats - Return the current device statistics  */

 NOTE: Not used, can't find analogous statistics */

 stats->rx_frame_errors     = devstat->; */

 stats->rx_fifo_errors      = devstat->; */

 stats->rx_missed_errors    = devstat->; */

 stats->tx_aborted_errors   = devstat->; */

 stats->tx_carrier_errors   = devstat->; */

 stats->tx_fifo_errors      = devstat->; */

 stats->tx_heartbeat_errors = devstat->; */

 stats->tx_window_errors    = devstat->; */

 Start the timer to track NIC errors */

 Stop the error timer */

 et131x_set_packet_filter - Configures the Rx Packet filtering */

 Default to disabled packet filtering */

	/* Set us to be in promiscuous mode so we receive everything, this

	 * is also true when we get a packet filter of 0

 Clear filter bits */

		/* Set us up with Multicast packet filtering.  Three cases are

		 * possible - (1) we have a multi-cast list, (2) we receive ALL

		 * multicast entries or (3) we receive none.

 Multicast filter bit */

 Set us up with Unicast packet filtering */

 Set us up with Broadcast packet filtering */

 Broadcast filter bit */

		/* Setup the receive mac configuration registers - Packet

		 * Filter control + the enable / disable for packet filter

		 * in the control reg.

	/* Before we modify the platform-independent filter flags, store them

	 * locally. This allows us to determine if anything's changed and if

	 * we even need to bother the hardware

	/* Clear the 'multicast' flag locally; because we only have a single

	 * flag to check multicast, and multiple multicast addresses can be

	 * set, this is the easiest way to determine if more than one

	 * multicast address is being set.

	/* Check the net_device flags and set the device independent flags

	 * accordingly

 Set values in the private adapter struct */

	/* Are the new flags different from the previous ones? If not, then no

	 * action is required

	 *

	 * NOTE - This block will always update the multicast_list with the

	 *        hardware, even if the addresses aren't the same.

 stop the queue if it's getting full */

 Save the timestamp for the TX timeout watchdog */

 TCB is not available */

/* et131x_tx_timeout - Timeout handler

 *

 * The handler called when a Tx request times out. The timeout period is

 * specified by the 'tx_timeo" element in the net_device structure (see

 * et131x_alloc_device() to see how this value is set).

 If the device is closed, ignore the timeout */

	/* Any nonrecoverable hardware error?

	 * Checks adapter->flags for any failure in phy reading

 Hardware failure? */

 Is send stuck? */

 perform reset of tx/rx */

 Set the config parameter for Jumbo Packet support */

 Init the device with the new settings */

 Perform some basic PCI checks */

 Check the DMA addressing support of this device */

 Map the bus-relative registers to system virtual memory */

 If Phy COMA mode was enabled when we went down, disable it here. */

 Init variable for counting how long we do not have link status */

	/* We can enable interrupts now

	 *

	 *  NOTE - Because registration of interrupt handler is done in the

	 *         device's open(), defer enabling device interrupts to that

	 *         point

	/* Register the net_device struct with the PCI subsystem. Save a copy

	 * of the PCI config space for this device now that the device has

	 * been initialized, just in case it needs to be quickly restored.

 SPDX-License-Identifier: GPL-2.0-only

/* Huawei HiNIC PCI Express Linux driver

 * Copyright(c) 2017 Huawei Technologies Co., Ltd

 The size of data to be sended (unit of 4 bytes) */

 SO_RO(strong order, relax order) */

/* specifies the issue request for the message data.

 * 0 - Tx request is done;

 * 1 - Tx request is in process.

/* specifies the mailbox message direction

 * 0 - send

 * 1 - receive

 MBOX size is 64B, 8B for mbox_header, 4B reserved */

 mbox write back status is 16B, only first 4B is used */

 max message counter wait to process for one function */

/**

 * hinic_register_pf_mbox_cb - register mbox callback for pf

 * @hwdev: the pointer to hw device

 * @mod:	specific mod that the callback will handle

 * @callback:	callback function

 * Return: 0 - success, negative - failure

/**

 * hinic_register_vf_mbox_cb - register mbox callback for vf

 * @hwdev: the pointer to hw device

 * @mod:	specific mod that the callback will handle

 * @callback:	callback function

 * Return: 0 - success, negative - failure

/**

 * hinic_unregister_pf_mbox_cb - unregister the mbox callback for pf

 * @hwdev:	the pointer to hw device

 * @mod:	specific mod that the callback will handle

/**

 * hinic_unregister_vf_mbox_cb - unregister the mbox callback for vf

 * @hwdev:	the pointer to hw device

 * @mod:	specific mod that the callback will handle

 clear mailbox write back status */

 The mbox message should be aligned in 4 bytes. */

 writing the mbox int attributes */

 write back is 16B, but only use first 4B */

 verify reading before check */

 writing the mbox msg attributes */

 The vf's offset to it's associated pf */

 if no data needs to response, set out_size to 1 */

	/* vf_offset_to_pf + vf_id is the vf's global function id of vf in

	 * this pf

 VF must use 0-level CLA */

	/* destroy workqueue before free related mbox resources in case of

	 * illegal resource access

 SPDX-License-Identifier: GPL-2.0

/* Huawei HiNIC PCI Express Linux driver

 * Copyright(c) 2017 Huawei Technologies Co., Ltd

 *

 * This program is free software; you can redistribute it and/or modify it

 * under the terms and conditions of the GNU General Public License,

 * version 2, as published by the Free Software Foundation.

 *

 * This program is distributed in the hope it will be useful, but WITHOUT

 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or

 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License

 * for more details.

 *

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Huawei HiNIC PCI Express Linux driver

 * Copyright(c) 2017 Huawei Technologies Co., Ltd

/**

 * hinic_rxq_clean_stats - Clean the statistics of specific queue

 * @rxq: Logical Rx Queue

/**

 * hinic_rxq_get_stats - get statistics of Rx Queue

 * @rxq: Logical Rx Queue

 * @stats: return updated stats here

/**

 * rxq_stats_init - Initialize the statistics of specific queue

 * @rxq: Logical Rx Queue

/**

 * rx_alloc_skb - allocate skb and map it to dma address

 * @rxq: rx queue

 * @dma_addr: returned dma address for the skb

 *

 * Return skb

/**

 * rx_unmap_skb - unmap the dma address of the skb

 * @rxq: rx queue

 * @dma_addr: dma address of the skb

/**

 * rx_free_skb - unmap and free skb

 * @rxq: rx queue

 * @skb: skb to free

 * @dma_addr: dma address of the skb

/**

 * rx_alloc_pkts - allocate pkts in rx queue

 * @rxq: rx queue

 *

 * Return number of skbs allocated

 Limit the allocation chunks */

 write all the wqes before update PI */

/**

 * free_all_rx_skbs - free all skbs in rx queue

 * @rxq: rx queue

/**

 * rx_recv_jumbo_pkt - Rx handler for jumbo pkt

 * @rxq: rx queue

 * @head_skb: the first skb in the list

 * @left_pkt_len: left size of the pkt exclude head skb

 * @ci: consumer index

 *

 * Return number of wqes that used for the left of the pkt

/**

 * rxq_recv - Rx handler

 * @rxq: rx queue

 * @budget: maximum pkts to process

 *

 * Return number of pkts received

 make sure we read rx_done before packet length */

 Disable the interrupt until napi will be completed */

/**

 * hinic_init_rxq - Initialize the Rx Queue

 * @rxq: Logical Rx Queue

 * @rq: Hardware Rx Queue to connect the Logical queue with

 * @netdev: network device to connect the Logical queue with

 *

 * Return 0 - Success, negative - Failure

/**

 * hinic_clean_rxq - Clean the Rx Queue

 * @rxq: Logical Rx Queue

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Huawei HiNIC PCI Express Linux driver

 * Copyright(c) 2017 Huawei Technologies Co., Ltd

 Sizes of the members in hinic_api_cmd_cell */

 cell data is passed by hw address */

/**

 * chain_busy - check if the chain is still processing last requests

 * @chain: chain to check

 *

 * Return 0 - Success, negative - Failure

 check for a space for a new command */

/**

 * get_cell_data_size - get the data size of a specific cell type

 * @type: chain type

 *

 * Return the data(Desc + Address) size in the cell

/**

 * prepare_cell_ctrl - prepare the ctrl of the cell for the command

 * @cell_ctrl: the control of the cell to set the control value into it

 * @data_size: the size of the data in the cell

 The data in the HW should be in Big Endian Format */

/**

 * prepare_api_cmd - prepare API CMD command

 * @chain: chain for the command

 * @dest: destination node on the card that will receive the command

 * @cmd: command data

 * @cmd_size: the command size

 The data in the HW should be in Big Endian Format */

/**

 * prepare_cell - prepare cell ctrl and cmd in the current cell

 * @chain: chain for the command

 * @dest: destination node on the card that will receive the command

 * @cmd: command data

 * @cmd_size: the command size

 *

 * Return 0 - Success, negative - Failure

/**

 * api_cmd_status_update - update the status in the chain struct

 * @chain: chain to update

/**

 * wait_for_status_poll - wait for write to api cmd command to complete

 * @chain: the chain of the command

 *

 * Return 0 - Success, negative - Failure

 wait for CI to be updated - sign for completion */

/**

 * wait_for_api_cmd_completion - wait for command to complete

 * @chain: chain for the command

 *

 * Return 0 - Success, negative - Failure

/**

 * api_cmd - API CMD command

 * @chain: chain for the command

 * @dest: destination node on the card that will receive the command

 * @cmd: command data

 * @cmd_size: the command size

 *

 * Return 0 - Success, negative - Failure

 inc pi before issue the command */

 issue the command */

/**

 * hinic_api_cmd_write - Write API CMD command

 * @chain: chain for write command

 * @dest: destination node on the card that will receive the command

 * @cmd: command data

 * @size: the command size

 *

 * Return 0 - Success, negative - Failure

 Verify the chain type */

/**

 * api_cmd_hw_restart - restart the chain in the HW

 * @chain: the API CMD specific chain to restart

 *

 * Return 0 - Success, negative - Failure

 Read Modify Write */

/**

 * api_cmd_ctrl_init - set the control register of a chain

 * @chain: the API CMD specific chain to set control register for

 Read Modify Write */

/**

 * api_cmd_set_status_addr - set the status address of a chain in the HW

 * @chain: the API CMD specific chain to set in HW status address for

/**

 * api_cmd_set_num_cells - set the number cells of a chain in the HW

 * @chain: the API CMD specific chain to set in HW the number of cells for

/**

 * api_cmd_head_init - set the head of a chain in the HW

 * @chain: the API CMD specific chain to set in HW the head for

/**

 * api_cmd_chain_hw_clean - clean the HW

 * @chain: the API CMD specific chain

/**

 * api_cmd_chain_hw_init - initialize the chain in the HW

 * @chain: the API CMD specific chain to initialize in HW

 *

 * Return 0 - Success, negative - Failure

/**

 * free_cmd_buf - free the dma buffer of API CMD command

 * @chain: the API CMD specific chain of the cmd

 * @cell_idx: the cell index of the cmd

/**

 * alloc_cmd_buf - allocate a dma buffer for API CMD command

 * @chain: the API CMD specific chain for the cmd

 * @cell: the cell in the HW for the cmd

 * @cell_idx: the index of the cell

 *

 * Return 0 - Success, negative - Failure

 set the cmd DMA address in the cell */

 The data in the HW should be in Big Endian Format */

/**

 * api_cmd_create_cell - create API CMD cell for specific chain

 * @chain: the API CMD specific chain to create its cell

 * @cell_idx: the index of the cell to create

 * @pre_node: previous cell

 * @node_vaddr: the returned virt addr of the cell

 *

 * Return 0 - Success, negative - Failure

 The data in the HW should be in Big Endian Format */

/**

 * api_cmd_destroy_cell - destroy API CMD cell of specific chain

 * @chain: the API CMD specific chain to destroy its cell

 * @cell_idx: the cell to destroy

/**

 * api_cmd_destroy_cells - destroy API CMD cells of specific chain

 * @chain: the API CMD specific chain to destroy its cells

 * @num_cells: number of cells to destroy

/**

 * api_cmd_create_cells - create API CMD cells for specific chain

 * @chain: the API CMD specific chain

 *

 * Return 0 - Success, negative - Failure

 set the Final node to point on the start */

 set the current node to be the head */

/**

 * api_chain_init - initialize API CMD specific chain

 * @chain: the API CMD specific chain to initialize

 * @attr: attributes to set in the chain

 *

 * Return 0 - Success, negative - Failure

/**

 * api_chain_free - free API CMD specific chain

 * @chain: the API CMD specific chain to free

/**

 * api_cmd_create_chain - create API CMD specific chain

 * @attr: attributes to set the chain

 *

 * Return the created chain

/**

 * api_cmd_destroy_chain - destroy API CMD specific chain

 * @chain: the API CMD specific chain to destroy

/**

 * hinic_api_cmd_init - Initialize all the API CMD chains

 * @chain: the API CMD chains that are initialized

 * @hwif: the hardware interface of a pci function device

 *

 * Return 0 - Success, negative - Failure

/**

 * hinic_api_cmd_free - free the API CMD chains

 * @chain: the API CMD chains that are freed

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Huawei HiNIC PCI Express Linux driver

 * Copyright(c) 2017 Huawei Technologies Co., Ltd

/**

 * queue_alloc_page - allocate page for Queue

 * @hwif: HW interface for allocating DMA

 * @vaddr: virtual address will be returned in this address

 * @paddr: physical address will be returned in this address

 * @shadow_vaddr: VM area will be return here for holding WQ page addresses

 * @page_sz: page size of each WQ page

 *

 * Return 0 - Success, negative - Failure

 use vzalloc for big mem */

/**

 * wqs_allocate_page - allocate page for WQ set

 * @wqs: Work Queue Set

 * @page_idx: the page index of the page will be allocated

 *

 * Return 0 - Success, negative - Failure

/**

 * wqs_free_page - free page of WQ set

 * @wqs: Work Queue Set

 * @page_idx: the page index of the page will be freed

/**

 * cmdq_allocate_page - allocate page for cmdq

 * @cmdq_pages: the pages of the cmdq queue struct to hold the page

 *

 * Return 0 - Success, negative - Failure

/**

 * cmdq_free_page - free page from cmdq

 * @cmdq_pages: the pages of the cmdq queue struct that hold the page

 *

 * Return 0 - Success, negative - Failure

/**

 * hinic_wqs_alloc - allocate Work Queues set

 * @wqs: Work Queue Set

 * @max_wqs: maximum wqs to allocate

 * @hwif: HW interface for use for the allocation

 *

 * Return 0 - Success, negative - Failure

/**

 * hinic_wqs_free - free Work Queues set

 * @wqs: Work Queue Set

/**

 * alloc_wqes_shadow - allocate WQE shadows for WQ

 * @wq: WQ to allocate shadows for

 *

 * Return 0 - Success, negative - Failure

/**

 * free_wqes_shadow - free WQE shadows of WQ

 * @wq: WQ to free shadows from

/**

 * free_wq_pages - free pages of WQ

 * @hwif: HW interface for releasing dma addresses

 * @wq: WQ to free pages from

 * @num_q_pages: number pages to free

/**

 * alloc_wq_pages - alloc pages for WQ

 * @hwif: HW interface for allocating dma addresses

 * @wq: WQ to allocate pages for

 * @max_pages: maximum pages allowed

 *

 * Return 0 - Success, negative - Failure

 HW uses Big Endian Format */

/**

 * hinic_wq_allocate - Allocate the WQ resources from the WQS

 * @wqs: WQ set from which to allocate the WQ resources

 * @wq: WQ to allocate resources for it from the WQ set

 * @wqebb_size: Work Queue Block Byte Size

 * @wq_page_size: the page size in the Work Queue

 * @q_depth: number of wqebbs in WQ

 * @max_wqe_size: maximum WQE size that will be used in the WQ

 *

 * Return 0 - Success, negative - Failure

/**

 * hinic_wq_free - Free the WQ resources to the WQS

 * @wqs: WQ set to free the WQ resources to it

 * @wq: WQ to free its resources to the WQ set resources

/**

 * hinic_wqs_cmdq_alloc - Allocate wqs for cmdqs

 * @cmdq_pages: will hold the pages of the cmdq

 * @wq: returned wqs

 * @hwif: HW interface

 * @cmdq_blocks: number of cmdq blocks/wq to allocate

 * @wqebb_size: Work Queue Block Byte Size

 * @wq_page_size: the page size in the Work Queue

 * @q_depth: number of wqebbs in WQ

 * @max_wqe_size: maximum WQE size that will be used in the WQ

 *

 * Return 0 - Success, negative - Failure

/**

 * hinic_wqs_cmdq_free - Free wqs from cmdqs

 * @cmdq_pages: hold the pages of the cmdq

 * @wq: wqs to free

 * @cmdq_blocks: number of wqs to free

/**

 * hinic_get_wqe - get wqe ptr in the current pi and update the pi

 * @wq: wq to get wqe from

 * @wqe_size: wqe size

 * @prod_idx: returned pi

 *

 * Return wqe pointer

 end prod index points to the next wqebb, therefore minus 1 */

	/* If we only have one page, still need to get shadown wqe when

	 * wqe rolling-over page

/**

 * hinic_return_wqe - return the wqe when transmit failed

 * @wq: wq to return wqe

 * @wqe_size: wqe size

/**

 * hinic_put_wqe - return the wqe place to use for a new wqe

 * @wq: wq to return wqe

 * @wqe_size: wqe size

/**

 * hinic_read_wqe - read wqe ptr in the current ci

 * @wq: wq to get read from

 * @wqe_size: wqe size

 * @cons_idx: returned ci

 *

 * Return wqe pointer

/**

 * hinic_read_wqe_direct - read wqe directly from ci position

 * @wq: wq

 * @cons_idx: ci position

 *

 * Return wqe

/**

 * wqe_shadow - check if a wqe is shadow

 * @wq: wq of the wqe

 * @wqe: the wqe for shadow checking

 *

 * Return true - shadow, false - Not shadow

/**

 * hinic_write_wqe - write the wqe to the wq

 * @wq: wq to write wqe to

 * @wqe: wqe to write

 * @wqe_size: wqe size

 SPDX-License-Identifier: GPL-2.0

/* Huawei HiNIC PCI Express Linux driver

 * Copyright(c) 2017 Huawei Technologies Co., Ltd

 *

 * This program is free software; you can redistribute it and/or modify it

 * under the terms and conditions of the GNU General Public License,

 * version 2, as published by the Free Software Foundation.

 *

 * This program is distributed in the hope it will be useful, but WITHOUT

 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or

 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License

 * for more details.

 *

 seconds */

 always set autonegotiation */

 set speed only when autoneg is disabled */

 only support to set autoneg and speed */

 get tx/rx irq0 as default parameters */

 coalesce_timer is in unit of 9us */

 coalesced_frames is in unit of 8 */

	/* netdev not running or qp not in using,

	 * don't need to set coalesce to hw

	/* setting coalesce timer or pending limit to zero will disable

	 * coalesce

	/* RSS does not support anything other than hashing

	 * to queues on src and dst IPs and ports

 We need at least the IP SRC and DEST fields for hashing */

 mark index for every pkt */

 wait till all pkts received to RX buffer */

 don't support loopback test when netdev is closed. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Huawei HiNIC PCI Express Linux driver

 * Copyright(c) 2017 Huawei Technologies Co., Ltd

/**

 * change_mac - change(add or delete) mac address

 * @nic_dev: nic device

 * @addr: mac address

 * @vlan_id: vlan number to set with the mac

 * @op: add or delete the mac

 *

 * Return 0 - Success, negative - Failure

/**

 * hinic_port_add_mac - add mac address

 * @nic_dev: nic device

 * @addr: mac address

 * @vlan_id: vlan number to set with the mac

 *

 * Return 0 - Success, negative - Failure

/**

 * hinic_port_del_mac - remove mac address

 * @nic_dev: nic device

 * @addr: mac address

 * @vlan_id: vlan number that is connected to the mac

 *

 * Return 0 - Success, negative - Failure

/**

 * hinic_port_get_mac - get the mac address of the nic device

 * @nic_dev: nic device

 * @addr: returned mac address

 *

 * Return 0 - Success, negative - Failure

/**

 * hinic_port_set_mtu - set mtu

 * @nic_dev: nic device

 * @new_mtu: new mtu

 *

 * Return 0 - Success, negative - Failure

/**

 * hinic_port_add_vlan - add vlan to the nic device

 * @nic_dev: nic device

 * @vlan_id: the vlan number to add

 *

 * Return 0 - Success, negative - Failure

/**

 * hinic_port_del_vlan - delete vlan from the nic device

 * @nic_dev: nic device

 * @vlan_id: the vlan number to delete

 *

 * Return 0 - Success, negative - Failure

/**

 * hinic_port_set_rx_mode - set rx mode in the nic device

 * @nic_dev: nic device

 * @rx_mode: the rx mode to set

 *

 * Return 0 - Success, negative - Failure

/**

 * hinic_port_link_state - get the link state

 * @nic_dev: nic device

 * @link_state: the returned link state

 *

 * Return 0 - Success, negative - Failure

/**

 * hinic_port_set_state - set port state

 * @nic_dev: nic device

 * @state: the state to set

 *

 * Return 0 - Success, negative - Failure

/**

 * hinic_port_set_func_state- set func device state

 * @nic_dev: nic device

 * @state: the state to set

 *

 * Return 0 - Success, negative - Failure

/**

 * hinic_port_get_cap - get port capabilities

 * @nic_dev: nic device

 * @port_cap: returned port capabilities

 *

 * Return 0 - Success, negative - Failure

/**

 * hinic_port_set_tso - set port tso configuration

 * @nic_dev: nic device

 * @state: the tso state to set

 *

 * Return 0 - Success, negative - Failure

 For this case, we think status (0xFF) is OK */

 cfg the rss indirect table by command queue */

 cfg the rss context table by command queue */

 pause settings is opposite from pfc */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Huawei HiNIC PCI Express Linux driver

 * Copyright(c) 2017 Huawei Technologies Co., Ltd

/**

 * parse_capability - convert device capabilities to NIC capabilities

 * @hwdev: the HW device to set and convert device capabilities for

 * @dev_cap: device capabilities from FW

 *

 * Return 0 - Success, negative - Failure

 Each QP has its own (SQ + RQ) interrupts */

/**

 * get_capability - get device capabilities from FW

 * @pfhwdev: the PF HW device to get capabilities for

 *

 * Return 0 - Success, negative - Failure

/**

 * get_dev_cap - get device capabilities

 * @hwdev: the NIC HW device to get capabilities for

 *

 * Return 0 - Success, negative - Failure

/**

 * init_msix - enable the msix and save the entries

 * @hwdev: the NIC HW device

 *

 * Return 0 - Success, negative - Failure

/**

 * disable_msix - disable the msix

 * @hwdev: the NIC HW device

/**

 * hinic_port_msg_cmd - send port msg to mgmt

 * @hwdev: the NIC HW device

 * @cmd: the port command

 * @buf_in: input buffer

 * @in_size: input size

 * @buf_out: output buffer

 * @out_size: returned output size

 *

 * Return 0 - Success, negative - Failure

/**

 * init_fw_ctxt- Init Firmware tables before network mgmt and io operations

 * @hwdev: the NIC HW device

 *

 * Return 0 - Success, negative - Failure

/**

 * set_hw_ioctxt - set the shape of the IO queues in FW

 * @hwdev: the NIC HW device

 * @rq_depth: rq depth

 * @sq_depth: sq depth

 *

 * Return 0 - Success, negative - Failure

/**

 * clear_io_resources - set the IO resources as not active in the NIC

 * @hwdev: the NIC HW device

 *

 * Return 0 - Success, negative - Failure

 sleep 100ms to wait for firmware stopping I/O */

/**

 * set_resources_state - set the state of the resources in the NIC

 * @hwdev: the NIC HW device

 * @state: the state to set

 *

 * Return 0 - Success, negative - Failure

/**

 * get_base_qpn - get the first qp number

 * @hwdev: the NIC HW device

 * @base_qpn: returned qp number

 *

 * Return 0 - Success, negative - Failure

/**

 * hinic_hwdev_ifup - Preparing the HW for passing IO

 * @hwdev: the NIC HW device

 * @sq_depth: the send queue depth

 * @rq_depth: the receive queue depth

 *

 * Return 0 - Success, negative - Failure

/**

 * hinic_hwdev_ifdown - Closing the HW for passing IO

 * @hwdev: the NIC HW device

 *

/**

 * hinic_hwdev_cb_register - register callback handler for MGMT events

 * @hwdev: the NIC HW device

 * @cmd: the mgmt event

 * @handle: private data for the handler

 * @handler: event handler

/**

 * hinic_hwdev_cb_unregister - unregister callback handler for MGMT events

 * @hwdev: the NIC HW device

 * @cmd: the mgmt event

/**

 * nic_mgmt_msg_handler - nic mgmt event handler

 * @handle: private data for the handler

 * @cmd: message command

 * @buf_in: input buffer

 * @in_size: input size

 * @buf_out: output buffer

 * @out_size: returned output size

 pf fault report event */

/**

 * init_pfhwdev - Initialize the extended components of PF

 * @pfhwdev: the HW device for PF

 *

 * Return 0 - success, negative - failure

/**

 * free_pfhwdev - Free the extended components of PF

 * @pfhwdev: the HW device for PF

 0 represents standard l2nic reset flow */

/**

 * hinic_init_hwdev - Initialize the NIC HW

 * @pdev: the NIC pci device

 * @devlink: the poniter of hinic devlink

 *

 * Return initialized NIC HW device

 *

 * Initialize the NIC HW device and return a pointer to it

/**

 * hinic_free_hwdev - Free the NIC HW device

 * @hwdev: the NIC HW device

/**

 * hinic_hwdev_num_qps - return the number QPs available for use

 * @hwdev: the NIC HW device

 *

 * Return number QPs available for use

/**

 * hinic_hwdev_get_sq - get SQ

 * @hwdev: the NIC HW device

 * @i: the position of the SQ

 *

 * Return: the SQ in the i position

/**

 * hinic_hwdev_get_rq - get RQ

 * @hwdev: the NIC HW device

 * @i: the position of the RQ

 *

 * Return: the RQ in the i position

/**

 * hinic_hwdev_msix_cnt_set - clear message attribute counters for msix entry

 * @hwdev: the NIC HW device

 * @msix_index: msix_index

 *

 * Return 0 - Success, negative - Failure

/**

 * hinic_hwdev_msix_set - set message attribute for msix entry

 * @hwdev: the NIC HW device

 * @msix_index: msix_index

 * @pending_limit: the maximum pending interrupt events (unit 8)

 * @coalesc_timer: coalesc period for interrupt (unit 8 us)

 * @lli_timer_cfg: replenishing period for low latency credit (unit 8 us)

 * @lli_credit_limit: maximum credits for low latency msix messages (unit 8)

 * @resend_timer: maximum wait for resending msix (unit coalesc period)

 *

 * Return 0 - Success, negative - Failure

/**

 * hinic_hwdev_hw_ci_addr_set - set cons idx addr and attributes in HW for sq

 * @hwdev: the NIC HW device

 * @sq: send queue

 * @pending_limit: the maximum pending update ci events (unit 8)

 * @coalesc_timer: coalesc period for update ci (unit 8 us)

 *

 * Return 0 - Success, negative - Failure

/**

 * hinic_hwdev_set_msix_state- set msix state

 * @hwdev: the NIC HW device

 * @msix_index: IRQ corresponding index number

 * @flag: msix state

 *

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Huawei HiNIC PCI Express Linux driver

 * Copyright(c) 2017 Huawei Technologies Co., Ltd

/**

 * hinic_txq_clean_stats - Clean the statistics of specific queue

 * @txq: Logical Tx Queue

/**

 * hinic_txq_get_stats - get statistics of Tx Queue

 * @txq: Logical Tx Queue

 * @stats: return updated stats here

/**

 * txq_stats_init - Initialize the statistics of specific queue

 * @txq: Logical Tx Queue

/**

 * tx_map_skb - dma mapping for skb and return sges

 * @nic_dev: nic device

 * @skb: the skb

 * @sges: returned sges

 *

 * Return 0 - Success, negative - Failure

/**

 * tx_unmap_skb - unmap the dma address of the skb

 * @nic_dev: nic device

 * @skb: the skb

 * @sges: the sges that are connected to the skb

 doff in unit of 4B */

 only csum offload support sctp */

 initialize inner IP header fields */

 Unsupported tunnel packet, disable csum offload */

 payload offset should not more than 221 */

 mss should not less than 80 */

		/* Check for the case free_tx_poll is called in another cpu

		 * and we stopped the subqueue after free_tx_poll check.

/**

 * tx_free_skb - unmap and free skb

 * @nic_dev: nic device

 * @skb: the skb

 * @sges: the sges that are connected to the skb

/**

 * free_all_tx_skbs - free all skbs in tx queue

 * @txq: tx queue

/**

 * free_tx_poll - free finished tx skbs in tx queue that connected to napi

 * @napi: napi

 * @budget: number of tx

 *

 * Return 0 - Success, negative - Failure

 Reading a WQEBB to get real WQE size and consumer index. */

		/* If this WQE have multiple WQEBBs, we will read again to get

		 * full size WQE.

 Disable the interrupt until napi will be completed */

/**

 * hinic_init_txq - Initialize the Tx Queue

 * @txq: Logical Tx Queue

 * @sq: Hardware Tx Queue to connect the Logical queue with

 * @netdev: network device to connect the Logical queue with

 *

 * Return 0 - Success, negative - Failure

/**

 * hinic_clean_txq - Clean the Tx Queue

 * @txq: Logical Tx Queue

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Huawei HiNIC PCI Express Linux driver

 * Copyright(c) 2017 Huawei Technologies Co., Ltd

 16 bytes - 2(8 byte unit) */

 24 bytes - 3(8 byte unit) */

 4 bytes (ctrl) - 1(8 byte unit) */

 12 bytes (ctrl + rsvd) - 2(8 byte unit) */

/**

 * hinic_alloc_cmdq_buf - alloc buffer for sending command

 * @cmdqs: the cmdqs

 * @cmdq_buf: the buffer returned in this struct

 *

 * Return 0 - Success, negative - Failure

/**

 * hinic_free_cmdq_buf - free buffer

 * @cmdqs: the cmdqs

 * @cmdq_buf: the buffer to free that is in this struct

 The first 8 bytes should be written last */

 The data that is written to HW should be in Big Endian Format */

 write all before the doorbell */

 Keep doorbell index correct. bh - for tasklet(ceq). */

 WQE_SIZE = WQEBB_SIZE, we will get the wq element and not shadow*/

 The data that is written to HW should be in Big Endian Format */

 CMDQ WQE is not shadow, therefore wqe will be written to wq */

 read error code after completion */

 Keep doorbell index correct */

 WQE_SIZE = WQEBB_SIZE, we will get the wq element and not shadow*/

 The data that is written to HW should be in Big Endian Format */

 cmdq wqe is not shadow, therefore wqe will be written to wq */

/**

 * hinic_cmdq_direct_resp - send command with direct data as resp

 * @cmdqs: the cmdqs

 * @mod: module on the card that will handle the command

 * @cmd: the command

 * @buf_in: the buffer for the command

 * @resp: the response to return

 *

 * Return 0 - Success, negative - Failure

/**

 * hinic_set_arm_bit - set arm bit for enable interrupt again

 * @cmdqs: the cmdqs

 * @q_type: type of queue to set the arm bit for

 * @q_id: the queue number

 *

 * Return 0 - Success, negative - Failure

 clear HW busy bit */

 verify wqe is clear */

/**

 * cmdq_arm_ceq_handler - cmdq completion event handler for arm command

 * @cmdq: the cmdq of the arm command

 * @wqe: the wqe of the arm command

 *

 * Return 0 - Success, negative - Failure

 HW should toggle the HW BUSY BIT */

/**

 * cmdq_sync_cmd_handler - cmdq completion event handler for sync command

 * @cmdq: the cmdq of the command

 * @cons_idx: the consumer index to update the error code for

 * @errcode: the error code

 write all before update for the command request */

/**

 * cmdq_ceq_handler - cmdq completion event handler

 * @handle: private data for the handler(cmdqs)

 * @ceqe_data: ceq element data

 Read the smallest wqe size for getting wqe size */

 arm_bit was set until here */

/**

 * cmdq_init_queue_ctxt - init the queue ctxt of a cmdq

 * @cmdq_ctxt: cmdq ctxt to initialize

 * @cmdq: the cmdq

 * @cmdq_pages: the memory of the queue

 The data in the HW is in Big Endian Format */

 block PFN - Read Modify Write */

/**

 * init_cmdq - initialize cmdq

 * @cmdq: the cmdq

 * @wq: the wq attaced to the cmdq

 * @q_type: the cmdq type of the cmdq

 * @db_area: doorbell area for the cmdq

 *

 * Return 0 - Success, negative - Failure

/**

 * free_cmdq - Free cmdq

 * @cmdq: the cmdq to free

/**

 * init_cmdqs_ctxt - write the cmdq ctxt to HW after init all cmdq

 * @hwdev: the NIC HW device

 * @cmdqs: cmdqs to write the ctxts for

 * @db_area: db_area for all the cmdqs

 *

 * Return 0 - Success, negative - Failure

 Write the CMDQ ctxts */

/**

 * hinic_init_cmdqs - init all cmdqs

 * @cmdqs: cmdqs to init

 * @hwif: HW interface for accessing cmdqs

 * @db_area: doorbell areas for all the cmdqs

 *

 * Return 0 - Success, negative - Failure

/**

 * hinic_free_cmdqs - free all cmdqs

 * @cmdqs: cmdqs to free

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Huawei HiNIC PCI Express Linux driver

 * Copyright(c) 2017 Huawei Technologies Co., Ltd

 The number of cache line to prefetch Until threshold state */

 The number of cache line to prefetch After threshold state */

 Threshold state */

 sizes of the SQ/RQ ctxt */

 Read the first page paddr from the WQ page paddr ptrs */

 If only one page, use 0-level CLA */

 Read the first page paddr from the WQ page paddr ptrs */

/**

 * alloc_sq_skb_arr - allocate sq array for saved skb

 * @sq: HW Send Queue

 *

 * Return 0 - Success, negative - Failure

/**

 * free_sq_skb_arr - free sq array for saved skb

 * @sq: HW Send Queue

/**

 * alloc_rq_skb_arr - allocate rq array for saved skb

 * @rq: HW Receive Queue

 *

 * Return 0 - Success, negative - Failure

/**

 * free_rq_skb_arr - free rq array for saved skb

 * @rq: HW Receive Queue

/**

 * hinic_init_sq - Initialize HW Send Queue

 * @sq: HW Send Queue

 * @hwif: HW Interface for accessing HW

 * @wq: Work Queue for the data of the SQ

 * @entry: msix entry for sq

 * @ci_addr: address for reading the current HW consumer index

 * @ci_dma_addr: dma address for reading the current HW consumer index

 * @db_base: doorbell base address

 *

 * Return 0 - Success, negative - Failure

/**

 * hinic_clean_sq - Clean HW Send Queue's Resources

 * @sq: Send Queue

/**

 * alloc_rq_cqe - allocate rq completion queue elements

 * @rq: HW Receive Queue

 *

 * Return 0 - Success, negative - Failure

/**

 * free_rq_cqe - free rq completion queue elements

 * @rq: HW Receive Queue

/**

 * hinic_init_rq - Initialize HW Receive Queue

 * @rq: HW Receive Queue

 * @hwif: HW Interface for accessing HW

 * @wq: Work Queue for the data of the RQ

 * @entry: msix entry for rq

 *

 * Return 0 - Success, negative - Failure

 HW requirements: Must be at least 32 bit */

/**

 * hinic_clean_rq - Clean HW Receive Queue's Resources

 * @rq: HW Receive Queue

/**

 * hinic_get_sq_free_wqebbs - return number of free wqebbs for use

 * @sq: send queue

 *

 * Return number of free wqebbs

/**

 * hinic_get_rq_free_wqebbs - return number of free wqebbs for use

 * @rq: recv queue

 *

 * Return number of free wqebbs

 set MSS value */

/**

 * hinic_sq_prepare_wqe - prepare wqe before insert to the queue

 * @sq: send queue

 * @prod_idx: pi value

 * @sq_wqe: wqe to prepare

 * @sges: sges for use by the wqe for send for buf addresses

 * @nr_sges: number of sges

/**

 * sq_prepare_db - prepare doorbell to write

 * @sq: send queue

 * @prod_idx: pi value for the doorbell

 * @cos: cos of the doorbell

 *

 * Return db value

 Data should be written to HW in Big Endian Format */

/**

 * hinic_sq_write_db- write doorbell

 * @sq: send queue

 * @prod_idx: pi value for the doorbell

 * @wqe_size: wqe size

 * @cos: cos of the wqe

 increment prod_idx to the next */

 Write all before the doorbell */

/**

 * hinic_sq_get_wqe - get wqe ptr in the current pi and update the pi

 * @sq: sq to get wqe from

 * @wqe_size: wqe size

 * @prod_idx: returned pi

 *

 * Return wqe pointer

/**

 * hinic_sq_return_wqe - return the wqe to the sq

 * @sq: send queue

 * @wqe_size: the size of the wqe

/**

 * hinic_sq_write_wqe - write the wqe to the sq

 * @sq: send queue

 * @prod_idx: pi of the wqe

 * @sq_wqe: the wqe to write

 * @skb: skb to save

 * @wqe_size: the size of the wqe

 The data in the HW should be in Big Endian Format */

/**

 * hinic_sq_read_wqebb - read wqe ptr in the current ci and update the ci, the

 * wqe only have one wqebb

 * @sq: send queue

 * @skb: return skb that was saved

 * @wqe_size: the wqe size ptr

 * @cons_idx: consumer index of the wqe

 *

 * Return wqe in ci position

 read the ctrl section for getting wqe size */

/**

 * hinic_sq_read_wqe - read wqe ptr in the current ci and update the ci

 * @sq: send queue

 * @skb: return skb that was saved

 * @wqe_size: the size of the wqe

 * @cons_idx: consumer index of the wqe

 *

 * Return wqe in ci position

/**

 * hinic_sq_put_wqe - release the ci for new wqes

 * @sq: send queue

 * @wqe_size: the size of the wqe

/**

 * hinic_sq_get_sges - get sges from the wqe

 * @sq_wqe: wqe to get the sges from its buffer addresses

 * @sges: returned sges

 * @nr_sges: number sges to return

/**

 * hinic_rq_get_wqe - get wqe ptr in the current pi and update the pi

 * @rq: rq to get wqe from

 * @wqe_size: wqe size

 * @prod_idx: returned pi

 *

 * Return wqe pointer

/**

 * hinic_rq_write_wqe - write the wqe to the rq

 * @rq: recv queue

 * @prod_idx: pi of the wqe

 * @rq_wqe: the wqe to write

 * @skb: skb to save

 The data in the HW should be in Big Endian Format */

/**

 * hinic_rq_read_wqe - read wqe ptr in the current ci and update the ci

 * @rq: recv queue

 * @wqe_size: the size of the wqe

 * @skb: return saved skb

 * @cons_idx: consumer index of the wqe

 *

 * Return wqe in ci position

/**

 * hinic_rq_read_next_wqe - increment ci and read the wqe in ci position

 * @rq: recv queue

 * @wqe_size: the size of the wqe

 * @skb: return saved skb

 * @cons_idx: consumer index in the wq

 *

 * Return wqe in incremented ci position

/**

 * hinic_rq_put_wqe - release the ci for new wqes

 * @rq: recv queue

 * @cons_idx: consumer index of the wqe

 * @wqe_size: the size of the wqe

 Rx WQE size is 1 WQEBB, no wq shadow*/

 clear done flag */

/**

 * hinic_rq_get_sge - get sge from the wqe

 * @rq: recv queue

 * @rq_wqe: wqe to get the sge from its buf address

 * @cons_idx: consumer index

 * @sge: returned sge

/**

 * hinic_rq_prepare_wqe - prepare wqe before insert to the queue

 * @rq: recv queue

 * @prod_idx: pi value

 * @rq_wqe: the wqe

 * @sge: sge for use by the wqe for recv buf address

/**

 * hinic_rq_update - update pi of the rq

 * @rq: recv queue

 * @prod_idx: pi value

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Huawei HiNIC PCI Express Linux driver

 * Copyright(c) 2017 Huawei Technologies Co., Ltd

/**

 * hinic_cpu_to_be32 - convert data to big endian 32 bit format

 * @data: the data to convert

 * @len: length of data to convert

/**

 * hinic_be32_to_cpu - convert data from big endian 32 bit format

 * @data: the data to convert

 * @len: length of data to convert

/**

 * hinic_set_sge - set dma area in scatter gather entry

 * @sge: scatter gather entry

 * @addr: dma address

 * @len: length of relevant data in the dma address

/**

 * hinic_sge_to_dma - get dma address from scatter gather entry

 * @sge: scatter gather entry

 *

 * Return dma address of sg entry

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Huawei HiNIC PCI Express Linux driver

 * Copyright(c) 2017 Huawei Technologies Co., Ltd

/**

 * hinic_msix_attr_set - set message attribute for msix entry

 * @hwif: the HW interface of a pci function device

 * @msix_index: msix_index

 * @pending_limit: the maximum pending interrupt events (unit 8)

 * @coalesc_timer: coalesc period for interrupt (unit 8 us)

 * @lli_timer: replenishing period for low latency credit (unit 8 us)

 * @lli_credit_limit: maximum credits for low latency msix messages (unit 8)

 * @resend_timer: maximum wait for resending msix (unit coalesc period)

 *

 * Return 0 - Success, negative - Failure

/**

 * hinic_msix_attr_get - get message attribute of msix entry

 * @hwif: the HW interface of a pci function device

 * @msix_index: msix_index

 * @pending_limit: the maximum pending interrupt events (unit 8)

 * @coalesc_timer: coalesc period for interrupt (unit 8 us)

 * @lli_timer: replenishing period for low latency credit (unit 8 us)

 * @lli_credit_limit: maximum credits for low latency msix messages (unit 8)

 * @resend_timer: maximum wait for resending msix (unit coalesc period)

 *

 * Return 0 - Success, negative - Failure

/**

 * hinic_msix_attr_cnt_clear - clear message attribute counters for msix entry

 * @hwif: the HW interface of a pci function device

 * @msix_index: msix_index

 *

 * Return 0 - Success, negative - Failure

/**

 * hinic_set_pf_action - set action on pf channel

 * @hwif: the HW interface of a pci function device

 * @action: action on pf channel

 *

 * Return 0 - Success, negative - Failure

/**

 * hwif_ready - test if the HW is ready for use

 * @hwif: the HW interface of a pci function device

 *

 * Return 0 - Success, negative - Failure

/**

 * set_hwif_attr - set the attributes in the relevant members in hwif

 * @hwif: the HW interface of a pci function device

 * @attr0: the first attribute that was read from the hw

 * @attr1: the second attribute that was read from the hw

 * @attr2: the third attribute that was read from the hw

/**

 * read_hwif_attr - read the attributes and set members in hwif

 * @hwif: the HW interface of a pci function device

/**

 * set_ppf - try to set hwif as ppf and set the type of hwif in this case

 * @hwif: the HW interface of a pci function device

 Read Modify Write */

 check PPF */

/**

 * set_dma_attr - set the dma attributes in the HW

 * @hwif: the HW interface of a pci function device

 * @entry_idx: the entry index in the dma table

 * @st: PCIE TLP steering tag

 * @at: PCIE TLP AT field

 * @ph: PCIE TLP Processing Hint field

 * @no_snooping: PCIE TLP No snooping

 * @tph_en: PCIE TLP Processing Hint Enable

 Read Modify Write */

/**

 * dma_attr_init - initialize the default dma attributes

 * @hwif: the HW interface of a pci function device

/**

 * hinic_init_hwif - initialize the hw interface

 * @hwif: the HW interface of a pci function device

 * @pdev: the pci device for accessing PCI resources

 *

 * Return 0 - Success, negative - Failure

 No transactionss before DMA is initialized */

/**

 * hinic_free_hwif - free the HW interface

 * @hwif: the HW interface of a pci function device

 SPDX-License-Identifier: GPL-2.0-only

/* Huawei HiNIC PCI Express Linux driver

 * Copyright(c) 2017 Huawei Technologies Co., Ltd

 SPDX-License-Identifier: GPL-2.0-only

/* Huawei HiNIC PCI Express Linux driver

 * Copyright(c) 2017 Huawei Technologies Co., Ltd

 send link change event mbox msg to active vfs under the pf */

 VLAN 0 is a special case, don't allow it to be removed */

 duplicate request, so just return success */

 duplicate request, so just return success */

 same request, so just return success */

 rate limit cannot be less than 0 and greater than link speed */

 same request, so just return success */

 Notify the VF of its new link state */

 pf receive message from vf */

 set vf_infos to default */

 vf use 256K as default wq page size, and can't change it */

 if SR-IOV is already disabled then nothing will be done */

	/* If our VFs are assigned we cannot shut down SR-IOV

	 * without causing issues, so just leave the hardware

	 * available but disabled

 disable iov and allow time for transactions to clear */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Huawei HiNIC PCI Express Linux driver

 * Copyright(c) 2017 Huawei Technologies Co., Ltd

 No coalescence */

/**

 * hinic_aeq_register_hw_cb - register AEQ callback for specific event

 * @aeqs: pointer to Async eqs of the chip

 * @event: aeq event to register callback for it

 * @handle: private data will be used by the callback

 * @hwe_handler: callback function

/**

 * hinic_aeq_unregister_hw_cb - unregister the AEQ callback for specific event

 * @aeqs: pointer to Async eqs of the chip

 * @event: aeq event to unregister callback for it

/**

 * hinic_ceq_register_cb - register CEQ callback for specific event

 * @ceqs: pointer to Completion eqs part of the chip

 * @event: ceq event to register callback for it

 * @handle: private data will be used by the callback

 * @handler: callback function

/**

 * hinic_ceq_unregister_cb - unregister the CEQ callback for specific event

 * @ceqs: pointer to Completion eqs part of the chip

 * @event: ceq event to unregister callback for it

/**

 * eq_update_ci - update the HW cons idx of event queue

 * @eq: the event queue to update the cons idx for

 * @arm_state: the arm bit value of eq's interrupt

 Read Modify Write */

/**

 * aeq_irq_handler - handler for the AEQ event

 * @eq: the Async Event Queue that received the event

 Data in HW is in Big endian Format */

 HW toggles the wrapped bit, when it adds eq element */

/**

 * ceq_event_handler - handler for the ceq events

 * @ceqs: ceqs part of the chip

 * @ceqe: ceq element that describes the event

/**

 * ceq_irq_handler - handler for the CEQ event

 * @eq: the Completion Event Queue that received the event

 Data in HW is in Big endian Format */

 HW toggles the wrapped bit, when it adds eq element event */

/**

 * eq_irq_handler - handler for the EQ event

 * @data: the Event Queue that received the event

/**

 * eq_irq_work - the work of the EQ that received the event

 * @work: the work struct that is associated with the EQ

/**

 * ceq_tasklet - the tasklet of the EQ that received the event

 * @t: the tasklet struct pointer

/**

 * aeq_interrupt - aeq interrupt handler

 * @irq: irq number

 * @data: the Async Event Queue that collected the event

 clear resend timer cnt register */

/**

 * ceq_interrupt - ceq interrupt handler

 * @irq: irq number

 * @data: the Completion Event Queue that collected the event

 clear resend timer cnt register */

 RMW Ctrl0 */

 RMW Ctrl0 */

 RMW Ctrl1 */

 RMW Ctrl1 */

/**

 * set_eq_ctrls - setting eq's ctrl registers

 * @eq: the Event Queue for setting

/**

 * aeq_elements_init - initialize all the elements in the aeq

 * @eq: the Async Event Queue

 * @init_val: value to initialize the elements with it

 Write the initilzation values */

/**

 * ceq_elements_init - Initialize all the elements in the ceq

 * @eq: the event queue

 * @init_val: value to init with it the elements

 Write the initilzation values */

/**

 * alloc_eq_pages - allocate the pages for the queue

 * @eq: the event queue

 *

 * Return 0 - Success, Negative - Failure

/**

 * free_eq_pages - free the pages of the queue

 * @eq: the Event Queue

/**

 * init_eq - initialize Event Queue

 * @eq: the event queue

 * @hwif: the HW interface of a PCI function device

 * @type: the type of the event queue, aeq or ceq

 * @q_id: Queue id number

 * @q_len: the number of EQ elements

 * @page_size: the page size of the pages in the event queue

 * @entry: msix entry associated with the event queue

 *

 * Return 0 - Success, Negative - Failure

 Clear PI and CI, also clear the ARM bit */

 set the attributes of the msix entry */

/**

 * remove_eq - remove Event Queue

 * @eq: the event queue

 clear aeq_len to avoid hw access host memory */

 clear ceq_len to avoid hw access host memory */

 update cons_idx to avoid invalid interrupt */

/**

 * hinic_aeqs_init - initialize all the aeqs

 * @aeqs: pointer to Async eqs of the chip

 * @hwif: the HW interface of a PCI function device

 * @num_aeqs: number of AEQs

 * @q_len: number of EQ elements

 * @page_size: the page size of the pages in the event queue

 * @msix_entries: msix entries associated with the event queues

 *

 * Return 0 - Success, negative - Failure

/**

 * hinic_aeqs_free - free all the aeqs

 * @aeqs: pointer to Async eqs of the chip

/**

 * hinic_ceqs_init - init all the ceqs

 * @ceqs: ceqs part of the chip

 * @hwif: the hardware interface of a pci function device

 * @num_ceqs: number of CEQs

 * @q_len: number of EQ elements

 * @page_size: the page size of the event queue

 * @msix_entries: msix entries associated with the event queues

 *

 * Return 0 - Success, Negative - Failure

/**

 * hinic_ceqs_free - free all the ceqs

 * @ceqs: ceqs part of the chip

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Huawei HiNIC PCI Express Linux driver

 * Copyright(c) 2017 Huawei Technologies Co., Ltd

 Data should be SEG LEN size aligned */

/**

 * hinic_register_mgmt_msg_cb - register msg handler for a msg from a module

 * @pf_to_mgmt: PF to MGMT channel

 * @mod: module in the chip that this handler will handle its messages

 * @handle: private data for the callback

 * @callback: the handler that will handle messages

/**

 * hinic_unregister_mgmt_msg_cb - unregister msg handler for a msg from a module

 * @pf_to_mgmt: PF to MGMT channel

 * @mod: module in the chip that this handler handles its messages

/**

 * prepare_header - prepare the header of the message

 * @pf_to_mgmt: PF to MGMT channel

 * @msg_len: the length of the message

 * @mod: module in the chip that will get the message

 * @ack_type: ask for response

 * @direction: the direction of the message

 * @cmd: command of the message

 * @msg_id: message id

 *

 * Return the prepared header value

/**

 * prepare_mgmt_cmd - prepare the mgmt command

 * @mgmt_cmd: pointer to the command to prepare

 * @header: pointer of the header for the message

 * @msg: the data of the message

 * @msg_len: the length of the message

/**

 * mgmt_msg_len - calculate the total message length

 * @msg_data_len: the length of the message data

 *

 * Return the total message length

 RSVD + HEADER_SIZE + DATA_LEN */

/**

 * send_msg_to_mgmt - send message to mgmt by API CMD

 * @pf_to_mgmt: PF to MGMT channel

 * @mod: module in the chip that will get the message

 * @cmd: command of the message

 * @data: the msg data

 * @data_len: the msg data length

 * @ack_type: ask for response

 * @direction: the direction of the original message

 * @resp_msg_id: msg id to response for

 *

 * Return 0 - Success, negative - Failure

/**

 * msg_to_mgmt_sync - send sync message to mgmt

 * @pf_to_mgmt: PF to MGMT channel

 * @mod: module in the chip that will get the message

 * @cmd: command of the message

 * @buf_in: the msg data

 * @in_size: the msg data length

 * @buf_out: response

 * @out_size: response length

 * @direction: the direction of the original message

 * @resp_msg_id: msg id to response for

 * @timeout: time-out period of waiting for response

 *

 * Return 0 - Success, negative - Failure

 Lock the sync_msg_buf */

 verify reading after completion */

/**

 * msg_to_mgmt_async - send message to mgmt without response

 * @pf_to_mgmt: PF to MGMT channel

 * @mod: module in the chip that will get the message

 * @cmd: command of the message

 * @buf_in: the msg data

 * @in_size: the msg data length

 * @direction: the direction of the original message

 * @resp_msg_id: msg id to response for

 *

 * Return 0 - Success, negative - Failure

 Lock the sync_msg_buf */

/**

 * hinic_msg_to_mgmt - send message to mgmt

 * @pf_to_mgmt: PF to MGMT channel

 * @mod: module in the chip that will get the message

 * @cmd: command of the message

 * @buf_in: the msg data

 * @in_size: the msg data length

 * @buf_out: response

 * @out_size: returned response length

 * @sync: sync msg or async msg

 *

 * Return 0 - Success, negative - Failure

 MGMT sent sync msg, send the response */

/**

 * mgmt_recv_msg_handler - handler for message from mgmt cpu

 * @pf_to_mgmt: PF to MGMT channel

 * @recv_msg: received message details

/**

 * mgmt_resp_msg_handler - handler for a response message from mgmt cpu

 * @pf_to_mgmt: PF to MGMT channel

 * @recv_msg: received message details

 verify writing all, before reading */

/**

 * recv_mgmt_msg_handler - handler for a message from mgmt cpu

 * @pf_to_mgmt: PF to MGMT channel

 * @header: the header of the message

 * @recv_msg: received message details

/**

 * mgmt_msg_aeqe_handler - handler for a mgmt message event

 * @handle: PF to MGMT channel

 * @data: the header of the message

 * @size: unused

/**

 * alloc_recv_msg - allocate receive message memory

 * @pf_to_mgmt: PF to MGMT channel

 * @recv_msg: pointer that will hold the allocated data

 *

 * Return 0 - Success, negative - Failure

/**

 * alloc_msg_buf - allocate all the message buffers of PF to MGMT channel

 * @pf_to_mgmt: PF to MGMT channel

 *

 * Return 0 - Success, negative - Failure

/**

 * hinic_pf_to_mgmt_init - initialize PF to MGMT channel

 * @pf_to_mgmt: PF to MGMT channel

 * @hwif: HW interface the PF to MGMT will use for accessing HW

 *

 * Return 0 - Success, negative - Failure

/**

 * hinic_pf_to_mgmt_free - free PF to MGMT channel

 * @pf_to_mgmt: PF to MGMT channel

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Huawei HiNIC PCI Express Linux driver

 * Copyright(c) 2017 Huawei Technologies Co., Ltd

/**

 * write_qp_ctxts - write the qp ctxt to HW

 * @func_to_io: func to io channel that holds the IO components

 * @base_qpn: first qp number

 * @num_qps: number of qps to write

 *

 * Return 0 - Success, negative - Failure

 TSO/LRO ctxt size: 0x0:0B; 0x1:160B; 0x2:200B; 0x3:240B */

 clean LRO/TSO context space */

/**

 * init_qp - Initialize a Queue Pair

 * @func_to_io: func to io channel that holds the IO components

 * @qp: pointer to the qp to initialize

 * @q_id: the id of the qp

 * @sq_msix_entry: msix entry for sq

 * @rq_msix_entry: msix entry for rq

 *

 * Return 0 - Success, negative - Failure

/**

 * destroy_qp - Clean the resources of a Queue Pair

 * @func_to_io: func to io channel that holds the IO components

 * @qp: pointer to the qp to clean

/**

 * hinic_io_create_qps - Create Queue Pairs

 * @func_to_io: func to io channel that holds the IO components

 * @base_qpn: base qp number

 * @num_qps: number queue pairs to create

 * @sq_msix_entries: msix entries for sq

 * @rq_msix_entries: msix entries for rq

 *

 * Return 0 - Success, negative - Failure

/**

 * hinic_io_destroy_qps - Destroy the IO Queue Pairs

 * @func_to_io: func to io channel that holds the IO components

 * @num_qps: number queue pairs to destroy

/**

 * hinic_io_init - Initialize the IO components

 * @func_to_io: func to io channel that holds the IO components

 * @hwif: HW interface for accessing IO

 * @max_qps: maximum QPs in HW

 * @num_ceqs: number completion event queues

 * @ceq_msix_entries: msix entries for ceqs

 *

 * Return 0 - Success, negative - Failure

/**

 * hinic_io_free - Free the IO components

 * @func_to_io: func to io channel that holds the IO components

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Huawei HiNIC PCI Express Linux driver

 * Copyright(c) 2017 Huawei Technologies Co., Ltd

/**

 * create_txqs - Create the Logical Tx Queues of specific NIC device

 * @nic_dev: the specific NIC device

 *

 * Return 0 - Success, negative - Failure

/**

 * free_txqs - Free the Logical Tx Queues of specific NIC device

 * @nic_dev: the specific NIC device

/**

 * create_rxqs - Create the Logical Rx Queues of specific NIC device

 * @nic_dev: the specific NIC device

 *

 * Return 0 - Success, negative - Failure

/**

 * free_rxqs - Free the Logical Rx Queues of specific NIC device

 * @nic_dev: the specific NIC device

 Disable txq napi firstly to aviod rewaking txq in free_tx_poll */

/**

 * change_mac_addr - change the main mac address of network device

 * @netdev: network device

 * @addr: mac address to set

 *

 * Return 0 - Success, negative - Failure

/**

 * add_mac_addr - add mac address to network device

 * @netdev: network device

 * @addr: mac address to add

 *

 * Return 0 - Success, negative - Failure

/**

 * remove_mac_addr - remove mac address from network device

 * @netdev: network device

 * @addr: mac address to remove

 *

 * Return 0 - Success, negative - Failure

 If Rx checksum is disabled, then LRO should also be disabled */

/**

 * link_status_event_handler - link event handler

 * @handle: nic device for the handler

 * @buf_in: input buffer

 * @in_size: input size

 * @buf_out: output buffer

 * @out_size: returned output size

 *

 * Return 0 - Success, negative - Failure

/**

 * nic_dev_init - Initialize the NIC device

 * @pdev: the NIC pci device

 *

 * Return 0 - Success, negative - Failure

 enable pause and disable pfc by default */

/*

 * Driver for the MPC5200 Fast Ethernet Controller

 *

 * Originally written by Dale Farnsworth <dfarnsworth@mvista.com> and

 * now maintained by Sylvain Munaut <tnt@246tNt.com>

 *

 * Copyright (C) 2007  Domen Puncer, Telargo, Inc.

 * Copyright (C) 2007  Sylvain Munaut <tnt@246tNt.com>

 * Copyright (C) 2003-2004  MontaVista, Software, Inc.

 *

 * This file is licensed under the terms of the GNU General Public License

 * version 2. This program is licensed "as is" without any warranty of any

 * kind, whether express or implied.

 *

 Private driver data structure */

 MDIO link details */

 the above default */

 zero out the initial receive buffers to aid debugging */

 based on generic_adjust_link from fs_enet-main.c */

 FD enable */

 disable Rx on Tx (HD) */

 power down phy */

/* This will only be invoked if your driver is _not_ in XOFF state.

 * What this means is that you need not check it, and that this

 * invariant will hold if you make sure that the netif_*_queue()

 * calls are done at the proper times.

/* This handles BestComm transmit task interrupts

 received sk_buff */

 new sk_buff to enqueue in its place */

 Test for errors in received frame */

 Drop packet and reuse the buffer */

		/* skbs are allocated on open, so now we allocate a new one,

 Can't get a new one : reuse the same & drop pkt */

 Enqueue the new sk_buff back on the hardware */

		/* Process the received skb - Drop the spin lock while

 length without CRC32 */

 mii is handled separately */

 clear pending events */

 on fifo error, soft-reset fec */

/*

 * Get the current statistics.

 * This may be called with the card open or closed.

 detailed rx_errors: */

 detailed tx_errors: */

/*

 * Read MIB counters in order to reset them,

 * then zero all the stats fields in memory

/*

 * Set or clear the multicast filter for this adaptor.

/**

 * mpc52xx_fec_hw_init

 * @dev: network device

 *

 * Setup various hardware setting, only needed once on start

 Whack a reset.  We should wait for this. */

 set pause to 0x20 frames */

	/* high service request will be deasserted when there's < 7 bytes in fifo

	 * low service request will be deasserted when there's < 4*7 bytes in fifo

 alarm when <= x bytes in FIFO */

 begin transmittion when 256 bytes are in FIFO (or EOF or FIFO full) */

 enable crc generation */

 No individual filter */

 No individual filter */

	/* set phy speed.

	 * this can't be done in phy driver, since it needs to be called

/**

 * mpc52xx_fec_start

 * @dev: network device

 *

 * This function is called to start or restart the FEC during a link

 * change.  This happens on fifo errors or when switching between half

 * and full duplex.

 clear sticky error bits */

 FIFOs will reset on mpc52xx_fec_enable */

 Set station address. */

 set max frame len, enable flow control, select mii mode */

 max frame length */

 FD enable */

 disable Rx on Tx (HD) */

 Clear any outstanding interrupt. */

 Enable interrupts we wish to service. */

 And last, enable the transmit and receive processing. */

/**

 * mpc52xx_fec_stop

 * @dev: network device

 *

 * stop all activity on fec and empty dma buffers

 disable all interrupts */

 Disable the rx task. */

 Wait for tx queue to drain, but only if we're in process context */

 Stop FEC */

 reset fec and bestcomm tasks */

 ethtool interface */

 ======================================================================== */

 OF Driver                                                                */

 ======================================================================== */

 Get the ether ndev & it's private zone */

 Reserve FEC control zone */

 Init ether ndev with what we have */

 ioremap the zones */

 Bestcomm init */

 Get the IRQ we need one by one */

 Control */

 RX */

 TX */

	/*

	 * MAC address init:

	 *

	 * First try to read MAC address from DT

		/*

		 * If the MAC addresse is not provided via DT then read

		 * it back from the controller regs

	/*

	 * Check if the MAC address is valid, if not get a random one

	/*

	 * Link mode configuration

 Start with safe defaults for link connection */

 The current speed preconfigures the speed of the MII link */

 If there is a phy handle, then get the PHY node */

 the 7-wire property means don't use MII mode */

 Hardware init */

 We're done ! */

 ======================================================================== */

 Module                                                                   */

 ======================================================================== */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) 2007 Freescale Semiconductor, Inc. All rights reserved.

 *

 * Description: QE UCC Gigabit Ethernet Ethtool API Set

 *

 * Author: Li Yang <leoli@freescale.com>

 *

 * Limitation:

 * Can only get/set settings of the first queue.

 * Need to re-open the interface manually after changing some parameters.

 FIXME: automatically restart */

 Report driver information */

 CONFIG_PM */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Freescale PowerQUICC Ethernet Driver -- MIIM bus implementation

 * Provides Bus interface for MIIM regs

 *

 * Author: Andy Fleming <afleming@freescale.com>

 * Modifier: Sandeep Gopalpet <sandeep.kumar@freescale.com>

 *

 * Copyright 2002-2004, 2008-2009 Freescale Semiconductor, Inc.

 *

 * Based on gianfar_mii.c and ucc_geth_mii.c (Li Yang, Kim Phillips)

 MII management configuration reg */

 MII management command reg */

 MII management address reg */

 MII management control reg */

 MII management status reg */

 MII management indication reg */

 MDIO Interrupt event register (for etsec2)*/

 MDIO Interrupt mask register (for etsec2)*/

 MDIO Event mapping register (for etsec2)*/

 TBI phy address reg (only on UCC) */

 Number of microseconds to wait for an MII register to respond */

/*

 * Per-device-type data.  Each type of device tree node that we support gets

 * one of these.

 *

 * @mii_offset: the offset of the MII registers within the memory map of the

 * node.  Some nodes define only the MII registers, and some define the whole

 * MAC (which includes the MII registers).

 *

 * @get_tbipa: determines the address of the TBIPA register

 *

 * @ucc_configure: a special function for extra QE configuration

 offset of the MII registers */

/*

 * Write value to the PHY at mii_id at register regnum, on the bus attached

 * to the local interface, which may be different from the generic mdio bus

 * (tied to a single interface), waiting until the write is done before

 * returning. This is helpful in programming interfaces like the TBI which

 * control interfaces like onchip SERDES and are always tied to the local

 * mdio pins, which may not be the same as system mdio bus, used for

 * controlling the external PHYs, for example.

 Set the PHY address and the register address we want to write */

 Write out the value we want */

 Wait for the transaction to finish */

/*

 * Read the bus for PHY at addr mii_id, register regnum, and return the value.

 * Clears miimcom first.

 *

 * All PHY operation done on the bus attached to the local interface, which

 * may be different from the generic mdio bus.  This is helpful in programming

 * interfaces like the TBI which, in turn, control interfaces like on-chip

 * SERDES and are always tied to the local mdio pins, which may not be the

 * same as system mdio bus, used for controlling the external PHYs, for eg.

 Set the PHY address and the register address we want to read */

 Clear miimcom, and then initiate a read */

 Wait for the transaction to finish, normally less than 100us */

 Grab the value of the register from miimstat */

 Reset the MIIM registers, and wait for the bus to free */

 Reset the management interface */

 Setup the MII Mgmt clock speed */

 Wait until the bus is free */

/*

 * Return the TBIPA address, starting from the address

 * of the mapped GFAR MDIO registers (struct gfar)

 * This is mildly evil, but so is our hardware for doing this.

 * Also, we have to cast back to struct gfar because of

 * definition weirdness done in gianfar.h.

/*

 * Return the TBIPA address, starting from the address

 * of the mapped GFAR MII registers (gfar_mii_regs[] within struct gfar)

/*

 * Return the TBIPAR address for an eTSEC2 node

/*

 * Return the TBIPAR address for a QE MDIO node, starting from the address

 * of the mapped MII registers (struct fsl_pq_mii)

/*

 * Find the UCC node that controls the given MDIO node

 *

 * For some reason, the QE MDIO nodes are not children of the UCC devices

 * that control them.  Therefore, we need to scan all UCC nodes looking for

 * the one that encompases the given MDIO node.  We do this by comparing

 * physical addresses.  The 'start' and 'end' addresses of the MDIO node are

 * passed, and the correct UCC node will cover the entire address range.

 *

 * This assumes that there is only one QE MDIO node in the entire device tree.

 if our mdio regs fall within this UCC regs range */

		/*

		 * cell-index and device-id for QE nodes are

		 * numbered from 1, not 0.

 Legacy UCC MDIO node */

 No Kconfig option for Fman support yet */

 Fman TBI operations are handled elsewhere */

		/*

		 * Add consistency check to make sure TBI is contained within

		 * the mapped range (not because we would get a segfault,

		 * rather to catch bugs in computing TBI address). Print error

		 * message but continue anyway.

	/*

	 * Some device tree nodes represent only the MII registers, and

	 * others represent the MAC and MII registers.  The 'mii_offset' field

	 * contains the offset of the MII registers inside the mapped register

	 * space.

 SPDX-License-Identifier: GPL-2.0

/*

 * Fast Ethernet Controller (ENET) PTP driver for MX6x.

 *

 * Copyright (C) 2012 Freescale Semiconductor, Inc.

 FEC 1588 register bits */

/**

 * fec_ptp_enable_pps

 * @fep: the fec_enet_private structure handle

 * @enable: enable the channel pps output

 *

 * This function enble the PPS ouput on the timer channel.

		/* clear capture or output compare interrupt status if have.

		/* It is recommended to double check the TMODE field in the

		 * TCSR register to be cleared before the first compare counter

		 * is written into TCCR register. Just add a double check.

 Dummy read counter to update the counter */

		/* We want to find the first compare event in the next

		 * second point. So we need to know what the ptp time

		 * is now and how many nanoseconds is ahead to get next second.

		 * The remaining nanosecond ahead before the next second would be

		 * NSEC_PER_SEC - ts.tv_nsec. Add the remaining nanoseconds

		 * to current timer would be next second.

 Convert the ptp local counter to 1588 timestamp */

		/* The tempval is  less than 3 seconds, and  so val is less than

		 * 4 seconds. No overflow for 32bit calculation.

		/* Need to consider the situation that the current time is

		 * very close to the second point, which means NSEC_PER_SEC

		 * - ts.tv_nsec is close to be zero(For example 20ns); Since the timer

		 * is still running when we calculate the first compare event, it is

		 * possible that the remaining nanoseonds run out before the compare

		 * counter is calculated and written into TCCR register. To avoid

		 * this possibility, we will set the compare event to be the next

		 * of next second. The current setting is 31-bit timer and wrap

		 * around over 2 seconds. So it is okay to set the next of next

		 * seond for the timer.

		/* We add (2 * NSEC_PER_SEC - (u32)ts.tv_nsec) to current

		 * ptp counter, which maybe cause 32-bit wrap. Since the

		 * (NSEC_PER_SEC - (u32)ts.tv_nsec) is less than 2 second.

		 * We can ensure the wrap will not cause issue. If the offset

		 * is bigger than fep->cc.mask would be a error.

 Calculate the second the compare event timestamp */

 * Enable compare event when overflow */

 Compare channel setting. */

		/* Write the second compare event timestamp and calculate

		 * the third timestamp. Refer the TCCR register detail in the spec.

/**

 * fec_ptp_read - read raw cycle counter (to be used by time counter)

 * @cc: the cyclecounter structure

 *

 * this function reads the cyclecounter registers and is called by the

 * cyclecounter structure used to construct a ns counter from the

 * arbitrary fixed point registers

/**

 * fec_ptp_start_cyclecounter - create the cycle counter from hw

 * @ndev: network device

 *

 * this function initializes the timecounter and cyclecounter

 * structures for use in generated a ns counter from the arbitrary

 * fixed point cycles registers in the hardware.

 grab the ptp lock */

 1ns counter */

 use 31-bit timer counter */

 reset the ns time counter */

/**

 * fec_ptp_adjfreq - adjust ptp cycle frequency

 * @ptp: the ptp clock structure

 * @ppb: parts per billion adjustment from base

 *

 * Adjust the frequency of the ptp cycle counter by the

 * indicated ppb from the base frequency.

 *

 * Because ENET hardware frequency adjust is complex,

 * using software method to do that.

	/* In theory, corr_inc/corr_period = ppb/NSEC_PER_SEC;

	 * Try to find the corr_inc  between 1 to fep->ptp_inc to

	 * meet adjustment requirement.

	/* Not found? Set it to high value - double speed

	 * correct in every clock step.

 dummy read to update the timer. */

/**

 * fec_ptp_adjtime

 * @ptp: the ptp clock structure

 * @delta: offset to adjust the cycle counter by

 *

 * adjust the timer by resetting the timecounter structure.

/**

 * fec_ptp_gettime

 * @ptp: the ptp clock structure

 * @ts: timespec structure to hold the current time value

 *

 * read the timecounter and return the correct value on ns,

 * after converting it into a struct timespec.

 Check the ptp clock */

/**

 * fec_ptp_settime

 * @ptp: the ptp clock structure

 * @ts: the timespec containing the new time for the cycle counter

 *

 * reset the timecounter to use a new base value instead of the kernel

 * wall timer value.

 Check the ptp clock */

	/* Get the timer value based on timestamp.

	 * Update the counter with the masked value.

/**

 * fec_ptp_enable

 * @ptp: the ptp clock structure

 * @rq: the requested feature to change

 * @on: whether to enable or disable the feature

 *

/**

 * fec_ptp_disable_hwts - disable hardware time stamping

 * @ndev: pointer to net_device

 reserved for future extensions */

/*

 * fec_time_keep - call timecounter_read every second to avoid timer overrun

 *                 because ENET just support 32bit counter, will timeout in 4s

 This function checks the pps event and reloads the timer compare counter. */

		/* Write the next next compare(not the next according the spec)

		 * value to the register

 Update the counter; */

/**

 * fec_ptp_init

 * @pdev: The FEC network adapter

 * @irq_idx: the interrupt index

 *

 * This function performs the required steps for enabling ptp

 * support. If ptp support has already been loaded it simply calls the

 * cyclecounter init routine and exits.

	/* Failure to get an irq is not fatal,

	 * only the PTP_CLOCK_PPS clock events should stop

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  drivers/net/ethernet/freescale/gianfar_ethtool.c

 *

 *  Gianfar Ethernet Driver

 *  Ethtool support for Gianfar Enet

 *  Based on e1000 ethtool support

 *

 *  Author: Andy Fleming

 *  Maintainer: Kumar Gala

 *  Modifier: Sandeep Gopalpet <sandeep.kumar@freescale.com>

 *

 *  Copyright 2003-2006, 2008-2009, 2011 Freescale Semiconductor, Inc.

 extra stats */

 rmon stats */

/* Fill in a buffer with the strings which correspond to the

/* Fill in an array of 64-bit statistics from various sources.

 * This array will be appended to the end of the ethtool_stats

 * structure, and returned to user space

 Fills in the drvinfo structure with some basic info */

 Return the length of the register structure */

 Return a dump of the GFAR register space */

/* Convert microseconds to ethernet clock ticks, which changes

 The timer is different, depending on the interface speed */

	/* Make sure we return a number greater than 0

 Convert ethernet clock ticks to microseconds */

 The timer is different, depending on the interface speed */

 Make sure we return a number greater than 0 */

 if ticks is > 0 */

/* Get the coalescing parameters, and put them in the cvals

/* Change the coalescing values.

 * Both cvals->*_usecs and cvals->*_frames have to be > 0

 * in order for coalescing to be active

 Check the bounds of the values */

 Check the bounds of the values */

 Set up rx coalescing */

 Set up tx coalescing */

/* Fills in rvals with the current ring parameters.  Currently,

 * rx, rx_mini, and rx_jumbo rings are the same size, as mini and

	/* Values changeable by the user.  The valid values are

	 * in the range 1 to the "*_max_pending" counterpart above.

/* Change the current ring parameters, stopping the controller if

 * necessary so that we don't mess things up while we're in motion.

 Change the sizes */

 Rebuild the rings with the new size */

 Now we take down the rings to rebuild them */

	/* If a match was found, then it begins the starting of a cluster rule

	 * if it was already programmed, we need to overwrite these rules

 hash rules */

 Write back the popped out rules again */

 write the filer rules here */

 Check if we are in FIFO mode */

 Or in standard mode */

	/* Sets the properties for arbitrary filer rule

	 * to the first 4 Layer 4 Bytes

 Write a mask to filer cache */

 Sets parse bits (e.g. IP or TCP) */

/* For setting a tuple of value and mask of type flag

 * Example:

 * IP-Src = 10.0.0.0/255.0.0.0

 * value: 0x0A000000 mask: FF000000 flag: RQFPR_IPV4

 *

 * Ethtool gives us a value=0 and mask=~0 for don't care a tuple

 * For a don't care mask it gives us a 0

 *

 * The check if don't care and the mask adjustment if mask=0 is done for VLAN

 * and MAC stuff on an upper level (due to missing information on this level).

 * For these guys we can discard them if they are value=0 and mask=0.

 *

 * Further the all masks are one-padded for better hardware efficiency.

 3bit */

 8bit */

 12bit */

 16bit */

 24bit */

 for all real 32bit masks */

 Translates value and mask for UDP, TCP or SCTP */

 Translates value and mask for RAW-IP4 */

 Translates value and mask for ETHER spec */

 Source address */

 Upper 24bit */

 And the same for the lower part */

 Destination address */

 Special for destination is limited broadcast */

 Upper 24bit */

 And the same for the lower part */

 Convert a rule to binary filter format of gianfar */

 Check if vlan is wanted */

 Separate the fields */

 Set the vlan attributes in the end */

 If there has been nothing written till now, it must be a default */

 Remove last AND */

 Specify which queue to use or to drop */

 Only big enough entries can be clustered */

	/* In rare cases the cache can be full while there is

	 * free space in hw

 Write the bit-pattern from software's buffer to hardware registers */

 Fill regular entries */

 Fill the rest with fall-troughs */

	/* Last entry must be default accept

	 * because that's what people expect

 So index is set to zero, too! */

	/* Now convert the existing filer data from flow_spec into

	 * filer tables binary format

 Write everything to hardware */

 Link in the new element at the right @location */

 SPDX-License-Identifier: GPL-2.0+

/*

 * Fast Ethernet Controller (FEC) driver for Motorola MPC8xx.

 * Copyright (c) 1997 Dan Malek (dmalek@jlc.net)

 *

 * Right now, I am very wasteful with the buffers.  I allocate memory

 * pages and then divide them into 2K frame buffers.  This way I know I

 * have buffers large enough to hold one frame within one buffer descriptor.

 * Once I get this working, I will use 64 or 128 byte CPM buffers, which

 * will be much more memory efficient and will easily handle lots of

 * small packets.

 *

 * Much better multiple PHY support by Magnus Damm.

 * Copyright (c) 2000 Ericsson Radio Systems AB.

 *

 * Support for FEC controller of ColdFire processors.

 * Copyright (c) 2001-2005 Greg Ungerer (gerg@snapgear.com)

 *

 * Bug fixes and cleanup by Philippe De Muyter (phdm@macqel.be)

 * Copyright (c) 2004-2006 Macq Electronique SA.

 *

 * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.

 Pause frame feild and FIFO threshold */

 ms */

 keep it for coldfire */

 sentinel */

 runs on i.mx25/50/53 */

 runs on i.mx27/35/51 */

 sentinel */ }

/*

 * Some hardware gets it MAC address out of local flash memory.

 * if this is non-zero then assume it is the address to get MAC from.

 CONFIG_M5272 */

/* The FEC stores dest/src/type/vlan, data, and checksum for receive packets.

 *

 * 2048 byte skbufs are allocated. However, alignment requirements

 * varies between FEC variants. Worst case is 64, so round down by 64.

 FEC receive acceleration */

 MIB Control Register */

/*

 * The 5270/5271/5280/5282/532x RX control register also contains maximum frame

 * size bits. Other FEC hardware does not, so we need to take that into

 * account when setting it.

 FEC MII MMFR bits definition */

 FEC ECR bits definition */

 us */

 Transmitter timeout */

 Max number of allowed TCP segments for software TSO */

 Only run for packets requiring a checksum. */

 Handle the last BD specially */

		/* Make sure the updates to rest of the descriptor are

		 * performed before transferring ownership.

 Protocol checksum off-load for TCP and UDP. */

 Fill in a Tx ring entry */

 Set buffer length and buffer pointer */

 Push the data cache so the CPM does not get stale memory data. */

 Save skb pointer */

	/* Make sure the updates to rest of the descriptor are performed before

	 * transferring ownership.

	/* Send it on its way.  Tell FEC it's ready, interrupt when done,

	 * it's the last BD of the frame, and to put the CRC on the end.

 If this was the last BD in the ring, start at the beginning again. */

	/* Make sure the update to bdp and tx_skbuff are performed before

	 * txq->bd.cur.

 Trigger transmission start */

 Handle the last BD specially */

 Protocol checksum off-load for TCP and UDP. */

 Initialize the TSO handler, and prepare the first payload */

 prepare packet headers: MAC + IP + TCP */

 Save skb pointer */

 Trigger transmission start */

 TODO: Release all used data descriptors for TSO */

/* Init RX & TX buffer descriptors

 Initialize the receive buffer descriptors. */

 Initialize the BD for every fragment in the page. */

 Set the last buffer to wrap */

 ...and the same for transmit */

 Initialize the BD for every fragment in the page. */

 Set the last buffer to wrap */

 enable DMA1/2 */

 enable DMA1/2 */

/*

 * This function is called to start or restart the FEC during a link

 * change, transmit timeout, or to reconfigure the FEC.  The network

 * packet processing for this device must be stopped before this call.

 ETHEREN */

	/* Whack a reset.  We should wait for this.

	 * For i.MX6SX SOC, enet use AXI bus, we use disable MAC

	 * instead of reset MAC itself.

	/*

	 * enet-mac reset will reset mac address registers too,

	 * so need to reconfigure it.

 Clear any outstanding interrupt, except MDIO. */

 Reset tx SKB buffers. */

 Enable MII mode */

 FD enable */

 No Rcv on Xmit */

 Set MII speed */

 align IP header */

 set RX checksum */

	/*

	 * The phy interface and speed need to get configured

	 * differently on enet-mac.

 Enable flow control and length check */

 RGMII, RMII or MII */

 1G, 100M or 10M */

 disable the gasket and wait */

			/*

			 * configure the gasket:

			 *   RMII, 50 MHz, no loopback, no echo

			 *   MII, 25 MHz, no loopback, no echo

 re-enable the gasket */

 enable pause frame*/

 set FIFO threshold parameter to reduce overrun */

 OPD */

 !defined(CONFIG_M5272) */

 Setup multicast filter. */

 enable ENET endian swap */

 enable ENET store and forward mode */

 Enable the MIB statistic event counters */

 And last, enable the transmit and receive processing */

 Enable interrupts we wish to service */

 Init the interrupt coalescing */

 We cannot expect a graceful transmit stop without link !!! */

 Graceful transmit stop */

	/* Whack a reset.  We should wait for this.

	 * For i.MX6SX SOC, enet use AXI bus, we use disable MAC

	 * instead of reset MAC itself.

 We have to keep ENET enabled to have MII interrupt stay working */

 get next bdp of dirty_tx */

 get next bdp of dirty_tx */

 Order the load of bd.cur and cbd_sc */

 Check for errors. */

 No heartbeat */

 Late collision */

 Retrans limit */

 Underrun */

 Carrier lost */

		/* NOTE: SKBTX_IN_PROGRESS being set does not imply it's we who

		 * are to time stamp the packet, so we still need to check time

		 * stamping enabled flag.

		/* Deferred means some collisions occurred during transmit,

		 * but we eventually sent the packet OK.

 Free the sk buffer associated with this last transmit */

		/* Make sure the update to bdp and tx_skbuff are performed

		 * before dirty_tx

 Update pointer to next buffer descriptor to be transmitted */

		/* Since we have freed up a buffer, the ring is no longer full

 ERR006358: Keep the transmitter going */

 Make sure that AVB queues are processed first. */

/* During a receive, the bd_rx.cur points to the current incoming buffer.

 * When we update through the ring, if the next incoming buffer has

 * not been given to the system, we just set the empty indicator,

 * effectively tossing the packet.

	/* First, grab all of the stats for the incoming packet.

	 * These get messed up if we get called due to a busy condition.

 Check for errors. */

 FIFO overrun */

 Frame too long or too short. */

 CRC Error */

 Report late collisions as a frame error. */

 Process the incoming frame. */

		/* The packet length includes FCS, but we don't want to

		 * include that when passing upstream as it messes up

		 * bridging applications.

 Extract the enhanced buffer descriptor */

 If this is a VLAN packet remove the VLAN Tag */

 Push and remove the vlan tag */

 Get receive timestamp from the skb */

 don't check it */

 Handle received VLAN packets */

 Clear the status flags for this buffer */

 Mark the buffer empty */

		/* Make sure the updates to rest of the descriptor are

		 * performed before transferring ownership.

 Update BD pointer to next entry */

		/* Doing this here will keep the FEC running while we process

		 * incoming frames.  On a heavily loaded network, we should be

		 * able to keep up at the expense of system resources.

 Make sure that AVB queues are processed first. */

 Don't clear MDIO events, we poll for those */

 Disable interrupts */

 ------------------------------------------------------------------------- */

	/*

	 * try to get mac address in following order:

	 *

	 * 1) module parameter via kernel command line in form

	 *    fec.macaddr=0x00,0x04,0x9f,0x01,0x30,0xe0

	/*

	 * 2) from device tree data

	/*

	 * 3) from flash or fuse (via platform data)

	/*

	 * 4) FEC mac registers set by bootloader

	/*

	 * 5) random mac address

 Report it and use a random ethernet address instead */

 Adjust MAC if using macaddr */

 ------------------------------------------------------------------------- */

/*

 * Phy section

	/*

	 * If the netdev is down, or is going down, we're not interested

	 * in link state events, so just mark our idea of the link as down

	 * and ignore the event.

 if any of the above changed restart the FEC */

 write address */

 wait for end of transfer */

 C22 read */

 start a read op */

 wait for end of transfer */

 write address */

 wait for end of transfer */

 C22 write */

 start a write op */

 wait for end of transfer */

		/*

		 * If the PHY still is not bound to the MAC, but there is

		 * OF PHY node and a matching PHY device instance already,

		 * use the OF PHY node to obtain the PHY device instance,

		 * and then use that PHY device instance when triggering

		 * the PHY reset.

 For rgmii tx internal delay, valid values are 0ps and 2000ps */

 For rgmii rx internal delay, valid values are 0ps and 2000ps */

 check for attached phy */

 mask with MAC supported features */

	/*

	 * The i.MX28 dual fec interfaces are not equal.

	 * Here are the differences:

	 *

	 *  - fec0 supports MII & RMII modes while fec1 only supports RMII

	 *  - fec0 acts as the 1588 time master while fec1 is slave

	 *  - external phys can only be configured by fec0

	 *

	 * That is to say fec1 can not work independently. It only works

	 * when fec0 is working. The reason behind this design is that the

	 * second interface is added primarily for Switch mode.

	 *

	 * Because of the last point above, both phys are attached on fec0

	 * mdio interface in board design, and need to be configured by

	 * fec0 mii_bus.

 fec1 uses fec0 mii_bus */

 2.5MHz by default */

	/*

	 * Set MII speed (= clk_get_rate() / 2 * phy_speed)

	 *

	 * The formula for FEC MDC is 'ref_freq / (MII_SPEED x 2)' while

	 * for ENET-MAC is 'ref_freq / ((MII_SPEED + 1) x 2)'.  The i.MX28

	 * Reference Manual has an error on this, and gets fixed on i.MX6Q

	 * document.

	/*

	 * The i.MX28 and i.MX6 types have another filed in the MSCR (aka

	 * MII_SPEED) register that defines the MDIO output hold time. Earlier

	 * versions are RAZ there, so just ignore the difference and write the

	 * register always.

	 * The minimal hold time according to IEE802.3 (clause 22) is 10 ns.

	 * HOLDTIME + 1 is the number of clk cycles the fec is holding the

	 * output.

	 * The HOLDTIME bitfield takes values between 0 and 7 (inclusive).

	 * Given that ceil(clkrate / 5000000) <= 64, the calculation for

	 * holdtime cannot result in a value greater than 3.

		/* Clear MMFR to avoid to generate MII event by writing MSCR.

		 * MII event generation condition:

		 * - writing MSCR:

		 *	- mmfr[31:0]_not_zero & mscr[7:0]_is_zero &

		 *	  mscr_reg_data_in[7:0] != 0

		 * - writing MMFR:

		 *	- mscr[7:0]_not_zero

 Clear any pending transaction complete indication */

 save fec0 mii_bus */

 List of registers that can be safety be read to dump them with ethtool */

 tx pause must be same as rx pause */

 RMON TX */

 IEEE TX */

 RMON RX */

 IEEE RX */

 Disable MIB statistics counters */

 Don't disable MIB statistics counters */

 !defined(CONFIG_M5272) */

 !defined(CONFIG_M5272) */

/* ITR clock source is enet system clock (clk_ahb).

 * TCTT unit is cycle_ns * 64 cycle

 * So, the ICTT value = X us / (cycle_ns * 64)

 Set threshold for interrupt coalescing */

 Must be greater than zero to avoid unpredictable behavior */

	/* Select enet system clock as Interrupt Coalescing

	 * timer Clock Source

 set ICFT and ICTT */

/* LPI Sleep Ts count base on tx clk (clk_ref).

 * The lpi sleep cnt value = X us / (cycle_ns).

 Set the last buffer to wrap. */

 Set the last buffer to wrap. */

	/* During the first fec_enet_open call the PHY isn't probed at this

	 * point. Therefore the phy_reset_after_clk_enable() call within

	 * fec_enet_clk_enable() fails. As we need this reset in order to be

	 * sure the PHY is working correctly we check if we need to reset again

	 * later when the PHY is probed

	/* I should reset the ring buffers here, but I don't yet know

	 * a simple way to do that.

 Init MAC prior to mii bus probe */

	/* Call phy_reset_after_clk_enable() again if it failed during

	 * phy_reset_after_clk_enable() before because the PHY wasn't probed.

 Probe and connect to PHY when open the interface */

/* Set or clear the multicast filter for this adaptor.

 * Skeleton taken from sunlance driver.

 * The CPM Ethernet implementation allows Multicast as well as individual

 * MAC address filtering.  Some of the drivers check to make sure it is

 * a group multicast address, and discard those that are not.  I guess I

 * will do the same for now, but just remove the test if you want

 * individual filtering as well (do the upper net layers want or support

 * this kind of feature?).

 #bits in hash */

		/* Catch all multicast addresses, so set the

		 * filter to all 1's

 Add the addresses in hash register */

 calculate crc32 value of mac address */

		/* only upper 6 bits (FEC_HASH_BITS) are used

		 * which point to specific bit in the hash registers

 Set a MAC change in hardware. */

	/* Add netif status check here to avoid system hang in below case:

	 * ifconfig ethx down; ifconfig ethx hw ether xx:xx:xx:xx:xx:xx;

	 * After ethx down, fec all clocks are gated off and then register

	 * access causes system hang.

/**

 * fec_poll_controller - FEC Poll controller function

 * @dev: The FEC network adapter

 *

 * Polled functionality used by netconsole and others in non interrupt mode

 *

 Receive checksum has been changed */

 /*

  * XXX:  We need to clean up on failure exits here.

  *

 Check mask of the streaming and coherent API */

 Allocate memory for buffer descriptors. */

 Get the Ethernet address */

 make sure MAC we just acquired is programmed into the hw */

 Set receive and transmit descriptor base. */

 The FEC Ethernet specific entries in the device structure */

 enable hw VLAN support */

 enable hw accelerator */

 A sane reset duration should not be longer than 1s */

 valid reset duration should be less than 1s */

 CONFIG_OF */

	/*

	 * In case of platform probe, the reset has been done

	 * by machine code.

 CONFIG_OF */

 parse the num of tx and rx queues */

 last for pps */

 last for pps */

 At least 1 irq is needed */

 Init network device */

 setup board info structure */

 default enable pause frame auto negotiation */

 Select default pin state */

 enet_out is optional, depends on board */

 clk_ref is optional, depends on board */

 clk_2x_txclk is optional, depends on board */

 Decide which interrupt line is wakeup capable */

 Carrier starts down, phylib will bring it up */

	/* SOC supply clock to phy, when clock is disabled, phy link down

	 * SOC control phy regulator, when regulator is disabled, phy link down

/*

 * Driver for the MPC5200 Fast Ethernet Controller - MDIO bus driver

 *

 * Copyright (C) 2007  Domen Puncer, Telargo, Inc.

 * Copyright (C) 2008  Wolfram Sang, Pengutronix

 *

 * This file is licensed under the terms of the GNU General Public License

 * version 2. This program is licensed "as is" without any warranty of any

 * kind, whether express or implied.

 wait for it to finish, this takes about 23 us on lite5200b */

 setup registers */

 set MII speed */

 let fec driver call it, since this has to be registered before it */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2006-2009 Freescale Semicondutor, Inc. All rights reserved.

 *

 * Author: Shlomi Gridish <gridish@freescale.com>

 *	   Li Yang <leoli@freescale.com>

 *

 * Description:

 * QE UCC Gigabit Ethernet Driver

 UGETH_VERBOSE_DEBUG */

 adjusted at startup if max-speed 1000 */

1536 */ ,

 Add extra bytes for VLANs etc. */

 Add extra bytes for VLANs etc. */

 Add extra bytes for VLANs etc. */

 DEBUG */

	/* We need the data buffer to be aligned properly.  We will reserve

	 * as many bytes as needed to align the data properly

		if (!skb)	/* If can not allocate data buffer,

 advance the BD pointer */

 First entry of Rx does not have page */

		/* Check that this entry was actually valid --

 First entry of Rx does not have page */

		/* Check that this entry was actually valid --

 First entry of Rx does not have page */

	/* Writing address ff.ff.ff.ff.ff.ff disables address

	/* Ethernet frames are defined in Little Endian mode,

 the address to the hash (Big Endian mode), we reverse the bytes.*/

	/* Tx firmware only if user handed pointer and driver actually

	/* Rx firmware only if user handed pointer and driver actually

	/* Hardware only if user handed pointer and driver actually

 DEBUG */

	/* Non-Back-to-back IPG part 1 should be <= Non-Back-to-back

(min_ifg        > IPGIFG_MINIMUM_IFG_ENFORCEMENT_MAX) || */

 Set UEMPR register */

 Set UPSMR register */

 Enable hardware statistics gathering if requested */

 Clear hardware statistics counters */

	/* Automatically zero hardware statistics counters on read,

 Note: this function does not check if */

 the parameters it receives are NULL   */

 Example: for a station address of 0x12345678ABCD, */

 0x12 is byte 0, 0x34 is byte 1 and so on and 0xCD is byte 5 */

 MACSTNADDR1 Register: */

 0                      7   8                      15  */

 station address byte 5     station address byte 4     */

 16                     23  24                     31  */

 station address byte 3     station address byte 2     */

 MACSTNADDR2 Register: */

 0                      7   8                      15  */

 station address byte 1     station address byte 0     */

 16                     23  24                     31  */

         reserved                   reserved           */

 max_rx_buf_len value must be a multiple of 128 */

                    Set MACCFG2                    */

                    Set UPSMR                      */

	/* Disable autonegotiation in tbi mode, because by default it

 Note that this depends on proper setting in utbipar register. */

 Turn off autonegotiation */

 Mask GRACEFUL STOP TX interrupt bit and clear it */

 clear by writing 1 */

 Issue host command */

 Wait for command to complete */

 Clear acknowledge bit */

	/* Keep issuing command and checking acknowledge bit until

 Issue host command */

 check if the UCC number is in range. */

	/* Get Tx and Rx going again, in case this channel was actively

 OK to do even if not disabled */

 check if the UCC number is in range. */

 Stop any transmissions */

 Stop any receptions */

 OK to do even if not enabled */

 Prevent any further xmits */

 Disable the interrupt to avoid NAPI rescheduling. */

 Stop NAPI, and possibly wait for its completion. */

 allow to xmit again  */

/* Called every time the controller might need to be made

 * aware of new link state.  The PHY code conveys this

 * information through variables in the ugeth structure, and this

 * function converts those variables into the appropriate

 * register values, and can bring down the device if needed.

		/* Now we make sure that we can be in full duplex mode.

 if reduced mode, re-set UPSMR.R10M */

			/*

			 * To change the MAC configuration we need to disable

			 * the controller. To do so, we have to either grab

			 * ugeth->lock, which is a bad idea since 'graceful

			 * stop' commands might take quite a while, or we can

			 * quiesce driver's activity.

/* Initialize TBI PHY interface for communicating with the

 * SERDES lynx PHY on the chip.  We communicate with this PHY

 * through the MDIO bus on each controller, treating it as a

 * "normal" PHY at the address found in the UTBIPA register.  We assume

 * that the UTBIPA register is valid.  Either the MDIO bus code will set

 * it to a value that doesn't conflict with other PHYs on the bus, or the

 * value doesn't matter, as there are no other PHYs on the bus.

	/*

	 * If the link is already up, we must already be ok, and don't need to

	 * configure and reset the TBI<->SerDes link.  Maybe U-Boot configured

	 * everything for us?  Resetting it takes the link down and requires

	 * several seconds for it to come back.

 Single clk mode, mii mode off(for serdes communication) */

/* Configure the PHY for dev.

 * returns 0 if success.  -1 if failure

 Clear the hash table. */

 Delete all remaining CQ elements */

 mark this paddr as not used */

 clear in hardware */

 Return existing data buffers in ring */

			/* Catch all multicast addresses, so set the

			 * filter to all 1's.

			/* Clear filter and add the addresses in the list.

				/* Ask CPM to run CRC and set bit in

				 * filter mask.

	/*

	 * Tell the kernel the link is down.

	 * Must be done before disabling the controller

	 * or deadlock may happen.

 Disable the controller */

 Mask all interrupts */

 Clear all interrupts */

 Disable Rx and Tx */

 Rx BD lengths */

 Tx BD lengths */

 mrblr */

 num Tx queues */

 num Rx queues */

 l2qt */

 l3qt */

 Generate uccm_mask for receive */

 Errors */

 Initialize the general fast UCC block. */

	/* read the number of risc engines, update the riscTx and riscRx

	 * if there are 4 riscs in QE

 Allocate Tx bds */

 Zero unused end of bd ring, according to spec */

 Init Tx bds */

 Setup the skbuff rings */

 clear bd buffer */

 set bd status and length */

 set bd status and length */

 for last BD set Wrap bit */

 Allocate Rx bds */

 Init Rx bds */

 Setup the skbuff rings */

 set bd status and length */

 clear bd buffer */

 set bd status and length */

 for last BD set Wrap bit */

 Calculate rx_extended_features */

                    Set UPSMR                      */

 For more details see the hardware spec.           */

 We're going to ignore other registers for now, */

 except as needed to get up and running         */

                    Set MACCFG1                    */

 For more details see the hardware spec.           */

                    Set IPGIFG                     */

 For more details see the hardware spec.           */

                    Set HAFDUP                     */

 For more details see the hardware spec.           */

                    Set IFSTAT                     */

 For more details see the hardware spec.           */

 Read only - resets upon read                      */

                    Clear UEMPR                    */

 For more details see the hardware spec.           */

                    Set UESCR                      */

 For more details see the hardware spec.           */

	/*

	 * Global PRAM

 Tx global PRAM */

 Allocate global tx parameter RAM page */

 Fill global PRAM */

 TQPTR */

 Size varies with number of Tx threads */

 vtagtable */

 iphoffset */

 SQPTR */

 Size varies with number of Tx queues */

 Setup the table */

 Assume BD rings are already established */

 schedulerbasepointer */

 scheduler exists only if more than 1 tx queue */

 Set values in scheduler */

 Set pointers to cpucount registers in scheduler */

 schedulerbasepointer */

 TxRMON_PTR (statistics) */

 temoder */

 Already has speed set */

 Function code register value to be used later */

 Required for QE */

 function code register */

 Rx global PRAM */

 Allocate global rx parameter RAM page */

 Fill global PRAM */

 RQPTR */

 Size varies with number of Rx threads */

 typeorlen */

 rxrmonbaseptr (statistics) */

 intCoalescingPtr */

 Size varies with number of Rx queues */

 Fill interrupt coalescing table */

 MRBLR */

 MFLR */

 MINFLR */

 MAXD1 */

 MAXD2 */

 l2qt */

 l3qt */

 vlantype */

 vlantci */

 ecamptr */

 RBDQPTR */

 Size varies with number of Rx queues */

 Setup the table */

 Assume BD rings are already established */

 rest of fields handled by QE */

 remoder */

 Already has speed set */

 Note that this function must be called */

 ONLY AFTER p_tx_fw_statistics_pram */

 andp_UccGethRxFirmwareStatisticsPram are allocated ! */

 function code register */

 initialize extended filtering */

		/* Allocate memory for extended filtering Mode Global

 initialize 82xx style address filtering */

 Init individual address recognition registers to disabled */

	/*

	 * Initialize UCC at QE level

	/* Allocate shadow InitEnet command parameter structure.

	 * This is needed because after the InitEnet command is executed,

	 * the structure in DPRAM is released, because DPRAM is a premium

	 * resource.

	 * This shadow structure keeps a copy of what was done so that the

	 * allocated resources can be released when the channel is freed.

 Fill shadow InitEnet command parameter structure */

 Rx needs one extra for terminator */

 Load Rx bds with buffers */

 Allocate InitEnet command parameter structure */

 Copy shadow InitEnet command parameter structure into PRAM */

 Issue QE command */

 Free InitEnet command parameter */

 This is called by the kernel when a frame is ready for transmission. */

 It is pointed to by the dev->hard_start_xmit function pointer */

 BD pointer */

 Start from the next BD that should be filled */

 Save the skb pointer so we can free it later */

 Update the current skb pointer (wrapping if this was the last) */

 set up the buffer descriptor */

 printk(KERN_DEBUG"skb->data is 0x%x\n",skb->data); */

 set bd status and length */

 Move to next BD in the ring */

	/* If the next BD still needs to be cleaned up, then the bds

		/* Indicate to QE that there are more Tx bds ready for

		/* This is done by writing a running counter of the bd

 collect received buffers */

 while there are received buffers and BD is full (~R_E) */

		/* determine whether buffer is first, last, first and last

 Prep the skb for the packet */

 Tell the skb what kind of packet this is */

 Send the packet up the stack */

 update to point at the next skb */

 Start from the next BD that should be filled */

 BD pointer */

 Normal processing. */

 BD contains already transmitted buffer.   */

 Handle the transmitted buffer and release */

 the BD to be used with the current frame  */

 We freed a buffer, so now we can restart transmission */

 Advance the confirmation BD pointer */

 Tx event processing */

 read and clear events */

 check for receive events that require processing */

 Errors and other events */

/*

 * Polling 'interrupt' - used by things like netconsole to send skbs

 * without having to re-enable interrupts. It's not called while

 * the interrupt routine is executing.

 CONFIG_NET_POLL_CONTROLLER */

	/*

	 * If device is not running, we will set mac addr register

	 * when opening the device.

       Set MACSTNADDR1, MACSTNADDR2                */

 For more details see the hardware spec.           */

 Called when something needs to use the ethernet device */

 Returns 0 for success. */

 Test station address */

 Stops the kernel queue, and halts the controller */

 Reopen device. This will reset the MAC and PHY. */

		/*

		 * Must reset MAC *and* PHY. This is done by reopening

		 * the device.

 Must start PHY here */

/*

 * ucc_geth_timeout gets called when a packet has not been

 * transmitted after a set amount of time.

	/*

	 * Disable the controller, otherwise we'll wakeup on any network

	 * activity.

		/*

		 * Full reinitialization is required if QE shuts down

		 * during sleep.

			/* If both *-clock-name and *-clock are missing,

			 * we want to tell people to use *-clock-name.

		/*

		 * In the case of a fixed PHY, the DT node associated

		 * to the PHY is the Ethernet MAC DT node.

 Find the TBI PHY node.  If it's not there, we don't support SGMII */

 get the phy interface type, or default to MII */

 handle interface property present in old trees */

 get speed, or derive from PHY interface */

 configure muram FIFOs for gigabit operation */

		/* If QE's snum number is 46/76 which means we need to support

		 * 4 UECs at 1000Base-T simultaneously, we need to allocate

		 * more Threads to Rx.

 Create an ethernet device instance */

 Create CQs for hash tables */

 Set the dev->base_addr to the gfar reg region */

 Fill in the dev structure */

 Carrier starts down, phylib will bring it up */

 SPDX-License-Identifier: GPL-2.0-or-later

/* drivers/net/ethernet/freescale/gianfar.c

 *

 * Gianfar Ethernet Driver

 * This driver is designed for the non-CPM ethernet controllers

 * on the 85xx and 83xx family of integrated processors

 * Based on 8260_io/fcc_enet.c

 *

 * Author: Andy Fleming

 * Maintainer: Kumar Gala

 * Modifier: Sandeep Gopalpet <sandeep.kumar@freescale.com>

 *

 * Copyright 2002-2009, 2011-2013 Freescale Semiconductor, Inc.

 * Copyright 2007 MontaVista Software, Inc.

 *

 *  Gianfar:  AKA Lambda Draconis, "Dragon"

 *  RA 11 31 24.2

 *  Dec +69 19 52

 *  V 3.84

 *  B-V +1.62

 *

 *  Theory of operation

 *

 *  The driver is initialized through of_device. Configuration information

 *  is therefore conveyed through an OF-style device tree.

 *

 *  The Gianfar Ethernet Controller uses a ring of buffer

 *  descriptors.  The beginning is indicated by a register

 *  pointing to the physical address of the start of the ring.

 *  The end is determined by a "wrap" bit being set in the

 *  last descriptor of the ring.

 *

 *  When a packet is received, the RXF bit in the

 *  IEVENT register is set, triggering an interrupt when the

 *  corresponding bit in the IMASK register is also set (if

 *  interrupt coalescing is active, then the interrupt may not

 *  happen immediately, but will wait until either a set number

 *  of frames or amount of time have passed).  In NAPI, the

 *  interrupt handler will signal there is work to be done, and

 *  exit. This method will start at the last known empty

 *  descriptor, and process every subsequent descriptor until there

 *  are none left with data (NAPI will stop after a set number of

 *  packets to give time to other tasks, but will eventually

 *  process all the packets).  The data arrives inside a

 *  pre-allocated skb, and so after the skb is passed up to the

 *  stack, a new skb must be allocated, and the address field in

 *  the buffer descriptor must be updated to indicate this new

 *  skb.

 *

 *  When the kernel requests that a packet be transmitted, the

 *  driver starts where it left off last time, and points the

 *  descriptor at the buffer which was passed in.  The driver

 *  then informs the DMA engine that there are packets ready to

 *  be transmitted.  Once the controller is finished transmitting

 *  the packet, an interrupt may be triggered (under the same

 *  conditions as for reception, but depending on the TXF bit).

 *  The driver then cleans up the buffer.

 set this when rx hw offload (TOE) functions are being used */

 Program the RIR0 reg with the required distribution */

 Restore PROMISC mode */

 Enable HW time stamping if requested from user space */

 Clear the LFC bit */

 Init flow control threshold values */

 Init rctrl based on our settings */

		/* Backward compatible case -- even if we enable

		 * multiple queues, there's only single reg to program

 Set the appropriate hash bit for the given addr */

/* The algorithm works like so:

 * 1) Take the Destination Address (ie the multicast address), and

 * do a CRC on it (little endian), and reverse the bits of the

 * result.

 * 2) Use the 8 most significant bits as a hash into a 256-entry

 * table.  The table is controlled through 8 32-bit registers:

 * gaddr0-7.  gaddr0's MSB is entry 0, and gaddr7's LSB is

 * gaddr7.  This means that the 3 most significant bits in the

 * hash index which gaddr register to use, and the 5 other bits

 * indicate which bit (assuming an IBM numbering scheme, which

 * for PowerPC (tm) is usually the case) in the register holds

 * the entry.

/* There are multiple MAC Address register pairs on some controllers

 * This function sets the numth pair to a given address

	/* For a station address of 0x12345678ABCD in transmission

	 * order (BE), MACnADDR1 is set to 0xCDAB7856 and

	 * MACnADDR2 is set to 0x34120000.

 Clear IEVENT */

 Initialize IMASK */

 Unmask the interrupts we look for */

 If we aren't the FEC we have multiple interrupts */

 One Q per interrupt group: Q0 to G0, Q1 to G1 */

	/* bit_map's MSB is q0 (from q0 to q7) but, for_each_set_bit parses

	 * right to left, so we need to revert the 8 bits to get the q index

	/* Calculate RSTAT, TSTAT, RQUEUE and TQUEUE values,

	 * also assign queues to groups

/* Reads the controller's registers to determine what interface

 * connects it to the PHY.

			/* This isn't autodetected right now, so it must

			 * be set by the device tree or platform code.

 MQ_MG_MODE */

 get the actual number of supported groups */

 one txq per int group */

 one rxq per int group */

 Init Rx queue filer rule set linked list */

 Parse and initialize group specific information */

 SQ_SG_MODE */

	/* Use PHY connection type from the DT node if one is specified there.

	 * rgmii-id really needs to be specified. Other types can be

	 * detected by hardware

	/* In the case of a fixed PHY, the DT node associated

	 * to the PHY is the Ethernet MAC DT node.

 Find the TBI PHY.  If it's not there, we don't support SGMII */

 Default rule */

 cur_filer_idx indicated the first non-masked rule */

 Rest are masked rules */

 w/o E suffix */

 MPC8313 Rev 2.0 and higher; All MPC837x */

 MPC8313 and MPC837x all rev */

 MPC8313 Rev < 2.0 */

 P2020/P1010 Rev 1; MPC8548 Rev 2 */

 aka eTSEC 20 */

 no plans to fix */

 non-mpc85xx parts, i.e. e300 core based */

	/* Normaly TSEC should not hang on GRS commands, so we should

	 * actually wait for IEVENT_GRSC flag.

	/* Read the eTSEC register at offset 0xD1C. If bits 7-14 are

	 * the same as bits 23-30, the eTSEC Rx is assumed to be idle

	 * and the Rx can be safely reset.

 Halt the receive and transmit queues */

 Stop the DMA, and wait for it to stop */

 Halt the receive and transmit queues */

 Dissable the Rx/Tx hw queues */

 Disable Rx/Tx DMA */

/* If there are any tx skbs or rx skbs still around, free them.

 * Then free tx_skbuff and rx_skbuff

 Go through all the buffer descriptors and free their data buffers */

 disable ints and gracefully shut down Rx/Tx DMA */

 Enable Rx/Tx hw queues */

 Initialize DMACTRL to have WWR and WOP */

 Make sure we aren't stopped */

 Clear THLT/RHLT, so that the DMA starts polling now */

 Enable Rx/Tx DMA */

 prevent tx timeout */

 try reuse page */

 Setup the new RxBD */

 Update to the next pointer */

 Initialize some variables in our dev structure */

 Initialize Transmit Descriptor Ring */

 Set the last descriptor in the ring to indicate wrap */

		/* make sure next_to_clean != next_to_use after this

		 * by leaving at least 1 unused descriptor

 Allocate memory for the buffer descriptors */

 enet DMA only understands physical addresses */

 Start the rx descriptor ring where the tx ring leaves off */

 Setup the skbuff rings */

 Bring the controller up and running */

 Start Rx/Tx DMA and enable the interrupts */

 force link state update after mac reset */

 get link partner capabilities */

				/* Reduced mode distinguishes

				 * between 10 and 100

 Turn last free buffer recording on */

/* Called every time the controller might need to be made

 * aware of new link state.  The PHY code conveys this

 * information through variables in the phydev structure, and this

 * function converts those variables into the appropriate

 * register values, and can bring down the device if needed.

/* Initialize TBI PHY interface for communicating with the

 * SERDES lynx PHY on the chip.  We communicate with this PHY

 * through the MDIO bus on each controller, treating it as a

 * "normal" PHY at the address found in the TBIPA register.  We assume

 * that the TBIPA register is valid.  Either the MDIO bus code will set

 * it to a value that doesn't conflict with other PHYs on the bus, or the

 * value doesn't matter, as there are no other PHYs on the bus.

	/* If the link is already up, we must already be ok, and don't need to

	 * configure and reset the TBI<->SerDes link.  Maybe U-Boot configured

	 * everything for us?  Resetting it takes the link down and requires

	 * several seconds for it to come back.

 Single clk mode, mii mode off(for serdes communication) */

/* Initializes driver's PHY state, and attaches to the PHY.

 * Returns 0 on success.

 Remove any features not supported by the controller */

 Add support for flow control */

 disable EEE autoneg, EEE not supported by eTSEC */

	/* If we're here, it's a IP packet with a TCP or UDP

	 * payload.  We set it to checksum, using a pseudo-header

	 * we provide

	/* Tell the controller what the protocol is

	 * And provide the already calculated phcs

	/* l3os is the distance between the start of the

	 * frame (skb->data) and the start of the IP hdr.

	 * l4os is the distance between the start of the

	 * l3 hdr and the l4 hdr

 eTSEC12: csum generation not supported for some fcb offsets */

/* eTSEC76: csum generation for frames larger than 2500 may

 * cause excess delays before start of transmission

/* This is called by the kernel when a frame is ready for transmission.

 * It is pointed to by the dev->hard_start_xmit function pointer

 check if time stamp should be generated */

 make space for additional header when fcb is needed */

 total number of fragments in the SKB */

 calculate the required number of TxBDs for this skb */

 check if there is space to queue this packet */

 no space, stop the queue */

 Update transmit stats */

 keep Tx bytes on wire for BQL accounting */

 Add TxPAL between FCB and frame if required */

 Add TxFCB if required */

 Set up checksumming */

 put back a new fcb for vlan/tstamp TOE */

 Tx TOE not used */

 Time stamp insertion requires one additional TxBD */

 Place the fragment addresses and lengths into the TxBDs */

 Point at the next BD, wrapping as needed */

 Handle the last BD specially */

 set the TxBD length and buffer pointer */

	/* If time stamping is requested one additional TxBD must be set up. The

	 * first TxBD points to the FCB and must have a data length of

	 * GMAC_FCB_LEN. The second TxBD points to the actual frame data with

	 * the full frame length.

 Setup tx hardware time stamping */

 force lstatus write before tx_skbuff */

	/* Update the current skb pointer to the next entry we will use

	 * (wrapping if necessary)

	/* We can work in parallel with gfar_clean_tx_ring(), except

	 * when modifying num_txbdfree. Note that we didn't grab the lock

	 * when we were reading the num_txbdfree and checking for available

	 * space, that's because outside of this function it can only grow.

 reduce TxBD free count */

	/* If the next BD still needs to be cleaned up, then the bds

	 * are full.  We need to tell the kernel to stop sending us stuff.

 Tell the DMA to go go go */

 Changes the mac address if the controller is not running. */

/* gfar_reset_task gets scheduled when a packet has not been

 * transmitted after a set amount of time.

 * For now, assume that clearing out all the structures, and

 * starting over will fix the problem.

 reserved for future extensions */

 Interrupt Handler for Transmit complete */

		/* When time stamping, one additional TxBD must be freed.

		 * Also, we need to dma_unmap_single() the TxPAL.

 Only clean completed frames */

 If we freed a buffer, we can restart transmission, if necessary */

 Update dirty indicators */

 If the packet was truncated, none of the other errors matter */

 Count the errors, if there were any */

		/* Clear IEVENT, so interrupts aren't called again

		 * because of the packets that have already arrived.

 Interrupt Handler for Transmit complete */

		/* Clear IEVENT, so interrupts aren't called again

		 * because of the packets that have already arrived.

 the last fragments' length contains the full frame length */

 try reuse page */

 change offset to the other half */

 find next buf that can reuse a page */

 copy page reference */

 sync for use by the device */

 reuse the free half of the page */

 page cannot be reused, unmap it */

 clear rxb content */

	/* If valid headers were found, and valid sums

	 * were verified, then we tell the kernel that no

	 * checksumming is necessary.  Otherwise, it is [FIXME]

 gfar_process_frame() -- handle one incoming packet if skb isn't NULL. */

 fcb is at the beginning if exists */

	/* Remove the FCB from the skb

	 * Remove the padded bytes, if there are any

 Get receive timestamp from the skb */

 Trim off the FCS */

	/* There's need to check for NETIF_F_HW_VLAN_CTAG_RX here.

	 * Even if vlan rx accel is disabled, on some chips

	 * RXFCB_VLN is pseudo randomly set.

/* gfar_clean_rx_ring() -- Processes each frame in the rx ring

 * until the budget/quota has been reached. Returns the number

 * of frames handled

 Get the first full descriptor */

 lost RXBD_LAST descriptor due to overrun */

 discard faulty buffer */

 can continue normally */

 order rx buffer descriptor reads */

 fetch next to clean buffer from the ring */

 fetch next buffer if not the last in frame */

 discard faulty buffer */

 Increment the number of packets */

 Send the packet up the stack */

 Store incomplete frames for completion */

 Update Last Free RxBD pointer for LFC */

	/* Clear IEVENT, so interrupts aren't called again

	 * because of the packets that have already arrived

 Clear the halt bit in RSTAT */

	/* Clear IEVENT, so interrupts aren't called again

	 * because of the packets that have already arrived

 run Tx cleanup to completion */

 GFAR error interrupt handler */

 Save ievent for future reference */

 Clear IEVENT */

 Magic Packet is not an error. */

 Hmm... */

 Update the error counters */

 The interrupt handler for devices with one interrupt */

 Save ievent for future reference */

 Check for reception */

 Check for transmit completion */

 Check for errors */

/* Polling 'interrupt' - used by things like netconsole to send skbs

 * without having to re-enable interrupts. It's not called while

 * the interrupt routine is executing.

 If the device has multiple interrupts, run tx/rx */

	/* If the device has multiple interrupts, register for

	 * them.  Otherwise, only register for the one

		/* Install our interrupt handlers for Error,

		 * Transmit, and Receive

 Free the IRQs */

/* Called when something needs to use the ethernet device

 * Returns 0 for success.

 Stops the kernel queue, and halts the controller */

 Disconnect from the PHY */

/* Clears each of the exact match registers to zero, so they

 * don't interfere with normal reception

/* Update the hash table based on the current list of multicast

 * addresses we subscribe to.  Also, change the promiscuity of

 * the device based on the flags (this function is called

 * whenever dev->flags is changed

 Set RCTRL to PROM */

 Set RCTRL to not PROM */

 Set the hash to rx all multicast frames */

 zero out the hash */

		/* If we have extended hash tables, we need to

		 * clear the exact match registers to prepare for

		 * setting them

 Parse the list, and set the appropriate bits */

 Reset MAC layer */

 We need to delay at least 3 TX clocks */

	/* the soft reset bit is not self-resetting, so we need to

	 * clear it before resuming normal operation

 Initialize the max receive frame/buffer lengths */

 Initialize the Minimum Frame Length Register */

 Initialize MACCFG2. */

	/* eTSEC74 erratum: Rx frames of length MAXFRM or MAXFRM-1

	 * are marked as truncated.  Avoid this by MACCFG2[Huge Frame]=1,

	 * and by checking RxBD[LG] and discarding larger than MAXFRM.

 Clear mac addr hash registers */

 clear ievent and imask before configuring coalescing */

 Configure the coalescing support */

	/* Stop the DMA engine now, in case it was running before

	 * (The firmware could have used it, and left it running).

 Zero out the rmon mib registers if it has them */

 Mask off the CAM interrupts */

 Clear the CAR registers (w1c style) */

 Initialize ECNTRL */

 Set the extraction length and index */

	/* Start with defaults, and add stashing

	 * depending on driver parameters

 FIFO configs */

 Program the interrupt steering regs, only for MG devices */

/* Set up the ethernet device structure, private data,

 * and anything else we need before we start

 Set the dev->base_addr to the gfar reg region */

 Fill in the dev structure */

 MTU range: 50 - 9586 */

 Register for napi ...We are registering NAPI for each grp */

	/* Insert receive time stamps into padding alignment bytes, and

	 * plus 2 bytes padding to ensure the cpu alignment.

 Initializing some of the rx/tx queue level parameters */

 Always enable rx filer if available */

 Enable most messages by default */

 use pritority h/w tx queue scheduling for single queue devices */

 Carrier starts down, phylib will bring it up */

 fill out IRQ number and name fields */

 Initialize the filer table */

 Print out the device info */

	/* Even more device info helps when determining which kernel

	 * provided which set of benchmarks.

 Filer rules implementing wol capabilities */

 clear the filer table, reject any packet by default */

 unicast packet, accept it */

 get the default rx queue index */

 gfar_start() for Rx only and with the FGPI filer interrupt enabled */

 Enable Rx hw queues */

 Initialize DMACTRL to have WWR and WOP */

 Make sure we aren't stopped */

 Clear RHLT, so that the DMA starts polling now */

 enable the Filer General Purpose Interrupt */

 Enable Rx DMA */

 Enable interrupt on Magic Packet */

 Enable Magic Packet mode */

 re-enable the Rx block */

 Disable Magic Packet mode */

 need to stop rx only, tx is already down */

 Structure for a device driver */

/*

 * QorIQ 10G MDIO Controller

 *

 * Copyright 2012 Freescale Semiconductor, Inc.

 * Copyright 2021 NXP

 *

 * Authors: Andy Fleming <afleming@freescale.com>

 *          Timur Tabi <timur@freescale.com>

 *

 * This file is licensed under the terms of the GNU General Public License

 * version 2.  This program is licensed "as is" without any warranty of any

 * kind, whether express or implied.

 Number of microseconds to wait for a register to respond */

 MDIO configuration and status */

 MDIO control */

 MDIO data */

 MDIO address */

/*

 * Wait until the MDIO bus is free

 Wait till the bus is free */

/*

 * Wait till the MDIO read or write operation is complete

 Wait till the MDIO write is complete */

/*

 * Write value to the PHY for this device to the register at regnum,waiting

 * until the write is done before it returns.  All PHY configuration has to be

 * done through the TSEC1 MIIM regs.

 Clause 45 (ie 10G) */

 Clause 22 (ie 1G) */

 Set the port and dev addr */

 Set the register address */

 Write the value to the register */

/*

 * Reads from register regnum in the PHY for device dev, returning the value.

 * Clears miimcom first.  All PHY configuration has to be done through the

 * TSEC1 MIIM regs.

 Set the Port and Device Addrs */

 Set the register address */

 Initiate the read */

 Return all Fs if nothing was there */

	/* In DPAA-1, MDIO is one of the many FMan sub-devices. The FMan

	 * defines a register space that spans a large area, covering all the

	 * subdevice areas. Therefore, MDIO cannot claim exclusive access to

	 * this register area.

 Set the PHY base address */

	/* For both ACPI and DT cases, endianness of MDIO controller

	 * needs to be specified using "little-endian" property.

/*

 * Copyright 2008-2015 Freescale Semiconductor Inc.

 *

 * Redistribution and use in source and binary forms, with or without

 * modification, are permitted provided that the following conditions are met:

 *     * Redistributions of source code must retain the above copyright

 *       notice, this list of conditions and the following disclaimer.

 *     * Redistributions in binary form must reproduce the above copyright

 *       notice, this list of conditions and the following disclaimer in the

 *       documentation and/or other materials provided with the distribution.

 *     * Neither the name of Freescale Semiconductor nor the

 *       names of its contributors may be used to endorse or promote products

 *       derived from this software without specific prior written permission.

 *

 *

 * ALTERNATIVELY, this software may be distributed under the terms of the

 * GNU General Public License ("GPL") as published by the Free Software

 * Foundation, either version 2 of that License or (at your option) any

 * later version.

 *

 * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY

 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED

 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE

 * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY

 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES

 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;

 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND

 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT

 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS

 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/**

 * fman_muram_init

 * @base:	Pointer to base of memory mapped FM-MURAM.

 * @size:	Size of the FM-MURAM partition.

 *

 * Creates partition in the MURAM.

 * The routine returns a pointer to the MURAM partition.

 * This pointer must be passed as to all other FM-MURAM function calls.

 * No actual initialization or configuration of FM_MURAM hardware is done by

 * this routine.

 *

 * Return: pointer to FM-MURAM object, or NULL for Failure.

/**

 * fman_muram_offset_to_vbase

 * @muram:	FM-MURAM module pointer.

 * @offset:	the offset of the memory block

 *

 * Gives the address of the memory region from specific offset

 *

 * Return: The address of the memory block

/**

 * fman_muram_alloc

 * @muram:	FM-MURAM module pointer.

 * @size:	Size of the memory to be allocated.

 *

 * Allocate some memory from FM-MURAM partition.

 *

 * Return: address of the allocated memory; NULL otherwise.

/**

 * fman_muram_free_mem

 * @muram:	FM-MURAM module pointer.

 * @offset:	offset of the memory region to be freed.

 * @size:	size of the memory to be freed.

 *

 * Free an allocated memory from FM-MURAM partition.

/*

 * Copyright 2017 NXP

 *

 * Redistribution and use in source and binary forms, with or without

 * modification, are permitted provided that the following conditions are met:

 *     * Redistributions of source code must retain the above copyright

 *       notice, this list of conditions and the following disclaimer.

 *     * Redistributions in binary form must reproduce the above copyright

 *       notice, this list of conditions and the following disclaimer in the

 *       documentation and/or other materials provided with the distribution.

 *     * Neither the name of NXP nor the

 *       names of its contributors may be used to endorse or promote products

 *       derived from this software without specific prior written permission.

 *

 *

 * ALTERNATIVELY, this software may be distributed under the terms of the

 * GNU General Public License ("GPL") as published by the Free Software

 * Foundation, either version 2 of that License or (at your option) any

 * later version.

 *

 * THIS SOFTWARE IS PROVIDED BY NXP ``AS IS'' AND ANY

 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED

 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE

 * DISCLAIMED. IN NO EVENT SHALL NXP BE LIABLE FOR ANY

 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES

 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;

 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND

 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT

 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS

 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 Maximum number of HW Ports */

 Maximum number of KeyGen Schemes */

 Number of generic KeyGen Generic Extract Command Registers */

 Dummy port ID */

 Select Scheme Value Register */

 Registers Shifting values */

 KeyGen Registers bit field masks: */

 Enable bit field mask for KeyGen General Configuration Register */

 KeyGen Global Registers bit field masks */

 Error events exceptions */

 Scheme Registers bit field masks */

 Known Protocol field codes */

 NIA values */

/* Hard-coded configuration:

 * These values are used as hard-coded values for KeyGen configuration

 * and they replace user selections for this hard-coded version

 Hash distribution shift */

 Hash shift */

/* Symmetric hash usage:

 * Warning:

 * - the value for symmetric hash usage must be in accordance with hash

 *	key defined below

 * - according to tests performed, spreading is not working if symmetric

 *	hash is set on true

 * So ultimately symmetric hash functionality should be always disabled:

 Hash Key extraction fields: */

/* Default values to be used as hash key in case IPv4 or L4 (TCP, UDP)

 * don't exist in the frame

 Default IPv4 address */

 Default L4 port */

 KeyGen Memory Mapped Registers: */

 Scheme Configuration RAM Registers */

 0x100: MODE */

 0x104: Extract Known Fields Command */

 0x108: Extract Known Default Value */

 0x10C: Bit Mask Command High */

 0x110: Bit Mask Command Low */

 0x114: Frame Queue Base */

 0x118: Hash Command */

 0x11C: Policer Profile Command */

 0x120: Generic Extract Command */

 0x140: KeyGen Scheme Entry Statistic Packet Counter */

 0x144: KeyGen Scheme Entry Default Value 0 */

 0x148: KeyGen Scheme Entry Default Value 1 */

 0x14C: KeyGen Scheme Entry Coarse Classification Bit*/

 0x150: KeyGen Scheme Entry Match vector */

 0x154: KeyGen Scheme Entry Operation Mode bits */

 0x158: KeyGen Scheme Entry Virtual Storage Profile */

 Port Partition Configuration Registers */

 0x100: KeyGen Port entry Scheme Partition */

 0x104: KeyGen Port Entry Classification Plan Partition */

/* General Configuration and Status Registers

 * Global Statistic Counters

 * KeyGen Global Registers

 0x000: KeyGen General Configuration Register */

 0x004: Reserved */

 0x008: Reserved */

 0x00C: KeyGen Error Event Register */

 0x010: KeyGen Error Event Enable Register */

 0x014: Reserved */

 0x018: Reserved */

 0x01C: KeyGen Scheme Error Event Register */

 0x020: KeyGen Scheme Error Event Enable Register */

 0x024: KeyGen Global Status Register */

 0x028: Total Packet Counter Register */

 0x02C: Soft Error Capture Register */

 0x030: Reserved */

 0x034: Frame Data Offset Register */

 0x038: Global Default Value Register 0 */

 0x03C: Global Default Value Register 1 */

 0x040: Reserved */

 0x044: Force Error Event Register */

 0x048: Reserved */

 0x100: Indirect Access Registers */

 Scheme Registers */

 Port Partition Registers */

 0x1FC: KeyGen Action Register */

 KeyGen Scheme data */

 Specifies if this scheme is used */

		/* Hardware port ID

		 * schemes sharing between multiple ports is not

		 * currently supported

		 * so we have only one port id bound to a scheme

		/* Base FQID:

		 * Must be between 1 and 2^24-1

		 * If hash is used and an even distribution is

		 * expected according to hash_fqid_count,

		 * base_fqid must be aligned to hash_fqid_count

		/* FQ range for hash distribution:

		 * Must be a power of 2

		 * Represents the range of queues for spreading

 Usage of Hashing and spreading over FQ */

 Symmetric Hash option usage */

		/* Hash result right shift.

		 * Select the 24 bits out of the 64 hash result.

		 * 0 means using the 24 LSB's, otherwise

		 * use the 24 LSB's after shifting right

 Match Vector */

 KeyGen driver data */

 Array of schemes */

 KeyGen registers */

/* keygen_write_ar_wait

 *

 * Write Action Register with specified value, wait for GO bit field to be

 * idle and then read the error

 *

 * regs: KeyGen registers

 * fmkg_ar: Action Register value

 *

 * Return: Zero for success or error code in case of failure

 Wait for GO bit field to be idle */

/* build_ar_scheme

 *

 * Build Action Register value for scheme settings

 *

 * scheme_id: Scheme ID

 * update_counter: update scheme counter

 * write: true for action to write the scheme or false for read action

 *

 * Return: AR value

/* build_ar_bind_scheme

 *

 * Build Action Register value for port binding to schemes

 *

 * hwport_id: HW Port ID

 * write: true for action to write the bind or false for read action

 *

 * Return: AR value

/* keygen_write_sp

 *

 * Write Scheme Partition Register with specified value

 *

 * regs: KeyGen Registers

 * sp: Scheme Partition register value

 * add: true to add a scheme partition or false to clear

 *

 * Return: none

/* build_ar_bind_cls_plan

 *

 * Build Action Register value for Classification Plan

 *

 * hwport_id: HW Port ID

 * write: true for action to write the CP or false for read action

 *

 * Return: AR value

/* keygen_write_cpp

 *

 * Write Classification Plan Partition Register with specified value

 *

 * regs: KeyGen Registers

 * cpp: CPP register value

 *

 * Return: none

/* keygen_write_scheme

 *

 * Write all Schemes Registers with specified values

 *

 * regs: KeyGen Registers

 * scheme_id: Scheme ID

 * scheme_regs: Scheme registers values desired to be written

 * update_counter: update scheme counter

 *

 * Return: Zero for success or error code in case of failure

 Write indirect scheme registers */

 Write AR (Action register) */

/* get_free_scheme_id

 *

 * Find the first free scheme available to be used

 *

 * keygen: KeyGen handle

 * scheme_id: pointer to scheme id

 *

 * Return: 0 on success, -EINVAL when the are no available free schemes

/* get_scheme

 *

 * Provides the scheme for specified ID

 *

 * keygen: KeyGen handle

 * scheme_id: Scheme ID

 *

 * Return: handle to required scheme

/* keygen_bind_port_to_schemes

 *

 * Bind the port to schemes

 *

 * keygen: KeyGen handle

 * scheme_id: id of the scheme to bind to

 * bind: true to bind the port or false to unbind it

 *

 * Return: Zero for success or error code in case of failure

/* keygen_scheme_setup

 *

 * Setup the scheme according to required configuration

 *

 * keygen: KeyGen handle

 * scheme_id: scheme ID

 * enable: true to enable scheme or false to disable it

 *

 * Return: Zero for success or error code in case of failure

 Clear scheme registers */

 Setup all scheme registers: */

 Enable Scheme */

 Enqueue frame NIA */

	/* Scheme don't override StorageProfile:

	 * valid only for DPAA_VERSION >= 11

 Configure Hard-Coded Rx Hashing: */

 configure kgse_ekfc */

 configure kgse_ekdv */

 configure kgse_dv0 */

 configure kgse_dv1 */

 configure kgse_hc  */

			/* Normally extraction key should be verified if

			 * complies with symmetric hash

			 * But because extraction is hard-coded, we are sure

			 * the key is symmetric

 configure kgse_fqb: Scheme FQID base */

 features not used by hard-coded configuration */

 Write scheme registers */

 Update used field for Scheme */

/* keygen_init

 *

 * KeyGen initialization:

 * Initializes and enables KeyGen, allocate driver memory, setup registers,

 * clear port bindings, invalidate all schemes

 *

 * keygen_regs: KeyGen registers base address

 *

 * Return: Handle to KeyGen driver

 Allocate memory for KeyGen driver */

	/* KeyGen initialization (for Master partition):

	 * Setup KeyGen registers

	/* Clear binding between ports to schemes and classification plans

	 * so that all ports are not bound to any scheme/classification plan

 Clear all pe sp schemes registers */

 Clear all pe cpp classification plans registers */

 Enable all scheme interrupts */

 Enable KyeGen */

/* keygen_port_hashing_init

 *

 * Initializes a port for Rx Hashing with specified configuration parameters

 *

 * keygen: KeyGen handle

 * hw_port_id: HW Port ID

 * hash_base_fqid: Hashing Base FQID used for spreading

 * hash_size: Hashing size

 *

 * Return: Zero for success or error code in case of failure

 Validate Scheme configuration parameters */

 Find a free scheme */

 Create and configure Hard-Coded Scheme: */

	/* Clear all scheme fields because the scheme may have been

	 * previously used

 Setup scheme: */

	/* All Schemes in hard-coded configuration

	 * are Indirect Schemes

 Bind Rx port to Scheme */

/*

 * Copyright 2008-2015 Freescale Semiconductor Inc.

 *

 * Redistribution and use in source and binary forms, with or without

 * modification, are permitted provided that the following conditions are met:

 *     * Redistributions of source code must retain the above copyright

 *       notice, this list of conditions and the following disclaimer.

 *     * Redistributions in binary form must reproduce the above copyright

 *       notice, this list of conditions and the following disclaimer in the

 *       documentation and/or other materials provided with the distribution.

 *     * Neither the name of Freescale Semiconductor nor the

 *       names of its contributors may be used to endorse or promote products

 *       derived from this software without specific prior written permission.

 *

 *

 * ALTERNATIVELY, this software may be distributed under the terms of the

 * GNU General Public License ("GPL") as published by the Free Software

 * Foundation, either version 2 of that License or (at your option) any

 * later version.

 *

 * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY

 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED

 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE

 * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY

 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES

 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;

 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND

 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT

 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS

 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 PCS registers */

 SGMII Control defines */

 SGMII Device Ability for SGMII defines */

 Link timer define */

 SGMII IF Mode defines */

 Num of additional exact match MAC adr regs */

 Control and Configuration Register (COMMAND_CONFIG) */

 07 Rx low power indication */

 08 Tx Low Power Idle Enable */

 12 Enable PFC */

 14 Payload length check disable */

 19 S/W Reset, self clearing bit */

 20 Enable Tx padding of frames */

 23 Ignore Pause frame quanta */

 25 Terminate/frwd CRC of frames */

 26 Frame padding removal */

 27 Promiscuous operation enable */

 30 MAC receive path enable */

 31 MAC transmit path enable */

 Transmit FIFO Sections Register (TX_FIFO_SECTIONS) */

 Interface Mode Register (IF_MODE) */

 30-31 Mask on i/f mode bits */

 30-31 10G interface */

 30-31 MII interface */

 30-31 GMII (1G) interface */

 10 - 1000Mbps RGMII */

 00 - 100Mbps RGMII */

 01 - 10Mbps RGMII */

 Setsp mask bits */

 Full duplex RGMII */

 Half duplex operation */

 Hash table Control Register (HASHTABLE_CTRL) */

 26-31 Hash table address code */

 MAC mcast indication */

 Hash tbl size */

 Interrupt Mask Register (IMASK) */

 1 Magic pkt detect indication */

 2 Timestamp FIFO ECC error evnt */

 6 Transmit frame ECC error evnt */

 7 Receive frame ECC error evnt */

 PCS (XG). Link sync (G) */

 Auto-negotiation */

 Link Training/New page */

 Magic pkt detection */

 Timestamp FIFO ECC error*/

 Rx FIFO overflow */

 Tx FIFO underflow */

 Tx FIFO overflow */

 Tx frame ECC error */

 Rx frame ECC error */

 Link Interruption flt */

 Rx FIFO empty */

 Tx FIFO empty */

 Low Power Idle */

 Phy loss of signal */

 Remote fault (XGMII) */

 Local fault (XGMII) */

 Lower 32 bits of 48-bit MAC address */

 Upper 16 bits of 48-bit MAC address */

 memory map */

 General Control and Status */

 0x008 Ctrl and cfg */

 0x00C-0x010 MAC_ADDR_0...1 */

 0x014 Max frame length */

 Receive FIFO configuration reg */

 Transmit FIFO configuration reg */

 0x02C Hash table control */

 0x040 Interrupt event */

 0x044 Transmitter inter-packet-gap */

 0x04C Interrupt mask */

 0x054 Pause quanta */

 0x064 Pause quanta threshold */

 0x074 Receive pause status */

 0x80-0x0B4 mac padr */

 0x0B8 Low Power Wakeup Timer */

 0x0BC Transmit EEE Low Power Timer */

 0x0E0 Statistics configuration */

 Rx Statistics Counter */

 Tx Statistics Counter */

 Line Interface Control */

 0x300 Interface Mode Control */

 0x304 Interface Status */

 HiGig/2 */

 0x340 Control and cfg */

 0x350 Pause quanta */

 0x360 Pause quanta threshold */

 0x370 Receive pause status */

 0x374 fifos status */

 0x378 rx messages counter */

 0x37C tx messages counter */

 Pointer to MAC memory mapped registers */

 MAC address of device */

 Ethernet physical interface */

 device cookie used by the exception cbs */

 Pointer to driver's global address hash table  */

 Pointer to driver's individual address hash table  */

 Config */

 Payload length check disable */

 Enable padding of frames in transmit direction */

 Max Frame Length */

 Pause Time */

 IF_MODE */

 TX_FIFO_SECTIONS */

 clear all pending events and set-up interrupts */

 SGMII mode */

 AN enable */

 For 10M: IF_MODE[SPEED_10M] = 0 */

 Device ability according to SGMII specification */

	/* Adjust link timer for SGMII  -

	 * According to Cisco SGMII specification the timer should be 1.6 ms.

	 * The link_timer register is configured in units of the clock.

	 * - When running as 1G SGMII, Serdes clock is 125 MHz, so

	 * unit = 1 / (125*10^6 Hz) = 8 ns.

	 * 1.6 ms in units of 8 ns = 1.6ms / 8ns = 2*10^5 = 0x30d40

	 * - When running as 2.5G SGMII, Serdes clock is 312.5 MHz, so

	 * unit = 1 / (312.5*10^6 Hz) = 3.2 ns.

	 * 1.6 ms in units of 3.2 ns = 1.6ms / 3.2ns = 5*10^5 = 0x7a120.

	 * Since link_timer value of 1G SGMII will be too short for 2.5 SGMII,

	 * we always set up here a value of 2.5 SGMII.

 Restart AN */

 AN disabled */

 AN Device capability  */

	/* Adjust link timer for SGMII  -

	 * For Serdes 1000BaseX auto-negotiation the timer should be 10 ms.

	 * The link_timer register is configured in units of the clock.

	 * - When running as 1G SGMII, Serdes clock is 125 MHz, so

	 * unit = 1 / (125*10^6 Hz) = 8 ns.

	 * 10 ms in units of 8 ns = 10ms / 8ns = 1250000 = 0x1312d0

	 * - When running as 2.5G SGMII, Serdes clock is 312.5 MHz, so

	 * unit = 1 / (312.5*10^6 Hz) = 3.2 ns.

	 * 10 ms in units of 3.2 ns = 10ms / 3.2ns = 3125000 = 0x2faf08.

	 * Since link_timer value of 1G SGMII will be too short for 2.5 SGMII,

	 * we always set up here a value of 2.5 SGMII.

 Restart AN */

	/* Imask include both error and notification/event bits.

	 * Leaving only error bits enabled by imask.

	 * The imask error bits are shifted by 16 bits offset from

	 * their corresponding location in the ievent - hence the >> 16

	/* Imask include both error and notification/event bits.

	 * Leaving only error bits enabled by imask.

	 * The imask error bits are shifted by 16 bits offset from

	 * their corresponding location in the ievent - hence the >> 16

 release the driver's group hash table */

 release the driver's individual hash table */

 Checks if mEMAC driver parameters were initialized */

 Set full duplex */

 Configure RGMII in manual mode */

 Full duplex */

 Unicast addresses not supported in hash */

 Create element to be added to the driver hash table */

 Always enabled. */

 First, reset the MAC if desired. */

 MAC Address */

	/* FM_RX_FIFO_CORRUPT_ERRATA_10GMAC_A006320 errata workaround

	 * Exists only in FMan 6.0 and 6.3.

		/* MAC strips CRC from received frames - this workaround

		 * should decrease the likelihood of bug appearance

 Configure internal SGMII PHY */

 Configure 4 internal SGMII PHYs */

			/* QSGMII PHY address occupies 3 upper bits of 5-bit

			 * phy_address; the lower 2 bits are used to extend

			 * register address space and access each one of 4

			 * ports inside QSGMII.

 Max Frame Length */

 allocate memory for the m_emac data structure */

 allocate memory for the m_emac driver parameters data structure */

 Plant parameter structure pointer */

 Save FMan revision */

/* Copyright 2008-2015 Freescale Semiconductor, Inc.

 *

 * Redistribution and use in source and binary forms, with or without

 * modification, are permitted provided that the following conditions are met:

 *     * Redistributions of source code must retain the above copyright

 *	 notice, this list of conditions and the following disclaimer.

 *     * Redistributions in binary form must reproduce the above copyright

 *	 notice, this list of conditions and the following disclaimer in the

 *	 documentation and/or other materials provided with the distribution.

 *     * Neither the name of Freescale Semiconductor nor the

 *	 names of its contributors may be used to endorse or promote products

 *	 derived from this software without specific prior written permission.

 *

 *

 * ALTERNATIVELY, this software may be distributed under the terms of the

 * GNU General Public License ("GPL") as published by the Free Software

 * Foundation, either version 2 of that License or (at your option) any

 * later version.

 *

 * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY

 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED

 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE

 * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY

 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES

 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;

 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND

 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT

 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS

 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 List of multicast addresses */

 don't flag RX FIFO after the first */

 For 10G MAC, disable Tx ECC exception */

 For 1G MAC, disable by default the MIB counters overflow interrupt */

 Clear previous address list */

 Add all the addresses from the new list */

/**

 * fman_set_mac_active_pause

 * @mac_dev:	A pointer to the MAC device

 * @rx:		Pause frame setting for RX

 * @tx:		Pause frame setting for TX

 *

 * Set the MAC RX/TX PAUSE frames settings

 *

 * Avoid redundant calls to FMD, if the MAC driver already contains the desired

 * active PAUSE settings. Otherwise, the new active settings should be reflected

 * in FMan.

 *

 * Return: 0 on success; Error code otherwise.

/**

 * fman_get_pause_cfg

 * @mac_dev:	A pointer to the MAC device

 * @rx_pause:	Return value for RX setting

 * @tx_pause:	Return value for TX setting

 *

 * Determine the MAC RX/TX PAUSE frames settings based on PHY

 * autonegotiation or values set by eththool.

 *

 * Return: Pointer to FMan device.

	/* If PAUSE autonegotiation is disabled, the TX/RX PAUSE settings

	 * are those set by ethtool.

	/* Else if PAUSE autonegotiation is enabled, the TX/RX PAUSE

	 * settings depend on the result of the link negotiation.

 get local capabilities */

 get link partner capabilities */

	/* Calculate TX/RX settings based on local and peer advertised

	 * symmetric/asymmetric PAUSE capabilities.

 Save private information */

 Get the FM node */

 Get the FMan cell-index */

 cell-index 0 => FMan id 1 */

 Get the address of the memory mapped registers */

 Get the cell-index */

 Get the MAC address */

 Get the port handles */

 Find the port node */

 Get the PHY connection type */

 We don't support half-duplex in SGMII mode */

 Gigabit support (no half-duplex) */

 The 10G interface only supports one mode */

 Get the rest of the PHY information */

 pause frame autonegotiation enabled */

	/* By intializing the values to false, force FMD to enable PAUSE frames

	 * on RX and TX

/*

 * Copyright 2008-2015 Freescale Semiconductor Inc.

 *

 * Redistribution and use in source and binary forms, with or without

 * modification, are permitted provided that the following conditions are met:

 *     * Redistributions of source code must retain the above copyright

 *       notice, this list of conditions and the following disclaimer.

 *     * Redistributions in binary form must reproduce the above copyright

 *       notice, this list of conditions and the following disclaimer in the

 *       documentation and/or other materials provided with the distribution.

 *     * Neither the name of Freescale Semiconductor nor the

 *       names of its contributors may be used to endorse or promote products

 *       derived from this software without specific prior written permission.

 *

 *

 * ALTERNATIVELY, this software may be distributed under the terms of the

 * GNU General Public License ("GPL") as published by the Free Software

 * Foundation, either version 2 of that License or (at your option) any

 * later version.

 *

 * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY

 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED

 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE

 * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY

 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES

 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;

 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND

 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT

 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS

 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 TBI register addresses */

 TBICON register bit fields */

 Soft reset */

 Disable receive disparity */

 Disable transmit disparity */

 Auto-negotiation sense enable */

 Clock select */

 GMII mode (TBI if not set) */

 Interrupt Mask Register (IMASK) */

 dtsec timestamp event bits */

 Group address bit indication */

 Defaults */

 register related defines (bits, field offsets..) */

 Number of hash table registers */

 Hash table size (32 bits*8 regs) */

 Extended Hash table size (32 bits*16 regs) */

 dTSEC Memory Map registers */

 dTSEC General Control and Status Registers */

 0x000 ETSEC_ID register */

 0x004 ETSEC_ID2 register */

 0x008 Interrupt event register */

 0x00C Interrupt mask register */

 0x014 E control register */

 0x018 Pause time value register */

 0x01C TBI PHY address register */

 0x020 Time-stamp Control register */

 0x024 Time-stamp event register */

 0x028 Timer event mask register */

 0x040 Transmit control register */

 0x050 Receive control register */

 0x080-0x09C Individual/group address */

 0x0A0-0x0BC Group address registers 0-7 */

 0x100 MAC configuration #1 */

 0x104 MAC configuration #2 */

 0x108 IPG/IFG */

 0x10C Half-duplex */

 0x110 Maximum frame */

 0x13C Interface status */

 0x140 Station Address,part 1 */

 0x144 Station Address,part 2 */

 octets 1-4 */

 octets 5-6 */

 0x148-0x1BC mac exact match addresses 1-15 */

 0x200 Tx and Rx 64 byte frame counter */

 0x204 Tx and Rx 65 to 127 byte frame counter */

 0x208 Tx and Rx 128 to 255 byte frame counter */

 0x20C Tx and Rx 256 to 511 byte frame counter */

 0x210 Tx and Rx 512 to 1023 byte frame counter */

 0x214 Tx and Rx 1024 to 1518 byte frame counter */

 0x218 Tx and Rx 1519 to 1522 byte good VLAN frame count */

 0x21C receive byte counter */

 0x220 receive packet counter */

 0x224 receive FCS error counter */

 0x228 RMCA Rx multicast packet counter */

 0x22C Rx broadcast packet counter */

 0x230 Rx control frame packet counter */

 0x234 Rx pause frame packet counter */

 0x238 Rx unknown OP code counter */

 0x23C Rx alignment error counter */

 0x240 Rx frame length error counter */

 0x244 Rx code error counter */

 0x248 Rx carrier sense error counter */

 0x24C Rx undersize packet counter */

 0x250 Rx oversize packet counter */

 0x254 Rx fragments counter */

 0x258 Rx jabber counter */

 0x25C Rx drop */

 0x260 Tx byte counter */

 0x264 Tx packet counter */

 0x268 Tx multicast packet counter */

 0x26C Tx broadcast packet counter */

 0x270 Tx pause control frame counter */

 0x274 Tx deferral packet counter */

 0x278 Tx excessive deferral packet counter */

 0x27C Tx single collision packet counter */

 0x280 Tx multiple collision packet counter */

 0x284 Tx late collision packet counter */

 0x288 Tx excessive collision packet counter */

 0x28C Tx total collision counter */

 0x294 Tx drop frame counter */

 0x298 Tx jabber frame counter */

 0x29C Tx FCS error counter */

 0x2A0 Tx control frame counter */

 0x2A4 Tx oversize frame counter */

 0x2A8 Tx undersize frame counter */

 0x2AC Tx fragments frame counter */

 0x2B0 carry register one register* */

 0x2B4 carry register two register* */

 0x2B8 carry register one mask register */

 0x2BC carry register two mask register */

/* struct dtsec_cfg - dTSEC configuration

 * Transmit half-duplex flow control, under software control for 10/100-Mbps

 * half-duplex media. If set, back pressure is applied to media by raising

 * carrier.

 * halfdup_retransmit:

 * Number of retransmission attempts following a collision.

 * If this is exceeded dTSEC aborts transmission due to excessive collisions.

 * The standard specifies the attempt limit to be 15.

 * halfdup_coll_window:

 * The number of bytes of the frame during which collisions may occur.

 * The default value of 55 corresponds to the frame byte at the end of the

 * standard 512-bit slot time window. If collisions are detected after this

 * byte, the late collision event is asserted and transmission of current

 * frame is aborted.

 * tx_pad_crc:

 * Pad and append CRC. If set, the MAC pads all ransmitted short frames and

 * appends a CRC to every frame regardless of padding requirement.

 * tx_pause_time:

 * Transmit pause time value. This pause value is used as part of the pause

 * frame to be sent when a transmit pause frame is initiated.

 * If set to 0 this disables transmission of pause frames.

 * preamble_len:

 * Length, in bytes, of the preamble field preceding each Ethernet

 * start-of-frame delimiter byte. The default value of 0x7 should be used in

 * order to guarantee reliable operation with IEEE 802.3 compliant hardware.

 * rx_prepend:

 * Packet alignment padding length. The specified number of bytes (1-31)

 * of zero padding are inserted before the start of each received frame.

 * For Ethernet, where optional preamble extraction is enabled, the padding

 * appears before the preamble, otherwise the padding precedes the

 * layer 2 header.

 *

 * This structure contains basic dTSEC configuration and must be passed to

 * init() function. A default set of configuration values can be

 * obtained by calling set_dflts().

 pointer to dTSEC memory mapped registers */

 MAC address of device */

 Ethernet physical interface */

 device cookie used by the exception cbs */

 Number of individual addresses in registers for this station */

 pointer to driver's global address hash table */

 pointer to driver's individual address hash table */

 PHY address 0 is reserved (DPAA RM) */

 Soft reset */

 dtsec_id2 */

 check RGMII support */

 Accept short frames */

	/* Assign a Phy Address to the TBI (TBIPA).

	 * Done also in cases where TBI is not selected to avoid conflict with

	 * the external PHY's Physical address

 Full Duplex */

 Initialize Maximum frame length */

 HASH */

 Initialize IADDRx */

 Initialize GADDRx */

	/* If Auto negotiation process is disabled, need to set up the PHY

	 * using the MII Management Interface

 Checks if dTSEC driver parameters were initialized */

 do not handle MDIO events */

 FM_TX_LOCKUP_ERRATA_DTSEC6 Errata workaround */

			/* a. Write 0x00E0_0C00 to DTSEC_ID

			 *	This is a read only register

			 * b. Read and save the value of TPKT

 c. Read the register at dTSEC address offset 0x32C */

			/* d. Compare bits [9:15] to bits [25:31] of the

			 * register at address offset 0x32C.

				/* If they are not equal, save the value of

				 * this register and wait for at least

				 * MAXFRM*16 ns

			/* e. Read and save TPKT again and read the register

			 * at dTSEC address offset 0x32C again

			/* f. Compare the value of TPKT saved in step b to

			 * value read in step e. Also compare bits [9:15] of

			 * the register at offset 0x32C saved in step d to the

			 * value of bits [9:15] saved in step e. If the two

			 * registers values are unchanged, then the transmit

			 * portion of the dTSEC controller is locked up and

			 * the user should proceed to the recover sequence.

 recover sequence */

 a.Write a 1 to RCTRL[GRS] */

				/* b.Wait until IEVENT[GRSC]=1, or at least

				 * 100 us has elapsed.

				/* c.Write a 1 to bit n of FM_RSTC

				 * (offset 0x0CC of FPM)

 d.Wait 4 Tx clocks (32 ns) */

 e.Write a 0 to bit n of FM_RSTC. */

				/* cleared by FMAN

 masked interrupts */

 release the driver's group hash table */

 release the driver's individual hash table */

 Graceful stop - Assert the graceful Rx stop bit */

 Workaround for dTSEC Errata A002 */

 Workaround for dTSEC Errata A004839 */

 Graceful stop - Assert the graceful Tx stop bit */

 dTSEC Errata A004: Do not use TCTRL[GTS]=1 */

 Workaround for dTSEC Errata A0012, A0014 */

 Enable */

 Graceful start - clear the graceful Rx/Tx stop bit */

 Graceful stop - Assert the graceful Rx/Tx stop bit */

 FM_BAD_TX_TS_IN_B_2_B_ERRATA_DTSEC_A003 Errata workaround */

 trigger the transmission of a flow-control pause frame */

	/* Initialize MAC Station Address registers (1 & 2)

	 * Station address have to be swapped (big endian to little endian

 Cannot handle unicast mac addr when GHTX is on */

	/* considering the 9 highest order bits in crc H[8:0]:

	 *if ghtx = 0 H[8:6] (highest order 3 bits) identify the hash register

	 *and H[5:1] (next 5 bits) identify the hash bit

	 *if ghts = 1 H[8:5] (highest order 4 bits) identify the hash register

	 *and H[4:0] (next 5 bits) identify the hash bit.

	 *

	 *In bucket index output the low 5 bits identify the hash register

	 *bit, while the higher 4 bits identify the hash register

		/* if !ghtx and mcast the bit must be set in gaddr instead of

		 *igaddr.

 Create element to be added to the driver hash table */

 Group Address */

 Cannot handle unicast mac addr when GHTX is on */

		/* if !ghtx and mcast the bit must be set

		 * in gaddr instead of igaddr.

 Group Address */

 Individual Address */

 address does not exist */

 Set unicast promiscuous */

 Set multicast promiscuous */

 Full Duplex */

 Configure the TBI PHY Control Register */

 Max Frame Length */

 register err intr handler for dtsec to FPM (err) */

 register 1588 intr handler for TMR to FPM (normal) */

 allocate memory for the UCC GETH data structure. */

 allocate memory for the d_tsec driver parameters data structure. */

 Plant parameter structure pointer */

 Save FMan revision */

/*

 * Copyright 2008 - 2015 Freescale Semiconductor Inc.

 *

 * Redistribution and use in source and binary forms, with or without

 * modification, are permitted provided that the following conditions are met:

 *     * Redistributions of source code must retain the above copyright

 *       notice, this list of conditions and the following disclaimer.

 *     * Redistributions in binary form must reproduce the above copyright

 *       notice, this list of conditions and the following disclaimer in the

 *       documentation and/or other materials provided with the distribution.

 *     * Neither the name of Freescale Semiconductor nor the

 *       names of its contributors may be used to endorse or promote products

 *       derived from this software without specific prior written permission.

 *

 *

 * ALTERNATIVELY, this software may be distributed under the terms of the

 * GNU General Public License ("GPL") as published by the Free Software

 * Foundation, either version 2 of that License or (at your option) any

 * later version.

 *

 * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY

 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED

 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE

 * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY

 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES

 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;

 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND

 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT

 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS

 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 Queue ID */

 General defines */

 Default values */

 QMI defines */

 BMI defins */

 NIA defines */

 Port IDs */

 BMI Rx port register map */

 Rx Configuration */

 Rx Status */

 Rx DMA attributes */

 Rx FIFO Parameters */

 Rx Frame End Data */

 Rx Internal Context Parameters */

 Rx Internal Buffer Margins */

 Rx External Buffer Margins */

 Rx Frame Next Engine */

 Rx Frame Command Attributes. */

 Rx Frame Parser Next Engine */

 Rx Parse Start Offset */

 Rx Policer Profile  */

 Rx Coarse Classification Base */

 Rx Excessive Threshold */

 (0x03C 0x03F) */

 Rx Parse Results Array Init */

 Rx Frame Queue ID */

 Rx Error Frame Queue ID */

 Rx Frame Status Discard Mask */

 Rx Frame Status Error Mask */

 Rx Frame Enqueue Next Engine */

 (0x074-0x07C)  */

 Rx Frame Continuous Mode Next Engine */

 (0x080 0x0FF)  */

 Buffer Manager pool Information- */

 Allocate Counter- */

 0x130/0x140 - 0x15F reserved - */

 Congestion Group Map */

 BM Pool Depletion  */

 (0x184 0x1FF) */

 Rx Statistics Counters */

 Rx Frame Counter */

 Rx Bad Frames Counter */

 Rx Large Frames Counter */

 Rx Filter Frames Counter */

 Rx Frame Discard Counter */

 Rx Frames List DMA Error Counter */

 Rx Out of Buffers Discard nntr */

 Rx Buffers Deallocate Counter */

 RX Prepare to enqueue Counte */

 (0x224 0x27F) */

 Rx Performance Counters */

 Rx Performance Count Parameters */

 Rx Cycle Counter */

 Rx Tasks Utilization Counter */

 Rx Receive Queue Utilization cntr */

 Rx DMA Utilization Counter */

 Rx FIFO Utilization Counter */

 Rx Pause Activation Counter */

 (0x2A0 0x2FF) */

 Rx Debug Configuration */

 Rx General Purpose Register */

 BMI Tx port register map */

 Tx Configuration */

 Tx Status */

 Tx DMA attributes */

 Tx FIFO Parameters */

 Tx Frame End Data */

 Tx Internal Context Parameters */

 Tx Frame Dequeue Next Engine. */

 Tx Frame Command attribute. */

 Tx Confirmation Frame Queue ID. */

 Tx Frame Error Queue ID */

 Tx Frame Enqueue Next Engine */

 Tx Rate Limiter Scale */

 Tx Rate Limiter */

 (0x034-0x6c) */

 Tx Coarse Classification base */

 Tx Frame Next Engine */

 Tx Priority based Flow Control (PFC) Mapping */

 Tx Frame Continuous Mode Next Engine */

 (0x080-0x200) */

 Tx Statistics Counters */

 Tx Frame Counter */

 Tx Frames Discard Counter */

 Tx Frame len error discard cntr */

 Tx Frame unsprt frmt discard cntr */

 Tx Buffers Deallocate Counter */

 (0x218-0x280) */

 Tx Performance Counters */

 Tx Performance Count Parameters */

 Tx Cycle Counter */

 Tx Tasks Utilization Counter */

 Tx Transmit conf Q util Counter */

 Tx DMA Utilization Counter */

 Tx FIFO Utilization Counter */

 (0x29C-0x2FF) */

 Tx Debug Configuration */

 Tx General Purpose Register */

 (0x310-0x3FF) */

 BMI port register map */

 QMI port register map */

 PortID n Configuration Register */

 PortID n Status Register */

 PortID n Task Status Register */

 0xn00C - 0xn01B */

 PortID n Enqueue NIA Register */

 PortID n Enq Total Frame Counter */

 0xn024 - 0x02B */

 PortID n Dequeue NIA Register */

 PortID n Dequeue Config Register */

 PortID n Dequeue tot Frame cntr */

 PortID n Dequeue FQID Dflt Cntr */

 PortID n Dequeue Confirm Counter */

 Soft Sequence Attachment */

 Line-up Enable Confirmation Mask */

 Parse Memory Direct Access Registers */

 (0x080-0x3f7) */

 Configuration Access Control */

 QMI dequeue prefetch modes */

 No prefetch mode */

 Partial prefetch mode */

 Full prefetch mode */

 A structure for defining FM port resources */

 Committed required resource */

 Extra (not committed) required resource */

 No swap, transfer data as is */

 The transferred data should be swapped in PPC Little Endian mode */

 The transferred data should be swapped in Big Endian mode */

 Default port color */

 Default port color is green */

 Default port color is yellow */

 Default port color is red */

 Ignore color */

 QMI dequeue from the SP channel - types */

 Priority precedence and Intra-Class scheduling */

 Active FQ precedence and Intra-Class scheduling */

 Active FQ precedence and override Intra-Class scheduling */

 External buffer pools configuration */

 Num of pools to set up */

 Enable allocate counters */

	/* Number of depleted pools - if reached the BMI indicates

	 * the MAC to send a pause frame

 BM pool ID */

 Pool's size - must be in ascending order */

 If this is a backup pool */

 Consider this buffer in multiple pools depletion criteria */

 Consider this buffer in single pool depletion criteria */

 FMan port virtual memory */

 Port type */

 Port speed */

 HW Port Id */

 QMan channel id (non RX only) */

 FMan Handle */

 DMA attributes */

 Enable write optimization */

 Rx FIFO parameters */

 always allow access to the extra resources */

 Frame end data */

 Internal context parameters */

 Internal buffer offset */

 External buffer margins */

 Frame attributes */

 Synchronization request */

 NIA */

 Parser Next Engine NIA */

 Enqueue NIA */

 Default/error queues */

 Discard/error masks */

 Tx Configuration register */

 DMA attributes */

 Tx FIFO parameters */

 Frame end data */

 Internal context parameters */

 Frame attributes */

 Dequeue NIA + enqueue NIA */

 Confirmation/error queues */

 Rx port configuration */

 Enqueue NIA */

 Continue with Tx port configuration */

 Enqueue NIA */

 Dequeue NIA */

 Dequeue Configuration register */

 enable HXS error reporting into FD[STATUS] PHE */

 Short packet padding removal from checksum calculation */

 Init BMI registers */

 Init QMI registers */

 Check buffers are provided in ascending order */

 Set up external buffers pools */

 Clear unused pools */

 Pools depletion */

 Checks if FMan port driver parameters were initialized */

 TX Ports */

		/* Add some margin for back-to-back capability to improve

		 * performance, allows the hardware to pipeline new frame dma

		 * while the previous frame not yet transmitted.

 RX Ports */

 4 according to spec + 1 for FOF>0 */

		/* Add some margin for back-to-back capability to improve

		 * performance,allows the hardware to pipeline new frame dma

		 * while the previous frame not yet transmitted.

 Verify the size  */

 save pools parameters for later use */

 FMBM_RMPD reg. - pool depletion */

	/* The code bellow is a trick so the FM will not release the buffer

	 * to BM nor will try to enqueue the frame to QM

			/* override fmbm_tcfqid 0 with a false non-0 value.

			 * This will force FM to act according to tfene.

			 * Otherwise, if fmbm_tcfqid is 0 the FM will release

			 * buffers to BM regardless of fmbm_tfene

	/* P4080 - Major 2

	 * P2041/P3041/P5020/P5040 - Major 3

	 * Tx/Bx - Major 6

 FMan V3 */

 FMan V2 */

 FMan V3 */

 FMan V2 */

 Excessive Threshold register - exists for pre-FMv3 chips only */

/**

 * fman_port_config

 * @port:	Pointer to the port structure

 * @params:	Pointer to data structure of parameters

 *

 * Creates a descriptor for the FM PORT module.

 * The routine returns a pointer to the FM PORT object.

 * This descriptor must be passed as first parameter to all other FM PORT

 * function calls.

 * No actual initialization or configuration of FM hardware is done by this

 * routine.

 *

 * Return: 0 on success; Error code otherwise.

 Allocate the FM driver's parameters structure */

 Initialize FM port parameters which will be kept by the driver */

 get FM revision */

 Continue with other parameters */

 set memory map pointers */

 resource distribution. */

	/* FM_HEAVY_TRAFFIC_SEQUENCER_HANG_ERRATA_FMAN_A006981 errata

	 * workaround

		/* FM_WRONG_RESET_VALUES_ERRATA_FMAN_A005127 Errata

		 * workaround

/*

 * fman_port_use_kg_hash

 * @port: A pointer to a FM Port module.

 * @enable: enable or disable

 *

 * Sets the HW KeyGen or the BMI as HW Parser next engine, enabling

 * or bypassing the KeyGen hashing of Rx traffic

 After the Parser frames go to KeyGen */

 After the Parser frames go to BMI */

/**

 * fman_port_init

 * @port:	A pointer to a FM Port module.

 *

 * Initializes the FM PORT module by defining the software structure and

 * configuring the hardware registers.

 *

 * Return: 0 on success; Error code otherwise.

		/* Call the external Buffer routine which also checks fifo

		 * size and updates it if necessary

 define external buffer pools and pool depletion */

 check if the largest external buffer pool is large enough */

 Call FM module routine for communicating parameters */

/**

 * fman_port_cfg_buf_prefix_content

 * @port:			A pointer to a FM Port module.

 * @buffer_prefix_content:	A structure of parameters describing

 *				the structure of the buffer.

 *				Out parameter:

 *				Start margin - offset of data from

 *				start of external buffer.

 * Defines the structure, size and content of the application buffer.

 * The prefix, in Tx ports, if 'pass_prs_result', the application should set

 * a value to their offsets in the prefix of the FM will save the first

 * 'priv_data_size', than, depending on 'pass_prs_result' and

 * 'pass_time_stamp', copy parse result and timeStamp, and the packet itself

 * (in this order), to the application buffer, and to offset.

 * Calling this routine changes the buffer margins definitions in the internal

 * driver data base from its default configuration:

 * Data size:  [DEFAULT_PORT_BUFFER_PREFIX_CONTENT_PRIV_DATA_SIZE]

 * Pass Parser result: [DEFAULT_PORT_BUFFER_PREFIX_CONTENT_PASS_PRS_RESULT].

 * Pass timestamp: [DEFAULT_PORT_BUFFER_PREFIX_CONTENT_PASS_TIME_STAMP].

 * May be used for all ports

 *

 * Allowed only following fman_port_config() and before fman_port_init().

 *

 * Return: 0 on success; Error code otherwise.

	/* if data_align was not initialized by user,

	 * we return to driver's default

/**

 * fman_port_disable

 * @port:	A pointer to a FM Port module.

 *

 * Gracefully disable an FM port. The port will not start new	tasks after all

 * tasks associated with the port are terminated.

 *

 * This is a blocking routine, it returns after port is gracefully stopped,

 * i.e. the port will not except new frames, but it will finish all frames

 * or tasks which were already began.

 * Allowed only following fman_port_init().

 *

 * Return: 0 on success; Error code otherwise.

 Disable QMI */

 Wait for QMI to finish FD handling */

 Timeout */

 Disable BMI */

 Wait for graceful stop end */

 Timeout */

/**

 * fman_port_enable

 * @port:	A pointer to a FM Port module.

 *

 * A runtime routine provided to allow disable/enable of port.

 *

 * Allowed only following fman_port_init().

 *

 * Return: 0 on success; Error code otherwise.

 Enable QMI */

 Enable BMI */

/**

 * fman_port_bind

 * @dev:		FMan Port OF device pointer

 *

 * Bind to a specific FMan Port.

 *

 * Allowed only after the port was created.

 *

 * Return: A pointer to the FMan port device.

/**

 * fman_port_get_qman_channel_id

 * @port:	Pointer to the FMan port devuce

 *

 * Get the QMan channel ID for the specific port

 *

 * Return: QMan channel ID

/**

 * fman_port_get_device

 * @port:	Pointer to the FMan port device

 *

 * Get the 'struct device' associated to the specified FMan port device

 *

 * Return: pointer to associated 'struct device'

 Get the FM node */

/*

 * Copyright 2008-2015 Freescale Semiconductor Inc.

 * Copyright 2020 NXP

 *

 * Redistribution and use in source and binary forms, with or without

 * modification, are permitted provided that the following conditions are met:

 *     * Redistributions of source code must retain the above copyright

 *       notice, this list of conditions and the following disclaimer.

 *     * Redistributions in binary form must reproduce the above copyright

 *       notice, this list of conditions and the following disclaimer in the

 *       documentation and/or other materials provided with the distribution.

 *     * Neither the name of Freescale Semiconductor nor the

 *       names of its contributors may be used to endorse or promote products

 *       derived from this software without specific prior written permission.

 *

 *

 * ALTERNATIVELY, this software may be distributed under the terms of the

 * GNU General Public License ("GPL") as published by the Free Software

 * Foundation, either version 2 of that License or (at your option) any

 * later version.

 *

 * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY

 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED

 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE

 * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY

 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES

 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;

 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND

 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT

 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS

 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 General defines */

 size of LIODN table */

 Modules registers offsets */

 Exceptions bit map */

 DMA defines */

 masks */

 FPM defines */

 BMI defines */

 QMI defines */

 HWP defines */

 IRAM defines */

 Default values */

 Defines used for enabling/disabling FMan interrupts */

 4 LSB of PORT_ID */

 4 LSB of TNUM */

 FM IRAM instruction address register */

 FM IRAM instruction data register */

 FM IRAM timing config register */

 FM IRAM ready register */

 FPM TNUM Control 0x00 */

 FPM Port_ID FmCtl Association 0x04 */

 FPM Breakpoint Control 0x08 */

 FPM Flush Control 0x0c */

 FPM Dispatch Thresholds1 0x10 */

 FPM Dispatch Thresholds2 0x14 */

 FM Error Pending Interrupts 0x18 */

 FM Error Interrupt Enable 0x1c */

 FPM FMan-Controller Event 1-4 0x20-0x2f */

 res 0x30 - 0x3f */

 PM FMan-Controller Event 1-4 0x40-0x4f */

 res 0x50-0x5f */

 FPM TimeStamp Control1 0x60 */

 FPM TimeStamp Control2 0x64 */

 FPM Time Stamp 0x68 */

 FPM Time Stamp Fraction 0x6c */

 FM Rams Control 0x70 */

 FPM External Requests Control 0x74 */

 FPM External Requests Config1 0x78 */

 FPM External Requests Config2 0x7c */

 FPM Data_Ram Data 0-15 0x80 - 0xbf */

 FPM Data Ram Access 0xc0 */

 FM IP Block Revision 1 0xc4 */

 FM IP Block Revision 2 0xc8 */

 FM Reset Command 0xcc */

 FM Classifier Debug 0xd0 */

 FM Normal Pending Interrupts 0xd4 */

 FPM External Requests Enable 0xd8 */

 FPM Event&Mask 0xdc */

 FPM CPU Event 1-4 0xe0-0xef */

 res 0xf0-0xff */

 FPM Port Status 0x100-0x1c7 */

 res 0x1c8-0x1ff */

 FPM CLFABC 0x200 */

 FPM CLFCC 0x204 */

 FPM CLFAVAL 0x208 */

 FPM CLFBVAL 0x20c */

 FPM CLFCVAL 0x210 */

 FPM CLFAMSK 0x214 */

 FPM CLFBMSK 0x218 */

 FPM CLFCMSK 0x21c */

 FPM CLFAMC 0x220 */

 FPM CLFBMC 0x224 */

 FPM CLFCMC 0x228 */

 FPM DECCEH 0x22c */

 res 0x230 - 0x3ff */

 0x400: FPM Task Status 0x400 - 0x5ff */

 BMI Initialization 0x00 */

 BMI Configuration 1 0x04 */

 BMI Configuration 2 0x08 */

 0x0c - 0x1f */

 Interrupt Event Register 0x20 */

 Interrupt Enable Register 0x24 */

 Interrupt Force Register 0x28 */

 0x2c - 0x3f */

 BMI Arbitration 0x40 - 0x5f */

 0x60 - 0x8f */

 Debug Trap Counter 0x90 - 0x9b */

 0x9c */

 Debug Compare val 0xa0-0xcf */

 Debug Compare Mask 0xd0-0xff */

 BMI Global Debug Enable 0x100 */

 BMI Port Parameters 0x104 - 0x1ff */

 0x200 */

 BMI Port FIFO Size 0x204 - 0x2ff */

 0x300 */

 Port Partition ID 0x304 - 0x3ff */

 General Configuration Register 0x00 */

 0x04 */

 Error Interrupt Event Register 0x08 */

 Error Interrupt Enable Register 0x0c */

 Error Interrupt Force Register 0x10 */

 Interrupt Event Register 0x14 */

 Interrupt Enable Register 0x18 */

 Interrupt Force Register 0x1c */

 Global Status Register 0x20 */

 Task Status Register 0x24 */

 Enqueue Total Frame Counter 0x28 */

 Dequeue Total Frame Counter 0x2c */

 Dequeue Counter 0 0x30 */

 Dequeue Counter 1 0x34 */

 Dequeue Counter 2 0x38 */

 Dequeue Counter 3 0x3c */

 Dequeue FQID from Default Counter 0x40 */

 Dequeue FQID from Context Counter 0x44 */

 Dequeue FQID from FD Counter 0x48 */

 Dequeue Confirm Counter 0x4c */

 0x50 - 0x6b */

 Tnum Aging Period Control 0x6c */

 Dequeue MAC Command Valid Counter 0x70 */

 Dequeue Invalid FD Command Counter 0x74 */

 Dequeue A1 Valid Counter 0x78 */

 0x7c */

 0x80 Debug Trap Counter 0x80 */

 0x84 Enqueue Frame desc Dynamic dbg 0x84 */

 0x88 - 0x8f */

 0x90 dbg trap cfg 1 Register 0x00 */

 Debug Trap Value 1 Register 0x04 */

 Debug Trap Mask 1 Register 0x08 */

 Debug Trap Counter 1 Register 0x0c */

 dbg Trap cfg 2 Register 0x10 */

 Debug Trap Value 2 Register 0x14 */

 Debug Trap Mask 2 Register 0x18 */

 0x1c */

 0x90 - 0xef */

 0xf0 - 0x3ff */

 FM DMA status register 0x00 */

 FM DMA mode register 0x04 */

 FM DMA bus threshold register 0x08 */

 FM DMA bus hysteresis register 0x0c */

 FM DMA SOS emergency Threshold Register 0x10 */

 FM DMA transfer bus address high reg 0x14 */

 FM DMA transfer bus address low reg 0x18 */

 FM DMA transfer bus communication ID reg 0x1c */

 FM DMA bus internal ram address register 0x20 */

 FM DMA bus internal ram data register 0x24 */

 FM DMA CAM watchdog counter value 0x28 */

 FM DMA CAM base in MURAM register 0x2c */

 FM DMA CAM and CMD Queue Debug reg 0x30 */

 FM DMA CAM and CMD Queue Value reg #1 0x34 */

 FM DMA CAM and CMD Queue Value reg #2 0x38 */

 FM DMA CMD Queue Value register #3 0x3c */

 FM DMA CMD Queue Value register #4 0x40 */

 FM DMA CMD Queue Value register #5 0x44 */

 FM DMA Semaphore Entry Full Reject Cntr 0x48 */

 FM DMA Semaphore Queue Full Reject Cntr 0x4c */

 FM DMA Semaphore SYNC Reject Counter 0x50 */

 FM DMA Debug Counter 0x54 */

 FM DMA Emergency Smoother Register 0x58 */

 0x5c */

 DMA LIODN regs 0x60-0xdf */

 0x000..0x843 */

 FM Parser Internal memory access control */

 0x848..0xFFF */

/* Structure that holds current FMan state.

 * Used for saving run time information.

 SOC specific */

 DMA */

 QMI */

 BMI */

 General */

 Structure that holds FMan initial configuration */

 order restoration */

 set LIODN base for this port */

 Init DMA Registers */

 clear status reg events */

 configure mode register */

 configure thresholds register */

 configure hysteresis register */

 configure emergency threshold */

 configure Watchdog */

 Allocate MURAM for CAM */

 Init FPM Registers */

 define exceptions and error behavior */

 Clear events */

 enable interrupts */

 FMan is not halted upon external halt activation */

 Man is not halted upon  Unrecoverable ECC error behavior */

 clear all fmCtls event registers */

 RAM ECC -  enable and clear events */

	/* first we need to clear all parser memory,

	 * as it is uninitialized and may cause ECC errors

 event bits */

 Init BMI Registers */

 define common resources */

 num of DMA's will be dynamically updated when each port is set */

 define unmaskable exceptions, enable and clear events */

 Init QMI Registers */

 Clear error interrupt events */

 enable events */

 Clear interrupt events */

 enable events */

 enable HW Parser */

 Enable all modules */

	/* clear&enable global counters - calculate reg and save for later,

	 * because it's the same reg for QMI enable

 Set enqueue and dequeue thresholds */

 disable bus error */

 enable ECC if not enabled */

 enable ECC interrupts */

			/* ECC mechanism may be disabled,

			 * depending on driver status

 enable ECC if not enabled */

 enable ECC interrupts */

			/* ECC mechanism may be disabled,

			 * depending on driver status

 clear tmp_reg event bits in order not to clear standing events */

	/* P4080 - Major 2

	 * P2041/P3041/P5020/P5040 - Major 3

	 * Tx/Bx - Major 6

 FManV3L */

 FManV3H */

 Checks if FMan driver parameters were initialized */

 clear the forced events */

 clear the acknowledged events */

 clear the forced events */

 clear the acknowledged events */

 clear DMA_STATUS_BUS_ERR if mask has no DMA_MODE_BER */

 clear relevant bits if mask has no DMA_MODE_ECC */

 clear set events */

 clear the all occurred events */

 clear MURAM event bit (do not clear IRAM event) */

 clear the forced events */

 clear the acknowledged events */

	/* configure timestamp so that bit 8 will count 1 microsecond

	 * Find effective count rate at TIMESTAMP least significant bits:

	 * Effective_Count_Rate = 1MHz x 2^8 = 256MHz

	 * Find frequency ratio between effective count rate and the clock:

	 * Effective_Count_Rate / CLK e.g. for 600 MHz clock:

	 * 256/600 = 0.4266666...

	/* we multiply by 2^16 to keep the fraction of the division

	 * we do not div back, since we write this value as a fraction

	 * see spec

 we check remainder of the division in order to round up if not int */

 enable timestamp with original clock */

 Enable the auto-increment */

	/* if this is the first time a port requires extra_fifo_pool_size,

	 * the total extra_fifo_pool_size must be initialized to 1 buffer per

	 * port

 check that there are enough uncommitted fifo size */

 Read, modify and write to HW */

 update accumulated */

 check that there are enough uncommitted tasks */

 update accumulated */

 Write to HW */

		/* Configuration according to values in the HW.

		 * read the current number of open Dma's

		/* This is the first configuration and user did not

		 * specify value (!open_dmas), reset values will be used

		 * and we just save these values for resource management

 update acummulated */

 calculate reg */

	/* update total num of DMA's with committed number of open DMAS,

	 * and max uncommitted pool.

 Allocate the FM driver's parameters structure */

 Initialize MURAM block */

 Initialize FM parameters which will be kept by the driver */

 Read FMan revision for future use*/

 FM_AID_MODE_NO_TNUM_SW005 Errata workaround */

 Wait for reset completion */

 Errata A007273 */

 Read current state */

 Enable all MACs */

 Perform FMan reset */

 Wait for reset completion */

 Restore devdisr2 value */

 clear revision-dependent non existing exception */

 clear CPG */

	/* Save LIODN info before FMan reset

	 * Skipping non-existent port 0 (i = 1)

 FMDM_PLR LSB holds LIODN base for odd ports */

 FMDM_PLR MSB holds LIODN base for even ports */

 Wait until QMI is not in halt not busy state */

 Init DMA Registers */

 Init FPM Registers */

 define common resources */

 allocate MURAM for FIFO according to total size */

 Init BMI Registers */

 Init QMI Registers */

 Init HW Parser */

 Init KeyGen */

/**

 * fman_register_intr

 * @fman:	A Pointer to FMan device

 * @module:	Calling module

 * @mod_id:	Module id (if more than 1 exists, '0' if not)

 * @intr_type:	Interrupt type (error/normal) selection.

 * @isr_cb:	The interrupt service routine.

 * @src_arg:	Argument to be passed to isr_cb.

 *

 * Used to register an event handler to be processed by FMan

 *

 * Return: 0 on success; Error code otherwise.

 register in local FM structure */

/**

 * fman_unregister_intr

 * @fman:	A Pointer to FMan device

 * @module:	Calling module

 * @mod_id:	Module id (if more than 1 exists, '0' if not)

 * @intr_type:	Interrupt type (error/normal) selection.

 *

 * Used to unregister an event handler to be processed by FMan

 *

 * Return: 0 on success; Error code otherwise.

/**

 * fman_set_port_params

 * @fman:		A Pointer to FMan device

 * @port_params:	Port parameters

 *

 * Used by FMan Port to pass parameters to the FMan

 *

 * Return: 0 on success; Error code otherwise.

 TX Ports */

 update qmi ENQ/DEQ threshold */

		/* if enq_th is too big, we reduce it to the max value

		 * that is still 0

		/* if deq_th is too small, we enlarge it to the min

		 * value that is still 0.

		 * depTh may not be larger than 63

		 * (fman->state->qmi_max_num_of_tnums-1).

/**

 * fman_reset_mac

 * @fman:	A Pointer to FMan device

 * @mac_id:	MAC id to be reset

 *

 * Reset a specific MAC

 *

 * Return: 0 on success; Error code otherwise.

 Get the relevant bit mask */

 reset */

/**

 * fman_set_mac_max_frame

 * @fman:	A Pointer to FMan device

 * @mac_id:	MAC id

 * @mfl:	Maximum frame length

 *

 * Set maximum frame length of specific MAC in FMan driver

 *

 * Return: 0 on success; Error code otherwise.

	/* if port is already initialized, check that MaxFrameLength is smaller

	 * or equal to the port's max

/**

 * fman_get_clock_freq

 * @fman:	A Pointer to FMan device

 *

 * Get FMan clock frequency

 *

 * Return: FMan clock frequency

/**

 * fman_get_bmi_max_fifo_size

 * @fman:	A Pointer to FMan device

 *

 * Get FMan maximum FIFO size

 *

 * Return: FMan Maximum FIFO size

/**

 * fman_get_revision

 * @fman:		- Pointer to the FMan module

 * @rev_info:		- A structure of revision information parameters.

 *

 * Returns the FM revision

 *

 * Allowed only following fman_init().

 *

 * Return: 0 on success; Error code otherwise.

/**

 * fman_get_qman_channel_id

 * @fman:	A Pointer to FMan device

 * @port_id:	Port id

 *

 * Get QMan channel ID associated to the Port id

 *

 * Return: QMan channel ID

/**

 * fman_get_mem_region

 * @fman:	A Pointer to FMan device

 *

 * Get FMan memory region

 *

 * Return: A structure with FMan memory region information

 Bootargs defines */

 Extra headroom for RX buffers - Default, min and max */

 Maximum frame length */

/* Extra headroom for Rx buffers.

 * FMan is instructed to allocate, on the Rx path, this amount of

 * space at the beginning of a data buffer, beside the DPA private

 * data area and the IC fields.

 * Does not impact Tx buffer layout.

 * Configurable from bootargs. 64 by default, it's needed on

 * particular forwarding scenarios that add extra headers to the

 * forwarded frame.

/* Max frame size, across all interfaces.

 * Configurable from bootargs, to avoid allocating oversized (socket)

 * buffers when not using jumbo frames.

 * Must be large enough to accommodate the network MTU, but small enough

 * to avoid wasting skb memory.

/**

 * fman_get_max_frm

 *

 * Return: Max frame length configured in the FM driver

/**

 * fman_get_rx_extra_headroom

 *

 * Return: Extra headroom size configured in the FM driver

/**

 * fman_bind

 * @fm_dev:	FMan OF device pointer

 *

 * Bind to a specific FMan device.

 *

 * Allowed only after the port was created.

 *

 * Return: A pointer to the FMan device

 error interrupts */

 MAC error interrupts */

 normal interrupts */

 MAC interrupts */

 Get the FM interrupt */

 Get the FM error interrupt */

 Get the FM address */

 Rounding to MHz */

 Get the MURAM base address and size */

/*

 * Copyright 2008 - 2015 Freescale Semiconductor Inc.

 *

 * Redistribution and use in source and binary forms, with or without

 * modification, are permitted provided that the following conditions are met:

 *     * Redistributions of source code must retain the above copyright

 *       notice, this list of conditions and the following disclaimer.

 *     * Redistributions in binary form must reproduce the above copyright

 *       notice, this list of conditions and the following disclaimer in the

 *       documentation and/or other materials provided with the distribution.

 *     * Neither the name of Freescale Semiconductor nor the

 *       names of its contributors may be used to endorse or promote products

 *       derived from this software without specific prior written permission.

 *

 *

 * ALTERNATIVELY, this software may be distributed under the terms of the

 * GNU General Public License ("GPL") as published by the Free Software

 * Foundation, either version 2 of that License or (at your option) any

 * later version.

 *

 * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY

 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED

 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE

 * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY

 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES

 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;

 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND

 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT

 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS

 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

	/* First we copy the external buffers pools information

	 * to an ordered local array

 get pool size */

		/* keep sizes in an array according to poolId

		 * for direct access

 save poolId in an ordered array according to size */

 this is the next free place in the array */

 find the right place for this poolId */

					/* move the pool_ids one place ahead

					 * to make room for this poolId

					/* now k==j, this is the place for

					 * the new size

 Align start of internal context data to 16 byte */

 Translate margin and int_context params to FM parameters */

 Initialize with illegal value. Later we'll set legal values. */

	/* Internally the driver supports 4 options

	 * 1. prsResult/timestamp/hashResult selection (in fact 8 options,

	 * but for simplicity we'll

	 * relate to it as 1).

	 * 2. All IC context (from AD) not including debug.

 This case covers the options under 1 */

 Copy size must be in 16-byte granularity. */

 Align start of internal context data to 16 byte */

		/* If PR is not requested, whether TS is

		 * requested or not, IC will be copied from TS

		/* No Internal Context passing, STartMargin is

		 * immediately after private_info

 align data start */

/*

 * Copyright 2008-2015 Freescale Semiconductor Inc.

 *

 * Redistribution and use in source and binary forms, with or without

 * modification, are permitted provided that the following conditions are met:

 *     * Redistributions of source code must retain the above copyright

 *       notice, this list of conditions and the following disclaimer.

 *     * Redistributions in binary form must reproduce the above copyright

 *       notice, this list of conditions and the following disclaimer in the

 *       documentation and/or other materials provided with the distribution.

 *     * Neither the name of Freescale Semiconductor nor the

 *       names of its contributors may be used to endorse or promote products

 *       derived from this software without specific prior written permission.

 *

 *

 * ALTERNATIVELY, this software may be distributed under the terms of the

 * GNU General Public License ("GPL") as published by the Free Software

 * Foundation, either version 2 of that License or (at your option) any

 * later version.

 *

 * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY

 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED

 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE

 * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY

 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES

 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;

 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND

 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT

 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS

 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 Transmit Inter-Packet Gap Length Register (TX_IPG_LENGTH) */

 Command and Configuration Register (COMMAND_CONFIG) */

 Interrupt Mask Register (IMASK) */

 Hashtable Control Register (HASHTABLE_CTRL) */

 number of pattern match registers (entries) */

 Group address bit indication */

 Hash table size (= 32 bits*8 regs) */

 tGEC memory map */

 0x000 Controller ID */

 0x004 */

 0x008 Control and configuration */

 0x00c Lower 32 bits of the MAC adr */

 0x010 Upper 16 bits of the MAC adr */

 0x014 Maximum frame length */

 0x018 Pause quanta */

 0x01c  */

 0x020  */

 0x024  */

 0x028  */

 0x02c Hash table control */

 0x030  */

 0x034  */

 0x038  */

 0x03c  */

 0x040  */

 0x044 Transmitter inter-packet-gap */

 0x048 Lower 32 bits of 2nd MAC adr */

 0x04c Upper 16 bits of 2nd MAC adr */

 0x050  */

 0x054  */

 0x058  */

 0x05c  */

 0x060 Interrupt mask */

 0x064 Interrupt event */

 0x068 Defines a UDP Port number */

 0x06c Type field for 1588v2 */

 0x070 */

 10Ge Statistics Counter */

 80 aFramesTransmittedOK */

 84 aFramesTransmittedOK */

 88 aFramesReceivedOK */

 8c aFramesReceivedOK */

 90 aFrameCheckSequenceErrors */

 94 aFrameCheckSequenceErrors */

 98 aAlignmentErrors */

 9c aAlignmentErrors */

 A0 aPAUSEMACCtrlFramesTransmitted */

 A4 aPAUSEMACCtrlFramesTransmitted */

 A8 aPAUSEMACCtrlFramesReceived */

 Ac aPAUSEMACCtrlFramesReceived */

 B0 aFrameTooLongErrors */

 B4 aFrameTooLongErrors */

 B8 aInRangeLengthErrors */

 Bc aInRangeLengthErrors */

 C0 VLANTransmittedOK */

 C4 VLANTransmittedOK */

 C8 VLANReceivedOK */

 Cc VLANReceivedOK */

 D0 if_out_octets */

 D4 if_out_octets */

 D8 if_in_octets */

 Dc if_in_octets */

 E0 if_in_ucast_pkts */

 E4 if_in_ucast_pkts */

 E8 ifInMulticastPkts */

 Ec ifInMulticastPkts */

 F0 ifInBroadcastPkts */

 F4 ifInBroadcastPkts */

 F8 if_out_errors */

 Fc if_out_errors */

 100-108 */

 108 if_out_ucast_pkts */

 10c if_out_ucast_pkts */

 110 ifOutMulticastPkts */

 114 ifOutMulticastPkts */

 118 ifOutBroadcastPkts */

 11c ifOutBroadcastPkts */

 120 etherStatsDropEvents */

 124 etherStatsDropEvents */

 128 etherStatsOctets */

 12c etherStatsOctets */

 130 etherStatsPkts */

 134 etherStatsPkts */

 138 etherStatsUndersizePkts */

 13c etherStatsUndersizePkts */

 140 etherStatsPkts64Octets */

 144 etherStatsPkts64Octets */

 148 etherStatsPkts65to127Octets */

 14c etherStatsPkts65to127Octets */

 150 etherStatsPkts128to255Octets */

 154 etherStatsPkts128to255Octets */

 158 etherStatsPkts256to511Octets */

 15c etherStatsPkts256to511Octets */

 160 etherStatsPkts512to1023Octets */

 164 etherStatsPkts512to1023Octets */

 168 etherStatsPkts1024to1518Octets */

 16c etherStatsPkts1024to1518Octets */

 170 etherStatsPkts1519toX */

 174 etherStatsPkts1519toX */

 178 etherStatsOversizePkts */

 17c etherStatsOversizePkts */

 180 etherStatsJabbers */

 184 etherStatsJabbers */

 188 etherStatsFragments */

 18C etherStatsFragments */

 190 if_in_errors */

 194 if_in_errors */

 Pointer to the memory mapped registers. */

 MAC address of device; */

 device cookie used by the exception cbs */

 pointer to driver's global address hash table  */

 pointer to driver's individual address hash table  */

 Config */

 Payload length check disable */

 Max Frame Length */

 Pause Time */

 clear all pending events and set-up interrupts */

 do not handle MDIO events */

 release the driver's group hash table */

 release the driver's individual hash table */

 Checks if tGEC driver parameters were initialized */

 Unicast addresses not supported in hash */

 CRC calculation */

 Take 9 MSB bits */

 Create element to be added to the driver hash table */

 CRC calculation */

 Take 9 MSB bits */

 interrupts */

 FM_10G_REM_N_LCL_FLT_EX_10GMAC_ERRATA_SW005 Errata workaround */

 Max Frame Length */

 FM_TX_FIFO_CORRUPTION_ERRATA_10GMAC_A007 Errata workaround */

 restore the default tx ipg Length */

 allocate memory for the UCC GETH data structure. */

 allocate memory for the 10G MAC driver parameters data structure. */

 Plant parameter structure pointer */

 Save FMan revision */

/* Copyright 2008-2016 Freescale Semiconductor Inc.

 *

 * Redistribution and use in source and binary forms, with or without

 * modification, are permitted provided that the following conditions are met:

 *     * Redistributions of source code must retain the above copyright

 *	 notice, this list of conditions and the following disclaimer.

 *     * Redistributions in binary form must reproduce the above copyright

 *	 notice, this list of conditions and the following disclaimer in the

 *	 documentation and/or other materials provided with the distribution.

 *     * Neither the name of Freescale Semiconductor nor the

 *	 names of its contributors may be used to endorse or promote products

 *	 derived from this software without specific prior written permission.

 *

 *

 * ALTERNATIVELY, this software may be distributed under the terms of the

 * GNU General Public License ("GPL") as published by the Free Software

 * Foundation, either version 2 of that License or (at your option) any

 * later version.

 *

 * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY

 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED

 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE

 * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY

 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES

 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;

 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND

 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT

 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS

 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* Copyright 2008-2016 Freescale Semiconductor, Inc.

 *

 * Redistribution and use in source and binary forms, with or without

 * modification, are permitted provided that the following conditions are met:

 *     * Redistributions of source code must retain the above copyright

 *	 notice, this list of conditions and the following disclaimer.

 *     * Redistributions in binary form must reproduce the above copyright

 *	 notice, this list of conditions and the following disclaimer in the

 *	 documentation and/or other materials provided with the distribution.

 *     * Neither the name of Freescale Semiconductor nor the

 *	 names of its contributors may be used to endorse or promote products

 *	 derived from this software without specific prior written permission.

 *

 *

 * ALTERNATIVELY, this software may be distributed under the terms of the

 * GNU General Public License ("GPL") as published by the Free Software

 * Foundation, either version 2 of that License or (at your option) any

 * later version.

 *

 * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY

 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED

 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE

 * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY

 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES

 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;

 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND

 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT

 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS

 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 dpa rx errors */

 demultiplexing errors */

 congestion related stats */

	/* The MAC should know how to handle PAUSE frame autonegotiation before

	 * adjust_link is triggered by a forced renegotiation of sym/asym PAUSE

	 * settings.

	/* Determine the sym/asym advertised PAUSE capabilities from the desired

	 * rx/tx pause settings.

 update current CPU's stats and also add them to the total values */

 gather congestion related counters */

 reset congestion stats (like QMan API does */

 we support hashing on IPv4/v6 src/dest IP and L4 src/dest port */

 save previous values */

 set new values */

 restore previous values */

 previous values will not fail, ignore return value */

/* Copyright 2008 - 2016 Freescale Semiconductor Inc.

 * Copyright 2020 NXP

 *

 * Redistribution and use in source and binary forms, with or without

 * modification, are permitted provided that the following conditions are met:

 *     * Redistributions of source code must retain the above copyright

 *	 notice, this list of conditions and the following disclaimer.

 *     * Redistributions in binary form must reproduce the above copyright

 *	 notice, this list of conditions and the following disclaimer in the

 *	 documentation and/or other materials provided with the distribution.

 *     * Neither the name of Freescale Semiconductor nor the

 *	 names of its contributors may be used to endorse or promote products

 *	 derived from this software without specific prior written permission.

 *

 * ALTERNATIVELY, this software may be distributed under the terms of the

 * GNU General Public License ("GPL") as published by the Free Software

 * Foundation, either version 2 of that License or (at your option) any

 * later version.

 *

 * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY

 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED

 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE

 * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY

 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES

 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;

 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND

 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT

 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS

 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* CREATE_TRACE_POINTS only needs to be defined once. Other dpaa files

 * using trace events only need to #include <trace/events/sched.h>

/* Ingress congestion threshold on FMan ports

 * The size in bytes of the ingress tail-drop threshold on FMan ports.

 * Traffic piling up above this value will be rejected by QMan and discarded

 * by FMan.

 Size in bytes of the FQ taildrop threshold */

/* Egress congestion threshold on 1G ports, range 0x1000 .. 0x10000000

 * The size in bytes of the egress Congestion State notification threshold on

 * 1G ports. The 1G dTSECs can quite easily be flooded by cores doing Tx in a

 * tight loop (e.g. by sending UDP datagrams at "while(1) speed"),

 * and the larger the frame size, the more acute the problem.

 * So we have to find a balance between these factors:

 * - avoiding the device staying congested for a prolonged time (risking

 *   the netdev watchdog to fire - see also the tx_timeout module param);

 * - affecting performance of protocols such as TCP, which otherwise

 *   behave well under the congestion notification mechanism;

 * - preventing the Tx cores from tightly-looping (as if the congestion

 *   threshold was too low to be effective);

 * - running out of memory if the CS threshold is set too high.

/* The size in bytes of the egress Congestion State notification threshold on

 * 10G ports, range 0x1000 .. 0x10000000

 Largest value that the FQD's OAL field can hold */

 Default alignment for start of data in an Rx FD */

/* aligning data start to 64 avoids DMA transaction splits, unless the buffer

 * is crossing a 4k page boundary

/* aligning to 256 avoids DMA transaction splits caused by 4k page boundary

 * crossings; also, all SG fragments except the last must have a size multiple

 * of 256 to avoid DMA transaction splits

 The DPAA requires 256 bytes reserved and mapped for the SGT */

/* Values for the L3R field of the FM Parse Results

 L3 Type field: First IP Present IPv4 */

 L3 Type field: First IP Present IPv6 */

 Values for the L4R field of the FM Parse Results */

 L4 Type field: UDP */

 L4 Type field: TCP */

/* FD status field indicating whether the FM Parser has attempted to validate

 * the L4 csum of the frame.

 * Note that having this bit set doesn't necessarily imply that the checksum

 * is valid. One would have to check the parse results to find that out.

 maximum number of entries in SG Table */

 maximum number of buffers released at once */

 All the dpa bps in use at any moment */

	/* Although we access another CPU's private data here

	 * we do it at initialization so it is safe

	/* The kernels enables GSO automatically, if we declare NETIF_F_SG.

	 * For conformity, we'll still declare GSO explicitly.

 we do not want shared skbs on TX */

 start without the RUNNING flag, phylib controls it later */

	/* Allow the Fman (Tx) port to process in-flight frames before we

	 * try switching it off.

/* Calculates the statistics for the given device by adding the statistics

 * collected by each CPU.

 add stats from all CPUs */

 reverting to previous address */

 checks if this bpool is already allocated */

 called only once per bpid by dpaa_bp_alloc_pool() */

 If the pool is already specified, we only create one per bpid */

 remove and free all the buffers from the given buffer pool */

				/* we have less than 8 buffers left;

				 * drain them one by one

 Pool is fully drained */

	/* the mapping between bpid and dpaa_bp is done very late in the

	 * allocation procedure; if something failed before the mapping, the bp

	 * was not configured, therefore we don't need the below instructions

/* Use multiple WQs for FQ assignment:

 *	- Tx Confirmation queues go to WQ1.

 *	- Rx Error and Tx Error queues go to WQ5 (giving them a better chance

 *	  to be scheduled, in case there are many more FQs in WQ6).

 *	- Rx Default goes to WQ6.

 *	- Tx queues go to different WQs depending on their priority. Equal

 *	  chunks of NR_CPUS queues go to WQ6 (lowest priority), WQ2, WQ1 and

 *	  WQ0 (highest priority).

 * This ensures that Tx-confirmed buffers are timely released. In particular,

 * it avoids congestion on the Tx Confirm FQs, which can pile up PFDRs if they

 * are greatly outnumbered by other FQs in the system, while

 * dequeue scheduling is round-robin.

 Low priority (best effort) */

 Medium priority */

 High priority */

 Very high priority */

 the PCD FQIDs range needs to be aligned for correct operation */

/* Congestion group state change notification callback.

 * Stops the device's egress queues while they are congested and

 * wakes them upon exiting congested state.

 * Also updates some CGR-related stats.

 Enable Congestion State Change Notifications and CS taildrop */

	/* Set different thresholds based on the MAC speed.

	 * This may turn suboptimal if the MAC is reconfigured at a speed

	 * lower than its max, e.g. if a dTSEC later negotiates a 100Mbps link.

	 * In such cases, we ought to reconfigure the threshold, too.

 Initialize each FQ in the list */

			/* If we have more Tx queues than the number of cores,

			 * just ignore the extra ones.

 Make sure all CPUs receive a corresponding Tx queue. */

 Note: we may get to keep an empty FQ in cache */

		/* Try to reduce the number of portal interrupts for

		 * Tx Confirmation FQs.

 FQ placement */

		/* Put all egress queues in a congestion group of their own.

		 * Sensu stricto, the Tx confirmation queues are Rx FQs,

		 * rather than Tx - but they nonetheless account for the

		 * memory footprint on behalf of egress traffic. We therefore

		 * place them in the netdev's CGR, along with the Tx FQs.

			/* Set a fixed overhead accounting, in an attempt to

			 * reduce the impact of fixed-size skb shells and the

			 * driver's needed headroom on system memory. This is

			 * especially the case when the egress traffic is

			 * composed of small datagrams.

			 * Unfortunately, QMan's OAL value is capped to an

			 * insufficient value, but even that is better than

			 * no overhead accounting at all.

			/* ContextA: OVOM=1(use contextA2 bits instead of ICAD)

			 *	     A2V=1 (contextA A2 field is valid)

			 *	     A0V=1 (contextA A0 field is valid)

			 *	     B0V=1 (contextB field is valid)

			 * ContextA A2: EBD=1 (deallocate buffers inside FMan)

			 * ContextB B0(ASPID): 0 (absolute Virtual Storage ID)

 Put all the ingress queues in our "ingress CGR". */

			/* Set a fixed overhead accounting, just like for the

			 * egress CGR.

 Initialization common to all ingress queues */

 Should never occur, address anyway to avoid leaking the buffers */

/* Turn on HW checksum computation for this outgoing frame.

 * If the current protocol is not something we support in this regard

 * (or if the stack has already computed the SW checksum), we do nothing.

 *

 * Returns 0 if all goes well (or HW csum doesn't apply), and a negative value

 * otherwise.

 *

 * Note that this function may modify the fd->cmd field and the skb data buffer

 * (the Parse Results area).

	/* Note: L3 csum seems to be already computed in sw, but we can't choose

	 * L4 alone from the FM configuration anyway.

	/* Fill in some fields of the Parse Results array, so the FMan

	 * can find them as if they came from the FMan Parser.

 If we're dealing with VLAN, get the real Ethernet type */

		/* We can't always assume the MAC header is set correctly

		 * by the stack, so reset to beginning of skb->data

	/* Fill in the relevant L3 parse result fields

	 * and read the L4 protocol type

 We shouldn't even be here */

 Fill in the relevant L4 parse result fields */

 At index 0 is IPOffset_1 as defined in the Parse Results */

 Enable L3 (and L4, if TCP or UDP) HW checksum. */

	/* On P1023 and similar platforms fd->cmd interpretation could

	 * be disabled by setting CONTEXT_A bit ICMD; currently this bit

	 * is not set so we do not need to check; in the future, if/when

	 * using context_a we need to check this bit

	/* Avoid releasing a completely null buffer; bman_release() requires

	 * at least one buffer.

 Give each CPU an allotment of "config_count" buffers */

		/* Although we access another CPU's counters here

		 * we do it at boot time so it is safe

/* Add buffers/(pages) for Rx processing whenever bpool count falls below

 * REFILL_THRESHOLD.

				/* Avoid looping forever if we've temporarily

				 * run out of memory. We'll try again at the

				 * next NAPI cycle.

/* Cleanup function for outgoing frame descriptors that were built on Tx path,

 * either contiguous frames or scatter/gather ones.

 * Skb freeing is not handled here.

 *

 * This function may be called on error paths in the Tx function, so guard

 * against cases when not all fd relevant fields were filled in. To avoid

 * reading the invalid transmission timestamp for the error paths set ts to

 * false.

 *

 * Return the skb backpointer, since for S/G frames the buffer containing it

 * gets freed here.

 *

 * No skb backpointer is set when transmitting XDP frames. Cleanup the buffer

 * and return NULL in this case.

		/* The sgt buffer has been allocated with netdev_alloc_frag(),

		 * it's from lowmem.

 sgt[0] is from lowmem, was dma_map_single()-ed */

 remaining pages were mapped with skb_frag_dma_map() */

	/* No skb backpointer is set when running XDP. An xdp_frame

	 * backpointer is saved instead.

 DMA unmapping is required before accessing the HW provided info */

 Free the page that we allocated on Tx for the SGT */

	/* The parser has run and performed L4 checksum validation.

	 * We know there were no parser errors (and implicitly no

	 * L4 csum error), otherwise we wouldn't be here.

	/* We're here because either the parser didn't run or the L4 checksum

	 * was not verified. This may include the case of a UDP frame with

	 * checksum zero or an L4 proto other than TCP/UDP

/* Build a linear skb around the received buffer.

 * We are guaranteed there is enough room at the end of the data buffer to

 * accommodate the shared info area of the skb.

/* Build an skb with the data of the first S/G entry in the linear portion and

 * the rest of the frame as skb fragments.

 *

 * The page fragment holding the S/G Table is recycled here.

 Iterate through the SGT entries and add data buffers to the skb */

 Extension bit is not supported */

 We may use multiple Rx pools */

			/* Make sure forwarded skbs will have enough space

			 * on Tx, if extra headers are added.

			/* Not the first S/G entry; all data from buffer will

			 * be added in an skb fragment; fragment index is offset

			 * by one since first S/G entry was incorporated in the

			 * linear part of the skb.

			 *

			 * Caution: 'page' may be a tail page.

 Compute offset in (possibly tail) page */

			/* page_offset only refers to the beginning of sgt[i];

			 * but the buffer itself may have an internal offset.

			/* skb_add_rx_frag() does no checking on the page; if

			 * we pass it a tail page, we'll end up with

			 * bad page accounting and eventually with segafults.

 Update the pool count for the current {cpu x bpool} */

 free the SG table buffer */

 free all the SG entries */

 all pages 0..i were unmaped */

 counters 0..i-1 were decremented */

 free the SGT fragment */

	/* We are guaranteed to have at least tx_headroom bytes

	 * available, so just use that for offset.

	/* Enable L3/L4 hardware checksum computation.

	 *

	 * We must do this before dma_map_single(DMA_TO_DEVICE), because we may

	 * need to write into the skb.

 Fill in the rest of the FD fields */

 Map the entire buffer size that may be seen by FMan, but no more */

 get a page to store the SGTable */

	/* Enable L3/L4 hardware checksum computation.

	 *

	 * We must do this before dma_map_single(DMA_TO_DEVICE), because we may

	 * need to write into the skb.

 SGT[0] is used by the linear part */

 populate the rest of SGT entries */

 keep the offset in the address */

 Set the final bit in the last used entry of the SGT */

 set fd offset to priv->tx_headroom */

 DMA map the SGT page */

 Trace this Tx fd */

 check linear buffer alignment */

 linear buffers just need to have an aligned start */

 linear data size for nonlinear skbs needs to be aligned */

 all fragments need to have aligned start addresses */

 all but last fragment need to have aligned sizes */

 copy all the skb content into a new linear buffer */

 NET_SKB_PAD bytes already reserved, adding up to tx_headroom */

 Workaround for DPAA_A050385 requires data start to be aligned */

 Copy relevant timestamp info from the old skb to the new */

	/* We move the headroom when we align it so we have to reset the

	 * network and transport header offsets relative to the new data

	 * pointer. The checksum offload relies on these offsets.

	/* Check the data alignment and make sure the headroom is large

	 * enough to store the xdpf backpointer. Use an aligned headroom

	 * value.

	 *

	 * Due to alignment constraints, we give XDP access to the full 256

	 * byte frame headroom. If the XDP program uses all of it, copy the

	 * data to a new buffer and make room for storing the backpointer.

	/* Try to move the data inside the buffer just enough to align it and

	 * store the xdpf backpointer. If the available headroom isn't large

	 * enough, resort to allocating a new buffer and copying the data.

	/* The XDP frame's headroom needs to be large enough to accommodate

	 * shifting the data as well as storing the xdpf backpointer.

	/* The new xdp_frame is stored in the new buffer. Reserve enough space

	 * in the headroom for storing it along with the driver's private

	 * info. The headroom needs to be aligned to DPAA_FD_DATA_ALIGNMENT to

	 * guarantee the data's alignment in the buffer.

	/* Assure the extended headroom and data don't overflow the buffer,

	 * while maintaining the mandatory tailroom.

 Copy the data to the new buffer at a properly aligned offset */

	/* Create an XDP frame around the new buffer in a similar fashion

	 * to xdp_convert_buff_to_frame.

 Release the initial buffer */

		/* We're going to store the skb backpointer at the beginning

		 * of the data buffer, so we need a privately owned skb

		 *

		 * We've made sure skb is not shared in dev->priv_flags,

		 * we need to verify the skb head is not cloned

	/* MAX_SKB_FRAGS is equal or larger than our dpaa_SGT_MAX_ENTRIES;

	 * make sure we don't feed FMan with more fragments than it supports.

		/* If the egress skb contains more fragments than we support

		 * we have no choice but to linearize it ourselves.

 Just create a S/G fd based on the skb */

 Create a contig FD from this skb */

 LLTX requires to do our own update of trans_start */

 Disable QMan IRQ and invoke NAPI */

	/* Leave empty the skb backpointer at the start of the buffer.

	 * Save the XDP frame for easy cleanup on confirmation.

 Bump the trans_start */

	/* We reserve a fixed headroom of 256 bytes under the erratum and we

	 * offer it all to XDP programs to use. If no room is left for the

	 * xdpf backpointer on TX, we will need to copy the data.

	 * Disable metadata support since data realignments might be required

	 * and the information can be lost.

 Update the length and the offset of the FD */

		/* We can access the full headroom when sending the frame

		 * back out

 Allow redirect to use the full headroom */

 Free the buffer */

 Trace the Rx fd */

 Make sure we didn't run out of buffers */

		/* Unable to refill the buffer pool due to insufficient

		 * system memory. Just release the frame back into the pool,

		 * otherwise we'll soon end up with an empty buffer pool.

 prefetch the first 64 bytes of the frame or the SGT start */

 The only FD types that we may receive are contig and S/G */

	/* Account for either the contig buffer or the SGT buffer (depending on

	 * which case we were in) having been removed from the pool.

 Extract the timestamp stored in the headroom before running XDP */

 Extract the hash stored in the headroom before running XDP */

		/* XDP doesn't support S/G frames. Return the fragments to the

		 * buffer pool and release the SGT.

 Set the previously extracted timestamp */

 Set the previously extracted hash */

 if L4 exists, it was used in the hash generation */

 Trace the fd */

 The Aquantia PHYs are capable of performing rate adaptation */

 Unless the PHY is capable of rate adaptation */

 remove any features not supported by the controller */

	/* We do not support S/G fragments when XDP is enabled.

	 * Limit the MTU in relation to the buffer size.

 S/G fragments are not supported in XDP-mode */

		/* Couldn't disable rx/tx timestamping separately.

		 * Do nothing here.

		/* Couldn't disable rx/tx timestamping separately.

		 * Do nothing here.

 TS is set for all frame types, not only those requested */

 Alloc the dpaa_bp struct and configure default values */

/* Place all ingress FQs (Rx Default, Rx Error) in a dedicated CGR.

 * We won't be sending congestion notifications to FMan; for now, we just use

 * this CGR to generate enqueue rejections to FMan in order to drop the frames

 * before they reach our ingress queues and eat up memory.

 Enable CS TD, but disable Congestion State Change Notifications. */

	/* This CGR will be associated with the SWP affined to the current CPU.

	 * However, we'll place all our ingress FQs in it.

	/* The frame headroom must accommodate:

	 * - the driver private data area

	 * - parse results, hash results, timestamp if selected

	 * If either hash results or time stamp are selected, both will

	 * be copied to/from the frame headroom, as TS is located between PR and

	 * HR in the IC and IC copy size has a granularity of 16bytes

	 * (see description of FMBM_RICP and FMBM_TICP registers in DPAARM)

	 *

	 * Also make sure the headroom is a multiple of data_align bytes

	/* Allocate this early, so we can store relevant information in

	 * the private area

 Do this here, so we can be verbose early */

 Devices used for DMA mapping */

	/* If fsl_fm_max_frm is set to a higher value than the all-common 1500,

	 * we choose conservatively and let the user explicitly set a higher

	 * MTU via ifconfig. Otherwise, the user may end up with different MTUs

	 * in the same LAN.

	 * If on the other hand fsl_fm_max_frm has been chosen below 1500,

	 * start with the maximum allowed.

 Rx */

 Tx */

 bp init */

 the raw size of the buffers used for reception */

 avoid runtime computations by keeping the usable size here */

	/* Walk the CPUs with affine portals

	 * and add this pool channel to each's dequeue mask.

	/* Create a congestion group for this netdev, with

	 * dynamically-allocated CGR ID.

	 * Must be executed after probing the MAC, but before

	 * assigning the egress FQs to the CGRs.

 Add the FQs to the interface, and make them active */

 All real interfaces need their ports initialized */

 Rx traffic distribution based on keygen hashing defaults to on */

 Initialize NAPI */

 initialize dpaa_eth mirror values */

	/* Only one channel is used and needs to be released after all

	 * interfaces are removed

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright 2014-2016 Freescale Semiconductor Inc.

 * Copyright 2017-2021 NXP

 *

/**

 * dpsw_open() - Open a control session for the specified object

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @dpsw_id:	DPSW unique ID

 * @token:	Returned token; use in subsequent API calls

 *

 * This function can be used to open a control session for an

 * already created object; an object may have been declared in

 * the DPL or by calling the dpsw_create() function.

 * This function returns a unique authentication token,

 * associated with the specific object ID and the specific MC

 * portal; this token must be used in all subsequent commands for

 * this specific object

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

 retrieve response parameters */

/**

 * dpsw_close() - Close the control session of the object

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 *

 * After this function is called, no further operations are

 * allowed on the object without opening a new control session.

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpsw_enable() - Enable DPSW functionality

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 *

 * Return:	Completion status. '0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpsw_disable() - Disable DPSW functionality

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 *

 * Return:	Completion status. '0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpsw_reset() - Reset the DPSW, returns the object to initial state.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpsw_set_irq_enable() - Set overall interrupt state.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPCI object

 * @irq_index:	The interrupt index to configure

 * @en:		Interrupt state - enable = 1, disable = 0

 *

 * Allows GPP software to control when interrupts are generated.

 * Each interrupt can have up to 32 causes.  The enable/disable control's the

 * overall interrupt state. if the interrupt is disabled no causes will cause

 * an interrupt

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpsw_set_irq_mask() - Set interrupt mask.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPCI object

 * @irq_index:	The interrupt index to configure

 * @mask:	Event mask to trigger interrupt;

 *		each bit:

 *			0 = ignore event

 *			1 = consider event for asserting IRQ

 *

 * Every interrupt can have up to 32 causes and the interrupt model supports

 * masking/unmasking each cause independently

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpsw_get_irq_status() - Get the current status of any pending interrupts

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 * @irq_index:	The interrupt index to configure

 * @status:	Returned interrupts status - one bit per cause:

 *			0 = no interrupt pending

 *			1 = interrupt pending

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

 retrieve response parameters */

/**

 * dpsw_clear_irq_status() - Clear a pending interrupt's status

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPCI object

 * @irq_index:	The interrupt index to configure

 * @status:	bits to clear (W1C) - one bit per cause:

 *			0 = don't change

 *			1 = clear status bit

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpsw_get_attributes() - Retrieve DPSW attributes

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 * @attr:	Returned DPSW attributes

 *

 * Return:	Completion status. '0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

 retrieve response parameters */

/**

 * dpsw_if_set_link_cfg() - Set the link configuration.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 * @if_id:	Interface id

 * @cfg:	Link configuration

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpsw_if_get_link_state - Return the link state

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 * @if_id:	Interface id

 * @state:	Link state	1 - linkup, 0 - link down or disconnected

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

 retrieve response parameters */

/**

 * dpsw_if_set_tci() - Set default VLAN Tag Control Information (TCI)

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 * @if_id:	Interface Identifier

 * @cfg:	Tag Control Information Configuration

 *

 * Return:	Completion status. '0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpsw_if_get_tci() - Get default VLAN Tag Control Information (TCI)

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 * @if_id:	Interface Identifier

 * @cfg:	Tag Control Information Configuration

 *

 * Return:	Completion status. '0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

 retrieve response parameters */

/**

 * dpsw_if_set_stp() - Function sets Spanning Tree Protocol (STP) state.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 * @if_id:	Interface Identifier

 * @cfg:	STP State configuration parameters

 *

 * The following STP states are supported -

 * blocking, listening, learning, forwarding and disabled.

 *

 * Return:	Completion status. '0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpsw_if_get_counter() - Get specific counter of particular interface

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 * @if_id:	Interface Identifier

 * @type:	Counter type

 * @counter:	return value

 *

 * Return:	Completion status. '0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

 retrieve response parameters */

/**

 * dpsw_if_enable() - Enable Interface

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 * @if_id:	Interface Identifier

 *

 * Return:	Completion status. '0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpsw_if_disable() - Disable Interface

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 * @if_id:	Interface Identifier

 *

 * Return:	Completion status. '0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpsw_if_get_attributes() - Function obtains attributes of interface

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 * @if_id:	Interface Identifier

 * @attr:	Returned interface attributes

 *

 * Return:	Completion status. '0' on Success; Error code otherwise.

/**

 * dpsw_if_set_max_frame_length() - Set Maximum Receive frame length.

 * @mc_io:		Pointer to MC portal's I/O object

 * @cmd_flags:		Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:		Token of DPSW object

 * @if_id:		Interface Identifier

 * @frame_length:	Maximum Frame Length

 *

 * Return:	Completion status. '0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpsw_vlan_add() - Adding new VLAN to DPSW.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 * @vlan_id:	VLAN Identifier

 * @cfg:	VLAN configuration

 *

 * Only VLAN ID and FDB ID are required parameters here.

 * 12 bit VLAN ID is defined in IEEE802.1Q.

 * Adding a duplicate VLAN ID is not allowed.

 * FDB ID can be shared across multiple VLANs. Shared learning

 * is obtained by calling dpsw_vlan_add for multiple VLAN IDs

 * with same fdb_id

 *

 * Return:	Completion status. '0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpsw_vlan_add_if() - Adding a set of interfaces to an existing VLAN.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 * @vlan_id:	VLAN Identifier

 * @cfg:	Set of interfaces to add

 *

 * It adds only interfaces not belonging to this VLAN yet,

 * otherwise an error is generated and an entire command is

 * ignored. This function can be called numerous times always

 * providing required interfaces delta.

 *

 * Return:	Completion status. '0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpsw_vlan_add_if_untagged() - Defining a set of interfaces that should be

 *				transmitted as untagged.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 * @vlan_id:	VLAN Identifier

 * @cfg:	Set of interfaces that should be transmitted as untagged

 *

 * These interfaces should already belong to this VLAN.

 * By default all interfaces are transmitted as tagged.

 * Providing un-existing interface or untagged interface that is

 * configured untagged already generates an error and the entire

 * command is ignored.

 *

 * Return:	Completion status. '0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpsw_vlan_remove_if() - Remove interfaces from an existing VLAN.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 * @vlan_id:	VLAN Identifier

 * @cfg:	Set of interfaces that should be removed

 *

 * Interfaces must belong to this VLAN, otherwise an error

 * is returned and an the command is ignored

 *

 * Return:	Completion status. '0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpsw_vlan_remove_if_untagged() - Define a set of interfaces that should be

 *		converted from transmitted as untagged to transmit as tagged.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 * @vlan_id:	VLAN Identifier

 * @cfg:	Set of interfaces that should be removed

 *

 * Interfaces provided by API have to belong to this VLAN and

 * configured untagged, otherwise an error is returned and the

 * command is ignored

 *

 * Return:	Completion status. '0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpsw_vlan_remove() - Remove an entire VLAN

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 * @vlan_id:	VLAN Identifier

 *

 * Return:	Completion status. '0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpsw_fdb_add() - Add FDB to switch and Returns handle to FDB table for

 *		the reference

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 * @fdb_id:	Returned Forwarding Database Identifier

 * @cfg:	FDB Configuration

 *

 * Return:	Completion status. '0' on Success; Error code otherwise.

/**

 * dpsw_fdb_remove() - Remove FDB from switch

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 * @fdb_id:	Forwarding Database Identifier

 *

 * Return:	Completion status. '0' on Success; Error code otherwise.

 prepare command */

/**

 * dpsw_fdb_add_unicast() - Function adds an unicast entry into MAC lookup table

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 * @fdb_id:	Forwarding Database Identifier

 * @cfg:	Unicast entry configuration

 *

 * Return:	Completion status. '0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpsw_fdb_dump() - Dump the content of FDB table into memory.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 * @fdb_id:	Forwarding Database Identifier

 * @iova_addr:	Data will be stored here as an array of struct fdb_dump_entry

 * @iova_size:	Memory size allocated at iova_addr

 * @num_entries:Number of entries written at iova_addr

 *

 * Return:	Completion status. '0' on Success; Error code otherwise.

 *

 * The memory allocated at iova_addr must be initialized with zero before

 * command execution. If the FDB table does not fit into memory MC will stop

 * after the memory is filled up.

 * The struct fdb_dump_entry array must be parsed until the end of memory

 * area or until an entry with mac_addr set to zero is found.

 prepare command */

 send command to mc */

/**

 * dpsw_fdb_remove_unicast() - removes an entry from MAC lookup table

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 * @fdb_id:	Forwarding Database Identifier

 * @cfg:	Unicast entry configuration

 *

 * Return:	Completion status. '0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpsw_fdb_add_multicast() - Add a set of egress interfaces to multi-cast group

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 * @fdb_id:	Forwarding Database Identifier

 * @cfg:	Multicast entry configuration

 *

 * If group doesn't exist, it will be created.

 * It adds only interfaces not belonging to this multicast group

 * yet, otherwise error will be generated and the command is

 * ignored.

 * This function may be called numerous times always providing

 * required interfaces delta.

 *

 * Return:	Completion status. '0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpsw_fdb_remove_multicast() - Removing interfaces from an existing multicast

 *				group.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 * @fdb_id:	Forwarding Database Identifier

 * @cfg:	Multicast entry configuration

 *

 * Interfaces provided by this API have to exist in the group,

 * otherwise an error will be returned and an entire command

 * ignored. If there is no interface left in the group,

 * an entire group is deleted

 *

 * Return:	Completion status. '0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpsw_ctrl_if_get_attributes() - Obtain control interface attributes

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 * @attr:	Returned control interface attributes

 *

 * Return:	'0' on Success; Error code otherwise.

/**

 * dpsw_ctrl_if_set_pools() - Set control interface buffer pools

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 * @cfg:	Buffer pools configuration

 *

 * Return:	'0' on Success; Error code otherwise.

/**

 * dpsw_ctrl_if_set_queue() - Set Rx queue configuration

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of dpsw object

 * @qtype:	dpsw_queue_type of the targeted queue

 * @cfg:	Rx queue configuration

 *

 * Return:	'0' on Success; Error code otherwise.

/**

 * dpsw_get_api_version() - Get Data Path Switch API version

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @major_ver:	Major version of data path switch API

 * @minor_ver:	Minor version of data path switch API

 *

 * Return:  '0' on Success; Error code otherwise.

/**

 * dpsw_if_get_port_mac_addr() - Retrieve MAC address associated to the physical port

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 * @if_id:	Interface Identifier

 * @mac_addr:	MAC address of the physical port, if any, otherwise 0

 *

 * Return:	Completion status. '0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

 retrieve response parameters */

/**

 * dpsw_ctrl_if_enable() - Enable control interface

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 *

 * Return:	'0' on Success; Error code otherwise.

/**

 * dpsw_ctrl_if_disable() - Function disables control interface

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 *

 * Return:	'0' on Success; Error code otherwise.

/**

 * dpsw_set_egress_flood() - Set egress parameters associated with an FDB ID

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 * @cfg:	Egress flooding configuration

 *

 * Return:	'0' on Success; Error code otherwise.

/**

 * dpsw_if_set_learning_mode() - Configure the learning mode on an interface.

 * If this API is used, it will take precedence over the FDB configuration.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 * @if_id:	InterfaceID

 * @mode:	Learning mode

 *

 * Return:	Completion status. '0' on Success; Error code otherwise.

/**

 * dpsw_acl_add() - Create an ACL table

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 * @acl_id:	Returned ACL ID, for future references

 * @cfg:	ACL configuration

 *

 * Create Access Control List table. Multiple ACLs can be created and

 * co-exist in L2 switch

 *

 * Return:	'0' on Success; Error code otherwise.

/**

 * dpsw_acl_remove() - Remove an ACL table from L2 switch.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 * @acl_id:	ACL ID

 *

 * Return:	'0' on Success; Error code otherwise.

/**

 * dpsw_acl_add_if() - Associate interface/interfaces with an ACL table.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 * @acl_id:	ACL ID

 * @cfg:	Interfaces list

 *

 * Return:	'0' on Success; Error code otherwise.

/**

 * dpsw_acl_remove_if() - De-associate interface/interfaces from an ACL table

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 * @acl_id:	ACL ID

 * @cfg:	Interfaces list

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpsw_acl_prepare_entry_cfg() - Setup an ACL entry

 * @key:		Key

 * @entry_cfg_buf:	Zeroed 256 bytes of memory before mapping it to DMA

 *

 * This function has to be called before adding or removing acl_entry

 *

/**

 * dpsw_acl_add_entry() - Add a rule to the ACL table.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 * @acl_id:	ACL ID

 * @cfg:	Entry configuration

 *

 * warning: This function has to be called after dpsw_acl_prepare_entry_cfg()

 *

 * Return:	'0' on Success; Error code otherwise.

/**

 * dpsw_acl_remove_entry() - Removes an entry from ACL.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 * @acl_id:	ACL ID

 * @cfg:	Entry configuration

 *

 * warning: This function has to be called after dpsw_acl_set_entry_cfg()

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpsw_set_reflection_if() - Set target interface for traffic mirrored

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 * @if_id:	Interface Id

 *

 * Only one mirroring destination is allowed per switch

 *

 * Return:	Completion status. '0' on Success; Error code otherwise.

/**

 * dpsw_if_add_reflection() - Setup mirroring rule

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 * @if_id:	Interface Identifier

 * @cfg:	Reflection configuration

 *

 * Return:	Completion status. '0' on Success; Error code otherwise.

/**

 * dpsw_if_remove_reflection() - Remove mirroring rule

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPSW object

 * @if_id:	Interface Identifier

 * @cfg:	Reflection configuration

 *

 * Return:	Completion status. '0' on Success; Error code otherwise.

 SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)

/* Copyright 2014-2016 Freescale Semiconductor Inc.

 * Copyright 2016 NXP

 * Copyright 2020 NXP

 DPNI_LINK_OPT_* */

 To be kept in sync with DPNI statistics */

 per-cpu stats */

 Channel stats */

 FQ stats */

 ethtool_get_stats(), ethtool_get_drvinfo() */

/** Fill in hardware counters, as returned by MC.

 Print standard counters, from DPNI statistics */

 We're not interested in pages 4 & 5 for now */

 Older firmware versions don't support all pages */

 Print per-cpu extra stats */

 Per-channel stats */

 Print FQ instantaneous counts */

 Only apply the rule for IPv4 frames */

 Only apply the rule for IPv4 frames with the specified L4 proto */

 allocate twice the key size, for the actual key and for mask */

 Fill the key and mask memory areas */

		/* Masking allows us to configure a maximal key during init and

		 * use it for all flow steering rules. Without it, we include

		 * in the key only the fields actually used, so we need to

		 * extract the others from the final key buffer.

		 *

		 * Program the FS key if needed, or return error if previously

		 * set key can't be used for the current rule. User needs to

		 * delete existing rules in this case to allow for the new one.

 If a rule is present at the specified location, delete it. */

 If no new entry to add, return here */

		/* we purposely ignore cmd->flow_type for now, because the

		 * classifier only supports a single set of fields for all

		 * protocols

 Keep track of the previous value, just in case we fail */

 Setup new value for rx coalescing */

 SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)

/* Copyright 2013-2016 Freescale Semiconductor Inc.

 * Copyright 2016 NXP

 * Copyright 2020 NXP

/**

 * dpni_prepare_key_cfg() - function prepare extract parameters

 * @cfg: defining a full Key Generation profile (rule)

 * @key_cfg_buf: Zeroed 256 bytes of memory before mapping it to DMA

 *

 * This function has to be called before the following functions:

 *	- dpni_set_rx_tc_dist()

 *	- dpni_set_qos_table()

 *

 * Return:	'0' on Success; Error code otherwise.

/**

 * dpni_open() - Open a control session for the specified object

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @dpni_id:	DPNI unique ID

 * @token:	Returned token; use in subsequent API calls

 *

 * This function can be used to open a control session for an

 * already created object; an object may have been declared in

 * the DPL or by calling the dpni_create() function.

 * This function returns a unique authentication token,

 * associated with the specific object ID and the specific MC

 * portal; this token must be used in all subsequent commands for

 * this specific object.

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

 retrieve response parameters */

/**

 * dpni_close() - Close the control session of the object

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 *

 * After this function is called, no further operations are

 * allowed on the object without opening a new control session.

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpni_set_pools() - Set buffer pools configuration

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @cfg:	Buffer pools configuration

 *

 * mandatory for DPNI operation

 * warning:Allowed only when DPNI is disabled

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpni_enable() - Enable the DPNI, allow sending and receiving frames.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:		Token of DPNI object

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpni_disable() - Disable the DPNI, stop sending and receiving frames.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpni_is_enabled() - Check if the DPNI is enabled.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @en:		Returns '1' if object is enabled; '0' otherwise

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

 retrieve response parameters */

/**

 * dpni_reset() - Reset the DPNI, returns the object to initial state.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpni_set_irq_enable() - Set overall interrupt state.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @irq_index:	The interrupt index to configure

 * @en:		Interrupt state: - enable = 1, disable = 0

 *

 * Allows GPP software to control when interrupts are generated.

 * Each interrupt can have up to 32 causes.  The enable/disable control's the

 * overall interrupt state. if the interrupt is disabled no causes will cause

 * an interrupt.

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpni_get_irq_enable() - Get overall interrupt state

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @irq_index:	The interrupt index to configure

 * @en:		Returned interrupt state - enable = 1, disable = 0

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

 retrieve response parameters */

/**

 * dpni_set_irq_mask() - Set interrupt mask.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @irq_index:	The interrupt index to configure

 * @mask:	event mask to trigger interrupt;

 *			each bit:

 *				0 = ignore event

 *				1 = consider event for asserting IRQ

 *

 * Every interrupt can have up to 32 causes and the interrupt model supports

 * masking/unmasking each cause independently

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpni_get_irq_mask() - Get interrupt mask.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @irq_index:	The interrupt index to configure

 * @mask:	Returned event mask to trigger interrupt

 *

 * Every interrupt can have up to 32 causes and the interrupt model supports

 * masking/unmasking each cause independently

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

 retrieve response parameters */

/**

 * dpni_get_irq_status() - Get the current status of any pending interrupts.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @irq_index:	The interrupt index to configure

 * @status:	Returned interrupts status - one bit per cause:

 *			0 = no interrupt pending

 *			1 = interrupt pending

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

 retrieve response parameters */

/**

 * dpni_clear_irq_status() - Clear a pending interrupt's status

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @irq_index:	The interrupt index to configure

 * @status:	bits to clear (W1C) - one bit per cause:

 *			0 = don't change

 *			1 = clear status bit

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpni_get_attributes() - Retrieve DPNI attributes.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @attr:	Object's attributes

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

 retrieve response parameters */

/**

 * dpni_set_errors_behavior() - Set errors behavior

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @cfg:	Errors configuration

 *

 * this function may be called numerous times with different

 * error masks

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpni_get_buffer_layout() - Retrieve buffer layout attributes.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @qtype:	Type of queue to retrieve configuration for

 * @layout:	Returns buffer layout attributes

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

 retrieve response parameters */

/**

 * dpni_set_buffer_layout() - Set buffer layout configuration.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @qtype:	Type of queue this configuration applies to

 * @layout:	Buffer layout configuration

 *

 * Return:	'0' on Success; Error code otherwise.

 *

 * @warning	Allowed only when DPNI is disabled

 prepare command */

 send command to mc*/

/**

 * dpni_set_offload() - Set DPNI offload configuration.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @type:	Type of DPNI offload

 * @config:	Offload configuration.

 *		For checksum offloads, non-zero value enables the offload

 *

 * Return:     '0' on Success; Error code otherwise.

 *

 * @warning    Allowed only when DPNI is disabled

 prepare command */

 send command to mc*/

 retrieve response parameters */

/**

 * dpni_get_qdid() - Get the Queuing Destination ID (QDID) that should be used

 *			for enqueue operations

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @qtype:	Type of queue to receive QDID for

 * @qdid:	Returned virtual QDID value that should be used as an argument

 *			in all enqueue operations

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

 retrieve response parameters */

/**

 * dpni_get_tx_data_offset() - Get the Tx data offset (from start of buffer)

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @data_offset: Tx data offset (from start of buffer)

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

 retrieve response parameters */

/**

 * dpni_set_link_cfg() - set the link configuration.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @cfg:	Link configuration

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpni_get_link_cfg() - return the link configuration

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @cfg:	Link configuration from dpni object

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

 retrieve response parameters */

/**

 * dpni_get_link_state() - Return the link state (either up or down)

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @state:	Returned link state;

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

 retrieve response parameters */

/**

 * dpni_set_max_frame_length() - Set the maximum received frame length.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @max_frame_length:	Maximum received frame length (in

 *				bytes); frame is discarded if its

 *				length exceeds this value

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpni_get_max_frame_length() - Get the maximum received frame length.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @max_frame_length:	Maximum received frame length (in

 *				bytes); frame is discarded if its

 *				length exceeds this value

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

 retrieve response parameters */

/**

 * dpni_set_multicast_promisc() - Enable/disable multicast promiscuous mode

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @en:		Set to '1' to enable; '0' to disable

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpni_get_multicast_promisc() - Get multicast promiscuous mode

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @en:		Returns '1' if enabled; '0' otherwise

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

 retrieve response parameters */

/**

 * dpni_set_unicast_promisc() - Enable/disable unicast promiscuous mode

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @en:		Set to '1' to enable; '0' to disable

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpni_get_unicast_promisc() - Get unicast promiscuous mode

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @en:		Returns '1' if enabled; '0' otherwise

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

 retrieve response parameters */

/**

 * dpni_set_primary_mac_addr() - Set the primary MAC address

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @mac_addr:	MAC address to set as primary address

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpni_get_primary_mac_addr() - Get the primary MAC address

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @mac_addr:	Returned MAC address

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

 retrieve response parameters */

/**

 * dpni_get_port_mac_addr() - Retrieve MAC address associated to the physical

 *			port the DPNI is attached to

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @mac_addr:	MAC address of the physical port, if any, otherwise 0

 *

 * The primary MAC address is not cleared by this operation.

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

 retrieve response parameters */

/**

 * dpni_enable_vlan_filter() - Enable/disable VLAN filtering mode

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @en:		Set to '1' to enable; '0' to disable

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpni_add_vlan_id() - Add VLAN ID filter

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @vlan_id:	VLAN ID to add

 * @flags:   0 - tc_id and flow_id will be ignored.

 * Pkt with this vlan_id will be passed to the next

 * classification stages

 * DPNI_VLAN_SET_QUEUE_ACTION

 * Pkt with this vlan_id will be forward directly to

 * queue defined by the tc_id and flow_id

 *

 * @tc_id: Traffic class selection (0-7)

 * @flow_id: Selects the specific queue out of the set allocated for the

 *           same as tc_id. Value must be in range 0 to NUM_QUEUES - 1

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpni_remove_vlan_id() - Remove VLAN ID filter

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @vlan_id:	VLAN ID to remove

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpni_add_mac_addr() - Add MAC address filter

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @mac_addr:	MAC address to add

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpni_remove_mac_addr() - Remove MAC address filter

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @mac_addr:	MAC address to remove

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpni_clear_mac_filters() - Clear all unicast and/or multicast MAC filters

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @unicast:	Set to '1' to clear unicast addresses

 * @multicast:	Set to '1' to clear multicast addresses

 *

 * The primary MAC address is not cleared by this operation.

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpni_set_rx_tc_dist() - Set Rx traffic class distribution configuration

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @tc_id:	Traffic class selection (0-7)

 * @cfg:	Traffic class distribution configuration

 *

 * warning: if 'dist_mode != DPNI_DIST_MODE_NONE', call dpni_prepare_key_cfg()

 *			first to prepare the key_cfg_iova parameter

 *

 * Return:	'0' on Success; error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpni_set_congestion_notification() - Set traffic class congestion

 *					notification configuration

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @qtype:	Type of queue - Rx, Tx and Tx confirm types are supported

 * @tc_id:	Traffic class selection (0-7)

 * @cfg:	Congestion notification configuration

 *

 * Return:	'0' on Success; error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpni_set_queue() - Set queue parameters

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @qtype:	Type of queue - all queue types are supported, although

 *		the command is ignored for Tx

 * @tc:		Traffic class, in range 0 to NUM_TCS - 1

 * @index:	Selects the specific queue out of the set allocated for the

 *		same TC. Value must be in range 0 to NUM_QUEUES - 1

 * @options:	A combination of DPNI_QUEUE_OPT_ values that control what

 *		configuration options are set on the queue

 * @queue:	Queue structure

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc */

/**

 * dpni_get_queue() - Get queue parameters

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @qtype:	Type of queue - all queue types are supported

 * @tc:		Traffic class, in range 0 to NUM_TCS - 1

 * @index:	Selects the specific queue out of the set allocated for the

 *		same TC. Value must be in range 0 to NUM_QUEUES - 1

 * @queue:	Queue configuration structure

 * @qid:	Queue identification

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc */

 retrieve response parameters */

/**

 * dpni_get_statistics() - Get DPNI statistics

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @page:	Selects the statistics page to retrieve, see

 *		DPNI_GET_STATISTICS output. Pages are numbered 0 to 6.

 * @stat:	Structure containing the statistics

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc */

 retrieve response parameters */

/**

 * dpni_set_taildrop() - Set taildrop per queue or TC

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @cg_point:	Congestion point

 * @qtype:	Queue type on which the taildrop is configured.

 *		Only Rx queues are supported for now

 * @tc:		Traffic class to apply this taildrop to

 * @index:	Index of the queue if the DPNI supports multiple queues for

 *		traffic distribution. Ignored if CONGESTION_POINT is not 0.

 * @taildrop:	Taildrop structure

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc */

/**

 * dpni_get_taildrop() - Get taildrop information

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @cg_point:	Congestion point

 * @qtype:	Queue type on which the taildrop is configured.

 *		Only Rx queues are supported for now

 * @tc:		Traffic class to apply this taildrop to

 * @index:	Index of the queue if the DPNI supports multiple queues for

 *		traffic distribution. Ignored if CONGESTION_POINT is not 0.

 * @taildrop:	Taildrop structure

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc */

 retrieve response parameters */

/**

 * dpni_get_api_version() - Get Data Path Network Interface API version

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @major_ver:	Major version of data path network interface API

 * @minor_ver:	Minor version of data path network interface API

 *

 * Return:	'0' on Success; Error code otherwise.

/**

 * dpni_set_rx_fs_dist() - Set Rx flow steering distribution

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @cfg: Distribution configuration

 *

 * If the FS is already enabled with a previous call the classification

 * key will be changed but all the table rules are kept. If the

 * existing rules do not match the key the results will not be

 * predictable. It is the user responsibility to keep key integrity.

 * If cfg.enable is set to 1 the command will create a flow steering table

 * and will classify packets according to this table. The packets that

 * miss all the table rules will be classified according to settings

 * made in dpni_set_rx_hash_dist()

 * If cfg.enable is set to 0 the command will clear flow steering table.

 * The packets will be classified according to settings made in

 * dpni_set_rx_hash_dist()

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpni_set_rx_hash_dist() - Set Rx hash distribution

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @cfg: Distribution configuration

 * If cfg.enable is set to 1 the packets will be classified using a hash

 * function based on the key received in cfg.key_cfg_iova parameter.

 * If cfg.enable is set to 0 the packets will be sent to the default queue

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpni_add_fs_entry() - Add Flow Steering entry for a specific traffic class

 *			(to select a flow ID)

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @tc_id:	Traffic class selection (0-7)

 * @index:	Location in the FS table where to insert the entry.

 *		Only relevant if MASKING is enabled for FS

 *		classification on this DPNI, it is ignored for exact match.

 * @cfg:	Flow steering rule to add

 * @action:	Action to be taken as result of a classification hit

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpni_remove_fs_entry() - Remove Flow Steering entry from a specific

 *			    traffic class

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @tc_id:	Traffic class selection (0-7)

 * @cfg:	Flow steering rule to remove

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpni_set_qos_table() - Set QoS mapping table

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @cfg:	QoS table configuration

 *

 * This function and all QoS-related functions require that

 *'max_tcs > 1' was set at DPNI creation.

 *

 * warning: Before calling this function, call dpkg_prepare_key_cfg() to

 *			prepare the key_cfg_iova parameter

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpni_add_qos_entry() - Add QoS mapping entry (to select a traffic class)

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @cfg:	QoS rule to add

 * @tc_id:	Traffic class selection (0-7)

 * @index:	Location in the QoS table where to insert the entry.

 *		Only relevant if MASKING is enabled for QoS classification on

 *		this DPNI, it is ignored for exact match.

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpni_remove_qos_entry() - Remove QoS mapping entry

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @cfg:	QoS rule to remove

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpni_clear_qos_table() - Clear all QoS mapping entries

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 *

 * Following this function call, all frames are directed to

 * the default traffic class (0)

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpni_set_tx_shaping() - Set the transmit shaping

 * @mc_io:		Pointer to MC portal's I/O object

 * @cmd_flags:		Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:		Token of DPNI object

 * @tx_cr_shaper:	TX committed rate shaping configuration

 * @tx_er_shaper:	TX excess rate shaping configuration

 * @coupled:		Committed and excess rate shapers are coupled

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpni_get_single_step_cfg() - return current configuration for

 *                              single step PTP

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @ptp_cfg:	ptp single step configuration

 *

 * Return:	'0' on Success; Error code otherwise.

 *

 prepare command */

 send command to mc*/

 read command response */

/**

 * dpni_set_single_step_cfg() - enable/disable and configure single step PTP

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPNI object

 * @ptp_cfg:	ptp single step configuration

 *

 * Return:	'0' on Success; Error code otherwise.

 *

 * The function has effect only when dpni object is connected to a dpmac

 * object. If the dpni is not connected to a dpmac the configuration will

 * be stored inside and applied when connection is made.

 prepare command */

 send command to mc*/

 SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)

/* Copyright 2020 NXP

			/* Low part of FAF.

			 * position ranges from 31 to 0, mask from 0 to 31.

			/* High part of FAF.

			 * position ranges from 95 to 32, mask from 0 to 63.

	/* No support for changing the action of an independent packet trap,

	 * only per trap group - parser error drops

 Configure handling of frames marked as errors from the parser */

 SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)

/* Copyright 2015 Freescale Semiconductor Inc.

 * Copyright 2018-2019 NXP

 Skip FQs with no traffic */

 Create a directory for the interface */

 per-cpu stats file */

 per-fq stats file */

 per-fq stats file */

 SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)

/* Copyright 2014-2016 Freescale Semiconductor Inc.

 * Copyright 2016-2020 NXP

/* CREATE_TRACE_POINTS only needs to be defined once. Other dpa files

 * using trace events only need to #include <trace/events/sched.h>

 HW checksum validation is disabled, nothing to do here */

 Read checksum validation bits */

 Inform the stack there's no need to compute L3/L4 csum anymore */

/* Free a received FD.

 * Not to be used for Tx conf FDs or on any other paths.

 If single buffer frame, just free the data buffer */

 We don't support any other format */

	/* For S/G frames, we first need to free all SG entries

	 * except the first one, which was taken care of already

 Build a linear skb based on a single-buffer frame descriptor */

 Build a non linear (fragmented) skb based on a S/G table */

		/* NOTE: We only support SG entries in dpaa2_sg_single format,

		 * but this is the only format we may receive from HW anyway

 Get the address and length from the S/G entry */

 We build the skb around the first data buffer */

				/* Free the first SG entry now, since we already

				 * unmapped it and obtained the virtual address

				/* We still need to subtract the buffers used

				 * by this FD from our software counter

 Rest of the data buffers are stored as skb frags */

			/* Offset in page (which may be compound).

			 * Data in subsequent SG entries is stored from the

			 * beginning of the buffer, so we don't need to add the

			 * sg_offset.

 Count all data buffers + SG table buffer */

/* Free buffers acquired from the buffer pool or which were meant to

 * be released in the pool

 try to enqueue all the FDs until the max number of retries is hit */

 enqueue the array of XDP_TX frames

 update statistics */

 Mark the egress frame hardware annotation area as valid */

	/* Instruct hardware to release the FD buffer directly into

	 * the buffer pool once transmission is completed, instead of

	 * sending a Tx confirmation frame to us

 xdp.data pointer may have changed */

 Allow redirect use of full headroom */

 Main Rx frame processing routine */

 Tracing point */

 We don't support any other format */

 Get the timestamp value */

 Check if we need to validate the L4 csum */

/* Processing of Rx frames received on the error FQ

 * We check and print the error bits and then free the frame

 We don't support any other format */

/* Consume all frames pull-dequeued into the store. This is the simplest way to

 * make sure we don't accidentally issue another volatile dequeue which would

 * overwrite (leak) frames already in the store.

 *

 * Observance of NAPI budget is not our concern, leaving that to the caller.

			/* If we're here, we *must* have placed a

			 * volatile dequeue comnmand, so keep reading through

			 * the store until we get some sort of valid response

			 * token (either a valid frame or an "empty dequeue")

	/* A dequeue operation only pulls frames from a single queue

	 * into the store. Return the frame queue as an out param.

 Configure the egress frame annotation for timestamp update */

 Mark the egress frame annotation area as valid */

 Set hardware annotation size */

	/* enable UPD (update prepanded data) bit in FAEAD field of

	 * hardware frame annotation area

 Mark the frame annotation status as valid */

 Mark the PTP flag for one step timestamping */

 Update current time to PTP message originTimestamp field */

 Create a frame descriptor based on a fragmented skb */

	/* Create and map scatterlist.

	 * We don't advertise NETIF_F_FRAGLIST, so skb_to_sgvec() will not have

	 * to go beyond nr_frags+1.

	 * Note: We don't support chained scatterlists

 Prepare the HW SGT structure */

	/* Fill in the HW SGT structure.

	 *

	 * sgt_buf is zeroed out, so the following fields are implicit

	 * in all sgt entries:

	 *   - offset is 0

	 *   - format is 'dpaa2_sg_single'

	/* Store the skb backpointer in the SGT buffer.

	 * Fit the scatterlist and the number of buffers alongside the

	 * skb backpointer in the software annotation area. We'll need

	 * all of them on Tx Conf.

 Separately map the SGT buffer */

/* Create a SG frame descriptor based on a linear skb.

 *

 * This function is used on the Tx path when the skb headroom is not large

 * enough for the HW requirements, thus instead of realloc-ing the skb we

 * create a SG frame descriptor with only one entry.

 Prepare the HW SGT structure */

 Fill in the HW SGT structure */

 Store the skb backpointer in the SGT buffer */

 Separately map the SGT buffer */

 Create a frame descriptor based on a linear skb */

	/* If there's enough room to align the FD address, do it.

	 * It will help hardware optimize accesses.

	/* Store a backpointer to the skb at the beginning of the buffer

	 * (in the private data area) such that we can release it

	 * on Tx confirm

/* FD freeing routine on the Tx path

 *

 * DMA-unmap and free FD and possibly SGT buffer allocated on Tx. The skb

 * back-pointed to is also freed.

 * This can be called either from dpaa2_eth_tx_conf() or on the error path of

 * dpaa2_eth_tx().

			/* Accessing the skb buffer is safe before dma unmap,

			 * because we didn't map the actual skb shell.

 Unmap the scatterlist */

 Unmap the SGT buffer */

 Unmap the SGT Buffer */

 Get the timestamp value */

 Free SGT buffer allocated on tx */

 Move on with skb release */

	/* We'll be holding a back-reference to the skb until Tx Confirmation;

	 * we don't want that overwritten by a concurrent Tx with a cloned skb.

 skb_unshare() has already freed the skb */

 Setup the FD fields */

 Tracing point */

	/* TxConf FQ selection relies on queue id from the stack.

	 * In case of a forwarded frame from another DPNI interface, we choose

	 * a queue affined to the same core that processed the Rx frame

		/* Hardware interprets priority level 0 as being the highest,

		 * so we need to do a reverse mapping to the netdev tc index

		/* We have only one FQ array entry for all Tx hardware queues

		 * with the same flow id (but different priority levels)

	/* Everything that happens after this enqueues might race with

	 * the Tx confirmation callback for this frame

 Clean up everything, including freeing the skb */

		/* Lock just before TX one-step timestamping packet,

		 * and release the lock in dpaa2_eth_free_tx_fd when

		 * confirm the packet has been sent on hardware, or

		 * when clean up during transmit failure.

 Utilize skb->cb[0] for timestamping request per skb */

 TX for one-step timestamping PTP Sync packet */

		/* Use two-step timestamping if not one-step timestamping

		 * PTP Sync packet

 TX for other packets */

 Tx confirmation frame processing routine */

 Tracing point */

 Check frame errors in the FD field */

 Tx-conf logically pertains to the egress path. */

/* Perform a single release command to add buffers

 * to the specified buffer pool

		/* Allocate buffer visible to WRIOP + skb shared info +

		 * alignment padding

		/* allocate one page for each Rx buffer. WRIOP sees

		 * the entire page except for a tailroom reserved for

		 * skb shared info

 tracing point */

 In case the portal is busy, retry until successful */

	/* If release command failed, clean up and bail out;

	 * not much else we can do about it

	/* If we managed to allocate at least some buffers,

	 * release them to hardware

/*

 * Drain the specified number of buffers from the DPNI's private buffer pool.

 * @count must not exceeed DPAA2_ETH_BUFS_PER_CMD

/* Function is called from softirq context only, so we don't need to guard

 * the access to percpu count

 Out of memory; abort for now, we'll try later on */

 Retry while portal is busy */

/* NAPI poll routine

 *

 * Frames are dequeued from the QMan channel associated with this NAPI context.

 * Rx, Tx confirmation and (if configured) Rx error frames all count

 * towards the NAPI budget.

 Refill pool if appropriate */

 We have a single Tx conf FQ on this channel */

		/* If we either consumed the whole NAPI budget with Rx frames

		 * or we reached the Tx confirmations threshold, we're done.

 Update NET DIM with the values for this CDAN */

	/* We didn't consume the entire budget, so finish napi and

	 * re-enable data availability notifications

	/* FQ taildrop: threshold is in bytes, per frame queue. Enabled if

	 * flow control is disabled (as it might interfere with either the

	 * buffer pool depletion trigger for pause frames or with the group

	 * congestion trigger for PFC frames)

	/* Congestion group taildrop: threshold is in frames, per group

	 * of FQs belonging to the same traffic class

	 * Enabled if general Tx pause disabled or if PFCs are enabled

	 * (congestion group threhsold for PFC generation is lower than the

	 * CG taildrop threshold, so it won't interfere with it; we also

	 * want frames in non-PFC enabled traffic classes to be kept in check)

	/* If Tx pause frame settings have changed, we need to update

	 * Rx FQ taildrop configuration as well. We configure taildrop

	 * only when pause frame generation is disabled.

	/* When we manage the MAC/PHY using phylink there is no need

	 * to manually update the netif_carrier.

 Chech link state; speed / duplex changes are not treated yet */

		/* Not much to do; the buffer pool, though not filled up,

		 * may still contain some buffers which would enable us

		 * to limp on.

		/* We'll only start the txqs when the link is actually ready;

		 * make sure we don't race against the link up notification,

		 * which may come immediately after dpni_enable();

		/* Also, explicitly set carrier off, otherwise

		 * netif_carrier_ok() will return true and cause 'ip link show'

		 * to report the LOWER_UP flag, even though the link

		 * notification wasn't even received.

 Total number of in-flight frames on ingress queues */

	/* On dpni_disable(), the MC firmware will:

	 * - stop MAC Rx and wait for all Rx frames to be enqueued to software

	 * - cut off WRIOP dequeues from egress FQs and wait until transmission

	 * of all in flight Tx frames is finished (and corresponding Tx conf

	 * frames are enqueued back to software)

	 *

	 * Before calling dpni_disable(), we wait for all Tx frames to arrive

	 * on WRIOP. After it finishes, wait until all remaining frames on Rx

	 * and Tx conf queues are consumed on NAPI poll.

 Allow the hardware some slack */

		/* Must go on and disable NAPI nonetheless, so we don't crash at

		 * the next "ifconfig up"

 Empty the buffer pool */

 Empty the Scatter-Gather Buffer cache */

/** Fill in counters maintained by the GPP driver. These may be different from

 * the hardware counters obtained by ethtool.

/* Copy mac unicast addresses from @net_dev to @priv.

 * Its sole purpose is to make dpaa2_eth_set_rx_mode() more readable.

/* Copy mac multicast addresses from @net_dev to @priv

 * Its sole purpose is to make dpaa2_eth_set_rx_mode() more readable.

 Basic sanity checks; these probably indicate a misconfiguration */

 Force promiscuous if the uc or mc counts exceed our capabilities. */

 Adjust promisc settings due to flag combinations */

		/* First, rebuild unicast filtering table. This should be done

		 * in promisc mode, in order to avoid frame loss while we

		 * progressively add entries to the table.

		 * We don't know whether we had been in promisc already, and

		 * making an MC call to find out is expensive; so set uc promisc

		 * nonetheless.

 Actual uc table reconstruction. */

 Finally, clear uc promisc and set mc promisc as requested. */

	/* Neither unicast, nor multicast promisc will be on... eventually.

	 * For now, rebuild mac filtering tables while forcing both of them on.

 Actual mac filtering tables reconstruction */

	/* Now we can clear both ucast and mcast promisc, without risking

	 * to drop legitimate frames anymore.

 TS is set for all frame types, not only those requested */

	/* We enforce a maximum Rx frame length based on MTU only if we have

	 * an XDP program attached (in order to avoid Rx S/G frames).

	 * Otherwise, we accept all incoming frames as long as they are not

	 * larger than maximum size supported in hardware

 Reserve extra headroom for XDP header size changes */

	/* While in xdp mode, enforce a maximum Rx frame size based on MTU.

	 * Also, when switching between xdp/non-xdp modes we need to reconfigure

	 * our Rx buffer layout. Buffer pool was drained on dpaa2_eth_stop,

	 * so we are sure no old format buffers will be used from now on.

	/* We require a minimum headroom to be able to transmit the frame.

	 * Otherwise return an error and let the original net_device handle it

 Setup the FD fields */

 Align FD address, if possible */

 fill in necessary fields here */

 create a FD for each xdp_frame in the list received */

 enqueue all the frame descriptors */

 update statistics */

	/* The first <num_queues> entries in priv->fq array are Tx/Tx conf

	 * queues, so only process those

 Only per port Tx shaping */

		/* The TBF interface is in bytes/s, whereas DPAA2 expects the

		 * rate in Mbits/s

 Update NAPI statistics */

 Allocate and configure a DPCON object */

/* DPIO setup: allocate and configure QBMan channels, setup core affinity

 * and register data availability notifications

	/* We want the ability to spread ingress traffic (RX, TX conf) to as

	 * many cores as possible, so we need one channel for each core

	 * (unless there's fewer queues than cores, in which case the extra

	 * channels would be wasted).

	 * Allocate one channel per core and register it to the core's

	 * affine DPIO. If not enough channels are available for all cores

	 * or if some cores don't have an affine DPIO, there will be no

	 * ingress frame processing on those cores.

 Try to allocate a channel */

 Register the new context */

			/* If no affine DPIO for this core, there's probably

			 * none available for next cores either. Signal we want

			 * to retry later, in case the DPIO devices weren't

			 * probed yet.

 Register DPCON notification with MC */

		/* If we managed to allocate a channel and also found an affine

		 * DPIO for this core, add it to the final mask

		/* Stop if we already have enough channels to accommodate all

		 * RX and TX conf queues

 deregister CDAN notifications and free channels */

	/* We should never get here. Issue a warning and return

	 * the first channel, because it's still better than nothing

	/* For each FQ, pick one channel/CPU to deliver frames to.

	 * This may well change at runtime, either through irqbalance or

	 * through direct user intervention.

	/* We have one TxConf FQ per Tx flow.

	 * The number of Tx and Rx queues is the same.

	 * Tx queues come first in the fq array.

 We have exactly one Rx error queue per DPNI */

 For each FQ, decide on which core to process incoming frames */

 Allocate and configure one buffer pool for each interface */

	/* We need to check for WRIOP version 1.0.0, but depending on the MC

	 * version, this number is not always provided correctly on rev1.

	 * We need to check for both alternatives in this situation.

	/* We need to ensure that the buffer size seen by WRIOP is a multiple

	 * of 64 or 256 bytes depending on the WRIOP version.

 tx buffer */

 tx-confirm buffer */

	/* Now that we've set our tx buffer layout, retrieve the minimum

	 * required tx data offset.

 rx buffer */

 Get the default link options so we don't override other flags */

 By default, enable both Rx and Tx pause frames */

	/* We only use Tx FQIDs for FQID-based enqueue, so check

	 * if DPNI version supports it before updating FQIDs

 Configure ingress classification based on VLAN PCP */

 VLAN TCI field */

	/* VLAN-based classification only makes sense if we have multiple

	 * traffic classes.

	 * Also, we need to extract just the 3-bit PCP field from the VLAN

	 * header and we can only do that by using a mask

 set QoS table */

 Add QoS table entries */

	/* We add rules for PCP-based distribution starting with highest

	 * priority (VLAN PCP = 7). If this DPNI doesn't have enough traffic

	 * classes to accommodate all priority levels, the lowest ones end up

	 * on TC 0 which was configured as default

	/* Table and key memory is not persistent, clean everything up after

	 * configuration is finished

 Configure the DPNI object this interface is associated with */

 get a handle for the DPNI object */

 Check if we can work with this DPNI object */

 Enable pause frame support */

 xdp_rxq setup */

 only once for each channel */

 All Tx queues belonging to the same flowid have the same qdbin */

 Supported header fields for Rx hash distribution key */

 L2 header */

		/* This is the last ethertype field parsed:

		 * depending on frame format, it can be the MAC ethertype

		 * or the VLAN etype.

 VLAN header */

 IP header */

		/* Using UDP ports, this is functionally equivalent to raw

		 * byte pairs from L4 header.

 Configure the Rx hash key using the legacy API */

 Configure the Rx hash key using the new API */

		/* If the flow steering / hashing key is shared between all

		 * traffic classes, install it just once

 Configure the Rx flow classification key */

		/* If the flow steering / hashing key is shared between all

		 * traffic classes, install it just once

 Size of the Rx flow classification key */

 Offset of header field in Rx classification key */

/* Prune unused fields from the classification rule.

 * Used when masking is not supported

/* Set Rx distribution (hash or flow classification) key

 * flags is a combination of RXH_ bits

		/* For both Rx hashing and classification keys

		 * we set only the selected fields.

 Prepare for setting the rx dist */

 Check if we actually support Rx flow classification */

	/* If there is no support for masking in the classification table,

	 * we don't set a default key, as it will depend on the rules

	 * added by the user at runtime.

/* Bind the DPNI to its needed objects and resources: buffer pool, DPIOs,

 * frame queues and channels

	/* have the interface implicitly distribute traffic based on

	 * the default hash key

	/* Configure the flow classification key; it includes all

	 * supported header fields and cannot be modified at runtime

 Configure handling of error frames */

 Configure Rx and Tx conf queues to generate CDANs */

 Allocate rings for storing incoming frame descriptors */

 Get firmware address, if any */

 Get DPNI attributes address, if any */

 First check if firmware has any address configured by bootloader */

 If the DPMAC addr != DPNI addr, update it */

		/* No MAC address configured, fill in net_dev->dev_addr

		 * with a random one

		/* Override NET_ADDR_RANDOM set by eth_hw_addr_random(); for all

		 * practical purposes, this will be our "permanent" mac address,

		 * at least until the next reboot. This move will also permit

		 * register_netdevice() to properly fill up net_dev->perm_addr.

		/* NET_ADDR_PERM is default, all we have to do is

		 * fill in the device addr.

 Explicitly add the broadcast address to the MAC filtering table */

 Set MTU upper limit; lower limit is 68B (default value) */

 Set actual number of queues in the net device */

 Capabilities listing */

 Features */

 NAPI weight *MUST* be a multiple of DPAA2_ETH_STORE_SIZE */

 Net device */

 Obtain a MC portal */

 MC objects initialization and configuration */

 Add a NAPI context for each channel */

 Percpu statistics */

 Configure checksum offload based on current interface flags */

 SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)

/* Copyright 2013-2016 Freescale Semiconductor Inc.

 * Copyright 2019 NXP

/**

 * dpmac_open() - Open a control session for the specified object.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @dpmac_id:	DPMAC unique ID

 * @token:	Returned token; use in subsequent API calls

 *

 * This function can be used to open a control session for an

 * already created object; an object may have been declared in

 * the DPL or by calling the dpmac_create function.

 * This function returns a unique authentication token,

 * associated with the specific object ID and the specific MC

 * portal; this token must be used in all subsequent commands for

 * this specific object

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

 retrieve response parameters */

/**

 * dpmac_close() - Close the control session of the object

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPMAC object

 *

 * After this function is called, no further operations are

 * allowed on the object without opening a new control session.

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpmac_get_attributes - Retrieve DPMAC attributes.

 *

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPMAC object

 * @attr:	Returned object's attributes

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

 retrieve response parameters */

/**

 * dpmac_set_link_state() - Set the Ethernet link status

 * @mc_io:      Pointer to opaque I/O object

 * @cmd_flags:  Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:      Token of DPMAC object

 * @link_state: Link state configuration

 *

 * Return:      '0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpmac_get_counter() - Read a specific DPMAC counter

 * @mc_io:	Pointer to opaque I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPMAC object

 * @id:		The requested counter ID

 * @value:	Returned counter value

 *

 * Return:	The requested counter; '0' otherwise.

 SPDX-License-Identifier: GPL-2.0

/*

 * DPAA2 Ethernet Switch driver

 *

 * Copyright 2014-2016 Freescale Semiconductor Inc.

 * Copyright 2017-2021 NXP

 *

 Minimal supported DPSW version */

	/* If we leave a bridge (bridge_dev is NULL), find an unused

	 * FDB and use that.

		/* If there is no unused FDB, we must be the last port that

		 * leaves the last bridge, all the others are standalone. We

		 * can just keep the FDB that we already have.

	/* The below call to netdev_for_each_lower_dev() demands the RTNL lock

	 * being held. Assert on it so that it's easier to catch new code

	 * paths that reach this point without the RTNL lock.

	/* If part of a bridge, use the FDB of the first dpaa2 switch interface

	 * to be present in that bridge

	/* The current port is about to change its FDB to the one used by the

	 * first port that joined the bridge.

		/* The previous FDB is about to become unused, since the

		 * interface is no longer standalone.

 Get a reference to the new FDB */

 Keep track of the new upper bridge device */

	/* Add all the DPAA2 switch ports found in the same bridging domain to

	 * the egress flooding domain

 Add the CTRL interface to the egress flooding domain */

 Setup broadcast flooding domain */

 Setup unknown flooding domain */

 Interface needs to be down to change PVID */

 Delete previous PVID info and mark the new one */

	/* If hit, this VLAN rule will lead the packet into the FDB table

	 * specified in the vlan configuration below

 Nothing to do */

 Silently discard error for calling multiple times the del command */

 Silently discard error for calling multiple times the add command */

 Silently discard error for calling multiple times the del command */

	/* When we manage the MAC/PHY using phylink there is no need

	 * to manually update the netif_carrier.

	/* Interrupts are received even though no one issued an 'ifconfig up'

	 * on the switch interface. Ignore these link state update interrupts

/* Manage all NAPI instances for the control interface.

 *

 * We only have one RX queue and one Tx Conf queue for all

 * switch ports. Therefore, we only need to enable the NAPI instance once, the

 * first time one of the switch ports runs .dev_open().

 Access to the ethsw->napi_users relies on the RTNL lock */

 a new interface is using the NAPI instance */

 if there is already a user of the instance, return */

 Access to the ethsw->napi_users relies on the RTNL lock */

 If we are not the last interface using the NAPI, return */

		/* Explicitly set carrier off, otherwise

		 * netif_carrier_ok() will return true and cause 'ip link show'

		 * to report the LOWER_UP flag, even though the link

		 * notification wasn't even received.

 This API only allows programming tagged, non-PVID VIDs */

 This API only allows programming tagged, non-PVID VIDs */

 Get firmware address, if any */

 First check if firmware has any address configured by bootloader */

		/* No MAC address configured, fill in net_dev->dev_addr

		 * with a random one

		/* Override NET_ADDR_RANDOM set by eth_hw_addr_random(); for all

		 * practical purposes, this will be our "permanent" mac address,

		 * at least until the next reboot. This move will also permit

		 * register_netdevice() to properly fill up net_dev->perm_addr.

 Move on with skb release */

	/* Clear FAS to have consistent values for TX confirmation. It is

	 * located in the first 8 bytes of the buffer's hardware annotation

	 * area

	/* Store a backpointer to the skb at the beginning of the buffer

	 * (in the private data area) such that we can release it

	 * on Tx confirm

 Setup the FD fields */

 We'll be holding a back-reference to the skb until Tx confirmation */

 skb_unshare() has already freed the skb */

	/* At this stage, we do not support non-linear skbs so just try to

	 * linearize the skb and if that's not working, just drop the packet.

	/* Offload all the mirror entries found in the block on this new port

	 * joining it.

	/* If the port is already bound to this ACL table then do nothing. This

	 * can happen when this port is the first one to join a tc block

	/* Mark the previous ACL table as being unused if this was the last

	 * port that was using it.

	/* Unoffload all the mirror entries found in the block from the

	 * port leaving it.

	/* We are the last port that leaves a block (an ACL table).

	 * We'll continue to use this table.

		/* If the filter block is not already known, then this port

		 * must be the first to join it. In this case, we can just

		 * continue to use our private table

	/* Make sure that the VLAN is not already configured

	 * on the switch port

 Check if there is space for a new VLAN */

 Check if there is space for a new VLAN */

 this is a new VLAN */

 Check if address is already set on this port */

		/* If we are deleting the PVID of a port, use VLAN 4095 instead

		 * as we are sure that neither the bridge nor the 8021q module

		 * will use it

		/* Delete VLAN from switch if it is no longer configured on

		 * any port

 Found a port member in VID */

 Delete the previously manually installed VLAN 1 */

 Inherit the initial bridge port learning state */

 Setup the egress flood policy (broadcast, unknown unicast) */

 First of all, fast age any learn FDB addresses on this switch port */

	/* Clear all RX VLANs installed through vlan_vid_add() either as VLAN

	 * upper devices or otherwise from the FDB table that we are about to

	 * leave

 Restore all RX VLANs into the new FDB table that we just joined */

	/* Reset the flooding state to denote that this port can send any

	 * packet in standalone mode. With this, we are also ensuring that any

	 * later bridge join will have the flooding flag on.

	/* Setup the egress flood policy (broadcast, unknown unicast).

	 * When the port is not under a bridge, only the CTRL interface is part

	 * of the flooding domain besides the actual port

 Recreate the egress flood domain of the FDB that we just left */

 No HW learning when not under a bridge */

	/* Add the VLAN 1 as PVID when not under a bridge. We need this since

	 * the dpaa2 switch interfaces are not capable to be VLAN unaware

	/* RCU read lock not necessary because we have write-side protection

	 * (rtnl_mutex), however a non-rcu iterator does not exist.

 Called under rcu_read_lock() */

 Take a reference on the device to avoid being freed. */

 Build a linear skb based on a single-buffer frame descriptor */

 get switch ingress interface ID */

 build the SKB based on the FD received */

	/* Remove the VLAN header if the packet that we just received has a vid

	 * equal to the port PVIDs. Since the dpaa2-switch can operate only in

	 * VLAN-aware mode and no alterations are made on the packet when it's

	 * redirected/mirrored to the control interface, we are sure that there

	 * will always be a VLAN header present.

 Setup the offload_fwd_mark only if the port is under a bridge */

/* Free buffers acquired from the buffer pool or which were meant to

 * be released in the pool

/* Perform a single release command to add buffers

 * to the specified buffer pool

		/* Allocate one page for each Rx buffer. WRIOP sees

		 * the entire page except for a tailroom reserved for

		 * skb shared info

	/* In case the portal is busy, retry until successful or

	 * max retries hit.

 If release command failed, clean up and bail out. */

	/* If we managed to allocate at least some buffers,

	 * release them to hardware

				/* Out of memory; abort for now, we'll

				 * try later on

	/* Try to pull from the FQ while the portal is busy and we didn't hit

	 * the maximum number fo retries

 Consume all frames pull-dequeued into the store */

 Get the next available FD from the store */

 NAPI poll routine */

 Refill pool if appropriate */

	/* We didn't consume the entire budget, so finish napi and re-enable

	 * data availability notifications

		/* Register a new software context for the FQID.

		 * By using NULL as the first parameter, we specify that we do

		 * not care on which cpu are interrupts received for this queue

 setup FQs for Rx and Tx Conf */

 setup the buffer pool needed on the Rx path */

 Minimum supported DPSW version check */

		/* Switch starts with all ports configured to VLAN 1. Need to

		 * remove this setting to allow configuration at bridge join

/* Add an ACL to redirect frames with specific destination MAC address to

 * control interface

 Match on the destination MAC address */

 Trap to CPU */

 Get the Tx queue for this specific port */

 Create a FDB table for this particular switch port */

 Find an unused dpaa2_switch_fdb structure and use it */

	/* We need to add VLAN 1 as the PVID on this port until it is under a

	 * bridge since the DPAA2 switch is not able to handle the traffic in a

	 * VLAN unaware fashion

 Setup the egress flooding domains (broadcast, unknown unicast */

 Create an ACL table to be used by this switch port */

 Set MTU limits */

	/* Populate the private port structure so that later calls to

	 * dpaa2_switch_port_init() can use it.

	/* The DPAA2 switch's ingress path depends on the VLAN table,

	 * thus we are not able to disable VLAN filtering.

 Allocate switch core*/

	/* Add a NAPI instance for each of the Rx queues. The first port's

	 * net_device will be associated with the instances since we do not have

	 * different queues for each switch ports.

 Setup IRQs */

	/* By convention, if the mirror port is equal to the number of switch

	 * interfaces, then mirroring of any kind is disabled.

	/* Register the netdev only when the entire setup is done and the

	 * switch port interfaces are ready to receive traffic

 SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)

 Copyright 2020 NXP */

			/* For priorities not set in the pfc_en mask, we leave

			 * the congestion thresholds at zero, which effectively

			 * disables generation of PFC frames for them

 If same PFC enabled mask, nothing to do */

	/* We allow PFC configuration even if it won't have any effect until

	 * general pause frames are enabled

 Configure congestion notifications for the enabled priorities */

 SPDX-License-Identifier: GPL-2.0

/*

 * DPAA2 Ethernet Switch flower support

 *

 * Copyright 2021 NXP

 *

 Add the new ACL entry to the linked list and get its index */

	/* Move up in priority the ACL entries to make space

	 * for the new filter.

 Add the new entry to hardware */

 Remove from hardware the ACL entry */

 Remove it from the list also */

 Move down in priority the entries over the deleted one */

 Setup the mirroring port */

	/* Setup the same egress mirroring configuration on all the switch

	 * ports that share the same filter block.

		/* We cannot add a per VLAN mirroring rule if the VLAN in

		 * question is not installed on the switch port.

	/* Remove this mirroring configuration from all the ports belonging to

	 * the filter block.

 Also remove it from the list of mirror filters */

 If this was the last mirror filter, then unset the mirror port */

 Offload rules only when the destination is a DPAA2 switch port */

	/* We have a single mirror port but can configure egress mirroring on

	 * all the other switch ports. We need to allow mirroring rules only

	 * when the destination port is the same.

 Parse the key */

	/* Make sure that we don't already have a mirror rule with the same

	 * configuration.

 If this filter is a an ACL one, remove it */

 If not, then it has to be a mirror */

 Offload rules only when the destination is a DPAA2 switch port */

	/* We have a single mirror port but can configure egress mirroring on

	 * all the other switch ports. We need to allow mirroring rules only

	 * when the destination port is the same.

	/* Make sure that we don't already have a mirror rule with the same

	 * configuration. One matchall rule per block is the maximum.

 If this filter is a an ACL one, remove it */

 If not, then it has to be a mirror */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright 2013-2016 Freescale Semiconductor Inc.

 * Copyright 2016-2018 NXP

 * Copyright 2020 NXP

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright 2013-2016 Freescale Semiconductor Inc.

 * Copyright 2016-2018 NXP

/**

 * dprtc_open() - Open a control session for the specified object.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @dprtc_id:	DPRTC unique ID

 * @token:	Returned token; use in subsequent API calls

 *

 * This function can be used to open a control session for an

 * already created object; an object may have been declared in

 * the DPL or by calling the dprtc_create function.

 * This function returns a unique authentication token,

 * associated with the specific object ID and the specific MC

 * portal; this token must be used in all subsequent commands for

 * this specific object

 *

 * Return:	'0' on Success; Error code otherwise.

/**

 * dprtc_close() - Close the control session of the object

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPRTC object

 *

 * After this function is called, no further operations are

 * allowed on the object without opening a new control session.

 *

 * Return:	'0' on Success; Error code otherwise.

/**

 * dprtc_set_irq_enable() - Set overall interrupt state.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPRTC object

 * @irq_index:	The interrupt index to configure

 * @en:		Interrupt state - enable = 1, disable = 0

 *

 * Allows GPP software to control when interrupts are generated.

 * Each interrupt can have up to 32 causes.  The enable/disable control's the

 * overall interrupt state. if the interrupt is disabled no causes will cause

 * an interrupt.

 *

 * Return:	'0' on Success; Error code otherwise.

/**

 * dprtc_get_irq_enable() - Get overall interrupt state

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPRTC object

 * @irq_index:	The interrupt index to configure

 * @en:		Returned interrupt state - enable = 1, disable = 0

 *

 * Return:	'0' on Success; Error code otherwise.

/**

 * dprtc_set_irq_mask() - Set interrupt mask.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPRTC object

 * @irq_index:	The interrupt index to configure

 * @mask:	Event mask to trigger interrupt;

 *		each bit:

 *			0 = ignore event

 *			1 = consider event for asserting IRQ

 *

 * Every interrupt can have up to 32 causes and the interrupt model supports

 * masking/unmasking each cause independently

 *

 * Return:	'0' on Success; Error code otherwise.

/**

 * dprtc_get_irq_mask() - Get interrupt mask.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPRTC object

 * @irq_index:	The interrupt index to configure

 * @mask:	Returned event mask to trigger interrupt

 *

 * Every interrupt can have up to 32 causes and the interrupt model supports

 * masking/unmasking each cause independently

 *

 * Return:	'0' on Success; Error code otherwise.

/**

 * dprtc_get_irq_status() - Get the current status of any pending interrupts.

 *

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPRTC object

 * @irq_index:	The interrupt index to configure

 * @status:	Returned interrupts status - one bit per cause:

 *			0 = no interrupt pending

 *			1 = interrupt pending

 *

 * Return:	'0' on Success; Error code otherwise.

/**

 * dprtc_clear_irq_status() - Clear a pending interrupt's status

 *

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPRTC object

 * @irq_index:	The interrupt index to configure

 * @status:	Bits to clear (W1C) - one bit per cause:

 *			0 = don't change

 *			1 = clear status bit

 *

 * Return:	'0' on Success; Error code otherwise.

 SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)

 Copyright 2019 NXP */

	/* We can switch between SGMII and 1000BASE-X at runtime with

	 * pcs-lynx

 do not error out on old DTS files */

	/* The MAC does not have the capability to add RGMII delays so

	 * error out if the interface mode requests them and there is no PHY

	 * to act upon them

	/* Find the device node representing the MAC device and link the device

	 * behind the associated netdev to it.

 SPDX-License-Identifier: GPL-2.0

/*

 * DPAA2 Ethernet Switch ethtool support

 *

 * Copyright 2014-2016 Freescale Semiconductor Inc.

 * Copyright 2017-2018 NXP

 *

	/* At the moment, we have no way of interrogating the DPMAC

	 * from the DPSW side or there may not exist a DPMAC at all.

	 * Report only autoneg state, duplexity and speed.

 Interface needs to be down to change link settings */

/*

 * FCC driver for Motorola MPC82xx (PQ2).

 *

 * Copyright (c) 2003 Intracom S.A.

 *  by Pantelis Antoniou <panto@intracom.gr>

 *

 * 2005 (c) MontaVista Software, Inc.

 * Vitaly Bordug <vbordug@ru.mvista.com>

 *

 * This file is licensed under the terms of the GNU General Public License

 * version 2. This program is licensed "as is" without any warranty of any

 * kind, whether express or implied.

************************************************/

 FCC access macros */

 write, read, set bits, clear bits */

************************************************/

 nothing */

 clear promiscuous always */

 if all multi or too many multicasts; just enable all */

 read back */

 clear everything (slow & steady does it) */

 get physical address */

 point to bds */

	/* Set maximum bytes per receive buffer.

	 * It must be a multiple of 32.

	/* Allocate space in the reserved FCC area of DPRAM for the

	 * internal buffers.  No one uses this space (yet), so we

	 * can do this.  Later, we will add resource management for

	 * this area.

 fill with special symbol...  */

 no CAM */

 Set CRC preset and mask */

 CRC Error counter       */

 alignment error counter */

 discard frame counter   */

 Retry limit threshold   */

 Normal persistence      */

 set group address */

 Clear hash filter tables */

 Clear the Out-of-sequence TxBD  */

 maximum frame length register */

 minimum frame length register */

 set address */

 maximum DMA1 length */

 maximum DMA2 length */

 Clear stat counters, in case we ever enable RMON */

 Suggested by manual */

 adjust to speed (for RMII mode) */

 clear events */

 Enable interrupts we wish to service */

 Set GFMR to enable Ethernet operating mode */

 set sync/delimiters */

 adjust to duplex mode */

 Restore multicast and promiscuous settings */

 stop ethernet */

 clear events */

 clear interrupt mask */

 nothing */

/* Some transmit errors cause the transmitter to shut

 * down.  We now issue a restart transmit.

 * Also, to workaround 8260 device erratum CPM37, we must

 * disable and then re-enable the transmitterfollowing a

 * Late Collision, Underrun, or Retry Limit error.

 * In addition, tbptr may point beyond BDs beyond still marked

 * as ready due to internal pipelining, so we need to look back

 * through the BDs and adjust tbptr to point to the last BD

 * marked as ready.  This may result in some buffers being

 * retransmitted.

 get the current bd held in TBPTR  and scan back from this point */

	/* Move through the bds in reverse, look for the earliest buffer

 Go back one buffer */

 update the previous buffer */

 We should never see all bds marked as ready, check anyway */

 Now update the TBPTR and dirty flag to the current buffer */

************************************************************************/

/*

 * Combined Ethernet driver for Motorola MPC8xx and MPC82xx.

 *

 * Copyright (c) 2003 Intracom S.A.

 *  by Pantelis Antoniou <panto@intracom.gr>

 *

 * 2005 (c) MontaVista Software, Inc.

 * Vitaly Bordug <vbordug@ru.mvista.com>

 *

 * This file is licensed under the terms of the GNU General Public License

 * version 2. This program is licensed "as is" without any warranty of any

 * kind, whether express or implied.

/* Make MII read/write commands for the FEC.

 Add PHY address to register command.  */

 this must never happen */

 Add PHY address to register command.  */

 Use maximum divider if clock is unknown */

	/*

	 * Scale for a MII clock <= 2.5 MHz

	 * Note that only 6 bits (25:30) are available for MII speed.

/*

 * Combined Ethernet driver for Motorola MPC8xx and MPC82xx.

 *

 * Copyright (c) 2003 Intracom S.A.

 *  by Pantelis Antoniou <panto@intracom.gr>

 *

 * 2005 (c) MontaVista Software, Inc.

 * Vitaly Bordug <vbordug@ru.mvista.com>

 *

 * This file is licensed under the terms of the GNU General Public License

 * version 2. This program is licensed "as is" without any warranty of any

 * kind, whether express or implied.

/* FIXME: If any other users of GPIO crop up, then these will have to

 * have some sort of global synchronization to avoid races with other

 * pins on the same port.  The ideal solution would probably be to

 * bind the ports to a GPIO driver, and have this be a client of it.

 Read back to flush the write. */

 Read back to flush the write. */

 Read back to flush the write. */

	/* This should really encode the pin number as well, but all

	 * we get is an int, and the odds of multiple bitbang mdio buses

	 * is low enough that it's not worth going too crazy.

/*

 * Freescale Ethernet controllers

 *

 * Copyright (c) 2005 Intracom S.A.

 *  by Pantelis Antoniou <panto@intracom.gr>

 *

 * 2005 (c) MontaVista Software, Inc.

 * Vitaly Bordug <vbordug@ru.mvista.com>

 *

 * This file is licensed under the terms of the GNU General Public License

 * version 2. This program is licensed "as is" without any warranty of any

 * kind, whether express or implied.

************************************************/

 for a CPM1 __raw_xxx's are sufficient */

 for others play it safe */

 write */

 read */

 set bits */

 clear bits */

/*

 * Delay to wait for FEC reset command to complete (in us)

 OK */

 nothing */

 if all multi or too many multicasts; just enable all */

	/*

	 * Set station address.

	/*

	 * Reset all multicast.

	/*

	 * Set maximum receive buffer size.

 get physical address */

	/*

	 * Set receive and transmit descriptor base.

	/*

	 * Enable big endian and don't care about SDMA FC.

	/*

	 * Set MII speed.

	/*

	 * Clear any outstanding interrupt.

 MII enable */

	/*

	 * Only set MII/RMII mode - do not touch maximum frame length

	 * configured before.

	/*

	 * adjust to duplex mode

 FD enable */

 FD disable */

 Restore multicast and promiscuous settings */

	/*

	 * Enable interrupts we wish to service.

	/*

	 * And last, enable the transmit and receive processing.

 already down */

 Graceful transmit stop */

	/*

	 * Disable FEC. Let only MII interrupts.

 shut down FEC1? that's where the mii bus is */

 MII/RMII enable */

 nothing */

************************************************************************/

/*

 * Combined Ethernet driver for Motorola MPC8xx and MPC82xx.

 *

 * Copyright (c) 2003 Intracom S.A.

 *  by Pantelis Antoniou <panto@intracom.gr>

 *

 * 2005 (c) MontaVista Software, Inc.

 * Vitaly Bordug <vbordug@ru.mvista.com>

 *

 * Heavily based on original FEC driver by Dan Malek <dan@embeddededge.com>

 * and modifications by Joakim Tjernlund <joakim.tjernlund@lumentis.se>

 *

 * This file is licensed under the terms of the GNU General Public License

 * version 2. This program is licensed "as is" without any warranty of any

 * kind, whether express or implied.

************************************************/

 -1 == use FS_ENET_DEF_MSG_ENABLE as value */

 NAPI function */

 clear status bits for napi*/

		/*

		 * Check for errors.

 No heartbeat */

 Late collision */

 Retrans limit */

 Underrun */

 Carrier lost */

		/*

		 * Deferred means some collisions occurred during transmit,

		 * but we eventually sent the packet OK.

 unmap */

		/*

		 * Free the sk buffer associated with this last transmit.

		/*

		 * Update pointer to next buffer descriptor to be transmitted.

		/*

		 * Since we have freed up a buffer, the ring is no longer

		 * full.

	/*

	 * First, grab all of the stats for the incoming packet.

	 * These get messed up if we get called due to a busy condition.

		/*

		 * Since we have allocated space to hold a complete frame,

		 * the last indicator should be set.

		/*

		 * Check for errors.

 Frame too long or too short. */

 Frame alignment */

 CRC Error */

 FIFO overrun */

			/*

			 * Process the incoming frame.

 remove CRC */

 +2 to make IP header L1 cache aligned */

 align IP header */

 Make room */

		/*

		 * Update BD pointer to next entry.

 done */

/*

 * The interrupt handler.

 * This is called from the MPC core interrupt.

 NOTE: it is possible for FCCs in NAPI mode    */

 to submit a spurious interrupt while in poll  */

	/*

	 * Initialize the receive buffer descriptors.

 zero */

	/*

	 * if we failed, fillup remainder

	/*

	 * ...and the same for transmit.

	/*

	 * Reset SKB transmit buffers.

 unmap */

	/*

	 * Reset SKB receive buffers

 unmap */

*********************************************************************************/

/*

 * MPC5121 FEC requeries 4-byte alignment for TX data buffer!

 Alloc new skb */

 Make sure new skb is properly aligned */

 Copy data to new skb ... */

 ... and free an old one */

			/*

			 * We have lost packet due to memory allocation error

			 * in tx_skb_align_workaround(). Hopefully original

			 * skb is still valid, so try transmit it later.

	/*

	 * Fill in a Tx ring entry

		/*

		 * Ooops.  All transmit buffers are full.  Bail out.

		 * This should not happen, since the tx queue should be stopped.

	/*

	 * Push the data cache so the CPM does not get stale memory data.

 Trigger transmission start */

	/* note that while FEC does not have this bit

	 * it marks it as available for software use

 Save skb pointer. */

 If this was the last BD in the ring, start at the beginning again. */

/*-----------------------------------------------------------------------------

 *  generic link-change handler - should be sufficient for most cases

 adjust to duplex mode */

 to initialize the fep->cur_rx,... */

 not doing this, will cause a crash in fs_enet_napi */

 Install our interrupt handler. */

 release any irqs */

************************************************************************/

*************************************************************************************/

		/* In the case of a fixed PHY, the DT node associated

		 * to the PHY is the Ethernet MAC DT node.

	/* make clock lookup non-fatal (the driver is shared among platforms),

	 * but require enable to succeed when a clock was specified/found,

	 * keep a reference to the clock upon successful acquisition

/*

 * Ethernet on Serial Communications Controller (SCC) driver for Motorola MPC8xx and MPC82xx.

 *

 * Copyright (c) 2003 Intracom S.A.

 *  by Pantelis Antoniou <panto@intracom.gr>

 *

 * 2005 (c) MontaVista Software, Inc.

 * Vitaly Bordug <vbordug@ru.mvista.com>

 *

 * This file is licensed under the terms of the GNU General Public License

 * version 2. This program is licensed "as is" without any warranty of any

 * kind, whether express or implied.

************************************************/

 for a 8xx __raw_xxx's are sufficient */

 for others play it safe */

 write, read, set bits, clear bits */

/*

 * Delay to wait for SCC reset command to complete (in us)

 nothing */

 clear promiscuous always */

 if all multi or too many multicasts; just enable all */

/*

 * This function is called to start or restart the FEC during a link

 * change.  This only happens when switching between half and full

 * duplex.

 clear everything (slow & steady does it) */

 point to bds */

	/* Initialize function code registers for big-endian.

	/* Set maximum bytes per receive buffer.

	 * This appears to be an Ethernet frame size, not the buffer

	 * fragment size.  It must be a multiple of four.

	/* Set CRC preset and mask.

 CRC Error counter */

 alignment error counter */

 discard frame counter */

 Tx short frame pad character */

 Retry limit threshold */

 maximum frame length register */

 minimum frame length register */

 maximum DMA1 length */

 maximum DMA2 length */

	/* Clear hash tables.

	/* set address

	/* Enable interrupts we wish to service.

	/* Set GSMR_H to enable all normal operating modes.

	 * Set GSMR_L to enable Ethernet to MC68160.

	/* Set sync/delimiters.

	/* Set processing mode.  Use Ethernet CRC, catch broadcast, and

	 * start frame search 22 bit times after RENA.

 Set full duplex mode if needed */

 Restore multicast and promiscuous settings */

 nothing */

 nothing */

************************************************************************/

 SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)

 Copyright 2017-2019 NXP */

 store 2 entries per reg: addr and value */

 current HW spec does byte reversal on everything including MAC addresses */

 IPv4 */

 IPv4 */

 get RSS hash config */

 total number of entries */

 number of entries in use */

 get entry x */

 total number of entries */

 array of indexes of used entries */

 number of entries in use */

 return the size of the RX flow hash key.  PF only */

 return the size of the RX flow hash indirection table */

 return hash function */

 return hash key */

 return RSS table */

 set hash key, if PF */

 set RSS table */

 do some h/w sanity checks for BDR length */

 commit the settings */

		/* reconfigure the operation mode of h/w interrupts,

		 * traffic needs to be paused in the process

 SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)

 Copyright 2019 NXP */

 MDIO configuration and status */

 MDIO control */

 MDIO data */

 MDIO address */

 external MDIO only - driven on neg MDC edge */

 clause 22 (ie 1G) */

 set port and dev addr */

 set the register address */

 write the value */

 set port and device addr */

 set the register address */

 initiate the read */

 return all Fs if nothing was there */

 Lock for MDIO access errata on LS1028A */

 SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)

 Copyright 2019 NXP */

	/* Configure the (administrative) gate control list using the

	 * control BD descriptor.

 Set all gates open as default */

 TSD and Qbv are mutually exclusive in hardware */

 Support highest prio and second prio tc in cbs mode */

		/* Make sure the other TC that are numerically

		 * lower than this TC have been disabled.

	/* Make sure the other TC that are numerically

	 * higher than this TC have been enabled.

	/* For top prio TC, the max_interfrence_size is maxSizedFrame.

	 *

	 * For next prio TC, the max_interfrence_size is calculated as below:

	 *

	 *      max_interference_size = M0 + Ma + Ra * M0 / (R0 - Ra)

	 *

	 *	- RA: idleSlope for AVB Class A

	 *	- R0: port transmit rate

	 *	- M0: maximum sized frame for the port

	 *	- MA: maximum sized frame for AVB Class A

	/* hiCredit bits calculate by:

	 *

	 * maxSizedFrame * (idleSlope/portTxRate)

	/* hiCredit bits to hiCredit register need to calculated as:

	 *

	 * (enetClockFrequency / portTransmitRate) * 100

 Set bw register and enable this traffic class */

 Do not support TXSTART and TX CSUM offload simutaniously */

 TSD and Qbv are mutually exclusive in hardware */

 This is for limit output type for input actions */

 include the must needed keys */

/* Only enable the green color frame now

 * Will add eir and ebs color blind, couple flag etc when

 * policing action add more offloading parameters

 spinlock for the struct enetc_psfp r/w */

 example for ACL actions */

 Stream Identity Entry Set Descriptor */

 Disable operation before enable */

 Only one port supported for one entry, set itself */

 Enable the entry overwrite again incase space flushed by hardware */

	/* VIDM default to be 1.

	 * VID Match. If set (b1) then the VID must match, otherwise

	 * any VID is considered a match. VIDM setting is only used

	 * when TG is set to b01.

 Stream Filter Instance Set Descriptor */

	/* The priority value which may be matched against the

	 * frame’s priority value to determine a match for this entry.

	/* Filter Type. Identifies the contents of the MSDU/FM_INST_INDEX

	 * field as being either an MSDU value or an index into the Flow

	 * Meter Instance table.

 Stream Gate Instance Set Descriptor */

 disable */

 enable */

 Keep open before gate list start */

 Basic config */

 If basetime is less than now, calculate start time */

 Default for eir ebs disable */

	/* Default:

	 * mark red disable

	 * drop on yellow disable

	 * color mode disable

	 * couple flag disable

 Not support without gate action */

 parsing gate action */

 Flow meter and max frame size */

 prio ref the filter prio */

 Update the stream filter handle also */

 Remove the old node if exist and update with a new node */

 Disable all list nodes and free all memory */

 SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)

 Copyright 2017-2019 NXP */

	/* For XDP_TX, pages come from RX, whereas for the other contexts where

	 * we have is_dma_page_set, those come from skb_frag_dma_map. We need

	 * to match the DMA mapping length, so we need to differentiate those.

 Let H/W know BD ring has been updated */

 includes wmb() */

 first BD needs frm_len and offload flags set */

 add extension BD for VLAN and/or timestamping */

 < C-TAG */

 Configure extension BD */

			/* Update originTimestamp field of Sync packet

			 * - 48 bits seconds field

			 * - 32 bits nanseconds field

 Configure single-step register */

 last BD needs 'F' bit set */

 first BD needs frm_len and offload flags set */

	/* For the TSO header we do not set the dma address since we do not

	 * want it unmapped when we do cleanup. We still set len so that we

	 * count the bytes sent.

 Actually write the header in the BD */

 Add extension BD for VLAN */

 Get the next BD */

 Setup the VLAN fields */

 < C-TAG */

 Write the BD */

	/* Compute the IP checksum. This is necessary since tso_build_hdr()

	 * already incremented the IP ID field.

 Compute the checksum over the L4 header. */

	/* Complete the L4 checksum by appending the pseudo-header to the

	 * already computed checksum.

 Initialize the TSO handler, and prepare the first payload */

 Get the BD */

 Determine the length of this packet */

 prepare packet headers: MAC + IP + TCP */

 compute the csum over the L4 header */

 Advance the index in the BDR */

			/* Compute the checksum over this segment of data and

			 * add it to the csum already computed (over the L4

			 * header and possible other data segments).

 Go to the next BD */

 Queue one-step Sync packet if already locked */

 fragments + head */

 Mark tx timestamp type on skb->cb[0] if requires */

 Fall back to two-step timestamp if not one-step Sync packet */

 disable interrupts */

 next buf that may reuse a page */

 copy page reference */

 sync for use by the device */

		/* RX ring is already full, we need to unmap and free the

		 * page, since there's nothing useful we can do with it.

				/* Start work to release lock for next one-step

				 * timestamping packet. And send one skb in

				 * tx_skbs queue if has.

		/* Scrub the swbd here so we don't have to do that

		 * when we reuse it during xmit

 BD iteration loop end */

 re-arm interrupt source */

 For XDP_TX, we forgo dma_unmap -> dma_map */

 try reuse page */

 update RxBD */

 clear 'R" as well */

 keep track from page reuse */

 update ENETC's consumer index */

 TODO: hashing */

/* This gets called during the non-XDP NAPI poll cycle as well as on XDP_PASS,

 * so it needs to work with both DMA_FROM_DEVICE as well as DMA_BIDIRECTIONAL

 * mapped buffers.

 Reuse the current page without performing half-page buffer flipping */

 Reuse the current page by performing half-page buffer flipping */

 not last BD in frame? */

 # of BDs to update at once */

 next descriptor to process */

 for reading other rxbd fields */

/* Puts in the TX ring one XDP frame, mapped as an array of TX software buffer

 * descriptors.

 last BD needs 'F' bit set */

 Undo the DMA mapping for all fragments */

 To be used for XDP_TX */

 To be used for XDP_TX */

 not last BD in frame? */

/* Convert RX buffer descriptors to TX buffer descriptors. These will be

 * recycled back into the RX ring in enetc_clean_tx_ring.

 No need to dma_map, we already have DMA_BIDIRECTIONAL */

 We rely on caller providing an rx_ring_last > rx_ring_first */

 next descriptor to process */

 for reading other rxbd fields */

				/* The XDP_TX enqueue was successful, so we

				 * need to scrub the RX software BDs because

				 * the ownership of the buffers no longer

				 * belongs to the RX ring, and we must prevent

				 * enetc_refill_rx_ring() from reusing

				 * rx_swbd->page.

			/* xdp_return_frame does not support S/G in the sense

			 * that it leaks the fragments (__xdp_return should not

			 * call page_frag_free only for the initial buffer).

			 * Until XDP_REDIRECT gains support for S/G let's keep

			 * the code structure in place, but dead. We drop the

			 * S/G frames ourselves to avoid memory leaks which

			 * would otherwise leave the kernel OOM.

 enable interrupts */

 Probing and Init */

 find out how many of various resources we have to work with */

 h/w requires 128B alignment */

 Set up RSS table defaults */

 set SI cache attributes */

 enable SI */

	/* Enable all available TX rings in order to configure as many

	 * priorities as possible, when needed.

	 * TODO: Make # of TX rings run-time configurable

 multiple of 64 */

 clearing PI/CI registers for Tx not supported, adjust sw indexes */

 enable Tx ints by setting pkt thr to 1 */

 enable ring */

 multiple of 64 */

 enable Rx ints by setting pkt thr to 1 */

 enable ring */

 disable EN bit on ring */

 disable EN bit on ring */

 wait for busy to clear */

 enable Tx & Rx event indication */

 init to non-0 minimum, will be adjusted later */

 enable Rx ints by setting pkt thr to 1 */

 enable Tx ints by setting pkt thr to 1 */

 phy-less mode */

 disable EEE autoneg, until ENETC driver supports it */

 Reset all ring priorities to 0 */

 Check if we have enough BD rings available to accommodate all TCs */

	/* For the moment, we use only one BD ring per TC.

	 *

	 * Configure num_tc BD rings with increasing priorities.

 Reset the number of netdev queues based on the TC count */

 Each TC is associated with one netdev queue */

	/* The buffer layout is changing, so we need to drain the old

	 * RX buffers and seed new ones.

 allocate MSIX for both messaging and Rx/Tx interrupts */

 # of tx rings per int vector */

 init defaults for adaptive IC */

 default tx ring mapping policy */

 disable all MSIX for this device */

 set up for high or low dma */

 align priv to 32B */

 force 32B alignment for enetc_si */

 SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)

/* Copyright 2021 NXP

 *

 * The Integrated Endpoint Register Block (IERB) is configured by pre-boot

 * software and is supposed to be to ENETC what a NVRAM is to a 'real' PCIe

 * card. Upon FLR, values from the IERB are transferred to the ENETC PFs, and

 * are read-only in the PF memory space.

 *

 * This driver fixes up the power-on reset values for the ENETC shared FIFO,

 * such that the TX and RX allocations are sufficient for jumbo frames, and

 * that intelligent FIFO dropping is enabled before the internal data

 * structures are corrupted.

 *

 * Even though not all ports might be used on a given board, we are not

 * concerned with partitioning the FIFO, because the default values configure

 * no strict reservations, so the entire FIFO can be used by the RX of a single

 * port, or the TX of a single port.

 IERB registers */

	/* By default, it is recommended to set the Host Transfer Agent

	 * per port transmit byte credit to "1000 + max_frame_size/2".

	 * The power-on reset value (1800 bytes) is rounded up to the nearest

	 * 100 assuming a maximum frame size of 1536 bytes.

	/* Internal memory allocated for transmit buffering is guaranteed but

	 * not reserved; i.e. if the total transmit allocation is not used,

	 * then the unused portion is not left idle, it can be used for receive

	 * buffering but it will be reclaimed, if required, from receive by

	 * intelligently dropping already stored receive frames in the internal

	 * memory to ensure that the transmit allocation is respected.

	 *

	 * PaTXMBAR must be set to a value larger than

	 *     PaTXBCR + 2 * max_frame_size + 32

	 * if frame preemption is not enabled, or to

	 *     2 * PaTXBCR + 2 * p_max_frame_size (pMAC maximum frame size) +

	 *     2 * np_max_frame_size (eMAC maximum frame size) + 64

	 * if frame preemption is enabled.

	/* Initial credits, in units of 8 bytes, to the Ingress Congestion

	 * Manager for the maximum amount of bytes the port is allocated for

	 * pending traffic.

	 * It is recommended to set the initial credits to 2 times the maximum

	 * frame size (2 frames of maximum size).

	/* Free buffer depletion threshold in bytes.

	 * This sets the minimum amount of free buffer memory that should be

	 * maintained in the datapath sub system, and when the amount of free

	 * buffer memory falls below this threshold, a depletion indication is

	 * asserted, which may trigger "intelligent drop" frame releases from

	 * the ingress queues in the ICM.

	 * It is recommended to set the free buffer depletion threshold to 1024

	 * bytes, since the ICM needs some FIFO memory for its own use.

 SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)

 Copyright 2017-2019 NXP */

 disable MR int source(s) */

 re-arm MR interrupts, w1c the IDR reg */

 w1c */

 Init */

 allocate and set receive buffer */

 set multiple of 32 bytes */

 register message passing interrupt handler */

 set one IRQ entry for PSI message receive notification (SI int) */

 initialize PSI mailbox */

 enable MR interrupts */

 disable MR interrupts */

 de-register message passing interrupt handler */

 SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)

 Copyright 2017-2019 NXP */

 Messaging */

 check for message delivery error */

 send the command and wait */

 Probing/ Init */

 pick up primary MAC address from SI */

 End of table. */

 SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)

 Copyright 2017-2019 NXP */

 add exact match addr */

 add hash table entry */

 MC */

 MC */

 exact match filter */

 fallback to HT filtering */

 hash table filter, clear EM filter for UC entries */

 enable promisc mode for SI0 (PF) */

 enable multi cast promisc mode for SI0 (PF) */

 first 2 filter entries belong to PF */

 Update unicast filters */

 Update multicast filters */

 update PF entries */

 RGMII mode */

 assume SGMII mode */

 only C-tags supported for now */

 (1) try to get the MAC address from the device tree */

 (2) bootloader supplied MAC address */

 (3) choose a random one */

 The PF might take its MAC from the device tree */

 split RFS entries between functions */

 enable RFS on port */

 Add default one-time settings for SI0 (PF) */

 Configure the SIs for each available VF */

 Port level VLAN settings */

 use outer tag for VLAN filtering */

	/* On LS1028A, the MAC RX FIFO defaults to 2, which is too high

	 * and may lead to RX lock-up under traffic. Set it to 1 instead,

	 * as recommended by the hardware team.

 Set pMAC step lock */

 set up hash key */

 split up RFS entries */

 enforce VLAN promisc mode for all SIs */

 enable port */

 Messaging */

 pick up primary MAC address from SI */

 Flow control */

		/* When the port first enters congestion, send a PAUSE request

		 * with the maximum number of quanta. When the port exits

		 * congestion, it will automatically send a PAUSE frame with

		 * zero quanta.

		/* Also, set up the refresh timer to send follow-up PAUSE

		 * frames at half the quanta value, in case the congestion

		 * condition persists.

		/* Start emitting PAUSE frames when 3 large frames (or more

		 * smaller frames) have accumulated in the FIFO waiting to be

		 * DMAed to the RX ring.

/* Initialize the entire shared memory for the flow steering entries

 * of this port (PF + VFs)

 Don't register with the IERB if the PF itself is disabled */

 End of table. */

 SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)

 Copyright 2019 NXP */

 set up for high or low dma */

 Allocate 1 interrupt */

 End of table. */

 SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)

 Copyright 2017-2019 NXP */

 h/w requires 128B alignment */

 set CBDR cache attributes */

 enable ring */

 disable ring */

 copy command to the ring */

 let H/W know BD ring has been updated */

 cannot sleep, rtnl_lock() */

 CBD may writeback data, feedback up level */

 fill up the "set" descriptor */

 enable entry */

 Set entry in RFS table */

 fill up the "set" descriptor */

 SI */

 HW only takes in a full 64 entry table */

 fill up the descriptor */

 Get RSS table */

 Set RSS table */

 SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)

 Copyright 2019 NXP */

 End of table. */

 SPDX-License-Identifier: GPL-2.0

/* sunbmac.c: Driver for Sparc BigMAC 100baseT ethernet adapters.

 *

 * Copyright (C) 1997, 1998, 1999, 2003, 2008 David S. Miller (davem@davemloft.net)

 Toe jam */

	/* 64byte bursts do not work at the moment, do

	 * not even try to enable them.  -DaveM

 All of memsize is given to bigmac. */

 Half to the transmitter, half to the receiver. */

	/* The fifo threshold bit is read-only and does

	 * not clear.  -DaveM

 Reset the transmitter and receiver. */

 Free any skippy bufs left around in the rings. */

 Now get new skbufs for the receive ring. */

 Because we reserve afterwards. */

	/* Only the bit for the present transceiver (internal or

	 * external) will stick, set them both and see what stays.

 Reset the PHY. */

 Now we try 10baseT. */

 We've tried them all. */

 Can't happens.... */

 foo on you */

 1.2 sec. */

/* Well, really we just force the chip into 100baseT then

 * 10baseT, each time checking for a link status.

 Grab new software copies of PHY registers. */

 Reset the PHY. */

 First we try 100baseT. */

 Latch current counters into statistics. */

 Reset QEC. */

 Init QEC. */

 Alloc and reset the tx/rx descriptor chains. */

 Initialize the PHY. */

 Stop transmitter and receiver. */

 Set hardware ethernet address. */

 Clear the hash table until mc upload occurs. */

 Enable Big Mac hash table filter. */

 Ok, configure the Big Mac transmitter. */

 The HME docs recommend to use the 10LSB of our MAC here. */

 Enable the output drivers no matter what. */

 Tell the QEC where the ring descriptors are. */

 Setup the FIFO pointers into QEC local memory. */

 Tell bigmac what interrupts we don't want to hear about. */

 Enable the various other irq's. */

 Set jam size to a reasonable default. */

 Clear collision counter. */

 Enable transmitter and receiver. */

 Ok, start detecting link speed/duplex. */

 Success. */

 Error interrupts get sent here. */

 BigMAC transmit complete service routines. */

 BigMAC receive complete service routines. */

 FCS not included */

 Check for errors. */

 Return it to the BigMAC. */

 Now refill the entry, if we can. */

 Trim the original skb for the netif. */

 Reuse original ring buffer. */

 No checksums done by the BigMAC ;-( */

 Latch status registers now. */

 Put a packet on the wire. */

 Avoid a race... */

 Get it going. */

	/* Disable the receiver.  The bit self-clears when

	 * the operation is complete.

 Re-enable the receiver. */

 Ethtool support... */

 Get a new device struct for this interface. */

 Setup softc, with backpointers to QEC and BigMAC SBUS device structs. */

 Map in QEC global control registers. */

 Make sure QEC is in BigMAC mode. */

 Reset the QEC. */

 Get supported SBUS burst sizes. */

 Perform QEC initialization. */

 Map in the BigMAC channel registers. */

 Map in the BigMAC control registers. */

	/* Map in the BigMAC transceiver registers, this is how you poke at

	 * the BigMAC's PHY.

 Stop the BigMAC. */

 Allocate transmit/receive descriptor DVMA block. */

 Get the board revision of this BigMAC. */

 Init auto-negotiation timer state. */

 Backlink to generic net device struct. */

 Set links to our BigMAC open and close routines. */

 Finish net device registration. */

 Something went wrong, undo whatever we did so far. */

 Free register mappings if any. */

 This also frees the co-located private data */

/* QEC can be the parent of either QuadEthernet or a BigMAC.  We want

 * the latter.

 SPDX-License-Identifier: GPL-2.0

/* sunhme.c: Sparc HME/BigMac 10/100baseT half/full duplex auto switching,

 *           auto carrier detecting ethernet driver.  Also known as the

 *           "Happy Meal Ethernet" found on SunSwift SBUS cards.

 *

 * Copyright (C) 1996, 1998, 1999, 2002, 2003,

 *		2006, 2008 David S. Miller (davem@davemloft.net)

 *

 * Changes :

 * 2000/11/11 Willy Tarreau <willy AT meta-x.org>

 *   - port to non-sparc architectures. Tested only on x86 and

 *     only currently works with QFE PCI cards.

 *   - ability to specify the MAC address at module load time by passing this

 *     argument : macaddr=0x00,0x10,0x20,0x30,0x40,0x50

 accept MAC address of the form macaddr=0x08,0x00,0x20,0x30,0x40,0x50 */

 #define AUTO_SWITCH_DEBUG */

 For lance-mode only */

 For all modes */

 For all modes */

 Toe jam */

/* NOTE: In the descriptor writes one _must_ write the address

 *	 member _first_.  The card must not be allowed to see

 *	 the updated descriptor flags until the address is

 *	 correct.  I've added a write memory barrier between

 *	 the two stores so that I can sleep well at night... -DaveM

 SBUS only compilation */

 PCI only compilation */

 Oh yes, the MIF BitBang is mighty fun to program.  BitBucket is more like it. */

 Impossible MIF read value */

 Enable the MIF BitBang outputs. */

 Force BitBang into the idle state. */

 Give it the read sequence. */

 Give it the PHY address. */

 Tell it what register we want to read. */

 Close down the MIF BitBang outputs. */

 Now read in the value. */

 Enable the MIF BitBang outputs. */

 Force BitBang into the idle state. */

 Give it write sequence. */

 Give it the PHY address. */

 Tell it what register we will be writing. */

 Tell it to become ready for the bits. */

 Close down the MIF BitBang outputs. */

 Welcome to Sun Microsystems, can I take your order please? */

 Would you like fries with that? */

 Anything else? */

 Fifty-two cents is your change, have a nice day. */

/* Auto negotiation.  The scheme is very simple.  We have a timer routine

 * that keeps watching the auto negotiation process as it progresses.

 * The DP83840 is first told to start doing it's thing, we set up the time

 * and place the timer state machine in it's initial state.

 *

 * Here the timer peeks at the DP83840 status registers at each click to see

 * if the auto negotiation has completed, we assume here that the DP83840 PHY

 * will time out at some point and just tell us what (didn't) happen.  For

 * complete coverage we only allow so many of the ticks at this level to run,

 * when this has expired we print a warning message and try another strategy.

 * This "other" strategy is to force the interface into various speed/duplex

 * configurations and we stop when we see a link-up condition before the

 * maximum number of "peek" ticks have occurred.

 *

 * Once a valid link status has been detected we configure the BigMAC and

 * the rest of the Happy Meal to speak the most efficient protocol we could

 * get a clean link for.  The priority for link configurations, highest first

 * is:

 *                 100 Base-T Full Duplex

 *                 100 Base-T Half Duplex

 *                 10 Base-T Full Duplex

 *                 10 Base-T Half Duplex

 *

 * We start a new timer now, after a successful auto negotiation status has

 * been detected.  This timer just waits for the link-up bit to get set in

 * the BMCR of the DP83840.  When this occurs we print a kernel log message

 * describing the link type in use and the fact that it is up.

 *

 * If a fatal error of some sort is signalled and detected in the interrupt

 * service routine, and the chip is reset, or the link is ifconfig'd down

 * and then back up, this entire process repeats itself all over again.

	/* Downgrade from full to half duplex.  Only possible

	 * via ethtool.

 Downgrade from 100 to 10. */

 We've tried everything. */

	/* All we care about is making sure the bigmac tx_cfg has a

	 * proper duplex setting.

 Forcing a link mode. */

	/* Before changing other bits in the tx_cfg register, and in

	 * general any of other the TX config registers too, you

	 * must:

	 * 1) Clear Enable

	 * 2) Poll with reads until that bit reads back as zero

	 * 3) Make TX configuration changes

	 * 4) Set Enable once more

		/* Only allow for 5 ticks, thats 10 seconds and much too

		 * long to wait for arbitration to complete.

 Enter force mode. */

				/* OK, seems we need do disable the transceiver for the first

				 * tick to make sure we get an accurate link state at the

				 * second tick.

 Anything interesting happen? */

 Just what we've been waiting for... */

					/* Ooops, something bad happened, go to force

					 * mode.

					 *

					 * XXX Broken hubs which don't support 802.3u

					 * XXX auto-negotiation make this happen as well.

 Success, at least so far, advance our state engine. */

		/* Auto negotiation was successful and we are awaiting a

		 * link up status.  I have decided to let this timer run

		 * forever until some sort of error is signalled, reporting

		 * a message to the user at 10 second intervals.

			/* Wheee, it's up, display the link mode in use and put

			 * the timer to sleep.

		/* Making the timeout here too long can make it take

		 * annoyingly long to attempt all of the link mode

		 * permutations, but then again this is essentially

		 * error recovery code for the most part.

				/* Re-enable transceiver, we'll re-enable the transceiver next

				 * tick, then check link state on the following tick.

 Force mode selection success. */

 XXX error? then what? */

 6 seconds or so... */

					/* Aieee, tried them all, reset the

					 * chip and try all over again.

 Let the user know... */

 ho hum... */

 Can't happens.... */

 foo on you */

 1.2 sec. */

 hp->happy_lock must be held */

 Would you like to try our SMCC Delux? */

 Lettuce, tomato, buggy hardware (no extra charge)? */

 Take care. */

 hp->happy_lock must be held */

 We have a special on GNU/Viking hardware bugs today. */

 Will that be all? */

 Don't forget your vik_1137125_wa.  Have a nice day. */

 hp->happy_lock must be held */

 We're consolidating our STB products, it's your lucky day. */

 Come back next week when we are "Sun Microelectronics". */

 Remember: "Different name, same old buggy as shit hardware." */

 hp->happy_lock must be held */

 hp->happy_lock must be held */

 If polling disabled or not polling already, nothing to do. */

 Shut up the MIF. */

 Turn off polling. */

 We are no longer polling. */

 Let the bits set. */

/* Only Sun can take such nice parts and fuck up the programming interface

 * like this.  Good job guys...

 It should reset quickly        */

 Dis-isolation can take longer. */

 hp->happy_lock must be held */

 Get fresh copies of the PHY registers. */

/* Figure out whether we have an internal or external transceiver.

 *

 * hp->happy_lock must be held

 If we are polling, we must stop to get the transceiver type. */

 Else we can just work off of the MDIO bits. */

 Grrr... */

/* The receive ring buffers are a bit tricky to get right.  Here goes...

 *

 * The buffers we dma into must be 64 byte aligned.  So we use a special

 * alloc_skb() routine for the happy meal to allocate 64 bytes more than

 * we really need.

 *

 * We use skb_reserve() to align the data block we get in the skb.  We

 * also program the etxregs->cfg register to use an offset of 2.  This

 * imperical constant plus the ethernet header size will always leave

 * us with a nicely aligned ip header once we pass things up to the

 * protocol layers.

 *

 * The numbers work out to:

 *

 *         Max ethernet frame size         1518

 *         Ethernet header size              14

 *         Happy Meal base offset             2

 *

 * Say a skb data area is at 0xf001b010, and its size alloced is

 * (ETH_FRAME_LEN + 64 + 2) = (1514 + 64 + 2) = 1580 bytes.

 *

 * First our alloc_skb() routine aligns the data base to a 64 byte

 * boundary.  We now have 0xf001b040 as our skb data address.  We

 * plug this into the receive descriptor address.

 *

 * Next, we skb_reserve() 2 bytes to account for the Happy Meal offset.

 * So now the data we will end up looking at starts at 0xf001b042.  When

 * the packet arrives, we will check out the size received and subtract

 * this from the skb->length.  Then we just pass the packet up to the

 * protocols as is, and allocate a new skb to replace this slot we have

 * just received from.

 *

 * The ethernet layer will strip the ether header from the front of the

 * skb we just sent to it, this leaves us with the ip header sitting

 * nicely aligned at 0xf001b050.  Also, for tcp and udp packets the

 * Happy Meal has even checksummed the tcp/udp data for us.  The 16

 * bit checksum is obtained from the low bits of the receive descriptor

 * flags, thus:

 *

 * 	skb->csum = rxd->rx_flags & 0xffff;

 * 	skb->ip_summed = CHECKSUM_COMPLETE;

 *

 * before sending off the skb to the protocols, and we are good as gold.

 hp->happy_lock must be held */

 Free any skippy bufs left around in the rings. */

 Now get new skippy bufs for the receive ring. */

 Because we reserve afterwards. */

 hp->happy_lock must be held */

 Read all of the registers we are interested in now. */

 XXX Check BMSR_ANEGCAPABLE, should not be necessary though. */

 Advertise everything we can support. */

		/* XXX Currently no Happy Meal cards I know off support 100BaseT4,

		 * XXX and this is because the DP83840 does not support it, changes

		 * XXX would need to be made to the tx/rx logic in the driver as well

		 * XXX so I completely skip checking for it in the BMSR for now.

 Enable Auto-Negotiation, this is usually on already... */

 Restart it to make sure it is going. */

 BMCR_ANRESTART self clears when the process has begun. */

 More than enough. */

 got it. */

		/* Force the link up, trying first a particular mode.

		 * Either we are here at the request of ethtool or

		 * because the Happy Meal would not start to autoneg.

		/* Disable auto-negotiation in BMCR, enable the duplex and

		 * speed setting, init the timer state machine, and fire it off.

			/* OK, seems we need do disable the transceiver for the first

			 * tick to make sure we get an accurate link state at the

			 * second tick.

 1.2 sec. */

 hp->happy_lock must be held */

 If auto-negotiation timer is running, kill it. */

 Stop polling. */

 Stop transmitter and receiver. */

 Alloc and reset the tx/rx descriptor chains. */

 Shut up the MIF. */

 See if we can enable the MIF frame on this card to speak to the DP83840. */

 Check the state of the transceiver. */

 Put the Big Mac into a sane state. */

 Cannot operate if we don't know the transceiver type! */

 Using the MII buffers. */

 Not using the MII, disable it. */

 Reset the Happy Meal Big Mac transceiver and the receiver. */

 Set jam size and inter-packet gaps to reasonable defaults. */

 Load up the MAC address and random seed. */

 The docs recommend to use the 10LSB of our MAC here. */

 Set the RX and TX ring ptrs. */

	/* Parity issues in the ERX unit of some HME revisions can cause some

	 * registers to not be written unless their parity is even.  Detect such

	 * lost writes and simply rewrite with a low bit set (which will be ignored

	 * since the rxring needs to be 2K aligned).

 Set the supported burst sizes. */

 It is always PCI and can handle 64byte bursts. */

		/* I have no idea if I should set the extended

		 * transfer mode bit for Cheerio, so for now I

		 * do not.  -DaveM

 CONFIG_SPARC */

 Turn off interrupts we do not want to hear. */

 Set the transmit ring buffer size. */

 Enable transmitter DVMA. */

	/* This chip really rots, for the receiver sometimes when you

	 * write to its control registers not all the bits get there

	 * properly.  I cannot think of a sane way to provide complete

	 * coverage for this hardware bug yet.

 XXX Should return failure here... */

 Enable Big Mac hash table filter. */

 Let the bits settle in the chip. */

 Ok, configure the Big Mac transmitter. */

	/* Don't turn on the "don't give up" bit for now.  It could cause hme

	 * to deadlock with the PHY if a Jabber occurs.

| BIGMAC_TXCFG_DGIVEUP*/);

 Give up after 16 TX attempts. */

 Enable the output drivers no matter what. */

 If card can do lance mode, enable it. */

 Disable the MII buffers if using external transceiver. */

 Start things up. */

 Set larger TX/RX size to allow for 802.1q */

 Get the autonegotiation started, and the watch timer ticking. */

 Success. */

 hp->happy_lock must be held */

 Latch PHY registers as of now. */

 Advertise everything we can support. */

 Update the PHY advertisement register. */

/* Once status is latched (by happy_meal_interrupt) it is cleared by

 * the hardware, so we cannot re-read it and get a correct value.

 *

 * hp->happy_lock must be held

 Only print messages for non-counter related interrupts. */

		/* Receive FIFO overflow is harmless and the hardware will take

 BigMAC SQE link test failed. */

 Transmit FIFO underrun, again DMA error likely. */

		/* Driver error, tried to transmit something larger

		 * than ethernet max mtu.

		/* This is harmless, it just means the system is

		 * quite loaded and the incoming packet rate was

		 * faster than the interrupt handler could keep up

		 * with.

 All sorts of DMA receive errors. */

		/* Driver bug, didn't set EOP bit in tx descriptor given

		 * to the happy meal.

 MIF signalled an interrupt, were we polling it? */

 All sorts of transmit DMA errors. */

		/* Bus or parity error when cpu accessed happy meal registers

		 * or it's internal FIFO's.  Should never see this.

 hp->happy_lock must be held */

 Use the fastest transmission protocol possible. */

 Finally stop polling and shut up the MIF. */

 hp->happy_lock must be held */

/* Originally I used to handle the allocation failure by just giving back just

 * that one ring buffer to the happy meal.  Problem is that usually when that

 * condition is triggered, the happy meal expects you to do something reasonable

 * with all of the packets it has DMA'd in.  So now I just drop the entire

 * ring when we cannot get a new skb and give them all back to the happy meal,

 * maybe things will be "happier" now.

 *

 * hp->happy_lock must be held

 Check for errors. */

 Return it to the Happy meal. */

 Now refill the entry, if we can. */

 Trim the original skb for the netif. */

 Reuse original ring buffer. */

 This card is _fucking_ hot... */

 un- */ happy_status))

	/* On SBUS Quattro QFE cards, all hme interrupts are concentrated

	 * into a single source which we register handling at probe time.

 If auto-negotiation timer is running, kill it. */

	/* On Quattro QFE cards, all hme interrupts are concentrated

	 * into a single source which we register handling at probe

	 * time and never unregister.

		/* We must give this initial chunk to the device last.

		 * Otherwise we could race with the device.

 Get it going. */

 Ethtool support... */

 XXX hardcoded stuff for now */

 XXX no MII support */

 XXX fixed PHYAD */

 Record PHY settings. */

 Verify the settings we care about. */

 Ok, do it to it. */

/* Given a happy meal sbus device, find it's quattro parent.

 * If none exist, allocate and return a new one.

 *

 * Return NULL on failure.

/* After all quattro cards have been probed, we call these functions

 * to register the IRQ handlers for the cards that have been

 * successfully probed and skip the cards that failed to initialize

 CONFIG_SBUS */

 No range tricks necessary on PCI. */

 CONFIG_PCI */

 We can match PCI devices too, do not accept those here. */

	/* If user did not specify a MAC address specifically, use

	 * the Quattro local-mac-address property...

 a mac address was given */

 Now enable the feature flags we can. */

 Get the supported DVMA burst sizes from our Happy SBUS. */

 Force check of the link first time we are brought up. */

 Force timer state to 'asleep' with count of zero. */

 Happy Meal can do it all... */

 Hook up SBUS register/descriptor accessors. */

	/* Grrr, Happy Meal comes up by default not advertising

	 * full duplex 100baseT capabilities, fix this.

 Fetch MAC address from vital product data of PCI ROM. */

 Sun MAC prefix then 3 random bytes. */

 !(CONFIG_SPARC) */

 Now make sure pci_dev cookie is there. */

 a mac address was given */

 Layout registers. */

 works with this on non-sparc hosts */

 Now enable the feature flags we can. */

 And of course, indicate this is PCI. */

 Assume PCI happy meals can handle all burst sizes. */

 Happy Meal can do it all... */

 Hook up PCI register/descriptor accessors. */

	/* Grrr, Happy Meal comes up by default not advertising

	 * full duplex 100baseT capabilities, fix this.

 Terminating entry */

 XXX qfe parent interrupt... */

 SPDX-License-Identifier: GPL-2.0+

/* cassini.c: Sun Microsystems Cassini(+) ethernet driver.

 *

 * Copyright (C) 2004 Sun Microsystems Inc.

 * Copyright (C) 2003 Adrian Sun (asun@darksunrising.com)

 *

 * This driver uses the sungem driver (c) David Miller

 * (davem@redhat.com) as its basis.

 *

 * The cassini chip has a number of features that distinguish it from

 * the gem chip:

 *  4 transmit descriptor rings that are used for either QoS (VLAN) or

 *      load balancing (non-VLAN mode)

 *  batching of multiple packets

 *  multiple CPU dispatching

 *  page-based RX descriptor engine with separate completion rings

 *  Gigabit support (GMII and PCS interface)

 *  MIF link up/down detection works

 *

 * RX is handled by page sized buffers that are attached as fragments to

 * the skb. here's what's done:

 *  -- driver allocates pages at a time and keeps reference counts

 *     on them.

 *  -- the upper protocol layers assume that the header is in the skb

 *     itself. as a result, cassini will copy a small amount (64 bytes)

 *     to make them happy.

 *  -- driver appends the rest of the data pages as frags to skbuffs

 *     and increments the reference count

 *  -- on page reclamation, the driver swaps the page with a spare page.

 *     if that page is still in use, it frees its reference to that page,

 *     and allocates a new page for use. otherwise, it just recycles the

 *     the page.

 *

 * NOTE: cassini can parse the header. however, it's not worth it

 *       as long as the network stack requires a header copy.

 *

 * TX has 4 queues. currently these queues are used in a round-robin

 * fashion for load balancing. They can also be used for QoS. for that

 * to work, however, QoS information needs to be exposed down to the driver

 * level so that subqueues get targeted to particular transmit rings.

 * alternatively, the queues can be configured via use of the all-purpose

 * ioctl.

 *

 * RX DATA: the rx completion ring has all the info, but the rx desc

 * ring has all of the data. RX can conceivably come in under multiple

 * interrupts, but the INT# assignment needs to be set up properly by

 * the BIOS and conveyed to the driver. PCI BIOSes don't know how to do

 * that. also, the two descriptor rings are designed to distinguish between

 * encrypted and non-encrypted packets, but we use them for buffering

 * instead.

 *

 * by default, the selective clear mask is set up to process rx packets.

 select which firmware to use */

 select which firmware to use as default */

 alternate firmware */

 use completion writeback registers */

 standard CSMA/CD */

 hw interrupt mitigation */

 don't test for entropy device */

/* NOTE: these aren't useable unless PCI interrupts can be assigned.

 * also, we need to make cp->lock finer-grained.

 debug vpd information if defined */

 rx processing options */

 specify to allocate large rx pages */

 if 1, don't batch flows */

 if 0, use frags */

 copy a little to make upper layers happy */

 define to calculate RX buffer stats */

/* length of time before we decide the hardware is borked,

 * and dev->tx_timeout() should be called to fix the problem

/* timeout values for state changing. these specify the number

 * of 10us delays to be used before giving up.

/* specify a minimum frame size to deal with some fifo issues

 * max mtu == 2 * page size - ethernet header - 64 - swivel =

 *            2 * page_size - 0x50

/*

 * Eliminate these and use separate atomic counters for each, to

 * avoid a race condition.

 -1 == use CAS_DEF_MSG_ENABLE as value */

/*

 * Work around for a PCS bug in which the link goes down due to the chip

 * being confused and never showing a link status of "up."

/*

 * Value in seconds, for user input.

/*

 * value in 'ticks' (units used by jiffies). Set when we init the

 * module because 'HZ' in actually a function call on some flavors of

 * Linux.  This will default to DEFAULT_LINKDOWN_TIMEOUT * HZ.

 0 : autoneg */

 1 : 10bt half duplex */

 2 : 100bt half duplex */

 3 : 10bt full duplex */

 4 : 100bt full duplex */

 5 : 1000bt full duplex */

/* WTZ: QA was finding deadlock problems with the previous

 * versions after long test runs with multiple cards per machine.

 * See if replacing cas_lock_all with safer versions helps. The

 * symptoms QA is reporting match those we'd expect if interrupts

 * aren't being properly restored, and we fixed a previous deadlock

 * with similar symptoms by using save/restore versions in other

 * places.

 Make sure we won't get any more interrupts */

 disable completion interrupts and selectively mask */

 all but TX_DONE */

 if we read back 0x0, we don't have an entropy device */

/* access to the phy. the following assumes that we've initialized the MIF to

 * be in frame rather than bit-bang mode

 poll for completion */

 -1 */

 poll for completion */

 cp->lock held. note: the last put_page will free the buffer */

/* local page allocation routines for the receive buffers. jumbo pages

 * require at least 8K contiguous and 8K aligned buffers.

 initialize spare pool of rx buffers, but allocate during the open */

 used on close. free all the spare buffers. */

 free spare buffers */

	/*

	 * Looks like Adrian had protected this with a different

	 * lock than used everywhere else to manipulate this list.

 replenish spares if needed */

	/* check inuse list. if we don't need any more free buffers,

	 * just free it

 make a local copy of the list */

		/*

		 * With the lockless pagecache, cassini buffering scheme gets

		 * slightly less accurate: we might find that a page has an

		 * elevated reference count here, due to a speculative ref,

		 * and skip it as in-use. Ideally we would be able to reclaim

		 * it. However this would be such a rare case, it doesn't

		 * matter too much as we should pick it up the next time round.

		 *

		 * Importantly, if we find that the page has a refcount of 1

		 * here (our refcount), then we know it is definitely not inuse

		 * so we can reuse it.

 put any inuse buffers back on the list */

 we still need spares, so try to allocate some */

 pull a page from the list. */

 try to do a quick recovery */

 trigger the timer to do the recovery */

 poll and interrupt on link status change. */

 Must be invoked under cp->lock */

 Setup link parameters */

	/*

	 * WTZ: If the old state was link_up, we turn off the carrier

	 * to replicate everything we do elsewhere on a link-down

	 * event when we were already in a link-up state..

		/*

		 * WTZ: This branch will simply schedule a full reset after

		 * we explicitly changed link modes in an ioctl. See if this

		 * fixes the link-problems we were having for forced mode.

 Must be invoked under cp->lock. */

 expanded memory access mode */

 pointer configuration for new firmware */

 download new firmware */

 enable firmware */

 phy initialization */

 if we're in MII/GMII mode, set up phy */

 take out of isolate mode */

 workaround link up/down issue with lucent */

 workarounds for broadcom phy */

 link workaround */

			/* load firmware to address 10Mbps auto-negotiation

			 * issue. NOTE: this will need to be changed if the

			 * default firmware gets fixed.

 advertise capabilities */

			/* make sure that we don't advertise half

			 * duplex to avoid a chip issue

 reset pcs for serdes */

 enable serdes pins on saturn */

 Reset PCS unit. */

		/* Make sure PCS is disabled while changing advertisement

		 * configuration.

 Advertise all capabilities except half-duplex. */

 enable PCS */

 pcs workaround: enable sync detect */

	/* The link status bit latches on zero, so you must

	 * read it twice in such a case to see a transition

	 * to the link being up.

	/* The remote-fault indication is only valid

	 * when autoneg has completed.

	/* work around link detection issue by querying the PCS state

	 * machine directly.

			/*

			 * force a reset, as a workaround for the

			 * link-failure problem. May want to move this to a

			 * point a bit earlier in the sequence. If we had

			 * generated a reset a short time ago, we'll wait for

			 * the link timer to check the status until a

			 * timer expires (link_transistion_jiffies_valid is

			 * true when the timer is running.)  Instead of using

			 * a system timer, we just do a check whenever the

			 * link timer is running - this clears the flag after

			 * a suitable delay.

		/* Cassini only: if you force a mode, there can be

		 * sync problems on link down. to fix that, the following

		 * things need to be checked:

		 * 1) read serialink state register

		 * 2) read pcs status register to verify link down.

		 * 3) if link down and serial link == 0x03, then you need

		 *    to global reset the chip.

 should check to see if we're in a forced mode */

			/* force a reset, as a workaround for the

			 * link-failure problem.  May want to move

			 * this to a point a bit earlier in the

			 * sequence.

	/* Defer timer expiration is quite normal,

	 * don't even log the event.

	/* The rest are all cases of one of the 16-bit TX

	 * counters expiring.

	/* We do not keep track of MAC_TX_COLL_FIRST and

	 * MAC_TX_PEAK_ATTEMPTS events.

 rx free descriptors */

 do desc 2 */

		/* rx desc 2 is for IPSEC packets. however,

		 * we don't it that for that purpose.

 rx completion registers */

 rx comp 2-4 */

	/* read selective clear regs to prevent spurious interrupts

	 * on reset because complete == kick.

	 * selective clear set up to prevent interrupts on resets

 2 is different from 3 and 4 */

 set up pause thresholds */

 zero out dma reassembly buffers */

 make sure address register is 0 for normal operation */

 interrupt mitigation */

	/* interrupt generation as a function of low water marks for

	 * free desc and completion entries. these are used to trigger

	 * housekeeping for rx descs. we don't use the free interrupt

	 * as it's not very useful

 val = CAS_BASE(RX_AE_THRESH_FREE, RX_AE_FREEN_VAL(0)); */

	/* Random early detect registers. useful for congestion avoidance.

	 * this should be tunable.

 receive page sizes. default == 2K (0x800) */

 round mtu + offset. constrain to page size. */

 enable the header parser if desired */

/* NOTE: we use the ENC RX DESC ring for spares. the rx_page[0,1]

 * flipping is protected by the fact that the chip will not

 * hand back the same page index while it's being processed.

 this needs to be changed if we actually use the ENC RX DESC ring */

 swap if buffer is in use */

 only clean ring 0 as ring 1 is used for spare buffers */

 release all rx flows */

 initialize descriptors */

 take ownership of rx comp descriptors */

/* When we get a RX fifo overflow, the RX unit is probably hung

 * so we do the following.

 *

 * If any part of the reset goes wrong, we return 1 and that causes the

 * whole chip to be reset.

 First, reset MAC RX. */

 Second, disable RX DMA. */

 Execute RX reset command. */

 reset driver rx state */

 Now, reprogram the rest of RX unit. */

 re-enable */

 these are all rollovers */

	/* We do not track MAC_RX_FRAME_COUNT and MAC_RX_VIOL_ERR

	 * events.

	/* This interrupt is just for pause frame and pause

	 * tracking.  It is useful for diagnostics and debug

	 * but probably by default we will mask these events.

 Must be invoked under cp->lock. */

		/* Try forced modes. we try things in the following order:

		 * 1000 full -> 100 full/half -> 10 half

 Downgrade from 1000 to 100 to 10 Mbps if necessary. */

 gigabit */

 fd failed */

 100Mbps failed */

 must be invoked with cp->lock held */

		/* Ok, here we got a link. If we had it due to a forced

		 * fallback, and we were configured for autoneg, we

		 * retry a short autoneg pass. If you know your hub is

		 * broken, use ethtool ;)

	/* link not up. if the link was previously up, we restart the

	 * whole process

 check for a link change */

 cassini+ has this reserved */

		/* Interrogate PCI config space for the

		 * true cause.

 For all PCI errors, we should reset the chip. */

/* All non-normal interrupt conditions get serviced here.

 * Returns non-zero if we should just exit the interrupt

 * handler right now (ie. if we reset the card which invalidates

 * all of the other original irq status bits).

 corrupt RX tag framing */

 length mismatch. */

/* NOTE: CAS_TABORT returns 1 or 2 so that it can be used when

 *       determining whether to do a netif_stop/wakeup

 this should never occur */

 however, we might get only a partial skb release. */

 tiny buffer may follow */

	/* this is wrong for multiple tx rings. the net device needs

	 * multiple queues for this to do the right thing.  we wait

	 * for 2*packets to be available when using tiny buffers

 process all the rings */

 use the completion writeback registers */

 always copy header pages */

 attach FCS */

 normal or jumbo packets. we use frags */

 attach FCS */

 make sure we always copy a header */

 not split */

 any more data? */

 copying packet */

 attach FCS */

 not split */

 any more data? */

 checksum includes FCS. strip it out. */

/* we can handle up to 64 rx flows at a time. we do the same thing

 * as nonreassm except that we batch up the buffers.

 * NOTE: we currently just treat each flow as a bunch of packets that

 *       we pass up. a better way would be to coalesce the packets

 *       into a jumbo packet. to do that, we need to do the following:

 *       1) the first packet will have a clean split between header and

 *          data. save both.

 *       2) each time the next flow packet comes in, extend the

 *          data length and merge the checksums.

 *       3) on flow release, fix up the header.

 *       4) make sure the higher layer doesn't care.

 * because packets get coalesced, we shouldn't run into fragment count

 * issues.

	/* this is protected at a higher layer, so no need to

	 * do any additional locking here. stick the buffer

	 * at the end.

/* put rx descriptor back on ring. if a buffer is in use by a higher

 * layer, this will need to put in a replacement.

 only when things are bad */

 make a new buffer if it's still in use */

				/* let the timer know that we need to

				 * do this again

/* process a completion ring. packets are set up in three basic ways:

 * small packets: should be copied header + data in single buffer.

 * large packets: header and data in a single buffer.

 * split packets: header in a separate buffer from data.

 *                data may be in multiple pages. data may be > 256

 *                bytes but in a single page.

 *

 * NOTE: RX page posting is done in this routine as well. while there's

 *       the capability of using multiple RX completion rings, it isn't

 *       really worthwhile due to the fact that the page posting will

 *       force serialization on the single descriptor ring.

 don't touch if still owned by hw */

 hw hasn't cleared the zero bit yet */

 get info on the packet */

 We'll just return it to Cassini. */

		/* see if it's a flow re-assembly or not. the driver

		 * itself handles release back up.

 non-reassm: these always get released */

 should it be released? */

 skip to the next entry */

 put completion entries back on the ring */

 zero and re-mark descriptors */

/* cassini can use all four PCI interrupts for the completion ring.

 * rings 3 and 4 are identical

 check for shared irq */

 handle rx separately */

 everything but rx packets */

		/* Frame arrived, no free RX buffers available.

 ring 2 handles a few more events than 3 and 4 */

 check for shared interrupt */

 handle rx separately */

 housekeeping interrupts */

		/* Frame arrived, no free RX buffers available.

		 * NOTE: we can get this on a link transition.

	/* NAPI rx packets. we spread the credits across all of the

	 * rxc rings

	 *

	 * to make sure we're fair with the work we loop through each

	 * ring N_RX_COMP_RING times with a request of

	 * budget / N_RX_COMP_RINGS

 final rx completion */

 cas_interrupt1(); */

 cas_interruptN(); */

 cas_interruptN(); */

 Algorithm: IRQ every 1/2 of descriptors. */

 This is a hard error, log it. */

 NOTE: len is always >  tabort */

 NOTE: len is always > tabort */

	/* this is only used as a load-balancing hint, so it doesn't

	 * need to be SMP safe

	/* XXX: we need some higher-level QoS hooks to steer packets to

	 *      individual queues.

 set up tx completion writeback registers. must be 8-byte aligned */

	/* enable completion writebacks, enable paced mode,

	 * disable read pipe, and disable pre-interrupt compwbs

 write out tx ring info and tx desc bases */

		/* don't zero out the kick register here as the system

		 * will wedge

	/* program max burst sizes. these numbers should be different

	 * if doing QoS.

 Must be invoked under cp->lock. */

			/* use the alternate mac address registers for the

			 * first 15 multicast addresses

			/* use hw hash table for the next series of

			 * multicast addresses

 Must be invoked under cp->lock. */

 must be invoked under cp->stat_lock[N_TX_RINGS] */

 do both TX and RX reset */

 wait for TX */

 wait for RX */

 Must be invoked under cp->lock. */

 setup core arbitration weight register */

	/* set the infinite burst register for chips that don't have

	 * pci issues.

 change later for 802.3z */

 min frame + FCS */

	/* Ethernet payload + header + FCS + optional VLAN tag. NOTE: we

	 * specify the maximum frame size to prevent RX tag errors on

	 * oversized frames.

	/* NOTE: crc_size is used as a surrogate for half-duplex.

	 * workaround saturn half-duplex issue by increasing preamble

	 * size to 65 bytes.

 setup mac address in perfect filter array */

	/* Setup MAC interrupts.  We want to get all of the interesting

	 * counter expiration events, but we do not want to hear about

	 * normal rx/tx as the DMA engine tells us that.

	/* Don't enable even the PAUSE interrupts for now, we

	 * make no use of those events other than to record them.

 Must be invoked under cp->lock. */

	/* Calculate pause thresholds.  Setting the OFF threshold to the

	 * full RX fifo size effectively disables PAUSE generation

/* get the mac address by reading the vpd information in the rom.

 * also get the phy type and determine if there's an entropy generator.

 * NOTE: this is a bit convoluted for the following reasons:

 *  1) vpd info has order-dependent mac addresses for multinic cards

 *  2) the only way to determine the nic order is to use the slot

 *     number.

 *  3) fiber cards don't have bridges, so their slot numbers don't

 *     mean anything.

 *  4) we don't actually know we have a fiber card until after

 *     the mac addresses are parsed.

 default phy type */

 give us access to the PROM */

 check for an expansion rom */

 search for beginning of vpd */

 check for PCIR */

 no vpd found */

 found a vpd field */

 extract keywords */

			/* look for the following things:

			 * -- correct length == 29

			 * 3 (type) + 2 (size) +

			 * 18 (strlen("local-mac-address") + 1) +

			 * 6 (mac addr)

			 * -- VPD Instance 'I'

			 * -- VPD Type Bytes 'B'

			 * -- VPD data length == 6

			 * -- property string == local-mac-address

			 *

			 * -- correct length == 24

			 * 3 (type) + 2 (size) +

			 * 12 (strlen("entropy-dev") + 1) +

			 * 7 (strlen("vms110") + 1)

			 * -- VPD Instance 'I'

			 * -- VPD Type String 'B'

			 * -- VPD data length == 7

			 * -- property string == entropy-dev

			 *

			 * -- correct length == 18

			 * 3 (type) + 2 (size) +

			 * 9 (strlen("phy-type") + 1) +

			 * 4 (strlen("pcs") + 1)

			 * -- VPD Instance 'I'

			 * -- VPD Type String 'S'

			 * -- VPD data length == 4

			 * -- property string == phy-type

			 *

			 * -- correct length == 23

			 * 3 (type) + 2 (size) +

			 * 14 (strlen("phy-interface") + 1) +

			 * 4 (strlen("pcs") + 1)

			 * -- VPD Instance 'I'

			 * -- VPD Type String 'S'

			 * -- VPD data length == 4

			 * -- property string == phy-interface

 finally, check string and length */

 set mac address */

 Sun MAC prefix then 3 random bytes. */

 check pci invariants */

		/* Original Cassini supports HW CSUM, but it's not

		 * enabled by default as it can trigger TX hangs.

 Only sun has original cassini chips.  */

		/* We use a flag because the same phy might be externally

		 * connected.

 get page size for rx buffers. */

 see if we can allocate larger pages */

 Fetch the FIFO configurations. */

	/* finish phy determination. MDIO1 takes precedence over MDIO0 if

	 * they're both connected.

 no more checking needed */

 MII */

 see if we can do gigabit */

 Must be invoked under cp->lock. */

 enable dma */

 enable the mac */

 enable interrupts */

 Must be invoked under cp->lock. */

 Must be invoked under cp->lock. */

 use GMII registers */

/* A link-up condition has occurred, initialize and enable the

 * rest of the chip.

 *

 * Must be invoked under cp->lock.

 deal with carrier and collision detect. */

 val now set up for REG_MAC_TX_CFG */

	/* If gigabit and half-duplex, enable carrier extension

	 * mode.  increase slot time to 512 bytes as well.

	 * else, disable it and make sure slot time is 64 bytes.

	 * also activate checksum bug workaround

 checksum workaround */

 minimum size gigabit frame at half duplex */

		/* checksum bug workaround. don't strip FCS when in

		 * half-duplex mode

 symmetric or asymmetric pause */

 symmetric pause */

 Must be invoked under cp->lock. */

 Default aneg parameters */

/* Must be invoked under cp->lock. on earlier cassini boards,

 * SOFT_0 is tied to PCI reset. we use this to force a pci reset,

 * let it settle out, and then restore pci state.

 issue a global reset. don't use RSTOUT. */

		/* For PCS, when the blkflag is set, we should set the

		 * SW_REST_BLOCK_PCS_SLINK bit to prevent the results of

		 * the last autonegotiation from being cleared.  We'll

		 * need some special handling if the chip is set into a

		 * loopback mode.

 need to wait at least 3ms before polling register */

 enable various BIM interrupts */

	/* clear out pci error status mask for handled errors.

	 * we don't deal with DMA counter overflows as they happen

	 * all the time.

	/* set up for MII by default to address mac rx reset timeout

	 * issue

 disable dma engines. */

 program header parser */

 clear out error registers */

 Shut down the chip, must be called with pm_mutex held.  */

 Make us not-running to avoid timers respawning */

 Stop the reset task */

 Actually stop the chip */

 let the reset task handle it */

			/* first buffer is never a tiny buffer and so

			 * needs to be unmapped.

				/* next buffer might by a tiny buffer.

				 * skip past it.

 zero out tiny buf usage */

 freed on close */

 Must be invoked under cp->lock. */

 need to clean all tx rings */

 zero out init block */

 allocated on open */

		/* We can have more tasks scheduled than actually

		 * needed.

	/* The link went down, we reset the ring, but keep

	 * DMA stopped. Use this function for reset

	 * on error as well.

 Make sure we don't get interrupts or tx packets */

			/* We call cas_spare_recover when we call cas_open.

			 * but we do not initialize the lists cas_spare_recover

			 * uses until cas_open is called.

 test => only pending_spare set */

		/* when pending == CAS_RESET_ALL, the following

		 * call to cas_init_hw will restart auto negotiation.

		 * Setting the second argument of cas_reset to

		 * !(pending == CAS_RESET_ALL) will set this argument

		 * to 1 (avoiding reinitializing the PHY for the normal

		 * PCS case) when auto negotiation is not restarted.

		/* One-second counter so link-down workaround doesn't

		 * cause resets to occur so fast as to fool the switch

		 * into thinking the link is down.

	/* If the link task is still pending, we just

	 * reschedule the link timer

 check for rx cleaning */

 post_rxds will do a mod_timer */

		/* WTZ: Solaris driver reads this twice, but that

		 * may be due to the PCS case and the use of a

		 * common implementation. Read it twice here to be

		 * safe.

 avoid dups */

 check for tx state machine confusion */

/* tiny buffers are used to avoid target abort issues with

 * older cassini's

	/* The power-management mutex protects the hw_running

	 * etc. state so it is safe to do this bit without cp->lock

 Reset the chip */

		/* We set the second arg to cas_reset to zero

		 * because cas_init_hw below will have its second

		 * argument set to non-zero, which will force

		 * autonegotiation to start.

 alloc rx descriptors */

 allocate spares */

	/* We can now request the interrupt as we know it's masked

	 * on the controller. cassini+ has up to 4 interrupts

	 * that can be used, but you need to do explicit pci interrupt

	 * mapping to expose them

 init hw */

 Make sure we don't get distracted by suspend/resume */

 Stop traffic, mark us closed */

 neg. values for 2nd arg to cas_read_phy */

 we collate all of the stats into net_stats[N_TX_RING] */

 collect outstanding stats */

	/* WTZ: the Cassini spec gives these as 16 bit counters but

	 * stored in 32-bit words.  Added a mask of 0xffff to be safe,

	 * in case the chip somehow puts any garbage in the other bits.

	 * Also, counter usage didn't seem to mach what Adrian did

	 * in the parts of the code that set these quantities. Made

	 * that consistent.

 saved bits that are unique to ring 0 */

 disable RX MAC and wait for completion */

 disable hash filter and wait for completion */

 program hash filters */

 Record PHY settings if HW is on. */

 pcs uses the same bits as mii */

		/* Force these to "unknown" if the link is not up and

		 * autonogotiation in enabled. We can set the link

		 * speed to 0, but not cmd->duplex,

		 * because its legal values are 0 and 1.  Ethtool will

		 * print the value reported in parentheses after the

		 * word "Unknown" for unrecognized values.

		 *

		 * If in forced mode, we report the speed and duplex

		 * settings that we configured.

 Verify the settings we care about. */

 Apply settings and restart link process. */

 Restart link process. */

 cas_read_regs handles locks (cp->lock).  */

	/* Hold the PM mutex while doing ioctl's or we may collide

	 * with open/close and power management and oops.

 Get address of MII PHY in use. */

 Read MII PHY register. */

 Write MII PHY register. */

/* When this chip sits underneath an Intel 31154 bridge, it is the

 * only subordinate device and we can tweak the bridge settings to

 * reflect that fact.

	/* Clear bit 10 (Bus Parking Control) in the Secondary

	 * Arbiter Control/Status Register which lives at offset

	 * 0x41.  Using a 32-bit word read/modify/write at 0x40

	 * is much simpler so that's how we do this.

	/* Max out the Multi-Transaction Timer settings since

	 * Cassini is the only device present.

	 *

	 * The register is 16-bit and lives at 0x50.  When the

	 * settings are enabled, it extends the GRANT# signal

	 * for a requestor after a transaction is complete.  This

	 * allows the next request to run without first needing

	 * to negotiate the GRANT# signal back.

	 *

	 * Bits 12:10 define the grant duration:

	 *

	 *	1	--	16 clocks

	 *	2	--	32 clocks

	 *	3	--	64 clocks

	 *	4	--	128 clocks

	 *	5	--	256 clocks

	 *

	 * All other values are illegal.

	 *

	 * Bits 09:00 define which REQ/GNT signal pairs get the

	 * GRANT# signal treatment.  We set them all.

	/* The Read Prefecth Policy register is 16-bit and sits at

	 * offset 0x52.  It enables a "smart" pre-fetch policy.  We

	 * enable it and max out all of the settings since only one

	 * device is sitting underneath and thus bandwidth sharing is

	 * not an issue.

	 *

	 * The register has several 3 bit fields, which indicates a

	 * multiplier applied to the base amount of prefetching the

	 * chip would do.  These fields are at:

	 *

	 *	15:13	---	ReRead Primary Bus

	 *	12:10	---	FirstRead Primary Bus

	 *	09:07	---	ReRead Secondary Bus

	 *	06:04	---	FirstRead Secondary Bus

	 *

	 * Bits 03:00 control which REQ/GNT pairs the prefetch settings

	 * get enabled on.  Bit 3 is a grouped enabler which controls

	 * all of the REQ/GNT pairs from [8:3].  Bits 2 to 0 control

	 * the individual REQ/GNT pairs [2:0].

 Force cacheline size to 0x8 */

	/* Force latency timer to maximum setting so Cassini can

	 * sit on the bus as long as it likes.

	/* we must always turn on parity response or else parity

	 * doesn't get generated properly. disable SERR/PERR as well.

	 * in addition, we want to turn MWI on.

	/*

	 * On some architectures, the default cache line size set

	 * by pci_try_set_mwi reduces perforamnce.  We have to increase

	 * it for this case.  To start, we'll print some configuration

	 * data.

 Configure DMA attributes. */

 A value of 0 indicates we never explicitly set it */

	/* Just in case the implementation of atomic operations

	 * change so that an explicit initialization is necessary.

 Default link parameters */

 give us access to cassini registers */

 Cassini features. */

 MTU range: 60 - varies or 9000 */

	/* Try to restore it in case the error occurred after we

	 * set it.

		/* Restore the cache line size if we had modified

		 * it.

 If the driver is opened, we stop the DMA */

		/* We can set the second arg of cas_reset to 0

		 * because on resume, we'll call cas_init_hw with

		 * its second arg set so that autonegotiation is

		 * restarted.

 SPDX-License-Identifier: GPL-2.0

/* sunvnet.c: Sun LDOM Virtual Network Driver.

 *

 * Copyright (C) 2007, 2008 David S. Miller <davem@davemloft.net>

 * Copyright (C) 2016-2017 Oracle. All rights reserved.

/* length of time before we decide the hardware is borked,

 * and dev->tx_timeout() should be called to fix the problem

 Ordered from largest major to lowest */

 func arg to vnet_start_xmit_common() to get the proper tx port */

 Wrappers to common functions */

 MTU range: 68 - 65535 */

 vio_unregister_driver() should have cleaned up port_list */

 SPDX-License-Identifier: GPL-2.0

/* sunvnet.c: Sun LDOM Virtual Network Driver.

 *

 * Copyright (C) 2007, 2008 David S. Miller <davem@davemloft.net>

 * Copyright (C) 2016-2017 Oracle. All rights reserved.

/* Heuristic for the number of times to exponentially backoff and

 * retry sending an LDC trigger when EAGAIN is encountered

 v1.3 */

 for version < 1.2, VIO_DRING_MODE = 0x3 and no bitmask */

	/* MTU negotiation:

	 *	< v1.3 - ETH_FRAME_LEN exactly

	 *	> v1.3 - MIN(pkt.mtu, VNET_MAXPACKET, port->rmtu) and change

	 *			pkt->mtu for ACK

	 *	= v1.3 - ETH_FRAME_LEN + VLAN_HLEN exactly

 v1.3 */

 LSO negotiation */

 for version >= 1.6, ACK packet mode we support */

/* The hypervisor interface that implements copying to/from imported

 * memory from another domain requires that copies are done to 8-byte

 * aligned buffers, and that the lengths of such copies are also 8-byte

 * multiples.

 *

 * So we align skb->data to an 8-byte multiple and pad-out the data

 * area so we can round the copy length up to the next multiple of

 * 8 for the copy.

 *

 * The transmitter puts the actual start of the packet 6 bytes into

 * the buffer it sends over, so that the IP headers after the ethernet

 * header are aligned properly.  These 6 bytes are not in the descriptor

 * length, they are simply implied.  This offset is represented using

 * the VNET_PACKET_SKIP macro.

 XXX Validate pkt->start_idx and pkt->end_idx XXX */

	/* sync for race conditions with vnet_start_xmit() and tell xmit it

	 * is time to send a trigger.

		/* vnet_start_xmit() just populated this dring but missed

		 * sending the "start" LDC message to the consumer.

		 * Send a "start" trigger on its behalf.

 XXX just reset or similar XXX */

/* If the queue is stopped, wake it up so that we'll

 * send out another START message at the next TX.

 we don't expect any other bits */

 RESET takes precedent over any other event */

 a link went down */

		/* If the device is running but its tx queue was

		 * stopped (due to flow control), restart it.

		 * This is necessary since vnet_port_reset()

		 * clears the tx drings and thus we may never get

		 * back a VIO_TYPE_DATA ACK packet - which is

		 * the normal mechanism to restart the tx queue.

 a link came up */

					/* failures like handshake_failure()

					 * may have cleaned up dring, but

					 * NAPI polling may bring us here.

 header */

 make sure we have enough cookies and alignment in every frag */

 copy the headers, no csum here */

 copy the rest, with csum calculation */

 add in the header checksums */

 save the final result */

 XXX */

 segment to TSO size */

 This is a hard error, log it. */

	/* We don't rely on the ACKs to free the skb in vnet_start_xmit(),

	 * thus it is safe to not set VIO_ACK_ENABLE for each transmission:

	 * the protocol itself does not require it as long as the peer

	 * sends a VIO_SUBTYPE_ACK for VIO_DRING_STOPPED.

	 *

	 * An ACK for every packet in the ring is expensive as the

	 * sending of LDC messages is slow and affects performance.

	/* This has to be a non-SMP write barrier because we are writing

	 * to memory which is shared with the peer LDOM.

	/* Exactly one ldc "start" trigger (for dr->cons) needs to be sent

	 * to notify the consumer that some descriptors are READY.

	 * After that "start" trigger, no additional triggers are needed until

	 * a DRING_STOPPED is received from the consumer. The dr->cons field

	 * (set up by vnet_ack()) has the value of the next dring index

	 * that has not yet been ack-ed. We send a "start" trigger here

	 * if, and only if, start_cons is true (reset it afterward). Conversely,

	 * vnet_ack() should check if the dring corresponding to cons

	 * is marked READY, but start_cons was false.

	 * If so, vnet_ack() should send out the missed "start" trigger.

	 *

	 * Note that the dma_wmb() above makes sure the cookies et al. are

	 * not globally visible before the VIO_DESC_READY, and that the

	 * stores are ordered correctly by the compiler. The consumer will

	 * not proceed until the VIO_DESC_READY is visible assuring that

	 * the consumer does not observe anything related to descriptors

	 * out of order. The HV trap from the LDC start trigger is the

	 * producer to consumer announcement that work is available to the

	 * consumer

 previous trigger suffices */

 XXX Implement me XXX */

 no tso in vsw, misbehaves in bridge */

 need an initial trigger */

	/* find the first least-used q

	 * When there are more ldoms than q's, we start to

	 * double up on ports per queue.

 SPDX-License-Identifier: GPL-2.0

/* sunqe.c: Sparc QuadEthernet 10baseT SBUS card driver.

 *          Once again I am out to prove that every ethernet

 *          controller out there can be most efficiently programmed

 *          if you make it look like a LANCE.

 *

 * Copyright (C) 1996, 1999, 2003, 2006, 2008 David S. Miller (davem@davemloft.net)

 Reset the MACE, then the QEC channel. */

 Shut it up. */

 Setup initial rx/tx init block pointers. */

 Enable/mask the various irq's. */

 Setup the FIFO pointers into QEC local memory. */

 Clear the channel collision counter. */

 For 10baseT, inter frame space nor throttle seems to be necessary. */

 Now dork with the AMD MACE. */

	/* The QEC dma's the rx'd packets from local memory out to main memory,

	 * and therefore it interrupts when the packet reception is "complete".

	 * So don't listen for the MACE talking about it.

 Only usable interface on QuadEther is twisted pair. */

 Tell MACE we are changing the ether address. */

 Clear out the address filter. */

 Address changes are now complete. */

 Wait a little bit for the link to come up... */

 Missed packet counter is cleared on a read. */

	/* Reload multicast information, this will enable the receiver

	 * and transmitter.

 QEC should now start to show interrupts. */

/* Grrr, certain error conditions completely lock up the AMD MACE,

 * so when we get these we _must_ reset the chip.

/* Per-QE receive interrupt service routine.  Just like on the happy meal

 * we receive directly into skb's with a small packet copy water mark.

 QE adds ether FCS size to len */

 Check for errors. */

/* Interrupts for all QE's get filtered out via the QEC master controller,

 * so we just run through each qe and check to see who is signaling

 * and thus needs to be serviced.

 Latch the status now. */

					/* Wake net queue and return to

					 * lazy tx reclaim.

/* Reclaim TX'd frames from the ring.  This must always run under

 * the IRQ protected qep->lock.

	/* Try to reclaim, if that frees up some tx

	 * entries, we're fine.

 Get a packet queued to go onto the wire. */

 Avoid a race... */

 Get it going. */

		/* Halt the net queue and enable tx interrupts.

		 * When the tx queue empties the tx irq handler

		 * will wake up the queue and return us back to

		 * the lazy tx reclaim scheme.

 Lock out others. */

 Program the qe with the new filter value. */

	/* Any change of the logical address filter, the physical address,

	 * or enabling/disabling promiscuous mode causes the MACE to disable

	 * the receiver.  So we must re-enable them here or else the MACE

	 * refuses to listen to anything on the network.  Sheesh, took

	 * me a day or two to find this bug.

 Let us get going again. */

 Ethtool support... */

 This is only called once at boot time for each card probed. */

	/* Packetsize only used in 100baseT BigMAC configurations,

	 * set it to zero just to be on the safe side.

 Set the local memsize register, divided up to one piece per QE channel. */

	/* Divide up the local QEC memory amongst the 4 QE receiver and

	 * transmitter FIFOs.  Basically it is (total / 2 / num_channels).

	/* Find and set the burst sizes for the QEC, since it

	 * does the actual dma for all 4 channels.

 Make sure the QEC is in MACE mode. */

 Stop this QE. */

 SPDX-License-Identifier: GPL-2.0

/* $Id: sungem.c,v 1.44.2.22 2002/03/13 01:18:12 davem Exp $

 * sungem.c: Sun GEM ethernet driver.

 *

 * Copyright (C) 2000, 2001, 2002, 2003 David S. Miller (davem@redhat.com)

 *

 * Support for Apple GMAC and assorted PHYs, WOL, Power Management

 * (C) 2001,2002,2003 Benjamin Herrenscmidt (benh@kernel.crashing.org)

 * (C) 2004,2005 Benjamin Herrenscmidt, IBM Corp.

 *

 * NAPI and NETPOLL support

 * (C) 2004 by Eric Lemoine (eric.lemoine@gmail.com)

 *

	/* These models only differ from the original GEM in

	 * that their tx/rx fifos are of a different size and

	 * they only support 10/100 speeds. -DaveM

	 *

	 * Apple's GMAC does support gigabit on machines with

	 * the BCM54xx PHYs. -BenH

 Enable all interrupts but TXDONE */

 Disable all interrupts, including TXDONE */

 write posting */

 CONFIG_PPC_PMAC */

 Turn off the chip's clock */

 CONFIG_PPC_PMAC */

 prevent tx timeout */

	/* NOTE: unconditional netif_wake_queue is only

	 * appropriate so long as all callers are assured to

	 * have free tx slots.

	/* The link status bit latches on zero, so you must

	 * read it twice in such a case to see a transition

	 * to the link being up.

		/* The remote-fault indication is only valid

		 * when autoneg has completed.

		/* If this happens and the link timer is not running,

		 * reset so we re-negotiate.

	/* Defer timer expiration is quite normal,

	 * don't even log the event.

	/* The rest are all cases of one of the 16-bit TX

	 * counters expiring.

	/* We do not keep track of MAC_TXSTAT_FCE and

	 * MAC_TXSTAT_PCE events.

/* When we get a RX fifo overflow, the RX unit in GEM is probably hung

 * so we do the following.

 *

 * If any part of the reset goes wrong, we return 1 and that causes the

 * whole chip to be reset.

 First, reset & disable MAC RX. */

 Second, disable RX DMA. */

 Execute RX reset command. */

 Refresh the RX ring. */

 Now we must reprogram the rest of RX unit. */

	/* We do not track MAC_RXSTAT_FCE and MAC_RXSTAT_VCE

	 * events.

	/* This interrupt is just for pause frame and pause

	 * tracking.  It is useful for diagnostics and debug

	 * but probably by default we will mask these events.

		/* Interrogate PCI config space for the

		 * true cause.

 For all PCI errors, we should reset the chip. */

/* All non-normal interrupt conditions get serviced here.

 * Returns non-zero if we should just exit the interrupt

 * handler right now (ie. if we reset the card which invalidates

 * all of the other original irq status bits).

 Frame arrived, no free RX buffers available. */

 corrupt RX tag framing */

	/* Need to make the tx_old update visible to gem_start_xmit()

	 * before checking for netif_queue_stopped().  Without the

	 * memory barrier, there is a small possibility that gem_start_xmit()

	 * will miss it and cause the queue to be stopped forever.

		/* When writing back RX descriptor, GEM writes status

		 * then buffer address, possibly in separate transactions.

		 * If we don't wait for the chip to write both, we could

		 * post a new buffer to this descriptor then have GEM spam

		 * on the buffer address.  We sync on the RX completion

		 * register to prevent this from happening.

 We can now account for the work we're about to do */

 We'll just return it to GEM. */

 Trim the original skb for the netif. */

 We'll reuse the original ring buffer. */

 Handle anomalies */

			/* We run the abnormal interrupt handling code with

			 * the Tx lock. It only resets the Rx portion of the

			 * chip, but we need to guard it against DMA being

			 * restarted by the link poll timer

 Run TX completion thread */

		/* Run RX thread. We don't use any locking here,

		 * code willing to do bad things - like cleaning the

		 * rx ring - must call napi_disable(), which

		 * schedule_timeout()'s if polling is already disabled.

	/* If polling was disabled at the time we received that

	 * interrupt, we may return IRQ_HANDLED here while we

	 * should return IRQ_NONE. No big deal...

 Algorithm: IRQ every 1/2 of descriptors. */

 This is a hard error, log it. */

		/* We must give this initial chunk to the device last.

		 * Otherwise we could race with the device.

		/* netif_stop_queue() must be done before checking

		 * checking tx index in TX_BUFFS_AVAIL() below, because

		 * in gem_tx(), we update tx_old before checking for

		 * netif_queue_stopped().

 Reset PCS unit. */

	/* Make sure PCS is disabled while changing advertisement

	 * configuration.

	/* Advertise all capabilities except asymmetric

	 * pause.

	/* Enable and restart auto-negotiation, disable wrapback/loopback,

	 * and re-enable PCS.

	/* Make sure serialink loopback is off.  The meaning

	 * of this bit is logically inverted based upon whether

	 * you are in Serialink or SERDES mode.

 Make sure we won't get any more interrupts */

 Reset the chip */

 We are ready to rock, turn everything on. */

/* DMA won't be actually stopped before about 4ms tho ...

 We are done rocking, turn everything off. */

 Need to wait a bit ... done by the caller */

 XXX dbl check what that function should do when called on PCS PHY

 Setup advertise */

 Setup link parameters */

 Sanitize settings based on PHY capabilities */

	/* If we are asleep, we don't try to actually setup the PHY, we

	 * just store the settings

 Configure PHY & start aneg */

/* A link-up condition has occurred, initialize and enable the

 * rest of the chip.

	/* We take the tx queue lock to avoid collisions between

	 * this code, the tx path and the NAPI-driven error path

 MAC_TXCFG_NBO must be zero. */

	/* If gigabit and half-duplex, enable carrier extension

	 * mode.  Else, disable it.

		/* We try forced modes after a failed aneg only on PHYs that don't

		 * have "magic_aneg" bit set, which means they internally do the

		 * while forced-mode thingy. On these, we just restart aneg

 Try forced modes. */

		/* Downgrade from 100 to 10 Mbps if necessary.

		 * If already at 10Mbps, warn user about the

		 * situation every 10 ticks.

 There's no point doing anything if we're going to be reset */

		/* Ok, here we got a link. If we had it due to a forced

		 * fallback, and we were configured for autoneg, we do

		 * retry a short autoneg pass. If you know your hub is

		 * broken, use ethtool ;)

		/* If the link was previously up, we restart the

		 * whole process

 The reset task will restart the timer */

 Init PHY interface and start link poll state machine */

 Revert MIF CFG setting done on stop_phy */

		/* Those delays sucks, the HW seems to love them though, I'll

		 * seriously consider breaking some locks here to be able

		 * to schedule instead

			/* Some PHYs used by apple have problem getting back to us,

			 * we do an additional reset here

 Init datapath mode register. */

 Reset and detect MII PHY */

 Init PHY */

 Default aneg parameters */

 Print things out */

 Ethernet payload + header + FCS + optional VLAN tag. */

	/* Clear RX/TX/MAC/XIF config, we will set these up and enable

	 * them once a link is established.

	/* Setup MAC interrupts.  We want to get all of the interesting

	 * counter expiration events, but we do not want to hear about

	 * normal rx/tx as the DMA engine tells us that.

	/* Don't enable even the PAUSE interrupts for now, we

	 * make no use of those events other than to record them.

	/* Don't enable GEM's WOL in normal operations

	/* Calculate pause thresholds.  Setting the OFF threshold to the

	 * full RX fifo size effectively disables PAUSE generation which

	 * is what we do for 10/100 only GEMs which have FIFOs too small

	 * to make real gains from PAUSE.

	/* Configure the chip "burst" DMA mode & enable some

	 * HW bug fixes on Apple version

	/* If Infinite Burst didn't stick, then use different

	 * thresholds (and Apple bug fixes don't exist)

	/* On Apple's sungem, we can't rely on registers as the chip

	 * was been powered down by the firmware. The PHY is looked

	 * up later on.

		/* We hard-code the PHY address so we can properly bring it out of

		 * reset later on, we can't really probe it at this point, though

		 * that isn't an issue.

		/* One of the MII PHYs _must_ be present

		 * as this chip has no gigabit PHY.

	/* Determine initial PHY interface type guess.  MDIO1 is the

	 * external PHY and thus takes precedence over MDIO0.

 Fetch the FIFO configurations now too. */

 Reset the chip */

 Make sure ints are disabled */

 Allocate & setup ring buffers */

 Configure pause thresholds */

 Init DMA & MAC engines */

	/* Let the chip settle down a bit, it seems that helps

	 * for sleep mode on some models

	/* Make sure we aren't polling PHY status change. We

	 * don't currently use that feature though

 Setup wake-on-lan for MAGIC packet */

		/* Machine sleep will die in strange ways if we

		 * dont wait a bit here, looks like the chip takes

		 * some time to really shut down

		/* According to Apple, we must set the MDIO pins to this begnign

		 * state or we may 1) eat more current, 2) damage some PHYs

 Init & setup chip hardware */

 An interrupt might come in handy */

	/* Mark us as attached again if we come from resume(), this has

	 * no effect if we weren't detached and needs to be done now.

 Restart NAPI & queues */

	/* Detect & init PHY, start autoneg etc... this will

	 * eventually result in starting DMA operations when

	 * the link is up

 Stop NAPI and stop tx queue */

	/* Make sure ints are disabled. We don't care about

	 * synchronizing as NAPI is disabled, thus a stray

	 * interrupt will do nothing bad (our irq handler

	 * just schedules NAPI)

 Stop the link timer */

	/* We cannot cancel the reset task while holding the

	 * rtnl lock, we'd get an A->B / B->A deadlock stituation

	 * if we did. This is not an issue however as the reset

	 * task is synchronized vs. us (rtnl_lock) and will do

	 * nothing if the device is down or suspended. We do

	 * still clear reset_task_pending to avoid a spurrious

	 * reset later on in case we do resume before it gets

	 * scheduled.

 If we are going to sleep with WOL */

 Get rid of rings */

 No irq needed anymore */

 Shut the PHY down eventually and setup WOL */

	/* Lock out the network stack (essentially shield ourselves

	 * against a racing open, close, control call, or suspend

	/* Skip the reset task if suspended or closed, or if it's

	 * been cancelled by gem_do_stop (see comment there)

 Stop the link timer */

 Stop NAPI and tx */

 Reset the chip & rings */

 Restart NAPI and Tx */

 We are back ! */

	/* If the link is not up, restart autoneg, else restart the

	 * polling timer

	/* We allow open while suspended, we just do nothing,

	 * the chip will be initialized in resume()

 Enable the cell */

 Make sure PCI access and bus master are enabled */

			/* Put cell and forget it for now, it will be considered

			 *as still asleep, a new sleep cycle may bring it back

 Make sure bus master is disabled */

 Cell not needed neither if no WOL */

	/* Lock the network stack first to avoid racing with open/close,

	 * reset task and setting calls

	/* Not running, mark ourselves non-present, no need for

	 * a lock here

	/* Tell the network stack we're gone. gem_do_stop() below will

	 * synchronize with TX, stop NAPI etc...

 Switch off chip, remember WOL setting */

 Cell not needed neither if no WOL */

 Unlock the network stack */

 See locking comment in gem_suspend */

	/* Not running, mark ourselves present, no need for

	 * a lock here

 Enable the cell */

	/* Restart chip. If that fails there isn't much we can do, we

	 * leave things stopped.

	/* If we had WOL enabled, the cell clock was never turned off during

	 * sleep, so we end up beeing unbalanced. Fix that here

 Unlock the network stack */

	/* I have seen this being called while the PM was in progress,

	 * so we shield against this. Let's also not poke at registers

	 * while the reset task is going on.

	 *

	 * TODO: Move stats collection elsewhere (link timer ?) and

	 * make this a nop to avoid all those synchro issues

 Better safe than sorry... */

 We'll just catch it later when the device is up'd or resumed */

 Better safe than sorry... */

 Better safe than sorry... */

 Jumbo-grams don't seem to work :-( */

 We'll just catch it later when the device is up'd or resumed */

 Better safe than sorry... */

 XXX hardcoded stuff for now */

 XXX fixed PHYAD */

 Return current PHY settings */

		/* If we started with a forced mode, we don't have a default

		 * advertise set, we need to return something sensible so

		 * userland can re-enable autoneg properly.

 XXX PCS ?

 serdes means usually a Fibre connector, with most fixed */

 Verify the settings we care about. */

 Apply settings and restart link process. */

 Restart link process  */

 Add more when I understand how to program the chip */

 like WAKE_UCAST | WAKE_MCAST | WAKE_BCAST */

 Add more when I understand how to program the chip */

	/* For SIOCGMIIREG and SIOCSMIIREG the core checks for us that

	 * netif_device_present() is true and holds rtnl_lock for us

	 * so we have nothing to worry about

 Get address of MII PHY in use. */

 Read MII PHY register. */

 Write MII PHY register. */

 Fetch MAC address from vital product data of PCI ROM. */

 Sun MAC prefix then 3 random bytes. */

 not Sparc and not PPC */

 Ensure reset task is truly gone */

 Free resources */

	/* Apple gmac note: during probe, the chip is powered up by

	 * the arch code to allow the code below to work (and to let

	 * the chip be probed on the config space. It won't stay powered

	 * up until the interface is brought up however, so we can't rely

	 * on register configuration done at this point.

 Configure DMA attributes. */

	/* All of the GEM documentation states that 64-bit DMA addressing

	 * is fully supported and should work just fine.  However the

	 * front end for RIO based GEMs is different and only supports

	 * 32-bit addressing.

	 *

	 * For now we assume the various PPC GEMs are 32-bit only as well.

	/* On Apple, we want a reference to the Open Firmware device-tree

	 * node. We use it for clock control.

 Only Apple version supports WOL afaik */

 Make sure cell is enabled */

 Make sure everything is stopped and in init state */

 Fill up the mii_phy structure (even if we won't use it) */

 By default, we start with autoneg */

 Check fifo sizes, PHY type, etc... */

	/* It is guaranteed that the returned buffer will be at least

	 * PAGE_SIZE aligned.

 Set that now, in case PM kicks in now */

 We can do scatter/gather and HW checksum */

 MTU range: 68 - 1500 (Jumbo mode is broken) */

 Register with kernel */

	/* Undo the get_cell with appropriate locking (we could use

	 * ndo_init/uninit but that would be even more clumsy imho)

 SPDX-License-Identifier: GPL-2.0

/* ldmvsw.c: Sun4v LDOM Virtual Switch Driver.

 *

 * Copyright (C) 2016-2017 Oracle. All rights reserved.

 This driver makes use of the common code in sunvnet_common.c */

/* Length of time before we decide the hardware is hung,

 * and dev->tx_timeout() should be called to fix the problem.

 Static HW Addr used for the network interfaces representing vsw ports */

 Ordered from largest major to lowest */

 func arg to vnet_start_xmit_common() to get the proper tx port */

 Wrappers to common functions */

 reset the channel */

 Get the parent virtual-network-switch macaddr and cfghandle */

 find or create associated vnet */

 MTU range: 68 - 65535 */

 Get (or create) the vnet associated with this port */

 no tso in vsw, misbehaves in bridge */

	/* Mark the port as belonging to ldmvsw which directs the

	 * the common code to use the net_device in the vnet_port

	 * rather than the net_device in the vnet (which is used

	 * by sunvnet). This bit is used by the VNET_PORT_TO_NET_DEVICE

	 * macro.

	/* assure no carrier until we receive an LDC_EVENT_UP,

	 * even if the vsw config script tries to force us up

 just need to free up the vnet list */

 vio_unregister_driver() should have cleaned up port_list */

 SPDX-License-Identifier: GPL-2.0

/* niu.c: Neptune ethernet driver.

 *

 * Copyright (C) 2007, 2008 David S. Miller (davem@davemloft.net)

 Mode is always 10G fiber.  */

 Initialize all 4 lanes of the SERDES.  */

 Initialize PLL for 1G */

 Initialize all 4 lanes of the SERDES.  */

 Initialize PLL for 10G */

 Initialize all 4 lanes of the SERDES.  */

 check if serdes is ready */

 10G failed, try initializing at 1G */

 Initialize all 4 lanes of the SERDES.  */

 Initialize all 4 lanes of the SERDES.  */

/* When written, certain PHY registers need to be read back twice

 * in order for the bits to settle properly.

 Set LED functions */

 led activity */

 Enable PMD  */

 XXX dig this out it might not be so useful XXX */

 XXX shared resource, lock parent XXX */

 handle different phy types */

 bcom 8704 */

 !lp->autoneg */

			/* if X-full requested while not supported, or

 XXX shared resource, lock parent XXX */

 Check PMA/PMD Register: 1.0001.2 == 1 */

 Check PMC Register : 3.0001.2 == 1: read twice */

 Check XGXS Register : 4.0018.[0-3,12] */

 handle different phy types */

 bcom 8704 */

 state change */

 A NEM was just plugged in */

 No mdio, back-to-back XAUI */

 debounce */

 No mdio, back-to-back XAUI: it is C10NEM */

 XXX */

 Initialize all 4 lanes of the SERDES.  */

 10G Serdes */

 1G Serdes */

 10G Fiber */

 1G copper */

 10G copper */

 1G fiber */

 10G fiber */

 IPV4 hash entry with valid bit clear, rest is don't care.  */

 Entries for the ports are interleaved in the TCAM */

 One entry reserved for IP fragment rule */

 One entry reserved for IP fragment rule */

 One entry reserved for IP fragment rule */

	/* This elaborate scheme is needed for reading the RX discard

	 * counters, as they are only 16-bit and can overflow quickly,

	 * and because the overflow indication bit is not usable as

	 * the counter value does not wrap, but remains at max value

	 * 0xFFFF.

	 *

	 * In theory and in practice counters can be lost in between

	 * reading nr64() and clearing the counter nw64().  For this

	 * reason, the number of counter clearings nw64() is

	 * limited/reduced though the limit parameter.

	/* RXMISC (Receive Miscellaneous Discard Count), covers the

	 * following discard events: IPP (Input Port Process),

	 * FFLP/TCAM, Full RCR (Receive Completion Ring) RBR (Receive

	 * Block Ring) prefetch buffer is empty.

 WRED (Weighted Random Early Discard) by hardware */

 Only sync discards stats when qlen indicate potential for drops */

	/* These values are recommended by the HW designers for fair

	 * utilization of DRR amongst the rings.

 XXX make these configurable... XXX */

 XXX better defaults, configurable, etc... XXX */

 XXX TXDMA 32bit mode? XXX */

	/* The length field in TX_RNG_CFIG is measured in 64-byte

	 * blocks.  rp->pending is the number of TX descriptors in

	 * our ring, 8 bytes each, thus we divide by 8 bytes more

	 * to get the proper value the chip wants.

 XXX RXDMA 32bit mode? XXX */

	/* Note that the noport bit is the same in both ipv4 and

	 * ipv6 format TCAM entries.

 1G fiber */

 10G SERDES */

 10G copper or fiber */

 1G SERDES */

 1G copper */

 1G RGMII FIBER */

	/* The XMAC_MIN register only accepts values for TX min which

	 * have the low 3 bits cleared.

	/* This looks hookey but the RX MAC reset we just did will

	 * undo some of the state we setup in niu_init_tx_mac() so we

	 * have to call it again.  In particular, the RX MAC reset will

	 * set the XMAC_MAX register back to it's default value.

 prevent tx timeout */

	/* NOTE: unconditional netif_wake_queue is only appropriate

	 * so long as all callers are assured to have free tx slots

	 * (such as after niu_init_hw).

 fill the flow spec entry */

 Not yet implemented */

 put the tcam size here */

 put the tcam size here */

 Discard was set before, but is not set now */

 Program new user IP class */

 fill in the tcam key and mask */

 Not yet implemented */

 fill in the assoc data */

 validate the entry */

 if the entry is of a user defined class, then update*/

 disable class */

 invalidate the entry */

 cycle on/off once per second */

		/* On N2 NIU, the ldn-->ldg assignments are setup and fixed by

		 * the firmware, and we're not supposed to change them.

		 * Validate the mapping, because if it's wrong we probably

		 * won't get any interrupts and that's painful to debug.

 ESPC_PIO_EN_ENABLE must be set */

 ESPC_PIO_EN_ENABLE must be set */

 ret == 1 is not an error */

 ESPC_PIO_EN_ENABLE must be set */

 ROM header signature?  */

 Apply offset to PCI data structure.  */

 Check for "PCIR" signature.  */

 Check for OBP image type.  */

 1G copper, MII */

 10G fiber, XPCS */

 1G fiber, PCS */

 10G copper, XPCS */

 10G Serdes or 1G Serdes, default to 10G */

 1G copper, MII */

 1G fiber, PCS */

 10G copper, XPCS */

 10G fiber, XPCS */

				/* Fall back to SPROM as last resort.

				 * This will fail on most cards.

				/* All of the current probing methods fail on

				 * Maramba on-board parts.

		/* Because of the NIU_PHY_ID_MASK being applied, the 8704

		 * test covers the 8706 as well.

 Port 0 to 7 are reserved for onboard Serdes, probe the rest.  */

 this is the Monza case */

 XXX */

		/* On N2 NIU the firmware has setup the SID mappings so they go

		 * to the correct values that will route the LDG to the proper

		 * interrupt in the NCU interrupt table.

	/* We adopt the LDG assignment ordering used by the N2 NIU

	 * 'interrupt' properties because that simplifies a lot of

	 * things.  This ordering is:

	 *

	 *	MAC

	 *	MIF	(if port zero)

	 *	SYSERR	(if port zero)

	 *	RX channels

	 *	TX channels

 MTU range: 68 - 9216 */

 Nothing to do.  */

 Nothing to do.  */

 CONFIG_SPARC64 */

/*

 * Allwinner EMAC Fast Ethernet driver for Linux.

 *

 * Copyright 2012-2013 Stefan Roese <sr@denx.de>

 * Copyright 2013 Maxime Ripard <maxime.ripard@free-electrons.com>

 *

 * Based on the Linux driver provided by Allwinner:

 * Copyright (C) 1997  Sten Wang

 *

 * This file is licensed under the terms of the GNU General Public

 * License version 2. This program is licensed "as is" without any

 * warranty of any kind, whether express or implied.

 defaults above */;

 Transmit timeout, default 5 seconds. */

/* EMAC register address locking.

 *

 * The EMAC uses an address register to control where data written

 * to the data register goes. This means that the address register

 * must be preserved over interrupts or similar calls.

 *

 * During interrupt and other critical calls, a spinlock is used to

 * protect the system, but the calls themselves save the address

 * in the address register in case they are interrupting another

 * access to the device.

 *

 * For general accesses a lock is provided so that calls which are

 * allowed to sleep are serialised so that the address register does

 * not need to be saved. This lock also serves to serialise access

 * to the EEPROM and PHY access registers which are shared between

 * these two devices.

/* The driver supports the original EMACE, and now the two newer

 * devices, EMACA and EMACB.

 set EMAC SPEED, depend on PHY  */

 set duplex depend on phy */

 to-do: PHY interrupts are currently not supported */

 attach the mac to the phy */

 mask with MAC supported features */

 RESET device */

 ethtool ops */

 set up TX */

 set MAC */

 set MAC CTL0 */

 set MAC CTL1 */

 set up IPGT */

 set up IPGR */

 set up Collison window */

 set up Max Frame Length */

 set up RX */

 initial EMAC */

 flush RX FIFO */

 initial MAC */

 soft reset MAC */

 set MII clock */

 clear RX counter */

 disable all interrupt and clear interrupt status */

 set up EMAC */

 set mac_address to chip */

 Initialize emac board */

 enable RX/TX */

 enable RX/TX0/RX Hlevel interrup */

 Our watchdog timed out. Called by the networking layer */

 Save previous register address */

 We can accept TX packets again */

 Restore previous register address */

/* Hardware start transmission.

 * Send a packet to media from the upper layer.

 TX control: First packet immediately send, second packet queue */

 set TX len */

 start translate from fifo to phy */

 save the time stamp */

 set TX len */

 start translate from fifo to phy */

 save the time stamp */

 Second packet */

 free this SKB */

/* EMAC interrupt handler

 * receive the packet to upper layer, free the transmitted packet

 One packet sent complete */

/* Received a packet and pass to upper layer

 Check packet ready or not */

		/* race warning: the first packet might arrive with

		 * the interrupts disabled, but the second will fix

		 * it

 Pass to upper layer */

 had one stuck? */

 disable RX */

 Flush RX FIFO */

 enable RX */

 A packet ready now  & Get status/length */

 Packet Status check */

 Move data from EMAC */

 Read received packet from RX SRAM */

 Pass to upper layer */

 A real interrupt coming */

 Disable all interrupts */

 Got EMAC interrupt status */

 Got ISR */

 Clear ISR status */

 Received the coming packet */

 carrier lost */

 Transmit Interrupt check */

 Re-enable interrupt mask */

/*

 * Used by netconsole

/*  Open the interface.

 *  The interface is opened whenever "ifconfig" actives it.

 Initialize EMAC board */

 Disable all interrupt */

 clear interrupt status */

 Disable RX/TX */

/* Stop the interface.

 * The interface is stopped when it is brought.

/* Search EMAC board, allocate space and register it

 fill in parameters for net-dev structure */

 Read MAC-address from DT */

 if the MAC address is invalid get a random one */

 Carrier starts down, phylib will bring it up */

 Deprecated */

/*

	drivers/net/ethernet/dec/tulip/pnic2.c



	Copyright 2000,2001  The Linux Kernel Team

	Written/copyright 1994-2001 by Donald Becker.

        Modified to hep support PNIC_II by Kevin B. Hendricks



	This software may be used and distributed according to the terms

	of the GNU General Public License, incorporated herein by reference.



        Please submit bugs to http://bugzilla.kernel.org/ .

/* Understanding the PNIC_II - everything is this file is based

 * on the PNIC_II_PDF datasheet which is sorely lacking in detail

 *

 * As I understand things, here are the registers and bits that

 * explain the masks and constants used in this file that are

 * either different from the 21142/3 or important for basic operation.

 *

 *

 * CSR 6  (mask = 0xfe3bd1fd of bits not to change)

 * -----

 * Bit 24    - SCR

 * Bit 23    - PCS

 * Bit 22    - TTM (Trasmit Threshold Mode)

 * Bit 18    - Port Select

 * Bit 13    - Start - 1, Stop - 0 Transmissions

 * Bit 11:10 - Loop Back Operation Mode

 * Bit 9     - Full Duplex mode (Advertise 10BaseT-FD is CSR14<7> is set)

 * Bit 1     - Start - 1, Stop - 0 Receive

 *

 *

 * CSR 14  (mask = 0xfff0ee39 of bits not to change)

 * ------

 * Bit 19    - PAUSE-Pause

 * Bit 18    - Advertise T4

 * Bit 17    - Advertise 100baseTx-FD

 * Bit 16    - Advertise 100baseTx-HD

 * Bit 12    - LTE - Link Test Enable

 * Bit 7     - ANE - Auto Negotiate Enable

 * Bit 6     - HDE - Advertise 10baseT-HD

 * Bit 2     - Reset to Power down - kept as 1 for normal operation

 * Bit 1     -  Loop Back enable for 10baseT MCC

 *

 *

 * CSR 12

 * ------

 * Bit 25    - Partner can do T4

 * Bit 24    - Partner can do 100baseTx-FD

 * Bit 23    - Partner can do 100baseTx-HD

 * Bit 22    - Partner can do 10baseT-FD

 * Bit 21    - Partner can do 10baseT-HD

 * Bit 15    - LPN is 1 if all above bits are valid other wise 0

 * Bit 14:12 - autonegotiation state (write 001 to start autonegotiate)

 * Bit 3     - Autopolarity state

 * Bit 2     - LS10B - link state of 10baseT 0 - good, 1 - failed

 * Bit 1     - LS100B - link state of 100baseT 0 - good, 1 - failed

 *

 *

 * Data Port Selection Info

 *-------------------------

 *

 * CSR14<7>   CSR6<18>    CSR6<22>    CSR6<23>    CSR6<24>   MODE/PORT

 *   1           0           0 (X)       0 (X)       1        NWAY

 *   0           0           1           0 (X)       0        10baseT

 *   0           1           0           1           1 (X)    100baseT

 *

 *

 set up what to advertise during the negotiation */

        /* load in csr14  and mask off bits not to touch

         * comment at top of file explains mask value

 bit 17 - advetise 100baseTx-FD */

 bit 16 - advertise 100baseTx-HD */

 bit 6 - advertise 10baseT-HD */

        /* Now set bit 12 Link Test Enable, Bit 7 Autonegotiation Enable

         * and bit 0 Don't PowerDown 10baseT

 tell pnic2_lnk_change we are doing an nway negotiation */

 now we have to set up csr6 for NWAY state */

        /* mask off any bits not to touch

         * comment at top of file explains mask value

 don't forget that bit 9 is also used for advertising */

 advertise 10baseT-FD for the negotiation (bit 9) */

        /* set bit 24 for nway negotiation mode ...

         * see Data Port Selection comment at top of file

         * and "Stop" - reset both Transmit (bit 13) and Receive (bit 1)

 all set up so now force the negotiation to begin */

        /* read in current values and mask off all but the

	 * Autonegotiation bits 14:12.  Writing a 001 to those bits

         * should start the autonegotiation

 read the staus register to find out what is up */

	/* If NWay finished and we have a negotiated partner capability.

         * check bits 14:12 for bit pattern 101 - all is good

 we did an auto negotiation */

 negotiation ended successfully */

	               /* get the link partners reply and mask out all but

                        * bits 24-21 which show the partners capabilities

                        * and match those to what we advertised

                        *

                        * then begin to interpret the results of the negotiation.

                        * Always go in this order : (we are ignoring T4 for now)

                        *     100baseTx-FD, 100baseTx-HD, 10baseT-FD, 10baseT-HD

 so check  if 100baseTx link state is okay */

 now record the duplex that was negotiated */

                        /* remember to turn off bit 7 - autonegotiate

                         * enable so we can properly end nway mode and

                         * set duplex (ie. use csr6<9> again)

                        /* now set the data port and operating mode

			 * (see the Data Port Selection comments at

			 * the top of the file

 get current csr6 and mask off bits not to touch */

 see comment at top of file */

			/* so if using if_port 3 or 5 then select the 100baseT

			 * port else select the 10baseT port.

			 * See the Data Port Selection table at the top

			 * of the file which was taken from the PNIC_II.PDF

			 * datasheet

 now set the full duplex bit appropriately */

			/* now the following actually writes out the

			 * new csr6 values

                        /* remember to turn off bit 7 - autonegotiate

                         * enable so we don't forget

                        /* what should we do when autonegotiate fails?

                         * should we try again or default to baseline

                         * case.  I just don't know.

                         *

                         * for now default to some baseline case

                         /* set to 10baseTx-HD - see Data Port Selection

                          * comment given at the top of the file

 Link blew? Maybe restart NWay. */

 we are at 100mb and a potential link change occurred */

 check 100 link beat */

 if failed then try doing an nway to get in sync */

 we are at 10mb and a potential link change occurred */

 if failed, try doing an nway to get in sync */

 if all else fails default to trying 10baseT-HD */

 make sure autonegotiate enable is off */

        /* set to 10baseTx-HD - see Data Port Selection

         * comment given at the top of the file

/*

	drivers/net/ethernet/dec/tulip/pnic.c



	Copyright 2000,2001  The Linux Kernel Team

	Written/copyright 1994-2001 by Donald Becker.



	This software may be used and distributed according to the terms

	of the GNU General Public License, incorporated herein by reference.



	Please submit bugs to http://bugzilla.kernel.org/ .

 Ignore baseT4 */

 Restart Tx */

		/* If we use an external MII, then we mustn't use the

		 * internal negotiation.

 Turn on autonegotiation. */

		/* the timer was called due to a work overflow

		 * in the interrupt handler. Skip the connection

		 * checks, the nic is definitively speaking with

		 * his link partner.

 Remote link fault */

 Ignore baseT4 */

 100baseTx link beat */

 Restart Tx */

/*

 * xircom_cb: A driver for the (tulip-like) Xircom Cardbus ethernet cards

 *

 * This software is (C) by the respective authors, and licensed under the GPL

 * License.

 *

 * Written by Arjan van de Ven for Red Hat, Inc.

 * Based on work by Jeff Garzik, Doug Ledford and Donald Becker

 *

 *  	This software may be used and distributed according to the terms

 *      of the GNU General Public License, incorporated herein by reference.

 *

 *

 * 	$Id: xircom_cb.c,v 1.33 2001/03/19 14:02:07 arjanv Exp $

 IO registers on the card, offsets */

 PCI registers */

 Offsets of the buffers within the descriptor pages, in bytes */

 Send and receive buffers, kernel-addressable and dma addressable forms */

	/* transmit_used is the rotating counter that indicates which transmit

	/* Spinlock to serialize register operations.

	   It must be helt while manipulating the following registers:

	   CSR0, CSR6, CSR7, CSR9, CSR10, CSR15

 Function prototypes */

/* xircom_probe is the code that gets called on device insertion.

   it sets up the hardware and registers the device to the networklayer.



   TODO: Send 1 or 2 "dummy" packets here as the card seems to discard the

         first two packets that get send, and pump hates that.



 First do the PCI initialisation */

 disable all powermanagement */

 Why isn't this done by pci_enable_device ?*/

 clear PCI status, if any */

	/*

	   Before changing the hardware, allocate the memory.

	   This way, we can fail gracefully if not enough memory

	   is available.

 Allocate the send/receive buffers */

 IO range. */

 start the transmitter to get a heartbeat */

 TODO: send 2 dummy packets here */

/*

 xircom_remove is called on module-unload or on device-eject.

 it unregisters the irq, io-region and network device.

 Interrupts and such are already stopped in the "ifconfig ethX down"

 code.

 Handle shared irq and hotplug */

 Clear all remaining interrupts */

	status |= 0xffffffff; /* FIXME: make this clear only the

 First see if we can free some descriptors */

 only send the packet if the descriptor is free */

			/* Copy the packet data; zero the memory first as the card

			/* FIXME: The specification tells us that the length we send HAS to be a multiple of

 bit 25: last descriptor of the ring */

 0xF0... means want interrupts*/

 This gives the descriptor to the card */

 next descriptor is occupied... */

 Uh oh... no free descriptor... drop the packet */

 we don't want new packets */

 We can enable this again once we send dummy packets on ifconfig ethX up */

 First: reset the card */

 Software reset */

 give the card some time to reset */

 disable Software reset */

	val = 0;		/* Value 0x00 is a safe and conservative value

/*

trigger_transmit causes the card to check for frames to be transmitted.

This is accomplished by writing to the CSR1 port. The documentation

claims that the act of writing is sufficient and that the value is

ignored; I chose zero.

/*

trigger_receive causes the card to check for empty frames in the

descriptor list in which packets can be received.

This is accomplished by writing to the CSR2 port. The documentation

claims that the act of writing is sufficient and that the value is

ignored; I chose zero.

/*

setup_descriptors initializes the send and receive buffers to be valid

descriptors and programs the addresses into the card.

 Receive descriptors */

 clear the descriptors */

 Rx Descr0: It's empty, let the card own it, no errors -> 0x80000000 */

 Rx Descr1: buffer 1 is 1536 bytes, buffer 2 is 0 bytes */

 bit 25 is "last descriptor" */

		/* Rx Descr2: address of the buffer

 Rx Desc3: address of 2nd buffer -> 0 */

 Write the receive descriptor ring address to the card */

 Receive descr list address */

 transmit descriptors */

 clear the descriptors */

 Tx Descr0: Empty, we own it, no errors -> 0x00000000 */

 Tx Descr1: buffer 1 is 1536 bytes, buffer 2 is 0 bytes */

 bit 25 is "last descriptor" */

		/* Tx Descr2: address of the buffer

 Tx Desc3: address of 2nd buffer -> 0 */

 wite the transmit descriptor ring to the card */

 xmit descr list address */

/*

remove_descriptors informs the card the descriptors are no longer

valid by setting the address in the card to 0x00.

 Receive descriptor address */

 Send descriptor address */

/*

link_status_changed returns 1 if the card has indicated that

the link status has changed. The new link status has to be read from CSR12.



This function also clears the status-bit.

 Status register */

 no change */

	/* clear the event by writing a 1 to the bit in the

/*

transmit_active returns 1 if the transmitter on the card is

in a non-stopped state.

 transmitter disabled */

/*

receive_active returns 1 if the receiver on the card is

in a non-stopped state.

 receiver disabled */

/*

activate_receiver enables the receiver on the card.

Before being allowed to active the receiver, the receiver

must be completely de-activated. To achieve this,

this code actually disables the receiver first; then it waits for the

receiver to become inactive, then it activates the receiver and then

it waits for the receiver to be active.



must be called with the lock held and interrupts disabled.

 Operation mode */

	/* If the "active" bit is set and the receiver is already

 disable the receiver */

 wait a while */

 enable the receiver */

 Operation mode */

 enable the receiver */

 now wait for the card to activate again */

 wait a while */

/*

deactivate_receiver disables the receiver on the card.

To achieve this this code disables the receiver first;

then it waits for the receiver to become inactive.



must be called with the lock held and interrupts disabled.

 Operation mode */

 disable the receiver */

 wait a while */

/*

activate_transmitter enables the transmitter on the card.

Before being allowed to active the transmitter, the transmitter

must be completely de-activated. To achieve this,

this code actually disables the transmitter first; then it waits for the

transmitter to become inactive, then it activates the transmitter and then

it waits for the transmitter to be active again.



must be called with the lock held and interrupts disabled.

 Operation mode */

	/* If the "active" bit is set and the receiver is already

 disable the transmitter */

 wait a while */

 enable the transmitter */

 Operation mode */

 enable the transmitter */

 now wait for the card to activate again */

 wait a while */

/*

deactivate_transmitter disables the transmitter on the card.

To achieve this this code disables the transmitter first;

then it waits for the transmitter to become inactive.



must be called with the lock held and interrupts disabled.

 Operation mode */

 disable the transmitter */

 wait a while */

/*

enable_transmit_interrupt enables the transmit interrupt



must be called with the lock held and interrupts disabled.

 Interrupt enable register */

 enable the transmit interrupt */

/*

enable_receive_interrupt enables the receive interrupt



must be called with the lock held and interrupts disabled.

 Interrupt enable register */

 enable the receive interrupt */

/*

enable_link_interrupt enables the link status change interrupt



must be called with the lock held and interrupts disabled.

 Interrupt enable register */

 enable the link status chage interrupt */

/*

disable_all_interrupts disables all interrupts



must be called with the lock held and interrupts disabled.

/*

enable_common_interrupts enables several weird interrupts



must be called with the lock held and interrupts disabled.

 Interrupt enable register */

 Normal Interrupt Summary */

 Abnormal Interrupt Summary */

 Fatal bus error */

 Receive Process Stopped */

 Receive Buffer Unavailable */

 Transmit Underflow */

 Transmit Buffer Unavailable */

 Transmit Process Stopped */

/*

enable_promisc starts promisc mode



must be called with the lock held and interrupts disabled.

/*

link_status() checks the links status and will return 0 for no link, 10 for 10mbit link and 100 for.. guess what.



Must be called in locked state with interrupts disabled

 bit 2 is 0 for 10mbit link, 1 for not an 10mbit link */

 bit 1 is 0 for 100mbit link, 1 for not an 100mbit link */

 If we get here -> no link at all */

/*

  read_mac_address() reads the MAC address from the NIC and stores it in the "dev" structure.



  This function will take the spinlock itself and can, as a result, not be called with the lock helt.

 enable boot rom access */

/*

 transceiver_voodoo() enables the external UTP plug thingy.

 it's called voodoo as I stole this code and cannot cross-reference

 it with the specification.

 disable all powermanagement */

 disable all powermanagement */

 The card can have received packets already, read them away now */

 Bufferoffset is in BYTES */

 packet received */

 TODO: discard error packets */

 minus 4, we don't want the CRC */

 give the buffer back to the card */

 Bufferoffset is in BYTES */

 Major error */

 bit 31 is 0 when done */

 Bit 8 in the status field is 1 if there was a collision */

 descriptor is free again */

/*

	drivers/net/ethernet/dec/tulip/interrupt.c



	Copyright 2000,2001  The Linux Kernel Team

	Written/copyright 1994-2001 by Donald Becker.



	This software may be used and distributed according to the terms

	of the GNU General Public License, incorporated herein by reference.



        Please submit bugs to http://bugzilla.kernel.org/ .

 We use 0 or max */

        /*  CRS11 21143 hardware Mitigation Control Interrupt

            We use only RX mitigation we other techniques for

            TX intr. mitigation.



           31    Cycle Size (timer control)

           30:27 TX timer in 16 * Cycle size

           26:24 TX No pkts before Int.

           23:20 RX timer in Cycle size

           19:17 RX No pkts before Int.

           16       Continues Mode (CM)

 IM disabled */

 RX time = 1, RX pkts = 2, CM = 1 */

       0x80FF0000      /* RX time = 16, RX pkts = 7, CM = 1 */

 RX time = 16, RX pkts = 0, CM = 1 */

 Refill the Rx ring buffers. */

			/* Rx stopped due to out of buffers,

			 * restart it

/* that one buffer is needed for mit activation; or might be a

 Acknowledge current RX interrupt sources. */

 If we own the next entry, it is a new packet. Send it up. */

		       /*

			* Omit the four octet CRC from the length.

			* (May not be considered valid until we have

			* checked status for RxLengthOver2047 bits)

		       /*

			* Maximum pkt_len is 1518 (1514 + vlan header)

			* Anything higher than this is always invalid

			* regardless of RxLengthOver2047 bits

 Ingore earlier buffers. */

 There was a fatal error. */

 end of a packet.*/

                               /* Check if the packet is long enough to accept without copying

 16 byte align the IP header */

 Pass up the skb already on the Rx ring. */

               /* New ack strategy... irq does not ack Rx any longer

               /* Really bad things can happen here... If new packet arrives

                * and an irq arrives (tx or just due to occasionally unset

                * mask), it will be acked by irq handler, but new thread

                * is not scheduled. It is major hole in design.

                * No idea how to fix this if "playing with fire" will fail

                * tomorrow (night 011029). If it will not fail, we won

          /* We use this simplistic scheme for IM. It's proven by

             real life installations. We can have IM enabled

            continuesly but this would cause unnecessary latency.

            Unfortunely we can't use all the NET_RX_* feedback here.

            This would turn on IM for devices that is not contributing

            to backlog congestion with unnecessary latency.



             We monitor the device RX-ring and have:



             HW Interrupt Mitigation either ON or OFF.



            ON:  More then 1 pkt received (per intr.) OR we are dropping

             OFF: Only 1 pkt received



 CONFIG_TULIP_NAPI_HW_MITIGATION */

 If RX ring is not full we are out of memory. */

 Remove us from polling list and enable RX intr. */

         /* The last op happens after poll completion. Which means the following:

          * 1. it can race with disabling irqs in irq handler

          * 2. it can race with dise/enabling irqs in other poll threads

          * 3. if an irq raised after beginning loop, it will be immediately

          *    triggered here.

          *

          * Summarizing: the logic results in some redundant irqs both

          * due to races in masking and due to too late acking of already

          * processed irqs. But it must not result in losing events.

 Executed with RX ints disabled */

 Start timer, stop polling, but do not enable rx interrupts. */

         /* Think: timer_pending() was an explicit signature of bug.

          * Timer can be pending now but fired and completed

 remove ourselves from the polling list */

 CONFIG_TULIP_NAPI */

 If we own the next entry, it is a new packet. Send it up. */

		/*

		  Omit the four octet CRC from the length.

		  (May not be considered valid until we have

		  checked status for RxLengthOver2047 bits)

		/*

		  Maximum pkt_len is 1518 (1514 + vlan header)

		  Anything higher than this is always invalid

		  regardless of RxLengthOver2047 bits

 Ingore earlier buffers. */

 There was a fatal error. */

 end of a packet.*/

			/* Check if the packet is long enough to accept without copying

 16 byte align the IP header */

 Pass up the skb already on the Rx ring. */

 CONFIG_TULIP_NAPI */

 ack interrupt */

 do link change stuff */

 clear irq ack bit */

/* The interrupt handler does all of the Rx thread work and cleans up

 Let's see whether the interrupt really is for us */

 Mask RX intrs and add the device to poll list. */

               /* Acknowledge the interrupt sources we handle here ASAP

 Acknowledge all of the current interrupt sources ASAP. */

  CONFIG_TULIP_NAPI */

 It still has not been Txed */

 Check for Rx filter setup frames. */

 test because dummy frames not mapped */

 There was an major error, log it. */

 Free the original skb. */

 Log errors. */

 Abnormal error summary bit. */

 Bump up the Tx threshold */

 Store-n-forward. */

 Restart the transmit process. */

 Missed a Rx frame. */

			/*

			 * NB: t21142_lnk_change() does a del_timer_sync(), so be careful if this

			 * call is ever done under the spinlock

				/* oops, we hit a PCI error.  The code produced corresponds

				 * to the reason:

				 *  0 - parity error

				 *  1 - master abort

				 *  2 - target abort

				 * Note that on parity error, we should do a software reset

				 * of the chip to get it back into a sane state (according

				 * to the 21142/3 docs that is).

				 *   -- rmk

 Clear all error sources, included undocumented ones! */

 Acknowledge all interrupt sources. */

                     /* Josip Loncaric at ICASE did extensive experimentation

 the LC82C168 doesn't have a hw timer.*/

                          /* Mask all interrupting sources, set timer to

 Abnormal intr. */

 check if the card is in suspend mode */

 CONFIG_TULIP_NAPI */

/*

	drivers/net/ethernet/dec/tulip/timer.c



	Copyright 2000,2001  The Linux Kernel Team

	Written/copyright 1994-2001 by Donald Becker.



	This software may be used and distributed according to the terms

	of the GNU General Public License, incorporated herein by reference.



	Please submit bugs to http://bugzilla.kernel.org/ .

 No EEPROM info, use generic code. */

			/* Not much that can be done.

 Type 0 serial or 4 SYM transceiver.  Check the link beat bit. */

 Check that the specified bit has the proper value. */

 Bogus Znyx board. */

 We start again, but should instead look for default. */

 Skip FD entries. */

 Restart the transmit process. */

 21140, 21142 MII */

 21142 serial block has no link beat. */

	/* mod_timer synchronizes us with potential add_timer calls

	 * from interrupts.

	/* mod_timer synchronizes us with potential add_timer calls

	 * from interrupts.

 de2104x.c: A Linux PCI Ethernet driver for Intel/Digital 21040/1 chips. */

/*

	Copyright 2001,2003 Jeff Garzik <jgarzik@pobox.com>



	Copyright 1994, 1995 Digital Equipment Corporation.	    [de4x5.c]

	Written/copyright 1994-2001 by Donald Becker.		    [tulip.c]



	This software may be used and distributed according to the terms of

	the GNU General Public License (GPL), incorporated herein by reference.

	Drivers based on or derived from this code fall under the GPL and must

	retain the authorship, copyright and license notice.  This file is not

	a complete program and may only be used when the entire operating

	system is licensed under the GPL.



	See the file COPYING in this distribution for more information.



	TODO, in rough priority order:

	* Support forcing media type with a module parameter,

	  like dl2k.c/sundance.c

	* Constants (module parms?) for Rx work limit

	* Complete reset on PciErr

	* Jumbo frames / dev->change_mtu

	* Adjust Rx FIFO threshold and Max Rx DMA burst on Rx FIFO error

	* Adjust Tx FIFO threshold and Max Tx DMA burst on Tx FIFO error

	* Implement Tx software interrupt mitigation via

	  Tx descriptor bit



 Set the copy breakpoint for the copy-only-tiny-buffer Rx structure. */

 Descriptor skip length in 32 bit longwords. */

 Size of each temporary Rx buffer.*/

 Time in jiffies before concluding the transmitter is hung. */

/* This is a mysterious value that can be written to CSR11 in the 21040 (only)

   to support a pre-NWay full-duplex signaling mechanism using short frames.

   No one knows what it should be, but if left at its default value some

 NIC registers */

 BusMode bits */

 Rx/TxPoll bits */

 Tx/Rx descriptor status bits */

 MacStatus bits */

 MacMode bits */

 ROMCmd bits */

 EEPROM shift clock. */

 EEPROM chip select. */

 Data from the Tulip to EEPROM. */

 Data from the EEPROM chip. */

 The EEPROM commands include the alway-set leading bit. */

 RxMissed bits */

 SROM-related bits */

 PCIPM bits */

 SIAStatus bits */

/*

 * Set the programmable burst length to 4 longwords for all:

 * DMA errors result without these values. Cache align 16 long.

 DE_MEDIA_xxx */

/* 21040 transceiver register settings:

 21041 transceiver register settings: TP AUTO, BNC, AUI, TP, TP FD*/

 If on-chip autonegotiation is broken, use half-duplex (FF3F) instead */

 Ingore earlier buffers. */

 There was a fatal error. */

 end of a packet.*/

		/* the length is actually a 15 bit value here according

		 * to Table 4-1 in the DE2104x spec so mask is 0x7fff

 We'll reuse the original ring buffer. */

 Trigger an immediate transmit demand. */

/* Set or clear the multicast filter for this adaptor.

   Note that we only use exclusion around actually queueing the

   new frame, not around filling de->setup_frame.  This is non-deterministic

 Broadcast entry */

 This should work on big-endian machines as well. */

 Fill the final entry with our physical address. */

	/* We have <= 14 addresses so we can use the wonderful

 Fill the unused entries with the broadcast address. */

 Fill the final entry with our physical address. */

 Set promiscuous. */

 Too many to filter well -- accept all multicasts. */

	/* Note that only the low-address shortword of setup_frame is valid!

 Must use a multicast hash table. */

	/*

	 * Now add this frame to the Tx list.

 Avoid a chip errata by prefixing a dummy entry. */

 Must set DescOwned later to avoid race with chip */

 Put the setup frame on the Tx list. */

 Trigger an immediate transmit demand. */

 self-clearing */

 The chip only need report frame silently dropped. */

	/* wait until in-flight frame completes.

	 * Max time @ 10BT: 1500*8b/10Mbps == 1200us (+ 100us margin)

	 * Typically expect this loop to end in < 50 us on 100BT.

 Reset phy */

	/* must delay 10ms before writing to other registers,

	 * especially CSR6

 clear port active bits */

 if media type locked, don't switch media */

 if activity detected, use that as hint for new media type */

 if AUI/BNC selected, then activity is on TP port */

 TP selected.  If there is only TP and BNC, then it's BNC */

 TP selected.  If there is only TP and AUI, then it's AUI */

 otherwise, ignore the hint */

	/*

	 * Absent or ambiguous activity hint, move to next advertised

	 * media state.  If de->media_type is left unchanged, this

	 * simply resets the PHY and reloads the current media settings.

 Ignore if current media is AUI or BNC and we can't use TP */

 If current media is not TP, change it to TP */

 Mark the link as down only if current media is TP */

	/*

	 * Reset MAC.  de4x5.c and tulip.c examined for "advice"

	 * in this area.

 Reset the chip, holding bit 0 set at least 50 PCI cycles. */

 de4x5.c delays, so we do too */

 Reset phy */

 reset phy */

 self-clearing */

 Update the error counts. */

 read all CSRs */

 handle self-clearing RxMissed counter, CSR8 */

 ignore maxtxpkt, maxrxpkt for now */

 nothing to change */

 Reset the pointer with a dummy write. */

 Note: this routine returns extra data bits for size detection. */

 Shift the read command bits out. */

 Terminate the EEPROM access. */

 download entire eeprom */

	/* DEC now has a specification but early board makers

 This does  memcmp(eedata, eedata+16, 8) */

 store MAC address */

 get offset of controller 0 info leaf.  ignore 2nd byte. */

 get pointer to info leaf */

 paranoia checks */

 get default media type */

 init SIA register values to defaults */

	/* parse media blocks to see what medias are supported,

	 * and if any custom CSR values are provided

 index based on media type in media block */

 10baseT */

 BNC */

 AUI */

 10baseT-FD */

 fill in defaults, for cases where custom CSRs not used */

			/* autonegotiation is broken at least on some chip

 for error cases, it's ok to assume we support all these */

 allocate a new ethernet device structure, and fill in defaults */

 wake up device, assign resources */

 reserve PCI resources to ensure driver atomicity */

 check for invalid IRQ value */

 obtain and check validity of PCI I/O address */

 remap CSR registers */

 make sure hardware is not running */

	/* get MAC address, initialize default media type and

	 * get list of supported media

 register new network interface with kernel */

 print info about board and interface just registered */

 enable busmastering */

 put adapter to sleep */

 Update the error counts. */

 winbond-840.c: A Linux PCI network adapter device driver. */

/*

	Written 1998-2001 by Donald Becker.



	This software may be used and distributed according to the terms of

	the GNU General Public License (GPL), incorporated herein by reference.

	Drivers based on or derived from this code fall under the GPL and must

	retain the authorship, copyright and license notice.  This file is not

	a complete program and may only be used when the entire operating

	system is licensed under the GPL.



	The author may be reached as becker@scyld.com, or C/O

	Scyld Computing Corporation

	410 Severn Ave., Suite 210

	Annapolis MD 21403



	Support and updates available at

	http://www.scyld.com/network/drivers.html



	Do not remove the copyright information.

	Do not change the version information unless an improvement has been made.

	Merely removing my name, as Compex has done in the past, does not count

	as an improvement.



	Changelog:

	* ported to 2.4

		???

	* spin lock update, memory barriers, new style dma mappings

		limit each tx buffer to < 1024 bytes

		remove DescIntr from Rx descriptors (that's an Tx flag)

		remove next pointer from Tx descriptors

		synchronize tx_q_bytes

		software reset in tx_timeout

			Copyright (C) 2000 Manfred Spraul

	* further cleanups

		power management.

		support for big endian descriptors

			Copyright (C) 2001 Manfred Spraul

	* ethtool support (jgarzik)

	* Replace some MII-related magic numbers with constants (jgarzik)



	TODO:

	* enable pci_power_off

	* Wake-On-LAN

/* Automatically extracted configuration info:

probe-func: winbond840_probe

config-in: tristate 'Winbond W89c840 Ethernet support' CONFIG_WINBOND_840



c-help-name: Winbond W89c840 PCI Ethernet support

c-help-symbol: CONFIG_WINBOND_840

c-help: This driver is for the Winbond W89c840 chip.  It also works with

c-help: the TX9882 chip on the Compex RL100-ATX board.

c-help: More specific information and updates are available from

c-help: http://www.scyld.com/network/drivers.html

/* The user-configurable values.

 1 normal messages, 0 quiet .. 7 verbose. */

/* Maximum number of multicast addresses to filter (vs. Rx-all-multicast).

/* Set the copy breakpoint for the copy-only-tiny-frames scheme.

/* Used to pass the media type, etc.

   Both 'options[]' and 'full_duplex[]' should exist for driver

   interoperability.

   The media type is usually passed in 'options[]'.

 More are supported, limit only on options */

 Operational parameters that are set at compile time. */

/* Keep the ring sizes a power of two for compile efficiency.

   The compiler will convert <unsigned>'%'<2^N> into a bit mask.

   Making the Tx ring too large decreases the effectiveness of channel

   bonding and packet priority.

 Limit ring entries actually used.  */

/* The presumed FIFO size for working around the Tx-FIFO-overflow bug.

   To avoid overflowing we don't queue again until we have room for a

   full-size packet.

 Operational parameters that usually are not changed. */

 Time in jiffies before concluding the transmitter is hung. */

 Include files, designed to support most kernel versions 2.0.0 and later. */

 Processor type for cache alignment. */

 tulip.h also defines this */

 Size of each temporary Rx buffer.*/

/*

				Theory of Operation



I. Board Compatibility



This driver is for the Winbond w89c840 chip.



II. Board-specific settings



None.



III. Driver operation



This chip is very similar to the Digital 21*4* "Tulip" family.  The first

twelve registers and the descriptor format are nearly identical.  Read a

Tulip manual for operational details.



A significant difference is that the multicast filter and station address are

stored in registers rather than loaded through a pseudo-transmit packet.



Unlike the Tulip, transmit buffers are limited to 1KB.  To transmit a

full-sized packet we must use both data buffers in a descriptor.  Thus the

driver uses ring mode where descriptors are implicitly sequential in memory,

rather than using the second descriptor address as a chain pointer to

subsequent descriptors.



IV. Notes



If you are going to almost clone a Tulip, why not go all the way and avoid

the need for a new driver?



IVb. References



http://www.scyld.com/expert/100mbps.html

http://www.scyld.com/expert/NWay.html

http://www.winbond.com.tw/



IVc. Errata



A horrible bug exists in the transmit FIFO.  Apparently the chip doesn't

correctly detect a full FIFO, and queuing more than 2048 bytes may result in

silent data corruption.



Test with 'ping -s 10000' on a fast computer.



/*

  PCI probe table.

 size of PCI BAR resource */

 Driver use, intended as capability flags. */

 Sometime a Level-One switch card. */

 terminate list. */

/* This driver was written to use PCI memory space, however some x86 systems

   work only with I/O space accesses. See CONFIG_TULIP_MMIO in .config

/* Offsets to the Command and Status Registers, "CSRs".

   While similar to the Tulip, these registers are longword aligned.

   Note: It's not useful to define symbolic names for every register bit in

   the device.  The name can only partially document the semantics and make

   the driver longer and more difficult to read.

 Debug use */

 Bits in the NetworkConfig register. */

 The Tulip Rx and Tx buffer descriptors. */

 winbond only supports one MII */

 The addresses of receive-in-place skbuffs. */

 The saved address of a sent-in-place packet/buffer, for later free(). */

 Media monitoring timer. */

 Frequently used values: keep some adjacent for cache effect. */

 Producer/consumer ring indices */

 Based on MTU+slack. */

 The Tx queue is full. */

 MII transceiver section. */

 MII device addresses. */

 MII device addresses, but only the first is used */

	/* Reset the chip to erase previous misconfiguration.

 The lower four bits are the media type. */

 The chip-specific entries in the device structure. */

/* Read the EEPROM and MII Management Data I/O (MDIO) interfaces.  These are

   often serial bit streams generated by the host processor.

/* Delay between EEPROM clock transitions.

   No extra delay is needed with 33Mhz PCI, but future 66Mhz access may need

   a delay.  Note that pre-2.0.34 kernels had a cache-alignment bug that

   made udelay() unreliable.

   The old method of using an ISA access as a delay, __SLOW_DOWN_IO__, is

   deprecated.

 The EEPROM commands include the alway-set leading bit. */

 Shift the read command bits out. */

 Terminate the EEPROM access. */

/*  MII transceiver control section.

	Read and write the MII registers using software-generated serial

	MDIO protocol.  See the MII specifications or DP83840A data sheet

	for details.



	The maximum data clock rate is 2.5 Mhz.  The minimum timing is usually

/* Set iff a MII transceiver on any interface requires mdio preamble.

   This only set with older transceivers, so the extra

/* Generate the preamble required for initial synchronization and

 Establish sync by sending at least 32 logic ones. */

 Shift the read command bits out. */

 Read the two transition, 16 data, and wire-idle bits. */

 Shift the command bits out. */

 Clear out extra bits. */

 Reset */

 Set the timer to check for link beat. */

 BSMR */

 reread: the link status bit is sticky */

		/* If the link partner doesn't support autonegotiation

		 * the MII detects it's abilities with the "parallel detection".

		 * Some MIIs update the LPA register to the result of the parallel

		 * detection, some don't.

		 * The Davicom PHY [at least 0181b800] doesn't.

		 * Instead bit 9 and 13 of the BMCR are updated to the result

		 * of the negotiation..

 remove fastether and fullduplex */

 stop both Tx and Rx processes */

 wait until they have really stopped */

 rx stopped */

 and restart them with the new configuration */

 Initial all Rx descriptors. */

 Mark the last entry as wrapping the ring. */

 Fill in the Rx buffers.  Handle allocation failure gracefully. */

 Initialize the Tx descriptors */

 Free all the skbuffs in the Rx queue. */

 Initialize other registers. */

 Big-endian descriptors */

 skip length 4 u32 */

 give Rx priority */

	/* Configure the PCI bus bursts and FIFO thresholds.

	   486: Set 8 longword cache alignment, 8 longword burst.

	   586: Set 16 longword cache alignment, no burst limit.

	   Cache alignment bits 15:14	     Burst length 13:8

		0000	<not allowed> 		0000 align to cache	0800 8 longwords

		4000	8  longwords		0100 1 longword		1000 16 longwords

		8000	16 longwords		0200 2 longwords	2000 32 longwords

 When not a module we can work around broken '486 PCI boards. */

	/* 128 byte Tx threshold;

 Clear and Enable interrupts by setting the interrupt mask. */

	/*

	 * Under high load dirty_tx and the internal tx descriptor pointer

	 * come out of sync, thus perform a software reset and reinitialize

	 * everything.

 prevent tx timeout */

 Initialize the Rx and Tx rings, along with various 'dev' bits. */

	/* Caution: the write order is important here, set the field

 Calculate the next Tx descriptor entry. */

	/* Now acquire the irq spinlock.

	 * The difficult race is the ordering between

	 * increasing np->cur_tx and setting DescOwned:

	 * - if np->cur_tx is increased first the interrupt

	 *   handler could consider the packet as transmitted

	 *   since DescOwned is cleared.

	 * - If DescOwned is set first the NIC could report the

	 *   packet as sent, but the interrupt handler would ignore it

	 *   since the np->cur_tx was not yet increased.

 flush length, buffer1, buffer2 */

 flush status and kick the hardware */

	/* Work around horrible bug in the chip by marking the queue as full

 There was an error, log it. */

 Free the original skb. */

 The ring is no longer full, clear tbusy. */

/* The interrupt handler does all of the Rx thread work and cleans up

 Acknowledge all of the current interrupt sources ASAP. */

 Abnormal error summary/uncommon events handlers. */

			/* Set the timer to re-enable the other interrupts after

/* This routine is logically part of the interrupt handler, but separated

 If EOP is set on the next entry, it's a new packet. Send it up. */

 Ingore earlier buffers. */

 There was a fatal error. */

 end of a packet.*/

 Omit the four octet CRC from the length. */

			/* Check if the packet is long enough to accept without copying

 16 byte align the IP header */

 Remove after testing. */

 You will want this info for the initial debug. */

 Refill the Rx ring buffers. */

 Better luck next round. */

 Bump up the Tx threshold */

		/* This causes lots of dropped packets,

		 * and under high load even tx_timeouts

 load full packet before starting */

 Missed a Rx frame. */

 Re-enable other interrupts. */

 The chip only need report frame silently dropped. */

 Multicast hash filter */

 Set promiscuous. */

 Too many to match, or accept all multicasts. */

 Get address of MII PHY in use. */

 Read MII PHY register. */

 Write MII PHY register. */

 Stop the chip's Tx and Rx processes. */

 __i386__ debugging only */

/*

 * suspend/resume synchronization:

 * - open, close, do_ioctl:

 * 	rtnl_lock, & netif_device_detach after the rtnl_unlock.

 * - get_stats:

 * 	spin_lock_irq(np->lock), doesn't touch hw if not present

 * - start_xmit:

 * 	synchronize_irq + netif_tx_disable;

 * - tx_timeout:

 * 	netif_device_detach + netif_tx_disable;

 * - set_multicast_list

 * 	netif_device_detach + netif_tx_disable;

 * - interrupt handler

 * 	doesn't touch hw if not present, synchronize_irq waits for

 * 	running instances of the interrupt handler.

 *

 * Disabling hw requires clearing csr6 & IntrEnable.

 * update_csr6 & all function that write IntrEnable check netif_device_present

 * before settings any bits.

 *

 * Detach must occur under spin_unlock_irq(), interrupts from a detached

 * device would cause an irq storm.

 no more hardware accesses behind this line. */

 pci_power_off(pdev, -1); */

 device not suspended */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

    A Davicom DM9102/DM9102A/DM9102A+DM9801/DM9102A+DM9802 NIC fast

    ethernet driver for Linux.

    Copyright (C) 1997  Sten Wang





    DAVICOM Web-Site: www.davicom.com.tw



    Author: Sten Wang, 886-3-5798797-8517, E-mail: sten_wang@davicom.com.tw

    Maintainer: Tobias Ringstrom <tori@unhappy.mine.nu>



    (C)Copyright 1997-1998 DAVICOM Semiconductor,Inc. All Rights Reserved.



    Marcelo Tosatti <marcelo@conectiva.com.br> :

    Made it compile in 2.3 (device to net_device)



    Alan Cox <alan@lxorguk.ukuu.org.uk> :

    Cleaned up for kernel merge.

    Removed the back compatibility support

    Reformatted, fixing spelling etc as I went

    Removed IRQ 0-15 assumption



    Jeff Garzik <jgarzik@pobox.com> :

    Updated to use new PCI driver API.

    Resource usage cleanups.

    Report driver version to user.



    Tobias Ringstrom <tori@unhappy.mine.nu> :

    Cleaned up and added SMP safety.  Thanks go to Jeff Garzik,

    Andrew Morton and Frank Davis for the SMP safety fixes.



    Vojtech Pavlik <vojtech@suse.cz> :

    Cleaned up pointer arithmetics.

    Fixed a lot of 64bit issues.

    Cleaned up printk()s a bit.

    Fixed some obvious big endian problems.



    Tobias Ringstrom <tori@unhappy.mine.nu> :

    Use time_after for jiffies calculation.  Added ethtool

    support.  Updated PCI resource allocation.  Do not

    forget to unmap PCI mapped skbs.



    Alan Cox <alan@lxorguk.ukuu.org.uk>

    Added new PCI identifiers provided by Clear Zhang at ALi

    for their 1563 ethernet device.



    TODO



    Check on 64 bit boxes.

    Check and fix on big endian boxes.



    Test and make sure PCI latency is now correct for all cases.

 Board/System/Debug information/definition ---------------- */

 Davicom DM9132 ID */

 Davicom DM9102 ID */

 Davicom DM9100 ID */

 Davicom DM9009 ID */

 Maximum tx packet per time */

 Allocated Tx descriptors */

 Allocated Rx descriptors */

 Max TX packet count */

 TX wakeup count */

 TX & RX burst mode */

 HD */

 TxJabber RxWatchdog */

 TXJT, LC, EC, FUE */

 TX TH 72 byte */

 TX TH 96 byte */

 TX TH 128 byte */

 TX TH 256 byte */

 TX TH 512 byte */

 TX TH 1K  byte */

 timer wakeup time : 1 second */

 tx packet time-out time 1.5 s" */

 tx packet Kick-out time 0.5 s" */

 CR9 definition: SROM/MII */

 Structure/enum declaration ------------------------------- */

 Data for the card */

 Data for us */

 Data for the card */

 Data for us */

 Chip vendor/Device ID */

 Chip revision */

 next device */

 PCI device */

 I/O base address */

 pointer for memory physical address */

 Tx buffer pool memory */

 Tx buffer pool align dword */

 descriptor pool memory */

 descriptor pointer */

 Tx buffer pool memory */

 Tx buffer pool align dword */

 descriptor pool memory */

 packet come pointer */

 transmitted packet count */

 wait to send packet count */

 available rx descriptor count */

 rx packet count a callback time */

 For HPNA register 16 */

 For HPNA remote device check */

 NIC media capability */

 Saved Phyxcer register 4 value */

 0:none, 1:DM9801, 2:DM9802 */

 Keep DM9102A chip type */

 user specify media mode */

 real work media mode */

 Hardware failed, need to reset */

 Operating mode check */

 Flag to record state */

 user WOL settings */

 Driver defined statistic counter */

 NIC SROM data */

 Global variable declaration ----------------------------- */

 For module input parameter */

 Default: Low Power/High Speed */

 Default: Disable Rx remote command */

 Default: Don't issue remote command */

 Default: HPNA NoiseFloor */

static u8 SF_mode;		/* Special Function: 1:VLAN, 2:RX Flow Control

 function declaration ------------------------------------- */

 DM910X network board routine ---------------------------- */

/*

 *	Search DM910X board ,allocate space and register it

 board information structure */

	/*

	 *	SPARC on-board DM910x chips should be handled by the main

	 *	tulip driver, except for early DM9100s.

 Init network device */

 Enable Master/IO access, Disable memory access */

 pci_{enable_device,set_master} sets minimum latency for us now */

 Set Latency Timer 80h */

	/* FIXME: setting values > 32 breaks some SiS 559x stuff.

 Init system & device */

 Allocate Tx/Rx descriptor memory */

 IO type range. */

 DM9102A E3 */

 read 64 word srom data */

 Set Node address */

 free board information */

/*

 *	Open the interface.

 *	The interface is opened whenever "ifconfig" actives it.

 system variable init */

 All capability*/

 CR6 operation mode decision */

 Enter the normal mode */

 Store & Forward mode */

 Enter the check mode */

 Initialize DM910X board */

 Active System Interface */

 set and active a timer process */

/*	Initialize DM910X board

 *	Reset DM910X board

 *	Initialize TX/Rx descriptor chain structure

 *	Send the set-up frame

 *	Enable Tx/Rx machine

 Reset DM910x MAC controller */

 RESET MAC */

 Phy addr : DM910(A)2/DM9132/9801, phy address = 1 */

 Parser SROM and media mode */

 RESET Phyxcer Chip by GPR port bit 7 */

 Let bit 7 output port */

 Issue RESET signal */

 Delay 300 ms */

 Clear RESET signal */

 Process Phyxcer Media Mode */

 Force 1M mode */

 Media Mode Process */

 Force Mode */

 Initialize Transmit/Receive descriptor and CR3/4 */

 Init CR6 to program DM910x operation */

 Send setup frame */

 DM9132 */

 DM9102/DM9102A */

 Init CR7, interrupt active bit */

 Init CR15, Tx jabber and Rx watchdog timer */

 Enable DM910X Tx/Rx function */

/*

 *	Hardware start transmission.

 *	Send a packet to media from the upper layer.

 Too large packet check */

 Resource flag check */

 No Tx resource check, it never happen nromally */

 Disable NIC interrupt */

 transmit this packet */

 Point to next transmit free descriptor */

 Transmit Packet Process */

 Set owner bit */

 Ready to send */

 Issue Tx polling */

 saved time stamp */

 queue TX packet */

 Issue Tx polling */

 Tx resource check */

 Restore CR7 to enable interrupt */

 free this SKB */

/*

 *	Stop the interface.

 *	The interface is stopped when it is brought.

 disable system */

 deleted timer */

 Reset & stop DM910X board */

 free interrupt */

 free allocated rx buffer */

 show statistic counter */

/*

 *	DM9102 insterrupt handler

 *	receive the packet to upper layer, free the transmitted packet

 Got DM910X status */

 Disable all interrupt in CR7 to solve the interrupt edge problem */

 Check system status */

 system bus error happen */

 Need to RESET */

 Received the coming packet */

 reallocate rx descriptor buffer */

 Free the transmitted descriptor */

 Mode Check */

 Restore CR7 to enable interrupt mask */

/*

 * Polling 'interrupt' - used by things like netconsole to send skbs

 * without having to re-enable interrupts. It's not called while

 * the interrupt routine is executing.

	/* disable_irq here is not very nice, but with the lockless

/*

 *	Free TX resource after TX complete

 A packet sent completed */

 Transmit statistic counter */

 UnderRun */

 End of while */

 Update TX remove pointer to next */

 Send the Tx packet in queue */

 Set owner bit */

 Ready to send */

 Issue Tx polling */

 saved time stamp */

 Resource available check */

 Active upper layer, send again */

/*

 *	Calculate the CRC valude of the Rx packet

 *	flag = 	1 : return the reverse CRC (for the received packet CRC)

 *		0 : return the normal CRC (for Hash Table index)

/*

 *	Receive the come packet and pass to upper layer

 packet owner check */

 A packet without First/Last flag */

 reuse this SKB */

 A packet with First/Last flag */

 error summary bit check */

 This is a error packet */

 Received Packet CRC check need or not */

 FIXME (?) */

 Found a error received packet */

 Good packet, send to upper layer */

 Shorst packet used new SKB */

 size less than COPY_SIZE, allocate a rxlen SKB */

 16byte align */

 Reuse SKB buffer when the packet is error */

/*

 * Set DM910X multicast address

 DM9132 */

 DM9102/DM9102A */

/*

 * 	Ethtool interace

/*

 *	A periodic timer routine

 *	Dynamic media sense, allocate Rx buffer...

 Media mode process when Link OK before enter this route */

 Operating Mode Check */

 Dynamic reset DM910X : system error or transmit time-out */

 TX polling kick monitor */

 Tx polling again */

 TX Timeout */

 Link status check, Dynamic media type change */

 DM9132 */

 DM9102/DM9102A */

 DM9102A Chip */

		/*0x43 is used instead of 0x3 because bit 6 should represent

	/* If chip reports that link is failed it could be because external

		PHY link status pin is not connected correctly to chip

		To be sure ask PHY too.

 need a dummy read because of PHY's register latch*/

 Link Failed */

 For Force 10/100M Half/Full mode: Enable Auto-Nego mode */

 AUTO or force 1M Homerun/Longrun don't need */

 AUTO mode, if INT phyxcer link failed, select EXT device */

 10/100M link failed, used 1M Home-Net */

 bit18=1, MII */

 bit9=0, HD mode */

 Auto Sense Speed */

 HPNA remote command check */

 Timer active again */

/*

 *	Dynamic reset the DM910X board

 *	Stop DM910X board

 *	Free Tx/Rx allocated memory

 *	Reset DM910X board

 *	Re-initialize DM910X board

 Sopt MAC controller */

 Disable Tx/Rx */

 Disable Interrupt */

 Disable upper layer interface */

 Free Rx Allocate buffer */

 system variable init */

 Re-initialize DM910X board */

 Restart upper layer interface */

/*

 *	free all allocated rx buffer

 free allocated rx buffer */

/*

 *	Reuse the SK buffer

/*

 *	Initialize transmit/Receive descriptor

 *	Using Chain structure, and allocate Tx/Rx buffer

 tx descriptor start pointer */

 TX DESC address */

 rx descriptor start pointer */

 RX DESC address */

 Init Transmit chain */

 IC, chain */

 Init Receive descriptor chain */

 pre-allocate Rx buffer */

/*

 *	Update CR6 value

 *	Firstly stop DM910X , then written value and start

 stop Tx/Rx */

/*

 *	Send a setup frame for DM9132

 *	This setup frame initialize DM910X address filter mode

 Node address */

 Clear Hash Table */

 broadcast address */

 the multicast address in Hash Table : 64 bits */

 Write the hash table to MAC MD table */

/*

 *	Send a setup frame for DM9102/DM9102A

 *	This setup frame initialize DM910X address filter mode

 Node address */

 broadcast address */

 fit the multicast address */

 prepare the setup frame */

 Resource Check and Send the setup packet */

 Resource Empty */

 Issue Tx polling */

 Put in TX queue */

/*

 *	Allocate rx buffer,

 *	As possible as allocate maxiumn Rx buffer

 FIXME (?) */

/*

 *	Read one word data from the serial ROM

 Send the Read Command 110b */

 Send the offset */

/*

 *	Auto sense the media mode

 CR6 bit18=0, select 10/100M */

 DM9132 */

 DM9102/DM9102A */

/*

 *	Set 10/100 phyxcer capability

 *	AUTO mode : phyxcer register4 is NIC capability

 *	Force mode: phyxcer register4 is the force media

 Select 10/100M phyxcer */

 DM9009 Chip: Phyxcer reg18 bit12=0 */

 Phyxcer capability setting */

 AUTO Mode */

 Force Mode */

 Write new capability to Phyxcer Reg4 */

 Restart Auto-Negotiation */

/*

 *	Process op-mode

 *	AUTO mode : PHY controller in Auto-negotiation Mode

 *	Force mode: PHY controller in force mode with HUB

 *			N-way force capability with SWITCH

 Full Duplex Mode Check */

 Set Full Duplex Bit */

 Clear Full Duplex Bit */

 Transciver Selection */

 1M HomePNA */

 External MII select */

 Internal 10/100 transciver */

 10/100M phyxcer force mode need */

 Forece Mode */

 parter without N-Way capability */

/*

 *	Write a word to Phy register

 DM9102/DM9102A Chip */

 Send 33 synchronization clock to Phy controller */

 Send start command(01) to Phy */

 Send write command(01) to Phy */

 Send Phy address */

 Send register address */

 written trasnition */

 Write a word data to PHY controller */

/*

 *	Read a word data from phy register

 DM9132 Chip */

 DM9102/DM9102A Chip */

 Send 33 synchronization clock to Phy controller */

 Send start command(01) to Phy */

 Send read command(10) to Phy */

 Send Phy address */

 Send register address */

 Skip transition state */

 read 16bit data */

/*

 *	Write one bit data to Phy Controller

 MII Clock Low */

 MII Clock High */

 MII Clock Low */

/*

 *	Read one bit phy data from PHY controller

/*

 *	Parser SROM and media mode

 Init CR15 */

 Check SROM Version */

 SROM V4.01 */

 Get NIC support media mode */

 Media Mode Force or not check */

 100MHF */

 10MFD */

 100MFD */

 HomePNA */

 Special Function setting */

 VLAN function */

 Flow Control */

 TX pause packet */

 Parse HPNA parameter */

 Accept remote command or not */

 Issue remote command & operation mode */

 Issue Remote Command */

 Don't Issue */

 Check DM9801 or DM9802 present or not */

 DM9801 or DM9802 present */

 DM9801 HomeRun */

 DM9802 LongRun */

/*

 *	Init HomeRun DM9801

 DM9801 E3 */

 DM9801 E4 */

 DM9801 E5 */

 DM9801 E6 */

/*

 *	Init HomeRun DM9802

/*

 *	Check remote HPNA power and speed status. If not correct,

 *	issue command again.

 Got remote device status */

 LP/LS */

 LP/HS */

 HP/LS */

 HP/HS */

 Check remote device status match our setting ot not */

 Match, every 10 minutes, check */

 Disable upper layer interface */

 Disable Tx/Rx */

 Disable Interrupt */

 Fre RX buffers */

 Enable WOL */

 Re-initialize DM910X board */

 Disable WOL */

 Restart upper layer interface */

/*	Description:

 *	when user used insmod to add module, system invoked init_module()

 *	to initialize and register.

 set debug flag */

 Default: LP/HS */

 Default: Ignored remote cmd */

 Default: Don't issue remote cmd */

/*

 *	Description:

 *	when user used rmmod to delete module, system invoked clean_module()

 *	to un-register all registered services.

/*

	drivers/net/ethernet/dec/tulip/21142.c



	Copyright 2000,2001  The Linux Kernel Team

	Written/copyright 1994-2001 by Donald Becker.



	This software may be used and distributed according to the terms

	of the GNU General Public License, incorporated herein by reference.



	DC21143 manual "21143 PCI/CardBus 10/100Mb/s Ethernet LAN Controller

	Hardware Reference Manual" is currently available at :

	http://developer.intel.com/design/network/manuals/278074.htm



	Please submit bugs to http://bugzilla.kernel.org/ .

/* Handle the 21143 uniquely: do autoselect with NWay, not the EEPROM list

 CSR12[LS10,LS100] are not reliable during autonegotiation */

 Don't screw up a negotiated session! */

 No 100mbps link beat, revert to 10mbps. */

 Negotiation failed.  Search media types. */

 10mbps link beat good. */

 Select 100mbps port to check for link beat. */

	/* mod_timer synchronizes us with potential add_timer calls

	 * from interrupts.

 Trigger NWAY. */

 CSR12[LS10,LS100] are not reliable during autonegotiation */

 If NWay finished and we have a negotiated partner capability. */

 If partner cannot negotiate, it is 10Mbps Half Duplex */

 Restart shouldn't be needed. */

 Link blew? Maybe restart NWay. */

 10mbps link beat good. */

 100mbps link beat good. */

 SPDX-License-Identifier: GPL-2.0-or-later

/*





 Board/System/Debug information/definition ---------------- */

 ULi M5261 ID*/

 ULi M5263 ID*/

 Allocated Tx descriptors */

 Allocated Rx descriptors */

 Max TX packet count */

 TX wakeup count */

 TxJabber RxWatchdog */

 TXJT, LC, EC, FUE */

 TX TH 72 byte */

 TX TH 96 byte */

 TX TH 128 byte */

 TX TH 256 byte */

 TX TH 512 byte */

 TX TH 1K  byte */

 timer wakeup time : 1 second */

 tx packet time-out time 8 s" */

 tx packet Kick-out time 2 s" */

 CR9 definition: SROM/MII */

 Structure/enum declaration ------------------------------- */

 Data for the card */

 Data for us */

 Data for the card */

 Data for us */

 next device */

 PCI device */

 I/O base address */

 pointer for memory physical address */

 Tx buffer pool memory */

 Tx buffer pool align dword */

 descriptor pool memory */

 descriptor pointer */

 Tx buffer pool memory */

 Tx buffer pool align dword */

 descriptor pool memory */

 packet come pointer */

 transmitted packet count */

 available rx descriptor count */

 rx packet count a callback time */

 NIC media capability */

 Saved Phyxcer register 4 value */

 user specify media mode */

 real work media mode */

 Ever link failed */

 Hardware failed, need to reset */

 Driver defined statistic counter */

 NIC SROM data */

 Global variable declaration ----------------------------- */

 For module input parameter */

 function declaration ------------------------------------- */

 ULI526X network board routine ---------------------------- */

/*

 *	Search ULI526X board, allocate space and register it

 board information structure */

 Init network device */

 Enable Master/IO access, Disable memory access */

 Init system & device */

 Allocate Tx/Rx descriptor memory */

 IO region. */

 Register some necessary functions */

 read 64 word srom data */

 Set Node address */

 SROM absent, so read MAC address from ID Table */

Diagnosis mode

Reset dianostic pointer port

Clear reset port

Reset ID Table pointer

Clear reset port

Clear CR13

Select ID Table access port

Read MAC address from CR14

Read end

Clear CR13

Clear CR0

Exist SROM*/

/*

 *	Open the interface.

 *	The interface is opened whenever "ifconfig" activates it.

 system variable init */

 All capability*/

 CR6 operation mode decision */

 Initialize ULI526X board */

 Active System Interface */

 set and active a timer process */

/*	Initialize ULI526X board

 *	Reset ULI526X board

 *	Initialize TX/Rx descriptor chain structure

 *	Send the set-up frame

 *	Enable Tx/Rx machine

 Reset M526x MAC controller */

 RESET MAC */

 Phy addr : In some boards,M5261/M5263 phy address != 1 */

peer add

 Parser SROM and media mode */

 phyxcer capability setting */

	/* See IEEE 802.3-2002.pdf (Section 2, Chapter "22.2.4 Management

	 * functions") or phy data sheet for details on phy reset

 Process Phyxcer Media Mode */

 Media Mode Process */

 Force Mode */

 Initialize Transmit/Receive descriptor and CR3/4 */

 Init CR6 to program M526X operation */

 Send setup frame */

 M5261/M5263 */

 Init CR7, interrupt active bit */

 Init CR15, Tx jabber and Rx watchdog timer */

 Enable ULI526X Tx/Rx function */

/*

 *	Hardware start transmission.

 *	Send a packet to media from the upper layer.

 Resource flag check */

 Too large packet check */

 No Tx resource check, it never happen nromally */

 Disable NIC interrupt */

 transmit this packet */

 Point to next transmit free descriptor */

 Transmit Packet Process */

 Set owner bit */

 Ready to send */

 Issue Tx polling */

 saved time stamp */

 Tx resource check */

 Restore CR7 to enable interrupt */

 free this SKB */

/*

 *	Stop the interface.

 *	The interface is stopped when it is brought.

 disable system */

 deleted timer */

 Reset & stop ULI526X board */

 free interrupt */

 free allocated rx buffer */

/*

 *	M5261/M5263 insterrupt handler

 *	receive the packet to upper layer, free the transmitted packet

 Got ULI526X status */

 Restore CR7 to enable interrupt mask */

 Check system status */

 system bus error happen */

 Need to RESET */

 Received the coming packet */

 reallocate rx descriptor buffer */

 Free the transmitted descriptor */

 Restore CR7 to enable interrupt mask */

 ISR grabs the irqsave lock, so this should be safe */

/*

 *	Free TX resource after TX complete

 A packet sent completed */

 Transmit statistic counter */

 UnderRun */

 End of while */

 Update TX remove pointer to next */

 Resource available check */

 Active upper layer, send again */

/*

 *	Receive the come packet and pass to upper layer

 packet owner check */

 A packet without First/Last flag */

 reuse this SKB */

 A packet with First/Last flag */

 error summary bit check */

 This is a error packet */

 Good packet, send to upper layer */

 Shorst packet used new SKB */

 size less than COPY_SIZE, allocate a rxlen SKB */

 16byte align */

 Reuse SKB buffer when the packet is error */

/*

 * Set ULI526X multicast address

 M5261/M5263 */

/*

 *	A periodic timer routine

 *	Dynamic media sense, allocate Rx buffer...

ULI526X_DBUG(0, "uli526x_timer()", 0);

 Dynamic reset ULI526X : system error or transmit time-out */

 TX polling kick monitor */

 Tx polling again

 TX Timeout

 Link status check, Dynamic media type change */

 Link Failed */

 For Force 10/100M Half/Full mode: Enable Auto-Nego mode */

 AUTO don't need */

 AUTO mode, if INT phyxcer link failed, select EXT device */

 bit9=0, HD mode */

 Auto Sense Speed */

 SHOW_MEDIA_TYPE(db->op_mode); */

 Timer active again */

/*

 *	Stop ULI526X board

 *	Free Tx/Rx allocated memory

 *	Init system variable

 Sopt MAC controller */

 Disable Tx/Rx */

 Disable Interrupt */

 Disable upper layer interface */

 Free Rx Allocate buffer */

 system variable init */

/*

 *	Dynamic reset the ULI526X board

 *	Stop ULI526X board

 *	Free Tx/Rx allocated memory

 *	Reset ULI526X board

 *	Re-initialize ULI526X board

 Re-initialize ULI526X board */

 Restart upper layer interface */

/*

 *	Suspend the interface.

/*

 *	Resume the interface.

 Re-initialize ULI526X board */

 Restart upper layer interface */

/*

 *	free all allocated rx buffer

 free allocated rx buffer */

/*

 *	Reuse the SK buffer

/*

 *	Initialize transmit/Receive descriptor

 *	Using Chain structure, and allocate Tx/Rx buffer

 tx descriptor start pointer */

 TX DESC address */

 rx descriptor start pointer */

 RX DESC address */

 Init Transmit chain */

 IC, chain */

 Init Receive descriptor chain */

 pre-allocate Rx buffer */

/*

 *	Update CR6 value

 *	Firstly stop ULI526X, then written value and start

/*

 *	Send a setup frame for M5261/M5263

 *	This setup frame initialize ULI526X address filter mode

 Node address */

 broadcast address */

 fit the multicast address */

 prepare the setup frame */

 Resource Check and Send the setup packet */

 Resource Empty */

 Issue Tx polling */

/*

 *	Allocate rx buffer,

 *	As possible as allocate maxiumn Rx buffer

 FIXME (?) */

/*

 *	Read one word data from the serial ROM

 Send the Read Command 110b */

 Send the offset */

/*

 *	Auto sense the media mode

/*

 *	Set 10/100 phyxcer capability

 *	AUTO mode : phyxcer register4 is NIC capability

 *	Force mode: phyxcer register4 is the force media

 Phyxcer capability setting */

 AUTO Mode */

 Force Mode */

 Write new capability to Phyxcer Reg4 */

 Restart Auto-Negotiation */

/*

 *	Process op-mode

	AUTO mode : PHY controller in Auto-negotiation Mode

 *	Force mode: PHY controller in force mode with HUB

 *			N-way force capability with SWITCH

 Full Duplex Mode Check */

 Set Full Duplex Bit */

 Clear Full Duplex Bit */

 10/100M phyxcer force mode need */

 Forece Mode */

 parter without N-Way capability */

 M5261/M5263 Chip */

 Send 33 synchronization clock to Phy controller */

 Send start command(01) to Phy */

 Send write command(01) to Phy */

 Send Phy address */

 Send register address */

 written trasnition */

 Write a word data to PHY controller */

 Send 33 synchronization clock to Phy controller */

 Send start command(01) to Phy */

 Send read command(10) to Phy */

 Send Phy address */

 Send register address */

 Skip transition state */

 read 16bit data */

/*

 *	Write one bit data to Phy Controller

 MII Clock Low */

 MII Clock High */

 MII Clock Low */

/*

 *	Read one bit phy data from PHY controller

/*	Description:

 *	when user used insmod to add module, system invoked init_module()

 *	to register the services.

 set debug flag */

/*

 *	Description:

 *	when user used rmmod to delete module, system invoked clean_module()

 *	to un-register all registered services.

/*

	drivers/net/ethernet/dec/tulip/media.c



	Copyright 2000,2001  The Linux Kernel Team

	Written/copyright 1994-2001 by Donald Becker.



	This software may be used and distributed according to the terms

	of the GNU General Public License, incorporated herein by reference.



	Please submit bugs to http://bugzilla.kernel.org/ .

/* The maximum data clock rate is 2.5 Mhz.  The minimum timing is usually

   met by back-to-back PCI I/O cycles, but we insert a delay to avoid

/* Read and write the MII registers using software-generated serial

   MDIO protocol.  It is just different enough from the EEPROM protocol

 Ignore the 0x02000 databook setting. */

/* MII transceiver control section.

   Read and write the MII registers using software-generated serial

   MDIO protocol.

   See IEEE 802.3-2002.pdf (Section 2, Chapter "22.2.4 Management functions")

   or DP83840A data sheet for more details.

 Establish sync by sending at least 32 logic ones. */

 Shift the read command bits out. */

 Read the two transition, 16 data, and wire-idle bits. */

 Establish sync by sending 32 logic ones. */

 Shift the command bits out. */

 Clear out extra bits. */

 Set up the transceiver control registers for the selected media type. */

 21140 non-MII xcvr. */

 SIA (CSR13-15) setup values are provided. */

 Direction */

 Data */

 Direction */

 Data */

 21142 */

 max 1 ms */

 flush posted writes */

 Sect 3.10.3 in DP83840A.pdf (p39) */

 Section 4.2 in DP83840A.pdf (p43) */

 and IEEE 802.3 "22.2.4.1.1 Reset" */

 flush posted writes */

 max 1 ms */

 flush posted writes */

 Sect 3.10.3 in DP83840A.pdf (p39) */

 Section 4.2 in DP83840A.pdf (p43) */

 and IEEE 802.3 "22.2.4.1.1 Reset" */

 flush posted writes */

 FIXME */

 Start with 10mbps to do autonegotiation. */

 Trigger autonegotiation. */

 Unknown chip type with no media table. */

/*

  Check the MII negotiated duplex and change the CSR6 setting if

  required.

  Return 0 if everything is OK.

  Return < 0 if the transceiver is missing or has no link beat.

	/* Find the connected MII xcvrs.

	   Doing this in open() would allow detecting external xcvrs later,

 preserve Becker logic, gain indentation level */

		/* if not advertising at all, gen an

		 * advertising value from the capability

		 * bits in BMSR

 Fixup for DLink with miswired PHY. */

 Enable autonegotiation: some boards default to off. */

 ...or disable nway, if forcing media */

 clear out bits we never want at this point */

			/* some phys need the ANE switch to

			 * happen before forced media settings

			 * will "take."  However, we write the

			 * same value twice in order not to

			 * confuse the sane phys.

/*  de4x5.c: A DIGITAL DC21x4x DECchip and DE425/DE434/DE435/DE450/DE500

             ethernet driver for Linux.



    Copyright 1994, 1995 Digital Equipment Corporation.



    Testing resources for this driver have been made available

    in part by NASA Ames Research Center (mjacob@nas.nasa.gov).



    The author may be reached at davies@maniac.ultranet.com.



    This program is free software; you can redistribute  it and/or modify it

    under  the terms of  the GNU General  Public License as published by the

    Free Software Foundation;  either version 2 of the  License, or (at your

    option) any later version.



    THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR   IMPLIED

    WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF

    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN

    NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT,  INDIRECT,

    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT

    NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF

    USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON

    ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT

    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF

    THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.



    You should have received a copy of the  GNU General Public License along

    with this program; if not, write  to the Free Software Foundation, Inc.,

    675 Mass Ave, Cambridge, MA 02139, USA.



    Originally,   this  driver  was    written  for the  Digital   Equipment

    Corporation series of EtherWORKS ethernet cards:



        DE425 TP/COAX EISA

	DE434 TP PCI

	DE435 TP/COAX/AUI PCI

	DE450 TP/COAX/AUI PCI

	DE500 10/100 PCI Fasternet



    but it  will  now attempt  to  support all  cards which   conform to the

    Digital Semiconductor   SROM   Specification.    The  driver   currently

    recognises the following chips:



        DC21040  (no SROM)

	DC21041[A]

	DC21140[A]

	DC21142

	DC21143



    So far the driver is known to work with the following cards:



        KINGSTON

	Linksys

	ZNYX342

	SMC8432

	SMC9332 (w/new SROM)

	ZNYX31[45]

	ZNYX346 10/100 4 port (can act as a 10/100 bridge!)



    The driver has been tested on a relatively busy network using the DE425,

    DE434, DE435 and DE500 cards and benchmarked with 'ttcp': it transferred

    16M of data to a DECstation 5000/200 as follows:



                TCP           UDP

             TX     RX     TX     RX

    DE425   1030k  997k   1170k  1128k

    DE434   1063k  995k   1170k  1125k

    DE435   1063k  995k   1170k  1125k

    DE500   1063k  998k   1170k  1125k  in 10Mb/s mode



    All  values are typical (in   kBytes/sec) from a  sample  of 4 for  each

    measurement. Their error is +/-20k on a quiet (private) network and also

    depend on what load the CPU has.



    =========================================================================

    This driver  has been written substantially  from  scratch, although its

    inheritance of style and stack interface from 'ewrk3.c' and in turn from

    Donald Becker's 'lance.c' should be obvious. With the module autoload of

    every  usable DECchip board,  I  pinched Donald's 'next_module' field to

    link my modules together.



    Up to 15 EISA cards can be supported under this driver, limited primarily

    by the available IRQ lines.  I have  checked different configurations of

    multiple depca, EtherWORKS 3 cards and de4x5 cards and  have not found a

    problem yet (provided you have at least depca.c v0.38) ...



    PCI support has been added  to allow the driver  to work with the DE434,

    DE435, DE450 and DE500 cards. The I/O accesses are a bit of a kludge due

    to the differences in the EISA and PCI CSR address offsets from the base

    address.



    The ability to load this  driver as a loadable  module has been included

    and used extensively  during the driver development  (to save those long

    reboot sequences).  Loadable module support  under PCI and EISA has been

    achieved by letting the driver autoprobe as if it were compiled into the

    kernel. Do make sure  you're not sharing  interrupts with anything  that

    cannot accommodate  interrupt  sharing!



    To utilise this ability, you have to do 8 things:



    0) have a copy of the loadable modules code installed on your system.

    1) copy de4x5.c from the  /linux/drivers/net directory to your favourite

    temporary directory.

    2) for fixed  autoprobes (not  recommended),  edit the source code  near

    line 5594 to reflect the I/O address  you're using, or assign these when

    loading by:



                   insmod de4x5 io=0xghh           where g = bus number

		                                        hh = device number



       NB: autoprobing for modules is now supported by default. You may just

           use:



                   insmod de4x5



           to load all available boards. For a specific board, still use

	   the 'io=?' above.

    3) compile  de4x5.c, but include -DMODULE in  the command line to ensure

    that the correct bits are compiled (see end of source code).

    4) if you are wanting to add a new  card, goto 5. Otherwise, recompile a

    kernel with the de4x5 configuration turned off and reboot.

    5) insmod de4x5 [io=0xghh]

    6) run the net startup bits for your new eth?? interface(s) manually

    (usually /etc/rc.inet[12] at boot time).

    7) enjoy!



    To unload a module, turn off the associated interface(s)

    'ifconfig eth?? down' then 'rmmod de4x5'.



    Automedia detection is included so that in  principal you can disconnect

    from, e.g.  TP, reconnect  to BNC  and  things will still work  (after a

    pause whilst the   driver figures out   where its media went).  My tests

    using ping showed that it appears to work....



    By  default,  the driver will  now   autodetect any  DECchip based card.

    Should you have a need to restrict the driver to DIGITAL only cards, you

    can compile with a  DEC_ONLY define, or if  loading as a module, use the

    'dec_only=1'  parameter.



    I've changed the timing routines to  use the kernel timer and scheduling

    functions  so that the  hangs  and other assorted problems that occurred

    while autosensing the  media  should be gone.  A  bonus  for the DC21040

    auto  media sense algorithm is  that it can now  use one that is more in

    line with the  rest (the DC21040  chip doesn't  have a hardware  timer).

    The downside is the 1 'jiffies' (10ms) resolution.



    IEEE 802.3u MII interface code has  been added in anticipation that some

    products may use it in the future.



    The SMC9332 card  has a non-compliant SROM  which needs fixing -  I have

    patched this  driver to detect it  because the SROM format used complies

    to a previous DEC-STD format.



    I have removed the buffer copies needed for receive on Intels.  I cannot

    remove them for   Alphas since  the  Tulip hardware   only does longword

    aligned  DMA transfers  and  the  Alphas get   alignment traps with  non

    longword aligned data copies (which makes them really slow). No comment.



    I  have added SROM decoding  routines to make this  driver work with any

    card that  supports the Digital  Semiconductor SROM spec. This will help

    all  cards running the dc2114x  series chips in particular.  Cards using

    the dc2104x  chips should run correctly with  the basic  driver.  I'm in

    debt to <mjacob@feral.com> for the  testing and feedback that helped get

    this feature working.  So far we have  tested KINGSTON, SMC8432, SMC9332

    (with the latest SROM complying  with the SROM spec  V3: their first was

    broken), ZNYX342  and  LinkSys. ZYNX314 (dual  21041  MAC) and  ZNYX 315

    (quad 21041 MAC)  cards also  appear  to work despite their  incorrectly

    wired IRQs.



    I have added a temporary fix for interrupt problems when some SCSI cards

    share the same interrupt as the DECchip based  cards. The problem occurs

    because  the SCSI card wants to  grab the interrupt  as a fast interrupt

    (runs the   service routine with interrupts turned   off) vs.  this card

    which really needs to run the service routine with interrupts turned on.

    This driver will  now   add the interrupt service   routine  as  a  fast

    interrupt if it   is bounced from the   slow interrupt.  THIS IS NOT   A

    RECOMMENDED WAY TO RUN THE DRIVER  and has been done  for a limited time

    until  people   sort  out their  compatibility    issues and the  kernel

    interrupt  service code  is  fixed.   YOU  SHOULD SEPARATE OUT  THE FAST

    INTERRUPT CARDS FROM THE SLOW INTERRUPT CARDS to ensure that they do not

    run on the same interrupt. PCMCIA/CardBus is another can of worms...



    Finally, I think  I have really  fixed  the module  loading problem with

    more than one DECchip based  card.  As a  side effect, I don't mess with

    the  device structure any  more which means that  if more than 1 card in

    2.0.x is    installed (4  in   2.1.x),  the  user   will have   to  edit

    linux/drivers/net/Space.c  to make room for  them. Hence, module loading

    is  the preferred way to use   this driver, since  it  doesn't have this

    limitation.



    Where SROM media  detection is used and  full duplex is specified in the

    SROM,  the feature is  ignored unless  lp->params.fdx  is set at compile

    time  OR during  a   module load  (insmod  de4x5   args='eth??:fdx' [see

    below]).  This is because there  is no way  to automatically detect full

    duplex   links  except through   autonegotiation.    When I  include the

    autonegotiation feature in  the SROM autoconf  code, this detection will

    occur automatically for that case.



    Command  line arguments are  now  allowed, similar  to passing arguments

    through LILO. This will allow a per adapter board  set up of full duplex

    and media. The only lexical constraints  are: the board name (dev->name)

    appears in the list before its  parameters.  The list of parameters ends

    either at the end of the parameter list or with another board name.  The

    following parameters are allowed:



            fdx        for full duplex

	    autosense  to set the media/speed; with the following

	               sub-parameters:

		       TP, TP_NW, BNC, AUI, BNC_AUI, 100Mb, 10Mb, AUTO



    Case sensitivity is important  for  the sub-parameters. They *must*   be

    upper case. Examples:



        insmod de4x5 args='eth1:fdx autosense=BNC eth0:autosense=100Mb'.



    For a compiled in driver, at or above line 548, place e.g.

	#define DE4X5_PARM "eth0:fdx autosense=AUI eth2:autosense=TP"



    Yes,  I know full duplex isn't  permissible on BNC  or AUI; they're just

    examples. By default, full duplex is turned off and  AUTO is the default

    autosense setting.  In reality, I expect only  the full duplex option to

    be used. Note the use of single quotes in the two examples above and the

    lack of commas to separate items. ALSO, you must get the requested media

    correct in relation to what the adapter SROM says it has. There's no way

    to  determine this in  advance other than by  trial and error and common

    sense, e.g. call a BNC connectored port 'BNC', not '10Mb'.



    Changed the bus probing.  EISA used to be  done first,  followed by PCI.

    Most people probably don't even know  what a de425 is today and the EISA

    probe has messed  up some SCSI cards  in the past,  so now PCI is always

    probed  first  followed by  EISA if  a) the architecture allows EISA and

    either  b) there have been no PCI cards detected or  c) an EISA probe is

    forced by  the user.  To force  a probe  include  "force_eisa"  in  your

    insmod "args" line;  for built-in kernels either change the driver to do

    this  automatically  or include  #define DE4X5_FORCE_EISA  on or  before

    line 1040 in the driver.



    TO DO:

    ------



    Revision History

    ----------------



    Version   Date        Description



      0.1     17-Nov-94   Initial writing. ALPHA code release.

      0.2     13-Jan-95   Added PCI support for DE435's.

      0.21    19-Jan-95   Added auto media detection.

      0.22    10-Feb-95   Fix interrupt handler call <chris@cosy.sbg.ac.at>.

                          Fix recognition bug reported by <bkm@star.rl.ac.uk>.

			  Add request/release_region code.

			  Add loadable modules support for PCI.

			  Clean up loadable modules support.

      0.23    28-Feb-95   Added DC21041 and DC21140 support.

                          Fix missed frame counter value and initialisation.

			  Fixed EISA probe.

      0.24    11-Apr-95   Change delay routine to use <linux/udelay>.

                          Change TX_BUFFS_AVAIL macro.

			  Change media autodetection to allow manual setting.

			  Completed DE500 (DC21140) support.

      0.241   18-Apr-95   Interim release without DE500 Autosense Algorithm.

      0.242   10-May-95   Minor changes.

      0.30    12-Jun-95   Timer fix for DC21140.

                          Portability changes.

			  Add ALPHA changes from <jestabro@ant.tay1.dec.com>.

			  Add DE500 semi automatic autosense.

			  Add Link Fail interrupt TP failure detection.

			  Add timer based link change detection.

			  Plugged a memory leak in de4x5_queue_pkt().

      0.31    13-Jun-95   Fixed PCI stuff for 1.3.1.

      0.32    26-Jun-95   Added verify_area() calls in de4x5_ioctl() from a

                          suggestion by <heiko@colossus.escape.de>.

      0.33     8-Aug-95   Add shared interrupt support (not released yet).

      0.331   21-Aug-95   Fix de4x5_open() with fast CPUs.

                          Fix de4x5_interrupt().

                          Fix dc21140_autoconf() mess.

			  No shared interrupt support.

      0.332   11-Sep-95   Added MII management interface routines.

      0.40     5-Mar-96   Fix setup frame timeout <maartenb@hpkuipc.cern.ch>.

                          Add kernel timer code (h/w is too flaky).

			  Add MII based PHY autosense.

			  Add new multicasting code.

			  Add new autosense algorithms for media/mode

			  selection using kernel scheduling/timing.

			  Re-formatted.

			  Made changes suggested by <jeff@router.patch.net>:

			    Change driver to detect all DECchip based cards

			    with DEC_ONLY restriction a special case.

			    Changed driver to autoprobe as a module. No irq

			    checking is done now - assume BIOS is good!

			  Added SMC9332 detection <manabe@Roy.dsl.tutics.ac.jp>

      0.41    21-Mar-96   Don't check for get_hw_addr checksum unless DEC card

                          only <niles@axp745gsfc.nasa.gov>

			  Fix for multiple PCI cards reported by <jos@xos.nl>

			  Duh, put the IRQF_SHARED flag into request_interrupt().

			  Fix SMC ethernet address in enet_det[].

			  Print chip name instead of "UNKNOWN" during boot.

      0.42    26-Apr-96   Fix MII write TA bit error.

                          Fix bug in dc21040 and dc21041 autosense code.

			  Remove buffer copies on receive for Intels.

			  Change sk_buff handling during media disconnects to

			   eliminate DUP packets.

			  Add dynamic TX thresholding.

			  Change all chips to use perfect multicast filtering.

			  Fix alloc_device() bug <jari@markkus2.fimr.fi>

      0.43   21-Jun-96    Fix unconnected media TX retry bug.

                          Add Accton to the list of broken cards.

			  Fix TX under-run bug for non DC21140 chips.

			  Fix boot command probe bug in alloc_device() as

			   reported by <koen.gadeyne@barco.com> and

			   <orava@nether.tky.hut.fi>.

			  Add cache locks to prevent a race condition as

			   reported by <csd@microplex.com> and

			   <baba@beckman.uiuc.edu>.

			  Upgraded alloc_device() code.

      0.431  28-Jun-96    Fix potential bug in queue_pkt() from discussion

                          with <csd@microplex.com>

      0.44   13-Aug-96    Fix RX overflow bug in 2114[023] chips.

                          Fix EISA probe bugs reported by <os2@kpi.kharkov.ua>

			  and <michael@compurex.com>.

      0.441   9-Sep-96    Change dc21041_autoconf() to probe quiet BNC media

                           with a loopback packet.

      0.442   9-Sep-96    Include AUI in dc21041 media printout. Bug reported

                           by <bhat@mundook.cs.mu.OZ.AU>

      0.45    8-Dec-96    Include endian functions for PPC use, from work

                           by <cort@cs.nmt.edu> and <g.thomas@opengroup.org>.

      0.451  28-Dec-96    Added fix to allow autoprobe for modules after

                           suggestion from <mjacob@feral.com>.

      0.5    30-Jan-97    Added SROM decoding functions.

                          Updated debug flags.

			  Fix sleep/wakeup calls for PCI cards, bug reported

			   by <cross@gweep.lkg.dec.com>.

			  Added multi-MAC, one SROM feature from discussion

			   with <mjacob@feral.com>.

			  Added full module autoprobe capability.

			  Added attempt to use an SMC9332 with broken SROM.

			  Added fix for ZYNX multi-mac cards that didn't

			   get their IRQs wired correctly.

      0.51   13-Feb-97    Added endian fixes for the SROM accesses from

			   <paubert@iram.es>

			  Fix init_connection() to remove extra device reset.

			  Fix MAC/PHY reset ordering in dc21140m_autoconf().

			  Fix initialisation problem with lp->timeout in

			   typeX_infoblock() from <paubert@iram.es>.

			  Fix MII PHY reset problem from work done by

			   <paubert@iram.es>.

      0.52   26-Apr-97    Some changes may not credit the right people -

                           a disk crash meant I lost some mail.

			  Change RX interrupt routine to drop rather than

			   defer packets to avoid hang reported by

			   <g.thomas@opengroup.org>.

			  Fix srom_exec() to return for COMPACT and type 1

			   infoblocks.

			  Added DC21142 and DC21143 functions.

			  Added byte counters from <phil@tazenda.demon.co.uk>

			  Added IRQF_DISABLED temporary fix from

			   <mjacob@feral.com>.

      0.53   12-Nov-97    Fix the *_probe() to include 'eth??' name during

                           module load: bug reported by

			   <Piete.Brooks@cl.cam.ac.uk>

			  Fix multi-MAC, one SROM, to work with 2114x chips:

			   bug reported by <cmetz@inner.net>.

			  Make above search independent of BIOS device scan

			   direction.

			  Completed DC2114[23] autosense functions.

      0.531  21-Dec-97    Fix DE500-XA 100Mb/s bug reported by

                           <robin@intercore.com

			  Fix type1_infoblock() bug introduced in 0.53, from

			   problem reports by

			   <parmee@postecss.ncrfran.france.ncr.com> and

			   <jo@ice.dillingen.baynet.de>.

			  Added argument list to set up each board from either

			   a module's command line or a compiled in #define.

			  Added generic MII PHY functionality to deal with

			   newer PHY chips.

			  Fix the mess in 2.1.67.

      0.532   5-Jan-98    Fix bug in mii_get_phy() reported by

                           <redhat@cococo.net>.

                          Fix bug in pci_probe() for 64 bit systems reported

			   by <belliott@accessone.com>.

      0.533   9-Jan-98    Fix more 64 bit bugs reported by <jal@cs.brown.edu>.

      0.534  24-Jan-98    Fix last (?) endian bug from <geert@linux-m68k.org>

      0.535  21-Feb-98    Fix Ethernet Address PROM reset bug for DC21040.

      0.536  21-Mar-98    Change pci_probe() to use the pci_dev structure.

			  **Incompatible with 2.0.x from here.**

      0.540   5-Jul-98    Atomicize assertion of dev->interrupt for SMP

                           from <lma@varesearch.com>

			  Add TP, AUI and BNC cases to 21140m_autoconf() for

			   case where a 21140 under SROM control uses, e.g. AUI

			   from problem report by <delchini@lpnp09.in2p3.fr>

			  Add MII parallel detection to 2114x_autoconf() for

			   case where no autonegotiation partner exists from

			   problem report by <mlapsley@ndirect.co.uk>.

			  Add ability to force connection type directly even

			   when using SROM control from problem report by

			   <earl@exis.net>.

			  Updated the PCI interface to conform with the latest

			   version. I hope nothing is broken...

			  Add TX done interrupt modification from suggestion

			   by <Austin.Donnelly@cl.cam.ac.uk>.

			  Fix is_anc_capable() bug reported by

			   <Austin.Donnelly@cl.cam.ac.uk>.

			  Fix type[13]_infoblock() bug: during MII search, PHY

			   lp->rst not run because lp->ibn not initialised -

			   from report & fix by <paubert@iram.es>.

			  Fix probe bug with EISA & PCI cards present from

                           report by <eirik@netcom.com>.

      0.541  24-Aug-98    Fix compiler problems associated with i386-string

                           ops from multiple bug reports and temporary fix

			   from <paubert@iram.es>.

			  Fix pci_probe() to correctly emulate the old

			   pcibios_find_class() function.

			  Add an_exception() for old ZYNX346 and fix compile

			   warning on PPC & SPARC, from <ecd@skynet.be>.

			  Fix lastPCI to correctly work with compiled in

			   kernels and modules from bug report by

			   <Zlatko.Calusic@CARNet.hr> et al.

      0.542  15-Sep-98    Fix dc2114x_autoconf() to stop multiple messages

                           when media is unconnected.

			  Change dev->interrupt to lp->interrupt to ensure

			   alignment for Alpha's and avoid their unaligned

			   access traps. This flag is merely for log messages:

			   should do something more definitive though...

      0.543  30-Dec-98    Add SMP spin locking.

      0.544   8-May-99    Fix for buggy SROM in Motorola embedded boards using

                           a 21143 by <mmporter@home.com>.

			  Change PCI/EISA bus probing order.

      0.545  28-Nov-99    Further Moto SROM bug fix from

                           <mporter@eng.mcd.mot.com>

                          Remove double checking for DEBUG_RX in de4x5_dbg_rx()

			   from report by <geert@linux-m68k.org>

      0.546  22-Feb-01    Fixes Alpha XP1000 oops.  The srom_search function

                           was causing a page fault when initializing the

                           variable 'pb', on a non de4x5 PCI device, in this

                           case a PCI bridge (DEC chip 21152). The value of

                           'pb' is now only initialized if a de4x5 chip is

                           present.

                           <france@handhelds.org>

      0.547  08-Nov-01    Use library crc32 functions by <Matt_Domsch@dell.com>

      0.548  30-Aug-03    Big 2.6 cleanup. Ported to PCI/EISA probing and

                           generic DMA APIs. Fixed DE425 support on Alpha.

			   <maz@wild-wind.fr.eu.org>

    =========================================================================

 CONFIG_PPC_PMAC */

/*

** MII Information

 Hard reset required?                         */

 IEEE OUI                                     */

 One cycle TA time - 802.3u is confusing here */

 Non autonegotiation (parallel) speed det.    */

 Hard reset required?                      */

 IEEE OUI                                  */

 One cycle TA time                         */

 Non autonegotiation (parallel) speed det. */

 MII address for the PHY                   */

 Start of GEP sequence block in SROM       */

 Start of reset sequence in SROM           */

 Media Capabilities                        */

 NWay Advertisement                        */

 Full DupleX capabilities for each media   */

 Transmit Threshold Mode for each media    */

 21142 MII Connector Interrupt info        */

 Allow up to 8 attached PHY devices per board */

 Media Code                                */

 csr13-15 valid when set                   */

 SIA Connectivity Register                 */

 SIA TX/RX Register                        */

 SIA General Register                      */

 SIA GEP Control Information               */

 SIA GEP Data                              */

/*

** Define the know universe of PHY devices that can be

** recognised by this driver.

 National TX      */

 Broadcom T4      */

 SEEQ T4          */

 Cypress T4       */

 Level One LTX970 */

/*

** These GENERIC values assumes that the PHY devices follow 802.3u and

** allow parallel detection to set the link partner ability register.

** Detection of 100Base-TX [H/F Duplex] and 100Base-T4 is supported.

 Autoneg. Link Partner Advertisement Reg. */

 All 100Mb/s Technologies            */

 100B-TX, 100B-TX FDX, 100B-T4       */

/*

** Define special SROM detection cases

/*

** SROM Repair definitions. If a broken SROM is detected a card may

** use this information to help figure out what to do. This is a

** "stab in the dark" and so far for SMC9332's only.

 SMC9332 */

static int de4x5_debug = (DEBUG_MII | DEBUG_SROM | DEBUG_PCICFG | DEBUG_MEDIA | DEBUG_VERSION);*/

/*

** Allow per adapter set up. For modules this is simply a command line

** parameter, e.g.:

** insmod de4x5 args='eth1:fdx autosense=BNC eth0:autosense=100Mb'.

**

** For a compiled in driver, place e.g.

**     #define DE4X5_PARM "eth0:fdx autosense=AUI eth2:autosense=TP"

** here

 msec autosense tick (DE500) */

 No Device (I/O) Address */

/*

** Ethernet PROM defines

/*

** Ethernet Info

 Buffer size for each Tx/Rx buffer */

 Packet + CRC */

 Maximum ethernet packet length */

 Maximum ethernet data length */

 Minimum ethernet data length */

 Addresses and data length info */

 3 second timeout */

/*

** EISA bus defines

 I/O port base address, slot 0 */

 I/O address extent */

/*

** Ethernet PROM defines for DC21040

/*

** PCI Bus defines

 I/O address extent */

 Network controller, Ethernet */

/*

** Memory Alignment. Each descriptor is 4 longwords long. To force a

** particular alignment on the TX descriptor, adjust DESC_SKIP_LEN and

** DESC_ALIGN. ALIGN aligns the start address of the private memory area

** and hence the RX descriptor ring's first entry.

 1 longword align */

 2 longword align */

 4 longword align */

 8 longword align */

 16 longword align */

 32 longword align */

 Keep the DC21040 happy... */

 Must agree with DESC_ALIGN */

#define DESC_ALIGN    u32 dummy[4];  / * Must agree with DESC_SKIP_LEN */

 See README.de4x5 for using this */

/*

** DE4X5 IRQ ENABLE/DISABLE

 Enable the IRQs */\

 Disable the IRQs */\

 Unmask the IRQs */\

 Mask the IRQs */\

/*

** DE4X5 START/STOP

 Enable the TX and/or RX */\

 Disable the TX and/or RX */ \

/*

** DE4X5 SIA RESET

 Reset SIA connectivity regs */

/*

** DE500 AUTOSENSE TIMER INTERVAL (MILLISECS)

/*

** SROM Structure

/*

** DE4X5 Descriptors. Make sure that all the RX buffers are contiguous

** and have sizes of both a power of 2 and a multiple of 4.

** A size of 256 bytes for each buffer could be chosen because over 90% of

** all packets in our network are <256 bytes long and 64 longword alignment

** is possible. 1536 showed better 'ttcp' performance. Take your pick. 32 TX

** descriptors are needed for machines with an ALPHA CPU.

 Number of RX descriptors   */

 Number of TX descriptors   */

 Power of 2 for kmalloc and */

 Multiple of 4 for DC21040  */

 Allows 512 byte alignment  */

/*

** The DE4X5 private structure

#define DE4X5_PKT_BIN_SZ  128            /* Should be >=100 unless you

 Private stats counters       */

 Adapter name                 */

 Aligned ISR flag             */

 RX descriptor ring           */

 TX descriptor ring           */

 TX skb for freeing when sent */

 RX skb's                     */

 RX descriptor ring pointers  */

 TX descriptor ring pointers  */

 Holds MCA and PA info.       */

 Min sized packet for loopback*/

 Adapter specific spinlock    */

 Public stats                 */

 Private stats counters	    */

 EISA or PCI                  */

 PCI Bus number               */

 Device number on PCI bus     */

 Adapter OPENED or CLOSED     */

 DC21040, DC21041 or DC21140  */

 Interrupt Mask (Enable) bits */

 Summary interrupt bits       */

 Media (eg TP), mode (eg 100B)*/

 Remember the last media conn */

 media full duplex flag       */

 Link is OK                   */

 Allow/disallow autosensing   */

 Enable descriptor polling    */

 Setup frame filtering type   */

 State within a 'media' state */

 List of attached PHY devices */

 SIA PHY Information          */

 Index to active PHY device   */

 Number of attached PHY's     */

 Scheduling counter           */

 Timer info for kernel        */

 Temporary global per card    */

 Lock the cache accesses      */

 Saved Bus Mode Register      */

 Saved Operating Mode Reg.    */

 Saved IRQ Mask Register      */

 Saved General Purpose Reg.   */

 Control info for GEP         */

 Saved SIA Connectivity Reg.  */

 Saved SIA TX/RX Register     */

 Saved SIA General Register   */

 Flag if state already saved  */

 Save the (re-ordered) skb's  */

 A copy of the SROM           */

 Card CFRV copy */

 Check for 'RX overflow' tag  */

 For non-DEC card use SROM    */

 Infoblock using the MII      */

 Autosense bits in GEP?       */

 0 => asserted high           */

 Autosense bit number in GEP  */

 SROM default medium          */

 Last infoblock number        */

 Initialised this infoblock?  */

 SROM infoleaf for controller */

 csr6 value in SROM infoblock */

 infoblock media              */

 Pointer to infoleaf function */

 Pointer to Type 5 reset info */

 Infoblock number             */

 Command line/ #defined params */

 Generic device */

 DMA handle for rings	    */

 Size of the DMA area	    */

 rx bufs on alpha, sparc, ... */

/*

** To get around certain poxy cards that don't provide an SROM

** for the second and more DECchip, I have to key off the first

** chip's address. I'll assume there's not a bad SROM iff:

**

**      o the chipset is the same

**      o the bus number is the same and > 0

**      o the sum of all the returned hw address bytes is 0 or 0x5fa

**

** Also have to save the irq for those cards whose hardware designers

** can't follow the PCI to PCI Bridge Architecture spec.

/*

** The transmit ring full condition is described by the tx_old and tx_new

** pointers by:

**    tx_old            = tx_new    Empty ring

**    tx_old            = tx_new+1  Full ring

**    tx_old+txRingSize = tx_new+1  Full ring  (wrapped condition)

/*

** Public Functions

/*

** Private functions

static void    srom_busy(u_int command, u_long address);*/

/*

** Note now that module autoprobing is allowed under EISA and PCI. The

** IRQ lines will not be auto-detected; instead I'll rely on the BIOSes

** to "do the right thing".

 EDIT THIS LINE FOR YOUR CONFIGURATION IF NEEDED        */

/*

** List the SROM infoleaf functions and chipsets

/*

** List the SROM info block functions

/*

** Miscellaneous defines...

 Hard RESET the PHY dev. */\

 Assert for 1ms */\

 Wait for 2ms */\

 Ensure we're not sleeping */

 Hardware could not reset */

    /*

    ** Now find out what kind of DC21040/DC21041/DC21140 board we have.

 Not found a board signature */

	/*

	** Choose correct autosensing in case someone messed up

	/*

	** Set up the RX descriptor ring (Intels)

	** Allocate contiguous receive buffers, long word aligned (Alphas)

 Dummy entry */

 Dummy entry */

 Write the end of list marker to the descriptor lists */

 Tell the adapter where the TX/RX rings are located. */

 Initialise the IRQ mask and Enable/Disable */

 Create a loopback packet frame for later media probing */

 Check if the RX overflow bug needs testing for */

 Initialise the SROM pointers if possible */

	/*

	** Check for an MII interface

 The DE4X5-specific entries in the device structure. */

 Fill in the generic fields of the device structure. */

 Let the adapter sleep to save power */

 Allocate the RX buffers */

    /*

    ** Wake up the adapter

    /*

    ** Re-initialize the DE4X5...

 prevent tx timeout */

/*

** Initialize the DE4X5 operating conditions. NB: a chip problem with the

** DC21140 requires using perfect filtering mode for that chip. Since I can't

** see why I'd want > 14 multicast addresses, I have changed all chips to use

** the perfect filtering mode. Keep the DMA burst length at 8: there seems

** to be data corruption problems if it is larger (UDP errors seen from a

** ttcp source).

 Lock out other processes whilst setting up the hardware */

 Autoconfigure the connected port */

 Select the MII or SRL port now and RESET the MAC */

    /*

    ** Set the programmable burst length to 8 longwords for all the DC21140

    ** Fasternet chips and 4 longwords for all others: DMA errors result

    ** without these values. Cache align 16 long.

 Turn off promiscuous mode */

 Build the setup frame depending on filtering mode */

 Poll for setup frame completion (adapter interrupts are disabled now) */

 Up to 500ms delay */

 Stop everything! */

/*

** Writes a socket buffer address to the next available transmit descriptor.

 Cannot send for now */

    /*

    ** Clean out the TX ring asynchronously to interrupts - sometimes the

    ** interrupts are lost by delayed descriptor status updates relative to

    ** the irq assertion, especially with a busy PCI bus.

 Test if cache is already locked - requeue skb if so */

 Transmit descriptor ring full or stale skb */

 Requeue the buffer */

 If we already have stuff queued locally, use that first */

 Start the TX */

 Another pkt may be queued */

/*

** The DE4X5 interrupt handler.

**

** I/O Read/Writes through intermediate PCI bridges are never 'posted',

** so that the asserted interrupt always has some real data to work with -

** if these I/O accesses are ever changed to memory accesses, ensure the

** STS write is read immediately to complete the transaction if the adapter

** is not on bus 0. Lost interrupts can still occur when the PCI bus load

** is high and descriptor status bits cannot be set before the associated

** interrupt is asserted and this routine entered.

 Ensure non re-entrancy */

 Read IRQ status */

 Reset the board interrupts */

 All done */

 Rx interrupt (packet[s] arrived) */

 Tx interrupt (packet sent) */

 TP Link has failed */

 Transmit underrun */

 Bus Error */

 Load the TX ring with any locally stored packets */

 Remember the start of frame */

 Valid frame status */

 There was an error. */

 Update the error stats. */

 A valid frame received */

 Push up the protocol stack */

 Update stats */

 Change buffer ownership for this frame, back to the adapter */

	/*

	** Update entry information

/*

** Buffer sent - check for TX buffer errors.

 Buffer not sent yet */

 Not setup frame */

 An error happened */

 Restart a stalled TX */

 Packet sent */

 Update the collision counter */

 Free the buffer. */

 Update all the pointers */

 Any resources available? */

    /*

    ** We stop the DE4X5 here... mask interrupts and stop TX & RX

 Free the associated irq */

 Free any socket buffers */

 Put the adapter to sleep to save power */

 Duplicates stats.rx_packets */

 Reset counters */

/*

** Removes the TD_IC flag from previous descriptor to improve TX performance.

** If the flag is changed on a descriptor that is being read by the hardware,

** I assume PCI transaction ordering will mean you are either successful or

** just miss asserting the change to the hardware. Anyway you're messing with

** a descriptor you don't own, but this shouldn't kill the chip provided

** the descriptor register is read only to the hardware.

/*

** Set or clear the multicast filter for this adaptor.

 First, double check that the adapter is open */

 set promiscuous mode */

 Start the TX */

 prevent tx timeout */

/*

** Calculate the hash code and update the logical address filter

** from a list of ethernet multicast addresses.

** Little endian crc one liner from Matt Thomas, DEC.

 Build the basic frame */

 Pass all multicasts */

 Hash Filtering */

 hashcode is 9 LSb of CRC */

 bit[3-8] -> byte in filter */

 bit[0-2] -> bit in byte */

 calc offset into setup frame */

 Perfect filtering */

 Read the EISA Configuration Registers */

	/* Looks like the Jensen firmware (rev 2.2) doesn't really

	 * care about the EISA configuration, and thus doesn't

	 * configure the PLX bridge properly. Oh well... Simply mimic

 EISA REG1: Assert DecChip 21040 HW Reset */

 EISA REG1: Deassert DecChip 21040 HW Reset */

 EISA REG3: R/W Burst Transfer Enable */

 32_bit slave/master, Preempt Time=23 bclks, Unlatched Interrupt */

 Write the PCI Configuration Registers */

 0 is the board name index... */

/*

** This function searches the current bus (which is >0) for a DECchip with an

** SROM, so that in multiport cards that have one SROM shared between multiple

** DECchips, we can find the base SROM irrespective of the BIOS scan direction.

** For single port cards this is a time waster...

 Clear upper 32 bits in Alphas */

 Get the chip configuration revision register */

 Set the device number information */

 Set the chipset information */

 Get the board I/O address (64 bits on sparc64) */

 Fetch the IRQ to be used */

 Check if I/O accesses are enabled */

 Search for a valid SROM attached to this DECchip */

/*

** PCI bus I/O device probe

** NB: PCI I/O accesses and Bus Mastering are enabled by the PCI BIOS, not

** the driver. Some PCI BIOS's, pre V2.1, need the slot + features to be

** enabled by the user first in the set up utility. Hence we just check for

** enabled features and silently ignore the card if they're not.

**

** STOP PRESS: Some BIOS's __require__ the driver to enable the bus mastering

** bit. Here, check for I/O accesses and then set BM. If you put the card in

** a non BM slot, you're on your own (and complain to the PC vendor that your

** PC doesn't conform to the PCI standard)!

**

** This function is only compatible with the *latest* 2.1.x kernels. For 2.0.x

** kernels use the V0.535[n] drivers.

 Clear upper 32 bits in Alphas */

 probe a single PCI device */

 Ok, the device seems to be for us. */

 Search for an SROM on this bus */

 Get the chip configuration revision register */

 Set the device number information */

 Set the chipset information */

 Get the board I/O address (64 bits on sparc64) */

 Fetch the IRQ to be used */

 Check if I/O accesses and Bus Mastering are enabled */

 __powerpc__ */

 Check the latency timer for values >= 0x60 */

/*

** Auto configure the media here rather than setting the port at compile

** time. This routine is called by de4x5_init() and when a loss of media is

** detected (excessive collisions, loss of carrier, no carrier or link fail

** [TP] or no recent receive activity) to check whether the user has been

** sneaky and changed the port on us.

 Bogus last media */

 Zero the lost frames counter */

/*

** Autoconfigure the media when using the DC21040. AUI cannot be distinguished

** from BNC as the port has a jumper to set thick or thin wire. When set for

** BNC, the BNC port will indicate activity if it's not terminated correctly.

** The only way to test for that is to place a loopback packet onto the

** network and watch for errors. Since we're messing with the interrupt mask

** register, disable the board interrupts and do not allow any more packets to

** be queued to the hardware. Re-enable everything only when the media is

** found.

** I may have to "age out" locally queued packets so that the higher layer

** timeouts don't effectively duplicate packets on the network.

 default to TP for all */

/*

** Autoconfigure the media when using the DC21041. AUI needs to be tested

** before BNC, because the BNC port will indicate activity if it's not

** terminated correctly. The only way to test for that is to place a loopback

** packet onto the network and watch for errors. Since we're messing with

** the interrupt mask register, disable the board interrupts and do not allow

** any more packets to be queued to the hardware. Re-enable everything only

** when the media is found.

 Save non transmitted skb's */

 On chip auto negotiation is broken */

 Set up full duplex for the autonegotiate */

 Set up half duplex for TP */

 Non selected port activity */

 Set up half duplex for AUI */

 Set up half duplex for BNC */

 Ensure media connected */

 Set up full duplex for the autonegotiate */

 Initialise the SIA */

/*

** Some autonegotiation chips are broken in that they do not return the

** acknowledge bit (anlpa & MII_ANLPA_ACK) in the link partner advertisement

** register, except at the first power up negotiation.

 Save non transmitted skb's */

 Fake out the MII speed set */

 Success! */

 Auto Negotiation failed to finish */

 Auto Negotiation failed to start */

 Choose 10Mb/s or 100Mb/s */

 Set 100Mb/s */

 Set 10Mb/s */

/*

** This routine may be merged into dc21140m_autoconf() sometime as I'm

** changing how I figure out the media - but trying to keep it backwards

** compatible with the de500-xa and de500-aa.

** Whether it's BNC, AUI, SYM or MII is sorted out in the infoblock

** functions and set during de4x5_mac_port() and/or de4x5_reset_phy().

** This routine just has to figure out whether 10Mb/s or 100Mb/s is

** active.

** When autonegotiation is working, the ANS part searches the SROM for

** the highest common speed (TP) link that both can run and if that can

** be full duplex. That infoblock is executed and then the link speed set.

**

** Only _10Mb and _100Mb are tested here.

 Save non transmitted skb's */

 Fixed media requested      */

 Success! */

 Auto Negotiation failed to finish */

 Auto Negotiation failed to start  */

 Set up half duplex for AUI        */

 Set up half duplex for BNC */

 Ensure media connected */

 Choose 10Mb/s or 100Mb/s */

 Do MII parallel detection */

/*

** This mapping keeps the original media codes and FDX flag unchanged.

** While it isn't strictly necessary, it helps me for the moment...

** The early return avoids a media state / SROM media space clash.

 Stop scrolling media messages */

/*

** General PHY reset function. Some MII devices don't reset correctly

** since their MII address pins can float at voltages that are dependent

** on the signal pin use. Do a double reset to ensure a reset.

 Type 5 infoblock reset */

 Already done if by SROM, else dc2104[01] */

 set up the interrupt mask */

 clear all pending interrupts */

 clear csr12 NRA and SRA bits */

/*

** Samples the 100Mb Link State Signal. The sample interval is important

** because too fast a rate can give erroneous results and confuse the

** speed sense algorithm.

 ms */

 ms */

/*

**

**

 de500-xa */

 Double read for sticky bits & temporary drops */

 de500-xa */

 Double read for sticky bits & temporary drops */

 de500-xa */

/*

** Send a packet onto the media and watch for send errors that indicate the

** media is bad or unconnected.

 Remember the ring position */

/*

** This function does 2 things: on Intels it kmalloc's another buffer to

** replace the one about to be passed up. On Alpha's it kmallocs a buffer

** into which the packet is copied.

 Fake out the open */

 Align */

 Wrapped buffer */

 Linear buffer */

 Dummy entry */

 Unload the locally queued packets */

/*

** When a user pulls a connection, the DECchip can end up in a

** 'running - waiting for end of transmission' state. This means that we

** have to perform a chip soft reset to ensure that we can synchronize

** the hardware and software and make any media probes using a loopback

** packet meaningful.

 Flush any sent skb's */

/*

** Check the Auto Negotiation State. Return OK when a link pass interrupt

** is received and the auto-negotiation status is NWAY OK.

 clear all pending interrupts */

 Only unmask if TX/RX is enabled */

 Reset any pending (stale) interrupts */

/*

**

/*

** Create a loopback ethernet packet

 Use this source address */

 Use this destination address */

 Packet length (2 bytes) */

/*

** Look for a particular board name in the EISA configuration space

 return the device name string */

/*

** Look for a particular board name in the PCI configuration space

 Search for a DEC name in the SROM */

 Use chip name to avoid confusion */

 card is not recognisably DEC */

/*

** Set up the Ethernet PROM counter to the start of the Ethernet address on

** the DC21040, else  read the SROM for the other chips.

** The SROM may not be present in a multi-MAC card, so first read the

** MAC address and check for a bad address. If there is a bad one then exit

** immediately with the prior srom contents intact (the h/w address will

** be fixed up later).

 Reset Ethernet Address ROM Pointer */

 Reset Ethernet Address ROM Pointer */

 Read new srom */

 for check for 0:0:0:0:0:0 or ff:ff:ff:ff:ff:ff */

 could get 0 only from all-0 and 3 * 0xffff only from all-1 */

/*

** Since the write on the Enet PROM register doesn't seem to reset the PROM

** pointer correctly (at least on my DE425 EISA card), this routine should do

** it...from depca.c.

 track signature */

 lost signature; begin search again */

 rare case.... */

/*

** For the bad status case and no SROM, then add one to the previous

** address. However, need to add one backwards in case we have 0xff

** as one or more of the bytes. Only the last 3 bytes should be checked

** as the first three are invariant - assigned to an organisation.

 If possible, try to fix a broken card - SMC only so far */

    /*

    ** If the address starts with 00 a0, we have to bit-reverse

    ** each byte of the address.

 CONFIG_PPC_PMAC */

 Test for a bad enet address */

/*

** Test for enet addresses in the first 32 bytes.

/*

** Assume that the irq's do not follow the PCI spec - this is seems

** to be true so far (2 for 2).

/*

** List of board exceptions with correctly wired IRQs

/*

** SROM Read

/*

static void

srom_busy(u_int command, u_long addr)

{

   sendto_srom((command & 0x0000ff00) | DT_CS, addr);



   while (!((getfrom_srom(addr) >> 3) & 0x01)) {

       mdelay(1);

   }



   sendto_srom(command & 0x0000ff00, addr);

}

 Find the infoleaf decoder function that matches this chipset */

 Find the information offset that this function should use */

/*

** This routine loads any type 1 or 3 MII info into the mii device

** struct and executes any type 5 code to reset PHY devices for this

** controller.

** The info for the MII devices will be valid since the index used

** will follow the discovery process from MII address 1-31 then 0.

 Block count */

 Jump the infoblocks to find types */

/*

** A generic routine that writes GEP control, data and reset information

** to the GEP register (21140) or csr15 GEP portion (2114[23]).

 2ms per action */

/*

** Basically this function is a NOP since it will never be called,

** unless I implement the DC21041 SROM functions. There's no need

** since the existing code will be satisfactory for all boards.

 Read the connection type */

 GEP control */

 Block count */

 Recursively figure out the info blocks */

 Read the connection type */

 Block count */

 Recursively figure out the info blocks */

 Read the connection type */

 Block count */

 Recursively figure out the info blocks */

/*

** The compact infoblock is only designed for DC21140[A] chips, so

** we'll reuse the dc21140m_autoconf function. Non MII media only.

 Recursively figure out the info blocks */

/*

** This block describes non MII media for the DC21140[A] only.

 Recursively figure out the info blocks */

 These functions are under construction! */

 Recursively figure out the info blocks */

 Recursively figure out the info blocks */

 Recursively figure out the info blocks */

	/* if (MOTO_SROM_BUG) statement indicates lp->active could

 Recursively figure out the info blocks */

 Hard coded defaults */

/*

** This block type provides information for resetting external devices

** (chips) through the General Purpose Register.

 Recursively figure out the info blocks */

 Must be initializing to run this code */

/*

** MII Read/Write

 Start of 34 bit preamble...    */

 ...continued                   */

 SFD and Read operation         */

 PHY address to be accessed     */

 PHY Register to read           */

 Turn around time - 2 MDC       */

 Read data                      */

 Start of 34 bit preamble...    */

 ...continued                   */

 SFD and Write operation        */

 PHY address to be accessed     */

 PHY Register to write          */

 Turn around time - 2 MDC       */

 Swap data bit ordering         */

 Write data                     */

 Tri-state MDIO */

/*

** Here's 3 ways to calculate the OUI from the ID registers.

/*

    union {

	u_short reg;

	u_char breg[2];

    } a;

 Read r2 and r3 */

                                                /* SEEQ and Cypress way * /

    / * Shuffle r2 and r3 * /

    a.reg=0;

    r3 = ((r3>>10)|(r2<<6))&0x0ff;

    r2 = ((r2>>2)&0x3fff);



    / * Bit reverse r3 * /

    for (i=0;i<8;i++) {

	ret<<=1;

	ret |= (r3&1);

	r3>>=1;

    }



    / * Bit reverse r2 * /

    for (i=0;i<16;i++) {

	a.reg<<=1;

	a.reg |= (r2&1);

	r2>>=1;

    }



    / * Swap r2 bytes * /

    i=a.breg[0];

    a.breg[0]=a.breg[1];

    a.breg[1]=i;



 SEEQ and Cypress way */

    return (r2<<6)|(u_int)(r3>>10); */      
 (I did it) My way */

/*

** The SROM spec forces us to search addresses [1-31 0]. Bummer.

 Search the MII address space for possible PHY devices */

 Count cycles */

 Wait for reset */

 Valid ID? */

 Search PHY table */

 ID match? */

 Stop the search */

 ANLPA register         */

 100Mb/s technologies   */

 TX & T4, H/F Duplex    */

 Reset the PHY devices */

For each PHY*/

 Initialise the setup frame */

 Host address */

 Host address */

 Broadcast address */

 Points to the next entry */

 Assert the OMR_PS bit in CSR6 */

 Soft Reset */

 Restore the GEP - especially for COMPACT and Type 0 Infoblocks */

 Restore CSR6 */

 Reset CSR8 */

/*

** Perform IOCTL call functions here. Some are privileged operations and the

** effective uid is checked in those cases. In the normal course of events

** this function is only used for my testing.

 Get the hardware address */

 Set the hardware address */

 Set up the descriptor and give ownership to the card */

 Start the TX */

 Unlock the TX ring */

 Say "Boo!" to the kernel log file */

 Enable pass all multicast addressing */

 Get the driver statistics */

 Zero out the driver statistics */

 Get the OMR Register contents */

 Set the OMR Register contents */

 Get the DE4X5 Registers */

 Dump the DE4X5 Status */

/*

      case DE4X5_DUMP:

	j = 0;

	tmp.addr[j++] = dev->irq;

	for (i=0; i<ETH_ALEN; i++) {

	    tmp.addr[j++] = dev->dev_addr[i];

	}

	tmp.addr[j++] = lp->rxRingSize;

	tmp.lval[j>>2] = (long)lp->rx_ring; j+=4;

	tmp.lval[j>>2] = (long)lp->tx_ring; j+=4;



	for (i=0;i<lp->rxRingSize-1;i++){

	    if (i < 3) {

		tmp.lval[j>>2] = (long)&lp->rx_ring[i].status; j+=4;

	    }

	}

	tmp.lval[j>>2] = (long)&lp->rx_ring[i].status; j+=4;

	for (i=0;i<lp->txRingSize-1;i++){

	    if (i < 3) {

		tmp.lval[j>>2] = (long)&lp->tx_ring[i].status; j+=4;

	    }

	}

	tmp.lval[j>>2] = (long)&lp->tx_ring[i].status; j+=4;



	for (i=0;i<lp->rxRingSize-1;i++){

	    if (i < 3) {

		tmp.lval[j>>2] = (s32)le32_to_cpu(lp->rx_ring[i].buf); j+=4;

	    }

	}

	tmp.lval[j>>2] = (s32)le32_to_cpu(lp->rx_ring[i].buf); j+=4;

	for (i=0;i<lp->txRingSize-1;i++){

	    if (i < 3) {

		tmp.lval[j>>2] = (s32)le32_to_cpu(lp->tx_ring[i].buf); j+=4;

	    }

	}

	tmp.lval[j>>2] = (s32)le32_to_cpu(lp->tx_ring[i].buf); j+=4;



	for (i=0;i<lp->rxRingSize;i++){

	    tmp.lval[j>>2] = le32_to_cpu(lp->rx_ring[i].status); j+=4;

	}

	for (i=0;i<lp->txRingSize;i++){

	    tmp.lval[j>>2] = le32_to_cpu(lp->tx_ring[i].status); j+=4;

	}



	tmp.lval[j>>2] = inl(DE4X5_BMR);  j+=4;

	tmp.lval[j>>2] = inl(DE4X5_TPD);  j+=4;

	tmp.lval[j>>2] = inl(DE4X5_RPD);  j+=4;

	tmp.lval[j>>2] = inl(DE4X5_RRBA); j+=4;

	tmp.lval[j>>2] = inl(DE4X5_TRBA); j+=4;

	tmp.lval[j>>2] = inl(DE4X5_STS);  j+=4;

	tmp.lval[j>>2] = inl(DE4X5_OMR);  j+=4;

	tmp.lval[j>>2] = inl(DE4X5_IMR);  j+=4;

	tmp.lval[j>>2] = lp->chipset; j+=4;

	if (lp->chipset == DC21140) {

	    tmp.lval[j>>2] = gep_rd(dev);  j+=4;

	} else {

	    tmp.lval[j>>2] = inl(DE4X5_SISR); j+=4;

	    tmp.lval[j>>2] = inl(DE4X5_SICR); j+=4;

	    tmp.lval[j>>2] = inl(DE4X5_STRR); j+=4;

	    tmp.lval[j>>2] = inl(DE4X5_SIGR); j+=4;

	}

	tmp.lval[j>>2] = lp->phy[lp->active].id; j+=4;

	if (lp->phy[lp->active].id && (!lp->useSROM || lp->useMII)) {

	    tmp.lval[j>>2] = lp->active; j+=4;

	    tmp.lval[j>>2]=mii_rd(MII_CR,lp->phy[lp->active].addr,DE4X5_MII); j+=4;

	    tmp.lval[j>>2]=mii_rd(MII_SR,lp->phy[lp->active].addr,DE4X5_MII); j+=4;

	    tmp.lval[j>>2]=mii_rd(MII_ID0,lp->phy[lp->active].addr,DE4X5_MII); j+=4;

	    tmp.lval[j>>2]=mii_rd(MII_ID1,lp->phy[lp->active].addr,DE4X5_MII); j+=4;

	    if (lp->phy[lp->active].id != BROADCOM_T4) {

		tmp.lval[j>>2]=mii_rd(MII_ANA,lp->phy[lp->active].addr,DE4X5_MII); j+=4;

		tmp.lval[j>>2]=mii_rd(MII_ANLPA,lp->phy[lp->active].addr,DE4X5_MII); j+=4;

	    }

	    tmp.lval[j>>2]=mii_rd(0x10,lp->phy[lp->active].addr,DE4X5_MII); j+=4;

	    if (lp->phy[lp->active].id != BROADCOM_T4) {

		tmp.lval[j>>2]=mii_rd(0x11,lp->phy[lp->active].addr,DE4X5_MII); j+=4;

		tmp.lval[j>>2]=mii_rd(0x12,lp->phy[lp->active].addr,DE4X5_MII); j+=4;

	    } else {

		tmp.lval[j>>2]=mii_rd(0x14,lp->phy[lp->active].addr,DE4X5_MII); j+=4;

	    }

	}



	tmp.addr[j++] = lp->txRingSize;

	tmp.addr[j++] = netif_queue_stopped(dev);



	ioc->len = j;

	if (copy_to_user(ioc->data, tmp.addr, ioc->len)) return -EFAULT;

	break;



/*

	drivers/net/ethernet/dec/tulip/eeprom.c



	Copyright 2000,2001  The Linux Kernel Team

	Written/copyright 1994-2001 by Donald Becker.



	This software may be used and distributed according to the terms

	of the GNU General Public License, incorporated herein by reference.



	Please submit bug reports to http://bugzilla.kernel.org/.

 Serial EEPROM section. */

/* The main routine to parse the very complicated SROM structure.

   Search www.digital.com for "21X4 SROM" to get details.

   This code is very complex, and will require changes to support

   additional cards, so I'll be verbose about what is going on.

 Known cards that have old-style EEPROMs. */

 10baseT */

 10baseT-FD */

 100baseTx */

 100baseTx-FD */ }},

 100baseFx */

 100baseFx-FD */

 10baseT */

 10baseT-FD */

 100baseTx */

 100baseTx-FD */ }},

 10base2, CSR12 0x10*/

 10baseT */

 10baseT-FD */

 100baseTx, CSR12 0x03 */

 100baseTx-FD CSR12 0x03 */}},

 10base2,   CSR12 0x1B */

 10baseT,   CSR12 0x0B */

 10baseT-FD,CSR12 0x0B */

 100baseTx, CSR12 0x1B */

 100baseTx-FD CSR12 0x1B */

	/* Default media = MII

	 * MII block, reset sequence (3) = 0x0821 0x0000 0x0001, capabilities 0x01e1

 0 == controller #, 1e == offset	*/

 0 == high offset, 0 == gap		*/

 Default Autoselect			*/

 1 leaf, extended type, bogus len	*/

 Type 3 (MII), PHY #0		*/

 0 init instr, 4 reset instr		*/

 Set control mode, GP0 output	*/

 Drive GP0 Low (RST is active low)	*/

 control mode, GP0 input (undriven)	*/

 clear control mode			*/

 100TX FDX + HDX, 10bT FDX + HDX	*/

 Advertise all above			*/

 FDX all above			*/

 Set fast TTM in 100bt modes		*/

 PHY cannot be unplugged		*/

/**

 * tulip_build_fake_mediatable - Build a fake mediatable entry.

 * @tp: Ptr to the tulip private data.

 *

 * Some cards like the 3x5 HSC cards (J3514A) do not have a standard

 * srom and can not be handled under the fixup routine.  These cards

 * still need a valid mediatable entry for correct csr12 setup and

 * mii handling.

 *

 * Since this is currently a parisc-linux specific function, the

 * #ifdef __hppa__ should completely optimize this function away for

 * non-parisc hardware.

 phy number */

 gpr setup sequence length */

 gpr setup sequence */

 phy reset sequence length */

 phy reset sequence */

 media capabilities */

 nway advertisement */

 fdx bit map */

 ttm bit map */

 Horrible, impossible failure. */

 inputs on bit7 for hsc-pci, bit6 for pci-fx */

	/*

	  dev is not registered at this point, so logging messages can't

	  use dev_<level> or netdev_<level> but dev->name is good via a

	  hack in the caller

 The last media info list parsed, for multiport boards.  */

	/* Detect an old-style (SA only) EEPROM layout:

 Do a fix-up based on the vendor half of the station address prefix. */

 An Accton EN1207, not an outlaw Maxtech. */

 No fixup found. */

 Multiport board. */

 No valid media table. */

 there is no phy information, don't even try to build mtable */

 Horrible, impossible failure. */

 21140 Compact block. */

 Bogus, but Znyx boards do it. */

 Hack to ignore Davicom delay period block */

 Davicom's media number for 100BaseTX is strange */

 Reading a serial EEPROM is a "bit" grungy, but we work our way through:->.*/

  EEPROM_Ctrl bits. */

 EEPROM shift clock. */

 EEPROM chip select. */

 Data from the Tulip to EEPROM. */

 Data from the EEPROM chip. */

/* Delay between EEPROM clock transitions.

   Even at 33Mhz current PCI implementations don't overrun the EEPROM clock.

 The EEPROM commands include the alway-set leading bit. */

 Note: this routine returns extra data bits for size detection. */

	/* If location is past the end of what we can address, don't

	 * read some other location (ie truncate). Just return zero.

 Shift the read command bits out. */

 Terminate the EEPROM access. */

/*	tulip_core.c: A DEC 21x4x-family ethernet driver for Linux.



	Copyright 2000,2001  The Linux Kernel Team

	Written/copyright 1994-2001 by Donald Becker.



	This software may be used and distributed according to the terms

	of the GNU General Public License, incorporated herein by reference.



	Please submit bugs to http://bugzilla.kernel.org/ .

 A few user-configurable values. */

 Maximum events (Rx packets, etc.) to handle at each interrupt. */

 Used to pass the full-duplex flag, etc. */

 Jumbo MTU for interfaces. */

  The possible media types that can be set in options[] are: */

 Set the copy breakpoint for the copy-only-tiny-buffer Rx structure. */

/*

  Set the bus performance register.

	Typical: Set 16 longword cache alignment, no burst limit.

	Cache alignment bits 15:14	     Burst length 13:8

		0000	No alignment  0x00000000 unlimited		0800 8 longwords

		4000	8  longwords		0100 1 longword		1000 16 longwords

		8000	16 longwords		0200 2 longwords	2000 32 longwords

		C000	32  longwords		0400 4 longwords

	Warning: many older 486 systems are broken and require setting 0x00A04800

	   8 longword cache alignment, 8 longword burst.

	ToDo: Non-Intel setting could be better.

/* The UltraSparc PCI controllers will disconnect at every 64-byte

 * crossing anyways so it makes no sense to tell Tulip to burst

 * any more than that.

 Operational parameters that usually are not changed. */

 Time in jiffies before concluding the transmitter is hung. */

/*

 * This table use during operation for capabilities and media timer.

 *

 * It is indexed via the values in 'enum chips'

 placeholder for array, slot unused currently */

 placeholder for array, slot unused currently */

 DC21140 */

 DC21142, DC21143 */

 LC82C168 */

 MX98713 */

 MX98715 */

 MX98725 */

 AX88140 */

 PNIC2 */

 COMET */

 COMPEX9881 */

 I21145 */

 DM910X */

 RS7112 */

	{ 0x10d9, 0x0531, PCI_ANY_ID, PCI_ANY_ID, 0, 0, MX98725 },*/

 3Com 3CSOHO100B-TX */

 Planex FNW-3602-TX */

 Microsoft MN-120 */

 terminate list */

 A full-duplex map for media types. */

 Wake the chip from sleep/snooze mode. */

 Disable all WOL events */

 On some chip revs we must set the MII/SYM port before the reset!? */

 Reset the chip, holding bit 0 set at least 50 PCI cycles. */

 flush write */

	/* Deassert reset.

	   Wait the specified 50 PCI cycles after a reset by initializing

 flush write */

 This is set_rx_mode(), but without starting the transmitter. */

 21140 bug: you must add the broadcast address. */

 Fill the final entry of the table with our physical address. */

 Put the setup frame on the Tx list. */

 Allow selecting a default media. */

 Start sensing first non-full-duplex media. */

 We must reset the media CSRs when we force-select MII mode. */

 for initial startup advertise 10/100 Full and Half */

 enable autonegotiate end interrupt */

 Start with 10mbps to do autonegotiation. */

 Provided by BOLO, Macronix - 12/10/1998. */

 Enable automatic Tx underrun recovery. */

 Start the chip's Tx to process setup frame. */

 Enable interrupts by setting the interrupt mask. */

 Rx poll demand */

	/* Set the timer to switch to check for link beat and perhaps switch

 Do nothing -- the media monitor should handle this. */

 prevent tx timeout */

 Initialize the Rx and Tx rings, along with various 'dev' bits. */

 Mark the last entry as wrapping the ring. */

		/* Note the receive buffer must be longword aligned.

		   netdev_alloc_skb() provides 16 byte alignment.  But do *not*

 Owned by Tulip chip */

	/* The Tx buffer descriptor is filled in as needed, but we

 Calculate the next Tx descriptor entry. */

 Typical path */

 No interrupt */

 Tx-done intr. */

 No Tx-done intr. */

 Leave room for set_rx_mode() to fill entries. */

 Tx-done intr. */

	/* if we were using Transmit Automatic Polling, we would need a

 Trigger an immediate transmit demand. */

 It wasn't Txed */

 Check for Tx filter setup frames. */

 test because dummy frames not mapped */

 Free the original skb. */

 Disable interrupts by clearing the interrupt mask. */

 Stop the Tx and Rx processes. */

 prepare receive buffers */

 release any unconsumed transmit buffers */

 Leave the driver in snooze, not sleep, mode. */

 Free all the skbuffs in the Rx queue. */

 Not owned by Tulip chip. */

 An invalid address. */

 Provide ioctl() calls to examine the MII xcvr state. */

 Get address of MII PHY in use. */

 Read MII PHY register. */

 Advertised value, bogus 10baseTx-FD value from CSR6. */

 Write MII PHY register. */

 Check for autonegotiation on or reset. */

/* Set or clear the multicast filter for this adaptor.

   Note that we only use exclusion around actually queueing the

   new frame, not around filling tp->setup_frame.  This is non-deterministic

 Broadcast entry */

 This should work on big-endian machines as well. */

 Fill the final entry with our physical address. */

	/* We have <= 14 addresses so we can use the wonderful

 Fill the unused entries with the broadcast address. */

 Fill the final entry with our physical address. */

 Set promiscuous. */

 Too many to filter well -- accept all multicasts. */

 Some work-alikes have only a 64-entry hash filter table. */

 Should verify correctness on big-endian/__powerpc__ */

 Arbitrary non-effective limit. */

 Multicast hash filter */

 No change. */

		/* Note that only the low-address shortword of setup_frame is valid!

 Must use a multicast hash table. */

 Same setup recently queued, we need not add it. */

 Now add this frame to the Tx list. */

 Avoid a chip errata by prefixing a dummy entry. */

 Must set DescOwned later to avoid race with chip */

 Put the setup frame on the Tx list. */

 Wrap ring. */

 Trigger an immediate transmit demand. */

 if we have any cache line size at all, we can do MRM and MWI */

	/* Enable MWI in the standard PCI command bit.

	 * Check for the case where MWI is desired but not available

 read result from hardware (in case bit refused to enable) */

 if cache line size hardwired to zero, no MWI */

	/* assign per-cacheline-size cache alignment and

	 * burst length values

	/* if we have a good cache line size, we by now have a good

	 * csr0, so save it and exit

 we don't have a good csr0 or cache line size, disable MWI */

	/* sane defaults for burst length and cache alignment

	 * originally from de4x5 driver

/*

 *	Chips that have the MRM/reserved bit quirk and the burst quirk. That

 *	is the DM910X and the on chip ULi devices

 See note below on the multiport cards. */

 Patch up x86 BIOS bug. */

	/*

	 *	Lan media wire a tulip chip to a wan interface. Needs a very

	 *	different driver (lmc driver)

	/*

	 *	DM910x chips should be handled by the dmfe driver, except

	 *	on-board chips on SPARC systems.  Also, early DM9100s need

	 *	software CRC which only the dmfe driver supports.

	/*

	 *	Looks for early PCI chipsets where people report hangs

	 *	without the workarounds being on.

	/* 1. Intel Saturn. Switch to 8 long words burst, 8 long word cache

	      aligned.  Aries might need this too. The Saturn errata are not

	      pretty reading but thankfully it's an old 486 chipset.



	   2. The dreaded SiS496 486 chipset. Same workaround as Intel

	      Saturn.

 bugfix: the ASIX must have a burst limit or horrible things happen. */

 PNIC doesn't have MWI/MRL/MRM... */

 zero reserved bits 31:20, 16 */

 DM9102A has troubles with MRM & clear reserved bits 24:22, 20, 16, 7:1 */

	/*

	 *	And back to business

 alloc_etherdev ensures aligned and zeroed private structures */

	/* grab all resources from both PIO and MMIO regions, as we

	/*

	 * initialize private data structure 'tp'

	 * it is zeroed and aligned in alloc_etherdev

 COMET: Enable power management only for AN983B */

 Stop the chip's Tx and Rx processes. */

 Clear the missed-packet counter. */

	/* The station address ROM is read byte serially.  The register must

	   be polled, waiting for the value to be read bit serially from the

	   EEPROM.

 No need to read the EEPROM. */

 A serial EEPROM interface, we read now and sort it out later. */

		/* DEC now has a specification (see Notes) but early board makers

 This does  memcmp(ee_data, ee_data+16, 8) */

 Check that the tuple type and length is correct. */

 Grrr, damn Matrox boards. */

 Cobalt MAC address in first EEPROM locations. */

 Ensure our media table fixup get's applied */

 Check to see if we have a broken srom */

 pci_vendor_id and subsystem_id are swapped */

			/* HSC-PCI boards need to be byte-swaped and shifted

			 * up 1 word.  This shift needs to happen at the end

			 * of the MAC first because of the 2 byte overlap.

 Lite-On boards have the address byte-swapped. */

	/* On the Zynx 315 Etherarray and other multiport boards only the

	   first Tulip has an EEPROM.

	   On Sparc systems the mac address is held in the OBP property

	   "local-mac-address".

	   The addresses of the subsequent ports are derived from the first.

	   Many PCI BIOSes also incorrectly report the IRQ line, so we correct

 Patch up x86 BIOS bug. */

 Patch up x86 BIOS bug. */

 The lower four bits are the media type. */

 Matching bits! */

 hack */

 un-hack */

		/* Find the connected MII xcvrs.

		   Doing this in open() would allow detecting external xcvrs

 The Tulip-specific entries in the device structure. */

 Reset the xcvr interface and turn on heartbeat. */

 just do a reset for sanity sake */

 Turn on autonegotiation. */

 Turn on NWay. */

 No initialization necessary. */

 put the chip in snooze mode until opened */

 set the registers according to the given wolopts */

 Set the Wake-up Control/Status Register to the given WOL options*/

 Clear the event flags */

 FIXME: it needlessly adds an error path. */

 Clear the PMES flag */

 Disable all wake-up events */

 pci_power_off (pdev, -1); */

/*

 * Polling 'interrupt' - used by things like netconsole to send skbs

 * without having to re-enable interrupts. It's not called while

 * the interrupt routine is executing.

	/* disable_irq here is not very nice, but with the lockless

 default to 8 longword cache line alignment */

 copy module parms into globals */

 probe for and init boards */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * drivers/net/ethernet/rocker/rocker.c - Rocker switch device driver

 * Copyright (c) 2014-2016 Jiri Pirko <jiri@mellanox.com>

 * Copyright (c) 2014 Scott Feldman <sfeldma@gmail.com>

/*****************************

 * HW basic testing functions

/******************************************

 * DMA rings and descriptors manipulations

 ring full */

 nothing to be done between head and tail */

 gen bit not set, desc is not ready yet */

	/* When ring is consumer, we need to advance head for each desc.

	 * That tells hw that the desc is ready to be used by it.

	/* Ensure that hw will see tlv_size zero in case of an error.

	 * That tells hw to use another descriptor.

/********************************

 * Interrupt handler and helpers

/********************

 * Command interface

 make sure name only contains alphanumeric characters */

/**********************

 * Worlds manipulation

/*****************

 * Net device ops

/********************

 * swdev interface

 Protect internal structures from changes */

 Called with rcu_read_lock() */

		/* Take referece on fib_info to prevent it from being

		 * freed while work is queued. Release it afterwards.

/********************

 * ethtool interface

/*****************

 * NAPI interface

 Cleanup tx descriptors */

 Process rx descriptors */

/*****************

 * PCI driver ops

 MTU range: 68 - 9000 */

 called under rcu_read_lock() */

 Take a reference on the rocker device */

	/* Only FIBs pointing to our own netdevs are programmed into

	 * the device, so no need to pass a callback.

/************************************

 * Net device notifier event handler

/************************************

 * Net event notifier event handler

/***********************

 * Module init and exit

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * drivers/net/ethernet/rocker/rocker_ofdpa.c - Rocker switch OF-DPA-like

 *					        implementation

 * Copyright (c) 2014 Scott Feldman <sfeldma@gmail.com>

 * Copyright (c) 2014-2016 Jiri Pirko <jiri@mellanox.com>

 key */

 key */

 key */

 key */

 key */

 for flow tbl accesses */

 for group tbl accesses */

 for fdb tbl accesses */

 for vlan tbl accesses */

 for neigh tbl accesses */

/* Rocker priority levels for flow table entries.  Higher

 * priority match takes precedence over lower priority match.

/*************************************************************

 * Flow, group, FDB, internal VLAN and neigh command prepares

 Note TLV array is 1-based */

/***************************************************

 * Flow, group, FDB, internal VLAN and neigh tables

	/* For each active neighbor, we have an L3 unicast group and

	 * a /32 route to the neighbor, which uses the L3 unicast

	 * group.  The L3 unicast group can also be referred to by

	 * other routes' nexthops.

	/* If the neigh is already resolved, then go ahead and

	 * install the entry, otherwise start the ARP process to

	 * resolve the neigh.

 Resolved means neigh ip_addr is resolved to neigh mac. */

	/* Adjust the flood group for this VLAN.  The flood group

	 * references an L2 interface group for each port in this

	 * VLAN.

 If there are no bridged ports in this VLAN, we're done */

	/* An L2 interface group for this port in this VLAN, but

	 * only when port STP state is LEARNING|FORWARDING.

	/* An L2 interface group for this VLAN to CPU port.

	 * Add when first port joins this VLAN and destroy when

	 * last port leaves this VLAN.

 pass link local multicast pkts up to CPU for filtering */

 pass local ARP pkts up to CPU */

 pass IPv4 mcast pkts up to CPU, RFC 1112 */

 pass IPv6 mcast pkts up to CPU, RFC 2464 */

 flood any pkts on vlan */

 pass all pkts up to CPU */

 already added */

 already removed */

	/* Normal Ethernet Frames.  Matches pkts from any local physical

	 * ports.  Goto VLAN tbl.

 Check if adding and already exists, or removing and can't find */

 Refreshing existing to update aging timers */

	/* Port will be forwarding-enabled if its STP state is LEARNING

	 * or FORWARDING.  Traffic from CPU can still egress, regardless of

	 * port STP state.  Use L2 interface group on port VLANs as a way

	 * to toggle port forwarding: if forwarding is disabled, L2

	 * interface group will not exist.

 port is completely disabled */

 bridge STP will enable port */

 port is not bridged, so simulate going to FORWARDING state */

 bridge STP will disable port */

 port is not bridged, so simulate going to DISABLED state */

 XXX deal with flags for PVID and untagged */

 XXX support ECMP */

 Send to CPU for processing */

/**********************************

 * Rocker world ops implementation

	/* Port is joining bridge, so the internal VLAN for the

	 * port is going to change to the bridge internal VLAN.

	 * Let's remove untagged VLAN (vid=0) from port and

	 * re-add once internal VLAN has changed.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * drivers/net/ethernet/rocker/rocker_tlv.c - Rocker switch device driver

 * Copyright (c) 2014-2016 Jiri Pirko <jiri@mellanox.com>

 * Copyright (c) 2014 Scott Feldman <sfeldma@gmail.com>

 SPDX-License-Identifier: (GPL-2.0 OR MIT)

/*

 * Microsemi Ocelot Switch driver

 *

 * Copyright (c) 2017 Microsemi Corporation

 Caller must hold &ocelot->mact_lock */

 Caller must hold &ocelot->mact_lock */

 Caller must hold &ocelot->mact_lock */

	/* Set the MAC address to handle and the vlan associated in a format

	 * understood by the hardware.

 Set MAC_CPU_COPY if the CPU port is used by a multicast entry */

 Issue a write command */

 Issue a forget command */

	/* Configure the learning mode entries attributes:

	 * - Do not copy the frame to the CPU extraction queues.

	 * - Use the vlan and mac_cpoy for dmac lookup.

	/* Clear the MAC table. We are not concurrent with anyone, so

	 * holding &ocelot->mact_lock is pointless.

 Select the VID to configure */

 Set the vlan port members mask and issue a write command */

/* We use native VLAN when we have to mix egress-tagged VLANs with exactly

 * _one_ egress-untagged VLAN (_the_ native VLAN)

/* Keep in sync REW_TAG_CFG_TAG_CFG and, if applicable,

 * REW_PORT_VLAN_CFG_PORT_VID, with the bridge VLAN table and VLAN awareness

 * state of the port.

		/* Not having a native VLAN is impossible, because

		 * ocelot_port_num_untagged_vlans has returned 1.

		 * So there is no use in checking for NULL here.

 Default vlan to clasify for untagged frames (may be zero) */

	/* If there's no pvid, we should drop not only untagged traffic (which

	 * happens automatically), but also 802.1p traffic which gets

	 * classified to VLAN 0, but that is always in our RX filter, so it

	 * would get accepted were it not for this setting.

		/* Bridge VLANs can be overwritten with a different

		 * egress-tagging setting, so make sure to override an untagged

		 * with a tagged VID if that's going on.

 We are adding an egress-tagged VLAN */

 We are adding an egress-tagged VLAN */

 Default ingress vlan classification */

 Untagged egress vlan clasification */

 Ingress */

 Egress */

 Clear VLAN table, by default all ports are members of all VLANs */

 Configure the port VLAN memberships */

	/* Because VLAN filtering is enabled, we need VID 0 to get untagged

	 * traffic.  It is added automatically if 8021q module is loaded, but

	 * we can't rely on it since module may be not loaded.

	/* Set vlan ingress filter mask to all ports but the CPU port by

	 * default.

 Disable dequeuing from the egress queues */

 Disable flow control */

 Disable priority flow control */

	/* Wait at least the time it takes to receive a frame of maximum length

	 * at the port.

	 * Worst-case delays for 10 kilobyte jumbo frames are:

	 * 8 ms on a 10M port

	 * 800 μs on a 100M port

	 * 80 μs on a 1G port

	 * 32 μs on a 2.5G port

 Disable half duplex backpressure. */

 Flush the queues associated with the port. */

 Enable dequeuing from the egress queues. */

 Wait until flushing is complete. */

 Clear flushing again. */

 Re-enable flow control */

 Put the port in reset. */

	/* The MAC might be integrated in systems where the MAC speed is fixed

	 * and it's the PCS who is performing the rate adaptation, so we have

	 * to write "1000Mbps" into the LINK_SPEED field of DEV_CLOCK_CFG

	 * (which is also its default value).

	/* Take port out of reset by clearing the MAC_TX_RST, MAC_RX_RST and

	 * PORT_RST bits in DEV_CLOCK_CFG.

	/* Handle RX pause in all cases, with 2500base-X this is used for rate

	 * adaptation.

	/* Flow control. Link speed is only used here to evaluate the time

	 * specification in incoming pause frames.

	/* Undo the effects of ocelot_phylink_mac_link_down:

	 * enable MAC module

 Core: Enable port for frame transfer */

 Store timestamp ID in OCELOT_SKB_CB(clone)->ts_id */

 Don't do anything if PTP timestamping not enabled */

 Store ptp_cmd in OCELOT_SKB_CB(skb)->ptp_cmd */

 Fall back to two-step timestamping */

 Read current PTP time to get seconds */

 Read packet HW timestamp from FIFO */

 Sec has incremented since the ts was registered */

 Check if a timestamp can be retrieved */

 Retrieve the ts ID and Tx port */

 Retrieve its associated skb */

 Get the h/w timestamp */

 Set the timestamp into the skb */

 Next ts */

 Read the FCS */

 Update the statistics if part of the FCS was read before */

	/* Everything we see on an interface that is in the HW bridge

	 * has already been forwarded.

 Add padding */

 Indicate EOF and valid bytes in last word */

 Add dummy CRC */

 Caller must hold &ocelot->mact_lock */

 Set row and column to read from */

 Issue a read command */

 Read the entry flags */

	/* If the entry read has another port configured as its destination,

	 * do not report it.

 Get the entry's MAC address and VLAN id */

	/* We could take the lock just around ocelot_mact_read, but doing so

	 * thousands of times in a row seems rather pointless and inefficient.

 Loop through all the mac tables entries. */

			/* If the entry is invalid (wrong port, invalid...),

			 * skip it.

 reserved for future extensions */

 Tx type sanity check */

		/* IFH_REW_OP_ONE_STEP_PTP updates the correctional field, we

		 * need to update the origin time.

 Commit back the result & save it */

 Configure the port to read the stats from */

 check and update now */

 Copy all counters */

	/* If a DSA tag_8021q CPU exists, it needs to be included in the

	 * regular forwarding path of the front ports regardless of whether

	 * those are bridged or standalone.

	 * If DSA tag_8021q is not used, this returns 0, which is fine because

	 * the hardware-based CPU port module can be a destination for packets

	 * even if it isn't part of PGID_SRC.

	/* Apply FWD mask. The loop is needed to add/remove the current port as

	 * a source for the other ports.

 Unused ports can't send anywhere */

			/* The DSA tag_8021q CPU ports need to be able to

			 * forward packets to all other ports except for

			 * themselves

			/* Standalone ports forward only to DSA tag_8021q CPU

			 * ports (if those exist), or to the hardware CPU port

			 * module otherwise.

	/* Setting AGE_PERIOD to zero effectively disables automatic aging,

	 * which is clearly not what our intention is. So avoid that.

	/* According to VSC7514 datasheet 3.9.1.5 IPv4 Multicast Entries and

	 * 3.9.1.6 IPv6 Multicast Entries, "Instead of a lookup in the

	 * destination mask table (PGID), the destination set is programmed as

	 * part of the entry MAC address.", and the DEST_IDX is set to 0.

		/* When searching for a nonreserved multicast PGID, ignore the

		 * dummy PGID of zero that we have for MACv4/MACv6 entries

 Search for a free index in the nonreserved multicast PGID area */

 New entry */

		/* Existing entry. Clean up the current port mask from

		 * hardware now, because we'll be modifying it.

 We have a PGID with fewer ports now */

 Reset destination and aggregation PGIDS */

	/* The visited ports bitmask holds the list of ports offloading any

	 * bonding interface. Initially we mark all these ports as unvisited,

	 * then every time we visit a port in this bitmask, we know that it is

	 * the lowest numbered port, i.e. the one whose logical ID == physical

	 * port ID == LAG ID. So we mark as visited all further ports in the

	 * bitmask that are offloading the same bonding interface. This way,

	 * we set up the aggregation PGIDs only once per bonding interface.

 Now, set PGIDs for each active LAG */

 Destination mask

			/* Don't do division by zero if there was no active

			 * port. Just make all aggregation codes zero.

		/* Mark all ports in the same LAG as visited to avoid applying

		 * the same config again.

/* When offloading a bonding interface, the switch ports configured under the

 * same bond must have the same logical port ID, equal to the physical port ID

 * of the lowest numbered physical port in that bond. Otherwise, in standalone/

 * bridged mode, each port has a logical port ID equal to its physical port ID.

 Rebalance the LAGs */

/* Configure the maximum SDU (L2 payload) on RX to the value specified in @sdu.

 * The length of VLAN tags is accounted for automatically via DEV_MAC_TAGS_CFG.

 * In the special case that it's the NPI port that we're configuring, the

 * length of the tag and optional prefix needs to be accounted for privately,

 * in order to be able to sustain communication at the requested @sdu.

 Set Pause watermark hysteresis */

 Tail dropping watermarks */

 Basic L2 initialization */

	/* Set MAC IFG Gaps

	 * FDX: TX_IFG = 5, RX_IFG1 = RX_IFG2 = 0

	 * !FDX: TX_IFG = 5, RX_IFG1 = RX_IFG2 = 5

 Load seed (0) and set MAC HDX late collision  */

 Set Max Length and maximum tags allowed */

 Set SMAC of Pause frame (00:00:00:00:00:00) */

 Enable transmission of pause frames */

 Drop frames with multicast source address */

 Set default VLAN and tag type to 8021Q. */

 Disable source address learning for standalone mode */

	/* Set the port's initial logical port ID value, enable receiving

	 * frames on it, and configure the MAC address learning type to

	 * automatic.

 Enable vcap lookups */

/* Configure and enable the CPU port module, which is a set of queues

 * accessible through register MMIO, frame DMA or Ethernet (in case

 * NPI mode is used).

 The unicast destination PGID for the CPU port module is unused */

	/* Instead set up a multicast destination PGID for traffic copied to

	 * the CPU. Whitelisted MAC addresses like the port netdevice MAC

	 * addresses will be copied to the CPU via this PGID.

 Enable CPU port module */

 CPU port Injection/Extraction configuration */

 Configure the CPU port to be VLAN aware */

	/* For Ocelot, Felix, Seville, Serval etc, SYS:MMGT:MMGT:FREECNT holds

	 * the number of 240-byte free memory words (aka 4-cell chunks) and not

	 * 192 bytes as the documentation incorrectly says.

 Clear all counters (5 groups) */

 Only use S-Tag */

 Aggregation mode */

	/* Set MAC age time to default value. The entry is aged after

	 * 2*AGE_PERIOD

 Disable learning for frames discarded by VLAN ingress filtering */

 Setup frame ageing - fixed value "2 sec" - in 6.5 us units */

 Setup flooding PGIDs */

 Transmit the frame to the local port. */

 Do not forward BPDU frames to the front ports. */

 Ensure bridging is disabled */

 Allow broadcast and unknown L2 multicast to the CPU. */

	/* Allow manual injection via DEVCPU_QS registers, and byte swap these

	 * registers endianness.

 SPDX-License-Identifier: (GPL-2.0 OR MIT)

/* Copyright 2020-2021 NXP

/* The queue system tracks four resource consumptions:

 * Resource 0: Memory tracked per source port

 * Resource 1: Frame references tracked per source port

 * Resource 2: Memory tracked per destination port

 * Resource 3: Frame references tracked per destination port

/* For each resource type there are 4 types of watermarks:

 * Q_RSRV: reservation per QoS class per port

 * PRIO_SHR: sharing watermark per QoS class across all ports

 * P_RSRV: reservation per port

 * COL_SHR: sharing watermark per color (drop precedence) across all ports

/* Reservation Watermarks

 * ----------------------

 *

 * For setting up the reserved areas, egress watermarks exist per port and per

 * QoS class for both ingress and egress.

/*  Amount of packet buffer

 *  |  per QoS class

 *  |  |  reserved

 *  |  |  |   per egress port

 *  |  |  |   |

 *  V  V  v   v

 * BUF_Q_RSRV_E

/*  Amount of packet buffer

 *  |  for all port's traffic classes

 *  |  |  reserved

 *  |  |  |   per egress port

 *  |  |  |   |

 *  V  V  v   v

 * BUF_P_RSRV_E

/*  Amount of packet buffer

 *  |  per QoS class

 *  |  |  reserved

 *  |  |  |   per ingress port

 *  |  |  |   |

 *  V  V  v   v

 * BUF_Q_RSRV_I

/*  Amount of packet buffer

 *  |  for all port's traffic classes

 *  |  |  reserved

 *  |  |  |   per ingress port

 *  |  |  |   |

 *  V  V  v   v

 * BUF_P_RSRV_I

/*  Amount of frame references

 *  |  per QoS class

 *  |  |  reserved

 *  |  |  |   per egress port

 *  |  |  |   |

 *  V  V  v   v

 * REF_Q_RSRV_E

/*  Amount of frame references

 *  |  for all port's traffic classes

 *  |  |  reserved

 *  |  |  |   per egress port

 *  |  |  |   |

 *  V  V  v   v

 * REF_P_RSRV_E

/*  Amount of frame references

 *  |  per QoS class

 *  |  |  reserved

 *  |  |  |   per ingress port

 *  |  |  |   |

 *  V  V  v   v

 * REF_Q_RSRV_I

/*  Amount of frame references

 *  |  for all port's traffic classes

 *  |  |  reserved

 *  |  |  |   per ingress port

 *  |  |  |   |

 *  V  V  v   v

 * REF_P_RSRV_I

/* Sharing Watermarks

 * ------------------

 *

 * The shared memory area is shared between all ports.

/* Amount of buffer

 *  |   per QoS class

 *  |   |    from the shared memory area

 *  |   |    |  for egress traffic

 *  |   |    |  |

 *  V   V    v  v

 * BUF_PRIO_SHR_E

/* Amount of buffer

 *  |   per color (drop precedence level)

 *  |   |   from the shared memory area

 *  |   |   |  for egress traffic

 *  |   |   |  |

 *  V   V   v  v

 * BUF_COL_SHR_E

/* Amount of buffer

 *  |   per QoS class

 *  |   |    from the shared memory area

 *  |   |    |  for ingress traffic

 *  |   |    |  |

 *  V   V    v  v

 * BUF_PRIO_SHR_I

/* Amount of buffer

 *  |   per color (drop precedence level)

 *  |   |   from the shared memory area

 *  |   |   |  for ingress traffic

 *  |   |   |  |

 *  V   V   v  v

 * BUF_COL_SHR_I

/* Amount of frame references

 *  |   per QoS class

 *  |   |    from the shared area

 *  |   |    |  for egress traffic

 *  |   |    |  |

 *  V   V    v  v

 * REF_PRIO_SHR_E

/* Amount of frame references

 *  |   per color (drop precedence level)

 *  |   |   from the shared area

 *  |   |   |  for egress traffic

 *  |   |   |  |

 *  V   V   v  v

 * REF_COL_SHR_E

/* Amount of frame references

 *  |   per QoS class

 *  |   |    from the shared area

 *  |   |    |  for ingress traffic

 *  |   |    |  |

 *  V   V    v  v

 * REF_PRIO_SHR_I

/* Amount of frame references

 *  |   per color (drop precedence level)

 *  |   |   from the shared area

 *  |   |   |  for ingress traffic

 *  |   |   |  |

 *  V   V   v  v

 * REF_COL_SHR_I

/* The hardware comes out of reset with strange defaults: the sum of all

 * reservations for frame memory is larger than the total buffer size.

 * One has to wonder how can the reservation watermarks still guarantee

 * anything under congestion.

 * Bring some sense into the hardware by changing the defaults to disable all

 * reservations and rely only on the sharing watermark for frames with drop

 * precedence 0. The user can still explicitly request reservations per port

 * and per port-tc through devlink-sb.

/* We want the sharing watermarks to consume all nonreserved resources, for

 * efficient resource utilization (a single traffic flow should be able to use

 * up the entire buffer space and frame resources as long as there's no

 * interference).

 * The switch has 10 sharing watermarks per lookup: 8 per traffic class and 2

 * per color (drop precedence).

 * The trouble with configuring these sharing watermarks is that:

 * (1) There's a risk that we overcommit the resources if we configure

 *     (a) all 8 per-TC sharing watermarks to the max

 *     (b) all 2 per-color sharing watermarks to the max

 * (2) There's a risk that we undercommit the resources if we configure

 *     (a) all 8 per-TC sharing watermarks to "max / 8"

 *     (b) all 2 per-color sharing watermarks to "max / 2"

 * So for Linux, let's just disable the sharing watermarks per traffic class

 * (setting them to 0 will make them always exceeded), and rely only on the

 * sharing watermark for drop priority 0. So frames with drop priority set to 1

 * by QoS classification or policing will still be allowed, but only as long as

 * the port and port-TC reservations are not exceeded.

/* Calculate all reservations, then set up the sharing watermark for DP=0 to

 * consume the remaining resources up to the pool's configured size.

 Ensure that all reservations can be enforced */

/* The hardware works like this:

 *

 *                         Frame forwarding decision taken

 *                                       |

 *                                       v

 *       +--------------------+--------------------+--------------------+

 *       |                    |                    |                    |

 *       v                    v                    v                    v

 * Ingress memory       Egress memory        Ingress frame        Egress frame

 *     check                check           reference check      reference check

 *       |                    |                    |                    |

 *       v                    v                    v                    v

 *  BUF_Q_RSRV_I   ok    BUF_Q_RSRV_E   ok    REF_Q_RSRV_I   ok     REF_Q_RSRV_E   ok

 *(src port, prio) -+  (dst port, prio) -+  (src port, prio) -+   (dst port, prio) -+

 *       |          |         |          |         |          |         |           |

 *       |exceeded  |         |exceeded  |         |exceeded  |         |exceeded   |

 *       v          |         v          |         v          |         v           |

 *  BUF_P_RSRV_I  ok|    BUF_P_RSRV_E  ok|    REF_P_RSRV_I  ok|    REF_P_RSRV_E   ok|

 *   (src port) ----+     (dst port) ----+     (src port) ----+     (dst port) -----+

 *       |          |         |          |         |          |         |           |

 *       |exceeded  |         |exceeded  |         |exceeded  |         |exceeded   |

 *       v          |         v          |         v          |         v           |

 * BUF_PRIO_SHR_I ok|   BUF_PRIO_SHR_E ok|   REF_PRIO_SHR_I ok|   REF_PRIO_SHR_E  ok|

 *     (prio) ------+       (prio) ------+       (prio) ------+       (prio) -------+

 *       |          |         |          |         |          |         |           |

 *       |exceeded  |         |exceeded  |         |exceeded  |         |exceeded   |

 *       v          |         v          |         v          |         v           |

 * BUF_COL_SHR_I  ok|   BUF_COL_SHR_E  ok|   REF_COL_SHR_I  ok|   REF_COL_SHR_E   ok|

 *      (dp) -------+        (dp) -------+        (dp) -------+        (dp) --------+

 *       |          |         |          |         |          |         |           |

 *       |exceeded  |         |exceeded  |         |exceeded  |         |exceeded   |

 *       v          v         v          v         v          v         v           v

 *      fail     success     fail     success     fail     success     fail      success

 *       |          |         |          |         |          |         |           |

 *       v          v         v          v         v          v         v           v

 *       +-----+----+         +-----+----+         +-----+----+         +-----+-----+

 *             |                    |                    |                    |

 *             +-------> OR <-------+                    +-------> OR <-------+

 *                        |                                        |

 *                        v                                        v

 *                        +----------------> AND <-----------------+

 *                                            |

 *                                            v

 *                                    FIFO drop / accept

 *

 * We are modeling each of the 4 parallel lookups as a devlink-sb pool.

 * At least one (ingress or egress) memory pool and one (ingress or egress)

 * frame reference pool need to have resources for frame acceptance to succeed.

 *

 * The following watermarks are controlled explicitly through devlink-sb:

 * BUF_Q_RSRV_I, BUF_Q_RSRV_E, REF_Q_RSRV_I, REF_Q_RSRV_E

 * BUF_P_RSRV_I, BUF_P_RSRV_E, REF_P_RSRV_I, REF_P_RSRV_E

 * The following watermarks are controlled implicitly through devlink-sb:

 * BUF_COL_SHR_I, BUF_COL_SHR_E, REF_COL_SHR_I, REF_COL_SHR_E

 * The following watermarks are unused and disabled:

 * BUF_PRIO_SHR_I, BUF_PRIO_SHR_E, REF_PRIO_SHR_I, REF_PRIO_SHR_E

 *

 * This function overrides the hardware defaults with more sane ones (no

 * reservations by default, let sharing use all resources) and disables the

 * unused watermarks.

/* Pool size and type are fixed up at runtime. Keeping this structure to

 * look up the cell size multipliers.

 Returns the pool size configured through ocelot_sb_pool_set */

/* The pool size received here configures the total amount of resources used on

 * ingress (or on egress, depending upon the pool index). The pool size, minus

 * the values for the port and port-tc reservations, is written into the

 * COL_SHR(dp=0) sharing watermark.

 This retrieves the configuration made with ocelot_sb_port_pool_set */

 This configures the P_RSRV per-port reserved resource watermark */

 This retrieves the configuration done by ocelot_sb_tc_pool_bind_set */

 This configures the Q_RSRV per-port-tc reserved resource watermark */

 Paranoid check? */

/* The hardware does not support atomic snapshots, we'll read out the

 * occupancy registers individually and have this as just a stub.

/* The watermark occupancy registers are cleared upon read,

 * so let's read them.

 This retrieves the watermark occupancy for per-port P_RSRV watermarks */

 This retrieves the watermark occupancy for per-port-tc Q_RSRV watermarks */

 SPDX-License-Identifier: (GPL-2.0 OR MIT)

/* Microsemi Ocelot Switch driver

 * Copyright (c) 2019 Microsemi Corporation

 Copy from Cache to TCAM */

 Copy from TCAM to Cache */

 Move <count> up */

 Move <count> down */

 Write all (from cache) */

 Max entry width (32bit words) */

 Max counter width (32bit words) */

 ENTRY_DAT */

 MASK_DAT */

 ACTION_DAT */

 CNT_DAT */

 TG_DAT */

 Action type */

 Current type-group */

 Current counter */

 Current entry offset */

 Current action offset */

 Current counter offset */

 Current type-group value */

 Current type-group mask */

 Convert from 0-based row to VCAP entry row and run command */

 Invert mask

 Encode action type */

 Extract action type */

 Calculate offsets for entry */

 Calculate key/action/counter offsets */

	/* Data wider than 32 bits are split up in chunks of maximum 32 bits.

	 * The 32 LSB of the data are written to the 32 MSB of the TCAM.

 Read row */

 Clear unused bits */

 OPCODE is inverse, bit 0 is reply flag, bit 1 is RARP flag */

 UDP/TCP protocol match */

 Any IP protocol match */

 Non-UDP/TCP protocol match */

		/* Iterate over the non-common part of the key and

		 * clear entry data

 Write row */

 Read row */

 Overloaded field */

 IPv4 "other" frame */

 Overloaded field */

 Write row */

 Read row */

 Write row */

/* If @on=false, then SNAP, ARP, IP and OAM frames will not match on keys based

 * on destination and source MAC addresses, but only on higher-level protocol

 * information. The only frame types to match on keys containing MAC addresses

 * in this case are non-SNAP, non-ARP, non-IP and non-OAM frames.

 *

 * If @on=true, then the above frame types (SNAP, ARP, IP and OAM) will match

 * on MAC_ETYPE keys such as destination and source MAC on this ingress port.

 * However the setting has the side effect of making these frames not matching

 * on any _other_ keys than MAC_ETYPE ones.

 ETH_P_ALL match, so all protocols below are included */

 We only have the S2_IP_TCPUDP_DIS set of knobs for VCAP IS2 */

 Search for any non-MAC_ETYPE rules on the port */

 Search for any MAC_ETYPE rules on the port */

 Add filter to the linked list */

 Get the index of the inserted filter */

 Move down the rules to make place for the new filter */

 Now insert the new filter */

 Gets index of the filter */

 Delete filter */

 Move up all the blocks over the deleted filter */

 Now delete the last filter, because it is duplicated */

 After we get the result we need to clear the counters */

 Only version 0 VCAP supported for now */

 Width in bits of type-group field */

 Number of subwords per TCAM row */

	/* Number of rows in TCAM. There can be this many full keys, or double

	 * this number half keys, or 4 times this number quarter keys.

	/* Assuming there are 4 subwords per TCAM row, their layout in the

	 * actual TCAM (not in the cache) would be:

	 *

	 * |  SW 3  | TG 3 |  SW 2  | TG 2 |  SW 1  | TG 1 |  SW 0  | TG 0 |

	 *

	 * (where SW=subword and TG=Type-Group).

	 *

	 * What VCAP_CONST_ENTRY_CNT is giving us is the width of one full TCAM

	 * row. But when software accesses the TCAM through the cache

	 * registers, the Type-Group values are written through another set of

	 * registers VCAP_TG_DAT, and therefore, it appears as though the 4

	 * subwords are contiguous in the cache memory.

	 * Important mention: regardless of the number of key entries per row

	 * (and therefore of key size: 1 full key or 2 half keys or 4 quarter

	 * keys), software always has to configure 4 Type-Group values. For

	 * example, in the case of 1 full key, the driver needs to set all 4

	 * Type-Group to be full key.

	 *

	 * For this reason, we need to fix up the value that the hardware is

	 * giving us. We don't actually care about the width of the entry in

	 * the TCAM. What we care about is the width of the entry in the cache

	 * registers, which is how we get to interact with it. And since the

	 * VCAP_ENTRY_DAT cache registers access only the subwords and not the

	 * Type-Groups, this means we need to subtract the width of the

	 * Type-Groups when packing and unpacking key entry data in a TCAM row.

	/* The width of the counter memory, this is the complete width of all

	 * counter-fields associated with one full-word entry. There is one

	 * counter per entry sub-word (see CAP_CORE::ENTRY_SWCNT for number of

	 * subwords.)

	/* Create a policer that will drop the frames for the cpu.

	 * This policer will be used as action in the acl rules to drop

	 * frames.

 SPDX-License-Identifier: (GPL-2.0 OR MIT)

/*

 * Microsemi Ocelot Switch driver

 *

 * Copyright (c) 2017 Microsemi Corporation

 VCAP_CORE_CFG */

 VCAP_CORE_CACHE */

 VCAP_CONST */

 Replicated per number of ports (12), register size 4 per port */

	/* Configure PLL5. This will need a proper CCF driver

	 * The values are coming from the VTSS API for Ocelot

/* Watermark encode

 * Bit 8:   Unit; 0:1, 1:16

 * Bit 7-0: Value to be multiplied with unit

 Specific Fields for IS1 Half Key S1_NORMAL */

 Layer-3 Information */

 Layer-4 Information */

 Specific Fields for IS1 Half Key S1_5TUPLE_IP4 */

 The fields below are incorrectly shifted by 2 in the manual */

 Common: 46 bits */

 MAC_ETYPE / MAC_LLC / MAC_SNAP / OAM common */

 MAC_ETYPE (TYPE=000) */

 MAC_LLC (TYPE=001) */

 MAC_SNAP (TYPE=010) */

 MAC_ARP (TYPE=011) */

 IP4_TCP_UDP / IP4_OTHER common */

 IP4_TCP_UDP (TYPE=100) */

 IP4_OTHER (TYPE=101) */

 IP6_STD (TYPE=110) */

 OAM (TYPE=111) */

 HIT_STICKY not included */

 HIT_STICKY not included */

 Initialize unused devlink ports at the end */

 Unregister the network interfaces */

 Tear down devlink ports for the registered network interfaces */

 Both the PTP interrupt and the PTP bank are available */

 SPDX-License-Identifier: (GPL-2.0 OR MIT)

/*

 * Microsemi Ocelot Switch driver

 *

 * Copyright (c) 2017 Microsemi Corporation

 SPDX-License-Identifier: (GPL-2.0 OR MIT)

/* Microsemi Ocelot Switch driver

 * Copyright (c) 2019 Microsemi Corporation

/* Arbitrarily chosen constants for encoding the VCAP block and lookup number

 * into the chain number. This is UAPI.

	/* Backwards compatibility with older, single-chain tc-flower

	 * offload support in Ocelot

/* Caller must ensure this is a valid IS1 or IS2 chain first,

 * by calling ocelot_chain_to_block.

/* Caller must ensure this is a valid IS2 chain first,

 * by calling ocelot_chain_to_block.

 calculate PAG value as chain index relative to the first PAG */

 Can't offload GOTO in VCAP ES0 */

 Non-optional GOTOs */

 VCAP IS1 can be skipped, either partially or completely */

	/* Lookup 2 of VCAP IS1 can really support non-optional GOTOs,

	 * using a Policy Association Group (PAG) value, which is an 8-bit

	 * value encoding a VCAP IS2 target chain.

	/* Non-optional GOTO from VCAP IS2 lookup 0 to lookup 1.

	 * We cannot change the PAG at this point.

 VCAP IS2 lookup 1 cannot jump anywhere */

 For VCAP ES0 (egress rewriter) we can match on the ingress port */

		/* The hw support mac matches only for MAC_ETYPE key,

		 * therefore if other matches(port, tcp flags, etc) are added

		 * then just bail out

 TODO: support SNAP, LLC etc */

 else, a filter of type OCELOT_VCAP_KEY_ANY is implicitly added */

/* If we have an egress VLAN modification rule, we need to actually write the

 * delta between the input VLAN (from the key) and the output VLAN (from the

 * action), but the action was parsed first. So we need to patch the delta into

 * the action here.

	/* The non-optional GOTOs for the TCAM skeleton don't need

	 * to be actually offloaded.

 SPDX-License-Identifier: (GPL-2.0 OR MIT)

/* Microsemi Ocelot Switch driver

 *

 * Copyright (c) 2017, 2019 Microsemi Corporation

 * Copyright 2020-2021 NXP

	/* Here is possible to use control or test dmac because the mask

	 * doesn't cover the LSB

 SPDX-License-Identifier: (GPL-2.0 OR MIT)

/* Microsemi Ocelot Switch driver

 *

 * Copyright (c) 2019 Microsemi Corporation

 Types for ANA:POL[0-192]:POL_MODE_CFG.FRM_MODE */

 Incl IPG. Unit: 33 1/3 kbps, 4096 bytes */

 Excl IPG. Unit: 33 1/3 kbps, 4096 bytes  */

 Unit: 33 1/3 fps, 32.8 frames */

 Unit: 1/3 fps, 0.3 frames */

 Policer indexes */

 0-11    : Port policers */

 32-127  : Queue policers  */

 Default policer order */

 Ocelot policer order: Serial (QoS -> Port -> VCAP) */

 Discard cir frames */

 33 1/3 kbps */

 No zero burst size */

 Limit burst size */

 Discard PIR frames */

 33 1/3 kbps */

 No zero burst size */

 Limit burst size */

 33 1/3 fps */

 32.8 frames */

 No zero burst size */

 Limit burst size */

 Discard all frames */

 1/3 fps */

 0.3 frames */

 No zero burst size */

 Limit burst size */

 MSCC_QOS_RATE_MODE_DISABLED */

 Disable policer using maximum rate and zero burst */

 Check limits */

 SPDX-License-Identifier: (GPL-2.0 OR MIT)

/* Microsemi Ocelot Switch driver

 *

 * This contains glue logic between the switchdev driver operations and the

 * mscc_ocelot_switch_lib.

 *

 * Copyright (c) 2017, 2019 Microsemi Corporation

 * Copyright 2020-2021 NXP

 Add the port MAC address to with the right VLAN information */

	/* 8021q removes VID 0 on module unload for all interfaces

	 * with VLAN filtering feature. We need to keep it to receive

	 * untagged traffic.

 Del the port MAC address to with the right VLAN information */

 Check if timestamping is needed */

 OCELOT_MACT_LEARN */

 OCELOT_MACT_FORGET */

	/* This doesn't handle promiscuous mode because the bridge core is

	 * setting IFF_PROMISC on all slave interfaces and all frames would be

	 * forwarded to the CPU port.

 Learn the new net device MAC address in the mac table. */

 Then forget the previous one. */

 Configure the port to read the stats from */

 Get Rx stats */

 Get Tx stats */

 Filtering */

	/* If the attached PHY device isn't capable of timestamping operations,

	 * use our own (when possible).

 Checks if the net_device instance given to us originates from our driver */

/* Treat CHANGEUPPER events on an offloaded LAG as individual CHANGEUPPER

 * events for the lower physical ports of the LAG.

 * If the LAG upper isn't offloaded, ignore its CHANGEUPPER events.

 * In case the LAG joined a bridge, notify that we are offloading it and can do

 * forwarding in hardware towards it.

 Blocking events. */

 Disable HDX fast control */

 SGMII only for now */

 Enable PCS */

 No aneg on SGMII */

 No loopback */

	/* DT bindings of internal PHY ports are broken and don't

	 * specify a phy-mode

 Ensure clock signals and speed are set on all QSGMII links */

 SPDX-License-Identifier: (GPL-2.0 OR MIT)

/* Microsemi Ocelot PTP clock driver

 *

 * Copyright (c) 2017 Microsemi Corporation

 * Copyright 2020 NXP

 Deal with negative values */

 Fall back using ocelot_ptp_settime64 which is not exact. */

 If the adjustment value is too large, use ns instead */

 Still too big */

 Reject requests with unsupported flags */

 Handle turning off */

 Compatibility */

 Calculate waveform high and low times */

 Handle PPS request */

 Handle periodic clock */

 Check if PHC support is missing at the configuration level */

	/* There is no device reconfiguration, PTP Rx stamping is always

	 * enabled.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * QLogic QLA3xxx NIC HBA Driver

 * Copyright (c)  2003-2006 QLogic Corporation

 defaults above */

 required last entry */

/*

 *  These are the known PHY's which are used

/*

 * Caller must take hw_lock.

/*

 * Caller holds hw_lock.

/*

 * Caller holds hw_lock. Only called during init.

/*

 * Caller holds hw_lock. Only called during init.

 The list is empty  */

			/*

			 * We save some space to copy the ethhdr from first

			 * buffer

/*

 * Caller holds hw_lock.

/*

 * Caller holds hw_lock.

 Clock in a zero, then do the start bit */

 Force the previous data bit to be different */

 If the bit changed, change the DO state to match */

 Force the previous data bit to be different */

			/*

			 * If the bit changed, then change the DO state to

			 * match

/*

 * Caller holds hw_lock.

/*

 * Caller holds hw_lock.

 Read the data bits */

 The first bit is a dummy.  Clock right over it. */

/*

 * Caller holds hw_lock.

 Auto scan will cycle through multiple ports */

	/*

	 * Scan register 1 of PHY/PETBI,

	 * Set up to scan both devices

	 * The autoscan starts from the first register, completes

	 * the last one before rolling over to the first

 See if scan mode is enabled before we turn it off */

 Scan is enabled */

 Scan is disabled */

	/*

	 * When disabling scan mode you must first change the MII register

	 * address

 Wait for write to complete 9/10/04 SJP */

 Wait for the read to complete */

 Wait for write to complete. */

 Wait for the read to complete */

 Enable Auto-negotiation sense */

 Enable Auto-negotiation sense */

 power down device bit 11 = 1 */

 enable diagnostic mode bit 2 = 1 */

 1000MB amplitude adjust (see Agere errata) */

 1000MB amplitude adjust (see Agere errata) */

 100MB amplitude adjust (see Agere errata) */

 100MB amplitude adjust (see Agere errata) */

 10MB amplitude adjust (see Agere errata) */

 10MB amplitude adjust (see Agere errata) */

 point to hidden reg 0x2806 */

 Write new PHYAD w/bit 5 set */

	/*

	 * Disable diagnostic mode bit 2 = 0

	 * Power up device bit 11 = 0

	 * Link up (on) and activity (blink)

 oui is split between two registers */

 Scan table for this PHY */

  Determine the PHY we are using by reading the ID's */

  Check if we have a Agere PHY */

		/* Determine which MII address we should be using

  We need to remember to initialize the Agere PHY */

	/*  Determine the particular PHY we have on board to apply

 need this here so address gets changed */

/*

 * Caller holds hw_lock.

/*

 * Caller holds hw_lock.

/*

 * Caller holds hw_lock.

/*

 * Caller holds hw_lock.

/*

 * Caller holds hw_lock.

/*

 * Caller holds hw_lock.

/*

 * Caller holds hw_lock.

/*

 *  ql_is_neg_pause() returns 1 if pause was negotiated to be on

/*

 * Caller holds hw_lock.

/*

 * Caller holds hw_lock.

/*

 * Caller holds hw_lock.

 turn off external loopback */

	/*  Some HBA's in the field are set to 0 and they need to

 Set the 1000 advertisements */

 Set the 10/100 & pause negotiation advertisements */

/*

 * Caller holds hw_lock.

 Copper port */

 configure the MAC */

 enable the MAC */

 Remote error detected */

			/*

			 * ql_port_start() is shared code and needs

			 * to lock the PHY on it's own.

 Restart port */

 Restart timer on 2 second interval. */

		/*

		 * See if the link is currently down or went down and came

		 * back up

 Restart timer on 2 second interval. */

/*

 * Caller must take hw_lock and QL_PHY_GIO_SEM.

/*

 * Caller must take hw_lock and QL_PHY_GIO_SEM.

/*

 * MII_Setup needs to be called before taking the PHY out of reset

 * so that the management interface clock speed can be set properly.

 * It would be better if we had a way to disable MDC until after the

 * PHY is out of reset, but we don't have that capability.

 Divide 125MHz clock by 28 to meet PHY timing requirements */

				/*

				 * We save some space to copy the ethhdr from

				 * first buffer

/*

 * Caller holds hw_lock.

/*

 * Caller holds hw_lock.

  Check the transmit response flags for any errors */

/*

 * The difference between 3022 and 3032 for inbound completions:

 * 3022 uses two buffers per completion.  The first buffer contains

 * (some) header info, the second the remainder of the headers plus

 * the data.  For this chip we reserve some space at the top of the

 * receive buffer so that the header info in buffer one can be

 * prepended to the buffer two.  Buffer two is the sent up while

 * buffer one is returned to the hardware to be reused.

 * 3032 receives all of it's data and headers in one buffer for a

 * simpler process.  3032 also supports checksum verification as

 * can be seen in ql_process_macip_rx_intr().

	/*

	 * Get the inbound address list (small buffer).

 start of second buffer */

	/*

	 * Get the inbound address list (small buffer).

 start of first buffer on 3022 */

 start of second buffer */

 Just the second buffer length here. */

		/*

		 * Copy the ethhdr from first buffer to second. This

		 * is necessary for 3022 IP completions.

 While there are entries in the completion queue. */

		/*

		 * Fix 4032 chip's undocumented "feature" where bit-8 is set

		 * if the inbound completion is for a VLAN.

			/*

			 * Chip Fatal Error.

			/*

			 * Soft Reset Requested.

/*

 * Get the total number of segments needed for the given number of fragments.

 * This is necessary because outbound address lists (OAL) will be used when

 * more than two frags are given.  Each address list has 5 addr/len pairs.

 * The 5th pair in each OAL is used to  point to the next OAL if more frags

 * are coming.  That is why the frags:segment count ratio is not linear.

/*

 * Map the buffers for this transmit.

 * This will return NETDEV_TX_BUSY or NETDEV_TX_OK based on success.

	/*

	 * Map the skb buffer first.

 Terminate the last segment. */

		/*

		 * Check for continuation requirements.

		 * It's strange but necessary.

		 * Continuation entry points to outbound address list.

 Terminate the last segment. */

	/* A PCI mapping failed and now we will need to back out

	 * We need to traverse through the oal's and associated pages which

	 * have been mapped and now we must unmap them to clean up properly

		/*

		 * Check for continuation requirements.

		 * It's strange but necessary.

/*

 * The difference between 3022 and 3032 sends:

 * 3022 only supports a simple single segment transmission.

 * 3032 supports checksumming and scatter/gather lists (fragments).

 * The 3032 supports sglists by using the 3 addr/len pairs (ALP)

 * in the IOCB plus a chain of outbound address lists (OAL) that

 * each contain 5 ALPs.  The last ALP of the IOCB (3rd) or OAL (5th)

 * will be used to point to an OAL when more ALP entries are required.

 * The IOCB is always the top of the chain followed by one or more

 * OALs (when necessary).

	/* The barrier is required to ensure request and response queue

	 * addr writes to the registers.

 Create Large Buffer Queue */

 Create Small Buffer Queue */

 Currently we allocate on one of memory and use it for smallbuffers */

 Initialize the small buffer queue. */

 Better luck next round */

			/*

			 * We save some space to copy the ethhdr from first

			 * buffer

 Create free list of transmit buffers */

		/*

		 * Bigger buffers, so less of them.

	/*

	 * First allocate a page of shared memory and use it for shadow

	 * locations of Network Request Queue Consumer Address Register and

	 * Network Completion Queue Producer Index Register

 Initialize the large buffer queue. */

 Bring out PHY out of reset */

 Give the PHY time to come out of reset. */

 V2 chip fix for ARS-39168. */

 Request Queue Registers */

 Response Queue Registers */

 Large Buffer Queue */

 Small Buffer Queue */

	/*

	 * Find out if the chip has already been initialized.  If it has, then

	 * we skip some of the initialization.

 Chip has not been configured yet, so let it rip. */

 Load the MAC Configuration */

 Program lower 32 bits of the MAC address */

 Program top 16 bits of the MAC address */

 Enable Primary MAC */

 Clear Primary and Secondary IP addresses */

 Indicate Configuration Complete */

 Enable Ethernet Function */

/*

 * Caller holds hw_lock.

	/*

	 * Issue soft reset to chip.

 Wait 3 seconds for reset to complete. */

 Wait until the firmware tells us the Soft Reset is done */

	/*

	 * Also, make sure that the Network Reset Interrupt bit has been

	 * cleared after the soft reset has taken place.

 Issue Force Soft Reset */

		/*

		 * Wait until the firmware tells us the Force Soft Reset is

		 * done

 Get the function number */

	/*

	 * Print PCI bus width/type.

	/*

	 * Wait for device to recover from a reset.

	 * (Rarely happens, but possible.)

 Program lower 32 bits of the MAC address */

 Program top 16 bits of the MAC address */

	/*

	 * Stop the queues, we've got a problem.

	/*

	 * Wake up the worker to process this event.

		/*

		 * Loop through the active list and return the skb.

		/*

		 * Wait the for Soft Reset to Complete.

			/*

			 * Set the reset flags and clear the board again.

			 * Nothing else to do...

 Set driver entry points */

 make sure the EEPROM is good */

 Validate and set parameters */

 Record PCI bus information. */

	/*

	 * Set the Maximum Memory Read Byte Count value. We do this to handle

	 * jumbo frames.

 we're going to reset, so assume we have no link for now */

 two second delay */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)

/* QLogic qed NIC Driver

 * Copyright (c) 2015-2017  QLogic Corporation

 * Copyright (c) 2019-2020 Marvell International Ltd.

 MFW speed capabilities maps */

 To prevent marking this module as "permanent" */

/* Check if the DMA controller on the machine can properly handle the DMA

 * addressing required by the device.

/* Performs PCI initializations as well as initializing PCI-related parameters

 * in the device structrue. Returns 0 in case of success.

 AER (Advanced Error reporting) configuration */

 Sets the requested power state */

 probing */

		/* If fastpath is initialized, we need at least one interrupt

		 * per hwfn [and the slow path interrupts]. New requested number

		 * should be a multiple of the number of hwfns.

	/* For VFs, we should return with an error in case we didn't get the

	 * exact number of msix vectors as we requested.

	 * Not doing that will lead to a crash when starting queues for

	 * this VF.

 MSI-x configuration was achieved */

 This function outputs the int mode and the number of enabled msix vector */

 Allocate MSIX table */

 Enable MSIX */

 Slowpath interrupt */

 Fastpath interrupts */

	/* Calling the disable function will make sure that any

	 * currently-running function is completed. The following call to the

	 * enable function makes this sequence a flush-like operation.

 Determine if interface is going to require LL2 */

 Mark the fastpath as free/used */

	/* Need to expose only MSI-X information; Single IRQ is handled solely

	 * by qed.

 slowpath */

 We want a minimum of one slowpath and one fastpath vector per hwfn */

 We want a minimum of one fastpath vector per vf hwfn */

 divide by 3 the MRs to avoid MF ILT overflow */

	/* In case we might support RDMA, don't allow qede to be greedy

	 * with the L2 contexts. Allow for 64 queues [rx, tx cos, xdp]

	 * per hwfn.

 Memory barrier for setting atomic bit */

 Memory barrier after setting atomic bit */

 Reset periodic Doorbell Recovery counter */

 Don't schedule periodic Doorbell Recovery if already scheduled */

 Stop queuing new delayed works */

 skip qed_db_rec_handler during recovery/unload */

 Allocate stream for unzipping */

 First Dword used to differentiate between various sources */

 Start the slowpath */

 Allocate LL2 interface if needed */

 RoCE/Storage use a single engine in CMT mode while L2 uses both */

 RoCE/Storage use a single engine in CMT mode while L2 uses both */

 The link should be set only once per PF */

	/* When VF wants to set link, force it to read the bulletin instead.

	 * This mimics the PF behavior, where a noitification [both immediate

	 * and possible later] would be generated when changing properties.

 For DAC media multiple speed capabilities are supported */

 Prepare source inputs */

 Set the link parameters to pass to protocol driver */

 Fill link advertised capability */

 Fill link supported capability */

 Fill partner advertised capability */

 TODO - fill duplex properly */

 MFW clears adv_caps on eee disable; use configured value */

 Allocate a buffer for holding the nvram image */

 Read image into buffer */

	/* Convert the buffer into big-endian format (excluding the

	 * closing 4 bytes of CRC).

	/* Calc CRC for the "actual" image buffer, i.e. not including

	 * the last 4 CRC bytes.

/* Binary file format -

 *     /----------------------------------------------------------------------\

 * 0B  |                       0x4 [command index]                            |

 * 4B  | image_type     | Options        |  Number of register settings       |

 * 8B  |                       Value                                          |

 * 12B |                       Mask                                           |

 * 16B |                       Offset                                         |

 *     \----------------------------------------------------------------------/

 * There can be several Value-Mask-Offset sets as specified by 'Number of...'.

 * Options - 0'b - Calculate & Update CRC for image

 Iterate over the values for setting */

/* Binary file format -

 *     /----------------------------------------------------------------------\

 * 0B  |                       0x3 [command index]                            |

 * 4B  | b'0: check_response?   | b'1-31  reserved                            |

 * 8B  | File-type |                   reserved                               |

 * 12B |                    Image length in bytes                             |

 *     \----------------------------------------------------------------------/

 *     Start a new file of the provided type

/* Binary file format -

 *     /----------------------------------------------------------------------\

 * 0B  |                       0x2 [command index]                            |

 * 4B  |                       Length in bytes                                |

 * 8B  | b'0: check_response?   | b'1-31  reserved                            |

 * 12B |                       Offset in bytes                                |

 * 16B |                       Data ...                                       |

 *     \----------------------------------------------------------------------/

 *     Write data as part of a file that was previously started. Data should be

 *     of length equal to that provided in the message

/* Binary file format [General header] -

 *     /----------------------------------------------------------------------\

 * 0B  |                       QED_NVM_SIGNATURE                              |

 * 4B  |                       Length in bytes                                |

 * 8B  | Highest command in this batchfile |          Reserved                |

 *     \----------------------------------------------------------------------/

 Check minimum size */

 Check signature */

 Validate internal size equals the image-size */

 Make sure driver familiar with all commands necessary for this */

/* Binary file format -

 *     /----------------------------------------------------------------------\

 * 0B  |                       0x5 [command index]                            |

 * 4B  | Number of config attributes     |          Reserved                  |

 * 4B  | Config ID                       | Entity ID      | Length            |

 * 4B  | Value                                                                |

 *     |                                                                      |

 *     \----------------------------------------------------------------------/

 * There can be several cfg_id-entity_id-Length-Value sets as specified by

 * 'Number of config attributes'.

 *

 * The API parses config attributes from the user provided buffer and flashes

 * them to the respective NVM path using Management FW inerface.

 NVM CFG ID attribute header */

	/* NVM CFG ID attributes. Start loop index from 1 to avoid additional

	 * arithmetic operations in the implementation.

 Commit to flash and free the resources */

 Parse the actual command */

 Check response if needed */

	/* Call the HW error handler of the protocol driver.

	 * If it is not available - perform a minimal handling of preventing

	 * HW attentions from being reasserted.

 Memory barrier for setting atomic bit */

 Memory barrier after setting atomic bit */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)

/* QLogic qed NIC Driver

 * Copyright (c) 2015-2016  QLogic Corporation

 * Copyright (c) 2019-2020 Marvell International Ltd.

 although performed by MCP, this test is per engine */

 although performed by MCP, this test is per engine */

 Acquire from MFW the amount of available images */

 Iterate over images and validate CRC */

		/* This mailbox returns information about the image required for

		 * reading it.

		/* After MFW crash dump is collected - the image's CRC stops

		 * being valid.

 Allocate a buffer for holding the nvram image */

 Read image into buffer */

		/* Convert the buffer into big-endian format (excluding the

		 * closing 4 bytes of CRC).

		/* Calc CRC for the "actual" image buffer, i.e. not including

		 * the last 4 CRC bytes.

		/* Done with this image; Free to prevent double release

		 * on subsequent failure.

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)

/* QLogic qed NIC Driver

 * Copyright (c) 2015-2017  QLogic Corporation

 * Copyright (c) 2019-2021 Marvell International Ltd.

 region 3 offsets */

 region 4 offsets */

 region 5 offsets */

 region 1 offsets */

 General constants */

 Max link speed (in Mbps) */

 Feature enable */

 Initial VOQ byte credit */

 Other PQ constants */

 VOQ constants */

 WFQ constants */

 PF WFQ increment value, 0x9000 = 4*9*1024 */

 PF WFQ Upper bound, in MB, 10 * burst size of 1ms in 50Gbps */

 PF WFQ max increment value, 0.7 * upper bound */

 Number of VOQs in E5 PF WFQ credit register (QmWfqCrd) */

 VP WFQ increment value */

 VP WFQ min increment value */

 VP WFQ max increment value, 2^30 */

 VP WFQ bypass threshold */

 VP RL credit task cost */

 Bit of VOQ in VP WFQ PQ map */

 Bit of PF in VP WFQ PQ map */

 RL constants */

 Period in us */

 Period in 25MHz cycles */

 RL increment value - rate is specified in mbps */

 PF RL Upper bound is set to 10 * burst size of 1ms in 50Gbps */

 Max PF RL increment value is 0.7 * upper bound */

 QCN RL Upper bound, speed is in Mpbs */

 AFullOprtnstcCrdMask constants */

 Command Queue constants */

 Pure LB CmdQ lines (+spare) */

/* Returns the VOQ line credit for the specified number of PBF command lines.

 * PBF lines are specified in 256b units.

 BTB: blocks constants (block size = 256B) */

 256B blocks in 9700B packet */

 Headroom per-port */

 Factored (hence really 0.7) */

 QM stop command constants */

 QM command macros */

******************* INTERNAL IMPLEMENTATION *********************/

 Returns the external VOQ number */

 Prepare PF RL enable/disable runtime init values */

 Enable RLs for all VOQs */

 Write RL period */

 Set credit threshold for QM bypass flow */

 Prepare PF WFQ enable/disable runtime init values */

 Set credit threshold for QM bypass flow */

 Prepare global RL enable/disable runtime init values */

 Write RL period (use timer 0 only) */

 Set credit threshold for QM bypass flow */

 Prepare VPORT WFQ enable/disable runtime init values */

 Set credit threshold for QM bypass flow */

/* Prepare runtime init values to allocate PBF command queue lines for

 * the specified VOQ.

 Prepare runtime init values to allocate PBF command queue lines. */

 Clear PBF lines of all VOQs */

		/* Find number of command queue lines to divide between the

		 * active physical TCs.

 Find #lines per active physical TC */

 Init registers per active TC */

 Init registers for pure LB TC */

/* Prepare runtime init values to allocate guaranteed BTB blocks for the

 * specified port. The guaranteed BTB space is divided between the TCs as

 * follows (shared space Is currently not used):

 * 1. Parameters:

 *    B - BTB blocks for this port

 *    C - Number of physical TCs for this port

 * 2. Calculation:

 *    a. 38 blocks (9700B jumbo frame) are allocated for global per port

 *	 headroom.

 *    b. B = B - 38 (remainder after global headroom allocation).

 *    c. MAX(38,B/(C+0.7)) blocks are allocated for the pure LB VOQ.

 *    d. B = B - MAX(38, B/(C+0.7)) (remainder after pure LB allocation).

 *    e. B/C blocks are allocated for each physical TC.

 * Assumptions:

 * - MTU is up to 9700 bytes (38 blocks)

 * - All TCs are considered symmetrical (same rate and packet size)

 * - No optimization for lossy TC (all are considered lossless). Shared space

 *   is not enabled and allocated for each TC.

 Subtract headroom blocks */

		/* Find blocks per physical TC. Use factor to avoid floating

		 * arithmethic.

 Init physical TCs */

 Init pure LB TC */

/* Prepare runtime init values for the specified RL.

 * Set max link speed (100Gbps) per rate limiter.

 * Return -1 on error.

 Go over all global RLs */

/* Returns the upper bound for the specified Vport RL parameters.

 * link_speed is in Mbps.

 * Returns 0 in case of error.

/* Prepare VPORT RL runtime init values.

 * Return -1 on error.

 Go over all PF VPORTs */

 Prepare Tx PQ mapping runtime init values for the specified PF */

 Set mapping from PQ group to PF */

 Set PQ sizes */

 Go over all Tx PQs */

 Update first Tx PQ of VPORT/TC */

 Create new VP PQ */

 Map VP PQ to VOQ and PF */

 Prepare PQ map entry */

 Set PQ base address */

 Clear PQ pointer table entry (64 bit) */

 Write PQ info to RAM */

 If VF PQ, add indication to PQ VF mask */

 Store Tx PQ VF mask to size select register */

 Prepare Other PQ mapping runtime init values for the specified PF */

	/* A single other PQ group is used in each PF, where PQ group i is used

	 * in PF i.

 Map PQ group to PF */

 Set PQ sizes */

 Set PQ base address */

 Clear PQ pointer table entry */

/* Prepare PF WFQ runtime init values for the specified PF.

 * Return -1 on error.

/* Prepare PF RL runtime init values for the specified PF.

 * Return -1 on error.

/* Prepare VPORT WFQ runtime init values for the specified VPORTs.

 * Return -1 on error.

 Go over all PF VPORTs */

 Each VPORT can have several VPORT PQ IDs for various TCs */

 Check if VPORT/TC is valid */

 Find WFQ weight (per VPORT or per VPORT+TC) */

 Config registers */

 Check if timeout while waiting for SDM command ready */

******************* INTERFACE IMPLEMENTATION *********************/

 Init AFullOprtnstcCrdMask */

 Enable/disable PF RL */

 Enable/disable PF WFQ */

 Enable/disable global RL */

 Enable/disable VPORT WFQ */

 Init PBF CMDQ line credit */

 Init BTB blocks in PBF */

 Clear first Tx PQ ID array for each VPORT */

 Map Other PQs (if any) */

 Map Tx PQs */

 Init PF WFQ */

 Init PF RL */

 Init VPORT WFQ */

 Set VPORT RL */

 Set command's PQ type */

 Go over requested PQs */

 Set PQ bit in mask (stop command only) */

 If last PQ or end of PQ mask, write command */

/**

 * qed_dmae_to_grc() - Internal function for writing from host to

 * wide-bus registers (split registers are not supported yet).

 *

 * @p_hwfn: HW device data.

 * @p_ptt: PTT window used for writing the registers.

 * @p_data: Pointer to source data.

 * @addr: Destination register address.

 * @len_in_dwords: Data length in dwords (u32).

 *

 * Return: Length of the written data in dwords (u32) or -1 on invalid

 *         input.

 Set DMAE params */

 Execute DMAE command */

 If not read using DMAE, read using GRC */

 Swap to CPU byteorder and write to registers using GRC */

 Update PRS register */

 Update NIG register */

 Update PBF register */

 Update PRS register */

 Update output  only if tunnel blocks not included. */

 Update NIG register */

 Update DORQ register */

 Update PRS register */

 Update output  only if tunnel blocks not included. */

 Update NIG register */

 Update DORQ registers */

 Update PRS register */

 Update NIG register */

 Update PBF register */

 Update PRS register */

 Update output  only if tunnel blocks not included. */

 Update NIG register */

 EDPM with geneve tunnel not supported in BB */

 Update DORQ registers */

 read PRS config register */

 set VXLAN_NO_L2_ENABLE mask */

 set VXLAN_NO_L2_ENABLE flag */

 update PRS FIC  register */

 clear VXLAN_NO_L2_ENABLE flag */

 write PRS config register */

 Disable gft search for PF */

 Clean ram & cam for next gft session */

 Zero camline */

 Zero ramline */

 Set RFS event ID to be awakened i Tstorm By Prs */

 Do not load context only cid in PRS on match. */

 Do not use tenant ID exist bit for gft search */

 Set Cam */

 Filters are per PF!! */

 Write characteristics to cam */

 Write line to RAM - compare to filter 4 tuple */

 Search no IP as GFT */

 Tunnel type */

 Allow tunneled traffic without inner IP */

 Set default profile so that no filter match will happen */

 Enable gft search */

 Calculate and return CDU validation byte per connection type/region/cid */

 automatically initialized to 0 */

	/* The CRC is calculated on the String-to-compress:

	 * [31:8]  = {CID[31:20],CID[11:0]}

	 * [7:4]   = Region

	 * [3:0]   = Type

 Convert to big-endian and calculate CRC8 */

	/* The validation byte [7:0] is composed:

	 * for type A validation

	 * [7]          = active configuration bit

	 * [6:0]        = crc[6:0]

	 *

	 * for type B validation

	 * [7]          = active configuration bit

	 * [6:3]        = connection_type[3:0]

	 * [2:0]        = crc[2:0]

 Calcualte and set validation bytes for session context */

 Calcualte and set validation bytes for task context */

 Memset session context to 0 while preserving validation bytes */

 Memset task context to 0 while preserving validation bytes */

 Enable and configure context validation */

 Enable validation for connection region 3: CCFC_CTX_VALID0[31:24] */

 Enable validation for connection region 5: CCFC_CTX_VALID1[15:8] */

 Enable validation for connection region 1: TCFC_CTX_VALID0[15:8] */

 For each Storm, set physical address in RAM */

 Allocate physical memory for Storm's overlays buffer */

 Skip overlays buffer header */

 Copy Storm's overlays buffer to allocated memory */

 Advance to next Storm */

 If memory allocation has failed, free all allocated memory */

 Skip Storms with no FW overlays */

 Calculate overlay RAM GRC address of current PF */

 Write Storm's overlay physical address to RAM */

 Free Storm's physical memory */

 Free allocated virtual memory */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)

/* QLogic qed NIC Driver

 * Copyright (c) 2015-2017  QLogic Corporation

 * Copyright (c) 2019-2020 Marvell International Ltd.

/* Get Traffic Class from priority traffic class table, 4 bits represent

 * the traffic class corresponding to the priority.

 Old MFW */

 Old MFW */

 PF update ramrod data */

 QM reconf data */

 Configure dcbx vlan priority in doorbell block for roce EDPM */

 Update app protocol data and hw_info fields with the TLV info */

/* Parse app TLV's to update TC information in hw_info structure for

 * reconfiguring QM. Get protocol specific data for PF update ramrod command.

 Parse APP TLV */

			/* ETH always have the enable bit reset, as it gets

			 * vlan information per packet. For other protocols,

			 * should be set according to the dcbx_enabled

			 * indication, but we only got here if there was an

			 * app tlv for the protocol, so dcbx must be enabled.

 If Eth TLV is not detected, use UFP TC as default TC */

	/* Update ramrod protocol data and hw_info fields

	 * with default info when corresponding APP TLV's are not detected.

	 * The enabled field has a different logic for ethernet as only for

	 * ethernet dcb should disabled by default, as the information arrives

	 * from the OS (unless an explicit app tlv was present).

/* Parse app TLV's to update TC information in hw_info structure for

 * reconfiguring QM. Get protocol specific data for PF update ramrod command.

	/* The data is considered to be valid only if both sequence numbers are

	 * the same.

 Old MFW */

	/* 8 bit tsa and bw data corresponding to each of the 8 TC's are

	 * encoded in a type u32 array of size 2.

	/* If DCBx version is non zero, then negotiation

	 * was successfuly performed

/* Read updated MIB.

 * Reconfigure QM and invoke PF update ramrod command if operational MIB

 * change is detected.

			/* reconfigure tcs of QM queues according

			 * to negotiation results

 update storm FW with negotiation results */

			/* for roce PFs, we may want to enable/disable DPM

			 * when DCBx change occurs

		/* Configure in NIG which protocols support EDPM and should

		 * honor PFC.

 Set pf update ramrod command params */

		/* Copy the priority value to the corresponding 4 bits in the

		 * traffic class table.

 clear set-parmas cache */

 First empty slot */

 First empty slot */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)

/* QLogic qed NIC Driver

 * Copyright (c) 2015-2017  QLogic Corporation

 * Copyright (c) 2019-2020 Marvell International Ltd.

 per protocol index data */

 Multiple bits start with this offset */

 Callback to call if attention will be triggered */

 Specific HW attention callbacks */

 This might occur on certain instances; Log it once then mask it */

	/* We've already cleared the timeout interrupt register, so we learn

	 * of interrupts via the validity register

 Read the GRC timeout information */

 Regardles of anything else, clean the validity bit */

 Clear the indications */

 Clear assert indications */

 Flush any pending (e)dpms as they may never arrive */

	/* wait for usage to zero or count to run out. This is necessary since

	 * EDPM doorbell transactions can take multiple 64b cycles, and as such

	 * can "split" over the pci. Possibly, the doorbell drop can happen with

	 * half an EDPM in the queue and other half dropped. Another EDPM

	 * doorbell to the same address (from doorbell recovery mechanism or

	 * from the doorbelling entity) could have first half dropped and second

	 * half interpreted as continuation of the first. To prevent such

	 * malformed doorbells from reaching the device, flush the queue before

	 * releasing the overflow sticky indication.

 should have been depleted by now */

 Release overflow sticky indication (stop silently dropping everything) */

 Repeat all last doorbells (doorbell drop recovery) */

 Run PF doorbell recovery in next periodic handler */

 Schedule the handler even if overflow was not detected */

	/* int_sts may be zero since all PFs were interrupted for doorbell

	 * overflow but another one already handled it. Can abort here. If

	 * This PF also requires overflow recovery we will be interrupted again.

	 * The masked almost full indication may also be set. Ignoring.

 check if db_drop or overflow happened */

 Obtain data about db drop/overflow */

 Log info */

 Clear the doorbell drop details and prepare for next drop */

		/* Mark interrupt as handled (note: even if drop was due to a different

		 * reason than overflow we mark as handled)

 If there are no indications other than drop indications, success */

 Some other indication was present - non recoverable */

 Call DORQ callback if the attention was missed */

/* Instead of major changes to the data-structure, we have a some 'special'

 * identifiers for sources that changed meaning between adapters.

 Notice aeu_invert_reg must be defined in the same order of bits as HW;  */

 After Invert 1 */

 After Invert 2 */

 After Invert 3 */

 After Invert 4 */

 After Invert 5 */

 After Invert 6 */

 After Invert 7 */

 After Invert 8 */

 After Invert 9 */

 Virtual & Physical address of the SB */

 Last seen running index */

 A mask of the AEU bits resulting in a parity error */

 A pointer to the attention description structure */

 Previously asserted attentions, which are still unasserted */

 Cleanup address for the link's general hw attention */

/**

 * qed_int_assertion() - Handle asserted attention bits.

 *

 * @p_hwfn: HW device data.

 * @asserted_bits: Newly asserted bits.

 *

 * Return: Zero value.

 Mask the source of the attention in the IGU */

 Handle MCP events */

 Clean the MCP attention */

/**

 * qed_int_deassertion_aeu_bit() - Handles the effects of a single

 * cause of the attention.

 *

 * @p_hwfn: HW device data.

 * @p_aeu: Descriptor of an AEU bit which caused the attention.

 * @aeu_en_reg: Register offset of the AEU enable reg. which configured

 *              this bit to this group.

 * @p_bit_name: AEU bit description for logging purposes.

 * @bitmask: Index of this bit in the aeu_en_reg.

 *

 * Return: Zero on success, negative errno otherwise.

 Call callback before clearing the interrupt status */

 Print HW block interrupt registers */

 Reach assertion if attention is fatal */

 If the attention is benign, no need to prevent it */

 Prevent this Attention from being asserted in the future */

 Re-enable FW aassertion (Gen 32) interrupts */

/**

 * qed_int_deassertion_parity() - Handle a single parity AEU source.

 *

 * @p_hwfn: HW device data.

 * @p_aeu: Descriptor of an AEU bit which caused the parity.

 * @aeu_en_reg: Address of the AEU enable register.

 * @bit_index: Index (0-31) of an AEU bit.

 In BB, there's a single parity bit for several blocks */

 Prevent this parity error from being re-asserted */

/**

 * qed_int_deassertion() - Handle deassertion of previously asserted

 * attentions.

 *

 * @p_hwfn: HW device data.

 * @deasserted_bits: newly deasserted bits.

 *

 * Return: Zero value.

 Read the attention registers in the AEU */

 Find parity attentions first */

 Skip register in which no parity bit is currently set */

 Find non-parity cause for attention and act */

 Handle only groups whose attention is currently deasserted */

 Skip if no bit from this group is currently set */

			/* Find all set bits from current register which belong

			 * to current group, making them responsible for the

			 * previous assertion.

 Skip Parity */

					/* Some bits represent more than a

					 * a single interrupt. Correctly print

					 * their name.

					/* We now need to pass bitmask in its

					 * correct position.

 Handle source of the attention */

 Handle missed DORQ attention */

 Clear IGU indication for the deasserted bits */

 Unmask deasserted attentions in IGU */

 Clear deassertion from inner state */

	/* Read current attention bits/acks - safeguard against attentions

	 * by guaranting work on a synchronized timeframe

 finish reading index before the loop condition */

	/* Attention / Deassertion are meaningful (and in correct state)

	 * only when they differ and consistent with known state - deassertion

	 * when previous attention & current ack, and assertion when current

	 * attention with no previous attention

	/* Both segments (interrupts & acks) are written to same place address;

	 * Need to guarantee all commands will be received (in-order) by HW.

	/* Disable ack for def status block. Required both for msix +

	 * inta in non-mask mode, in inta does no harm.

 Gather Interrupts/Attentions information */

 Check if we expect interrupts at this time. if not just ack them */

 Check the validity of the DPC ptt. If not ack interrupts and fail */

 Look for a free index */

		/* This should be done before the interrupts are enabled,

		 * since otherwise a new attention will be generated.

 Configure Attention Status Block in IGU */

 Set the pointer to the AEU descriptors */

 Calculate Parity Masks */

 j is array index, k is bit index */

 Set the address of cleanup for the mcp attention */

 SB struct */

 SB ring  */

 Attention setup */

 coalescing timeout = timeset << (timer_res + 1) */

 Coalesce = (timeset << timer-res), timeset is 7bit wide */

 Wide-bus, initialize via DMAE */

 Initialize Status Block Address */

 Configure pi coalescing if set */

 timeset = (coalesce >> timer-res), timeset is 7bit wide */

 zero status block and ack counter */

 Assuming continuous set of IGU SBs dedicated for given PF */

	/* The igu address will hold the absolute address that needs to be

	 * written to for a specific status block

 zero status block and ack counter */

 Vector 0 is reserved to Default SB */

 Lose reference to client's SB info, and fix counters */

 SB struct */

 SB ring  */

 Status Block setup */

 Look for a free index */

 Configure AEU signal change to produce attentions */

 Unmask AEU signals toward IGU */

 Enable interrupt Generation */

 Set the data field */

 Set the control register */

 calculate where to read the status bit from */

 Now wait for the command to complete */

 Set */

 Clear */

 Wait for the IGU SB to cleanup */

 Clear the CAU for the SB */

		/* Use the numbers the MFW have provided -

		 * don't forget MFW accounts for the default SB as well.

			/* At this point we know how many SBs we have totally

			 * in IGU + number of PF SBs. So we can validate that

			 * we'd have sufficient for VF.

			/* Currently cap the number of VFs SBs by the

			 * number of VFs.

 Mark all SBs as free, now in the right PF/VFs division */

	/* We now proceed to re-configure the IGU cam to reflect the initial

	 * configuration. We can start with the Default SB.

 VF entries would be enabled when VF is initializaed */

 Fill the block information */

 Distinguish between existent and non-existent default SB */

 Find the range of VF ids whose SB belong to this PF */

 Read current entry; Notice it might not belong to this PF */

 Available for VFs of this PF */

		/* Mark the First entry belonging to the PF or its VFs

		 * as the default SB [we'll reset IGU prior to first usage].

		/* limit number of prints by having each PF print only its

		 * entries with the exception of PF0 which would print

		 * everything.

 All non default SB are considered free at this point */

/**

 * qed_int_igu_init_rt() - Initialize IGU runtime registers.

 *

 * @p_hwfn: HW device data.

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)

/* QLogic qed NIC Driver

 * Copyright (c) 2015-2017  QLogic Corporation

 * Copyright (c) 2019-2020 Marvell International Ltd.

	/* qed_spq_get_entry() can either get an entry from the free_pool,

	 * or, if no entries are left, allocate a new entry and add it to

	 * the unlimited_pending list.

 update initial eq producer */

	/* enable_stag_pri_change should be set if port is in BD mode or,

	 * UFP with Host Control mode.

 Place EQ address in RAMROD */

 Place consolidation queue address in ramrod */

 Get SPQ entry */

 Get SPQ entry */

 Set pf update ramrod command params */

 Get SPQ entry */

 Get SPQ entry */

 Get SPQ entry */

 Get SPQ entry */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)

/* QLogic qed NIC Driver

 * Copyright (c) 2015-2017  QLogic Corporation

 * Copyright (c) 2019-2020 Marvell International Ltd.

 win 2: addr=0x1c02000, size=4096 bytes */

 win 3: addr=0x1c80000, size=4096 bytes */

 win 4: addr=0x1d00000, size=4096 bytes */

 win 5: addr=0x1d01000, size=4096 bytes */

 win 6: addr=0x1d02000, size=4096 bytes */

 win 7: addr=0x1d80000, size=4096 bytes */

 win 8: addr=0x1d81000, size=4096 bytes */

 win 9: addr=0x1d82000, size=4096 bytes */

 win 10: addr=0x1e00000, size=4096 bytes */

 win 11: addr=0x1e01000, size=4096 bytes */

 win 12: addr=0x1e80000, size=4096 bytes */

 win 13: addr=0x1f00000, size=4096 bytes */

 win 14: addr=0x1c08000, size=4096 bytes */

 IRO Array */

	/* Since not all RT entries are initialized, go over the RT and

	 * for each segment of initialized values use DMA.

		/* In case there isn't any wide-bus configuration here,

		 * simply write the data instead of using dmae.

 Start of a new segment */

 invalidate after writing */

 Jump over the entire segment, including invalid entry */

 Perform DMAE only for lengthy enough sections or for wide-bus */

	/* invoke the DMAE virtual/physical buffer API with

	 * 1. DMAE init channel

	 * 2. addr,

	 * 3. p_hwfb->temp_data,

	 * 4. fill_count

 init_ops write command */

 Sanitize */

 init_ops read/poll commands */

 init_ops callbacks entry point */

			/* qed_init_run is always invoked from

			 * sleep-able context

 Set the global windows */

 First Dword contains metadata and should be skipped */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)

 Copyright 2021 Marvell. All rights reserved. */

 Get SPQ entry */

 Get SPQ entry */

 Stop the nvmetcp */

 Fill task information */

 Get SPQ entry */

 Transmission PQ is the first of the PF */

 nvmetcp Pure-ACK PQ */

 Get SPQ entry */

 Get SPQ entry */

 Get SPQ entry */

 Try finding a free connection that can be used */

 Need to allocate a new connection */

 Allocate a hashed connection */

 Acquire the connection */

 Added the connection to hash table */

 Update the connection with information from the params */

 FW initializations */

 Networking and TCP stack initializations */

 Update the connection with information from the params */

 Placeholder - initialize pfv, cpda, hpda */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)

/* QLogic qed NIC Driver

 * Copyright (c) 2015-2017  QLogic Corporation

 * Copyright (c) 2019-2020 Marvell International Ltd.

 Account for 5 sec */

 Account for 500 msec */

 The MB data is actually BE; Need to force it to cpu */

 Must be called while cmd_lock is acquired */

 Must be called while cmd_lock is acquired */

 Must be called while cmd_lock is acquired */

 Maximum of 1 sec to wait for the SHMEM ready indication */

 Get the MFW MB address and number of supported messages */

	/* The driver can notify that there was an MCP reset, and might read the

	 * SHMEM values before the MFW has completed initializing them.

	 * To avoid this, the "sup_msgs" field in the MFW mailbox is used as a

	 * data ready indication.

 Calculate the driver and MFW mailbox address */

	/* Get the current driver mailbox sequence before sending

	 * the first command

 Get current FW pulse sequence */

 Allocate mcp_info structure */

 Initialize the MFW spinlock */

		/* Do not free mcp_info here, since public_base indicate that

		 * the MCP is not initialized

	/* Use MCP history register to check if MCP reset occurred between init

	 * time and now.

 Ensure that only a single thread is accessing the mailbox */

 Set drv command along with the updated sequence */

 Wait for MFW response */

 Give the FW up to 500 second (50*1000*10usec) */

 Must be called while cmd_lock is acquired */

	/* There is at most one pending command at a certain time, and if it

	 * exists - it is placed at the HEAD of the list.

 Must be called while cmd_lock is acquired */

 Return if no new non-handled response has been received */

 Get the MFW response along with the sequence number */

 Get the MFW param */

 Get the union data */

 Must be called while cmd_lock is acquired */

 Set the union data */

 Set the drv param */

 Set the drv command along with the sequence number */

 Wait until the mailbox is non-occupied */

		/* Exit the loop if there is no pending command, or if the

		 * pending command is completed during this iteration.

		 * The spinlock stays locked until the command is sent.

 Send the mailbox command */

 Wait for the MFW response */

		/* Exit the loop if the command is already completed, or if the

		 * command is completed during this iteration.

		 * The spinlock stays locked until the list element is removed.

 Clear the sequence number from the MFW response */

 MCP not initialized */

 nvm_info needs to be updated */

 Use the maximal value since the actual one is part of the response */

	/* First handle cases where another load request should/might be sent:

	 * - MFW expects the old interface [HSI version = 1]

	 * - MFW responds that a force load request is required

	/* Now handle the other types of responses.

	 * The "REFUSED_HSI_1" and "REFUSED_REQUIRES_FORCE" responses are not

	 * expected here after the additional revised load requests were sent.

			/* The role and fw/driver version match, but the PF is

			 * already loaded and has not been unloaded gracefully.

 Check if there is a DID mismatch between nvm-cfg/efuse */

 Set the primary MAC if WoL is enabled */

 Clear the ACK bits */

 Prevent SW/attentions from doing this at the same time */

		/* Link indication with modern MFW arrives as per-PF

		 * indication.

 Max bandwidth configuration */

 Min bandwidth configuration */

 Set the shmem configuration according to params */

	/* There are MFWs that share this capability regardless of whether

	 * this is feasible or not. And given that at the very least adv_caps

	 * would be set internally by qed, we want to make sure LFA would

	 * still work.

 if mcp fails to respond we must abort */

	/* Mimic link-change attention, done for several reasons:

	 *  - On reset, there's no guarantee MFW would trigger

	 *    an attention.

	 *  - On initialization, older MFWs might not indicate link change

	 *    during LFA, so we'll never get an UP indication.

	/* Prevent possible attentions/interrupts during the recovery handling

	 * and till its load phase, during which they will be re-enabled.

	/* The following operations should be done once, and thus in CMT mode

	 * are carried out by only the first HW function.

 Acknowledge the MFW */

 Configure DB to add external vlan to EDPM packets */

 Acknowledge the MFW */

 A single notification should be sent to upper driver in CMT mode */

	/* In CMT mode - no need for more than a single acknowledgment to the

	 * MFW, and no more than a single notification to the upper driver.

 Merge UFP TC with the dcbx TC data */

 update storm FW with negotiation results */

 update stag pcp value */

 Read Messages from MFW */

 Compare current messages to old ones */

 ACK everything */

 MFW expect answer in BE, so we force write in that format */

 Copy the new mfw messages into the shadow */

 Read the address of the nvm_cfg */

 Read the offset of nvm_cfg1 */

 Old MFW has a global configuration for all PFs regarding RDMA support */

	/* There wasn't ever a legacy MFW that published iwarp.

	 * So at this point, this is either plain l2 or RoCE.

 Store primary MAC for later possible WoL */

 Wait for the drain to complete before returning */

 Allow ongoing PCIe transactions to complete */

 Clear the PF's internal FID_enable in the PXP */

 Only Leader can configure MSIX, and need to take CMT into account */

 A maximal 100 msec waiting time for the MCP to halt */

	/* MCP is BE, and on LE platforms PCI would swap access to SHMEM

	 * in 32-bit granularity.

	 * So the MAC has to be set in native order [and not byte order],

	 * otherwise it would be read incorrectly by MFW after swap.

 Store primary MAC for later possible WoL */

 Store the WoL update for a future unload */

		/* This can be a lengthy process, and it's possible scheduler

		 * isn't preemptible. Sleep a bit to prevent CPU hogging.

		/* This can be a lengthy process, and it's possible scheduler

		 * isn't pre-emptable. Sleep a bit to prevent CPU hogging.

		/* For MBI upgrade, MFW response includes the next buffer offset

		 * to be delivered to MFW.

 Acquire from MFW the amount of available images */

 Iterate over images and get their attributes */

 Update hwfn's nvm_info */

 Translate image_id into MFW definitions */

 Validate sizes - both the image's and the supplied buffer's */

 Each VFC resource can accommodate both a MAC and a VLAN */

 CNQ/CMDQS are the same resource */

 Attempt to acquire the resource */

 Analyze the response */

 No need for an interval before the first iteration */

 Attempt to release the resource */

 Analyze the response */

		/* Permanent resources don't require aging, and there's no

		 * point in trying to acquire them more than once since it's

		 * unexpected another entity would release them.

 Header format: [31:28] PFID, [27:20] flags, [19:12] type, [11:0] S/N */

 First chunk is marked as 'first' */

 Clear the 'first' marking after sending the first chunk */

 Last chunk is marked as 'last' */

 Casting the left size to u8 is ok since at this point it is <= 32 */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)

/* QLogic qed NIC Driver

 * Copyright (c) 2015-2017  QLogic Corporation

 * Copyright (c) 2019-2020 Marvell International Ltd.

 IOV ramrods */

 Get SPQ entry */

 Get SPQ entry */

 In case we haven't found any valid cid, then its disabled */

 Increment bulletin board version and compute crc */

 propagate bulletin board via dmae to vm memory */

 Some sanity checks */

		/* This can happen only due to a bug. In this case we set

		 * num_vfs to zero to avoid memory corruption in the code that

		 * assumes max number of vfs

 Allocate PF Mailbox buffer (per-VF) */

 Allocate PF Mailbox Reply buffer (per-VF) */

 Learn the PCI configuration */

 Allocate a new struct for IOV information */

	/* We want PF IOV to be synonemous with the existence of p_iov_info;

	 * In case the capability is published but there are no VFs, simply

	 * de-allocate the struct.

	/* First VF index based on offset is tricky:

	 *  - If ARI is supported [likely], offset - (16 - pf_id) would

	 *    provide the number for eng0. 2nd engine Vfs would begin

	 *    after the first engine's VFs.

	 *  - If !ARI, VFs would start on next device.

	 *    so offset - (256 - pf_id) would provide the number.

	 * Utilize the fact that (256 - pf_id) is achieved only by later

	 * to differentiate between the two.

 Check PF supports sriov */

 Check VF validity */

 Set VF masks and configuration - pretend */

 unpretend */

 iterate over all queues, clear sb consumer */

 unpretend */

	/* For AH onward, configuration is per-PF. Find maximum of all

	 * the currently enabled child VFs, and set the number to be that.

	/* It's possible VF was previously considered malicious -

	 * clear the indication even if we're only going to disable VF.

 unpretend */

/**

 * qed_iov_config_perm_table() - Configure the permission zone table.

 *

 * @p_hwfn: HW device data.

 * @p_ptt: PTT window for writing the registers.

 * @vf: VF info data.

 * @enable: The actual permision for this VF.

 *

 * In E4, queue zone permission table size is 320x9. There

 * are 320 VF queues for single engine device (256 for dual

 * engine device), and each entry has the following format:

 * {Valid, VF[7:0]}

 Reset vf in IGU - interrupts are still disabled */

 Permission Table */

 Configure igu sb in CAU which were marked valid */

 Invalidate igu CAM lines and mark them as free */

 Perform sanity checking on the requested queue_id */

 If client *really* wants, Tx qid can be shared with PF */

 Limit number of queues according to number of CIDs */

 Choose queue number and index ranges */

 Update the link configuration in bulletin */

	/* Get the link configuration back in bulletin so

	 * that when VFs are re-enabled they get the actual

	 * link configuration.

 Forget the VF's acquisition message */

	/* disablng interrupts and resetting permission table was done during

	 * vf-close, however, we could get here without going through vf_close

 Disable Interrupts for VF */

 Reset Permission table */

 place a given tlv on the tlv buffer, continuing current tlv list */

 Offset should keep pointing to next TLV (the end of the last) */

 Return a pointer to the start of the added tlv */

 list the types and lengths of the tlvs on the buffer */

 output tlv */

 Validate entry - protect against malicious VFs */

	/* Once PF copies the rc to the VF, the latter can continue

	 * and send an additional message. So we have to make sure the

	 * channel would be re-set to ready prior to that.

 Prepare response for all extended tlvs if they are found by PF */

 Clear the VF mac */

 If VF previously requested less resources, go back to default */

 Returns either 0, or log(size) */

	/* If VF didn't bother asking for QIDs than don't bother limiting

	 * number of CIDs. The VF doesn't care about the number, and this

	 * has the likely result of causing an additional acquisition.

	/* If doorbell bar was mapped by VF, limit the VF CIDs to an amount

	 * that would make sure doorbells for all CIDs fall within the bar.

	 * If it doesn't, make sure regview window is sufficient.

 Queue related information */

	/* These fields are filled for backward compatibility.

	 * Unused by modern vfs.

 Filter related information */

	/* This isn't really needed/enforced, but some legacy VFs might depend

	 * on the correct filling of this field.

 Validate sufficient resources for VF */

		/* Some legacy OSes are incapable of correctly handling this

		 * failure.

	/* Write the PF version so that VF would know which version

	 * is supported - might be later overridden. This guarantees that

	 * VF could recognize legacy PF based on lack of versions in reply.

 Validate FW compatibility */

 On 100g PFs, prevent old VFs from loading */

 Store the acquire message */

 fill in pfdev info */

	/* Share our ability to use multiple queue-ids only with VFs

	 * that request it.

 Share the sizes of the bars with VF */

	/* Incorrect when legacy, but doesn't matter as legacy isn't reading

	 * this field.

	/* Fill resources available to VF; Make sure there are enough to

	 * satisfy the VF's request.

 Start the VF in FW */

 Fill agreed size of bulletin board in response */

 Prepare Response */

 Reconfigure vlans */

		/* Since there's no way [currently] of removing the MAC,

		 * we can always assume this means we need to force it.

 Send the ramrod */

 Update the default-vlan & silent vlan stripping */

 Update all the Rx queues */

 There can be at most 1 Rx queue on qzone. Find it */

	/* If forced features are terminated, we need to configure the shadow

	 * configuration back again.

 Initialize Status block in CAU */

	/* Take into consideration configuration forced by hypervisor;

	 * If none is configured, use the supplied VF values [for old

	 * vfs that would still be fine, since they passed '0' as padding].

 Non trusted VFs should enable control frame filtering */

 Force configuration if needed on the newly opened vport */

 Forget the configuration on the vport */

	/* Taking a bigger struct instead of adding a TLV to list was a

	 * mistake, but one which we're now stuck with, as some older

	 * clients assume the size of the previous response.

 Update the TLV with the response */

 Search for the qid if the VF published its going to provide it */

 Acquire a new queue-cid */

 Since IGU index is passed via sb_info, construct a dummy one */

	/* Legacy VFs have their Producers in a different location, which they

	 * calculate on their own and clean the producer prior to this.

	/* If PF modifies VF's req then it should

	 * still return an error in case of partial configuration

	 * or modified configuration as opposed to requested one.

 If QED client is willing to update anything ? */

	/* Taking a bigger struct instead of adding a TLV to list was a

	 * mistake, but one which we're now stuck with, as some older

	 * clients assume the size of the previous response.

 Update the TLV with the response */

 Acquire a new queue-cid */

 Since IGU index is passed via sb_info, construct a dummy one */

	/* We've validated the index and the existence of the active RXQ -

	 * now we need to make sure that it's using the correct qid.

 Now that we know we have a valid Rx-queue - close it */

	/* There has never been an official driver that used this interface

	 * for stopping multiple queues, and it is now considered deprecated.

	 * Validate this isn't used here.

 Find which qid-index is associated with the queue */

	/* There has never been an official driver that used this interface

	 * for stopping multiple queues, and it is now considered deprecated.

	 * Validate this isn't used here.

 Find which qid-index is associated with the queue */

	/* There shouldn't exist a VF that uses queue-qids yet uses this

	 * API with multiple Rx queues. Validate this.

	/* Validate inputs - for the legacy case this is still true since

	 * qid_usage_idx for each Rx queue would be LEGACY_QID_RX.

 Prepare the handlers */

 Ignore the VF request if we're forcing a vlan */

	/* Untrusted VFs can't even be trusted to know that fact.

	 * Simply indicate everything is configured fine, and trace

	 * configuration 'behind their back'.

 Valiate PF can send such a request */

	/* Search for extended tlvs list and update values

	 * from VF in struct qed_sp_vport_update_params.

	/* Some of the extended TLVs need to be validated first; In that case,

	 * they can update the mask without updating the accepted [so that

	 * PF could communicate to VF it has rejected request].

 First remove entries and then add new ones */

	/* In forced mode, we're willing to remove entries - but we don't add

	 * new ones.

 If we're in forced-mode, we don't allow any change */

 Don't keep track of shadow copy since we don't intend to restore. */

 First remove entries and then add new ones */

 List the new MAC address */

 No real decision to make; Store the configured MAC */

 Update and post bulleitin again */

 Prepare the unicast filter params */

 Update shadow copy of the VF configuration */

 Determine if the unicast filtering is acceptible by PF */

		/* Once VLAN is forced or PVID is set, do not allow

		 * to add/replace any further VLANs.

 Reset the SBs */

 Disable Interrupts for VF */

 Reset Permission table */

 Stopping the VF */

 Read initial consumers & producers */

 "max_phys_tcs_per_port" active TCs + 1 pure LB TC */

 Wait for consumers to pass the producers */

 "max_phys_tcs_per_port" active TCs + 1 pure LB TC */

 If VF isn't active, no need for anything but SW */

		/* Workaround to make VF-PF channel ready, as FW

		 * doesn't do that as a part of FLR.

		/* VF_STOPPED has to be set only after final cleanup

		 * but prior to re-enabling the VF.

 Mark VF for ack and clean pending state */

	/* Since BRB <-> PRS interface can't be tested as part of the flr

	 * polling due to HW limitations, simply sleep a bit. And since

	 * there's no need to wait per-vf, do it before looping.

 Mark VFs */

			/* No need to lock here, since pending_flr should

			 * only change here and before ACKing MFw. Since

			 * MFW will not trigger an additional attention for

			 * VF flr until ACKs, we're safe.

 qed_iov_process_mbx_request */

 check if tlv type is known */

		/* unknown TLV - this may belong to a VF driver from the future

		 * - a version written after this PF driver was written, which

		 * supports features unknown as of yet. Too bad since we don't

		 * support them. Or this may be because someone wrote a crappy

		 * VF driver and is sending garbage over the channel.

		/* Try replying in case reply address matches the acquisition's

		 * posted address.

	/* List the physical address of the request so that handler

	 * could later on copy the message from it.

 Mark the event and schedule the workqueue */

 Trust mode will disable Forced MAC */

 Forced MAC will disable MAC_ADDR */

 After VF VPORT start PF will configure spoof check */

 The "rl_id" is set as the "vport_id" */

/**

 * qed_schedule_iov - schedules IOV task for VF and PF

 * @hwfn: hardware function pointer

 * @flag: IOV flag for VF/PF

 Memory barrier for setting atomic bit */

 Memory barrier after setting atomic bit */

 Mark VFs for disablement */

		/* Failure to acquire the ptt in 100g creates an odd error

		 * where the first engine has already relased IOV.

 Clean WFQ db and configure equal weight for all vports */

 Wait until VF is disabled before releasing */

	/* Since we have an equal resource distribution per-VF, and we assume

	 * PF has acquired the QED_PF_L2_QUE first queues, we start setting

	 * sequentially from there.

 Initialize HW for VF access */

 Make sure not to use more than 16 queues per VF */

 Enable SRIOV PCIe functions */

 Set the MAC, and schedule the IOV task */

 Set the forced vlan, and schedule the IOV task */

 Sanitize request */

 Fill information about VF */

 Update bulletin of all future possible VFs with link configuration */

		/* Only hwfn0 is actually interested in the link speed.

		 * But since only it would receive an MFW indication of link,

		 * need to take configuration from it - otherwise things like

		 * rate limiting for hwfn1 VF would not work.

 Modify link according to the VF's configured link state */

			/* Set speed according to maximum supported by HW.

			 * that is 40G for regular devices and 100G for CMT

			 * mode devices.

 In auto mode pass PF link image to VF */

 Sanitize request */

 Handle configuration of link state */

 Skip VFs with no pending messages */

 Copy VF's message to PF's request buffer for that VF */

 Update data on bulletin board */

 Update bulletin board with MAC */

 Force MAC converted to generic MAC in case of VF trust on */

			/* Clear existing shadow copy of MAC to have a clean

			 * slate.

 Update shadow copy with VF MAC when trust mode is turned off */

		/* Clear bulletin when trust mode is turned off,

		 * to have a clean slate for next (normal) operations.

		/* Need to make sure current requested configuration didn't

		 * flip so that we'll end up configuring something that's not

		 * needed.

 Handle forced MAC mode */

 Validate that the VF has a configured vport */

 Remove if needed; Otherwise this would set the mask */

		/* PFs needs a dedicated workqueue only if they support IOV.

		 * VFs always require one.

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)

 Copyright 2021 Marvell. All rights reserved. */

 sgl params */

 The following function initializes of NVMeTCP task params */

 The following function initializes default values to all tasks */

 Swapping requirements used below, will be removed in future FW versions */

 M-Storm Context: */

 Ustorm Context: */

 The following function initializes the U-Storm Task Contexts */

 Remaining data to be received in bytes. Used in validations*/

 The following function initializes Local Completion Contexts: */

 Common Fastpath task init function: */

 Tx/Rx: */

 if data to transmit: */

 if data to receive: */

 Ustorm context: */

 Remaining Receive length is the Task Size */

 The size of the transmitted task */

 num_sges */

 Set exp_data_acked */

 Ustorm Context: */

 Remaining Receive length is the Task Size */

 The size of the transmitted task */

 num_sges */

 tx_dif_conn_err_en */

 SGL context: */

 The following function initializes Login task in Host mode: */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)

/* QLogic qed NIC Driver

 * Copyright (c) 2015-2017  QLogic Corporation

 * Copyright (c) 2019-2020 Marvell International Ltd.

 First sb id for RoCE is after all the l2 sb */

 2 cids per qp */

 Each MR uses a single task */

	/* Queue zone lines are shared between RoCE and L2 in such a way that

	 * they can be used by each without obstructing the other.

 Allocate a struct with device params and fill it */

 Allocate a struct with port params and fill it */

 Allocate bit map for pd's */

 Allocate bit map for XRC Domains */

 Allocate DPI bitmap */

	/* Allocate bitmap for cq's. The maximum number of CQs is bound to

	 * the number of connections we support. (num_qps in iWARP or

	 * num_qps/2 in RoCE).

	/* Allocate bitmap for toggle bit for cq icids

	 * We toggle the bit every time we create or resize cq for a given icid.

	 * Size needs to equal the size of the cq bmap.

 Allocate bitmap for itids */

 Allocate bitmap for cids used for qps. */

 Allocate bitmap for cids used for responders/requesters. */

	/* The first SRQ follows the last XRC SRQ. This means that the

	 * SRQ IDs start from an offset equals to max_xrc_srqs.

 Allocate bitmap for srqs */

 print aligned non-zero lines, if any */

 print last unaligned non-zero line, if any */

 Vendor specific information */

	/* The number of QPs may be higher than QED_ROCE_MAX_QPS, because

	 * it is up-aligned to 16 and then to ILT page size within qed cxt.

	 * This is OK in terms of ILT but we don't want to configure the FW

	 * above its abilities

	/* CQs uses the same icids that QPs use hence they are limited by the

	 * number of icids. There are two icids per QP.

 The number of mrs is smaller by 1 since the first is reserved */

	/* The maximum CQE capacity per CQ supported.

	 * max number of cqes will be in two layer pbl,

	 * 8 is the pointer size in bytes

	 * 32 is the size of cq element in bytes

 Set capablities */

 Check atomic operations support in PCI configuration space. */

 Save the number of cnqs for the function close ramrod */

 Get SPQ entry */

 we assume here that cnq_id and qz_offset are the same */

	/* Tid 0 will be used as the key for "reserved MR".

	 * The driver should allocate memory for it so it can be loaded but no

	 * ramrod should be passed on it.

 Disable RoCE search */

 Get SPQ entry */

 Stop RoCE */

 Allocate DPI */

 Calculate the corresponding DPI address */

 The link state is saved only for the leading hwfn */

 Return struct with device parameters */

 keep prod updates ordered */

 Mark the fastpath as free/used */

 Allocates an unused protection domain */

 Returns a previously allocated protection domain for reuse */

	/* the function toggle the bit that is related to a given icid

	 * and returns the new toggle bit's value

 Allocate icid */

 Check if icid requires a page allocation */

 Get SPQ entry */

 Send create CQ ramrod */

 toggle the bit for every resize or create cq for a given icid */

 restore toggle bit */

 release allocated icid */

 Get SPQ entry */

 Send destroy CQ ramrod */

 Free icid */

	/* The following fields are filled in from qp and not FW as they can't

	 * be modified by FW

 free qp params struct */

 Some sanity checks... */

 Update QP structure with the updated values */

		/* Indicates that the following parameters have changed:

		 * Traffic class, flow label, hop limit, source GID,

		 * destination GID, loopback indicator

 Get SPQ entry */

 Don't initialize D/C field, as it may override other bits. */

 DIF */

 Get SPQ entry */

		/* Bit indicating that the TID is in use and a nig drain is

		 * required before sending the ramrod again

 Resend the ramrod */

 if rdma wasn't activated yet, naturally there are no qps */

 Make sure iwarp cmt mode is enabled before setting affinity */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)

/* QLogic qed NIC Driver

 * Copyright (c) 2015-2017  QLogic Corporation

 * Copyright (c) 2019-2020 Marvell International Ltd.

 QM constants */

 in bytes */

 Doorbell-Queue constants */

 Searcher constants */

 Timers constants */

 ILT entry structure */

 connection context union */

 TYPE-0 task context - iSCSI, FCOE */

 TYPE-1 task context - ROCE */

 in 4k chunks */

 Alignment is inherent to the type1_task_context structure */

 counts the iids for the CDU/CDUC ILT client configuration */

 counts the iids for the Searcher block configuration */

 Add L2 filtering filters in addition */

 counts the iids for the Timers block configuration */

 per segment */

	/* Timers is a special case -> we don't count how many cids require

	 * timers but what's the max cid that will be used by the timer block.

	 * therefore we traverse in reverse order, and once we hit a protocol

	 * that requires the timers memory, we'll sum all the protocols up

	 * to that one.

			/* for each segment there is at most one

			 * protocol for which count is not 0.

			/* The last array elelment is for the VFs. As for PF

			 * segments there can be only one protocol for

			 * which this value is not 0.

		/* for each segment there is at most one

		 * protocol for which count is not 0.

		/* The last array elelment is for the VFs. As for PF

		 * segments there can be only one protocol for

		 * which this value is not 0.

	/* Find the protocol with tid count > 0 for this segment.

	 * Note: there can only be one and this is already validated.

 set the iids count per protocol */

 verify thatits called only once for each block */

	/* Reset all ILT blocks at the beginning of ILT computing in order

	 * to prevent memory allocation for irrelevant blocks afterwards.

 CDUC */

 CDUC PF */

 get the counters for the CDUC and QM clients  */

 CDUC VF */

 CDUT PF */

 first the 'working' task memory */

 next the 'init' task memory (forced load memory) */

			/* The segment is active (total size pf 'working'

			 * memory is > 0) but has no FL (forced-load, Init)

			 * memory. Thus:

			 *

			 * 1.   The total-size in the corrsponding FL block of

			 *      the ILT client is set to 0 - No ILT line are

			 *      provisioned and no ILT memory allocated.

			 *

			 * 2.   The start-line of said block is set to the

			 *      start line of the matching working memory

			 *      block in the ILT client. This is later used to

			 *      configure the CDU segment offset registers and

			 *      results in an FL command for TIDs of this

			 *      segement behaves as regular load commands

			 *      (loading TIDs from the working memory).

 CDUT VF */

		/* Stricly speaking we need to iterate over all VF

		 * task segment types, but a VF has only 1 segment

 'working' memory */

 'init' memory */

 see comment above */

 Now for the rest of the VFs */

 QM */

 SRC */

	/* Both the PF and VFs searcher connections are stored in the per PF

	 * database. Thus sum the PF searcher cids and all the VFs searcher

	 * cids.

 TM PF */

 TM VF */

 TSDM (SRQ CONTEXT) */

	/* if the SRC ILT client is inactive - there are no connection

	 * requiring the searcer, leave.

 use the same page size as the SRC ILT client */

 allocate t2 */

 Set the t2 pointers */

 entries per page - must be a power of two */

 Total number of ILT lines used by this PF */

 Special handling for RoCE that supports dynamic allocation */

 Handle PF maps */

 Handle VF maps */

 Initialize ILT client registers */

 default ILT page size for all clients is 64K */

 Initialize task sizes */

 Initialize the dynamic ILT allocation mutex */

 Set the cxt mangr pointer priori to further allocations */

 Allocate the ILT shadow table */

 Allocate the T2  table */

 Allocate and initialize the acquired cids bitmaps */

 Reset acquired cids */

 CDU Common */

 CDUC - connection configuration */

 CDUT - type-0 tasks configuration */

 cxt size and block-waste are multipes of 8 */

 CDUT - type-1 tasks configuration */

 cxt size and block-waste are multipes of 8 */

 CDU PF */

 There are initializations only for CDUT during pf Phase */

 Segment 0 */

		/* Note: start_line is already adjusted for the CDU

		 * segment register granularity, so we just need to

		 * divide. Adjustment is implicit as we assume ILT

		 * Page size is larger than 32K!

 CM PF */

 XCM pure-LB queue */

 DQ PF */

	/* Connection types 6 & 7 are not in use, yet they must be configured

	 * as the highest possible connection. Not configuring them means the

	 * defaults will be  used, and with a large number of cids a bug may

	 * occur, if the defaults will be smaller than dq_pf_max_cid /

	 * dq_vf_max_cid.

 For simplicty  we set the 'block' to be an ILT page */

 ILT (PSWRQ2) PF */

		/** Client's 1st val and RT array are absolute, ILT shadows'

		 *  lines are relative.

			/** p_virt could be NULL incase of dynamic

			 *  allocation

 SRC (Searcher) PF */

 Timers PF */

 @@@TBD No pre-scan for now */

 Note: We assume consecutive VFs for a PF */

 n/a for PF */

 scan all   */

 enale scan */

 @@@TBD how to enable the scan for the VFs */

 Note: We assume consecutive VFs for a PF */

 @@@TBD how to enable the scan for the VFs */

 If FCoE is active set the MAX OX_ID (tid) in the Parser */

 Determine the right map to take this CID from */

 Iterate over protocols and find matching cid range */

 Test acquired and find matching per-protocol map */

 Test acquired and find matching per-protocol map */

 set the protocl type */

 compute context virtual pointer */

 Make sure context is allocated (dynamic allocation) */

 Each QP requires one connection */

 each QP requires two connections */

		/* Deliberatly passing ROCE for tasks id. This is because

		 * iWARP / RoCE share the task id.

 XRC SRQs populate a single ILT page */

 Set the number of required CORE connections */

 SPQ */

 no need for break since RoCE coexist with Ethernet */

 Verify the personality */

/* This function is very RoCE oriented, if another protocol in the future

 * will want this feature we'll need to modify the function to be more generic

 The first ILT page is not used for regular SRQs. Skip it. */

 Calculate line in ilt */

	/* If line is already allocated, do nothing, otherwise allocate it and

	 * write it to the PSWRQ2 registers.

	 * This section can be run in parallel from different contexts and thus

	 * a mutex protection is needed.

	/* configuration of refTagMask to 0xF is required for RoCE DIF MR only,

	 * to compensate for a HW bug, but it is configured even if DIF is not

	 * enabled. This is harmless and allows us to avoid a dedicated API. We

	 * configure the field for all of the contexts on the newly allocated

	 * page.

 compute absolute offset */

 Write via DMAE since the PSWRQ2_REG_ILT_MEMORY line is a wide-bus */

 Update the relevant register in the parser */

 Enable RDMA search */

/* This function is very RoCE oriented, if another protocol in the future

 * will want this feature we'll need to modify the function to be more generic

 Calculate line in ilt */

 compute absolute offset */

		/* Write via DMAE since the PSWRQ2_REG_ILT_MEMORY line is a

		 * wide-bus.

 Free Connection CXT */

	/* Free Task CXT ( Intentionally RoCE as task-id is shared between

	 * RoCE and iWARP )

 Free TSDM CXT */

 Verify the personality */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)

/* QLogic qed NIC Driver

 * Copyright (c) 2015-2017  QLogic Corporation

 * Copyright (c) 2019-2020 Marvell International Ltd.

/***************************************************************************

 * Structures & Definitions

/***************************************************************************

 * Blocking Imp. (BLOCK/EBLOCK mode)

 Make sure completion done is visible on waiting thread */

 Validate we receive completion update */

 ^^^ */

	/* A relatively short polling period w/o sleeping, to allow the FW to

	 * complete the ramrod and thus possibly to avoid the following sleeps.

 Move to polling with a sleeping period between iterations */

 Retry after drain */

/***************************************************************************

 * SPQ entries inner API

/***************************************************************************

 * HSI access

 QM physical queue */

 struct assignment */

 send a doorbell on the slow hwfn session */

 make sure the SPQE is updated before the doorbell */

 make sure doorbell is rang */

/***************************************************************************

 * Asynchronous events

/***************************************************************************

 * EQ API

 take a snapshot of the FW consumer */

	/* Need to guarantee the fw_cons index we use points to a usuable

	 * element (to comply with our chain), so our macros would comply

 Complete current segment of eq entries */

 Attempt to post pending requests */

 Allocate EQ struct */

 register EQ completion on the SP SB */

/***************************************************************************

 * CQE API - manipulate EQ functionality

	/* @@@tmp - it's possible we'll eventually want to handle some

	 * actual commands that can arrive here, but for now this is only

	 * used to complete the ramrod using the echo value on the cqe

/***************************************************************************

 * Slow hwfn Queue (spq)

 SPQ empty pool */

 Statistics */

 SPQ cid, cannot fail */

 reset the chain itself */

 Initialize the address/data of the SPQ doorbell */

 Register the SPQ doorbell with the doorbell recovery mechanism */

 SPQ struct */

 SPQ ring */

 allocate and fill the SPQ elements (incl. ramrod data list) */

 Delete the SPQ doorbell from the doorbell recovery mechanism */

 Locked variant; Should be called while the SPQ lock is taken */

/**

 * qed_spq_add_entry() - Add a new entry to the pending list.

 *                       Should be used while lock is being held.

 *

 * @p_hwfn: HW device data.

 * @p_ent: An entry to add.

 * @priority: Desired priority.

 *

 * Adds an entry to the pending list is there is room (an empty

 * element is available in the free_pool), or else places the

 * entry in the unlimited_pending pool.

 *

 * Return: zero on success, -EINVAL on invalid @priority.

			/* Copy the ring element physical pointer to the new

			 * entry, since we are about to override the entire ring

			 * entry and don't want to lose the pointer.

 EBLOCK responsible to free the allocated p_ent */

 entry is to be placed in 'pending' queue */

/***************************************************************************

 * Accessor

 illegal */

/***************************************************************************

 * Posting new Ramrods

/* Avoid overriding of SPQ entries when getting out-of-order completions, by

 * marking the completions in a bitmap and increasing the chain consumer only

 * for the first successive completed entries.

 Let the flow complete w/o any error handling */

 Complete the entry */

 Check return value after LOCK is taken for cleaner error flow */

	/* Check if entry is in block mode before qed_spq_add_entry,

	 * which might kfree p_ent.

 Add the request to the pending queue */

		/* Since it's possible that pending failed for a different

		 * entry [although unlikely], the failed entry was already

		 * dealt with; No need to return it here.

		/* For entries in QED BLOCK mode, the completion code cannot

		 * perform the necessary cleanup - if it did, we couldn't

		 * access p_ent here to see whether it's successful or not.

		 * Thus, after gaining the answer perform the cleanup here.

 Return the entry which was actually posted */

 return to pool */

 return to the free pool */

		/* This is relatively uncommon - depends on scenarios

		 * which have mutliple per-PF sent ramrods.

	/* Release lock before callback, as callback may post

	 * an additional ramrod.

		/* EBLOCK  is responsible for returning its own entry into the

		 * free list.

 Allocate ConsQ struct */

 Allocate and initialize ConsQ chain */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)

/* QLogic qed NIC Driver

 * Copyright (c) 2015-2017  QLogic Corporation

 * Copyright (c) 2019-2020 Marvell International Ltd.

		/* icid release in this async event can occur only if the icid

		 * was offloaded to the FW. In case it wasn't offloaded this is

		 * handled in qed_roce_sp_destroy_qp.

	/* when destroying a_RoCE QP the control is returned to the user after

	 * the synchronous part. The asynchronous part may take a little longer.

	 * We delay for a short while if an async destroy QP is still expected.

	 * Beyond the added delay we clear the bitmap anyway.

		/* If the HW device is during recovery, all resources are

		 * immediately reset without receiving a per-cid indication

		 * from HW. In this case we don't expect the cid bitmap to be

		 * cleared.

		/* The IPv4 addresses shall be aligned to the highest word.

		 * The lower words must be zero.

 GIDs and IPv6 addresses coincide in location and size */

 the two icid's should be adjacent */

	/* If these icids require a new ILT line allocate DMA-able context for

	 * an ILT page

 Allocate DMA-able memory for IRQ */

 Get SPQ entry */

 Allocate DMA-able memory for ORQ */

 Get SPQ entry */

 Get SPQ entry */

 Get SPQ entry */

		/* If a responder was never offload, we need to free the cids

		 * allocated in create_qp as a FW async event will never arrive

 Get SPQ entry */

 Free IRQ - only if ramrod succeeded, in case FW is still using it */

 Get SPQ entry */

 Free ORQ - only if ramrod succeeded, in case FW is still using it */

		/* We can't send ramrod to the fw since this qp wasn't offloaded

		 * to the fw yet

 Send a query responder ramrod to FW to get RQ-PSN and state */

 Get SPQ entry */

 Don't send query qp for the requester */

 Send a query requester ramrod to FW to get SQ-PSN and state */

 Get SPQ entry */

 Destroys the specified QP */

 Send destroy requester ramrod */

	/* Perform additional operations according to the current state and the

	 * next state

 Init->RTR or Reset->RTR */

 RTR-> RTS */

 Send modify responder ramrod */

 RTS->RTS */

 RTS->SQD */

 SQD->SQD */

 SQD->RTS */

 ->ERR */

 Any state -> RESET */

 Send destroy responder ramrod */

	/* an even icid belongs to a responder while an odd icid belongs to a

	 * requester. The 'cid' received as an input can be either. We calculate

	 * the "partner" icid and call it xcid. Only if both are free then the

	 * "cid" map can be cleared.

	/* if any QPs are already active, we want to disable DPM, since their

	 * context information contains information from before the latest DCBx

	 * update. Otherwise enable it.

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)

/* QLogic qed NIC Driver

 * Copyright (c) 2015-2017  QLogic Corporation

 * Copyright (c) 2019-2020 Marvell International Ltd.

 Lock protecting LL2 buffer lists in sleepless context */

	/* For legacy (RAM based) queues, the stats_id will be set as the

	 * queue_id. Otherwise (context based queue), it will be set to

	 * the "abs_pf_id" offset from the end of the RAM based queue IDs.

	 * If the final value exceeds the total counters amount, return

	 * INVALID value to indicate that the stats for this connection should

	 * be disabled.

 All we need to do is release the mapping */

 Determine if data is valid */

 Allocate a replacement for buffer; Reuse upon failure */

 If need to reuse or there's no replacement buffer, repost this */

	/* Get parital ethernet information instead of eth_type_trans(),

	 * Since we don't have an associated net_device.

 Pass SKB onward */

 Update Buffer information and update FW producer */

 Need to make a flush */

 Process delete isle first */

 Now process create/add/join isles */

 Submit Tx buffers here */

 Get SPQ entry */

 Get SPQ entry */

 Get SPQ entry */

 Get SPQ entry */

 All bds_set elements are flexibily added. */

 Correct number of requested OOO buffers if needed */

	/* LL2 queues handles will be split as follows:

	 * First will be the legacy queues, and then the ctx based.

 QED_LL2_RX_TYPE_CTX */

 Find a free connection to be used */

 Correct maximum number of Tx BDs */

 Register callbacks for the Rx/Tx queues */

	/* QED_LL2_RX_TYPE_CTX

	 * FW distinguishes between the legacy queues (ram based) and the

	 * ctx based queues by the queue_id.

	 * The first MAX_NUM_LL2_RX_RAM_QUEUES queues are legacy

	 * and the queue ids above that are ctx base.

	/* See comment on the acquire connection for how the ll2

	 * queues handles are divided.

 All bds_set elements are flexibily added. */

 If there is no valid stats id for this connection, disable stats */

 QED_LL2_RX_TYPE_CTX - using doorbell */

 prepare db data */

 prepare db data */

 This handles the flushing of already posted buffers */

 This handles the supplied packet [if there is one] */

 update producer by giving a doorbell */

		/* Make sure chain element is updated before ringing the

		 * doorbell

		/* Make sure chain element is updated before ringing the

		 * doorbell

 If we're lacking entries, let's try to flush buffers to FW */

 We have an Rx packet we can fill */

 Check if we only want to enqueue this packet without informing FW */

 Need to provide the packet with additional BDs for frags */

 This should be called while the Txq spinlock is being held */

 If there are missing BDs, don't do anything now */

 Push the current packet to the list and clean after it */

 Notify FW of packet only if requested to */

 Make sure the BDs data is updated before ringing the doorbell */

 Get entry, but only if we have tx elements for it */

 Prepare packet and BD, and perhaps send a doorbell to FW */

 Fill the BD information, and possibly notify FW */

 Stop Tx & Rx of connection, if needed */

 Make sure this is seen by ll2_lb_rxq_completion */

 Make sure this is seen by ll2_lb_rxq_completion */

 Allocate LL2's set struct */

 In CMT mode, LL2 is always started on engine 0 for a storage PF */

 Post all Rx buffers to FW */

 Initialize LL2 locks & lists */

	/* Allocate memory for LL2.

	 * In CMT mode, in case of a storage PF which is affintized to engine 1,

	 * LL2 is started also on engine 0 and thus we need twofold buffers.

	/* In CMT mode, always need to start LL2 on engine 0 for a storage PF,

	 * since broadcast/mutlicast packets are routed to engine 0.

	/* Cache number of fragments from SKB since SKB may be freed by

	 * the completion routine after calling qed_ll2_prepare_tx_packet()

 Request HW to calculate IP csum */

	/* qed_ll2_prepare_tx_packet() may actually send the packet if

	 * there are no fragments in the skb and subsequently the completion

	 * routine may run and free the SKB, so no dereferencing the SKB

	 * beyond this point unless skb has any fragments.

		/* if failed not much to do here, partial packet has been posted

		 * we can't free memory, will need to wait for completion

 In CMT mode, LL2 is always started on engine 0 for a storage PF */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)

/* QLogic qed NIC Driver

 * Copyright (c) 2015-2017  QLogic Corporation

 * Copyright (c) 2019-2020 Marvell International Ltd.

 Get SPQ entry */

 Sanity */

 Get SPQ entry */

 Transmission PQ is the first of the PF */

 iSCSI Pure-ACK PQ */

 Get SPQ entry */

 Get SPQ entry */

 Get SPQ entry */

 Get SPQ entry */

 Get SPQ entry */

 Try finding a free connection that can be used */

 Need to allocate a new connection */

 Use input connection or allocate a new one */

 Stop the iscsi */

 Fill task information */

 Allocate a hashed connection */

 Acquire the connection */

 Added the connection to hash table */

 Update the connection with information from the params */

 Set default values on other connection fields */

 Update the connection with information from the params */

 Retrieve FW statistics */

 Translate FW statistics into struct */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)

/* QLogic qed NIC Driver

 * Copyright (c) 2015-2017  QLogic Corporation

 * Copyright (c) 2019-2020 Marvell International Ltd.

 16 nano second time quantas to wait before making a Drift adjustment */

 Nano seconds to add/subtract when making a Drift adjustment */

 Add/subtract the Adjustment_Value when making a Drift adjustment */

 Param mask for Hardware to detect/timestamp the L2/L4 unicast PTP packets */

		/* MFW doesn't support resource locking, first PF on the port

		 * has lock ownership.

 MFW doesn't support locking, first PF has lock ownership */

 Read Rx timestamp */

 Reset timestamp register to allow new timestamp */

 Read Tx timestamp */

 Reset timestamp register to allow new timestamp */

 Read Phy Hardware Clock */

 Filter PTP protocol packets that need to be timestamped */

 Reset possibly old timestamps */

/* Adjust the HW clock by a rate given in parts-per-billion (ppb) units.

 * FW/HW accepts the adjustment value in terms of 3 parameters:

 *   Drift period - adjustment happens once in certain number of nano seconds.

 *   Drift value - time is adjusted by a certain value, for example by 5 ns.

 *   Drift direction - add or subtract the adjustment value.

 * The routine translates ppb into the adjustment triplet in an optimal manner.

		/* Adjustment value is up to +/-7ns, find an optimal value in

		 * this range.

 Check both rounding ends for approximate error */

 Determine which end gives better approximation */

 Track best approximation found so far */

		/* This is a special case as its the only value which wouldn't

		 * fit in a s64 variable. In order to prevent castings simple

		 * handle it seperately.

 Reset PTP event detection rules - will be configured in the IOCTL */

 Pause free running counter */

 Resume free running counter */

 Disable drift register */

 Reset possibly old timestamps */

 Reset PTP event detection rules */

 Disable the PTP feature */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)

/* QLogic qed NIC Driver

 * Copyright (c) 2015-2017  QLogic Corporation

 * Copyright (c) 2019-2020 Marvell International Ltd.

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)

/* QLogic qed NIC Driver

 * Copyright (c) 2015-2017  QLogic Corporation

 * Copyright (c) 2019-2020 Marvell International Ltd.

 Get SPQ entry */

 Sanity */

 Get SPQ entry */

 Transmission PQ is the first of the PF */

 Get SPQ entry */

 Get SPQ entry */

 Allocate LL2's set struct */

 Use input connection [if provided] or allocate a new one */

 Stop the fcoe */

 Fill task information */

 Allocate a hashed connection */

 Acquire the connection */

 Added the connection to hash table */

 Update the connection with information from the params */

 Update the connection with information from the params */

 Retrieve FW statistics */

 Translate FW statistics into struct */

 Request protocol driver to fill-in the rest */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)

/* QLogic qed NIC Driver

 * Copyright (c) 2015-2017  QLogic Corporation

 * Copyright (c) 2019-2020 Marvell International Ltd.

 on ird */

 on ord */

 20 min */

 1 sec */

 Override devinfo with iWARP specific values */

/* We have two cid maps, one for tcp which should be used only from passive

 * syn processing and replacing a pre-allocated ep in the list. The second

 * for active tcp and for QPs.

/* This function allocates a cid for passive tcp (called from syn receive)

 * the reason it's separate from the regular cid allocation is because it

 * is assured that these cids already have ilt allocated. They are preallocated

 * to ensure that we won't need to allocate memory during syn processing

 Get SPQ entry */

	/* modify QP can be called from upper-layer or as a result of async

	 * RST/FIN... therefore need to protect

 could happen due to race... do nothing.... */

 Get SPQ entry */

 Make sure ep is closed before returning and freeing memory. */

 Read ord/ird values from private data buffer */

		/* Temprary store in cm_info incoming ord/ird requested, later

		 * replace with negotiated value during accept

 Peer2Peer negotiation */

 if we're left with no match send our capabilities */

 Strip mpa v2 hdr from private data before sending to upper layer */

 Now they're migrated. */

		/* We don't care about the return code, it's ok if tcp_cid

		 * remains invalid...in this case we'll defer allocation

/* Called as a result of the event:

 * IWARP_EVENT_TYPE_ASYNC_MPA_HANDSHAKE_COMPLETE

 paired with READ_ONCE in destroy_qp */

	/* on passive side, if there is no associated QP (REJECT) we need to

	 * return the ep to the pool, (in the regular case we add an element

	 * in accept instead of this one.

	 * In both cases we need to remove it from the ep_list.

 Rejected */

 Allocate ep object */

	/* in some cases we could have failed allocating a tcp cid when added

	 * from accept / failure... retry now..this is not the common case.

		/* if we fail we could look for another entry with a valid

		 * tcp_cid, but since we don't expect to reach this anyway

		 * it's not worth the handling

/* This function waits for all the bits of a bmap to be cleared, as long as

 * there is progress ( i.e. the number of bits left to be cleared decreases )

 * the function continues.

		/* If the HW device is during recovery, all resources are

		 * immediately reset without receiving a per-cid indication

		 * from HW. In this case we don't expect the cid_map to be

		 * cleared.

 Now free the tcp cids from the main cid map */

 Now wait for all cids to be completed */

		/* During initialization we allocate from the main pool,

		 * afterwards we allocate only from the tcp_cid.

			/* We don't care about the return code, it's ok if

			 * tcp_cid remains invalid...in this case we'll

			 * defer allocation

	/* Allocate bitmap for tcp cid. These are used by passive side

	 * to ensure it can allocate a tcp cid during dpc that was

	 * pre-acquired and doesn't require dynamic allocation of ilt

		/* Negotiate ord/ird: if upperlayer requested ord larger than

		 * ird advertised by remote, we need to decrease our ord

 Update cm_info ord/ird to be negotiated values */

 Pad to multiple of 4 */

 fpdu can be fragmented over maximum 3 bds: header, partial mpa, unaligned */

	/* special case of one byte remaining...

	 * lower byte will be read next packet

 complete fpdu */

	/* need to copy the data from the partial packet stored in fpdu

	 * to the new buf, for this we also need to move the data currently

	 * placed on the buf. The assumption is that the buffer is big enough

	 * since fpdu_length <= mss, we use an intermediate buffer since

	 * we may need to copy the new data to an overlapping location

	/* If we managed to post the buffer copy the data to the new buffer

	 * o/w this will occur in the next round...

 fpdu->pkt_hdr remains as is */

 fpdu->mpa_frag is overridden with new buf */

 Update incomplete packets if needed */

 Missing lower byte is now available */

 one byte of hdr */

/* This function is used to recycle a buffer using the ll2 drop option. It

 * uses the mechanism to ensure that all buffers posted to tx before this one

 * were completed. The buffer sent here will be sent as a cookie in the tx

 * completion function and can then be reposted to rx chain when done. The flow

 * that requires this is the flow where a FPDU splits over more than 3 tcp

 * segments. In this case the driver needs to re-post a rx buffer instead of

 * the one received, but driver can't simply repost a buffer it copied from

 * as there is a case where the buffer was originally a packed FPDU, and is

 * partially posted to FW. Driver needs to ensure FW is done with it.

 vlan overload with enum iwarp_ll2_tx_queues */

	/* An unaligned packet means it's split over two tcp segments. So the

	 * complete packet requires 3 bds, one for the header, one for the

	 * part of the fpdu of the first tcp segment, and the last fragment

	 * will point to the remainder of the fpdu. A packed pdu, requires only

	 * two bds, one for the header and one for the data.

 offset in words */

 Send the mpa_buf only with the last fpdu (in case of packed) */

 vlan overload with enum iwarp_ll2_tx_queues */

	/* special case of unaligned packet and not packed, need to send

	 * both buffers as cookie to release.

 Set first fragment to header */

 Set second fragment to first part of packet */

 Set third fragment to second part of the packet */

/* This function is called when an unaligned or incomplete MPA packet arrives

 * driver needs to align the packet, perhaps using previous data and send

 * it down to FW once it is aligned.

 something corrupt with cid, post rx back */

				/* special handling of fpdu split over more

				 * than 2 segments

 packet will be re-processed later */

 packet will be re-processed later */

				/* don't reset fpdu -> we need it for next

				 * classify

 The framed PDU was sent - no more incomplete bytes */

		/* busy means break and continue processing later, don't

		 * remove the buf from the pending list.

 different error, don't continue */

 Check if packet was received with errors... */

 Check if there is a listener for this 4-tuple+vlan */

	/* There may be an open ep on this connection if this is a syn

	 * retrasnmit... need to make sure there isn't...

 can happen in packed mpa unaligned... */

 this was originally an rx packet, post it back */

/* The only slowpath for iwarp ll2 is unalign flush. When this completion

 * is received, need to reset the FPDU.

 buffers will be deallocated by qed_ll2 */

 Start SYN connection */

 SYN will use ctx based queues */

 will never be fragmented */

 Start OOO connection */

 OOO/unaligned will use legacy ll2 queues (ram based) */

 will never be fragmented */

 Start Unaligned MPA connection */

	/* FW requires that once a packet arrives OOO, it must have at

	 * least 2 rx buffers available on the unaligned connection

	 * for handling the case that it is a partial fpdu.

	/* The mpa_bufs array serves for pending RX packets received on the

	 * mpa ll2 that don't have place on the tx ring and require later

	 * processing. We can't fail on allocation of such a struct therefore

	 * we allocate enough to take care of all rx packets

 value 0 is used for ilog2(QED_IWARP_RCV_WND_SIZE_MIN) */

 paired with READ_ONCE in destroy_qp */

 paired with READ_ONCE in destroy_qp */

 Done with the SYN packet, post back to ll2 rx */

 If connect failed - upper layer doesn't know about it */

 Async completion after TCP 3-way handshake */

 Async completion for Close Connection ramrod */

 Async event for active side only */

 FW assigns value that is no greater than u16 */

 FW assigns value that is no greater than u16 */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)

/* QLogic qed NIC Driver

 * Copyright (c) 2015-2017  QLogic Corporation

 * Copyright (c) 2019-2020 Marvell International Ltd.

	/* This lock is released when we receive PF's response

	 * in qed_send_msg2pf().

	 * So, qed_vf_pf_prep() and qed_send_msg2pf()

	 * must come in sequence.

 Reset Request offset */

 Clear mailbox - both request and reply */

 Init type and length */

 Init first tlv header */

 output tlvs list */

 need to add the END TLV to the message size */

 Send TLVs over HW channel */

	/* The message data must be written first, to prevent trigger before

	 * data is written.

	/* When PF would be done with the response, it would write back to the

	 * `done' address from a coherent DMA zone. Poll until then.

 Only add QIDs for the queue if it was negotiated with PF */

 clear mailbox and prep first tlv */

 add list termination tlv */

 humble our request */

 clear mailbox and prep first tlv */

 starting filling the request */

 Fill capability field with any non-deprecated config we support */

 If we've mapped the doorbell bar, try using queue qids */

 pf 2 vf bulletin board address */

 add list termination tlv */

 Clear response buffer, as this might be a re-send */

 send acquire request */

 Re-try acquire in case of vf-pf hw channel timeout */

 copy acquire response from buffer to p_hwfn */

 PF agrees to allocate our resources */

				/* It's possible legacy PF mistakenly accepted;

				 * but we don't care - simply mark it as

				 * legacy and continue.

			/* If PF/VF are using same Major, PF must have had

			 * it's reasons. Simply fail.

 Mark the PF as legacy, if needed */

	/* In case PF doesn't support multi-queue Tx, update the number of

	 * CIDs to reflect the number of queues [older PFs didn't fill that

	 * field].

 Update bulletin board size with response from PF */

 get HW info */

 Learn of the possibility of CMT */

 Regview size is fixed */

 Doorbell is received from PF */

	/* Set number of hwfns - might be overridden once leading hwfn learns

	 * actual configuration from PF.

 Allocate vf sriov info */

	/* Doorbells are tricky; Upper-layer has alreday set the hwfn doorbell

	 * value, but there are several incompatibily scenarios where that

	 * would be incorrect and we'd need to override it.

		/* For leading hw-function, value is always correct, but need

		 * to handle scenario where legacy PF would not support 100g

		 * mapped bars later.

		/* here, value would be correct ONLY if the leading hwfn

		 * received indication that mapped-bars are supported.

 Allocate vf2pf msg */

 Allocate Bulletin board */

	/* If VF is 100g using a mapped bar and PF is too old to support that,

	 * acquisition would succeed - but the VF would have no way knowing

	 * the size of the doorbell bar configured in HW and thus will not

	 * know how to split it for 2nd hw-function.

	 * In this case we re-try without the indication of the mapped

	 * doorbell.

 Update mode and classes provided by PF */

 add list termination tlv */

 clear mailbox and prep first tlv */

	/* If PF is legacy, we'll need to calculate producers ourselves

	 * as well as clean them.

 Init the rcq, rx bd and rx sge (if valid) producers to 0 */

 add list termination tlv */

 Learn the address of the producer from the response */

 Init the rcq, rx bd and rx sge (if valid) producers to 0 */

 clear mailbox and prep first tlv */

 add list termination tlv */

 clear mailbox and prep first tlv */

 Tx */

 add list termination tlv */

	/* Modern PFs provide the actual offsets, while legacy

	 * provided only the queue id.

 clear mailbox and prep first tlv */

 add list termination tlv */

 clear mailbox and prep first tlv */

 status blocks */

 add list termination tlv */

 clear mailbox and prep first tlv */

 add list termination tlv */

 clear mailbox and prep header tlv */

 Prepare extended tlvs */

 add list termination tlv */

 clear mailbox and prep first tlv */

 add list termination tlv */

 clear mailbox and prep first tlv */

 add list termination tlv */

 clear mailbox and prep first tlv */

 add list termination tlv */

 clear mailbox and prep header tlv */

 clear mailbox and prep header tlv */

 add list termination tlv */

 clear mailbox and prep header tlv */

 add list termination tlv */

 Need to guarantee PF is not in the middle of writing it */

 If version did not update, no need to do anything */

 Verify the bulletin we see is valid */

 Set the shadow bulletin and process it */

 Forbid VF from changing a MAC enforced by PF */

 Always update link configuration according to bulletin */

 Handle bulletin board changes */

 As VF is polling bulletin board, need to constantly re-schedule */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)

/* QLogic qed NIC Driver

 * Copyright (c) 2015-2017  QLogic Corporation

 * Copyright (c) 2019-2020 Marvell International Ltd.

******************* Doorbell Recovery *******************/

/* The doorbell recovery mechanism consists of a list of entries which represent

 * doorbelling entities (l2 queues, roce sq/rq/cqs, the slowpath spq, etc). Each

 * entity needs to register with the mechanism and provide the parameters

 * describing it's doorbell, including a location where last used doorbell data

 * can be found. The doorbell execute function will traverse the list and

 * doorbell all of the registered entries.

 Display a single doorbell recovery entry */

 Doorbell address sanity (address within doorbell bar range) */

 Make sure doorbell address is within the doorbell bar */

 ake sure doorbell data pointer is not null */

 Find hwfn according to the doorbell address */

 In CMT doorbell bar is split down the middle between engine 0 and enigne 1 */

 Add a new entry to the doorbell recovery mechanism */

 Shortcircuit VFs, for now */

 Sanitize doorbell address */

 Obtain hwfn from doorbell address */

 Create entry */

 Populate entry */

 Display */

 Protect the list */

 Remove an entry from the doorbell recovery mechanism */

 Shortcircuit VFs, for now */

 Obtain hwfn from doorbell address */

 Protect the list */

 search according to db_data addr since db_addr is not unique (roce) */

 Initialize the doorbell recovery mechanism */

 Make sure db_size was set in cdev */

 Destroy the doorbell recovery mechanism */

 Print the content of the doorbell recovery mechanism */

 Protect the list */

 Ring the doorbell of a single doorbell recovery entry */

 Print according to width */

 Sanity */

	/* Flush the write combined buffer. Since there are multiple doorbelling

	 * entities using the same address, if we don't flush, a transaction

	 * could be lost.

 Ring the doorbell */

	/* Flush the write combined buffer. Next doorbell may come from a

	 * different entity to the same address...

 Traverse the doorbell recovery entry list and ring all the doorbells */

 Track amount of times recovery was executed */

 Protect the list */

******************* Doorbell Recovery end ****************/

********************************* NIG LLH ***********************************/

 Number of LLH filters banks */

	/* Array of filters arrays:

	 * "num_ppfid" elements of filters banks, where each is an array of

	 * "NIG_REG_LLH_FUNC_FILTER_EN_SIZE" filters.

 Check if the same filter already exist */

 Find a new entry in case of a new filter */

 No free entry was found */

 No matching filter was found */

 RoCE PF is bound to a single engine */

 Storage PF is bound to a single engine while L2 PF uses both */

 L2_PERSONALITY */

 The iWARP affinity is set as the affinity of ppfid 0 */

 QP bit 15 */

	/* The NIG/LLH registers that are accessed in this function have only 16

	 * rows which are exposed to a PF. I.e. only the 16 filters of its

	 * default ppfid. Accessing filters of other ppfids requires pretending

	 * to another PFs.

	 * The calculation of PPFID->PFID in AH is based on the relative index

	 * of a PF on its port.

	 * For BB the pfid is actually the abs_ppfid.

 Filter enable - should be done first when removing a filter */

 Filter value */

 size_in_dwords */,

 Filter mode */

 Filter protocol type */

 Filter header select */

 Filter enable - should be done last when adding a filter */

 Mode: 0: MAC-address classification 1: protocol classification */

 Configure the LLH only in case of a new the filter */

 Configure the LLH only in case of a new the filter */

 Remove from the LLH in case the filter is not in use */

 Remove from the LLH in case the filter is not in use */

****************************** NIG LLH - End ********************************/

 Old MFW initialized above registered only conditionally */

 hwfn 0 is always active */

 set the default cache alignment to 128 */

 Destroy doorbell recovery mechanism */

******************* QM initialization *******************/

 determines the physical queue flags for a given PF. */

 common flags */

 feature flags */

 protocol flags */

 Getters for resource amounts necessary for qm initialization */

 num RLs can't exceed resource amount of rls or vports */

 Make sure after we reserve there's something left */

 subtract rls necessary for VFs and one default one for the PF */

 all pqs share the same vport, except for vfs and pf_rl pqs */

 calc amount of PQs according to the requested flags */

 initialize the top level QM params */

 pq and vport bases for this PF */

 rate limiting and weighted fair queueing are always enabled */

 TC config is different for AH 4 port */

 in AH 4 port we have fewer TCs per port */

	/* unless MFW indicated otherwise, ooo_tc == 3 for

	 * AH 4-port and 4 otherwise.

 initialize qm vport params */

 all vports participate in weighted fair queueing */

 initialize qm port params */

 Initialize qm port parameters */

 indicate how ooo and high pri traffic is dealt with */

/* Reset the params which must be reset for qm init. QM init may be called as

 * a result of flows other than driver load (e.g. dcbx renegotiation). Other

 * params may be affected by the init but would simply recalculate to the same

 * values. The allocations made for QM init, ports, vports, pqs and vfqs are not

 * affected as these amounts stay the same.

/* initialize a single pq and manage qm_info resources accounting.

 * The pq_init_flags param determines whether the PQ is rate limited

 * (for VF or PF) and whether a new vport is allocated to the pq or not

 * (i.e. vport will be shared).

 flags for pq init */

 defines for pq init */

 init pq params */

 qm params accounting */

 get pq index according to PQ_FLAGS */

 Can't have multiple flags set here */

 save pq index in qm info */

 get tx pq index, with the PQ TX base already set (ready for context init) */

 Functions for creating specific types of pqs */

 override pq's TC if offload TC is set */

 rate limited pqs, must come first (FW assumption) */

 pqs for multi cos */

 pure loopback pq */

 out of order pq */

 pure ack pq */

 pq for offloaded protocol */

 low latency pq */

 done sharing vports */

 pqs for vfs */

 compare values of getters against resources amounts */

 top level params */

 port table */

 vport table */

 pq table */

 reset params required for init run */

 init QM top level params */

 init QM port params */

 init QM vport params */

 init QM physical queue params */

 display all that init */

/* This function reconfigures the QM pf on the fly.

 * For this purpose we:

 * 1. reconfigure the QM database

 * 2. set new values to runtime array

 * 3. send an sdm_qm_cmd through the rbc interface to stop the QM

 * 4. activate init tool in QM_PF stage

 * 5. send an sdm_qm_cmd through rbc interface to release the QM

 initialize qed's qm data structure */

 stop PF's qm queues */

 prepare QM portion of runtime array */

 activate init tool on runtime array */

 start PF's qm queues */

 Initialize the doorbell recovery mechanism */

 First allocate the context manager structure */

		/* Set the HW cid/tid numbers (in the contest manager)

		 * Must be done prior to any further computations.

 init qm info */

 Compute the ILT client partition */

			/* In case there are not enough ILT lines we reduce the

			 * number of RDMA tasks and re-compute.

		/* CID map / ILT shadow table / T2

		 * The talbes sizes are determined by the computations above

 SPQ, must follow ILT because initializes SPQ context */

 SP status block allocation */

 EQ */

			/* EQ should be able to get events from all SRQ's

			 * at the same time

 DMA info initialization */

 DCBX initialization */

 Read shadow of current MFW mailbox */

 Make sure notification is not set before initiating final cleanup */

 Poll until completion */

 Cleanup afterwards */

 Init run time data for all PFs on an engine. */

 Program GTT windows */

 pretend to original PF */

 pretend to original PF */

 Calculate DPI size */

 Calculate doorbell regions */

 Check that the normal and PWM sizes are valid */

 Calculate number of DPIs */

		/* Either EDPM is mandatory, or we are attempting to allocate a

		 * WID per CPU.

		/* Either EDPM is disabled from user configuration, or it is

		 * disabled via DCBx, or it is not mandatory and we failed to

		 * allocated a WID per CPU.

 DEMS size is configured log2 of DWORDs, hence the division by 4 */

 In CMT the gate should be cleared by the 2nd hwfn */

 Update rate limit once we'll actually have a link */

 Set VLAN in NIG if needed */

 Enable classification by MAC if needed */

 Protocol Configuration */

 Sanity check before the PF init sequence that uses DMAE */

 PF Init sequence */

 QM_PF Init sequence (may be invoked separately e.g. for DCB) */

 Pure runtime initializations - directly to the HW  */

 Use the leading hwfn since in CMT only NIG #0 is operational */

 enable interrupts */

 send function start command */

 Configure the PF's internal FID_enable for master transactions */

 Wait until value is set - try for 1 second every 50us */

 Read shadow of current MFW mailbox */

 If management didn't provide a default, set one of our own */

		/* Only relevant for recovery:

		 * Clear the indication after LOAD_REQ is responded by the MFW.

		/* Clean up chip from previous driver if such remains exist.

		 * This is not needed when the PF is the first one on the

		 * engine, since afterwards we are going to init the FW.

 Log and clear previous pglue_b errors if such exist */

 Enable the PF's internal FID_enable in the PXP */

		/* Clear the pglue_b was_error indication.

		 * In E4 it must be done after the BME and the internal

		 * FID_enable for the PF are set, since VDMs may cause the

		 * indication to be set again.

 send DCBX attention request command */

 Get pre-negotiated values for stag, bandwidth etc. */

	/* The MFW load lock should be released also when initialization fails.

 close timers */

		/* Dependent on number of connection/tasks, possibly

		 * 1ms sleep is required between polls

 mark the hw as uninitialized... */

 Send unload command to MCP */

		/* After this point no MFW attentions are expected, e.g. prevent

		 * race between pf stop and dcbx pf update.

 Disable Attention Generation */

 Need to wait 1ms to guarantee SBs are cleared */

 Disable PF in HW blocks */

		/* Clear the PF's internal FID_enable in the PXP.

		 * In CMT this should only be done for first hw-function, and

		 * only after all transactions have stopped for all active

		 * hw-functions.

 Need to wait 1ms to guarantee SBs are cleared */

 Re-open incoming traffic */

 Free hwfn memory and resources acquired in hw_hwfn_prepare */

 Setup bar access */

 clear indirect access */

 Clean previous pglue_b errors if such exist */

 enable internal target-read */

 ME Register */

		/* Roce CNQ each requires: 1 status block + 1 CNQ. We divide

		 * the status blocks equally between L2 / RoCE but with

		 * consideration as to how many l2 queues / cnqs we have.

 Start by allocating VF queues, then PF's */

			/* No need for a case for QED_CMDQS_CQS since

			 * CNQ/CMDQS are the same resource.

		/* There's no point to continue to the next resource if the

		 * command is not supported by the MFW.

		 * We do continue if the command is supported but the resource

		 * is unknown to the MFW. Such a resource will be later

		 * configured with the default allocation values.

 The granularity of the PQs is 8 */

 Each VFC resource can accommodate both a MAC and a VLAN */

 CNQ/CMDQS are the same resource */

		/* Since we want its value to reflect whether MFW supports

		 * the new scheme, have a default of 0.

	/* Default driver values are applied in the following cases:

	 * - The resource allocation MB command is not supported by the MFW

	 * - There is an internal error in the MFW while processing the request

	 * - The resource ID is unknown to the MFW

	/* PQs have to divide by 8 [that's the HW granularity].

	 * Reduce number so it would fit.

 Calculation of BB/AH is different for native_ppfid_idx */

	/* Setting the max values of the soft resources and the following

	 * resources allocation queries should be atomic. Since several PFs can

	 * run in parallel - a resource lock is needed.

	 * If either the resource lock or resource set value commands are not

	 * supported - skip the max values setting, release the lock if

	 * needed, and proceed to the queries. Other failures, including a

	 * failure to acquire the lock, will cause this function to fail.

 PPFID bitmap */

 Sanity for ILT */

 This will also learn the number of SBs from MFW */

 Read global nvm_cfg address */

 Verify MCP has initialized it */

 Read nvm_cfg1  (Notice this is just offset, and not offsize (TBD) */

 Read default link configuration */

 Read Multi-function information from shmem */

		/* In CMT the PF is unknown when the GFS block processes the

		 * packet. Therefore cannot use searcher as it has a per PF

		 * database, and thus ARFS must be disabled.

		 *

 Read device capabilities information from shmem */

 Read device serial number information from shmem */

	/* Bit 0 of MISCS_REG_FUNCTION_HIDE indicates whether the bypass values

	 * in the other bits are selected.

	 * Bits 1-15 are for functions 1-15, respectively, and their value is

	 * '0' only for enabled functions (function 0 always exists and

	 * enabled).

	 * In case of CMT, only the "even" functions are enabled, and thus the

	 * number of functions for both hwfns is learnt from the same bits.

 Get the number of the enabled functions on the engine */

 Get the PF index within the enabled functions */

 In CMT there is always only one port */

 Determine the number of ports per engine */

 Default to something */

 Get the total number of ports of the device */

 Since all information is common, only first hwfns should do this */

 Read Vendor Id / Device Id */

 Determine type */

 Learn number of HW-functions */

 Split PCI bars evenly between hwfns */

 Validate that chip access is feasible */

 Allocate PTT pool */

 Allocate the main PTT */

 First hwfn learns basic information, e.g., number of hwfns */

 Initialize MCP structure */

 Read the device configuration information from the HW and SHMEM */

	/* Sending a mailbox to the MFW should be done after qed_get_hw_info()

	 * is called as it sets the ports number in an engine.

 NVRAM info initialization and population */

 Allocate the init RT array and initialize the init-ops engine */

 Store the precompiled init data ptrs */

 Initialize the first hwfn - will learn number of hwfns */

 Initialize the rest of the hwfns */

 adjust bar offset for second engine */

 prepare second hw function */

		/* in case of error, need to free the previously

		 * initiliazed hwfn 0.

 Coalesce = (timeset << timer-resolution), timeset is 7bit wide */

 Coalesce = (timeset << timer-resolution), timeset is 7bit wide */

/* Calculate final WFQ values for all vports and configure them.

 * After this configuration each vport will have

 * approx min rate =  min_pf_rate * (vport_wfq / QED_WFQ_UNIT)

/* This function performs several validations for WFQ

 * configuration and required min rate for a given vport

 * 1. req_rate must be greater than one percent of min_pf_rate.

 * 2. req_rate should not cause other vports [not configured for WFQ explicitly]

 *    rates to get less than one percent of min_pf_rate.

 * 3. total_req_min_rate [all vports min rate sum] shouldn't exceed min_pf_rate.

 Accounting for the vports which are configured for WFQ explicitly */

 Include current vport data as well */

 Validate all pre configured vports for wfq */

/* Main API for qed clients to configure vport min rate.

 * vp_id - vport id in PF Range[0 - (total_num_vports_per_pf - 1)]

 * rate - Speed in Mbps needs to be assigned to a given vport.

 Currently not supported; Might change in future */

 API to configure WFQ from mcp link change */

	/* Since the limiter also affects Tx-switched traffic, we don't want it

	 * to limit such traffic in case there's no actual limit.

	 * In that case, set limit to imaginary high boundary.

 Main API to configure PF max bandwidth where bw range is [1 - 100] */

 Main API to configure PF min bandwidth where bw range is [1-100] */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)

 Copyright (c) 2019-2020 Marvell International Ltd. */

 To be filled with the address to set in Value field */

 To be used internally in case the value has to be modified */

 Returns size of the data buffer or, -1 in case TLV data is not available. */

 Validate numbers */

	/* Read the TLV request to local buffer. MFW represents the TLV in

	 * little endian format and mcp returns it bigendian format. Hence

	 * driver need to convert data to little endian first and then do the

	 * memcpy (casting) to preserve the MFW TLV format in the driver buffer.

	 *

 Parse the headers to enumerate the requested TLV groups */

 Sanitize the TLV groups according to personality */

 Update the TLV values in the local buffer */

	/* Write the TLV data to shared memory. The stream of 4 bytes first need

	 * to be mem-copied to u32 element to make it as LSB format. And then

	 * converted to big endian as required by mcp-write.

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)

/* QLogic qed NIC Driver

 * Copyright (c) 2015 QLogic Corporation

 * Copyright (c) 2019-2021 Marvell International Ltd.

 Memory groups enum */

 Memory groups names */

 Idle check conditions */

 Array of Idle Check conditions */

****************************** Data Types **********************************/

 CM context types */

 Debug bus frame modes */

 4 Storm dwords (no HW) */

 2 Storm dwords, 2 HW dwords */

 1 Storm dwords, 3 HW dwords */

 4 HW dwords (no Storms) */

 8 HW dwords (no Storms) */

 Debug bus SEMI frame modes */

 4 fast dw */

 2 fast dw, 2 slow dw */

 1 fast dw,3 slow dw */

 4 slow dw */

 Debug bus filter types */

 Filter always off */

 Filter before trigger only */

 Filter after trigger only */

 Filter always on */

 Debug bus pre-trigger recording types */

 Record from time 0 */

 Record some chunks before trigger */

 Drop data before trigger */

 Debug bus post-trigger recording types */

 Start recording after trigger */

 Drop data after trigger */

 Debug bus other engine mode */

 DBG block Framing mode definitions */

 Chip constant definitions */

 HW type constant definitions */

 RBC reset definitions */

/* Storm constant definitions.

 * Addresses are in bytes, sizes are in quad-regs.

 Debug Bus Constraint operation constant definitions */

 Storm Mode definitions */

 Address is in 128b units. Width is in bits. */

 In dwords */

 PHY base GRC address */

 Relative address of indirect TBUS address register (bits 0..7) */

 Relative address of indirect TBUS address register (bits 8..10) */

 Relative address of indirect TBUS data register (bits 0..7) */

 Relative address of indirect TBUS data register (bits 8..11) */

 Split type definitions */

******************************* Constants **********************************/

 In the macros below, size and offset are specified in bits */

 extra lines include a signature line + optional latency events line */

 The sizes and offsets below are specified in bits */

**************************** Constant Arrays *******************************/

 DBG block framing mode definitions, in descending preference order */

 Chip constant definitions array */

 Storm constant definitions array */

 Tstorm */

 {bb} {k2} */

 Mstorm */

 {bb} {k2}*/

 Ustorm */

 {bb} {k2} */

 Xstorm */

 {bb} {k2} */

 Ystorm */

 {bb} {k2} */

 Pstorm */

 {bb} {k2} */

 HW_TYPE_ASIC */

 DBG_GRC_PARAM_DUMP_TSTORM */

 DBG_GRC_PARAM_DUMP_MSTORM */

 DBG_GRC_PARAM_DUMP_USTORM */

 DBG_GRC_PARAM_DUMP_XSTORM */

 DBG_GRC_PARAM_DUMP_YSTORM */

 DBG_GRC_PARAM_DUMP_PSTORM */

 DBG_GRC_PARAM_DUMP_REGS */

 DBG_GRC_PARAM_DUMP_RAM */

 DBG_GRC_PARAM_DUMP_PBUF */

 DBG_GRC_PARAM_DUMP_IOR */

 DBG_GRC_PARAM_DUMP_VFC */

 DBG_GRC_PARAM_DUMP_CM_CTX */

 DBG_GRC_PARAM_DUMP_ILT */

 DBG_GRC_PARAM_DUMP_RSS */

 DBG_GRC_PARAM_DUMP_CAU */

 DBG_GRC_PARAM_DUMP_QM */

 DBG_GRC_PARAM_DUMP_MCP */

 DBG_GRC_PARAM_DUMP_DORQ */

 DBG_GRC_PARAM_DUMP_CFC */

 DBG_GRC_PARAM_DUMP_IGU */

 DBG_GRC_PARAM_DUMP_BRB */

 DBG_GRC_PARAM_DUMP_BTB */

 DBG_GRC_PARAM_DUMP_BMB */

 DBG_GRC_PARAM_RESERVED1 */

 DBG_GRC_PARAM_DUMP_MULD */

 DBG_GRC_PARAM_DUMP_PRS */

 DBG_GRC_PARAM_DUMP_DMAE */

 DBG_GRC_PARAM_DUMP_TM */

 DBG_GRC_PARAM_DUMP_SDM */

 DBG_GRC_PARAM_DUMP_DIF */

 DBG_GRC_PARAM_DUMP_STATIC */

 DBG_GRC_PARAM_UNSTALL */

 DBG_GRC_PARAM_RESERVED2 */

 DBG_GRC_PARAM_MCP_TRACE_META_SIZE */

 DBG_GRC_PARAM_EXCLUDE_ALL */

 DBG_GRC_PARAM_CRASH */

 DBG_GRC_PARAM_PARITY_SAFE */

 DBG_GRC_PARAM_DUMP_CM */

 DBG_GRC_PARAM_DUMP_PHY */

 DBG_GRC_PARAM_NO_MCP */

 DBG_GRC_PARAM_NO_FW_VER */

 DBG_GRC_PARAM_RESERVED3 */

 DBG_GRC_PARAM_DUMP_MCP_HW_DUMP */

 DBG_GRC_PARAM_DUMP_ILT_CDUC */

 DBG_GRC_PARAM_DUMP_ILT_CDUT */

 DBG_GRC_PARAM_DUMP_CAU_EXT */

 SPLIT_TYPE_NONE */

 SPLIT_TYPE_PORT */

 SPLIT_TYPE_PF */

 SPLIT_TYPE_PORT_PF */

 SPLIT_TYPE_VF */

******************************* Variables **********************************/

 The version of the calling app */

*************************** Private Functions ******************************/

 Reads and returns a single dword from the specified unaligned buffer */

 Sets the value of the specified GRC param */

 Returns the value of the specified GRC param */

 Initializes the GRC parameters */

 Sets pointer and size for the specified binary buffer type */

 Initializes debug data for the specified device */

 Set chip */

 Set HW type */

 Set port mode */

 Set 100G mode */

 Set number of ports */

 Set number of PFs per port */

 Initializes the GRC parameters */

/* Reads the FW info structure for the specified Storm from the chip,

 * and writes it to the specified fw_info pointer.

	/* Read first the address that points to fw_info location.

	 * The address is located in the last line of the Storm RAM.

 Read FW version info from Storm RAM */

/* Dumps the specified string to the specified buffer.

 * Returns the dumped size in bytes.

/* Dumps zeros to align the specified buffer to dwords.

 * Returns the dumped size in bytes.

/* Writes the specified string param to the specified buffer.

 * Returns the dumped size in dwords.

 Dump param name */

 Indicate a string param value */

 Dump param value */

 Align buffer to next dword */

/* Writes the specified numeric param to the specified buffer.

 * Returns the dumped size in dwords.

 Dump param name */

 Indicate a numeric param value */

 Align buffer to next dword */

 Dump param value (and change offset from bytes to dwords) */

/* Reads the FW version and writes it as a param to the specified buffer.

 * Returns the dumped size in dwords.

 Read FW info from chip */

 Create FW version/image strings */

 Dump FW version, image and timestamp */

/* Reads the MFW version and writes it as a param to the specified buffer.

 * Returns the dumped size in dwords.

		/* Find MCP public data GRC address. Needs to be ORed with

		 * MCP_REG_SCRATCH due to a HW bug.

 Find MCP public global section offset */

 Read MFW version from MCP public global section */

 Dump MFW version param */

/* Reads the chip revision from the chip and writes it as a param to the

 * specified buffer. Returns the dumped size in dwords.

/* Writes a section header to the specified buffer.

 * Returns the dumped size in dwords.

/* Writes the common global params to the specified buffer.

 * Returns the dumped size in dwords.

 Dump global params section header */

 Store params */

/* Writes the "last" section (including CRC) to the specified buffer at the

 * given offset. Returns the dumped size in dwords.

 Dump CRC section header */

 Calculate CRC32 and add it to the dword after the "last" section */

 Update blocks reset state  */

 Read reset registers */

 Check if blocks are in reset */

 is_mode_match recursive function */

 Get next element from modes tree buffer */

 Returns true if the mode (specified using modes_buf_offset) is enabled */

 Enable / disable the Debug block */

 Resets the Debug block */

/* Enable / disable Debug Bus clients according to the specified mask

 * (1 = enable, 0 = disable).

 Disable debug bus in all blocks */

 Disable all blocks */

 Disable debug bus */

/* Returns true if the specified entity (indicated by GRC param) should be

 * included in the dump, false otherwise.

/* Returns the storm_id that matches the specified Storm letter,

 * or MAX_DBG_STORMS if invalid storm letter.

/* Returns true of the specified Storm should be included in the dump, false

 * otherwise.

/* Returns true if the specified memory should be included in the dump, false

 * otherwise.

 If the block is associated with a Storm, check Storm match */

 Stalls all Storms */

/* Takes all blocks out of reset. If rbc_only is true, only RBC clients are

 * taken out of reset.

 Take RBCs out of reset */

 Fill reset regs values */

 Write reset registers */

 Returns the attention block data of the specified block */

 Returns the attention registers of the specified block */

 For each block, clear the status of all parities */

 Check mode */

 If Mode match: clear parity status */

 Finds the meta data image in NVRAM */

 Call NVRAM get file command */

 Check response */

 Update return values */

 Check alignment */

 Reads data from NVRAM */

 Call NVRAM read command */

 Check response */

 Update read offset */

/* Dumps GRC registers section header. Returns the dumped size in dwords.

 * the following parameters are dumped:

 * - count: no. of dumped entries

 * - split_type: split type

 * - split_id: split ID (dumped only if split_id != SPLIT_TYPE_NONE)

 * - reg_type_name: register type name (dumped only if reg_type_name != NULL)

/* Reads the specified registers into the specified buffer.

 * The addr and len arguments are specified in dwords.

/* Dumps the GRC registers in the specified address range.

 * Returns the dumped size in dwords.

 * The addr and len arguments are specified in dwords.

 Try reading using DMAE */

 Set DMAE params */

 Execute DMAE command */

 If not read using DMAE, read using GRC */

 Set pretend */

 Read registers using GRC */

 Print log */

/* Dumps GRC registers sequence header. Returns the dumped size in dwords.

 * The addr and len arguments are specified in dwords.

/* Dumps GRC registers sequence. Returns the dumped size in dwords.

 * The addr and len arguments are specified in dwords.

/* Dumps GRC registers sequence with skip cycle.

 * Returns the dumped size in dwords.

 * - addr:	start GRC address in dwords

 * - total_len:	total no. of dwords to dump

 * - read_len:	no. consecutive dwords to read

 * - skip_len:	no. of dwords to skip (and fill with zeros)

 Dumps GRC registers entries. Returns the dumped size in dwords. */

 Check mode/block */

 Dumps GRC registers entries. Returns the dumped size in dwords. */

 In PORT_PF split type, print a port split header */

 Calculate register dump header size (and skip it for now) */

 Dump registers */

 Write register dump header */

/* Dumps registers according to the input registers array. Returns the dumped

 * size in dwords.

 Cancel pretends (pretend to original PF) */

 Dump reset registers. Returns the dumped size in dwords. */

 Calculate header size */

 Write reset registers */

 Write header */

/* Dump registers that are modified during GRC Dump and therefore must be

 * dumped first. Returns the dumped size in dwords.

 Write empty header for attention registers */

 Write parity registers */

 Check mode */

 Mode match: read & dump registers */

 Overwrite header for attention registers */

 Write empty header for stall registers */

 Write Storm stall status registers */

 Overwrite header for stall registers */

 Dumps registers that can't be represented in the debug arrays */

	/* Dump R/TDIF_REG_DEBUG_ERROR_INFO_SIZE (every 8'th register should be

	 * skipped).

/* Dumps a GRC memory header (section and params). Returns the dumped size in

 * dwords. The following parameters are dumped:

 * - name:	   dumped only if it's not NULL.

 * - addr:	   in dwords, dumped only if name is NULL.

 * - len:	   in dwords, always dumped.

 * - width:	   dumped if it's not zero.

 * - packed:	   dumped only if it's not false.

 * - mem_group:	   always dumped.

 * - is_storm:	   true only if the memory is related to a Storm.

 * - storm_letter: valid only if is_storm is true.

 *

 Dump section header */

 Dump name */

 Dump address */

 Dump len */

 Dump bit width */

 Dump packed */

 Dump reg type */

/* Dumps a single GRC memory. If name is NULL, the memory is stored by address.

 * Returns the dumped size in dwords.

 * The addr and len arguments are specified in dwords.

 Dumps GRC memories entries. Returns the dumped size in dwords. */

 Check required mode */

			/* If memory is associated with Storm,

			 * update storm details

 Dump memory */

/* Dumps GRC memories according to the input array dump_mem.

 * Returns the dumped size in dwords.

/* Dumps GRC context data for the specified Storm.

 * Returns the dumped size in dwords.

 * The lid_size argument is specified in quad-regs.

 Convert quad-regs to dwords */

 Dump context data */

 Dumps GRC contexts. Returns the dumped size in dwords. */

 Dump Conn AG context size */

 Dump Conn ST context size */

 Dump Task AG context size */

 Dump Task ST context size */

/* Reads data from VFC. Returns the number of dwords read (0 on error).

 * Sizes are specified in dwords.

 Write VFC command */

 Write VFC address */

 Read response */

 Poll until ready */

 Dump VFC CAM. Returns the dumped size in dwords. */

 Prepare CAM address */

 Read VFC CAM data */

 Dump VFC RAM. Returns the dumped size in dwords. */

 Prepare RAM address */

 Read VFC RAM data */

 Dumps GRC VFC data. Returns the dumped size in dwords. */

 Read CAM */

 Read RAM */

 Dumps GRC RSS data. Returns the dumped size in dwords. */

 Dump RSS data */

 Dumps GRC Big RAM. Returns the dumped size in dwords. */

 Dump memory header */

 Read and dump Big RAM data */

 Dump Big RAM */

 Dumps MCP scratchpad. Returns the dumped size in dwords. */

 Halt MCP */

 Dump MCP scratchpad */

 Dump MCP cpu_reg_file */

 Dump MCP registers */

 Dump required non-MCP registers */

 Release MCP */

/* Dumps the tbus indirect memory for all PHYs.

 * Returns the dumped size in dwords.

 Dumps the MCP HW dump from NVRAM. Returns the dumped size in dwords. */

 Read HW dump image from NVRAM */

 Dump HW dump image section */

 Read MCP HW dump image into dump buffer */

 Dumps Static Debug data. Returns the dumped size in dwords. */

 Don't dump static debug if a debug bus recording is in progress */

 Disable debug bus in all blocks */

 Dump all static debug lines for each relevant block */

 Dump static section params */

 If all lines are invalid - dump zeros */

 Enable block's client */

 Configure debug line ID */

 Read debug line info */

 Disable block's client and debug output */

/* Performs GRC Dump to the specified buffer.

 * Returns the dumped size in dwords.

 Update reset state */

 Dump global params */

 Dump reset registers (dumped before taking blocks out of reset ) */

 Take all blocks out of reset (using reset registers) */

 Disable all parities using MFW command */

 Dump modified registers (dumped before modifying them) */

 Stall storms */

 Dump all regs  */

 Dump all blocks except MCP */

 Dump special registers */

 Dump memories */

 Dump MCP */

 Dump context */

 Dump RSS memories */

 Dump Big RAM */

 Dump VFC */

 Dump PHY tbus */

 Dump MCP HW Dump */

 Dump static debug data (only if not during debug bus recording) */

 Dump last section */

 Unstall storms */

 Clear parity status */

 Enable all parities using MFW command */

/* Writes the specified failing Idle Check rule to the specified buffer.

 * Returns the dumped size in dwords.

 Dump rule data */

 Dump condition register values */

 Write register header */

 Write register values */

 Dump info register values */

 Check if register's block is in reset */

 Check mode */

 Write register header */

 Write register values */

 Dumps idle check rule entries. Returns the dumped size in dwords. */

		/* Check if all condition register blocks are out of reset, and

		 * find maximal number of entries (all condition registers that

		 * are memories must have the same size, which is > 1).

		/* Go over all register entries (number of entries is the same

		 * for all condition registers).

 Read current entry of all condition registers */

				/* Find GRC address (if it's a memory, the

				 * address of the specific entry is calculated).

 Read registers */

			/* Call rule condition function.

			 * If returns true, it's a failure.

/* Performs Idle Check Dump to the specified buffer.

 * Returns the dumped size in dwords.

 Dump global params  - 1 must match below amount of params */

 Dump idle check section header with a single parameter */

 Check mode */

 Overwrite num_rules parameter */

 Dump last section */

/* Get info on the MCP Trace data in the scratchpad:

 * - trace_data_grc_addr (OUT): trace data GRC address in bytes

 * - trace_data_size (OUT): trace data size in bytes (without the header)

 Read trace section offsize structure from MCP scratchpad */

 Extract trace section address from offsize (in scratchpad) */

 Read signature from MCP trace section */

 Read trace size from MCP trace section */

/* Reads MCP trace meta data image from NVRAM

 * - running_bundle_id (OUT): running bundle ID (invalid when loaded from file)

 * - trace_meta_offset (OUT): trace meta offset in NVRAM in bytes (invalid when

 *			      loaded from file).

 * - trace_meta_size (OUT):   size in bytes of the trace meta data.

 Read MCP trace section offsize structure from MCP scratchpad */

 Find running bundle ID */

 Find image in NVRAM */

 Reads the MCP Trace meta data from NVRAM into the specified buffer */

 Read meta data from NVRAM */

 Extract and check first signature */

 Extract number of modules */

 Skip all modules */

 Extract and check second signature */

 Dump MCP Trace */

 Get trace data info */

 Dump global params */

	/* Halt MCP while reading from scratchpad so the read data will be

	 * consistent. if halt fails, MCP trace is taken anyway, with a small

	 * risk that it may be corrupt.

 Find trace data size */

 Dump trace data section header and param */

 Read trace data from scratchpad into dump buffer */

 Resume MCP (only if halt succeeded) */

 Dump trace meta section header */

	/* If MCP Trace meta size parameter was set, use it.

	 * Otherwise, read trace meta.

	 * trace_meta_size_bytes is dword-aligned.

 Dump trace meta size param */

 Read trace meta image into dump buffer */

 Dump last section */

	/* If no mcp access, indicate that the dump doesn't contain the meta

	 * data from NVRAM.

 Dump GRC FIFO */

 Dump global params */

	/* Dump fifo data section header and param. The size param is 0 for

	 * now, and is overwritten after reading the FIFO.

		/* FIFO max size is REG_FIFO_DEPTH_DWORDS. There is no way to

		 * test how much data is available, except for reading it.

	/* Pull available data from fifo. Use DMAE since this is widebus memory

	 * and must be accessed atomically. Test for dwords_read not passing

	 * buffer size since more entries could be added to the buffer as we are

	 * emptying it.

 Dump last section */

 Dump IGU FIFO */

 Dump global params */

	/* Dump fifo data section header and param. The size param is 0 for

	 * now, and is overwritten after reading the FIFO.

		/* FIFO max size is IGU_FIFO_DEPTH_DWORDS. There is no way to

		 * test how much data is available, except for reading it.

	/* Pull available data from fifo. Use DMAE since this is widebus memory

	 * and must be accessed atomically. Test for dwords_read not passing

	 * buffer size since more entries could be added to the buffer as we are

	 * emptying it.

 Dump last section */

 Protection Override dump */

 Dump global params */

	/* Dump data section header and param. The size param is 0 for now,

	 * and is overwritten after reading the data.

 Add override window info to buffer */

 Dump last section */

/* Performs FW Asserts Dump to the specified buffer.

 * Returns the dumped size in dwords.

 Dump global params */

 Find Storm dump size */

 Read FW info for the current Storm */

 Dump FW Asserts section header and params */

 Read and dump FW Asserts data */

 Dump last section */

/* Dumps the specified ILT pages to the specified buffer.

 * Returns the dumped size in dwords.

			/* Copy page ID to dump buffer

			 * (if dump is needed and buffer is not full)

 Copy page memory to dump buffer */

/* Dumps a section containing the dumped ILT pages.

 * Returns the dumped size in dwords.

 Dump size parameter (0 for now, overwritten with real size later) */

	/* CDUC pages are ordered as follows:

	 * - PF pages - valid section (included in PF connection type mapping)

	 * - PF pages - invalid section (not dumped)

	 * - For each VF in the PF:

	 *   - VF pages - valid section (included in VF connection type mapping)

	 *   - VF pages - invalid section (not dumped)

 Dump connection PF pages */

 Dump connection VF pages */

	/* CDUT pages are ordered as follows:

	 * - PF init pages (not dumped)

	 * - PF work pages

	 * - For each VF in the PF:

	 *   - VF init pages (not dumped)

	 *   - VF work pages

 Dump task PF pages */

 Dump task VF pages */

Dump Searcher pages */

 Overwrite size param */

/* Dumps a section containing the global parameters.

 * Part of ilt dump process

 * Returns the dumped size in dwords.

	/* Additional/Less parameters require matching of number in call to

	 * dump_common_global_params()

/* Dump section containing number of PF CIDs per connection type.

 * Part of ilt dump process.

 * Returns the dumped size in dwords.

/* Dump section containing number of VF CIDs per connection type

 * Part of ilt dump process.

 * Returns the dumped size in dwords.

/* Performs ILT Dump to the specified buffer.

 * buf_size_in_dwords - The dumped buffer size.

 * Returns the dumped size in dwords.

	/* if need to dump then save memory for the last section

	 * (last section calculates CRC of dumped data)

 Dump global params */

	/* if need to dump then first check that there is enough memory

	 * in dumped buffer for this section calculate the size of this

	 * section without dumping. if there is not enough memory - then

	 * stop the dumping.

	/* Dump section containing number of PF CIDs per connection type

	 * If need to dump then first check that there is enough memory in

	 * dumped buffer for this section.

	/* Dump section containing number of VF CIDs per connection type

	 * If need to dump then first check that there is enough memory in

	 * dumped buffer for this section.

	/* Dump section containing physical memory descriptors for each

	 * ILT page.

	/* If need to dump then first check that there is enough memory

	 * in dumped buffer for the section header.

	/* Copy memory descriptors to dump buffer

	 * If need to dump then dump till the dump buffer size

 Dump ILT pages IDs */

 Dump ILT pages memory */

 Dump last section */

**************************** Public Functions *******************************/

 Convert binary data to debug arrays */

 Skip Storm if it's in reset */

 Read FW info for the current Storm */

	/* Initializes the GRC parameters (if not initialized). Needed in order

	 * to set the default parameter values for the first time.

 Preset param */

		/* Disabling a preset is not allowed. Call

		 * dbg_grc_set_params_default instead.

 Update all params with the preset values */

 Skip persistent params */

 Find preset value */

 Regular param - set its value */

 Assign default GRC param values */

 Doesn't do anything, needed for compile time asserts */

 GRC Dump */

 Revert GRC params to their default */

 Update reset state */

 Idle Check Dump */

 Revert GRC params to their default */

 Update reset state */

 Perform dump */

 Revert GRC params to their default */

 Update reset state */

 Revert GRC params to their default */

 Update reset state */

 Revert GRC params to their default */

 Update reset state */

 Revert GRC params to their default */

 Update reset state */

 Revert GRC params to their default */

 Reveret GRC params to their default */

 Check mode */

 Mode match - read attention status register */

 Non-zero attention status - add to results */

****************************** Data Types **********************************/

 REG fifo element */

 REG fifo error element */

 IGU fifo element */

 Protection override element */

******************************* Constants **********************************/

**************************** Constant Arrays *******************************/

 Status string array */

 DBG_STATUS_OK */

 DBG_STATUS_APP_VERSION_NOT_SET */

 DBG_STATUS_UNSUPPORTED_APP_VERSION */

 DBG_STATUS_DBG_BLOCK_NOT_RESET */

 DBG_STATUS_INVALID_ARGS */

 DBG_STATUS_OUTPUT_ALREADY_SET */

 DBG_STATUS_INVALID_PCI_BUF_SIZE */

 DBG_STATUS_PCI_BUF_ALLOC_FAILED */

 DBG_STATUS_PCI_BUF_NOT_ALLOCATED */

 DBG_STATUS_INVALID_FILTER_TRIGGER_DWORDS */

 DBG_STATUS_NO_MATCHING_FRAMING_MODE */

 DBG_STATUS_VFC_READ_ERROR */

 DBG_STATUS_STORM_ALREADY_ENABLED */

 DBG_STATUS_STORM_NOT_ENABLED */

 DBG_STATUS_BLOCK_ALREADY_ENABLED */

 DBG_STATUS_BLOCK_NOT_ENABLED */

 DBG_STATUS_NO_INPUT_ENABLED */

 DBG_STATUS_NO_FILTER_TRIGGER_256B */

 DBG_STATUS_FILTER_ALREADY_ENABLED */

 DBG_STATUS_TRIGGER_ALREADY_ENABLED */

 DBG_STATUS_TRIGGER_NOT_ENABLED */

 DBG_STATUS_CANT_ADD_CONSTRAINT */

 DBG_STATUS_TOO_MANY_TRIGGER_STATES */

 DBG_STATUS_TOO_MANY_CONSTRAINTS */

 DBG_STATUS_RECORDING_NOT_STARTED */

 DBG_STATUS_DATA_DIDNT_TRIGGER */

 DBG_STATUS_NO_DATA_RECORDED */

 DBG_STATUS_DUMP_BUF_TOO_SMALL */

 DBG_STATUS_DUMP_NOT_CHUNK_ALIGNED */

 DBG_STATUS_UNKNOWN_CHIP */

 DBG_STATUS_VIRT_MEM_ALLOC_FAILED */

 DBG_STATUS_BLOCK_IN_RESET */

 DBG_STATUS_INVALID_TRACE_SIGNATURE */

 DBG_STATUS_INVALID_NVRAM_BUNDLE */

 DBG_STATUS_NVRAM_GET_IMAGE_FAILED */

 DBG_STATUS_NON_ALIGNED_NVRAM_IMAGE */

 DBG_STATUS_NVRAM_READ_FAILED */

 DBG_STATUS_IDLE_CHK_PARSE_FAILED */

 DBG_STATUS_MCP_TRACE_BAD_DATA */

 DBG_STATUS_MCP_TRACE_NO_META */

 DBG_STATUS_MCP_COULD_NOT_HALT */

 DBG_STATUS_MCP_COULD_NOT_RESUME */

 DBG_STATUS_RESERVED0 */

 DBG_STATUS_SEMI_FIFO_NOT_EMPTY */

 DBG_STATUS_IGU_FIFO_BAD_DATA */

 DBG_STATUS_MCP_COULD_NOT_MASK_PRTY */

 DBG_STATUS_FW_ASSERTS_PARSE_FAILED */

 DBG_STATUS_REG_FIFO_BAD_DATA */

 DBG_STATUS_PROTECTION_OVERRIDE_BAD_DATA */

 DBG_STATUS_DBG_ARRAY_NOT_SET */

 DBG_STATUS_RESERVED1 */

 DBG_STATUS_NON_MATCHING_LINES */

 DBG_STATUS_INSUFFICIENT_HW_IDS */

 DBG_STATUS_DBG_BUS_IN_USE */

 DBG_STATUS_INVALID_STORM_DBG_MODE */

 DBG_STATUS_OTHER_ENGINE_BB_ONLY */

 DBG_STATUS_FILTER_SINGLE_HW_ID */

 DBG_STATUS_TRIGGER_SINGLE_HW_ID */

 DBG_STATUS_MISSING_TRIGGER_STATE_STORM */

 DBG_STATUS_MDUMP2_FAILED_TO_REQUEST_OFFSIZE */

 DBG_STATUS_MDUMP2_FAILED_VALIDATION_OF_DATA_CRC */

 DBG_STATUS_MDUMP2_INVALID_SIGNATURE */

 DBG_STATUS_MDUMP2_INVALID_LOG_SIZE */

 DBG_STATUS_MDUMP2_INVALID_LOG_HDR */

 DBG_STATUS_MDUMP2_INVALID_LOG_DATA */

 DBG_STATUS_MDUMP2_ERROR_EXTRACTING_NUM_PORTS */

 DBG_STATUS_MDUMP2_ERROR_EXTRACTING_MFW_STATUS */

 DBG_STATUS_MDUMP2_ERROR_DISPLAYING_LINKDUMP */

 DBG_STATUS_MDUMP2_ERROR_READING_PHY_CFG */

 DBG_STATUS_MDUMP2_ERROR_READING_PLL_MODE */

 DBG_STATUS_MDUMP2_ERROR_READING_LANE_REGS */

 DBG_STATUS_MDUMP2_ERROR_ALLOCATING_BUF */

 Idle check severity names array */

 MCP Trace level names array */

 Access type names array */

 Privilege type names array */

 Protection type names array */

 Master type names array */

 REG FIFO error messages array */

 IGU FIFO sources array */

 IGU FIFO error messages */

 IGU FIFO address data */

******************************* Variables **********************************/

 Temporary buffer, used for print size calculations */

*************************** Private Functions ******************************/

/* Reads the specified number of bytes from the specified cyclic buffer (up to 4

 * bytes) and returns them as a dword value. the specified buffer offset is

 * updated.

	/* Assume running on a LITTLE ENDIAN and the buffer is network order

	 * (BIG ENDIAN), as high order bytes are placed in lower memory address.

/* Reads and returns the next byte from the specified buffer.

 * The specified buffer offset is updated.

/* Reads and returns the next dword from the specified buffer.

 * The specified buffer offset is updated.

/* Reads the next string from the specified buffer, and copies it to the

 * specified pointer. The specified buffer offset is updated.

/* Returns a pointer to the specified offset (in bytes) of the specified buffer.

 * If the specified buffer in NULL, a temporary buffer pointer is returned.

/* Reads a param from the specified buffer. Returns the number of dwords read.

 * If the returned str_param is NULL, the param is numeric and its value is

 * returned in num_param.

 * Otheriwise, the param is a string and its pointer is returned in str_param.

 Extract param name */

 Check param type */

 String param */

 Numeric param */

/* Reads a section header from the specified buffer.

 * Returns the number of dwords read.

/* Reads section params from the specified buffer and prints them to the results

 * buffer. Returns the number of dwords read.

/* Returns the block name that matches the specified block ID,

 * or NULL if not found.

/* Parses the idle check rules and returns the number of characters printed.

 * In case of parsing error, returns 0.

 Offset in results_buf in bytes */

 Go over dumped results */

 Skip rule header */

 Update errors/warnings count */

 Print rule severity */

 Print rule message */

 Print register values */

 Skip reg header */

			/* Skip register names until the required reg_id is

			 * reached.

 Check if end of dump buffer was exceeded */

/* Parses an idle check dump buffer.

 * If result_buf is not NULL, the idle check results are printed to it.

 * In any case, the required results buffer size is assigned to

 * parsed_results_bytes.

 * The parsing status is returned.

 Offset in results_buf in bytes */

 Read global_params section */

 Print global params */

	/* Read idle_chk section

	 * There may be 1 or 2 idle_chk section parameters:

	 * - 1st is "num_rules"

	 * - 2nd is "num_rules_not_dumped" (optional)

 Print FW output */

 Print LSI output */

 Print errors/warnings count */

 Add 1 for string NULL termination */

/* Allocates and fills MCP Trace meta data based on the specified meta data

 * dump buffer.

 * Returns debug status code.

 Free the previous meta before loading a new one. */

 Read first signature */

 Read no. of modules and allocate memory for their pointers */

 Allocate and read all module strings */

 Update number of modules to be released */

 Read second signature */

 Read number of formats and allocate memory for all formats */

 Allocate and read all strings */

 Update number of modules to be released */

/* Parses an MCP trace buffer. If result_buf is not NULL, the MCP Trace results

 * are printed to it. The parsing status is returned.

 * Arguments:

 * trace_buf - MCP trace cyclic buffer

 * trace_buf_size - MCP trace cyclic buffer size in bytes

 * data_offset - offset in bytes of the data to parse in the MCP trace cyclic

 *		 buffer.

 * data_size - size in bytes of data to parse.

 * parsed_buf - destination buffer for parsed data.

 * parsed_results_bytes - size of parsed data in bytes.

 Skip message if its index doesn't exist in the meta data */

 Extract param size (0..3) */

			/* If the param size is zero, there are no other

			 * parameters.

			/* Size is encoded using 2 bits, where 3 is used to

			 * encode 4.

 Print current message to results buffer */

 Add string NULL terminator */

/* Parses an MCP Trace dump buffer.

 * If result_buf is not NULL, the MCP Trace results are printed to it.

 * In any case, the required results buffer size is assigned to

 * parsed_results_bytes.

 * The parsing status is returned.

 Read global_params section */

 Print global params */

 Read trace_data section */

 Prepare trace info */

 Read meta_data section */

 Choose meta data buffer */

 Dump doesn't include meta data */

 Dump includes meta data */

 Allocate meta data memory */

/* Parses a Reg FIFO dump buffer.

 * If result_buf is not NULL, the Reg FIFO results are printed to it.

 * In any case, the required results buffer size is assigned to

 * parsed_results_bytes.

 * The parsing status is returned.

 Read global_params section */

 Print global params */

 Read reg_fifo_data section */

 Decode elements */

 Discover if element belongs to a VF or a PF */

 Find error message */

 Add parsed element to parsed buffer */

 Add 1 for string NULL termination */

	/* Dword12 (dword index 1 and 2) contains bits 32..95 of the

	 * FIFO element.

 Find address data */

 Prepare parsed address data */

 Prepare parsed write data */

 Add parsed element to parsed buffer */

/* Parses an IGU FIFO dump buffer.

 * If result_buf is not NULL, the IGU FIFO results are printed to it.

 * In any case, the required results buffer size is assigned to

 * parsed_results_bytes.

 * The parsing status is returned.

 Read global_params section */

 Print global params */

 Read igu_fifo_data section */

 Decode elements */

 Add 1 for string NULL termination */

 Read global_params section */

 Print global params */

 Read protection_override_data section */

 Decode elements */

 Add 1 for string NULL termination */

/* Parses a FW Asserts dump buffer.

 * If result_buf is not NULL, the FW Asserts results are printed to it.

 * In any case, the required results buffer size is assigned to

 * parsed_results_bytes.

 * The parsing status is returned.

 Read global_params section */

 Print global params */

 Extract params */

 Print data */

 Add 1 for string NULL termination */

**************************** Public Functions *******************************/

 Convert binary data to debug arrays */

 Doesn't do anything, needed for compile time asserts */

 Frees the specified MCP Trace meta data */

 Release modules */

 Release formats */

 Go over registers with a non-zero attention status */

 Go over attention status bits */

			/* Check if bit mask should be advanced (due to unused

			 * bits).

 Check current bit index */

				/* An attention bit with value=1 was found

				 * Find attention name

 Wrapper for unifying the idle_chk and mcp_trace api */

******************************* Feature Meta data section ******************/

 Feature meta data lookup table */

 Generic function for decoding debug feature info */

 Check if feature supports formatting capability */

 Obtain size of formatted output */

	/* Make sure that the allocated size is a multiple of dword

	 * (4 bytes).

 allocate temp text buf */

 Decode feature opcodes to string on temp buf */

	/* Replace the original null character with a '\n' character.

	 * The bytes that were added as a result of the dword alignment are also

	 * padded with '\n' characters.

 Dump printable feature to log */

 Dump binary data as is to the output file */

	/* Free the old dump_buf and point the dump_buf to the newly allocated

	 * and formatted text buffer.

 Generic function for performing the dump of a debug feature. */

	/* Dump_buf was already allocated need to free (this can happen if dump

	 * was called but file was never read).

	 * We can't use the buffer as is since size may have changed.

	/* Get buffer size from hsi, allocate accordingly, and perform the

	 * dump.

	/* If mcp is stuck we get DBG_STATUS_NVRAM_GET_IMAGE_FAILED error.

	 * In this case the buffer holds valid binary data, but we won't able

	 * to parse it (since parsing relies on data in NVRAM which is only

	 * accessible when MFW is responsive). skip the formatting but return

	 * success so that binary data is provided.

 Format output */

 QED_NVM_IMAGE_NVM_META image is not swapped like other images */

/* Defines the amount of bytes allocated for recording the length of debugfs

 * feature buffer.

 Collect idle_chks and grcDump for each hw function */

 First idle_chk */

 Second idle_chk */

 reg_fifo dump */

 igu_fifo dump */

 protection_override dump */

 fw_asserts dump */

		/* Grc dump - must be last because when mcp stuck it will

		 * clutter idle_chk, reg_fifo, ...

 mcp_trace */

 nvm cfg1 */

 nvm default */

 nvm meta */

 nvm mdump */

 Engine specific */

 Engine common */

 Acquire ptt */

 Get dump */

 Feature will not be dumped if it exceeds maximum size */

	/* return max size of phy info and

	 * phy mac_stat multiplied by the number of ports

 Sync ver with debugbus qed code */

	/* Debug values are after init values.

	 * The offset is the first dword of the file.

 Set the hwfn to be 0 as default */

	/* debug features' buffers may be allocated if debug feature was used

	 * but dump wasn't called

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)

 Copyright (c) 2020 Marvell International Ltd. */

/**

 * qed_chain_free() - Free chain DMA memory.

 *

 * @cdev: Main device structure.

 * @chain: Chain to free.

	/* The actual chain size can be larger than the maximal possible value

	 * after rounding up the requested elements number to pages, and after

	 * taking into account the unusuable elements (next-ptr elements).

	 * The size of a "u16" chain can be (U16_MAX + 1) since the chain

	 * size/capacity fields are of u32 type.

	/* Last page's next element should point to the beginning of the

	 * chain.

 Fill the PBL table with the physical address of the page */

 Keep the virtual address of the page */

/**

 * qed_chain_alloc() - Allocate and initialize a chain.

 *

 * @cdev: Main device structure.

 * @chain: Chain to be processed.

 * @params: Chain initialization parameters.

 *

 * Return: 0 on success, negative errno otherwise.

 SPDX-License-Identifier: GPL-2.0-or-later

/* Marvell/Qlogic FastLinQ NIC driver

 *

 * Copyright (C) 2020 Marvell International Ltd.

	/* Having context means that was a dump request after fatal,

	 * so we enable extra debugging while gathering the dump,

	 * just in case

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)

/* QLogic qed NIC Driver

 * Copyright (c) 2015-2017  QLogic Corporation

 * Copyright (c) 2019-2020 Marvell International Ltd.

 The lock is meant to synchronize access to the qid usage */

 Free until hit first uninitialized entry */

 For PF's VFs we maintain the index inside queue-zone in IOV */

/* The internal is only meant to be directly called by PFs initializeing CIDs

 * for their VFs.

 Fill in parameters */

 Fill-in bits related to VFs' queues if information was provided */

 Don't try calculating the absolute indices for VFs */

	/* Calculate the engine-absolute indices of the resources.

	 * This would guarantee they're valid later on.

	 * In some cases [SBs] we already have the right values.

	/* In case of a PF configuring its VF's queues, the stats-id is already

	 * absolute [since there's a single index that's suitable per-VF].

	/* VF-images have provided the qid_usage_idx on their own.

	 * Otherwise, we need to allocate a unique one.

	/* In case of legacy VFs, The CID can be derived from the additional

	 * VF parameters - the VF assumes queue X uses CID X, so we can simply

	 * use the vf_qid for this purpose as well.

	/* Get a unique firmware CID for this queue, in case it's a PF.

	 * VF's don't need a CID as the queue configuration will be done

	 * by PF.

 TPA related fields */

 Software Function ID in hwfn (PFs are 0 - 15, VFs are 16 - 135) */

 Set Rx mode accept flags */

 Set Tx mode accept flags */

 Copy input params to ramrod according to FW struct */

 Update mcast bins for VFs, PF doesn't use this functionality */

 Prepare and send the vport rx_mode change */

 Get SPQ entry */

 Init the rcq, rx bd and rx sge (if valid) producers to 0 */

 Allocate a CID for the queue */

 Provide the caller with a reference to as handler */

 Get SPQ entry */

	/* Cleaning the queue requires the completion to arrive there.

	 * In addition, VFs require the answer to come as eqe to PF.

 Get SPQ entry */

 Provide the caller with the necessary return values */

 Get SPQ entry */

/*******************************************************************************

 * Description:

 *         Calculates crc 32 on a buffer

 *         Note: crc32_length MUST be aligned to 8

 * Return:

crc32_result[0] = 1;*/

 Get SPQ entry */

 explicitly clear out the entire vector */

	/* filter ADD op is explicit set op and it removes

	 *  any existing filters for the vport

 Convert to correct endianity */

 only ADD and REMOVE operations are supported for multi-cast */

 Statistics related code */

 The main vport index is relative first */

 Reduce the statistics baseline */

 zeroes V-PORT specific portion of stats (Port stats remains untouched) */

	/* PORT statistics are not necessarily reset, so we need to

	 * read and create a baseline for future statistics.

	 * Link change stat is maintained by MFW, return its value as is.

 Get SPQ entry */

			/* Since the feature controls only queue-zones,

			 * make sure we have the contexts [rx, xdp, tcs] to

			 * match.

			/* queues might theoretically be >256, but interrupts'

			 * upper-limit guarantes that it would fit in a u8.

 Determine queues &  XDP support */

 Enable VF XDP in case PF guarntees sufficient connections */

 For VF, we start bulletin reading */

 untagged only */

 Update configuration with what's correct regardless of CMT */

	/* In regular scenario, we'd simply need to take input handlers.

	 * But in CMT, we'd have to split the handlers according to the

	 * engine they were configured on. We'd then have to understand

	 * whether RSS is really required, since 2-queues on CMT doesn't

	 * require RSS.

 Start by copying the non-spcific information to the 2nd copy */

 CMT should be round-robin */

 Make sure RSS is actually required */

 Translate protocol params into sp params */

 Prepare the RSS configuration */

 TODO - reference count for module? */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)

/* QLogic qed NIC Driver

 * Copyright (c) 2015-2017  QLogic Corporation

 * Copyright (c) 2019-2020 Marvell International Ltd.

 Invalid values */

 ptt synchronized access */

 Take the free PTT from the list */

 The HW is using DWORDS and we need to translate it to Bytes */

 Update PTT entery in admin window */

 The HW is using DWORDS and the address is in Bytes */

 Verify the address is within the window */

	/* Every pretend undos previous pretends, including

	 * previous port pretend.

 DMAE */

	/* Whether the source is the PCIe or the GRC.

	 * 0- The source is the PCIe

	 * 1- The source is the GRC.

 The destination of the DMA can be: 0-None 1-PCIe 2-GRC 3-None */

	/* Whether to write a completion word to the completion destination:

	 * 0-Do not write a completion word

	 * 1-Write the completion word

 swapping mode 3 - big endian */

 reset source address in next go */

 reset dest address in next go */

 SRC/DST VFID: all 1's - pf, otherwise VF id */

 All the DMAE 'go' registers form an array in internal memory */

 verify address is not NULL */

	/* Copy the command to DMAE - need to do it before every call

	 * for source/dest address no reset.

	 * The first 9 DWs are the command registers, the 10 DW is the

	 * GO register, and the rest are result registers

	 * (which are read only by the client).

 Just make sure no one is in the middle */

		/* to sync the completion_word since we are not

		 * using the volatile keyword for p_completion_word

 for virtual source addresses we use the intermediate buffer. */

 for virtual source addresses we use the intermediate buffer. */

 Let the flow complete w/o any error handling */

 Check if the grc_addr is valid like < MAX_GRC_OFFSET */

 might be zero on last iteration */

 Fan failure cannot be masked by handling of another HW error */

 Fill the bottom half of the allocated memory with a known pattern */

 Save the address itself as the value */

 Zero the top half of the allocated memory */

 Verify that the top half of the allocated memory has the pattern */

 The corresponding address in the bottom half */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)

/*

 * Copyright 2021 Marvell. All rights reserved.

tos*/, 0
 If not resolved, kick-off state machine towards resolution */

 query neighbor until resolved or timeout */

 copy resolved MAC address */

 If not resolved, kick-off state machine towards resolution */

 query neighbor until resolved or timeout */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)

/* QLogic qede NIC Driver

 * Copyright (c) 2015-2017  QLogic Corporation

 * Copyright (c) 2019-2020 Marvell International Ltd.

	/* ptp spinlock is used for protecting the cycle/time counter fields

	 * and, also for serializing the qed PTP API invocations.

/**

 * qede_ptp_adjfreq() - Adjust the frequency of the PTP cycle counter.

 *

 * @info: The PTP clock info structure.

 * @ppb: Parts per billion adjustment from base.

 *

 * Return: Zero on success, negative errno otherwise.

 Re-init the timecounter */

 Enable (or disable) ancillary features of the phc subsystem */

 Read Tx timestamp registers */

 Reschedule to keep checking for a valid TS value */

 Read the PHC. This API is invoked with ptp_lock held. */

 Initialize PTP detection for UDP/IPv4 events */

 Initialize PTP detection for UDP/IPv4 or UDP/IPv6 events */

 Initialize PTP detection L2 events */

 Initialize PTP detection L2, UDP/IPv4 or UDP/IPv6 events */

	/* Cancel PTP work queue. Should be done after the Tx queues are

	 * drained to prevent additional scheduling.

 Disable PTP in HW */

 Configure PTP in HW */

 Init work queue for Tx timestamping */

 Init cyclecounter and timecounter */

 Fill the ptp_clock_info struct and register PTP clock */

 schedule check for Tx timestamp */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)

/* QLogic qede NIC Driver

 * Copyright (c) 2015 QLogic Corporation

 * Copyright (c) 2019-2020 Marvell International Ltd.

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)

/* QLogic qede NIC Driver

 * Copyright (c) 2015-2017  QLogic Corporation

 * Copyright (c) 2019-2020 Marvell International Ltd.

/*********************************

 * Content also used by slowpath *

	/* In case lazy-allocation is allowed, postpone allocation until the

	 * end of the NAPI run. We'd still need to make sure the Rx ring has

	 * sufficient buffers to guarantee an additional Rx interrupt.

	/* Map the entire page as it would be used

	 * for multiple RX buffer segment size mapping.

 Advance PROD and get BD pointer */

 Unmap the data and free skb */

 Unmap the data of the skb frags */

 Free skb */

 Unmap the data and free skb when mapping failed during start_xmit */

 Return prod to its position before this skb was handled */

 Unmap the data of the skb frags */

 Return again prod to its position before this skb was handled */

 Free skb */

 Map skb non-linear frag data for DMA */

 Setup the data pointer of the frag data */

 +2 for 1st BD for headers and 2nd BD for headlen (if required) */

 linear payload would require its own BD */

	/* wmb makes sure that the BDs data is updated before updating the

	 * producer, otherwise FW may read old data from the BDs.

	/* Fence required to flush the write combined buffer, since another

	 * CPU may write to the same doorbell address and data may be lost

	 * due to relaxed order nature of write combined bar.

 We can safely ignore the offset, as it's 0 for XDP */

 Tell compiler that consumer and producer can change */

	/* Need to make the tx_bd_cons update visible to start_xmit()

	 * before checking for netif_tx_queue_stopped().  Without the

	 * memory barrier, there is a small possibility that

	 * start_xmit() will miss it and cause the queue to be stopped

	 * forever.

	 * On the other hand we need an rmb() here to ensure the proper

	 * ordering of bit testing in the following

	 * netif_tx_queue_stopped(txq) call.

		/* Taking tx_lock is needed to prevent reenabling the queue

		 * while it's empty. This could have happen if rx_action() gets

		 * suspended in qede_tx_int() after the condition before

		 * netif_tx_wake_queue(), while tx_action (qede_start_xmit()):

		 *

		 * stops the queue->sees fresh tx_bd_cons->releases the queue->

		 * sends some packets consuming the whole queue again->

		 * stops the queue

 Tell compiler that status block fields can change */

/* This function reuses the buffer(from an offset) from

 * consumer index to producer index in the bd ring

/* In case of allocation failures reuse buffers

 * from consumer index to produce buffers for firmware

 Move to the next segment in the page */

			/* Since we failed to allocate new buffer

			 * current buffer can be used again.

		/* Increment refcount of the page as we don't want

		 * network stack to take the ownership of the page

		 * which can be recycled multiple times by the driver.

 Update producers */

	/* Make sure that the BD and SGE data is updated before updating the

	 * producers since FW might read the BD/SGE right after the producer

	 * is updated.

 Add one frag and update the appropriate fields in the skb */

		/* Incr page ref count to reuse on allocation failure

		 * so that it doesn't get freed while freeing SKB.

 We've consumed the first BD and prepared an SKB */

	/* For smaller frames still need to allocate skb, memcpy

	 * data and benefit in reusing the page segment instead of

	 * un-mapping it.

		/* Incr page ref count to reuse on allocation failure so

		 * that it doesn't get freed while freeing SKB [as its

		 * already mapped there].

 We've consumed the first BD and prepared an SKB */

		/* Consume from ring but do not produce since

		 * this might be used by FW still, it will be re-used

		 * at TPA end.

 This is needed in order to enable forwarding support */

 We still need to handle bd_len_list to consume buffers */

	/* FW can send a single MTU sized packet from gro flow

	 * due to aggregation timeout/last segment etc. which

	 * is not expected to be a gro packet. If a skb has zero

	 * frags then simply push it in the stack as non gso skb.

 Sanity */

 Finalize the SKB */

	/* tcp_gro_complete() will copy NAPI_GRO_CB(skb)->count

	 * to skb_shinfo(skb)->gso_segs

 Return true iff packet is to be passed to stack */

 Recalculate, as XDP might have changed the headers */

 Count number of packets not to be passed to stack */

 We need the replacement buffer before transmit. */

		/* Now if there's a transmission problem, we'd still have to

		 * throw current buffer, as replacement was already allocated.

 Regardless, we've consumed an Rx BD */

 We need the replacement buffer before transmit. */

 We've already used one BD for the SKB. Now take care of the rest */

 We need a replacement buffer for each BD */

		/* Now that we've allocated the replacement buffer,

		 * we can safely consume the next BD and map it to the SKB.

 Get the CQE from the completion ring */

 Process an unlikely slowpath event */

 Handle TPA cqes */

	/* Get the data from the SW ring; Consume it only after it's evident

	 * we wouldn't recycle it.

 Run eBPF program if one is attached */

 If this is an error packet then drop it */

	/* Basic validation passed; Need to prepare an SKB. This would also

	 * guarantee to finally consume the first BD upon success.

	/* In case of Jumbo packet, several PAGE_SIZEd buffers will be pointed

	 * by a single cqe.

 The SKB contains all the data. Now prepare meta-magic */

 SKB is prepared - pass it to stack */

	/* Memory barrier to prevent the CPU from doing speculative reads of CQE

	 * / BD in the while-loop before reading hw_comp_cons. If the CQE is

	 * read before it is written by FW, then FW writes CQE and SB, and then

	 * the CPU reads the hw_comp_cons, it will use an old CQE.

 Loop to complete all indicated BDs */

 Allocate replacement buffers */

 Update producers */

	/* *_has_*_work() reads the status block, thus we need to ensure that

	 * status block indices have been actually read (qed_sb_update_sb_idx)

	 * prior to this check (*_has_*_work) so that we won't write the

	 * "newer" value of the status block to HW (if there was a DMA right

	 * after qede_has_rx_work and if there is no rmb, the memory reading

	 * (qed_sb_update_sb_idx) may be postponed to right before *_ack_sb).

	 * In this case there will never be another interrupt until there is

	 * another update of the status block, while there is still unhandled

	 * work.

/*********************

 * NDO & API related *

 Handle case where we are called by netpoll with a budget of 0 */

 Update and reenable interrupts */

do not update*/);

 Main transmit function */

 Get tx-queue context and netdev index */

 Fill the entry in the SW ring and the BDs in the FW ring */

 Map skb linear data for DMA and set in the first BD */

	/* In case there is IPv6 with extension headers or LSO we need 2nd and

	 * 3rd BDs.

 We need to fill in additional data in second_bd... */

 Fill the parsing flags & params according to the requested offload */

		/* We don't re-calculate IP checksum as it is already done by

		 * the upper stack

		/* Legacy FW had flipped behavior in regard to this bit -

		 * I.e., needed to set to prevent FW from touching encapsulated

		 * packets when it didn't need to.

		/* If the packet is IPv6 with extension header, indicate that

		 * to FW and pass few params, since the device cracker doesn't

		 * support parsing IPv6 with extension header/s.

 @@@TBD - if will not be removed need to check */

		/* Make life easier for FW guys who can't deal with header and

		 * data on same BD. If we need to split, use the second bd...

			/* this marks the BD as one that has no

			 * individual mapping

 Handle fragmented skb */

 special handle for frags inside 2nd and 3rd bds.. */

 map last frags into 4th, 5th .... */

 update the first BD with the actual num BDs */

	/* Advance packet producer only before sending the packet since mapping

	 * of pages may fail.

 'next page' entries are counted in the producer value */

		/* paired memory barrier is in qede_tx_int(), we have to keep

		 * ordering of set_bit() in netif_tx_stop_queue() and read of

		 * fp->bd_tx_cons

 8B udp header + 8B base tunnel header + 32B option length */

		/* Disable offloads for geneve tunnels, as HW can't parse

		 * the geneve header which has option length greater than 32b

		 * and disable offloads for the ports which are not offloaded.

			/* IPIP tunnels are unknown to the device or at least unsupported natively,

			 * offloads for them can't be done trivially, so disable them for such skb.

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)

/* QLogic qede NIC Driver

 * Copyright (c) 2015-2017  QLogic Corporation

 * Copyright (c) 2019-2020 Marvell International Ltd.

 Describe filtering mode needed for this kind of filter */

 Used to compare new/old filters. Return true if IPs match */

 Given an address into ethhdr build a header from tuple info */

 Stringify the tuple for a print into the provided buffer */

 pointer to aRFS packet buffer */

 dma map address of aRFS packet buffer */

 length of aRFS packet buffer */

 tuples to hold from aRFS packet buffer */

 lock for filter list access */

 Currently configured filtering mode */

 Should be called while qede_lock is held */

/* This function waits until all aRFS filters get deleted and freed.

 * On timeout it frees all filters forcefully.

 Something is terribly wrong, free forcefully */

 Filter match */

 Need to validate current RSS config uses valid entries */

 Now that we have the queue-indirection, prepare the handles */

 Proceed only if action actually needs to be performed */

 Verify vlan isn't already configured */

 If interface is down, cache this VLAN ID and return */

	/* Check for the filter limit.

	 * Note - vlan0 has a reserved filter and can be added without

	 * worrying about quota

 vlan0 filter isn't consuming out of our quota */

 Out of quota; Activate accept-any-VLAN mode */

 vlan0 filter isn't consuming out of our quota */

 Configure non-configured vlans */

 We have used all our credits, now enable accept_any_vlan */

 vlan0 filter doesn't consume our VLAN filter's quota */

	/* enable accept_any_vlan mode if we have more VLANs than credits,

	 * or remove accept_any_vlan mode if we've actually removed

	 * a non-configured vlan, and all remaining vlans are truly configured.

 Find whether entry exists */

		/* As interface is already down, we don't have a VPORT

		 * instance to remove vlan filter. So just update vlan list

 Remove vlan */

	/* We have removed a VLAN - try to see if we can

	 * configure non-configured VLAN from the list.

 vlan0 filter isn't consuming out of our quota */

		/* Make sure that we definitely need to reload.

		 * In case of an eBPF attached program, there will be no FW

		 * aggregations, so no need to actually reload.

 If we're called, there was already a bpf reference increment */

	/* Make sure the state doesn't transition while changing the MAC.

	 * Also, all flows accessing the dev_addr field are doing that under

	 * this lock.

 Remove the previous primary mac */

 Ask PF to explicitly update a copy in bulletin board */

 Remove all previously configured MAC filters */

 Check for all multicast @@@TBD resource allocation */

 Add all multicast MAC filters */

 Must be called with qede_lock held */

	/* Remove all previous unicast secondary macs and multicast macs

	 * (configure / leave the primary mac)

 Check for promiscuous */

 Configure all filters regardless, in case promisc is rejected */

 take care of VLAN mode */

		/* It's possible that accept_any_vlan mode is set due to a

		 * previous setting of IFF_PROMISC. If vlan credits are

		 * sufficient, disable accept_any_vlan.

 ports is weakly typed to suit both TCP and UDP ports */

 ports is weakly typed to suit both TCP and UDP ports */

 Validate fields which are set and not accepted by the driver */

	/* We must have Only 4-tuples/l4 port/src ip/dst ip

	 * as an input.

	/* We must have Only 4-tuples/l4 port/src ip/dst ip

	 * as an input.

 Must be called while qede lock is held */

 parse flower attribute and prepare filter */

 Validate profile mode and number of filters */

 parse tc actions and get the vf_id */

 Check location isn't already in use */

 Check if the filtering-mode could support the filter */

 Make sure location is valid and filter isn't already set */

 Translate the flow specification into something fittign our DB */

 Build a minimal header according to the flow */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)

/* QLogic qedr NIC Driver

 * Copyright (c) 2015-2017  QLogic Corporation

 * Copyright (c) 2019-2020 Marvell International Ltd.

 Leftovers from previous error recovery */

 no more events will be added after this */

	/* Avoid race with add_event flow, make sure it finishes before

	 * we start accessing the list and cleaning up the work

 Cannot start qedr while recovering since it wasn't fully stopped */

 Cannot remove qedr while recovering since it wasn't fully stopped */

 If device has experienced recovery it was already removed */

 If a recovery was experienced avoid adding the event */

	/* We don't want the cleanup flow to start while we're allocating and

	 * scheduling the work

 already being destroyed */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)

/* QLogic qede NIC Driver

 * Copyright (c) 2015-2017  QLogic Corporation

 * Copyright (c) 2019-2020 Marvell International Ltd.

 Utilize last protocol index for XDP */

 Enable/Disable Tx switching for PF */

 Check whether this is a qede device */

 Notify qed of the name change */

	/* Must register notifier before pci ops, since we might miss

	 * interface rename after pci probe and netdev registration.

/* -------------------------------------------------------------------------

 * START OF PROBE / REMOVE

 * -------------------------------------------------------------------------

	/* As ethtool doesn't have the ability to show WoL behavior as

	 * 'default', if device supports it declare it's enabled.

 user-changeble features */

 MTU range: 46 - 9600 */

 Set network device HW mac */

/* This function converts from 32b param to two params of level and module

 * Input 32b decoding:

 * b31 - enable all NOTICE prints. NOTICE prints are for deviation from the

 * 'happy' flow, e.g. memory allocation failed.

 * b30 - enable all INFO prints. INFO prints are for major steps in the flow

 * and provide important parameters.

 * b29-b0 - per-module bitmap, where each bit enables VERBOSE prints of that

 * module. VERBOSE prints are for tracking the specific flow in low level.

 *

 * Notice that the level should be that of the lowest required logs.

			/* Handle mem alloc failure case where qede_init_fp

			 * didn't register xdp_rxq_info yet.

			 * Implicit only (fp->type & QEDE_FASTPATH_RX)

	/* Allocate the FP elements for Rx queues followed by combined and then

	 * the Tx. This ordering should be maintained so that the respective

	 * queues (Rx or Tx) will be together in the fastpath array and the

	 * associated ids will be sequential.

/* The qede lock is used to protect driver state change and driver flows that

 * are not reentrant.

/* This version of the lock should be used when acquiring the RTNL lock is also

 * needed in addition to the internal qede lock.

	/* Disable execution of this deferred work once

	 * qede removal is in progress, this stop any future

	 * scheduling of sp_task.

	/* The locking scheme depends on the specific flag:

	 * In case of QEDE_SP_RECOVERY, acquiring the RTNL lock is required to

	 * ensure that ongoing flows are ended and new ones are not started.

	 * In other cases - only the internal qede lock should be acquired.

		/* SRIOV must be disabled outside the lock to avoid a deadlock.

		 * The recovery of the active VFs is currently not supported.

		/* SRIOV must be disabled outside the lock to avoid a deadlock.

		 * The recovery of the active VFs is currently not supported.

 64 rx + 64 tx + 64 XDP */

 1 rx + 1 xdp + max tx cos */

	/* Same for VFs - make sure they'll have sufficient connections

	 * to support XDP Tx queues.

 Start the Slowpath-process */

 Learn information crucial for qede to progress */

		/* Prepare the lock prior to the registration of the netdev,

		 * as once it's registered we might reach flows requiring it

		 * [it's even possible to reach a flow needing it directly

		 * from there, although it's unlikely].

 PTP not supported on VFs */

 Use global ops since we've freed edev */

	/* Since this can happen out-of-sync with other flows,

	 * don't release the netdevice until after slowpath stop

	 * has been called to guarantee various other contexts

	 * [e.g., QED register callbacks] won't break anything when

	 * accessing the netdevice.

/* -------------------------------------------------------------------------

 * START OF LOAD / UNLOAD

 * -------------------------------------------------------------------------

 Setup queues according to possible resources*/

 Managed to request interrupts for our queues */

 This function allocates fast-path status block memory */

 Free rx buffers */

 Free the parallel SW ring */

 Free the real RQ ring used by FW */

 This function allocates all memory needed per Rx queue */

 Make sure that the headroom and  payload fit in a single page */

	/* Segment size to split a page in multiple equal parts,

	 * unless XDP is used in which case we'd use the entire page.

 Allocate the parallel driver ring for Rx buffers */

 Allocate FW Rx ring  */

 Allocate FW completion ring */

 Allocate buffers for the Rx ring */

 Free the parallel SW ring */

 Free the real RQ ring used by FW */

 This function allocates all memory needed per Tx queue */

 Allocate the parallel driver ring for Tx buffers */

 This function frees all memory of a single fp */

/* This function allocates all memory needed for a single fp (i.e. an entity

 * which contains status block, one rx queue and/or multiple per-TC tx queues.

 This function allocates all qede memory at NIC load. */

 This function inits fp content and resets the SB, RXQ and TXQ structures */

 Determine how to map buffers for this queue */

 Driver have no error path from here */

 Add NAPI objects */

 Sanitize number of interrupts == number of prepared RSS queues */

 Learn Interrupt configuration */

 qed should learn receive the RSS ids and callbacks */

 FW finished processing, wait for HW to transmit all tx packets */

 delete doorbell from doorbell recovery mechanism */

 Disable the vport */

 Flush Tx queues. If needed, request drain from MCP */

 Stop all Queues in reverse order */

 Stop the Tx Queue(s) */

 Stop the Rx Queue */

 Stop the XDP forwarding queue */

 Stop the vport */

	/* Let the XDP queue share the queue-zone with one of the regular txq.

	 * We don't really care about its coalescing.

 Determine the FW consumer address associated */

 Prepare the doorbell parameters */

 register doorbell with doorbell recovery mechanism */

 Use the return parameters */

 Prepare and send the vport enable */

 Close OS Tx */

 Reset the link */

 Release the interrupts */

 Program un-configured VLANs */

 Ask for link-up using current configuration */

/* 'func' should be able to run between unload and reload assuming interface

 * is actually running, or afterwards in case it's currently DOWN.

	/* Since qede_lock is held, internal state wouldn't change even

	 * if netdev state would start transitioning. Check whether current

	 * internal configuration indicates device is up, then reload.

 Since no one is going to do it for us, re-configure */

 called with rtnl_lock */

	/* No need to acquire first the qede_lock since is done by qede_sp_task

	 * before calling this function.

 Get a call trace of the flow that led to the error */

 Prevent HW attentions from being reasserted */

 make this error as recoverable and start recovery*/

	/* Fan failure cannot be masked by handling of another HW error or by a

	 * concurrent recovery process.

 Copy the first two UC macs */

	/* Fill information regarding queues; Should be done under the qede

	 * lock to guarantee those don't change beneath our feet.

			/* This one is a bit tricky; Firmware might stop

			 * placing packets if ring is not yet full.

			 * Give an approximation.

/**

 * qede_io_error_detected(): Called when PCI error is detected

 *

 * @pdev: Pointer to PCI device

 * @state: The current pci connection state

 *

 *Return: pci_ers_result_t.

 *

 * This function is called after a PCI bus error affecting

 * this device has been detected.

 PF handles the recovery of its VFs */

 Close OS Tx */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)

/* QLogic qede NIC Driver

 * Copyright (c) 2015-2017  QLogic Corporation

 * Copyright (c) 2019-2020 Marvell International Ltd.

 MFW supports SmartAN */

 Forced speed capabilities maps */

 Ethtool callbacks */

 Account for queue statistics */

 Account for non-queue statistics */

 Need to protect the access to the fastpath array */

 Account for the Regular Tx statistics */

 Account for the Regular Rx statistics */

 Account for XDP statistics [if needed] */

 can only change RECOVER_ON_ERROR flag */

 forced speed */

 Need to actually change configuration */

 Toggle the link */

			/* All TX queues of given fastpath uses same

			 * coalescing value, so no need to iterate over

			 * all TCs, TC0 txq should suffice.

			/* All TX queues of given fastpath uses same

			 * coalescing value, so no need to iterate over

			 * all TCs, TC0 txq should suffice.

 Validate legality of configuration */

 Change ring size and re-load */

 Netdevice NDOs */

 Set the mtu field and re-start the interface if needed */

 We don't support `other' channels */

 Check if there was a change in the active parameters */

 We need the number of queues to be divisible between the hwfns */

 Set number of queues and reload if necessary */

 Reset the indirection table if rx queue count is updated */

 cycle on/off once per second */

 For TCP only 4-tuple hash is supported */

 For UDP either 2-tuple hash or 4-tuple hash is supported */

 For UDP either 2-tuple hash or 4-tuple hash is supported */

 For IP only 2-tuple hash is supported */

 RSS is not supported for these protocols */

 No action is needed if there is no change in the rss capability */

 Update internal configuration */

 Re-configure if possible */

 This function enables the interrupt generation and the NAPI on the device */

 Update and reenable interrupts */

 This function disables the NAPI and the interrupt generation on the device */

 Disable interrupts */

 Fill the entry in the SW ring and the BDs in the FW ring */

 Map skb linear data for DMA and set in the first BD */

 update the first BD with the actual num BDs */

 'next page' entries are counted in the producer value */

	/* wmb makes sure that the BDs data is updated before updating the

	 * producer, otherwise FW may read old data from the BDs.

	/* The packet is expected to receive on rx-queue 0 even though RSS is

	 * enabled. This is because the queue 0 is configured as the default

	 * queue and that the loopback traffic is not IP.

 Get the CQE from the completion ring */

 Get the data from the SW ring */

 Bring up the link in Loopback mode */

 Wait for loopback configuration to apply */

	/* Setting max packet size to 1.5K to avoid data being split over

	 * multiple BDs in cases where MTU > PAGE_SIZE.

 Bring up the link in Normal mode */

 Wait for loopback configuration to apply */

 Read first 4 bytes to find the sfp type */

 SFP, SFP+, SFP-28 */

 QSFP */

 QSFP+ */

 QSFP-28 */

 Read A0 section */

 Limit transfer size to the A0 section boundary */

 Read A2 section */

 Limit transfer size to the A2 section boundary */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * QLogic qlcnic NIC Driver

 * Copyright (c) 2009-2013 QLogic Corporation

 check for data size of multiple of 16 and 16 byte alignment */

 DMA register base address */

 DMA register offsets w.r.t base address */

 Wait for DMA to complete */

 Check if DMA engine is available */

 Create DMA descriptor */

	/* dma_desc_cmd  0:15  = 0

	 * dma_desc_cmd 16:19  = mem->dma_desc_cmd 0:3

	 * dma_desc_cmd 20:23  = pci function number

	 * dma_desc_cmd 24:31  = mem->dma_desc_cmd 8:15

 Collect memory dump using multiple DMA operations if required */

 Write DMA descriptor to MS memory*/

 Return if we don't have firmware dump template header */

 Calculate the size for dump data area only */

 Find the handler for this entry */

 Collect dump for this entry */

 Send a udev event to notify availability of FW dump */

	/* For special adapters (with 0x8830 device ID), where iSCSI firmware

	 * dump needs to be captured as part of regular firmware dump

	 * collection process, firmware exports it's capability through

	 * capability registers

		/* Once we have minidump template with extended iSCSI dump

		 * capability, update the minidump capture mask to 0x1f as

		 * per FW requirement

 SPDX-License-Identifier: GPL-2.0-only

/*

 * QLogic qlcnic NIC Driver

 * Copyright (c)  2009-2013 QLogic Corporation

 1st local, 2nd operational 3rd remote */

 of Link/ port BW */

 always prio_link */

 % of link bandwidth */

 % of BWG's bandwidth */

 0 - local, 1 - operational, 2 - remote */

 Only for CEE (-1) */

 8 priorities for PGs */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * QLogic qlcnic NIC Driver

 * Copyright (c) 2009-2013 QLogic Corporation

 owner bits of status_desc */

/* Status descriptor:

   0-3 port, 4-7 status, 8-11 type, 12-27 total_length

   28-43 reference_handle, 44-47 protocol, 48-52 pkt_offset

   53-55 desc_cnt, 56-57 owner, 58-63 opcode

 opcode field in status_desc */

 for status field in status_desc */

 VXLAN header size = 8 */

		/* Copy inner and outer headers in Tx descriptor(s)

		 * If total_hdr_len > cmd_desc_type0, use multiple

		 * descriptors

		/* Make sure updated tx_ring->producer is visible

		 * for qlcnic_tx_avail()

 Prepare first 16 bits of byte offset 16 of Tx descriptor */

 outer IP header's size in 32bit words size*/

 outer IP header offset */

		/* For LSO, we need to copy the MAC/IP/TCP headers into

 Only in case of TSO on vlan device */

 Create a TSO vlan header template for firmware */

	/* 14 frags supported for normal packet and

	 * 32 frags supported for TSO packet

 move to next desc.*/

 Check if it is a VXLAN packet */

 Ensure writes are complete before HW fetches Tx descriptors */

		/* Do not advertise Link up to the stack if device

		 * is in loopback mode

 make a rcv descriptor  */

	/*

	 * If everything is freed up to consumer then check if the ring is full

	 * If the ring is full then check if more needs to be freed and

	 * schedule the call back again.

	 *

	 * This happens when there are 2 CPUs. One could be freeing and the

	 * other filling it. If the ring is full when we get out of here and

	 * the card has already interrupted the host then the host can miss the

	 * interrupt.

	 *

	 * There is still a possible race condition and the host could miss an

	 * interrupt. The card has to take care of this.

 Check if we need a repoll */

 As qlcnic_process_cmd_ring() returned 0, we need a repoll*/

 Outer vlan tag. Packet should follow non-vlan path */

 make a rcv descriptor  */

 Reset the descriptor */

 tx ring count = 1 */

 Check if we need a repoll */

 tx ring count = 1 */

 Check if we need a repoll */

 need a repoll */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * QLogic qlcnic NIC Driver

 * Copyright (c) 2009-2013 QLogic Corporation

		/*

		 * Now go through all of them, set reference handles

		 * and put them in the queues.

/*

 * Utility to translate from internal Phantom CRB address

 * to external PCI CRB address.

 reset abyte_cnt and dummy_byte_cnt */

 Halt all the indiviual PEGs and other blocks */

 disable all I2Q */

 disable all niu interrupts */

 disable xge rx/tx */

 disable xg1 rx/tx */

 disable sideband mac */

 disable ap0 mac */

 disable ap1 mac */

 halt sre */

 halt epg */

 halt timers */

 halt pegs */

 big hammer don't reset CAM block on reset */

 Init HW CRB block */

 skipping cold reboot MAGIC */

 do not reset PCI */

 core clock */

 MN clock */

 MS clock */

 skip the function enable register */

 After writing this register, HW needs time for CRB */

 to quiet down (else crb_window returns 0xffffffff) */

 Initialize protocol process engine */

 0-4:-signature,  4-8:-fw version */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * QLogic qlcnic NIC Driver

 * Copyright (c) 2009-2013 QLogic Corporation

 On configuring VF flood bit, PFD will receive traffic from all VFs */

	/* After disabling SRIOV re-init the driver in default mode

	   configure opmode based on op_mode of function

 Return number of vfs enabled */

	/* For 84xx adapter in case of PVID , PFD should send vlan mode as

	 * QLC_NO_VLAN_MODE to VFD which is zero in mailbox response

 SPDX-License-Identifier: GPL-2.0-only

/*

 * QLogic qlcnic NIC Driver

 * Copyright (c) 2009-2013 QLogic Corporation

 83xx Module type */

 10GBase-LRM */

 10GBase-LR */

 10GBase-SR */

#define QLC_83XX_MODULE_DA_10GE_PASSIVE_CP	0x4 /* 10GE passive

						     * copper(compliant)

#define QLC_83XX_MODULE_DA_10GE_ACTIVE_CP	0x5 /* 10GE active limiting

						     * copper(compliant)

#define QLC_83XX_MODULE_DA_10GE_LEGACY_CP	0x6 /* 10GE passive copper

						     * (legacy, best effort)

 1000Base-SX */

 1000Base-LX */

 1000Base-CX */

 1000Base-T*/

#define QLC_83XX_MODULE_DA_1GE_PASSIVE_CP	0xb /* 1GE passive copper

						     * (legacy, best effort)

 Unknown module type */

 Port types */

 Global Reset */

 Wildcard */

 Informant */

 Host MBX ctrl */

 FW MBX ctrl */

 BOOT LOADER ADDRESS REG */

 BOOT LOADER SIZE REG */

 FW IMAGE ADDR REG */

 MBX intr enable */

 Default Intr mask */

 Default Interrupt ID */

 QLC_83XX_IDC_MAJ_VERSION */

 QLC_83XX_IDC_DEV_STATE */

 QLC_83XX_IDC_DRV_PRESENCE */

 QLC_83XX_IDC_DRV_ACK */

 QLC_83XX_IDC_CTRL */

 QLC_83XX_IDC_DRV_AUDIT */

 QLC_83XX_IDC_MIN_VERSION */

 QLC_83XX_RECOVER_DRV_LOCK */

 QLC_83XX_IDC_PF_0 */

 QLC_83XX_IDC_PF_1 */

 QLC_83XX_IDC_PF_2 */

 QLC_83XX_IDC_PF_3 */

 QLC_83XX_IDC_PF_4 */

 QLC_83XX_IDC_PF_5 */

 QLC_83XX_IDC_PF_6 */

 QLC_83XX_IDC_PF_7 */

 QLC_83XX_IDC_PF_8 */

 QLC_83XX_IDC_PF_9 */

 QLC_83XX_IDC_PF_10 */

 QLC_83XX_IDC_PF_11 */

 QLC_83XX_IDC_PF_12 */

 QLC_83XX_IDC_PF_13 */

 QLC_83XX_IDC_PF_14 */

 QLC_83XX_IDC_PF_15 */

 QLC_83XX_IDC_DEV_PARTITION_INFO_1 */

 QLC_83XX_IDC_DEV_PARTITION_INFO_2 */

 QLC_83XX_DRV_OP_MODE */

 QLC_83XX_VNIC_STATE */

 QLC_83XX_DRV_LOCK */

 QLC_83XX_DRV_UNLOCK */

 QLC_83XX_DRV_LOCK_ID */

 QLC_83XX_ASIC_TEMP */

 PEG_HALT_STAT1 */

 PEG_HALT_STAT2 */

 FW_HEARTBEAT */

 FLASH LOCK_ID */

 FW_CAPABILITIES */

 Driver active, DRV_REG0 */

 Device state, DRV_REG1 */

 Driver state, DRV_REG2 */

 Driver scratch, DRV_REG3 */

 Device partition info, DRV_REG4 */

 Driver IDC ver, DRV_REG5 */

 FW_VER_MAJOR */

 FW_VER_MINOR */

 FW_VER_SUB */

 NPAR STATE */

 FW_IMG_VALID */

 CMD_PEG_STATE */

 RCV_PEG_STATE */

 ASIC TEMP */

 FW API */

 DRV OP MODE */

 FLASH LOCK */

 FLASH UNLOCK */

 MSI-X enablement failed, use legacy interrupt */

 account for AEN interrupt MSI-X based interrupts */

 setup interrupt mapping table for fw */

	/* Mailbox in MSI-x mode and Legacy Interrupt share the same

	 * source register. We could be here before contexts are created

	 * and sds_ring->crb_intr_mask has not been initialized, calculate

	 * BAR offset for Interrupt Source Register

 The barrier is required to ensure writes to the registers */

 clear the interrupt trigger control register */

 Enable mailbox interrupt */

 write the function number to register */

 Determine function privilege level */

 set up status rings, mbx 2-81 */

 send the mailbox command */

 status descriptor ring */

 set mailbox hdr and capabilities */

 set up status rings, mbx 8-57/87 */

 set up receive rings, mbx 88-111/135 */

 Jumbo ring */

 send the mailbox command */

 Receive descriptor ring */

 Standard ring */

 Jumbo ring */

 status descriptor ring */

 Reset host resources */

 setup mailbox inbox registerss */

 send the mailbox command*/

 Get LED configuration */

 Set LED Configuration */

 Restoring default LED configuration */

 Poll for link up event before running traffic */

 Check if port is already in loopback mode */

 Wait for Link and IDC Completion AEN */

 Wait for Link and IDC Completion AEN */

	/*

	 * Adapter needs IP address in network byte order.

	 * But hardware mailbox registers go through writel(), hence IP address

	 * gets swapped on big endian architecture.

	 * To negate swapping of writel() on big endian architecture

	 * use swab32(value).

	/*

	 * RSS request:

	 * bits 3-0: Rsvd

	 *      5-4: hash_type_ipv4

	 *	7-6: hash_type_ipv6

	 *	  8: enable

	 *        9: use indirection table

	 *    16-31: indirection table mask

 link speed */

 Check if data is spread across multiple sectors */

 Multi sector read */

 This write is needed once for each sector */

 Single sector read */

 First DWORD write */

 Second to N-1 DWORD writes */

 Last DWORD write */

 Operation failed, clear error bit */

 Check if recovery need to be performed by the calling function */

 Force release the lock */

 Clear recovery bits */

 Force exit from while loop after few attempts */

 Check alignment */

 Status check failure */

 Get port configuration info */

 Get Link Status related info */

 hard code until there is a way to get it from flash */

 83xx devices do not support Half duplex */

 force speed */

 fill in MAC tx counters */

 skip 24 bytes of reserved area */

 fill in MAC rx counters */

 skip 24 bytes of reserved area */

 fill in MAC rx frame stats */

 fill in eSwitch stats */

 skip 8 bytes of reserved data */

 skip 8 bytes containing RE1FBQ error data */

 skip 8 bytes of reserved data */

 Get Tx stats */

 Get MAC stats */

 Get Rx stats */

 In MB */

			/* Backward compatibility for existing

			 * flash definitions

 Back channel specific operations bits */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * QLogic qlcnic NIC Driver

 * Copyright (c) 2009-2013 QLogic Corporation

 compute and set default and max tx/sds rings */

		/* After adapter reset PF driver may take some time to

		 * respond to VF's request. Retry request till maximum retries.

	/* configure unicast MAC address, if there is not sufficient space

	 * to store all the unicast addresses then enable promiscuous mode

 Skip the context reset and check if FW is hung */

	/* Check if number of resets exceed the threshold.

	 * If it exceeds the threshold just fail the VF.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * QLogic qlcnic NIC Driver

 * Copyright (c) 2009-2013 QLogic Corporation

 read which mode */

 read which mode */

 Marker btw regs and TX ring count */

 No. of TX ring */

 No. of RX ring */

 No. of SDS ring */

 get flow control settings */

 read mode */

 set flow control */

 set autoneg */

 Retrieve MAC statistics from firmware */

/*

 * Set the coalescing parameters. Currently only normal is supported.

 * If rx_coalesce_usecs == 0 or rx_max_coalesced_frames == 0 then set the

 * firmware coalescing to default.

	/*

	* Return Error if unsupported values or

	* unsupported parameters are set.

 Copy template header first */

 Copy captured dump data */

 Free dump area once data has been captured */

 Store new capture mask in template header as well*/

 SPDX-License-Identifier: GPL-2.0-only

/*

 * QLogic qlcnic NIC Driver

 * Copyright (c) 2009-2013 QLogic Corporation

 Reset template definitions */

 EPORT control registers */

 Template header */

 Command entry header. */

 Generic poll command */

 Read modify write command */

 Generic command with 2 DWORD */

 Generic command with 4 DWORD */

 Clear graceful reset bit */

/**

 * qlcnic_83xx_idc_check_reset_ack_reg

 *

 * @adapter: adapter structure

 *

 * Check ACK wait limit and clear the functions which failed to ACK

 *

 * Return 0 if all functions have acknowledged the reset request.

 Clear functions which failed to ACK */

/**

 * qlcnic_83xx_idc_tx_soft_reset

 *

 * @adapter: adapter structure

 *

 * Handle context deletion and recreation request from transmit routine

 *

 * Returns -EBUSY  or Success (0)

 *

/**

 * qlcnic_83xx_idc_detach_driver

 *

 * @adapter: adapter structure

 * Detach net interface, stop TX and cleanup resources before the HW reset.

 * Returns: None

 *

 Disable mailbox interrupt */

/**

 * qlcnic_83xx_idc_attach_driver

 *

 * @adapter: adapter structure

 *

 * Re-attach and re-enable net interface

 * Returns: None

 *

/**

 * qlcnic_83xx_idc_find_reset_owner_id

 *

 * @adapter: adapter structure

 *

 * NIC gets precedence over ISCSI and ISCSI has precedence over FCOE.

 * Within the same class, function with lowest PCI ID assumes ownership

 *

 * Returns: reset owner id or failure indication (-EIO)

 *

/**

 * qlcnic_83xx_idc_ready_state_entry

 *

 * @adapter: adapter structure

 *

 * Perform ready state initialization, this routine will get invoked only

 * once from READY state.

 *

 * Returns: Error code or Success(0)

 *

 Re-attach the device if required */

/**

 * qlcnic_83xx_idc_vnic_pf_entry

 *

 * @adapter: adapter structure

 *

 * Ensure vNIC mode privileged function starts only after vNIC mode is

 * enabled by management function.

 * If vNIC mode is ready, start initialization.

 *

 * Returns: -EIO or 0

 *

 Privileged function waits till mgmt function enables VNIC mode */

 Perform one time initialization from ready state */

			/* If the previous state is UNKNOWN, device will be

/**

 * qlcnic_83xx_idc_cold_state_handler

 *

 * @adapter: adapter structure

 *

 * If HW is up and running device will enter READY state.

 * If firmware image from host needs to be loaded, device is

 * forced to start with the file firmware image.

 *

 * Returns: Error code or Success(0)

 *

/**

 * qlcnic_83xx_idc_init_state

 *

 * @adapter: adapter structure

 *

 * Reset owner will restart the device from this state.

 * Device will enter failed state if it remains

 * in this state for more than DEV_INIT time limit.

 *

 * Returns: Error code or Success(0)

 *

/**

 * qlcnic_83xx_idc_ready_state

 *

 * @adapter: adapter structure

 *

 * Perform IDC protocol specicifed actions after monitoring device state and

 * events.

 *

 * Returns: Error code or Success(0)

 *

 Perform NIC configuration based ready state entry actions */

 Move to need reset state and prepare for reset */

 Check for soft reset request */

 Move to need quiesce state if requested */

/**

 * qlcnic_83xx_idc_need_reset_state

 *

 * @adapter: adapter structure

 *

 * Device will remain in this state until:

 *	Reset request ACK's are received from all the functions

 *	Wait time exceeds max time limit

 *

 * Returns: Error code or Success(0)

 *

 Check for ACK from other functions */

 Transit to INIT state and restart the HW */

/**

 * qlcnic_83xx_idc_poll_dev_state

 *

 * @work: kernel work queue structure used to schedule the function

 *

 * Poll device state periodically and perform state specific

 * actions defined by Inter Driver Communication (IDC) protocol.

 *

 * Returns: None

 *

 Re-schedule the function */

 Check if reset recovery is disabled */

 Propagate do not reset request to other functions */

 Clear driver lock register */

 First to load function should cold boot the device */

 Check if reset recovery is enabled */

 Clear driver presence bit */

 alignment check */

 16 byte write to MS memory */

	/* FW image in file is in little endian, swap the data to nullify

	 * the effect of writel() operation on big endian platform.

 alignment check */

 Reset bits 29 to 31 */

 Copy template header from flash */

 Copy rest of the template */

 Get Stop, Start and Init command offsets */

 Read Write HW register command */

 Read Modify Write HW register command */

 Write HW register command */

 Read and Write instruction */

 Poll HW register command */

 Poll and write HW register command */

 Read Modify Write register command */

 Read and poll register command */

/**

* qlcnic_83xx_exec_template_cmd

*

* @p_dev: adapter structure

* @p_buff: Poiter to instruction template

*

* Template provides instructions to stop, restart and initalize firmware.

* These instructions are abstracted as a series of read, write and

* poll operations on hardware registers. Register information and operation

* specifics are not exposed to the driver. Driver reads the template from

* flash and executes the instructions located at pre-defined offsets.

*

* Returns: None

 POST FW related definations*/

 POST Timeout values in milliseconds */

 POST result values */

 Set timeout values with extra 2 seconds of buffer */

 clear QLC_83XX_POST_SIGNATURE_REG register */

 Set POST mode */

 Collect FW register dump if required */

 Check if POST needs to be run */

 No need to run POST in next reset sequence */

 Again reset the adapter to load regular firmware  */

 Boot either flash image or firmware image from host file system */

	/* eSwitch capability indicates vNIC mode.

	 * vNIC and SRIOV are mutually exclusive operational modes.

	 * If SR-IOV capability is detected, SR-IOV physical function

	 * will get initialized in default mode.

	 * SR-IOV virtual function initialization follows a

	 * different code path and opmode.

	 * SRIOV mode has precedence over vNIC mode.

 compute and set drv sds rings */

 Check if POST needs to be run */

 Configure default, SR-IOV or Virtual NIC mode of operation */

 Perform operating mode specific initialization */

 Periodically monitor device status */

	/* Mark the previous IDC state as NEED_RESET so

	 * that state_entry() will perform the reattachment

	 * and bringup the device

 SPDX-License-Identifier: GPL-2.0-only

/*

 * QLogic qlcnic NIC Driver

 * Copyright (c) 2009-2013 QLogic Corporation

 0: PCI */

 1: PCIE */

 2: MN */

 3: */

 4: P2NR1 */

 5: SRE   */

 6: NIU   */

 7: QM    */

 8: SQM0  */

 9: SQM1*/

 10: SQM2*/

 11: SQM3*/

 12: I2Q */

 13: TMR */

 14: ROMUSB */

 15: PEG4 */

 16: XDMA */

 17: PEG0 */

 18: PEG1 */

 19: PEG2 */

 20: PEG3 */

 21: P2ND */

 22: P2NI */

 23: */

 24: */

 25: */

 26: */

 27: */

 28: */

 29: MS */

 30: P2NR2 */

 31: EPG */

 32: PCI */

 33: PCIE */

 34: CAM */

 35: */

 36: */

 37: */

 38: */

 39: */

 40: TMR */

 41: P2NR3 */

 42: RPMX1 */

 43: RPMX2 */

 44: RPMX3 */

 45: RPMX4 */

 46: RPMX5 */

 47: RPMX6 */

 48: RPMX7 */

 49: XDMA */

 50: I2Q */

 51: ROMUSB */

 52: */

 53: RPMX0 */

 54: RPMX8 */

 55: RPMX9 */

 56: OCM0 */

 57: CRYPTO */

 58: SMB */

 59: I2C0 */

 60: I2C1 */

 61: LPC */

 62: P2NC */

 63: P2NR0 */

/*

 * top 12 bits of crb internal address (hub, agent)

  PCI Windowing for DDR regions.  */

 Delete MAC from the existing list */

 look up if already exists */

	/* configure unicast MAC address, if there is not sufficient space

	 * to store all the unicast addresses then enable promiscuous mode

 Send the interrupt coalescing parameter set by ethtool to the card. */

	/*

	 * RSS request:

	 * bits 3-0: hash_method

	 *      5-4: hash_type_ipv4

	 *	7-6: hash_type_ipv6

	 *	  8: enable

	 *        9: use indirection table

	 *       10: type-c rss

	 *	 11: udp rss

	 *    47-12: reserved

	 *    62-48: indirection table mask

	 *	 63: feature flag

/*

 * qlcnic_change_mtu - Change the Maximum Transfer Unit

 * @returns 0 on success, negative on failure

/*

 * Changes the CRB window to the specified window.

 /* Returns < 0 if off is not valid,

 *	 1 if window access is needed. 'off' is set to offset from

 *	   CRB space in 128M pci map

 *	 0 if no window access is needed. 'off' is set to 2M addr

 * In: 'off' is offset from base in 128M pci map

	/*

	 * Try direct map

	/*

	 * Not in direct map, use crb window

/*

 * In: 'off' is offset from CRB space in 128M pci map

 * Out: 'off' is 2M pci map addr

 * side effect: lock crb window

 indirect access */

 indirect access */

 read back to flush */

 read */

 write */

 Set window to 0 */

 Set MS memory control data for different adapters */

 Only 64-bit aligned access */

 This is the modify part of read-modify-write */

 This is the write part of read-modify-write */

 Only 64-bit aligned access */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * QLogic qlcnic NIC Driver

 * Copyright (c) 2009-2013 QLogic Corporation

/**

 * qlcnic_83xx_init_mgmt_vnic

 *

 * @adapter: adapter structure

 * Management virtual NIC sets the operational mode of other vNIC's and

 * configures embedded switch (ESWITCH).

 * Returns: Success(0) or error code.

 *

/**

 * qlcnic_83xx_config_vnic_opmode

 *

 * @adapter: adapter structure

 * Identify virtual NIC operational modes.

 *

 * Returns: Success(0) or error code.

 *

 SPDX-License-Identifier: GPL-2.0-only

/*

 * QLogic qlcnic NIC Driver

 * Copyright (c) 2009-2013 QLogic Corporation

 Allocate mailbox registers */

 Free up mailbox registers */

 give atleast 1ms for firmware to respond */

 Acquire semaphore before accessing CRB */

 Release semaphore */

 reset host resources */

 cmd desc ring */

 Allow dma queues to drain after context reset */

 Get info of a NIC partition */

 Configure a NIC partition */

 Get PCI Info of a partition */

 Configure eSwitch for port mirroring */

 This routine will retrieve the MAC statistics from firmware */

/* Configure eSwitch port

op_mode = 0 for setting default port behavior

op_mode = 1 for setting  vlan id

op_mode = 2 for deleting vlan id

op_type = 0 for vlan_id

op_type = 1 for port vlan_id

 SPDX-License-Identifier: GPL-2.0-only

/*

 * QLogic qlcnic NIC Driver

 * Copyright (c) 2009-2013 QLogic Corporation

 display millidegree celcius */

 hwmon-sysfs attributes */

 Skip hwmon registration for a VF device */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * QLogic qlcnic NIC Driver

 * Copyright (c) 2009-2013 QLogic Corporation

  PCI Device ID Table  */

 PEG_HALT_STAT1 */

 PEG_HALT_STAT2 */

 FW_HEARTBEAT */

 LOCK ID */

 FW_CAPABILITIES */

 drv active */

 dev state */

 drv state */

 drv scratch */

 dev partition info */

 drv idc ver */

 fw version major */

 fw version minor */

 fw version sub */

 npar state */

 FW_IMG_VALID */

 CMD_PEG_STATE */

 RCV_PEG_STATE */

 ASIC TEMP */

 FW api */

 drv op mode */

 flash lock */

 flash unlock */

 set station address */

 83xx adapter does not have max_tx_rings intialized in probe */

 83xx adapter does not have max_sds_rings intialized in probe */

 Set rings to 0 so we can restore original TSS/RSS count */

 Distribute vectors equally */

	/* Update eSwitch status for adapters without per port eSwitch

	 * configuration capability

 Determine FW API version */

 Find PCI function number */

 Determine function privilege level */

 remap phys address */

 Set privilege level for other functions */

 Set the NPAR config data after FW reset */

 Initialize interrupt coalesce parameters */

 Usage: During suspend and firmware recovery module */

 clear stats */

 Reset context in hardware only */

 encapsulation Tx offload supported by Adapter */

 MTU range: 68 - 9600 */

 Reset firmware API lock */

 MAC + ": " + name */

 compute and set default and max tx/sds rings */

/*

 * qlcnic_close - Disables a network interface entry point

 check interrupt state machine, to be sure */

 read twice to ensure write is flushed */

 clear interrupt */

 Grab api lock, before checking state */

 Dont grab rtnl lock during Quiscent mode */

 Dont ack if this instance is the reset owner */

Transit NPAR state to NON Operational */

 Transit to NPAR READY state from NPAR NOT READY state */

	/* Check if we need to update real_num_{tx|rx}_queues because

	 * qlcnic_setup_intr() may change Tx/Rx rings size

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2003 - 2009 NetXen, Inc.

 * Copyright (C) 2009 - QLogic Corporation.

 * All rights reserved.

 Default to restricted 1G auto-neg mode */

  PCI Device ID Table  */

 Update addressable range if firmware supports it */

 This is the first boot after power up */

 PCI bus master workaround */

 This is the first boot after power up */

 clear the register for future unloads/loads */

 Start P2 boot loader */

 clear chicken3.25:24 */

	/*

	 * if gen1 and B0, set F1020 - if gen 2, do nothing

	 * if gen2 set to F1000

  set chicken3.24 if gen1 */

 set chicken3.24 if gen1 */

 set station address */

 fall through for msi */

	/*

	 * Set the CRB window to invalid. If any register in window 0 is

	 * accessed it should set the window to 0 and then reset it to 1.

 remap phys address */

 0 is for BAR 0 */

 128 Meg of memory */

 doorbell is on bar 4 */

 Get FW Mini Coredump template and store it */

 required for NX2031 dummy dma */

 Initialize multicast addr pool owners */

	/*

	 * Tell the hardware our version number.

 Handshake with the card before we register the devices. */

 fall through and release firmware */

 with rtnl_lock */

 Usage: During resume and firmware recovery module.*/

 with rtnl_lock */

 Usage: During suspend and firmware recovery module */

 Print ULA info only once for an adapter */

 root bus? */

 This will be reset for mezz cards  */

 Mezz cards have PCI function 0,2,3 enabled */

	/*

	 * See if the firmware gave us a virtual-physical port mapping.

 MTU range: 0 - 8000 (P2) or 9600 (P3) */

/*

 * netxen_nic_close - Disables a network interface entry point

 Only in case of TSO on vlan device */

	/* For LSO, we need to copy the MAC/IP/TCP headers into

	 * the descriptor ring

 Create a TSO vlan header template for firmware */

	/* 14 frags supported for normal packet and

	 * 32 frags supported for TSO packet

 move to next desc.*/

 try to scrub interrupt */

 check interrupt state machine, to be sure */

 not our interrupt */

 claim interrupt */

 clear interrupt */

 read twice to ensure write is flushed */

 clear interrupt */

	/* NX_DEV_NEED_RESET, this state can be marked in two cases

	 * 1. Tx timeout 2. Fw hang

	 * Send request to destroy context in case of tx timeout only

	 * and doesn't required in case of Fw hang

 Checks if DIMM info is valid. */

 Checks if DIMM info is present. */

 Size returned in MB. */

 bridged_mode control */

/**

 * netxen_config_master - configure addresses based on master

 * @dev: netxen device

 * @event: netdev event

	/*

	 * This is the case where the netxen nic is being

	 * enslaved and is dev_open()ed in bond_enslave()

	 * Now we should program the bond's (and its vlans')

	 * addresses in the netxen NIC.

	/*

	 * This is the case where the netxen nic is being

	 * released and is dev_close()ed in bond_release()

	 * just before IFF_BONDING is stripped.

 If this is a bonding device, look for netxen-based slaves*/

 Act only if the actual netxen is the target */

 If this is a bonding device, look for netxen-based slaves*/

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2003 - 2009 NetXen, Inc.

 * Copyright (C) 2009 - QLogic Corporation.

 * All rights reserved.

 0: PCI */

 1: PCIE */

 2: MN */

 3: */

 4: P2NR1 */

 5: SRE   */

 6: NIU   */

 7: QM    */

 8: SQM0  */

 9: SQM1*/

 10: SQM2*/

 11: SQM3*/

 12: I2Q */

 13: TMR */

 14: ROMUSB */

 15: PEG4 */

 16: XDMA */

 17: PEG0 */

 18: PEG1 */

 19: PEG2 */

 20: PEG3 */

 21: P2ND */

 22: P2NI */

 23: */

 24: */

 25: */

 26: */

 27: */

 28: */

 29: MS */

 30: P2NR2 */

 31: EPG */

 32: PCI */

 33: PCIE */

 34: CAM */

 35: */

 36: */

 37: */

 38: */

 39: */

 40: TMR */

 41: P2NR3 */

 42: RPMX1 */

 43: RPMX2 */

 44: RPMX3 */

 45: RPMX4 */

 46: RPMX5 */

 47: RPMX6 */

 48: RPMX7 */

 49: XDMA */

 50: I2Q */

 51: ROMUSB */

 52: */

 53: RPMX0 */

 54: RPMX8 */

 55: RPMX9 */

 56: OCM0 */

 57: CRYPTO */

 58: SMB */

 59: I2C0 */

 60: I2C1 */

 61: LPC */

 62: P2NC */

 63: P2NR0 */

/*

 * top 12 bits of crb internal address (hub, agent)

  PCI Windowing for DDR regions.  */

CRB Window: bit 25 of CRB address */

 Disable an XG interface */

 write twice to flush */

 add broadcast addr to filter */

 add station addr to filter */

 Full promiscuous mode */

 Clear out remaining addresses */

 look up if already exists */

 assuming caller has already copied new addr to netdev */

/*

 * Send the interrupt coalescing parameter set by ethtool to the card.

	/*

	 * RSS request:

	 * bits 3-0: hash_method

	 *      5-4: hash_type_ipv4

	 *	7-6: hash_type_ipv6

	 *	  8: enable

	 *        9: use indirection table

	 *    47-10: reserved

	 *    63-48: indirection table mask

/*

 * netxen_nic_change_mtu - Change the Maximum Transfer Unit

 * @returns 0 on success, negative on failure

/*

 * Changes the CRB window to the specified window.

/*

 * Returns < 0 if off is not valid,

 *	 1 if window access is needed. 'off' is set to offset from

 *	   CRB space in 128M pci map

 *	 0 if no window access is needed. 'off' is set to 2M addr

 * In: 'off' is offset from base in 128M pci map

	/*

	 * Try direct map

	/*

	 * Not in direct map, use crb window

/*

 * In: 'off' is offset from CRB space in 128M pci map

 * Out: 'off' is 2M pci map addr

 * side effect: lock crb window

 Window 1 */

 Window 0 */

 Window 1 */

 Window 0 */

 indirect access */

 indirect access */

 window 1 registers only */

 read back to flush */

 read */

 write */

 Only 64-bit aligned access */

 P2 has different SIU and MIU test agent base addr */

 Only 64-bit aligned access */

 P2 has different SIU and MIU test agent base addr */

 Only 64-bit aligned access */

 P3 onward, test agent base for MIU and SIU is same */

 Only 64-bit aligned access */

 P3 onward, test agent base for MIU and SIU is same */

 NIU access sections */

 Decide which address to use */

 Decide which value to use */

 Decide which address to use */

 Write value back to state area.*/

 Read memory or MN */

 This is size in bytes */

 Read CRB operation */

 Read ROM */

 Handle L2 Cache */

 Handle L1 Cache */

 Reading OCM memory */

 Read MUX data */

 Handling Queue State Reads */

/*

* We catch an error where driver does not read

* as much data as we expect from the entry.

 Next entry in the template */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2003 - 2009 NetXen, Inc.

 * Copyright (C) 2009 - QLogic Corporation.

 * All rights reserved.

 give atleast 1ms for firmware to respond */

 Acquire semaphore before accessing CRB */

 Release semaphore */

 Instance 0 */

 crb_rcv_producer: */

 Jumbo frames */

 LRO */

 crb_sts_consumer: */

 sw_int_mask */

 Instance 1 */

 crb_rcv_producer: */

 Jumbo frames */

 LRO */

 crb_sts_consumer: */

 sw_int_mask */

 Instance 2 */

 crb_rcv_producer: */

 Jumbo frames */

 LRO */

 crb_sts_consumer: */

 sw_int_mask */

 Instance 3 */

 crb_rcv_producer: */

 Jumbo frames */

 LRO */

 crb_sts_consumer: */

 sw_int_mask */

 cmd desc ring */

 Allow dma queues to drain after context reset */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2003 - 2009 NetXen, Inc.

 * Copyright (C) 2009 - QLogic Corporation.

 * All rights reserved.

 read which mode */

 get flow control settings */

 not supported */

 read mode */

 set flow control */

 set autoneg */

 link test */

/*

 * Set the coalescing parameters. Currently only normal is supported.

 * If rx_coalesce_usecs == 0 or rx_max_coalesced_frames == 0 then set the

 * firmware coalescing to default.

	/*

	* Return Error if unsupported values or

	* unsupported parameters are set.

 Fw dump levels */

 Copy template header first */

 Copy captured dump data */

 Free dump area once data has been captured */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2003 - 2009 NetXen, Inc.

 * Copyright (C) 2009 - QLogic Corporation.

 * All rights reserved.

 free whatever was already allocated */

		/*

		 * Now go through all of them, set reference handles

		 * and put them in the queues.

/*

 * netxen_decode_crb_addr(0 - utility to translate from internal Phantom CRB

 * address to external PCI CRB address.

 reset abyte_cnt and dummy_byte_cnt */

 resetall */

 skipping cold reboot MAGIC */

 do not reset PCI */

 core clock */

 MN clock */

 MS clock */

 skip the function enable register */

 After writing this register, HW needs time for CRB */

 to quiet down (else crb_window returns 0xffffffff) */

 hold xdma in reset also */

 disable_peg_cache_all */

 unreset_net_cache */

 p2dn replyCount */

 disable_peg_cache 0 */

 disable_peg_cache 1 */

 peg_clr_all */

 peg_clr 0 */

 peg_clr 1 */

 peg_clr 2 */

 peg_clr 3 */

 NX2031 firmware doesn't support heartbit */

 last attempt had failed */

 firmware is dead */

 check if we have got newer or different file firmware */

 hi, lo are already in host endian byteorder */

 New fw from file is not allowed, if fw on flash is < 4.0.554 */

 check if flashed firmware is newer only for no-mn and P2 case*/

 NX2031 always had MN */

/*

 * NetXen DMA watchdog control:

 *

 *	Bit 0		: enabled => R/O: 1 watchdog active, 0 inactive

 *	Bit 1		: disable_request => 1 req disable dma watchdog

 *	Bit 2		: enable_request =>  1 req enable dma watchdog

 *	Bit 3-31	: unused

 update link parameters */

 Process Command status ring */

 Get the next frag */

	/*

	 * If everything is freed up to consumer then check if the ring is full

	 * If the ring is full then check if more needs to be freed and

	 * schedule the call back again.

	 *

	 * This happens when there are 2 CPUs. One could be freeing and the

	 * other filling it. If the ring is full when we get out of here and

	 * the card has already interrupted the host then the host can miss the

	 * interrupt.

	 *

	 * There is still a possible race condition and the host could miss an

	 * interrupt. The card has to take care of this.

 make a rcv descriptor  */

			/*

			 * Write a doorbell msg to tell phanmon of change in

			 * receive ring producer

			 * Only for firmware version < 4.0.0

 make a rcv descriptor  */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * drivers/net/ethernet/nxp/lpc_eth.c

 *

 * Author: Kevin Wells <kevin.wells@nxp.com>

 *

 * Copyright (C) 2010 NXP Semiconductors

 * Copyright (C) 2012 Roland Stigge <stigge@antcom.de>

/*

 * Ethernet MAC controller Register offsets

/*

 * mac1 register definitions

/*

 * mac2 register definitions

/*

 * ipgt register definitions

/*

 * ipgr register definitions

/*

 * clrt register definitions

/*

 * maxf register definitions

/*

 * supp register definitions

/*

 * test register definitions

/*

 * mcfg register definitions

/*

 * mcmd register definitions

/*

 * madr register definitions

/*

 * mwtd register definitions

/*

 * mrdd register definitions

/*

 * mind register definitions

/*

 * command register definitions

/*

 * status register definitions

/*

 * tsv0 register definitions

/*

 * tsv1 register definitions

/*

 * rsv register definitions

/*

 * flowcontrolcounter register definitions

/*

 * flowcontrolstatus register definitions

/*

 * rxfilterctrl, rxfilterwolstatus, and rxfilterwolclear shared

 * register definitions

/*

 * rxfilterctrl register definitions

/*

 * rxfilterwolstatus/rxfilterwolclear register definitions

/*

 * intstatus, intenable, intclear, and Intset shared register

 * definitions

/*

 * powerdown register definitions

 Receive Status information word */

 Receive Descriptor control word */

 Transmit Status information word */

 Transmit Descriptor control word */

/*

 * Structure of a TX/RX descriptors and RX status

/*

 * Device driver data structure

/*

 * MAC support functions

 Set station address */

 Get station address */

 Reset all MAC logic */

 Reset MII management hardware */

 Setup MII clock to slowest rate with a /28 divider */

 Setup TX/RX descriptors */

 Setup TX descriptors, status, and buffers */

 Setup RX descriptors, status, and buffers */

 Map the TX descriptors to the TX buffers in hardware */

 Map the RX descriptors to the RX buffers in hardware */

	/* Setup base addresses in hardware to point to buffers and

	 * descriptors

 Disable controller and reset */

 Initial MAC setup */

 Collision window, gap */

 Setup TX and RX descriptors */

 Setup packet filtering */

 Get the next TX buffer output index */

 Clear and enable interrupts */

 Enable controller */

 Reset ethernet and power down PHY */

/*

 * MAC<--->PHY support functions

 Wait for unbusy status */

 Wait for completion */

 Attach to the PHY */

 Setup MII mode */

 A buffer is available, get buffer status */

 Next buffer and decrement used buffer counter */

 Update collision counter */

 Any errors occurred? */

 FIFO underrun */

 Late collision */

 Excessive collision */

 Defer limit */

 Update stats */

 Get the current RX buffer indexes */

 Get pointer to receive status */

 Status error? */

 Check statuses */

 Overrun error */

 CRC error */

 Length error */

 Other error */

 Packet is good */

 Copy packet from buffer */

 Pass to upper layer */

 Increment consume index */

 Clear interrupts */

		/* This function should never be called when there are no

		 * buffers

 Get the next TX descriptor index */

 Setup control for the transfer */

 Copy data to the DMA buffer */

 Save the buffer and increment the buffer counter */

 Start transmit */

 Stop queue if no more TX buffers */

 Set station address */

 Set station address */

 Set initial hash table */

 64 bits : multicast address in hash table */

 Suspended PHY makes LPC ethernet core block, so resume now */

 Reset and initialize */

 schedule a link state check */

/*

 * Ethtool ops

 Setup network interface for RMII or MII mode */

 Get platform resources */

 Allocate net driver data structure */

 Save resources */

 Get clock for the device */

 Enable network clock */

 Map IO space */

 Setup driver functions */

 Get size of DMA buffers/descriptors region */

		/* Allocate a chunk of memory for the DMA ethernet buffers

		 * and descriptors

 Get MAC address from current HW setting (POR state is all zeros) */

 then shut everything down to save power */

 Set default parameters */

 Force an MII interface reset and clock setup */

	/* Force default PHY interface setup in chip, this will probably be

	 * changed by the PHY driver

			/*

			 * Reset again now clock is disable to be sure

			 * EMC_MDC is down

 Enable interface clock */

 Reset and initialize */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Linux network driver for QLogic BR-series Converged Network Adapter.

/*

 * Copyright (c) 2005-2014 Brocade Communications Systems, Inc.

 * Copyright (c) 2014-2015 QLogic Corporation

 * All rights reserved

 * www.qlogic.com

	/* Convert loaded firmware to host order as it is stored in file

	 * as sequence of LE32 integers.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Linux network driver for QLogic BR-series Converged Network Adapter.

/*

 * Copyright (c) 2005-2014 Brocade Communications Systems, Inc.

 * Copyright (c) 2014-2015 QLogic Corporation

 * All rights reserved

 * www.qlogic.com

 MSGQ module source file. */

 No-op */

 Walk through pending list to see if the command can be posted */

 No-op */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Linux network driver for QLogic BR-series Converged Network Adapter.

/*

 * Copyright (c) 2005-2014 Brocade Communications Systems, Inc.

 * Copyright (c) 2014-2015 QLogic Corporation

 * All rights reserved

 * www.qlogic.com

/*

 * FW response handlers

	/**

	 * Store only if not set earlier, since BNAD can override the HW

	 * attributes

 Copy Rxf stats to SW area, scatter them while copying */

 Copy Txf stats to SW area, scatter them while copying */

 Dispatch events */

 Dispatch events */

 No-op */

 ETHPORT */

 No-op */

 This event is received due to Rx objects failing */

 No-op */

 down_resp_wait -> up_resp_wait transition on ETHPORT_E_UP */

	/**

	 * NOTE: Do not call bna_bfi_ethport_down() here. That will over step

	 * mbox due to up_resp_wait -> down_resp_wait transition on event

	 * ETHPORT_E_DOWN

 up_resp_wait->down_resp_wait transition on ETHPORT_E_DOWN */

		/**

		 * This event is received due to Rx objects stopping in

		 * parallel to ethport

 No-op */

 up_resp_wait->last_resp_wait transition on ETHPORT_T_STOP */

 Reset the physical port status to enabled */

 Should be called only when ethport is disabled */

 ENET */

 No-op */

		/**

		 * This event is received due to Ethport, Tx and Rx objects

		 * failing

 No-op */

 No-op */

	/**

	 * NOTE: Do not call bna_enet_chld_start() here, since it will be

	 * inadvertently called during cfg_wait->started transition as well

 IOCETH */

	/**

	 * Do not call bfa_nw_ioc_enable() here. It must be called in the

	 * previous state due to failed -> ioc_ready_wait transition.

 This event is received due to enet failing */

 No-op */

 IOC callback functions */

	/**

	 * Attach IOC and claim:

	 *	1. DMA memory for IOC attributes

	 *	2. Kernel memory for FW trace

	/**

	 * Attach common modules (Diag, SFP, CEE, Port) and claim respective

	 * DMA memory.

 A separate queue to allow synchronous setting of a list of MACs */

 A separate queue to allow synchronous setting of a list of MACs */

 DMA memory for COMMON_MODULE */

 DMA memory for retrieving IOC attributes */

 Virtual memory for retreiving fw_trc */

 DMA memory for retreiving stats */

 Virtual memory for Tx objects - stored by Tx module */

 Virtual memory for TxQ - stored by Tx module */

 Virtual memory for Rx objects - stored by Rx module */

 Virtual memory for RxPath - stored by Rx module */

 Virtual memory for RxQ - stored by Rx module */

 Virtual memory for Unicast MAC address - stored by ucam module */

 Virtual memory for Multicast MAC address - stored by mcam module */

 Virtual memory for Multicast handle - stored by mcam module */

 Also initializes diag, cee, sfp, phy_port, msgq */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Linux network driver for QLogic BR-series Converged Network Adapter.

/*

 * Copyright (c) 2005-2014 Brocade Communications Systems, Inc.

 * Copyright (c) 2014-2015 QLogic Corporation

 * All rights reserved

 * www.qlogic.com

 IOC local definitions */

 Asic specific macros : see bfa_hw_cb.c and bfa_hw_ct.c for details. */

/*

 * forward declarations

 IOC state machine definitions/declarations */

!< IOC reset request		*/

!< IOC enable request		*/

!< IOC disable request	*/

!< driver detach cleanup	*/

!< f/w enabled		*/

!< IOC get attribute response	*/

!< f/w disabled		*/

!< failure notice by iocpf sm	*/

!< heartbeat failure		*/

!< hardware error interrupt	*/

!< timeout			*/

!< PCI mapping failure notice	*/

/*

 * Forward declareations for iocpf state machine

 IOCPF state machine events */

!< IOCPF enable request	*/

!< IOCPF disable request	*/

!< stop on driver detach	*/

!< f/w initialization done	*/

!< enable f/w response	*/

!< disable f/w response	*/

!< failure notice by ioc sm	*/

!< init fail notice by ioc sm	*/

!< init fail notice by ioc sm	*/

!< h/w semaphore is locked	*/

!< f/w response timeout	*/

!< h/w sem mapping error	*/

 IOCPF states */

!< IOC is in reset state */

!< Waiting for IOC h/w semaphore */

!< IOC h/w is being initialized */

!< IOCPF is initialized */

!< IOCPF failed */

!< IOCPF failed */

!< IOCPF is being disabled */

!< IOCPF is disabled */

!< IOC f/w different from drivers */

 IOC State Machine */

 Beginning state. IOC uninit state. */

 IOC is in uninit state. */

 Reset entry actions -- initialize state machine */

 IOC is in reset state. */

/* Host IOC function is being enabled, awaiting response from firmware.

 * Semaphore is acquired.

 Semaphore should be acquired for version check. */

 IOC configuration in progress. Timer is active. */

 IOC is being disabled */

		/*

		 * No state change.  Will move to disabled state

		 * after iocpf sm completes failure processing and

		 * moves to disabled state.

 IOC disable completion entry. */

 Hardware initialization retry. */

		/**

		 * Initialization retry failed.

 IOC failure. */

 HB failure notification, ignore. */

 IOC failure. */

 IOCPF State Machine */

 Reset entry actions -- initialize state machine */

 Beginning state. IOC is in reset state. */

 Semaphore should be acquired for version check. */

 Awaiting h/w semaphore to continue with version check. */

 Notify enable completion callback */

 Call only the first time sm enters fwmismatch state. */

 Awaiting firmware version match. */

 Request for semaphore. */

 Awaiting semaphore for h/w initialzation. */

/* Hardware is being initialized. Interrupts are enabled.

 * Holding hardware semaphore lock.

	/**

	 * Enable Interrupts before sending fw IOC ENABLE cmd.

/* Host IOC function is being enabled, awaiting response from firmware.

 * Semaphore is acquired.

 IOC is being disabled */

 IOC hb ack request is being removed. */

 IOC disable completion entry. */

 Hardware initialization failed. */

 Hardware initialization failed. */

	/**

	 * Mark IOC as failed in hardware and stop firmware.

	/**

	 * Flush any queued up mailbox requests.

 IOC is in failed state. */

 IOC is in failed state. */

 BFA IOC private functions */

 Notify common modules registered for notification. */

 Clear fwver hdr */

 Spin on init semaphore to serialize. */

	/*

	 * Try to lock and then unlock the semaphore.

 Unlock init semaphore */

	/**

	 * First read to the semaphore register will return 0, subsequent reads

	 * will return 1. Semaphore is released by writing 1 to the register

 Initialize LPU local memory (aka secondary memory / SRAM) */

	/*

	 * i2c workaround 12.5khz clock

	/**

	 * wait for memory initialization to be complete

	/**

	 * If memory initialization is not successful, IOC timeout will catch

	 * such failures.

	/**

	 * Take processor out of reset.

	/**

	 * Put processors in reset.

 Get driver and firmware versions. */

/* Returns TRUE if major minor and maintenance are same.

 * If patch version are same, check for MD5 Checksum to be same.

 Returns TRUE if both are compatible and patch of fwhdr_to_cmp is better. */

	/* GA takes priority over internal builds of the same patch stream.

	 * At this point major minor maint and patch numbers are same.

	/* All Version Numbers are equal.

	 * Md5 check to be done as a part of compatibility check.

 register definitions */

 fifo size */

 max # of status check */

 max # of blocking op check */

 write in progress bit mask */

 fast read */

 write enable */

 sector erase */

 write */

 read status */

 hardware error definition */

!< flash not present */

!< flash not initialized */

!< flash bad */

!< flash busy */

!< command active never cleared */

!< fifo count never cleared */

!< write-in-progress never cleared */

!< fli timeout */

!< invalid length */

 flash command register data structure */

 flash device status register data structure */

 flash address register data structure */

 Flash raw private functions */

 Flush FLI data fifo. */

 fifo counter in terms of words */

 Check the device status. It may take some time. */

 Read flash status. */

 Start flash read operation. */

 len must be mutiple of 4 and not exceeding fifo size */

 check status */

 check if write-in-progress bit is cleared */

 Check flash read operation. */

 End flash read operation. */

 read data fifo up to 32 words */

 Perform flash raw read. */

 fw image address */

/*

 * Returns TRUE if driver is willing to work with current smem f/w version.

 If smem is incompatible or old, driver should not work with it. */

	/* IF Flash has a better F/W than smem do not work with smem.

	 * If smem f/w == flash f/w, as smem f/w not old | incmp, work with it.

	 * If Flash is old or incomp work with smem iff smem f/w == drv f/w.

/* Return true if current running version is valid. Firmware signature and

 * execution context (driver/bios) must match.

 Conditionally flush any pending message from firmware at start. */

	/**

	 * check if firmware is valid

	/**

	 * If hardware initialization is in progress (initialized by other IOC),

	 * just wait for an initialization completion interrupt.

	/**

	 * If IOC function is disabled and firmware version is same,

	 * just re-enable IOC.

		/**

		 * When using MSI-X any pending firmware ready event should

		 * be flushed. Otherwise MSI-X interrupts are not delivered.

	/**

	 * Initialize the h/w for any other states.

	/*

	 * first write msg to mailbox registers

	/*

	 * write 1 to mailbox CMD to trigger LPU event

 overflow in 2106 */

 overflow in 2106 */

 Initiate a full firmware download. */

		/**

		 * write smem

		/**

		 * handle page offset wrap around

	/*

	 * Set boot type, env and device mode at the end.

 BFA ioc enable reply by firmware */

 Update BFA configuration from firmware configuration. */

 Attach time initialization of mbox logic. */

 Mbox poll timer -- restarts any pending mailbox requests. */

	/**

	 * If no command pending, do nothing

	/**

	 * If previous command is not yet fetched by firmware, do nothing

	/**

	 * Enqueue command to firmware.

	/**

	 * Give a callback to the client, indicating that the command is sent

 Cleanup any pending requests. */

/**

 * bfa_nw_ioc_smem_read - Read data from SMEM to host through PCI memmap

 *

 * @ioc:     memory for IOC

 * @tbuf:    app memory to store data from smem

 * @soff:    smem offset

 * @sz:      size of smem in bytes

	/*

	 *  Hold semaphore to serialize pll init and fwtrc.

		/**

		 * handle page offset wrap around

	/*

	 * release semaphore

 Retrieve saved firmware trace from a prior IOC failure. */

 Save firmware trace if configured. */

 Retrieve saved firmware trace from a prior IOC failure. */

	/**

	 * Notify driver and common modules registered for notification.

 IOCPF to IOC interface */

	/**

	 * Provide enable completion callback and AEN notification.

 IOC public */

	/*

	 *  Hold semaphore so that nobody can access the chip during init.

 Initialize LMEM */

	/*

	 *  release semaphore.

/* Interface used by diag module to do firmware boot with memory test

 * as the entry vector.

		/* Work with Flash iff flash f/w is better than driver f/w.

		 * Otherwise push drivers firmware.

	/**

	 * Initialize IOC state of all functions on a chip reset.

 Enable/disable IOC failure auto recovery. */

	/**

	 * read the MBOX msg

	/**

	 * turn off mailbox interrupt by clearing mailbox status

/**

 * bfa_nw_ioc_attach - IOC attach time initialization and setup.

 *

 * @ioc:	memory for IOC

 * @bfa:	driver instance structure

 * @cbfn:	callback function

 Driver detach time IOC cleanup. */

 Done with detach, empty the notify_q. */

/**

 * bfa_nw_ioc_pci_init - Setup IOC PCI properties.

 *

 * @ioc:	memory for IOC

 * @pcidev:	PCI device information for this IOC

 * @clscode:	class code

	/**

	 * Initialize IOC and device personality

	/**

	 * Set asic specific interfaces.

/**

 * bfa_nw_ioc_mem_claim - Initialize IOC dma memory

 *

 * @ioc:	memory for IOC

 * @dm_kva:	kernel virtual address of IOC dma memory

 * @dm_pa:	physical address of IOC dma memory

	/**

	 * dma memory for firmware attribute

 Return size of dma memory required. */

 Initialize memory for saving firmware trace. */

 Register mailbox message handler function, to be called by common modules */

/**

 * bfa_nw_ioc_mbox_queue - Queue a mailbox command request to firmware.

 *

 * @ioc:	IOC instance

 * @cmd:	Mailbox command

 * @cbfn:	callback function

 * @cbarg:	arguments to callback

 *

 * Waits if mailbox is busy. Responsibility of caller to serialize

	/**

	 * If a previous command is pending, queue new command

	/**

	 * If mailbox is busy, queue command for poll timer

	/**

	 * mailbox is free -- queue command to firmware

 Handle mailbox interrupts */

		/**

		 * Treat IOC message class as special.

	/**

	 * Try to send pending mailbox commands

 return true if IOC is disabled */

 return true if IOC is operational */

/* Add to IOC heartbeat failure notification queue. To be used by common

 * modules such as cee, port, diag.

 For now, model descr uses same model string */

 WWN public */

 Firmware failure detected. Start recovery actions. */

 BFA IOC PF private functions */

/*

 *	Flash module specific

/*

 * FLASH DMA buffer should be big enough to hold both MFG block and

 * asic block(64k) at the same time and also should be 2k aligned to

 * avoid write segement to cross sector boundary.

/*

 * Send flash write request.

 indicate if it's the last msg of the whole write operation */

/**

 * bfa_flash_read_send - Send flash read request.

 *

 * @cbarg: callback argument

/**

 * bfa_flash_intr - Process flash response messages upon receiving interrupts.

 *

 * @flasharg: flash structure

 * @msg: message structure

 receiving response after ioc failure */

/*

 * Flash memory info API.

/**

 * bfa_nw_flash_attach - Flash attach API.

 *

 * @flash: flash structure

 * @ioc: ioc structure

 * @dev: device structure

/**

 * bfa_nw_flash_memclaim - Claim memory for flash

 *

 * @flash: flash structure

 * @dm_kva: pointer to virtual memory address

 * @dm_pa: physical memory address

/**

 * bfa_nw_flash_get_attr - Get flash attribute.

 *

 * @flash: flash structure

 * @attr: flash attribute structure

 * @cbfn: callback function

 * @cbarg: callback argument

 *

 * Return status.

/**

 * bfa_nw_flash_update_part - Update flash partition.

 *

 * @flash: flash structure

 * @type: flash partition type

 * @instance: flash partition instance

 * @buf: update data buffer

 * @len: data buffer length

 * @offset: offset relative to the partition starting address

 * @cbfn: callback function

 * @cbarg: callback argument

 *

 * Return status.

	/*

	 * 'len' must be in word (4-byte) boundary

/**

 * bfa_nw_flash_read_part - Read flash partition.

 *

 * @flash: flash structure

 * @type: flash partition type

 * @instance: flash partition instance

 * @buf: read data buffer

 * @len: data buffer length

 * @offset: offset relative to the partition starting address

 * @cbfn: callback function

 * @cbarg: callback argument

 *

 * Return status.

	/*

	 * 'len' must be in word (4-byte) boundary

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Linux network driver for QLogic BR-series Converged Network Adapter.

/*

 * Copyright (c) 2005-2014 Brocade Communications Systems, Inc.

 * Copyright (c) 2014-2015 QLogic Corporation

 * All rights reserved

 * www.qlogic.com

/**

 * bfa_cee_attr_meminfo - Returns the size of the DMA memory needed by CEE attributes

/**

 * bfa_cee_stats_meminfo - Returns the size of the DMA memory needed by CEE stats

/**

 * bfa_cee_get_attr_isr - CEE ISR for get-attributes responses from f/w

 *

 * @cee: Pointer to the CEE module

 * @status: Return status from the f/w

/**

 * bfa_cee_get_stats_isr - CEE ISR for get-stats responses from f/w

 *

 * @cee: Pointer to the CEE module

 * @status: Return status from the f/w

/**

 * bfa_cee_reset_stats_isr - CEE ISR for reset-stats responses from f/w

 *

 * @cee: Input Pointer to the CEE module

 * @status: Return status from the f/w

/**

 * bfa_nw_cee_meminfo - Returns the size of the DMA memory needed by CEE module

/**

 * bfa_nw_cee_mem_claim - Initialized CEE DMA Memory

 *

 * @cee: CEE module pointer

 * @dma_kva: Kernel Virtual Address of CEE DMA Memory

 * @dma_pa:  Physical Address of CEE DMA Memory

/**

 * bfa_nw_cee_get_attr - Send the request to the f/w to fetch CEE attributes.

 *

 * @cee: Pointer to the CEE module data structure.

 * @attr: attribute requested

 * @cbfn: function pointer

 * @cbarg: function pointer arguments

 *

 * Return: status

/**

 * bfa_cee_isr - Handles Mail-box interrupts for CEE module.

 * @cbarg: argument passed containing pointer to the CEE module data structure.

 * @m: message pointer

/**

 * bfa_cee_notify - CEE module heart-beat failure handler.

 *

 * @arg: argument passed containing pointer to the CEE module data structure.

 * @event: IOC event type

/**

 * bfa_nw_cee_attach - CEE module-attach API

 *

 * @cee: Pointer to the CEE module data structure

 * @ioc: Pointer to the ioc module data structure

 * @dev: Pointer to the device driver module data structure.

 *       The device driver specific mbox ISR functions have

 *       this pointer as one of the parameters.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Linux network driver for QLogic BR-series Converged Network Adapter.

/*

 * Copyright (c) 2005-2014 Brocade Communications Systems, Inc.

 * Copyright (c) 2014-2015 QLogic Corporation

 * All rights reserved

 * www.qlogic.com

/*

 * forward declarations

 Called from bfa_ioc_attach() to map asic specific calls. */

 Return true if firmware of current driver matches the running firmware. */

	/**

	 * If bios boot (flash based) -- do not increment usage count

	/**

	 * If usage count is 0, always return TRUE.

	/**

	 * Use count cannot be non-zero and chip in uninitialized state.

	/**

	 * Check if another driver with a different firmware is active

	/**

	 * Same firmware version. Increment the reference count.

	/**

	 * If bios boot (flash based) -- do not decrement usage count

	/**

	 * decrement usage count

 Notify other functions on HB failure. */

 Wait for halt to take effect */

 Host to LPU mailbox message addresses */

 Host <-> LPU mailbox command/status registers - port 0 */

 Host <-> LPU mailbox command/status registers - port 1 */

	/*

	 * PSS control registers

	/*

	 * IOC semaphore registers and serialization

	/**

	 * sram memory access

	/*

	 * err set reg : for notification of hb failure in fcmode

	/*

	 * PSS control registers

	/*

	 * IOC semaphore registers and serialization

	/**

	 * sram memory access

	/*

	 * err set reg : for notification of hb failure in fcmode

 Initialize IOC to port mapping. */

	/**

	 * For catapult, base port id on personality register and IOC type

 Set interrupt mode for a function: INTX or MSIX */

	/**

	 * If already in desired mode, do not change anything

 MSI-X resource allocation for 1860 with no asic block */

 Cleanup hw semaphore and usecnt registers */

	/*

	 * Read the hw sem reg to make sure that it is locked

	 * before we clear it. If it is not locked, writing 1

	 * will lock it instead of clearing it.

 Synchronized IOC failure processing routines */

	/*

	 * Driver load time.  If the sync required bit for this PCI fn

	 * is set, it is due to an unclean exit by the driver for this

	 * PCI fn in the previous incarnation. Whoever comes here first

	 * should clean it up, no matter which PCI fn.

 Synchronized IOC failure processing routines */

	/**

	 * The check below is to see whether any other PCI fn

	 * has reinitialized the ASIC (reset sync_ackd bits)

	 * and failed again while this IOC was waiting for hw

	 * semaphore (in bfa_iocpf_sm_semwait()).

	/**

	 * If another PCI fn reinitialized and failed again while

	 * this IOC was waiting for hw sem, the sync_ackd bit for

	 * this IOC need to be set again to allow reinitialization.

	/*

	 * put s_clk PLL and PLL FSM in reset

	/*

	 * Ignore mode and program for the max clock (which is FC16)

	 * Firmware/NFC will do the PLL init appropriately

	/*

	 * while doing PLL init dont clock gate ethernet subsystem

	/*

	 * set sclk value

	/*

	 * poll for s_clk lock or delay 1ms

	/*

	 * Dont do clock gating for ethernet subsystem, firmware/NFC will

	 * do this appropriately

	/*

	 * put l_clk PLL and PLL FSM in reset

	/*

	 * set LPU speed (set for FC16 which will work for other modes)

	/*

	 * set LPU half speed (set for FC16 which will work for other modes)

	/*

	 * set lclk for mode (set for FC16)

	/*

	 * poll for s_clk lock or delay 1ms

	/*

	 * release soft reset on s_clk & l_clk

	/*

	 * release soft reset on s_clk & l_clk

 put port0, port1 MAC & AHB in reset */

 release soft reset on s_clk & l_clk */

 Announce flash device presence, if flash was corrupted. */

	/*

	 * Mask the interrupts and clear any

	 * pending interrupts left by BIOS/EFI

 For first time initialization, no need to clear interrupts */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Linux network driver for QLogic BR-series Converged Network Adapter.

/*

 * Copyright (c) 2005-2014 Brocade Communications Systems, Inc.

 * Copyright (c) 2014-2015 QLogic Corporation

 * All rights reserved

 * www.qlogic.com

/*

 * BNA debufs interface

 *

 * To access the interface, debugfs file system should be mounted

 * if not already mounted using:

 *	mount -t debugfs none /sys/kernel/debug

 *

 * BNA Hierarchy:

 *	- bna/pci_dev:<pci_name>

 * where the pci_name corresponds to the one under /sys/bus/pci/drivers/bna

 *

 * Debugging service available per pci_dev:

 *	fwtrc:  To collect current firmware trace.

 *	fwsave: To collect last saved fw trace as a result of firmware crash.

 *	regwr:  To write one word to chip register

 *	regrd:  To read one or more words from chip register.

 Get IOC info */

 Retrieve CEE related info */

 Retrieve flash partition info */

 Changes the current file position */

/*

 * Function to check if the register offset passed is valid.

 check [16:15] */

 PCIe core register */

 8k dwords or 32KB */

 CB 32 KB memory page */

 8k dwords or 32KB */

 CB register space 64KB */

 Copy the user space buf */

 offset and len sanity check */

 Copy the user space buf */

 offset only 17 bit and word align */

 offset and len sanity check */

 Initialize debugfs interface for BNA */

 Setup the BNA debugfs root directory*/

 Setup the pci_dev debugfs directory for the port */

 Uninitialize debugfs interface for BNA */

 Remove the pci_dev debugfs directory for the port */

 Remove the BNA debugfs root directory */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Linux network driver for QLogic BR-series Converged Network Adapter.

/*

 * Copyright (c) 2005-2014 Brocade Communications Systems, Inc.

 * Copyright (c) 2014-2015 QLogic Corporation

 * All rights reserved

 * www.qlogic.com

 10G full duplex setting supported only */

 Lock rqd. to access bnad->bna_lock */

	/*

	 * Do not need to store rx_coalesce_usecs here

	 * Every time DIM is disabled, we can get it from the

	 * stack.

 Add Tx Inter-pkt DMA count?  */

 restore rx configuration */

 ccb->consumer_index */

	/*

	 * Used bna_lock to sync reads from bna_stats, which is written

	 * under the same lock

 Get netif_queue_stopped from stack */

 Fill driver stats into ethtool buffers */

 Fill hardware stats excluding the rxf/txf into ethtool bufs */

 Fill txf stats into ethtool buffers */

  Fill rxf stats into ethtool buffers */

 Fill per Q stats into ethtool buffers */

 Check for the flash type & base offset value */

 Fill the magic value */

 Query the flash partition based on the offset */

 Check if the flash update request is valid */

 Query the flash partition based on the offset */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Linux network driver for QLogic BR-series Converged Network Adapter.

/*

 * Copyright (c) 2005-2014 Brocade Communications Systems, Inc.

 * Copyright (c) 2014-2015 QLogic Corporation

 * All rights reserved

 * www.qlogic.com

/*

 * Module params

/*

 * Global variables

/*

 * Local MACROS

/*

 * Reinitialize completions in CQ, once Rx is taken down

 Tx Datapath functions */

 Caller should ensure that the entry at unmap_q[index] is valid */

/*

 * Frees all pending Tx Bufs

 * At this point no activity is expected on the Q,

 * so DMA unmap & freeing is fine.

/*

 * bnad_txcmpl_process : Frees the Tx bufs on Tx completion

 * Can be called in a) Interrupt context

 *		    b) Sending context

 Just return if TX is stopped */

 Update consumer pointers. */

 MSIX Tx Completion Handler */

 Default is page-based allocation. Multi-buffer support - TBD */

 prefetch header */

		/* The 'valid' field is set by the adapter, only after writing

		 * the other fields of completion entry. Hence, do not load

		 * other fields of completion entry *before* the 'valid' is

		 * loaded. Adding the rmb() here prevents the compiler and/or

		 * CPU from reordering the reads which would potentially result

		 * in reading stale values in completion entry.

 start of packet ci */

		/* Check all the completions for this frame.

		 * busy-wait doesn't help much, break here.

				/* The 'valid' field is set by the adapter, only

				 * after writing the other fields of completion

				 * entry. Hence, do not load other fields of

				 * completion entry *before* the 'valid' is

				 * loaded. Adding the rmb() here prevents the

				 * compiler and/or CPU from reordering the reads

				 * which would potentially result in reading

				 * stale values in completion entry.

 TODO: BNA_CQ_EF_LOCAL ? */

 MSIX Rx Path Handler */

 Interrupt handlers */

 Mbox Interrupt Handlers */

 Process data interrupts */

 Tx processing */

 Rx processing */

/*

 * Called in interrupt / callback context

 * with bna_lock held, so cfg_flags access is OK

/*

 * Called with bnad->bna_lock held b'cos of

 * bnad->cfg_flags access.

 Control Path Handlers */

 Callbacks */

						/*

						 * Force an immediate

	/*

	 * Workaround for first ioceth enable failure & we

	 * get a 0 MAC address. We try to get the MAC address

	 * again here.

/*

 * Free all TxQs buffers and then notify TX_E_CLEANUP_DONE to Tx fsm.

/*

 * Free all RxQs buffers and then notify RX_E_CLEANUP_DONE to Rx fsm.

		/*

		 * Wait till the poll handler has exited

		 * and nothing can be scheduled anymore

 Resource allocation, free functions */

 Free IRQ for Mailbox */

/*

 * Allocates IRQ for Mailbox, but keep it disabled

 * This will be enabled once we get the mbox enable callback

 * from bna

	/*

	 * Set the Mbox IRQ disable flag, so that the IRQ handler

	 * called from request_irq() for SHARED IRQs do not execute

 Allocates Interrupt Descriptor List for MSIX/INT-X vectors */

/* NOTE: Should be called for MSIX only

 * Unregisters Tx MSIX vector(s) from the kernel

/* NOTE: Should be called for MSIX only

 * Registers Tx MSIX vector(s) and ISR(s), cookie with the kernel

/* NOTE: Should be called for MSIX only

 * Unregisters Rx MSIX vector(s) from the kernel

/* NOTE: Should be called for MSIX only

 * Registers Tx MSIX vector(s) and ISR(s), cookie with the kernel

 Free Tx object Resources */

 Allocates memory and interrupt resources for Tx object */

 Free Rx object Resources */

 Allocates memory and interrupt resources for Rx object */

 All memory needs to be allocated before setup_ccbs */

 Timer callbacks */

 a) IOC timer */

/*

 * All timer routines use bnad->bna_lock to protect against

 * the following race, which may occur in case of no locking:

 *	Time	CPU m	CPU n

 *	0       1 = test_bit

 *	1			clear_bit

 *	2			del_timer_sync

 *	3	mod_timer

 b) Dynamic Interrupt Moderation Timer */

 Check for BNAD_CF_DIM_ENABLED, does not eliminate a race */

 c)  Statistics Timer */

/*

 * Set up timer for DIM

 * Called with bnad->bna_lock held

/*

 * Set up timer for statistics

 * Called with mutex_lock(&bnad->conf_mutex) held

/*

 * Stops the stats timer

 * Called with mutex_lock(&bnad->conf_mutex) held

 Utilities */

 Index 0 has broadcast address */

 Initialize & enable NAPI */

 First disable and then clean up */

 Should be held with conf_lock held */

 Should be held with conf_lock held */

 Initialize the Tx object configuration */

 Get BNA's resource requirement for one tx object */

 Fill Unmap Q memory requirements */

 Allocate resources */

 Ask BNA to create one Tx object, supplying required resources */

 Register ISR for the Tx object */

 Setup the rx config for bna_rx_create */

 bnad decides the configuration */

	/* BNA_RXP_SINGLE - one data-buffer queue

	 * BNA_RXP_SLR - one small-buffer and one large-buffer queues

	 * BNA_RXP_HDS - one header-buffer and one data-buffer queues

 TODO: configurable param for queue type */

		/* though size_routing_enable is set in SLR,

		 * small packets may get routed to same rxq.

		 * set buf_size to 2048 instead of PAGE_SIZE.

 this should be in multiples of 2 */

 initialize for q1 for BNA_RXP_SLR/BNA_RXP_HDS */

 Called with mutex_lock(&bnad->conf_mutex) held */

 destroy and create new rx objects */

 restore rx configuration */

 Called with bnad_conf_lock() held */

 Called with mutex_lock(&bnad->conf_mutex) held */

 Initialize the Rx object configuration */

 Get BNA's resource requirement for one Rx object */

 Fill Unmap Q memory requirements */

 Allocate resource */

 Ask BNA to create one Rx object, supplying required resources */

	/*

	 * Init NAPI, so that state is set to NAPI_STATE_SCHED,

	 * so that IRQ handler cannot schedule NAPI at this point.

 Register ISR for the Rx object */

 Set up Dynamic Interrupt Moderation Vector */

 Enable VLAN filtering only on the default Rx */

 Start the DIM timer */

 Called with conf_lock & bnad->bna_lock held */

 Called with conf_lock & bnad->bna_lock held */

/*

 * Called with bnad->bna_lock held

 If datapath is down, pretend everything went through */

 Should be called with conf_lock held */

 Called with mutex_lock(&bnad->conf_mutex) held */

 Statistics utilities */

/*

 * Must be called with the bna_lock held.

 receive ring buffer overflow  ?? */

 recv'r fifo overrun */

 Utility used by bnad_start_xmit, for doing TSO */

	/*

	 * For TSO, the TCP checksum field is seeded with pseudo-header sum

	 * excluding the length field.

 Do we really need these? */

/*

 * Initialize Q numbers depending on Rx Paths

 * Called with bnad->bna_lock held, because of cfg_flags

 * access.

 INTx */

/*

 * Adjusts the Q numbers, given a number of msix vectors

 * Give preference to RSS as opposed to Tx priority Queues,

 * in such a case, just use 1 Tx Q

 * Called with bnad->bna_lock held b'cos of cfg_flags access

 Enable / disable ioceth */

 Free BNA resources */

 Allocates memory and interrupt resources for BNA */

 Interrupt enable / disable */

 ret = #of vectors that we got */

 Netdev entry points */

 Tx */

 Rx */

 Port */

 Enable broadcast */

 Restore VLANs, if any */

 Set the UCAST address */

 Start the stats timer */

 Stop the stats timer */

 Synchronize mailbox IRQ */

 TX */

 Returns 0 for success */

 nexthdr may not be TCP immediately. */

/*

 * bnad_start_xmit : Netdev entry point for Transmit

 *		     Called under lock held by net_device

 Sanity checks for the skb */

	/*

	 * Takes care of the Tx that is scheduled between clearing the flag

	 * and the netif_tx_stop_all_queues() call.

 4 vectors per work item */

 Check for available TxQ resources */

		/*

		 * Check again to deal with race condition between

		 * netif_stop_queue here, and netif_wake_queue in

		 * interrupt handler which is not inside netif tx lock.

 Program the opcode, flags, frame_len, num_vectors in WI */

 Program the vectors */

 Undo the changes starting at tcb->producer_index */

 Undo the changes starting at tcb->producer_index */

 Undo the changes starting at tcb->producer_index */

/*

 * Used spin_lock to synchronize reading of stats structures, which

 * is written by BNA under the same lock.

 ucast packets not in UCAM are routed to default function */

 copy rest of the MCAST addresses */

 clear bnad flags to update it with new settings */

/*

 * bna_lock is used to sync writes to netdev->addr

 * conf_lock cannot be used since this call may be made

 * in a non-blocking context.

 check if multi-buffer needs to be enabled */

 only when transition is over 4K */

		/*

		 * Tx processing may happen in sending context, so no need

		 * to explicitly process completions here

 Rx processing */

 MTU range: 46 - 9000 */

/*

 * 1. Initialize the bnad structure

 * 2. Setup netdev pointer in pci_dev

 * 3. Initialize no. of TxQ & CQs & MSIX vectors

 * 4. Initialize work queue.

/*

 * Must be called after bnad_pci_uninit()

 * so that iounmap() and pci_set_drvdata(NULL)

 * happens only after PCI uninitialization.

/*

 * Initialize locks

	a) Per ioceth mutes used for serializing configuration

	   changes from OS interface

	b) spin lock used to protect bna state machine

 PCI Initialization */

	/*

	 * Allocates sizeof(struct net_device + struct bnad)

	 * bnad = netdev->priv

	/*

	 * PCI initialization

	 *	Output : using_dac = 1 for 64 bit DMA

	 *			   = 0 for 32 bit DMA

	/*

	 * Initialize bnad structure

	 * Setup relation between pci_dev & netdev

 Initialize netdev structure, set up ethtool ops */

 Set link to down state */

 Setup the debugfs node for this bfad */

 Get resource requirement form bna */

 Allocate resources from bna */

 Setup pcidev_info for bna_init() */

 Set up timers */

	/*

	 * Start the chip

	 * If the call back comes with error, we bail out.

	 * This is a catastrophic error.

 Get the burnt-in mac */

 Finally, reguister with net_device layer */

 Remove the debugfs node for this bnad */

 Remove the debugfs node for this bnad */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Linux network driver for QLogic BR-series Converged Network Adapter.

/*

 * Copyright (c) 2005-2014 Brocade Communications Systems, Inc.

 * Copyright (c) 2014-2015 QLogic Corporation

 * All rights reserved

 * www.qlogic.com

 IB */

 RXF */

 No-op */

 No more pending config updates */

 No-op */

 No more pending config updates */

 This function gets the multicast MAC that has already been added to CAM */

 First delete multicast entries to maintain the count */

 Add multicast entries */

 Throw away delete pending mcast entries */

 Move active mcast entries to pending_add_q */

 Clear ucast from cache */

 for pure priority tagged frames */

 Check if already added or pending addition */

 Purge the pending_add_q */

 Schedule active_q entries for deletion */

 Allocate nodes */

 Add the new entries */

 Purge the pending_add_q */

 Schedule active_q entries for deletion */

 Allocate nodes */

 Add the new entries */

 Purge all entries from pending_add_q */

 Schedule all entries in active_q for deletion */

 Delete MAC addresses previousely added */

 Set default unicast MAC */

 Add additional MAC entries */

 Throw away delete pending ucast entries */

 Move active ucast entries to pending_add_q */

 Enable/disable promiscuous mode */

 move promisc configuration from pending -> active */

 move promisc configuration from pending -> active */

 Clear pending promisc mode disable */

 Move promisc mode config from active -> pending */

 Enable/disable allmulti mode */

 move allmulti configuration from pending -> active */

 move allmulti configuration from pending -> active */

 Clear pending allmulti mode disable */

 Move allmulti mode config from active -> pending */

 Do nothing if pending enable or already enabled */

 Turn off pending disable command */

 Schedule enable */

 Do nothing if pending disable or already disabled */

 Turn off pending enable command */

 Schedule disable */

 Do nothing if pending enable or already enabled */

 Turn off pending disable command */

 Schedule enable */

 Do nothing if pending disable or already disabled */

 Turn off pending enable command */

 Schedule disable */

 RX */

 no-op */

 Start IB */

 No-op */

 No-op */

 Small RxQ */

 Large/Single RxQ */

				/* multi-buffer is enabled by allocating

				 * a new rx with new set of resources.

				 * q0->buffer_size should be initialized to

				 * fragment size.

 Stop IB */

 Indicate Enet is not enabled, and failed */

 Initialize the queues */

 Build RX queues */

 build RX-path queue */

 build RXQ queue */

 Setup doorbells */

 Initialize producer/consumer indexes */

 Following callbacks are mandatory */

 Setup IB */

 Setup large Q */

 Setup small Q */

 Setup CQ */

		/* if multi-buffer is enabled sum of q0_depth

		 * and q1_depth need not be a power of 2

 h/w should not be accessed. Treat we're stopped */

 Error checks */

 If promisc mode is already enabled elsewhere in the system */

 If default mode is already enabled in the system */

 Trying to enable promiscuous and default mode together */

 If default mode is already enabled elsewhere in the system */

 If promiscuous mode is already enabled in the system */

 Process the commands */

 Trigger h/w if needed */

 Arrive at preconfigured coalescing timeo value based on pkt rate */

 Set it to IB */

 TX */

 No-op */

 No-op */

 Start IB */

		/**

		 * We are here due to start_wait -> stop_wait transition on

		 * TX_E_STOP event

 No-op */

 No-op */

 No-op */

 No-op */

 No-op */

 No-op */

 Stop IB */

 Setup doorbells */

 Initialize producer/consumer indexes */

	/**

	 * Get resources

 Tx */

 TxQs */

	/*

	 * Initialize

 Tx */

 Following callbacks are mandatory */

 TxQ */

 IB */

 TCB */

 QPT, SWQPT, Pages */

 Callback to bnad for setting up TCB */

/*======================================================================

    fmvj18x_cs.c 2.8 2002/03/23



    A fmvj18x (and its compatibles) PCMCIA client driver



    Contributed by Shingo Fujimoto, shingo@flab.fujitsu.co.jp



    TDK LAK-CD021 and CONTEC C-NET(PC)C support added by 

    Nobuhiro Katayama, kata-n@po.iijnet.or.jp



    The PCMCIA client code is based on code written by David Hinds.

    Network code is based on the "FMV-18x driver" by Yutaka TAMIYA

    but is actually largely Donald Becker's AT1700 driver, which

    carries the following attribution:



    Written 1993-94 by Donald Becker.



    Copyright 1993 United States Government as represented by the

    Director, National Security Agency.

    

    This software may be used and distributed according to the terms

    of the GNU General Public License, incorporated herein by reference.

    

    The author may be reached as becker@scyld.com, or C/O

    Scyld Computing Corporation

    410 Severn Ave., Suite 210

    Annapolis MD 21403

   

====================================================================*/

 Module parameters */

 SRAM configuration */

 0:4KB*2 TX buffer   else:8KB*2 TX buffer */

====================================================================*/

/*

    PCMCIA event handlers

/*

    LAN controller(MBH86960A) specific routines

/*

    card type

/*

    driver specific data structure

====================================================================*/

/* 

    ioport offset from the base address 

 transmit status register */

 receive status register */

 transmit interrupt mask register */

 receive interrupt mask register */

 transmit mode register */

 receive mode register */

 configuration register 0 */

 configuration register 1 */

 node ID register            (bank 0) */

 multicast address registers (bank 1) */

 buffer mem port registers   (bank 2) */

 transmit start register */

 16 collision control register */

 reserved */

 reserved */

 skip received packet register */

 LAN card control register */

 hardware address */

 UNGERMANN-BASS hardware address */

/* 

    control bits 

 flags */

 can accept new packet */

 carrier is detected */

 send packet successfully */

 short packet error */

 collision error */

 16 collision error */

 bus read error */

 packet(s) in buffer */

 bus read error */

 short packet */

 frame error */

 CRC error */

 overflow error */

 receive buffer is empty */

 drop packet in buffer */

 default bitmaps */

 commands */

 no tests, detect carrier */

 (RX_MODE) */

 (RX_MODE) */

 16bit bus, 4K x 2 Tx queues */

 16bit bus, 8K x 2 Tx queues */

 Data Link Controller off (CONFIG_0) */

 Data Link Controller off (CONFIG_0) */

 bank 0 (CONFIG_1) */

 bank 1 (CONFIG_1) */

 bank 2 (CONFIG_1) */

 contrl chip power off (CONFIG_1) */

 do transmit packet */

 send a packet */

 Auto skip packet on 16 col detected */

 Stop and skip packet on 16 col */

 Auto skip packet on 16 col detected */

 Stop and skip packet on 16 col */

 LAN controller ignores interrupts */

 LAN controller will catch interrupts */

 bank 0 (CONFIG_1) */

 bank 1 (CONFIG_1) */

 bank 2 (CONFIG_1) */

 Make up a FMVJ18x specific data structure */

 The io structure describes IO port mapping */

 General socket configuration */

 fmvj18x_attach */

====================================================================*/

 fmvj18x_detach */

====================================================================*/

    /*

	Ungermann-Bass Access/CARD accepts 0x300,0x320,0x340,0x360

	0x380,0x3c0 only for ioport.

 calculate ConfigIndex value */

 RequestIO failed */

 strange, but that's what the code did already before... */

 Yes, I have CISTPL_FUNCE. Let's check CISTPL_MANFID */

 MultiFunction Card */

 MultiFunction Card */

 MultiFunction Card */

                /* RATOC REX-5588/9822/4886's PRODID are 0004(=MBH10302),

 old type card */

 MBH10304 with buggy CIS */

 NextCom NC5310, etc. */

 Reset controller */

 Power On chip and select bank 0 */

 Set hardware address */

 Read MACID from CIS */

 Read MACID from register */

 Read MACID from Buggy CIS */

 Read MACID from register */

 print current configuration */

 fmvj18x_config */

====================================================================*/

 Allocate a small memory window */

    /*

     *  MBH10304 CISTPL_FUNCE_LAN_NODE_ID format

     *  22 0d xx xx xx 04 06 yy yy yy yy yy yy ff

     *  'xx' is garbage.

     *  'yy' is MAC address.

 fmvj18x_get_hwinfo */

====================================================================*/

 Allocate a small memory window */

 Config Option Register of LAN */

 Config and Status Register */

 I/O Base(Low) of LAN */

 I/O Base(High) of LAN */

 Config Option Register of Modem */

 Config and Status Register */

====================================================================*/

 set NULL before iounmap */

====================================================================*/

====================================================================*/

 avoid multiple interrupts */

 wait for a while */

 get status */

 clear status */

 there is packet(s) in rx buffer */

 Ack interrupt for multifunction card */

 fjn_interrupt */

====================================================================*/

 ToDo: We should try to restart the adaptor... */

 Disable both interrupts. */

 wait for a while */

 If the Tx is idle, always trigger a transmit. */

 Yes, there is room for one more packet. */

 Yes, there is room for one more packet. */

 Re-enable interrupts */

 fjn_start_xmit */

====================================================================*/

 Reset controller */

 Power On chip and select bank 0 */

 Set Tx modes */

 set Rx modes */

 Set hardware address */

 (re)initialize the multicast table */

 Switch to bank 2 (runtime mode) */

 set 16col ctrl bits */

 clear Reserved Regs */

 reset Skip packet reg. */

 Enable Tx and Rx */

 Init receive pointer ? */

 Clear all status */

 Turn on Rx interrupts */

 Turn on interrupts from LAN card controller */

 fjn_reset */

====================================================================*/

 5 -> 10: by agy 19940922 */

 There was an error. */

 Malloc up new buffer. */

    /* If any worth-while packets have been received, dev_rint()

	   has done a netif_wake_queue() for us and will work on them

/*

    if (lp->cardtype != TDK) {

	int i;

	for (i = 0; i < 20; i++) {

	    if ((inb(ioaddr + RX_MODE) & F_BUF_EMP) == F_BUF_EMP)

		break;

	    (void)inw(ioaddr + DATAPORT);  /+ dummy status read +/

	    outb(F_SKP_PKT, ioaddr + RX_SKIP);

	}



	if (i > 0)

	    pr_debug("%s: Exint Rx packet with mode %02x after "

		  "%d ticks.\n", dev->name, inb(ioaddr + RX_MODE), i);

    }

 fjn_rx */

====================================================================*/

 fjn_open */

====================================================================*/

 Set configuration register 0 to disable Tx and Rx. */

 Update the statistics -- ToDo. */

 Power-down the chip.  Green, green, green! */

 Set the ethernet adaptor disable IRQ */

 fjn_close */

====================================================================*/

/*

  Set the multicast/promiscuous mode for this adaptor.

 Multicast hash filter */

 Disable Tx and Rx */

 Enable promiscuous mode */

 Too many to filter perfectly -- accept all multicasts. */

 Use normal mode. */

 Ignore almost all multicasts. */

 Use normal mode. */

 Switch to bank 1 and set the multicast table. */

 SPDX-License-Identifier: GPL-2.0

/* Renesas Ethernet AVB device driver

 *

 * Copyright (C) 2014-2019 Renesas Electronics Corporation

 * Copyright (C) 2015 Renesas Solutions Corp.

 * Copyright (C) 2015-2016 Cogent Embedded, Inc. <source@cogentembedded.com>

 *

 * Based on the SuperH Ethernet driver

 RAVB_BE */

 RAVB_NC */

 RAVB_BE */

 RAVB_NC */

 Set config mode */

 Check if the operating mode is changed to the config mode */

 10BASE */

 100BASE */

 1000BASE */

 100BASE */

 1000BASE */

/* Get MAC address from the MAC address registers

 *

 * Ethernet AVB device doesn't have ROM for MAC address.

 * This function gets the MAC address that was used by a bootloader.

 MDC pin control */

 Data I/O pin control */

 Set data bit */

 Get data bit */

 MDIO bus control struct */

 Free TX skb function for AVB-IP */

 Descriptor type must be checked before all other reads */

 Free the original skb. */

 Last packet descriptor? */

 Free skb's and DMA buffers for Ethernet AVB */

 Free RX skb ringbuffer */

 Free aligned TX buffers */

	/* Free TX skb ringbuffer.

	 * SKBs are freed by ravb_tx_free() call above.

 Build RX ring buffer */

 RX descriptor */

		/* We just set the data size to 0 for a failed mapping which

		 * should prevent DMA from happening...

 type */

 Build RX ring buffer */

 RX descriptor */

		/* We just set the data size to 0 for a failed mapping which

		 * should prevent DMA from happening...

 type */

 Format skb and descriptor buffer for Ethernet AVB */

 Build TX ring buffer */

 type */

 RX descriptor base address for best effort */

 type */

 TX descriptor base address for best effort */

 type */

 Init skb and descriptor buffer for Ethernet AVB */

 Allocate RX and TX skb rings */

 Allocate rings for the aligned buffers */

 Allocate all RX descriptors. */

 Allocate all TX descriptors. */

 Receive frame limit set register */

 EMAC Mode: PAUSE prohibition; Duplex; TX; RX; CRC Pass Through */

 Set MAC address */

 E-MAC status register clear */

 E-MAC interrupt enable register */

 Receive frame limit set register */

 EMAC Mode: PAUSE prohibition; Duplex; RX Checksum; TX; RX */

 Set MAC address */

 E-MAC status register clear */

 E-MAC interrupt enable register */

 E-MAC init function */

 Descriptor format */

 Set DMAC RX */

 Set Max Frame Length (RTC) */

 Set FIFO size */

 Frame receive */

 Disable FIFO full warning */

 Receive FIFO full error, descriptor empty */

 Descriptor format */

 Set AVB RX */

 Set FIFO size */

 Timestamp enable */

 Interrupt init: */

 Clear DIL.DPLx */

 Set queue specific interrupt */

 Frame receive */

 Disable FIFO full warning */

 Receive FIFO full error, descriptor empty */

 Frame transmitted, timestamp FIFO updated */

 Device init function for Ethernet AVB */

 Set CONFIG mode */

 Setting the control will start the AVB-DMAC process. */

	/* The hardware checksum is contained in sizeof(__sum16) (2) bytes

	 * appended to packet data

 Packet receive function for Gigabit Ethernet */

 Descriptor type must be checked before all other reads */

 We use 0-byte descriptors to mark the DMA mapping errors */

 Refill the RX ring buffers. */

			/* We just set the data size to 0 for a failed mapping

			 * which should prevent DMA  from happening...

 Descriptor type must be set after all the above writes */

 Packet receive function for Ethernet AVB */

 Descriptor type must be checked before all other reads */

 We use 0-byte descriptors to mark the DMA mapping errors */

 Refill the RX ring buffers. */

 Better luck next round. */

			/* We just set the data size to 0 for a failed mapping

			 * which should prevent DMA  from happening...

 Descriptor type must be set after all the above writes */

 Packet receive function for Ethernet AVB */

 Disable TX and RX */

 Enable TX and RX */

 function for waiting dma process finished */

 Wait for stopping the hardware TX process */

 Stop the E-MAC's RX/TX processes. */

 Wait for stopping the RX DMA process */

 Stop AVB-DMAC process */

 E-MAC interrupt handler */

 clear interrupt */

 Link changed */

 DIsable RX and TX */

 Enable RX and TX */

 Error interrupt handler */

 Receive Descriptor Empty int */

 Receive Descriptor Empty int */

 Receive FIFO Overflow int */

 Mask RX and TX interrupts */

 Get interrupt status */

 Received and transmitted interrupts */

 Timestamp updated */

 Network control and best effort queue RX/TX */

 E-MAC status summary */

 Error status summary */

 gPTP interrupt status summary */

 Timestamp/Error/gPTP interrupt handler */

 Get interrupt status */

 Timestamp updated */

 Error status summary */

 gPTP interrupt status summary */

 Network control/Best effort queue RX/TX */

 Processing RX Descriptor Ring */

 Clear RX interrupt */

 Processing TX Descriptor Ring */

 Clear TX interrupt */

 Re-enable RX/TX interrupts */

 Receive error message handling */

 PHY state control function */

 Disable TX and RX right over here, if E-MAC change is ignored */

 Enable TX and RX right over here, if E-MAC change is ignored */

 sentinel */ }

 PHY init function */

 Try connecting to PHY */

		/* In the case of a fixed PHY, the DT node associated

		 * to the PHY is the Ethernet MAC DT node.

	/* This driver only support 10/100Mbit speeds on R-Car H3 ES1.0

	 * at this time.

 10BASE, Pause and Asym Pause is not supported */

 Half Duplex is not supported */

 PHY control start function */

 Device-specific stats */

 Stop PTP Clock driver */

 Wait for DMA stopping */

 Free all the skb's in the RX queue and the DMA buffers. */

 Set new parameters */

 Initialise PTP Clock driver */

 Network device open function for Ethernet AVB */

 Device init */

 Initialise PTP Clock driver */

 PHY control start */

 Stop PTP Clock driver */

 Timeout function for Ethernet AVB */

 tx_errors count up */

 Stop PTP Clock driver */

 Wait for DMA stopping */

		/* If ravb_stop_dma() fails, the hardware is still operating

		 * for TX and/or RX. So, this should not call the following

		 * functions because ravb_dmac_init() is possible to fail too.

		 * Also, this should not retry ravb_stop_dma() again and again

		 * here because it's possible to wait forever. So, this just

		 * re-enables the TX and RX and skip the following

		 * re-initialization procedure.

 Device init */

		/* If ravb_dmac_init() fails, descriptors are freed. So, this

		 * should return here to avoid re-enabling the TX and RX in

		 * ravb_emac_init().

 Initialise PTP Clock driver */

 Packet transmit function for Ethernet AVB */

		/* Zero length DMA descriptors are problematic as they seem

		 * to terminate DMA transfers. Avoid them by simply using a

		 * length of DPTR_ALIGN (4) when skb data is aligned to

		 * DPTR_ALIGN.

		 *

		 * As skb is guaranteed to have at least ETH_ZLEN (60)

		 * bytes of data by the call to skb_put_padto() above this

		 * is safe with respect to both the length of the first DMA

		 * descriptor (len) overflowing the available data and the

		 * length of the second DMA descriptor (skb->len - len)

		 * being negative.

 TX timestamp required */

 TAG and timestamp required flag */

 Descriptor type must be set after all the above writes */

 If skb needs TX timestamp, it is handled in network control queue */

 (write clear) */

 (write clear) */

 (write clear) */

 Update promiscuous bit */

 Device close function for Ethernet AVB */

 Disable interrupts by clearing the interrupt masks. */

 Stop PTP Clock driver */

 Set the config mode to stop the AVB-DMAC's processes */

 Clear the timestamp list */

 PHY disconnect */

 Free all the skb's in the RX queue and the DMA buffers. */

 Control hardware time stamping */

 Reserved for future extensions */

 ioctl to device function */

 Disable TX and RX */

 Modify RX Checksum setting */

 Enable TX and RX */

 Place holder */

 MDIO bus init function */

 Bitbang init */

 MII controller setting */

 Hook up MII support for ethtool */

 Register MDIO bus */

 MDIO bus release function */

 Unregister mdio bus */

 Free bitbang info */

 Set CSEL value */

 Set tx and rx clock internal delay modes */

 Valid values are 0 and 1800, according to DT bindings */

 Valid values are 0 and 2000, according to DT bindings */

 Fall back to legacy rgmii-*id behavior */

 The Ether-specific entries in the device structure. */

	/* FIXME: R-Car Gen2 has 4byte alignment restriction for tx buffer

	 * Use two descriptor to handle such situation. First descriptor to

	 * handle aligned data buffer and second descriptor to handle the

	 * overflow data because of alignment.

 Set function */

 Set AVB config mode */

 Set GTI value */

 Request GTI loading */

 Allocate descriptor base address table */

 Initialise HW timestamp list */

 Initialise PTP Clock driver */

 Debug message level */

 Read and set MAC address */

 MDIO bus init */

 Network device register */

 Print device information */

 Stop PTP Clock driver */

 Stop PTP Clock driver */

 Set reset mode */

 Disable interrupts by clearing the interrupt masks. */

 Only allow ECI interrupts */

 Enable MagicPacket */

 Disable MagicPacket */

 If WoL is enabled set reset mode to rearm the WoL logic */

	/* All register have been reset to default values.

	 * Restore all registers which where setup at probe time and

	 * reopen device if it was running before system suspended.

 Set AVB config mode */

 Set GTI value */

 Request GTI loading */

 Restore descriptor base address table */

	/* Runtime PM callback shared between ->runtime_suspend()

	 * and ->runtime_resume(). Simply returns success.

	 *

	 * This driver re-initializes all registers after

	 * pm_runtime_get_sync() anyway so there is no need

	 * to save and restore registers here.

 SPDX-License-Identifier: GPL-2.0+

/* PTP 1588 clock using the Renesas Ethernet AVB

 *

 * Copyright (C) 2013-2015 Renesas Electronics Corporation

 * Copyright (C) 2015 Renesas Solutions Corp.

 * Copyright (C) 2015-2016 Cogent Embedded, Inc. <source@cogentembedded.com>

 Caller must hold the lock */

 Caller must hold the lock */

 Caller must hold the lock */

	/* When the comparison value (GPTC.PTCV) is in range of

	 * [x-1 to x+1] (x is the configured increment value in

	 * GTI.TIV), it may happen that a comparison match is

	 * not detected when the timer wraps around.

 PTP clock operations */

 Reject requests with unsupported flags */

 Reject requests with unsupported flags */

 Unmask interrupt */

 Mask interrupt */

 Caller must hold the lock */

 SPDX-License-Identifier: GPL-2.0

/*  SuperH Ethernet device driver

 *

 *  Copyright (C) 2014 Renesas Electronics Corporation

 *  Copyright (C) 2006-2012 Nobuhiro Iwamatsu

 *  Copyright (C) 2008-2014 Renesas Solutions Corp.

 *  Copyright (C) 2013-2017 Cogent Embedded, Inc.

 *  Copyright (C) 2014 Codethink Limited

/* use some intentionally tricky logic here to initialize the whole struct to

 * 0xffff, but then override certain fields, requiring us to indicate that we

 * "know" that there are overrides in this structure, and we'll need to disable

 * that warning from W=1 builds. GCC has supported this option since 4.2.X, but

 * the macros available to do this only define GCC 8.

 reset device */

 Table Init */

 Reset HW CRC register */

 Select MII mode */

 10BASE */

 100BASE */

 1000BASE */

 R7S72100 */

 R8A7740 */

 There is CPU dependent code */

 10BASE */

 100BASE */

 R-Car Gen1 */

 R-Car Gen2 and RZ/G1 */

 R8A77980 */

 R7S9210 */

 CONFIG_OF */

 10BASE */

 100BASE */

 SH7724 */

 10BASE */

 100BASE */

 SH7757 */

 save MAHR and MALR */

 restore MAHR and MALR */

 10BASE */

 100BASE */

 1000BASE */

 SH7757(GETHERC) */

 SH7734 */

 SH7763 */

 Program the hardware MAC address from dev->dev_addr. */

/* Get MAC address from SuperH MAC address register

 *

 * SuperH's Ethernet device doesn't have 'ROM' to MAC address.

 * This driver get MAC address that use by bootloader(U-boot or sh-ipl+g).

 * When you want use this device, you must set MAC address in bootloader.

 *

 Data I/O pin control */

 Set bit data*/

 Get bit data*/

 MDC pin control */

 mdio bus control struct */

 free Tx skb function */

 TACT bit must be checked before all the following reads */

 Free the original skb. */

 free skb and descriptor buffer */

 Free Rx skb ringbuffer */

 Free Tx skb ringbuffer */

 format skb and descriptor buffer */

 build Rx ring buffer */

 skb */

 The size of the buffer is a multiple of 32 bytes. */

 RX descriptor */

 Rx descriptor address set */

 Mark the last entry as wrapping the ring. */

 build Tx ring buffer */

 Tx descriptor address set */

 Get skb and descriptor buffer */

	/* +26 gets the maximum ethernet encapsulation, +7 & ~7 because the

	 * card needs room to do 8 byte alignment, +2 so we can reserve

	 * the first 2 bytes, and +16 gets room for the status word from the

	 * card.

 Allocate RX and TX skb rings */

 Allocate all Rx descriptors. */

 Allocate all Tx descriptors. */

 Free Rx and Tx skb ring buffer and DMA buffer */

 Soft Reset */

 Descriptor format */

 all sh_eth int mask */

 FIFO size set */

 Frame recv control (enable multiple-packets per rx irq) */

 DMA transfer burst mode */

 Burst cycle count upper-limit */

 Recv frame limit set register */

 EMAC Mode: PAUSE prohibition; Duplex; RX Checksum; TX; RX */

 E-MAC Status Register clear */

 E-MAC Interrupt Enable register */

 Set MAC address */

 mask reset */

 Setting the Rx mode will start the Rx process. */

	/* Deactivate all TX descriptors, so DMA should stop at next

	 * packet boundary if it's currently running

 Disable TX FIFO egress to MAC */

 Stop RX DMA at next packet boundary */

	/* Aside from TX DMA, we can't tell when the hardware is

	 * really stopped, so we need to reset to make sure.

	 * Before doing that, wait for long enough to *probably*

	 * finish transmitting the last packet and poll stats.

 max frame time at 10 Mbps < 1250 us */

 Set the RMII mode again if required */

 Set MAC address again */

 The hardware checksum is 2 bytes appended to packet data */

 Packet receive function */

 RACT bit must be checked before all the following reads */

		/* In case of almost all GETHER/ETHERs, the Receive Frame State

		 * (RFS) bits in the Receive Descriptor 0 are from bit 9 to

		 * bit 0. However, in case of the R8A7740 and R7S72100

		 * the RFS bits are from bit 25 to bit 16. So, the

		 * driver needs right shifting by 16.

 Refill the Rx ring buffers. */

 The size of the buffer is 32 byte boundary. */

 Better luck next round. */

 RACT bit must be set after all the above writes */

 Restart Rx engine if stopped. */

 If we don't need to check status, don't. -KDU */

 fix the values for the next receiving if RDE is set */

 disable tx and rx */

 enable tx and rx */

 E-MAC interrupt handler */

 clear int */

 Link Changed */

 Link Up */

 clear int */

 enable tx and rx */

 error control function */

 Unused write back interrupt */

 Transmit Abort int */

 Receive Abort int */

 Receive Frame Overflow int */

 Transmit Descriptor Empty int */

 FIFO under flow */

 Receive Descriptor Empty int */

 Receive FIFO Overflow int */

 Address Error */

 Tx error */

 dmesg */

 dirty buffer free */

 SH7712 BUG */

 tx dma start */

 wakeup */

 Get interrupt status */

	/* Mask it with the interrupt mask, forcing ECI interrupt  to be always

	 * enabled since it's the one that  comes  thru regardless of the mask,

	 * and  we need to fully handle it  in sh_eth_emac_interrupt() in order

	 * to quench it as it doesn't get cleared by just writing 1 to the  ECI

	 * bit...

 Mask Rx interrupts */

 Tx Check */

 Clear Tx interrupts */

 E-MAC interrupt */

 Clear error interrupts */

 Clear Rx interrupts */

 Reenable Rx interrupts */

 PHY state control function */

 Disable TX and RX right over here, if E-MAC change is ignored */

 Enable TX and RX right over here, if E-MAC change is ignored */

 PHY init function */

 Try connect to PHY */

 mask with MAC supported features */

 PHY control start function */

/* If it is ever necessary to increase SH_ETH_REG_DUMP_MAX_REGS, the

 * version must be bumped as well.  Just adding registers up to that

 * limit is fine, as long as the existing register indices don't

 * change.

	/* Dump starts with a bitmap that tells ethtool which

	 * registers are defined for this chip.

	/* Add a register to the dump, if it has a defined offset.

	 * This automatically skips most undefined registers, but for

	 * some it is also necessary to check a capability flag in

	 * struct sh_eth_cpu_data.

 This is the start of a table, not just a single register. */

 device-specific stats */

		/* Serialise with the interrupt handler and NAPI, then

		 * disable interrupts.  We have to clear the

		 * irq_enabled flag first to ensure that interrupts

		 * won't be re-enabled.

 Free all the skbuffs in the Rx queue and the DMA buffers. */

 Set new parameters */

 network device open function */

 Descriptor set */

 device init */

 PHY control start*/

 Timeout function */

 tx_errors count up */

 Free all the skbuffs in the Rx queue. */

 device init */

 Packet transmit function */

 soft swap. */

 TACT bit must be set after all the above writes */

 cur_tx must be incremented after TACT bit was set */

/* The statistics registers have write-clear behaviour, which means we

 * will lose any increment between the read and write.  We mitigate

 * this by only clearing when we read a non-zero value, so we will

 * never falsely report a total of zero.

 device close function */

	/* Serialise with the interrupt handler and NAPI, then disable

	 * interrupts.  We have to clear the irq_enabled flag first to

	 * ensure that interrupts won't be re-enabled.

 PHY Disconnect */

 Free all the skbuffs in the Rx queue and the DMA buffer. */

 For TSU_POSTn. Please refer to the manual about this (strange) bitfields */

 If other port enables, the function returns "true" */

 No entry found, create one */

 Enable the entry */

 Entry found or created, enable POST */

 Entry found */

 Disable the entry if both ports was disabled */

 Disable the entry if both ports was disabled */

 Update promiscuous flag and multicast filter */

	/* Initial condition is MCT = 1, PRM = 0.

	 * Depending on ndev->flags, set PRM or clear MCT

 update the ethernet mode */

 Disable TX and RX */

 Modify RX Checksum setting */

 Enable TX and RX */

 No filtering if vid = 0 */

	/* The controller has one VLAN tag HW filter. So, if the filter is

	 * already enabled, the driver disables it and the filte

 disable VLAN filter */

 No filtering if vid = 0 */

 SuperH's TSU register init function */

 Disable all CAM entry */

 Enable POST registers */

 Disable forward(0->1) */

 Disable forward(1->0) */

 forward fifo 3k-3k */

 Disable QTAG(0->1) */

 Disable QTAG(1->0) */

 all interrupt status clear */

 Disable all interrupt */

 Disable all CAM entry */

 Disable CAM entry [ 0- 7] */

 Disable CAM entry [ 8-15] */

 Disable CAM entry [16-23] */

 Disable CAM entry [24-31] */

 MDIO bus release function */

 unregister mdio bus */

 free bitbang info */

 MDIO bus init function */

 create bit control struct for PHY */

 bitbang init */

 MII controller setting */

 Wrap accessors with Runtime PM-aware ops */

 Hook up MII support for ethtool */

 register MDIO bus */

 get PHY ID */

 set cpu data */

	/* User's manual states max MTU should be 2048 but due to the

	 * alignment calculations in sh_eth_ring_init() the practical

	 * MTU is a bit less. Maybe this can be optimized some more.

 set function */

 debug message level */

 read and set MAC address */

		/* We can only request the  TSU region  for the first port

		 * of the two  sharing this TSU for the probe to succeed...

 ioremap the TSU registers */

 Need to init only the first port of the two sharing a TSU */

 TSU init (Init only)*/

 MDIO bus init */

 network device register */

 print device information */

 net_dev free */

 Only allow ECI interrupts */

 Enable MagicPacket */

 Disable MagicPacket */

	/* The device needs to be reset to restore MagicPacket logic

	 * for next wakeup. If we close and open the device it will

	 * both be reset and all registers restored. This is what

	 * happens during suspend and resume without WoL enabled.

	/* Runtime PM callback shared between ->runtime_suspend()

	 * and ->runtime_resume(). Simply returns success.

	 *

	 * This driver re-initializes all registers after

	 * pm_runtime_get_sync() anyway so there is no need

	 * to save and restore registers here.

 SPDX-License-Identifier: GPL-2.0

 Copyright(c) 2017 - 2021 Pensando Systems, Inc */

		/* If called with new_ts == NULL, replay the previous request

		 * primarily for recovery after a FW_RESET.

		 * We saved the previous configuration request info, so copy

		 * the previous request for reference, clear the current state

		 * to match the device's reset state, and run with it.

 special queues remain allocated, just unused */

 read and discard low part to defeat hw staging of high part */

	/* If tick_high changed, re-read tick_low once more.  Assume tick_high

	 * cannot change again so soon as in the span of re-reading tick_low.

 Reject phc adjustments during device upgrade */

 Adjustment value scaled by 2^16 million */

 Adjustment value to scale */

 Final adjusted multiplier */

 update the point-in-time basis to now, before adjusting the rate */

	/* Setphc commands are posted in-order, sequenced by phc->lock.  We

	 * need to drop the lock before waiting for the command to complete.

 Reject phc adjustments during device upgrade */

	/* Setphc commands are posted in-order, sequenced by phc->lock.  We

	 * need to drop the lock before waiting for the command to complete.

 Reject phc adjustments during device upgrade */

	/* Setphc commands are posted in-order, sequenced by phc->lock.  We

	 * need to drop the lock before waiting for the command to complete.

 Do not attempt to read device time during upgrade */

	/* Do not update phc during device upgrade, but keep polling to resume

	 * after upgrade.  Since we don't update the point in time basis, there

	 * is no expectation that we are maintaining the phc time during the

	 * upgrade.  After upgrade, it will need to be readjusted back to the

	 * correct time by the ptp daemon.

 update point-in-time basis to now */

	/* Setphc commands are posted in-order, sequenced by phc->lock.  We

	 * need to drop the lock before waiting for the command to complete.

 max ticks is limited by the multiplier, or by the update period. */

		/* max ticks that do not overflow when multiplied by max

		 * adjusted multiplier (twice the initial multiplier)

 approx ticks at four times the update period */

 transform to bitmask */

 constrain to the hardware bitmask, and use this as the bitmask */

	/* the wrap period is now defined by diff (or phc->cc.mask)

	 *

	 * we will update the time basis at about 1/4 the wrap period, so

	 * should not see a difference of more than +/- diff/4.

	 *

	 * this is sufficient not see a difference of more than +/- diff/2, as

	 * required by timecounter_cyc2time, to detect an old time stamp.

	 *

	 * adjust the initial multiplier, being careful to avoid overflow:

	 *  - do not overflow 63 bits: init_cc_mult * SCALED_PPM

	 *  - do not overflow 64 bits: max_mult * (diff / 2)

	 *

	 * we want to increase the initial multiplier as much as possible, to

	 * allow for more precise adjustment in ionic_phc_adjfine.

	 *

	 * only adjust the multiplier if we can double it or more.

 initial multiplier will be 2^n of hardware cc.mult */

 increase cc.mult and cc.shift by the same 2^n and n. */

 frequency adjustments are relative to the initial multiplier */

 Update cycle_last at 1/4 the wrap period, or IONIC_PHC_UPDATE_NS */

	/* We have allowed to adjust the multiplier up to +/- 1 part per 1.

	 * Here expressed as NORMAL_PPB (1 billion parts per billion).

 SPDX-License-Identifier: GPL-2.0

 Copyright(c) 2017 - 2019 Pensando Systems, Inc */

 check for done */

 interrupt the wait if FW stopped */

	/* Wait for dev cmd to complete, retrying if we get EAGAIN,

	 * but don't wait any longer than max_seconds.

		/* Don't check the heartbeat on FW_CONTROL commands as they are

		 * notorious for interrupting the firmware's heartbeat update.

		/* It is possible (but unlikely) that FW was busy and missed a

		 * heartbeat check but is still alive and will process this

		 * request, so don't clean the dev_cmd in this case.

 SPDX-License-Identifier: GPL-2.0

 Copyright(c) 2017 - 2019 Pensando Systems, Inc */

 queuetype support level */

 0 = Base version with CQ support */

 0 = Base version */

 0 = Base version with CQ+SG support */

	[IONIC_QTYPE_TXQ]     = 1,   /* 0 = Base version with CQ+SG support

				      * 1 =   ... with Tx SG version 1

				/* Fire off another watchdog to see

				 * if the FW is already back rather than

				 * waiting another whole cycle

 Don't put carrier back up if we're in a broken state */

 we only need one request outstanding at a time */

	/* If there was a previous fw communcation error, don't bother with

	 * sending the adminq command and just return the same error value.

 try to get the irq on the local numa node first */

 q & cq need to be contiguous in case of notifyq */

 Let the notifyq ride on the adminq interrupt */

 if we're not running, just set the values and return */

 Have we run out of new completions to process? */

 Don't delete our own address from the uc list */

 grab the flags once for local use */

 sync the filters */

	/* check for overflow state

	 *    if so, we track that we overflowed and enable NIC PROMISC

	 *    else if the overflow is set and not needed

	 *       we remove our overflow flag and check the netdev flags

	 *       to see if we can disable NIC PROMISC

 Sync the kernel filter list with the driver filter list */

	/* Shove off the rest of the rxmode work to the work task

	 * which will include syncing the filters to the firmware.

 set up what we expect to support by default */

 tell the netdev what we actually can support */

 Stop and clean the queues before reconfiguration */

 Re-init the queues after reconfiguration */

	/* The only way txrx_init can fail here is if communication

	 * with FW is suddenly broken.  There's not much we can do

	 * at this point - error messages have already been printed,

	 * so we can continue on and the user can eventually do a

	 * DOWN and UP to try to reset and clear the issue.

 if we're not running, nothing more to do */

	/* if we were stopped before this scheduled job was launched,

	 * don't bother the queues as they are already stopped.

 Fill indirection table with 'default' values */

 If recovering from a broken state, clear the bit and we'll try again */

 don't start the queues until we have link */

	/* If hardware timestamping is enabled, but the queues were freed by

	 * ionic_stop, those need to be reallocated and initialized, too.

 until someday when we support qos */

 setting the min just seems silly */

 convert to u8 for config */

 convert to u8 for config */

 only swapping the queues, not the napi, flags, or other stuff */

 allocate temporary qcq arrays to hold new queue structs */

	/* allocate new desc_info and rings, but leave the interrupt setup

	 * until later so as to not mess with the still-running queues

 stop and clean the queues */

 swap new desc_info and rings, keeping existing interrupt config */

 if we need to change the interrupt layout, this is the time */

 clear existing interrupt assignments */

 re-assign the interrupts */

 now we can rework the debugfs mappings */

 re-init the queues, but don't lose an error code */

 free old allocs without cleaning intr */

 free q array */

	/* clean the unused dma and info allocations when new set is smaller

	 * than the full array, but leave the qcq shells in place

 Convert the default coalesce value to actual hw resolution */

 allocate lif info */

 allocate control queues and txrx queue arrays */

 allocate rss indirection table */

 restore the hardware timestamping queues */

 free rss indirection table */

 free queues */

 free lif info */

 unmap doorbell page */

 free netdev & lif */

 preset the callback info */

		/* If the netdev mac is non-zero and doesn't match the default

		 * device address, it was set by something earlier and we're

		 * likely here again after a fw-upgrade reset.  We need to be

		 * sure the netdev mac is in our filter list.

 Update the netdev mac with the device's mac */

 now that we have the hw_index we can figure out our doorbell page */

 first doorbell id reserved for kernel (dbid aka pid == zero) */

 only register LIF0 for now */

 filter out the ones we know about */

 retrieve basic values from FW */

 limit values to play nice with kdump */

 reserve last queue id for hardware timestamping */

	/* interrupt usage:

	 *    1 for master lif adminq/notifyq

	 *    1 for each CPU for master lif TxRx queue pairs

	 *    whatever's left is for RDMA queues

 adminq + 1 TxRx queue pair */

 SPDX-License-Identifier: GPL-2.0

 Copyright(c) 2017 - 2019 Pensando Systems, Inc */

 SW Stats group */

 Add more stat groups here */

 SPDX-License-Identifier: GPL-2.0

 Copyright(c) 2017 - 2019 Pensando Systems, Inc */

	/* The port_info data is found in a DMA space that the NIC keeps

	 * up-to-date, so there's no need to request the data from the

	 * NIC, we already have it in our memory space.

 Copper */

 Fibre */

 This means there's no module plugged in */

 set autoneg */

 set speed */

 change both at the same time */

 Tx normally shares Rx interrupt, so only change Rx if not split */

	/* Convert the usec request to a HW usable value.  If they asked

	 * for non-zero and it resolved to zero, bump it up

 Save the new values */

 if nothing to do return success */

 if we're not running, just set the values and return */

 report maximum channels */

 report current channels */

 if we're not running, just set the values and return */

 report the module data type and length */

	/* The NIC keeps the module prom up-to-date in the DMA space

	 * so we can simply copy the module bytes into the data buffer.

 Let's make sure we got a consistent copy */

 tx modes */

 rx filters */

 flap the link to force auto-negotiation */

 SPDX-License-Identifier: GPL-2.0

 Copyright(c) 2017 - 2019 Pensando Systems, Inc */

 remove from old id list, save new id in tmp list */

 rebuild the by_id hash lists with the new filter ids */

 remove from current linking so we can refresh it */

 don't bother if we already have it and it is sync'd */

 mark preemptively as sync'd to block any parallel attempts */

 save as SYNCED to catch any DEL requests while processing */

	/* Don't bother with the write to FW if we know there's no room,

	 * we can try again on the next sync attempt.

	 * Since the FW doesn't have a way to tell us the vlan limit,

	 * we start max_vlans at 0 until we hit the ENOSPC error.

 set the state back to NEW so we can try again later */

			/* If -ENOSPC we won't waste time trying to sync again

			 * until there is a delete that might make room

		/* Someone requested a delete while we were adding

		 * so update the filter info with the results from the add

		 * and the data will be there for the delete on the next

		 * sync cycle.

	/* Copy the filters to be added and deleted

	 * into a separate local list that needs no locking.

	/* If the add or delete fails, it won't get marked as sync'd

	 * and will be tried again in the next sync action.

	 * Do the deletes first in case we're in an overflow state and

	 * they can clear room for some new filters

 SPDX-License-Identifier: GPL-2.0

 Copyright(c) 2017 - 2019 Pensando Systems, Inc */

 Supported devices */

 end of table */

 only map the whole bar 0 */

 ignore failures from older FW, we just won't get stats */

 Query system for DMA addressing limitation for the device. */

 Setup PCI device */

 Configure the device */

 Configure the ports */

 Allocate and init the LIF */

	/* Don't fail the probe for these errors, keep

	 * the hw interface around for inspection

 SPDX-License-Identifier: GPL-2.0

 Copyright(c) 2017 - 2019 Pensando Systems, Inc */

 SPDX-License-Identifier: GPL-2.0

 Copyright(c) 2017 - 2019 Pensando Systems, Inc */

 BAR0: dev_cmd and interrupts */

 BAR1: doorbells */

 set times to ensure the first check will proceed */

 init as ready, so no transition if the first check succeeds */

 Devcmd Interface */

 wait a least one second before testing again */

 if called concurrently, only the first should proceed. */

	/* firmware is useful only if the running bit is set and

	 * fw_status != 0xff (bad PCI read)

	 * If fw_status is not ready don't bother with the generation.

			/* If the generation changed, the fw status is not

			 * ready so we need to trigger a fw-down cycle.  After

			 * the down, the next watchdog will see the fw is up

			 * and the generation value stable, so will trigger

			 * the fw-up activity.

 is this a transition? */

 wait at least one watchdog period since the last heartbeat */

 early FW version had no heartbeat, so fake it */

 log a transition */

 Device commands */

 Port commands */

 VF commands */

 LIF commands */

 check for empty queue */

 stop index must be for a descriptor that is not yet completed */

 SPDX-License-Identifier: GPL-2.0

 Copyright(c) 2017 - 2019 Pensando Systems, Inc */

 SPDX-License-Identifier: GPL-2.0

 Copyright(c) 2020 Pensando Systems, Inc */

/* The worst case wait for the install activity is about 25 minutes when

 * installing a new CPLD, which is very seldom.  Normal is about 30-35

 * seconds.  Since the driver can't tell if a CPLD update will happen we

 * set the timeout for the ugly case.

 Number of periodic log updates during fw file download */

 SPDX-License-Identifier: GPL-2.0

 Copyright(c) 2017 - 2019 Pensando Systems, Inc */

 don't re-use pages allocated in low-mem condition */

 don't re-use buffers from non-local numa nodes */

 check for empty queue */

 clean the related q entry, only one per qc completion */

 alloc a new buffer? */

 fill main descriptor - buf[0] */

 fill sg descriptors - buf[1..n] */

 alloc a new sg buffer? */

 clear end sg element as a sentinel */

 unwind the frag mappings and the head mapping */

	/* clean the related q entries, there could be

	 * several q entries completed for each cq completion

 walk the not completed tx entries, if any */

	/* Preload inner-most TCP csum field with IP pseudo hdr

	 * calculated with IP length set to zero.  HW will later

	 * add in length to each TCP segment resulting from the TSO.

 use fragments until we have enough to post a single descriptor */

 if the fragment is exhausted then move to the next one */

 grab the next fragment */

 fill main descriptor */

 fill sg descriptor */

 post descriptor */

 Buffer information is stored with the first tso descriptor */

 set up the initial descriptor */

 add frags */

 Each desc is mss long max, so a descriptor for each gso_seg */

 If non-TSO, just need 1 desc and nr_frags sg elems */

 Too many frags, so linearize */

 Might race with ionic_tx_clean, check again */

	/* Does not stop/start txq, because we post to a separate tx queue

	 * for timestamping, and if a packet can't be posted immediately to

	 * the timestamping queue, it is dropped.

	/* Stop the queue if there aren't descriptors for the next packet.

	 * Since our SG lists per descriptor take care of most of the possible

	 * fragmentation, we don't need to have many descriptors available.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 1999 - 2010 Intel Corporation.

 * Copyright (C) 2010 OKI SEMICONDUCTOR Co., LTD.

 *

 * This code was derived from the Intel e1000e Linux driver.

 5 bit address bus (0-0x1F) */

 PHY 1000 MII Register/Bit Definitions */

 PHY Registers defined by IEEE */

 Control Register */

 Status Regiser */

 Phy Id Register (word 1) */

 Phy Id Register (word 2) */

 Autoneg Advertisement */

 Link Partner Ability (Base Page) */

 Autoneg Expansion Register */

 Next Page TX */

 Link Partner Next Page */

 1000Base-T Control Register */

 1000Base-T Status Register */

 Extended Status Register */

 PHY Specific Control Register */

 Extended PHY Specific Control Register */

 LED Control Register */

 Extended PHY Specific Status Register */

 PHY Control Register */

 bits 6,13: 10=1000, 01=100, 00=10 */

 Collision test enable */

 FDX =1, half duplex =0 */

 Restart auto negotiation */

 Isolate PHY from MII */

 Power down */

 Auto Neg Enable */

 bits 6,13: 10=1000, 01=100, 00=10 */

 0 = normal, 1 = loopback */

 0 = normal, 1 = PHY reset */

 PHY Status Register */

 Extended register capabilities */

 Jabber Detected */

 Link Status 1 = link */

 Auto Neg Capable */

 Remote Fault Detect */

 Auto Neg Complete */

 Preamble may be suppressed */

 Ext. status info in Reg 0x0F */

 100T2 Half Duplex Capable */

 100T2 Full Duplex Capable */

 10T   Half Duplex Capable */

 10T   Full Duplex Capable */

 100X  Half Duplex Capable */

 100X  Full Duplex Capable */

 100T4 Capable */

 AR8031 PHY Debug Registers */

 TX clock delay of 2.0ns */

 Hibernate enable */

 Phy Id Register (word 2) */

 PHY Specific Control Register */

 Default value of PHY register */

 Control Register */

 Autoneg Advertisement */

 Next Page TX */

 1000Base-T Control Register */

 PHY Specific Control Register */

/**

 * pch_gbe_phy_get_id - Retrieve the PHY ID and revision

 * @hw:	       Pointer to the HW structure

 * Returns

 *	0:			Successful.

 *	Negative value:		Failed.

	/*

	 * PHY_ID1: [bit15-0:ID(21-6)]

	 * PHY_ID2: [bit15-10:ID(5-0)][bit9-4:Model][bit3-0:revision]

/**

 * pch_gbe_phy_read_reg_miic - Read MII control register

 * @hw:	     Pointer to the HW structure

 * @offset:  Register offset to be read

 * @data:    Pointer to the read data

 * Returns

 *	0:		Successful.

 *	-EINVAL:	Invalid argument.

/**

 * pch_gbe_phy_write_reg_miic - Write MII control register

 * @hw:	     Pointer to the HW structure

 * @offset:  Register offset to be read

 * @data:    data to write to register at offset

 * Returns

 *	0:		Successful.

 *	-EINVAL:	Invalid argument.

/**

 * pch_gbe_phy_sw_reset - PHY software reset

 * @hw:	            Pointer to the HW structure

/**

 * pch_gbe_phy_hw_reset - PHY hardware reset

 * @hw:	   Pointer to the HW structure

/**

 * pch_gbe_phy_power_up - restore link in case the phy was powered down

 * @hw:	   Pointer to the HW structure

 Just clear the power down bit to wake the phy back up */

	/* according to the manual, the phy will retain its

/**

 * pch_gbe_phy_power_down - Power down PHY

 * @hw:	   Pointer to the HW structure

	/* Power down the PHY so no link is implied when interface is down *

	 * The PHY cannot be powered down if any of the following is TRUE *

	 * (a) WoL is enabled

	 * (b) AMT is active

/**

 * pch_gbe_phy_set_rgmii - RGMII interface setting

 * @hw:	            Pointer to the HW structure

/**

 * pch_gbe_phy_tx_clk_delay - Setup TX clock delay via the PHY

 * @hw:	            Pointer to the HW structure

 * Returns

 *	0:		Successful.

 *	-EINVAL:	Invalid argument.

	/* The RGMII interface requires a ~2ns TX clock delay. This is typically

	 * done in layout with a longer trace or via PHY strapping, but can also

	 * be done via PHY configuration registers.

/**

 * pch_gbe_phy_init_setting - PHY initial setting

 * @hw:	            Pointer to the HW structure

 Setup a TX clock delay on certain platforms */

/**

 * pch_gbe_phy_disable_hibernate - Disable the PHY low power state

 * @hw:	            Pointer to the HW structure

 * Returns

 *	0:		Successful.

 *	-EINVAL:	Invalid argument.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 1999 - 2010 Intel Corporation.

 * Copyright (C) 2010 OKI SEMICONDUCTOR Co., LTD.

 *

 * This code was derived from the Intel e1000e Linux driver.

 for __MODULE_STRING */

/*

 * TxDescriptors - Transmit Descriptor Count

 * @Valid Range:   PCH_GBE_MIN_TXD - PCH_GBE_MAX_TXD

 * @Default Value: PCH_GBE_DEFAULT_TXD

/*

 * RxDescriptors -Receive Descriptor Count

 * @Valid Range:   PCH_GBE_MIN_RXD - PCH_GBE_MAX_RXD

 * @Default Value: PCH_GBE_DEFAULT_RXD

/*

 * Speed - User Specified Speed Override

 * @Valid Range: 0, 10, 100, 1000

 *   - 0:    auto-negotiate at all supported speeds

 *   - 10:   only link at 10 Mbps

 *   - 100:  only link at 100 Mbps

 *   - 1000: only link at 1000 Mbps

 * @Default Value: 0

/*

 * Duplex - User Specified Duplex Override

 * @Valid Range: 0-2

 *   - 0:  auto-negotiate for duplex

 *   - 1:  only link at half duplex

 *   - 2:  only link at full duplex

 * @Default Value: 0

/*

 * AutoNeg - Auto-negotiation Advertisement Override

 * @Valid Range: 0x01-0x0F, 0x20-0x2F

 *

 *       The AutoNeg value is a bit mask describing which speed and duplex

 *       combinations should be advertised during auto-negotiation.

 *       The supported speed and duplex modes are listed below

 *

 *       Bit           7     6     5      4      3     2     1      0

 *       Speed (Mbps)  N/A   N/A   1000   N/A    100   100   10     10

 *       Duplex                    Full          Full  Half  Full   Half

 *

 * @Default Value: 0x2F (copper)

 Not used, just FYI */

/*

 * FlowControl - User Specified Flow Control Override

 * @Valid Range: 0-3

 *    - 0:  No Flow Control

 *    - 1:  Rx only, respond to PAUSE frames but do not generate them

 *    - 2:  Tx only, generate PAUSE frames but ignore them on receive

 *    - 3:  Full Flow Control Support

 * @Default Value: Read flow control settings from the EEPROM

/*

 * XsumRX - Receive Checksum Offload Enable/Disable

 * @Valid Range: 0, 1

 *    - 0:  disables all checksum offload

 *    - 1:  enables receive IP/TCP/UDP checksum offload

 * @Default Value: PCH_GBE_DEFAULT_RX_CSUM

 trueorfalse */

/*

 * XsumTX - Transmit Checksum Offload Enable/Disable

 * @Valid Range: 0, 1

 *    - 0:  disables all checksum offload

 *    - 1:  enables transmit IP/TCP/UDP checksum offload

 * @Default Value: PCH_GBE_DEFAULT_TX_CSUM

 trueorfalse */

/*

 * pch_gbe_option - Force the MAC's flow control settings

 * @hw:	            Pointer to the HW structure

 * Returns:

 *	0:			Successful.

 *	Negative value:		Failed.

 range_option info */

 list_option info */

/**

 * pch_gbe_validate_option - Validate option

 * @value:    value

 * @opt:      option

 * @adapter:  Board private structure

 * Returns:

 *	0:			Successful.

 *	Negative value:		Failed.

/**

 * pch_gbe_check_copper_options - Range Checking for Link Options, Copper Version

 * @adapter:  Board private structure

 Speed */

 Duplex */

 Autoneg */

/**

 * pch_gbe_check_options - Range Checking for Command Line Parameters

 * @adapter:  Board private structure

 Transmit Descriptor Count */

 Receive Descriptor Count */

 Checksum Offload Enable/Disable */

 Checksum Offload Enable/Disable */

 Flow Control */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 1999 - 2010 Intel Corporation.

 * Copyright (C) 2010 - 2012 LAPIS SEMICONDUCTOR CO., LTD.

 *

 * This code was derived from the Intel e1000e Linux driver.

 watchdog time */

 2MB */

 Initialize the wake-on-LAN settings */

 Ethertype field values */

 Pause packet value */

/* This defines the bits that are set in the Interrupt Mask

 * Set/Read Register.  Each bit is documented below:

 *   o RXT0   = Receiver Timer Interrupt (ring 0)

 *   o TXDW   = Transmit Descriptor Written Back

 *   o RXDMT0 = Receive Descriptor Minimum Threshold hit (ring 0)

 *   o RXSEQ  = Receive Sequence Error

 *   o LSC    = Link Status Change

 Macros for ieee1588 */

 0x40 Time Synchronization Channel Control Register Bits */

 0x44 Time Synchronization Channel Event Register Bits */

 Get ieee1588's dev information */

 Get ieee1588's dev information */

	/*

	 * This really stinks, but we have to poll for the Tx time stamp.

 reserved for future extensions */

 Get ieee1588's dev information */

 Clear out any old time stamps. */

/**

 * pch_gbe_mac_read_mac_addr - Read MAC address

 * @hw:	            Pointer to the HW structure

 * Returns:

 *	0:			Successful.

/**

 * pch_gbe_wait_clr_bit - Wait to clear a bit

 * @reg:	Pointer of register

 * @bit:	Busy bit

 wait busy */

/**

 * pch_gbe_mac_mar_set - Set MAC address register

 * @hw:	    Pointer to the HW structure

 * @addr:   Pointer to the MAC address

 * @index:  MAC address array register

	/*

	 * HW expects these in little endian so we reverse the byte order

	 * from network order (big endian) to little endian

 Stop the MAC Address of index. */

 wait busy */

 Set the MAC address to the MAC address 1A/1B register */

 Start the MAC address of index */

 wait busy */

/**

 * pch_gbe_mac_reset_hw - Reset hardware

 * @hw:	Pointer to the HW structure

 Read the MAC address. and store to the private data */

 Setup the receive addresses */

 Disables Receive MAC */

 Enables Receive MAC */

/**

 * pch_gbe_mac_init_rx_addrs - Initialize receive address's

 * @hw:	Pointer to the HW structure

 * @mar_count: Receive address registers

 Setup the receive address */

 Zero out the other receive addresses */

 wait busy */

/**

 * pch_gbe_mac_force_mac_fc - Force the MAC's flow control settings

 * @hw:	            Pointer to the HW structure

 * Returns:

 *	0:			Successful.

 *	Negative value:		Failed.

/**

 * pch_gbe_mac_set_wol_event - Set wake-on-lan event

 * @hw:     Pointer to the HW structure

 * @wu_evt: Wake up event

 Set Wake-On-Lan address mask */

 wait busy */

/**

 * pch_gbe_mac_ctrl_miim - Control MIIM interface

 * @hw:   Pointer to the HW structure

 * @addr: Address of PHY

 * @dir:  Operetion. (Write or Read)

 * @reg:  Access register of PHY

 * @data: Write data.

 *

 * Returns: Read date.

 No way to indicate timeout error */

/**

 * pch_gbe_mac_set_pause_packet - Set pause packet

 * @hw:   Pointer to the HW structure

 Set Pause packet */

 Transmit Pause Packet */

/**

 * pch_gbe_alloc_queues - Allocate memory for all rings

 * @adapter:  Board private structure to initialize

 * Returns:

 *	0:	Successfully

 *	Negative value:	Failed

/**

 * pch_gbe_init_stats - Initialize status

 * @adapter:  Board private structure to initialize

/**

 * pch_gbe_init_phy - Initialize PHY

 * @adapter:  Board private structure to initialize

 * Returns:

 *	0:	Successfully

 *	Negative value:	Failed

 Discover phy addr by searching addrs in order {1,0,2,..., 31} */

 Selected the phy and isolate the rest */

 MII setup */

/**

 * pch_gbe_mdio_read - The read function for mii

 * @netdev: Network interface device structure

 * @addr:   Phy ID

 * @reg:    Access location

 * Returns:

 *	0:	Successfully

 *	Negative value:	Failed

/**

 * pch_gbe_mdio_write - The write function for mii

 * @netdev: Network interface device structure

 * @addr:   Phy ID (not used)

 * @reg:    Access location

 * @data:   Write data

/**

 * pch_gbe_reset_task - Reset processing at the time of transmission timeout

 * @work:  Pointer of board private structure

/**

 * pch_gbe_reinit_locked- Re-initialization

 * @adapter:  Board private structure

/**

 * pch_gbe_reset - Reset GbE

 * @adapter:  Board private structure

 reprogram multicast address register after reset */

 Setup the receive address. */

 Setup Mac interface option RGMII */

/**

 * pch_gbe_free_irq - Free an interrupt

 * @adapter:  Board private structure

/**

 * pch_gbe_irq_disable - Mask off interrupt generation on the NIC

 * @adapter:  Board private structure

/**

 * pch_gbe_irq_enable - Enable default interrupt generation settings

 * @adapter:  Board private structure

/**

 * pch_gbe_setup_tctl - configure the Transmit control registers

 * @adapter:  Board private structure

/**

 * pch_gbe_configure_tx - Configure Transmit Unit after Reset

 * @adapter:  Board private structure

 Setup the HW Tx Head and Tail descriptor pointers */

 Enables Transmission DMA */

/**

 * pch_gbe_setup_rctl - Configure the receive control registers

 * @adapter:  Board private structure

/**

 * pch_gbe_configure_rx - Configure Receive Unit after Reset

 * @adapter:  Board private structure

 Disables Receive DMA */

	/* Setup the HW Rx Head and Tail Descriptor Pointers and

/**

 * pch_gbe_unmap_and_free_tx_resource - Unmap and free tx socket buffer

 * @adapter:     Board private structure

 * @buffer_info: Buffer information structure

/**

 * pch_gbe_unmap_and_free_rx_resource - Unmap and free rx socket buffer

 * @adapter:      Board private structure

 * @buffer_info:  Buffer information structure

/**

 * pch_gbe_clean_tx_ring - Free Tx Buffers

 * @adapter:  Board private structure

 * @tx_ring:  Ring to be cleaned

 Free all the Tx ring sk_buffs */

 Zero out the descriptor ring */

/**

 * pch_gbe_clean_rx_ring - Free Rx Buffers

 * @adapter:  Board private structure

 * @rx_ring:  Ring to free buffers from

 Free all the Rx ring sk_buffs */

 Zero out the descriptor ring */

 Set the RGMII control. */

 Set the communication mode */

/**

 * pch_gbe_watchdog - Watchdog process

 * @t:  timer list containing a Board private structure

 mii library handles link maintenance tasks */

 Set the RGMII control. */

 Set the communication mode */

/**

 * pch_gbe_tx_queue - Carry out queuing of the transmission data

 * @adapter:  Board private structure

 * @tx_ring:  Tx descriptor ring structure

 * @skb:      Sockt buffer structure

-- Set frame control --*/

 Performs checksum processing */

	/*

	 * It is because the hardware accelerator does not support a checksum,

	 * when the received data size is less than 64 bytes.

 [Header:14][payload] ---> [Header:14][paddong:2][payload]    */

-- Set Buffer information --*/

-- Set Tx descriptor --*/

 Update software pointer of TX descriptor */

/**

 * pch_gbe_update_stats - Update the board statistics counters

 * @adapter:  Board private structure

	/*

	 * Prevent stats update while adapter is being reset, or if the pci

	 * connection is down.

 Update device status "adapter->stats" */

 Update network device status "adapter->net_stats" */

 Fill out the OS statistics structure */

 Rx Errors */

 Tx Errors */

 Disable Receive DMA */

 Enables Receive DMA */

/**

 * pch_gbe_intr - Interrupt Handler

 * @irq:   Interrupt number

 * @data:  Pointer to a network interface device structure

 * Returns:

 *	- IRQ_HANDLED:	Our interrupt

 *	- IRQ_NONE:	Not our interrupt

 Check request status */

 When request status is no interruption factor */

 Not our interrupt. End processing. */

 When Rx descriptor is empty  */

 Set Pause packet */

 When request status is Receive interruption */

 Enable only Rx Descriptor empty */

 Start polling for NAPI */

/**

 * pch_gbe_alloc_rx_buffers - Replace used receive buffers; legacy & extended

 * @adapter:       Board private structure

 * @rx_ring:       Rx descriptor ring

 * @cleaned_count: Cleaned count

 Better luck next round */

 align */

 while !buffer_info->skb */

/**

 * pch_gbe_alloc_tx_buffers - Allocate transmit buffers

 * @adapter:   Board private structure

 * @tx_ring:   Tx descriptor ring

/**

 * pch_gbe_clean_tx - Reclaim resources after transmit completes

 * @adapter:   Board private structure

 * @tx_ring:   Tx descriptor ring

 * Returns:

 *	true:  Cleaned the descriptor

 *	false: Not cleaned the descriptor

 current marked clean, tx queue filling up, do extra clean */

 tx queue nearly full */

 current marked clean, scan for more that need cleaning. */

found*/

increment, wrap*/

found one to clean, usu gbec_status==2000.*/

 weight of a sort for tx, to avoid endless transmit cleanup */

skip this if nothing cleaned*/

 Recover from running out of Tx resources in xmit_frame */

/**

 * pch_gbe_clean_rx - Send received data up the network stack; legacy

 * @adapter:     Board private structure

 * @rx_ring:     Rx descriptor ring

 * @work_done:   Completed count

 * @work_to_do:  Request count

 * Returns:

 *	true:  Cleaned the descriptor

 *	false: Not cleaned the descriptor

 Check Rx descriptor status */

 unmap dma */

 Error check */

 get receive length */

 length convert[-3], length includes FCS length */

			/*

			 * buffer_info->rx_buffer: [Header:14][payload]

			 * skb->data: [Reserve:2][Header:14][payload]

 update status of driver */

 Write meta date of skb */

 return some buffers to hardware, one at a time is too slow */

/**

 * pch_gbe_setup_tx_resources - Allocate Tx resources (Descriptors)

 * @adapter:  Board private structure

 * @tx_ring:  Tx descriptor ring (for a specific queue) to setup

 * Returns:

 *	0:		Successfully

 *	Negative value:	Failed

/**

 * pch_gbe_setup_rx_resources - Allocate Rx resources (Descriptors)

 * @adapter:  Board private structure

 * @rx_ring:  Rx descriptor ring (for a specific queue) to setup

 * Returns:

 *	0:		Successfully

 *	Negative value:	Failed

/**

 * pch_gbe_free_tx_resources - Free Tx Resources

 * @adapter:  Board private structure

 * @tx_ring:  Tx descriptor ring for a specific queue

/**

 * pch_gbe_free_rx_resources - Free Rx Resources

 * @adapter:  Board private structure

 * @rx_ring:  Ring to clean the resources from

/**

 * pch_gbe_request_irq - Allocate an interrupt line

 * @adapter:  Board private structure

 * Returns:

 *	0:		Successfully

 *	Negative value:	Failed

/**

 * pch_gbe_up - Up GbE network device

 * @adapter:  Board private structure

 * Returns:

 *	0:		Successfully

 *	Negative value:	Failed

 Ensure we have a valid MAC */

 hardware has been reset, we need to reload some things */

/**

 * pch_gbe_down - Down GbE network device

 * @adapter:  Board private structure

	/* signal that we're down so the interrupt handler does not

/**

 * pch_gbe_sw_init - Initialize general software structures (struct pch_gbe_adapter)

 * @adapter:  Board private structure to initialize

 * Returns:

 *	0:		Successfully

 *	Negative value:	Failed

/**

 * pch_gbe_open - Called when a network interface is made active

 * @netdev:	Network interface device structure

 * Returns:

 *	0:		Successfully

 *	Negative value:	Failed

 allocate transmit descriptors */

 allocate receive descriptors */

/**

 * pch_gbe_stop - Disables a network interface

 * @netdev:  Network interface device structure

 * Returns:

 *	0: Successfully

/**

 * pch_gbe_xmit_frame - Packet transmitting start

 * @skb:     Socket buffer structure

 * @netdev:  Network interface device structure

 * Returns:

 *	- NETDEV_TX_OK:   Normal end

 *	- NETDEV_TX_BUSY: Error end

 CRC,ITAG no support */

/**

 * pch_gbe_set_multi - Multicast and Promiscuous mode set

 * @netdev:   Network interface device structure

 By default enable address & multicast filtering */

 Promiscuous mode disables all hardware address filtering */

	/* If we want to monitor more multicast addresses than the hardware can

	 * support then disable hardware multicast filtering.

	/* If we're not using multicast filtering then there's no point

	 * configuring the unused MAC address registers.

	/* Load the first set of multicast addresses into MAC address registers

	 * for use by hardware filtering.

 If there are spare MAC registers, mask & clear them */

 Clear MAC address mask */

 wait busy */

 Clear MAC address */

/**

 * pch_gbe_set_mac - Change the Ethernet Address of the NIC

 * @netdev: Network interface device structure

 * @addr:   Pointer to an address structure

 * Returns:

 *	0:		Successfully

 *	-EADDRNOTAVAIL:	Failed

/**

 * pch_gbe_change_mtu - Change the Maximum Transfer Unit

 * @netdev:   Network interface device structure

 * @new_mtu:  New value for maximum frame size

 * Returns:

 *	0:		Successfully

 *	-EINVAL:	Failed

/**

 * pch_gbe_set_features - Reset device after features changed

 * @netdev:   Network interface device structure

 * @features:  New features

 * Returns:

 *	0:		HW state updated successfully

/**

 * pch_gbe_ioctl - Controls register through a MII interface

 * @netdev:   Network interface device structure

 * @ifr:      Pointer to ifr structure

 * @cmd:      Control command

 * Returns:

 *	0:	Successfully

 *	Negative value:	Failed

/**

 * pch_gbe_tx_timeout - Respond to a Tx Hang

 * @netdev:   Network interface device structure

 * @txqueue: index of hanging queue

 Do the reset outside of interrupt context */

/**

 * pch_gbe_napi_poll - NAPI receive and transfer polling callback

 * @napi:    Pointer of polling device struct

 * @budget:  The maximum number of a packet

 * Returns:

 *	false:  Exit the polling mode

 *	true:   Continue the polling mode

	/* If no Tx and not enough Rx work done,

	 * exit the polling mode

/**

 * pch_gbe_netpoll - Used by things like netconsole to send skbs

 * @netdev:  Network interface device structure

 Request a slot slot reset. */

 Clear wake up status */

 Clear wake on lan control and status */

 CONFIG_PM */

 MTU range: 46 - 10300 */

 setup the private structure */

 Initialize PHY */

 Read the MAC address. and store to the private data */

		/*

		 * If the MAC is invalid (or just missing), display a warning

		 * but do not abort setting up the device. pch_gbe_up will

		 * prevent the interface from being brought up until a valid MAC

		 * is set.

 initialize the wol settings based on the eeprom settings */

 reset the hardware with the new settings */

 tell the stack to leave us alone until pch_gbe_open() is called */

 Disable hibernation on certain platforms */

/* The AR803X PHY on the MinnowBoard requires a physical pin to be toggled to

 * ensure it is awake for probe and init. Request the line and reset the PHY.

 required last entry */

 pch_gbe_main.c */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 1999 - 2010 Intel Corporation.

 * Copyright (C) 2010 OKI SEMICONDUCTOR Co., LTD.

 *

 * This code was derived from the Intel e1000e Linux driver.

/*

 * pch_gbe_stats - Stats item information

/*

 * pch_gbe_gstrings_stats - ethtool information status name list

/**

 * pch_gbe_get_link_ksettings - Get device-specific settings

 * @netdev: Network interface device structure

 * @ecmd:   Ethtool command

 * Returns:

 *	0:			Successful.

 *	Negative value:		Failed.

/**

 * pch_gbe_set_link_ksettings - Set device-specific settings

 * @netdev: Network interface device structure

 * @ecmd:   Ethtool command

 * Returns:

 *	0:			Successful.

 *	Negative value:		Failed.

	/* when set_settings() is called with a ethtool_cmd previously

 reset the link */

/**

 * pch_gbe_get_regs_len - Report the size of device registers

 * @netdev: Network interface device structure

 * Returns: the size of device registers.

/**

 * pch_gbe_get_drvinfo - Report driver information

 * @netdev:  Network interface device structure

 * @drvinfo: Driver information structure

/**

 * pch_gbe_get_regs - Get device registers

 * @netdev: Network interface device structure

 * @regs:   Ethtool register structure

 * @p:      Buffer pointer of read device register date

 PHY register */

/**

 * pch_gbe_get_wol - Report whether Wake-on-Lan is enabled

 * @netdev: Network interface device structure

 * @wol:    Wake-on-Lan information

/**

 * pch_gbe_set_wol - Turn Wake-on-Lan on or off

 * @netdev: Network interface device structure

 * @wol:    Pointer of wake-on-Lan information straucture

 * Returns:

 *	0:			Successful.

 *	Negative value:		Failed.

 these settings will always override what we currently have */

/**

 * pch_gbe_nway_reset - Restart autonegotiation

 * @netdev: Network interface device structure

 * Returns:

 *	0:			Successful.

 *	Negative value:		Failed.

/**

 * pch_gbe_get_ringparam - Report ring sizes

 * @netdev:  Network interface device structure

 * @ring:    Ring param structure

/**

 * pch_gbe_set_ringparam - Set ring sizes

 * @netdev:  Network interface device structure

 * @ring:    Ring param structure

 * Returns

 *	0:			Successful.

 *	Negative value:		Failed.

 Try to get new resources before deleting old */

/**

 * pch_gbe_get_pauseparam - Report pause parameters

 * @netdev:  Network interface device structure

 * @pause:   Pause parameters structure

/**

 * pch_gbe_set_pauseparam - Set pause parameters

 * @netdev:  Network interface device structure

 * @pause:   Pause parameters structure

 * Returns:

 *	0:			Successful.

 *	Negative value:		Failed.

/**

 * pch_gbe_get_strings - Return a set of strings that describe the requested

 *			 objects

 * @netdev:    Network interface device structure

 * @stringset: Select the stringset. [ETH_SS_TEST] [ETH_SS_STATS]

 * @data:      Pointer of read string data.

/**

 * pch_gbe_get_ethtool_stats - Return statistics about the device

 * @netdev: Network interface device structure

 * @stats:  Ethtool statue structure

 * @data:   Pointer of read status area

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * RDC R6040 Fast Ethernet MAC support

 *

 * Copyright (C) 2004 Sten Wang <sten.wang@rdc.com.tw>

 * Copyright (C) 2007

 *	Daniel Gimpelevich <daniel@gimpelevich.san-francisco.ca.us>

 * Copyright (C) 2007-2012 Florian Fainelli <f.fainelli@gmail.com>

 Time in jiffies before concluding the transmitter is hung. */

 RDC MAC I/O Size */

 MAX RDC MAC */

 MAC registers */

 Control register 0 */

 Receive enable */

 Promiscuous mode */

 Enable multicast hash table function */

 Transmission enable */

 Full/Half duplex */

 Control register 1 */

 Reset the MAC */

 Bus control */

 TX interrupt control */

 RX interrupt control */

 TX poll command register */

 Trigger MAC to transmit */

 RX buffer size */

 RX descriptor control */

 Last status */

 TX FIFO under-run */

 Transmit exceed collision */

 Transmit late collision */

 MDIO control register */

 MDIO write */

 MDIO read */

 MDIO read data register */

 MDIO write data register */

 TX descriptor start address 0 */

 TX descriptor start address 1 */

 RX descriptor start address 0 */

 RX descriptor start address 1 */

 Status register */

 INT enable register */

 Mask off interrupts */

 RX finished */

 No RX descriptor available */

 RX FIFO full */

 RX early */

 TX finished */

 TX early */

 Event counter overflow */

 PHY link changed */

 Event counter INT status */

 Event counter INT enable  */

 Successfully received packet counter */

 Event counter 0 */

 Event counter 1 */

 Event counter 2 */

 Event counter 3 */

 Successfully transmit packet counter */

 Event counter 4 */

 Pause frame counter register */

 Hash table 0 */

 Hash table 1 */

 Hash table 2 */

 Hash table 3 */

 Multicast address MID0 Low */

 Multicast address MID0 Medium */

 Multicast address MID0 High */

 MID1 Low */

 MID1 Medium */

 MID1 High */

 MID2 Low */

 MID2 Medium */

 MID2 High */

 MID3 Low */

 MID3 Medium */

 MID3 High */

 PHY status change configuration register */

 PHY status change enable */

 PHY address shift */

 Timer divider shift */

 PHY status register */

 MAC status machine */

 MAC status machine reset */

 MDC speed control register */

 Identifier register */

 TX descriptor count */

 RX descriptor count */

 MAC Bus Control Register */

 Max number multicast addresses to filter */

 Default MAC read/write operation timeout */

 Descriptor status */

 MAC is the owner of this descriptor */

 RX was successful */

 RX PHY error */

 RX dribble packet */

 RX length exceeds buffer size */

 RX length > maximum packet length */

 RX packet length < 64 byte */

 RX CRC error */

 RX broadcast (no error) */

 RX multicast (no error) */

 RX multicast hit in hash table (no error) */

 RX MID table hit (no error) */

 RX mask for the index of matched MIDx */

 RX and TX interrupts that we handle */

 0-3 */

 4-7 */

 8-B */

 C-F */

 10-13 */

 14-17 */

 18-1B */

 1C-1F */

 driver lock */

 Read a word data from PHY Chip */

 Wait for the read bit to be cleared */

 Write a word data from PHY Chip */

 Write the command to the MDIO bus */

 Wait for the write bit to be cleared */

 Allocate skbs for the rx descriptors */

 Deallocate all previously allocated skbs */

 Reset internal state machine */

 Restore MDIO clock frequency */

 Mask Off Interrupt */

 Reset RDC MAC */

 MAC Bus Control Register */

 Buffer Size Register */

 Write TX ring start address */

 Write RX ring start address */

 Set interrupt waiting time and packet numbers */

 Enable interrupts */

 Enable TX and RX */

	/* Let TX poll the descriptors

	 * we may got called by r6040_tx_timeout which has left

 Reset MAC and re-init all registers */

 Stop RDC MAC and Free the allocated resource */

 Stop MAC */

 Mask Off Interrupt */

 Reset RDC MAC */

 Restore MAC Address to MIDx */

 Free RX buffer */

 Free TX buffer */

 Free Descriptor memory */

 Limit not reached and the descriptor belongs to the CPU */

 Read the descriptor status */

 Global error status set */

 RX dribble */

 Buffer length exceeded */

 Packet too long */

 Packet < 64 bytes */

 CRC error */

 Packet successfully received */

 Do not count the CRC */

 Send to upper layer */

 put new skb into descriptor */

 put the descriptor back to the MAC */

 Check for errors */

 Not complete */

 Statistic Counter */

 Free buffer */

 To next descriptor */

 Enable RX/TX interrupt */

 The RDC interrupt handler. */

 Save MIER */

 Mask off RDC MAC interrupt */

 Read MISR status and clear */

 Restore RDC MAC interrupt */

 RX interrupt request */

 RX descriptor unavailable */

 Mask off RX interrupt */

 Restore RDC MAC interrupt */

 Init RDC MAC */

 Initialise and alloc RX/TX buffers */

 improve performance (by RDC guys) */

 Initialize all MAC registers */

 Read/set MAC address routines */

 Reset MAC */

 Restore MAC Address */

 Request IRQ and Register interrupt handler */

 Set MAC address */

 Allocate Descriptor memory */

 Critical Section */

 TX resource check */

 Set TX descriptor & Transmit it */

 Trigger the MAC to check the TX descriptor */

 If no tx resource, stop */

 Keep our MAC Address */

 Clear AMCP & PROM bits */

 Promiscuous mode */

	/* Enable multicast hash table function to

	/* Use internal multicast address registers if the number of

 Otherwise, Enable multicast hash table function. */

 Build multicast hash table */

 Fill the MAC hash tables with their values */

 reflect duplex change */

 this should always be supported */

 IO Size check */

	/* If PHY status change register is still set to zero it means the

	 * bootloader didn't initialize it, so we set it to:

	 * - enable phy status change

	 * - enable all phy addresses

 Init system & device */

 Set MAC address */

	/* Some bootloader/BIOSes do not initialize

 Link new device into r6040_root_dev */

 Init RDC private data */

 The RDC-specific entries in the device structure. */

 Register net device. After this dev->name assign */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Ethernet driver for the WIZnet W5300 chip.

 *

 * Copyright (C) 2008-2009 WIZnet Co.,Ltd.

 * Copyright (C) 2011 Taehun Kim <kth3321 <at> gmail.com>

 * Copyright (C) 2012 Mike Sinkovsky <msink@permonline.ru>

/*

 * Registers

 Mode Register */

 Data bus width */

 Mac layer pause frame */

 Write data fetch time */

 Read data hold time */

 FIFO swap */

 S/W reset */

 Ping block */

 Data bus swap */

 Indirect mode */

 Interrupt Register */

 Interrupt Mask Register */

 S0 interrupt */

 Source MAC address (0123) */

 Source MAC address (45) */

 Transmit Memory Size (0123) */

 Transmit Memory Size (4567) */

 Receive Memory Size (0123) */

 Receive Memory Size (4567) */

 Memory Type */

 Chip ID register */

 =0x5300 for WIZnet W5300 */

 S0 Mode Register */

 Close mode */

 MAC RAW mode (promiscuous) */

 MAC RAW mode (filtered) */

 S0 Command Register */

 OPEN command */

 CLOSE command */

 SEND command */

 RECV command */

 S0 Interrupt Mask Register */

 S0 Interrupt Register */

 Receive interrupt */

 Send OK interrupt */

 S0 Socket Status Register */

 S0 TX Write Size Register */

 S0 TX Free Size Register */

 S0 Received data Size */

 S0 Transmit FIFO */

 S0 Receive FIFO */

/*

 * Device driver private data structure

/************************************************************************

 *

 *  Lowlevel I/O functions

 *

/*

 * In direct address mode host system can directly access W5300 registers

 * after mapping to Memory-Mapped I/O space.

 *

 * 0x400 bytes are required for memory space.

/*

 * In indirect address mode host system indirectly accesses registers by

 * using Indirect Mode Address Register (IDM_AR) and Indirect Mode Data

 * Register (IDM_DR), which are directly mapped to Memory-Mapped I/O space.

 * Mode Register (MR) is directly accessible.

 *

 * Only 0x06 bytes are required for memory space.

 Indirect Mode Address */

 Indirect Mode Data */

 CONFIG_WIZNET_BUS_ANY */

	/* Configure 128K of internal memory

	 * as 64K RX fifo and 64K TX fifo

/***********************************************************************

 *

 *   Device driver functions / callbacks

 *

 cannot read TX_FIFO */

 cannot read RX_FIFO */

	/* This chip doesn't support VLAN packets with normal MTU,

	 * so disable VLAN for this device.

 CONFIG_PM_SLEEP */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Ethernet driver for the WIZnet W5100/W5200/W5500 chip.

 *

 * Copyright (C) 2016 Akinobu Mita <akinobu.mita@gmail.com>

 *

 * Datasheet:

 * http://www.wiznet.co.kr/wp-content/uploads/wiznethome/Chip/W5100/Document/W5100_Datasheet_v1.2.6.pdf

 * http://wiznethome.cafe24.com/wp-content/uploads/wiznethome/Chip/W5200/Documents/W5200_DS_V140E.pdf

 * http://wizwiki.net/wiki/lib/exe/fetch.php?media=products:w5500:w5500_ds_v106e_141230.pdf

 Serialize access to cmd_buf */

	/* DMA (thus cache coherency maintenance) requires the

	 * transfer buffers to live in their own cache lines.

 Serialize access to cmd_buf */

	/* DMA (thus cache coherency maintenance) requires the

	 * transfer buffers to live in their own cache lines.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Ethernet driver for the WIZnet W5100 chip.

 *

 * Copyright (C) 2006-2008 WIZnet Co.,Ltd.

 * Copyright (C) 2012 Mike Sinkovsky <msink@permonline.ru>

/*

 * W5100/W5200/W5500 common registers

 Mode Register */

 S/W reset */

 Ping block */

 Address Auto-Increment */

 Indirect mode */

 Source MAC address */

 Interrupt Register */

 Sn Mode Register */

 Sn Command Register */

 Sn Interrupt Register */

 Sn Status Register */

 Sn Transmit free memory size */

 Sn Transmit memory read pointer */

 Sn Transmit memory write pointer */

 Sn Receive free memory size */

 Sn Receive memory read pointer */

 MAC RAW mode */

 MAC Filter for W5100 and W5200 */

 MAC Filter for W5500 */

 OPEN command */

 CLOSE command */

 SEND command */

 RECV command */

 complete sending */

 receiving data */

 mac raw mode */

/*

 * W5100 and W5200 common registers

 Interrupt Mask Register */

 S0 interrupt */

 Retry Time-value Register */

 =0x07d0 (2000) */

/*

 * W5100 specific register and memory

 Receive Memory Size */

 Transmit Memory Size */

/*

 * W5200 specific register and memory

 Sn RX Memory Size */

 Sn TX Memory Size */

/*

 * W5500 specific register and memory

 *

 * W5500 register and memory are organized by multiple blocks.  Each one is

 * selected by 16bits offset address and 5bits block select bits.  So we

 * encode it into 32bits address. (lower 16bits is offset address and

 * upper 16bits is block select bits)

 Socket Interrupt Mask Register */

 Retry Time-value Register */

 Sn RX Memory Size */

 Sn TX Memory Size */

/*

 * Device driver private data structure

 Socket 0 register offset address */

 Socket 0 TX buffer offset address and size */

 Socket 0 RX buffer offset address and size */

/************************************************************************

 *

 *  Lowlevel I/O functions

 *

 Serialize access in indirect address mode */

/*

 * In direct address mode host system can directly access W5100 registers

 * after mapping to Memory-Mapped I/O space.

 *

 * 0x8000 bytes are required for memory space.

/*

 * In indirect address mode host system indirectly accesses registers by

 * using Indirect Mode Address Register (IDM_AR) and Indirect Mode Data

 * Register (IDM_DR), which are directly mapped to Memory-Mapped I/O space.

 * Mode Register (MR) is directly accessible.

 *

 * Only 0x04 bytes are required for memory space.

 Indirect Mode Address Register */

 Indirect Mode Data Register */

 CONFIG_WIZNET_BUS_ANY */

	/* Configure 16K of internal memory

	 * as 8K RX buffer and 8K TX buffer

	/* Configure internal RX memory as 16K RX buffer and

	 * internal TX memory as 16K TX buffer

	/* Configure internal RX memory as 16K RX buffer and

	 * internal TX memory as 16K TX buffer

/***********************************************************************

 *

 *   Device driver functions / callbacks

 *

	/* This chip doesn't support VLAN packets with normal MTU,

	 * so disable VLAN for this device.

 CONFIG_PM_SLEEP */

 SPDX-License-Identifier: GPL-2.0+

/*

 * Microchip ENC28J60 ethernet driver (MAC + PHY)

 *

 * Copyright (C) 2007 Eurek srl

 * Author: Claudio Lanconelli <lanconelli.claudio@eptar.com>

 * based on enc28j60.c written by David Anders for 2.4 kernel version

 *

 * $Id: enc28j60.c,v 1.22 2007/12/20 10:47:01 claudio Exp $

/* Buffer size required for the largest SPI transfer (i.e., reading a

 * frame).

 Max TX retries in case of collision as suggested by errata datasheet */

 Driver local data */

 current register bank selected */

 next packet pointer within FIFO */

 statistics: max packet counter */

 use ethtool to change the level for any given device */

/*

 * SPI read buffer

 * Wait for the SPI transfer and copy received data to destination.

/*

 * SPI write buffer

/*

 * basic SPI read operation

 do dummy read if needed */

/*

 * basic SPI write operation

	/* Errata workaround #1, CLKRDY check is unreliable,

/*

 * select the current register bank if necessary

	/* These registers (EIE, EIR, ESTAT, ECON2, ECON1)

	 * are present in all banks, no need to switch bank.

 Clear or set each bank selection bit as needed */

/*

 * Register access routines through the SPI bus.

 * Every register access comes in two flavours:

 * - nolock_xxx: caller needs to invoke mutex_lock, usually to access

 *   atomically more than one register

 * - locked_xxx: caller doesn't need to invoke mutex_lock, single access

 *

 * Some registers can be accessed through the bit field clear and

 * bit field set to avoid a read modify write cycle.

/*

 * Register bit field Set

/*

 * Register bit field Clear

/*

 * Register byte read

/*

 * Register word read

/*

 * Register byte write

/*

 * Register word write

/*

 * Buffer memory read

 * Select the starting address and execute a SPI buffer read.

/*

 * Write packet to enc28j60 TX buffer memory

 Set the write pointer to start of transmit buffer area */

 Set the TXND pointer to correspond to the packet size given */

 write per-packet control byte */

 copy the packet into the transmit buffer */

 20 msec timeout read */

/*

 * Wait until the PHY operation is complete.

/*

 * PHY register read

 * PHY registers are not accessed directly, but through the MII.

 set the PHY register address */

 start the register read operation */

 wait until the PHY read completes */

 quit reading */

 return the data */

 set the PHY register address */

 write the PHY data */

 wait until the PHY write completes and return */

/*

 * Program the hardware MAC address from dev->dev_addr.

 NOTE: MAC address in ENC28J60 is byte-backward */

/*

 * Store the new hardware address in dev->dev_addr, and update the MAC.

/*

 * Debug routine to dump useful register contents

/*

 * ERXRDPT need to be set always at odd addresses, refer to errata datasheet

/*

 * Calculate wrap around when reading beyond the end of the RX buffer

 set receive buffer start + end */

 set transmit buffer start + end */

/*

 * Low power mode shrinks power consumption about 100x, so we'd like

 * the chip to be in that mode whenever it's inactive. (However, we

 * can't stay in low power mode during suspend with WOL active.)

 ECON2_VRPS was set during initialization */

 caller sets ECON1_RXEN */

 first reset the chip */

 Clear ECON1 */

 enable address auto increment and voltage regulator powersave */

	/*

	 * Check the RevID.

	 * If it's 0x00 or 0xFF probably the enc28j60 is not mounted or

	 * damaged.

 default filter mode: (unicast OR broadcast) AND crc valid */

 enable MAC receive */

 enable automatic padding and CRC operations */

 set inter-frame gap (non-back-to-back) */

 set inter-frame gap (back-to-back) */

 DEFER bit */

 set inter-frame gap (non-back-to-back) */

 set inter-frame gap (back-to-back) */

	/*

	 * MACLCON1 (default)

	 * MACLCON2 (default)

	 * Set the maximum packet size which the controller will accept.

 Configure LEDs */

 enable interrupts */

 enable receive logic */

 disable interrupts and packet reception */

		/* link is in low power mode now; duplex setting

		 * will take effect on next enc28j60_hw_init().

/*

 * Read the Transmit Status Vector

/*

 * Receive Status vector

/*

 * Hardware receive function.

 * Read the buffer memory, update the FIFO pointer to free the buffer,

 * check the status vector and decrement the packet counter.

 packet address corrupted: reset RX logic */

 Read next packet pointer and rx status vector */

 copy the packet from the receive buffer */

 update statistics */

	/*

	 * Move the RX read pointer to the start of the next

	 * received packet.

	 * This frees the memory we just read out.

 we are done with this packet, decrement the packet counter */

/*

 * Calculate free space in RxFIFO

/*

 * Access the PHY to determine link status

/*

 * RX handler

 * Ignore PKTIF because is unreliable! (Look at the errata datasheet)

 * Check EPKTCNT is the suggested workaround.

 * We don't need to clear interrupt flag, automatically done when

 * enc28j60_hw_rx() decrements the packet counter.

 * Returns how many packet processed.

 update statistics */

 disable further interrupts */

 DMA interrupt handler (not currently used) */

 LINK changed handler */

 read PHIR to clear the flag */

 TX complete handler */

 TX Error handler */

 Reset TX logic */

 Transmit Late collision check for retransmit */

 RX Error handler */

 Check free FIFO space to flag RX overrun */

 RX handler */

 re-enable interrupts */

/*

 * Hardware transmit function.

 * Fill the buffer memory and send the contents of the transmit buffer

 * onto the network

 readback and verify written data */

 limit the test to the first 64 bytes */

 + 1 to skip control byte */

 set TX request flag */

	/* If some error occurs while trying to transmit this

	 * packet, you should return '1' from this function.

	 * In such a case you _may not_ do anything to the

	 * SKB, it is still owned by the network queueing

	 * layer when an error is returned. This means you

	 * may not modify any SKB fields, you may not free

	 * the SKB, etc.

 Remember the skb for deferred processing */

 actual delivery of data */

	/*

	 * Can't do anything in interrupt context because we need to

	 * block (spi_sync() is blocking) so fire of the interrupt

	 * handling workqueue.

	 * Remember that we access enc28j60 registers through SPI bus

	 * via spi_sync() call.

 can't restart safely under softirq */

/*

 * Open/initialize the board. This is called (in the current kernel)

 * sometime after booting when the 'ifconfig' program is run.

 *

 * This routine should set everything up anew at each open, even

 * registers that "should" only need to be set once at boot, so that

 * there is non-reboot way to recover if something goes wrong.

 Reset the hardware here (and take it out of low power mode) */

 Update the MAC address (in case user has changed it) */

 Enable interrupts */

 check link status */

	/* We are now ready to accept transmit requests from

	 * the queueing layer of the networking.

 The inverse routine to net_open(). */

/*

 * Set or clear the multicast filter for this adapter

 * num_addrs == -1	Promiscuous mode, receive all packets

 * num_addrs == 0	Normal mode, filter out multicast packets

 * num_addrs > 0	Multicast mode, receive normal and MC packets

 ......................... ETHTOOL SUPPORT ........................... */

 priv to netdev reference */

 priv to spi reference */

 spi to priv reference */

	/* Board setup must set the relevant edge trigger type;

	 * level triggers won't currently work.

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0+ */

 Copyright (C) 2018 Microchip Technology Inc. */

 disable the interrupt to prevent repeated re-triggering */

 poll func will enable later */

 enable isr */

 poll funct will enable later */

 enable isr */

 use mask as implied status */

 disable vector interrupt */

 disable master interrupt */

  use vector mask as implied enable mask */

 disable interrupts on this vector */

 enable master interrupt */

 enable vector interrupt */

 enable and activate test interrupt */

 disable test interrupt */

 Try to set up MSIX interrupts */

 If MSIX failed try to setup using MSI interrupts */

 If MSIX, and MSI failed, setup using legacy interrupt */

 At this point we must have at least one irq */

 map all interrupts to vector 0 */

 enable interrupts */

 map TX interrupt to vector */

 Remove TX interrupt from shared mask */

 map RX interrupt to vector */

 Remove RX interrupt from shared mask */

 comfirm MII not busy */

 set the address, index & direction (read from PHY) */

 confirm MII not busy */

 set the address, index & direction (write to PHY) */

 disable auto duplex, and speed detection. Phylib does that */

	/* set maximum pause time because when fifo space frees

	 * up a zero value pause frame will be sent to release the pause

 PHY */

 Only called with in probe, and before mdiobus_register */

 set interface mode */

 RGMII */

 GMII */

 set duplex mode */

 set bus speed */

 try devicetree phy, or fixed link */

 try internal phy */

 MAC doesn't support 1000T Half */

 support both flow controls */

 Add mac address to perfect Filter */

 set first 32 into Perfect Filter */

 1 for the main skb buffer */

 requires an extension descriptor */

 1 for each fragment buffer */

	/* called only from within lan743x_tx_xmit_frame.

	 * assuming tx->ring_lock has already been acquired.

 data0 will be programmed in one of other frame assembler functions */

	/* called only from within lan743x_tx_xmit_frame.

	 * assuming tx->ring_lock has already been acquired.

 wrap up previous descriptor */

 move to next descriptor */

 add extension descriptor */

 data0 will be programmed in one of other frame assembler functions */

	/* called only from within lan743x_tx_xmit_frame

	 * assuming tx->ring_lock has already been acquired

 wrap up previous descriptor */

 move to next descriptor */

 cleanup all previously setup descriptors */

 data0 will be programmed in one of other frame assembler functions */

	/* called only from within lan743x_tx_xmit_frame

	 * assuming tx->ring_lock has already been acquired

 wrap up previous descriptor */

 save to overflow buffer */

 space available, transmit skb  */

			/* upon error no need to call

			 *	lan743x_tx_frame_end

			 * frame assembler clean up was performed inside

			 *	lan743x_tx_frame_add_fragment

 clean up tx ring */

 space is now available, transmit overflow skb */

 enable isr */

 initialize fifo */

 enable fifo */

 reset tx channel */

 Write TX_BASE_ADDR */

 Write TX_CFG_B */

 Write TX_CFG_A */

 Write TX_HEAD_WRITEBACK_ADDR */

 set last head */

 write TX_TAIL */

  start dmac channel */

 update the tail once per 8 descriptors */

 sync used area of buffer only */

			/* frame length is valid only if LS bit is set.

			 * it's a safe upper bound for the used area in this

			 * buffer.

 extension is expected to follow */

 extension not yet available */

 extension not yet available */

	/* Only the last buffer in a multi-buffer frame contains the total frame

	 * length. The chip occasionally sends more buffers than strictly

	 * required to reach the total frame length.

	 * Handle this by adding all buffers to the skb in their entirety.

	 * Once the real frame length is known, trim the skb.

 save existing skb, allocate new skb and map to dma */

		/* failed to allocate next skb.

		 * Memory is very low.

		 * Drop this packet and reuse buffer.

 drop packet that was being assembled */

 add buffers to skb via skb->frag_list */

		/* packet to assemble has already been dropped because one or

		 * more of its buffers could not be allocated

 push tail and head forward */

 clear int status bit before reading packet */

 re-arm interrupts, must write to rx tail on some chip variants */

 set ring base address */

 set rx write back address */

 set RX_CFG_A */

 set RX_CFG_B */

 set RX_CFG_C */

 initialize fifo */

 enable fifo */

 LAN7430 uses internal phy at address 1 */

 register mdiobus */

/* lan743x_pcidev_probe - Device Initialization Routine

 * @pdev: PCI device information struct

 * @id: entry in lan743x_pci_tbl

 *

 * Returns 0 on success, negative on failure

 *

 * initializes an adapter identified by a pci_dev structure.

 * The OS initialization, configuring of the adapter private structure,

 * and a hardware reset occur.

 carrier off reporting is important to ethtool even BEFORE open */

/**

 * lan743x_pcidev_remove - Device Removal Routine

 * @pdev: PCI device information struct

 *

 * this is called by the PCI subsystem to alert the driver

 * that it should release a PCI device.  This could be caused by a

 * Hot-Plug event, or because the driver is going to be removed from

 * memory.

	/* close netdev when netdev is at running state.

	 * For instance, it is true when system goes to sleep by pm-suspend

	 * However, it is false when system goes to sleep by suspend GUI menu

 clean up lan743x portion */

 clear wake settings */

 IPv4 multicast */

 IPv6 multicast */

		/* set MAC_WUF_CFG & WUF_MASK

		 * for packettype (offset 12,13) = ARP (0x0806)

 clear all wakes */

 Host sets PME_En, put D3hot */

	/* open netdev when netdev is at running state while resume.

	 * For instance, it is true when system wakesup after pm-suspend

	 * However, it is false when system wakes up after suspend GUI menu

 CONFIG_PM_SLEEP */

 SPDX-License-Identifier: GPL-2.0+ */

 Copyright (C) 2018 Microchip Technology Inc. */

 LED0 offset in HW_CFG */

 set all direction to input, data = 0 */

 disable all gpio, set to open drain */

 set all to 1588 low polarity level */

 disable all 1588 output */

 shift queue */

 assign pin to GPIO function */

 set as output, and zero initial value */

 enable gpio, and set buffer type to push pull */

 set 1588 polarity to high */

 use channel A */

 use channel B */

 disable ptp output */

 release gpio output */

 disable gpio */

 reset back to input */

 assign pin to original function */

 set target to far in the future, effectively disabling it */

 Reject requests with unsupported flags */

 already on, turn off first */

		/* Check if we can do 50% toggle on an even value of period.

		 * If the period number is odd, then check if the requested

		 * pulse width is the same as one of pre-defined width values.

		 * Otherwise, return failure.

 It's 50% match. Use the toggle option */

 In this case, devide period value by 2 */

 if we can't do toggle, then the width option needs to be the exact match */

 turn off by setting target far in future */

 Configure to pulse every period */

 set the reload to one toggle cycle */

 set the start time */

	/* Confirm the requested function is supported. Parameter

	 * validation is done by the caller.

 convert to clock set */

 convert to clock set */

 do clock step */

			/* subtracting nano seconds is not allowed

			 * convert to subtracting from seconds,

			 * and adding to nanoseconds

 add 8 ns to cover the likely normal increment */

 carry into seconds */

 tasklet will re-enable later */

 clear int status bit */

 clear int status bit */

 clear int status bit */

 re-enable isr */

		/* this should never happen, so long as the tx channel

		 * calls and honors the result from

		 * lan743x_ptp_request_tx_timestamp

 clean up pending timestamp requests */

 request granted */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Microchip ENCX24J600 ethernet driver

 *

 * Copyright (C) 2015 Gridpoint

 * Author: Jon Ringle <jringle@gridpoint.com>

/* SRAM memory layout:

 *

 * 0x0000-0x05ff TX buffers  1.5KB  (1*1536) reside in the GP area in SRAM

 * 0x0600-0x5fff RX buffers 22.5KB (15*1536) reside in the RX area in SRAM

 device access lock */

 Waits for autonegotiation to complete. */

 Max retransmittions attempt  */

 Access the PHY to determine link status */

		/* Re-enable autoneg since we won't know what we might be

		 * connected to when the link is brought back up again.

 Maintain stats */

 Clear interrupts */

 Packet counter is full */

 Enable interrupts */

 Write and verify a test value to EUDAST */

 Wait for CLKRDY to become set */

 Issue a System Reset command */

 Confirm that EUDAST has 0000h after system reset */

 Wait for PHY register and status bits to become available */

 Reset TX */

 Clear the TXIF flag if were previously set */

 Write the Tx Buffer pointer */

 Set up RX packet start address in the SRAM */

 Preload the RX Data pointer to the beginning of the RX area */

 Set up RX end address in the SRAM */

 Reset the  user data pointers    */

 Set Max Frame length */

 CHIP configuration */

 MAC layer configuration */

 PHY configuation */

	/* PHY Leds: link status,

	 * LEDA: Link State + collision events

	 * LEDB: Link State + transmit/receive events

 Loopback disabled */

 interpacket gap value */

 Write the auto negotiation pattern */

 Program the Maximum frame length */

 Init Tx pointers */

 Init Rx pointers */

 Clear the interrupt flags in case was set */

 Enable the interrupts */

 Enable RX */

 Disable all interrupts */

 Disable RX */

		/* link is in low power mode now; duplex setting

		 * will take effect on next encx24j600_hw_init()

speeds other than SPEED_10 and SPEED_100 */

are not supported by chip */

 Program the hardware MAC address from dev->dev_addr.*/

 Store the new hardware address in dev->dev_addr, and update the MAC.*/

 Last transmition aborted due to error. Reset TX interface */

 Clear the TXIF flag if were previously set */

 Set the data pointer to the TX buffer address in the SRAM */

 Copy the packet into the SRAM */

 Program the Tx buffer start pointer */

 Program the packet length */

 Start the transmission */

 save the timestamp */

 Remember the skb for deferred processing */

 Deal with a transmit timeout */

 ignore errors for unreadable registers */

 Default configuration PHY configuration */

 Reset device and check if it is connected */

 Initialize the device HW to the consistent state */

 Get the MAC address from the chip */

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0+ */

 Copyright (C) 2018 Microchip Technology Inc. */

 eeprom */

 clear it and wait to be cleared */

 set power down bit */

 set to BYTE program mode */

 Issue write/erase enable command */

 Fill data register */

 Send "write" command */

 Beware!  OTP is One Time Programming ONLY! */

 EEE_TX_LPI_REQ_DLY & tx_lpi_timer are same uSec unit */

 CONFIG_PM */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Register map access API - ENCX24J600 support

 *

 * Copyright 2015 Gridpoint

 *

 * Author: Jon Ringle <jringle@gridpoint.com>

		/* Translate registers that are more effecient using

		 * 3-byte SPI commands

		/* Translate registers that are more effecient using

		 * 3-byte SPI commands

 SPI 1-byte command. Ignore data */

 Can be modified via single byte cmds */

 Can be modified via single byte cmds */

 Can be modified via single byte cmds */

 single byte cmds are precious */

 SPDX-License-Identifier: GPL-2.0+

/* Microchip Sparx5 Switch driver

 *

 * Copyright (c) 2021 Microchip Technology Inc. and its subsidiaries.

 *

 * The Sparx5 Chip Register Model can be browsed at this location:

 * https://github.com/microchip-ung/sparx-5_reginfo

 0x600000000 */

 0x600080000 */

 0x600400000 */

 0x610004000 */

 0x610008000 */

 0x61000c000 */

 0x610010000 */

 0x610014000 */

 0x610018000 */

 0x61001c000 */

 0x610020000 */

 0x610024000 */

 0x610028000 */

 0x61002c000 */

 0x610030000 */

 0x610034000 */

 0x610038000 */

 0x61003c000 */

 0x610040000 */

 0x610044000 */

 0x610048000 */

 0x61004c000 */

 0x610050000 */

 0x610054000 */

 0x610058000 */

 0x61005c000 */

 0x610060000 */

 0x610064000 */

 0x610068000 */

 0x61006c000 */

 0x610070000 */

 0x610074000 */

 0x610078000 */

 0x61007c000 */

 0x610080000 */

 0x610084000 */

 0x610088000 */

 0x61008c000 */

 0x610090000 */

 0x610094000 */

 0x610098000 */

 0x61009c000 */

 0x6100a0000 */

 0x6100a4000 */

 0x6100a8000 */

 0x6100ac000 */

 0x6100b0000 */

 0x6100b4000 */

 0x6100b8000 */

 0x6100bc000 */

 0x6100c0000 */

 0x6100c4000 */

 0x6100c8000 */

 0x6100cc000 */

 0x6100d0000 */

 0x6100d4000 */

 0x6100d8000 */

 0x6100dc000 */

 0x6100e0000 */

 0x6100e4000 */

 0x6100e8000 */

 0x6100ec000 */

 0x6100f0000 */

 0x6100f4000 */

 0x6100f8000 */

 0x6100fc000 */

 0x610104000 */

 0x610108000 */

 0x61010c000 */

 0x610114000 */

 0x610118000 */

 0x61011c000 */

 0x610124000 */

 0x610128000 */

 0x61012c000 */

 0x610130000 */

 0x610404000 */

 0x610408000 */

 0x61040c000 */

 0x610410000 */

 0x610414000 */

 0x610418000 */

 0x61041c000 */

 0x610420000 */

 0x610424000 */

 0x610428000 */

 0x61042c000 */

 0x610430000 */

 0x610434000 */

 0x610438000 */

 0x61043c000 */

 0x610440000 */

 0x610444000 */

 0x610448000 */

 0x61044c000 */

 0x610450000 */

 0x610454000 */

 0x610458000 */

 0x61045c000 */

 0x610460000 */

 0x610464000 */

 0x610468000 */

 0x61046c000 */

 0x610470000 */

 0x610474000 */

 0x610478000 */

 0x61047c000 */

 0x610480000 */

 0x610484000 */

 0x610488000 */

 0x61048c000 */

 0x610490000 */

 0x610494000 */

 0x610498000 */

 0x61049c000 */

 0x6104a0000 */

 0x6104a4000 */

 0x6104a8000 */

 0x6104ac000 */

 0x6104b0000 */

 0x6104b4000 */

 0x6104b8000 */

 0x6104bc000 */

 0x6104c4000 */

 0x6104c8000 */

 0x6104cc000 */

 0x6104d4000 */

 0x6104d8000 */

 0x6104dc000 */

 0x6104e4000 */

 0x6104e8000 */

 0x6104ec000 */

 0x6104f4000 */

 0x6104f8000 */

 0x6104fc000 */

 0x610504000 */

 0x610600000 */

 0x611010000 */

 0x611030000 */

 0x611050000 */

 0x611060000 */

 0x611080000 */

 0x6110a0000 */

 0x6110b0000 */

 0x6110c0000 */

 0x611100000 */

 0x611200000 */

 0x611280000 */

 0x6112c0000 */

 0x611400000 */

 0x611480000 */

 0x611580000 */

 0x611600000 */

 0x611800000 */

 0x611900000 */

 0x611a00000 */

 Vitesse */

 Setup VLAN */

 Create a phylink for PHY management.  Also handles SFPs */

		/* Still initializing, should be complete in

		 * less than 1ms

 Initialize memories, if not done already */

 Reset counters */

 Enable switch-core and queue system */

	/* Verify if core clock frequency is supported on target.

	 * If 'VTSS_CORE_CLOCK_DEFAULT' then the highest supported

	 * freq. is used

 Not supported */

 Not supported */

 Not supported */

 Not supported */

 Update state with chosen frequency */

 Configure the LCPLL */

 Set 80,90,95,100% of memory size for top watermarks */

/* Some boards needs to map the SGPIO for signal detect explicitly to the

 * port module

 Enable SGPIO Signal Detect remapping */

 Refer to LOS SGPIO */

 Setup own UPSIDs */

 Enable CPU ports */

 Init masks */

 CPU copy CPU pgids */

 Recalc injected frame FCS */

 Init MAC table, ageing */

 Setup VLANs */

 Add host mode BC address (points only to CPU) */

 Enable queue limitation watermarks */

 Init stats */

 Init mact_sw struct */

 Start Frame DMA with fallback to register based INJ/XTR */

 Do switch core reset if available */

 Default values, some from DT */

 Read chip ID to check CPU interface */

 Initialize Switchcore and internal RAMs */

 Initialize the LC-PLL (core clock) and set affected registers */

 Unregister netdevs */

 SPDX-License-Identifier: GPL-2.0+

/* Microchip Sparx5 Switch driver

 *

 * Copyright (c) 2021 Microchip Technology Inc. and its subsidiaries.

/* The IFH bit position of the first VSTAX bit. This is because the

 * VSTAX bit positions in Data sheet is starting from zero.

		/* Max width is 5 bytes - 40 bits. In worst case this will

		 * spread over 6 bytes - 48 bits

 Calculate the Start IFH byte position of this IFH bit position */

 Calculate the Start bit position in the Start IFH byte */

 The b0-b7 goes into the start IFH byte */

 The b8-b15 goes into the next IFH byte */

 The b16-b23 goes into the next IFH byte */

 The b24-b31 goes into the next IFH byte */

 The b32-b39 goes into the next IFH byte */

 The b40-b47 goes into the next IFH byte */

 VSTAX.RSV = 1. MSBit must be 1 */

 VSTAX.INGR_DROP_MODE = Enable. Don't make head-of-line blocking */

 MISC.CPU_MASK/DPORT = Destination port */

 MISC.PIPELINE_PT */

 MISC.PIPELINE_ACT */

 FWD.SRC_PORT = CPU */

 FWD.SFLOW_ID (disable SFlow sampling) */

 FWD.UPDATE_FCS = Enable. Enforce update of FCS. */

 power up serdes */

 power down serdes */

 Remove current */

 Add new */

 Record the address */

 Disconnect the phy */

 SPDX-License-Identifier: GPL-2.0+

/* Microchip Sparx5 Switch driver

 *

 * Copyright (c) 2021 Microchip Technology Inc. and its subsidiaries.

 QSYS calendar information */

 Ports mapped in a calendar register */

 Bit per port in calendar register */

 DSM calendar information */

 Maps from taxis to port numbers */

 This is used in calendar configuration */

 250000 / 3 */

 500000 / 3 */

 625000 / 3 */

 Internal ports */

 Equals 1.25G */

 IPMC only idle BW */

 OAM only idle BW */

 IPinIP gets only idle BW */

 not in port map */

 Front ports - may be used */

 Auto configure the QSYS calendar based on port configuration */

 Setup the calendar with the bandwidth to each port */

 Internal ports are granted half the value */

 Halt the calendar while changing it */

 Assign port bandwidth to auto calendar */

	/* Increase grant rate of all ports to account for

	 * core clock ppm deviations

 672->671 */

 Grant idle usage to VD 0-2 */

 Enable Auto mode */

 Verify successful calendar config */

 Default empty calendar */

 Map ports to taxi positions */

 Empty calendar */

 Make room for overhead traffic */

 Configure the DSM calendar based on port configuration */

 SPDX-License-Identifier: GPL-2.0+

/* Microchip Sparx5 Switch driver

 *

 * Copyright (c) 2021 Microchip Technology Inc. and its subsidiaries.

 *

 * The Sparx5 Chip Register Model can be browsed at this location:

 * https://github.com/microchip-ung/sparx-5_reginfo

/* Frame DMA DCB format

 *

 * +---------------------------+

 * |         Next Ptr          |

 * +---------------------------+

 * |   Reserved  |    Info     |

 * +---------------------------+

 * |         Data0 Ptr         |

 * +---------------------------+

 * |   Reserved  |    Status0  |

 * +---------------------------+

 * |         Data1 Ptr         |

 * +---------------------------+

 * |   Reserved  |    Status1  |

 * +---------------------------+

 * |         Data2 Ptr         |

 * +---------------------------+

 * |   Reserved  |    Status2  |

 * |-------------|-------------|

 * |                           |

 * |                           |

 * |                           |

 * |                           |

 * |                           |

 * |---------------------------|

 * |         Data14 Ptr        |

 * +-------------|-------------+

 * |   Reserved  |    Status14 |

 * +-------------|-------------+

/* For each hardware DB there is an entry in this list and when the HW DB

 * entry is used, this SW DB entry is moved to the back of the list

 Reset the status of the DB */

 Reset the status of the DB */

 Write the buffer address in the LLP and LLP1 regs */

 Set the number of RX DBs to be used, and DB end-of-frame interrupt */

 Set the RX Watermark to max */

 Start RX fdma */

 Enable RX channel DB interrupt */

 Activate the RX channel */

 Dectivate the RX channel */

 Disable RX channel DB interrupt */

 Stop RX fdma */

 Write the buffer address in the LLP and LLP1 regs */

 Set the number of TX DBs to be used, and DB end-of-frame interrupt */

 Start TX fdma */

 Activate the channel */

 Disable the channel */

 Reload the RX channel */

 Reload the TX channel */

 Check if the DCB is done */

 Replace the DB entry with a new SKB */

 Map the new skb data and set the new skb */

 Now do the normal processing of the skb */

 Map to port netdev */

	/* Everything we see on an interface that is in the HW bridge

	 * has already been forwarded

 Check if the DCB can be reused */

		/* As the DCB  can be reused, just advance the dcb_index

		 * pointer and set the nextptr in the DCB

 Handle wrap-around */

 Now for each dcb allocate the db */

		/* For each db allocate an skb and map skb data pointer to the DB

		 * dataptr. In this way when the frame is received the skb->data

		 * will contain the frame, so no memcpy is needed

 Now for each dcb allocate the db */

 TX databuffers must be 16byte aligned */

 Let the curr_entry to point to the last allocated entry */

 Fetch a netdev for SKB and NAPI use, any will do */

 Clear interrupt */

 Change mode to fdma extraction and injection */

 CPU ports capture setup */

 ASM CPU port: No preamble, IFH, enable padding */

 1 = IFH */

 Reset WM cnt to unclog queued frames */

 Set Disassembler Stop Watermark level */

 Enable port in queue system */

		/* Disable Disassembler buffer underrun watchdog

		 * to avoid truncated packets in XTR

 Disabling frame aging */

 Reset FDMA state */

 Force ACP caching but disable read/write allocation */

 Stop the fdma and channel interrupts */

 Wait for the RX channel to stop */

 SPDX-License-Identifier: GPL-2.0+

/* Microchip Sparx5 Switch driver

 *

 * Copyright (c) 2021 Microchip Technology Inc. and its subsidiaries.

 All other states treated as blocking */

 apply the bridge_fwd_mask to all the ports */

 First bridged port */

			/* This is adding the port to a second bridge, this is

			 * unsupported

	/* Port enters in bridge mode therefor don't need to copy to CPU

	 * frames for multicast in case the bridge is not requesting them

 Clear bridge vlan settings before updating the port settings */

 Port enters in host more therefore restore mc list */

 Skip null/host interfaces */

 Bridge connects to vid? */

 Add port MAC address from the VLAN */

		/* Control port addr visibility depending on

		 * port VLAN connectivity.

 First, handle bridge address'es */

 Now look at bridged ports */

 Master bridge? */

 Delete the port MAC address with the matching VLAN information */

 SPDX-License-Identifier: GPL-2.0+

/* Microchip Sparx5 Switch driver

 *

 * Copyright (c) 2021 Microchip Technology Inc. and its subsidiaries.

 Index of ANA_AC port counters */

 Add a potentially wrapping 32 bit value to a 64 bit counter */

 value has wrapped */

 Copy port counters to the ethtool buffer */

 Not initialized yet */

 Enable global events for port policer drops */

 Clear Queue System counters */

 Use counter for port policer drop count */

 SPDX-License-Identifier: GPL-2.0+

/* Microchip Sparx5 Switch driver

 *

 * Copyright (c) 2021 Microchip Technology Inc. and its subsidiaries.

 Currently not used */

 Configure the port to speed/duplex/pause */

 Currently not used */

 Enable the PCS matching this interface type */

 Currently not used */

 SPDX-License-Identifier: GPL-2.0+

/* Microchip Sparx5 Switch driver

 *

 * Copyright (c) 2021 Microchip Technology Inc. and its subsidiaries.

 Divide up mask in 32 bit words */

 Output mask to respective registers */

 Map VLAN = FID */

 Configure PVID */

 Make the port a member of the VLAN */

 Default ingress vlan classification */

 Untagged egress vlan classification */

	/* 8021q removes VID 0 on module unload for all interfaces

	 * with VLAN filtering feature. We need to keep it to receive

	 * untagged traffic.

 Stop the port from being a member of the vlan */

 Ingress */

 Egress */

 mask is spread across 3 registers x 32 bit */

 Divide up fwd mask in 32 bit words */

 Update flood masks */

 Update SRC masks */

 Allow to send to all bridged but self */

 Learning enabled only for bridged ports */

 Apply learning mask */

 Configure PVID, vlan aware */

		/* If port is vlan-aware and tagged, drop untagged and

		 * priority tagged frames.

 Egress configuration (REW_TAG_CFG): VLAN tag type to 8021Q */

 Tag all frames except when VID == DEFAULT_VLAN */

 Egress VID */

 SPDX-License-Identifier: GPL-2.0+

/* Microchip Sparx5 Switch driver

 *

 * Copyright (c) 2021 Microchip Technology Inc. and its subsidiaries.

 Commands for Mac Table Command register */

 Insert (Learn) 1 entry */

 Unlearn (Forget) 1 entry */

 Look up 1 entry */

 Read entry at Mac Table Index */

 Write entry at Mac Table Index */

 Scan (Age or find next) */

 Get next entry */

 Delete all entries in table */

 Commands for MAC_ENTRY_ADDR_TYPE */

	/* Set the MAC address to handle and the vlan associated in a format

	 * understood by the hardware.

 Add upsid */

 MAC entry properties */

  Insert/learn new entry */

 Issue a lookup command */

 Issue an unlearn command */

	/* In case the entry already exists, don't add it again to SW,

	 * just update HW, but we need to look in the actual HW because

	 * it is possible for an entry to be learn by HW and before the

	 * mact thread to start the frame will reach CPU and the CPU will

	 * add the entry but without the extern_learn flag.

	/* Add the entry in SW MAC table not to get the notification when

	 * SW is pulling again

 New entry? */

 Don't age this */

	/* Delete the entry in SW MAC table not to get the notification when

	 * SW is pulling again

 Entry handled */

 Present, not moved */

 Entry not found - now add */

 New or moved entry - notify bridge */

 Reset MAC entry flags */

 MAIN mac address processing loop */

 If the entry is in HW or permanent, then skip */

 unit 10 ms */

 10 ms */

 one bit ageing */

  Flush MAC table */

 SPDX-License-Identifier: GPL-2.0+

/* Microchip Sparx5 Switch driver

 *

 * Copyright (c) 2021 Microchip Technology Inc. and its subsidiaries.

 1G HDX not supported

 Get PCS Link down sticky */

 Clear the sticky */

 Get both current Link and Sync status */

 Get PCS ANEG status register */

 Aneg complete provides more information  */

 The link is or has been down. Clear the sticky bit */

/* Get link status of 1000Base-X/in-band and SFI ports.

	/* Resource == 0: Memory tracked per source (SRC-MEM)

	 * Resource == 1: Frame references tracked per source (SRC-REF)

	 * Resource == 2: Memory tracked per destination (DST-MEM)

	 * Resource == 3: Frame references tracked per destination. (DST-REF)

 1: Reset the PCS Rx clock domain  */

 2: Disable MAC frame reception */

 1: Reset the PCS Rx clock domain  */

 2: Disable MAC frame reception */

 3: Disable traffic being sent to or from switch port->portno */

 4: Disable dequeuing from the egress queues  */

 5: Disable Flowcontrol */

 6: Wait while the last frame is exiting the queues */

 7: Flush the queues accociated with the port->portno */

 8: Enable dequeuing from the egress queues */

 9: Wait until flushing is complete */

 10: Reset the  MAC clock domain */

 11: Clear flushing */

 12: Disable 5G/10G/25 BaseR PCS */

 Disable 25G PCS */

 12: Disable 1G PCS */

 The port is now flushed and disabled  */

/* Configure port muxing:

 * QSGMII:     4x2G5 devices

 Nothing to do */

 QSGMII: 4x2G5 devices. Mode Q'  */

 Affects d0-d3,d8-d11..d40-d43 */

 625Mhz for now */

 FC gen disabled */

 Set HDX flowcontrol */

 Obey flowcontrol  */

 Disable forward pressure */

 Generate pause frames */

 cl-37 aneg */

 Enable SGMII Aneg */

	/* Configure SerDes with port parameters

	 * For BaseR, the serdes driver supports 10GGBASE-R and speed 5G/10G/25G

 Cisco-SGMII in-band-aneg */

 Clause-37 in-band-aneg */

 Phy is connnected to the MAC */

 Choose SGMII or 1000BaseX/2500BaseX PCS mode */

 Enable PCS */

 Enable in-band aneg */

 Take PCS out of reset */

  SFI : No in-band-aneg. Speeds 5G/10G/25G */

 Enable PCS for 25G device, speed 25G */

 Enable PCS for 5G/10G/25G devices, speed 5G/10G */

 Enable 5G/10G/25G MAC module */

 Take the device out of reset */

 Switch between 1G/2500 and 5G/10G/25G devices */

 Configure speed/duplex dependent registers */

 GIG/FDX mode */

 Set MAC IFG Gaps */

 Disabling frame aging when in HDX (due to HDX issue) */

 Enable MAC module */

 Select speed and take MAC out of reset */

 switch device */

 Disable the not-in-use device */

 Disable the port before re-configuring */

 Enable/disable 1G counters in ASM */

 Enable/disable 1G counters in DSM */

 high speed device is already configured */

 Configure flow control */

 Set the DSM stop watermark */

 Enable port in queue system */

 Save the new values */

 Initialize port config to default */

 FC generate disabled */

 Set the mux port mode  */

 Configure MAC vlan awareness */

 Set Max Length */

 1G/2G5: Signal Detect configuration */

 Set Pause WM hysteresis */

 Port ATOP. Frames are tail dropped when this WM is hit */

 Discard pause frame 01-80-C2-00-00-01 */

 Enable shadow device */

 All ports must be PCS enabled in QSGMII mode

 Default IFGs for 1G */

 Low speed device only - return */

 Now setup the high speed device */

 Set Max Length */

 Handle Signal Detect in 10G PCS */

 Handle Signal Detect in 25G PCS */

 Enable port for frame transfer? */

 SPDX-License-Identifier: GPL-2.0+

/* Microchip Sparx5 Switch driver

 *

 * Copyright (c) 2021 Microchip Technology Inc. and its subsidiaries.

 Start flush */

 Allow to drain */

 All Queues normal */

 FWD is bit 45-72 (28 bits), but we only read the 27 LSB for now */

 Get IFH */

 Decode IFH (whats needed) */

 Map to port netdev */

 Have netdev, get skb */

 Now, pull frame data */

 No accompanying data */

			/* This assumes STATUS_WORD_POS == 1, Status

			 * just after last data

 But get the last 4 bytes as well */

	/* Everything we see on an interface that is in the HW bridge

	 * has already been forwarded

 Finish up skb */

 Indicate SOF */

 Write the IFH to the chip. */

 Write words, round up */

 Add padding */

 Indicate EOF and valid bytes in last word */

 Add dummy CRC */

 Reset Watermark count to restart */

 Change mode to manual extraction and injection */

 CPU ports capture setup */

 ASM CPU port: No preamble, IFH, enable padding */

 1 = IFH */

 Reset WM cnt to unclog queued frames */

 Set Disassembler Stop Watermark level */

		/* Enable Disassembler buffer underrun watchdog

 Check data in queue */

 sundance.c: A Linux device driver for the Sundance ST201 "Alta". */

/*

	Written 1999-2000 by Donald Becker.



	This software may be used and distributed according to the terms of

	the GNU General Public License (GPL), incorporated herein by reference.

	Drivers based on or derived from this code fall under the GPL and must

	retain the authorship, copyright and license notice.  This file is not

	a complete program and may only be used when the entire operating

	system is licensed under the GPL.



	The author may be reached as becker@scyld.com, or C/O

	Scyld Computing Corporation

	410 Severn Ave., Suite 210

	Annapolis MD 21403



	Support and updates available at

	http://www.scyld.com/network/sundance.html

	[link no longer provides useful info -jgarzik]

	Archives of the mailing list are still available at

	https://www.beowulf.org/pipermail/netdrivers/



/* The user-configurable values.

 1 normal messages, 0 quiet .. 7 verbose. */

/* Maximum number of multicast addresses to filter (vs. rx-all-multicast).

/* Set the copy breakpoint for the copy-only-tiny-frames scheme.

   Setting to > 1518 effectively disables this feature.

   This chip can receive into offset buffers, so the Alpha does not

/* media[] specifies the media type the NIC operates at.

		 autosense	Autosensing active media.

		 10mbps_hd 	10Mbps half duplex.

		 10mbps_fd 	10Mbps full duplex.

		 100mbps_hd 	100Mbps half duplex.

		 100mbps_fd 	100Mbps full duplex.

		 0		Autosensing active media.

		 1	 	10Mbps half duplex.

		 2	 	10Mbps full duplex.

		 3	 	100Mbps half duplex.

		 4	 	100Mbps full duplex.

 Operational parameters that are set at compile time. */

/* Keep the ring sizes a power of two for compile efficiency.

   The compiler will convert <unsigned>'%'<2^N> into a bit mask.

   Making the Tx ring too large decreases the effectiveness of channel

   bonding and packet priority, and more than 128 requires modifying the

   Tx error recovery.

 Limit ring entries actually used.  */

 Operational parameters that usually are not changed. */

 Time in jiffies before concluding the transmitter is hung. */

 Size of each temporary Rx buffer.*/

 Include files, designed to support most kernel versions 2.0.0 and later. */

 Processor type for cache alignment. */

/*

				Theory of Operation



I. Board Compatibility



This driver is designed for the Sundance Technologies "Alta" ST201 chip.



II. Board-specific settings



III. Driver operation



IIIa. Ring buffers



This driver uses two statically allocated fixed-size descriptor lists

formed into rings by a branch from the final descriptor to the beginning of

the list.  The ring sizes are set at compile time by RX/TX_RING_SIZE.

Some chips explicitly use only 2^N sized rings, while others use a

'next descriptor' pointer that the driver forms into rings.



IIIb/c. Transmit/Receive Structure



This driver uses a zero-copy receive and transmit scheme.

The driver allocates full frame size skbuffs for the Rx ring buffers at

open() time and passes the skb->data field to the chip as receive data

buffers.  When an incoming frame is less than RX_COPYBREAK bytes long,

a fresh skbuff is allocated and the frame is copied to the new skbuff.

When the incoming frame is larger, the skbuff is passed directly up the

protocol stack.  Buffers consumed this way are replaced by newly allocated

skbuffs in a later phase of receives.



The RX_COPYBREAK value is chosen to trade-off the memory wasted by

using a full-sized skbuff for small frames vs. the copying costs of larger

frames.  New boards are typically used in generously configured machines

and the underfilled buffers have negligible impact compared to the benefit of

a single allocation size, so the default value of zero results in never

copying packets.  When copying is done, the cost is usually mitigated by using

a combined copy/checksum routine.  Copying also preloads the cache, which is

most useful with small frames.



A subtle aspect of the operation is that the IP header at offset 14 in an

ethernet frame isn't longword aligned for further processing.

Unaligned buffers are permitted by the Sundance hardware, so

frames are received into the skbuff at an offset of "+2", 16-byte aligning

the IP header.



IIId. Synchronization



The driver runs as two independent, single-threaded flows of control.  One

is the send-packet routine, which enforces single-threaded use by the

dev->tbusy flag.  The other thread is the interrupt handler, which is single

threaded by the hardware and interrupt handling software.



The send packet thread has partial control over the Tx ring and 'dev->tbusy'

flag.  It sets the tbusy flag whenever it's queuing a Tx packet. If the next

queue slot is empty, it clears the tbusy flag when finished otherwise it sets

the 'lp->tx_full' flag.



The interrupt handler has exclusive control over the Rx ring and records stats

from the Tx ring.  After reaping the stats, it marks the Tx queue entry as

empty by incrementing the dirty_tx mark. Iff the 'lp->tx_full' flag is set, it

clears both the tx_full and tbusy flags.



IV. Notes



IVb. References



The Sundance ST201 datasheet, preliminary version.

The Kendin KS8723 datasheet, preliminary version.

The ICplus IP100 datasheet, preliminary version.

http://www.scyld.com/expert/100mbps.html

http://www.scyld.com/expert/NWay.html



IVc. Errata



 Work-around for Kendin chip bugs. */

 terminate list. */

/* This driver was written to use PCI memory space, however x86-oriented

/* Offsets to the device registers.

   Unlike software-only systems, device drivers interact with complex hardware.

   It's not useful to define symbolic names for every register bit in the

   device.  The name can only partially document the semantics and make

   the driver longer and more difficult to read.

   In general, only the important configuration values or bits changed

   multiple times should be defined symbolically.

 Aliased and bogus values! */

 Bits in the interrupt status/mask registers. */

 Bits in the RxMode register. */

 Bits in MACCtrl. */

 Bits in WakeEvent register. */

 The Rx and Tx buffer descriptors. */

/* Note that using only 32 bit fields simplifies conversion to big-endian

 Bits in netdev_desc.status */

 Required alignment mask */

/* Use  __attribute__((aligned (L1_CACHE_BYTES)))  to maintain alignment

 Descriptor rings first for alignment. */

 Media monitoring timer. */

 backpointer */

 ethtool extra stats */

 Frequently used values: keep some adjacent for cache effect. */

 Producer/consumer ring indices */

 Based on MTU+slack. */

 Last Tx descriptor used. */

 These values are keep track of the transceiver/media in use. */

 Last dev->if_port value. */

 Wake on LAN enabled */

 Multicast and receive mode. */

 SMP lock multicast updates. */

 MII transceiver section. */

 MII device addresses, only first one used. */

 The station address location in the EEPROM. */

 ST201 documentation states ASICCtrl is a 32bit register */

 ST201 documentation states reset can take up to 1 ms */

 The chip-specific entries in the device structure. */

 MTU range: 68 - 8191 */

 Default setting */

	/*

	 * It seems some phys doesn't deal well with address 0 being accessed

	 * first

 wraps to zero, due to 'phy & 0x1f' */

 Parse override configuration */

 Fibre PHY? */

 Default 100Mbps Full */

 Reset PHY */

 If flow control enabled, we need to advertise it.*/

 Force media type */

 Perhaps move the reset here? */

 Reset the chip to erase previous misconfiguration. */

 Read the EEPROM and MII Management Data I/O (MDIO) interfaces. */

 Typical 1900 ticks. */

/*  MII transceiver control section.

	Read and write the MII registers using software-generated serial

	MDIO protocol.  See the MII specifications or DP83840A data sheet

	for details.



	The maximum data clock rate is 2.5 Mhz.  The minimum timing is usually

/* Generate the preamble required for initial synchronization and

 Establish sync by sending at least 32 logic ones. */

 Shift the read command bits out. */

 Read the two transition, 16 data, and wire-idle bits. */

 Shift the command bits out. */

 Clear out extra bits. */

 The Tx list pointer is written as packets are queued. */

 Initialize other registers. */

 Configure the PCI bus bursts and FIFO thresholds. */

 Set the chip to poll every N*320nsec. */

 Fix DFE-580TX packet drop issue */

 Disable Wol */

 Set the timer to check for link beat. */

 Enable interrupts by setting the interrupt mask. */

 Force media */

 Autonegotiation */

 Stop and restart the chip's Tx processes . */

 prevent tx timeout */

 Initialize the Rx and Tx rings, along with various 'dev' bits. */

 Initialize all Rx descriptors. */

 Fill in the Rx buffers.  Handle allocation failure gracefully. */

 16 byte align the IP header. */

 Chain the next pointer */

 Indicate the latest descriptor of tx ring */

 Calculate the next Tx descriptor entry. */

 Increment cur_tx before tasklet_schedule() */

 Schedule a tx_poll() task */

 On some architectures: explicitly flush cache lines here. */

 do nothing */

 Reset hardware tx and free all of tx buffers */

 Reset tx logic, TxListPtr will be cleaned */

 free all tx skbuff */

/* The interrupt handler cleans up after the Tx thread,

					/*

					** This reset has been verified on

					** DFE-580TX boards ! phdm@macqel.be.

 TxUnderrun */

 Restart Tx FIFO and transmitter */

 No need to reset the Tx pointer here */

 Restart the Tx. Need to make sure tx enabled */

 Yup, this is a documentation bug.  It cost me *hours*. */

 Free the original skb. */

 Free the original skb. */

 The ring is no longer full, clear busy flag. */

 Abnormal error summary/uncommon events handlers. */

 If EOP is set on the next entry, it's a new packet. Send it up. */

 Chip omits the CRC. */

 There was a error. */

			/* Check if the packet is long enough to accept without copying

 16 byte align the IP header */

 Note: checksum -> skb->ip_summed = CHECKSUM_UNNECESSARY; */

 Refill the Rx ring buffers. */

 Better luck next round. */

 Align IP on 16 byte boundaries */

 Perhaps we need not reset this field. */

 We must do a global reset of DMA to continue. */

 The chip only need report frame silently dropped. */

 Multicast hash filter */

 Set promiscuous. */

 Too many to match, or accept all multicasts. */

 Invoked with rtnl_lock held */

 CONFIG_PM */

 Wait and kill tasklet */

 Disable interrupts by clearing the interrupt mask. */

 Disable Rx and Tx DMA for safely release resource */

 Stop the chip's Tx and Rx processes. */

RX_RING_SIZE*/4 ; i++) {

 __i386__ debugging only */

 Free all the skbuffs in the Rx queue. */

 poison */

 SPDX-License-Identifier: GPL-2.0-or-later

  D-Link DL2000-based Gigabit Ethernet Adapter Linux driver */

/*

    Copyright (c) 2001, 2002 by D-Link Corporation

    Written by Edward Peng.<edward_peng@dlink.com.tw>

    Created 03-May-2001, base on Linux' sundance.c.



 Rx frame count each interrupt */

 Rx DMA wait time in 640ns increments */

 HW xmit count each TxDMAComplete */

 Rx frame count each interrupt */

 Rx DMA wait time in 64ns increments */

 HW xmit count each TxDMAComplete */

 Enable the default interrupts */

 IO registers range. */

 MM registers range. */

 Parse manual configuration */

 MTU range: 68 - 1536 or 8000 */

 Parse eeprom data */

 Find PHY address */

 Fiber device? */

 Set media and reset PHY */

 default Auto-Negotiation for fiber deivices */

		/* Auto-Negotiation is mandatory for 1000BASE-T,

 D-Link Only */

 Check CRC */

 Set MAC address */

 Parse Software Information Block */

 Format version */

 End of cell */

 Duplex Polarity */

 Wake Polarity */

 Adapter description */

 Reversed */

 Unknown cell */

 Free all the skbuffs in the queue. */

 allocate and initialize Tx and Rx descriptors */

 Initialize Tx descriptors, TFDListPtr leaves in start_xmit(). */

 Initialize Rx descriptors & allocate buffers */

 Allocated fixed size of skbuff */

 Rubicon now supports 40 bits of addressing space. */

 Reset all logic functions */

 DebugCtrl bit 4, 5, 9 must set */

 PHY magic taken from ipg driver, undocumented registers */

 advertise 1000BASE-T half & full duplex, prefer MASTER */

 Jumbo frame */

 Set RFDListPtr */

 Set station address */

	/* 16 or 32-bit access is required by TC9020 datasheet but 8-bit works

	 * too. However, it doesn't work on IP1000A so we use 16-bit access.

 Set RIO to poll every N*320nsec. */

 clear statistics */

 VLAN supported */

 priority field in RxDMAIntCtrl  */

 VLANId */

 Length/Type should be 0x8100 */

		/* Enable AutoVLANuntagging, but disable AutoVLANtagging.

 Start Tx/Rx */

 Disable interrupts */

 Stop Tx and Rx logics */

 Recover rx ring exhausted error */

 Re-allocate skbuffs to fill the descriptor ring */

 Dropped packets don't need to re-allocate */

 end for */

 end if */

 prevent tx timeout */

 Link Down */

	/* DL2K bug: DMA fails to get next descriptor ptr in 10Mbps mode

 TxDMAPollNow */

 Schedule ISR */

 do nothing */

 The first TFDListPtr */

 Processing received packets */

 TxDMAComplete interrupt */

 Free used tx skbuffs */

 Handle uncommon events */

 Free used tx skbuffs */

	/* If the ring is no longer full, clear tx_full and

 Ttransmit Underrun */

 Transmit Underrun need to set TxReset, DMARest, FIFOReset */

 Wait for ResetBusy bit clear */

 Reset TFDListPtr */

 Let TxStartThresh stay default value */

 Late Collision */

 TxReset and clear FIFO */

 Wait reset done */

 Let TxStartThresh stay default value */

 Maximum Collisions */

 Restart the Tx */

 If RFDDone, FrameStart and FrameEnd set, there is a new packet in. */

 Chip omits the CRC. */

 Update rx error statistics, drop packet. */

 Small skbuffs for short packets */

 Checksum done by hw, but csum value unavailable. */

 Re-allocate skbuffs to fill the descriptor ring */

 Dropped packets don't need to re-allocate */

 Link change event */

 UpdateStats statistics registers */

	/* PCI Error, a catastronphic error related to the bus interface

	/* All statistics registers need to be acknowledged,

 detailed tx errors */

 Clear all other statistic register. */

	/* All statistics registers need to be acknowledged,

 detailed rx errors */

 detailed tx errors */

 Clear all other statistic register. */

 RxFlowcontrol DA: 01-80-C2-00-00-01. Hash index=0x39 */

 Receive all frames promiscuously. */

 Receive broadcast and multicast frames */

		/* Receive broadcast frames and multicast frames filtering

			/* The inverted high significant 6 bits of CRC are

 ReceiveVLANMatch field in ReceiveMode */

 fiber device */

 copper device */

 not supported */

 Read the EEPROM word */

 We use I/O instruction to read/write eeprom to avoid fail on some machines */

 Preamble */

 ST(2), OP(2), ADDR(5), REG#(5), TA(2), Data(16) total 32 bits */

 ST,OP = 0110'b for read operation */

 Turnaround */

 Read data */

 End cycle */

 Preamble */

 ST(2), OP(2), ADDR(5), REG#(5), TA(2), Data(16) total 32 bits */

 ST,OP,AAAAA,RRRRR,TA = 0101xxxxxxxxxx10'b = 0x5002 for write */

 End cycle */

 Auto-Negotiation not completed */

 else tx_flow, rx_flow = user select  */

 Does user set speed? */

 Advertise capabilities */

 Enable Auto crossover */

 11'b */

 Soft reset PHY */

 Force speed setting */

 1) Disable Auto crossover */

 2) PHY Reset */

 3) Power Down */

 must be 0x1940 */

 wait a certain time */

 4) Advertise nothing */

 5) Set media and Power Up */

 Set 1000BaseT Master/Slave setting */

 Auto-Negotiation not completed */

 else tx_flow, rx_flow = user select  */

 Auto-Negotiation? */

 Advertise capabilities */

 Soft reset PHY */

 Force speed setting */

 PHY Reset */

  Advertise nothing */

 CONFIG_PM_SLEEP */

 Read Documentation/networking/device_drivers/ethernet/dlink/dl2k.rst. */

 SPDX-License-Identifier: GPL-2.0

 Copyright(c) 1999 - 2006 Intel Corporation. */

/*

 *	e100.c: Intel(R) PRO/100 ethernet driver

 *

 *	(Re)written 2003 by scott.feldman@intel.com.  Based loosely on

 *	original e100 driver, but better described as a munging of

 *	e100, e1000, eepro100, tg3, 8139cp, and other drivers.

 *

 *	References:

 *		Intel 8255x 10/100 Mbps Ethernet Controller Family,

 *		Open Source Software Developers Manual,

 *		http://sourceforge.net/projects/e1000

 *

 *

 *	                      Theory of Operation

 *

 *	I.   General

 *

 *	The driver supports Intel(R) 10/100 Mbps PCI Fast Ethernet

 *	controller family, which includes the 82557, 82558, 82559, 82550,

 *	82551, and 82562 devices.  82558 and greater controllers

 *	integrate the Intel 82555 PHY.  The controllers are used in

 *	server and client network interface cards, as well as in

 *	LAN-On-Motherboard (LOM), CardBus, MiniPCI, and ICHx

 *	configurations.  8255x supports a 32-bit linear addressing

 *	mode and operates at 33Mhz PCI clock rate.

 *

 *	II.  Driver Operation

 *

 *	Memory-mapped mode is used exclusively to access the device's

 *	shared-memory structure, the Control/Status Registers (CSR). All

 *	setup, configuration, and control of the device, including queuing

 *	of Tx, Rx, and configuration commands is through the CSR.

 *	cmd_lock serializes accesses to the CSR command register.  cb_lock

 *	protects the shared Command Block List (CBL).

 *

 *	8255x is highly MII-compliant and all access to the PHY go

 *	through the Management Data Interface (MDI).  Consequently, the

 *	driver leverages the mii.c library shared with other MII-compliant

 *	devices.

 *

 *	Big- and Little-Endian byte order as well as 32- and 64-bit

 *	archs are supported.  Weak-ordered memory and non-cache-coherent

 *	archs are supported.

 *

 *	III. Transmit

 *

 *	A Tx skb is mapped and hangs off of a TCB.  TCBs are linked

 *	together in a fixed-size ring (CBL) thus forming the flexible mode

 *	memory structure.  A TCB marked with the suspend-bit indicates

 *	the end of the ring.  The last TCB processed suspends the

 *	controller, and the controller can be restarted by issue a CU

 *	resume command to continue from the suspend point, or a CU start

 *	command to start at a given position in the ring.

 *

 *	Non-Tx commands (config, multicast setup, etc) are linked

 *	into the CBL ring along with Tx commands.  The common structure

 *	used for both Tx and non-Tx commands is the Command Block (CB).

 *

 *	cb_to_use is the next CB to use for queuing a command; cb_to_clean

 *	is the next CB to check for completion; cb_to_send is the first

 *	CB to start on in case of a previous failure to resume.  CB clean

 *	up happens in interrupt context in response to a CU interrupt.

 *	cbs_avail keeps track of number of free CB resources available.

 *

 * 	Hardware padding of short packets to minimum packet size is

 * 	enabled.  82557 pads with 7Eh, while the later controllers pad

 * 	with 00h.

 *

 *	IV.  Receive

 *

 *	The Receive Frame Area (RFA) comprises a ring of Receive Frame

 *	Descriptors (RFD) + data buffer, thus forming the simplified mode

 *	memory structure.  Rx skbs are allocated to contain both the RFD

 *	and the data buffer, but the RFD is pulled off before the skb is

 *	indicated.  The data buffer is aligned such that encapsulated

 *	protocol headers are u32-aligned.  Since the RFD is part of the

 *	mapped shared memory, and completion status is contained within

 *	the RFD, the RFD must be dma_sync'ed to maintain a consistent

 *	view from software and hardware.

 *

 *	In order to keep updates to the RFD link field from colliding with

 *	hardware writes to mark packets complete, we use the feature that

 *	hardware will not write to a size 0 descriptor and mark the previous

 *	packet as end-of-list (EL).   After updating the link, we remove EL

 *	and only then restore the size such that hardware may use the

 *	previous-to-end RFD.

 *

 *	Under typical operation, the  receive unit (RU) is start once,

 *	and the controller happily fills RFDs as frames arrive.  If

 *	replacement RFDs cannot be allocated, or the RU goes non-active,

 *	the RU must be restarted.  Frame arrival generates an interrupt,

 *	and Rx indication and re-allocation happen in the same context,

 *	therefore no locking is required.  A software-generated interrupt

 *	is generated from the watchdog to recover from a failed allocation

 *	scenario where all Rx resources have been indicated and none re-

 *	placed.

 *

 *	V.   Miscellaneous

 *

 * 	VLAN offloading of tagging, stripping and filtering is not

 * 	supported, but driver will accommodate the extra 4-byte VLAN tag

 * 	for processing by upper layers.  Tx/Rx Checksum offloading is not

 * 	supported.  Tx Scatter/Gather is not supported.  Jumbo Frames is

 * 	not supported (hardware limitation).

 *

 * 	MagicPacket(tm) WoL support is enabled/disabled via ethtool.

 *

 * 	Thanks to JC (jchapman@katalix.com) for helping with

 * 	testing/troubleshooting the development driver.

 *

 * 	TODO:

 * 	o several entry points race with dev->close

 * 	o check for tx-no-resources/stop Q races with tx clean/wake Q

 *

 *	FIXES:

 * 2005/12/02 - Michael O'Donnell <Michael.ODonnell at stratus dot com>

 *	- Stratus87247: protect MDI control register manipulations

 * 2009/06/01 - Andreas Mohr <andi at lisas dot de>

 *      - add clean lowlevel I/O emulation for cards with MII-lacking PHYs

 CSR (Control/Status Registers) */

/*

 * cb_command - Command Block flags

 * @cb_tx_nc:  0: controller does CRC (normal),  1: CRC from skb memory

0*/	u8 X(byte_count:6, pad0:2);

1*/	u8 X(X(rx_fifo_limit:4, tx_fifo_limit:3), pad1:1);

2*/	u8 adaptive_ifs;

3*/	u8 X(X(X(X(mwi_enable:1, type_enable:1), read_align_enable:1),

4*/	u8 X(rx_dma_max_count:7, pad4:1);

5*/	u8 X(tx_dma_max_count:7, dma_max_count_enable:1);

6*/	u8 X(X(X(X(X(X(X(late_scb_update:1, direct_rx_dma:1),

7*/	u8 X(X(X(X(X(rx_discard_short_frames:1, tx_underrun_retry:2),

8*/	u8 X(X(mii_mode:1, pad8:6), csma_disabled:1);

9*/	u8 X(X(X(X(X(rx_tcpudp_checksum:1, pad9:3), vlan_arp_tco:1),

10*/	u8 X(X(X(pad10:3, no_source_addr_insertion:1), preamble_length:2),

11*/	u8 X(linear_priority:3, pad11:5);

12*/	u8 X(X(linear_priority_mode:1, pad12:3), ifs:4);

13*/	u8 ip_addr_lo;

14*/	u8 ip_addr_hi;

15*/	u8 X(X(X(X(X(X(X(promiscuous_mode:1, broadcast_disabled:1),

16*/	u8 fc_delay_lo;

17*/	u8 fc_delay_hi;

18*/	u8 X(X(X(X(X(rx_stripping:1, tx_padding:1), rx_crc_transfer:1),

19*/	u8 X(X(X(X(X(X(X(addr_wake:1, magic_packet_disable:1),

20*/	u8 X(X(X(pad20_1:5, fc_priority_location:1), multi_ia:1), pad20_2:1);

21*/	u8 X(X(pad21_1:3, multicast_all:1), pad21_2:4);

22*/	u8 X(X(rx_d102_mode:1, rx_vlan_drop:1), pad22:6);

pad*/];

 Important: keep total struct u32-aligned */

 Begin: frequently used values: keep adjacent for cache effect */

 End: frequently used values: keep adjacent for cache effect */

	/* Flush previous PCI writes through intermediate bridges

	/* Put CU and RU into idle with a selective reset to get

 Now fully reset device */

 Mask off our interrupt line - it's unmasked after reset */

	/* Passing the self-test is a pretty good indication

 Wait 10 msec for self-test to complete */

 Interrupts are enabled after self-test */

 Check results of self-test */

 Three cmds: write/erase enable, write data, write/erase disable */

 Bit-bang cmds to write word to eeprom */

 Chip select */

 Wait 10 msec for cmd to complete */

 Chip deselect */

 General technique stolen from the eepro100 driver - very clever */

 Chip select */

 Bit-bang to read word from eeprom */

		/* Eeprom drives a dummy zero to EEDO after receiving

 Chip deselect */

 Load entire EEPROM image into driver cache and validate checksum */

 Try reading with an 8-bit addr len to discover actual addr len */

	/* The checksum, stored in the last word, is calculated such that

 Save (portion of) driver EEPROM cache to device and update checksum */

 Try reading with an 8-bit addr len to discover actual addr len */

	/* The checksum, stored in the last word, is calculated such that

 we might have to wait 100ms!!! */

 delay like the old code */

 Previous command is accepted when SCB clears */

	/* Order is important otherwise we'll be in a race with h/w:

			/* Ok, here's where things get sticky.  It's

			 * possible that we can't schedule the command

			 * because the controller is too busy, so

			 * let's just queue the command and try again

request a reset

 the standard mdio_ctrl() function for usual MII-compliant hardware */

	/*

	 * Stratus87247: we shouldn't be writing the MDI control

	 * register until the Ready bit shows True.  Also, since

	 * manipulation of the MDI control registers is a multi-step

	 * procedure it should be done under lock.

 No way to indicate timeout error */

 slightly tweaked mdio_ctrl() function for phy_82552_v specifics */

			/*

			 * Workaround Si issue where sometimes the part will not

			 * autoneg to 100Mbps even when advertised.

/* Fully software-emulated mdio_ctrl() function for cards without

 * MII-compliant PHYs.

 * For now, this is mainly geared towards 80c24 support; in case of further

 * requirements for other types (i82503, ...?) either extend this mechanism

 * or split it, whichever is cleaner.

	/* might need to allocate a netdev_priv'ed register array eventually

	 * to be able to record state changes, but for now

 Auto-negotiation, right? */

 for mii_link_ok() */ |

 80c24 is a "combo card" PHY, right? */

	/* for now, just check it by comparing whether we

	   are using MII software emulation.

 MAC type is encoded as rev ID; exception: ICH is treated as 82559 */

 Quadwords to DMA into FIFO before starting frame transmit */

 no interrupt for every tx completion, delay = 256us if not 557 */

 Template for a freshly allocated RFD */

 MII setup */

 bytes in this struct */

 bytes in FIFO before DMA */

 reserved */

 1=standard, 0=extended */

 1=standard, 0=extended */

 1=discard, 0=pass */

 # of underrun retries */

 1=MII mode, 0=i82503 mode */

 1=no, 0=yes */

 0=1, 1=3, 2=7, 3=15 bytes */

 x16 = inter frame spacing */

 ARP IP filter - not used */

 0=CRS only, 1=CRS or CDT */

 time delay for fc frame */

 1=pad short frames */

 7=priority fc disabled */

 1=examine FDX# pin */

 1=byte#31, 0=byte#19 */

 1=force, 0=auto */

 1=save, 0=discard */

 1=discard, 0=save */

 1=on, 0=off */

 1=save, 0=discard */

 1=accept, 0=no */

 disable WoL when up */

 1=off, 0=on */

 1=Tx fc off, 0=Tx fc on */

 1=enable, 0=disable */

 1=standard, 0=extended */

 1=VLANs ok, 0=standard */

 TCO stats enable */

 Enable TCO in extended config */

 extended bytes */

 GMRC for TCO */

 1=save, 0=discard */

 1=save, 0=discard */

 1=discard, 0=save */

/*************************************************************************

*  CPUSaver parameters

*

*  All CPUSaver parameters are 16-bit literals that are part of a

*  "move immediate value" instruction.  By changing the value of

*  the literal in the instruction before the code is loaded, the

*  driver can change the algorithm.

*

*  INTDELAY - This loads the dead-man timer with its initial value.

*    When this timer expires the interrupt is asserted, and the

*    timer is reset each time a new packet is received.  (see

*    BUNDLEMAX below to set the limit on number of chained packets)

*    The current default is 0x600 or 1536.  Experiments show that

*    the value should probably stay within the 0x200 - 0x1000.

*

*  BUNDLEMAX -

*    This sets the maximum number of frames that will be bundled.  In

*    some situations, such as the TCP windowing algorithm, it may be

*    better to limit the growth of the bundle size than let it go as

*    high as it can, because that could cause too much added latency.

*    The default is six, because this is the number of packets in the

*    default TCP window size.  A value of 1 would make CPUSaver indicate

*    an interrupt for every frame received.  If you do not want to put

*    a limit on the bundle size, set this value to xFFFF.

*

*  BUNDLESMALL -

*    This contains a bit-mask describing the minimum size frame that

*    will be bundled.  The default masks the lower 7 bits, which means

*    that any frame less than 128 bytes in length will not be bundled,

*    but will instead immediately generate an interrupt.  This does

*    not affect the current bundle in any way.  Any frame that is 128

*    bytes or large will be bundled normally.  This feature is meant

*    to provide immediate indication of ACK frames in a TCP environment.

*    Customers were seeing poor performance when a machine with CPUSaver

*    enabled was sending but not receiving.  The delay introduced when

*    the ACKs were received was enough to reduce total throughput, because

*    the sender would sit idle until the ACK was finally seen.

*

*    The current default is 0xFF80, which masks out the lower 7 bits.

*    This means that any frame which is x7F (127) bytes or smaller

*    will cause an immediate interrupt.  Because this value must be a

*    bit mask, there are only a few valid values that can be used.  To

*    turn this feature off, the driver can write the value xFFFF to the

*    lower word of this instruction (in the same way that the other

*    parameters are used).  Likewise, a value of 0xF800 (2047) would

*    cause an interrupt to be generated for every frame, because all

*    standard Ethernet frames are <= 2047 bytes in length.

/* if you wish to disable the ucode functionality, while maintaining the

 * workarounds it provides, set the following defines to:

 * BUNDLESMALL 0

 * BUNDLEMAX 1

 * INTDELAY 1

 0x600 */

 Initialize firmware */

 do not load u-code for ICH devices */

	/* Search for ucode match against h/w revision

	 *

	 * Based on comments in the source code for the FreeBSD fxp

	 * driver, the FIRMWARE_D102E ucode includes both CPUSaver and

	 *

	 *    "fixes for bugs in the B-step hardware (specifically, bugs

	 *     with Inline Receive)."

	 *

	 * So we must fail if it cannot be loaded.

	 *

	 * The other microcode files are only required for the optional

	 * CPUSaver feature.  Nice to have, but no reason to fail.

 No ucode on other devices */

	/* If the firmware has not previously been loaded, request a pointer

	 * to it. If it was previously loaded, we are reinitializing the

	 * adapter, possibly in a resume from hibernate, in which case

	 * request_firmware() cannot be used.

	/* Firmware should be precisely UCODE_SIZE (words) plus three bytes

 Read timer, bundle and min_size from end of firmware blob */

	/* OK, firmware is validated and ready to use. Save a pointer

	/* It's not a real skb; we just abused the fact that e100_exec_cb

 firmware is stored as little endian already */

 Read timer, bundle and min_size from end of firmware blob */

 Insert user-tunable settings in cb->u.ucode */

 If it's NULL, then no ucode is required */

 must restart cuc */

 wait for completion */

 wait for possibly (ouch) 500ms */

 ack any interrupts, something could have been set */

 if the command failed, or is not OK, notify and return */

 Non-MII PHY; UNTESTED! */

 Non-MII PHY; UNTESTED! */

 Non-MII PHY; tested and working */

		/* paragraph from the FreeBSD driver, "FXP_PHY_80C24":

		 * The Seeq 80c24 AutoDUPLEX(tm) Ethernet Interface Adapter

		 * doesn't have a programming interface of any sort.  The

		 * media is sensed automatically based on how the link partner

		 * is configured.  This is, in essence, manual configuration.

 is this ok for an MII-less PHY? */

		/* these might be needed for certain MII-less cards...

		 * nic->flags |= ich;

 Discover phy addr by searching addrs in order {1,0,2,..., 31} */

		/* uhoh, no PHY detected: check whether we seem to be some

		 * weird, rare variant which is *known* to not have any MII.

		 * But do this AFTER MII checking only, since this does

 simply return and hope for the best */

 for unknown cases log a fatal error */

 Get phy ID */

 Select the phy and isolate the rest */

	/*

	 * Workaround for 82552:

	 * Clear the ISOLATE bit on selected phy_id last (mirrored on all

	 * other phy_id's) using bmcr value from addr discovery loop above.

 Handle National tx phys */

 Disable congestion control */

 assign special tweaked mdio_ctrl() function */

 Workaround Si not advertising flow-control during autoneg */

 Reset for the above changes to take effect */

 enable/disable MDI/MDI-X auto-switching. */

	/* Device's stats reporting may take several microseconds to

	 * complete, so we're always waiting for results of the

	/* Adjust inter-frame-spacing (IFS) between two transmits if

 mii library handles link maintenance tasks */

	/* Software generated interrupt to recover from (rare) Rx

	 * allocation failure.

	 * Unfortunately have to use a spinlock to not re-enable interrupts

	 * accidentally, due to hardware that shares a register between the

 Issue a multicast command to workaround a 557 lock up */

 Need SW workaround for ICH[x] 10Mbps/half duplex Tx hang. */

 If we can't map the skb, have the upper layer try later */

	/*

	 * Use the last 4 bytes of the SKB payload packet as the CRC, used for

	 * testing, ie sending frames with bad CRC.

 interrupt every 16 packets regardless of delay */

		/* SW workaround for ICH[x] 10Mbps/half duplex Tx hang.

		   Issue a NOP command followed by a 1us delay before

 We queued the skb, but now we're out of space. */

 This is a hard error - log it. */

 Clean CBs marked complete */

 read skb after status */

 Recover from running out of Tx resources in xmit_frame */

 handle init time starts */

 (Re)start RU if suspended or idle and RFA is non-NULL */

 Init, and map the RFD. */

	/* Link the RFD to end of RFA by linking previous RFD to

	 * this one.  We are safe to touch the previous RFD because

 Need to sync before taking a peek at cb_complete bit */

 read size after status bit */

 If data isn't ready, nothing to indicate */

		/* If the next buffer has the el bit, but we think the receiver

		 * is still running, check to see if it really stopped while

		 * we had interrupts off.

		 * This allows for a fast restart without re-enabling

 Get actual data size */

 Get data */

	/* If this buffer has the el bit, but we think the receiver

	 * is still running, check to see if it really stopped while

	 * we had interrupts off.

	 * This allows for a fast restart without re-enabling interrupts.

	 * This can happen when the RU sees the size change but also sees

 Pull off the RFD and put the actual data (minus eth hdr) */

	/* If we are receiving all frames, then don't bother

	 * checking for errors.

 Received oversized frame, but keep it. */

 Don't indicate if hardware indicates errors */

 Don't indicate oversized frames */

 Indicate newly arrived packets */

 Hit quota or no more to clean */

	/* On EAGAIN, hit quota so have more work to do, restart once

	 * cleanup is complete.

	 * Else, are we already rnr? then pay attention!!! this ensures that

	 * the state machine progression never allows a start with a

	 * partially cleaned list, avoiding a race between hardware

 Alloc new skbs to refill list */

 Better luck next time (see watchdog) */

		/* Set the el-bit on the buffer that is before the last buffer.

		 * This lets us update the next pointer on the last buffer

		 * without worrying about hardware touching it.

		 * We set the size to 0 to prevent hardware from touching this

		 * buffer.

		 * When the hardware hits the before last buffer with el-bit

		 * and size of 0, it will RNR interrupt, the RUS will go into

		 * the No Resources state.  It will not complete nor write to

		/* Now that we have a new stopping point, we can clear the old

		 * stopping point.  We must sync twice to get the proper

 ack the rnr?

	/* Set the el-bit on the buffer that is before the last buffer.

	 * This lets us update the next pointer on the last buffer without

	 * worrying about hardware touching it.

	 * We set the size to 0 to prevent hardware from touching this buffer.

	 * When the hardware hits the before last buffer with el-bit and size

	 * of 0, it will RNR interrupt, the RU will go into the No Resources

 Not our interrupt */

 Hardware is ejected */

 Ack interrupt(s) */

 We hit Receive No Resource (RNR); restart RU after cleaning */

 If budget fully consumed, continue polling */

 only re-enable interrupt if stack agrees polling is really done */

 ASF can be enabled from eeprom */

	/* enable ints _after_ enabling poll, preventing a race between

 wait here for poll to complete */

	/* Reset outside of interrupt context, to avoid request_irq

	/* Use driver resources to perform internal MAC or PHY

	 * loopback test.  A single packet is prepared and transmitted

	 * in loopback mode, and the test passes if the received

 ICH PHY loopback is broken so do MAC loopback instead */

 LEDTX and LED_RX both on */

 LEDTX and LED_RX both off */

	/* We know the number of registers, and the size of the dump buffer.

	 * Calculate the total size in bytes.

		/* Note that we read the registers in reverse order. This

		 * ordering is the ABI apparently used by ethtool and other

		 * applications.

 save speed, duplex & autoneg settings */

 restore speed, duplex & autoneg settings */

 device-specific stats */

 D100 MAC doesn't allow rx of vlan packets with normal MTU */

 locks must be initialized before calling hw_reset */

	/* Reset the device before pci_set_master() in case device is in some

	 * funky state and has an interrupt pending - hint: we don't have the

 Wol magic packet can be enabled from eeprom */

 ack any pending wake events, disable PME */

 SmartSpeed Ctrl register */

 Reverse auto-negotiation */

 Auto-negotiate now */

 enable reverse auto-negotiation */

 disable reverse auto-negotiation */

 ------------------ PCI Error Recovery infrastructure  -------------- */

/**

 * e100_io_error_detected - called when PCI error is detected.

 * @pdev: Pointer to PCI device

 * @state: The current pci connection state

 Request a slot reset. */

/**

 * e100_io_slot_reset - called after the pci bus has been reset.

 * @pdev: Pointer to PCI device

 *

 * Restart the card from scratch.

 Only one device per card can do a reset */

/**

 * e100_io_resume - resume normal operations

 * @pdev: Pointer to PCI device

 *

 * Resume normal operations after an error recovery

 * sequence has been completed.

 ack any pending wake events, disable PME */

 Power Management hooks */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c)  2018 Intel Corporation */

 required last entry */

 Repartition PBA for greater than 9k MTU if required */

	/* flow control settings

	 * The high water mark must be low enough to fit one full frame

	 * after transmitting the pause frame.  As such we must have enough

	 * space to allow for us to complete our current transmit and then

	 * receive the frame that is in progress from the link partner.

	 * Set it to:

	 * - the full Rx FIFO size minus one full Tx plus one full Rx frame

 16-byte granularity */

 Re-establish EEE setting */

 Enable HW to recognize an 802.1Q VLAN Ethernet packet */

 Re-enable PTP, where applicable. */

 Re-enable TSN offloading, where applicable. */

/**

 * igc_power_up_link - Power up the phy link

 * @adapter: address of board private structure

/**

 * igc_release_hw_control - release control of the h/w to f/w

 * @adapter: address of board private structure

 *

 * igc_release_hw_control resets CTRL_EXT:DRV_LOAD bit.

 * For ASF and Pass Through versions of f/w this means that the

 * driver is no longer loaded.

 Let firmware take over control of h/w */

/**

 * igc_get_hw_control - get control of the h/w from f/w

 * @adapter: address of board private structure

 *

 * igc_get_hw_control sets CTRL_EXT:DRV_LOAD bit.

 * For ASF and Pass Through versions of f/w this means that

 * the driver is loaded.

 Let firmware know the driver has taken over */

/**

 * igc_clean_tx_ring - Free Tx Buffers

 * @tx_ring: ring to be cleaned

 check for eop_desc to determine the end of the packet */

 unmap remaining buffers */

 unmap any remaining paged data */

 move us one more past the eop_desc for start of next pkt */

 reset BQL for queue */

 reset next_to_use and next_to_clean */

/**

 * igc_free_tx_resources - Free Tx Resources per Queue

 * @tx_ring: Tx descriptor ring for a specific queue

 *

 * Free all transmit software resources

 if not set, then don't free */

/**

 * igc_free_all_tx_resources - Free Tx Resources for All Queues

 * @adapter: board private structure

 *

 * Free all transmit software resources

/**

 * igc_clean_all_tx_rings - Free Tx Buffers for all queues

 * @adapter: board private structure

/**

 * igc_setup_tx_resources - allocate Tx resources (Descriptors)

 * @tx_ring: tx descriptor ring (for a specific queue) to setup

 *

 * Return 0 on success, negative on failure

 round up to nearest 4K */

/**

 * igc_setup_all_tx_resources - wrapper to allocate Tx resources for all queues

 * @adapter: board private structure

 *

 * Return 0 on success, negative on failure

 Free all the Rx ring sk_buffs */

		/* Invalidate cache lines that may have been written to by

		 * device so that we avoid corrupting memory.

 free resources associated with mapping */

/**

 * igc_clean_rx_ring - Free Rx Buffers per Queue

 * @ring: ring to free buffers from

/**

 * igc_clean_all_rx_rings - Free Rx Buffers for all queues

 * @adapter: board private structure

/**

 * igc_free_rx_resources - Free Rx Resources

 * @rx_ring: ring to clean the resources from

 *

 * Free all receive software resources

 if not set, then don't free */

/**

 * igc_free_all_rx_resources - Free Rx Resources for All Queues

 * @adapter: board private structure

 *

 * Free all receive software resources

/**

 * igc_setup_rx_resources - allocate Rx resources (Descriptors)

 * @rx_ring:    rx descriptor ring (for a specific queue) to setup

 *

 * Returns 0 on success, negative on failure

 Round up to nearest 4K */

/**

 * igc_setup_all_rx_resources - wrapper to allocate Rx resources

 *                                (Descriptors) for all queues

 * @adapter: board private structure

 *

 * Return 0 on success, negative on failure

/**

 * igc_configure_rx_ring - Configure a receive ring after Reset

 * @adapter: board private structure

 * @ring: receive ring to be configured

 *

 * Configure the Rx unit of the MAC after a reset.

 disable the queue */

 Set DMA base address registers */

 initialize head and tail */

 reset next-to- use/clean to place SW in sync with hardware */

 initialize rx_buffer_info */

 initialize Rx descriptor 0 */

 enable receive descriptor fetching */

/**

 * igc_configure_rx - Configure receive Unit after Reset

 * @adapter: board private structure

 *

 * Configure the Rx unit of the MAC after a reset.

	/* Setup the HW Rx Head and Tail Descriptor Pointers and

	 * the Base and Length of the Rx Descriptor Ring

/**

 * igc_configure_tx_ring - Configure transmit ring after Reset

 * @adapter: board private structure

 * @ring: tx ring to configure

 *

 * Configure a transmit ring after a reset.

 disable the queue */

/**

 * igc_configure_tx - Configure transmit Unit after Reset

 * @adapter: board private structure

 *

 * Configure the Tx unit of the MAC after a reset.

/**

 * igc_setup_mrqc - configure the multiple receive queue control registers

 * @adapter: Board private structure

	/* Disable raw packet checksumming so that RSS hash is placed in

	 * descriptor on writeback.  No need to enable TCP/UDP/IP checksum

	 * offloads as they are enabled by default

 Enable Receive Checksum Offload for SCTP */

 Don't need to set TUOFL or IPOFL, they default to 1 */

	/* Generate RSS hash based on packet types, TCP/UDP

	 * port numbers and/or IPv4/v6 src and dst addresses

/**

 * igc_setup_rctl - configure the receive control registers

 * @adapter: Board private structure

	/* enable stripping of CRC. Newer features require

	 * that the HW strips the CRC.

 disable store bad packets and clear size bits. */

 enable LPE to allow for reception of jumbo frames */

 disable queue 0 to prevent tail write w/o re-config */

 This is useful for sniffing bad packets. */

		/* UPE and MPE will be handled by normal PROMISC logic

		 * in set_rx_mode

 Receive bad packets */

 RX All Bcast Pkts */

 RX All MAC Ctrl Pkts */

 Allow filtered pause */

 Disable VLAN CFIEN Filter */

/**

 * igc_setup_tctl - configure the transmit control registers

 * @adapter: Board private structure

 disable queue 0 which icould be enabled by default */

 Program the Transmit Control Register */

 Enable transmits */

/**

 * igc_set_mac_filter_hw() - Set MAC address filter in hardware

 * @adapter: Pointer to adapter where the filter should be set

 * @index: Filter index

 * @type: MAC address filter type (source or destination)

 * @addr: MAC address

 * @queue: If non-negative, queue assignment feature is enabled and frames

 *         matching the filter are enqueued onto 'queue'. Otherwise, queue

 *         assignment is disabled.

/**

 * igc_clear_mac_filter_hw() - Clear MAC address filter in hardware

 * @adapter: Pointer to adapter where the filter should be cleared

 * @index: Filter index

 Set default MAC address for the PF in the first RAR entry */

/**

 * igc_set_mac - Change the Ethernet Address of the NIC

 * @netdev: network interface device structure

 * @p: pointer to an address structure

 *

 * Returns 0 on success, negative on failure

 set the correct pool for the new PF MAC address in entry 0 */

/**

 *  igc_write_mc_addr_list - write multicast addresses to MTA

 *  @netdev: network interface device structure

 *

 *  Writes multicast address list to the MTA hash table.

 *  Returns: -ENOMEM on failure

 *           0 on no addresses written

 *           X on writing X addresses to MTA

 nothing to program, so clear mc list */

 The shared function expects a packed array of only addresses. */

	/* FIXME: when using ETF together with taprio, we may have a

	 * case where 'delta' is larger than the cycle_time, this may

	 * cause problems if we don't read the current value of

	 * IGC_BASET, as the value writen into the launchtime

	 * descriptor field may be misinterpreted.

 set bits to identify this as an advanced context descriptor */

 For i225, context index must be unique per ring. */

	/* We assume there is always a valid Tx time available. Invalid times

	 * should have been handled by the upper layers.

 validate that this is actually an SCTP request */

 update TX checksum flag */

 memory barriier comment */

	/* We need to check again in a case another CPU has just

	 * made room available.

 A reprieve! */

 set type for advanced descriptor with frame checksum insertion */

 set HW vlan bit if vlan is present */

 set segmentation bits for TSO */

 set timestamp bit if present */

 insert frame checksum */

 insert L4 checksum */

 insert IPv4 checksum */

 record length, and DMA address */

 write last descriptor with RS and EOP bits */

 set the timestamp */

	/* Force memory writes to complete before letting h/w know there

	 * are new descriptors to fetch.  (Only applicable for weak-ordered

	 * memory model archs, such as IA-64).

	 *

	 * We also need this memory barrier to make certain all of the

	 * status bits have been updated before next_to_watch is written.

 set next_to_watch value indicating a packet is present */

 Make sure there is space in the ring for the next send. */

 clear dma mappings for failed tx_buffer_info map */

 ADV DTYP TUCMD MKRLOC/ISCSIHEDLEN */

 initialize outer IP header fields */

		/* IP header will have to cancel out any data that

		 * is not a part of the outer IP header

 determine offset of inner transport header */

 remove payload length from inner checksum */

 compute length of segmentation header */

 compute length of segmentation header */

 update gso size and bytecount with header size */

 MSS L4LEN IDX */

 VLAN MACLEN IPLEN */

	/* need: 1 descriptor per page * PAGE_SIZE/IGC_MAX_DATA_PER_TXD,

	 *	+ 1 desc for skb_headlen/IGC_MAX_DATA_PER_TXD,

	 *	+ 2 desc gap to keep tail from touching head,

	 *	+ 1 desc for context descriptor,

	 * otherwise try next time

 this is a hard error */

 record the location of the first descriptor for this packet */

		/* FIXME: add support for retrieving timestamps from

		 * the other timer registers before skipping the

		 * timestamping request.

 record initial flags and protocol */

	/* The minimum packet size with TCTL.PSP set is 17 so pad the skb

	 * in order to meet this minimum size requirement.

 Ignore Checksum bit is set */

 Rx checksum disabled via ethtool */

 TCP/UDP checksum error bit is set */

		/* work around errata with sctp packets where the TCPE aka

		 * L4E bit is set incorrectly on 64 byte (60 byte w/o crc)

		 * packets (aka let the stack check the crc32c)

 let the stack verify checksum errors */

 It must be a TCP or UDP packet with a valid checksum */

/**

 * igc_process_skb_fields - Populate skb header fields from Rx descriptor

 * @rx_ring: rx descriptor ring packet is being transacted on

 * @rx_desc: pointer to the EOP Rx descriptor

 * @skb: pointer to current skb being populated

 *

 * This function checks the ring, descriptor, and packet information in order

 * to populate the hash, checksum, VLAN, protocol, and other fields within the

 * skb.

 enable VLAN tag insert/strip */

 disable VLAN tag insert/strip */

 we are reusing so sync this buffer for CPU use */

/**

 * igc_add_rx_frag - Add contents of Rx buffer to sk_buff

 * @rx_ring: rx descriptor ring to transact packets on

 * @rx_buffer: buffer containing page to add

 * @skb: sk_buff to place the data into

 * @size: size of buffer to be added

 *

 * This function will add the data contained in rx_buffer->page to the skb.

 prefetch first cache line of first page */

 build an skb around the page buffer */

 update pointers within the skb to store the data */

 prefetch first cache line of first page */

 allocate a skb to store the frags */

 Determine available headroom for copy */

 align pull length to size of long to optimize memcpy performance */

 update all of the pointers */

/**

 * igc_reuse_rx_page - page flip buffer and store it back on the ring

 * @rx_ring: rx descriptor ring to store buffers on

 * @old_buff: donor buffer to have page reused

 *

 * Synchronizes page for reuse by the adapter

 update, and store next to alloc */

	/* Transfer page from old buffer to new buffer.

	 * Move each member individually to avoid possible store

	 * forwarding stalls.

 avoid re-using remote and pfmemalloc pages */

 if we are only owner of page we can reuse it */

	/* If we have drained the page fragment pool we need to update

	 * the pagecnt_bias and page count so that we fully restock the

	 * number of references the driver holds.

/**

 * igc_is_non_eop - process handling of non-EOP buffers

 * @rx_ring: Rx ring being processed

 * @rx_desc: Rx descriptor for current buffer

 *

 * This function updates next to clean.  If the buffer is an EOP buffer

 * this function exits returning false, otherwise it will place the

 * sk_buff in the next buffer to be chained and return true indicating

 * that this is in fact a non-EOP buffer.

 fetch, update, and store next to clean */

/**

 * igc_cleanup_headers - Correct corrupted or empty headers

 * @rx_ring: rx descriptor ring packet is being transacted on

 * @rx_desc: pointer to the EOP Rx descriptor

 * @skb: pointer to current skb being fixed

 *

 * Address the case where we are pulling data in on pages only

 * and as such no data is present in the skb header.

 *

 * In addition if skb is not at least 60 bytes we need to pad it so that

 * it is large enough to qualify as a valid Ethernet frame.

 *

 * Returns true if an error was encountered and skb was freed.

 XDP packets use error pointer so abort at this point */

 if eth_skb_pad returns an error the skb was freed */

 hand second half of page back to the ring */

		/* We are not reusing the buffer so unmap it and free

		 * any references we are holding to it

 clear contents of rx_buffer */

 since we are recycling buffers we should seldom need to alloc */

 alloc new page for storage */

 map page for use */

	/* if mapping failed free memory back to system since

	 * there isn't much point in holding memory we can't use

/**

 * igc_alloc_rx_buffers - Replace used receive buffers; packet split

 * @rx_ring: rx descriptor ring

 * @cleaned_count: number of buffers to clean

 nothing to do */

 sync the buffer for use by the device */

		/* Refresh the desc even if buffer_addrs didn't change

		 * because each write-back erases this info.

 clear the length for the next_to_use descriptor */

 record the next descriptor to use */

 update next to alloc since we have filled the ring */

		/* Force memory writes to complete before letting h/w

		 * know there are new descriptors to fetch.  (Only

		 * applicable for weak-ordered memory model archs,

		 * such as IA-64).

 Clear the length for the next_to_use descriptor. */

		/* Force memory writes to complete before letting h/w

		 * know there are new descriptors to fetch.  (Only

		 * applicable for weak-ordered memory model archs,

		 * such as IA-64).

 This function requires __netif_tx_lock is held by the caller. */

 This function assumes rcu_read_lock() is held by the caller. */

 This function assumes __netif_tx_lock is held by the caller. */

	/* Once tail pointer is updated, hardware can fetch the descriptors

	 * any time so we issue a write membar here to ensure all memory

	 * writes are complete before the tail pointer is updated.

 return some buffers to hardware, one at a time is too slow */

		/* This memory barrier is needed to keep us from reading

		 * any other fields out of the rx_desc until we know the

		 * descriptor has been written back

 exit if we failed to retrieve a buffer */

 fetch next buffer in frame if non-eop */

 verify the packet layout is correct */

 probably a little skewed due to removing CRC */

 populate checksum, VLAN, and protocol */

 reset skb pointer */

 update budget accounting */

 place incomplete frames back on ring for completion */

		/* This memory barrier is needed to keep us from reading

		 * any other fields out of the rx_desc until we know the

		 * descriptor has been written back

			/* HW timestamp has been copied into local variable. Metadata

			 * length when XDP program is called should be 0.

/**

 * igc_clean_tx_irq - Reclaim resources after transmit completes

 * @q_vector: pointer to q_vector containing needed info

 * @napi_budget: Used to determine if we are in netpoll

 *

 * returns true if ring is completely cleaned

 if next_to_watch is not set then there is no work pending */

 prevent any other reads prior to eop_desc */

 if DD is not set pending work has not been completed */

 clear next_to_watch to prevent false hangs */

 update the statistics for this packet */

 clear last DMA location and unmap remaining buffers */

 unmap any remaining paged data */

 move us one more past the eop_desc for start of next pkt */

 issue prefetch for next Tx descriptor */

 update budget accounting */

		/* Detect a transmit hang in hardware, this serializes the

		 * check with the clearing of time_stamp and movement of i

 detected Tx unit hang */

 we are about to reset, no point in enabling stuff */

		/* Make sure that anybody stopping the queue after this

		 * sees the new next_to_clean.

/**

 * igc_add_mac_filter() - Add MAC address filter

 * @adapter: Pointer to adapter where the filter should be added

 * @type: MAC address filter type (source or destination)

 * @addr: MAC address

 * @queue: If non-negative, queue assignment feature is enabled and frames

 *         matching the filter are enqueued onto 'queue'. Otherwise, queue

 *         assignment is disabled.

 *

 * Return: 0 in case of success, negative errno code otherwise.

/**

 * igc_del_mac_filter() - Delete MAC address filter

 * @adapter: Pointer to adapter where the filter should be deleted from

 * @type: MAC address filter type (source or destination)

 * @addr: MAC address

		/* If this is the default filter, we don't actually delete it.

		 * We just reset to its default value i.e. disable queue

		 * assignment.

/**

 * igc_add_vlan_prio_filter() - Add VLAN priority filter

 * @adapter: Pointer to adapter where the filter should be added

 * @prio: VLAN priority value

 * @queue: Queue number which matching frames are assigned to

 *

 * Return: 0 in case of success, negative errno code otherwise.

/**

 * igc_del_vlan_prio_filter() - Delete VLAN priority filter

 * @adapter: Pointer to adapter where the filter should be deleted from

 * @prio: VLAN priority value

/**

 * igc_add_etype_filter() - Add ethertype filter

 * @adapter: Pointer to adapter where the filter should be added

 * @etype: Ethertype value

 * @queue: If non-negative, queue assignment feature is enabled and frames

 *         matching the filter are enqueued onto 'queue'. Otherwise, queue

 *         assignment is disabled.

 *

 * Return: 0 in case of success, negative errno code otherwise.

/**

 * igc_del_etype_filter() - Delete ethertype filter

 * @adapter: Pointer to adapter where the filter should be deleted from

 * @etype: Ethertype value

 Indirect table select register */

 Normalize index down to host table register */

	/* Length has to be aligned to 8. Otherwise the filter will fail. Bail

	 * out early to avoid surprises later.

 Select corresponding flex filter register and get base for host table. */

	/* When adding a filter globally disable flex filter feature. That is

	 * recommended within the datasheet.

 Configure filter */

 Write data (128 byte) and mask (128 bit) */

 Write row: dw0, dw1 and mask */

 mask is only valid for MASK(7, 0) */

 Enable filter. */

 Filter 0-7 are enabled via WUFC. The other 24 filters are not. */

 data */

 mask */

	/* Construct the flex filter:

	 *  -> dest_mac [6]

	 *  -> src_mac [6]

	 *  -> tpid [2]

	 *  -> vlan tci [2]

	 *  -> ether type [2]

	 *  -> user data [8]

	 *  -> = 26 bytes => 32 length

 Add destination MAC  */

 Add source MAC */

 Add VLAN etype */

 Add VLAN TCI */

 Add Ether type */

 Add user data */

 Add it down to the hardware and enable it. */

	/* Just disable the filter. The filter table itself is kept

	 * intact. Another flex_filter_add() should override the "old" data

	 * then.

 No filters are in use, we may disable flex filters */

/**

 * igc_get_nfc_rule() - Get NFC rule

 * @adapter: Pointer to adapter

 * @location: Rule location

 *

 * Context: Expects adapter->nfc_rule_lock to be held by caller.

 *

 * Return: Pointer to NFC rule at @location. If not found, NULL.

/**

 * igc_del_nfc_rule() - Delete NFC rule

 * @adapter: Pointer to adapter

 * @rule: Pointer to rule to be deleted

 *

 * Disable NFC rule in hardware and delete it from adapter.

 *

 * Context: Expects adapter->nfc_rule_lock to be held by caller.

/**

 * igc_add_nfc_rule() - Add NFC rule

 * @adapter: Pointer to adapter

 * @rule: Pointer to rule to be added

 *

 * Enable NFC rule in hardware and add it to adapter.

 *

 * Context: Expects adapter->nfc_rule_lock to be held by caller.

 *

 * Return: 0 on success, negative errno on failure.

/**

 * igc_set_rx_mode - Secondary Unicast, Multicast and Promiscuous mode set

 * @netdev: network interface device structure

 *

 * The set_rx_mode entry point is called whenever the unicast or multicast

 * address lists or the network interface flags are updated.  This routine is

 * responsible for configuring the hardware for proper unicast, multicast,

 * promiscuous mode, and all-multi behavior.

 Check for Promiscuous and All Multicast modes */

			/* Write addresses to the MTA, if the attempt fails

			 * then we should just turn on promiscuous mode so

			 * that we can at least receive multicast traffic

	/* Write addresses to available RAR registers, if there is not

	 * sufficient space to store all the addresses then enable

	 * unicast promiscuous mode

 update state of unicast and multicast */

/**

 * igc_configure - configure the hardware for RX and TX

 * @adapter: private board structure

	/* call igc_desc_unused which always leaves

	 * at least 1 descriptor unused to make sure

	 * next_to_use != next_to_clean

/**

 * igc_write_ivar - configure ivar for given MSI-X vector

 * @hw: pointer to the HW structure

 * @msix_vector: vector number we are allocating to a given ring

 * @index: row index of IVAR register to write within IVAR table

 * @offset: column offset of in IVAR, should be multiple of 8

 *

 * The IVAR table consists of 2 columns,

 * each containing an cause allocation for an Rx and Tx ring, and a

 * variable number of rows depending on the number of queues supported.

 clear any bits that are currently set */

 write vector and valid bit */

 add q_vector eims value to global eims_enable_mask */

 configure q_vector to set itr on first interrupt */

/**

 * igc_configure_msix - Configure MSI-X hardware

 * @adapter: Pointer to adapter structure

 *

 * igc_configure_msix sets up the hardware to properly

 * generate MSI-X interrupts.

 set vector for other causes, i.e. link changes */

		/* Turn on MSI-X capability first, or our settings

		 * won't stick.  And it will take days to debug.

 enable msix_other interrupt */

 do nothing, since nothing else supports MSI-X */

 switch (hw->mac.type) */

/**

 * igc_irq_enable - Enable default interrupt generation settings

 * @adapter: board private structure

/**

 * igc_irq_disable - Mask off interrupt generation on the NIC

 * @adapter: board private structure

 Determine if we need to pair queues. */

	/* If rss_queues > half of max_rss_queues, pair the queues in

	 * order to conserve interrupts due to limited supply.

/**

 * igc_reset_q_vector - Reset config for interrupt vector

 * @adapter: board private structure to initialize

 * @v_idx: Index of vector to be reset

 *

 * If NAPI is enabled it will delete any references to the

 * NAPI struct. This is preparation for igc_free_q_vector.

	/* if we're coming from igc_set_interrupt_capability, the vectors are

	 * not yet allocated

/**

 * igc_free_q_vector - Free memory allocated for specific interrupt vector

 * @adapter: board private structure to initialize

 * @v_idx: Index of vector to be freed

 *

 * This function frees the memory allocated to the q_vector.

	/* igc_get_stats64() might access the rings on this vector,

	 * we must wait a grace period before freeing it.

/**

 * igc_free_q_vectors - Free memory allocated for interrupt vectors

 * @adapter: board private structure to initialize

 *

 * This function frees the memory allocated to the q_vectors.  In addition if

 * NAPI is enabled it will delete any references to the NAPI struct prior

 * to freeing the q_vector.

/**

 * igc_update_itr - update the dynamic ITR value based on statistics

 * @q_vector: pointer to q_vector

 * @ring_container: ring info to update the itr for

 *

 * Stores a new ITR value based on packets and byte

 * counts during the last interrupt.  The advantage of per interrupt

 * computation is faster updates and more accurate ITR for the current

 * traffic pattern.  Constants in this function were computed

 * based on theoretical maximum wire speed and thresholds were set based

 * on testing data as well as attempting to minimize response time

 * while increasing bulk throughput.

 * NOTE: These calculations are only valid when operating in a single-

 * queue environment.

 no packets, exit with status unchanged */

 handle TSO and jumbo frames */

 50 usec aka 20000 ints/s */

 this if handles the TSO accounting */

 250 usec aka 4000 ints/s */

 clear work counters since we have the values we need */

 write updated itr to ring container */

 for non-gigabit speeds, just fix the interrupt rate at 4000 */

 conservative mode (itr 3) eliminates the lowest_latency setting */

 counts and packets in update_itr are dependent on these numbers */

 70,000 ints/sec */

 20,000 ints/sec */

 4,000 ints/sec */

		/* this attempts to bias the interrupt rate towards Bulk

		 * by adding intermediate steps when interrupt rate is

		 * increasing

		/* Don't write the value here; it resets the adapter's

		 * internal timer, and causes us to delay far longer than

		 * we should between interrupts.  Instead, we write the ITR

		 * value at the beginning of the next interrupt so the timing

		 * ends up being correct.

/**

 * igc_set_interrupt_capability - set MSI or MSI-X if supported

 * @adapter: Pointer to adapter structure

 * @msix: boolean value for MSI-X capability

 *

 * Attempt to configure interrupts using the best available

 * capabilities of the hardware and kernel.

 Number of supported queues. */

 start with one vector for every Rx queue */

 if Tx handler is separate add 1 for every Tx queue */

 store the number of vectors reserved for queues */

 add 1 vector for link status interrupts */

 populate entry values */

/**

 * igc_update_ring_itr - update the dynamic ITR value based on packet size

 * @q_vector: pointer to q_vector

 *

 * Stores a new ITR value based on strictly on packet size.  This

 * algorithm is less sophisticated than that used in igc_update_itr,

 * due to the difficulty of synchronizing statistics across multiple

 * receive rings.  The divisors and thresholds used by this function

 * were determined based on theoretical maximum wire speed and testing

 * data, in order to minimize response time while increasing bulk

 * throughput.

 * NOTE: This function is called only when operating in a multiqueue

 * receive environment.

	/* For non-gigabit speeds, just fix the interrupt rate at 4000

	 * ints/sec - ITR timer value of 120 ticks.

 if avg_wire_size isn't set no work was done */

 Add 24 bytes to size to account for CRC, preamble, and gap */

 Don't starve jumbo frames */

 Give a little boost to mid-size frames */

 conservative mode (itr 3) eliminates the lowest_latency setting */

/**

 * igc_cache_ring_register - Descriptor ring to register mapping

 * @adapter: board private structure to initialize

 *

 * Once we know the feature-set enabled for the device, we'll cache

 * the register offset the descriptor ring is assigned to.

/**

 * igc_poll - NAPI Rx polling callback

 * @napi: napi polling structure

 * @budget: count of how many packets we should handle

 If all work not completed, return budget and keep polling */

	/* Exit the polling mode, but don't re-enable interrupts if stack might

	 * poll us due to busy-polling

/**

 * igc_alloc_q_vector - Allocate memory for a single interrupt vector

 * @adapter: board private structure to initialize

 * @v_count: q_vectors allocated on adapter, used for ring interleaving

 * @v_idx: index of vector in adapter struct

 * @txr_count: total number of Tx rings to allocate

 * @txr_idx: index of first Tx ring to allocate

 * @rxr_count: total number of Rx rings to allocate

 * @rxr_idx: index of first Rx ring to allocate

 *

 * We allocate one q_vector.  If allocation fails we return -ENOMEM.

 igc only supports 1 Tx and/or 1 Rx queue per vector */

 allocate q_vector and rings */

 initialize NAPI */

 tie q_vector and adapter together */

 initialize work limits */

 initialize ITR configuration */

 initialize pointer to rings */

 initialize ITR */

 rx or rx/tx vector */

 tx only vector */

 assign generic ring traits */

 configure backlink on ring */

 update q_vector Tx values */

 apply Tx specific ring traits */

 assign ring to adapter */

 push pointer to next ring */

 assign generic ring traits */

 configure backlink on ring */

 update q_vector Rx values */

 apply Rx specific ring traits */

 assign ring to adapter */

/**

 * igc_alloc_q_vectors - Allocate memory for interrupt vectors

 * @adapter: board private structure to initialize

 *

 * We allocate one q_vector per queue interrupt.  If allocation fails we

 * return -ENOMEM.

 update counts and index */

 update counts and index */

/**

 * igc_init_interrupt_scheme - initialize interrupts, allocate queues/vectors

 * @adapter: Pointer to adapter structure

 * @msix: boolean for MSI-X capability

 *

 * This function initializes the interrupts and allocates all of the queues.

/**

 * igc_sw_init - Initialize general software structures (struct igc_adapter)

 * @adapter: board private structure to initialize

 *

 * igc_sw_init initializes the Adapter private data structure.

 * Fields are initialized based on PCI device information and

 * OS network device settings (MTU size).

 set default ring sizes */

 set default ITR values */

 set default work limits */

 adjust max frame to be at least the size of a standard frame */

 Assume MSI-X interrupts, will be checked during IRQ allocation */

 This call may decrease the number of queues */

 Explicitly disable IRQ since the NIC can be in any state. */

/**

 * igc_up - Open the interface and prepare it to handle traffic

 * @adapter: board private structure

 hardware has been reset, we need to reload some things */

 Clear any pending interrupts. */

 start the watchdog. */

/**

 * igc_update_stats - Update the board statistics counters

 * @adapter: board private structure

	/* Prevent stats update while adapter is being reset, or if the pci

	 * connection is down.

 read stats registers */

 clear GORCL */

 clear GOTCL */

 Fill out the OS statistics structure */

 Rx Errors */

	/* RLEC on some newer hardware can be incorrect so build

	 * our own version based on RUC and ROC

 Tx Errors */

 Tx Dropped needs to be maintained elsewhere */

 Management Stats */

/**

 * igc_down - Close the interface

 * @adapter: board private structure

 disable receives in the hardware */

 flush and sleep below */

 set trans_start so we don't get spurious watchdogs during reset */

 disable transmits in the hardware */

 flush both disables and wait for them to finish */

 record the stats before reset*/

 clear VLAN promisc flag so VFTA will be updated if necessary */

 If we're already down or resetting, just bail */

/**

 * igc_change_mtu - Change the Maximum Transfer Unit

 * @netdev: network interface device structure

 * @new_mtu: new value for maximum frame size

 *

 * Returns 0 on success, negative on failure

 adjust max frame to be at least the size of a standard frame */

 igc_down has a dependency on max_frame_size */

/**

 * igc_get_stats64 - Get System Network Statistics

 * @netdev: network interface device structure

 * @stats: rtnl_link_stats64 pointer

 *

 * Returns the address of the device statistics structure.

 * The statistics are updated here and also from the timer callback.

	/* Since there is no support for separate Rx/Tx vlan accel

	 * enable/disable make sure Tx flag is always in same state as Rx.

 Add VLAN support */

 Make certain the headers can be described by a context descriptor */

	/* We can only support IPv4 TSO in tunnels if we can mangle the

	 * inner IP ID field, so strip TSO if MANGLEID is not supported.

 retrieve hardware timestamp */

 acknowledge the interrupts */

/**

 * igc_msix_other - msix other interrupt handler

 * @irq: interrupt number

 * @data: pointer to a q_vector

 reading ICR causes bit 31 of EICR to be cleared */

 HW is reporting DMA is out of sync */

 guard against interrupt when we're going down */

 Write the ITR value calculated from the previous interrupt. */

/**

 * igc_request_msix - Initialize MSI-X interrupts

 * @adapter: Pointer to adapter structure

 *

 * igc_request_msix allocates MSI-X vectors and requests interrupts from the

 * kernel.

 free already assigned IRQs */

/**

 * igc_clear_interrupt_scheme - reset the device to a state of no interrupts

 * @adapter: Pointer to adapter structure

 *

 * This function resets the device so that it has 0 rx queues, tx queues, and

 * MSI-X interrupts allocated.

/* Need to wait a few seconds after link up to get diagnostic information from

 * the phy

/**

 * igc_has_link - check shared code for link and determine up/down

 * @adapter: pointer to driver private info

	/* get_link_status is set on LSC (link status) interrupt or

	 * rx sequence error interrupt.  get_link_status will stay

	 * false until the igc_check_for_link establishes link

	 * for copper adapters ONLY

/**

 * igc_watchdog - Timer Call-back

 * @t: timer for the watchdog

 Do the rest outside of interrupt context */

 Cancel scheduled suspend requests. */

 Link status message must follow this format */

 disable EEE if enabled */

 check if SmartSpeed worked */

 adjust timeout factor according to speed/duplex */

 wait for Remote receiver status OK */

 link state has changed, schedule phy info update */

 Links status message must follow this format */

 link state has changed, schedule phy info update */

 link is down, time to check for alternate media */

 return immediately */

 also check for alternate media here */

 return immediately */

			/* We've lost link, so the controller stops DMA,

			 * but we've got queued Tx work that's never going

			 * to get done, so reset controller to flush Tx.

			 * (Do the reset outside of interrupt context).

 return immediately since reset is imminent */

 Force detection of hung controller every watchdog period */

 Cause software interrupt to ensure Rx ring is cleaned */

 Reset the timer */

/**

 * igc_intr_msi - Interrupt Handler

 * @irq: interrupt number

 * @data: pointer to a network interface device structure

 read ICR disables interrupts using IAM */

 HW is reporting DMA is out of sync */

/**

 * igc_intr - Legacy Interrupt Handler

 * @irq: interrupt number

 * @data: pointer to a network interface device structure

	/* Interrupt Auto-Mask...upon reading ICR, interrupts are masked.  No

	 * need for the IMC write

	/* IMS will not auto-mask if INT_ASSERTED is not set, and if it is

	 * not set, then the adapter didn't send an interrupt

 HW is reporting DMA is out of sync */

 guard against interrupt when we're going down */

/**

 * igc_request_irq - initialize interrupts

 * @adapter: Pointer to adapter structure

 *

 * Attempts to configure interrupts using the best available

 * capabilities of the hardware and kernel.

 fall back to MSI */

 fall back to legacy interrupts */

/**

 * __igc_open - Called when a network interface is made active

 * @netdev: network interface device structure

 * @resuming: boolean indicating if the device is resuming

 *

 * Returns 0 on success, negative value on failure

 *

 * The open entry point is called when a network interface is made

 * active by the system (IFF_UP).  At this point all resources needed

 * for transmit and receive operations are allocated, the interrupt

 * handler is registered with the OS, the watchdog timer is started,

 * and the stack is notified that the interface is ready.

 disallow open during test */

 allocate transmit descriptors */

 allocate receive descriptors */

 Notify the stack of the actual queue counts. */

 Clear any pending interrupts. */

 start the watchdog. */

/**

 * __igc_close - Disables a network interface

 * @netdev: network interface device structure

 * @suspending: boolean indicating the device is suspending

 *

 * Returns 0, this is not allowed to fail

 *

 * The close entry point is called when an interface is de-activated

 * by the OS.  The hardware is still under the driver's control, but

 * needs to be disabled.  A global MAC reset is issued to stop the

 * hardware, and all transmit and receive resources are freed.

/**

 * igc_ioctl - Access the hwtstamp interface

 * @netdev: network interface device structure

 * @ifr: interface request data

 * @cmd: ioctl command

	/* If we program the controller's BASET registers with a time

	 * in the future, it will hold all the packets until that

	 * time, causing a lot of TX Hangs, so to avoid that, we

	 * reject schedules that would start in the future.

		/* i225 only supports "global" frame preemption

		 * settings.

	/* FIXME: be a little smarter about cases when the gate for a

	 * queue stays open for more than one entry.

	/* i225 has two sets of credit-based shaper logic.

	 * Supporting it only on the top two priority queues

	/* CBS should be enabled on the highest priority queue first in order

	 * for the CBS algorithm to operate as intended.

 PCIe configuration access */

 reads should not return all F's */

	/* Make sure dplx is at most 1 bit and lsb of speed is not set

	 * for the switch() below to work

 not supported */

 not supported */

 clear MDI, MDI(-X) override is only allowed when autoneg enabled */

/**

 * igc_probe - Device Initialization Routine

 * @pdev: PCI device information struct

 * @ent: entry in igc_pci_tbl

 *

 * Returns 0 on success, negative on failure

 *

 * igc_probe initializes an adapter identified by a pci_dev structure.

 * The OS initialization, configuring the adapter private structure,

 * and a hardware reset occur.

 hw->hw_addr can be zeroed, so use adapter->io_addr for unmap */

 PCI config space info */

 Copy the default MAC and PHY function pointers */

 Initialize skew-specific constants */

 Add supported features to the features list*/

 setup the private structure */

 copy netdev features into list of user selectable features */

 MTU range: 68 - 9216 */

	/* before reading the NVM, reset the controller to put the device in a

	 * known good starting state

 copy the MAC address out of the NVM */

 configure RXPBSIZE and TXPBSIZE */

 Initialize link properties that are user-changeable */

 By default, support wake on port A */

 initialize the wol settings based on the eeprom settings */

 reset the hardware with the new settings */

	/* let the f/w know that the h/w is now under the control of the

	 * driver.

 carrier off reporting is important to ethtool even BEFORE open */

 Check if Media Autosense is enabled */

 print pcie link status and MAC address */

 Disable EEE for internal PHY devices */

/**

 * igc_remove - Device Removal Routine

 * @pdev: PCI device information struct

 *

 * igc_remove is called by the PCI subsystem to alert the driver

 * that it should release a PCI device.  This could be caused by a

 * Hot-Plug event, or because the driver is going to be removed from

 * memory.

	/* Release control of h/w to f/w.  If f/w is AMT enabled, this

	 * would have already happened in close and is redundant.

 turn on all-multi mode if wake on multicast is enabled */

 Allow time for pending master requests to run */

	/* Release control of h/w to f/w.  If f/w is AMT enabled, this

	 * would have already happened in close and is redundant.

	/* WUPM stores only the first 128 bytes of the wake packet.

	 * Read the packet only if we have the whole thing.

 Ensure reads are 32-bit aligned */

	/* let the f/w know that the h/w is now under the control of the

	 * driver.

 CONFIG_PM */

/**

 *  igc_io_error_detected - called when PCI error is detected

 *  @pdev: Pointer to PCI device

 *  @state: The current PCI connection state

 *

 *  This function is called after a PCI bus error affecting

 *  this device has been detected.

 Request a slot reset. */

/**

 *  igc_io_slot_reset - called after the PCI bus has been reset.

 *  @pdev: Pointer to PCI device

 *

 *  Restart the card from scratch, as if from a cold-boot. Implementation

 *  resembles the first-half of the igc_resume routine.

		/* In case of PCI error, adapter loses its HW address

		 * so we should re-assign it here.

/**

 *  igc_io_resume - called when traffic can start to flow again.

 *  @pdev: Pointer to PCI device

 *

 *  This callback is called when the error recovery driver tells us that

 *  its OK to resume normal operation. Implementation resembles the

 *  second-half of the igc_resume routine.

	/* let the f/w know that the h/w is now under the control of the

	 * driver.

/**

 * igc_reinit_queues - return error

 * @adapter: pointer to adapter structure

/**

 * igc_get_hw_dev - return device

 * @hw: pointer to hardware structure

 *

 * used by hardware layer to print debugging information

/**

 * igc_init_module - Driver Registration Routine

 *

 * igc_init_module is the first routine called when the driver is

 * loaded. All it does is register with the PCI subsystem.

/**

 * igc_exit_module - Driver Exit Cleanup Routine

 *

 * igc_exit_module is called just before the driver is removed

 * from memory.

 igc_main.c */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020, Intel Corporation. */

		/* For now, the driver doesn't support XDP functionality with

		 * jumbo frames so we return error.

		/* When XDP is enabled, the driver doesn't support frames that

		 * span over multiple buffers. To avoid that, we check if xsk

		 * frame size is big enough to fit the max ethernet frame size

		 * + vlan double tagging.

 Rx and Tx rings share the same napi context. */

 Rx and Tx rings share the same napi context. */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c)  2018 Intel Corporation */

 ethtool support for igc */

 forward declaration */

 packets, bytes, restart_queue */

 NVM image version is reported as firmware version for i225 device */

 gPHY firmware version is reported as PHY FW version */

 General Registers */

 NVM Register */

 Interrupt */

	/* Reading EICS for EICR because they read the

	 * same but EICS does not clear on read

	/* Reading ICS for ICR because they read the

	 * same but ICS does not clear on read

 Flow Control */

 Receive */

 Transmit */

 Wake Up */

 MAC */

 Statistics */

	/* XXX: Due to a bug few lines above, RAL and RAH registers are

	 * overwritten. To preserve the ABI, we write these registers again in

	 * regs_buff.

 apply any specific unsupported masks here */

 these settings will always override what we currently have */

	/* If the link is not reported up to netdev, interrupts are disabled,

	 * and so the physical link state may have changed since we last

	 * looked. Set get_link_status to make sure that the true link

	 * state is interrogated, rather than pulling a cached and possibly

	 * stale link state from the driver.

 Device's eeprom is always little-endian, word addressable */

		/* need read/modify/write of first changed EEPROM word

		 * only the second byte of the word is being modified

		/* need read/modify/write of last changed EEPROM word

		 * only the first byte of the word is being modified

 Device's eeprom is always little-endian, word addressable */

 Update the checksum if nvm write succeeded */

 nothing to do */

	/* We can't just free everything and then setup again,

	 * because the ISRs in MSI-X mode get passed pointers

	 * to the Tx and Rx ring structs.

 BUG_ON(p - data != IGC_STATS_LEN * ETH_GSTRING_LEN); */

 If ITR is disabled, disable DMAC */

 convert to rate of irq's per second */

 convert to rate of irq's per second */

 Report default options for RSS on igc */

	/* RSS does not support anything other than hashing

	 * to queues on src and dst IPs and ports

 if we changed something we need to update flags */

 Perform hash on these packet types */

	/* Both source and destination address filters only support the full

	 * mask.

 VLAN etype matching */

 Check for user defined data */

	/* When multiple filter options or user data or vlan etype is set, use a

	 * flex filter.

/**

 * igc_ethtool_check_nfc_rule() - Check if NFC rule is valid

 * @adapter: Pointer to adapter

 * @rule: Rule under evaluation

 *

 * The driver doesn't support rules with multiple matches so if more than

 * one bit in filter flags is set, @rule is considered invalid.

 *

 * Also, if there is already another rule with the same filter in a different

 * location, @rule is considered invalid.

 *

 * Context: Expects adapter->nfc_rule_lock to be held by caller.

 *

 * Return: 0 in case of success, negative errno code otherwise.

 We do not allow change in unsupported parameters */

 Verify user input. */

 Report maximum channels */

 Report info for other vector */

 Verify they are not requesting separate vectors */

 Verify other_count is valid and has not been changed */

 Verify the number of channels doesn't exceed hw limits */

		/* Hardware has to reinitialize queues and interrupts to

		 * match the new configuration.

 reset interface to repopulate queues */

 EEE status on negotiated link */

	/* Report correct negotiated EEE status for devices that

	 * wrongly report EEE at half-duplex

 Tx LPI timer is not implemented currently */

 reset link */

 supported link modes */

 twisted pair */

 advertising link modes */

 set autoneg settings */

 Set pause flow control settings */

			/* For I225, STATUS will indicate 1G speed in both

			 * 1 Gbps and 2.5 Gbps link modes.

			 * An additional bit is used

			 * to differentiate between 1 Gbps and 2.5 Gbps.

 MDI-X => 2; MDI =>1; Invalid =>0 */

	/* When adapter in resetting mode, autoneg/speed/duplex

	 * cannot be changed

	/* MDI setting is only allowed when autoneg enabled because

	 * some hardware doesn't allow MDI setting when speed or

	 * duplex is forced.

	/* Converting to legacy u32 drops ETHTOOL_LINK_MODE_2500baseT_Full_BIT.

	 * We have to check this and convert it to ADVERTISE_2500_FULL

	 * (aka ETHTOOL_LINK_MODE_2500baseX_Full_BIT) explicitly.

 MDI-X => 2; MDI => 1; Auto => 3 */

		/* fix up the value for auto (3 => 0) as zero is mapped

		 * internally to auto

 reset the link */

		/* Link test performed before hardware reset so autoneg doesn't

		 * interfere with test result

		/* loopback and interrupt tests

		 * will be implemented in the future

 register, eeprom, intr and loopback tests not run online */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c)  2018 Intel Corporation */

/**

 * igc_check_reset_block - Check if PHY reset is blocked

 * @hw: pointer to the HW structure

 *

 * Read the PHY management control register and check whether a PHY reset

 * is blocked.  If a reset is not blocked return 0, otherwise

 * return IGC_ERR_BLK_PHY_RESET (12).

/**

 * igc_get_phy_id - Retrieve the PHY ID and revision

 * @hw: pointer to the HW structure

 *

 * Reads the PHY registers and stores the PHY ID and possibly the PHY

 * revision in the hardware structure.

/**

 * igc_phy_has_link - Polls PHY for link

 * @hw: pointer to the HW structure

 * @iterations: number of times to poll for link

 * @usec_interval: delay between polling attempts

 * @success: pointer to whether polling was successful or not

 *

 * Polls the PHY status register for link, 'iterations' number of times.

		/* Some PHYs require the PHY_STATUS register to be read

		 * twice due to the link bit being sticky.  No harm doing

		 * it across the board.

			/* If the first read fails, another entity may have

			 * ownership of the resources, wait and try again to

			 * see if they have relinquished the resources yet.

/**

 * igc_power_up_phy_copper - Restore copper link in case of PHY power down

 * @hw: pointer to the HW structure

 *

 * In the case of a PHY power down to save power, or to turn off link during a

 * driver unload, restore the link to previous settings.

 The PHY will retain its settings across a power down/up cycle */

/**

 * igc_power_down_phy_copper - Power down copper PHY

 * @hw: pointer to the HW structure

 *

 * Power down PHY to save power when interface is down and wake on lan

 * is not enabled.

 The PHY will retain its settings across a power down/up cycle */

	/* Temporary workaround - should be removed when PHY will implement

	 * IEEE registers as properly

 hw->phy.ops.write_reg(hw, PHY_CONTROL, mii_reg);*/

/**

 * igc_check_downshift - Checks whether a downshift in speed occurred

 * @hw: pointer to the HW structure

 *

 * Success returns 0, Failure returns 1

 *

 * A downshift is detected by querying the PHY link health.

 speed downshift not supported */

/**

 * igc_phy_hw_reset - PHY hardware reset

 * @hw: pointer to the HW structure

 *

 * Verify the reset block is not blocking us from resetting.  Acquire

 * semaphore (if necessary) and read/set/write the device control reset

 * bit in the PHY.  Wait the appropriate delay time for the device to

 * reset and release the semaphore (if necessary).

 SW should guarantee 100us for the completion of the PHY reset */

/**

 * igc_phy_setup_autoneg - Configure PHY for auto-negotiation

 * @hw: pointer to the HW structure

 *

 * Reads the MII auto-neg advertisement register and/or the 1000T control

 * register and if the PHY is already setup for auto-negotiation, then

 * return successful.  Otherwise, setup advertisement and flow control to

 * the appropriate values for the wanted auto-negotiation.

 Read the MII Auto-Neg Advertisement Register (Address 4). */

 Read the MII 1000Base-T Control Register (Address 9). */

 Read the MULTI GBT AN Control Register - reg 7.32 */

	/* Need to parse both autoneg_advertised and fc and set up

	 * the appropriate PHY registers.  First we will parse for

	 * autoneg_advertised software override.  Since we can advertise

	 * a plethora of combinations, we need to check each bit

	 * individually.

	/* First we clear all the 10/100 mb speed bits in the Auto-Neg

	 * Advertisement Register (Address 4) and the 1000 mb speed bits in

	 * the  1000Base-T Control Register (Address 9).

 Do we want to advertise 10 Mb Half Duplex? */

 Do we want to advertise 10 Mb Full Duplex? */

 Do we want to advertise 100 Mb Half Duplex? */

 Do we want to advertise 100 Mb Full Duplex? */

 We do not allow the Phy to advertise 1000 Mb Half Duplex */

 Do we want to advertise 1000 Mb Full Duplex? */

 We do not allow the Phy to advertise 2500 Mb Half Duplex */

 Do we want to advertise 2500 Mb Full Duplex? */

	/* Check for a software override of the flow control settings, and

	 * setup the PHY advertisement registers accordingly.  If

	 * auto-negotiation is enabled, then software will have to set the

	 * "PAUSE" bits to the correct value in the Auto-Negotiation

	 * Advertisement Register (PHY_AUTONEG_ADV) and re-start auto-

	 * negotiation.

	 *

	 * The possible values of the "fc" parameter are:

	 *      0:  Flow control is completely disabled

	 *      1:  Rx flow control is enabled (we can receive pause frames

	 *          but not send pause frames).

	 *      2:  Tx flow control is enabled (we can send pause frames

	 *          but we do not support receiving pause frames).

	 *      3:  Both Rx and Tx flow control (symmetric) are enabled.

	 *  other:  No software override.  The flow control configuration

	 *          in the EEPROM is used.

		/* Flow control (Rx & Tx) is completely disabled by a

		 * software over-ride.

		/* Rx Flow control is enabled, and Tx Flow control is

		 * disabled, by a software over-ride.

		 *

		 * Since there really isn't a way to advertise that we are

		 * capable of Rx Pause ONLY, we will advertise that we

		 * support both symmetric and asymmetric Rx PAUSE.  Later

		 * (in igc_config_fc_after_link_up) we will disable the

		 * hw's ability to send PAUSE frames.

		/* Tx Flow control is enabled, and Rx Flow control is

		 * disabled, by a software over-ride.

		/* Flow control (both Rx and Tx) is enabled by a software

		 * over-ride.

/**

 * igc_wait_autoneg - Wait for auto-neg completion

 * @hw: pointer to the HW structure

 *

 * Waits for auto-negotiation to complete or for the auto-negotiation time

 * limit to expire, which ever happens first.

 Break after autoneg completes or PHY_AUTO_NEG_LIMIT expires. */

	/* PHY_AUTO_NEG_TIME expiration doesn't guarantee auto-negotiation

	 * has completed.

/**

 * igc_copper_link_autoneg - Setup/Enable autoneg for copper link

 * @hw: pointer to the HW structure

 *

 * Performs initial bounds checking on autoneg advertisement parameter, then

 * configure to advertise the full capability.  Setup the PHY to autoneg

 * and restart the negotiation process between the link partner.  If

 * autoneg_wait_to_complete, then wait for autoneg to complete before exiting.

	/* Perform some bounds checking on the autoneg advertisement

	 * parameter.

	/* If autoneg_advertised is zero, we assume it was not defaulted

	 * by the calling code so we set to advertise full capability.

	/* Restart auto-negotiation by setting the Auto Neg Enable bit and

	 * the Auto Neg Restart bit in the PHY control register.

	/* Does the user want to wait for Auto-Neg to complete here, or

	 * check at a later time (for example, callback routine).

/**

 * igc_setup_copper_link - Configure copper link settings

 * @hw: pointer to the HW structure

 *

 * Calls the appropriate function to configure the link for auto-neg or forced

 * speed and duplex.  Then we check for link, once link is established calls

 * to configure collision distance and flow control are called.  If link is

 * not established, we return -IGC_ERR_PHY (-2).

		/* Setup autoneg and flow control advertisement and perform

		 * autonegotiation.

		/* PHY will be set to 10H, 10F, 100H or 100F

		 * depending on user settings.

	/* Check link status. Wait up to 100 microseconds for link to become

	 * valid.

/**

 * igc_read_phy_reg_mdic - Read MDI control register

 * @hw: pointer to the HW structure

 * @offset: register offset to be read

 * @data: pointer to the read data

 *

 * Reads the MDI control register in the PHY at offset and stores the

 * information read to data.

	/* Set up Op-code, Phy Address, and register offset in the MDI

	 * Control register.  The MAC will take care of interfacing with the

	 * PHY to retrieve the desired data.

	/* Poll the ready bit to see if the MDI read completed

	 * Increasing the time out as testing showed failures with

	 * the lower time out

/**

 * igc_write_phy_reg_mdic - Write MDI control register

 * @hw: pointer to the HW structure

 * @offset: register offset to write to

 * @data: data to write to register at offset

 *

 * Writes data to MDI control register in the PHY at offset.

	/* Set up Op-code, Phy Address, and register offset in the MDI

	 * Control register.  The MAC will take care of interfacing with the

	 * PHY to write the desired data.

	/* Poll the ready bit to see if the MDI read completed

	 * Increasing the time out as testing showed failures with

	 * the lower time out

/**

 * __igc_access_xmdio_reg - Read/write XMDIO register

 * @hw: pointer to the HW structure

 * @address: XMDIO address to program

 * @dev_addr: device address to program

 * @data: pointer to value to read/write from/to the XMDIO address

 * @read: boolean flag to indicate read or write

 Recalibrate the device back to 0 */

/**

 * igc_read_xmdio_reg - Read XMDIO register

 * @hw: pointer to the HW structure

 * @addr: XMDIO address to program

 * @dev_addr: device address to program

 * @data: value to be read from the EMI address

/**

 * igc_write_xmdio_reg - Write XMDIO register

 * @hw: pointer to the HW structure

 * @addr: XMDIO address to program

 * @dev_addr: device address to program

 * @data: value to be written to the XMDIO address

/**

 * igc_write_phy_reg_gpy - Write GPY PHY register

 * @hw: pointer to the HW structure

 * @offset: register offset to write to

 * @data: data to write at register offset

 *

 * Acquires semaphore, if necessary, then writes the data to PHY register

 * at the offset. Release any acquired semaphores before exiting.

/**

 * igc_read_phy_reg_gpy - Read GPY PHY register

 * @hw: pointer to the HW structure

 * @offset: lower half is register offset to read to

 * upper half is MMD to use.

 * @data: data to read at register offset

 *

 * Acquires semaphore, if necessary, then reads the data in the PHY register

 * at the offset. Release any acquired semaphores before exiting.

/**

 * igc_read_phy_fw_version - Read gPHY firmware version

 * @hw: pointer to the HW structure

 NVM image version is reported as firmware version for i225 device */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c)  2018 Intel Corporation */

/**

 * igc_acquire_nvm_i225 - Acquire exclusive access to EEPROM

 * @hw: pointer to the HW structure

 *

 * Acquire the necessary semaphores for exclusive access to the EEPROM.

 * Set the EEPROM access request bit and wait for EEPROM access grant bit.

 * Return successful if access grant bit set, else clear the request for

 * EEPROM access and return -IGC_ERR_NVM (-1).

/**

 * igc_release_nvm_i225 - Release exclusive access to EEPROM

 * @hw: pointer to the HW structure

 *

 * Stop any current commands to the EEPROM and clear the EEPROM request bit,

 * then release the semaphores acquired.

/**

 * igc_get_hw_semaphore_i225 - Acquire hardware semaphore

 * @hw: pointer to the HW structure

 *

 * Acquire the HW semaphore to access the PHY or NVM

 Get the SW semaphore */

		/* In rare circumstances, the SW semaphore may already be held

		 * unintentionally. Clear the semaphore once before giving up.

 If we do not have the semaphore here, we have to give up. */

 Get the FW semaphore. */

 Semaphore acquired if bit latched */

 Release semaphores */

/**

 * igc_acquire_swfw_sync_i225 - Acquire SW/FW semaphore

 * @hw: pointer to the HW structure

 * @mask: specifies which semaphore to acquire

 *

 * Acquire the SW/FW semaphore to access the PHY or NVM.  The mask

 * will also specify which port we're acquiring the lock for.

 Firmware currently using resource (fwmask) */

/**

 * igc_release_swfw_sync_i225 - Release SW/FW semaphore

 * @hw: pointer to the HW structure

 * @mask: specifies which semaphore to acquire

 *

 * Release the SW/FW semaphore used to access the PHY or NVM.  The mask

 * will also specify which port we're releasing the lock for.

 Empty */

/**

 * igc_read_nvm_srrd_i225 - Reads Shadow Ram using EERD register

 * @hw: pointer to the HW structure

 * @offset: offset of word in the Shadow Ram to read

 * @words: number of words to read

 * @data: word read from the Shadow Ram

 *

 * Reads a 16 bit word from the Shadow Ram using the EERD register.

 * Uses necessary synchronization semaphores.

	/* We cannot hold synchronization semaphores for too long,

	 * because of forceful takeover procedure. However it is more efficient

	 * to read in bursts than synchronizing access for each word.

/**

 * igc_write_nvm_srwr - Write to Shadow Ram using EEWR

 * @hw: pointer to the HW structure

 * @offset: offset within the Shadow Ram to be written to

 * @words: number of words to write

 * @data: 16 bit word(s) to be written to the Shadow Ram

 *

 * Writes data to Shadow Ram at offset using EEWR register.

 *

 * If igc_update_nvm_checksum is not called after this function , the

 * Shadow Ram will most likely contain an invalid checksum.

	/* A check for invalid values:  offset too large, too many words,

	 * too many words for the offset, and not enough words.

/**

 * igc_write_nvm_srwr_i225 - Write to Shadow RAM using EEWR

 * @hw: pointer to the HW structure

 * @offset: offset within the Shadow RAM to be written to

 * @words: number of words to write

 * @data: 16 bit word(s) to be written to the Shadow RAM

 *

 * Writes data to Shadow RAM at offset using EEWR register.

 *

 * If igc_update_nvm_checksum is not called after this function , the

 * data will not be committed to FLASH and also Shadow RAM will most likely

 * contain an invalid checksum.

 *

 * If error code is returned, data and Shadow RAM may be inconsistent - buffer

 * partially written.

	/* We cannot hold synchronization semaphores for too long,

	 * because of forceful takeover procedure. However it is more efficient

	 * to write in bursts than synchronizing access for each word.

/**

 * igc_validate_nvm_checksum_i225 - Validate EEPROM checksum

 * @hw: pointer to the HW structure

 *

 * Calculates the EEPROM checksum by reading/adding each word of the EEPROM

 * and then verifies that the sum of the EEPROM is equal to 0xBABA.

	/* Replace the read function with semaphore grabbing with

	 * the one that skips this for a while.

	 * We have semaphore taken already here.

 Revert original read operation. */

/**

 * igc_pool_flash_update_done_i225 - Pool FLUDONE status

 * @hw: pointer to the HW structure

/**

 * igc_update_flash_i225 - Commit EEPROM to the flash

 * @hw: pointer to the HW structure

/**

 * igc_update_nvm_checksum_i225 - Update EEPROM checksum

 * @hw: pointer to the HW structure

 *

 * Updates the EEPROM checksum by reading/adding each word of the EEPROM

 * up to the checksum.  Then calculates the EEPROM checksum and writes the

 * value to the EEPROM. Next commit EEPROM data onto the Flash.

	/* Read the first word from the EEPROM. If this times out or fails, do

	 * not continue or we could be in for a very long wait while every

	 * EEPROM read fails

	/* Do not use hw->nvm.ops.write, hw->nvm.ops.read

	 * because we do not want to take the synchronization

	 * semaphores twice here.

/**

 * igc_get_flash_presence_i225 - Check if flash device is detected

 * @hw: pointer to the HW structure

/**

 * igc_init_nvm_params_i225 - Init NVM func ptrs.

 * @hw: pointer to the HW structure

 NVM Function Pointers */

/**

 *  igc_set_eee_i225 - Enable/disable EEE support

 *  @hw: pointer to the HW structure

 *  @adv2p5G: boolean flag enabling 2.5G EEE advertisement

 *  @adv1G: boolean flag enabling 1G EEE advertisement

 *  @adv100M: boolean flag enabling 100M EEE advertisement

 *

 *  Enable/disable EEE based on setting in dev_spec structure.

 enable or disable per user setting */

 This bit should not be set in normal operation. */

/* igc_set_ltr_i225 - Set Latency Tolerance Reporting thresholds

 * @hw: pointer to the HW structure

 * @link: bool indicating link status

 *

 * Set the LTR thresholds based on the link speed (Mbps), EEE, and DMAC

 * settings, otherwise specify that there is no LTR requirement.

 If we do not have link, LTR thresholds are zero. */

		/* Check if using copper interface with EEE enabled or if the

		 * link speed is 10 Mbps.

 EEE enabled, so send LTRMAX threshold. */

 Calculate tw_system (nsec). */

 Get the Rx packet buffer size. */

 Calculations vary based on DMAC settings. */

 Convert size to bits. */

			/* Convert size to bytes, subtract the MTU, and then

			 * convert the size to bits.

		/* Calculate the thresholds. Since speed is in Mbps, simplify

		 * the calculation by multiplying size/speed by 1000 for result

		 * to be in nsec before dividing by the scale in nsec. Set the

		 * scale such that the LTR threshold fits in the register.

 Only write the LTR thresholds if they differ from before. */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c)  2019 Intel Corporation */

/* Returns the TSN specific registers to their default values after

 * the adapter is reset.

			/* If we have a base_time we are in "taprio"

			 * mode and we need to be strict about the

			 * cycles: only transmit a packet if it can be

			 * completed during that cycle.

 Skip configuring CBS for Q2 and Q3 */

			/* According to i225 datasheet section 7.5.2.7, we

			 * should set the 'idleSlope' field from TQAVCC

			 * register following the equation:

			 *

			 * value = link-speed   0x7736 * BW * 0.2

			 *         ---------- *  -----------------         (E1)

			 *          100Mbps            2.5

			 *

			 * Note that 'link-speed' is in Mbps.

			 *

			 * 'BW' is the percentage bandwidth out of full

			 * link speed which can be found with the

			 * following equation. Note that idleSlope here

			 * is the parameter from this function

			 * which is in kbps.

			 *

			 *     BW =     idleSlope

			 *          -----------------                      (E2)

			 *          link-speed * 1000

			 *

			 * That said, we can come up with a generic

			 * equation to calculate the value we should set

			 * it TQAVCC register by replacing 'BW' in E1 by E2.

			 * The resulting equation is:

			 *

			 * value = link-speed * 0x7736 * idleSlope * 0.2

			 *         -------------------------------------   (E3)

			 *             100 * 2.5 * link-speed * 1000

			 *

			 * 'link-speed' is present in both sides of the

			 * fraction so it is canceled out. The final

			 * equation is the following:

			 *

			 *     value = idleSlope * 61036

			 *             -----------------                   (E4)

			 *                  2500000

			 *

			 * NOTE: For i225, given the above, we can see

			 *       that idleslope is represented in

			 *       40.959433 kbps units by the value at

			 *       the TQAVCC register (2.5Gbps / 61036),

			 *       which reduces the granularity for

			 *       idleslope increments.

			 *

			 * In i225 controller, the sendSlope and loCredit

			 * parameters from CBS are not configurable

			 * by software so we don't do any

			 * 'controller configuration' in respect to

			 * these parameters.

 Disable any CBS for the queue */

 Set idleSlope to zero. */

 Set hiCredit to zero. */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c)  2019 Intel Corporation */

 SYSTIM read access for I225 */

 The timestamp is latched when SYSTIML is read. */

 Make sure this pin is not enabled as an input. */

 Make sure this pin is not enabled as an output. */

 Reject requests with unsupported flags */

 Reject requests failing to enable both edges. */

 Reject requests with unsupported flags */

 For now, always select timer 0 as source. */

/**

 * igc_ptp_systim_to_hwtstamp - convert system time value to HW timestamp

 * @adapter: board private structure

 * @hwtstamps: timestamp structure to update

 * @systim: unsigned 64bit system time value

 *

 * We need to convert the system time value stored in the RX/TXSTMP registers

 * into a hwtstamp which can be used by the upper level timestamping functions.

 Upper 32 bits contain s, lower 32 bits contain ns. */

/**

 * igc_ptp_rx_pktstamp - Retrieve timestamp from Rx packet buffer

 * @adapter: Pointer to adapter the packet buffer belongs to

 * @buf: Pointer to packet buffer

 *

 * This function retrieves the timestamp saved in the beginning of packet

 * buffer. While two timestamps are available, one in timer0 reference and the

 * other in timer1 reference, this function considers only the timestamp in

 * timer0 reference.

 *

 * Returns timestamp value.

	/* Timestamps are saved in little endian at the beginning of the packet

	 * buffer following the layout:

	 *

	 * DWORD: | 0              | 1              | 2              | 3              |

	 * Field: | Timer1 SYSTIML | Timer1 SYSTIMH | Timer0 SYSTIML | Timer0 SYSTIMH |

	 *

	 * SYSTIML holds the nanoseconds part while SYSTIMH holds the seconds

	 * part of the timestamp.

 Adjust timestamp for the RX latency based on link speed */

		/* FIXME: For now, only support retrieving RX timestamps from

		 * timer 0.

 Read TXSTMP registers to discard any timestamp previously stored. */

/**

 * igc_ptp_set_timestamp_mode - setup hardware for timestamping

 * @adapter: networking device structure

 * @config: hwtstamp configuration

 *

 * Return: 0 in case of success, negative errno code otherwise.

 reserved for future extensions */

 Clear the tx valid bit in TSYNCTXCTL register to enable interrupt. */

	/* If we haven't received a timestamp within the timeout, it is

	 * reasonable to assume that it will never occur, so we can unlock the

	 * timestamp bit when this occurs.

/**

 * igc_ptp_tx_hwtstamp - utility function which checks for TX time stamp

 * @adapter: Board private structure

 *

 * If we were asked to do hardware stamping and such a time stamp is

 * available, then it must have been for this skb here because we only

 * allow only one such packet into the queue.

	/* Clear the lock early before calling skb_tstamp_tx so that

	 * applications are not woken up before the lock bit is clear. We use

	 * a copy of the skb pointer to ensure other threads can't change it

	 * while we're notifying the stack.

 Notify the stack and free the skb after we've unlocked */

/**

 * igc_ptp_tx_work

 * @work: pointer to work struct

 *

 * This work function polls the TSYNCTXCTL valid bit to determine when a

 * timestamp has been taken for the current stored skb.

/**

 * igc_ptp_set_ts_config - set hardware time stamping config

 * @netdev: network interface device structure

 * @ifr: interface request data

 *

 save these settings for future reference */

/**

 * igc_ptp_get_ts_config - get hardware time stamping config

 * @netdev: network interface device structure

 * @ifr: interface request data

 *

 * Get the hwtstamp_config settings to return to the user. Rather than attempt

 * to deconstruct the settings from the registers, just return a shadow copy

 * of the last known settings.

/* The two conditions below must be met for cross timestamping via

 * PCIe PTM:

 *

 * 1. We have an way to convert the timestamps in the PTM messages

 *    to something related to the system clocks (right now, only

 *    X86 systems with support for the Always Running Timer allow that);

 *

 * 2. We have PTM enabled in the path from the device to the PCIe root port.

 Get a snapshot of system clocks to use as historic value. */

		/* Doing this in a loop because in the event of a

		 * badly timed (ha!) system clock adjustment, we may

		 * get PTM errors from the PCI root, but these errors

		 * are transitory. Repeating the process returns valid

		 * data eventually.

		/* To "manually" start the PTM cycle we need to clear and

		 * then set again the TRIG bit.

		/* The cycle only starts "for real" when software notifies

		 * that it has read the registers, this is done by setting

		 * VALID bit.

 An error occurred, log it. */

			/* The STAT register is write-1-to-clear (W1C),

			 * so write the previous error status to clear it.

	/* FIXME: When the register that tells the endianness of the

	 * PTM registers are implemented, check them here and add the

	 * appropriate conversion.

/**

 * igc_ptp_init - Initialize PTP functionality

 * @adapter: Board private structure

 *

 * This function is called at device probe to initialize the PTP

 * functionality.

/**

 * igc_ptp_suspend - Disable PTP work items and prepare for suspend

 * @adapter: Board private structure

 *

 * This function stops the overflow check work and PTP Tx timestamp work, and

 * will prepare the device for OS suspend.

/**

 * igc_ptp_stop - Disable PTP device and stop the overflow check.

 * @adapter: Board private structure.

 *

 * This function stops the PTP support and cancels the delayed work.

/**

 * igc_ptp_reset - Re-enable the adapter for PTP following a reset.

 * @adapter: Board private structure.

 *

 * This function handles the reset work required to re-enable the PTP device.

 reset the tstamp_config */

 Force the first cycle to run. */

 No work to do. */

 Re-initialize the timer. */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c)  2018 Intel Corporation */

/**

 * igc_reset_hw_base - Reset hardware

 * @hw: pointer to the HW structure

 *

 * This resets the hardware into a known state.  This is a

 * function pointer entry point called by the api module.

	/* Prevent the PCI-E bus from sticking if there is no TLP connection

	 * on the last TLP read/write transaction when MAC is reset.

		/* When auto config read does not complete, do not

		 * return with an error. This can happen in situations

		 * where there is no eeprom and prevents getting link.

 Clear any pending interrupt events. */

/**

 * igc_init_nvm_params_base - Init NVM func ptrs.

 * @hw: pointer to the HW structure

	/* Added to a constant, "size" becomes the left-shift value

	 * for setting word_size.

	/* Just in case size is out of range, cap it to the largest

	 * EEPROM size supported

/**

 * igc_setup_copper_link_base - Configure copper link settings

 * @hw: pointer to the HW structure

 *

 * Configures the link for auto-neg or forced speed and duplex.  Then we check

 * for link, once link is established calls to configure collision distance

 * and flow control are called.

/**

 * igc_init_mac_params_base - Init MAC func ptrs.

 * @hw: pointer to the HW structure

 Set mta register count */

 reset */

 Allow a single clear of the SW semaphore on I225 */

 physical interface link setup */

/**

 * igc_init_phy_params_base - Init PHY func ptrs.

 * @hw: pointer to the HW structure

 set lan id */

	/* Make sure the PHY is in a good state. Several people have reported

	 * firmware leaving the PHY's page select register set to something

	 * other than the default of zero, which causes the PHY ID read to

	 * access something other than the intended register.

 mac initialization and operations */

 NVM initialization */

 setup PHY parameters */

/**

 * igc_acquire_phy_base - Acquire rights to access PHY

 * @hw: pointer to the HW structure

 *

 * Acquire access rights to the correct PHY.  This is a

 * function pointer entry point called by the api module.

/**

 * igc_release_phy_base - Release rights to access PHY

 * @hw: pointer to the HW structure

 *

 * A wrapper to release access rights to the correct PHY.  This is a

 * function pointer entry point called by the api module.

/**

 * igc_init_hw_base - Initialize hardware

 * @hw: pointer to the HW structure

 *

 * This inits the hardware readying it for operation.

 Setup the receive address */

 Zero out the Multicast HASH table */

 Zero out the Unicast HASH table */

 Setup link and flow control */

	/* Clear all of the statistics registers (clear on read).  It is

	 * important that we do this after we have tried to establish link

	 * because the symbol error count will increment wildly if there

	 * is no link.

/**

 * igc_power_down_phy_copper_base - Remove link during PHY power down

 * @hw: pointer to the HW structure

 *

 * In the case of a PHY power down to save power, or to turn off link during a

 * driver unload, or wake on lan is not enabled, remove the link.

 If the management interface is not enabled, then power down */

/**

 * igc_rx_fifo_flush_base - Clean rx fifo after Rx enable

 * @hw: pointer to the HW structure

 *

 * After Rx enable, if manageability is enabled then there is likely some

 * bad data at the start of the fifo and possibly in the DMA fifo.  This

 * function clears the fifos and flushes any packets that came in as rx was

 * being enabled.

 disable IPv6 options as per hardware errata */

 Disable all Rx queues */

 Poll all queues to verify they have shut down */

	/* Clear RLPML, RCTL.SBP, RFCTL.LEF, and set RCTL.LPE so that all

	 * incoming packets are rejected.  Set enable and wait 2ms so that

	 * any packet that was coming in as RCTL.EN was set is flushed

	/* Enable Rx queues that were previously enabled and restore our

	 * previous state

 Flush receive errors generated by workaround */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c)  2018 Intel Corporation */

/**

 * igc_poll_eerd_eewr_done - Poll for EEPROM read/write completion

 * @hw: pointer to the HW structure

 * @ee_reg: EEPROM flag for polling

 *

 * Polls the EEPROM status bit for either read or write completion based

 * upon the value of 'ee_reg'.

/**

 * igc_acquire_nvm - Generic request for access to EEPROM

 * @hw: pointer to the HW structure

 *

 * Set the EEPROM access request bit and wait for EEPROM access grant bit.

 * Return successful if access grant bit set, else clear the request for

 * EEPROM access and return -IGC_ERR_NVM (-1).

/**

 * igc_release_nvm - Release exclusive access to EEPROM

 * @hw: pointer to the HW structure

 *

 * Stop any current commands to the EEPROM and clear the EEPROM request bit.

/**

 * igc_read_nvm_eerd - Reads EEPROM using EERD register

 * @hw: pointer to the HW structure

 * @offset: offset of word in the EEPROM to read

 * @words: number of words to read

 * @data: word read from the EEPROM

 *

 * Reads a 16 bit word from the EEPROM using the EERD register.

	/* A check for invalid values:  offset too large, too many words,

	 * and not enough words.

/**

 * igc_read_mac_addr - Read device MAC address

 * @hw: pointer to the HW structure

/**

 * igc_validate_nvm_checksum - Validate EEPROM checksum

 * @hw: pointer to the HW structure

 *

 * Calculates the EEPROM checksum by reading/adding each word of the EEPROM

 * and then verifies that the sum of the EEPROM is equal to 0xBABA.

/**

 * igc_update_nvm_checksum - Update EEPROM checksum

 * @hw: pointer to the HW structure

 *

 * Updates the EEPROM checksum by reading/adding each word of the EEPROM

 * up to the checksum.  Then calculates the EEPROM checksum and writes the

 * value to the EEPROM.

 SPDX-License-Identifier: GPL-2.0

 Copyright (c)  2020 Intel Corporation */

	/* Because the status register is such a special case,

	 * we handle it separately from the rest of the register

	 * tests.  Some bits are read-only, some toggle, and some

	 * are writeable.

 restore previous status */

	/* Perform the remainder of the register test, looping through

	 * the test table until we either fail or reach the null entry.

 add delay to give enough time for autonegotioation to finish */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c)  2018 Intel Corporation */

 General Registers */

 Interrupt Registers */

 RX Registers */

 TX Registers */

 List Terminator */

 igc_regdump - register printout routine */

 igc_rings_dump - Tx-rings and Rx-rings */

 Print TX Ring Summary */

 Print TX Rings */

	/* Transmit Descriptor Formats

	 *

	 * Advanced Transmit Descriptor

	 *   +--------------------------------------------------------------+

	 * 0 |         Buffer Address [63:0]                                |

	 *   +--------------------------------------------------------------+

	 * 8 | PAYLEN  | PORTS  |CC|IDX | STA | DCMD  |DTYP|MAC|RSV| DTALEN |

	 *   +--------------------------------------------------------------+

	 *   63      46 45    40 39 38 36 35 32 31   24             15       0

 Print RX Rings Summary */

 Print RX Rings */

	/* Advanced Receive Descriptor (Read) Format

	 *    63                                           1        0

	 *    +-----------------------------------------------------+

	 *  0 |       Packet Buffer Address [63:1]           |A0/NSE|

	 *    +----------------------------------------------+------+

	 *  8 |       Header Buffer Address [63:1]           |  DD  |

	 *    +-----------------------------------------------------+

	 *

	 *

	 * Advanced Receive Descriptor (Write-Back) Format

	 *

	 *   63       48 47    32 31  30      21 20 17 16   4 3     0

	 *   +------------------------------------------------------+

	 * 0 | Packet     IP     |SPH| HDR_LEN   | RSV|Packet|  RSS |

	 *   | Checksum   Ident  |   |           |    | Type | Type |

	 *   +------------------------------------------------------+

	 * 8 | VLAN Tag | Length | Extended Error | Extended Status |

	 *   +------------------------------------------------------+

	 *   63       48 47    32 31            20 19               0

 Descriptor Done */

 igc_regs_dump - registers dump */

 Print Registers */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c)  2018 Intel Corporation */

/**

 * igc_disable_pcie_master - Disables PCI-express master access

 * @hw: pointer to the HW structure

 *

 * Returns 0 (0) if successful, else returns -10

 * (-IGC_ERR_MASTER_REQUESTS_PENDING) if master disable bit has not caused

 * the master requests to be disabled.

 *

 * Disables PCI-Express master access and verifies there are no pending

 * requests.

/**

 * igc_init_rx_addrs - Initialize receive addresses

 * @hw: pointer to the HW structure

 * @rar_count: receive address registers

 *

 * Setup the receive address registers by setting the base receive address

 * register to the devices MAC address and clearing all the other receive

 * address registers to 0.

 Setup the receive address */

 Zero out the other (rar_entry_count - 1) receive addresses */

/**

 * igc_set_fc_watermarks - Set flow control high/low watermarks

 * @hw: pointer to the HW structure

 *

 * Sets the flow control high/low threshold (watermark) registers.  If

 * flow control XON frame transmission is enabled, then set XON frame

 * transmission as well.

	/* Set the flow control receive threshold registers.  Normally,

	 * these registers will be set to a default threshold that may be

	 * adjusted later by the driver's runtime code.  However, if the

	 * ability to transmit pause frames is not enabled, then these

	 * registers will be set to 0.

		/* We need to set up the Receive Threshold high and low water

		 * marks as well as (optionally) enabling the transmission of

		 * XON frames.

/**

 * igc_setup_link - Setup flow control and link settings

 * @hw: pointer to the HW structure

 *

 * Determines which flow control settings to use, then configures flow

 * control.  Calls the appropriate media-specific link configuration

 * function.  Assuming the adapter has a valid link partner, a valid link

 * should be established.  Assumes the hardware has previously been reset

 * and the transmitter and receiver are not enabled.

	/* In the case of the phy reset being blocked, we already have a link.

	 * We do not need to set it up again.

	/* If requested flow control is set to default, set flow control

	 * to the both 'rx' and 'tx' pause frames.

	/* We want to save off the original Flow Control configuration just

	 * in case we get disconnected and then reconnected into a different

	 * hub or switch with different Flow Control capabilities.

 Call the necessary media_type subroutine to configure the link. */

	/* Initialize the flow control address, type, and PAUSE timer

	 * registers to their default values.  This is done even if flow

	 * control is disabled, because it does not hurt anything to

	 * initialize these registers.

/**

 * igc_force_mac_fc - Force the MAC's flow control settings

 * @hw: pointer to the HW structure

 *

 * Force the MAC's flow control settings.  Sets the TFCE and RFCE bits in the

 * device control register to reflect the adapter settings.  TFCE and RFCE

 * need to be explicitly set by software when a copper PHY is used because

 * autonegotiation is managed by the PHY rather than the MAC.  Software must

 * also configure these bits when link is forced on a fiber connection.

	/* Because we didn't get link via the internal auto-negotiation

	 * mechanism (we either forced link or we got link via PHY

	 * auto-neg), we have to manually enable/disable transmit an

	 * receive flow control.

	 *

	 * The "Case" statement below enables/disable flow control

	 * according to the "hw->fc.current_mode" parameter.

	 *

	 * The possible values of the "fc" parameter are:

	 *      0:  Flow control is completely disabled

	 *      1:  Rx flow control is enabled (we can receive pause

	 *          frames but not send pause frames).

	 *      2:  Tx flow control is enabled (we can send pause frames

	 *          frames but we do not receive pause frames).

	 *      3:  Both Rx and TX flow control (symmetric) is enabled.

	 *  other:  No other values should be possible at this point.

/**

 * igc_clear_hw_cntrs_base - Clear base hardware counters

 * @hw: pointer to the HW structure

 *

 * Clears the base hardware counters by reading the counter registers.

/**

 * igc_rar_set - Set receive address register

 * @hw: pointer to the HW structure

 * @addr: pointer to the receive address

 * @index: receive address array register

 *

 * Sets the receive address array register at index to the address passed

 * in by addr.

	/* HW expects these in little endian so we reverse the byte order

	 * from network order (big endian) to little endian

 If MAC address zero, no need to set the AV bit */

	/* Some bridges will combine consecutive 32-bit writes into

	 * a single burst write, which will malfunction on some parts.

	 * The flushes avoid this.

/**

 * igc_check_for_copper_link - Check for link (Copper)

 * @hw: pointer to the HW structure

 *

 * Checks to see of the link status of the hardware has changed.  If a

 * change in link status has been detected, then we read the PHY registers

 * to get the current speed/duplex if link exists.

	/* We only want to go out to the PHY registers to see if Auto-Neg

	 * has completed and/or if our link status has changed.  The

	 * get_link_status flag is set upon receiving a Link Status

	 * Change or Rx Sequence Error interrupt.

	/* First we want to see if the MII Status Register reports

	 * link.  If so, then we want to get the current speed/duplex

	 * of the PHY.

 No link detected */

	/* Check if there was DownShift, must be checked

	 * immediately after link-up

	/* If we are forcing speed/duplex, then we simply return since

	 * we have already determined whether we have link or not.

	/* Auto-Neg is enabled.  Auto Speed Detection takes care

	 * of MAC speed/duplex configuration.  So we only need to

	 * configure Collision Distance in the MAC.

	/* Configure Flow Control now that Auto-Neg has completed.

	 * First, we need to restore the desired flow control

	 * settings because we may have had to re-autoneg with a

	 * different link partner.

	/* Now that we are aware of our link settings, we can set the LTR

	 * thresholds.

/**

 * igc_config_collision_dist - Configure collision distance

 * @hw: pointer to the HW structure

 *

 * Configures the collision distance to the default value and is used

 * during link setup. Currently no func pointer exists and all

 * implementations are handled in the generic version of this function.

/**

 * igc_config_fc_after_link_up - Configures flow control after link

 * @hw: pointer to the HW structure

 *

 * Checks the status of auto-negotiation after link up to ensure that the

 * speed and duplex were not forced.  If the link needed to be forced, then

 * flow control needs to be forced also.  If auto-negotiation is enabled

 * and did not fail, then we configure flow control based on our link

 * partner.

	/* Check for the case where we have fiber media and auto-neg failed

	 * so we had to force link.  In this case, we need to force the

	 * configuration of the MAC to match the "fc" parameter.

	/* Check for the case where we have copper media and auto-neg is

	 * enabled.  In this case, we need to check and see if Auto-Neg

	 * has completed, and if so, how the PHY and link partner has

	 * flow control configured.

		/* Read the MII Status Register and check to see if AutoNeg

		 * has completed.  We read this twice because this reg has

		 * some "sticky" (latched) bits.

		/* The AutoNeg process has completed, so we now need to

		 * read both the Auto Negotiation Advertisement

		 * Register (Address 4) and the Auto_Negotiation Base

		 * Page Ability Register (Address 5) to determine how

		 * flow control was negotiated.

		/* Two bits in the Auto Negotiation Advertisement Register

		 * (Address 4) and two bits in the Auto Negotiation Base

		 * Page Ability Register (Address 5) determine flow control

		 * for both the PHY and the link partner.  The following

		 * table, taken out of the IEEE 802.3ab/D6.0 dated March 25,

		 * 1999, describes these PAUSE resolution bits and how flow

		 * control is determined based upon these settings.

		 * NOTE:  DC = Don't Care

		 *

		 *   LOCAL DEVICE  |   LINK PARTNER

		 * PAUSE | ASM_DIR | PAUSE | ASM_DIR | NIC Resolution

		 *-------|---------|-------|---------|--------------------

		 *   0   |    0    |  DC   |   DC    | igc_fc_none

		 *   0   |    1    |   0   |   DC    | igc_fc_none

		 *   0   |    1    |   1   |    0    | igc_fc_none

		 *   0   |    1    |   1   |    1    | igc_fc_tx_pause

		 *   1   |    0    |   0   |   DC    | igc_fc_none

		 *   1   |   DC    |   1   |   DC    | igc_fc_full

		 *   1   |    1    |   0   |    0    | igc_fc_none

		 *   1   |    1    |   0   |    1    | igc_fc_rx_pause

		 *

		 * Are both PAUSE bits set to 1?  If so, this implies

		 * Symmetric Flow Control is enabled at both ends.  The

		 * ASM_DIR bits are irrelevant per the spec.

		 *

		 * For Symmetric Flow Control:

		 *

		 *   LOCAL DEVICE  |   LINK PARTNER

		 * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result

		 *-------|---------|-------|---------|--------------------

		 *   1   |   DC    |   1   |   DC    | IGC_fc_full

		 *

			/* Now we need to check if the user selected RX ONLY

			 * of pause frames.  In this case, we had to advertise

			 * FULL flow control because we could not advertise RX

			 * ONLY. Hence, we must now check to see if we need to

			 * turn OFF  the TRANSMISSION of PAUSE frames.

		/* For receiving PAUSE frames ONLY.

		 *

		 *   LOCAL DEVICE  |   LINK PARTNER

		 * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result

		 *-------|---------|-------|---------|--------------------

		 *   0   |    1    |   1   |    1    | igc_fc_tx_pause

		/* For transmitting PAUSE frames ONLY.

		 *

		 *   LOCAL DEVICE  |   LINK PARTNER

		 * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result

		 *-------|---------|-------|---------|--------------------

		 *   1   |    1    |   0   |    1    | igc_fc_rx_pause

		/* Per the IEEE spec, at this point flow control should be

		 * disabled.  However, we want to consider that we could

		 * be connected to a legacy switch that doesn't advertise

		 * desired flow control, but can be forced on the link

		 * partner.  So if we advertised no flow control, that is

		 * what we will resolve to.  If we advertised some kind of

		 * receive capability (Rx Pause Only or Full Flow Control)

		 * and the link partner advertised none, we will configure

		 * ourselves to enable Rx Flow Control only.  We can do

		 * this safely for two reasons:  If the link partner really

		 * didn't want flow control enabled, and we enable Rx, no

		 * harm done since we won't be receiving any PAUSE frames

		 * anyway.  If the intent on the link partner was to have

		 * flow control enabled, then by us enabling RX only, we

		 * can at least receive pause frames and process them.

		 * This is a good idea because in most cases, since we are

		 * predominantly a server NIC, more times than not we will

		 * be asked to delay transmission of packets than asking

		 * our link partner to pause transmission of frames.

		/* Now we need to do one last check...  If we auto-

		 * negotiated to HALF DUPLEX, flow control should not be

		 * enabled per IEEE 802.3 spec.

		/* Now we call a subroutine to actually force the MAC

		 * controller to use the correct flow control settings.

/**

 * igc_get_auto_rd_done - Check for auto read completion

 * @hw: pointer to the HW structure

 *

 * Check EEPROM for Auto Read done bit.

/**

 * igc_get_speed_and_duplex_copper - Retrieve current speed/duplex

 * @hw: pointer to the HW structure

 * @speed: stores the current speed

 * @duplex: stores the current duplex

 *

 * Read the status register for the current speed/duplex and store the current

 * speed and duplex for copper connections.

		/* For I225, STATUS will indicate 1G speed in both 1 Gbps

		 * and 2.5 Gbps link modes. An additional bit is used

		 * to differentiate between 1 Gbps and 2.5 Gbps.

/**

 * igc_put_hw_semaphore - Release hardware semaphore

 * @hw: pointer to the HW structure

 *

 * Release hardware semaphore used to access the PHY or NVM

/**

 * igc_enable_mng_pass_thru - Enable processing of ARP's

 * @hw: pointer to the HW structure

 *

 * Verifies the hardware needs to leave interface enabled so that frames can

 * be directed to and from the management interface.

/**

 *  igc_hash_mc_addr - Generate a multicast hash value

 *  @hw: pointer to the HW structure

 *  @mc_addr: pointer to a multicast address

 *

 *  Generates a multicast address hash value which is used to determine

 *  the multicast filter table array address and new table value.  See

 *  igc_mta_set()

 Register count multiplied by bits per register */

	/* For a mc_filter_type of 0, bit_shift is the number of left-shifts

	 * where 0xFF would still fall within the hash mask.

	/* The portion of the address that is used for the hash table

	 * is determined by the mc_filter_type setting.

	 * The algorithm is such that there is a total of 8 bits of shifting.

	 * The bit_shift for a mc_filter_type of 0 represents the number of

	 * left-shifts where the MSB of mc_addr[5] would still fall within

	 * the hash_mask.  Case 0 does this exactly.  Since there are a total

	 * of 8 bits of shifting, then mc_addr[4] will shift right the

	 * remaining number of bits. Thus 8 - bit_shift.  The rest of the

	 * cases are a variation of this algorithm...essentially raising the

	 * number of bits to shift mc_addr[5] left, while still keeping the

	 * 8-bit shifting total.

	 *

	 * For example, given the following Destination MAC Address and an

	 * MTA register count of 128 (thus a 4096-bit vector and 0xFFF mask),

	 * we can see that the bit_shift for case 0 is 4.  These are the hash

	 * values resulting from each mc_filter_type...

	 * [0] [1] [2] [3] [4] [5]

	 * 01  AA  00  12  34  56

	 * LSB                 MSB

	 *

	 * case 0: hash_value = ((0x34 >> 4) | (0x56 << 4)) & 0xFFF = 0x563

	 * case 1: hash_value = ((0x34 >> 3) | (0x56 << 5)) & 0xFFF = 0xAC6

	 * case 2: hash_value = ((0x34 >> 2) | (0x56 << 6)) & 0xFFF = 0x163

	 * case 3: hash_value = ((0x34 >> 0) | (0x56 << 8)) & 0xFFF = 0x634

/**

 *  igc_update_mc_addr_list - Update Multicast addresses

 *  @hw: pointer to the HW structure

 *  @mc_addr_list: array of multicast addresses to program

 *  @mc_addr_count: number of multicast addresses to program

 *

 *  Updates entire Multicast Table Array.

 *  The caller must have a packed mc_addr_list of multicast addresses.

 clear mta_shadow */

 update mta_shadow from mc_addr_list */

 replace the entire MTA table */

