 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Patch transfer callback for Emu10k1

 *

 *  Copyright (C) 2000 Takashi iwai <tiwai@suse.de>

/*

 * All the code for loading in a patch.  There is very little that is

 * chip specific here.  Just the actual writing to the board.

/*

/*

 * allocate a sample block and copy data from userspace

 recalculate address offset */

 some samples have invalid data.  the addresses are corrected in voice info */

 be sure loop points start < end */

 compute true data size to be loaded */

 not supported */

 try to allocate a memory block */

 not ENOMEM (for compatibility with OSS) */

 set the total size */

 write blank samples at head */

 copy start->loopend */

 not supported yet */

 handle reverse (or bidirectional) loop */

 copy loop in reverse */

 modify loop pointers */

 add sample pointer */

 loopend -> sample end */

 clear rest of samples (if any) */

 if no blank loop is attached in the sample, add it */

 not supported yet */

 unsigned -> signed */

 recalculate offset */

/*

 * free a sample block

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright (c) by Lee Revell <rlrevell@joe-job.com>

 *                   Clemens Ladisch <clemens@ladisch.de>

 *  Routines for control of EMU10K1 chips

 *

 *  BUGS:

 *    --

 *

 *  TODO:

 *    --

 minimum time is 5 ticks */

 1 sample @ 48KHZ = 20.833...us */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright (c) by James Courtier-Dutton <James@superbug.demon.co.uk>

 *  Driver p16v chips

 *  Version: 0.25

 *

 *  FEATURES currently supported:

 *    Output fixed at S32_LE, 2 channel to hw:0,0

 *    Rates: 44.1, 48, 96, 192.

 *

 *  Changelog:

 *  0.8

 *    Use separate card based buffer for periods table.

 *  0.9

 *    Use 2 channel output streams instead of 8 channel.

 *       (8 channel output streams might be good for ASIO type output)

 *    Corrected speaker output, so Front -> Front etc.

 *  0.10

 *    Fixed missed interrupts.

 *  0.11

 *    Add Sound card model number and names.

 *    Add Analog volume controls.

 *  0.12

 *    Corrected playback interrupts. Now interrupt per period, instead of half period.

 *  0.13

 *    Use single trigger for multichannel.

 *  0.14

 *    Mic capture now works at fixed: S32_LE, 96000Hz, Stereo.

 *  0.15

 *    Force buffer_size / period_size == INTEGER.

 *  0.16

 *    Update p16v.c to work with changed alsa api.

 *  0.17

 *    Update p16v.c to work with changed alsa api. Removed boot_devs.

 *  0.18

 *    Merging with snd-emu10k1 driver.

 *  0.19

 *    One stereo channel at 24bit now works.

 *  0.20

 *    Added better register defines.

 *  0.21

 *    Integrated with snd-emu10k1 driver.

 *  0.22

 *    Removed #if 0 ... #endif

 *  0.23

 *    Implement different capture rates.

 *  0.24

 *    Implement different capture source channels.

 *    e.g. When HD Capture source is set to SPDIF,

 *    setting HD Capture channel to 0 captures from CDROM digital input.

 *    setting HD Capture channel to 1 captures from SPDIF in.

 *  0.25

 *    Include capture buffer sizes.

 *

 *  BUGS:

 *    Some stability problems when unloading the snd-p16v kernel module.

 *    --

 *

 *  TODO:

 *    SPDIF out.

 *    Find out how to change capture sample rates. E.g. To record SPDIF at 48000Hz.

 *    Currently capture fixed at 48000Hz.

 *

 *    --

 *  GENERAL INFO:

 *    Model: SB0240

 *    P16V Chip: CA0151-DBS

 *    Audigy 2 Chip: CA0102-IAT

 *    AC97 Codec: STAC 9721

 *    ADC: Philips 1361T (Stereo 24bit)

 *    DAC: CS4382-K (8-channel, 24bit, 192Khz)

 *

 *  This code was initially based on code from ALSA's emu10k1x.c which is:

 *  Copyright (c) by Francisco Moraes <fmoraes@nc.rr.com>

 Testing channel outputs 0=Front, 1=Center/LFE, 2=Unknown, 3=Rear */

/* Card IDs:

 * Class 0401: 1102:0004 (rev 04) Subsystem: 1102:2002 -> Audigy2 ZS 7.1 Model:SB0350

 * Class 0401: 1102:0004 (rev 04) Subsystem: 1102:1007 -> Audigy2 6.1    Model:SB0240

 * Class 0401: 1102:0004 (rev 04) Subsystem: 1102:1002 -> Audigy2 Platinum  Model:SB msb0240230009266

 * Class 0401: 1102:0004 (rev 04) Subsystem: 1102:2007 -> Audigy4 Pro Model:SB0380 M1SB0380472001901E

 *

 hardware definition */

 Only supports 24-bit samples padded to 32 bits. */

 size has to be N*64 bytes */

 open_playback callback */

 dev_dbg(emu->card->dev, "epcm kcalloc: %p\n", epcm); */

	/*

	dev_dbg(emu->card->dev, "epcm device=%d, channel_id=%d\n",

		   substream->pcm->device, channel_id);

 debug */

 debug */

 channel->interrupt = snd_p16v_pcm_channel_interrupt; */

 open_capture callback */

 dev_dbg(emu->card->dev, "epcm kcalloc: %p\n", epcm); */

	/*

	dev_dbg(emu->card->dev, "epcm device=%d, channel_id=%d\n",

		   substream->pcm->device, channel_id);

 debug */

 debug */

 channel->interrupt = snd_p16v_pcm_channel_interrupt; */

 close callback */

struct snd_pcm_runtime *runtime = substream->runtime;

struct snd_emu10k1_pcm *epcm = runtime->private_data;

 FIXME: maybe zero others */

 close callback */

struct snd_pcm_runtime *runtime = substream->runtime;

struct snd_emu10k1_pcm *epcm = runtime->private_data;

 FIXME: maybe zero others */

 Only using channel 0 for now, but the card has 2 channels.

 prepare playback callback */

 debug */

 debug */

 FIXME: Check emu->buffer.size before actually writing to it. */

snd_emu10k1_ptr20_write(emu, PLAYBACK_PERIOD_SIZE, channel, frames_to_bytes(runtime, runtime->period_size)<<16); 
 buffer size in bytes

 prepare capture callback */

	/*

	dev_dbg(emu->card->dev, "prepare capture:channel_number=%d, rate=%d, "

	       "format=0x%x, channels=%d, buffer_size=%ld, period_size=%ld, "

	       "frames_to_bytes=%d\n",

	       channel, runtime->rate, runtime->format, runtime->channels,

	       runtime->buffer_size, runtime->period_size,

	       frames_to_bytes(runtime, 1));

 FIXME: Check emu->buffer.size before actually writing to it. */

 buffer size in bytes

snd_emu10k1_ptr20_write(emu, CAPTURE_SOURCE, 0x0, 0x333300e4); /* Select MIC or Line in */

snd_emu10k1_ptr20_write(emu, EXTENDED_INT_MASK, 0, snd_emu10k1_ptr20_read(emu, EXTENDED_INT_MASK, 0) | (0x110000<<channel));

 trigger_playback callback */

 dev_dbg(emu->card->dev, "p16v channel=%d\n", channel); */

 dev_dbg(emu->card->dev, "basic=0x%x, inte=0x%x\n", basic, inte); */

 trigger_capture callback */

snd_emu10k1_ptr20_write(emu, EXTENDED_INT_MASK, 0, snd_emu10k1_ptr20_read(emu, EXTENDED_INT_MASK, 0) & ~(0x110000<<channel));

 pointer_playback callback */

 pointer_capture callback */

	/*

	dev_dbg(emu->card->dev, "ptr1 = 0x%lx, ptr2=0x%lx, ptr=0x%lx, "

	       "buffer_size = 0x%x, period_size = 0x%x, bits=%d, rate=%d\n",

	       ptr1, ptr2, ptr, (int)runtime->buffer_size,

	       (int)runtime->period_size, (int)runtime->frame_bits,

	       (int)runtime->rate);

 operators */

 dev_dbg(emu->card->dev, "snd_p16v_pcm called. device=%d\n", device); */

 Single playback 8 channel device.

 Single capture 2 channel device.

		/*

		dev_dbg(emu->card->dev,

			   "preallocate playback substream: err=%d\n", err);

		/*

		dev_dbg(emu->card->dev,

			   "preallocate capture substream: err=%d\n", err);

 Left */

 Right */

 Left */

 Right */

 up to 4, but only first channel is used */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>

 *                   Creative Labs, Inc.

 *  Routines for control of EMU10K1 chips / PCM routines

 *  Multichannel PCM support Copyright (c) Lee Revell <rlrevell@joe-job.com>

 *

 *  BUGS:

 *    --

 *

 *  TODO:

 *    --

 already allocated */

			/*

			dev_dbg(emu->card->dev, "pcm_channel_alloc: "

			       "failed extra: voices=%d, frame=%d\n",

			       voices, frame);

 really supported? */

/*

 * calculate cache invalidate size 

 *

 * stereo: channel is stereo

 * w_16: using 16bit samples

 *

 * returns: cache invalidate size in samples

 volume parameters */

 mono, left, right (master voice = left) */

 setup routing */

 Stop CA */

 Assumption that PT is already 0 so no harm overwriting */

 Disable interpolators on emu1010 card */

 Clear filter delay memory */

 invalidate maps */

 modulation envelope */

 volume envelope */

 filter envelope */

 pitch envelope */

 change */

	/*

	 * the kX driver leaves some space between voices

 only difference with the master voice is we use it for the pointer */

 zeroing the buffer size will stop capture */

 set cs to 2 * number of cache registers beside the invalidated */

 reset cache */

 fill cache */

 skip second voice for mono */

 skip second voice for mono */

 Disable interpolators on emu1010 card */

	/* try to sychronize the current position for the interrupt

	/*

	dev_dbg(emu->card->dev,

		"trigger - emu10k1 = 0x%x, cmd = %i, pointer = %i\n",

	       (int)emu, cmd, substream->ops->pointer(substream))

 do we need this? */

 hmm this should cause full and half full interrupt to be raised? */

		/*

		dev_dbg(emu->card->dev, "adccr = 0x%x, adcbs = 0x%x\n",

		       epcm->adccr, epcm->adcbs);

 Perex's code */

 EMU10K1 Open Source code from Creative */

	/*

	dev_dbg(emu->card->dev,

	       "ptr = 0x%lx, buffer_size = 0x%lx, period_size = 0x%lx\n",

	       (long)ptr, (long)runtime->buffer_size,

	       (long)runtime->period_size);

 prepare voices */

 hack, it takes awhile until capture is started */

/*

 *  Playback support device description

/*

 *  Capture support device description

/*

 *

  Nb. of channels has been increased to 16 */

		/* TODO

		 * SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S32_LE

		 * SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 |

		 * SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 |

		 * SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000

		 * rate_min = 44100,

		 * rate_max = 192000,

		 * channels_min = 16,

		 * channels_max = 16,

		 * Need to add mixer control to fix sample rate

		 *                 

		 * There are 32 mono channels of 16bits each.

		 * 24bit Audio uses 2x channels over 16bit

		 * 96kHz uses 2x channels over 48kHz

		 * 192kHz uses 4x channels over 48kHz

		 * So, for 48kHz 24bit, one has 16 channels

		 * for 96kHz 24bit, one has 8 channels

		 * for 192kHz 24bit, one has 4 channels

		 *

 For 44.1kHz */

 For 48kHz */

 For 96kHz */

 For 192kHz */

		/* efx_voices_mask[0] is expected to be zero

 		 * efx_voices_mask[1] is expected to have 32bits set

 EFX playback */

 playback substream can't use managed buffers due to alignment */

 EFX playback */

	/*

	dev_dbg(emu->card->dev,

		"tram_poke1: dst_left = 0x%p, dst_right = 0x%p, "

	       "src = 0x%p, count = 0x%x\n",

	       dst_left, dst_right, src, count);

	/*

	dev_dbg(emu->card->dev, "prepare: etram_pages = 0x%p, dma_area = 0x%x, "

	       "buffer_size = 0x%x (0x%x)\n",

	       emu->fx8010.etram_pages, runtime->dma_area,

	       runtime->buffer_size, runtime->buffer_size << 2);

 byte size */

 reset */

 reset */

 reset ptr number */

 follow thru */

 roll the ball */

 byte pointer */

 SNDRV_PCM_INFO_MMAP_VALID | */ SNDRV_PCM_INFO_PAUSE |

	/* EFX capture - record the "FXBUS2" channels, by default we connect the EXTINs 

	 * to these

 emu->efx_voices_mask[0] = FXWC_DEFAULTROUTE_C | FXWC_DEFAULTROUTE_A; */

			/* Pavel Hofman - 32 voices will be used for

			 * capture (write mode) -

			 * each bit = corresponding voice

	/* For emu1010, the control has to set 32 upper bits (voices)

	 * out of the 64 bits (voices) to true for the 16-channels capture

	 * to work correctly. Correct A_FXWC2 initial value (0xffffffff)

	 * is already defined but the snd_emu10k1_pcm_efx_voices_mask

	 * control can override this register's value.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  synth callback routines for Emu10k1

 *

 *  Copyright (C) 2000 Takashi Iwai <tiwai@suse.de>

 voice status */

 Keeps track of what we are finding */

/*

 * prototypes

/*

 * Ensure a value is between two points

 * macro evaluates its args more than once, so changed to upper-case.

/*

 * set up operators

/*

 * get more voice for pcm

 *

 * terminate most inactive voice and give it as a pcm voice.

 *

 * voice_lock is already held.

 no OFF voices */

				/*

				dev_warn(emu->card->dev,

				       "synth_get_voice: ch < 0 (%d) ??", i);

 not found */

/*

 * turn off the voice (not terminated)

/*

 * terminate the voice

/*

 * release the voice to system

 FIXME: emu10k1_synth is broken. */

 This can get called with hw == 0 */

 Problem apparent on plug, unplug then plug */

 on the Audigy 2 ZS Notebook. */

 snd_emu10k1_ptr_write(hw, DCYSUSV, vp->ch, 0);

/*

 * update registers

/*

 * look up voice table - get the best voice in order of preference

 spinlock held! */

 XXX MAX_?INT really */

	/*

	 * Go through them all and get a best one to use.

	 * NOTE: could also look at volume and pick the quietest one.

 check if sample is finished playing (non-looping only) */

/*

 * get an empty voice

 *

 * emu->voice_lock is already held.

 allocate a voice */

 not found */

/*

 * prepare envelopes and LFOs

 dev_err(hw->card->devK, "emu: cannot map!\n"); */

 set channel routing */

 A = left(0), B = right(1), C = reverb(c), D = chorus(d) */

 channel to be silent and idle */

 set pitch offset */

 set envelope parameters */

	/* decay/sustain parameter for volume envelope is used

 cutoff and volume */

 modulation envelope heights */

 lfo1/2 delay */

 lfo1 pitch & cutoff shift */

 lfo1 volume & freq */

 lfo2 pitch & freq */

 reverb and loop start (reverb 8bit, MSB) */

 chorus & loop end (chorus 8bit, MSB) */

 clear filter delay memory */

 invalidate maps */

 cache */

 cache */

 invalidate maps */

 fill cache */

 Q & current address (Q 4bit value, MSB) */

 reset volume */

/*

 * Start envelope

 not mapped */

 set pitch target and pan (volume) */

 pitch target */

 trigger voice */

 set lfo1 modulation height and cutoff */

 set lfo2 pitch & frequency */

 set filterQ */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  The driver for the EMU10K1 (SB Live!) based soundcards

 *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>

 *

 *  Copyright (c) by James Courtier-Dutton <James@superbug.demon.co.uk>

 *      Added support for Audigy 2 Value.

 Index 0-MAX */

 ID for this card */

 Enable this card */

 Force card subsystem model */

/*

 * Class 0401: 1102:0008 (rev 00) Subsystem: 1102:1001 -> Audigy2 Value  Model:SB0400

 EMU10K1 */

 Audigy */

 Audigy 2 Value SB0400 */

/*

 * Audigy 2 Value notes:

 * A_IOCFG Input (GPIO)

 * 0x400  = Front analog jack plugged in. (Green socket)

 * 0x1000 = Read analog jack plugged in. (Black socket)

 * 0x2000 = Center/LFE analog jack plugged in. (Orange socket)

 * A_IOCFG Output (GPIO)

 * 0x60 = Sound out of front Left.

 * Win sets it to 0xXX61

 This stores the periods table. */

 P16V */	

 P16V */

 CONFIG_PM_SLEEP */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>,

 *                   Takashi Iwai <tiwai@suse.de>

 *                   Creative Labs, Inc.

 *  Routines for control of EMU10K1 chips / mixer routines

 *  Multichannel PCM support Copyright (c) Lee Revell <rlrevell@joe-job.com>

 *

 *  Copyright (c) by James Courtier-Dutton <James@superbug.co.uk>

 *  	Added EMU 1010 support.

 *

 *  BUGS:

 *    --

 *

 *  TODO:

 *    --

 WM8775 gain scale */

 Limit: emu->spdif_bits */

/*

 * Items labels in enum mixer controls assigning source data to

 * each destination

 1616(m) cardbus */

/*

 * List of data sources available for each destination

 0 */

 1 */

 2 */

 3 */

 4 */

 5 */

 6 */

 7 */

 8 */

 9 */

 10 */

 11 */

 12 */

 13 */

 14 */

 15 */

 16 */

 17 */

 18 */

 19 */

 20 */

 21 */

 22 */

 23 */

 24 */

 25 */

 26 */

 27 */

 28 */

 29 */

 30 */

 31 */

 32 */

 33 */

 34 */

 35 */

 36 */

 37 */

 38 */

 39 */

 40 */

 41 */

 42 */

 43 */

 44 */

 45 */

 46 */

 47 */

 48 */

 49 */

 50 */

 51 */

 52 */

 1616(m) cardbus */

/*

 * Data destinations - physical EMU outputs.

 * Each destination has an enum mixer control to choose a data source

 0 */

 1 */

 2 */

 3 */

 4 */

 5 */

 6 */

 7 */

 8 */

 9 */

 10 */

 11 */

 12 */

 13 */

 14 */

 15 */

 16 */

 17 */

 18 */

 19 */

 20 */

 21 */

 22 */

 23 */

 1616(m) cardbus */

/*

 * Data destinations - HANA outputs going to Alice2 (audigy) for

 *   capture (EMU32 + I2S links)

 * Each destination has an enum mixer control to choose a data source

 Limit: emu1010_output_dst, emu->emu1010.output_source */

 Limit: emu1010_output_dst, emu->emu1010.output_source */

 Limit: emu1010_input_dst, emu->emu1010.input_source */

 Limit: emu1010_input_dst, emu->emu1010.input_source */

 1616(m) cardbus */

 Limit: uinfo->value.enumerated.items = 4; */

 44100 */

 Mute all */

 Default fallback clock 48kHz */

 Word Clock source, Internal 44.1kHz x1 */

 Set LEDs on Audio Dock */

 Allow DLL to settle */

 Unmute all */

 48000 */

 Mute all */

 Default fallback clock 48kHz */

 Word Clock source, Internal 48kHz x1 */

 Set LEDs on Audio Dock */

 Allow DLL to settle */

 Unmute all */

 Take clock from S/PDIF IN */

 Mute all */

 Default fallback clock 48kHz */

 Word Clock source, sync to S/PDIF input */

 Set LEDs on Audio Dock */

 FIXME: We should set EMU_HANA_DOCK_LEDS_2_LOCK only when clock signal is present and valid */	

 Allow DLL to settle */

 Unmute all */

 Take clock from ADAT IN */

 Mute all */

 Default fallback clock 48kHz */

 Word Clock source, sync to ADAT input */

 Set LEDs on Audio Dock */

 FIXME: We should set EMU_HANA_DOCK_LEDS_2_LOCK only when clock signal is present and valid */	

 Allow DLL to settle */

   Unmute all */

 Limit: uinfo->value.enumerated.items = 2; */

 Limit: uinfo->value.enumerated.items = 2; */

	/* If the capture source has changed,

	 * update the capture volume from the cached value

	 * for the particular source.

 Limit: uinfo->value.enumerated.items = 2; */

        emu->i2c_capture_volume */

 Mute input */

 Left */

 Left */

 Right */

 Right */

 Set source */

 Limit: emu->i2c_capture_volume */

        capture_source: uinfo->value.enumerated.items = 2 */

 Limit: emu->i2c_capture_volume */

        capture_source: uinfo->value.enumerated.items = 2 */

 Left */

 Right */

 Limit: emu->spdif_bits */

 PCM stream controls */

 Mutichannel PCM stream controls */

 Do nothing for Audigy 2 ZS Notebook */

 workaround for too low volume on Audigy due to 16bit/24bit conversion */

 FIXME: better to use a cached version */

/*

/*

 no AC97 mono, surround, center/lfe */

 Master/PCM controls on ac97 of Audigy has no effect */

		/* On the Audigy2 the AC97 playback is piped into

 remove unused AC97 capture controls */

 use conventional names */

 "Wave Capture Volume", "PCM Capture Volume", */

"Analog Mix Capture Volume","OLD Analog Mix Capture Volume",

		/* On the Audigy2 ZS Notebook

		/* On the Audigy2 the AC97 playback is piped into

 we don't need VRA */

 FIXME: get rid of ugly gotos.. */

 set master volume to 0 dB */

 set capture source to mic */

 set mono output (TAD) to mic */

			/*

			 * Credits for cards based on STAC9758:

			 *   James Courtier-Dutton <James@superbug.demon.co.uk>

			 *   Voluspa <voluspa@comhem.se>

 remove unused AC97 controls */

 SB Live! Platinum CT4760P */

 Audigy 4 Pro */

 initialize the routing and volume table for each pcm playback stream */

 initialize the routing and volume table for the multichannel playback stream */

 FIXME: APS has these controls? */

 sb live! and audigy */

 Disable the snd_audigy_spdif_shared_spdif */

 sb live! */

 P16V */

 1616(m) cardbus */

 all other e-mu cards for now */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>

 *                   Creative Labs, Inc.

 *  Routines for effect processor FX8010

 *

 *  Copyright (c) by James Courtier-Dutton <James@superbug.co.uk>

 *  	Added EMU 1010 support.

 *

 *  BUGS:

 *    --

 *

 *  TODO:

 *    --

 for testing purposes - digital out -> capture */

 for testing purposes - set S/PDIF to AC3 output */

 for testing purposes - feed the front signal to Center/LFE outputs */

/*

 *  Tables

 0x00 */ "PCM Left",

 0x01 */ "PCM Right",

 0x02 */ "PCM Surround Left",

 0x03 */ "PCM Surround Right",

 0x04 */ "MIDI Left",

 0x05 */ "MIDI Right",

 0x06 */ "Center",

 0x07 */ "LFE",

 0x08 */ NULL,

 0x09 */ NULL,

 0x0a */ NULL,

 0x0b */ NULL,

 0x0c */ "MIDI Reverb",

 0x0d */ "MIDI Chorus",

 0x0e */ NULL,

 0x0f */ NULL

 0x00 */ "AC97 Left",

 0x01 */ "AC97 Right",

 0x02 */ "TTL IEC958 Left",

 0x03 */ "TTL IEC958 Right",

 0x04 */ "Zoom Video Left",

 0x05 */ "Zoom Video Right",

 0x06 */ "Optical IEC958 Left",

 0x07 */ "Optical IEC958 Right",

 0x08 */ "Line/Mic 1 Left",

 0x09 */ "Line/Mic 1 Right",

 0x0a */ "Coaxial IEC958 Left",

 0x0b */ "Coaxial IEC958 Right",

 0x0c */ "Line/Mic 2 Left",

 0x0d */ "Line/Mic 2 Right",

 0x0e */ NULL,

 0x0f */ NULL

 0x00 */ "AC97 Left",

 0x01 */ "AC97 Right",

 0x02 */ "Audigy CD Left",

 0x03 */ "Audigy CD Right",

 0x04 */ "Optical IEC958 Left",

 0x05 */ "Optical IEC958 Right",

 0x06 */ NULL,

 0x07 */ NULL,

 0x08 */ "Line/Mic 2 Left",

 0x09 */ "Line/Mic 2 Right",

 0x0a */ "SPDIF Left",

 0x0b */ "SPDIF Right",

 0x0c */ "Aux2 Left",

 0x0d */ "Aux2 Right",

 0x0e */ NULL,

 0x0f */ NULL

 0x00 */ "AC97 Left",

 0x01 */ "AC97 Right",

 0x02 */ "Optical IEC958 Left",

 0x03 */ "Optical IEC958 Right",

 0x04 */ "Center",

 0x05 */ "LFE",

 0x06 */ "Headphone Left",

 0x07 */ "Headphone Right",

 0x08 */ "Surround Left",

 0x09 */ "Surround Right",

 0x0a */ "PCM Capture Left",

 0x0b */ "PCM Capture Right",

 0x0c */ "MIC Capture",

 0x0d */ "AC97 Surround Left",

 0x0e */ "AC97 Surround Right",

 0x0f */ NULL,

 0x10 */ NULL,

 0x11 */ "Analog Center",

 0x12 */ "Analog LFE",

 0x13 */ NULL,

 0x14 */ NULL,

 0x15 */ NULL,

 0x16 */ NULL,

 0x17 */ NULL,

 0x18 */ NULL,

 0x19 */ NULL,

 0x1a */ NULL,

 0x1b */ NULL,

 0x1c */ NULL,

 0x1d */ NULL,

 0x1e */ NULL,

 0x1f */ NULL,

 0x00 */ "Digital Front Left",

 0x01 */ "Digital Front Right",

 0x02 */ "Digital Center",

 0x03 */ "Digital LEF",

 0x04 */ "Headphone Left",

 0x05 */ "Headphone Right",

 0x06 */ "Digital Rear Left",

 0x07 */ "Digital Rear Right",

 0x08 */ "Front Left",

 0x09 */ "Front Right",

 0x0a */ "Center",

 0x0b */ "LFE",

 0x0c */ NULL,

 0x0d */ NULL,

 0x0e */ "Rear Left",

 0x0f */ "Rear Right",

 0x10 */ "AC97 Front Left",

 0x11 */ "AC97 Front Right",

 0x12 */ "ADC Capture Left",

 0x13 */ "ADC Capture Right",

 0x14 */ NULL,

 0x15 */ NULL,

 0x16 */ NULL,

 0x17 */ NULL,

 0x18 */ NULL,

 0x19 */ NULL,

 0x1a */ NULL,

 0x1b */ NULL,

 0x1c */ NULL,

 0x1d */ NULL,

 0x1e */ NULL,

 0x1f */ NULL,

 dB gain = (float) 20 * log10( float(db_table_value) / 0x8000000 ) */

 EMU10k1/EMU10k2 DSP control db gain */

 EMU10K1 bass/treble db gain */

/*

 *   controls

/*

 *   Interrupt handler

 irq ptr can be removed from list */

/*************************************************************************

 * EMU10K1 effect manager

 FIXME: we need to check the WRITE access */

 inverted, we want to write new value in gpr_ctl_put() */

 overwrite */

	/* stop FX processor - this may be dangerous, but it's better to miss

 ok, do the main job */

 start FX processor when the DSP code is updated */

 ok, do the main job */

 remove */

 FIXME: we need to add universal code to the PCM transfer routine */

/*

 * Used for emu1010 - conversion from 32-bit capture inputs from HANA

 * to 2 x 16-bit registers in audigy - their values are read via DMA.

 * Conversion is performed by Audigy DSP instructions of FX8010.

/*

 * initial DSP configuration for Audigy

 we reserve 10 voices */

 clear free GPRs */

 clear TRAM data & address lines */

 stop FX processor */

	/* PCM front Playback Volume (independent from stereo mix)

	 * playback = 0 + ( gpr * FXBUS_PCM_LEFT_FRONT >> 31)

	 * where gpr contains attenuation from corresponding mixer control

	 * (snd_emu10k1_init_stereo_control)

 PCM Surround Playback (independent from stereo mix) */

 PCM Side Playback (independent from stereo mix) */

 PCM Center Playback (independent from stereo mix) */

 PCM LFE Playback (independent from stereo mix) */

	/*

	 * Stereo Mix

 Wave (PCM) Playback Volume (will be renamed later) */

 Synth Playback */

 Wave (PCM) Capture */

 Synth Capture */

	/*

	 * inputs

 emu1212 DSP 0 and DSP 1 Capture */

 Note:JCD:No longer bit shift lower 16bits to upper 16bits of 32bit value. */

 AC'97 Playback Volume - used only for mic (renamed later) */

 AC'97 Capture Volume - used only for mic */

 mic capture buffer */	

 Audigy CD Playback Volume */

 Audigy CD Capture Volume */

 Optical SPDIF Playback Volume */

 Optical SPDIF Capture Volume */

 Line2 Playback Volume */

 Line2 Capture Volume */

 Philips ADC Playback Volume */

 Philips ADC Capture Volume */

 Aux2 Playback Volume */

 Aux2 Capture Volume */

 Stereo Mix Front Playback Volume */

 Stereo Mix Surround Playback */

 Stereo Mix Center Playback */

 Center = sub = Left/2 + Right/2 */

 Stereo Mix LFE Playback */

 Stereo Mix Side Playback */

	/*

	 * outputs

	/*

	 *  Process tone control

 left */

 right */

 rear left */

 rear right */

 center */

 LFE */

 side left */

 side right */

 front/rear/center-lfe/side */

 left/right */

 center */

 Master volume (will be renamed later) */

 analog speakers */

 headphone */

 digital outputs */

 A_PUT_STEREO_OUTPUT(A_EXTOUT_FRONT_L, A_EXTOUT_FRONT_R, playback + SND_EMU10K1_PLAYBACK_CHANNELS); */

 EMU1010 Outputs from PCM Front, Rear, Center, LFE, Side */

 IEC958 Optical Raw Playback Switch */ 

 Due to a SPDIF output bug on some Audigy cards, this code delays the Right channel by 1 sample */

 ADC buffer */

 Capture 16 (originally 8) channels of S32_LE sound */

			/*

			dev_dbg(emu->card->dev, "emufx.c: gpr=0x%x, tmp=0x%x\n",

			       gpr, tmp);

 For the EMU1010: How to get 32bit values from the DSP. High 16bits into L, low 16bits into R. */

			/* A_P16VIN(0) is delayed by one sample,

			 * so all other A_P16VIN channels will need to also be delayed

 Left ADC in. 1 of 2 */

 Right ADC in 1 of 2 */

			/* Delaying by one sample: instead of copying the input

			 * value A_P16VIN to output A_FXBUS2 as in the first channel,

			 * we use an auxiliary register, delaying the value by one

			 * sample

 For 96kHz mode */

 Left ADC in. 2 of 2 */

 Right ADC in 2 of 2 */

			/* Pavel Hofman - we still have voices, A_FXBUS2s, and

			 * A_P16VINs available -

			 * let's add 8 more capture channels - total of 16

 EFX capture - capture the 16 EXTINs */

 Capture 16 channels of S16_LE sound */

 JCD test */

	/*

	 * ok, set up done..

 clear remaining instruction memory */

 support TLV */

 clear again */

/*

 * initial DSP configuration for Emu10k1

 when volume = max, then copy only to avoid volume modification */

 with iMAC0 (negative values) */

 clear free GPRs */

 clear TRAM data & address lines */

 we have 12 inputs */

 we have 6 playback channels and tone control doubles */

 we need 4 temporary GPR */

 from 0x8c to 0xff is the area for tone control */

 stop FX processor */

	/*

	 *  Process FX Buses

 S/PDIF left */

 S/PDIF right */

 Raw S/PDIF PCM */

 skip at 01 to 22 */

 skip at 06 to 22 */

 skip at 0a to 24 */

 if the trigger flag is not set, skip */

 00: */ OP(icode, &ptr, iMAC0, C_00000000, GPR(ipcm->gpr_trigger), C_00000000, C_00000000);

 01: */ OP(icode, &ptr, iSKIP, GPR_COND, GPR_COND, CC_REG_ZERO, GPR(gpr + 6));

 if the running flag is set, we're running */

 02: */ OP(icode, &ptr, iMAC0, C_00000000, GPR(ipcm->gpr_running), C_00000000, C_00000000);

 03: */ OP(icode, &ptr, iSKIP, GPR_COND, GPR_COND, CC_REG_NONZERO, C_00000004);

 wait until ((GPR_DBAC>>11) & 0x1f) == 0x1c) */

 04: */ OP(icode, &ptr, iANDXOR, GPR(tmp + 0), GPR_DBAC, GPR(gpr + 4), C_00000000);

 05: */ OP(icode, &ptr, iMACINT0, C_00000000, GPR(tmp + 0), C_ffffffff, GPR(gpr + 5));

 06: */ OP(icode, &ptr, iSKIP, GPR_COND, GPR_COND, CC_REG_NONZERO, GPR(gpr + 7));

 07: */ OP(icode, &ptr, iACC3, GPR(gpr + 12), C_00000010, C_00000001, C_00000000);

 08: */ OP(icode, &ptr, iANDXOR, GPR(ipcm->gpr_running), GPR(ipcm->gpr_running), C_00000000, C_00000001);

 09: */ OP(icode, &ptr, iACC3, GPR(gpr + 12), GPR(gpr + 12), C_ffffffff, C_00000000);

 0a: */ OP(icode, &ptr, iSKIP, GPR_COND, GPR_COND, CC_REG_NONZERO, GPR(gpr + 11));

 0b: */ OP(icode, &ptr, iACC3, GPR(gpr + 12), C_00000001, C_00000000, C_00000000);

 0c: */ OP(icode, &ptr, iANDXOR, GPR(tmp + 0), ETRAM_DATA(ipcm->etram[0]), GPR(gpr + 0), C_00000000);

 0d: */ OP(icode, &ptr, iLOG, GPR(tmp + 0), GPR(tmp + 0), GPR(gpr + 3), C_00000000);

 0e: */ OP(icode, &ptr, iANDXOR, GPR(8), GPR(tmp + 0), GPR(gpr + 1), GPR(gpr + 2));

 0f: */ OP(icode, &ptr, iSKIP, C_00000000, GPR_COND, CC_REG_MINUS, C_00000001);

 10: */ OP(icode, &ptr, iANDXOR, GPR(8), GPR(8), GPR(gpr + 1), GPR(gpr + 2));

 11: */ OP(icode, &ptr, iANDXOR, GPR(tmp + 0), ETRAM_DATA(ipcm->etram[1]), GPR(gpr + 0), C_00000000);

 12: */ OP(icode, &ptr, iLOG, GPR(tmp + 0), GPR(tmp + 0), GPR(gpr + 3), C_00000000);

 13: */ OP(icode, &ptr, iANDXOR, GPR(9), GPR(tmp + 0), GPR(gpr + 1), GPR(gpr + 2));

 14: */ OP(icode, &ptr, iSKIP, C_00000000, GPR_COND, CC_REG_MINUS, C_00000001);

 15: */ OP(icode, &ptr, iANDXOR, GPR(9), GPR(9), GPR(gpr + 1), GPR(gpr + 2));

 16: */ OP(icode, &ptr, iACC3, GPR(tmp + 0), GPR(ipcm->gpr_ptr), C_00000001, C_00000000);

 17: */ OP(icode, &ptr, iMACINT0, C_00000000, GPR(tmp + 0), C_ffffffff, GPR(ipcm->gpr_size));

 18: */ OP(icode, &ptr, iSKIP, GPR_COND, GPR_COND, CC_REG_MINUS, C_00000001);

 19: */ OP(icode, &ptr, iACC3, GPR(tmp + 0), C_00000000, C_00000000, C_00000000);

 1a: */ OP(icode, &ptr, iACC3, GPR(ipcm->gpr_ptr), GPR(tmp + 0), C_00000000, C_00000000);

 1b: */ OP(icode, &ptr, iACC3, GPR(ipcm->gpr_tmpcount), GPR(ipcm->gpr_tmpcount), C_ffffffff, C_00000000);

 1c: */ OP(icode, &ptr, iSKIP, GPR_COND, GPR_COND, CC_REG_NONZERO, C_00000002);

 1d: */ OP(icode, &ptr, iACC3, GPR(ipcm->gpr_tmpcount), GPR(ipcm->gpr_count), C_00000000, C_00000000);

 1e: */ OP(icode, &ptr, iACC3, GPR_IRQ, C_80000000, C_00000000, C_00000000);

 1f: */ OP(icode, &ptr, iANDXOR, GPR(ipcm->gpr_running), GPR(ipcm->gpr_running), C_00000001, C_00010000);

 20: */ OP(icode, &ptr, iANDXOR, GPR(ipcm->gpr_running), GPR(ipcm->gpr_running), C_00010000, C_00000001);

 21: */ OP(icode, &ptr, iSKIP, C_00000000, C_7fffffff, C_7fffffff, C_00000002);

 22: */ OP(icode, &ptr, iMACINT1, ETRAM_ADDR(ipcm->etram[0]), GPR(gpr + 8), GPR_DBAC, C_ffffffff);

 23: */ OP(icode, &ptr, iMACINT1, ETRAM_ADDR(ipcm->etram[1]), GPR(gpr + 9), GPR_DBAC, C_ffffffff);

 24: */

 Wave Playback Volume */

 Wave Surround Playback Volume */

 Wave Center/LFE Playback Volume */

 Wave Capture Volume + Switch */

 Synth Playback Volume */

 Synth Capture Volume + Switch */

 Surround Digital Playback Volume (renamed later without Digital) */

 Surround Capture Volume + Switch */

 Center Playback Volume (renamed later without Digital) */

 LFE Playback Volume + Switch (renamed later without Digital) */

 Front Playback Volume */

 Front Capture Volume + Switch */

	/*

	 *  Process inputs

 AC'97 Playback Volume */

 AC'97 Capture Volume */

 IEC958 TTL Playback Volume */

 IEC958 TTL Capture Volume + Switch */

 Zoom Video Playback Volume */

 Zoom Video Capture Volume + Switch */

 IEC958 Optical Playback Volume */

 IEC958 Optical Capture Volume */

 Line LiveDrive Playback Volume */

 Line LiveDrive Capture Volume + Switch */

 IEC958 Coax Playback Volume */

 IEC958 Coax Capture Volume + Switch */

 Line LiveDrive Playback Volume */

 Line LiveDrive Capture Volume */

	/*

	 *  Process tone control

 left */

 right */

 rear left */

 rear right */

 center */

 LFE */

 front/rear/center-lfe */

 left/right */

 center */

	/*

	 *  Process outputs

 AC'97 Playback Volume */

 IEC958 Optical Raw Playback Switch */

 Headphone Playback Volume */

 AC'97 can have also Headphone control */

 EFX capture - capture the 16 EXTINS */

		/* On the Live! 5.1, FXBUS2(1) and FXBUS(2) are shared with EXTOUT_ACENTER

		 * and EXTOUT_ALFE, so we can't connect inputs to them for multitrack recording.

		 *

		 * Since only 14 of the 16 EXTINs are used, this is not a big problem.  

		 * We route AC97L and R to FX capture 14 and 15, SPDIF CD in to FX capture 

		 * 0 and 3, then the rest of the EXTINs to the corresponding FX capture 

		 * channel.  Multitrack recorders will still see the center/lfe output signal 

		 * on the second and third channels.

 clear remaining instruction memory */

 support TLV */

 clear again */

 stop processor */

 FIXME: who use them? */

 size is in samples */

/*

 * save/restore GPR, TRAM and codes

 set up TRAM */

 start FX processor when the DSP code is updated */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>

 *                   Creative Labs, Inc.

 *  Routines for IRQ control of EMU10K1 chips

 *

 *  BUGS:

 *    --

 *

 *  TODO:

 *    --

 Full Loop */

 dev_dbg(emu->card->dev, "status2=0x%x\n", status2); */

 dev_info(emu->card->dev, "capture int found\n"); */

 dev_info(emu->card->dev, "capture period_elapsed\n"); */

 ack all */

make sure any interrupts we don't handle are disabled:

 ack all */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>

 *  Copyright (c) by Takashi Iwai <tiwai@suse.de>

 *

 *  EMU10K1 memory page allocation (PTB area)

/* page arguments of these two macros are Emu page (4096 bytes), not like

 * aligned pages in others

 get aligned page from offset address */

 get offset address from aligned page */

 fill PTB entrie(s) corresponding to page with addr */

 fill PTB entrie(s) corresponding to page with silence pointer */

 fill PTB entries -- we need to fill UNIT_PAGES entries */

 do not increment ptr */

 PAGE_SIZE */

/*

 initialize emu10k1 part */

/*

 * search empty region on PTB with the given size

 *

 * if an empty region is found, return the page and store the next mapped block

 * in nextp

 * if not found, return a negative error code.

 we look for the maximum empty hole */

/*

 * map a memory block onto emu10k1's PTB

 *

 * call with memblk_lock held

 not found */

 insert this block in the proper position of mapped list */

 append this as a newest block in order list */

 fill PTB */

/*

 * unmap the block

 * return the size of resultant empty pages

 *

 * call with memblk_lock held

 calculate the expected size of empty region */

 remove links */

 clear PTB */

 return the new empty size */

/*

 * search empty pages with the given size, and create a memory block

 *

 * unlike synth_alloc the memory block is aligned to the page start

 create a new memory block */

 set aligned offset */

/*

 * check if the given pointer is valid for pages

/*

 * map the given memory block on PTB.

 * if the block is already mapped, update the link order.

 * if no empty pages are found, tries to release unused memory blocks

 * and retry the mapping.

 update order link */

 no enough page - try to unmap some blocks */

 starting from the oldest block */

 ok the empty region is enough large */

/*

 * page allocation for DMA

	/* fill buffer addresses but pointers are not stored so that

	 * snd_free_pci_page() is not called in in synth_free()

 set PTB entries */

 do not unmap this block! */

/*

 * release DMA buffer from page table

/*

 * allocate DMA pages, widening the allocation if necessary

 *

 * See the comment above snd_emu10k1_detect_iommu() in emu10k1_main.c why

 * this might be needed.

 *

 * If you modify this function check whether __synth_free_pages() also needs

 * changes.

		/*

		 * The device has been observed to accesses up to 256 extra

		 * bytes, but use 1k to be safe.

/*

 * memory allocation using multiple pages (for synth)

 * Unlike the DMA allocation above, non-contiguous pages are assined.

/*

 * allocate a synth sample area

/*

 * free a synth sample area

 check new allocation range */

 first page was already allocated */

 last page was already allocated */

 release allocated pages */

		/*

		 * please keep me in sync with logic in

		 * snd_emu10k1_alloc_pages_maybe_wider()

/*

 * allocate kernel pages

 allocate kernel pages */

 release allocated pages */

/*

 * free pages

 calculate buffer pointer from offset address */

/*

 * bzero(blk + offset, size)

/*

 * copy_from_user(blk + offset, data, size)

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2008, Creative Technology Ltd. All Rights Reserved.

 *

 * @File	cthw20k2.c

 *

 * @Brief

 * This file contains the implementation of hardware access method for 20k2.

 *

 * @Author	Liu Chun

 * @Date 	May 14 2008

 for i2c */

/*

 * Type definition block.

 * The layout of control structures can be directly applied on 20k2 chip.

/*

 * SRC control block definitions.

 SRC resource control block */

/* Mixer Parameter Ring ram Low and Hight register.

 SRC resource register dirty flags */

 Clear Z-Buffers */

 SRC manager control block */

 SRCIMP manager control block */

 SRCIMP manager register dirty flags */

/*

 * Function implementation block.

 Clear Z-Buffer registers */

		/* Take the parameter mixer resource in the same group as that

		 * the idx src is in for simplicity. Unlike src, all conjugate

		 * parameter mixer resources must be programmed for

 Write srccf register */

/*

 * AMIXER control block definitions.

 AMIXER resource register dirty flags */

 AMIXER resource control block */

/*

 * DAIO control block definitions.

 Receiver Sample Rate Tracker Control register */

 DAIO Receiver register dirty flags */

 DAIO Receiver control block */

 Audio Input Mapper RAM */

 Audio Transmitter Control and Status register */

 XDIF Transmitter register dirty flags */

 XDIF Transmitter control block */

 XDIF Transmitter Channel Status Low Register */

 Audio Receiver Control register */

 DAIO manager register dirty flags */

 DAIO manager control block */

 S/PDIF SPOSx */

 S/PDIF output */

 CDIF */

 Non-audio */

 Non-audio */

 I2S output */

idx %= 4; */

 Timer interrupt */

 Card hardware initialization block */

 master sample rate in rsrs */

 master sample rate in rsrs */

 the input source of ADC */

 boost mic by 20db if input is microphone */

 master sample rate in rsrs */

	/* Program I2S with proper sample rate and enable the correct I2S

 PCM4220 on Titanium HD is different. */

		/* Specify all playing 96khz

		 * EA [0]	- Enabled

		 * RTA [4:5]	- 96kHz

		 * EB [8]	- Enabled

		 * RTB [12:13]	- 96kHz

		 * EC [16]	- Enabled

		 * RTC [20:21]	- 96kHz

		 * ED [24]	- Enabled

 This comment looks wrong since loop is over 4  */

 channels and emu20k2 supports 4 spdif IOs.     */

 1st 3 channels are SPDIFs (SB0960) */

			/* Initialize the SPDIF Out Channel status registers.

			 * The value specified here is based on the typical

			 * values provided in the specification, namely: Clock

			 * Accuracy of 1000ppm, Sample Rate of 48KHz,

			 * unspecified source number, Generation status = 1,

			 * Category code = 0x12 (Digital Signal Mixer),

			 * Mode = 0, Emph = 0, Copy Permitted, AN = 0

			 * (indicating that we're transmitting digital audio,

 Default to 48kHz */

 Again, loop is over 4 channels not 5. */

 Next 5 channels are I2S (SB0960) */

 Four channels per sample period */

 FIXME: check this against the chip spec */

 TRANSPORT operations */

 Set up device page table */

 32-bit, 4k-size page */

 64bit address */

 Write page table physical address to all PTPAL registers */

 Enable virtual memory transfer */

 Enable transport bus master and queueing of request */

 Enable transport ring */

 Card initialization */

 DAC operations */

 I2C status */

 Used with I2C_IF_STATUS */

 Used with I2C_IF_STATUS */

 Send keys for forced BIOS mode */

 Check whether the chip is unlocked */

 Write twice */

 Direct control mode */

 I2C id */

 I2C mode */

 Force a read operation */

 Dummy write to trigger the write operation */

 This is the real data */

 Mode Control 1 */

 Mode Control 2 */

 Mode Control 3 */

 Filter Control */

 Invert Control */

 Mixing Control Pair 1 */

 Vol Control A1 */

 Vol Control B1 */

 Mixing Control Pair 2 */

 Vol Control A2 */

 Vol Control B2 */

 Mixing Control Pair 3 */

 Vol Control A3 */

 Vol Control B3 */

 Mixing Control Pair 4 */

 Vol Control A4 */

 Vol Control B4 */

 Single Speed Mode 0-50kHz */

 Double Speed Mode 50-100kHz */

 Quad Speed Mode 100-200kHz */

 Set DAC reset bit as output */

		/* Reset DAC twice just in-case the chip

	/* Note: Every I2C write must have some delay.

 ADC operations */

 Titanium HD has two ADC chips, one for line in and one */

 for MIC. We don't need to switch the ADC input. */

 Link L+R gain... */

 ...so there should be no need for the following. */

 Mic, 20dB */

 Line-in, 0dB */

  Set ADC reset bit as output */

 Initialize I2C */

 Reset the ADC (reset is active low). */

 Set up the PCM4220 ADC on Titanium HD */

 Single Speed Mode 32-50kHz */

 Double Speed Mode 50-108kHz */

 Quad Speed Mode 108kHz-216kHz */

 Return the ADC to normal operation. */

 I2C write to register offset 0x0B to set ADC LRCLK polarity */

 invert bit, interface format to I2S, word length to 24-bit, */

 enable ADC high pass filter. Fixes bug 5323?		*/

 Set the master mode (256fs) */

 slave mode, 128x oversampling 256fs */

 slave mode, 64x oversampling, 256fs */

 Configure GPIO bit 14 change to line-in/mic-in */

 Mute line and headphones (intended for anti-pop). */

 Unmute line and headphones. */

 Mic, 0dB */

 FP Mic, 0dB */

 Aux Ext, 0dB */

 Set DMA transfer mask */

 Switch to 20k2 mode from UAA mode. */

/*error3:

	iounmap((void *)hw->mem_base);

 disable transport bus master and queueing of request */

 disable pll */

 TODO: Disable interrupt and so on... */

	/* Get PCI io port/memory base address and

 PLL init */

 kick off auto-init */

 Reset all global pending interrupts */

 Reset all SRC pending interrupts */

 TODO: detect the card ID and configure GPIO accordingly. */

 Configures GPIO (0xD802 0x98028) */

hw_write_20kx(hw, GPIO_CTRL, 0x7F07);*/

 Configures GPIO (SB0880) */

hw_write_20kx(hw, GPIO_CTRL, 0xFF07);*/

 Enable audio ring */

 Enables input from the audio ring */

 Re-initialize card hardware. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * PCM timer handling on ctxfi

 timer instance -- assigned to each PCM stream */

 timer instance manager */

 global timer lock (for xfitimer) */

 lock for instance list */

 current wallclock */

 in IRQ handling */

 need to reprogram the internval */

 global timer running */

/*

 * system-timer-based updates

	/* Add extra HZ*5/1000 to avoid overrun issue when recording

/*

 * Handling multiple streams using a global emu20k1 timer irq

/*

 * reprogram the timer interval;

 * checks the running instance list and determines the next timer interval.

 * also updates the each stream position, returns the number of streams

 * to call snd_pcm_period_elapsed() appropriately

 *

 * call this inside the lock and irq disabled

 clear flag */

 pending to the next irq */

 clear flag */

 look through the instance list and call period_elapsed if needed */

 Handle timer-interrupt */

 start/stop the timer */

 reached from IRQ handler; let it handle later */

/*

 * timer instance

 to be sure */

/*

 * timer manager

 Interval timer interrupt */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2008, Creative Technology Ltd. All Rights Reserved.

 *

 * @File    ctatc.c

 *

 * @Brief

 * This file contains the implementation of the device resource management

 * object.

 *

 * @Author Liu Chun

 * @Date Mar 28 2008

 2^(-0.5) in 14-bit floating format */

 terminator */

 terminator */

 20k1 models */

 20k2 models */

/* *

 * Only mono and interleaved modes are supported now.

 * Always allocates a contiguous channel block.

 get pitch and convert to fixed-point 8.24 format. */

 0.26 <= pitch <= 1.72 */

 pitch == 1.8375 */

 pitch == 2 */

 0 <= pitch <= 8 */

 first release old resources */

 Get SRC resource */

 Get AMIXER resource */

 Set up device virtual mem map */

 Connect resources */

 Undo device virtual mem map */

 get pitch and convert to fixed-point 8.24 format. */

 FIXME: do we really need SRC here if pitch==1 */

			/* Need two-stage SRCs, SRCIMPs and

			/* Need one-stage SRCs, SRCIMPs and

 first release old resources */

	/* The numbers of converting SRCs and SRCIMPs should be determined

 get pitch and convert to fixed-point 8.24 format. */

		/* Need extra AMIXERs and SRCIMPs for special treatment

 Allocate SRCs for sample rate conversion if needed */

 Allocate AMIXERs for routing SRCs of conversion if needed */

 Allocate a SUM resource to mix all input channels together */

 Allocate SRCIMP resources */

 Allocate a SRC for writing data to host memory */

 Set up device virtual mem map */

 Get needed resources. */

 Connect resources */

		/* Special connection for interleaved

 Set up converting SRCs */

  Set up recording SRC */

 Disable relevant SRCs firstly */

 Enable SRCs respectively */

 Enable relevant SRCs synchronously */

 first release old resources */

 Get SRC resource */

 Get AMIXER resource */

 Set up device virtual mem map */

	/* Configure SPDIFOO and PLL to passthrough mode;

 Get needed resources. */

 Connect resources */

 Connect to SPDIFOO */

 Restore PLL to atc->rsr if needed. */

 disconnect internal mixer objects */

 Destroy internal mixer objects */

 Destroy device virtual memory manager object */

 Initialize card hardware. */

 Actually disable SRCs */

 Synchronously enable SRCs */

 Titanium HD has a dedicated ADC for the Mic. */

 Re-initialize card hardware. */

 Get resources */

 Build topology */

 Do hardware resume. */

/**

 *  ct_atc_create - create and initialize a hardware manager

 *  @card: corresponding alsa card object

 *  @pci: corresponding kernel pci device object

 *  @rsr: reference sampling rate

 *  @msr: master sampling rate

 *  @chip_type: CHIPTYP enum values

 *  @ssid: vendor ID (upper 16 bits) and device ID (lower 16 bits)

 *  @ratc: return created object address in it

 *

 *  Creates and initializes a hardware manager.

 *

 *  Creates kmallocated ct_atc structure. Initializes hardware.

 *  Returns 0 if succeeds, or negative error code if fails.

 Set operations */

 Find card model */

 Set up device virtual memory management object */

 Create all atc hw devices */

 Get resources */

 Build topology */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2008, Creative Technology Ltd. All Rights Reserved.

 *

 * @File	ctpcm.c

 *

 * @Brief

 * This file contains the definition of the pcm device functions.

 *

 * @Author	Liu Chun

 * @Date 	Apr 2 2008

 Hardware descriptions for playback */

 Hardware descriptions for capture */

 pcm playback operations */

 TODO: Notify mixer inactive. */

 The ct_atc_pcm object will be freed by runtime->private_free */

 clear previous resources */

 clear previous resources */

 Read out playback position */

 pcm capture operations */

 The ct_atc_pcm object will be freed by runtime->private_free */

 TODO: Notify mixer inactive. */

 Read out playback position */

 PCM operators for playback */

 PCM operators for capture */

 Create ALSA pcm device */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2008, Creative Technology Ltd. All Rights Reserved.

 *

 * @File	cthardware.c

 *

 * @Brief

 * This file contains the implementation of hardware access methord.

 *

 * @Author	Liu Chun

 * @Date 	Jun 26 2008

 20k1 device */

 20k2 device */

 @field should always be greater than 0 */

 @field should always be greater than 0 */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2008, Creative Technology Ltd. All Rights Reserved.

 *

 * @File	ctamixer.c

 *

 * @Brief

 * This file contains the implementation of the Audio Mixer

 * resource management object.

 *

 * @Author	Liu Chun

 * @Date 	May 21 2008

 y is a 14-bit immediate constant */

 Program master and conjugate resources */

 Set amixer specific operations */

 Allocate mem for amixer resource */

	/* Check whether there are sufficient

 SUM resource management */

 Allocate mem for sum resource */

 Check whether there are sufficient sum resources to meet request. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * xfi linux driver.

 *

 * Copyright (C) 2008, Creative Technology Ltd. All Rights Reserved.

 only X-Fi is supported, so... */

 Create alsa devices supported by this card */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2008, Creative Technology Ltd. All Rights Reserved.

 *

 * @File    ctvmem.c

 *

 * @Brief

 * This file contains the implementation of virtual memory management object

 * for card device.

 *

 * @Author Liu Chun

 * @Date Apr 1 2008

/* *

 * Find or create vm block based on requested @size.

 * @size must be page aligned.

 found a block that is big enough */

 Move the vm node from unused list to used list directly */

 found a position */

 Map host addr (kmalloced/vmalloced) to device logical addr. */

 do unmapping */

/* *

 * return the host physical addr of the @index-th device

 * page table page on success, or ~0UL on failure.

 * The first returned ~0UL indicates the termination.

 Allocate page table pages */

 no page table pages are allocated */

/* The caller must ensure no mapping pages are being used

 free used and unused list nodes */

 free allocated page table pages */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2008, Creative Technology Ltd. All Rights Reserved.

 *

 * @File	ctmixer.c

 *

 * @Brief

 * This file contains the implementation of alsa mixer device functions.

 *

 * @Author	Liu Chun

 * @Date 	May 28 2008

 volume control mixers */

 this should always be the last one */

 volume control mixers */

 switch control mixers */

 this should always be the last one */

 FIXME: this static looks like it would fail if more than one card was */

 installed. */

 not used */

/* Map integer value ranging from 0 to 65535 to 14-bit float value ranging

 i <= 6 */

 not used */

 Synchronize Master/PCM playback AMIXERs. */

 Do changes in mixer. */

 Do changes out of mixer. */

 Create snd kcontrol instances on demand */

 Allocate sum resources for mixer obj */

 Allocate amixer resources for mixer obj */

 Allocate mem for mixer obj */

 Build topology from destination to source */

 Set up Master mixer */

 Set up Wave-out mixer */

 Set up S/PDIF-out mixer */

 Set up PCM-in mixer */

 Set up Line-in mixer */

 Set up Mic-in mixer */

 Set up S/PDIF-in mixer */

 Set up Master recording mixer */

 Set up PCM-in recording mixer */

 Set up Line-in recording mixer */

 Set up Mic-in recording mixer */

 Set up S/PDIF-in recording mixer */

 resume topology and volume gain. */

 resume switch state. */

 Release amixer resources */

 Release sum resources */

 Release mem assigned to mixer object */

 Allocate mem for mixer obj */

 Set operations */

 Allocate chip resources for mixer obj */

 Build internal mixer topology */

 Create snd kcontrol instances on demand */

 vol_ctl.device = swh_ctl.device = device; */ 
 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2008, Creative Technology Ltd. All Rights Reserved.

 *

 * @File	ctresource.c

 *

 * @Brief

 * This file contains the implementation of some generic helper functions.

 *

 * @Author	Liu Chun

 * @Date 	May 15 2008

 Resource allocation based on bit-map management mechanism */

 Check whether there are sufficient resources to meet request. */

 found sufficient contiguous resources */

 Can not find sufficient contiguous resources */

 Mark the contiguous bits in resource bit-map as used */

 Mark the contiguous bits in resource bit-map as used */

 SRC channel is at Audio Ring slot 1 every 16 slots. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2008, Creative Technology Ltd. All Rights Reserved.

 *

 * @File	ctdaio.c

 *

 * @Brief

 * This file contains the implementation of Digital Audio Input Output

 * resource management object.

 *

 * @Author	Liu Chun

 * @Date 	May 23 2008

	/* Actually, this is not the resource index of DAIO.

	 * For DAO, it is the input mapper index. And, for DAI,

 Program master and conjugate resources */

 Program master and conjugate resources */

 Program conjugate resources */

 Program conjugate resources */

 Set daio->rscl/r->ops to daio specific ones */

 default to disabling control of a SRC */

 default to disabling SRT */

 Check whether there are sufficient daio resources to meet request. */

 Allocate mem for daio resource */

 free daio input mapper list */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2008, Creative Technology Ltd. All Rights Reserved.

 *

 * @File	ctimap.c

 *

 * @Brief

 * This file contains the implementation of generic input mapper operations

 * for input mapper management.

 *

 * @Author	Liu Chun

 * @Date 	May 23 2008

 found a position in list */

 entry is the only one node in mappers list */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2008, Creative Technology Ltd. All Rights Reserved.

 *

 * @File	ctsrc.c

 *

 * @Brief

 * This file contains the implementation of the Sample Rate Convertor

 * resource management object.

 *

 * @Author	Liu Chun

 * @Date 	May 13 2008

 Save dirty flags for conjugate resource programming */

 Program conjugate parameter mixer resources */

hw->src_set_sa(src->rsc.ctrl_blk, 0x100);*/

hw->src_set_la(src->rsc.ctrl_blk, 0x03ffffe0);*/

 Initialize src specific rsc operations */

 Set @intlv of the last SRC to NULL */

 Check whether there are sufficient src resources to meet request. */

 Allocate mem for master src resource */

 Disable all SRC resources. */

 SRCIMP resource manager operations */

 Program master and conjugate resources */

 Program master and conjugate resources */

 Reserve memory for imapper nodes */

 Set srcimp specific operations */

 Allocate mem for SRCIMP resource */

 Check whether there are sufficient SRCIMP resources. */

 free src input mapper list */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2008, Creative Technology Ltd. All Rights Reserved.

 *

 * @File	cthw20k1.c

 *

 * @Brief

 * This file contains the implementation of hardware access methord for 20k1.

 *

 * @Author	Liu Chun

 * @Date 	Jun 24 2008

/*

 * Type definition block.

 * The layout of control structures can be directly applied on 20k2 chip.

/*

 * SRC control block definitions.

 SRC resource control block */

/* Mixer Parameter Ring ram Low and Hight register.

 SRC resource register dirty flags */

 Clear Z-Buffers */

 SRC manager control block */

 SRCIMP manager control block */

 SRCIMP manager register dirty flags */

/*

 * Function implementation block.

 Clear Z-Buffer registers */

		/* Take the parameter mixer resource in the same group as that

		 * the idx src is in for simplicity. Unlike src, all conjugate

		 * parameter mixer resources must be programmed for

 Write srccf register */

/*

 * AMIXER control block definitions.

 AMIXER resource register dirty flags */

 AMIXER resource control block */

 20k1 amixer does not have this field */

amixer_mgr_ctrl_blk_t *blk;*/

	/*blk = kzalloc(sizeof(*blk), GFP_KERNEL);

	if (!blk)

		return -ENOMEM;



kfree((amixer_mgr_ctrl_blk_t *)blk);*/

/*

 * DAIO control block definitions.

 Receiver Sample Rate Tracker Control register */

 DAIO Receiver register dirty flags */

 DAIO Receiver control block */

 S/PDIF Transmitter register dirty flags */

 S/PDIF Transmitter control block */

 S/PDIF Output Channel Status Register */

 Audio Input Mapper RAM */

 I2S Transmitter/Receiver Control register */

 S/PDIF Transmitter Control register */

 S/PDIF Receiver Control register */

 DAIO manager register dirty flags */

 DAIO manager control block */

 S/PDIF SRTs */

 I2S SRT */

 S/PDIF SPOSx */

 S/PDIF input */

 I2S input */

 S/PDIF input */

 I2S input */

 S/PDIF output */

 I2S output */

 S/PDIF output */

 I2S output */

 S/PDIF output */

 CDIF */

 Non-audio */

 Non-audio */

 Raw */

 I2S output */

idx %= 4; */

 Timer interrupt */

 Card hardware initialization block */

 master sample rate in rsrs */

 master sample rate in rsrs */

 the input source of ADC */

 boost mic by 20db if input is microphone */

 master sample rate in rsrs */

 Read I2S CTL.  Keep original value. */

i2sorg = hw_read_20kx(hw, I2SCTL);*/

 enable all audio out and I2S-D input */

	/* Program I2S with proper master sample rate and enable

	/* Enable S/PDIF-out-A in fixed 24-bit data

 Disable all before doing any changes. */

 Enable S/PDIF-in-A in fixed 24-bit data format. */

 Disable all before doing any changes. */

 TRANSPORT operations */

 Set up device page table */

 32-bit, 4k-size page */

 64bit address */

 Only 4k h/w pages for simplicitiy */

 really needed? */

 Card initialization */

 DAC operations */

 write to i2c status control */

 To be effective, need to reset the DAC twice. */

 set gpio */

 SB055x, unmute outputs */

 set GPIO6 to low */

 set GPIO1 to high */

 mute outputs */

 write to i2c status control */

 unmute outputs */

 ADC operations */

 Digital I/O */

	/*

	 * check and set the following GPIO bits accordingly

	 * ADC_Gain		= GPIO2

	 * DRM_off		= GPIO3

	 * Mic_Pwr_on		= GPIO7

	 * Digital_IO_Sel	= GPIO8

	 * Mic_Sw		= GPIO9

	 * Aux/MicLine_Sw	= GPIO12

 set to digital */

 i2c ready poll */

 set i2c access mode as Direct Control */

 Mic-in */

 Line-in */

 set to Digital */

 +12dB boost */

 +12dB boost */

 No boost */

 No boost */

 i2c ready poll */

 set i2c access mode as Direct Control */

 Mic-in */

 Line-in */

 +12dB boost */

 +12dB boost */

 No boost */

 No boost */

 default to analog */

 set GPIO7 to select Mic */

 set to Digital */

 i2c ready poll */

 write to i2c status control */

 SB073x and Vista compatible cards have no digit IO switch */

 By default, Hendrix card UAA Bar0 should be using memory... */

 Read current mode from Mode Change Register */

 Determine current mode... */

 Not in UAA mode currently. Return directly. */

 Set up X-Fi core PCI configuration space. */

 Switch to X-Fi config space with BAR0 exposed. */

 Copy UAA's BAR5 into X-Fi BAR0 */

 Switch to X-Fi config space without BAR0 exposed. */

 Switch to X-Fi mode */

 Set DMA transfer mask */

 Switch to X-Fi mode from UAA mode if neeeded */

 disable transport bus master and queueing of request */

 disable pll */

 Get PCI io port base address and do Hendrix switch if needed. */

 PLL init */

 kick off auto-init */

 Enable audio ring */

 Reset all global pending interrupts */

 Reset all SRC pending interrupts */

 Detect the card ID and configure GPIO accordingly. */

 Enables input from the audio ring */

 Switch to UAA config space. */

 Re-initialize card hardware. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * C-Media CMI8788 driver - helper functions

 *

 * Copyright (c) Clemens Ladisch <clemens@ladisch.de>

	/*

	 * Reading the status register also clears the bits, so we have to save

	 * the read bits in status.

	/*

	 * Check even after a timeout because this function should not require

	 * the AC'97 interrupt to be enabled.

/*

 * About 10% of AC'97 register reads or writes fail to complete, but even those

 * where the controller indicates completion aren't guaranteed to have actually

 * happened.

 *

 * It's hard to assign blame to either the controller or the codec because both

 * were made by C-Media ...

 require two "completed" writes, just to be sure */

 we require two consecutive reads of the same value */

			/*

			 * Invert the register value bits to make sure that two

			 * consecutive unsuccessful reads do not return the same

			 * value.

	/*

	 * Higher timeout to be sure: 200 us;

	 * actual transaction should not need more than 40 us.

	/*

	 * We need to wait AFTER initiating the SPI transaction,

	 * otherwise read operations will not work.

 should not need more than about 300 us */

 wait for ACK */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * card driver for the Xonar DG/DGX

 *

 * Copyright (c) Clemens Ladisch <clemens@ladisch.de>

 * Copyright (c) Roman Volkov <v1ron@mail.ru>

/*

 * Xonar DG/DGX

 * ------------

 *

 * CS4245 and CS4361 both will mute all outputs if any clock ratio

 * is invalid.

 *

 * CMI8788:

 *

 *   SPI 0 -> CS4245

 *

 *   Playback:

 *   IS 1 -> CS4245

 *   IS 2 -> CS4361 (center/LFE)

 *   IS 3 -> CS4361 (surround)

 *   IS 4 -> CS4361 (front)

 *   Capture:

 *   IS ADC 1 <- CS4245

 *

 *   GPIO 3 <- ?

 *   GPIO 4 <- headphone detect

 *   GPIO 5 -> enable ADC analog circuit for the left channel

 *   GPIO 6 -> enable ADC analog circuit for the right channel

 *   GPIO 7 -> switch green rear output jack between CS4245 and the first

 *             channel of CS4361 (mechanical relay)

 *   GPIO 8 -> enable output to speakers

 *

 * CS4245:

 *

 *   input 0 <- mic

 *   input 1 <- aux

 *   input 2 <- front mic

 *   input 4 <- line

 *   DAC out -> headphones

 *   aux out -> front panel headphones

 save the initial state: codec version, registers */

	/*

	 * Power up the CODEC internals, enable soft ramp & zero cross, work in

	 * async. mode, enable aux output from DAC. Invert DAC output as in the

	 * Windows driver.

 anti-pop delay, wait some time before enabling the output */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * helper functions for Asus Xonar cards

 *

 * Copyright (c) Clemens Ladisch <clemens@ladisch.de>

 TODO: stop PCMs */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * helper functions for HDMI models (Xonar HDAV1.3/HDAV1.3 Slim)

 *

 * Copyright (c) Clemens Ladisch <clemens@ladisch.de>

 1 = non-audio */

 96000 */

 ? */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * C-Media CMI8788 driver - PCM code

 *

 * Copyright (c) Clemens Ladisch <clemens@ladisch.de>

 most DMA channels have a 16-bit counter for 32-bit words */

 the multichannel DMA channel has a 24-bit counter */

 48000 */

 2 */

 no spinlock, this read should be atomic */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * card driver for models with PCM1796 DACs (Xonar D2/D2X/HDAV1.3/ST/STX)

 *

 * Copyright (c) Clemens Ladisch <clemens@ladisch.de>

/*

 * Xonar D2/D2X

 * ------------

 *

 * CMI8788:

 *

 *   SPI 0 -> 1st PCM1796 (front)

 *   SPI 1 -> 2nd PCM1796 (surround)

 *   SPI 2 -> 3rd PCM1796 (center/LFE)

 *   SPI 4 -> 4th PCM1796 (back)

 *

 *   GPIO 2 -> M0 of CS5381

 *   GPIO 3 -> M1 of CS5381

 *   GPIO 5 <- external power present (D2X only)

 *   GPIO 7 -> ALT

 *   GPIO 8 -> enable output to speakers

 *

 * CM9780:

 *

 *   LINE_OUT -> input of ADC

 *

 *   AUX_IN   <- aux

 *   VIDEO_IN <- CD

 *   FMIC_IN  <- mic

 *

 *   GPO 0 -> route line-in (0) or AC97 output (1) to CS5381 input

/*

 * Xonar HDAV1.3 (Deluxe)

 * ----------------------

 *

 * CMI8788:

 *

 *   IC <-> PCM1796 (addr 1001100) (front)

 *

 *   GPI 0 <- external power present

 *

 *   GPIO 0 -> enable HDMI (0) or speaker (1) output

 *   GPIO 2 -> M0 of CS5381

 *   GPIO 3 -> M1 of CS5381

 *   GPIO 4 <- daughterboard detection

 *   GPIO 5 <- daughterboard detection

 *   GPIO 6 -> ?

 *   GPIO 7 -> ?

 *   GPIO 8 -> route input jack to line-in (0) or mic-in (1)

 *

 *   UART <-> HDMI controller

 *

 * CM9780:

 *

 *   LINE_OUT -> input of ADC

 *

 *   AUX_IN <- aux

 *   CD_IN  <- CD

 *   MIC_IN <- mic

 *

 *   GPO 0 -> route line-in (0) or AC97 output (1) to CS5381 input

 *

 * no daughterboard

 * ----------------

 *

 *   GPIO 4 <- 1

 *

 * H6 daughterboard

 * ----------------

 *

 *   GPIO 4 <- 0

 *   GPIO 5 <- 0

 *

 *   IC <-> PCM1796 (addr 1001101) (surround)

 *       <-> PCM1796 (addr 1001110) (center/LFE)

 *       <-> PCM1796 (addr 1001111) (back)

 *

 * unknown daughterboard

 * ---------------------

 *

 *   GPIO 4 <- 0

 *   GPIO 5 <- 1

 *

 *   IC <-> CS4362A (addr 0011000) (surround, center/LFE, back)

/*

 * Xonar Essence ST (Deluxe)/STX (II)

 * ----------------------------------

 *

 * CMI8788:

 *

 *   IC <-> PCM1792A (addr 1001100)

 *       <-> CS2000 (addr 1001110) (ST only)

 *

 *   ADC1 MCLK -> REF_CLK of CS2000 (ST only)

 *

 *   GPI 0 <- external power present (STX only)

 *

 *   GPIO 0 -> enable output to speakers

 *   GPIO 1 -> route HP to front panel (0) or rear jack (1)

 *   GPIO 2 -> M0 of CS5381

 *   GPIO 3 -> M1 of CS5381

 *   GPIO 4 <- daughterboard detection

 *   GPIO 5 <- daughterboard detection

 *   GPIO 6 -> ?

 *   GPIO 7 -> route output to speaker jacks (0) or HP (1)

 *   GPIO 8 -> route input jack to line-in (0) or mic-in (1)

 *

 * PCM1792A:

 *

 *   SCK <- CLK_OUT of CS2000 (ST only)

 *

 * CM9780:

 *

 *   LINE_OUT -> input of ADC

 *

 *   AUX_IN <- aux

 *   MIC_IN <- mic

 *

 *   GPO 0 -> route line-in (0) or AC97 output (1) to CS5381 input

 *

 * H6 daughterboard

 * ----------------

 *

 * GPIO 4 <- 0

 * GPIO 5 <- 0

/*

 * Xonar Xense

 * -----------

 *

 * CMI8788:

 *

 *   IC <-> PCM1796 (addr 1001100) (front)

 *       <-> CS4362A (addr 0011000) (surround, center/LFE, back)

 *       <-> CS2000 (addr 1001110)

 *

 *   ADC1 MCLK -> REF_CLK of CS2000

 *

 *   GPI 0 <- external power present

 *

 *   GPIO 0 -> enable output

 *   GPIO 1 -> route HP to front panel (0) or rear jack (1)

 *   GPIO 2 -> M0 of CS5381

 *   GPIO 3 -> M1 of CS5381

 *   GPIO 4 -> enable output

 *   GPIO 5 -> enable output

 *   GPIO 6 -> ?

 *   GPIO 7 -> route output to HP (0) or speaker (1)

 *   GPIO 8 -> route input jack to mic-in (0) or line-in (1)

 *

 * CM9780:

 *

 *   LINE_OUT -> input of ADC

 *

 *   AUX_IN   <- aux

 *   VIDEO_IN <- ?

 *   FMIC_IN  <- mic

 *

 *   GPO 0 -> route line-in (0) or AC97 output (1) to CS5381 input

 *   GPO 1 -> route mic-in from input jack (0) or front panel header (1)

 10011, ii, /W=0 */

 100111, 0, /W=0 */

 maps ALSA channel pair number to SPI output */

 set ATLD before ATL/ATR */

 1.0 */

 PLL lock delay */

 PLL lock delay */

 CD in is actually connected to the video in pin */

 no volume/mute, as IC to the third DAC does not work */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * C-Media CMI8787 driver for the Studio Evolution SE6X

 *

 * Copyright (c) Clemens Ladisch <clemens@ladisch.de>

/*

 * CMI8787:

 *

 *   SPI    -> microcontroller (not actually used)

 *   GPIO 0 -> do.

 *   GPIO 2 -> do.

 *

 *   DAC0   -> both PCM1792A (L+R, each in mono mode)

 *   ADC1  <-  1st PCM1804

 *   ADC2  <-  2nd PCM1804

 *   ADC3  <-  3rd PCM1804

 no DAC volume/mute */

 nothing to do (the microcontroller monitors DAC_LRCK) */

 route the same stereo pair to DAC0 and DAC1 */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * C-Media CMI8788 driver for Asus Xonar cards

 *

 * Copyright (c) Clemens Ladisch <clemens@ladisch.de>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * C-Media CMI8788 driver for C-Media's reference design and similar models

 *

 * Copyright (c) Clemens Ladisch <clemens@ladisch.de>

/*

 * CMI8788:

 *

 *   SPI 0 -> 1st AK4396 (front)

 *   SPI 1 -> 2nd AK4396 (surround)

 *   SPI 2 -> 3rd AK4396 (center/LFE)

 *   SPI 3 -> WM8785

 *   SPI 4 -> 4th AK4396 (back)

 *

 *   GPIO 0 -> DFS0 of AK5385

 *   GPIO 1 -> DFS1 of AK5385

 *

 * X-Meridian models:

 *   GPIO 4 -> enable extension S/PDIF input

 *   GPIO 6 -> enable on-board S/PDIF input

 *

 * Claro models:

 *   GPIO 6 -> S/PDIF from optical (0) or coaxial (1) input

 *   GPIO 8 -> enable headphone amplifier

 *

 * CM9780:

 *

 *   LINE_OUT -> input of ADC

 *

 *   AUX_IN <- aux

 *   CD_IN  <- CD

 *   MIC_IN <- mic

 *

 *   GPO 0 -> route line-in (0) or AC97 output (1) to ADC input

 C-Media's reference design */

 Asus Xonar DG */

 Asus Xonar DGX */

 PCI 2.0 HD Audio */

 Kuroutoshikou CMI8787-HG2PCI */

 TempoTec HiFier Fantasia */

 TempoTec HiFier Serenade */

 AuzenTech X-Meridian */

 AuzenTech X-Meridian 2G */

 HT-Omega Claro */

 HT-Omega Claro halo */

 maps ALSA channel pair number to SPI output */

 wait for the new MCLK to become stable */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * card driver for models with WM8776/WM8766 DACs (Xonar DS/HDAV1.3 Slim)

 *

 * Copyright (c) Clemens Ladisch <clemens@ladisch.de>

/*

 * Xonar DS

 * --------

 *

 * CMI8788:

 *

 *   SPI 0 -> WM8766 (surround, center/LFE, back)

 *   SPI 1 -> WM8776 (front, input)

 *

 *   GPIO 4 <- headphone detect, 0 = plugged

 *   GPIO 6 -> route input jack to mic-in (0) or line-in (1)

 *   GPIO 7 -> enable output to front L/R speaker channels

 *   GPIO 8 -> enable output to other speaker channels and front panel headphone

 *

 * WM8776:

 *

 *   input 1 <- line

 *   input 2 <- mic

 *   input 3 <- front mic

 *   input 4 <- aux

/*

 * Xonar HDAV1.3 Slim

 * ------------------

 *

 * CMI8788:

 *

 *   IC <-> WM8776 (addr 0011010)

 *

 *   GPIO 0  -> disable HDMI output

 *   GPIO 1  -> enable HP output

 *   GPIO 6  -> firmware EEPROM IC clock

 *   GPIO 7 <-> firmware EEPROM IC data

 *

 *   UART <-> HDMI controller

 *

 * WM8776:

 *

 *   input 1 <- mic

 *   input 2 <- aux

 001101, 0, /W=0 */

 reg >= WM8776_HPLVOL is always true */

 reg >= WM8766_LDA1 is always true */

	/*

	 * The WM8766 can mix left and right channels, but this setting

	 * applies to all three stereo pairs.

 line-in and mic-in are exclusive */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * C-Media CMI8788 driver - main driver module

 *

 * Copyright (c) Clemens Ladisch <clemens@ladisch.de>

 no data, but read it anyway to clear the interrupt */

 write the interrupt bit(s) to clear */

	/*

	 * This function gets called when there is new activity on the SPDIF

	 * input, or when we lose lock on the input signal, or when the rate

	 * changes.

		/*

		 * If we detect activity on the SPDIF input but cannot lock to

		 * a signal, the clock bit is likely to be wrong.

 nothing detected with either clock; give up */

				/*

				 * Reset clock to <= 96 kHz because this is

				 * more likely to be received next time.

		/*

		 * We don't actually know that any channel status bits have

		 * changed, but let's send a notification just to be sure.

	/*

	 * Make sure the EEPROM pins are available, i.e., not used for SPI.

	 * (This function is called before we initialize or use SPI.)

	/*

	 * Read the subsystem device ID directly from the EEPROM, because the

	 * chip didn't if the first EEPROM word was overwritten.

 use default ID if EEPROM is missing */

	/*

	 * We use only the subsystem device ID for searching because it is

	 * unique even without the subsystem vendor ID, which may have been

	 * overwritten in the EEPROM.

		/*

		 * This function gets called only when a known card model has

		 * been detected, i.e., we know there is a valid subsystem

		 * product ID at index 2 in the EEPROM.  Therefore, we have

		 * been able to deduce the correct subsystem vendor ID, and

		 * this is enough information to restore the original EEPROM

		 * contents.

 PLX PEX8111/PEX8112 PCIe/PCI bridge */

 enable blind prefetching */

 enable beacon generation */

 set prefetch size to 128 bytes */

 Pericom PI7C9X110 PCIe/PCI bridge */

 park the PCI arbiter to the sound chip */

 Texas Instruments XIO2001 PCIe/PCI bridge */

 request length limit: 64 bytes */

 request count limit: one buffer */

 power down unused ADCs and DACs */

 CONFIG_PM_SLEEP */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Mixer controls for the Xonar DG/DGX

 *

 * Copyright (c) Clemens Ladisch <clemens@ladisch.de>

 * Copyright (c) Roman Volkov <v1ron@mail.ru>

 analog output select */

 mute FP (aux output) amplifier, switch rear jack to CS4245 */

		/*

		 * Unmute FP amplifier, switch rear jack to CS4361;

		 * I2S channels 2,3,4 should be inactive.

		/*

		 * 2.0, 4.0, 5.1: switch to CS4361, mute FP amp.,

		 * and change playback routing.

 CS4245 Headphone Channels A&B Volume Control */

 Headphone Mute */

 capture volume for all sources */

 Capture Source */

 ADC high-pass filter */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * C-Media CMI8788 driver - mixer code

 *

 * Copyright (c) Clemens Ladisch <clemens@ladisch.de>

 DAC 0: front, DAC 1: surround, DAC 2: center/LFE, DAC 3: back */

 stereo -> front */

 stereo -> front+surround */

 stereo -> front+surround+back */

 stereo -> front+surround+center/LFE */

 stereo -> front+surround+center/LFE+back */

 in 7.1 mode, "rear" channels go to the "back" jack */

 OXYGEN_RATE_48000 */

 S/PDIF rate was already set by the caller */

 category and original */

 I'm too lazy to write a function for each control :-) */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * card driver for models with CS4398/CS4362A DACs (Xonar D1/DX)

 *

 * Copyright (c) Clemens Ladisch <clemens@ladisch.de>

/*

 * Xonar D1/DX

 * -----------

 *

 * CMI8788:

 *

 *   IC <-> CS4398 (addr 1001111) (front)

 *       <-> CS4362A (addr 0011000) (surround, center/LFE, back)

 *

 *   GPI 0 <- external power present (DX only)

 *

 *   GPIO 0 -> enable output to speakers

 *   GPIO 1 -> route output to front panel

 *   GPIO 2 -> M0 of CS5361

 *   GPIO 3 -> M1 of CS5361

 *   GPIO 6 -> ?

 *   GPIO 7 -> ?

 *   GPIO 8 -> route input jack to line-in (0) or mic-in (1)

 *

 * CM9780:

 *

 *   LINE_OUT -> input of ADC

 *

 *   AUX_IN  <- aux

 *   MIC_IN  <- mic

 *   FMIC_IN <- front mic

 *

 *   GPO 0 -> route line-in (0) or AC97 output (1) to CS5361 input

 10011, AD1=1, AD0=1, /W=0 */

 001100, AD0=0, /W=0 */

 set CPEN (control port mode) and power down */

 configure */

 clear power down */

 SPDX-License-Identifier: GPL-2.0-or-later

/* -*- linux-c -*- *

 *

 * ALSA driver for the digigram lx6464es interface

 *

 * Copyright (c) 2008, 2009 Tim Blechmann <tim@klingt.org>

 LX6464ES */

 LX6464ES-CAE */

 LX6464ESe */

 LX6464ESe-CAE */

 PGO pour USERo dans le registre pci_0x06/loc_0xEC */

 alsa callbacks */

 copy the struct snd_pcm_hardware struct */

 buffer-size should better be multiple of period-size */

 the clock rate cannot be changed */

 constrain period size */

 reset the dsp during initialization */

 activate reset of xilinx */

 deactivate reset of xilinx */

 todo: add some error handling? */

 clear mr */

 le xilinx ES peut ne pas etre encore pret, on attend. */

 TEST if we have access to Xilinx/MicroBlaze */

 PCI9056_SPACE0_REMAP */

 seems to be appropriate */

 initialize ethersound */

 configure 64 io channels */

	/*

	 * write it to the card !

	 * this actually kicks the ES xilinx, the first time since poweron.

	 * the MAC address in the Reg_ADMACESMSB Reg_ADMACESLSB registers

	 * is not ready before this is done, and the bit 2 in Reg_CSES is set.

 later: what firmware version do we expect? */

 retrieve Play/Rec features */

		/* done here because we may have to handle alternate

 later */

 init the EtherSound sample rate */

 blocksize is a power of 2 */

 initialize and test the xilinx dsp chip */

	/** \todo the mac address should be ready by not, but it isn't,

 channels */

 24 bit samples */

 periods */

 frames per period */

 duplex */

 hardcoded device name & channel count */

 enable PCI device */

 check if we can restrict PCI DMA transfers to 32 bits */

 initialize synchronization structs */

 request resources */

 plx port */

 dsp port */

 SPDX-License-Identifier: GPL-2.0-or-later

/* -*- linux-c -*- *

 *

 * ALSA driver for the digigram lx6464es interface

 * low-level interface

 *

 * Copyright (c) 2009 Tim Blechmann <tim@klingt.org>

 #define RMH_DEBUG 1 */

 low-level register access */

 we cannot use memcpy_fromio */

 we cannot use memcpy_to */

 rmh */

	u32    dcCodeOp;	/* Op Code of the command (usually 1st 24-bits

 Command length in words of 24 bits.*/

	u16    dcStatusType;	/* Status type: 0 for fixed length, 1 for

 Status length (if fixed).*/

/*

  Initialization and control data for the Microblaze interface

  - OpCode:

    the opcode field of the command set at the proper offset

  - CmdLength

    the number of command words

  - StatusType

    offset in the status registers: 0 means that the return value may be

    different from 0, and must be read

  - StatusLength

    the number of status words (in addition to the return value)

custom*/

*/		    , CMD_NAME("INFO_DEBUG") },

*/

*/		    , CMD_NAME("GET_SYS_CFG") },

*/

*/		    , CMD_NAME("SET_GRANULARITY") },

*/

*/		    , CMD_NAME("SET_TIMER_IRQ") },

*/

up to 10*/     , CMD_NAME("GET_EVENT") },

*/

up to 4*/      , CMD_NAME("GET_PIPES") },

*/

*/		    , CMD_NAME("ALLOCATE_PIPE") },

*/

*/		    , CMD_NAME("RELEASE_PIPE") },

*/

*/

up to 2*/      , CMD_NAME("STOP_PIPE") },

*/

up to 2*/      , CMD_NAME("GET_PIPE_SPL_COUNT") },

up to 5*/

*/		    , CMD_NAME("TOGGLE_PIPE_STATE") },

up to 4*/

*/		    , CMD_NAME("DEF_STREAM") },

*/

*/		    , CMD_NAME("SET_MUTE") },

*/

*/		    , CMD_NAME("GET_STREAM_SPL_COUNT") },

up to 4*/

*/		    , CMD_NAME("UPDATE_BUFFER") },

*/

*/		    , CMD_NAME("GET_BUFFER") },

*/

up to 4*/      , CMD_NAME("CANCEL_BUFFER") },

*/

*/		    , CMD_NAME("GET_PEAK") },

*/

*/		    , CMD_NAME("SET_STREAM_STATE") },

 sleep 500 - 100 = 400 times 100us -> the timeout is >= 40 ms */

 write command */

 MicoBlaze gogogo */

 wait for device to answer */

 read response */

 clear Reg_CSM_MR */

 low-level dsp access */

 unknown */

 todo: endianess handling */

 we don't necessarily need the full length */

 low-level pipe handling */

 finished */

 free */

 need all words here! */

 don't sleep! */

 hi part */

 lo part */

	/* max 2*PCMOnlyGranularity = 2*1024 at 44100 = < 50 ms:

 low-level stream handling */

 16 bit format */

 little endian/intel format */

 hi part */

 lo part */

 low-level buffer handling */

 request interrupt notification */

 todo: pause request, circular buffer */

	chip->rmh.cmd[0] |= MASK_BUFFER_ID; /* ask for the current buffer: the

/* low-level gain/peak handling

 *

 * \todo: can we unmute capture/playback channels independently?

 *

 bit set to 1: channel muted */

 hi part */

 lo part */

 -90.308dB */

 -72.247dB */

 -60.205dB */

 -48.030dB */

 -36.005dB */

 -30.001dB */

 -24.002dB */

 -18.000dB */

 -15.000dB */

 -12.001dB */

 -9.000dB */

 -6.004dB */

 -3.000dB */

 -2.000dB */

 -1.000dB */

 FS */

 interrupt handling */

 Test if PCI Doorbell interrupt is active */

 RAZ interrupt */

	irq_async = irqsrc & MASK_SYS_ASYNC_EVENTS; /* + EtherSound response

 dev_dbg(chip->card->dev, "interrupt: async event pending\n"); */

 answer from CMD_04_GET_EVENT */

	/* We can optimize this to not read dumb events.

	 * Answer words are in the following order:

	 * Stat[0]	general status

	 * Stat[1]	end of buffer OUT pF

	 * Stat[2]	end of buffer OUT pf

	 * Stat[3]	end of buffer IN pF

	 * Stat[4]	end of buffer IN pf

	 * Stat[5]	MSB underrun

	 * Stat[6]	LSB underrun

	 * Stat[7]	MSB overrun

	 * Stat[8]	LSB overrun

 todo: handle xrun notification */

 this device did not cause the interrupt */

		/* backdoor for ethersound commands

		 *

		 * for now, we do not need this

		 *

 handle async events */

	/* enable/disable interrupts

	 *

	 * Set the Doorbell and PCI interrupt enable bits

	 *

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *   ALSA driver for ICEnsemble ICE1712 (Envy24)

 *

 *   Lowlevel functions for Hoontech STDSP24

 *

 *	Copyright (c) 2000 Jaroslav Kysela <perex@perex.cz>

 Hoontech-specific setting */

 select box */

 prepare for write */

 select box */

 let's go - activate only functions in first box */

			    /* ICE1712_STDSP24_MUTE |

			       ICE1712_STDSP24_INSEL |

	/*  These boxconfigs have caused problems in the past.

	 *  The code is not optimal, but should now enable a working config to

	 *  be achieved.

	 *  ** MIDI IN can only be configured on one box **

	 *  ICE1712_STDSP24_BOX_MIDI1 needs to be set for that box.

	 *  Tests on a ADAC2000 box suggest the box config flags do not

	 *  work as would be expected, and the inputs are crossed.

	 *  Setting ICE1712_STDSP24_BOX_MIDI1 and ICE1712_STDSP24_BOX_MIDI2

	 *  on the same box connects MIDI-In to both 401 uarts; both outputs

	 *  are then active on all boxes.

	 *  The default config here sets up everything on the first box.

	 *  Alan Horstmann  5.2.2008

/*

 * AK4524 access

 start callback for STDSP24 with modified hardware */

 Hoontech STDSP24 with modified hardware */

 CIF high */

 set the analog DACs */

 set the analog ADCs */

 analog section */

 ak4524 controls */

 entry point */

 a dummy id */

 a dummy id */

		/* STAudio ADCIII has the same SSID as Hoontech StA DSP24,

		 * thus identified only via the explicit model option

 a dummy id */

 terminator */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *	ALSA driver for ICEnsemble VT1724 (Envy24HT)

 *

 *	Lowlevel functions for Ego Sys Waveterminal 192M

 *

 *		Copyright (c) 2006 Guedez Clement <klem.dev@gmail.com>

 *		Some functions are taken from the Prodigy192 driver

 *		source

 rate change needs atomic mute/unmute of all dacs*/

/*

 *	2*ADC 6*DAC no1 ringbuffer r/w on i2c bus

/*

 *	2*ADC 2*DAC no2 ringbuffer r/w on i2c bus

/*

 *	DAC mute control

stac9460 1*/

stac9460 2*/

/*

 * 	DAC volume attenuation mixer control

 mute */

 0dB */

/*

 * ADC mute control

/*

 *ADC gain mixer control

 0dB */

 22.5dB */

/*

 * MIC / LINE switch fonction

/*

 * Handler for setting correct codec rate - called when rate change is detected

 no hint - S/PDIF input is master, simply return */

 256x, base rate mode */

 256x, mid rate mode */

 128x, high rate mode */

 change detected, setting master clock, muting first */

 due to possible conflicts with mute controls - mutexing */

 we have to remember current mute status for each DAC */

printk(KERN_DEBUG "Rate change: %d, new MC: 0x%02x\n", rate, new);*/

	/* unmuting - only originally unmuted dacs -

Limits value in dB for fader*/

/*

 * Control tabs

INIT*/

WTM 192M*/

init mutex for dac mute conflict*/

initialize codec*/

	[ICE_EEP2_SYSCONF]      = 0x67, /*SYSCONF: clock 192KHz, mpu401,

 ACLINK : I2S */

 I2S: vol; 96k, 24bit, 192k */

SPDIF: out-en, spidf ext out*/

entry point*/

terminator*/

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *   ALSA driver for ICEnsemble VT1724 (Envy24HT)

 *

 *   Lowlevel functions for ONKYO WAVIO SE-90PCI and SE-200PCI

 *

 *	Copyright (c) 2007 Shin-ya Okada  sh_okada(at)d4.dion.ne.jp

 *                                        (at) -> @

***************************************************************************/

  ONKYO WAVIO SE-200PCI                                                   */

***************************************************************************/

/*

 *  system configuration ICE_EEP2_SYSCONF=0x4b

 *    XIN1 49.152MHz

 *    not have UART

 *    one stereo ADC and a S/PDIF receiver connected

 *    four stereo DACs connected

 *

 *  AC-Link configuration ICE_EEP2_ACLINK=0x80

 *    use I2C, not use AC97

 *

 *  I2S converters feature ICE_EEP2_I2S=0x78

 *    I2S codec has no volume/mute control feature

 *    I2S codec supports 96KHz and 192KHz

 *    I2S codec 24bits

 *

 *  S/PDIF configuration ICE_EEP2_SPDIF=0xc3

 *    Enable integrated S/PDIF transmitter

 *    internal S/PDIF out implemented

 *    S/PDIF is stereo

 *    External S/PDIF out implemented

 *

 *

 * ** connected chips **

 *

 *  WM8740

 *      A 2ch-DAC of main outputs.

 *      It setuped as I2S mode by wire, so no way to setup from software.

 *      The sample-rate are automatically changed. 

 *          ML/I2S (28pin) --------+

 *          MC/DM1 (27pin) -- 5V   |

 *          MD/DM0 (26pin) -- GND  |

 *          MUTEB  (25pin) -- NC   |

 *          MODE   (24pin) -- GND  |

 *          CSBIW  (23pin) --------+

 *                                 |

 *          RSTB   (22pin) --R(1K)-+

 *      Probably it reduce the noise from the control line.

 *

 *  WM8766

 *      A 6ch-DAC for surrounds.

 *      It's control wire was connected to GPIOxx (3-wire serial interface)

 *          ML/I2S (11pin) -- GPIO18

 *          MC/IWL (12pin) -- GPIO17

 *          MD/DM  (13pin) -- GPIO16

 *          MUTE   (14pin) -- GPIO01

 *

 *  WM8776

 *     A 2ch-ADC(with 10ch-selector) plus 2ch-DAC.

 *     It's control wire was connected to SDA/SCLK (2-wire serial interface)

 *          MODE (16pin) -- R(1K) -- GND

 *          CE   (17pin) -- R(1K) -- GND  2-wire mode (address=0x34)

 *          DI   (18pin) -- SDA

 *          CL   (19pin) -- SCLK

 *

 *

 * ** output pins and device names **

 *

 *   7.1ch name -- output connector color -- device (-D option)

 *

 *      FRONT 2ch                  -- green  -- plughw:0,0

 *      CENTER(Lch) SUBWOOFER(Rch) -- black  -- plughw:0,2,0

 *      SURROUND 2ch               -- orange -- plughw:0,2,1

 *      SURROUND BACK 2ch          -- white  -- plughw:0,2,2

 *

***************************************************************************/

  WM8740 interface                                                        */

***************************************************************************/

 nothing to do */

 nothing to do */

***************************************************************************/

  WM8766 interface                                                        */

***************************************************************************/

 RESET ALL */

 volume L=0 R=0 */

 volume L=0 R=0 */

 volume L=0 R=0 */

 serial mode I2S-24bits */

 MCLK=256fs */

 MDP=0 */

 MDP=0 */

 demp=off mute=off */

 ch-assign L=L R=R RESET */

 ch-assign L=L R=R */

 MCLK=128fs */

 MCLK=256fs */

***************************************************************************/

  WM8776 interface                                                        */

***************************************************************************/

 LINE, CD, MIC, ALL, GND */

 AFL -- After Fader Listening */

 AGC -- Auto Gain Control of the input */

 Off */

 LimiterMode */

 ALCMode */

 reset all */

 ADC and DAC interface is I2S 24bits mode */

 The sample-rate are automatically changed */

 BUT my board can not do reset all, so I load all by manually. */

 head phone mute and power down */

 nothing to do */

***************************************************************************/

  runtime interface                                                       */

***************************************************************************/

 mute */

 0dB */

***************************************************************************/

  ONKYO WAVIO SE-90PCI                                                    */

***************************************************************************/

/*

 *  system configuration ICE_EEP2_SYSCONF=0x4b

 *  AC-Link configuration ICE_EEP2_ACLINK=0x80

 *  I2S converters feature ICE_EEP2_I2S=0x78

 *  S/PDIF configuration ICE_EEP2_SPDIF=0xc3

 *

 *  ** connected chip **

 *

 *   WM8716

 *      A 2ch-DAC of main outputs.

 *      It setuped as I2S mode by wire, so no way to setup from software.

 *         ML/I2S (28pin) -- +5V

 *         MC/DM1 (27pin) -- GND

 *         MC/DM0 (26pin) -- GND

 *         MUTEB  (25pin) -- open (internal pull-up)

 *         MODE   (24pin) -- GND

 *         CSBIWO (23pin) -- +5V

 *

 Nothing to do for this chip. */

***************************************************************************/

  probe/initialize/setup                                                  */

***************************************************************************/

 nothing to do for VT1724_SUBDEVICE_SE90PCI */

***************************************************************************/

  entry point                                                             */

***************************************************************************/

 49.152Hz, spdif-in/ADC, 4DACs */

 I2S */

 96k-ok, 24bit, 192k-ok */

 out-en, out-int, spdif-in */

 WM8766 mute      1=output */

 not used */

 WM8766 ML/MC/MD  1=output */

 0=writable */

 0=writable */

 0=writable */

 WM8766 mute=0 */

 not used */

 WM8766 ML/MC/MD */

 49.152Hz, spdif-in/ADC, 4DACs */

 I2S */

 96k-ok, 24bit, 192k-ok */

 out-en, out-int, spdif-in */

 ALL GPIO bits are in input mode */

terminator*/

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *   ALSA driver for VT1724 ICEnsemble ICE1724 / VIA VT1724 (Envy24HT)

 *                   VIA VT1720 (Envy24PT)

 *

 *	Copyright (c) 2000 Jaroslav Kysela <perex@perex.cz>

 *                    2002 James Stafford <jstafford@ampltd.com>

 *                    2003 Takashi Iwai <tiwai@suse.de>

 lowlevel routines */

 Index 0-MAX */

 ID for this card */

 Enable this card */

 Both VT1720 and VT1724 have the same PCI IDs */

/*

 *  Basic I/O

/*

 *  default rates, default clock routines

 check whether the clock mode is spdif-in */

/*

 * locking rate makes sense only for internal clock mode

/*

 * ac97 section

/*

 * GPIO operations

 set gpio direction 0 = read, 1 = write */

 dummy read for pci-posting */

 get gpio direction 0 = read, 1 = write */

 set the gpio mask (0 = writable) */

 VT1720 supports only 16 GPIO bits */

 dummy read for pci-posting */

 dummy read for pci-posting */

/*

 * MIDI

	/* mask irq when all bytes have been transmitted.

	 * enabled again in output_trigger when the new data comes in.

 call with ice->reg_lock */

 32 bytes should be transmitted in less than about 12 ms */

/*

 *  Interrupt handler

			/* Due to mysterical reasons, MPU_TX is always

			 * generated (and can't be cleared) when a PCM

			 * playback is going.  So let's ignore at the

			 * next loop.

 ack MPU irq */

			/*

			 * Multi-track PCM

			 * PCM assignment are:

			 * Playback DMA0 (M/C) = playback_pro_substream

			 * Playback DMA1 = playback_con_substream_ds[0]

			 * Playback DMA2 = playback_con_substream_ds[1]

			 * Playback DMA3 = playback_con_substream_ds[2]

			 * Playback DMA4 (SPDIF) = playback_con_substream

			 * Record DMA0 = capture_pro_substream

			 * Record DMA1 = capture_con_substream

 ack anyway to avoid freeze */

 ought to really handle this properly */

 If I don't do this, I get machine lockup due to continual interrupts */

/*

 *  PCM code - professional part (multitrack)

 up to 96000 */

 up to 48000 */

 ADDR register offset */

 SIZE register offset */

 COUNT register offset */

 start & pause bit */

 apps will have to restart stream */

/*

 check MT02 */

 128x MCLK */

 256x MCLK */

 master clock changed */

 no change in master clock */

 running? we cannot change the rate now... */

		/* comparing required and current rate - makes sense for

		/* force means the rate was switched by ucontrol, otherwise

 setting master clock */

 set up codecs */

 mark surround channels */

 PDMA0 can be multi-channel up to 8 */

 check individual playback stream */

 unmark surround channels */

 outl(size, ICEMT1724(ice, PLAYBACK_SIZE)); */

 outl(size, ICEMT1724(ice, PLAYBACK_COUNT)); */

	/*

	dev_dbg(ice->card->dev, "pro prepare: ch = %d, addr = 0x%x, "

	       "buffer = 0x%x, period = 0x%x\n",

	       substream->runtime->channels,

	       (unsigned int)substream->runtime->dma_addr,

	       snd_pcm_lib_buffer_bytes(substream),

	       snd_pcm_lib_period_bytes(substream));

 read PLAYBACK_ADDR */

 read PLAYBACK_SIZE */

 use ADDR register */

 use SIZE register */

 19bits dword */

 FIXME: constraints needed */

 16bits dword */

 16bits dword */

/*

 * set rate constraints

 I2S */

 VT1720 doesn't support more than 96kHz */

 ACLINK */

/* if the card has the internal rate locked (is_pro_locked), limit runtime

   hw rates to the current internal rate only.

/* multi-channel playback needs alignment 8x32bit regardless of the channels

 * actually used

 calculate the currently available channels */

 channels must be even */

/*

 * SPDIF PCM

 update spdif control bits; call with reg_lock */

 update SPDIF control bits according to the given rate */

 no spdif device */

/*

 * independent surround PCMs

 already used by PDMA0? */

 FIXME: should handle blocking mode properly */

/*

 *  Mixer section

 cold reset */

 FIXME */

 I2S mixer only */

/*

 *

/*

 *

/*

 professional, non-audio */

 professional */

 96k */

 192k */

 88.2k */

 176.4k */

 consumer */

 copyright */

 category */

 fs */

 professional, non-audio */

 professional */

 consumer */

 copyright */

 category */

 fs */

 FIXME: the following conflict with IEC958 Playback Route */

 .name =         SNDRV_CTL_NAME_IEC958("", PLAYBACK, SWITCH), */

 NOT USED YET */

/*

 * GPIO access from extern

 NOT USED YET */

/*

 *  rate

 internal clocks */

 external clocks */

 upper limit - keep at top */

 ext_clock items */

 int clock items */

 standard external clock - only single type - SPDIF IN */

 setting clock to external - SPDIF */

 setting 256fs */

 if rate = 0 => external clock */

 switching to external clock */

 internal on-card clock */

 the first switch to the ext. clock mode? */

 notify akm chips as well */

/*

 * routing

 0 */

 1-2 */

 3-4 */

 we now have 3 bits per output */

 PCM */

 PSDIN0 Left */

 PSDIN0 Right */

 SPDIN Left */

 SPDIN Right */

 FIXME: for compatibility with ice1712... */

/*

  ooAoo cards with no controls

	[ICE_EEP2_SYSCONF]     = 0x4c,	/* 49MHz crystal, no mpu401, no ADC,

 I2S */

 no volume, 96k, 24bit, 192k */

 out-en, out-int, out-ext */

 no GPIOs are used */

 inputs */

	[ICE_EEP2_GPIO_STATE1] = 0x00, /* all 1, but GPIO_CPLD_RW

 inputs */

 terminator */

/*

	/*

	dev_dbg(ice->card->dev, "i2c_read: [0x%x,0x%x] = 0x%x\n", dev, addr, val);

	/*

	dev_dbg(ice->card->dev, "i2c_write: [0x%x,0x%x] = 0x%x\n", dev, addr, data);

 EEPROM device address */

			/* invalid subvendor from EEPROM, try the PCI

			 * subststem ID instead

 if the EEPROM is given by the driver, use it */

 assume AC97-only card which can suspend without additional code */

 pci posting flush */

 pci posting flush */

 MPU_RX and TX irq masks are cleared later dynamically */

	/* don't handle FIFO overrun/underruns (just yet),

	 * since they cause machine lockups

 use default only */

 mask all interrupts */

 enable PCI device */

/*

 *

 * Registration

 *

 field init before calling chip_init */

 specific driver? */

	/*

	* VT1724 has separate DMAs for the analog and the SPDIF streams while

	* ICE1712 has only one for both (mixed up).

	*

	* Confusingly the analog PCM is named "professional" here because it

	* was called so in ice1712 driver, and vt1724 driver is derived from

	* ice1712 driver.

 has SPDIF I/O */

 set watermarks */

 set UART mode */

 switching to external clock via SPDIF */

 internal on-card clock */

 CONFIG_PM_SLEEP */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *   ALSA driver for ICEnsemble VT1724 (Envy24HT)

 *

 *   Lowlevel functions for AudioTrak Prodigy 192 cards

 *   Supported IEC958 input from optional MI/ODI/O add-on card.

 *

 *   Specifics (SW, HW):

 *   -------------------

 *   	* 49.5MHz crystal

 *   	* SPDIF-OUT on the card:

 *  	  - coax (through isolation transformer)/toslink supplied by

 *          74HC04 gates - 3 in parallel

 *   	  - output switched between on-board CD drive dig-out connector

 *          and ice1724 SPDTX pin, using 74HC02 NOR gates, controlled

 *          by GPIO20 (0 = CD dig-out, 1 = SPDTX)

 *   	* SPDTX goes straight to MI/ODI/O card's SPDIF-OUT coax

 *

 *   	* MI/ODI/O card: AK4114 based, used for iec958 input only

 *   		- toslink input -> RX0

 *   		- coax input -> RX1

 *   		- 4wire protocol:

 *   			AK4114		ICE1724

 *   			------------------------------

 * 			CDTO (pin 32) -- GPIO11 pin 86

 * 			CDTI (pin 33) -- GPIO10 pin 77

 * 			CCLK (pin 34) -- GPIO9 pin 76

 * 			CSN  (pin 35) -- GPIO8 pin 75

 *   		- output data Mode 7 (24bit, I2S, slave)

 *		- both MCKO1 and MCKO2 of ak4114 are fed to FPGA, which

 *		  outputs master clock to SPMCLKIN of ice1724.

 *		  Experimentally I found out that only a combination of

 *		  OCKS0=1, OCKS1=1 (128fs, 64fs output) and ice1724 -

 *		  VT1724_MT_I2S_MCLK_128X=0 (256fs input) yields correct

 *		  sampling rate. That means that the FPGA doubles the

 *		  MCK01 rate.

 *

 *	Copyright (c) 2003 Takashi Iwai <tiwai@suse.de>

 *      Copyright (c) 2003 Dimitromanolakis Apostolos <apostol@cs.utoronto.ca>

 *      Copyright (c) 2004 Kouichi ONO <co2b@ceres.dti.ne.jp>

 rate change needs atomic mute/unmute of all dacs*/

/*

 * DAC mute control

/*

 * idx = STAC9460 volume register number, mute: 0 = mute, 1 = unmute

 dev_dbg(ice->card->dev, "Volume register 0x%02x: 0x%02x\n", idx, new);*/

 due to possible conflicts with stac9460_set_rate_val, mutexing */

	/*

	dev_dbg(ice->card->dev, "Mute put: reg 0x%02x, ctrl value: 0x%02x\n", idx,

	       ucontrol->value.integer.value[0]);

/*

 * DAC volume attenuation mixer control

 mute */

 0dB */

		/*

		dev_dbg(ice->card->dev, "DAC Volume: reg 0x%02x: 0x%02x\n",

		       idx, ovol);

/*

 * ADC mute control

/*

 * ADC gain mixer control

 0dB */

 22.5dB */

/*

 * Handler for setting correct codec rate - called when rate change is detected

 no hint - S/PDIF input is master, simply return */

 256x, base rate mode */

 256x, mid rate mode */

 128x, high rate mode */

 change detected, setting master clock, muting first */

 due to possible conflicts with mute controls - mutexing */

 we have to remember current mute status for each DAC */

dev_dbg(ice->card->dev, "Rate change: %d, new MC: 0x%02x\n", rate, new);*/

	/* unmuting - only originally unmuted dacs -

/*

 * mixers

 AK4114 - ICE1724 connections on Prodigy192 + MI/ODI/O */

/* CDTO (pin 32) -- GPIO11 pin 86

 * CDTI (pin 33) -- GPIO10 pin 77

 * CCLK (pin 34) -- GPIO9 pin 76

 * CSN  (pin 35) -- GPIO8 pin 75

#define AK4114_ADDR	0x00 /* C1-C0: Chip Address

			      * (According to datasheet fixed to 00)

/*

 * 4wire ak4114 protocol - writing data

 drop clock */

 set data */

 raise clock */

/*

 * 4wire ak4114 protocol - reading data

 drop clock */

 read data */

 raise clock */

/*

 * 4wire ak4114 protocol - starting sequence

 high at init */

 drop chip select */

/*

 * 4wire ak4114 protocol - final sequence

 raise chip select */

/*

 * Write data to addr register of ak4114

/*

 * Read data from addr register of ak4114

	/* AK4114_IPS0 bit = 0 -> RX0 = Toslink

	 * AK4114_IPS0 bit = 1 -> RX1 = Coax

 AK4114_IPS0 could be any bit */

		/* ice1724 expects I2S and provides clock,

		 * DEM0 disables the deemphasis filter

 default input RX0 */

	/* AK4114 in Prodigy192 cannot detect external rate correctly.

 registers 0x0 - 0x14 */

 ak4114 is connected */

 ak4114 in MIO/DI/O handles no IEC958 output */

/*

 * check for presence of MI/ODI/O add-on card with digital inputs

 random value */

 random SAFE address */

 ak4114 seems to communicate, apparently exists */

 writing back original value */

/*

 * initialize the chip

/*		STAC946X_MASTER_VOLUME, 0,

		STAC946X_LF_VOLUME, 0,

		STAC946X_RF_VOLUME, 0,

		STAC946X_LR_VOLUME, 0,

		STAC946X_RR_VOLUME, 0,

		STAC946X_CENTER_VOLUME, 0,

 prodigy 192 */

 ice1724, e.g. 23 GPIOs */

 initialize codec */

 MI/ODI/O add on card with AK4114 */

		/* from this moment if err = 0 then

		 * spec->ak4114 should not be null

/*

 * Aureon boards don't provide the EEPROM data except for the vendor IDs.

 * hence the driver needs to sets up it properly.

	[ICE_EEP2_SYSCONF]     = 0x6a,	/* 49MHz crystal, mpu401,

					 * spdif-in+ 1 stereo ADC,

					 * 3 stereo DACs

 I2S */

 vol, 96k, 24bit, 192k */

 out-en, out-int, spdif-in */

	[ICE_EEP2_GPIO_STATE2] = 0x10,  /* GPIO20: 0 = CD drive dig. input

					 * passthrough,

					 * 1 = SPDIF-OUT from ice1724

 entry point */

 terminator */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *   ALSA driver for ICEnsemble VT17xx

 *

 *   Lowlevel functions for WM8766 codec

 *

 *	Copyright (c) 2012 Ondrej Zary <linux@rainbow-software.org>

 low-level access */

 mixer controls */

 exported functions */

 reset */

 load defaults */

 restore volume after MCLK stopped */

 mixer callbacks */

 this also works for enum because value is a union */

 both stereo controls in one register */

 stereo controls in different registers */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *   ALSA driver for ICEnsemble VT17xx

 *

 *   Lowlevel functions for WM8776 codec

 *

 *	Copyright (c) 2012 Ondrej Zary <linux@rainbow-software.org>

 low-level access */

 addr + 9th data bit */

 remaining 8 data bits */

 register-level functions */

 Off */

 Limiter */

 ALC Right */

 ALC Left */

 ALC Stereo */

 mixer controls */

 .enum_names item count */

 .enum_names item count */

 .enum_names item count */

 .enum_names item count */

 .enum_names item count */

 .enum_names item count */

 .enum_names item count */

 exported functions */

 reset */

 load defaults */

 restore volume after MCLK stopped */

 mixer callbacks */

 this also works for enum because value is a union */

 both stereo controls in one register */

 stereo controls in different registers */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *   ALSA driver for ICEnsemble VT1724 (Envy24HT)

 *

 *   Lowlevel functions for ESI Maya44 cards

 *

 *	Copyright (c) 2009 Takashi Iwai <tiwai@suse.de>

 *	Based on the patches by Rainer Zimmermann <mail@lightshed.de>

 WM8776 register indexes */

 clock ratio identifiers for snd_wm8776_set_rate() */

 write the given register and save the data to the cache */

	/*

	 * WM8776 registers are up to 9 bits wide, bit 8 is placed in the LSB

	 * of the address field

/*

 * update the given register with and/or mask and save the data to the cache

/*

 * WM8776 volume controls

 volume range: 0..maxval */

 left and right registers */

 value mask */

 zero-value offset */

 mute bit */

 update bits */

 extra bits for ADC mute */

 update and zero-cross enable */

 zero-cross enable */

 update */

 ADCMUX bits */

/*

 * dB tables

 headphone output: mute, -73..+6db (1db step) */

 DAC output: mute, -127..0db (0.5db step) */

 ADC gain: mute, -21..+24db (0.5db step) */

/*

 * WM8776 switch controls

/*

 * GPIO pins (known ones for maya44)

/*

 * GPIO switch controls

/*

 * capture source selection

 known working input slots (0-4) */

 in-2 */

 in-4 */

/*

 * Maya44 routing switch settings have different meanings than the standard

 * ice1724 switches as defined in snd_vt1724_pro_route_info (ice1724.c).

 0 */

/*

 * controls to be added

 FIXME: do controls 5-9 have any meaning? */

/*

 * initialize a wm8776 chip

 R2: headphone L+R muted + update */

 R5: DAC output L+R muted + update */

 R6: DAC output phase normal */

		0x07, 0x091, /* R7: DAC enable zero cross detection,

 R8: DAC soft mute off */

 R9: no deemph, DAC zero detect disabled */

 R10: DAC I2C mode, std polarities, 24bit */

		0x0b, 0x022, /* R11: ADC I2C mode, std polarities, 24bit,

 R12: ADC+DAC slave, ADC+DAC 44,1kHz */

 R13: all power up */

		0x0e, 0x100, /* R14: ADC left muted,

		0x0f, 0x100, /* R15: ADC right muted,

 R16: ALC...*/

 R17: disable ALC */

 R18: ALC...*/

 R19: noise gate...*/

 R21: ADC input mux init, mute all inputs */

 R22: output mux, select DAC */

 enable DAC output; mute bypass, aux & all inputs */

/*

 * change the rate on the WM8776 codecs.

 * this assumes that the VT17xx's rate is changed by the calling function.

 * NOTE: even though the WM8776's are running in slave mode and rate

 * selection is automatic, we need to call snd_wm8776_set_rate() here

 * to make sure some flags are set correctly.

 no hint - S/PDIF input is master, simply return */

	/*

	 * this currently sets the same rate for ADC and DAC, but limits

	 * ADC rate to 256X (96kHz). For 256X mode (96kHz), this sets ADC

	 * oversampling to 64x, as recommended by WM8776 datasheet.

	 * Setting the rate is not really necessary in slave mode.

/*

 * supported sample rates (to override the default one)

 playback rates: 32..192 kHz */

/*

 * chip addresses on I2C bus

 codec 0 & 1 */

/*

 * initialize the chip

 initialise codecs */

 set card specific rates */

 register change rate notifier */

 RDMA1 (2nd input channel) is used for ADC by default */

 have an own routing control */

/*

 * Maya44 boards don't provide the EEPROM data except for the vendor IDs.

 * hence the driver needs to sets up it properly.

 clock xin1=49.152MHz, mpu401, 2 stereo ADCs+DACs */

 I2S */

 vol, 96k, 24bit, 192k */

 enable spdif out, spdif out supp, spdif-in, ext spdif out */

0x9f*/,

0xff*/,

0x7f*/,

 entry point */

 terminator */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *   ALSA driver for ICEnsemble VT1724 (Envy24HT)

 *

 *   Lowlevel functions for Infrasonic Quartet

 *

 *	Copyright (c) 2009 Pavel Hofman <pavel.hofman@ivitera.com>

 system control register */

 monitoring control register */

 cpld register */

 chip address on I2C bus */

 S/PDIF receiver */

 chip address on SPI bus */

 ADC/DAC */

/*

 * GPIO pins

 GPIO0 - O - DATA0, def. 0 */

 GPIO1 - I/O - DATA1, Jack Detect Input0 (0:present, 1:missing), def. 1 */

 GPIO2 - I/O - DATA2, Jack Detect Input1 (0:present, 1:missing), def. 1 */

 GPIO3 - I/O - DATA3, def. 1 */

 GPIO4 - I/O - DATA4, SPI CDTO, def. 1 */

 GPIO5 - I/O - DATA5, SPI CCLK, def. 1 */

 GPIO6 - I/O - DATA6, Cable Detect Input (0:detected, 1:not detected */

 GPIO7 - I/O - DATA7, Device Detect Input (0:detected, 1:not detected */

 GPIO8 - O - CPLD Chip Select, def. 1 */

 GPIO9 - O - CPLD register read/write (0:write, 1:read), def. 0 */

 GPIO10 - O - SPI Chip Select for CODEC#0, def. 1 */

 GPIO11 - O - SPI Chip Select for CODEC#1, def. 1 */

/* GPIO12 - O - Ex. Register Output Enable (0:enable, 1:disable), def. 1,

/* GPIO13 - O - Ex. Register0 Chip Select for System Control Register,

/* GPIO14 - O - Ex. Register1 Chip Select for Monitor Control Register,

 System Control Register GPIO_SCR data bits */

 Mic/Line select relay (0:line, 1:mic) */

 Phantom power drive control (0:5V, 1:48V) */

 H/W mute control (0:Normal, 1:Mute) */

 Phantom power control (0:Phantom on, 1:off) */

 Analog input 1/2 Source Select */

 Analog input 3/4 Source Select (0:line, 1:hi-z) */

 Codec Power Down (0:power down, 1:normal) */

 Monitor Control Register GPIO_MCR data bits */

 Input 1/2 to Monitor 1/2 (0:off, 1:on) */

 Input 1/2 to Monitor 3/4 (0:off, 1:on) */

 Input 3/4 to Monitor 1/2 (0:off, 1:on) */

 Input 3/4 to Monitor 3/4 (0:off, 1:on) */

 Output to Monitor 1/2 (0:off, 1:on) */

 Output to Monitor 3/4 (0:off, 1:on) */

 CPLD Register DATA bits */

 Clock Rate Select */

 Sync Source Select (0:Internal, 1:External) */

 Word Clock FS Select (0:FS, 1:256FS) */

 Coaxial Output Source (IS-Link) (0:SPDIF, 1:I2S) */

 Input 1/2 Source Select (0:Analog12, 1:An34) */

 Input 3/4 Source Select (0:Analog34, 1:Digital In) */

 internal clock (CPLD_SYNC_SEL = 0) options */

 external clock (CPLD_SYNC_SEL = 1) options */

 external clock - SPDIF */

 external clock - WordClock 1xfs */

 external clock - WordClock 256xfs */

 Clock and Format Control register */

 Deem and Volume Control register */

/*

 * Conversion from int value to its binary form. Used for debugging.

 * The output buffer must be allocated prior to calling the function.

/*

 * Initial setup of the conversion array GPIO <-> rate

/*

 * AK4620 section

/*

 * Write data to addr register of ak4620

	/*dev_dbg(ice->card->dev, "Writing to AK4620: chip=%d, addr=0x%x,

 set mask - only SPI bits */

 high all */

 drop chip select */

 CODEC 1 */

 build I2C address + data byte */

 drop clock */

 set data */

 raise clock */

 all back to 1 */

 return all gpios to non-writable */

 restore GPIOs direction */

 clear the bits */

 set the new bits */

/*

 * change the rate of AK4620

	if (rate == 0)  /* no hint - S/PDIF input is master or the new spdif

 adjust DFS on codecs - see datasheet */

 set new value */

	.num_dacs = 4,	/* DAC1 - Output 12

	.num_adcs = 4,	/* ADC1 - Input 12

 Communication routines with the CPLD */

/* Writes data to external register reg, both reg and data are

 set direction of used GPIOs*/

 all outputs */

 mask - writable bits */

 write the data */

 drop output enable */

 drop the register gpio */

 raise the register GPIO */

 raise all data gpios */

 mask - immutable bits */

 outputs only 8-15 */

 unmute */

 un-smuting DAC */

 mute */

 smuting DAC */

 set smute */

 no change */

 BUG - no other combinations allowed */

 binary 10 is not supported */

 shifting to SCR_AIN12_SEL0 */

 change requested */

 turn off relay */

 turn on relay */

 turn on relay */

 no change */

 if phantom voltage =48V, phantom on */

 phantom on requested */

 0 = voltage 5V */ {

 is off, turn on */

 turn voltage on first, = 1 */

 turn phantom on, = 0 */

 phantom off requested and 1 = voltage 48V */

 is on, turn off */

 turn voltage off first, = 0 */

 turn phantom off, = 1 */

 no change */

 no change */

 Create virtual master control */

 only capture SPDIF over AK4113 */

 CPLD_SYNC_SEL: 0 = internal, 1 = external (i.e. spdif master) */

 setting new rate */

 switching ice1724 to external clock - supplied by ext. circuits */

 switch to internal clock, drop CPLD_SYNC_SEL */

	/* dev_dbg(ice->card->dev, "QT - set_rate: old %x, new %x\n",

 no change in master clock */

 setting clock to external - SPDIF */

 changed */

 checking only rate/clock-related bits */

 switched to internal clock, is not any external type */

 undefined combination of external clock setup */

 Called when ak4113 detects change in the input SPDIF stream */

 only for SPDIF master mode, rate was changed */

		/* dev_dbg(ice->card->dev, "ak4113 - input rate changed to %d\n",

/*

 * If clock slaved to SPDIF-IN, setting runtime rate

 * to the detected external rate

 not external SPDIF, no rate limitation */

 only external SPDIF can detect incoming sample rate */

/*

 * initialize the chip

 AK4113_REG_PWRDN */	AK4113_RST | AK4113_PWN |

 AK4113_REQ_FORMAT */	AK4113_DIF_I24I2S | AK4113_VTX |

 AK4113_REG_IO0 */	AK4113_OPS2 | AK4113_TXE |

 AK4113_REG_IO1 */	AK4113_EFH_1024LRCLK | AK4113_IPS(0),

 AK4113_REG_INT0_MASK */	0,

 AK4113_REG_INT1_MASK */	0,

 AK4113_REG_DATDTS */		0,

 switching ice1724 to external clock - supplied by ext. circuits */

 qtet is clocked by Xilinx array */

	/* since Qtet can detect correct SPDIF-in rate, all streams can be

 Mute Off */

 SCR Initialize*/

 keep codec power down first */

 codec power up */

 MCR Initialize */

 CPLD Initialize */

 only one codec with two chips */

 callback for codecs rate setting */

	/* AK41143 in Quartet can detect external rate correctly

	[ICE_EEP2_SYSCONF]     = 0x28,	/* clock 256(24MHz), mpu401, 1xADC,

 I2S */

 96k, 24bit, 192k */

 out-en, out-int, in, out-ext */

	[ICE_EEP2_GPIO_DIR]    = 0x00,	/* 0-7 inputs, switched to output

 8-15 outputs */

 changed only for OUT operations */

 inputs */

	[ICE_EEP2_GPIO_STATE1] = 0x7d, /* all 1, but GPIO_CPLD_RW

 inputs */

 entry point */

 terminator */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *   ALSA driver for ICEnsemble ICE1712 (Envy24)

 *

 *   Lowlevel functions for M-Audio Audiophile 192, Revolution 7.1 and 5.1

 *

 *	Copyright (c) 2003 Takashi Iwai <tiwai@suse.de>

 a non-standard I2C device for revo51 */

 assert PRST# to converters; MT05 bit 7 */

 deassert PRST# */

/*

 * change the rate of Envy24HT, AK4355 and AK4381

 no hint - S/PDIF input is master, simply return */

 adjust DFS on codecs */

 reset DFS */

 snd_akm4xxx_write(ak, 0, reg, tmp); */

 value is written in reset(0) */

/*

 * I2C access to the PT2258 volume controller on GPIO 6/7 (Revolution 5.1)

 write SCL */

 write SDA */

 create the I2C bus */

 create the I2C device */

/*

 * initialize the chips on M-Audio Revolution cards

 front channels DAC supports muting */

 high at init */

 high at init */

 high at init */

 high at init */

 AK4358 for AP192 DAC, AK5385A for ADC */

 reset CKS */

 reset DFS pins of AK5385A for ADC, too */

 reset ADC */

 high at init */

 AK4114 support on Audiophile 192 */

/* CDTO (pin 32) -- GPIO2 pin 52

 * CDTI (pin 33) -- GPIO3 pin 53 (shared with AK4358)

 * CCLK (pin 34) -- GPIO1 pin 51 (shared with AK4358)

 * CSN  (pin 35) -- GPIO7 pin 59

 drop clock */

 set data */

 raise clock */

 drop clock */

 read data */

 raise clock */

 high at init */

	/* AK4114 in Revo cannot detect external rate correctly.

 determine I2C, DACs and ADCs */

 second stage of initialization, analog parts and others */

 unmute all codecs */

 unmute all codecs */

 unmute all codecs */

 only capture SPDIF over AK4114 */

 entry point */

 terminator */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *   ALSA driver for ICEnsemble VT1724 (Envy24HT)

 *

 *   Lowlevel functions for Advanced Micro Peripherals Ltd AUDIO2000

 *

 *	Copyright (c) 2000 Jaroslav Kysela <perex@perex.cz>

 0 db */

 0 db */

 24bit I2S */

 24bit I2S */	

 only use basic functionality for now */

 VT1616 6ch codec connected to PSDOUT0 using packed mode */

	/* Chaintech AV-710 has another WM8728 codec connected to PSDOUT4

	   (shared with the SPDIF output). Mixer control for this codec

		/* we use pins 39 and 41 of the VT1616 for left and right

 entry point */

 terminator */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *   ALSA driver for ICEnsemble ICE1712 (Envy24)

 *

 *   Lowlevel functions for M-Audio Delta 1010, 1010E, 44, 66, 66E, Dio2496,

 *			    Audiophile, Digigram VX442

 *

 *	Copyright (c) 2000 Jaroslav Kysela <perex@perex.cz>

/*

 * CS8427 via SPI mode (for Audiophile), emulated I2C

 send 8 bits */

 read 8 bits */

 assert chip select */

 deassert chip select */

 sequential write */

 address + write mode */

 sequential read */

 address + read mode */

/*

 send byte to transmitter */

/*

 * AK4524 on Delta 44 and 66 to choose the chip mask

/*

 * AK4524 on Delta1010LT to choose the chip address

/*

 * AK4524 on Delta66 rev E to choose the chip address

/*

 * AK4528 on VX442 to choose the chip mask

/*

 * change the DFS bit according rate for Delta1010

 no hint - S/PDIF input is master, simply return */

/*

 * change the rate of AK4524 on Delta 44/66, AP, 1010LT

 no hint - S/PDIF input is master, simply return */

 check before reset ak4524 to avoid unnecessary clicks */

 do it again */

/*

 * change the rate of AK4524 on VX442

/*

 * SPDIF ops for Delta 1010, Dio, 66

 open callback */

 set up */

 consumer */

 CS8427 receiver error register */

/*

 * initialize the chips on M-Audio cards

 the default level of the CIF pin from AK4524 */

 set later */

 the default level of the CIF pin from AK4524 */

 set later */

 the default level of the CIF pin from AK4524 */

 set later */

 set later */

 init spdif */

 nothing */

 Set spdif defaults */

 init codec and restore registers */

 reset & mute codec */

 determine I2C, DACs and ADCs */

 two AK4324 codecs */

 omni not supported yet */

 initialize the SPI clock to high */

 initialize spdif */

 Set spdif defaults */

 no analog? */

 second stage of initialization, analog parts and others */

/*

 * additional controls for M-Audio cards

 1010 and dio specific controls */

 normal spdif controls */

 spdif status in */

 ak4524 controls */

 entry point */

 terminator */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *   ALSA driver for ICEnsemble ICE1712 (Envy24)

 *

 *   AK4524 / AK4528 / AK4529 / AK4355 / AK4381 interface

 *

 *	Copyright (c) 2000 Jaroslav Kysela <perex@perex.cz>

/*

 * write AK4xxx register

 start without chip select */

 chip select low */

 doesn't handle cf=1 yet */

 build I2C address + data byte */

 drop clock */

 set data */

 raise clock */

 assert a cs pulse to trigger */

 chip select high to trigger */

 deselect address */

/*

 * initialize the struct snd_akm4xxx record with the template

/*

 * build AK4xxx controls

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *   ALSA driver for ICEnsemble VT1724 (Envy24HT)

 *

 *   Lowlevel functions for Pontis MS300

 *

 *	Copyright (c) 2004 Takashi Iwai <tiwai@suse.de>

 I2C addresses */

 WM8776 registers */

 headphone left attenuation */

 headphone left attenuation */

 headphone master (both channels) */

 override LLR */

 digital left attenuation */

 DAC phase swap */

/*

 * GPIO

 CS */

 CLK */

 CS8416 -> VT1720 */

 VT1720 -> CS8416 */

/*

 * get the current register value of WM codec

/*

 * set the register value of WM codec and remember it

/*

 * DAC volume attenuation mixer control (-64dB to 0dB)

 mute */

 0dB, 0.5dB step */

/*

 * ADC gain mixer control (-64dB to 0dB)

 mute (-64dB) */

 0dB, 0.5dB step */

/*

 * ADC input mux mixer control

/*

 * Analog bypass (In -> Out)

/*

 * Left/Right swap

/*

 * write data in the SPI mode

 WRITE */

 MAP */

 DATA */

 trigger */

 restore */

 WRITE */

 MAP */

 trigger */

 READ */

 trigger */

 restore */

/*

 * SPDIF input source

 RXP0 */

 RXP1 */

 RXP2 */

/*

 * GPIO controls

 16bit */

 4-7 reserved */

 4-7 reserved */

 4-7 reserved */

 4-7 reserved */

/*

 * mixers

 FIXME: which interface? */

/*

 * WM codec registers

/*

 * initialize the chip

 These come first to reduce init pop noise */

 ADC mute */

 DAC softmute */

 DAC mute */

 All power-up except HP */

 reset */

 256fs, slave mode */

 I2S, normal polarity, 24bit */

 I2S, normal polarity, 24bit */

 DAC L/R */

 OUT DAC */

 HP 0dB */

 HP 0dB */

 DAC 0dB */

 DAC 0dB */

 DAC 0dB */

 DAC 0dB */

 WM_DAC_MASTER,	0x0100, */	
 phase normal */

 no deemphasis, no ZFLG */

 ADC muted */

 ADC muted */

 */

 */

 */

 */

 DAC unmute */

 ADC unmute, both CD/Line On */

 RUN, RXP0 */

 slave, 24bit */

 to remember the register values */

	/* HACK - use this as the SPDIF source.

	 * don't call snd_ice1712_gpio_get/put(), otherwise it's overwritten

 initialize WM8776 codec */

 initialize CS8416 codec */

 assert PRST#; MT05 bit 7 */

 deassert PRST# */

/*

 * Pontis boards don't provide the EEPROM data at all.

 * hence the driver needs to sets up it properly.

 clock 256, mpu401, spdif-in/ADC, 1DAC */

 I2S */

 vol, 96k, 24bit, 192k */

 out-en, out-int, spdif-in */

 ignored */

 4-7 reserved for CS8416 */

 ignored */

 0-low, 1-high, 2-high */

 ignored */

 entry point */

 terminator */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *   ALSA driver for ICEnsemble VT1724 (Envy24HT)

 *

 *   Lowlevel functions for Philips PSC724 Ultimate Edge

 *

 *	Copyright (c) 2012 Ondrej Zary <linux@rainbow-software.org>

***************************************************************************/

  PHILIPS PSC724 ULTIMATE EDGE                                            */

***************************************************************************/

/*

 *  VT1722 (Envy24GT) - 6 outputs, 4 inputs (only 2 used), 24-bit/96kHz

 *

 *  system configuration ICE_EEP2_SYSCONF=0x42

 *    XIN1 49.152MHz

 *    no MPU401

 *    one stereo ADC, no S/PDIF receiver

 *    three stereo DACs (FRONT, REAR, CENTER+LFE)

 *

 *  AC-Link configuration ICE_EEP2_ACLINK=0x80

 *    use I2S, not AC97

 *

 *  I2S converters feature ICE_EEP2_I2S=0x30

 *    I2S codec has no volume/mute control feature (bug!)

 *    I2S codec does not support 96KHz or 192KHz (bug!)

 *    I2S codec 24bits

 *

 *  S/PDIF configuration ICE_EEP2_SPDIF=0xc1

 *    Enable integrated S/PDIF transmitter

 *    internal S/PDIF out implemented

 *    No S/PDIF input

 *    External S/PDIF out implemented

 *

 *

 * ** connected chips **

 *

 *  WM8776

 *     2-channel DAC used for main output and stereo ADC (with 10-channel MUX)

 *     AIN1: LINE IN, AIN2: CD/VIDEO, AIN3: AUX, AIN4: Front MIC, AIN5: Rear MIC

 *     Controlled by I2C using VT1722 I2C interface:

 *          MODE (pin16) -- GND

 *          CE   (pin17) -- GND  I2C mode (address=0x34)

 *          DI   (pin18) -- SDA  (VT1722 pin70)

 *          CL   (pin19) -- SCLK (VT1722 pin71)

 *

 *  WM8766

 *      6-channel DAC used for rear & center/LFE outputs (only 4 channels used)

 *      Controlled by SPI using VT1722 GPIO pins:

 *          MODE   (pin 1) -- GPIO19 (VT1722 pin99)

 *          ML/I2S (pin11) -- GPIO18 (VT1722 pin98)

 *          MC/IWL (pin12) -- GPIO17 (VT1722 pin97)

 *          MD/DM  (pin13) -- GPIO16 (VT1722 pin96)

 *          MUTE   (pin14) -- GPIO20 (VT1722 pin101)

 *

 *  GPIO14 is used as input for headphone jack detection (1 = connected)

 *  GPIO22 is used as MUTE ALL output, grounding all 6 channels

 *

 * ** output pins and device names **

 *

 *   5.1ch name -- output connector color -- device (-D option)

 *

 *      FRONT 2ch                  -- green  -- plughw:0,0

 *      CENTER(Lch) SUBWOOFER(Rch) -- orange -- plughw:0,2,0

 *      REAR 2ch                   -- black  -- plughw:0,2,1

 codec access low-level functions */

 MSB first */

 CLOCK high */

 LOAD high */

 LOAD low, DATA and CLOCK high */

 mute all */

 jack detection */

 notify about master speaker mute change */

 and headphone mute change */

 mixer controls */

 restore codec volume settings after rate change (PMCLK stop) */

 power management */

 init */

 PSC724 has buggy EEPROM (no 96&192kHz, all FFh GPIOs), so override it here */

 49.152MHz, 1 ADC, 3 DACs */

 I2S */

 I2S volume, 96kHz, 24bit */

 spdif out-en, out-int, no input */

 GPIO outputs */

 MUTE_ALL,WM8766 MUTE/MODE/ML/MC/MD */

 GPIO write enable */

 read-only */

 read-only */

 MUTE_ALL,WM8766 MUTE/MODE/ML/MC/MD */

 GPIO initial state */

 unmuted, all WM8766 pins low */

terminator*/

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *   ALSA driver for ICEnsemble VT1724 (Envy24HT)

 *

 *   Lowlevel functions for ESI Juli@ cards

 *

 *	Copyright (c) 2004 Jaroslav Kysela <perex@perex.cz>

 *	              2008 Pavel Hofman <dustin@seznam.cz>

/*

 * chip addresses on I2C bus

 S/PDIF receiver */

 DAC */

/*

 * Juli does not use the standard ICE1724 clock scheme. Juli's ice1724 chip is

 * supplied by external clock provided by Xilinx array and MK73-1 PLL frequency

 * multiplier. Actual frequency is set by ice1724 GPIOs hooked to the Xilinx.

 *

 * The clock circuitry is supplied by the two ice1724 crystals. This

 * arrangement allows to generate independent clock signal for AK4114's input

 * rate detection circuit. As a result, Juli, unlike most other

 * ice1724+ak4114-based cards, detects spdif input rate correctly.

 * This fact is applied in the driver, allowing to modify PCM stream rate

 * parameter according to the actual input rate.

 *

 * Juli uses the remaining three stereo-channels of its DAC to optionally

 * monitor analog input, digital input, and digital output. The corresponding

 * I2S signals are routed by Xilinx, controlled by GPIOs.

 *

 * The master mute is implemented using output muting transistors (GPIO) in

 * combination with smuting the DAC.

 *

 * The card itself has no HW master volume control, implemented using the

 * vmaster control.

 *

 * TODO:

 * researching and fixing the input monitors

/*

 * GPIO pins

 also external */

 0 = external, 1 = internal */

 RO only: 0 = present */

 must be 0 */

 1 = active */

 1 = active */

 1 = active */

 must be 0 */

 output mute, 1 = muted */

/*

 * Initial setup of the conversion array GPIO <-> rate

/*

 * If SPDIF capture and slaved to SPDIF-IN, setting runtime rate

 * to the external rate

/*

 * AK4358 section

/*

 * change the rate of envy24HT, AK4358, AK5385

	if (rate == 0)  /* no hint - S/PDIF input is master or the new spdif

 adjust DFS on codecs */

 AK5385 first, since it requires cold reset affecting both codecs */

	/* dev_dbg(ice->card->dev, "JULI - ak5385 set_rate_val: new gpio 0x%x\n",

 cold reset */

 AK4358 */

 set new value, reset DFS */

 reinit ak4114 */

	.num_dacs = 8,	/* DAC1 - analog out

			   DAC2 - analog in monitor

			   DAC3 - digital out monitor

			   DAC4 - digital in monitor

 val 0 = signal on */

 val 1 = signal on */

 unmute */

 0 = signal on */

 un-smuting DAC */

 1 = signal on */

 mute */

 1 = signal off */

 smuting DAC */

 0 = signal off */

	/* dev_dbg(ice->card->dev,

		"JULI - mute/unmute: control_value: 0x%x, old_gpio: 0x%x, "

		"new_gpio 0x%x\n",

		(unsigned int)ucontrol->value.integer.value[0], old_gpio,

 no change */

	/* Although the following functionality respects the succint NDA'd

	 * documentation from the card manufacturer, and the same way of

	 * operation is coded in OSS Juli driver, only Digital Out monitor

	 * seems to work. Surprisingly, Analog input monitor outputs Digital

	 * output data. The two are independent, as enabling both doubles

	 * volume of the monitor sound.

	 *

	 * Checking traces on the board suggests the functionality described

	 * by the manufacturer is correct - I2S from ADC and AK4114

	 * go to ICE as well as to Xilinx, I2S inputs of DAC2,3,4 (the monitor

	 * inputs) are fed from Xilinx.

	 *

	 * I even checked traces on board and coded a support in driver for

	 * an alternative possibility - the unused I2S ICE output channels

	 * switched to HW-IN/SPDIF-IN and providing the monitoring signal to

	 * the DAC - to no avail. The I2S outputs seem to be unconnected.

	 *

	 * The windows driver supports the monitoring correctly.

 dev_dbg(card->dev, "add_followers - %s\n", *list); */

 dev_dbg(card->dev, "follower %s found\n", *list); */

 Create virtual master control */

 only capture SPDIF over AK4114 */

/*

 * suspend/resume

 akm4358 un-reset, un-mute */

 reinit ak4114 */

 akm4358 reset and soft-mute */

/*

 * initialize the chip

 setting new rate */

	/* dev_dbg(ice->card->dev, "JULI - set_rate: old %x, new %x\n",

			old & GPIO_RATE_MASK,

 switching to external clock - supplied by external circuits */

 no change in master clock */

 setting clock to external - SPDIF */

 external clock (= 0), multiply 1x, 48kHz */

 Called when ak4114 detects change in the input SPDIF stream */

 only for SPDIF master mode, rate was changed */

		/* dev_dbg(ice->card->dev, "ak4114 - input rate changed to %d\n",

 AK4117_REG_PWRDN */	AK4114_RST | AK4114_PWN |

 AK4114_REQ_FORMAT */	AK4114_DIF_I24I2S,

 AK4114_REG_IO0 */	AK4114_TX1E,

 AK4114_REG_IO1 */	AK4114_EFH_1024 | AK4114_DIT |

 AK4114_REG_INT0_MASK */ 0,

 AK4114_REG_INT1_MASK */ 0

 callback for codecs rate setting */

 AK4114 in Juli can detect external rate correctly */

/*

 * it seems that the analog doughter board detection does not work reliably, so

 * force the analog flag; it should be very rare (if ever) to come at Juli@

 * used without the analog daughter board

 juli is clocked by Xilinx array */

/*

 * Juli@ boards don't provide the EEPROM data except for the vendor IDs.

 * hence the driver needs to sets up it properly.

	[ICE_EEP2_SYSCONF]     = 0x2b,	/* clock 512, mpu401, 1xADC, 1xDACs,

 I2S */

 vol, 96k, 24bit, 192k */

 out-en, out-int, spdif-in */

 5, 6:inputs; 7, 4-0 outputs*/

 5, 6: locked; 7, 4-0 writable */

 0-7 writable */

 internal clock, multiple 1x, 48kHz*/

 unmuted */

 entry point */

 terminator */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *   ALSA driver for ICEnsemble VT1724 (Envy24HT)

 *

 *   Lowlevel functions for Terratec Aureon cards

 *

 *	Copyright (c) 2003 Takashi Iwai <tiwai@suse.de>

 *

 * NOTES:

 *

 * - we reuse the struct snd_akm4xxx record for storing the wm8770 codec data.

 *   both wm and akm codecs are pretty similar, so we can integrate

 *   both controls in the future, once if wm codecs are reused in

 *   many boards.

 *

 * - DAC digital volumes are not implemented in the mixer.

 *   if they show better response than DAC analog volumes, we can use them

 *   instead.

 *

 *   Lowlevel functions for AudioTrak Prodigy 7.1 (and possibly 192) cards

 *      Copyright (c) 2003 Dimitromanolakis Apostolos <apostol@cs.utoronto.ca>

 *

 *   version 0.82: Stable / not all features work yet (no communication with AC97 secondary)

 *       added 64x/128x oversampling switch (should be 64x only for 96khz)

 *       fixed some recording labels (still need to check the rest)

 *       recording is working probably thanks to correct wm8770 initialization

 *

 *   version 0.5: Initial release:

 *           working: analog output, mixer, headphone amplifier switch

 *       not working: prety much everything else, at least i could verify that

 *                    we have no digital output, no capture, pretty bad clicks and poops

 *                    on mixer switch and other coll stuff.

 AC97 register cache for Aureon */

 WM8770 registers */

 DAC1-8 analog attenuation */

 DAC master analog attenuation */

 DAC1-8 digital attenuation */

 DAC master digital attenuation */

 DAC phase */

 DAC control bits */

 mute controls */

 de-emphasis and zefo-flag */

 interface control */

 master clock and mode */

 power-down controls */

 ADC gain L(19)/R(1a) */

 input MUX */

 output MUX */

 output MUX */

 software reset */

 CS8415A registers */

 PCA9554 registers */

 I2C device address */

 input port */

 output port */

 input invert */

 port directions */

/*

 * Aureon Universe additional controls using PCA9554

/*

 * Send data to pca9554

 ID 0100000, write */

 disable SPI devices */

	/*

	 * send i2c stop condition and start condition

	 * to obtain sane state

	/*

	 * send device address, command and value,

	 * skipping ack cycles in between

 Send address to XILINX chip */

 Send low-order byte to XILINX chip */

 Send high-order byte to XILINX chip */

 Instruct XILINX chip to parse the data to the STAC9744 chip */

 Store the data in out private buffer */

/*

 * Initialize STAC9744 chip

 Cold reset */

 Unmute AC'97 master volume permanently - muting is done by WM8770 */

/*

 * AC'97 volume controls

/*

 * AC'97 mute controls

/*

 * AC'97 mute controls

/*

 * write data in the SPI mode

/*

 * Read data in SPI mode

/*

 * get the current register value of WM codec

/*

 * set the register value of WM codec

/*

 * set the register value of WM codec and remember it

/*

/*

 * AC'97 master playback mute controls (Mute on WM8770 chip)

 0dB .. -100dB */

/*

 * DAC mute control

/*

 * Master volume attenuation mixer control

/*

 * DAC volume attenuation mixer control

 mute (-101dB) */

 0dB */

/*

 * WM8770 mute control

/*

 * WM8770 master mute control

 digital master volume */

 -64dB */

 mute (-64dB) */

 0dB */

 prelatch */

 update */

/*

 * ADC mute control

/*

 * ADC gain mixer control

 -12dB */

 19dB */

/*

 * ADC input mux mixer control

 AIN1 */

 AIN2 */

 AIN3 */

 AIN4 */

 AIN5 */

 AIN1 */

 AIN2 */

 AIN3 */

 AIN4 */

 AIN5 */

 AIN6 */

 AIN7 */

 AIN8 */

/*

 * CS8415 Input mux

 RXP0 */

 RXP1 */

 snd_ice1712_save_gpio_status(ice); */

 val = aureon_cs8415_get(ice, CS8415_CTRL2); */

 snd_ice1712_restore_gpio_status(ice); */

/*

 * CS8415A Mute

/*

 * CS8415A Q-Sub info

/*

 * Headphone Amplifier

/*

 * Deemphasis

/*

 * ADC Oversampling

/*

 * mixers

 no side */

/*

 * reset the chip

 These come first to reduce init pop noise */

 ADC Mux (AC'97 source) */

 Out Mux1 (VOUT1 = DAC+AUX, VOUT2 = DAC) */

 Out Mux2 (VOUT2 = DAC, VOUT3 = DAC) */

 All power-up */

 I2S, normal polarity, 24bit */

 256fs, slave mode */

 DAC1 analog mute */

 DAC2 analog mute */

 DAC3 analog mute */

 DAC4 analog mute */

 DAC5 analog mute */

 DAC6 analog mute */

 DAC7 analog mute */

 DAC8 analog mute */

 master analog mute */

 DAC1 digital full */

 DAC2 digital full */

 DAC3 digital full */

 DAC4 digital full */

 DAC5 digital full */

 DAC6 digital full */

 DAC7 digital full */

 DAC8 digital full */

 master digital full */

 phase normal */

 unmute DAC L/R */

 all unmute */

 no deemphasis, no ZFLG */

 -12dB ADC/L */

 -12dB ADC/R */

 These come first to reduce init pop noise */

 ADC Mux */

 Out Mux1 */

 Out Mux2 */

 All power-up */

 I2S, normal polarity, 24bit, high-pass on */

 128fs, slave mode */

 DAC1 analog mute */

 DAC2 analog mute */

 DAC3 analog mute */

 DAC4 analog mute */

 DAC5 analog mute */

 DAC6 analog mute */

 DAC7 analog mute */

 DAC8 analog mute */

 master analog mute */

 DAC1 digital full */

 DAC2 digital full */

 DAC3 digital full */

 DAC4 digital full */

 DAC5 digital full */

 DAC6 digital full */

 DAC7 digital full */

 DAC8 digital full */

 master digital full */

 phase normal */

 unmute DAC L/R */

 all unmute */

 no deemphasis, no ZFLG */

 -12dB ADC/L */

 -12dB ADC/R */

 RUN */

 no mute, OMCK output on RMCK pin */

 S/PDIF source on RXP1 */

 slave, 24bit, MSB on second OSCLK, SDOUT for right channel when OLRCK is high */

 fix this for the time being */

 reset the wm codec as the SPI mode */

 initialize WM8770 codec */

 initialize CS8415A codec */

 initialize PCA9554 pin directions & set default input */

 internal AUX */

/*

 * suspend/resume

	/* workaround for poking volume with alsamixer after resume:

/*

 * initialize the chip

 aureon 7.1 and prodigy 7.1 */

 to remember the register values of CS8415 */

/*

 * Aureon boards don't provide the EEPROM data except for the vendor IDs.

 * hence the driver needs to sets up it properly.

 clock 512, spdif-in/ADC, 3DACs */

 I2S */

 vol, 96k, 24bit, 192k */

 out-en, out-int, spdif-in */

 clock 512, spdif-in/ADC, 4DACs */

 I2S */

 vol, 96k, 24bit, 192k */

 out-en, out-int, spdif-in */

	[ICE_EEP2_SYSCONF]     = 0x2b,	/* clock 512, mpu401, spdif-in/ADC,

					 * 4DACs

 I2S */

 vol, 96k, 24bit, 192k */

 out-en, out-int, spdif-in */

 clock 384, spdif-in/ADC, 4DACs */

 I2S */

 vol, 96k, 24bit, 192k */

 out-en, out-int, spdif-in */

 entry point */

 keep in 15 letters */

 should be identical with Aureon71 */

 terminator */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *   ALSA driver for ICEnsemble ICE1712 (Envy24)

 *

 *	Copyright (c) 2000 Jaroslav Kysela <perex@perex.cz>

/*

  NOTES:

  - spdif nonaudio consumer mode does not work (at least with my

    Sony STR-DB830)

/*

 * Changes:

 *

 *  2002.09.09	Takashi Iwai <tiwai@suse.de>

 *	split the code to several files.  each low-level routine

 *	is stored in the local file and called from registration

 *	function from card_info struct.

 *

 *  2002.11.26	James Stafford <jstafford@ampltd.com>

 *	Added support for VT1724 (Envy24HT)

 *	I have left out support for 176.4 and 192 KHz for the moment.

 *  I also haven't done anything with the internal S/PDIF transmitter or the MPU-401

 *

 *  2003.02.20  Taksahi Iwai <tiwai@suse.de>

 *	Split vt1724 part to an independent driver.

 *	The GPIO is accessed through the callback functions now.

 *

 * 2004.03.31 Doug McLain <nostar@comcast.net>

 *    Added support for Event Electronics EZ8 card to hoontech.c.

 lowlevel routines */

 Index 0-MAX */

 ID for this card */

 Enable this card */

 Delta44 & 66 Omni I/O support */

 CS8427 S/PDIF transceiver reset timeout value in msec */

 DXR enable for DMX6FIRE */

 ICE1712 */

/*

 *  Basic I/O

 check whether the clock mode is spdif-in */

 timeout */

/*

 * pro ac97 section

 timeout */

/*

 * consumer ac97 digital mix

/*

 * gpio operations

 dummy read for pci-posting */

 dummy read for pci-posting */

 dummy read for pci-posting */

/*

 *

 * CS8427 interface

 *

/*

 * change the input clock selection

 * spdif_clock = 1 - IEC958 input, 0 - Envy24

 CS8427 auto increment | register number 4 + data */

/*

 * spdif callbacks

/*

 * create and initialize callbacks for cs8427 interface

 change CS8427 clock source too */

 notify ak4524 chip as well */

/*

 *  Interrupt handler

 dev_dbg(ice->card->dev, "pbkstatus = 0x%x\n", pbkstatus); */

/*

 *  PCM part - consumer I/O

/*

 *  PCM code - professional part (multitrack)

/*

 assign channels to iec958 */

/*

 *  Mixer section

 multi-channel mixer */

 initialize volumes */

 mute */

 mute */

 mute */

 I2S mixer only */

/*

 *

/*

 *

/*

/*

 *  rate

 0: 6 */

 1: 3 */

 2: 10 */

 3: 2 */

 4: 5 */

 5: 9 */

 6: 1 */

 7: 4 */

 8: 8 */

 9: 0 */

 10: 15 */

 11: 11 */

 12: 7 */

 13: -- */

 0: 6 */

 1: 3 */

 2: 10 */

 3: 2 */

 4: 5 */

 5: 9 */

 6: 1 */

 7: 4 */

 8: 8 */

 9: 0 */

 10: 15 */

 11: 11 */

 12: 7 */

 "IEC958 Input",	13: -- */

/*

 * routing

 0 */

 1-4 */

 5-8 */

 9-10 */

 11 - optional */

 update PSDOUT */

 dig mixer (or pcm) */

 spdif in */

 analog in */

 pcm */

 dig mixer of pcm */

 update CAPTURE */

 analog in */

 spdif in */

 update SPDOUT */

/*

 *

/*

 * list of available boards

 I2C EEPROM device address */

 invalid subvendor from EEPROM, try the PCI subststem ID instead */

 if the EEPROM is given by the driver, use it */

 FIXME: any cards without the correct size? */

 return -EIO; */

		/*  Set eeprom value to limit active ADCs and DACs to 6;

		 *  Also disable AC97 as no hardware in standard 6fire card/box

		 *  Note: DXR extensions are not currently supported

 unmask used interrupts */

 mask all interrupts */

 enable PCI device */

 check, if we can restrict PCI DMA transfers to 28 bits */

 consumer format */

 no emphasis */

 PCM encoder/decoder */

 disable legacy emulation */

/*

 *

 * Registration

 *

 specific driver? */

  Preferred name available in card_info */

  2nd port used  */

  Preferred name available in card_info */

 switching to external clock via SPDIF */

 internal on-card clock */

 CONFIG_PM_SLEEP */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *   ALSA driver for ICEnsemble ICE1724 (Envy24)

 *

 *   Lowlevel functions for Terratec PHASE 22

 *

 *	Copyright (c) 2005 Misha Zhilin <misha@epiphan.com>

/* PHASE 22 overview:

 *   Audio controller: VIA Envy24HT-S (slightly trimmed down Envy24HT, 4in/4out)

 *   Analog chip: AK4524 (partially via Philip's 74HCT125)

 *   Digital receiver: CS8414-CS (supported in this release)

 *		PHASE 22 revision 2.0 and Terrasoniq/Musonik TS22PCI have CS8416

 *		(support status unknown, please test and report)

 *

 *   Envy connects to AK4524

 *	- CS directly from GPIO 10

 *	- CCLK via 74HCT125's gate #4 from GPIO 4

 *	- CDTI via 74HCT125's gate #2 from GPIO 5

 *		CDTI may be completely blocked by 74HCT125's gate #1

 *		controlled by GPIO 3

/* PHASE 28 overview:

 *   Audio controller: VIA Envy24HT (full untrimmed version, 4in/8out)

 *   Analog chip: WM8770 (8 channel 192k DAC, 2 channel 96k ADC)

 *   Digital receiver: CS8414-CS (supported in this release)

 AC97 register cache for Phase28 */

 WM8770 registers */

 DAC1-8 analog attenuation */

 DAC master analog attenuation */

 DAC1-8 digital attenuation */

 DAC master digital attenuation */

 DAC phase */

 DAC control bits */

 mute controls */

 de-emphasis and zefo-flag */

 interface control */

 master clock and mode */

 power-down controls */

 ADC gain L(19)/R(1a) */

 input MUX */

 output MUX */

 output MUX */

 software reset */

/*

 * Logarithmic volume values for WM8770

 * Computed as 20 * Log10(255 / x)

 Configure DAC/ADC description for generic part of ice1724 */

 Envy24HT-S have 16 bit wide GPIO */

 Initialize analog chips */

	[ICE_EEP2_SYSCONF]     = 0x28,  /* clock 512, mpu 401,

 I2S */

 vol, 96k, 24bit */

 out-en, out-int, spdif-in */

	[ICE_EEP2_SYSCONF]     = 0x2b,  /* clock 512, mpu401,

 I2S */

 vol, 96k, 24bit, 192k */

 out-en, out-int, spdif-in */

/*

 * write data in the SPI mode

/*

 * get the current register value of WM codec

/*

 * set the register value of WM codec

/*

 * set the register value of WM codec and remember it

/*

 * DAC mute control

/*

 * Master volume attenuation mixer control

 These come first to reduce init pop noise */

 ADC Mux (AC'97 source) */

 Out Mux1 (VOUT1 = DAC+AUX, VOUT2 = DAC) */

 Out Mux2 (VOUT2 = DAC, VOUT3 = DAC) */

 All power-up */

 I2S, normal polarity, 24bit */

 256fs, slave mode */

 DAC1 analog mute */

 DAC2 analog mute */

 DAC3 analog mute */

 DAC4 analog mute */

 DAC5 analog mute */

 DAC6 analog mute */

 DAC7 analog mute */

 DAC8 analog mute */

 master analog mute */

 DAC1 digital full */

 DAC2 digital full */

 DAC3 digital full */

 DAC4 digital full */

 DAC5 digital full */

 DAC6 digital full */

 DAC7 digital full */

 DAC8 digital full */

 master digital full */

 phase normal */

 unmute DAC L/R */

 all unmute */

 no deemphasis, no ZFLG */

 -12dB ADC/L */

 -12dB ADC/R */

 Initialize analog chips */

 fix this for time being */

 reset the wm codec as the SPI mode */

/*

 * DAC volume attenuation mixer control

 mute (-101dB) */

 0dB */

/*

 * WM8770 mute control

/*

 * WM8770 master mute control

 digital master volume */

 -64dB */

 mute (-64dB) */

 0dB */

 prelatch */

 update */

/*

 * Deemphasis

/*

 * ADC Oversampling

 terminator */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *   ALSA driver for VT1720/VT1724 (Envy24PT/Envy24HT)

 *

 *   Lowlevel functions for VT1720-based motherboards

 *

 *	Copyright (c) 2004 Takashi Iwai <tiwai@suse.de>

 VT1616 codec */

 WM8728 codec */

 FIXME: TODO */

 FIXME: needs some quirks for VT1616? */

 EEPROM image */

 clock 256, 1ADC, 2DACs */

 ACLINK, packed */

 - */

 - */

 - */

 - */

 - */

 clock 256, 1ADC, 2DACs */

 ACLINK, packed */

 - */

 - */

 - */

 - */

 - */

 entry point */

 identical with k8x800 */

 identical with k8x800 */

 identical with k8x800 */

 terminator */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *   ALSA driver for ICEnsemble ICE1712 (Envy24)

 *

 *   Lowlevel functions for Terratec EWS88MT/D, EWX24/96, DMX 6Fire

 *

 *	Copyright (c) 2000 Jaroslav Kysela <perex@perex.cz>

 *                    2002 Takashi Iwai <tiwai@suse.de>

 additional i2c devices for EWS boards */

/*

 * access via i2c mode (for EWX 24/96, EWS 88MT&D)

 send SDA and SCL */

 set RW pin to low */

 set RW pin to high */

 reset write mask */

 set RW high */

 CS high also */

 CS high also */

 write SCL */

 write SDA */

/*

 * AK4524 access

 AK4524 chip select; address 0x48 bit 0-3 */

 start callback for EWS88MT, needs to select a certain chip mask */

 assert AK4524 CS */

 stop callback for EWS88MT, needs to deselect chip mask */

 start callback for EWX24/96 */

 start callback for DMX 6fire */

/*

 * CS8404 interface on EWS88MT/D

/*

 open callback */

 set up SPDIF for EWS88MT / EWS88D */

 consumer */

/*

 CIF high */

 no chip select on gpio */

 set rw bit high */

 CIF high */

 set rw bit high */

 CIF high */

 set later */

 set rw bit high */

/*

 * initialize the chip

 6fire specific */

 set the analog DACs */

 Note: not analog but ADAT I/O */

 create i2c */

 create i2c devices */

 Check if the front module is connected */

 set up SPDIF interface */

 set up CS8404 */

 Set spdif defaults */

 no analog? */

 analog section */

/*

 * EWX 24/96 specific controls

 i/o sensitivity - this callback is shared among other devices, too */

/*

 * EWS88MT specific controls

 analog output sensitivity;; address 0x48 bit 6 */

 high = -10dBV, low = +4dBu */

 analog output sensitivity;; address 0x48 bit 6 */

 analog input sensitivity; address 0x46 */

 reversed; high = +4dBu, low = -10dBV */

 analog output sensitivity; address 0x46 */

/*

 * EWS88D specific controls

 inverted */

/*

 * DMX 6Fire specific controls

 DMX6FIRE_CONTROL("Master Clock Select", 3, 0),

 all terratec cards have spdif, but cs8427 module builds it's own controls */

 ak4524 controls */

 card specific controls */

 entry point */

 terminator */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *   ALSA driver for ICEnsemble VT1724 (Envy24HT)

 *

 *   Lowlevel functions for Audiotrak Prodigy 7.1 Hifi

 *   based on pontis.c

 *

 *      Copyright (c) 2007 Julian Scheel <julian@jusst.de>

 *      Copyright (c) 2007 allank

 *      Copyright (c) 2004 Takashi Iwai <tiwai@suse.de>

 I2C addresses */

 WM8776 registers */

 headphone left attenuation */

 headphone left attenuation */

#define WM_HP_MASTER		0x02	/* headphone master (both channels),

 digital left attenuation */

 DAC phase swap */

 Analog Recording Source :- Mic, LineIn, CD/Video, */

 implement capture source select control for WM8776 */

 GPIO pins of envy24ht connected to wm8766 */

 CLK, Pin97 on ICE1724 */

 DATA VT1724 -> WM8766, Pin96 */

 Latch, Pin98 */

 WM8766 registers */

 DAC Control */

 Interface Control */

/*

 * Prodigy HD2

 CSN->GPIO8, pin 75 */

 CCLK->GPIO9, pin 76 */

 CDTI->GPIO10, pin 77 */

 ak4396 registers */

/*

 * get the current register value of WM codec

/*

 * set the register value of WM codec and remember it

/*

 * write data in the SPI mode

/*

 * SPI implementation for WM8766 codec - only writing supported, no readback

 latch must be low when writing */

 REGISTER ADDRESS */

 release latch */

 restore */

/*

 * serial interface for ak4396 - only writing supported, no readback

 latch must be low when writing */

 REGISTER ADDRESS */

 release latch */

 restore */

/*

 * ak4396 mixers

/*

 * DAC volume attenuation mixer control (-64dB to 0dB)

 mute */

 linear */

 --------------- */

/*

 * DAC volume attenuation mixer control (-64dB to 0dB)

 mute */

 0dB, 0.5dB step */

/*

 * WM8766 DAC volume attenuation mixer control

 mute */

 0dB */

/*

 * Master volume attenuation mixer control / applied to WM8776+WM8766

 Apply to front DAC */

 KONSTI */

 KONSTI */

/*

 * ADC gain mixer control (-64dB to 0dB)

 mute (-64dB) */

 0dB, 0.5dB step */

/*

 * ADC input mux mixer control

/*

 * Analog bypass (In -> Out)

/*

 * Left/Right swap

/*

 * mixers

/*

 * WM codec registers

 I2S Normal Mode, 24 bit */

 These come first to reduce init pop noise */

 ADC mute */

 0x00c0 replaced by 0x0003 */

 DAC softmute */

 DAC mute */

 All power-up except HP */

 reset */

 no DAC attenuation here */

 reinitialize WM8776 and re-apply old register values */

 reinitialize WM8766 and re-apply volumes for all DACs */

 unmute WM8776 DAC */

/*

 * initialize the chip

 256fs, slave mode */

 I2S, normal polarity, 24bit */

 I2S, normal polarity, 24bit */

 DAC L/R */

 OUT DAC */

 HP 0dB */

 HP 0dB */

 DAC 0dB */

 DAC 0dB */

 DAC 0dB */

 DAC 0dB */

 phase normal */

 DAC master muted */

 no deemphasis, no ZFLG */

 ADC muted */

 ADC muted */

 */

 */

 */

 */

 DAC unmute */

 ADC unmute, both CD/Line On */

	/* HACK - use this as the SPDIF source.

	* don't call snd_ice1712_gpio_get/put(), otherwise it's overwritten

 to remember the register values */

 initialize WM8776 codec */

/*

 * initialize the chip

 I2S Normal Mode, 24 bit */

 initialize ak4396 codec */

 reset codec */

 initialize ak4396 codec and restore previous mixer volumes */

	/* HACK - use this as the SPDIF source.

	* don't call snd_ice1712_gpio_get/put(), otherwise it's overwritten

 to remember the register values */

 SYSCONF: clock 512, spdif-in/ADC, 4DACs */

 ACLINK: I2S */

 I2S: vol, 96k, 24bit, 192k */

 SPDIF: out-en, out-int, spdif-in */

 GPIO_DIR */

 GPIO_DIR1 */

 GPIO_DIR2 */

 GPIO_MASK */

 GPIO_MASK1 */

 GPIO_MASK2 */

 GPIO_STATE */

 GPIO_STATE1 */

 GPIO_STATE2 */

 SYSCONF: clock 512, spdif-in/ADC, 4DACs */

 ACLINK: I2S */

 I2S: vol, 96k, 24bit, 192k */

 SPDIF: out-en, out-int, spdif-in */

 GPIO_DIR */

 GPIO_DIR1 */

 GPIO_DIR2 */

 GPIO_MASK */

 GPIO_MASK1 */

 GPIO_MASK2 */

 GPIO_STATE */

 GPIO_STATE1 */

 GPIO_STATE2 */

 SYSCONF: clock 512, ADC, 4DACs */	

 ACLINK: I2S */

 I2S: vol, 96k, 24bit, 192k */

 SPDIF: out-en, out-int */

 GPIO_DIR */

 GPIO_DIR1 */

 GPIO_DIR2 */

 GPIO_MASK */

 GPIO_MASK1 */

 GPIO_MASK2 */

 GPIO_STATE */

 GPIO_STATE1 */

 GPIO_STATE2 */

 entry point */

 terminator */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Driver for Digigram miXart soundcards

 *

 * mixer callbacks

 *

 * Copyright (c) 2003 by Digigram <alsa@digigram.com>

 [000] -96.0 dB */

 [001] -95.5 dB */

 [002] -95.0 dB */

 [003] -94.5 dB */

 [004] -94.0 dB */

 [005] -93.5 dB */

 [006] -93.0 dB */

 [007] -92.5 dB */

 [008] -92.0 dB */

 [009] -91.5 dB */

 [010] -91.0 dB */

 [011] -90.5 dB */

 [012] -90.0 dB */

 [013] -89.5 dB */

 [014] -89.0 dB */

 [015] -88.5 dB */

 [016] -88.0 dB */

 [017] -87.5 dB */

 [018] -87.0 dB */

 [019] -86.5 dB */

 [020] -86.0 dB */

 [021] -85.5 dB */

 [022] -85.0 dB */

 [023] -84.5 dB */

 [024] -84.0 dB */

 [025] -83.5 dB */

 [026] -83.0 dB */

 [027] -82.5 dB */

 [028] -82.0 dB */

 [029] -81.5 dB */

 [030] -81.0 dB */

 [031] -80.5 dB */

 [032] -80.0 dB */

 [033] -79.5 dB */

 [034] -79.0 dB */

 [035] -78.5 dB */

 [036] -78.0 dB */

 [037] -77.5 dB */

 [038] -77.0 dB */

 [039] -76.5 dB */

 [040] -76.0 dB */

 [041] -75.5 dB */

 [042] -75.0 dB */

 [043] -74.5 dB */

 [044] -74.0 dB */

 [045] -73.5 dB */

 [046] -73.0 dB */

 [047] -72.5 dB */

 [048] -72.0 dB */

 [049] -71.5 dB */

 [050] -71.0 dB */

 [051] -70.5 dB */

 [052] -70.0 dB */

 [053] -69.5 dB */

 [054] -69.0 dB */

 [055] -68.5 dB */

 [056] -68.0 dB */

 [057] -67.5 dB */

 [058] -67.0 dB */

 [059] -66.5 dB */

 [060] -66.0 dB */

 [061] -65.5 dB */

 [062] -65.0 dB */

 [063] -64.5 dB */

 [064] -64.0 dB */

 [065] -63.5 dB */

 [066] -63.0 dB */

 [067] -62.5 dB */

 [068] -62.0 dB */

 [069] -61.5 dB */

 [070] -61.0 dB */

 [071] -60.5 dB */

 [072] -60.0 dB */

 [073] -59.5 dB */

 [074] -59.0 dB */

 [075] -58.5 dB */

 [076] -58.0 dB */

 [077] -57.5 dB */

 [078] -57.0 dB */

 [079] -56.5 dB */

 [080] -56.0 dB */

 [081] -55.5 dB */

 [082] -55.0 dB */

 [083] -54.5 dB */

 [084] -54.0 dB */

 [085] -53.5 dB */

 [086] -53.0 dB */

 [087] -52.5 dB */

 [088] -52.0 dB */

 [089] -51.5 dB */

 [090] -51.0 dB */

 [091] -50.5 dB */

 [092] -50.0 dB */

 [093] -49.5 dB */

 [094] -49.0 dB */

 [095] -48.5 dB */

 [096] -48.0 dB */

 [097] -47.5 dB */

 [098] -47.0 dB */

 [099] -46.5 dB */

 [100] -46.0 dB */

 [101] -45.5 dB */

 [102] -45.0 dB */

 [103] -44.5 dB */

 [104] -44.0 dB */

 [105] -43.5 dB */

 [106] -43.0 dB */

 [107] -42.5 dB */

 [108] -42.0 dB */

 [109] -41.5 dB */

 [110] -41.0 dB */

 [111] -40.5 dB */

 [112] -40.0 dB */

 [113] -39.5 dB */

 [114] -39.0 dB */

 [115] -38.5 dB */

 [116] -38.0 dB */

 [117] -37.5 dB */

 [118] -37.0 dB */

 [119] -36.5 dB */

 [120] -36.0 dB */

 [121] -35.5 dB */

 [122] -35.0 dB */

 [123] -34.5 dB */

 [124] -34.0 dB */

 [125] -33.5 dB */

 [126] -33.0 dB */

 [127] -32.5 dB */

 [128] -32.0 dB */

 [129] -31.5 dB */

 [130] -31.0 dB */

 [131] -30.5 dB */

 [132] -30.0 dB */

 [133] -29.5 dB */

 [134] -29.0 dB */

 [135] -28.5 dB */

 [136] -28.0 dB */

 [137] -27.5 dB */

 [138] -27.0 dB */

 [139] -26.5 dB */

 [140] -26.0 dB */

 [141] -25.5 dB */

 [142] -25.0 dB */

 [143] -24.5 dB */

 [144] -24.0 dB */

 [145] -23.5 dB */

 [146] -23.0 dB */

 [147] -22.5 dB */

 [148] -22.0 dB */

 [149] -21.5 dB */

 [150] -21.0 dB */

 [151] -20.5 dB */

 [152] -20.0 dB */

 [153] -19.5 dB */

 [154] -19.0 dB */

 [155] -18.5 dB */

 [156] -18.0 dB */

 [157] -17.5 dB */

 [158] -17.0 dB */

 [159] -16.5 dB */

 [160] -16.0 dB */

 [161] -15.5 dB */

 [162] -15.0 dB */

 [163] -14.5 dB */

 [164] -14.0 dB */

 [165] -13.5 dB */

 [166] -13.0 dB */

 [167] -12.5 dB */

 [168] -12.0 dB */

 [169] -11.5 dB */

 [170] -11.0 dB */

 [171] -10.5 dB */

 [172] -10.0 dB */

 [173] -9.5 dB */

 [174] -9.0 dB */

 [175] -8.5 dB */

 [176] -8.0 dB */

 [177] -7.5 dB */

 [178] -7.0 dB */

 [179] -6.5 dB */

 [180] -6.0 dB */

 [181] -5.5 dB */

 [182] -5.0 dB */

 [183] -4.5 dB */

 [184] -4.0 dB */

 [185] -3.5 dB */

 [186] -3.0 dB */

 [187] -2.5 dB */

 [188] -2.0 dB */

 [189] -1.5 dB */

 [190] -1.0 dB */

 [191] -0.5 dB */

 [192] 0.0 dB */

 [193] 0.5 dB */

 [194] 1.0 dB */

 [195] 1.5 dB */

 [196] 2.0 dB */

 [197] 2.5 dB */

 [198] 3.0 dB */

 [199] 3.5 dB */

 [200] 4.0 dB */

 [201] 4.5 dB */

 [202] 5.0 dB */

 [203] 5.5 dB */

 [204] 6.0 dB */

 [205] 6.5 dB */

 [206] 7.0 dB */

 [207] 7.5 dB */

 [208] 8.0 dB */

 [209] 8.5 dB */

 [210] 9.0 dB */

 [211] 9.5 dB */

 [212] 10.0 dB */

 [213] 10.5 dB */

 [214] 11.0 dB */

 [215] 11.5 dB */

 [216] 12.0 dB */

 [217] 12.5 dB */

 [218] 13.0 dB */

 [219] 13.5 dB */

 [220] 14.0 dB */

 [221] 14.5 dB */

 [222] 15.0 dB */

 [223] 15.5 dB */

 [224] 16.0 dB */

 [225] 16.5 dB */

 [226] 17.0 dB */

 [227] 17.5 dB */

 [228] 18.0 dB */

 [229] 18.5 dB */

 [230] 19.0 dB */

 [231] 19.5 dB */

 [232] 20.0 dB */

 [233] 20.5 dB */

 [234] 21.0 dB */

 [235] 21.5 dB */

 [236] 22.0 dB */

 [237] 22.5 dB */

 [238] 23.0 dB */

 [239] 23.5 dB */

 [240] 24.0 dB */

 [241] 24.5 dB */

 [242] 25.0 dB */

 [243] 25.5 dB */

 [244] 26.0 dB */

 [245] 26.5 dB */

 [246] 27.0 dB */

 [247] 27.5 dB */

 [248] 28.0 dB */

 [249] 28.5 dB */

 [250] 29.0 dB */

 [251] 29.5 dB */

 [252] 30.0 dB */

 [253] 30.5 dB */

 [254] 31.0 dB */

 [255] 31.5 dB */

 -96.0 dB + 8.0 dB = -88.0 dB */

  31.5 dB + 8.0 dB =  39.5 dB */

  -8.0 dB + 8.0 dB =  0.0 dB */

 -96.0 dB + 1.5 dB = -94.5 dB (possible is down to (-114.0+1.5)dB) */

   0.0 dB + 1.5 dB =  1.5 dB */

  -1.5 dB + 1.5 dB =  0.0 dB */

 left and right */

/*

 * analog level control

 playback */

 -96 dB */

 0 dB */

 capture */

 -96 dB */

 31.5 dB */

 playback */

 capture */

 name will be filled later */

 shared */

 update playback levels */

 shared */

 [000] = 0.00e+000 = mute if <= -109.5dB */

 [001] = 3.55e-006 = pow(10.0, 0.05 * -109.0dB) */

 [002] = 3.76e-006 = pow(10.0, 0.05 * -108.5dB) */

 [003] = 3.98e-006 = pow(10.0, 0.05 * -108.0dB) */

 [004] = 4.22e-006 = pow(10.0, 0.05 * -107.5dB) */

 [005] = 4.47e-006 = pow(10.0, 0.05 * -107.0dB) */

 [006] = 4.73e-006 = pow(10.0, 0.05 * -106.5dB) */

 [007] = 5.01e-006 = pow(10.0, 0.05 * -106.0dB) */

 [008] = 5.31e-006 = pow(10.0, 0.05 * -105.5dB) */

 [009] = 5.62e-006 = pow(10.0, 0.05 * -105.0dB) */

 [010] = 5.96e-006 = pow(10.0, 0.05 * -104.5dB) */

 [011] = 6.31e-006 = pow(10.0, 0.05 * -104.0dB) */

 [012] = 6.68e-006 = pow(10.0, 0.05 * -103.5dB) */

 [013] = 7.08e-006 = pow(10.0, 0.05 * -103.0dB) */

 [014] = 7.50e-006 = pow(10.0, 0.05 * -102.5dB) */

 [015] = 7.94e-006 = pow(10.0, 0.05 * -102.0dB) */

 [016] = 8.41e-006 = pow(10.0, 0.05 * -101.5dB) */

 [017] = 8.91e-006 = pow(10.0, 0.05 * -101.0dB) */

 [018] = 9.44e-006 = pow(10.0, 0.05 * -100.5dB) */

 [019] = 1.00e-005 = pow(10.0, 0.05 * -100.0dB) */

 [020] = 1.06e-005 = pow(10.0, 0.05 * -99.5dB) */

 [021] = 1.12e-005 = pow(10.0, 0.05 * -99.0dB) */

 [022] = 1.19e-005 = pow(10.0, 0.05 * -98.5dB) */

 [023] = 1.26e-005 = pow(10.0, 0.05 * -98.0dB) */

 [024] = 1.33e-005 = pow(10.0, 0.05 * -97.5dB) */

 [025] = 1.41e-005 = pow(10.0, 0.05 * -97.0dB) */

 [026] = 1.50e-005 = pow(10.0, 0.05 * -96.5dB) */

 [027] = 1.58e-005 = pow(10.0, 0.05 * -96.0dB) */

 [028] = 1.68e-005 = pow(10.0, 0.05 * -95.5dB) */

 [029] = 1.78e-005 = pow(10.0, 0.05 * -95.0dB) */

 [030] = 1.88e-005 = pow(10.0, 0.05 * -94.5dB) */

 [031] = 2.00e-005 = pow(10.0, 0.05 * -94.0dB) */

 [032] = 2.11e-005 = pow(10.0, 0.05 * -93.5dB) */

 [033] = 2.24e-005 = pow(10.0, 0.05 * -93.0dB) */

 [034] = 2.37e-005 = pow(10.0, 0.05 * -92.5dB) */

 [035] = 2.51e-005 = pow(10.0, 0.05 * -92.0dB) */

 [036] = 2.66e-005 = pow(10.0, 0.05 * -91.5dB) */

 [037] = 2.82e-005 = pow(10.0, 0.05 * -91.0dB) */

 [038] = 2.99e-005 = pow(10.0, 0.05 * -90.5dB) */

 [039] = 3.16e-005 = pow(10.0, 0.05 * -90.0dB) */

 [040] = 3.35e-005 = pow(10.0, 0.05 * -89.5dB) */

 [041] = 3.55e-005 = pow(10.0, 0.05 * -89.0dB) */

 [042] = 3.76e-005 = pow(10.0, 0.05 * -88.5dB) */

 [043] = 3.98e-005 = pow(10.0, 0.05 * -88.0dB) */

 [044] = 4.22e-005 = pow(10.0, 0.05 * -87.5dB) */

 [045] = 4.47e-005 = pow(10.0, 0.05 * -87.0dB) */

 [046] = 4.73e-005 = pow(10.0, 0.05 * -86.5dB) */

 [047] = 5.01e-005 = pow(10.0, 0.05 * -86.0dB) */

 [048] = 5.31e-005 = pow(10.0, 0.05 * -85.5dB) */

 [049] = 5.62e-005 = pow(10.0, 0.05 * -85.0dB) */

 [050] = 5.96e-005 = pow(10.0, 0.05 * -84.5dB) */

 [051] = 6.31e-005 = pow(10.0, 0.05 * -84.0dB) */

 [052] = 6.68e-005 = pow(10.0, 0.05 * -83.5dB) */

 [053] = 7.08e-005 = pow(10.0, 0.05 * -83.0dB) */

 [054] = 7.50e-005 = pow(10.0, 0.05 * -82.5dB) */

 [055] = 7.94e-005 = pow(10.0, 0.05 * -82.0dB) */

 [056] = 8.41e-005 = pow(10.0, 0.05 * -81.5dB) */

 [057] = 8.91e-005 = pow(10.0, 0.05 * -81.0dB) */

 [058] = 9.44e-005 = pow(10.0, 0.05 * -80.5dB) */

 [059] = 1.00e-004 = pow(10.0, 0.05 * -80.0dB) */

 [060] = 1.06e-004 = pow(10.0, 0.05 * -79.5dB) */

 [061] = 1.12e-004 = pow(10.0, 0.05 * -79.0dB) */

 [062] = 1.19e-004 = pow(10.0, 0.05 * -78.5dB) */

 [063] = 1.26e-004 = pow(10.0, 0.05 * -78.0dB) */

 [064] = 1.33e-004 = pow(10.0, 0.05 * -77.5dB) */

 [065] = 1.41e-004 = pow(10.0, 0.05 * -77.0dB) */

 [066] = 1.50e-004 = pow(10.0, 0.05 * -76.5dB) */

 [067] = 1.58e-004 = pow(10.0, 0.05 * -76.0dB) */

 [068] = 1.68e-004 = pow(10.0, 0.05 * -75.5dB) */

 [069] = 1.78e-004 = pow(10.0, 0.05 * -75.0dB) */

 [070] = 1.88e-004 = pow(10.0, 0.05 * -74.5dB) */

 [071] = 2.00e-004 = pow(10.0, 0.05 * -74.0dB) */

 [072] = 2.11e-004 = pow(10.0, 0.05 * -73.5dB) */

 [073] = 2.24e-004 = pow(10.0, 0.05 * -73.0dB) */

 [074] = 2.37e-004 = pow(10.0, 0.05 * -72.5dB) */

 [075] = 2.51e-004 = pow(10.0, 0.05 * -72.0dB) */

 [076] = 2.66e-004 = pow(10.0, 0.05 * -71.5dB) */

 [077] = 2.82e-004 = pow(10.0, 0.05 * -71.0dB) */

 [078] = 2.99e-004 = pow(10.0, 0.05 * -70.5dB) */

 [079] = 3.16e-004 = pow(10.0, 0.05 * -70.0dB) */

 [080] = 3.35e-004 = pow(10.0, 0.05 * -69.5dB) */

 [081] = 3.55e-004 = pow(10.0, 0.05 * -69.0dB) */

 [082] = 3.76e-004 = pow(10.0, 0.05 * -68.5dB) */

 [083] = 3.98e-004 = pow(10.0, 0.05 * -68.0dB) */

 [084] = 4.22e-004 = pow(10.0, 0.05 * -67.5dB) */

 [085] = 4.47e-004 = pow(10.0, 0.05 * -67.0dB) */

 [086] = 4.73e-004 = pow(10.0, 0.05 * -66.5dB) */

 [087] = 5.01e-004 = pow(10.0, 0.05 * -66.0dB) */

 [088] = 5.31e-004 = pow(10.0, 0.05 * -65.5dB) */

 [089] = 5.62e-004 = pow(10.0, 0.05 * -65.0dB) */

 [090] = 5.96e-004 = pow(10.0, 0.05 * -64.5dB) */

 [091] = 6.31e-004 = pow(10.0, 0.05 * -64.0dB) */

 [092] = 6.68e-004 = pow(10.0, 0.05 * -63.5dB) */

 [093] = 7.08e-004 = pow(10.0, 0.05 * -63.0dB) */

 [094] = 7.50e-004 = pow(10.0, 0.05 * -62.5dB) */

 [095] = 7.94e-004 = pow(10.0, 0.05 * -62.0dB) */

 [096] = 8.41e-004 = pow(10.0, 0.05 * -61.5dB) */

 [097] = 8.91e-004 = pow(10.0, 0.05 * -61.0dB) */

 [098] = 9.44e-004 = pow(10.0, 0.05 * -60.5dB) */

 [099] = 1.00e-003 = pow(10.0, 0.05 * -60.0dB) */

 [100] = 1.06e-003 = pow(10.0, 0.05 * -59.5dB) */

 [101] = 1.12e-003 = pow(10.0, 0.05 * -59.0dB) */

 [102] = 1.19e-003 = pow(10.0, 0.05 * -58.5dB) */

 [103] = 1.26e-003 = pow(10.0, 0.05 * -58.0dB) */

 [104] = 1.33e-003 = pow(10.0, 0.05 * -57.5dB) */

 [105] = 1.41e-003 = pow(10.0, 0.05 * -57.0dB) */

 [106] = 1.50e-003 = pow(10.0, 0.05 * -56.5dB) */

 [107] = 1.58e-003 = pow(10.0, 0.05 * -56.0dB) */

 [108] = 1.68e-003 = pow(10.0, 0.05 * -55.5dB) */

 [109] = 1.78e-003 = pow(10.0, 0.05 * -55.0dB) */

 [110] = 1.88e-003 = pow(10.0, 0.05 * -54.5dB) */

 [111] = 2.00e-003 = pow(10.0, 0.05 * -54.0dB) */

 [112] = 2.11e-003 = pow(10.0, 0.05 * -53.5dB) */

 [113] = 2.24e-003 = pow(10.0, 0.05 * -53.0dB) */

 [114] = 2.37e-003 = pow(10.0, 0.05 * -52.5dB) */

 [115] = 2.51e-003 = pow(10.0, 0.05 * -52.0dB) */

 [116] = 2.66e-003 = pow(10.0, 0.05 * -51.5dB) */

 [117] = 2.82e-003 = pow(10.0, 0.05 * -51.0dB) */

 [118] = 2.99e-003 = pow(10.0, 0.05 * -50.5dB) */

 [119] = 3.16e-003 = pow(10.0, 0.05 * -50.0dB) */

 [120] = 3.35e-003 = pow(10.0, 0.05 * -49.5dB) */

 [121] = 3.55e-003 = pow(10.0, 0.05 * -49.0dB) */

 [122] = 3.76e-003 = pow(10.0, 0.05 * -48.5dB) */

 [123] = 3.98e-003 = pow(10.0, 0.05 * -48.0dB) */

 [124] = 4.22e-003 = pow(10.0, 0.05 * -47.5dB) */

 [125] = 4.47e-003 = pow(10.0, 0.05 * -47.0dB) */

 [126] = 4.73e-003 = pow(10.0, 0.05 * -46.5dB) */

 [127] = 5.01e-003 = pow(10.0, 0.05 * -46.0dB) */

 [128] = 5.31e-003 = pow(10.0, 0.05 * -45.5dB) */

 [129] = 5.62e-003 = pow(10.0, 0.05 * -45.0dB) */

 [130] = 5.96e-003 = pow(10.0, 0.05 * -44.5dB) */

 [131] = 6.31e-003 = pow(10.0, 0.05 * -44.0dB) */

 [132] = 6.68e-003 = pow(10.0, 0.05 * -43.5dB) */

 [133] = 7.08e-003 = pow(10.0, 0.05 * -43.0dB) */

 [134] = 7.50e-003 = pow(10.0, 0.05 * -42.5dB) */

 [135] = 7.94e-003 = pow(10.0, 0.05 * -42.0dB) */

 [136] = 8.41e-003 = pow(10.0, 0.05 * -41.5dB) */

 [137] = 8.91e-003 = pow(10.0, 0.05 * -41.0dB) */

 [138] = 9.44e-003 = pow(10.0, 0.05 * -40.5dB) */

 [139] = 1.00e-002 = pow(10.0, 0.05 * -40.0dB) */

 [140] = 1.06e-002 = pow(10.0, 0.05 * -39.5dB) */

 [141] = 1.12e-002 = pow(10.0, 0.05 * -39.0dB) */

 [142] = 1.19e-002 = pow(10.0, 0.05 * -38.5dB) */

 [143] = 1.26e-002 = pow(10.0, 0.05 * -38.0dB) */

 [144] = 1.33e-002 = pow(10.0, 0.05 * -37.5dB) */

 [145] = 1.41e-002 = pow(10.0, 0.05 * -37.0dB) */

 [146] = 1.50e-002 = pow(10.0, 0.05 * -36.5dB) */

 [147] = 1.58e-002 = pow(10.0, 0.05 * -36.0dB) */

 [148] = 1.68e-002 = pow(10.0, 0.05 * -35.5dB) */

 [149] = 1.78e-002 = pow(10.0, 0.05 * -35.0dB) */

 [150] = 1.88e-002 = pow(10.0, 0.05 * -34.5dB) */

 [151] = 2.00e-002 = pow(10.0, 0.05 * -34.0dB) */

 [152] = 2.11e-002 = pow(10.0, 0.05 * -33.5dB) */

 [153] = 2.24e-002 = pow(10.0, 0.05 * -33.0dB) */

 [154] = 2.37e-002 = pow(10.0, 0.05 * -32.5dB) */

 [155] = 2.51e-002 = pow(10.0, 0.05 * -32.0dB) */

 [156] = 2.66e-002 = pow(10.0, 0.05 * -31.5dB) */

 [157] = 2.82e-002 = pow(10.0, 0.05 * -31.0dB) */

 [158] = 2.99e-002 = pow(10.0, 0.05 * -30.5dB) */

 [159] = 3.16e-002 = pow(10.0, 0.05 * -30.0dB) */

 [160] = 3.35e-002 = pow(10.0, 0.05 * -29.5dB) */

 [161] = 3.55e-002 = pow(10.0, 0.05 * -29.0dB) */

 [162] = 3.76e-002 = pow(10.0, 0.05 * -28.5dB) */

 [163] = 3.98e-002 = pow(10.0, 0.05 * -28.0dB) */

 [164] = 4.22e-002 = pow(10.0, 0.05 * -27.5dB) */

 [165] = 4.47e-002 = pow(10.0, 0.05 * -27.0dB) */

 [166] = 4.73e-002 = pow(10.0, 0.05 * -26.5dB) */

 [167] = 5.01e-002 = pow(10.0, 0.05 * -26.0dB) */

 [168] = 5.31e-002 = pow(10.0, 0.05 * -25.5dB) */

 [169] = 5.62e-002 = pow(10.0, 0.05 * -25.0dB) */

 [170] = 5.96e-002 = pow(10.0, 0.05 * -24.5dB) */

 [171] = 6.31e-002 = pow(10.0, 0.05 * -24.0dB) */

 [172] = 6.68e-002 = pow(10.0, 0.05 * -23.5dB) */

 [173] = 7.08e-002 = pow(10.0, 0.05 * -23.0dB) */

 [174] = 7.50e-002 = pow(10.0, 0.05 * -22.5dB) */

 [175] = 7.94e-002 = pow(10.0, 0.05 * -22.0dB) */

 [176] = 8.41e-002 = pow(10.0, 0.05 * -21.5dB) */

 [177] = 8.91e-002 = pow(10.0, 0.05 * -21.0dB) */

 [178] = 9.44e-002 = pow(10.0, 0.05 * -20.5dB) */

 [179] = 1.00e-001 = pow(10.0, 0.05 * -20.0dB) */

 [180] = 1.06e-001 = pow(10.0, 0.05 * -19.5dB) */

 [181] = 1.12e-001 = pow(10.0, 0.05 * -19.0dB) */

 [182] = 1.19e-001 = pow(10.0, 0.05 * -18.5dB) */

 [183] = 1.26e-001 = pow(10.0, 0.05 * -18.0dB) */

 [184] = 1.33e-001 = pow(10.0, 0.05 * -17.5dB) */

 [185] = 1.41e-001 = pow(10.0, 0.05 * -17.0dB) */

 [186] = 1.50e-001 = pow(10.0, 0.05 * -16.5dB) */

 [187] = 1.58e-001 = pow(10.0, 0.05 * -16.0dB) */

 [188] = 1.68e-001 = pow(10.0, 0.05 * -15.5dB) */

 [189] = 1.78e-001 = pow(10.0, 0.05 * -15.0dB) */

 [190] = 1.88e-001 = pow(10.0, 0.05 * -14.5dB) */

 [191] = 2.00e-001 = pow(10.0, 0.05 * -14.0dB) */

 [192] = 2.11e-001 = pow(10.0, 0.05 * -13.5dB) */

 [193] = 2.24e-001 = pow(10.0, 0.05 * -13.0dB) */

 [194] = 2.37e-001 = pow(10.0, 0.05 * -12.5dB) */

 [195] = 2.51e-001 = pow(10.0, 0.05 * -12.0dB) */

 [196] = 2.66e-001 = pow(10.0, 0.05 * -11.5dB) */

 [197] = 2.82e-001 = pow(10.0, 0.05 * -11.0dB) */

 [198] = 2.99e-001 = pow(10.0, 0.05 * -10.5dB) */

 [199] = 3.16e-001 = pow(10.0, 0.05 * -10.0dB) */

 [200] = 3.35e-001 = pow(10.0, 0.05 * -9.5dB) */

 [201] = 3.55e-001 = pow(10.0, 0.05 * -9.0dB) */

 [202] = 3.76e-001 = pow(10.0, 0.05 * -8.5dB) */

 [203] = 3.98e-001 = pow(10.0, 0.05 * -8.0dB) */

 [204] = 4.22e-001 = pow(10.0, 0.05 * -7.5dB) */

 [205] = 4.47e-001 = pow(10.0, 0.05 * -7.0dB) */

 [206] = 4.73e-001 = pow(10.0, 0.05 * -6.5dB) */

 [207] = 5.01e-001 = pow(10.0, 0.05 * -6.0dB) */

 [208] = 5.31e-001 = pow(10.0, 0.05 * -5.5dB) */

 [209] = 5.62e-001 = pow(10.0, 0.05 * -5.0dB) */

 [210] = 5.96e-001 = pow(10.0, 0.05 * -4.5dB) */

 [211] = 6.31e-001 = pow(10.0, 0.05 * -4.0dB) */

 [212] = 6.68e-001 = pow(10.0, 0.05 * -3.5dB) */

 [213] = 7.08e-001 = pow(10.0, 0.05 * -3.0dB) */

 [214] = 7.50e-001 = pow(10.0, 0.05 * -2.5dB) */

 [215] = 7.94e-001 = pow(10.0, 0.05 * -2.0dB) */

 [216] = 8.41e-001 = pow(10.0, 0.05 * -1.5dB) */

 [217] = 8.91e-001 = pow(10.0, 0.05 * -1.0dB) */

 [218] = 9.44e-001 = pow(10.0, 0.05 * -0.5dB) */

 [219] = 1.00e+000 = pow(10.0, 0.05 * 0.0dB) */

 [220] = 1.06e+000 = pow(10.0, 0.05 * 0.5dB) */

 [221] = 1.12e+000 = pow(10.0, 0.05 * 1.0dB) */

 [222] = 1.19e+000 = pow(10.0, 0.05 * 1.5dB) */

 [223] = 1.26e+000 = pow(10.0, 0.05 * 2.0dB) */

 [224] = 1.33e+000 = pow(10.0, 0.05 * 2.5dB) */

 [225] = 1.41e+000 = pow(10.0, 0.05 * 3.0dB) */

 [226] = 1.50e+000 = pow(10.0, 0.05 * 3.5dB) */

 [227] = 1.58e+000 = pow(10.0, 0.05 * 4.0dB) */

 [228] = 1.68e+000 = pow(10.0, 0.05 * 4.5dB) */

 [229] = 1.78e+000 = pow(10.0, 0.05 * 5.0dB) */

 [230] = 1.88e+000 = pow(10.0, 0.05 * 5.5dB) */

 [231] = 2.00e+000 = pow(10.0, 0.05 * 6.0dB) */

 [232] = 2.11e+000 = pow(10.0, 0.05 * 6.5dB) */

 [233] = 2.24e+000 = pow(10.0, 0.05 * 7.0dB) */

 [234] = 2.37e+000 = pow(10.0, 0.05 * 7.5dB) */

 [235] = 2.51e+000 = pow(10.0, 0.05 * 8.0dB) */

 [236] = 2.66e+000 = pow(10.0, 0.05 * 8.5dB) */

 [237] = 2.82e+000 = pow(10.0, 0.05 * 9.0dB) */

 [238] = 2.99e+000 = pow(10.0, 0.05 * 9.5dB) */

 [239] = 3.16e+000 = pow(10.0, 0.05 * 10.0dB) */

 [240] = 3.35e+000 = pow(10.0, 0.05 * 10.5dB) */

 [241] = 3.55e+000 = pow(10.0, 0.05 * 11.0dB) */

 [242] = 3.76e+000 = pow(10.0, 0.05 * 11.5dB) */

 [243] = 3.98e+000 = pow(10.0, 0.05 * 12.0dB) */

 [244] = 4.22e+000 = pow(10.0, 0.05 * 12.5dB) */

 [245] = 4.47e+000 = pow(10.0, 0.05 * 13.0dB) */

 [246] = 4.73e+000 = pow(10.0, 0.05 * 13.5dB) */

 [247] = 5.01e+000 = pow(10.0, 0.05 * 14.0dB) */

 [248] = 5.31e+000 = pow(10.0, 0.05 * 14.5dB) */

 [249] = 5.62e+000 = pow(10.0, 0.05 * 15.0dB) */

 [250] = 5.96e+000 = pow(10.0, 0.05 * 15.5dB) */

 [251] = 6.31e+000 = pow(10.0, 0.05 * 16.0dB) */

 [252] = 6.68e+000 = pow(10.0, 0.05 * 16.5dB) */

 [253] = 7.08e+000 = pow(10.0, 0.05 * 17.0dB) */

 [254] = 7.50e+000 = pow(10.0, 0.05 * 17.5dB) */

 [255] = 7.94e+000 = pow(10.0, 0.05 * 18.0dB) */

 -109.5 dB */

  18.0 dB */

  0.0 dB */

 AES playback */

 analog playback */

 only when pipe exists ! */

 only when pipe exists ! */

 shared */

 -109.5 dB */

   18.0 dB */

 index */

 AES capture */

 analog capture */

 AES playback */

 analog playback */

 index */

 AES capture */

 analog capture */

 AES playback */

 analog playback */

 name will be filled later */

 count will be filled later */

 shared */

 index */

 AES playback */

 index */

 name will be filled later */

 shared */

 no pipe defined */

/*

 * monitoring level control

 shared */

/*

 * monitoring switch control

 mask 0x01 ans 0x02 */

 allocate or release resources for monitoring */

 allocate the playback pipe for monitoring */

 allocate the capture pipe for monitoring */

 release the capture pipe for monitoring */

 release the playback pipe for monitoring */

 shared */

 analog volumes can be set even if there is no pipe */

 analog levels for capture only on the first two chips */

 can be in another place */

 analog output level control */

 playback */

 output mute controls */

 analog input level control only on first two chips !*/

 capture */

 playback analog */

 capture analog */

 playback AES/EBU */

 capture AES/EBU */

 playback analog */

 playback AES/EBU */

 monitoring */

 init all mixer data and program the master volumes/switches */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Driver for Digigram miXart soundcards

 *

 * main file with alsa callbacks

 *

 * Copyright (c) 2003 by Digigram <alsa@digigram.com>

 Index 0-MAX */

 ID for this card */

 Enable this card */

/*

 MC8240 */

 already started */

 already stopped */

 function called with wrong pipe status */

 the event ! (take care: the MSB and two LSB's have to be 0) */

 wait on the last MSG_SYSTEM_SEND_SYNCHRO_CMD command to be really finished */

 start or stop the pipe (1 pipe) */

(struct mixart_uid){0,0};*/

 in case of start same command once again with pipe_count=0 */

 in case of start send a synchro top */

 !start */

 nothing to do */

 only one entry in uid_caller ! */

/*

 *  Allocate or reference output pipe for analog IOs (pcmp0/1)

 analog inputs */

 digital inputs */

 analog outputs */

 digital outputs */

 a new stream is opened and there are already all streams in use */

 pipe is not yet defined */

 should be StreamManagerUID, but zero is OK if there is only one ! */

 the left connector */

 we don't yet know the format, so config 16 bit pcm audio for instance */

 is 4.0f */

 find the right bufferinfo_array */

 in the array capture is behind playback */

 1 will set the miXart to ring-buffer mode ! */

 buffer is not yet allocated */

 buffer is not yet allocated */

 construct the identifier of the stream buffer received in the interrupts ! */

 id of the pipe, as returned by embedded */

 pipe->stream_uid[i] = buf->sgroup_resp.stream[i].stream_uid; */

 release the clock */

 stop the pipe */

 the streaming group ! */

 delete the pipe */

 reset stream pos      */

/*

 *  Trigger callback

 START_STREAM */

 STOP_STREAM */

 TODO */

 TODO */

/*

 *  prepare callback for all pcms

 TODO de faon non bloquante, rappliquer les hw_params (rate, bits, codec) */

 only the first stream can choose the sample rate */

 the further opened streams will be limited to its frequency (see open) */

 set the clock only once (first stream) on the same pipe */

 if frequency not yet defined, use some default */

 TODO: what else to configure ? */

 stream_param.samples_per_frame = 2; */

 stream_param.bytes_per_frame = 4; */

 stream_param.bytes_per_sample = 2; */

 set to 1 */

 set to 1 */

/*

 *  HW_PARAMS callback for all pcms

 set up channels */

  set up format for the stream */

 update the stream levels */

 set the format to the board */

 in array capture is behind playback */

 bufferinfo[i].buffer_id  is already defined */

/*

 *  TODO CONFIGURATION SPACE for all pcms, mono pcm must update channels_max

 256 frames U8 mono*/

 256 frames U8 mono*/

 get stream info */

 streams in use */

 get pipe pointer (out pipe) */

 start the pipe if necessary */

 not configured yet */

 if a sample rate is already used, another stream cannot change */

 for instance, no mono */

 get stream info */

 streams in use */

 get pipe pointer (in pipe) */

 start the pipe if necessary */

 not configured yet */

 if a sample rate is already used, another stream cannot change */

 sample rate released */

 delete pipe */

 set up the unique device id with the chip index */

/*

/*

/*

/*

 * release all the cards assigned to a manager instance

 stop mailbox */

 release irq  */

 reset board if some firmware was loaded */

 release the i/o ports */

 free flowarray */

 free bufferarray */

/*

 * proc interface

/*

  mixart_BA0 proc interface for BAR 0 - read callback

 make sure the read size is a multiple of 4 bytes */

/*

  mixart_BA1 proc interface for BAR 1 - read callback

 make sure the read size is a multiple of 4 bytes */

 stats available when embedded OS is running */

 get perf reference */

 endif elf loaded */

 text interface to read perf and temp meters */

 end of proc interface */

/*

 *    probe function - creates the card manager

	/*

 enable PCI device */

 check if we can restrict PCI DMA transfers to 32 bits */

	/*

 resource assignment */

 init mailbox  */

 init setup mutex*/

 card assignment */

 4  FIXME: configurable? */

 init proc interface only for chip0 */

 init firmware status (mgr->dsp_loaded reset in hwdep_new) */

 create array of streaminfo */

 init streaminfo_array */

 create array of bufferinfo */

 init bufferinfo_array */

 set up firmware */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Driver for Digigram miXart soundcards

 *

 * low level interface with interrupt handling and mail box implementation

 *

 * Copyright (c) 2003 by Digigram <alsa@digigram.com>

 400 ms */

 mask for following types */

 embedded -> driver (only notification, do not get_msg() !) */

 driver <-> embedded (a command has no answer) */

 driver -> embedded (request will get an answer back) */

 embedded -> driver */

 this bit is set for a notification that has been canceled */

 read the message frame fifo */

 no message posted */

 error */

 error */

 increment the tail index */

 copy message descriptor from miXart to driver */

 size of descriptor + response */

 dwMessageID */

 uidDest */

 */

 swap if necessary */

 u32 size */

	/*

	 * free message frame address

 give address back to outbound fifo */

 increment the outbound free head */

/*

 * send a message to miXart. return: the msg_frame used for this message

 call with mgr->msg_lock held! */

 get message frame address */

 set address to zero on this fifo position */

 increment the inbound free tail */

 TODO : use memcpy_toio() with intermediate buffer to copy the message */

 copy message descriptor to card memory */

 size of descriptor + request */

 dwMessageID */

 uidDest */

 */

 SizeHeader */

 OffsetDLL_T16 */

 SizeDLL_T16 */

 OffsetDLL_DRV */

 SizeDLL_DRV */

 dwExpectedAnswerSize */

 copy message data to card memory */

 the pending event is the notification we wait for ! */

 the pending event is the answer we wait for (same address than the request)! */

 copy address back to caller */

 mark the frame as a request (will have an answer) */

 post the frame */

 increment the inbound post head */

 set to 0, so it's no notification to wait for, but the answer */

 send the message */

 send and mark the answer pending */

 error - no ack */

 retrieve the answer into the same struct mixart_msg */

 send the message */

 send and mark the notification event pending */

 error - no ack */

 just send the message (do not mark it as a pending one) */

 the answer will be handled by snd_struct mixart_msgasklet()  */

 common buffer of interrupt to send/receive messages */

 process the message ... */

 answer to a message on that we did not wait for (send_msg_nonblock) */

 msg contains no address ! do not get_msg() ! */

 get_msg() necessary */

 switch type */

 decrement counter */

 while there is a msg in fifo */

 this device did not cause the interrupt */

 mask all interrupts */

 outdoorbell register clear */

 clear interrupt */

 process interrupt */

 card0 to 3 */

 pcm0 to 3  */

 0 to MIXART_PLAYBACK_STREAMS */

 playback == 0 / capture == 1 */

 while */

 Traces are text: the swapped msg_data has to be swapped back ! */

 answer or notification to a message we are waiting for*/

 answer to a message we did't want to wait for */

 TODO : are there things to do here ? */

 switch on msg type */

 while there are msgs */

 allow interrupt again */

 allow outbound messagebox to generate interrupts */

 no more interrupts on outbound messagebox */

 reset miXart */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Driver for Digigram miXart soundcards

 *

 * DSP firmware management

 *

 * Copyright (c) 2003 by Digigram <alsa@digigram.com>

/**

 * mixart_wait_nice_for_register_value - wait for a value on a peudo register,

 * exit with a timeout

 *

 * @mgr: pointer to miXart manager structure

 * @offset: unsigned pseudo_register base + offset of value

 * @is_egal: wait for the equal value

 * @value: value

 * @timeout: timeout in centisenconds

	do {	/* we may take too long time in this loop.

		 * so give controls back to kernel if needed.

 wait for different value */

/*

  structures needed to upload elf code packets 

/*

 * get basic information and init miXart

 audio IDs for request to the board */

 board num = 0 */

 odd */

 even */

 dev_dbg(&mgr->pci->dev, "playback connector[%d].object_id = %x\n", k, connector->uid[k].object_id); */

 TODO: really need send_msg MSG_CONNECTOR_GET_AUDIO_INFO for each connector ? perhaps for analog level caps ? */

dev_dbg(&mgr->pci->dev, "play  analog_info.analog_level_present = %x\n", audio_info->info.analog_info.analog_level_present);*/

 board num = 0 */

 odd */

 even */

 dev_dbg(&mgr->pci->dev, "capture connector[%d].object_id = %x\n", k, connector->uid[k].object_id); */

 TODO: really need send_msg MSG_CONNECTOR_GET_AUDIO_INFO for each connector ? perhaps for analog level caps ? */

dev_dbg(&mgr->pci->dev, "rec  analog_info.analog_level_present = %x\n", audio_info->info.analog_info.analog_level_present);*/

 get the uid for the console manager */

 cardindex = 0 */

 used later for clock issues ! */

 min 2 phys io per card (analog in + analog out) */

 send a synchro command to card (necessary to do this before first MSG_STREAM_START_STREAM_GRP_PACKET) */

 though why not here */

 this command has no data. response is a 32 bit status */

 firmware base addresses (when hard coded) */

 read motherboard xilinx status */

 read elf status */

 read daughterboard xilinx status */

 motherboard xilinx status 5 will say that the board is performing a reset */

 try again later */

 xilinx already loaded ? */ 

 the status should be 0 == "idle" */

 modprob -r may help ? */

 check xilinx validity */

 set xilinx status to copying */

 setup xilinx base address */

 setup code size for xilinx file */

 copy xilinx code */

 set xilinx status to copy finished */

 return, because no further processing needed */

 the status should be 0 == "idle" */

 modprob -r may help ? */

 wait for xilinx status == 4 */

 5sec */

 init some data on the card */

 set miXart boardnumber to 0 */

 reset pointer to flow table on miXart */

 set elf status to copying */

 process the copying of the elf packets */

 set elf status to copy finished */

 wait for elf status == 4 */

 3sec */

 miXart waits at this point on the pointer to the flow table */

 give pointer of flow table to miXart */

 return, another xilinx file has to be loaded before */

 elf and xilinx should be loaded */

 modprob -r may help ? */

 wait for daughter detection != 0 */

 300msec */

 the board type can now be retrieved */

 no daughter board; the file does not have to be loaded, continue after the switch */

 only if aesebu daughter board presence (elf code must run)  */ 

 daughter should be idle */

 modprob -r may help ? */

 check daughterboard xilinx validity */

 inform mixart about the size of the file */

 set daughterboard status to 1 */

 wait for status == 2 */

 300msec */

 get the address where to write the file */

 copy daughterboard xilinx code */

 set daughterboard status to 4 */

 continue with init */

 end of switch file index*/

 wait for daughter status == 3 */

 3sec */

 init mailbox (communication with embedded) */

 first communication with embedded */

 create devices and mixer in accordance with HW options*/

 fake hwdep dsp record */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright (c) 2004 James Courtier-Dutton <James@superbug.demon.co.uk>

 *  Driver CA0106 chips. e.g. Sound Blaster Audigy LS and Live 24bit

 *  Version: 0.0.18

 *

 *  FEATURES currently supported:

 *    See ca0106_main.c for features.

 * 

 *  Changelog:

 *    Support interrupts per period.

 *    Removed noise from Center/LFE channel when in Analog mode.

 *    Rename and remove mixer controls.

 *  0.0.6

 *    Use separate card based DMA buffer for periods table list.

 *  0.0.7

 *    Change remove and rename ctrls into lists.

 *  0.0.8

 *    Try to fix capture sources.

 *  0.0.9

 *    Fix AC3 output.

 *    Enable S32_LE format support.

 *  0.0.10

 *    Enable playback 48000 and 96000 rates. (Rates other that these do not work, even with "plug:front".)

 *  0.0.11

 *    Add Model name recognition.

 *  0.0.12

 *    Correct interrupt timing. interrupt at end of period, instead of in the middle of a playback period.

 *    Remove redundent "voice" handling.

 *  0.0.13

 *    Single trigger call for multi channels.

 *  0.0.14

 *    Set limits based on what the sound card hardware can do.

 *    playback periods_min=2, periods_max=8

 *    capture hw constraints require period_size = n * 64 bytes.

 *    playback hw constraints require period_size = n * 64 bytes.

 *  0.0.15

 *    Separated ca0106.c into separate functional .c files.

 *  0.0.16

 *    Modified Copyright message.

 *  0.0.17

 *    Implement Mic and Line in Capture.

 *  0.0.18

 *    Add support for mute control on SB Live 24bit (cards w/ SPI DAC)

 *

 *  This code was initially based on code from ALSA's emu10k1x.c which is:

 *  Copyright (c) by Francisco Moraes <fmoraes@nc.rr.com>

 Digital */

 Analog */

 Mute input */

 Left */

 Left */

 Right */

 Right */

 Set source */

 snd_ca0106_i2c_write(emu, ADC_MUX, 0); */ 
 snd_ca0106_i2c_write(emu, ADC_MUX, ADC_MUX_MIC); */

 snd_ca0106_i2c_write(emu, ADC_MUX, 0); */ 
 snd_ca0106_i2c_write(emu, ADC_MUX, ADC_MUX_LINEIN); */

/*

	/* If the capture source has changed,

	 * update the capture volume from the cached value

	 * for the particular source.

		/* FIXME: this isn't safe, but needed to keep the compatibility

		 * with older alsa-lib config

 Left */

 Right */

 Left */

 Right */

 bit already cleared, do nothing */

 bit already set, do nothing */

 Unused channel */

 FIXME: strcpy is bad. */

 gpio_type == 2 */

 Create virtual master controls */

 save volumes */

 CONFIG_PM_SLEEP */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright (c) 2004 James Courtier-Dutton <James@superbug.demon.co.uk>

 *  Driver CA0106 chips. e.g. Sound Blaster Audigy LS and Live 24bit

 *  Version: 0.0.18

 *

 *  FEATURES currently supported:

 *    See ca0106_main.c for features.

 * 

 *  Changelog:

 *    Support interrupts per period.

 *    Removed noise from Center/LFE channel when in Analog mode.

 *    Rename and remove mixer controls.

 *  0.0.6

 *    Use separate card based DMA buffer for periods table list.

 *  0.0.7

 *    Change remove and rename ctrls into lists.

 *  0.0.8

 *    Try to fix capture sources.

 *  0.0.9

 *    Fix AC3 output.

 *    Enable S32_LE format support.

 *  0.0.10

 *    Enable playback 48000 and 96000 rates. (Rates other that these do not work, even with "plug:front".)

 *  0.0.11

 *    Add Model name recognition.

 *  0.0.12

 *    Correct interrupt timing. interrupt at end of period, instead of in the middle of a playback period.

 *    Remove redundent "voice" handling.

 *  0.0.13

 *    Single trigger call for multi channels.

 *  0.0.14

 *    Set limits based on what the sound card hardware can do.

 *    playback periods_min=2, periods_max=8

 *    capture hw constraints require period_size = n * 64 bytes.

 *    playback hw constraints require period_size = n * 64 bytes.

 *  0.0.15

 *    Separate ca0106.c into separate functional .c files.

 *  0.0.16

 *    Modified Copyright message.

 *  0.0.17

 *    Add iec958 file in proc file system to show status of SPDIF in.

 *  0.0.18

 *    Implement support for Line-in capture on SB Live 24bit.

 *

 *  This code was initially based on code from ALSA's emu10k1x.c which is:

 *  Copyright (c) by Francisco Moraes <fmoraes@nc.rr.com>

 consumer */

 SPDX-License-Identifier: GPL-2.0-or-later

/* 

 *  Copyright 10/16/2005 Tilman Kranz <tilde@tk-sls.de>

 *  Creative Audio MIDI, for the CA0106 Driver

 *  Version: 0.0.1

 *

 *  Changelog:

 *    Implementation is based on mpu401 and emu10k1x and

 *    tested with ca0106.

 *    mpu401: Copyright (c) by Jaroslav Kysela <perex@perex.cz>

 *    emu10k1x: Copyright (c) by Francisco Moraes <fmoraes@nc.rr.com>

 ca_midi_clear_rx(midi); */

 try to send some amount of bytes here before interrupts */

 no more data */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright (c) 2004 James Courtier-Dutton <James@superbug.demon.co.uk>

 *  Driver CA0106 chips. e.g. Sound Blaster Audigy LS and Live 24bit

 *  Version: 0.0.25

 *

 *  FEATURES currently supported:

 *    Front, Rear and Center/LFE.

 *    Surround40 and Surround51.

 *    Capture from MIC an LINE IN input.

 *    SPDIF digital playback of PCM stereo and AC3/DTS works.

 *    (One can use a standard mono mini-jack to one RCA plugs cable.

 *     or one can use a standard stereo mini-jack to two RCA plugs cable.

 *     Plug one of the RCA plugs into the Coax input of the external decoder/receiver.)

 *    ( In theory one could output 3 different AC3 streams at once, to 3 different SPDIF outputs. )

 *    Notes on how to capture sound:

 *      The AC97 is used in the PLAYBACK direction.

 *      The output from the AC97 chip, instead of reaching the speakers, is fed into the Philips 1361T ADC.

 *      So, to record from the MIC, set the MIC Playback volume to max,

 *      unmute the MIC and turn up the MASTER Playback volume.

 *      So, to prevent feedback when capturing, minimise the "Capture feedback into Playback" volume.

 *   

 *    The only playback controls that currently do anything are: -

 *    Analog Front

 *    Analog Rear

 *    Analog Center/LFE

 *    SPDIF Front

 *    SPDIF Rear

 *    SPDIF Center/LFE

 *   

 *    For capture from Mic in or Line in.

 *    Digital/Analog ( switch must be in Analog mode for CAPTURE. )

 * 

 *    CAPTURE feedback into PLAYBACK

 * 

 *  Changelog:

 *    Support interrupts per period.

 *    Removed noise from Center/LFE channel when in Analog mode.

 *    Rename and remove mixer controls.

 *  0.0.6

 *    Use separate card based DMA buffer for periods table list.

 *  0.0.7

 *    Change remove and rename ctrls into lists.

 *  0.0.8

 *    Try to fix capture sources.

 *  0.0.9

 *    Fix AC3 output.

 *    Enable S32_LE format support.

 *  0.0.10

 *    Enable playback 48000 and 96000 rates. (Rates other that these do not work, even with "plug:front".)

 *  0.0.11

 *    Add Model name recognition.

 *  0.0.12

 *    Correct interrupt timing. interrupt at end of period, instead of in the middle of a playback period.

 *    Remove redundent "voice" handling.

 *  0.0.13

 *    Single trigger call for multi channels.

 *  0.0.14

 *    Set limits based on what the sound card hardware can do.

 *    playback periods_min=2, periods_max=8

 *    capture hw constraints require period_size = n * 64 bytes.

 *    playback hw constraints require period_size = n * 64 bytes.

 *  0.0.15

 *    Minor updates.

 *  0.0.16

 *    Implement 192000 sample rate.

 *  0.0.17

 *    Add support for SB0410 and SB0413.

 *  0.0.18

 *    Modified Copyright message.

 *  0.0.19

 *    Finally fix support for SB Live 24 bit. SB0410 and SB0413.

 *    The output codec needs resetting, otherwise all output is muted.

 *  0.0.20

 *    Merge "pci_disable_device(pci);" fixes.

 *  0.0.21

 *    Add 4 capture channels. (SPDIF only comes in on channel 0. )

 *    Add SPDIF capture using optional digital I/O module for SB Live 24bit. (Analog capture does not yet work.)

 *  0.0.22

 *    Add support for MSI K8N Diamond Motherboard with onboard SB Live 24bit without AC97. From kiksen, bug #901

 *  0.0.23

 *    Implement support for Line-in capture on SB Live 24bit.

 *  0.0.24

 *    Add support for mute control on SB Live 24bit (cards w/ SPI DAC)

 *  0.0.25

 *    Powerdown SPI DAC channels when not in use

 *

 *  BUGS:

 *    Some stability problems when unloading the snd-ca0106 kernel module.

 *    --

 *

 *  TODO:

 *    4 Capture channels, only one implemented so far.

 *    Other capture rates apart from 48khz not implemented.

 *    MIDI

 *    --

 *  GENERAL INFO:

 *    Model: SB0310

 *    P17 Chip: CA0106-DAT

 *    AC97 Codec: STAC 9721

 *    ADC: Philips 1361T (Stereo 24bit)

 *    DAC: WM8746EDS (6-channel, 24bit, 192Khz)

 *

 *  GENERAL INFO:

 *    Model: SB0410

 *    P17 Chip: CA0106-DAT

 *    AC97 Codec: None

 *    ADC: WM8775EDS (4 Channel)

 *    DAC: CS4382 (114 dB, 24-Bit, 192 kHz, 8-Channel D/A Converter with DSD Support)

 *    SPDIF Out control switches between Mic in and SPDIF out.

 *    No sound out or mic input working yet.

 * 

 *  GENERAL INFO:

 *    Model: SB0413

 *    P17 Chip: CA0106-DAT

 *    AC97 Codec: None.

 *    ADC: Unknown

 *    DAC: Unknown

 *    Trying to handle it like the SB0410.

 *

 *  This code was initially based on code from ALSA's emu10k1x.c which is:

 *  Copyright (c) by Francisco Moraes <fmoraes@nc.rr.com>

 module parameters (see "Module Parameters")

 Force card subsystem model */

 Sound Blaster X-Fi Extreme Audio. This does not have an AC97. 53SB079000000 */

 It is really just a normal SB Live 24bit. */

	 /* Tested:

	  * See ALSA bug#3251

 Sound Blaster X-Fi Extreme Audio. This does not have an AC97. 53SB079000000 */

 It is really just a normal SB Live 24bit. */

	 /*

 	  * CTRL:CA0111-WTLF

	  * ADC: WM8775SEDS

	  * DAC: CS4382-KQZ

	 /* Tested:

	  * Playback on front, rear, center/lfe speakers

	  * Capture from Mic in.

	  * Not-Tested:

	  * Capture from Line in.

	  * Playback to digital out.

 New Dell Sound Blaster Live! 7.1 24bit. This does not have an AC97.  */

 AudigyLS[SB0310] */

 Unknown AudigyLS that also says SB0310 on it */

 New Sound Blaster Live! 7.1 24bit. This does not have an AC97. 53SB041000001 */

 New Dell Sound Blaster Live! 7.1 24bit. This does not have an AC97.  */

 New Audigy SE. Has a different DAC. */

	 /* SB0570:

	  * CTRL:CA0106-DAT

	  * ADC: WM8775EDS

	  * DAC: WM8768GEDS

 New Audigy LS. Has a different DAC. */

	 /* SB0570:

	  * CTRL:CA0106-DAT

	  * ADC: WM8775EDS

	  * DAC: WM8768GEDS

	/* Sound Blaster 5.1vx

	 * Tested: Playback on front, rear, center/lfe speakers

	 * Not-Tested: Capture

 MSI K8N Diamond Motherboard with onboard SB Live 24bit without AC97 */

	 /* SB0438

	  * CTRL:CA0106-DAT

	  * ADC: WM8775SEDS

	  * DAC: CS4382-KQZ

 MSI K8N Diamond PLUS MB */

	/* Giga-byte GA-G1975X mobo

	 * Novell bnc#395807

 FIXME: the GPIO and I2C setting aren't tested well */

	 /* Shuttle XPC SD31P which has an onboard Creative Labs

	  * Sound Blaster Live! 24-bit EAX

	  * high-definition 7.1 audio processor".

	  * Added using info from andrewvegan in alsa bug #1298

	/* Shuttle XPC SD11G5 which has an onboard Creative Labs

	 * Sound Blaster Live! 24-bit EAX

	 * high-definition 7.1 audio processor".

	 * Fixes ALSA bug#1600

 hardware definition */

1,

6,

 FIXME: looks like 44.1kHz capture causes noisy output on 48kHz */

 FIXME */

 Only 16bit values allowed */

 Set xxx20000 */

 Set xxx1xxxx */

 write post */

 Wait for status bit to return to 0 */

 Timed out */

 Write post */

 The ADC does not support i2c read, so only write is implemented */

	/*

	dev_dbg(emu->card->dev, "I2C-write:reg=0x%x, value=0x%x\n", reg, value);

 Not sure what this I2C channel controls. */

 snd_ca0106_ptr_write(emu, I2C_D0, 0, tmp); */

 This controls the I2C connected to the WM8775 ADC Codec */

 Send the data to i2c */

tmp = snd_ca0106_ptr_read(emu, I2C_A, 0);

tmp = tmp & ~(I2C_A_ADC_READ|I2C_A_ADC_LAST|I2C_A_ADC_START|I2C_A_ADC_ADD_MASK);

 Wait till the transaction ends */

dev_dbg(emu->card->dev, "I2C:status=0x%x\n", status);*/

Read back and see if the transaction is successful

 Power up */

 Power down */

 open_playback callback */

	/*

	dev_dbg(chip->card->dev, "open:channel_id=%d, chip=%p, channel=%p\n",

	       channel_id, chip, channel);

channel->interrupt = snd_ca0106_pcm_channel_interrupt;

 Front channel dac should already be on */

 close callback */

 Front channel dac should stay on */

 FIXME: maybe zero others */

 open_capture callback */

	/*

	dev_dbg(chip->card->dev, "open:channel_id=%d, chip=%p, channel=%p\n",

	       channel_id, chip, channel);

channel->interrupt = snd_ca0106_pcm_channel_interrupt;

snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE, &hw_constraints_capture_period_sizes);

 close callback */

 FIXME: maybe zero others */

 prepare playback callback */

 FIXME: Depending on mixer selection of SPDIF out or not, select the spdif rate or the DAC rate. */

 Global. Set SPDIF rate. We only support 44100 to spdif, not to DAC. */

 debug */

 debug */

 Rate can be set per channel. */

 reg40 control host to fifo */

 reg71 controls DAC rate. */

 Format is a global setting */

 FIXME: Only let the first channel accessed set this. */

 FIXME: Check emu->buffer->size before actually writing to it. */

 buffer size in bytes

 FIXME  test what 0 bytes does. */

 buffer size in bytes

 Unmute output */

 prepare capture callback */

 Global. Set ADC rate. */

 debug */

 debug */

 reg71 controls ADC rate. */

 Format is a global setting */

 FIXME: Only let the first channel accessed set this. */

 The SB0410 and SB0413 use I2C to control ADC. */

 Adjust the over sampler to better suit the capture rate. */

	/*

	dev_dbg(emu->card->dev,

	       "prepare:channel_number=%d, rate=%d, format=0x%x, channels=%d, "

	       "buffer_size=%ld, period_size=%ld, frames_to_bytes=%d\n",

	       channel, runtime->rate, runtime->format, runtime->channels,

	       runtime->buffer_size, runtime->period_size,

	       frames_to_bytes(runtime, 1));

 buffer size in bytes

 trigger_playback callback */

 dev_dbg(emu->card->dev, "channel=%d\n", channel); */

 dev_dbg(emu->card->dev, "basic=0x%x, extended=0x%x\n",basic, extended); */

 trigger_capture callback */

 pointer_playback callback */

 pointer_capture callback */

	/*

	dev_dbg(emu->card->dev, "ptr1 = 0x%lx, ptr2=0x%lx, ptr=0x%lx, "

	       "buffer_size = 0x%x, period_size = 0x%x, bits=%d, rate=%d\n",

	       ptr1, ptr2, ptr, (int)runtime->buffer_size,

	       (int)runtime->period_size, (int)runtime->frame_bits,

	       (int)runtime->rate);

 operators */

 we don't need VRA */

	/*

	dev_dbg(emu->card->dev, "interrupt status = 0x%08x, stat76=0x%08x\n",

		   status, stat76);

	dev_dbg(emu->card->dev, "ptr=0x%08x\n",

		   snd_ca0106_ptr_read(chip, PLAYBACK_POINTER, 0));

 0x1 for one half, 0x10 for the other half period. */

 FIXME: Select the correct substream for period elapsed */

 dev_dbg(emu->card->dev, "interrupt [%d] used\n", i); */

		/*

		dev_dbg(emu->card->dev, "channel=%p\n", pchannel);

		dev_dbg(emu->card->dev, "interrupt stat76[%d] = %08x, use=%d, channel=%d\n", i, stat76, pchannel->use, pchannel->number);

 0x1 for one half, 0x10 for the other half period. */

 FIXME: Select the correct substream for period elapsed */

 dev_dbg(emu->card->dev, "interrupt [%d] used\n", i); */

		/*

		dev_dbg(emu->card->dev, "channel=%p\n", pchannel);

		dev_dbg(emu->card->dev, "interrupt stat76[%d] = %08x, use=%d, channel=%d\n", i, stat76, pchannel->use, pchannel->number);

 acknowledge the interrupt if necessary

 0dB dig. attenuation */

 Reset */

 Timeout */

 Interface control */

 Master mode control */

 Powerdown control */

 Attenuation Left  0x01 = -103dB, 0xff = 24dB */

 Attenuation Right 0.5dB steps */

 ALC Control 1 */

 ALC Control 2 */

 ALC Control 3 */

 Noise gate control */

 Limiter control */

 ADC Mixer control */

	/*

	 *  Init to 0x02109204 :

	 *  Clock accuracy    = 0     (1000ppm)

	 *  Sample Rate       = 2     (48kHz)

	 *  Audio Channel     = 1     (Left of 2)

	 *  Source Number     = 0     (Unspecified)

	 *  Generation Status = 1     (Original for Cat Code 12)

	 *  Cat Code          = 12    (Digital Signal Mixer)

	 *  Mode              = 0     (Mode 0)

	 *  Emphasis          = 0     (None)

	 *  CP                = 1     (Copyright unasserted)

	 *  AN                = 0     (Audio data)

	 *  P                 = 0     (Consumer)

 Only SPCS1 has been tested */

 Write 0x8000 to AC97_REC_GAIN to mute it. */

 FIXME: what are these? */

 OSS drivers set this. */

 snd_ca0106_ptr_write(chip, SPDIF_SELECT2, 0, 0xf0f003f); */

 Analog or Digital output */

	/* 0x0b000000 for digital, 0x000b0000 for analog, from win2000 drivers.

	 * Use 0x000f0000 for surround71

 Set digital SPDIF output off */

snd_ca0106_ptr_write(chip, 0x45, 0, 0);*/ 
snd_ca0106_ptr_write(chip, 0x45, 0, 0xf00);*/ 
 goes to 0x40c80000 when doing SPDIF IN/OUT */

	/* (Mute) CAPTURE feedback into PLAYBACK volume.

	 * Only lower 16 bits matter.

 SPDIF IN Volume */

 SPDIF IN Volume, 0x70 = (vol & 0x3f) | 0x40 */

 Only high 16 bits matter */

 Mute */

 Select MIC, Line in, TAD in, AUX in */

 Default to CAPTURE_SOURCE to i2s in */

 Default to AC97 in */

 Default to CAPTURE_SOURCE to AC97 in */

 Select MIC, Line in, TAD in, AUX in */

 Default to Set CAPTURE_SOURCE to i2s in */

 The SB0438 use GPIO differently. */

		/* FIXME: Still need to find out what the other GPIO bits do.

		 * E.g. For digital spdif out.

 outl(0x00f0e000, chip->port+GPIO); */ 
 Analog */

 The SB0410 and SB0413 use GPIO differently. */

		/* FIXME: Still need to find out what the other GPIO bits do.

		 * E.g. For digital spdif out.

 outl(0x00f0e000, chip->port+GPIO); */ 
 Analog */

 Analog */

 outl(0x005f02a2, chip->port+GPIO); */ 
 Win2000 uses 0x1e0 */

 outl(HCFG_LOCKSOUNDCACHE|HCFG_AUDIOENABLE, chip->port+HCFG); */

 0x1000 causes AC3 to fails. Maybe it effects 24 bit output. */

 outl(0x00001409, chip->port+HCFG); */

 outl(0x00000009, chip->port+HCFG); */

 AC97 2.0, Enable outputs. */

 The SB0410 and SB0413 use I2C to control ADC. */

 dev_dbg(emu->card->dev, "I2C:array size=0x%x\n", size); */

 Line in */

 Enable Line-in capture. MIC in currently untested. */

 snd_ca0106_i2c_write(chip, ADC_MUX, ADC_MUX_LINEIN); */

 The SB0570 use SPI to control DAC. */

 Enable front dac only */

 disable interrupts */

 disable audio */

 outl(HCFG_LOCKSOUNDCACHE, chip->port + HCFG); */

	/* FIXME: We need to stop and DMA transfers here.

	 *        But as I am not sure how yet, we cannot from the dma pages.

	 * So we can fix: snd-malloc: Memory leak?  pages not freed = 8

 This stores the periods table. */

 read serial */

 The SB0410 and SB0413 do not have an AC97 chip. */

 PCI IDs

 Audigy LS or Live 24bit */

 pci_driver definition

 SPDX-License-Identifier: GPL-2.0

 Playback */

 capture */

 SPDX-License-Identifier: GPL-2.0-or-later

/* 

 * Driver for NeoMagic 256AV and 256ZX chipsets.

 * Copyright (c) 2000 by Takashi Iwai <tiwai@suse.de>

 *

 * Based on nm256_audio.c OSS driver in linux kernel.

 * The original author of OSS nm256 driver wishes to remain anonymous,

 * so I just put my acknoledgment to him/her here.

 * The original author's web page is found at

 *	http://www.uglx.org/sony.html

/*

 * some compile conditions.

 Index */

 ID for this card */

 disabled as default */

 not specified */

 disabled */

 disabled */

 just for backward compatibility */

/*

 * hw definitions

 The BIOS signature. */

 Signature mask. */

 Size of the second memory area. */

 The base offset of the mixer in the second memory area. */

 The maximum size of a coefficient entry. */

 The interrupt register. */

 And its bits. */

 The AV's "mixer ready" status bit and location. */

/*

 * For the ZX.  It uses the same interrupt register, but it holds 32

 * bits instead of 16.

 The ZX's "mixer ready" status bit and location. */

 The playback registers start from here. */

 The record registers start from here. */

 The rate register is located 2 bytes from the start of the register area. */

 Mono/stereo flag, number of bits on playback, and rate mask. */

 Playback enable register. */

 Mutes the audio output. */

 Recording enable register. */

 coefficient buffer pointer */

 DMA buffer offsets */

 offset from chip->buffer */

 buffer size in bytes */

 mapped pointer */

 physical address of the mapped pointer */

 buffer size of the substream in bytes */

 period size in bytes */

 # of periods */

 bit shifts */

 current period # */

 control port */

 physical address */

 buffer */

 buffer phyiscal address */

 start offset from pci resource 0 */

 end offset */

 total buffer size */

 coefficient buffer */

 coefficient buffer for each stream */

 coeff. table is loaded? */

 use one big coef. table */

 Workaround for some laptops to avoid freeze */

 Extended workaround for some other laptops to avoid freeze */

 register offset of ac97 mixer */

 offset of mixer status reg. */

 bit mask to test the mixer status */

 counter to check bogus interrupts */

 register caches, only for valid regs */

/*

 * include coefficient table

/*

 * PCI ids

/*

 * lowlvel stuffs

/*

 * coefficient handlers -- what a magic!

 ???  Record seems to behave differently than playback.  */

 The enable register for the specified engine.  */

 The recording engine uses coefficient values 8-15.  */

 The actual rates supported by the card. */

/*

 * return the index of the target rate

/*

 * set sample rate and format

 0 = playback */

 1 = record */

 acquire interrupt */

 release interrupt */

/*

 * start / stop

 update the watermark (current period) */

 program buffer pointers */

 Enable playback engine and interrupts. */

 Enable both channels. */

 program buffer pointers */

 Enable playback engine and interrupts. */

 Stop the play engine. */

 Shut off sound from both channels. */

 Disable play engine. */

 Disable recording engine. */

/*

 * prepare playback/capture channel

/*

 * get the current pointer

 Remapped I/O space can be accessible as pointer on i386 */

 This might be changed in the future */

/*

 * silence / copy for playback

/*

 * copy to user

 !__i386__ */

/*

 * update playback/capture watermarks

 spinlock held! */

 spinlock held! */

/*

 * hardware info

SNDRV_PCM_INFO_PAUSE |*/

24k*/ | SNDRV_PCM_RATE_8000_48000,

SNDRV_PCM_INFO_PAUSE |*/

24k*/ | SNDRV_PCM_RATE_8000_48000,

 set dma transfer size */

 area and addr are already set and unchanged */

/*

 * open

/*

 * close - we don't have to do special..

/*

 * create a pcm instance

/* 

 * Initialize the hardware. 

 Reset everything. */

 stop sounds.. */

snd_nm256_playback_stop(chip);

snd_nm256_capture_stop(chip);

		/*

		 * I'm not sure if the best thing is to stop the card from

		 * playing or just release the interrupt (after all, we're in

		 * a bad situation, so doing fancy stuff may not be such a good

		 * idea).

		 *

		 * I worry about the card engine continuing to play noise

		 * over and over, however--that could become a very

		 * obnoxious problem.  And we know that when this usually

		 * happens things are fairly safe, it just means the user's

		 * inserted a PCMCIA card and someone's spamming us with IRQ 9s.

/* 

 * Handle a potential interrupt for the device referred to by DEV_ID. 

 *

 * I don't like the cut-n-paste job here either between the two routines,

 * but there are sufficient differences between the two interrupt handlers

 * that parameterizing it isn't all that great either.  (Could use a macro,

 * I suppose...yucky bleah.)

 Not ours. */

 Rather boring; check for individual interrupts and process them. */

 Unknown interrupt. */

 Pray. */

/*

 * Handle a potential interrupt for the device referred to by DEV_ID.

 * This handler is for the 256ZX, and is very similar to the non-ZX

 * routine.

 Not ours. */

 Rather boring; check for individual interrupts and process them. */

 Unknown interrupt. */

 Pray. */

/*

 * AC97 interface

/*

 * Waits for the mixer to become ready to be written; returns a zero value

 * if it timed out.

	/* 

	 * Loop around waiting for the mixer to become ready. 

/* 

 * Initial register values to be written to the AC97 mixer.

 * While most of these are identical to the reset values, we do this

 * so that we have most of the register contents cached--this avoids

 * reading from the mixer directly (which seems to be problematic,

 * probably due to ignorance).

/*

 * some nm256 easily crash when reading from mixer registers

 * thus we're treating it as a write-only mixer and cache the

 * written values

/* 

 Wait for the write to take, too. */

 a little delay here seems better.. */

 successful write: set cache */

 static resolution table */

 terminator */

 initialize the ac97 into a known state */

 Reset the mixer.  'Tis magic!  */

 Dell latitude LS will lock up by this */

 Dell latitude CSx will lock up by this */

			/* preload the cache, so as to avoid even a single

			 * read of the mixer regs

 create an ac97 mixer interface */

 we support audio! */

 looks like an invalid id */

/* 

 * See if the signature left by the NM256 BIOS is intact; if so, we use

 * the associated address as the end of our audio buffer in the video

 * RAM.

 The signature is located 1K below the end of video RAM.  */

 Default buffer end is 5120 bytes below the top of RAM.  */

		/*

		 * If it's obviously invalid, don't use it

/*

 * APM event handler, so the card is properly reinitialized after a power

 * event.

 Perform a full reset on the hardware */

 restore ac97 */

 CONFIG_PM_SLEEP */

 store buffer sizes in bytes */

	/* 

	 * The NM256 has two memory ports.  The first port is nothing

	 * more than a chunk of video RAM, which is used as the I/O ring

	 * buffer.  The second port has the actual juicy stuff (like the

	 * mixer and the playback engine control registers).

 Init the memory port info.  */

 remap control port (#2) */

 Ok, try to see if this is a non-AC97 version of the hardware. */

 Not sure if there is any relevant detect for the ZX or not.  */

 get buffer end pointer from signature */

 set offsets */

 Fixed setting. */

 pci_set_master(pci); /* needed? */

 HP omnibook 4150 has cs4232 codec internally */

 Reset workarounds to avoid lock-ups */

 terminator */

 this avoids conflicts with XFree86 server */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Driver for Digigram VX222 V2/Mic PCI soundcards

 *

 * Copyright (c) 2002 by Takashi Iwai <tiwai@suse.de>

 Index 0-MAX */

 ID for this card */

 Enable this card */

 microphone */

 microphone */

/*

 PLX */

 PLX */

/*

 hw specs */

 hw specs */

 hw specs */

/*

 enable PCI device */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Driver for Digigram VX222 V2/Mic soundcards

 *

 * VX222-specific low-level routines

 *

 * Copyright (c) 2002 by Takashi Iwai <tiwai@suse.de>

 Write: POTENTIOMETER ; Read: COMPRESSION LEVEL activate

 Read: COMPRESSION THRESHOLD activate

 Read: LEVEL LIMITATION activate

 VX_INTCSR_REGISTER_OFFSET

 VX_CNTRL_REGISTER_OFFSET

 VX_GPIOC (new with PLX9030)

 on the PLX */

 on the PLX */

 on the PLX */

/**

 * vx2_inb - read a byte from the register

 * @chip: VX core instance

 * @offset: register enum

/**

 * vx2_outb - write a byte on the register

 * @chip: VX core instance

 * @offset: the register offset

 * @val: the value to write

	/*

	dev_dbg(chip->card->dev, "outb: %x -> %x\n", val, vx2_reg_addr(chip, offset));

/**

 * vx2_inl - read a 32bit word from the register

 * @chip: VX core instance

 * @offset: register enum

/**

 * vx2_outl - write a 32bit word on the register

 * @chip: VX core instance

 * @offset: the register enum

 * @val: the value to write

	/*

	dev_dbg(chip->card->dev, "outl: %x -> %x\n", val, vx2_reg_addr(chip, offset));

/*

 * redefine macros to call directly

/*

 * vx_reset_dsp - reset the DSP

 ms */

 set the reset dsp bit to 0 */

 set the reset dsp bit to 1 */

	/* This test uses several write/read sequences on TEST0 and TEST1 bits

	 * to figure out whever or not the xilinx was correctly loaded

 We write 1 on CDSP.TEST0. We should get 0 on STATUS.TEST0. */

 We write 0 on CDSP.TEST0. We should get 1 on STATUS.TEST0. */

 not implemented on VX_2_BOARDS */

 We write 1 on CDSP.TEST1. We should get 0 on STATUS.TEST1. */

 We write 0 on CDSP.TEST1. We should get 1 on STATUS.TEST1. */

/**

 * vx2_setup_pseudo_dma - set up the pseudo dma read/write mode.

 * @chip: VX core instance

 * @do_write: 0 = read, 1 = set up for DMA write

	/* Interrupt mode and HREQ pin enabled for host transmit data transfers

	 * (in case of the use of the pseudo-dma facility).

	/* Reset the pseudo-dma register (in case of the use of the

	 * pseudo-dma facility).

/*

 * vx_release_pseudo_dma - disable the pseudo-DMA mode

 HREQ pin disabled. */

 pseudo-dma write */

	/* Transfer using pseudo-dma.

 in 32bit words */

 Transfer using pseudo-dma. */

 in 32bit words */

 Transfer using pseudo-dma. */

 pseudo dma read */

	/* Transfer using pseudo-dma.

 in 32bit words */

 Transfer using pseudo-dma. */

 in 32bit words */

 Transfer using pseudo-dma. */

/*

 * transfer counts bits to PLX

 set the clock bit to 0. */

 set the clock bit to 1. */

/*

 * load the xilinx image

 XILINX reset (wait at least 1 millisecond between reset on and off). */

 VX222 V2 and VX222_MIC_BOARD with new PLX9030 use this register */

 don't take too much time in this loop... */

 end signature */

 test after loading (is buggy with VX222) */

 Test if load successful: test bit 8 of register GPIOC (VX222: use CNTRL) ! */

/*

 * load the boot/dsp images

 xilinx image */

 DSP boot */

 DSP image */

/*

 * vx_test_and_ack - test and acknowledge interrupt

 *

 * called from irq hander, too

 *

 * spinlock held!

 not booted yet? */

 ok, interrupts generated, now ack it */

 set ACQUIT bit up and down */

	/* useless read just to spend some time and maintain

	 * the ACQUIT signal up for a while ( a bus cycle )

 ack */

	/* useless read just to spend some time and maintain

 clear */

/*

 * vx_validate_irq - enable/disable IRQ

 Set the interrupt enable bit to 1 in CDSP register */

 Set the PCI interrupt enable bit to 1.*/

 Set the PCI interrupt enable bit to 0. */

/*

 * write an AKM codec data (24bit)

 We have to send 24 bits (3 x 8 bits). Start with most signif. Bit */

 Terminate access to codec registers */

 [000] =  +0.000 dB  ->  AKM(0x7f) =  +0.000 dB  error(+0.000 dB)

 [001] =  -0.500 dB  ->  AKM(0x7d) =  -0.572 dB  error(-0.072 dB)

 [002] =  -1.000 dB  ->  AKM(0x7c) =  -0.873 dB  error(+0.127 dB)

 [003] =  -1.500 dB  ->  AKM(0x7a) =  -1.508 dB  error(-0.008 dB)

 [004] =  -2.000 dB  ->  AKM(0x79) =  -1.844 dB  error(+0.156 dB)

 [005] =  -2.500 dB  ->  AKM(0x77) =  -2.557 dB  error(-0.057 dB)

 [006] =  -3.000 dB  ->  AKM(0x76) =  -2.937 dB  error(+0.063 dB)

 [007] =  -3.500 dB  ->  AKM(0x75) =  -3.334 dB  error(+0.166 dB)

 [008] =  -4.000 dB  ->  AKM(0x73) =  -4.188 dB  error(-0.188 dB)

 [009] =  -4.500 dB  ->  AKM(0x72) =  -4.648 dB  error(-0.148 dB)

 [010] =  -5.000 dB  ->  AKM(0x71) =  -5.134 dB  error(-0.134 dB)

 [011] =  -5.500 dB  ->  AKM(0x70) =  -5.649 dB  error(-0.149 dB)

 [012] =  -6.000 dB  ->  AKM(0x6f) =  -6.056 dB  error(-0.056 dB)

 [013] =  -6.500 dB  ->  AKM(0x6d) =  -6.631 dB  error(-0.131 dB)

 [014] =  -7.000 dB  ->  AKM(0x6c) =  -6.933 dB  error(+0.067 dB)

 [015] =  -7.500 dB  ->  AKM(0x6a) =  -7.571 dB  error(-0.071 dB)

 [016] =  -8.000 dB  ->  AKM(0x69) =  -7.909 dB  error(+0.091 dB)

 [017] =  -8.500 dB  ->  AKM(0x67) =  -8.626 dB  error(-0.126 dB)

 [018] =  -9.000 dB  ->  AKM(0x66) =  -9.008 dB  error(-0.008 dB)

 [019] =  -9.500 dB  ->  AKM(0x65) =  -9.407 dB  error(+0.093 dB)

 [020] = -10.000 dB  ->  AKM(0x64) =  -9.826 dB  error(+0.174 dB)

 [021] = -10.500 dB  ->  AKM(0x62) = -10.730 dB  error(-0.230 dB)

 [022] = -11.000 dB  ->  AKM(0x61) = -11.219 dB  error(-0.219 dB)

 [023] = -11.500 dB  ->  AKM(0x60) = -11.738 dB  error(-0.238 dB)

 [024] = -12.000 dB  ->  AKM(0x5f) = -12.149 dB  error(-0.149 dB)

 [025] = -12.500 dB  ->  AKM(0x5e) = -12.434 dB  error(+0.066 dB)

 [026] = -13.000 dB  ->  AKM(0x5c) = -13.033 dB  error(-0.033 dB)

 [027] = -13.500 dB  ->  AKM(0x5b) = -13.350 dB  error(+0.150 dB)

 [028] = -14.000 dB  ->  AKM(0x59) = -14.018 dB  error(-0.018 dB)

 [029] = -14.500 dB  ->  AKM(0x58) = -14.373 dB  error(+0.127 dB)

 [030] = -15.000 dB  ->  AKM(0x56) = -15.130 dB  error(-0.130 dB)

 [031] = -15.500 dB  ->  AKM(0x55) = -15.534 dB  error(-0.034 dB)

 [032] = -16.000 dB  ->  AKM(0x54) = -15.958 dB  error(+0.042 dB)

 [033] = -16.500 dB  ->  AKM(0x53) = -16.404 dB  error(+0.096 dB)

 [034] = -17.000 dB  ->  AKM(0x52) = -16.874 dB  error(+0.126 dB)

 [035] = -17.500 dB  ->  AKM(0x51) = -17.371 dB  error(+0.129 dB)

 [036] = -18.000 dB  ->  AKM(0x50) = -17.898 dB  error(+0.102 dB)

 [037] = -18.500 dB  ->  AKM(0x4e) = -18.605 dB  error(-0.105 dB)

 [038] = -19.000 dB  ->  AKM(0x4d) = -18.905 dB  error(+0.095 dB)

 [039] = -19.500 dB  ->  AKM(0x4b) = -19.538 dB  error(-0.038 dB)

 [040] = -20.000 dB  ->  AKM(0x4a) = -19.872 dB  error(+0.128 dB)

 [041] = -20.500 dB  ->  AKM(0x48) = -20.583 dB  error(-0.083 dB)

 [042] = -21.000 dB  ->  AKM(0x47) = -20.961 dB  error(+0.039 dB)

 [043] = -21.500 dB  ->  AKM(0x46) = -21.356 dB  error(+0.144 dB)

 [044] = -22.000 dB  ->  AKM(0x44) = -22.206 dB  error(-0.206 dB)

 [045] = -22.500 dB  ->  AKM(0x43) = -22.664 dB  error(-0.164 dB)

 [046] = -23.000 dB  ->  AKM(0x42) = -23.147 dB  error(-0.147 dB)

 [047] = -23.500 dB  ->  AKM(0x41) = -23.659 dB  error(-0.159 dB)

 [048] = -24.000 dB  ->  AKM(0x40) = -24.203 dB  error(-0.203 dB)

 [049] = -24.500 dB  ->  AKM(0x3f) = -24.635 dB  error(-0.135 dB)

 [050] = -25.000 dB  ->  AKM(0x3e) = -24.935 dB  error(+0.065 dB)

 [051] = -25.500 dB  ->  AKM(0x3c) = -25.569 dB  error(-0.069 dB)

 [052] = -26.000 dB  ->  AKM(0x3b) = -25.904 dB  error(+0.096 dB)

 [053] = -26.500 dB  ->  AKM(0x39) = -26.615 dB  error(-0.115 dB)

 [054] = -27.000 dB  ->  AKM(0x38) = -26.994 dB  error(+0.006 dB)

 [055] = -27.500 dB  ->  AKM(0x37) = -27.390 dB  error(+0.110 dB)

 [056] = -28.000 dB  ->  AKM(0x36) = -27.804 dB  error(+0.196 dB)

 [057] = -28.500 dB  ->  AKM(0x34) = -28.699 dB  error(-0.199 dB)

 [058] = -29.000 dB  ->  AKM(0x33) = -29.183 dB  error(-0.183 dB)

 [059] = -29.500 dB  ->  AKM(0x32) = -29.696 dB  error(-0.196 dB)

 [060] = -30.000 dB  ->  AKM(0x31) = -30.241 dB  error(-0.241 dB)

 [061] = -30.500 dB  ->  AKM(0x31) = -30.241 dB  error(+0.259 dB)

 [062] = -31.000 dB  ->  AKM(0x30) = -30.823 dB  error(+0.177 dB)

 [063] = -31.500 dB  ->  AKM(0x2e) = -31.610 dB  error(-0.110 dB)

 [064] = -32.000 dB  ->  AKM(0x2d) = -31.945 dB  error(+0.055 dB)

 [065] = -32.500 dB  ->  AKM(0x2b) = -32.659 dB  error(-0.159 dB)

 [066] = -33.000 dB  ->  AKM(0x2a) = -33.038 dB  error(-0.038 dB)

 [067] = -33.500 dB  ->  AKM(0x29) = -33.435 dB  error(+0.065 dB)

 [068] = -34.000 dB  ->  AKM(0x28) = -33.852 dB  error(+0.148 dB)

 [069] = -34.500 dB  ->  AKM(0x27) = -34.289 dB  error(+0.211 dB)

 [070] = -35.000 dB  ->  AKM(0x25) = -35.235 dB  error(-0.235 dB)

 [071] = -35.500 dB  ->  AKM(0x24) = -35.750 dB  error(-0.250 dB)

 [072] = -36.000 dB  ->  AKM(0x24) = -35.750 dB  error(+0.250 dB)

 [073] = -36.500 dB  ->  AKM(0x23) = -36.297 dB  error(+0.203 dB)

 [074] = -37.000 dB  ->  AKM(0x22) = -36.881 dB  error(+0.119 dB)

 [075] = -37.500 dB  ->  AKM(0x21) = -37.508 dB  error(-0.008 dB)

 [076] = -38.000 dB  ->  AKM(0x20) = -38.183 dB  error(-0.183 dB)

 [077] = -38.500 dB  ->  AKM(0x1f) = -38.726 dB  error(-0.226 dB)

 [078] = -39.000 dB  ->  AKM(0x1e) = -39.108 dB  error(-0.108 dB)

 [079] = -39.500 dB  ->  AKM(0x1d) = -39.507 dB  error(-0.007 dB)

 [080] = -40.000 dB  ->  AKM(0x1c) = -39.926 dB  error(+0.074 dB)

 [081] = -40.500 dB  ->  AKM(0x1b) = -40.366 dB  error(+0.134 dB)

 [082] = -41.000 dB  ->  AKM(0x1a) = -40.829 dB  error(+0.171 dB)

 [083] = -41.500 dB  ->  AKM(0x19) = -41.318 dB  error(+0.182 dB)

 [084] = -42.000 dB  ->  AKM(0x18) = -41.837 dB  error(+0.163 dB)

 [085] = -42.500 dB  ->  AKM(0x17) = -42.389 dB  error(+0.111 dB)

 [086] = -43.000 dB  ->  AKM(0x16) = -42.978 dB  error(+0.022 dB)

 [087] = -43.500 dB  ->  AKM(0x15) = -43.610 dB  error(-0.110 dB)

 [088] = -44.000 dB  ->  AKM(0x14) = -44.291 dB  error(-0.291 dB)

 [089] = -44.500 dB  ->  AKM(0x14) = -44.291 dB  error(+0.209 dB)

 [090] = -45.000 dB  ->  AKM(0x13) = -45.031 dB  error(-0.031 dB)

 [091] = -45.500 dB  ->  AKM(0x12) = -45.840 dB  error(-0.340 dB)

 [092] = -46.000 dB  ->  AKM(0x12) = -45.840 dB  error(+0.160 dB)

 [093] = -46.500 dB  ->  AKM(0x11) = -46.731 dB  error(-0.231 dB)

 [094] = -47.000 dB  ->  AKM(0x11) = -46.731 dB  error(+0.269 dB)

 [095] = -47.500 dB  ->  AKM(0x10) = -47.725 dB  error(-0.225 dB)

 [096] = -48.000 dB  ->  AKM(0x10) = -47.725 dB  error(+0.275 dB)

 [097] = -48.500 dB  ->  AKM(0x0f) = -48.553 dB  error(-0.053 dB)

 [098] = -49.000 dB  ->  AKM(0x0e) = -49.152 dB  error(-0.152 dB)

 [099] = -49.500 dB  ->  AKM(0x0d) = -49.796 dB  error(-0.296 dB)

 [100] = -50.000 dB  ->  AKM(0x0d) = -49.796 dB  error(+0.204 dB)

 [101] = -50.500 dB  ->  AKM(0x0c) = -50.491 dB  error(+0.009 dB)

 [102] = -51.000 dB  ->  AKM(0x0b) = -51.247 dB  error(-0.247 dB)

 [103] = -51.500 dB  ->  AKM(0x0b) = -51.247 dB  error(+0.253 dB)

 [104] = -52.000 dB  ->  AKM(0x0a) = -52.075 dB  error(-0.075 dB)

 [105] = -52.500 dB  ->  AKM(0x0a) = -52.075 dB  error(+0.425 dB)

 [106] = -53.000 dB  ->  AKM(0x09) = -52.990 dB  error(+0.010 dB)

 [107] = -53.500 dB  ->  AKM(0x09) = -52.990 dB  error(+0.510 dB)

 [108] = -54.000 dB  ->  AKM(0x08) = -54.013 dB  error(-0.013 dB)

 [109] = -54.500 dB  ->  AKM(0x08) = -54.013 dB  error(+0.487 dB)

 [110] = -55.000 dB  ->  AKM(0x07) = -55.173 dB  error(-0.173 dB)

 [111] = -55.500 dB  ->  AKM(0x07) = -55.173 dB  error(+0.327 dB)

 [112] = -56.000 dB  ->  AKM(0x06) = -56.512 dB  error(-0.512 dB)

 [113] = -56.500 dB  ->  AKM(0x06) = -56.512 dB  error(-0.012 dB)

 [114] = -57.000 dB  ->  AKM(0x06) = -56.512 dB  error(+0.488 dB)

 [115] = -57.500 dB  ->  AKM(0x05) = -58.095 dB  error(-0.595 dB)

 [116] = -58.000 dB  ->  AKM(0x05) = -58.095 dB  error(-0.095 dB)

 [117] = -58.500 dB  ->  AKM(0x05) = -58.095 dB  error(+0.405 dB)

 [118] = -59.000 dB  ->  AKM(0x05) = -58.095 dB  error(+0.905 dB)

 [119] = -59.500 dB  ->  AKM(0x04) = -60.034 dB  error(-0.534 dB)

 [120] = -60.000 dB  ->  AKM(0x04) = -60.034 dB  error(-0.034 dB)

 [121] = -60.500 dB  ->  AKM(0x04) = -60.034 dB  error(+0.466 dB)

 [122] = -61.000 dB  ->  AKM(0x04) = -60.034 dB  error(+0.966 dB)

 [123] = -61.500 dB  ->  AKM(0x03) = -62.532 dB  error(-1.032 dB)

 [124] = -62.000 dB  ->  AKM(0x03) = -62.532 dB  error(-0.532 dB)

 [125] = -62.500 dB  ->  AKM(0x03) = -62.532 dB  error(-0.032 dB)

 [126] = -63.000 dB  ->  AKM(0x03) = -62.532 dB  error(+0.468 dB)

 [127] = -63.500 dB  ->  AKM(0x03) = -62.532 dB  error(+0.968 dB)

 [128] = -64.000 dB  ->  AKM(0x03) = -62.532 dB  error(+1.468 dB)

 [129] = -64.500 dB  ->  AKM(0x02) = -66.054 dB  error(-1.554 dB)

 [130] = -65.000 dB  ->  AKM(0x02) = -66.054 dB  error(-1.054 dB)

 [131] = -65.500 dB  ->  AKM(0x02) = -66.054 dB  error(-0.554 dB)

 [132] = -66.000 dB  ->  AKM(0x02) = -66.054 dB  error(-0.054 dB)

 [133] = -66.500 dB  ->  AKM(0x02) = -66.054 dB  error(+0.446 dB)

 [134] = -67.000 dB  ->  AKM(0x02) = -66.054 dB  error(+0.946 dB)

 [135] = -67.500 dB  ->  AKM(0x02) = -66.054 dB  error(+1.446 dB)

 [136] = -68.000 dB  ->  AKM(0x02) = -66.054 dB  error(+1.946 dB)

 [137] = -68.500 dB  ->  AKM(0x02) = -66.054 dB  error(+2.446 dB)

 [138] = -69.000 dB  ->  AKM(0x02) = -66.054 dB  error(+2.946 dB)

 [139] = -69.500 dB  ->  AKM(0x01) = -72.075 dB  error(-2.575 dB)

 [140] = -70.000 dB  ->  AKM(0x01) = -72.075 dB  error(-2.075 dB)

 [141] = -70.500 dB  ->  AKM(0x01) = -72.075 dB  error(-1.575 dB)

 [142] = -71.000 dB  ->  AKM(0x01) = -72.075 dB  error(-1.075 dB)

 [143] = -71.500 dB  ->  AKM(0x01) = -72.075 dB  error(-0.575 dB)

 [144] = -72.000 dB  ->  AKM(0x01) = -72.075 dB  error(-0.075 dB)

 [145] = -72.500 dB  ->  AKM(0x01) = -72.075 dB  error(+0.425 dB)

 [146] = -73.000 dB  ->  AKM(0x01) = -72.075 dB  error(+0.925 dB)

 [147] = -73.500 dB  ->  AKM(0x00) =  mute       error(+infini)

/*

 * pseudo-codec write entry

	/* `data' is a value between 0x0 and VX2_AKM_LEVEL_MAX = 0x093, in the case of the AKM codecs, we need

	   a look up table, as there is no linear matching between the driver codec values

	   and the real dBu value

/*

 * write codec bit for old VX222 board

 activate access to codec registers */

 Terminate access to codec registers */

/*

 * reset codec bit

 Set the reset CODEC bit to 0. */

 Set the reset CODEC bit to 1. */

 additionnel wait time for AKM's */

 DAC power up, ADC power up, Vref power down */

 default */

 Mute = ON ,Deemphasis = OFF */

 DAC and ADC normal operation */

 set up the micro input selector */

 reset phantom power supply */

/*

 * change the audio source

/*

 * set the clock source

/*

 * reset the board

 initialize the register values */

/*

 * input level controls for VX222 Mic

/* Micro level is specified to be adjustable from -96dB to 63 dB (board coded 0x00 ... 318),

 * 318 = 210 + 36 + 36 + 36   (210 = +9dB variable) (3 * 36 = 3 steps of 18dB pre ampli)

 * as we will mute if less than -110dB, so let's simply use line input coded levels and add constant offset !

 add 318 - 0xff */

 limitation to +9dB of 3310 real gain */

 raise pre ampli + 18dB */

 lower level 18 dB (*2 because of 0.5 dB steps !) */

 set pre-amp level */

 Activate input level programming */

 We have to send 32 bits (4 x 8 bits) */

 Terminate input level programming */

/*

 * controls API for input levels

 input levels */

 mic level */

/*

 * FIXME: compressor/limiter implementation is missing yet...

 mute input levels */

 controls */

/*

 * callbacks

 for old VX222 board */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>

 *  Universal interface for Audio Codec '97

 *

 *  For more details look to AC '97 component specification revision 2.2

 *  by Intel Corporation (http://developer.intel.com).

/*



/*

 * This is an _inofficial_ Aztech Labs entry

 * (value might differ from unknown official Aztech ID),

 * currently used by the AC97 emulation of the almost-AC97 PCI168 card.

 already patched */

 already patched */

 already patched */

 already patched */

 SmartMC II

 SmartAMC fixme: the mask might be different

 same as TR28028?

 alias VIA VT1611A?

 VT1616 compatible (chipset integrated)

 only guess --jk

 volume wrap fix 

 added by xin jin [07/09/99]

 only guess --jk [TR28023 = eMicro EM28023 (new CT1297)]

 modified ICE1232 with S/PDIF

 modified VT1616 with S/PDIF

 patch?

 patch?

 patch?

/*

 *  I/O routines

 filter some registers for buggy codecs */

 AD1819 */

 AD1881 */

 AD1881A */

 0x59 */

 AD1885 */

 AD1886 */

 AD1886A - !!verify!! --jk */

 AD1887 - !!verify!! --jk */

 0x59 */

/**

 * snd_ac97_write - write a value on the given register

 * @ac97: the ac97 instance

 * @reg: the register to change

 * @value: the value to set

 *

 * Writes a value on the given register.  This will invoke the write

 * callback directly after the register check.

 * This function doesn't change the register cache unlike

 * #snd_ca97_write_cache(), so use this only when you don't want to

 * reflect the change to the suspend/resume state.

 Fix H/W bug of ALC100/100P */

 reset audio codec */

/**

 * snd_ac97_read - read a value from the given register

 * 

 * @ac97: the ac97 instance

 * @reg: the register to read

 *

 * Reads a value from the given register.  This will invoke the read

 * callback directly after the register check.

 *

 * Return: The read value.

 read a register - return the cached value if already read */

 set_bit(reg, ac97->reg_accessed);

/**

 * snd_ac97_write_cache - write a value on the given register and update the cache

 * @ac97: the ac97 instance

 * @reg: the register to change

 * @value: the value to set

 *

 * Writes a value on the given register and updates the register

 * cache.  The cached values are used for the cached-read and the

 * suspend/resume.

/**

 * snd_ac97_update - update the value on the given register

 * @ac97: the ac97 instance

 * @reg: the register to change

 * @value: the value to set

 *

 * Compares the value with the register cache and updates the value

 * only when the value is changed.

 *

 * Return: 1 if the value is changed, 0 if no change, or a negative

 * code on failure.

/**

 * snd_ac97_update_bits - update the bits on the given register

 * @ac97: the ac97 instance

 * @reg: the register to change

 * @mask: the bit-mask to change

 * @value: the value to set

 *

 * Updates the masked-bits on the given register only when the value

 * is changed.

 *

 * Return: 1 if the bits are changed, 0 if no change, or a negative

 * code on failure.

 no lock version - see snd_ac97_update_bits() */

 select single codec */

 update PCM bits */

 select all codecs */

/*

 * Controls

 save/restore ac97 v2.3 paging */

 lock paging */

 unlock paging */

 volume and switch controls */

 check analog mixer power-down */

 change the existing EAPD control as inverted */

 EAPD up */

 FIXME: AC'97 spec doesn't say which bits are used for what */

 category + original

 44.1

 48.0

 illegal.

 turn off */

 turn on again */

 int invert = (kcontrol->private_value >> 24) & 0xff;

 turn off */

 turn on again */

/*

 *

 for avoiding click noises during shut down */

 if nonzero - fixed and we can't set it */

 center */

 lfe */

 nothing seems to be here - mute flag is not set */

 try another test */

 nothing here */

 success, useable */

 first look up the static resolution table */

		/* Do the read twice due to buffers on some ac97 codecs.

		 * e.g. The STAC9704 returns exactly what you wrote to the register

		 * if you read it immediately. This causes the detect routine to fail.

 check the volume resolution of center/lfe */

 reset volume to zero */

/*

 * create mute switch(es) for normal stereo controls

 check whether both mute bits work */

 mute as default */

/*

 * set dB information

/*

 * create a volume for normal stereo/mono controls

 invert */

 invert */

/*

 * create a mute-switch and a volume for normal stereo/mono controls

 build master controls */

 AD claims to remove this control from AD1887, although spec v2.2 does not allow this */

 build center controls */

 build LFE controls */

 build surround controls */

 Surround Master (0x38) is with stereo mutes */

 build headphone controls */

 build master mono controls */

 build master tone controls */

 build Beep controls */

 build Phone controls */

 build MIC controls */

 build Line controls */

 build CD controls */

 build Video controls */

 build Aux controls */

 build PCM controls */

 build Capture controls */

 build MIC Capture controls */

 build PCM out path & mute control */

 build Simulated Stereo Enhancement control */

 build 3D Stereo Enhancement control */

 build Loudness control */

 build Mono output select control */

 build Mic select control */

 build ADC/DAC loopback control */

 build 3D controls */

 build S/PDIF controls */

 Hack for ASUS P5P800-VM, which does not indicate S/PDIF capability */

 set default PCM S/PDIF params */

 consumer,PCM audio,no copyright,no preemphasis,PCM coder,original,48000Hz */

 build chip specific controls */

	/*

	ac97_dbg(ac97, "AC97_GPIO_CFG = %x\n",

	       snd_ac97_read(ac97,AC97_GPIO_CFG));

 build modem switches */

 build chip specific controls */

 test a non-standard rate */

 let's try to obtain standard rates */

 test standard double rates */

 some codecs don't support variable double rates */

 restore the default value */

 check AC97_SPDIF register to accept which sample rates */

 look for the codec id table matching with the given id */

/**

 * snd_ac97_get_short_name - retrieve codec name

 * @ac97: the codec instance

 *

 * Return: The short identifying name of the codec.

/* wait for a while until registers are accessible after RESET

 * return 0 if ok, negative not ready

 use preliminary reads to settle the communication */

 modem? */

 probably only Xbox issue - all registers are read as zero */

			/* because the PCM or MASTER volume registers can be modified,

			 * the REC_GAIN register is used for tests

 test if we can write to the record gain volume register */

/**

 * snd_ac97_bus - create an AC97 bus component

 * @card: the card instance

 * @num: the bus number

 * @ops: the bus callbacks table

 * @private_data: private data pointer for the new instance

 * @rbus: the pointer to store the new AC97 bus instance.

 *

 * Creates an AC97 bus component.  An struct snd_ac97_bus instance is newly

 * allocated and initialized.

 *

 * The ops table must include valid callbacks (at least read and

 * write).  The other callbacks, wait and reset, are not mandatory.

 * 

 * The clock is set to 48000.  If another clock is needed, set

 * ``(*rbus)->clock`` manually.

 *

 * The AC97 bus instance is registered as a low-level device, so you don't

 * have to release it manually.

 *

 * Return: Zero if successful, or a negative error code on failure.

 stop no dev release warning */

 register ac97 codec to bus */

 disconnect ac97 codec */

 build_ops to do nothing */

/**

 * snd_ac97_mixer - create an Codec97 component

 * @bus: the AC97 bus which codec is attached to

 * @template: the template of ac97, including index, callbacks and

 *         the private data.

 * @rac97: the pointer to store the new ac97 instance.

 *

 * Creates an Codec97 component.  An struct snd_ac97 instance is newly

 * allocated and initialized from the template.  The codec

 * is then initialized by the standard procedure.

 *

 * The template must include the codec number (num) and address (addr),

 * and the private data (private_data).

 * 

 * The ac97 instance is registered as a low-level device, so you don't

 * have to release it manually.

 *

 * Return: Zero if successful, or a negative error code on failure.

 reset to defaults */

 proceed anyway - it's often non-critical */

 test for AC'97 */

 test if we can write to the record gain volume register */

 invalid combination */

 test for MC'97 */

 invalid combination */

 FIXME: always skipping?

 FIXME: add powerdown control */

 nothing should be in powerdown mode */

 reset to defaults */

 nothing should be in powerdown mode */

 FIXME: add powerdown control */

 nothing should be in powerdown mode */

 note: it's important to set the rate at first */

 nothing should be in powerdown mode */

 L/R, MIC, SDAC, LDAC VRA support */

 LDAC/SDAC/CDAC */

 VRA/VRM */

		/* Intel controllers require double rate data to be put in

 restore to slots 10/11 to avoid the confliction with surrounds */

 VRA support */

 codec specific code (patch) should override these values */

 MIC VRA support */

 SDAC support */

 LDAC support */

 additional initializations */

 ac97->id might be changed in the special setup code

/*

 * Power down the chip.

 *

 * MASTER and HEADPHONE registers are muted but the register cache values

 * are not changed, so that the values can be restored in snd_ac97_resume().

 some codecs have stereo mute bits */

 surround, CLFE, mic powerdown */

 powerdown external amplifier */

 Headphone amplifier powerdown */

 ADC & DAC powerdown */

 Analog Mixer powerdown (Vref on) */

 Analog Mixer powerdown */

 AC-link powerdown, internal Clk disable */

 FIXME: this may cause click noises on some boards */

/**

 * snd_ac97_update_power - update the powerdown register

 * @ac97: the codec instance

 * @reg: the rate register, e.g. AC97_PCM_FRONT_DAC_RATE

 * @powerup: non-zero when power up the part

 *

 * Update the AC97 powerdown register bits of the given part.

 *

 * Return: Zero.

 SPDIF requires DAC power, too */

		/* adjust power-down bits after two seconds delay

		 * (for avoiding loud click noises for many (OSS) apps

		 *  that open/close frequently)

 CONFIG_SND_AC97_POWER_SAVE */

 needs power-up analog mix and vref */

 power down analog mix and vref */

/**

 * snd_ac97_suspend - General suspend function for AC97 codec

 * @ac97: the ac97 instance

 *

 * Suspends the codec, power down the chip.

/*

 * restore ac97 status

		/* restore only accessible registers

		 * some chip (e.g. nm256) may hang up when unsupported registers

		 * are accessed..!

/*

 * restore IEC958 status

 reset spdif status */

 turn on again */

/**

 * snd_ac97_resume - General resume function for AC97 codec

 * @ac97: the ac97 instance

 *

 * Do the standard resume procedure, power up and restoring the

 * old register values.

 FIXME: extra delay */

/*

 * Hardware tuning

 remove the control with the given name and optional suffix */

 rename the control with the given name and optional suffix */

 rename both Volume and Switch controls - don't check the return value */

 swap controls */

 bind hp and master controls instead of using only hp control */

 ac97 tune: bind Master and Headphone controls */

 ac97 tune: use Headphone control as master */

 ac97 tune: swap Headphone and Master controls */

 ac97 tune: swap Surround and Master controls */

 ac97 tune: set up mic sharing for AD codecs */

 Turn on OMS bit to route microphone to back panel */

 ac97 tune: set up ALC jack-select */

 select jack detect function */

 Line-out auto mute */

 ac97 tune: inversed EAPD bit */

 ac97 tune: EAPD controls mute LED bound with the master mute */

 mute LED on */

 mute LED on */

 apply the quirk with the given type */

 apply the quirk with the given name */

 for compatibility, accept the numbers, too */

/**

 * snd_ac97_tune_hardware - tune up the hardware

 * @ac97: the ac97 instance

 * @quirk: quirk list

 * @override: explicit quirk value (overrides the list if non-NULL)

 *

 * Do some workaround for each pci device, such as renaming of the

 * headphone (true line-out) control as "Master".

 * The quirk-list must be terminated with a zero-filled entry.

 *

 * Return: Zero if successful, or a negative error code on failure.

 quirk overriden? */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>

 *  Universal interface for Audio Codec '97

 *

 *  For more details look to AC '97 component specification revision 2.2

 *  by Intel Corporation (http://developer.intel.com) and to datasheets

 *  for specific codecs.

/*

 *  PCM support

 standard rates */

 3&4 front, 7&8 rear, 6&9 center/lfe */

 slot 3 */

 slot 4 */

 slot 5 */

 slot 6 */

 slot 7 */

 slot 8 */

 slot 9 */

 slot 10 */

 slot 11 */

 7&8 front, 6&9 rear, 10&11 center/lfe */

 slot 3 */

 slot 4 */

 slot 5 */

 slot 6 */

 slot 7 */

 slot 8 */

 slot 9 */

 slot 10 */

 slot 11 */

 6&9 front, 10&11 rear, 3&4 center/lfe */

 slot 3 */

 slot 4 */

 slot 5 */

 slot 6 */

 slot 7 */

 slot 8 */

 slot 9 */

 slot 10 */

 slot 11 */

 10&11 front, 3&4 rear, 7&8 center/lfe */

 slot 3 */

 slot 4 */

 slot 5 */

 slot 6 */

 slot 7 */

 slot 8 */

 slot 9 */

 slot 10 */

 slot 11 */

 double rates */

 3&4 front, 7&8 front (t+1) */

 slot 3 */

 slot 4 */

 slot 5 */

 slot 6 */

 slot 7 */

 slot 8 */

 slot 9 */

 slot 10 */

 slot 11 */

 not specified in the specification */

 slot 3 */

 slot 4 */

 slot 5 */

 slot 6 */

 slot 7 */

 slot 8 */

 slot 9 */

 slot 10 */

 slot 11 */

 slot 3 */

 slot 4 */

 slot 5 */

 slot 6 */

 slot 7 */

 slot 8 */

 slot 9 */

 slot 10 */

 slot 11 */

 slot 3 */

 slot 4 */

 slot 5 */

 slot 6 */

 slot 7 */

 slot 8 */

 slot 9 */

 slot 10 */

 slot 11 */

 FIXME: more various mappings for ADC? */

 3 */

 4 */

 5 */

 6 */

 7 */

 8 */

 9 */

 10 */

 11 */

 pseudo register */

 TODO: double rate support */

 invalid - disable output */

 invalid - disable output */

 update the internal spdif bits */

/**

 * snd_ac97_set_rate - change the rate of the given input/output.

 * @ac97: the ac97 instance

 * @reg: the register to change

 * @rate: the sample rate to set

 *

 * Changes the rate of the given input/output on the codec.

 * If the codec doesn't support VAR, the rate must be 48000 (except

 * for SPDIF).

 *

 * The valid registers are AC97_PMC_MIC_ADC_RATE,

 * AC97_PCM_FRONT_DAC_RATE, AC97_PCM_LR_ADC_RATE.

 * AC97_PCM_SURR_DAC_RATE and AC97_PCM_LFE_DAC_RATE are accepted

 * if the codec supports them.

 * AC97_SPDIF is accepted as a pseudo register to modify the SPDIF

 * status bits.

 *

 * Return: Zero if successful, or a negative error code on failure.

 MIC VRA */

 VRA */

 special case */

		/* Intel controllers require double rate data to be put in

		 * slots 7+8

 Note: it's simply emulation of AMAP behaviour */

/**

 * snd_ac97_pcm_assign - assign AC97 slots to given PCM streams

 * @bus: the ac97 bus instance

 * @pcms_count: count of PCMs to be assigned

 * @pcms: PCMs to be assigned

 *

 * It assigns available AC97 slots for given PCMs. If none or only

 * some slots are available, pcm->xxx.slots and pcm->xxx.rslots[] members

 * are reduced and might be zero.

 *

 * Return: Zero if successful, or a negative error code on failure.

 first step - exclusive devices */

 low-level driver thinks that it's more clever */

 exclusive access */

 non-exclusive access */

 for double rate, we check the first codec only */

 not used */

/**

 * snd_ac97_pcm_open - opens the given AC97 pcm

 * @pcm: the ac97 pcm instance

 * @rate: rate in Hz, if codec does not support VRA, this value must be 48000Hz

 * @cfg: output stream characteristics

 * @slots: a subset of allocated slots (snd_ac97_pcm_assign) for this pcm

 *

 * It locks the specified slots and sets the given rate to AC97 registers.

 *

 * Return: Zero if successful, or a negative error code on failure.

/**

 * snd_ac97_pcm_close - closes the given AC97 pcm

 * @pcm: the ac97 pcm instance

 *

 * It frees the locked AC97 slots.

 *

 * Return: Zero.

/**

 * snd_ac97_pcm_double_rate_rules - set double rate constraints

 * @runtime: the runtime of the ac97 front playback pcm

 *

 * Installs the hardware constraint rules to prevent using double rates and

 * more than two channels at the same time.

 *

 * Return: Zero if successful, or a negative error code on failure.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>

 *  Universal interface for Audio Codec '97

 *

 *  For more details look to AC '97 component specification revision 2.2

 *  by Intel Corporation (http://developer.intel.com) and to datasheets

 *  for specific codecs.

/*

 *  Forward declarations

/*

 *  Chip specific initialization

 replace with a new TLV */

 set to the page, update bits and restore the page */

 unlock paging */

/*

 * shared line-in/mic controls

 6ch */

 4ch */

 8ch */

 system has shared jacks with surround out enabled */

 system has shared jacks with center/lfe out enabled */

 system has shared jacks with line in enabled */

 system has shared jacks with mic in enabled */

 The following snd_ac97_ymf753_... items added by David Shust (dshust@shustring.com) */

 Modified for YMF743 by Keita Maehara <maehara@debian.org> */

/* It is possible to indicate to the Yamaha YMF7x3 the type of

 0 = invalid */

/* It is possible to indicate to the Yamaha YMF7x3 the source to

 set default PCM S/PDIF params */

 PCM audio,no copyright,no preemphasis,PCM coder,original */

 Yamaha 3D enhancement */

 48k only */

 force the detection of spdif */

/* The AC'97 spec states that the S/PDIF signal is to be output at pin 48.

   The YMF753 will output the S/PDIF signal to pin 43, 47 (EAPD), or 48.

   By default, no output pin is selected, and the S/PDIF signal is not output.

	/* The following can be used to direct S/PDIF output to pin 47 (EAPD).

	/* Patch for Yamaha YMF753, Copyright (c) by David Shust, dshust@shustring.com.

	   This chip has nonstandard and extended behaviour with regard to its S/PDIF output.

	   The AC'97 spec states that the S/PDIF signal is to be output at pin 48.

	   The YMF753 will ouput the S/PDIF signal to pin 43, 47 (EAPD), or 48.

	   By default, no output pin is selected, and the S/PDIF signal is not output.

	   There is also a bit to mute S/PDIF output in a vendor-specific register.

 Yamaha 3D enhancement */

/*

 * May 2, 2003 Liam Girdwood <lrg@slimlogic.co.uk>

 *  removed broken wolfson00 patch.

 *  added support for WM9705,WM9708,WM9709,WM9710,WM9711,WM9712 and WM9717.

	/* This is known to work for the ViewSonic ViewPad 1000

	 * Randolph Bentson <bentson@holmsjoen.com>

	 * WM9703/9707/9708/9717 

 patch for DVD noise */

 WM9704M/9704Q */

 WM9705, WM9710 */

 WM9705 touchscreen uses AUX and VIDEO for touch */

 WM9711, WM9712 */

 WM9713, WM9714 */

/*

 * Tritech codec

/*

 * Sigmatel STAC97xx codecs

 "Sigmatel " removed due to excessive name length: */

 the register bit is writable, but the function is not implemented: */

 HP (sigmatel surround) support */

 nothing */

 patch for SigmaTel

 patch for SigmaTel

 is this correct? --jk */

 patch for SigmaTel

 is this correct? --jk */

 DAC-A direct */

 DAC-A to Mix = PCM */

 DAC-B direct = Surround */

 DAC-B to Mix */

 DAC-C direct = Center/LFE */

 OUTSEL */ 0xd794, 
 IOMISC */ 0x2001,

 INSEL */ 0x0201, 
 VARIOUS */ 0x0040

 OUTSEL */ 0xfc70, 
 IOMISC */ 0x2102, 
 INSEL */ 0x0203, 
 VARIOUS */ 0x0041 
 Gateway M675 notebook */

 patch for SigmaTel

 FIXME: assume only page 0 for writing cache */

/*

 * Cirrus Logic CS42xx codecs

 con mask, pro mask, default */

 switch, spsa */

 set default PCM S/PDIF params */

 consumer,PCM audio,no copyright,no preemphasis,PCM coder,original,48000Hz */

	/* Basically, the cs4201/cs4205/cs4297a has non-standard sp/dif registers.

	   WHY CAN'T ANYONE FOLLOW THE BLOODY SPEC?  *sigh*

	   - sp/dif EA ID is not set, but sp/dif is always present.

	   - enable/disable is spdif register bit 15.

	   - sp/dif control register is 0x68.  differs from AC97:

	   - valid is bit 14 (vs 15)

	   - no DRS

	   - only 44.1/48k [00 = 48, 01=44,1] (AC97 is 00=44.1, 10=48)

	   - sp/dif ssource select is in 0x5e bits 0,1.

 force the detection of spdif */

 force the detection of PC Beep */

/*

 * Conexant codecs

 con mask, pro mask, default */

 switch */

 set default PCM S/PDIF params */

 consumer,PCM audio,no copyright,no preemphasis,PCM coder,original,48000Hz */

 force the detection of spdif */

 48k only */

/*

 * Analog Devices AD18xx, AD19xx codecs

 normal restore */

 restore the AD18xx codec configurations */

 select single codec */

 select all codecs */

 restore status */

 handle multi codecs for AD18xx */

 select single codec */

 update PCM bits */

 select all codecs */

 ignore */

 terminator */

 patch for Analog Devices

 select all codecs */

 test for unchained codec

 ID0C, ID1C, SDIE = off */

 SDIE

 already detected?

 test for chained codecs

 ID1C

 SDIE | ID1C

 SDIE | ID1C

 patch for Analog Devices

 select all codecs */

 check if only one codec is present */

 ok, deselect all ID bits */

 required for AD1886/AD1885 combination */

 AC97_SINGLE("Digital Audio Mode", AC97_AD_MISC, 12, 1, 0), */ 
 inverted */

 inverted */

 This is required to deal with the Intel D815EEAL2 */

 i.e. Line out is actually headphone out from codec */

 set default */

 Presario700 workaround */

 for Jack Sense/SPDIF Register misetting causing */

 MISC bits (AD1888/AD1980/AD1985 register 0x76) */

 mic boost */

 +20dB */

 +10dB */

 +30dB */

 VREF high-Z */

 0=2.25V, 1=3.7V */

 0V (AD1985 only) */

 sample rate unlock */

 LINE_OUT amplifiers input select */

 2-channel mic select */

 SPREAD enable */

 downmix mode: */

  0 = 6-to-4, 1 = 6-to-2 downmix */

 downmix mode: 1 = enabled */

 headphone amplifier input select */

 center/lfe disable */

 LINE_OUT disable */

 mute split */

 AC97 no compatible mode */

 DAC zero-fill mode */

 MISC 1 bits (AD1986 register 0x76) */

 mic boost */

 +20dB */

 +10dB */

 +30dB */

 LINE_IN select bit 0 */

 LINE_IN select bit 1 */

 LINE_IN pins as LINE_IN source */

 SURROUND pins as LINE_IN source */

 MIC_1/2 pins as LINE_IN source */

 sample rate unlock */

 SURROUND_OUT amplifiers input sel */

 2-channel mic select */

 SPREAD enable */

 downmix mode: */

  0 = 6-to-4, 1 = 6-to-2 downmix */

 downmix mode: 1 = enabled */

 center/lfe disable */

 SURROUND_OUT disable */

 mute split (read only 1) */

 AC97 no compatible mode (r/o 1) */

 DAC zero-fill mode */

 MISC 2 bits (AD1986 register 0x70) */

 Misc Control Bits 2 (AD1986) */

 C/LFE VREF_OUT 2.25V */

 C/LFE VREF_OUT 0V */

 C/LFE VREF_OUT 3.7V */

 Jack Sense Mapping 1 = alternate */

 Mono Mute Disable */

 MIC VREF_OUT 2.25V */

 MIC VREF_OUT 0V */

 MIC VREF_OUT 3.7V */

 MISC 3 bits (AD1986 register 0x7a) */

 Misc Control Bits 3 (AD1986) */

 Mic Mix, left/right */

 General Purpose Out */

 LINE_OUT headphone drive */

 LINE_OUT VREF_OUT 2.25V */

 LINE_OUT VREF_OUT 0V */

 LINE_OUT VREF_OUT 3.7V */

 Jack Sense Invert SENSE_A */

 LINE_OUT amplifiers input select */

 Headphone amplifiers */

   input select Surround DACs */

 Headphone amplifiers input */

   select C/LFE DACs */

 Jack Sense Invert SENSE_B */

 Serial Config bits (AD1986 register 0x74) (incomplete) */

 Optional Mic Selector bit 0 */

 Optional Mic Selector bit 1 */

 Optional Mic Selector bit 2 */

 MIC_1/2 pins are MIC sources */

 LINE_IN pins are MIC sources */

 Center/LFE pins are MCI sources */

 Mix of MIC and C/LFE pins */

   are MIC sources */

 MIX of MIC and LINE_IN pins */

   are MIC sources */

 MIX of LINE_IN and C/LFE pins */

   are MIC sources */

 MIX of MIC, LINE_IN, C/LFE pins */

   are MIC sources */

/* deny list to avoid HP/Line jack-sense controls

 * (SS vendor << 16 | device)

 Thinkpad R40 */

 Thinkpad X31 */

 Thinkpad T41p */

 Thinkpad R40e */

 Thinkpad T42p/R50p */

 Thinkpad T43p 2668-G7U */

 Thinkpad X41-2527 */

 Dell Dimension 2400 */

 Asus A7V8X-MX */

 Toshiba Satellite A-15 S127 */

 Toshiba P500 */

 Samsung NP-X20C004/SEG */

 end */

/* allow list to enable HP jack-sense bits

 * (SS vendor << 16 | device)

 HP nc4000/4010 */

 HP nc6000 */

 HP nc4220 */

 HP nx6110 */

 HP nc6220 */

 HP nc8220 */

 HP nx9105 */

 HP Compaq dc5100 SFF(PT003AW) */

 FSC Scenic-W */

 end */

 enable headphone jack sense */

 clear LODIS if shared jack is to be used for Surround out */

 clear CLDIS if shared jack is to be used for C/LFE out */

 shared Line-In */

 rename 0x04 as "Master" and 0x02 as "Master Surround" */

	/*

	 * LO can be used as a real line-out on some devices,

	 * and we need to revert the front/surround mixer switches

 ASUS A9T laptop */

 AD-compatible mode */

 Stereo mutes enabled */

 Switch FRONT/SURROUND LINE-OUT/HP-OUT default connection */

		/* it seems that most vendors connect line-out connector to

		 * headphone out of AC'97

 clear OMS if shared jack is to be used for C/LFE out */

 rename 0x04 as "Master" and 0x02 as "Master Surround" */

 switch front/surround line-out/hp-out */

 AD-compatible mode */

 Stereo mutes enabled */

 update current jack configuration */

 on AD1985 rev. 3, AC'97 revision bits are zero */

 SOSEL is set to values of "Spread" or "Exchange F/S" controls */

 SOSEL is set to values of "Spread" or "Exchange F/S" controls */

 Use MIC_1/2 V_REFOUT as the "get" value */

 High-Z */

 3.7 V */

 2.25 V */

 0 V */

 disable SURROUND and CENTER/LFE if not surround mode */

 select line input (default=LINE_IN, SURROUND or MIC_1/2) */

 select microphone input (MIC_1/2, Center/LFE or LINE_IN) */

 update current jack configuration */

/*

 * realtek ALC203: use mono-out for pin 37

/*

 * realtek ALC65x/850 codecs

 shared Line-In / Surround Out */

 update shared Mic In / Center/LFE Out */

 disable/enable vref */

 turn on/off center-on-mic */

 GPIO0 high for mic */

 4: Analog Input To Surround */

 5: Analog Input To Center/LFE */

 6: Independent Master Volume Right */

 7: Independent Master Volume Left */

 8: reserved */

 9: Line-In/Surround share */

 10: Mic/CLFE share */

 11-13: in IEC958 controls */

 always set in patch_alc650 */

 disable this controls since it doesn't work as expected */

 AC97_SINGLE("IEC958 Input Monitor", AC97_ALC650_MULTICH, 13, 1, 0), */

 determine the revision */

 Old version */

 D version */

 E version */

 F version */

 revision E or F */

 FIXME: what about revision D ? */

 enable AC97_ALC650_GPIO_SETUP, AC97_ALC650_CLOCK for R/W */

 Enable SPDIF-IN only on Rev.E and above */

 SPDIF IN with pin 47 */

 ASUS A6KM requires EAPD */

 enable */

 disable */

	/* set default: slot 3,4,7,8,6,9

	   spdif-in monitor off, analog-spdif off, spdif-in off

	   center on mic off, surround on line-in off

	   downmix off, duplicate front off

 set GPIO0 for mic bias */

 GPIO0 pin output, no interrupt, high */

 full DAC volume */

 shared Line-In / Surround Out */

 update shared Mic In / Center/LFE Out */

 misc control; vrefout disable */

 disable this controls since it doesn't work as expected */

 AC97_PAGE_SINGLE("IEC958 Input Monitor", AC97_ALC650_MULTICH, 14, 1, 0, 0), */

 ALC658 */

 assume only page 0 for writing cache */

 adjust default values */

 misc control */

 ALC658 */

 Pin 47 is spdif input pin */

 ALC655 */

 MSI S270 laptop */

 LG K1 Express */

 MSI L725 laptop */

 MSI L720 laptop */

 MSI S250 laptop */

 Pin 47 is EAPD (for internal speaker) */

 Pin 47 is spdif input pin */

 this seems missing on some hardwares */

 vref enable */

	/* set default: spdif-in enabled,

	   spdif-in monitor off, spdif-in PCM off

	   center on mic off, surround on line-in off

	   duplicate front off

 full DAC volume */

 update undocumented bit... */

 shared Line-In / Surround Out */

 SURR 1kOhm (bit4), Amp (bit5) */

 LINE-IN = 0, SURROUND = 2 */

 update shared Mic In / Center/LFE Out */

 Vref disable (bit12), 1kOhm (bit13) */

 MIC-IN = 1, CENTER-LFE = 5 */

 Aux is Back Surround */

 for IEC958 playback route - ALC655 compatible */

 assume only page 0 for writing cache */

 adjust default values */

	/* set default: spdif-in enabled,

	   spdif-in monitor off, spdif-in PCM off

	   center on mic off, surround on line-in off

	   duplicate front off

	   NB default bit 10=0 = Aux is Capture, not Back Surround

	/* SURR_OUT: on, Surr 1kOhm: on, Surr Amp: off, Front 1kOhm: off

	 * Front Amp: on, Vref: enable, Center 1kOhm: on, Mix: on

	/* detection UIO2,3: all path floating, UIO3: MIC, Vref2: disable,

	 * UIO1: FRONT, Vref3: disable, UIO3: LINE, Front-Mic: mute

 full DAC volume */

	/*

	 * 3D register is different from AC97 standard layout

	 * (also do some renaming, to resemble Windows driver naming)

	/* Aztech Windows driver calls the

/*

 * C-Media CM97xx codecs

 shared Line-In / Surround Out */

 FIXME: can anyone confirm below? */

 CM9738 has no PCM volume although the register reacts */

 BIT 0: SPDI_EN - always true */

 BIT 1: SPDIFS */

 BIT 2: IG_SPIV */

 BIT 3: SPI2F */

 BIT 4: SPI2SDI */

 BIT 8: SPD32 - 32bit SPDIF - not supported yet */

 shared Line-In / Surround Out */

 shared Mic In / Center/LFE Out **/

 CM9739/A has no Master and PCM volume although the register reacts */

 check spdif */

 enable spdif in */

 48k only */

 disable extended-id */

 set-up multi channel */

 bit 14: 0 = SPDIF, 1 = EAPD */

 bit 13: enable internal vref output for mic */

 bit 12: disable center/lfe (switchable) */

 bit 10: disable surround/line (switchable) */

 bit 9: mix 2 surround off */

 bit 4: undocumented; 0 mutes the CM9739A, which defaults to 1 */

 bit 3: undocumented; surround? */

 bit 0: dB */

 FIXME: set up GPIO */

 Special exception for ASUS W1000/CMI9739. It does not have an SPDIF in. */

	/* FIXME: check the bits for each model

	 *        model 83 is confirmed to work

 9761-78 & 82 */

 9761-82 rev.B */

 9761-83 */

 9761-78 & 82 */

 9761-82 rev.B */

 9761-83 */

 9761-78 & 82 */

 9761-82 rev.B */

 9761-83 */

 9761-78 & 82 */

 9761-82 rev.B */

 9761-83 */

 SPDIF-loopback */

 ADC loopback */

 AC-link */

 BIT 1: SPDIFS */

 BIT 2: IG_SPIV */

 BIT 3: SPI2F */

 BIT 4: SPI2SDI */

 BIT 9-10: DAC_CTL */

 CM9761 has no PCM volume although the register reacts */

	/* Master volume seems to have _some_ influence on the analog

	 * input sounds

AC97_HAS_NO_MASTER_VOL |*/ AC97_HAS_NO_PCM_VOL;

 1 = model 82 revision B, 2 = model 83 */

 check page 1, reg 0x60 */

 revision B? */

 enable spdif */

 force the SPDIF bit in ext_id - codec doesn't set this bit! */

 to be sure: we overwrite the ext status bits */

 Don't set 0x0200 here.  This results in the silent analog output */

 enable spdif-in */

 48k only */

 set-up multi channel */

	/* bit 15: pc master beep off

	 * bit 14: pin47 = EAPD/SPDIF

	 * bit 13: vref ctl [= cm9739]

	 * bit 12: CLFE control (reverted on rev B)

	 * bit 11: Mic/center share (reverted on rev B)

	 * bit 10: suddound/line share

	 * bit  9: Analog-in mix -> surround

	 * bit  8: Analog-in mix -> CLFE

	 * bit  7: Mic/LFE share (mic/center/lfe)

	 * bit  5: vref select (9761A)

	 * bit  4: front control

	 * bit  3: surround control (revereted with rev B)

	 * bit  2: front mic

	 * bit  1: stereo mic

	 * bit  0: mic boost level (0=20dB, 1=30dB)

 front on */

 FIXME: set up GPIO */

 identical with CM9761 */

 enable spdif */

 48k only */

 SPDI_EN */

/*

 * VIA VT1613 codec

/*

 * VIA VT1616 codec

 find a mixer control element with the given name */

 create a virtual master control and add followers */

 There is already a misnamed master switch.  Rename it.  */

/*

 * VT1617A codec

/*

 * unfortunately, the vt1617a stashes the twiddlers required for

 * noodling the i/o jacks on 2 different regs. that means that we can't

 * use the easy way provided by AC97_ENUM_DOUBLE() we have to write

 * are own funcs.

 *

 * NB: this is absolutely and utterly different from the vt1618. dunno

 * about the 1616.

 copied from ac97_surround_jack_mode_info() */

	/* ordering in this list reflects vt1617a docs for Reg 20 and

	 * 7a and Table 6 that lays out the matrix NB WRT Table6: SM51

	 * is SM51EN *AND* it's Bit14, not Bit15 so the table is very

 grab codec handle */

	/* grab our desired bits, then mash them together in a manner

 grab codec handle */

	/* push our values into the register - consider that things will be left

	/*

	 * These are used to enable/disable surround sound on motherboards

	 * that have 3 bidirectional analog jacks

	/* we choose to not fail out at this point, but we tell the

	/* bring analog power consumption to normal by turning off the

	 * headphone amplifier, like WinXP driver for EPIA SP

	/* We need to check the bit before writing it.

	 * On some (many?) hardwares, setting bit actually clears it!

 force the detection of spdif */

/* VIA VT1618 8 CHANNEL AC97 CODEC

 *

 * VIA implements 'Smart 5.1' completely differently on the 1618 than

 * it does on the 1617a. awesome! They seem to have sourced this

 * particular revision of the technology from somebody else, it's

 * called Universal Audio Jack and it shows up on some other folk's chips

 * as well.

 *

 * ordering in this list reflects vt1618 docs for Reg 60h and

 * the block diagram, DACs are as follows:

 *

 *        OUT_O -> Front,

 *	  OUT_1 -> Surround,

 *	  OUT_2 -> C/LFE

 *

 * Unlike the 1617a, each OUT has a consistent set of mappings

 * for all bitpatterns other than 00:

 *

 *        01       Unmixed Output

 *        10       Line In

 *        11       Mic  In

 *

 * Special Case of 00:

 *

 *        OUT_0    Mixed Output

 *        OUT_1    Reserved

 *        OUT_2    Reserved

 *

 * I have no idea what the hell Reserved does, but on an MSI

 * CN700T, i have to set it to get 5.1 output - YMMV, bad

 * shit may happen.

 *

 * If other chips use Universal Audio Jack, then this code might be applicable

 * to them.

 This list reflects the vt1618 docs for Vendor Defined Register 0x60. */

 speaker jack */

 line jack */

 mic jack */

/* All of the vt1618 Universal Audio Jack twiddlers are on

 * Vendor Defined Register 0x60, page 0. The bits, and thus

 * the mask, are the only thing that changes

 config aux in jack - not found on 3 jack motherboards or soundcards */

 toggle surround rear dac power */

 toggle aux in surround rear out jack */

/*

 shared Line-In / Surround Out */

 shared Mic / Center/LFE Out */

 full DAC volume */

/*

 * Si3036 codec

/*

 * LM 4550 Codec

 *

 * We use a static resolution table since LM4550 codec cannot be

 * properly autoprobed to determine the resolution via

 * check_volume_resolution().

 LSB is ignored */

 terminator */

/* 

 *  UCB1400 codec (http://www.semiconductors.philips.com/acrobat_download/datasheets/UCB1400-02.pdf)

/* enable/disable headphone driver which allows direct connection to

   stereo headphone without the use of external DC blocking

/* Filter used to compensate the DC offset is added in the ADC to remove idle

/* Control smart-low-power mode feature. Allows automatic power down

 enable headphone driver and smart low power mode by default */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>

 *  Universal interface for Audio Codec '97

 *

 *  For more details look to AC '97 component specification revision 2.2

 *  by Intel Corporation (http://developer.intel.com).

/*

 * proc interface

   0 */ "No 3D Stereo Enhancement",

   1 */ "Analog Devices Phat Stereo",

   2 */ "Creative Stereo Enhancement",

   3 */ "National Semi 3D Stereo Enhancement",

   4 */ "YAMAHA Ymersion",

   5 */ "BBE 3D Stereo Enhancement",

   6 */ "Crystal Semi 3D Stereo Enhancement",

   7 */ "Qsound QXpander",

   8 */ "Spatializer 3D Stereo Enhancement",

   9 */ "SRS 3D Stereo Enhancement",

  10 */ "Platform Tech 3D Stereo Enhancement",

  11 */ "AKM 3D Audio",

  12 */ "Aureal Stereo Enhancement",

  13 */ "Aztech 3D Enhancement",

  14 */ "Binaura 3D Audio Enhancement",

  15 */ "ESS Technology Stereo Enhancement",

  16 */ "Harman International VMAx",

  17 */ "Nvidea/IC Ensemble/KS Waves 3D Stereo Enhancement",

  18 */ "Philips Incredible Sound",

  19 */ "Texas Instruments 3D Stereo Enhancement",

  20 */ "VLSI Technology 3D Stereo Enhancement",

  21 */ "TriTech 3D Stereo Enhancement",

  22 */ "Realtek 3D Stereo Enhancement",

  23 */ "Samsung 3D Stereo Enhancement",

  24 */ "Wolfson Microelectronics 3D Enhancement",

  25 */ "Delta Integration 3D Enhancement",

  26 */ "SigmaTel 3D Enhancement",

  27 */ "IC Ensemble/KS Waves",

  28 */ "Rockwell 3D Stereo Enhancement",

  29 */ "Reserved 29",

  30 */ "Reserved 30",

  31 */ "Reserved 31"

 val = snd_ac97_read(ac97, AC97_RESET);

 VRA */

 ALC650 specific*/

 Analog Devices AD1881/85/86

 select single codec */

 select all codecs */

 direct register write for debugging */

 register must be even */

 Analog Devices AD1881/85/86

 select single codec */

 select all codecs */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * HD audio interface patch for Creative X-Fi CA0110-IBG chip

 *

 * Copyright (c) 2008 Takashi Iwai <tiwai@suse.de>

/*

 * patch entries

 terminator */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * HD audio interface patch for Conexant HDA audio codec

 *

 * Copyright (c) 2006 Pototskiy Akex <alex.pototskiy@gmail.com>

 * 		      Takashi Iwai <tiwai@suse.de>

 * 		      Tobin Davis  <tdavis@dsl-only.net>

 extra EAPD pins */

 flag for snd_hda_parse_pin_defcfg() */

 OPLC XO specific */

 offset into olpc_xo_dc_bias */

 additional beep mixers; private_value will be overwritten */

/*

 * Automatic parser for CX20641 & co

 parse EAPDs */

	/* NOTE: below is a wild guess; if we have more than two EAPDs,

	 * it's a new chip, where EAPDs are supposed to be associated to

	 * pins, and we can control EAPD per pin.

	 * OTOH, if only one or two EAPDs are found, it's an old chip,

	 * thus it might control over all pins.

 turn on/off EAPD according to Master switch */

 turn on/off EAPD according to Master switch (inversely!) for mute LED */

	/* Turn the problematic codec into D3 to avoid spurious noises

/*

 * pin fix-up

 for hda_fixup_thinkpad_acpi() */

 The verbs used in this function were tested on a Conexant CX20751/2 codec. */

 enable merged mode for analog int-mic */

 disable merged mode for analog int-mic */

 OPLC XO 1.5 fixup */

/* OLPC XO-1.5 supports DC input mode (e.g. for use with analog sensors)

 * through the microphone jack.

 * When the user enables this through a mixer switch, both internal and

 * external microphones are disabled. Gain is fixed at 0dB. In this mode,

 * we also allow the bias to be configured through a separate mixer

	/* Set up mic pins for port-B, C and F dynamically as the recording

	 * LED is turned on/off by these pin controls

 disable DC bias path and pin for port F */

 update port B (ext mic) and C (int mic) */

		/* OLPC defers mic widget control until when capture is

		 * started because the microphone LED comes on as soon as

		 * these settings are put in place. if we did this before

		 * recording, it would give the false indication that

		 * recording is happening when it is not.

 enable normal mic path */

 disable normal mic path */

		/* Even though port F is the DC input, the bias is controlled

		 * on port B.  We also leave that port as an active input (but

		 * unselected) in DC mode just in case that is necessary to

		 * make the bias setting take effect.

 enable DC bias path and pin */

 mic_autoswitch hook */

 in DC mode, we don't handle automic */

 pcm_capture hook */

	/* toggle spec->recording flag and update mic pins accordingly

	 * for turning on/off LED

/* overriding mic boost put callback; update mic boost volume only when

 * DC mode is disabled

	/* OLPC's microphone port is DC coupled for use with external sensors,

	 * therefore we use a 50% mic bias in order to center the input signal

	 * with the DC input range of the codec.

 override mic boost control */

/*

 * Fix max input level on mixer widget to 0dB

 * (originally it has 0x2b steps with 0dB offset 0x14)

/*

 * Fix max input level on mixer widget to 0dB

 * (originally it has 0x1e steps with 0 dB offset 0x17)

	/* the mic pin (0x19) doesn't give an unsolicited event;

	 * probe the mic pin together with the headphone pin (0x16)

 update LED status via GPIO */

 turn on/off mute LED via GPIO per vmaster hook */

 turn on/off mic-mute LED via GPIO per capture hook */

 ThinkPad X200 & co with cxt5051 */

 HP (seq# overridden) */

 dock-mic */

 dock-HP */

 dock SPDIF out */

 ThinkPad 410/420/510/520, X201 & co with cxt5066 */

 HP (seq# overridden) */

 dock-mic */

 dock-HP */

 Lemote A1004/A1205 with cxt5066 */

 Internal mic */

 External mic */

 Not used */

 Not used */

 Not used */

 Not used */

 Not used */

 0x17 was falsely set up as a mic, it should 0x1d */

 use as headphone mic, without its own jack detect */

 speaker/hp */

 ext mic */

 int mic */

 int mic */

 line-out */

 line-in */

 enable NID 0x1d for the speaker on top */

	/* HP, Packard Bell, Fujitsu-Siemens & Lenovo laptops have

	 * really bad sound over 0dB on NID 0x17.

	/* HP laptops have really bad sound over 0 dB on NID 0x10.

/* add "fake" mute amp-caps to DACs on cx5051 so that mixer mute switches

 * can be created (bko#42825)

	/* Some laptops with Conexant chips show stalls in S3 resume,

	 * which falls into the single-cmd mode.

	 * Better to make reset, then.

/*

 terminator */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Universal Interface for Intel High Definition Audio Codec

 *

 * Copyright (c) 2004 Takashi Iwai <tiwai@suse.de>

/*

 * Send and receive a verb - passed to exec_verb override for hdac_device

 clear reset-flag when the communication gets recovered */

/**

 * snd_hda_sequence_write - sequence writes

 * @codec: the HDA codec

 * @seq: VERB array to send

 *

 * Send the commands sequentially from the given array.

 * The array must be terminated with NID=0.

 connection list element */

 look up the cached results */

 read the connection and add to the cache */

/**

 * snd_hda_get_conn_list - get connection list

 * @codec: the HDA codec

 * @nid: NID to parse

 * @listp: the pointer to store NID list

 *

 * Parses the connection list of the given widget and stores the pointer

 * to the list of NIDs.

 *

 * Returns the number of connections, or a negative error code.

 *

 * Note that the returned pointer isn't protected against the list

 * modification.  If snd_hda_override_conn_list() might be called

 * concurrently, protect with a mutex appropriately.

 if the connection-list is already cached, read it */

/**

 * snd_hda_get_connections - copy connection list

 * @codec: the HDA codec

 * @nid: NID to parse

 * @conn_list: connection list array; when NULL, checks only the size

 * @max_conns: max. number of connections to store

 *

 * Parses the connection list of the given widget and stores the list

 * of NIDs.

 *

 * Returns the number of connections, or a negative error code.

/**

 * snd_hda_override_conn_list - add/modify the connection-list to cache

 * @codec: the HDA codec

 * @nid: NID to parse

 * @len: number of connection list entries

 * @list: the list of connection entries

 *

 * Add or modify the given connection-list to the cache.  If the corresponding

 * cache already exists, invalidate it and append a new one.

 *

 * Returns zero or a negative error code.

/**

 * snd_hda_get_conn_index - get the connection index of the given NID

 * @codec: the HDA codec

 * @mux: NID containing the list

 * @nid: NID to select

 * @recursive: 1 when searching NID recursively, otherwise 0

 *

 * Parses the connection list of the widget @mux and checks whether the

 * widget @nid is present.  If it is, return the connection index.

 * Otherwise it returns -1.

/**

 * snd_hda_get_num_devices - get DEVLIST_LEN parameter of the given widget

 *  @codec: the HDA codec

 *  @nid: NID of the pin to parse

 *

 * Get the device entry number on the given widget. This is a feature of

 * DP MST audio. Each pin can have several device entries in it.

/**

 * snd_hda_get_devices - copy device list without cache

 * @codec: the HDA codec

 * @nid: NID of the pin to parse

 * @dev_list: device list array

 * @max_devices: max. number of devices to store

 *

 * Copy the device list. This info is dynamic and so not cached.

 * Currently called only from hda_proc.c, so not exported.

 not multi-stream capable */

 error */

/**

 * snd_hda_get_dev_select - get device entry select on the pin

 * @codec: the HDA codec

 * @nid: NID of the pin to get device entry select

 *

 * Get the devcie entry select on the pin. Return the device entry

 * id selected on the pin. Return 0 means the first device entry

 * is selected or MST is not supported.

 not support dp_mst will always return 0, using first dev_entry */

/**

 * snd_hda_set_dev_select - set device entry select on the pin

 * @codec: the HDA codec

 * @nid: NID of the pin to set device entry select

 * @dev_id: device entry id to be set

 *

 * Set the device entry select on the pin nid.

 not support dp_mst will always return 0, using first dev_entry */

 AC_PAR_DEVLIST_LEN is 0 based. */

	/* If Device List Length is 0 (num_device = 1),

	 * the pin is not multi stream capable.

	 * Do nothing in this case.

	/* Behavior of setting index being equal to or greater than

	 * Device List Length is not predictable

/*

 * read widget caps for each widget and store in cache

 read all pin default configurations and save codec->init_pins */

		/*

		 * all device entries are the same widget control so far

		 * fixme: if any codec is different, need fix here

 look up the given pin config list and return the item matching with NID */

/* set the current pin config value for the given NID.

 * the value is cached, and read via snd_hda_codec_get_pincfg()

	/* the check below may be invalid when pins are added by a fixup

	 * dynamically (e.g. via snd_hda_codec_update_widgets()), so disabled

	 * for now

	/*

	if (get_wcaps_type(get_wcaps(codec, nid)) != AC_WID_PIN)

		return -EINVAL;

/**

 * snd_hda_codec_set_pincfg - Override a pin default configuration

 * @codec: the HDA codec

 * @nid: NID to set the pin config

 * @cfg: the pin default config value

 *

 * Override a pin default configuration value in the cache.

 * This value can be read by snd_hda_codec_get_pincfg() in a higher

 * priority than the real hardware value.

/**

 * snd_hda_codec_get_pincfg - Obtain a pin-default configuration

 * @codec: the HDA codec

 * @nid: NID to get the pin config

 *

 * Get the current pin config value of the given pin NID.

 * If the pincfg value is cached or overridden via sysfs or driver,

 * returns the cached value.

/**

 * snd_hda_codec_set_pin_target - remember the current pinctl target value

 * @codec: the HDA codec

 * @nid: pin NID

 * @val: assigned pinctl value

 *

 * This function stores the given value to a pinctl target value in the

 * pincfg table.  This isn't always as same as the actually written value

 * but can be referred at any time via snd_hda_codec_get_pin_target().

/**

 * snd_hda_codec_get_pin_target - return the current pinctl target value

 * @codec: the HDA codec

 * @nid: pin NID

/**

 * snd_hda_shutup_pins - Shut up all pins

 * @codec: the HDA codec

 *

 * Clear all pin controls to shup up before suspend for avoiding click noise.

 * The controls aren't cached so that they can be resumed properly.

	/* don't shut up pins when unloading the driver; otherwise it breaks

	 * the default pin setup at the next load of the driver

 use read here for syncing after issuing each verb */

 Restore the pin controls cleared previously via snd_hda_shutup_pins() */

 for non-polling trigger: we need nothing if already powered on */

 the power-up/down sequence triggers the runtime resume */

 update jacks manually if polling is required, too */

 release all pincfg lists */

/*

 * audio-converter setup caches

 cvt is currently used */

 setups should be cleared */

 get or create a cache entry for the given audio converter NID */

/*

 * PCM device

/*

 * codec destructor

 pm_runtime_put() is called in snd_hdac_device_exit() */

 free only driver_pins so that init_pins + user_pins are restored */

 enable/disable display power per codec */

 also called from hda_bind.c */

 it was powered up in snd_hda_codec_new(), now all done */

	/*

	 * snd_hda_codec_device_new() is used by legacy HDA and ASoC driver.

	 * We can't unregister ASoC device since it will be unregistered in

	 * snd_hdac_ext_bus_device_remove().

	/*

	 * In the case of ASoC HD-audio bus, the device refcount is released in

	 * snd_hdac_ext_bus_device_remove() explicitly.

	/*

	 * In the case of ASoC HD-audio, hda_codec is device managed.

	 * It will be freed when the ASoC device is removed.

/**

 * snd_hda_codec_new - create a HDA codec

 * @bus: the bus to assign

 * @card: card for this codec

 * @codec_addr: the codec address

 * @codecp: the pointer to store the generated codec

 *

 * Returns 0 if successful, or a negative error code.

 power-up all before initialization */

 PM runtime needs to be enabled later after binding codec */

/**

 * snd_hda_codec_update_widgets - Refresh widget caps and pin defaults

 * @codec: the HDA codec

 *

 * Forcibly refresh the all widget caps and the init pin configurations of

 * the given codec.

	/* Assume the function group node does not change,

	 * only the widget nodes may change.

 update the stream-id if changed */

 update the format-id if changed */

/**

 * snd_hda_codec_setup_stream - set up the codec for streaming

 * @codec: the CODEC to set up

 * @nid: the NID to set up

 * @stream_tag: stream tag to pass, it's between 0x1 and 0xf.

 * @channel_id: channel id to pass, zero based.

 * @format: stream format.

 make other inactive cvts with the same stream-tag dirty */

/**

 * __snd_hda_codec_cleanup_stream - clean up the codec for closing

 * @codec: the CODEC to clean up

 * @nid: the NID to clean up

 * @do_now: really clean up the stream instead of clearing the active flag

		/* here we just clear the active flag when do_now isn't set;

		 * actual clean-ups will be done later in

		 * purify_inactive_streams() called from snd_hda_codec_prpapre()

 clean up the all conflicting obsolete streams */

 clean up all streams; called from suspend */

/*

 * amp access functions

/**

 * query_amp_caps - query AMP capabilities

 * @codec: the HD-auio codec

 * @nid: the NID to query

 * @direction: either #HDA_INPUT or #HDA_OUTPUT

 *

 * Query AMP capabilities for the given widget and direction.

 * Returns the obtained capability bits.

 *

 * When cap bits have been already read, this doesn't read again but

 * returns the cached value.

/**

 * snd_hda_check_amp_caps - query AMP capabilities

 * @codec: the HD-audio codec

 * @nid: the NID to query

 * @dir: either #HDA_INPUT or #HDA_OUTPUT

 * @bits: bit mask to check the result

 *

 * Check whether the widget has the given amp capability for the direction.

/**

 * snd_hda_override_amp_caps - Override the AMP capabilities

 * @codec: the CODEC to clean up

 * @nid: the NID to clean up

 * @dir: either #HDA_INPUT or #HDA_OUTPUT

 * @caps: the capability bits to set

 *

 * Override the cached AMP caps bits value by the given one.

 * This function is useful if the driver needs to adjust the AMP ranges,

 * e.g. limit to 0dB, etc.

 *

 * Returns zero if successful or a negative error code.

 enable fake mute if no h/w mute but min=mute */

/**

 * snd_hda_codec_amp_update - update the AMP mono value

 * @codec: HD-audio codec

 * @nid: NID to read the AMP value

 * @ch: channel to update (0 or 1)

 * @dir: #HDA_INPUT or #HDA_OUTPUT

 * @idx: the index value (only for input direction)

 * @mask: bit mask to set

 * @val: the bits value to set

 *

 * Update the AMP values for the given channel, direction and index.

/**

 * snd_hda_codec_amp_stereo - update the AMP stereo values

 * @codec: HD-audio codec

 * @nid: NID to read the AMP value

 * @direction: #HDA_INPUT or #HDA_OUTPUT

 * @idx: the index value (only for input direction)

 * @mask: bit mask to set

 * @val: the bits value to set

 *

 * Update the AMP values like snd_hda_codec_amp_update(), but for a

 * stereo widget with the same mask and value.

/**

 * snd_hda_codec_amp_init - initialize the AMP value

 * @codec: the HDA codec

 * @nid: NID to read the AMP value

 * @ch: channel (left=0 or right=1)

 * @dir: #HDA_INPUT or #HDA_OUTPUT

 * @idx: the index value (only for input direction)

 * @mask: bit mask to set

 * @val: the bits value to set

 *

 * Works like snd_hda_codec_amp_update() but it writes the value only at

 * the first access.  If the amp was already initialized / updated beforehand,

 * this does nothing.

/**

 * snd_hda_codec_amp_init_stereo - initialize the stereo AMP value

 * @codec: the HDA codec

 * @nid: NID to read the AMP value

 * @dir: #HDA_INPUT or #HDA_OUTPUT

 * @idx: the index value (only for input direction)

 * @mask: bit mask to set

 * @val: the bits value to set

 *

 * Call snd_hda_codec_amp_init() for both stereo channels.

 get num steps */

/**

 * snd_hda_mixer_amp_volume_info - Info callback for a standard AMP mixer

 * @kcontrol: referred ctl element

 * @uinfo: pointer to get/store the data

 *

 * The control element is supposed to have the private_value field

 * set up via HDA_COMPOSE_AMP_VAL*() or related macros.

 ofs = 0: raw max value */

/**

 * snd_hda_mixer_amp_volume_get - Get callback for a standard AMP mixer volume

 * @kcontrol: ctl element

 * @ucontrol: pointer to get/store the data

 *

 * The control element is supposed to have the private_value field

 * set up via HDA_COMPOSE_AMP_VAL*() or related macros.

/**

 * snd_hda_mixer_amp_volume_put - Put callback for a standard AMP mixer volume

 * @kcontrol: ctl element

 * @ucontrol: pointer to get/store the data

 *

 * The control element is supposed to have the private_value field

 * set up via HDA_COMPOSE_AMP_VAL*() or related macros.

 inquiry the amp caps and convert to TLV */

/**

 * snd_hda_mixer_amp_tlv - TLV callback for a standard AMP mixer volume

 * @kcontrol: ctl element

 * @op_flag: operation flag

 * @size: byte size of input TLV

 * @_tlv: TLV data

 *

 * The control element is supposed to have the private_value field

 * set up via HDA_COMPOSE_AMP_VAL*() or related macros.

/**

 * snd_hda_set_vmaster_tlv - Set TLV for a virtual master control

 * @codec: HD-audio codec

 * @nid: NID of a reference widget

 * @dir: #HDA_INPUT or #HDA_OUTPUT

 * @tlv: TLV data to be stored, at least 4 elements

 *

 * Set (static) TLV data for a virtual master volume using the AMP caps

 * obtained from the reference NID.

 * The volume range is recalculated as if the max volume is 0dB.

 find a mixer control element with the given name */

/**

 * snd_hda_find_mixer_ctl - Find a mixer control element with the given name

 * @codec: HD-audio codec

 * @name: ctl id name string

 *

 * Get the control element with the given id string and IFACE_MIXER.

 16 ctlrs should be large enough */

/**

 * snd_hda_ctl_add - Add a control element and assign to the codec

 * @codec: HD-audio codec

 * @nid: corresponding NID (optional)

 * @kctl: the control element to assign

 *

 * Add the given control element to an array inside the codec instance.

 * All control elements belonging to a codec are supposed to be added

 * by this function so that a proper clean-up works at the free or

 * reconfiguration time.

 *

 * If non-zero @nid is passed, the NID is assigned to the control element.

 * The assignment is shown in the codec proc file.

 *

 * snd_hda_ctl_add() checks the control subdev id field whether

 * #HDA_SUBDEV_NID_FLAG bit is set.  If set (and @nid is zero), the lower

 * bits value is taken as the NID to assign. The #HDA_NID_ITEM_AMP bit

 * specifies if kctl->private_value is a HDA amplifier value.

/**

 * snd_hda_add_nid - Assign a NID to a control element

 * @codec: HD-audio codec

 * @nid: corresponding NID (optional)

 * @kctl: the control element to assign

 * @index: index to kctl

 *

 * Add the given control element to an array inside the codec instance.

 * This function is used when #snd_hda_ctl_add cannot be used for 1:1

 * NID:KCTL mapping - for example "Capture Source" selector.

/**

 * snd_hda_ctls_clear - Clear all controls assigned to the given codec

 * @codec: HD-audio codec

/**

 * snd_hda_lock_devices - pseudo device locking

 * @bus: the BUS

 *

 * toggle card->shutdown to allow/disallow the device access (as a hack)

/**

 * snd_hda_unlock_devices - pseudo device unlocking

 * @bus: the BUS

/**

 * snd_hda_codec_reset - Clear all objects assigned to the codec

 * @codec: HD-audio codec

 *

 * This frees the all PCM and control elements assigned to the codec, and

 * clears the caches and restores the pin default configurations.

 *

 * When a device is being used, it returns -EBSY.  If successfully freed,

 * returns zero.

 OK, let it free */

 allow device access again */

 apply the function to all matching follower ctls in the mixer list */

 call kctl->put with the given value(s) */

 initialize the follower volume with 0dB via snd_ctl_apply_vmaster_followers() */

 ignore */

 unmute the follower via snd_ctl_apply_vmaster_followers() */

/**

 * __snd_hda_add_vmaster - create a virtual master control and add followers

 * @codec: HD-audio codec

 * @name: vmaster control name

 * @tlv: TLV data (optional)

 * @followers: follower control names (optional)

 * @suffix: suffix string to each follower name (optional)

 * @init_follower_vol: initialize followers to unmute/0dB

 * @access: kcontrol access rights

 * @ctl_ret: store the vmaster kcontrol in return

 *

 * Create a virtual master control with the given name.  The TLV data

 * must be either NULL or a valid data.

 *

 * @followers is a NULL-terminated array of strings, each of which is a

 * follower control name.  All controls with these names are assigned to

 * the new virtual master control.

 *

 * This function returns zero if successful or a negative error code.

 init with master mute & zero volume */

 meta hook to call each driver's vmaster hook */

/**

 * snd_hda_add_vmaster_hook - Add a vmaster hw specific hook

 * @codec: the HDA codec

 * @hook: the vmaster hook object

 *

 * Add a hw specific hook (like EAPD) with the given vmaster switch kctl.

/**

 * snd_hda_sync_vmaster_hook - Sync vmaster hook

 * @hook: the vmaster hook

 *

 * Call the hook with the current value for synchronization.

 * Should be called in init callback.

	/* don't call vmaster hook in the destructor since it might have

	 * been already destroyed

/**

 * snd_hda_mixer_amp_switch_info - Info callback for a standard AMP mixer switch

 * @kcontrol: referred ctl element

 * @uinfo: pointer to get/store the data

 *

 * The control element is supposed to have the private_value field

 * set up via HDA_COMPOSE_AMP_VAL*() or related macros.

/**

 * snd_hda_mixer_amp_switch_get - Get callback for a standard AMP mixer switch

 * @kcontrol: ctl element

 * @ucontrol: pointer to get/store the data

 *

 * The control element is supposed to have the private_value field

 * set up via HDA_COMPOSE_AMP_VAL*() or related macros.

/**

 * snd_hda_mixer_amp_switch_put - Put callback for a standard AMP mixer switch

 * @kcontrol: ctl element

 * @ucontrol: pointer to get/store the data

 *

 * The control element is supposed to have the private_value field

 * set up via HDA_COMPOSE_AMP_VAL*() or related macros.

/*

 * SPDIF out controls

/* convert from SPDIF status bits to HDA SPDIF bits

 * bit 0 (DigEn) is always set zero (to be filled later)

/* convert to SPDIF status bits from HDA SPDIF bits

 set digital convert verbs both for the given NID and its followers */

 unmute amp switch (if any) */

 end */

/**

 * snd_hda_create_dig_out_ctls - create Output SPDIF-related controls

 * @codec: the HDA codec

 * @associated_nid: NID that new ctls associated with

 * @cvt_nid: converter NID

 * @type: HDA_PCM_TYPE_*

 * Creates controls related with the digital output.

 * Called from each patch supporting the digital out.

 *

 * Returns 0 if successful, or a negative error code.

 suppose a single SPDIF device */

/**

 * snd_hda_spdif_out_of_nid - get the hda_spdif_out entry from the given NID

 * @codec: the HDA codec

 * @nid: widget NID

 *

 * call within spdif_mutex lock

/**

 * snd_hda_spdif_ctls_unassign - Unassign the given SPDIF ctl

 * @codec: the HDA codec

 * @idx: the SPDIF ctl index

 *

 * Unassign the widget from the given SPDIF control.

/**

 * snd_hda_spdif_ctls_assign - Assign the SPDIF controls to the given NID

 * @codec: the HDA codec

 * @idx: the SPDIF ctl idx

 * @nid: widget NID

 *

 * Assign the widget to the SPDIF control with the given index.

/*

 * SPDIF sharing with analog output

/**

 * snd_hda_create_spdif_share_sw - create Default PCM switch

 * @codec: the HDA codec

 * @mout: multi-out instance

 ATTENTION: here mout is passed as private_data, instead of codec */

/*

 * SPDIF input

 end */

/**

 * snd_hda_create_spdif_in_ctls - create Input SPDIF-related controls

 * @codec: the HDA codec

 * @nid: audio in widget NID

 *

 * Creates controls related with the SPDIF input.

 * Called from each patch supporting the SPDIF in.

 *

 * Returns 0 if successful, or a negative error code.

/**

 * snd_hda_codec_set_power_to_all - Set the power state to all widgets

 * @codec: the HDA codec

 * @fg: function group (not used now)

 * @power_state: the power state to set (AC_PWRST_*)

 *

 * Set the given power state to all widgets that have the power control.

 * If the codec has power_filter set, it evaluates the power state and

 * filter out if it's unchanged as D3.

/**

 * snd_hda_codec_eapd_power_filter - A power filter callback for EAPD

 * @codec: the HDA codec

 * @nid: widget NID

 * @power_state: power state to evalue

 *

 * Don't power down the widget if it controls eapd and EAPD_BTLENABLE is set.

 * This can be used a codec power_filter callback.

/*

 * set power state of the codec, and return the power state

 this delay seems necessary to avoid click noise at power-down */

 repeat power states setting at most 10 times*/

/* sync power states of all widgets;

 * this is called at the end of codec parsing

 don't care if no filter is used */

 execute additional init verbs */

 update the power on/off account with the current jiffies */

/*

 * call suspend and power-down; used both from PM and power-save

 * this function returns the power state in the end

/*

 * kick up codec; used both from PM and power-save

 Nothing to do if card registration fails and the component driver never probes */

 Nothing to do if card registration fails and the component driver never probes */

 CONFIG_PM */

 If no other pm-functions are called between prepare() and complete() */

 CONFIG_PM_SLEEP */

 referred in hda_bind.c */

 CONFIG_PM_SLEEP */

 suspend the codec at shutdown; called from driver's shutdown callback */

/*

 * add standard channel maps if not specified

/* default channel maps for 2.1 speakers;

 * since HD-audio supports only stereo, odd number channels are omitted

 continue to initialize... */

 we create chmaps here instead of build_pcms */

 call at the last init point */

/*

 * PCM stuff

 query support PCM information from the given NID */

/*

 * codec prepare/cleanup entries

/**

 * snd_hda_codec_prepare - Prepare a stream

 * @codec: the HDA codec

 * @hinfo: PCM information

 * @stream: stream tag to assign

 * @format: format id to assign

 * @substream: PCM substream to assign

 *

 * Calls the prepare callback set by the codec with the given arguments.

 * Clean up the inactive streams when successful.

/**

 * snd_hda_codec_cleanup - Clean up stream resources

 * @codec: the HDA codec

 * @hinfo: PCM information

 * @substream: PCM substream

 *

 * Calls the cleanup callback set by the codec with the given arguments.

 global */

/*

 * get the empty PCM device number to assign

 audio device indices; not linear to keep compatibility */

	/* assigned to static slots up to dev#10; if more needed, assign

	 * the later slot dynamically (when CONFIG_SND_DYNAMIC_MINORS=y)

 non-fixed slots starting from 10 */

 call build_pcms ops of the given codec and set up the default parameters */

 already parsed */

 assign all PCMs of the given codec */

 attach a new PCM streams */

 already attached */

 no substreams assigned */

 no fatal error */

 no fatal error */

/**

 * snd_hda_add_new_ctls - create controls from the array

 * @codec: the HDA codec

 * @knew: the array of struct snd_kcontrol_new

 *

 * This helper function creates and add new controls in the given array.

 * The array must be terminated with an empty entry as terminator.

 *

 * Returns 0 if successful, or a negative error code.

 skip this codec private value */

			/* try first with another device index corresponding to

			 * the codec addr; if it still fails (or it's the

			 * primary codec), then try another control index

/**

 * snd_hda_set_power_save - reprogram autosuspend for the given delay

 * @bus: HD-audio bus

 * @delay: autosuspend delay in msec, 0 = off

 *

 * Synchronize the runtime PM autosuspend state from the power_save option.

/**

 * snd_hda_check_amp_list_power - Check the amp list and update the power

 * @codec: HD-audio codec

 * @check: the object containing an AMP list and the status

 * @nid: NID to check / update

 *

 * Check whether the given NID is in the amp list.  If it's in the list,

 * check the current AMP status, and update the power-status according

 * to the mute status.

 *

 * This function is supposed to be set or called from the check_power_status

 * patch ops.

 nothing changed */

/*

 * input MUX helper

/**

 * snd_hda_input_mux_info - Info callback helper for the input-mux enum

 * @imux: imux helper object

 * @uinfo: pointer to get/store the data

/**

 * snd_hda_input_mux_put - Put callback helper for the input-mux enum

 * @codec: the HDA codec

 * @imux: imux helper object

 * @ucontrol: pointer to get/store the data

 * @nid: input mux NID

 * @cur_val: pointer to get/store the current imux value

/**

 * snd_hda_enum_helper_info - Helper for simple enum ctls

 * @kcontrol: ctl element

 * @uinfo: pointer to get/store the data

 * @num_items: number of enum items

 * @texts: enum item string array

 *

 * process kcontrol info callback of a simple string enum array

 * when @num_items is 0 or @texts is NULL, assume a boolean enum array

/*

 * Multi-channel / digital-out PCM helper functions

 setup SPDIF output stream */

	/* Add sanity check to pass klockwork check.

	 * This should never happen.

	/* turn off SPDIF if needed; otherwise the IEC958 bits won't be

 turn on again (if needed) */

/**

 * snd_hda_multi_out_dig_open - open the digital out in the exclusive mode

 * @codec: the HDA codec

 * @mout: hda_multi_out object

 already opened as analog dup; reset it once */

/**

 * snd_hda_multi_out_dig_prepare - prepare the digital out stream

 * @codec: the HDA codec

 * @mout: hda_multi_out object

 * @stream_tag: stream tag to assign

 * @format: format id to assign

 * @substream: PCM substream to assign

/**

 * snd_hda_multi_out_dig_cleanup - clean-up the digital out stream

 * @codec: the HDA codec

 * @mout: hda_multi_out object

/**

 * snd_hda_multi_out_dig_close - release the digital out stream

 * @codec: the HDA codec

 * @mout: hda_multi_out object

/**

 * snd_hda_multi_out_analog_open - open analog outputs

 * @codec: the HDA codec

 * @mout: hda_multi_out object

 * @substream: PCM substream to assign

 * @hinfo: PCM information to assign

 *

 * Open analog outputs and set up the hw-constraints.

 * If the digital outputs can be opened as follower, open the digital

 * outputs, too.

 FIXME: need notify? */

/**

 * snd_hda_multi_out_analog_prepare - Preapre the analog outputs.

 * @codec: the HDA codec

 * @mout: hda_multi_out object

 * @stream_tag: stream tag to assign

 * @format: format id to assign

 * @substream: PCM substream to assign

 *

 * Set up the i/o for analog out.

 * When the digital out is available, copy the front out to digital out, too.

 front */

 headphone out will just decode front left/right (stereo) */

 extra outputs copied from front */

 surrounds */

 independent out */

 copy front */

 extra surrounds */

/**

 * snd_hda_multi_out_analog_cleanup - clean up the setting for analog out

 * @codec: the HDA codec

 * @mout: hda_multi_out object

/**

 * snd_hda_get_default_vref - Get the default (mic) VREF pin bits

 * @codec: the HDA codec

 * @pin: referred pin NID

 *

 * Guess the suitable VREF pin bits to be set as the pin-control value.

 * Note: the function doesn't set the AC_PINCTL_IN_EN bit.

 Exception: if the default pin setup is vref50, we give it priority */

/**

 * snd_hda_correct_pin_ctl - correct the pin ctl value for matching with the pin cap

 * @codec: the HDA codec

 * @pin: referred pin NID

 * @val: pin ctl value to audit

 don't know what to do... */

/**

 * _snd_hda_set_pin_ctl - Helper to set pin ctl value

 * @codec: the HDA codec

 * @pin: referred pin NID

 * @val: pin control value to set

 * @cached: access over codec pinctl cache or direct write

 *

 * This function is a helper to set a pin ctl value more safely.

 * It corrects the pin ctl value via snd_hda_correct_pin_ctl(), stores the

 * value in pin target array via snd_hda_codec_set_pin_target(), then

 * actually writes the value via either snd_hda_codec_write_cache() or

 * snd_hda_codec_write() depending on @cached flag.

/**

 * snd_hda_add_imux_item - Add an item to input_mux

 * @codec: the HDA codec

 * @imux: imux helper object

 * @label: the name of imux item to assign

 * @index: index number of imux item to assign

 * @type_idx: pointer to store the resultant label index

 *

 * When the same label is used already in the existing items, the number

 * suffix is appended to the label.  This label index number is stored

 * to type_idx when non-NULL pointer is given.

/**

 * snd_hda_bus_reset_codecs - Reset the bus

 * @bus: HD-audio bus

 FIXME: maybe a better way needed for forced reset */

/**

 * snd_print_pcm_bits - Print the supported PCM fmt bits to the string buffer

 * @pcm: PCM caps bits

 * @buf: the string buffer to write

 * @buflen: the max buffer length

 *

 * used by hda_proc.c and hda_eld.c

 necessary when j == 0 */

 SPDX-License-Identifier: GPL-2.0

/* Fixes for HP X360 laptops with top B&O speakers

 * to be included from codec driver

 SPDX-License-Identifier: GPL-2.0-only

/*

 * sysfs interface for HD-audio codec

 *

 * Copyright (c) 2014 Takashi Iwai <tiwai@suse.de>

 *

 * split from hda_hwdep.c

 hint string pair */

 contained in the same alloc as key */

 CONFIG_PM */

/*

 * sysfs interface

/*

 * allocate a string at most len chars, and remove the trailing EOL

 extract key and val */

 replace */

 allocate a new hint entry */

 sysfs attributes exposed only when CONFIG_SND_HDA_RECONFIG=y */

/**

 * snd_hda_get_hint - Look for hint string

 * @codec: the HDA codec

 * @key: the hint key string

 *

 * Look for a hint key/value pair matching with the given key string

 * and returns the value string.  If nothing found, returns NULL.

/**

 * snd_hda_get_bool_hint - Get a boolean hint value

 * @codec: the HDA codec

 * @key: the hint key string

 *

 * Look for a hint key/value pair matching with the given key string

 * and returns a boolean value parsed from the value.  If no matching

 * key is found, return a negative value.

 true */

 yes */

/**

 * snd_hda_get_int_hint - Get an integer hint value

 * @codec: the HDA codec

 * @key: the hint key string

 * @valp: pointer to store a value

 *

 * Look for a hint key/value pair matching with the given key string

 * and stores the integer value to @valp.  If no matching key is found,

 * return a negative error code.  Otherwise it returns zero.

 CONFIG_SND_HDA_RECONFIG */

/*

 * common sysfs attributes

 parser mode */

/* parse the contents after the line "[codec]"

 * accept only the line with three numbers, and assign the current codec

/* parse the contents after the other command tags, [pincfg], [verb],

 * [vendor_id], [subsystem_id], [revision_id], [chip_name], [hint] and [model]

 * just pass to the sysfs helper (only when any codec was specified)

 check the line starting with '[' -- change the parser mode accodingly */

/* copy one line from the buffer in fw, and update the fields in fw

 * return zero if it reaches to the end of the buffer, or non-zero

 * if successfully copied a line

 *

 * the spaces at the beginning and the end of the line are stripped

/**

 * snd_hda_load_patch - load a "patch" firmware file and parse it

 * @bus: HD-audio bus

 * @fw_size: the firmware byte size

 * @fw_buf: the firmware data

 CONFIG_SND_HDA_PATCH_LOADER */

/*

 * sysfs entries

 clear init verbs */

 clear hints */

 we don't need to free hint->val */

 SPDX-License-Identifier: GPL-2.0

 Fixes for Lenovo Ideapad S740, to be included from codec driver */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Jack-detection handling for HD-audio

 *

 * Copyright (c) 2011 Takashi Iwai <tiwai@suse.de>

/**

 * is_jack_detectable - Check whether the given pin is jack-detectable

 * @codec: the HDA codec

 * @nid: pin NID

 *

 * Check whether the given pin is capable to report the jack detection.

 * The jack detection might not work by various reasons, e.g. the jack

 * detection is prohibited in the codec level, the pin config has

 * AC_DEFCFG_MISC_NO_PRESENCE bit, no unsol support, etc.

 execute pin sense measurement */

 need trigger? */

/**

 * snd_hda_jack_tbl_get_mst - query the jack-table entry for the given NID

 * @codec: the HDA codec

 * @nid: pin NID to refer to

 * @dev_id: pin device entry id

/**

 * snd_hda_jack_tbl_get_from_tag - query the jack-table entry for the given tag

 * @codec: the HDA codec

 * @tag: tag value to refer to

 * @dev_id: pin device entry id

/**

 * snd_hda_jack_tbl_new - create a jack-table entry for the given NID

 * @codec: the HDA codec

 * @nid: pin NID to assign

 * @dev_id: pin device entry id

		/*

		 * Copy jack_detect from existing_nid_jack to avoid

		 * snd_hda_jack_detect_enable_callback_mst() making multiple

		 * SET_UNSOLICITED_ENABLE calls on the same pin.

 free jack instances manually when clearing/reconfiguring */

 update the cached value and notification flag if needed */

 A gating jack indicates the jack is invalid if gating is unplugged */

 If a jack is gated by this one update it. */

/**

 * snd_hda_jack_set_dirty_all - Mark all the cached as dirty

 * @codec: the HDA codec

 *

 * This function sets the dirty flag to all entries of jack table.

 * It's called from the resume path in hda_codec.c.

/**

 * snd_hda_jack_pin_sense - execute pin sense measurement

 * @codec: the CODEC to sense

 * @nid: the pin NID to sense

 * @dev_id: pin device entry id

 *

 * Execute necessary pin sense measurement and return its Presence Detect,

 * Impedance, ELD Valid etc. status bits.

/**

 * snd_hda_jack_detect_state_mst - query pin Presence Detect status

 * @codec: the CODEC to sense

 * @nid: the pin NID to sense

 * @dev_id: pin device entry id

 *

 * Query and return the pin's Presence Detect status, as either

 * HDA_JACK_NOT_PRESENT, HDA_JACK_PRESENT or HDA_JACK_PHANTOM.

/**

 * snd_hda_jack_detect_enable_callback_mst - enable the jack-detection

 * @codec: the HDA codec

 * @nid: pin NID to enable

 * @func: callback function to register

 * @dev_id: pin device entry id

 *

 * In the case of error, the return value will be a pointer embedded with

 * errno.  Check and handle the return value appropriately with standard

 * macros such as @IS_ERR() and @PTR_ERR().

 already registered */

 No unsol if we're polling instead */

/**

 * snd_hda_jack_detect_enable - Enable the jack detection on the given pin

 * @codec: the HDA codec

 * @nid: pin NID to enable jack detection

 * @dev_id: pin device entry id

 *

 * Enable the jack detection with the default callback.  Returns zero if

 * successful or a negative error code.

/**

 * snd_hda_jack_set_gating_jack - Set gating jack.

 * @codec: the HDA codec

 * @gated_nid: gated pin NID

 * @gating_nid: gating pin NID

 *

 * Indicates the gated jack is only valid when the gating jack is plugged.

/**

 * snd_hda_jack_bind_keymap - bind keys generated from one NID to another jack.

 * @codec: the HDA codec

 * @key_nid: key event is generated by this pin NID

 * @keymap: map of key type and key code

 * @jack_nid: key reports to the jack of this pin NID

 *

 * This function is used in the case of key is generated from one NID while is

 * reported to the jack of another NID.

/**

 * snd_hda_jack_set_button_state - report button event to the hda_jack_tbl button_state.

 * @codec: the HDA codec

 * @jack_nid: the button event reports to the jack_tbl of this NID

 * @button_state: the button event captured by codec

 *

 * Codec driver calls this function to report the button event.

/**

 * snd_hda_jack_report_sync - sync the states of all jacks and report if changed

 * @codec: the HDA codec

 update all jacks at first */

	/* report the updated jacks; it's done after updating all jacks

	 * to make sure that all gating jacks properly have been set

 button released */

 guess the jack type from the pin-config */

/**

 * snd_hda_jack_add_kctl_mst - Add a kctl for the given pin

 * @codec: the HDA codec

 * @nid: pin NID to assign

 * @dev_id : pin device entry id

 * @name: string name for the jack

 * @phantom_jack: flag to deal as a phantom jack

 * @type: jack type bits to be reported, 0 for guessing from pincfg

 * @keymap: optional jack / key mapping

 *

 * This assigns a jack-detection kctl to the given pin.  The kcontrol

 * will have the given name and index.

 already created */

 Example final name: "Internal Mic Phantom Jack" */

/**

 * snd_hda_jack_add_kctls - Add kctls for all pins included in the given pincfg

 * @codec: the HDA codec

 * @cfg: pin config table to parse

		/* If we have headphone mics; make sure they get the right name

 might be duplicated */

 might be duplicated */

/**

 * snd_hda_jack_unsol_event - Handle an unsolicited event

 * @codec: the HDA codec

 * @res: the unsolicited event data

/**

 * snd_hda_jack_poll_all - Poll all jacks

 * @codec: the HDA codec

 *

 * Poll all detectable jacks with dirty flag, update the status, call

 * callbacks and call snd_hda_jack_report_sync() if any changes are found.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * HD audio interface patch for Creative CA0132 chip

 *

 * Copyright (c) 2011, Creative Technology Ltd.

 *

 * Based on patch_ca0110.c

 * Copyright (c) 2008 Takashi Iwai <tiwai@suse.de>

 Enable this to see controls for tuning purpose. */

#define ENABLE_TUNING_CONTROLS*/

 Strings for Input Source Enum Control */

 Speaker vnid */

 Effects values size*/

/*

 * Default values for the effect slider controls, they are in order of their

 * effect NID's. Surround, Crystalizer, Dialog Plus, Smart Volume, and then

 * X-bass.

 Amount of effect level sliders for ca0132_alt controls. */

 Latency introduced by DSP blocks in milliseconds. */

effect module ID*/

effect module request*/

 0:output; 1:input*/

 number of default non-on/off params */

effect default values, 1st is on/off. */

 Tuning controls */

effect module ID*/

effect module request*/

 0:output; 1:input*/

effect default values*/

 Voice FX Presets */

effect module request*/

preset name*/

 ca0132 EQ presets, taken from Windows Sound Blaster Z Driver */

effect module request*/

preset name*/

/*

 * DSP reqs for handling full-range speakers/bass redirection. If a speaker is

 * set as not being full range, and bass redirection is enabled, all

 * frequencies below the crossover frequency are redirected to the LFE

 * channel. If the surround configuration has no LFE channel, this can't be

 * enabled. X-Bass must be disabled when using these.

 Between 0x16-0x1a are the X-Bass reqs. */

/*

 * Definitions for the DSP req's to handle speaker tuning. These all belong to

 * module ID 0x96, the output effects module.

	/*

	 * Currently, this value is always set to 0.0f. However, on Windows,

	 * when selecting certain headphone profiles on the new Sound Blaster

	 * connect software, the QUERY_SPEAKER_EQ_ADDRESS req on mid 0x80 is

	 * sent. This gets the speaker EQ address area, which is then used to

	 * send over (presumably) an equalizer profile for the specific

	 * headphone setup. It is sent using the same method the DSP

	 * firmware is uploaded with, which I believe is why the 'ctspeq.bin'

	 * file exists in linux firmware tree but goes unused. It would also

	 * explain why the QUERY_SPEAKER_EQ_ADDRESS req is defined but unused.

	 * Once this profile is sent over, SPEAKER_TUNING_USE_SPEAKER_EQ is

	 * set to 1.0f.

	/*

	 * Inversion is used when setting headphone virtualization to line

	 * out. Not sure why this is, but it's the only place it's ever used.

 Delay is used when setting surround speaker distance in Windows. */

 Of these two, only mute seems to ever be used. */

 Surround output channel count configuration structures. */

/*

 * DSP volume setting structs. Req 1 is left volume, req 2 is right volume,

 * and I don't know what the third req is, but it's always zero. I assume it's

 * some sort of update or set command to tell the DSP there's new volume info.

 module ID*/

 scp req ID */

 Values for ca0113_mmio_command_set for selecting output. */

 Speakers. */

 Headphones. */

 Speakers. */

 Headphones. */

 ae5 ca0113 command sequences to set headphone gain levels. */

/*

 * Data structures for storing audio router remapping data. These are used to

 * remap a currently active streams ports.

 for DspIO node */

 for ChipIO node */

/*

 *  Control flag IDs

 Connection manager stream setup is bypassed/enabled */

 DSP DMA is bypassed/enabled */

 8051 'idle' mode is disabled/enabled */

 Tracker for the SPDIF-in path is bypassed/enabled */

 DigitalOut to Spdif2Out connection is disabled/enabled */

 Digital Microphone is disabled/enabled */

 ADC_B rate is 48 kHz/96 kHz */

 ADC_C rate is 48 kHz/96 kHz */

 DAC rate is 48 kHz/96 kHz (affects all DACs) */

 DSP rate is 48 kHz/96 kHz */

 SRC clock is 98 MHz/196 MHz (196 MHz forces rate to 96 KHz) */

 SRC rate is 48 kHz/96 kHz (48 kHz disabled when clock is 196 MHz) */

 Decode Loop (DSP->SRC->DSP) is disabled/enabled */

 De-emphasis filter on DAC-1 disabled/enabled */

 De-emphasis filter on DAC-2 disabled/enabled */

 De-emphasis filter on DAC-3 disabled/enabled */

 High-pass filter on ADC_B disabled/enabled */

 High-pass filter on ADC_C disabled/enabled */

 Common mode on Port_A disabled/enabled */

 Common mode on Port_D disabled/enabled */

 Impedance for ramp generator on Port_A 16 Ohm/10K Ohm */

 Impedance for ramp generator on Port_D, 16 Ohm/10K Ohm */

 ASI rate is 48kHz/96kHz */

 DAC power settings able to control attached ports no/yes */

 Clock Stop OK reporting is disabled/enabled */

 Number of control flags */

/*

 * Control parameter IDs

 0: None, 1: Mic1In*/

 0: force HDA, 1: allow DSP if HDA Spdif1Out stream is idle */

	/* Port A output stage gain setting to use when 16 Ohm output

	/* Port D output stage gain setting to use when 16 Ohm output

	/*

	 * This control param name was found in the 8051 memory, and makes

	 * sense given the fact the AE-5 uses it and has the ASI flag set.

 Stream Control */

 Select stream with the given ID */

 Source connection point for the selected stream */

 Destination connection point for the selected stream */

 Number of audio channels in the selected stream */

Enable control for the selected stream */

 Connection Point Control */

 Select connection point with the given ID */

 Connection point sample rate */

 Node Control */

 Select HDA node with the given ID */

/*

 *  Dsp Io Status codes

 Success */

 Busy, unable to accept new command, the host must retry */

 SCP command queue is full */

 SCP response queue is empty */

/*

 *  Chip Io Status codes

 Success */

 Busy, unable to accept new command, the host must retry */

/*

 *  CA0132 sample rate

 retrieve parameters from hda format */

/*

 * CA0132 specific

 Nodes configurations */

 for desktop ca0132 codecs */

 chip access */

 chip access mutex */

 DSP download related */

 mixer and effects related */

 ca0132_alt control related values */

 AE-5 Control values */

 ZxR Control Values */

	/*

	 * The Recon3D, Sound Blaster Z, Sound Blaster ZxR, and Sound Blaster

	 * AE-5 all use PCI region 2 to toggle GPIO and other currently unknown

	 * things.

	/*

	 * Whether or not to use the alt functions like alt_select_out,

	 * alt_select_in, etc. Only used on desktop codecs for now, because of

	 * surround sound support.

	/*

	 * Whether or not to use alt controls:	volume effect sliders, EQ

	 * presets, smart volume presets, and new control names with FX prefix.

	 * Renames PlayEnhancement and CrystalVoice too.

/*

 * CA0132 quirks table

 Builtin Speaker */

 N/A */

 N/A */

 N/A */

 HP */

 Headset?  disabled for now */

 Mic */

 Builtin Mic */

 N/A */

 N/A */

 Sound Blaster Z pin configs taken from Windows Driver */

 Port G -- Lineout FRONT L/R */

 SPDIF Out 1 */

 Digital Out */

 SPDIF In */

 Port A -- BackPanel HP */

 Port D -- Center/LFE or FP Hp */

 Port B -- LineMicIn2 / Rear L/R */

 Port C -- LineIn1 */

 What U Hear In*/

 N/A */

 Sound Blaster ZxR pin configs taken from Windows Driver */

 Port G -- Lineout FRONT L/R */

 SPDIF Out 1 - Disabled*/

 Digital Out */

 SPDIF In - Disabled*/

 Port A -- BackPanel HP */

 Port D -- Center/LFE */

 Port B -- LineMicIn2 / Rear L/R */

 Port C -- LineIn1 */

 What U Hear In*/

 N/A */

 Recon3D pin configs taken from Windows Driver */

 Port G -- Lineout FRONT L/R */

 SPDIF Out 1 */

 Digital Out */

 SPDIF In */

 Port A -- BackPanel HP */

 Port D -- Center/LFE or FP Hp */

 Port B -- LineMicIn2 / Rear L/R */

 Port C -- LineIn1 */

 What U Hear In*/

 N/A */

 Sound Blaster AE-5 pin configs taken from Windows Driver */

 Port G -- Lineout FRONT L/R */

 SPDIF Out 1 */

 Digital Out */

 SPDIF In */

 Port A -- Rear L/R. */

 Port D -- Center/LFE or FP Hp */

 Port B -- LineMicIn2 / Rear Headphone */

 Port C -- LineIn1 */

 What U Hear In*/

 N/A */

 Recon3D integrated pin configs taken from Windows Driver */

 Port G -- Lineout FRONT L/R */

 SPDIF Out 1 */

 Digital Out */

 SPDIF In */

 Port A -- BackPanel HP */

 Port D -- Center/LFE or FP Hp */

 Port B -- LineMicIn2 / Rear L/R */

 Port C -- LineIn1 */

 What U Hear In*/

 N/A */

 Output selection quirk info structures. */

 ParamID 0x0d value. */

 Speakers. */

 Headphones. */

 Speakers. */

 Headphones. */

 Speakers. */

 Headphones. */

 Speakers. */

 Headphones. */

 Speakers. */

 Headphones. */

 Speakers. */

 Headphones. */

/*

 * CA0132 codec access

 Chip access helper function */

 send bits of data specified by reg */

/*

 * Write chip address through the vendor widget -- NOT protected by the Mutex!

 send low 16 bits of the address */

 send high 16 bits of the address */

/*

 * Write data through the vendor widget -- NOT protected by the Mutex!

 send low 16 bits of the data */

 send high 16 bits of the data */

	/*If no error encountered, automatically increment the address

/*

 * Write multiple data through the vendor widget -- NOT protected by the Mutex!

/*

 * Read data through the vendor widget -- NOT protected by the Mutex!

 post read */

 read status */

 read data */

	/*If no error encountered, automatically increment the address

/*

 * Write given value to the given address through the chip I/O widget.

 * protected by the Mutex

 write the address, and if successful proceed to write data */

/*

 * Write given value to the given address through the chip I/O widget.

 * not protected by the Mutex

 write the address, and if successful proceed to write data */

/*

 * Write multiple values to the given address through the chip I/O widget.

 * protected by the Mutex

/*

 * Read the given address through the chip I/O widget

 * protected by the Mutex

 write the address, and if successful proceed to write data */

/*

 * Set chip control flags through the chip I/O widget.

/*

 * Set chip parameters through the chip I/O widget.

/*

 * Set chip parameters through the chip I/O widget. NO MUTEX.

/*

 * Connect stream to a source point, and then connect

 * that source point to a destination point.

/*

 * Set number of channels in the selected stream.

/*

 * Enable/Disable audio stream.

/*

 * Get ChipIO audio stream's status.

/*

 * Set sampling rate of the connection point. NO MUTEX.

/*

 * Set sampling rate of the connection point.

/*

 * Writes to the 8051's internal address space directly instead of indirectly,

 * giving access to the special function registers located at addresses

 * 0x80-0xFF.

/*

 * Writes to the 8051's exram, which has 16-bits of address space.

 * Data at addresses 0x2000-0x7fff is mirrored to 0x8000-0xdfff.

 * Data at 0x8000-0xdfff can also be used as program memory for the 8051 by

 * setting the pmem bank selection SFR.

 * 0xe000-0xffff is always mapped as program memory, with only 0xf000-0xffff

 * being writable.

 Lower 8-bits. */

 Upper 8-bits. */

 8-bits of data. */

 PLL_PMU writes share the lower address register of the 8051 exram writes. */

 8-bits of data. */

 Readback data from the 8051's exram. No mutex. */

/*

 * Enable clocks.

/*

 * CA0132 DSP IO stuffs

 send bits of data specified by reg to dsp */

/*

 * Wait for DSP to be ready for commands

/*

 * Write SCP data to DSP

 OK, now check if the write itself has executed*/

/*

 * Write multiple SCP data to DSP

/*

 * Construct the SCP header using corresponding fields

/*

 * Extract corresponding fields from SCP header

 Structure to contain any SCP message */

 clear all from the response queue */

/*

 * Send SCP message to DSP

 get scp header from buffer */

 swap source id with target id */

/**

 * dspio_scp - Prepare and send the SCP message to DSP

 * @codec: the HDA codec

 * @mod_id: ID of the DSP module to send the command

 * @src_id: ID of the source

 * @req: ID of request to send to the DSP module

 * @dir: SET or GET

 * @data: pointer to the data to send with the request, request specific

 * @len: length of the data, in bytes

 * @reply: point to the buffer to hold data returned for a reply

 * @reply_len: length of the reply buffer returned from GET

 *

 * Returns zero or a negative error code.

 extract send and reply headers members */

/*

 * Set DSP parameters

/*

 * Allocate a DSP DMA channel via an SCP message

/*

 * Free a DSP DMA via an SCP message

/*

 * (Re)start the DSP

/*

 * Reset the DSP

/*

 * Convert chip address to DSP address

/*

 * Check if the DSP DMA is active

/*

 * Setup the DSP DMA per-transfer-specific registers

/*

 * Start the DSP DMA

/*

 * Stop the DSP DMA

/**

 * dsp_allocate_router_ports - Allocate router ports

 *

 * @codec: the HDA codec

 * @num_chans: number of channels in the stream

 * @ports_per_channel: number of ports per channel

 * @start_device: start device

 * @port_map: pointer to the port list to hold the allocated ports

 *

 * Returns zero or a negative error code.

/*

 * Free router ports

/*

 * Allocate DSP ports for the download stream

/*

 * free DSP ports

/*

 *  HDA DMA engine stuffs for DSP code download

/*

 *  Reset DMA for DSP download

/*

 * CA0132 chip DSP transfer stuffs.  For DSP download.

/*

 * Program a list of address/data pairs via the ChipIO widget.

 * The segment data is in the format of successive pairs of words.

 * These are repeated as indicated by the segment's count field.

/**

 * dspxfr_one_seg - Write a block of data into DSP code or data RAM using pre-allocated DMA engine.

 *

 * @codec: the HDA codec

 * @fls: pointer to a fast load image

 * @reloc: Relocation address for loading single-segment overlays, or 0 for

 *	   no relocation

 * @dma_engine: pointer to DMA engine to be used for DSP download

 * @dma_chan: The number of DMA channels used for DSP download

 * @port_map_mask: port mapping

 * @ovly: TRUE if overlay format is required

 *

 * Returns zero or a negative error code.

/**

 * dspxfr_image - Write the entire DSP image of a DSP code/data overlay to DSP memories

 *

 * @codec: the HDA codec

 * @fls_data: pointer to a fast load image

 * @reloc: Relocation address for loading single-segment overlays, or 0 for

 *	   no relocation

 * @sample_rate: sampling rate of the stream used for DSP download

 * @channels: channels of the stream used for DSP download

 * @ovly: TRUE if overlay format is required

 *

 * Returns zero or a negative error code.

/*

 * CA0132 DSP download stuffs.

set DSP speaker to 2.0 configuration*/

update write pointer*/

/**

 * dspload_image - Download DSP from a DSP Image Fast Load structure.

 *

 * @codec: the HDA codec

 * @fls: pointer to a fast load image

 * @ovly: TRUE if overlay format is required

 * @reloc: Relocation address for loading single-segment overlays, or 0 for

 *	   no relocation

 * @autostart: TRUE if DSP starts after loading; ignored if ovly is TRUE

 * @router_chans: number of audio router channels to be allocated (0 means use

 *		  internal defaults; max is 32)

 *

 * Download DSP from a DSP Image Fast Load structure. This structure is a

 * linear, non-constant sized element array of structures, each of which

 * contain the count of the data to be loaded, the data itself, and the

 * corresponding starting chip address of the starting data location.

 * Returns zero or a negative error code.

/*

 * ca0113 related functions. The ca0113 acts as the HDA bus for the pci-e

 * based cards, and has a second mmio region, region2, that's used for special

 * commands.

/*

 * For cards with PCI-E region2 (Sound Blaster Z/ZxR, Recon3D, and AE-5)

 * the mmio address 0x320 is used to set GPIO pins. The format for the data

 * The first eight bits are just the number of the pin. So far, I've only seen

 * this number go to 7.

 * AE-5 note: The AE-5 seems to use pins 2 and 3 to somehow set the color value

 * of the on-card LED. It seems to use pin 2 for data, then toggles 3 to on and

 * then off to send that bit.

/*

 * Special pci region2 commands that are only used by the AE-5. They follow

 * a set format, and require reads at certain points to seemingly 'clear'

 * the response data. My first tests didn't do these reads, and would cause

 * the card to get locked up until the memory was read. These commands

 * seem to work with three distinct values that I've taken to calling group,

 * target-id, and value.

	/*

	 * Need delay here or else it goes too fast and works inconsistently.

/*

 * This second type of command is used for setting the sound filter type.

/*

 * Setup GPIO for the other variants of Core3D.

/*

 * Sets up the GPIO pins so that they are discoverable. If this isn't done,

 * the card shows as having no GPIO pins.

 Sets the GPIO for audio output. */

/*

 * GPIO control functions for the Recon3D integrated.

 Bit 1 - Switch between front/rear mic. 0 = rear, 1 = front */

 Bit 2 - Switch between headphone/line out. 0 = Headphone, 1 = Line */

	/*

	 * I dunno what this actually does, but it stays on until the dsp

	 * is downloaded.

	/*

	 * Same as above, no clue what it does, but it comes on after the dsp

	 * is downloaded.

 Set GPIO bit 1 to 0 for rear mic */

 Set GPIO bit 1 to 1 for front microphone*/

 Set GPIO bit 2 to 0 for headphone */

 Set GPIO bit 2 to 1 for speaker */

 Set GPIO bit 3 to 1 until DSP is downloaded */

 Set GPIO bit 4 to 1 once DSP is downloaded */

 Get the current GPIO Data setup */

 Get the current GPIO Data setup */

 Set DOWNLOADING bit to 0. */

/*

 * PCM callbacks

	/*If Playback effects are on, allow stream some time to flush

 Add latency if playback enhancement and either effect is enabled. */

 Applying Speaker EQ adds latency as well. */

/*

 * Digital out

/*

 * Analog capture

/*

 * Controls stuffs.

/*

 * Mixer controls helpers.

/*

 * Creates a mixer control that uses defaults of HDA_CODEC_VOL except for the

 * volume put, which is used for setting the DSP volume. This was done because

 * the ca0132 functions were taking too much time and causing lag.

 stereo */

 lookup tables */

/*

 * Lookup table with decibel values for the DSP. When volume is changed in

 * Windows, the DSP is also sent the dB value in floating point. In Windows,

 * these values have decimal points, probably because the Windows driver

 * actually uses floating point. We can't here, so I made a lookup table of

 * values -90 to 9. -90 is the lowest decibel value for both the ADC's and the

 * DAC's, and 9 is the maximum.

/*

 * This table counts from float 0 to 1 in increments of .01, which is

 * useful for a few different sliders.

/*

 * This table counts from float 10 to 1000, which is the range of the x-bass

 * crossover slider in Windows.

 The following are for tuning of products */

 any change? */

 any change? */

 any change? */

 Wedge Angle defaults to 30.  10 below is 30 - 20.  20 is min. */

 SVM level defaults to 0.74. */

 EQ defaults to 0dB. */

ENABLE_TUNING_CONTROLS*/

/*

 * Select the active output.

 * If autodetect is enabled, output will be selected based on jack detection.

 * If jack inserted, headphone will be selected, else built-in speakers

 * If autodetect is disabled, output will be selected based on selection.

speaker out config*/

enable speaker EQ*/

 Setup EAPD */

 disable headphone node */

 enable speaker node */

headphone out config*/

disable speaker EQ*/

 Setup EAPD */

 disable speaker*/

 enable headphone*/

 2.0/4.0 setup has no LFE channel, so setting full-range does nothing. */

 Set front L/R full range. Zero for full-range, one for redirection. */

 When setting full-range rear, both rear and center/lfe are set. */

	/*

	 * Only the AE series cards set this value when setting full-range,

	 * and it's always 1.0f.

 If it is enabled, make sure to set the crossover frequency. */

/*

 * These are the commands needed to setup output on each of the different card

 * types.

/*

 * This function behaves similarly to the ca0132_select_out funciton above,

 * except with a few differences. It adds the ability to select the current

 * output with an enumerated control "output source" if the auto detect

 * mute switch is set to off. If the auto detect mute switch is enabled, it

 * will detect either headphone or lineout(SPEAKER_OUT) from jack detection.

 * It also adds the ability to auto-detect the front headphone port.

 Default Headphone is rear headphone */

	/*

	 * If headphone rear or front is plugged in, set to headphone.

	 * If neither is plugged in, set to rear line out. Only if

	 * hp/speaker auto detect is enabled.

 Begin DSP output switch, mute DSP volume. */

 Enable EAPD */

 Disable headphone node. */

 Set front L-R to output. */

 Set Center/LFE to output. */

 Set rear surround to output. */

		/*

		 * Without PlayEnhancement being enabled, if we've got a 2.0

		 * setup, set it to floating point eight to disable any DSP

		 * processing effects.

 Disable all speaker nodes. */

 enable headphone, either front or rear */

	/*

	 * If output effects are enabled, set the X-Bass effect value again to

	 * make sure that it's properly enabled/disabled for speaker

	 * configurations with an LFE channel.

 Set speaker EQ bypass attenuation to 0. */

	/*

	 * Although unused on all cards but the AE series, this is always set

	 * to zero when setting the output.

 Unmute DSP now that we're done with output selection. */

/*

 * Select the active VIP source

 if CrystalVoice if off, vipsource should be 0 */

 if CrystalVoice is off, vipsource should be 0 */

/*

 * Select the active microphone.

 * If autodetect is enabled, mic will be selected based on jack detection.

 * If jack inserted, ext.mic will be selected, else built-in mic

 * If autodetect is disabled, mic will be selected based on selection.

 enable digital Mic */

 set voice focus */

 disable digital Mic */

 disable voice focus */

/*

 * Select the active input.

 * Mic detection isn't used, because it's kind of pointless on the SBZ.

 * The front mic has no jack-detection, so the only way to switch to it

 * is to do it manually in alsamixer.

/*

 * Check if VNODE settings take effect immediately.

/*

* The following functions are control change helpers.

* They return 0 if no changed.  Return 1 if changed.

 based on CrystalVoice state to enable VoiceFX. */

/*

 * Set the effects parameters

 no changed */

 for out effect, qualify with PE */

 if PE if off, turn off out effects. */

 for in effect, qualify with CrystalVoice */

 if CrystalVoice if off, turn off in effects. */

 Voice Focus applies to 2-ch Mic, Digital Mic */

 If Voice Focus on SBZ, set to two channel. */

		/*

		 * For SBZ noise reduction, there's an extra command

		 * to module ID 0x47. No clue why.

 If rear line in disable effects. */

 no changed */

/*

 * Turn on/off Playback Enhancements

 PE affects all out effects */

 Check if Mic1 is streaming, if so, stop streaming */

 Resume Mic1 streaming if it was stopped. */

 Restore the previous stream and channel */

/*

 * Turn on/off CrystalVoice

 CrystalVoice affects all in effects */

 including VoiceFX */

 set correct vipsource */

 on */

 off */

/*

 * gpio pin 1 is a relay that switches on/off, apparently setting the headphone

 * amplifier to handle a 600 ohm load.

 if effective conditions, then update hw immediately. */

 End of control change helpers. */

/*

 * Below I've added controls to mess with the effect levels, I've only enabled

 * them on the Sound Blaster Z, but they would probably also work on the

 * Chromebook. I figured they were probably tuned specifically for it, and left

 * out for a reason.

 Sets DSP effect level from the sliders above the controls */

	/*

	 * For X_BASS, req 2 is actually crossover freq instead of

	 * effect level

 Find the actual effect structure */

/*

 * The X-bass crossover starts at 10hz, so the min is 1. The

 * frequency is set in multiples of 10.

 any change? */

 any change? */

/*

 * Mic Boost Enum for alternative ca0132 codecs. I didn't like that the original

 * only has off or full 30 dB, and didn't like making a volume slider that has

 * traditional 0-100 in alsamixer that goes in big steps. I like enum better.

/*

 * Sound BlasterX AE-5 Headphone Gain Controls.

/*

 * Sound BlasterX AE-5 sound filter enumerated control.

/*

 * Input Select Control for alternative ca0132 codecs. This exists because

 * front microphone has no auto-detect, and we need a way to set the rear

 * as line-in

	/*

	 * The AE-7 has no front microphone, so limit items to 2: rear mic and

	 * line-in.

 Sound Blaster Z Output Select Control */

 Select surround output type: 2.1, 4.0, 4.1, or 5.1. */

/*

 * Smart Volume output setting control. Three different settings, Normal,

 * which takes the value from the smart volume slider. The two others, loud

 * and night, disregard the slider value and have uneditable values.

 Req 2 is the Smart Volume Setting req. */

 Sound Blaster Z EQ preset controls */

	/*

	 * Idx 0 is default.

	 * Default needs to qualify with CrystalVoice state.

	/*

	 * Idx 0 is default.

	 * Default needs to qualify with CrystalVoice state.

 enable voice fx */

 vnode */

 effects, include PE and CrystalVoice */

 mic boost */

 vnode */

 PE */

 CrystalVoice */

 out and in effects */

 mic boost */

 Mic boost does not apply to Digital Mic */

/*

 * Volume related

/*

 * Sets the internal DSP decibel level to match the DAC for output, and the

 * ADC for input. Currently only the SBZ sets dsp capture volume level, and

 * all alternative codecs set DSP playback volume.

 follow shared_out info */

 follow shared_mic info */

 store the left and right volume */

 store the left and right volume */

 if effective conditions, then update hw immediately. */

/*

 * This function is the same as the one above, because using an if statement

 * inside of the above volume control for the DSP volume would cause too much

 * lag. This is a lot more smooth.

 store the left and right volume */

 follow shared_out tlv */

 follow shared_mic tlv */

 Add volume slider control for effect level */

/*

 * Added FX: prefix for the alternative codecs, because otherwise the surround

 * effect would conflict with the Surround sound volume control. Also seems more

 * clear as to what the switches do. Left alone for others.

	/* If using alt_controls, add FX: prefix. But, don't add FX:

	 * prefix to OutFX or InFX enable controls.

 Create the EQ Preset control */

/*

 * Add enumerated control for the three different settings of the smart volume

 * output effect. Normal just uses the slider value, and loud and night are

 * their own things that ignore that value.

/*

 * Create an Output Select enumerated control for codecs with surround

 * out capabilities.

/*

 * Add a control for selecting channel count on speaker output. Setting this

 * allows the DSP to do bass redirection and channel upmixing on surround

 * configurations.

/*

 * Full range front stereo and rear surround switches. When these are set to

 * full range, the lower frequencies from these channels are no longer

 * redirected to the LFE channel.

/*

 * Bass redirection redirects audio below the crossover frequency to the LFE

 * channel on speakers that are set as not being full-range. On configurations

 * without an LFE channel, it does nothing. Bass redirection seems to be the

 * replacement for X-Bass on configurations with an LFE channel.

/*

 * Create an Input Source enumerated control for the alternate ca0132 codecs

 * because the front microphone has no auto-detect, and Line-in has to be set

 * somehow.

/*

 * Add mic boost enumerated control. Switches through 0dB to 30dB. This adds

 * more control than the original mic boost, which is either full 30dB or off.

/*

 * Add headphone gain enumerated control for the AE-5. This switches between

 * three modes, low, medium, and high. When non-headphone outputs are selected,

 * it is automatically set to high. This is the same behavior as Windows.

/*

 * Add sound filter enumerated control for the AE-5. This adds three different

 * settings: Slow Roll Off, Minimum Phase, and Fast Roll Off. From what I've

 * read into it, it changes the DAC's interpolation filter.

/*

 * Need to create follower controls for the alternate codecs that have surround

 * capabilities.

/*

 * Also need special channel map, because the default one is incorrect.

 * I think this has to do with the pin for rear surround being 0x11,

 * and the center/lfe being 0x10. Usually the pin order is the opposite.

 Add the correct chmap for streams with 6 channels. */

/*

 * When changing Node IDs for Mixer Controls below, make sure to update

 * Node IDs in ca0132_config() as well.

 end */

/*

 * Desktop specific control mixer. Removes auto-detect for mic, and adds

 * surround controls. Also sets both the Front Playback and Capture Volume

 * controls to alt so they set the DSP's decibel level.

 end */

/*

 * Same as the Sound Blaster Z, except doesn't use the alt volume for capture

 * because it doesn't set decibel levels for the DSP for capture.

 end */

 Add Mixer controls */

 Setup vmaster with surround followers for desktop ca0132 devices */

	/* Add in and out effects controls.

	 * VoiceFX, PE and CrystalVoice are added separately.

 Desktop cards break if Echo Cancellation is used. */

	/*

	 * If codec has use_alt_controls set to true, add effect level sliders,

	 * EQ presets, and Smart Volume presets. Also, change names to add FX

	 * prefix, and change PlayEnhancement and CrystalVoice to match.

	/*

	 * If the codec uses alt_functions, you need the enumerated controls

	 * to select the new outputs and inputs, plus add the new mic boost

	 * setting control.

		/*

		 * ZxR only has microphone input, there is no front panel

		 * header on the card, and aux-in is handled by the DBPro board.

 spec->multiout.share_spdif = 1; */

/*

 * PCM

 With the DSP enabled, desktops don't use this ADC. */

 init to 0 dB and unmute. */

/*

 * Switch between Digital built-in mic and analog mic.

 set DMic input as 2-ch */

 set AMic input as mono */

 clear bit7 and bit5 to disable dmic */

/*

 * Initialization for Digital Mic.

	/* Setup Digital Mic here, but don't enable.

	 * Enable based on jack detect.

	/* MCLK uses MPIO1, set to enable.

	 * Bit 2-0: MPIO select

	 * Bit   3: set to disable

	 * Bit 7-4: reserved

	/* Data1 uses MPIO3. Data2 not use

	 * Bit 2-0: Data1 MPIO select

	 * Bit   3: set disable Data1

	 * Bit 6-4: Data2 MPIO select

	 * Bit   7: set disable Data2

	/* Use Ch-0 and Ch-1. Rate is 48K, mode 1. Disable DMic first.

	 * Bit 3-0: Channel mask

	 * Bit   4: set for 48KHz, clear for 32KHz

	 * Bit   5: mode

	 * Bit   6: set to select Data2, clear for Data1

	 * Bit   7: set to enable DMic, clear for AMic

 keep a copy of dmic ctl val for enable/disable dmic purpuse */

/*

 * Initialization for Analog Mic 2

 If there is an active channel for some reason, find it and free it. */

 Read active DSPDMAC channel register. */

 AND against 0xfff to get the active channel bits. */

 If there are no active channels, nothing to free. */

	/*

	 * Check each DSP DMA channel for activity, and if the channel is

	 * active, free it.

/*

 * In the case of CT_EXTENSIONS_ENABLE being set to 1, and the DSP being in

 * use, audio is no longer routed directly to the DAC/ADC from the HDA stream.

 * Instead, audio is now routed through the DSP's DMA controllers, which

 * the DSP is tasked with setting up itself. Through debugging, it seems the

 * cause of most of the no-audio on startup issues were due to improperly

 * configured DSP DMA channels.

 *

 * Normally, the DSP configures these the first time an HDA audio stream is

 * started post DSP firmware download. That is why creating a 'dummy' stream

 * worked in fixing the audio in some cases. This works most of the time, but

 * sometimes if a stream is started/stopped before the DSP can setup the DMA

 * configuration registers, it ends up in a broken state. Issues can also

 * arise if streams are started in an unusual order, i.e the audio output dma

 * channel being sandwiched between the mic1 and mic2 dma channels.

 *

 * The solution to this is to make sure that the DSP has no DMA channels

 * in use post DSP firmware download, and then to manually start each default

 * DSP stream that uses the DMA channels. These are 0x0c, the audio output

 * stream, 0x03, analog mic 1, and 0x04, analog mic 2.

	/*

	 * Check if any of the default streams are active, and if they are,

	 * stop them.

	/*

	 * If all DSP streams are inactive, there should be no active DSP DMA

	 * channels. Check and make sure this is the case, and if it isn't,

	 * free any active channels.

 Make sure stream 0x0c is six channels. */

 Give the DSP some time to setup the DMA channel. */

/*

 * The region of ChipIO memory from 0x190000-0x1903fc is a sort of 'audio

 * router', where each entry represents a 48khz audio channel, with a format

 * of an 8-bit destination, an 8-bit source, and an unknown 2-bit number

 * value. The 2-bit number value is seemingly 0 if inactive, 1 if active,

 * and 3 if it's using Sample Rate Converter ports.

 * An example is:

 * 0x0001f8c0

 * In this case, f8 is the destination, and c0 is the source. The number value

 * is 1.

 * This region of memory is normally managed internally by the 8051, where

 * the region of exram memory from 0x1477-0x1575 has each byte represent an

 * entry within the 0x190000 range, and when a range of entries is in use, the

 * ending value is overwritten with 0xff.

 * 0x1578 in exram is a table of 0x25 entries, corresponding to the ChipIO

 * streamID's, where each entry is a starting 0x190000 port offset.

 * 0x159d in exram is the same as 0x1578, except it contains the ending port

 * offset for the corresponding streamID.

 *

 * On certain cards, such as the SBZ/ZxR/AE7, these are originally setup by

 * the 8051, then manually overwritten to remap the ports to work with the

 * new DACs.

 *

 * Currently known portID's:

 * 0x00-0x1f: HDA audio stream input/output ports.

 * 0x80-0xbf: Sample rate converter input/outputs. Only valid ports seem to

 *            have the lower-nibble set to 0x1, 0x2, and 0x9.

 * 0xc0-0xdf: DSP DMA input/output ports. Dynamically assigned.

 * 0xe0-0xff: DAC/ADC audio input/output ports.

 *

 * Currently known streamID's:

 * 0x03: Mic1 ADC to DSP.

 * 0x04: Mic2 ADC to DSP.

 * 0x05: HDA node 0x02 audio stream to DSP.

 * 0x0f: DSP Mic exit to HDA node 0x07.

 * 0x0c: DSP processed audio to DACs.

 * 0x14: DAC0, front L/R.

 *

 * It is possible to route the HDA audio streams directly to the DAC and

 * bypass the DSP entirely, with the only downside being that since the DSP

 * does volume control, the only volume control you'll get is through PCM on

 * the PC side, in the same way volume is handled for optical out. This may be

 * useful for debugging.

 Get the starting port for the stream to be remapped. */

	/*

	 * Check if the stream's port value is 0xff, because the 8051 may not

	 * have gotten around to setting up the stream yet. Wait until it's

	 * setup to remap it's ports.

 Offset isn't in bytes, its in 32-bit words, so multiply it by 4. */

 Update stream map configuration. */

/*

 * Default speaker tuning values setup for alternative codecs.

 Non-zero values are floating point 0.000198. */

 Non-zero values are floating point 0.000220. */

 Non-zero values are floating point 0.000100. */

/*

 * If we never change these, probably only need them on initialization.

/*

 * Initialize mic for non-chromebook ca0132 implementations.

 Mic 1 Setup */

 Mic 2 setup (not present on desktop cards) */

/*

 * Sets the source of stream 0x14 to connpointID 0x48, and the destination

 * connpointID to 0x91. If this isn't done, the destination is 0x71, and

 * you get no sound. I'm guessing this has to do with the Sound Blaster Z

 * having an updated DAC, which changes the destination to that DAC.

 This value is 0x43 for 96khz, and 0x83 for 192khz. */

 Setup stream 0x14 with it's source and destination points */

/*

 * Write data through ChipIO to setup proper stream destinations.

 * Not sure how it exactly works, but it seems to direct data

 * to different destinations. Example is f8 to c0, e0 to c0.

 * All I know is, if you don't set these, you get no sound.

 Remap DAC0's output ports. */

 Remap DSP audio output stream ports. */

	/*

	 * Param3 in the 8051's memory is represented by the ascii string 'mch'

	 * which seems to be 'multichannel'. This is also mentioned in the

	 * AE-5's registry values in Windows.

	/*

	 * I believe ASI is 'audio serial interface' and that it's used to

	 * change colors on the external LED strip connected to the AE-5.

 Seems to share the same port remapping as the SBZ. */

	/*

	 * In the 8051's memory, this param is referred to as 'n2sid', which I

	 * believe is 'node to streamID'. It seems to be a way to assign a

	 * stream to a given HDA node.

	/*

	 * Now, at this point on Windows, an actual stream is setup and

	 * seemingly sends data to the HDA node 0x09, which is the digital

	 * audio input node. This is left out here, because obviously I don't

	 * know what data is being sent. Interestingly, the AE-5 seems to go

	 * through the motions of getting here and never actually takes this

	 * step, but the AE-7 does.

	/*

	 * Runs again, this has been repeated a few times, but I'm just

	 * following what the Windows driver does.

/*

 * The Windows driver has commands that seem to setup ASI, which I believe to

 * be some sort of audio serial interface. My current speculation is that it's

 * related to communicating with the new DAC.

/*

 * Setup default parameters for DSP

 out, in effects + voicefx */

remove DSP headroom*/

set speaker EQ bypass attenuation*/

 set AMic1 and AMic2 as mono mic */

 set AMic1 as CrystalVoice input */

 set WUH source */

/*

 * Setup default parameters for Recon3D/Recon3Di DSP.

remove DSP headroom*/

 set WUH source */

 Set speaker source? */

 Disable mute on Center/LFE. */

 Setup effect defaults */

/*

 * Setup default parameters for the Sound Blaster Z DSP. A lot more going on

 * than the Chromebook setup.

	/*

	 * Sets internal input loopback to off, used to have a switch to

	 * enable input loopback, but turned out to be way too buggy.

remove DSP headroom*/

 set WUH source */

 Set speaker source? */

 out, in effects + voicefx */

/*

 * Setup default parameters for the Sound BlasterX AE-5 DSP.

 New, unknown SCP req's */

 Internal loopback off */

remove DSP headroom*/

 set WUH source */

 Set speaker source? */

 out, in effects + voicefx */

/*

 * Setup default parameters for the Sound Blaster AE-7 DSP.

 New, unknown SCP req's */

 Internal loopback off */

remove DSP headroom*/

 set WUH source */

 Set speaker source? */

	/*

	 * This is the second time we've called this, but this is seemingly

	 * what Windows does.

	/*

	 * Not sure why, but these are both set to 1. They're only set to 0

	 * upon shutdown.

 Volume control related. */

 out, in effects + voicefx */

/*

 * Initialization of flags in chip

/*

 * Initialization of parameters in chip

	/*

	 * Alternate firmwares for different variants. The Recon3Di apparently

	 * can use the default firmware, but I'll leave the option in case

	 * it needs it again.

	/*

	 * Use default ctefx.bin if no alt firmware is detected, or if none

	 * exists for your particular codec.

 NOP */

 don't retry failures */

 For codecs using alt functions, this is already done earlier */

	/* Delay enabling the HP amp, to let the mic-detection

	 * state machine run.

 Front headphone jack detection */

/*

 * Verbs tables.

 Sends before DSP download. */

enable ct extension*/

 Send at exit. */

set afg to D3*/

disable ct extension*/

 Other verbs tables. Sends after DSP download. */

 chip init verbs */

 Extra init verbs for desktop cards. */

	/*

	 * The Windows driver always does this upon startup, which seems to

	 * clear out any previous configuration. This should help issues where

	 * a boot into Windows prior to a boot into Linux breaks things. Also,

	 * Windows always sends the reset twice.

	/*

	 * Default states for effects are in ca0132_effects[].

	/*

	 * Sets defaults for the effect slider controls, only for alternative

	 * ca0132 codecs. Also sets x-bass crossover frequency to 80hz.

 Set speakers to default to full range. */

	/*

	 * The ZxR doesn't have a front panel header, and it's line-in is on

	 * the daughter board. So, there is no input enum control, and we need

	 * to make sure that spec->in_enum_val is set properly.

/*

 * Recon3Di exit specific commands.

 prevents popping noise on shutdown */

/*

 * Sound Blaster Z exit specific commands.

 On shutdown, sends commands in sets of three */

 Mess with GPIO */

 put any chip cleanup stuffs here. */

/*

 * This fixes a problem that was hard to reproduce. Very rarely, I would

 * boot up, and there would be no sound, but the DSP indicated it had loaded

 * properly. I did a few memory dumps to see if anything was different, and

 * there were a few areas of memory uninitialized with a1a2a3a4. This function

 * checks if those areas are uninitialized, and if they are, it'll attempt to

 * reload the card 3 times. Usually it fixes by the second.

	/*

	 * While the failure condition is true, and we haven't reached our

	 * three reload limit, continue trying to reload the driver and

	 * fix the issue.

/*

 * This is for the extra volume verbs 0x797 (left) and 0x798 (right). These add

 * extra precision for decibel values. If you had the dB value in floating point

 * you would take the value after the decimal point, multiply by 64, and divide

 * by 2. So for 8.59, it's (59 * 64) / 100. Useful if someone wanted to

 * implement fixed point or floating point dB volumes. For now, I'll set them

 * to 0 just incase a value has lingered from a boot into Windows.

/*

 * Extra commands that don't really fit anywhere else.

/*

 * The ZxR seems to use alternative DAC's for the surround channels, which

 * require PLL PMU setup for the clock rate, I'm guessing. Without setting

 * this up, we get no audio out of the surround jacks.

	/*

	 * This writes a RET instruction at the entry point of the function at

	 * 0xfa92 in exram. This function seems to have something to do with

	 * ASI. Might be some way to prevent the card from reconfiguring the

	 * ASI stuff itself.

/*

 * These are sent before the DSP is downloaded. Not sure

 * what they do, or if they're necessary. Could possibly

 * be removed. Figure they're better to leave in.

		/*

		 * AE-7 shares all writes with the AE-5, except that it writes

		 * a different value to 0x20c.

/*

 * This function writes to some SFR's, does some region2 writes, and then

 * eventually resets the codec with the 0x7ff verb. Not quite sure why it does

 * what it does.

	/*

	 * First writes are in single bytes, final are in 4 bytes. So, we use

	 * writeb, then writel.

/*

 * Extra init functions for alternative ca0132 codecs. Done

 * here so they don't clutter up the main ca0132_init function

 * anymore than they have to.

	/*

	 * If the DSP is already downloaded, and init has been entered again,

	 * there's only two reasons for it. One, the codec has awaken from a

	 * suspended state, and in that case dspload_is_loaded will return

	 * false, and the init will be ran again. The other reason it gets

	 * re entered is on startup for some reason it triggers a suspend and

	 * resume state. In this case, it will check if the DSP is downloaded,

	 * and not run the init function again. For codecs using alt_functions,

	 * it will check if the DSP is loaded properly.

	/*

	 * Re set the PlayEnhancement switch on a resume event, because the

	 * controls will not be reloaded.

 speaker out */

 digital mic / analog mic1 */

 analog mic2 */

 what u hear */

 Line out */

 Rear headphone out */

 Front Headphone / Center/LFE*/

 Rear surround */

 Rear Mic / Line-in */

 Front Mic, but only if no DSP */

 what u hear */

 Rear Mic / Line-in */

 What U Hear */

 SPDIF I/O */

 Line out */

 Rear headphone out */

 Center/LFE */

 Rear surround */

 Rear Mic / Line-in */

 Not connected, no front mic */

 what u hear */

 Rear Mic / Line-in */

 What U Hear */

 ZxR DBPro Aux In */

 RCA Line-in */

 Line out */

 Rear headphone out */

 Front Headphone / Center/LFE*/

 Rear surround */

 Rear Mic / Line-in */

 Front Mic, but only if no DSP */

 what u hear */

 Rear Mic / Line-in */

 What U Hear */

 SPDIF I/O */

 Line out */

 Rear headphone out */

 Front Headphone / Center/LFE*/

 Rear surround */

 Rear Mic / Line-in */

 Front Mic, but only if no DSP */

 what u hear */

 Rear Mic / Line-in */

 What U Hear */

 SPDIF I/O */

 speaker out */

 headphone out */

 digital mic / analog mic1 */

 analog mic2 */

 what u hear */

 SPDIF I/O */

 Verbs + terminator (an empty element) */

	/*

	 * Since desktop cards use pci_mmio, this can be used to determine

	 * whether or not to use these verbs instead of a separate bool.

 config EAPD */

 Previously commented configuration */

	/*

	spec->spec_init_verbs[2].nid = 0x0b;

	spec->spec_init_verbs[2].param = AC_VERB_SET_EAPD_BTLENABLE;

	spec->spec_init_verbs[2].verb = 0x02;



	spec->spec_init_verbs[3].nid = 0x10;

	spec->spec_init_verbs[3].param = 0x78D;

	spec->spec_init_verbs[3].verb = 0x02;



	spec->spec_init_verbs[4].nid = 0x10;

	spec->spec_init_verbs[4].param = AC_VERB_SET_EAPD_BTLENABLE;

	spec->spec_init_verbs[4].verb = 0x02;

 Terminator: spec->spec_init_verbs[NUM_SPEC_VERBS-1] */

/*

 * The Sound Blaster ZxR shares the same PCI subsystem ID as some regular

 * Sound Blaster Z cards. However, they have different HDA codec subsystem

 * ID's. So, we check for the ZxR's subsystem ID, as well as the DBPro

 * daughter boards ID.

 Detect codec quirk */

 Set which mixers each quirk uses. */

 Setup whether or not to use alt functions/controls/pci_mmio */

/*

 * patch entries

 terminator */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Universal Interface for Intel High Definition Audio Codec

 *

 * HD audio interface patch for C-Media CMI9880

 *

 * Copyright (c) 2004 Takashi Iwai <tiwai@suse.de>

/*

 * stuff for auto-parser

	/* mask NID 0x10 from the playback volume selection;

	 * it's a headphone boost volume handled manually below

/*

 * patch entries

 terminator */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *

 *  patch_hdmi.c - routines for HDMI/DisplayPort codecs

 *

 *  Copyright(c) 2008-2010 Intel Corporation. All rights reserved.

 *  Copyright (c) 2006 ATI Technologies Inc.

 *  Copyright (c) 2008 NVIDIA Corp.  All rights reserved.

 *  Copyright (c) 2008 Wei Ni <wni@nvidia.com>

 *  Copyright (c) 2013 Anssi Hannula <anssi.hannula@iki.fi>

 *

 *  Authors:

 *			Wu Fengguang <wfg@linux.intel.com>

 *

 *  Maintained by:

 *			Wu Fengguang <wfg@linux.intel.com>

 max. connections to a widget */

 pin idx, different device entries on the same pin use the same idx */

 pointer to spec->pcm_rec[n] dynamically*/

 which pcm is attached. -1 means no pcm is attached */

 the stream has been set up by prepare callback */

 current number of channels */

 channel-map override by ALSA API? */

 ALSA API channel-map */

 operations used by generic code that can be overridden by patches */

 enable/disable HBR (HD passthrough) */

 struct hdmi_spec_per_cvt */

 only for haswell fix */

	/*

	 * num_pins is the number of virtual pins

	 * for example, there are 3 pins, and each pin

	 * has 4 device entries, then the num_pins is 12

	/*

	 * num_nids is the number of real pins

	 * In the above example, num_nids is 3

	/*

	 * dev_num is the number of device entries

	 * on each pin.

	 * In the above example, dev_num is 4

 struct hdmi_spec_per_pin */

 for audio component binding */

 pcm_bitmap means which pcms have been assigned to pins*/

 counter of pcm_rec[] */

	/* bitmap shows whether the pcm is opened in user space

	 * bit 0 means the first playback PCM (PCM3);

	 * bit 1 means the second playback PCM, and so on.

 apply Intel platform-specific fixups */

	/*

	 * Non-generic VIA/NVIDIA specific

 use eld_notify callback for hotplug */

 audio component registered in this driver */

 force connectivity */

 reverse port/pin mapping */

 Flag to enable silent stream feature */

 0x84 */

 0x01 */

 0x0a */

 CC in bits 0:2, CT in 4:7 */

 0x84 */

 0x1b */

 0x11 << 2 */

 match with HDMI infoframe from this on */

/*

 * HDMI routines

 obtain hdmi_pcm object assigned to idx */

 obtain hda_pcm object assigned to idx */

	/*

	 * (dev_id == -1) means it is NON-MST pin

	 * return the first virtual pin on this port

 no pin is bound to the pcm */

 no pin is bound to the pcm */

	/* no pin nid is associated with the kctl now

	 * tbd: associate pin nid to eld ctl later

 Unmute */

 Disable pin out until stream is active */

		/* Enable pin out: some machines with GM965 gets broken output

		 * when the pin is disabled or changed while using with HDMI

/*

 * ELD proc files

/*

 * Audio InfoFrame routines

/*

 * Enable Audio InfoFrame Transmission

/*

 * Disable Audio InfoFrame Transmission

 byte index wrapped around */

 be paranoid */

 HDMI */

 DisplayPort */

	/*

	 * sizeof(ai) is used instead of sizeof(*hdmi_ai) or

	 * sizeof(*dp_ai) to avoid partial match/update problems when

	 * the user switches between HDMI/DP monitors.

 some HW (e.g. HSW+) needs reprogramming the amp at each time */

	/*

	 * always configure channel mapping, it may have been changed by the

	 * user in the meantime

/*

 * Unsolicited events

 stop polling when notification is enabled */

 TODO */

	/* For Haswell, the converter 1/2 may keep in D3 state after bootup,

	 * thus pins could only choose converter 0 for use. Make sure the

/*

 * Callbacks

 HBR should be Non-PCM, 8 channels */

		/*

		 * on recent platforms IEC Coding Type is required for HBR

		 * support, read current Digital Converter settings and set

		 * ICT bitfield if needed.

 on recent platforms ICT mode is required for HBR support */

/* Try to find an available converter

 * If pin_idx is less then zero, just try to find an available converter.

 * Otherwise, try to find an available converter and get the cvt mux index

 * of the pin.

 pin_idx < 0 means no pin will be bound to the converter */

 Dynamically assign converter to stream */

 Must not already be assigned */

 Must be in pin's mux's list of converters */

 Not in mux list */

 No free converters */

 Assure the pin select the right convetor */

/* get the mux index for the converter of the pins

 * converter's mux index is the same for all pins on Intel platform

/* Intel HDMI workaround to fix audio routing issue:

 * For some Intel display codecs, pins share the same connection list.

 * So a conveter can be selected by multiple pins and playback on any of these

 * pins will generate sound on the external display, because audio flows from

 * the same converter to the display pipeline. Also muting one pin may make

 * other pins have no sound output.

 * So this function assures that an assigned converter for a pin is not selected

 * by any other pins.

 configure the pins connections */

		/*

		 * pin not connected to monitor

		 * no need to operate on it

		/*

		 * if per_pin->dev_id >= dev_num,

		 * snd_hda_get_dev_select() will fail,

		 * and the following operation is unpredictable.

		 * So skip this situation.

		/*

		 * Calling this function should not impact

		 * on the device entry selection

		 * So let's save the dev id for each pin,

		 * and restore it when return

		/* choose an unassigned converter. The conveters in the

		 * connection list are in the same order as in the codec.

 A wrapper of intel_not_share_asigned_cvt() */

	/* On Intel platform, the mapping of converter nid to

	 * mux index of the pins are always the same.

	 * The pin nid may be 0, this means all pins will not

	 * share the converter.

 skeleton caller of pin_cvt_fixup ops */

/* called in hdmi_pcm_open when no pin is assigned to the PCM

 * in dyn_pcm_assign mode.

 todo: setup spdif ctls assign */

 Initially set the converter's capabilities */

 Store the updated parameters */

/*

 * HDA PCM callbacks

 Validate hinfo */

		/* no pin is assigned to the PCM

		 * PA need pcm open successfully when probe

 Claim converter */

 flip stripe flag for the assigned stream if supported */

 configure unused pins to choose other converters */

 Initially set the converter's capabilities */

 Restrict capabilities by ELD if this isn't disabled */

 Store the updated parameters */

/*

 * HDA/HDMI auto parsing

 all the device entries on the same pin have the same conn list */

	/* on the new machines, try to assign the pcm slot dynamically,

	 * not use the preferred fixed map (legacy way) anymore.

	/*

	 * generic_hdmi_build_pcms() may allocate extra PCMs on some

	 * platforms (with maximum of 'num_nids + dev_num - 1')

	 *

	 * The per_pin of pin_nid_idx=n and dev_id=m prefers to get pcm-n

	 * if m==0. This guarantees that dynamic pcm assignments are compatible

	 * with the legacy static per_pin-pcm assignment that existed in the

	 * days before DP-MST.

	 *

	 * Intel DP-MST prefers this legacy behavior for compatibility, too.

	 *

	 * per_pin of m!=0 prefers to get pcm=(num_nids + (m - 1)).

 have a second try; check the area over num_nids */

 the last try; check the empty slots in pins */

 pcm already be attached to the pin */

 pcm already be detached from the pin */

 hdmi audio only uses playback and one substream */

/* update per_pin ELD from the given new ELD;

 * setup info frame and notification accordingly

 * also notify ELD kctl and report jack status changes

 for monitor disconnection, save pcm_idx firstly */

	/*

	 * pcm_idx >=0 before update_eld() means it is in monitor

	 * disconnected event. Jack must be fetched before update_eld().

	/* if pcm_idx == -1, it means this is in monitor connection event

	 * we can get the correct pcm_idx now.

	/*

	 * Re-setup pin and infoframe. This is needed e.g. when

	 * - sink is first plugged-in

	 * - transcoder can change during stream playback on Haswell

	 *   and this can make HW reset converter selection on a pin.

 update ELD and jack state via HD-audio verbs */

	/*

	 * Always execute a GetPinSense verb here, even when called from

	 * hdmi_intrinsic_event; for some NVIDIA HW, the unsolicited

	 * response's PD bit is not the real PD value, but indicates that

	 * the real PD value changed. An older version of the HD-audio

	 * specification worked this way. Hence, we just ignore the data in

	 * the unsolicited response to avoid custom WARs.

 configure unused pins to choose other converters */

 trigger silent stream generation in hw */

 update ELD and jack state via audio component */

	/*

	 * Power-up will call hdmi_present_sense, so the PM calls

	 * have to be done without mutex held.

	/*

	 * For DP MST audio, Configuration Default is the same for

	 * all device entries on the same pin

	/*

	 * To simplify the implementation, malloc all

	 * the virtual pins in the initialization statically

		/*

		 * On Intel platforms, device entries count returned

		 * by AC_PAR_DEVLIST_LEN is dynamic, and depends on

		 * the type of receiver that is connected. Allocate pin

		 * structures based on worst case.

		/*

		 * spec->dev_num is the maxinum number of device entries

		 * among all the pins

		/*

		 * If the platform doesn't support DP MST,

		 * manually set dev_num to 1. This means

		 * the pin has only one device entry.

	/*

	 * hdmi_add_pin() assumes total amount of converters to

	 * be known, so first discover all converters

 discover audio pins */

/*

	/* Add sanity check to pass klockwork check.

	 * This should never happen.

/*

 * HDMI callbacks

		/* when dyn_pcm_assign and pcm is not bound to a pin

		 * skip pin setup and return 0 to make audio playback

		 * be ongoing

	/* Verify pin:cvt selections to avoid silent audio after S3.

	 * After S3, the audio driver restores pin:cvt selections

	 * but this can happen before gfx is ready and such selection

	 * is overlooked by HW. Thus multiple pins can share a same

	 * default convertor and mute control will affect each other,

	 * which can cause a resumed audio playback become silent

	 * after S3.

 Call sync_audio_rate to set the N/CTS/M manually if necessary */

 Todo: add DP1.2 MST audio support later */

 snd_hda_set_dev_select() has been called before */

 chmap is already set to 0 in caller */

	/*

	 * for non-mst mode, pcm number is the same as before

	 * for DP MST mode without extra PCM, pcm number is same

	 * for DP MST mode with extra PCMs, pcm number is

	 *  (nid number + dev_num - 1)

	 * dev_num is the device entry number in a pin

 pcm number is less than 16 */

 other pstr fields are set in open */

 no PCM: mark this for skipping permanently */

		/* create the spdif for each pcm

		 * pin will be bound when monitor is connected

 add control for ELD Bytes */

 add channel maps */

 allocate codec->spec and assign/initialize generic parser ops */

 initialize to 1 */

 generic HDMI parser */

/*

 * generic audio component binding

 turn on / off the unsol event jack detection dynamically */

		/* clear unsol even if component notifier is used, or re-enable

		 * if notifier is cleared

 set up / clear component notifier dynamically */

 reprogram each jack detection logic depending on the notifier */

 enable / disable the notifier via master bind / unbind */

 check whether both HD-audio and DRM PCI devices belong to the same bus */

 audio component notifier for AMD/Nvidia HDMI codecs */

	/* skip notification during system suspend (but not in runtime PM);

	 * the state will be updated at resume

 ditto during suspend/resume process itself */

 set up the private drm_audio_ops from the template */

	/* intel_audio_codec_enable() or intel_audio_codec_disable()

	 * will call pin_eld_notify with using audio_ptr pointer

	 * We need make sure audio_ptr is really setup

 initialize the generic HDMI audio component */

/*

 * Intel codec parsers and helpers

 enable DP 1.2 features */

 enable 2nd & 3rd pins and convertors */

 enable DP1.2 mode */

/* Haswell needs to re-issue the vendor-specific verbs before turning to D0.

 * Otherwise you may get severe h/w communication errors.

/* There is a fixed mapping between audio pin node and display port.

 * on SNB, IVY, HSW, BSW, SKL, BXT, KBL:

 * Pin Widget 5 - PORT B (port = 1 in i915 driver)

 * Pin Widget 6 - PORT C (port = 2 in i915 driver)

 * Pin Widget 7 - PORT D (port = 3 in i915 driver)

 *

 * on VLV, ILK:

 * Pin Widget 4 - PORT B (port = 1 in i915 driver)

 * Pin Widget 5 - PORT C (port = 2 in i915 driver)

 * Pin Widget 6 - PORT D (port = 3 in i915 driver)

 ILK */

 ILK */

 VLV */

	/*

	 * looking for the pin number in the mapping table and return

	 * the index which indicate the port number

 we assume only from port-B to port-D */

	/* skip notification during system suspend (but not in runtime PM);

	 * the state will be updated at resume

 ditto during suspend/resume process itself */

 register i915 component pin_eld_notify callback */

 no need for forcible resume for jack check thanks to notifier */

 setup_stream ops override for HSW+ */

 pin_cvt_fixup ops override for HSW+ and VLV+ */

 precondition and allocation for Intel codecs */

 requires i915 binding */

 set probe_id here to prevent generic fallback binding */

 no need to handle unsol events */

 parse and post-process for Intel codecs */

 Intel Haswell and onwards; audio component with eld notifier */

	/*

	 * Enable silent stream feature, if it is enabled via

	 * module param or Kconfig option

	/*

	 * pin to port mapping table where the value indicate the pin number and

	 * the index indicate the port number.

	/*

	 * pin to port mapping table where the value indicate the pin number and

	 * the index indicate the port number.

 Intel Baytrail and Braswell; with eld notifier */

	/* For Valleyview/Cherryview, only the display codec is in the display

	 * power well and can use link_power ops to request/release the power.

 Intel IronLake, SandyBridge and IvyBridge; with eld notifier */

/*

 * Shared non-generic implementations

 unsolicited event for jack sensing */

/* generic_hdmi_build_jack can be used for simple_hdmi, too,

 * as long as spec->pins[] is set correctly

 some codecs require to unmute the pin */

/*

 * Nvidia specific implementations

front, rear, clfe, rear_surr */

 set audio protect on */

 enable digital output on pin widget */

 terminator */

 set audio protect on */

 enable digital output on pin widget */

 terminator */

 support only the safe format and rate */

 support all rates and formats */

 no analog */

	/* Set the audio infoframe channel allocation and checksum fields.  The

 set the stream id */

 set the stream format */

	/* The audio hardware sends a channel count of 0x7 (8ch) when all the

 turn off SPDIF once; otherwise the IEC958 bits won't be updated */

 set the stream id */

 set the stream format */

 turn on again (if needed) */

 enable and set the channel status audio/data flag */

		/* turn off SPDIF once;

		 *otherwise the IEC958 bits won't be updated

 set the stream id */

 set the stream format */

 turn on again (if needed) */

 enable and set the channel status audio/data flag */

 override the PCM rates, etc, as the codec doesn't give full list */

 add channel maps */

	/* Initialize the audio infoframe channel mask and checksum to something

/*

 * NVIDIA codecs ignore ASP mapping for 2ch - confirmed on:

 * - 0x10de0015

 * - 0x10de0040

 If the speaker allocation matches the channel count, it is OK. */

 all channels are remappable freely */

 map from pin NID to port; port is 0-based */

 for Nvidia: assume widget NID starting from 4, with step 1 (4, 5, 6, ...) */

 reverse-map from port to pin NID: see above */

/*

 * The HDA codec on NVIDIA Tegra contains two scratch registers that are

 * accessed using vendor-defined verbs. These registers can be used for

 * interoperability between the HDA and HDMI drivers.

 Audio Function Group node */

/*

 * The SCRATCH0 register is used to notify the HDMI codec of changes in audio

 * format. On Tegra, bit 31 is used as a trigger that causes an interrupt to

 * be raised in the HDMI codec. The remainder of the bits is arbitrary. This

 * implementation stores the HDA format (see AC_FMT_*) in bits [15:0] and an

 * additional bit (at position 30) to signal the validity of the format.

 *

 * | 31      | 30    | 29  16 | 15   0 |

 * +---------+-------+--------+--------+

 * | TRIGGER | VALID | UNUSED | FORMAT |

 * +-----------------------------------|

 *

 * Note that for the trigger bit to take effect it needs to change value

 * (i.e. it needs to be toggled).

/*

 * The format parameter is the HDA audio format (see AC_FMT_*). If set to 0,

 * the format is invalidated so that the HDMI codec can be disabled.

 bits [31:30] contain the trigger and valid bits */

 bits [15:0] are used to store the HDA format */

 bits [16:24] are unused */

	/*

	 * Bit 30 signals that the data is valid and hence that HDMI audio can

	 * be enabled.

	/*

	 * Whenever the trigger bit is toggled, an interrupt is raised in the

	 * HDMI codec. The HDMI driver will use that as trigger to update its

	 * configuration.

 notify the HDMI codec of the format change */

 invalidate the format in the HDMI codec */

	/*

	 * Override ->prepare() and ->cleanup() operations to notify the HDMI

	 * codec about format changes.

/*

 * ATI/AMD-specific implementations

 ATI/AMD specific HDA pin verbs, see the AMD HDA Verbs specification */

 AMD specific HDA cvt verbs */

 call hda_eld.c ATI/AMD-specific function */

	/*

	 * ATI/AMD have automatic FC/LFE swap built-in

	 * when in pairwise mapping mode.

 see channel_allocations[].speakers[] */

 check that only channel pairs need to be remapped on old pre-rev3 ATI/AMD */

 channel is in a supported position */

 even channel, check the odd companion */

 companion channel already checked */

		/* In case this is an odd slot but without stream channel, do not

		 * disable the slot since the corresponding even slot could have a

		 * channel. In case neither have a channel, the slot pair will be

 ati_channel_setup format: [7..4] = stream_channel_id, [1] = mute, [0] = enable */

	/*

	 * Pre-rev3 ATI/AMD codecs operate in a paired channel mode, so

	 * we need to take that into account (a single channel may take 2

	 * channel slots if we need to carry a silent channel next to it).

	 * On Rev3+ AMD codecs this function is not used.

 We only produce even-numbered channel count TLVs */

 produce paired maps for pre-rev3 ATI/AMD codecs */

 add N/A channel if the companion channel is occupied */

 default as per AMD spec */

 disable ramp-up/down for non-pcm as per AMD spec */

 make sure downmix information in infoframe is zero */

 enable channel-wise remap mode if supported */

 map from pin NID to port; port is 0-based */

 for AMD: assume widget NID starting from 3, with step 2 (3, 5, 7, ...) */

 reverse-map from port to pin NID: see above */

 override to ATI/AMD-specific versions with pairwise mapping */

 ATI/AMD converters do not advertise all of their capabilities */

	/* AMD GPUs have neither EPSS nor CLKSTOP bits, hence preventing

	 * the link-down as is.  Tell the core to allow it.

 VIA HDMI Implementation */

 audio converter1 */

 HDMI output pin1 */

/*

 * patch entries

 17 is known to be absent */

 special ID for generic HDMI */

 terminator */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Universal Interface for Intel High Definition Audio Codec

 *

 * HD audio interface patch for Silicon Labs 3054/5 modem codec

 *

 * Copyright (c) 2005 Sasha Khapyorsky <sashak@alsa-project.org>

 *                    Takashi Iwai <tiwai@suse.de>

 si3054 verbs */

 si3054 nodes (registers) */

 extended MID */

 line level */

 GPIO bits */

 chipid and revisions */

 si3054 codec registers (nodes) access macros */

/*

 * Modem mixer

/*

 * PCM callbacks

/*

 * Init part

 let's pray that this is no fatal error */

 return -EACCES; */

/*

/*

 * patch entries

 VIA HDA on Clevo m540 */

 Asus A8J Modem (SM56) */

 LG LW20 modem */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Universal Interface for Intel High Definition Audio Codec

 *

 * HD audio interface patch for Realtek ALC codecs

 *

 * Copyright (c) 2004 Kailang Yang <kailang@realtek.com.tw>

 *                    PeiSen Hou <pshou@realtek.com.tw>

 *                    Takashi Iwai <tiwai@suse.de>

 *                    Jonathan Woithe <jwoithe@just42.net>

 keep halting ALC5505 DSP, for power saving */

 extra amp-initialization sequence types */

 Means that this sku is set by driver, not read from hw */

 must be at head */

 codec parameterization */

 flag for snd_hda_parse_pin_defcfg() */

 GPIO bits */

 add a delay before writing gpio_data */

 mute LED for HP laptops, see vref_mute_led_set() */

 hooks */

 flag for other variants */

 for PLL fix */

/*

 * COEF access helper functions

 a special bypass for COEF 0; read the cached value at the second time */

 coef writes/updates batch */

/*

 * GPIO setup tables, used in initialization

 Enable GPIO mask and set output */

/*

 * Fix hardware PLL issue

 * On some codecs, the analog PLL gating control must be off while

 * the default value is 1.

 update the master volume per volume-knob's unsol event */

	/* For some reason, the res given from ALC880 is broken.

 Change EAPD to verb control */

 EAPD Ctrl */

 EAPD Ctrl */

 additional initialization for ALC888 variants */

 alc888-VA */

 alc888-VB */

 Turn EAPD to High */

 turn on/off EAPD control (only if available) */

 turn on/off EAPD controls of the codec */

 We currently only handle front, HP */

	/* don't shut up pins when unloading the driver; otherwise it breaks

	 * the default pin setup at the next load of the driver

 use read here for syncing after issuing each verb */

/* generic shutup callback;

 * just turning off EAPD and a little pause for avoiding pop-noise

 generic EAPD initialization */

 get a primary headphone pin if available */

/*

 * Realtek SSID verification

/* Could be any non-zero and even value. When used as fixup, tells

 * the driver to ignore any present sku defines.

 assume always enabled */

 check sum */

 return the position of NID in the list, or -1 if not found */

 return true if the given NID is found in the list */

/* check subsystem ID and set up device-specific initialization;

 * return 1 if initialized, 0 if invalid SSID

/* 32-bit subsystem ID for BIOS loading in HD Audio codec.

 *	31 ~ 16 :	Manufacture ID

 *	15 ~ 8	:	SKU ID

 *	7  ~ 0	:	Assembly ID

 *	port-A --> pin 39/41, port-E --> pin 14/15, port-D --> pin 35/36

 invalid SSID, check the special NID pin defcfg instead */

	/*

	 * 31~30	: port connectivity

	 * 29~21	: reserve

	 * 20		: PCBEEP input

	 * 19~16	: Check sum (15:1)

	 * 15~1		: Custom

	 * 0		: override

 no physical connection */

 check sum */

	/*

	 * 0 : override

	 * 1 :	Swap Jack

	 * 2 : 0 --> Desktop, 1 --> Laptop

	 * 3~5 : External Amplifier control

	 * 7~6 : Reserved

 external Amp control */

	/* is laptop or Desktop and enable the function "Mute internal speaker

	 * when the external headphone out jack is plugged"

	/*

	 * 10~8 : Jack location

	 * 12~11: Headphone out -> 00: PortA, 01: PortE, 02: PortD, 03: Resvered

	 * 14~13: Resvered

	 * 15   : 1 --> enable the function "Mute internal speaker

	 *	        when the external headphone out jack is plugged"

 HP to chassis */

/* Check the validity of ALC subsystem-id

/*

/*

 * Common callbacks

 hibernation resume needs the full chip initialization */

 applied in below */

 apply verbs here after own init */

 disabled explicitly by hints */

 to avoid pop noise */

/*

/*

 * Rename codecs appropriately from COEF value or subvendor id

 terminator */

 terminator */

/*

 * Digital-beep handlers

 additional beep mixers; private_value will be overwritten */

 set up and create beep controls */

 denylist -- no beep available */

 parse the BIOS configuration and set up the alc_spec */

/* return 1 if successful, 0 if the proper config is not found,

 * or a negative error code

 common preparation job for alc_spec */

 FIXME: do we need this for all Realtek codec models? */

/*

 * ALC880 fix-ups

 enable the volume-knob widget support on NID 0x21 */

 disable bogus unused pins */

 line-in */

 headphone */

 disable bogus unused pins */

 change to EAPD mode */

 change to EAPD mode */

 override all pins as BIOS on old Amilo is broken */

 HP */

 speaker */

 bass speaker */

 N/A */

 N/A */

 mic-in */

 N/A */

 N/A */

 N/A */

 N/A */

 SPDIF out */

 almost compatible with FUJITSU, but no bass and SPDIF */

 HP */

 speaker */

 N/A */

 N/A */

 N/A */

 mic-in */

 N/A */

 N/A */

 N/A */

 N/A */

 N/A */

 need to fix HP and speaker pins to be parsed correctly */

 HP */

 speaker */

 bass speaker */

 disable bogus unused pins */

 set up the whole pins as BIOS is utterly broken */

 speaker */

 HP */

 N/A */

 N/A */

 mic-in */

 N/A */

 line-in */

 N/A */

 N/A */

 N/A */

 SPDIF */

 set up the whole pins as BIOS is utterly broken */

 HP */

 N/A */

 N/A */

 N/A */

 mic */

 N/A */

 N/A */

 N/A */

 N/A */

 N/A */

 SPDIF out */

 line-out */

 N/A */

 N/A */

 N/A */

 mic-in */

 HP */

 line-in */

 front-mic */

 N/A */

 N/A */

 0x1e is filled in below */

 N/A */

 N/A */

 SPDIF */

 front */

 N/A */

 CLFE */

 surr */

 mic-in */

 HP */

 line-in */

 front-mic */

 N/A */

 N/A */

 0x1e is filled in below */

 N/A */

 N/A */

 SPDIF */

 front */

 surr */

 CLFE */

 side */

 mic-in */

 front-mic */

 line-in */

 HP */

 N/A */

 N/A */

 0x1e is filled in below */

 N/A */

 N/A */

 SPDIF */

 HP with jack detect */

	/* Below is the copied entries from alc880_quirks.c.

	 * It's not quite sure whether BIOS sets the correct pin-config table

	 * on these machines, thus they are kept to be compatible with

	 * the old static quirks.  Once when it's confirmed to work without

	 * these overrides, it'd be better to remove.

 broken BIOS */

 default Intel */

/*

 * OK, here we have finally the patch for ALC880

 automatic parse from the BIOS config */

/*

 * ALC260 support

/*

 * Pin config fixes

		/* although the machine has only one output pin, we need to

		 * toggle GPIO1 according to the jack state

 copy it for automute */

 HP/speaker */

 int mic */

 ext mic */

 SPDIF out */

 disable bogus I/O pins */

 speaker */

 HP */

 Pin configs are missing completely on some VAIOs */

/*

	/* as quite a few machines require HP amp for speaker outputs,

	 * it's easier to enable it unconditionally; even if it's unneeded,

	 * it's almost harmless.

 automatic parse from the BIOS config */

/*

 * ALC882/883/885/888/889 support

 *

 * ALC882 is almost identical with ALC880 but has cleaner and more flexible

 * configuration.  Each pin widget can choose any input DACs and a mixer.

 * Each ADC is connected from a mixer of all inputs.  This makes possible

 * 6-channel independent captures.

 *

 * In addition, an independent DAC for the multi-playback (not used in this

 * driver yet).

/*

 * Pin config fixes

 set up GPIO at initialization */

/* Fix the connection of some pins for ALC889:

 * At least, Acer Aspire 5935 shows the connections to DAC3/4 don't

 * work correctly (bko#42740)

 fake the connections during parsing the tree */

 restore the connections */

 Set VREF on HP pin */

 Set VREF on speaker pins on imac91 */

 Set VREF on speaker pins on mba11 */

 Set VREF on speaker pins on mba21 */

/* Don't take HP output as primary

 * Strangely, the speaker output doesn't work on Vaio Z and some Vaio

 * all-in-one desktop PCs (for example VGC-LN51JGB) through DAC 0x05

/* For dual-codec configuration, we need to disable some features to avoid

 * conflicts of kctls and PCM streams

 disable vmaster */

 auto-mute and auto-mic switch don't work with multiple codecs */

 disable aamix as well */

 add location prefix to avoid conflicts */

 override card longname to provide a unique UCM profile */

 rename Capture controls depending on the codec */

	/* We therefore want to make sure 0x14 (front headphone) and

	 * 0x1b (speakers) use the stereo DAC 0x02

 side */

 rear */

 clfe */

 rear int speakers */

 subwoofer */

 fix sequence for CLFE */

 CD */

 Front HP jack is flaky, disable jack detect */

 hidden surround speaker */

 change to EAPD mode */

 change to EAPD mode */

 change to EAPD mode */

 eanable EAPD on Acer laptops */

 CLFE speaker */

 surround speaker */

 CLFE speaker */

 surround speaker */

 additional init verbs for Acer Aspire 8930G */

 Enable all DACs */

 DAC DISABLE/MUTE 1? */

			/*  setting bits 1-5 disables DAC nids 0x02-0x06

 DAC DISABLE/MUTE 2? */

			/*  some bit here disables the other DACs.

			/* DMIC fix

			 * This laptop has a stereo digital microphone.

			 * The mics are only 1cm apart which makes the stereo

			 * useless. However, either the mic or the ALC889

			 * makes the signal become a difference/sum signal

			 * instead of standard stereo, which is annoying.

			 * So instead we flip this bit which makes the

			 * codec replicate the sum signal to both channels,

			 * turning it into a normal mono mic.

 DMIC_CONTROL? Init value = 0x0001 */

 bass speaker */

 use as headset mic, without its own jack detect */

 use as headset mic, without its own jack detect */

 All Apple entries are in codec SSIDs */

/*

 * BIOS auto configuration

 almost identical with ALC880 parser... */

/*

 ALC883 and variants */

 automatic parse from the BIOS config */

/*

 * ALC262 support

/*

 * Pin config fixes

 speaker */

 front HP */

 rear HP */

 speaker */

 internal speaker */

 int AUX */

/*

	/* pshou 07/11/05  set a zero PCM sample to DAC when FIFO is

	 * under-run

 automatic parse from the BIOS config */

/*

 *  ALC268

 bind Beep switches of both NID 0x0f and 0x10 */

 set PCBEEP vol = 0, mute connections */

 enable SPDIF out */

	/* below is codec SSID since multiple Toshiba laptops have the

	 * same PCI SSID 1179:ff00

/*

 * BIOS auto configuration

/*

 ALC268 has no aa-loopback mixer */

 automatic parse from the BIOS config */

 override the amp caps for beep generator */

/*

 * ALC269

 fixed rate */

 fixed rate */

 different alc269-variants */

/*

 * BIOS auto configuration

 Volume up key */

 Volume down key */

 Power Down Control */

 FIFO and filter clock */

 DMIC control */

 Analog clock */

 JD */

 JD offset1 */

 JD offset2 */

 LDO1/2/3, DAC/ADC */

 JD */

 Capless */

 Class D test 4 */

 IO power down directly */

 ANC */

 AGC MUX */

 DAC simple content protection */

 ADC simple content protection */

 DAC ADC Zero Detection */

 PLL */

 capless control 2 */

 capless control 3 */

 capless control 4 */

 capless control 5 */

 class D test 2 */

 class D test 3 */

 class D test 5 */

 class D test 6 */

 classD OCP */

 classD pure DC test */

 Class D amp control */

 Index 0x78 Direct Drive HP AMP LPM Control 1 */

 Headphone capless set to high power mode */

 Headphone capless set to normal mode */

 Power Down Control */

 FIFO and filter clock */

 DMIC control */

 Analog clock */

 JD */

 JD offset1 */

 JD offset2 */

 LDO1/2/3, DAC/ADC */

 JD */

 Capless */

 Class D test 4 */

 IO power down directly */

 ANC */

 AGC MUX */

 DAC simple content protection */

 ADC simple content protection */

 DAC ADC Zero Detection */

 PLL */

 capless control 2 */

 capless control 3 */

 capless control 4 */

 capless control 5 */

 class D test 2 */

 class D test 3 */

 class D test 5 */

 class D test 6 */

 classD OCP */

 classD pure DC test */

 test mode */

 Class D DC enable */

 DC offset */

 Class D amp control */

 HP JD control */

 Index 0x43 Direct Drive HP AMP LPM Control 1 */

 Headphone capless set to high power mode */

 Index 0x46 Combo jack auto switch control 2 */

 3k pull low control for Headset jack. */

 Headphone capless set to normal mode */

depop hp during suspend*/

 Low power */

 Hight power */

 Clear bit */

	/*

	 * Expose headphone mic (or possibly Line In on some machines) instead

	 * of PC Beep on 1Ah, and disable 1Ah loopback for all outputs. See

	 * Documentation/sound/hd-audio/realtek-pc-beep.rst for details of

	 * this register.

 3k pull low control for Headset jack. */

 NOTE: call this before clearing the pin, otherwise codec stalls */

	/* If disable 3k pulldown control for alc257, the Mic detection will not work correctly

	 * when booting with headset plugged. So skip setting it for the codec alc257

 Reset HP JD */

 Amp control */

 Digital Misc control */

 Passthrough Control */

 Set HP depop to manual mode */

 HP depop procedure start */

 Wait for depop procedure finish  */

 write back the result */

 required only at boot or S3 and S4 resume time */

 Low power */

 Hight power */

 3k pull low control for Headset jack. */

 Set HP depop to manual mode */

 HP depop procedure start */

 Wait for depop procedure finish  */

 Set HP depop to auto mode */

 required only at boot or S4 resume time */

 LSB */

 MSB */

 DSP CPU stop */

 DDR enter self refresh */

 Clock control for PLL and CPU */

 Disable Input OP */

 Stop PLL2 */

 Stop PLL1 */

 Stop PLL3 */

 switch Ringbuffer clock to DBUS clock */

 PLL1 control */

 PLL2 control */

 PLL3 control*/

 Function reset */

 DRAM control */

 DRAM control */

 DRAM control */

 Read revision ID */

 I/O PAD Configuration */

*/

 Clock control */

 PLL2 control */

 OSC Control */

 DRAM Function control */

 NOP */

 NOP */

	/* on some machine, the BIOS will clear the codec gpio data when enter

	 * suspend, and won't restore the data after resume, so we restore it

	 * in the driver.

 CONFIG_PM */

 Fix the speaker amp after resume, etc */

	/* Due to a hardware problem on Lenovo Ideadpad, we need to

	 * fix the sample rate of analog I/O to 44.1kHz

	/* The digital-mic unit sends PDM (differential signal) instead of

	 * the standard PCM, thus you can't record a valid mono stream as is.

	 * Below is a workaround specific to ALC269 to control the dmic

	 * signal source as mono.

/*

 * Magic sequence to make Huawei Matebook X right speaker working (bko#197801)

 Initialization magic */

 Start */

 temporarily power up/down for setting VREF */

 update mute-LED according to the speaker mute state via mic VREF pin */

 Make sure the led works even in runtime suspend */

 Set pin ctl again, it might have just been set to 0 */

 update LED status via GPIO */

 muted -> LED on */

 turn on/off mute LED via GPIO per vmaster hook */

 turn on/off mic-mute LED via GPIO per capture hook */

 setup mute and mic-mute GPIO bits, add hooks appropriately */

 turn on/off mic-mute LED per capture hook via VREF change */

		/* Like hp_gpio_mic1_led, but also needs GPIO4 low to

		 * enable headphone amp

/* HP Spectre x360 14 model needs a unique workaround for enabling the amp;

 * it needs to toggle the GPIO0 once on and off at each time (bko#210633)

 need to toggle GPIO to enable the amp */

 toggle GPIO2 at each time stream is started; we use PREPARE state instead */

 temporarily power up/down for setting COEF bit */

 update mute-LED according to the speaker mute state via COEF bit */

 turn on/off mic-mute LED per capture hook by coef bit */

	/* GPIO2 just toggles on a keypress/keyrelease cycle. Therefore

/* GPIO1 = set according to SKU external amp

 * GPIO2 = mic mute hotkey

 * GPIO3 = mute LED

 * GPIO4 = mic mute LED

/* Line2 = mic mute hotkey

 * GPIO2 = mic mute LED

 INPUT */

 INPUT */

 LDO and MISC control */

 UAJ function set to menual mode */

 Direct Drive HP Amp control(Set to verb control)*/

 Set MIC2 Vref gate with HP */

 Direct Drive HP Amp control */

 LDO and MISC control */

 UAJ function set to menual mode */

 Set MIC2 Vref gate with HP */

 Direct Drive HP Amp control */

 Direct Drive HP Amp control(Set to verb control)*/

 SET Line1 JD to 0 */

 SET charge pump by verb */

 SET EN_OSW to 1 */

 Combo JD gating with LINE1-VREFO */

 Set to TRS type */

 Combo Jack auto detect */

 Set MIC2 Vref gate to normal */

 Direct Drive HP Amp control(Set to verb control)*/

 Set MIC2 Vref gate to normal */

 SET charge pump by verb */

 SET EN_OSW to 0 */

 Combo JD gating without LINE1-VREFO */

 Set to TRS mode */

 Direct Drive HP Amp control(Set to verb control)*/

 Set to TRS type */

 Combo Jack auto detect */

 Set to TRS type */

 Combo JD gating without LINE1-VREFO */

 Iphone type */

 Set to CTIA type */

 Set to CTIA type */

 Set to ctia type */

 SET Line1 JD to 1 */

 Nokia type */

 Set to OMTP Type */

 Set to OMTP Type */

 Set to omtp type */

 SET Line1 JD to 1 */

 Headset output enable */

 combo jack auto switch control(Check type)*/

		WRITE_COEF(0x49, 0x0149), /* combo jack auto switch control(Vref

 Check Type */

 Combo Jack auto detect */

 Set to ctia type */

 Find mic pins */

 Set to iphone type */

 Headset Mic enable or disable, only for Dell Dino */

 toggled via hp_automute_hook */

 Disable AA-loopback as it causes white noise */

 fixup for Thinkpad docks: add dock pins, avoid HP parser fixup */

 dock headphone */

 dock mic */

 avoid click noises */

 dock headphone */

 dock mic */

 Enable DOCK device */

 Enable DOCK device */

	/* Assure the speaker pin to be coupled with DAC NID 0x03; otherwise

	 * the speaker output becomes too low by some reason on Thinkpads with

	 * ALC298 codec

 Prevent pop noises when headphones are plugged in */

		/* mic pin 0x19 must be initialized with Vref Hi-Z, otherwise

		 * it causes a click noise at start up

 Make the internal mic the default input source. */

 Mic-in is same pin as headphone */

		/* Disable boost for mic-in permanently. (This code is only called

 Returns the nid of the external mic input pin, or 0 if it cannot be found. */

	/* The mic boosts on level 2 and 3 are too noisy

	   on the internal mic input.

 Disable AA-loopback as it causes white noise */

 MIC2-VREF control */

 Set to manual mode */

 Enable Line1 input control by verb */

 MIC2-VREF control */

 Set to manual mode */

 mute tablet speaker pin (0x14) via dock plugging in addition */

 dock speaker pin */

 TX300 needs to set up GPIO2 for the speaker amp */

		/* this is a bit tricky; give more sane names for the main

		 * (tablet) speaker and the dock speaker, respectively

		/* DAC node 0x03 is giving mono output. We therefore want to

		   make sure 0x14 (front speaker) and 0x15 (headphones) use the

		/* The speaker is routed to the Node 0x06 by a mistake, as a result

		   we can't adjust the speaker's volume since this node does not has

		   Amp-out capability. we change the speaker's route to:

		   Node 0x02 (Audio Output) -> Node 0x0c (Audio Mixer) -> Node 0x17 (

		   Pin Complex), since Node 0x02 has Amp-out caps, we can adjust

 disable DAC3 (0x06) selection on NID 0x17 as it has no volume amp control */

 force NID 0x17 (Bass Speaker) to DAC1 to share it with the main speaker */

 Hook to update amp GPIO4 for automute */

 mute_led_polarity is set to 0, so we pass inverted value here */

/* Manage GPIOs for HP EliteBook Folio 9480m.

 *

 * GPIO4 is the headphone amplifier power control

 * GPIO3 is the audio output mute indicator LED

 amp at GPIO4; toggled via alc280_hp_gpio4_automute_hook() */

 set data bit low */

/* Quirk for Thinkpad X1 7th and 8th Gen

 * The following fixed routing needed

 * DAC1 (NID 0x02) -> Speaker (NID 0x14); some eq applied secretly

 * DAC2 (NID 0x03) -> Bass (NID 0x17) & Headphone (NID 0x21); sharing a DAC

 * DAC3 (NID 0x06) -> Unused, due to the lack of volume amp

 exclude 0x06 */

		/* The generic parser creates somewhat unintuitive volume ctls

		 * with the fixed routing above, and the shared DAC2 may be

		 * confusing for PA.

		 * Rename those to unique names so that PA doesn't touch them

		 * and use only Master volume.

 override card longname to provide a unique UCM profile */

 rename Capture controls depending on the codec */

 Forcibly assign NID 0x03 to HP/LO while NID 0x02 to SPK for EQ */

 avoid DAC 0x06 for bass speaker 0x17; it has no volume control */

 The DAC of NID 0x3 will introduce click/pop noise on headphones, so invalidate it */

 Reset HP JD */

 Reset HP JD */

	/* The Windows driver sets the codec up in a very different way where

	 * it appears to leave 0x10 = 0x8a20 set. For Linux we need to toggle it

 Pin 0x21: headphones/headset mic */

		/* Make sure to start in a correct state, i.e. if

		 * headphones have been plugged in before powering up the system

	/* Windows sets 0x10 to 0x8420 for Node 0x20 which is

	 * responsible from changes between speakers and headphones

 Mic RING SLEEVE swap for combo jack */

/* GPIO1 = amplifier on/off

 * GPIO3 = mic mute LED

 front/high speakers */

 back/bass speakers */

enable micmute led

 needed for amp of back speakers */

 share DAC to have unified volume control */

 need to toggle GPIO to enable the amp of back speakers */

 rear speaker */

 force front speaker to DAC1 */

 for hda_fixup_thinkpad_acpi() */

 reduce click noise */

 Fixup for Lenovo Legion 15IMHg05 speaker output on headset removal. */

 for alc295_fixup_hp_top_speakers */

 for alc285_fixup_ideapad_s740_coef() */

	/*

	* A certain other OS sets these coeffs to different values. On at least one TongFang

	* barebone these settings might survive even a cold reboot. So to restore a clean slate the

	* values are explicitly reset to default here. Without this, the external microphone is

	* always in a plugged-in state, while the internal microphone is always in an unplugged

	* state, breaking the ability to use the internal microphone.

 Enables internal speaker */

 subwoofer */

 dock line-out */

 dock mic-in */

 headset mic, with jack detect */

 HP out */

 speaker */

 HP out */

 mic */

 int-mic */

 int-mic */

 speaker */

 HP out */

 mic */

 speaker */

 mic */

 int-mic */

 HP out */

 int-mic */

 speaker */

 mic */

 HP out */

 dock mic */

 dock headphone */

 use as headset mic, without its own jack detect */

 use as headphone mic, without its own jack detect */

 dock line out */

 dock mic */

 use as headset mic, without its own jack detect */

 use as headset mic, without its own jack detect */

 use as headset mic, without its own jack detect */

 use as headphone mic, without its own jack detect */

 headset mic w/o jack detect */

 use as headset mic, without its own jack detect */

 Headset mic */

 speaker */

 mic */

 int-mic */

 HP out */

 int-mic */

 speaker */

 mic */

 SPDIF1 */

 HP out */

 class-D output amp +5dB */

 int-mic */

 mic */

 Unused bogus pin */

 subwoofer */

 subwoofer */

 use as headset mic, without its own jack detect */

 use as headset mic, without its own jack detect */

 use as headset mic, without its own jack detect */

 use as headphone mic, without its own jack detect */

 use as headset mic, without its own jack detect */

 use as headphone mic, without its own jack detect */

 use as headset mic, without its own jack detect */

 line-out */

 headset mic */

 line-in */

 line-out */

 line-in */

 use as headset mic, without its own jack detect */

 use as headphone mic, without its own jack detect */

 micmute fixup must be applied at last */

 headset mic w/o jack detect */

 use as headset mic, without its own jack detect */

 use as headphone mic, without its own jack detect */

 use as headset mic, without its own jack detect */

 Enables internal speaker */

 Disable pass-through path for FRONT 14h */

 Front Mic */

 use as headset mic, without its own jack detect */

 use as headphone mic, without its own jack detect */

 use as internal mic */

 use as headset mic, without its own jack detect */

 Set up GPIO2 for the speaker amp */

 use as headset mic, without its own jack detect */

 Enables internal speaker */

			/* Change the mic location from front to right, otherwise there are

			   two front mics with the same name, pulseaudio can't handle them.

			   This is just a temporary workaround, after applying this fixup,

			   there will be one "Front Mic" and one "Mic" in this machine.

 Rear Headset HP */

 use as Front headset mic, without its own jack detect */

 Rear Headset MIC */

 Enables internal speaker */

 use as headset mic, without its own jack detect */

 use as headset mic, without its own jack detect */

 use as internal mic */

 use as headset mic, without its own jack detect */

 use as headset mic */

 Set EAPD high */

 use as headset mic, without its own jack detect */

 Disable PCBEEP-IN passthrough */

 use as internal mic */

 Rear Line out */

 use as Front headset mic, without its own jack detect */

 headset mic with jack detect */

 use as headset mic, without its own jack detect */

 use as headset mic, without its own jack detect */

 bass spk */

 The GPIO must be pulled to initialize the AMP */

 Set EAPD high */

 front HP mic */

 rear external mic */

 front HP out */

 set 0x15 to HP-OUT ctrl */

 unmute the 0x15 amp */

 rear HP mic */

 rear external mic */

 rear HP out */

 set 0x15 to HP-OUT ctrl */

 unmute the 0x15 amp */

 set 0x1b to HP-OUT */

			/* Set bit 10 to correct noisy output after reboot from

			 * Windows 10 (due to pop noise reduction?)

 use as headset mic, without its own jack detect */

 use as internal speaker */

 use as headset mic, without its own jack detect */

 use as line out */

 use as headset mic */

 use as headset mic, without its own jack detect */

 headset mic with jack detect */

 use as headset mic, without its own jack detect */

 speaker */

 HP out */

 mic */

 speaker */

 HP out */

 mic */

 speaker */

 HP out */

 mic */

 speaker */

 mic1 */

 mic2 */

 speaker */

 HP out */

 rear  mic */

 front mic */

 front lineout */

 use as headset mic, without its own jack detect */

 use as headset mic, without its own jack detect */

 Set EAPD high */

 use as headset mic, without its own jack detect */

 use as headset mic, without its own jack detect */

 use as internal mic */

 Change the Headphone location to Left */

.v.verbs = legion_15imhg05_coefs,

 set left speaker Legion 7i.

 set right speaker Legion 7i.

 set left speaker Yoga 7i.

 set right speaker Yoga 7i.

 use as headset mic, without its own jack detect */

 Also known as Malata PC-B1303 */

	/* Below is a quirk table taken from the old code.

	 * Basically the device should work as is without the fixup table.

	 * If BIOS doesn't give a proper info, enable the corresponding

	 * fixup entry.

/* This is the fallback pin_fixup_tbl for alc269 family, to make the tbl match

 * more machines, don't need to match all valid pins, just need to match

 * all the pins defined in the tbl. Just because of this reason, it is possible

 * that a single machine matches multiple tbls, so there is one limitation:

 *   at most one tbl is allowed to define for the same vendor and same codec

 Power up output pin */

 Capless ramp up clock control */

 Class D power on reset */

 HP */

/*

 ALC256 does not have any loopback mixer path */

 no loopback on ALC225, ALC295 and ALC299 */

 no loopback on ALC287 */

 ALC2x4 does not have any loopback mixer path */

 UAJ MIC Vref control by verb */

 no loopback on ALC300 */

 ALC700 does not have any loopback mixer path */

 Combo jack auto trigger control */

	/* FIXME: both TX300 and ROG Strix G17 have the same SSID, and

	 * the quirk breaks the latter (bko#214101).

	 * Clear the wrong entry.

 automatic parse from the BIOS config */

/*

 * ALC861

 Pin config fixes */

 On some laptops, VREF of pin 0x0f is abused for controlling the main amp */

 suppress the jack-detection */

 HP */

 speaker */

			/* ASUS W7J needs a magic pin setup on unused NID 0x10

			 * for enabling outputs

/*

 automatic parse from the BIOS config */

/*

 * ALC861-VD support

 *

 * Based on ALC882

 *

 * In addition, an independent DAC

 exclude VREF80 */

 reset GPIO1 */

/*

 automatic parse from the BIOS config */

/*

 * ALC662 support

 *

 * ALC662 is almost identical with ALC880 but has cleaner and more flexible

 * configuration.  Each pin widget can choose any input DACs and a mixer.

 * Each ADC is connected from a mixer of all inputs.  This makes possible

 * 6-channel independent captures.

 *

 * In addition, an independent DAC for the multi-playback (not used in this

 * driver yet).

/*

 * BIOS auto configuration

 LFE only on right */

 override the 2.1 chmap */

 avoid D3 for keeping GPIO up */

	/* surround speakers at 0x1b already get muted automatically when

	 * headphones are plugged in, but we have to mute/unmute the remaining

	 * channels manually:

	 * 0x15 - front left/front right

	 * 0x18 - front center/ LFE

 Pin 0x1b: shared headphones jack and surround speakers */

 subwoofer needs an extra GPIO setting to become audible */

		/* Make sure to start in a correct state, i.e. if

		 * headphones have been plugged in before powering up the system

 use as headset mic, with its own jack detect */

 subwoofer */

 subwoofer */

 speaker */

 mic */

 int-mic */

 HP out */

 speaker */

 mic */

 int-mic */

 HP out */

 speaker */

 mic */

 int-mic */

 HP out */

 speaker */

 HP */

 mic */

 int-mic */

 HP2 */

 speaker */

 speaker */

 mic */

 int-mic */

 HP */

 speaker */

 HP */

 speaker */

 mic */

 int-mic */

 speaker */

 HP2 */

 mic */

 int-mic */

 HP */

 speaker */

 speaker */

 mic */

 int-mic */

 HP */

 HP */

 speaker */

 int-mic */

 HP */

 speaker */

 mic */

 HP */

 Front HP */

 use as headset mic, without its own jack detect */

 headphone mic by setting pin control of 0x1b (headphone out) to in + vref_50 */

 use as headphone mic, without its own jack detect */

 use as headset mic, without its own jack detect */

 bass speaker */

 bass speaker */

 use as headphone mic, without its own jack detect */

 bass speaker */

 use as headset mic, without its own jack detect */

 HP */

 use as headphone mic, without its own jack detect */

 use as headset mic, without its own jack detect */

 no internal speaker */

 disabled */

 disabled */

 use as headset mic, without its own jack detect */

 front speakers */

 center/subwoofer */

 surround plus jack for HP */

 use as headset mic, without its own jack detect */

 use as headset mic, without its own jack detect */

	/* Below is a quirk table taken from the old code.

	 * Basically the device should work as is without the fixup table.

	 * If BIOS doesn't give a proper info, enable the corresponding

	 * fixup entry.

/*

 handle multiple HPs as is */

 automatic parse from the BIOS config */

/*

 * ALC680 support

/*

 ALC680 has no aa-loopback mixer */

 automatic parse from the BIOS config */

/*

 * patch entries

 terminator */

 SPDX-License-Identifier: GPL-2.0

/* Helper functions for Thinkpad LED control;

 * to be included from codec driver

 CONFIG_THINKPAD_ACPI */

 CONFIG_THINKPAD_ACPI */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Generic routines and proc interface for ELD(EDID Like Data) information

 *

 * Copyright(c) 2008 Intel Corporation.

 * Copyright (c) 2013 Anssi Hannula <anssi.hannula@iki.fi>

 *

 * Authors:

 * 		Wu Fengguang <wfg@linux.intel.com>

 also include valid xtypes below */

  0 */ "undefined",

  1 */ "LPCM",

  2 */ "AC-3",

  3 */ "MPEG1",

  4 */ "MP3",

  5 */ "MPEG2",

  6 */ "AAC-LC",

  7 */ "DTS",

  8 */ "ATRAC",

  9 */ "DSD (One Bit Audio)",

 10 */ "E-AC-3/DD+ (Dolby Digital Plus)",

 11 */ "DTS-HD",

 12 */ "MLP (Dolby TrueHD)",

 13 */ "DST",

 14 */ "WMAPro",

 15 */ "HE-AAC",

 16 */ "HE-AACv2",

 17 */ "MPEG Surround",

/*

 * The following two lists are shared between

 * 	- HDMI audio InfoFrame (source to sink)

 * 	- CEA E-EDID Extension (sink to source)

/*

 * SS1:SS0 index => sample size

 0: Refer to Stream Header */

 1: 16 bits */

 2: 20 bits */

 3: 24 bits */

/*

 * SF2:SF1:SF0 index => sampling frequency

 0: Refer to Stream Header */

 1:  32000Hz */

 2:  44100Hz */

 3:  48000Hz */

 4:  88200Hz */

 5:  96000Hz */

 6: 176400Hz */

 7: 192000Hz */

/*

 * Be careful, ELD buf could be totally rubbish!

 not specified, but the spec's tendency is little endian */

	/*

	 * HDMI sink's ELD info cannot always be retrieved for now, e.g.

	 * in console or for audio devices. Assume the highest speakers

	 * configuration, to _not_ prohibit multi-channel audio playback.

	/*

	 * ELD size is initialized to zero in caller function. If no errors and

	 * ELD is valid, actual eld_size is assigned.

 wfg: workaround for ASUS P5E-VM HDMI board */

 set ELD buffer */

		/*

		 * Graphics driver might be writing to ELD buffer right now.

		 * Just abort. The caller will repoll after a while.

		/*

		 * The first byte cannot be zero. This can happen on some DVI

		 * connections. Some Intel chips may also need some 250ms delay

		 * to return non-zero ELD data, even when the graphics driver

		 * correctly writes ELD content before setting ELD_valid bit.

/*

 * SNDRV_PCM_RATE_* and AC_PAR_PCM values don't match, print correct rates with

 * hdmi-specific routine.

 necessary when j == 0 */

		/*

		 * We don't allow modification to these fields:

		 * 	monitor_name manufacture_id product_id

		 * 	eld_version edid_version

 CONFIG_SND_PROC_FS */

 update PCM info based on ELD */

	/* assume basic audio support (the basic audio flag is not in ELD;

	 * however, all audio capable sinks are required to support basic

 restrict the parameters by the values the codec provides */

 ATI/AMD specific stuff (ELD emulation) */

 first three bytes are just standard SAD */

 in standard HDMI VSDB format */

 max len 18 bytes */

 ATI/AMD does not have ELD, emulate it */

 version */

 speaker allocation from EDID */

 is DisplayPort? */

 not handled by ATI/AMD */

 format is supported, copy SAD as-is */

 for PCM there is a separate stereo rate mask */

 rates from the extra byte */

	/*

	 * HDMI VSDB latency format:

	 * separately for both audio and video:

	 *  0          field not valid or unknown latency

	 *  [1..251]   msecs = (x-1)*2  (max 500ms with x = 251 = 0xfb)

	 *  255        audio/video not supported

	 *

	 * HDA latency format:

	 * single value indicating video latency relative to audio:

	 *  0          unknown or 0ms

	 *  [1..250]   msecs = x*2  (max 500ms with x = 250 = 0xfa)

	 *  [251..255] reserved

 else unknown/invalid or 0ms or video ahead of audio, so use zero */

 SAD count */

 Baseline ELD block length is 4-byte aligned */

 Baseline ELD length (4-byte header is not counted in) */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * HD-audio codec driver binding

 * Copyright (c) Takashi Iwai <tiwai@suse.de>

/*

 * find a matching codec id

 check probe_id instead of vendor_id if set */

 process an unsolicited event */

 ignore unsol events during shutdown */

 ignore unsol events during system suspend/resume */

/**

 * snd_hda_codec_set_name - set the codec name

 * @codec: the HDA codec

 * @name: name string to set

 update the mixer name */

 only register after the bus probe finished; otherwise it's racy */

 try to auto-load codec module */

 MODULE */

 try to auto-load and bind the codec module */

 if all audio out widgets are digital, let's assume the codec as a HDMI/DP */

 HDMI parser supports only HDMI out */

 no HDMI codec parser support */

 CONFIG_SND_HDA_CODEC_HDMI */

/**

 * snd_hda_codec_configure - (Re-)configure the HD-audio codec

 * @codec: the HDA codec

 *

 * Start parsing of the given codec tree and (re-)initialize the whole

 * patch instance.

 *

 * Returns 0 if successful or a negative error code.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * HWDEP Interface for HD-audio codec

 *

 * Copyright (c) 2007 Takashi Iwai <tiwai@suse.de>

/*

 * write/read an out-of-bound verb

 open-code get_wcaps(verb>>24) with nospec */

/*

 for sysfs */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *

 *  Implementation of primary alsa driver code base for Intel HD Audio.

 *

 *  Copyright(c) 2004 Intel Corporation. All rights reserved.

 *

 *  Copyright (c) 2004 Takashi Iwai <tiwai@suse.de>

 *                     PeiSen Hou <pshou@realtek.com.tw>

 for art-tsc conversion */

 DSP lock helpers */

 assign a stream for the PCM */

 release the assigned stream */

/*

 * PCM ops

 reset BDL address */

 CA-IBG chips need the playback stream starting from 1 */

 first, set SYNC bits of corresponding streams */

 reset SYNC bits */

 use the position buffer as default */

/*

 * azx_scale64: Scale base by mult/div while not overflowing sanely

 *

 * Derived from scale64_check_overflow in kernel/time/timekeeping.c

 *

 * The tmestamps for a 48Khz stream can overflow after (2^64/10^9)/48K which

 * is about 384307 ie ~4.5 days.

 *

 * This scales the calculation so that overflow will happen but after 2^64 /

 * 48000 secs, which is pretty large!

 *

 * In caln below:

 *	base may overflow, but since there isnt any additional division

 *	performed on base its OK

 *	rem cant overflow because both are 32-bit values

 0th stream tag is not used, so DMA ch 0 is for 1st stream tag */

 Enable the capture */

 Read wall clock counter */

 Read TSC counter */

 Read Link counter */

 Ack: registers read done */

		/*

		 * An error occurs near frame "rollover". The clocks in

		 * frame value indicates whether this error may have

		 * occurred. Here we use the value of 10 i.e.,

		 * HDA_MAX_CYCLE_OFFSET

		/*

		 * Sleep before we read again, else we may again get

		 * value near to MAX_CYCLE. Try to sleep for different

		 * amount of time so we dont hit the same number again

 can be optimized */

 rest of structure is valid */

 24 MHz WallClock == 42ns resolution */

 24 MHz WallClock == 42ns resolution */

 No full-resume yet implemented */

 SNDRV_PCM_INFO_RESUME |*/

 legacy */

 avoid wrap-around with wall-clock */

		/* constrain buffer sizes to be multiple of 128

		   bytes. This is more efficient in terms of memory

		   access but isn't required by the HDA spec and

		   prevents users from specifying exact period/buffer

		   sizes. For example for 44.1kHz, a period size set

		/* Don't enforce steps on buffer sizes, still need to

		   be multiple of 4 bytes (HDA spec). Tested on Intel

		   HDA controllers, may not work on all devices where

 sanity check */

	/* disable LINK_ATIME timestamps for capture streams

 legacy */

 buffer pre-allocation */

 receive a response */

		/* If this critical timeout happens during the codec probing

		 * phase, this is likely an access to a non-existing codec

		 * slot.  Better to return an error and reset the system.

 no fallback mechanism? */

	/* a fatal communication error; need either to reset or to fallback

	 * to the single_cmd mode

 give a chance to retry */

/*

 * Use the single immediate command instead of CORB/RIRB for simplicity

 *

 * Note: according to Intel, this is not preferred use.  The command was

 *       intended for the BIOS only, and may get confused with unsolicited

 *       responses.  So, we shouldn't use it for normal operation from the

 *       driver.

 *       I left the codes, however, for debugging/testing purposes.

 receive a response */

 check IRV busy bit */

 reuse rirb.res as the response return value */

 send a command */

 check ICB busy bit */

 Clear IRV valid bit */

 receive a response */

/*

 * The below are the main callbacks from hda_codec.

 *

 * They are just the skeleton to call sub-callbacks according to the

 * current setting of chip->single_cmd.

 send a command */

 get a response */

/*

 * DSP loading code (e.g. for CA0132)

 use the first stream for loading DSP */

 CONFIG_SND_HDA_DSP_LOADER */

/*

 * reset and start the controller registers

 correct RINTCNT for CXT */

/*

 * interrupt handler

 check whether this IRQ is really acceptable */

 count for avoiding endless loop */

			/*

			 * Clearing the interrupt status here ensures that no

			 * interrupt gets masked after the RIRB wp is read in

			 * snd_hdac_bus_update_rirb. This avoids a possible

			 * race condition where codec response in RIRB may

			 * remain unserviced by IRQ, eventually falling back

			 * to polling mode in azx_rirb_get_response.

/*

 * Codec initerface

/*

 * Probe the given codec address

 HD-audio bus initialization */

 enable sync_write flag for stable communication as default */

 Probe codecs */

 First try to probe all given codec slots */

				/* Some BIOSen give you wrong codec addresses

				 * that don't exist

				/* More badly, accessing to a non-existing

				 * codec often screws up the controller chip,

				 * and disturbs the further communications.

				 * Thus if an error occurs during probing,

				 * better to reset the controller chip to

				 * get back to the sanity state.

 Then create codec instances */

 configure each codec instance */

 unregister failed codecs if any codec has been probed */

 initialize SD streams */

	/* initialize each stream (aka device)

	 * assign the starting bdl address to each stream (device)

	 * and initialize

		/* stream tag must be unique throughout

		 * the stream direction group,

		 * valid values 1...15

		 * use separate stream tag if the flag

		 * AZX_DCAPS_SEPARATE_STREAM_TAG is used

 SPDX-License-Identifier: GPL-2.0-only

/*

 *

 * Implementation of primary ALSA driver code base for NVIDIA Tegra HDA.

 Defines for Nvidia Tegra HDA support */

 IPFS */

 FPCI */

 max number of SDs */

/*

 * Tegra194 does not reflect correct number of SDO lines. Below macro

 * is used to update the GCAP register to workaround the issue.

 nothing special */

 Enable PCI access */

 Enable MEM/IO space and bus master */

/*

 * power management

 enable controller wake up event */

 disable controller wake up event*/

/*

 * destructor

	/*

	 * Tegra194 has 4 SDO lines and the STRIPE can be used to

	 * indicate how many of the SDO lines the stream should be

	 * striped. But GCAP register does not reflect the true

	 * capability of HW. Below workaround helps to fix this.

	 *

	 * GCAP_NSDO is bits 19:18 in T_AZA_DBG_CFG_2,

	 * 0 for 1 SDO, 1 for 2 SDO, 2 for 4 SDO lines.

	/* read number of streams from GCAP register instead of using

	 * hardcoded value

 gcap didn't give any info, switching to old method */

 initialize streams */

 initialize chip */

	/*

	 * Playback (for 44.1K/48K, 2-channel, 16-bps) fails with

	 * 4 SDO lines due to legacy design limitation. Following

	 * is, from HD Audio Specification (Revision 1.0a), used to

	 * control striping of the stream across multiple SDO lines

	 * for sample rates <= 48K.

	 *

	 * { ((num_channels * bits_per_sample) / number of SDOs) >= 8 }

	 *

	 * Due to legacy design issue it is recommended that above

	 * ratio must be greater than 8. Since number of SDO lines is

	 * in powers of 2, next available ratio is 16 which can be

	 * used as a limiting factor here.

 codec detection */

 driver name */

 shortname for card */

 longname for card */

/*

 * constructor

 create codec instances */

 no error return from async probe */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Universal Interface for Intel High Definition Audio Codec

 * 

 * Generic proc interface

 *

 * Copyright (c) 2004 Takashi Iwai <tiwai@suse.de>

 always use noncached version */

 is this a stereo widget or a stereo-to-mono mix? */

	/* check for a stereo-to-mono mix; it must be:

	 * only a single connection, only for input, and only a mixer widget

 the connection source is a stereo? */

/*

 * Parse the pin default config value and returns the string of the

 * jack location, e.g. "Rear", "Front", etc.

/*

 * Parse the pin default config value and returns the string of the

 * jack connectivity, i.e. external or internal connection.

/*

 * Parse the pin default config value and returns the string of the

 * jack type, i.e. the purpose of the jack, such as Line-Out or CD.

 Realtek uses this bit as a different meaning */

	/* Default association and sequence values refer to default grouping

	 * of pin complexes and their sequence within the group. This is used

	 * for priority and resource allocation.

		/* Miscellaneous bit indicates external hardware does not

		 * support presence detection even if the pin complex

		 * indicates it is supported.

	/* Note: This is racy - another process could run in parallel and change

 Get Cache connections info */

 FIXME: add GPO and GPI pin information */

		/* volume knob is a special widget that always have connection

		 * list

/*

 * create a proc read

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *

 *  hda_intel.c - Implementation of primary alsa driver code base

 *                for Intel HD Audio.

 *

 *  Copyright(c) 2004 Intel Corporation. All rights reserved.

 *

 *  Copyright (c) 2004 Takashi Iwai <tiwai@suse.de>

 *                     PeiSen Hou <pshou@realtek.com.tw>

 *

 *  CONTACTS:

 *

 *  Matt Jared		matt.jared@intel.com

 *  Andy Kopp		andy.kopp@intel.com

 *  Dan Kogan		dan.d.kogan@intel.com

 *

 *  CHANGES:

 *

 *  2004.12.01	Major rewrite by tiwai, merged the work of pshou

 for snoop control */

 position fix mode */

 Defines for ATI HD Audio support in SB450 south bridge */

 Defines for Nvidia HDA support */

 Defines for Intel SCH HDA snoop control */

 Define VIA HD Audio Device ID*/

 max number of SDs */

 ICH, ATI and VIA have 4 playback and 4 capture */

 ULI has 6 playback and 5 capture */

 ATI HDMI may have up to 8 playbacks and 0 capture */

 TERA has 4 playback and 3 capture */

/* reset the HD-audio controller in power save mode.

 * this may give more power-saving, but will take longer time to

 * wake up.

 CONFIG_PM */

/*

 driver types */

 keep this as last entry */

 quirks for old Intel chipsets */

 quirks for Intel PCH */

 PCH up to IVB; no runtime PM; bind with i915 gfx */

 PCH for HSW/BDW; with runtime PM */

 no i915 binding for this as HSW/BDW has another controller for HDMI */

 HSW HDMI */

AZX_DCAPS_ALIGN_BUFSIZE |*/ AZX_DCAPS_COUNT_LPIB_DELAY |\

 Broadwell HDMI can't use position buffer reliably, force to use LPIB */

AZX_DCAPS_ALIGN_BUFSIZE |*/ AZX_DCAPS_POSFIX_LPIB |\

 quirks for ATI SB / AMD Hudson */

 quirks for ATI/AMD HDMI */

 quirks for ATI HDMI with snoop off */

 quirks for AMD SB */

 quirks for Nvidia */

/*

 * vga_switcheroo support

 kept old name for compatibility */

/*

 * initialize the PCI registers

 update bits in a PCI register byte */

	/* Clear bits 0-2 of PCI register TCSEL (at offset 0x44)

	 * TCSEL == Traffic Class Select Register, which sets PCI express QOS

	 * Ensuring these bits are 0 clears playback static on some HD Audio

	 * codecs.

	 * The PCI register TCSEL is defined in the Intel manuals.

	/* For ATI SB450/600/700/800/900 and AMD Hudson azalia HD audio,

	 * we need to enable snoop.

 For NVIDIA HDA, enable snoop */

 Enable SCH/PCH snoop if needed */

/*

 * In BXT-P A0, HD-Audio DMA requests is later than expected,

 * and makes an audio stream sensitive to system latencies when

 * 24/32 bits are playing.

 * Adjusting threshold of DMA fifo to force the DMA request

 * sooner to improve latency tolerance at the expense of power.

/*

 * ML_LCAP bits:

 *  bit 0: 6 MHz Supported

 *  bit 1: 12 MHz Supported

 *  bit 2: 24 MHz Supported

 *  bit 3: 48 MHz Supported

 *  bit 4: 96 MHz Supported

 *  bit 5: 192 MHz Supported

	/*

	 * the codecs are sharing the first link setting by default

	 * If other links are enabled for stream, they need similar fix

 wait for CPA */

 0. check lctl register value is correct or not */

 if SCF is already set, let's use it */

	/*

	 * Before operating on SPA, CPA must match SPA.

	 * Any deviation may result in undefined behavior.

 1. turn link down: set SPA to 0 and wait CPA to 0 */

 2. update SCF to select a properly audio clock*/

 4. turn link up: set SPA to 1 and wait CPA to 1 */

 reduce dma latency to avoid noise */

 calculate runtime delay from LPIB */

 called from IRQ */

 bogus IRQ, process it later */

/*

 * Check whether the current DMA position is acceptable for updating

 * periods.  Returns non-zero if it's OK.

 *

 * Many HD-audio controllers appear pretty inaccurate about

 * the update-IRQ timing.  The IRQ is issued before actually the

 * data is processed.  So, we need to process it afterwords in a

 * workqueue.

 *

 * Returns 1 if OK to proceed, 0 for delay handling, -1 for skipping update

 bogus (too early) interrupt */

 use the position buffer as default */

 this shouldn't happen! */

 NG - it's below the first next period boundary */

 OK, no need to check period boundary */

 OK, already in hwptr updating process */

 check whether the period gets really elapsed */

 too early wakeup, process it later */

 OK, it's fine */

/*

 * The work for pending PCM period updates.

 too early */

 clear irq_pending flags and assure no on-going workq */

 get the current DMA position with correction on VIA chips */

 Playback, no problem using link position */

 Capture */

	/* For new chipset,

	 * use mod to get the DMA position just like old chipset

 Link position never gather than FIFO size */

 Find nearest previous boudary */

 Calculate real DMA position we want */

 get the current DMA position with FIFO size correction */

 correct the DMA position for capture stream */

 just read back the calculated value in the above */

 trigger power-save check at writing parameter */

/*

 * power management

 Read STATESTS before controller reset */

 Avoid codec resume if runtime resume is for system suspend */

 power down again for link-controlled chips */

	/* HDA controller always requires different WAKEEN for runtime suspend

	 * and system suspend, so don't use direct-complete here.

/* put codec down to D3 at hibernation for Intel SKL+;

 * otherwise BIOS may still access the codec and screw up the driver

 CONFIG_PM_SLEEP */

 enable controller wake up event */

 disable controller Wake Up event*/

 ELD notification gets broken when HD-audio bus is off */

 NOP */

 NOP */

 CONFIG_PM */

			/* when we get suspended by vga_switcheroo we end up in D3cold,

			 * however we have no ACPI handle, so pci/acpi can't put us there,

/*

 * The discrete GPU cannot power down unless the HDA controller runtime

 * suspends, so activate runtime PM on codecs even if power_save == 0.

 reset the power save setup */

		/* cleared in either gpu_bound op or codec probe, or when its

		 * upstream port has _PR3 (i.e. dGPU).

 NOP */

 NOP */

 SUPPORT_VGA_SWITCHER */

/*

 * destructor

 to be sure */

 ATPX is in the integrated GPU's namespace */

/*

 * Check of disabled HDMI controller by vga_switcheroo

 check only discrete GPU */

				/* ATPX is in the integrated GPU's ACPI namespace

				 * rather than the dGPU's namespace. However,

				 * the dGPU is the one who is involved in

				 * vgaswitcheroo.

 SUPPORT_VGA_SWITCHEROO */

/*

 * allow/deny-listing for position_fix

 Check VIA/ATI HD Audio Controller exist */

 combo mode uses LPIB only for playback */

/*

 * deny-lists for probe_mask

	/* Thinkpad often breaks the controller communication when accessing

	 * to the non-working (or non-existing) modem codec slot.

 broken BIOS */

 including bogus ALC268 in slot#2 that conflicts with ALC888 */

 forced codec slots */

 WinFast VP200 H (Teradici) user reported broken communication */

 check forced option */

/*

 * allow/deny-list for enable_msi

 AMD Hudson */

 AMD Hudson */

 AMD Hudson */

 AMD Hudson */

 Athlon64 X2 + nvidia */

 nvidia */

 Athlon64 X2 + nvidia MCP55 */

 AMD Hudson */

 Athlon64 X2 + nvidia */

 ICH6 */

 enable MSI as default */

 NVidia chipsets seem to cause troubles with MSI */

 check the snoop mode availability */

		/* force to non-snoop mode for a new VIA controller

		 * when BIOS is set

 C-Media requires non-cached pages only for CORB/RIRB */

 some exceptions: Atoms seem problematic with value 1 */

 Baytrail */

 Braswell */

/*

 * constructor

 allow fallback to single_cmd at errors */

 explicitly set to single_cmd or not */

 use the non-cached pages in non-snoop mode */

 continue probing in work context as may trigger request module */

 Fix up base address on ULI M5461 */

	/*

	 * Some Intel CPUs has always running timer (ART) feature and

	 * controller may have Global time sync reporting capability, so

	 * check both of these before declaring synchronized time reporting

	 * capability SNDRV_PCM_INFO_HAS_LINK_SYNCHRONIZED_ATIME

 AMD devices support 40 or 48bit DMA, take the safe one */

 disable SB600 64bit support for safety */

 NVidia hardware normally only supports up to 40 bits of DMA */

 disable 64bit DMA address on some devices */

 disable buffer size rounding to 128-byte multiples if supported */

 allow 64bit DMA address if supported by H/W */

	/* read number of streams from GCAP register instead of using

	 * hardcoded value

 gcap didn't give any info, switching to old method */

 sanity check for the SDxCTL.STRM field overflow */

 initialize streams */

 initialize chip */

 codec detection */

 keep running the rest for the runtime PM */

 callback from request_firmware_nowait() */

 continue probing */

/* Denylist for skipping the whole probe:

 * some HD-audio PCI entries are exposed without any codecs, and such devices

 * should be ignored from the beginning.

 ASUS ROG Zenith II / Strix */

 MSI TRX40 Creator */

 MSI TRX40 */

	/*

	 * stop probe if another Intel's DSP driver should be activated

 continued in azx_firmware_cb() */

 CONFIG_SND_HDA_PATCH_LOADER */

/* On some boards setting power_save to a non 0 value leads to clicking /

 * popping sounds when ever we enter/leave powersaving mode. Ideally we would

 * figure out how to avoid these sounds, but that is not always feasible.

 * So we keep a list of devices where we disable powersaving as its known

 * to causes problems on these devices.

bugzilla.redhat.com/show_bug.cgi?id=1525104 */

bugzilla.redhat.com/show_bug.cgi?id=1525104 */

bugzilla.redhat.com/show_bug.cgi?id=1525104 */

bugzilla.redhat.com/show_bug.cgi?id=1525104 */

bugzilla.redhat.com/show_bug.cgi?id=1525104 */

bugzilla.redhat.com/show_bug.cgi?id=1525104 */

 Note the P55A-UD3 and Z87-D3HP share the subsys id for the HDA dev */

bugzilla.redhat.com/show_bug.cgi?id=1525104 */

bugzilla.kernel.org/show_bug.cgi?id=199607 */

bugs.launchpad.net/bugs/1821663 */

bugzilla.redhat.com/show_bug.cgi?id=1520902 */

bugzilla.kernel.org/show_bug.cgi?id=198611 */

bugzilla.redhat.com/show_bug.cgi?id=1689623 */

bugzilla.redhat.com/show_bug.cgi?id=1572975 */

bugs.launchpad.net/bugs/1821663 */

 CONFIG_PM */

 CONFIG_PM */

 number of codec slots for each chipset: 0 = default slots (i.e. 4) */

 bind with i915 if needed */

			/* if the controller is bound only with HDMI/DP

			 * (for HSW and BDW), we need to abort the probe;

			 * for other chips, still continue probing as other

			 * codecs can be on the same link.

 don't bother any longer */

 HSW/BDW controllers need this power */

	/* Request display power well for the HDA controller or codec. For

	 * Haswell/Broadwell, both the display HDA controller and codec need

	 * this power. For other platforms, like Baytrail/Braswell, only the

	 * display codec needs the power and it can be released after probe.

 create codec instances */

 no longer needed */

 keep things up */

 cancel the pending probing work */

		/* FIXME: below is an ugly workaround.

		 * Both device_release_driver() and driver_probe_device()

		 * take *both* the device's and its parent's lock before

		 * calling the remove() and probe() callbacks.  The codec

		 * probe takes the locks of both the codec itself and its

		 * parent, i.e. the PCI controller dev.  Meanwhile, when

		 * the PCI controller is unbound, it takes its lock, too

		 * ==> ouch, a deadlock!

		 * As a workaround, we unlock temporarily here the controller

		 * device during cancel_work_sync() call.

 PCI IDs */

 CPT */

 PBG */

 Panther Point */

 Lynx Point */

 9 Series */

 Wellsburg */

 Lewisburg */

 Lynx Point-LP */

 Lynx Point-LP */

 Wildcat Point-LP */

 Sunrise Point */

 Sunrise Point-LP */

 Kabylake */

 Kabylake-LP */

 Kabylake-H */

 Coffelake */

 Cannonlake */

 CometLake-LP */

 CometLake-H */

 CometLake-S */

 CometLake-R */

 Icelake */

 Icelake-H */

 Jasperlake */

 Tigerlake */

 Tigerlake-H */

 DG1 */

 Alderlake-S */

 Alderlake-P */

 Alderlake-M */

 Elkhart Lake */

 Broxton-P(Apollolake) */

 Broxton-T */

 Gemini-Lake */

 Haswell */

 Broadwell */

 5 Series/3400 */

 Poulsbo */

 Oaktrail */

 BayTrail */

 Braswell */

 ICH6 */

 ICH7 */

 ESB2 */

 ICH8 */

 ICH9 */

 ICH9 */

 ICH10 */

 ICH10 */

 Generic Intel */

 ATI SB 450/600/700/800/900 */

 AMD Hudson */

 AMD, X370 & co */

 AMD, X570 & co */

 AMD Stoney */

 AMD Raven */

 ATI HDMI */

 VIA VT8251/VT8237A */

 VIA GFX VT7122/VX900 */

 VIA GFX VT6122/VX11 */

 SIS966 */

 ULI M5461 */

 NVIDIA MCP */

 Teradici */

 Creative X-Fi (CA0110-IBG) */

 CTHDA chips */

	/* the following entry conflicts with snd-ctxfi driver,

	 * as ctxfi driver mutates from HD-audio to native mode with

	 * a special command sequence.

 this entry seems still valid -- i.e. without emu20kx chip */

 CM8888 */

 Vortex86MX */

 VMware HDAudio */

 AMD/ATI Generic, PCI class code and Vendor ID for HD Audio */

 Zhaoxin */

 pci_driver definition */

 SPDX-License-Identifier: GPL-2.0+

/*

 * Digital Beep Input Interface for HD-audio codec

 *

 * Author: Matt Ranostay <matt.ranostay@konsulko.com>

 * Copyright (c) 2008 Embedded Alley Solutions Inc

 46.875 Hz */

 93.750 Hz */

 12 KHz */

 generate or stop tone */

/* (non-standard) Linear beep tone calculation for IDT/STAC codecs 

 *

 * The tone frequency of beep generator on IDT/STAC codecs is

 * defined from the 8bit tone parameter, in Hz,

 *    freq = 48000 * (257 - tone) / 1024

 * that is from 12kHz to 93.75Hz in steps of 46.875 Hz

 fixed point */

 round to nearest step */

 turn off PC beep*/

 max frequency */

/* HD-audio standard beep tone parameter calculation

 *

 * The tone frequency in Hz is calculated as

 *   freq = 48000 / (tone * 4)

 * from 47Hz to 12kHz

 disabled */

 schedule beep event */

 turn off beep */

/**

 * snd_hda_enable_beep_device - Turn on/off beep sound

 * @codec: the HDA codec

 * @enable: flag to turn on/off

/**

 * snd_hda_attach_beep_device - Attach a beep input device

 * @codec: the HDA codec

 * @nid: beep NID

 *

 * Attach a beep object to the given widget.  If beep hint is turned off

 * explicitly or beep_mode of the codec is turned off, this doesn't nothing.

 *

 * Currently, only one beep device is allowed to each codec.

 disabled explicitly by hints */

 disabled by module option */

 enable linear scale */

 setup digital beep device */

/**

 * snd_hda_detach_beep_device - Detach the beep device

 * @codec: the HDA codec

 get/put callbacks for beep mute mixer switches */

/**

 * snd_hda_mixer_amp_switch_get_beep - Get callback for beep controls

 * @kcontrol: ctl element

 * @ucontrol: pointer to get/store the data

/**

 * snd_hda_mixer_amp_switch_put_beep - Put callback for beep controls

 * @kcontrol: ctl element

 * @ucontrol: pointer to get/store the data

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * HD audio interface patch for Cirrus Logic CS8409 HDA bridge chip

 *

 * Copyright (C) 2021 Cirrus Logic, Inc. and

 *                    Cirrus Logic International Semiconductor Ltd.

/******************************************************************************

 *                        CS8409 Specific Functions

 keep the ADCs powered up when it's dynamically switchable */

/*

 * cs8409_enable_i2c_clock - Disable I2C clocks

 * @codec: the codec instance

 * Disable I2C clocks.

 * This must be called when the i2c mutex is unlocked.

/*

 * cs8409_disable_i2c_clock_worker - Worker that disable the I2C Clock after 25ms without use

/*

 * cs8409_enable_i2c_clock - Enable I2C clocks

 * @codec: the codec instance

 * Enable I2C clocks.

 * This must be called when the i2c mutex is locked.

	/* Cancel the disable timer, but do not wait for any running disable functions to finish.

	 * If the disable timer runs out before cancel, the delayed work thread will be blocked,

	 * waiting for the mutex to become unlocked. This mutex will be locked for the duration of

	 * any i2c transaction, so the disable function will run to completion immediately

	 * afterwards in the scenario. The next enable call will re-enable the clock, regardless.

/**

 * cs8409_i2c_wait_complete - Wait for I2C transaction

 * @codec: the codec instance

 *

 * Wait for I2C transaction to complete.

 * Return -ETIMEDOUT if transaction wait times out.

/**

 * cs8409_set_i2c_dev_addr - Set i2c address for transaction

 * @codec: the codec instance

 * @addr: I2C Address

/**

 * cs8409_i2c_set_page - CS8409 I2C set page register.

 * @scodec: the codec instance

 * @i2c_reg: Page register

 *

 * Returns negative on error.

/**

 * cs8409_i2c_read - CS8409 I2C Read.

 * @scodec: the codec instance

 * @addr: Register to read

 *

 * Returns negative on error, otherwise returns read value in bits 0-7.

 Register in bits 15-8 and the data in 7-0 */

/**

 * cs8409_i2c_bulk_read - CS8409 I2C Read Sequence.

 * @scodec: the codec instance

 * @seq: Register Sequence to read

 * @count: Number of registeres to read

 *

 * Returns negative on error, values are read into value element of cs8409_i2c_param sequence.

/**

 * cs8409_i2c_write - CS8409 I2C Write.

 * @scodec: the codec instance

 * @addr: Register to write to

 * @value: Data to write

 *

 * Returns negative on error, otherwise returns 0.

/**

 * cs8409_i2c_bulk_write - CS8409 I2C Write Sequence.

 * @scodec: the codec instance

 * @seq: Register Sequence to write

 * @count: Number of registeres to write

 *

 * Returns negative on error.

 Enable/Disable Unsolicited Response */

	/* CS8409 is simple HDA bridge and intended to be used with a remote

	 * companion codec. Most of input/output PIN(s) have only basic

	 * capabilities. Receive and Transmit NID(s) have only OUTC and INC

	 * capabilities and no presence detect capable (PDC) and call to

	 * snd_hda_gen_build_controls() will mark them as non detectable

	 * phantom jacks. However, a companion codec may be

	 * connected to these pins which supports jack detect

	 * capabilities. We have to override pin capabilities,

	 * otherwise they will not be created as input devices.

/******************************************************************************

 *                        CS42L42 Specific Functions

 Configure CS42L42 slave codec for jack autodetect */

 Clear WAKE# */

 Wait ~2.5ms */

 Set mode WAKE# output follows the combination logic directly */

 Clear interrupts status */

 Enable interrupt */

 Enable and run CS42L42 slave codec jack auto detect */

 Clear interrupts */

 Wait ~100us*/

 TIP_SENSE INSERT/REMOVE */

 jack in transition */

 Read jack detect status registers */

 If status values are < 0, read error has occurred. */

 HSDET_AUTO_DONE */

 Disable HSDET_AUTO_DONE */

 Type 4 not supported	*/

 type = 3 has no mic */

 Configure the HSDET mode. */

 Enable the HPOUT ground clamp and configure the HP pull-down */

 Re-Enable Tip Sense Interrupt */

 Bring CS42L42 out of Reset */

 Initialize CS42L42 companion codec */

 Clear interrupts, by reading interrupt status registers */

 Power down CS42L42 ASP/EQ/MIX/HP */

 Put CS42L42 into Reset */

 Cancel i2c clock disable timer, and disable clock if left enabled */

/******************************************************************************

 *                   BULLSEYE / WARLOCK / CYBORG Specific Functions

 *                               CS8409/CS42L42

/*

 * In the case of CS8409 we do not have unsolicited events from NID's 0x24

 * and 0x34 where hs mic and hp are connected. Companion codec CS42L42 will

 * generate interrupt via gpio 4 to notify jack events. We have to overwrite

 * generic snd_hda_jack_unsol_event(), read CS42L42 jack detect status registers

 * and then notify status via generic snd_hda_jack_unsol_event() call.

	/* jack_unsol_event() will be called every time gpio line changing state.

	 * In this case gpio4 line goes up as a result of reading interrupt status

	 * registers in previous cs8409_jack_unsol_event() call.

	 * We don't need to handle this event, ignoring...

 Report jack*/

 Report jack*/

 Manage PDREF, when transition to D3hot */

 Cancel i2c clock disable timer, and disable clock if left enabled */

/* Vendor specific HW configuration

 * PLL, ASP, I2C, SPI, GPIOs, DMIC etc...

 DMIC1_MO=00b, DMIC1/2_SR=1 */

 Enable Unsolicited Response */

	/* CS8409 pins have no AC_PINSENSE_PRESENCE

	 * capabilities. We have to intercept 2 calls for pins 0x24 and 0x34

	 * and return correct pin sense values for read_pin_sense() call from

	 * hda_jack based on CS42L42 jack detect status.

 verb exec op override */

 GPIO 5 out, 3,4 in */

 Basic initial sequence for specific hw configuration */

		/* Set TIP_SENSE_EN for analog front-end of tip sense.

		 * Additionally set HSBIAS_SENSE_EN and Full Scale volume for some variants.

 Fix Sample Rate to 48kHz */

 add hooks */

 Set initial DMIC volume to -26 dB */

 Disable Unsolicited Response during boot */

		/* Run jack auto detect first time on boot

		 * after controls have been added, to check if jack has

		 * been already plugged in.

		 * Run immediately after init.

/******************************************************************************

 *                          Dolphin Specific Functions

 *                               CS8409/ 2 X CS42L42

/*

 * In the case of CS8409 we do not have unsolicited events when

 * hs mic and hp are connected. Companion codec CS42L42 will

 * generate interrupt via irq_mask to notify jack events. We have to overwrite

 * generic snd_hda_jack_unsol_event(), read CS42L42 jack detect status registers

 * and then notify status via generic snd_hda_jack_unsol_event() call.

/* Vendor specific HW configuration

 * PLL, ASP, I2C, SPI, GPIOs, DMIC etc...

 Enable Unsolicited Response */

	/* CS8409 pins have no AC_PINSENSE_PRESENCE

	 * capabilities. We have to intercept calls for CS42L42 pins

	 * and return correct pin sense values for read_pin_sense() call from

	 * hda_jack based on CS42L42 jack detect status.

 verb exec op override */

 GPIO 1,5 out, 0,4 in */

 Basic initial sequence for specific hw configuration */

 Fix Sample Rate to 48kHz */

 add hooks */

 Update Line Out kcontrol template */

		/* Run jack auto detect first time on boot

		 * after controls have been added, to check if jack has

		 * been already plugged in.

		 * Run immediately after init.

 terminator */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * HD audio interface patch for Cirrus Logic CS420x chip

 *

 * Copyright (c) 2009 Takashi Iwai <tiwai@suse.de>

/*

 EAPD GPIO bit for headphones */

 EAPD GPIO bit for speakers */

 CS421x */

 for MBP SPDIF control */

 available models with CS420x */

 aliases */

 CS421x boards */

 Vendor-specific processing widget */

 coef indices */

/* SZC bitmask, 4 modes below:

 * 0 = immediate,

 * 1 = digital immediate, analog zero-cross

 * 2 = digtail & analog soft-ramp

 * 3 = digital soft-ramp, analog zero-cross

 SZC setup for mic */

 SZC setup for line-in */

 PGA mode: 0 = differential, 1 = signle-ended */

 PGA setup for mic */

 PGA setup for line-in */

/* SZC bitmask, 4 modes below:

 * 0 = Immediate

 * 1 = zero-cross

 * 2 = soft-ramp

 * 3 = soft-ramp on zero-cross

 nid 0x02 */

 nid 0x03 */

 nid 0x04 */

 0x0008 - test reg key */

 0x0009 - 0x0014 -> 12 test regs */

 0x0015 - visibility reg */

 Cirrus Logic CS4208 */

/*

 * Cirrus Logic CS4210

 *

 * 1 DAC => HP(sense) / Speakers,

 * 1 ADC <= LineIn(sense) / MicIn / DMicIn,

 * 1 SPDIF OUT => SPDIF Trasmitter(sense)

 Port E */

 Port H */

 Cirrus Logic CS4213 is like CS4210 but does not have SPDIF input/output */

/*

 * auto-mute and auto-mic switching

 * CS421x auto-output redirecting

 * HP/SPK/SPDIF

 mute HPs if spdif jack (SENSE_B) is present */

 CS420x has multiple ADC, CS421x has single ADC */

 DMIC2 2 chan on, GPIO1 off */

			coef |= 1 << 3; /* DMIC1 2 chan on, GPIO0 off

					 * No effect if SPDIF_OUT2 is

					 * selected in IDX_SPDIF_CTL.

 DAC1/2/3 SZCMode Soft Ramp */

 Mute DACs on FIFO error */

 Enable DACs High Pass Filter */

 Disable Coefficient Auto increment */

 ADC1/2 - Digital and Analog Soft Ramp */

 Beep */

 Enable Beep thru DAC1/2/3 */

 terminator */

 AFG: D0 */

 VPW: processing on */

 A1 ICS */

 A1 Enable, A Thresh = 300mV */

 terminator */

/* Errata: CS4207 rev C0/C1/C2 Silicon

 *

 * http://www.cirrus.com/en/pubs/errata/ER880C3.pdf

 *

 * 6. At high temperature (TA > +85C), the digital supply current (IVD)

 * may be excessive (up to an additional 200 A), which is most easily

 * observed while the part is being held in reset (RESET# active low).

 *

 * Root Cause: At initial powerup of the device, the logic that drives

 * the clock and write enable to the S/PDIF SRC RAMs is not properly

 * initialized.

 * Certain random patterns will cause a steady leakage current in those

 * RAM cells. The issue will resolve once the SRCs are used (turned on).

 *

 * Workaround: The following verb sequence briefly turns on the S/PDIF SRC

 * blocks, which will alleviate the issue.

 AFG: D0 */

 VPW: processing on */

 S/PDIF Rx: D0 */

 S/PDIF Tx: D0 */

 terminator */

 SPDIF setup */

 SRC_MUTE soft-mute on SPDIF (if no lock) */

 Replace with mute on error */

		coef |= 0x4000; /* RX to TX1 or TX2 Loopthru / SPDIF2

				 * SPDIF_OUT2 is shared with GPIO1 and

				 * DMIC_SDA2.

 init_verb sequence for C0/C1/C2 errata*/

 keep the ADCs powered up when it's dynamically switchable */

 this conflicts with too many other models */

SND_PCI_QUIRK(0x8086, 0x7270, "IMac 27 Inch", CS420X_IMAC27),*/

 codec SSID */

 terminator */

 terminator */

 terminator */

 terminator */

 terminator */

 HP */

 speaker */

 mic */

 terminator */

 HP */

 Speaker */

 Mic */

 terminator */

 GPIO1 = headphones */

 GPIO3 = speakers */

 GPIO2 = headphones */

 GPIO3 = speakers */

 internal mic ADC2: right only, single ended */

/*

 * CS4208 support:

 * Its layout is no longer compatible with CS4206/CS4207

 terminator */

 codec SSID matching */

 terminator */

 remap the fixup from codec SSID and apply it */

 default fixup */

 MacMini 7,1 has the inverted jack detection */

 mic (audio-in) jack: disable detect */

 SPDIF: disable detect */

 HP pin (0x10) has an inverted detection */

 disable the bogus Mic and SPDIF jack detections */

 hook the SPDIF switch */

 correct the 0dB offset of input pins */

 exclude NID 0x10 (HP) from output volumes due to different steps */

/*

 * Cirrus Logic CS4210

 *

 * 1 DAC => HP(sense) / Speakers,

 * 1 ADC <= LineIn(sense) / MicIn / DMicIn,

 * 1 SPDIF OUT => SPDIF Trasmitter(sense)

 CS4210 board names */

 Test Intel board + CDB2410  */

 terminator */

 CS4210 board pinconfigs */

 Default CS4210 (CDB4210)*/

 terminator */

 Stumpy ChromeBox */

 terminator */

 Setup GPIO/SENSE for each board (if used) */

	/*

	 *  Disable Coefficient Index Auto-Increment(DAI)=1,

	 *  PDREF=0

 ADC SZCMode = Digital Soft Ramp */

 DAC SZCMode = Digital Soft Ramp */

 Mute DAC on FIFO error */

 Enable DAC High Pass Filter */

 terminator */

/* Errata: CS4210 rev A1 Silicon

 *

 * http://www.cirrus.com/en/pubs/errata/

 *

 * Description:

 * 1. Performance degredation is present in the ADC.

 * 2. Speaker output is not completely muted upon HP detect.

 * 3. Noise is present when clipping occurs on the amplified

 *    speaker outputs.

 *

 * Workaround:

 * The following verb sequence written to the registers during

 * initialization will correct the issues listed above.

 VPW: processing on */

 Test mode: on */

 Chop double */

 Increase ADC current */

 Mute speaker */

 Remove noise */

 terminator */

 Speaker Amp Gain is controlled by the vendor widget's coef 4 */

 GPIO, DMIC_SCL, DMIC_SDA and SENSE_B are multiplexed */

 B1,B2 are GPIOs */

 B2 is SENSE_B, not inverted  */

		/*

		 *  GPIO or SENSE_B forced - disconnect the DMIC pin.

 detect on spdif is specific to CS4210 */

 SPDIF TX on/off */

 set the upper-limit for mixer amp to 0dB */

/*

 *	Manage PDREF, when transitioning to D3hot

 *	(DAC,ADC) -> D3, PDREF=1, AFG->D3

 PDREF */

	/*

	 *  Update the GPIO/DMIC/SENSE_B pinmux before the configuration

	 *   is auto-parsed. If GPIO or SENSE_B is forced, DMIC input

	 *   is disabled.

/*

 * patch entries

 terminator */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Universal Interface for Intel High Definition Audio Codec

 *

 * Generic widget tree parser

 *

 * Copyright (c) 2004 Takashi Iwai <tiwai@suse.de>

/**

 * snd_hda_gen_spec_init - initialize hda_gen_spec struct

 * @spec: hda_gen_spec object to initialize

 *

 * Initialize the given hda_gen_spec object.

/**

 * snd_hda_gen_add_kctl - Add a new kctl_new struct from the template

 * @spec: hda_gen_spec object

 * @name: name string to override the template, NULL if unchanged

 * @temp: template for the new kctl

 *

 * Add a new kctl (actually snd_kcontrol_new to be instantiated later)

 * element based on the given snd_kcontrol_new template @temp and the

 * name string @name to the list in @spec.

 * Returns the newly created object or NULL as error.

/*

 * store user hints

 the following two are just for compatibility */

/*

 * pin control value accesses

 restore the pinctl based on the cached value */

 set the pinctl target value and write it if requested */

 set pinctl target values for all given pins */

/*

 * parsing paths

 return the position of NID in the list, or -1 if not found */

 return true if the given NID is contained in the path */

/**

 * snd_hda_get_path_idx - get the index number corresponding to the path

 * instance

 * @codec: the HDA codec

 * @path: nid_path object

 *

 * The returned index starts from 1, i.e. the actual array index with offset 1,

 * and zero is handled as an invalid path

/**

 * snd_hda_get_path_from_idx - get the path instance corresponding to the

 * given index number

 * @codec: the HDA codec

 * @idx: the path index

 check whether the given DAC is already found in any existing paths */

 check whether the given two widgets can be connected */

 nid, dir and idx */

 check whether the given ctl is already assigned in any path elements */

 check whether a control with the given (nid, dir, idx) was assigned */

 called recursively */

 anchor passed */

 hit the exclusive nid */

			/* special case: when from_nid is 0,

			 * try to find an empty DAC

 anchor is not requested or already passed? */

/*

 * snd_hda_parse_nid_path - parse the widget path from the given nid to

 * the target nid

 * @codec: the HDA codec

 * @from_nid: the NID where the path start from

 * @to_nid: the NID where the path ends at

 * @anchor_nid: the anchor indication

 * @path: the path object to store the result

 *

 * Returns true if a matching path is found.

 *

 * The parsing behavior depends on parameters:

 * when @from_nid is 0, try to find an empty DAC;

 * when @anchor_nid is set to a positive value, only paths through the widget

 * with the given value are evaluated.

 * when @anchor_nid is set to a negative value, paths through the widget

 * with the negative of given value are excluded, only other paths are chosen.

 * when @anchor_nid is zero, no special handling about path selection.

/**

 * snd_hda_add_new_path - parse the path between the given NIDs and

 * add to the path list

 * @codec: the HDA codec

 * @from_nid: the NID where the path start from

 * @to_nid: the NID where the path ends at

 * @anchor_nid: the anchor indication, see snd_hda_parse_nid_path()

 *

 * If no valid path is found, returns NULL.

 check whether the path has been already added */

 push back */

 clear the given path as invalid so that it won't be picked up later */

 return a DAC if paired to the given pin by codec driver */

 look for an empty DAC slot */

 replace the channels in the composed amp value with the given number */

 look for a widget suitable for assigning a mute switch in the path */

 look for a widget suitable for assigning a volume ctl in the path */

/*

 * path activation / deactivation

 can have the amp-in capability? */

 only for input pins */

 can have the amp-out capability? */

 only for output pins */

 check whether the given (nid,dir,idx) is active */

 ignore unplugged paths except for DAC/ADC */

 check whether the NID is referred by any active paths */

 get the default amp value for the target state */

 set to 0dB */

 is this a stereo widget or a stereo-to-mono mix? */

 initialize the amp value (only at the first time) */

 update the amp, doing in stereo or mono depending on NID */

/* calculate amp value mask we can modify;

 * if the given amp is controlled by mixers, don't touch it

 check whether the given amp is still used by others */

	/* here is a little bit tricky in comparison with activate_amp_out();

	 * when aa-mixer is available, we need to enable the path as well

 when aamix is disabled, force to off */

 sync power of each widget in the given path */

			/* all known codecs seem to be capable to handl

			 * widgets state even in D3, so far.

			 * if any new codecs need to restore the widget

			 * states after D0 transition, call the function

			 * below.

 disabled */

 do sync with the last power state change */

/**

 * snd_hda_activate_path - activate or deactivate the given path

 * @codec: the HDA codec

 * @path: the path to activate/deactivate

 * @enable: flag to activate or not

 * @add_aamix: enable the input from aamix NID

 *

 * If @add_aamix is set, enable the input from aa-mix NID as well (if any).

 make sure the widget is powered up */

 if the given path is inactive, put widgets into D3 (only if suitable) */

 turn on/off EAPD on the given pin */

 re-initialize the path specified by the given path index */

/*

 * Helper functions for creating mixer ctl elements

 only the put callback is replaced for handling the special mute */

 replaced */

 replaced */

 add dynamic controls from template */

 return the channel bits suitable for the given path->ctls[] */

 mono (left only) */

 stereo */

/* create a mute-switch for the given mixer widget;

 * if it has multiple sources (e.g. DAC and loopback), create a bind-mute

 playback mute control with the software mute bit check */

/*

 * Bound mute controls

 index 0 */

 any ctl assigned to the path with the given index? */

 give some appropriate ctl name prefix for the given line out channel */

	/* if there is really a single DAC used in the whole output paths,

	 * use it master (or "PCM" if a vmaster hook is present)

 multi-io channels */

		/* if the primary channel vol/mute is shared with HP volume,

		 * don't name it as Speaker

		/* if the primary channel vol/mute is shared with spk volume,

		 * don't name it as Headphone

 for multi-io case, only the primary out */

		/* This deals with the case where one HP or one Speaker or

		 * one HP + one Speaker need to share the DAC with LO

 for a single channel output, we don't have to name the channel */

/*

 * Parse output paths

 badness definition */

 No primary DAC is found for the main output */

 No DAC is found for the extra output */

 No possible multi-ios */

 No individual DAC for extra output */

 No individual DAC for extra surrounds */

 Primary DAC shared with main surrounds */

 No independent HP possible */

 Primary DAC shared with main CLFE */

 Primary DAC shared with extra surrounds */

 Volume widget is shared */

/* look for widgets in the given path which are appropriate for

 * volume and mute controls, and assign the values to ctls[].

 *

 * When no appropriate widget is found in the path, the badness value

 * is incremented depending on the situation.  The function returns the

 * total badness for both volume and mute controls.

 already evaluated */

 get the DAC of the primary output corresponding to the given array index */

 return the DAC if it's reachable, otherwise zero */

 try to assign DACs to pins and return the resultant badness */

 try to steal the DAC of surrounds for the front */

 try with aamix */

 print_nid_path(codec, "output", path); */

 return NID if the given pin has only a single connection to a certain DAC */

 check whether the given pin can be a multi-io pin */

 count the number of input pins that are capable to be multi-io */

/*

 * multi-io helper

 *

 * When hardwired is set, try to fill ony hardwired pins, and returns

 * zero if any pins are filled, non-zero if nothing found.

 * When hardwired is off, try to fill possible input pins, and returns

 * the badness value.

 print_nid_path(codec, "multiio", path); */

 nothing found */

 no badness if nothing found */

 cancel newly assigned paths */

 assign volume and mute controls */

 map DACs for all pins in the list if they are single connections */

 print_nid_path(codec, "output", path); */

 create a new path including aamix if available, and return its index */

 print_nid_path(codec, "output-aamix", path); */

 unused as default */

 static route */

 check whether the independent HP is available with the current config */

 assume no path conflicts unless aamix is involved */

 check whether output paths contain aamix */

/* fill the empty entries in the dac array for speaker/hp with the

 * shared dac pointed by the paths

 fill in the dac_nids table from the parsed pin configuration */

 set num_dacs once to full for look_for_dac() */

 clear path indices */

 fill hard-wired DACs first */

 try to fill multi-io first */

 we don't count badness at this stage yet */

 give badness */

 re-count num_dacs and squash invalid entries */

 re-fill the shared DAC for speaker / headphone */

 NOP */

 find all available DACs of the codec */

 set initial pinctl targets */

 clear indep_hp flag if not available */

 add playback controls from the parsed DAC table */

 Center/LFE */

 add playback controls for speaker and HP outputs */

/*

 * independent HP controls

 update HP aamix paths in case it conflicts with indep HP */

/*

 * channel mode enum control

/* Default value to be passed as aamix argument for snd_hda_activate_path();

 * used for output paths

 update jack retasking in case it modifies any of them */

/*

 * aamix loopback enable/disable switch

	/* if HP aamix path is driven from a different DAC and the

	 * independent HP mode is ON, can't turn on aamix path

 re-initialize the output paths; only called from loopback_mixing_put() */

/*

 * shared headphone/mic handling

 for shared I/O, change the pin-control accordingly */

	/* if the HP pin doesn't support VREF and the codec driver gives an

	 * alternative pin, set up the VREF on that pin instead

 create a shared input with the headphone out */

		/* automatic detection: only if no input or a single internal

		 * input pin is found, try to detect the shared hp/mic

 clear once */

 no input */

 we can't handle auto-mic together with HP-mic */

/*

 * output jack mode

/*

 * input jack mode

 from AC_PINCTL_VREF_HIZ to AC_PINCTL_VREF_100 */

 filter out unusual vrefs */

 convert from the enum item index to the vref ctl index (0=HIZ, 1=50%...) */

 convert back from the vref ctl index to the enum item index */

 set the right text */

 already done in create_out_jack_mode() */

 no jack mode for fixed pins */

 no multiple vref caps? */

/*

 * HP/mic shared jack mode

/*

 * Parse input paths

 add the powersave loopback-list entry */

/* return true if either a volume or a mute amp is found for the given

 * aamix path; the amp has to be either in the mixer node or its direct leaf

 check leaf node */

 create input playback/capture controls for the given pin */

 no DAC/ADC involved */

 static route */

 no DAC/ADC involved */

 Parse the codec tree and retrieve ADCs */

 copy the detected ADCs to all_adcs[] */

/* filter out invalid adc_nids that don't give all active input pins;

 * if needed, check whether dynamic ADC-switching is available

 check whether ADC-switch is possible */

 shrink the invalid adcs and input paths */

 reduce to a single ADC */

 single index for individual volumes ctls */

 parse capture source paths from the given pin and create imux items */

/*

 * create playback/capture controls for input pins

 fill the label for each input at first */

 a dummy cfg->input idx for stereo mix */

 add stereo mix when explicitly enabled via hint */

/*

 * input source mux

 get the input path specified by the given adc and imux indices */

 the ctls are created at once with multiple counts */

/*

 * capture volume and capture switch ctls

 call the given amp update function for all amps in the imux list at once */

 capture volume ctl callbacks */

 capture switch ctl callbacks */

 capture switch put callback for a single control with hook call */

 Make independent right kcontrol */

 create single (and simple) capture volume and switch controls */

 create bound capture volume and switch controls */

 return the vol ctl when used first in the imux list */

 create individual capture volume and switch controls per input */

/*

 * add mic boosts if needed

 check whether the given amp is feasible as a boost volume */

 look for a boost amp in a widget close to the pin */

 check only line-in and mic pins */

 create a boost control */

/*

 * vmaster mute LED hook helpers

/**

 * snd_hda_gen_add_mute_led_cdev - Create a LED classdev and enable as vmaster mute LED

 * @codec: the HDA codec

 * @callback: the callback for LED classdev brightness_set_blocking

/**

 * snd_hda_gen_add_micmute_led_cdev - Create a LED classdev and enable as mic-mute LED

 * @codec: the HDA codec

 * @callback: the callback for LED classdev brightness_set_blocking

 *

 * Called from the codec drivers for offering the mic mute LED controls.

 * This creates a LED classdev and sets up the cap_sync_hook that is called at

 * each time when the capture mixer switch changes.

 *

 * When NULL is passed to @callback, no classdev is created but only the

 * LED-trigger is set up.

 *

 * Returns 0 or a negative error.

 CONFIG_SND_HDA_GENERIC_LEDS */

/*

 * parse digital I/Os and set up NIDs in BIOS auto-parse mode

 support multiple SPDIFs; the secondary is set up as a follower */

 no jack detection */

 no jack */

/*

 * input MUX handling

 select the given imux item; either unmute exclusively or select the route */

/* power up/down widgets in the all paths that match with the given NID

 * as terminals (either start- or endpoint)

 *

 * returns the last changed NID, or zero if unchanged.

 check the jack status for power control */

/* power up/down the paths of the given pin according to the jack state;

 * power = 0/1 : only power up/down if it matches with the jack state,

 *       < 0   : force power up/down to follow the jack sate

 *

 * returns the last changed NID, or zero if unchanged.

 callback only doing power up -- called at first */

 callback only doing power down -- called at last */

 set up the power up/down callbacks */

/* enabled power callback to each available I/O pin with jack detections;

 * the digital I/O pins are excluded because of the unreliable detectsion

 sync path power up/down with the jack states of given pins */

 sync path power up/down with pins; called at init and resume */

 add fake paths if not present yet */

 create fake paths to all outputs from beep */

 power up/down beep widget and its output paths */

/**

 * snd_hda_gen_fix_pin_power - Fix the power of the given pin widget to D0

 * @codec: the HDA codec

 * @pin: NID of pin to fix

/*

 * Jack detections for HP auto-mute and mic-switch

 check each pin in the given array; returns true if any of them is plugged */

 don't detect pins retasked as inputs */

 standard HP/line-out auto-mute helper */

 no mute for inputs */

			/* don't reset VREF value in case it's controlling

			 * the amp (see alc861_fixup_asus_amp_vref_0f())

			/* here we call update_pin_ctl() so that the pinctl is

			 * changed without changing the pinctl target value;

			 * the original target value will be still referred at

			 * the init / resume again

/**

 * snd_hda_gen_update_outputs - Toggle outputs muting

 * @codec: the HDA codec

 *

 * Update the mute status of all outputs based on the current jack states.

	/* Control HP pins/amps depending on master_mute state;

	 * in general, HP pins/amps control should be enabled in all cases,

	 * but currently set only for master_mute, just to be safe

 toggle line-out mutes if needed, too */

 if LO is a copy of either HP or Speaker, don't need to handle it */

 sync the whole vmaster followers to reflect the new auto-mute status */

/**

 * snd_hda_gen_hp_automute - standard HP-automute helper

 * @codec: the HDA codec

 * @jack: jack object, NULL for the whole

 No detection for the first HP jack during indep-HP mode */

/**

 * snd_hda_gen_line_automute - standard line-out-automute helper

 * @codec: the HDA codec

 * @jack: jack object, NULL for the whole

 check LO jack only when it's different from HP */

/**

 * snd_hda_gen_mic_autoswitch - standard mic auto-switch helper

 * @codec: the HDA codec

 * @jack: jack object, NULL for the whole

 don't detect pins retasked as outputs */

 call appropriate hooks */

 update jack retasking */

/*

 * Auto-Mute mode mixer enum support

/*

 * Check the availability of HP/line-out auto-mute;

 * Set up appropriately if really supported

 need two different output types */

 create a control for automute mode */

 check whether all auto-mic pins are valid; setup indices if OK */

 no corresponding imux */

 we don't need the jack detection for the first pin */

/*

 * Check the availability of auto-mic switch;

 * Set up if really supported

 already occupied */

 invalid type */

 invalid entry */

 invalid type */

 only mic is allowed */

 no unsol support */

	/* sort the am_entry in the order of attr so that the pin with a

	 * higher attr will be selected when the jack is plugged.

/**

 * snd_hda_gen_path_power_filter - power_filter hook to make inactive widgets

 * into power down

 * @codec: the HDA codec

 * @nid: NID to evalute

 * @power_state: target power state

 mute all aamix inputs initially; parse up to the first leaves */

/**

 * snd_hda_gen_stream_pm - Stream power management callback

 * @codec: the HDA codec

 * @nid: audio widget

 * @on: power on/off flag

 *

 * Set this in patch_ops.stream_pm.  Only valid with power_save_node flag.

/**

 * snd_hda_gen_parse_auto_config - Parse the given BIOS configuration and

 * set up the hda_gen_spec

 * @codec: the HDA codec

 * @cfg: Parsed pin configuration

 *

 * return 1 if successful, 0 if the proper config is not found,

 * or a negative error code

 can't find valid BIOS pin config */

 use HP as primary out */

 add power-down pin callbacks at first */

 check the multiple speaker and headphone pins */

 add stereo mix if available and not enabled yet */

	/* create "Headphone Mic Jack Mode" if no input selection is

	 * available (or user specifies add_jack_modes hint)

 add power-up pin callbacks at last */

 mute all aamix input initially */

/*

 * Build control elements

 follower controls for virtual master */

/**

 * snd_hda_gen_build_controls - Build controls from the parsed results

 * @codec: the HDA codec

 *

 * Pass this to build_controls patch_ops.

 if we have no master control, let's create it */

 no longer needed */

/*

 * PCM definitions

/*

 * Analog playback callbacks

/*

 * Digital out

/*

 * Analog capture

/*

 NID is set in build_pcms */

 NID is set in build_pcms */

 NID is set in build_pcms */

 can be overridden */

 NID is set in build_pcms */

 NID is set in build_pcms */

 NID is set in build_pcms */

 Used by build_pcms to flag that a PCM has no playback stream */

/*

 * dynamic changing ADC PCM streams

 stream is running, let's swap the current ADC */

 analog capture with dynamic dual-adc changes */

 fill later */

 drop non-alnum chars after a space */

/* copy PCM stream info from @default_str, and override non-NULL entries

 * from @spec_str and @nid

/**

 * snd_hda_gen_build_pcms - build PCM streams based on the parsed results

 * @codec: the HDA codec

 *

 * Pass this to build_pcms patch_ops.

 SPDIF for stream index #1 */

	/* If the use of more than one ADC is requested for the current

	 * model, configure a second analog capture-only PCM.

 Additional Analaog capture for index #2 */

/*

 * Standard auto-parser initializations

 configure the given path as a proper output */

 initialize primary output paths */

 initialize hp and speaker paths */

 initialize multi-io paths */

 set up input pins and loopback paths */

 init loopback inputs */

 initialize ADC paths */

 set right pin controls for digital I/O */

/* clear unsol-event tags on unused pins; Conexant codecs seem to leave

 * invalid unsol tags by some reason

/**

 * snd_hda_gen_init - initialize the generic spec

 * @codec: the HDA codec

 *

 * This can be put as patch_ops init function.

 call init functions of standard auto-mute helpers */

/**

 * snd_hda_gen_free - free the generic spec

 * @codec: the HDA codec

 *

 * This can be put as patch_ops free function.

/**

 * snd_hda_gen_check_power_status - check the loopback power save state

 * @codec: the HDA codec

 * @nid: NID to inspect

 *

 * This can be put as patch_ops check_power_status function.

/*

 * the generic codec support

/*

 * snd_hda_parse_generic_codec - Generic codec parser

 * @codec: the HDA codec

 terminator */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * patch_cs8409-tables.c  --  HD audio interface patch for Cirrus Logic CS8409 HDA bridge chip

 *

 * Copyright (C) 2021 Cirrus Logic, Inc. and

 *                    Cirrus Logic International Semiconductor Ltd.

 *

 * Author: Lucas Tanure <tanureal@opensource.cirrus.com>

/******************************************************************************

 *                          CS42L42 Specific Data

 *

 fixed rate */

 fixed rate */

/******************************************************************************

 *                   BULLSEYE / WARLOCK / CYBORG Specific Arrays

 *                               CS8409/CS42L42

 WAKE from GPIO 3,4 */

 Enable VPW processing */

 Configure GPIO 6,7 */

 I2C mode */

 Set I2C bus speed */

 100kHz I2C_STO = 2 */

 terminator */

 ASP-1-TX */

 ASP-1-RX */

 ASP-2-TX */

 DMIC-1 */

 terminator */

 Vendor specific HW configuration for CS42L42 */

 Vendor specific hw configuration for CS8409 */

 +PLL1/2_EN, +I2C_EN */

 ASP1/2_EN=0, ASP1_STP=1 */

 ASP1/2_BUS_IDLE=10, +GPIO_I2C */

 ASP1.A: TX.LAP=0, TX.LSZ=24 bits, TX.LCS=0 */

 ASP1.A: TX.RAP=0, TX.RSZ=24 bits, TX.RCS=32 */

 ASP2.A: TX.LAP=0, TX.LSZ=24 bits, TX.LCS=0 */

 ASP2.A: TX.RAP=1, TX.RSZ=24 bits, TX.RCS=0 */

 ASP1.A: RX.LAP=0, RX.LSZ=24 bits, RX.LCS=0 */

 ASP1.A: RX.RAP=0, RX.RSZ=24 bits, RX.RCS=0 */

 ASP1: LCHI = 00h */

 ASP1: MC/SC_SRCSEL=PLL1, LCPR=FFh */

 ASP1: MCEN=0, FSD=011, SCPOL_IN/OUT=0, SCDIV=1:4 */

 ASP2: LCHI=1Fh */

 ASP2: MC/SC_SRCSEL=PLL1, LCPR=3Fh */

 ASP2: 5050=1, MCEN=0, FSD=010, SCPOL_IN/OUT=1, SCDIV=1:16 */

 DMIC1_MO=10b, DMIC1/2_SR=1 */

 ASP1/2_BEEP=0 */

 ASP1/2_EN=1, ASP1_STP=1 */

 -PLL2_EN */

 TX2.A: pre-scale att.=0 dB */

 ASP1/2_xxx_EN=1, ASP1/2_MCLK_EN=0, DMIC1_SCL_EN=1 */

 test mode on */

 GPIO hysteresis = 30 us */

 test mode off */

 Terminator */

 EQ_SEL=1, EQ1/2_EN=0 */

 +EQ_ACC */

 +EQ2_EN */

 EQ_DATA_HI=0x0647 */

 +EQ_WRT, +EQ_ACC, EQ_ADR=0, EQ_DATA_LO=0x67 */

 EQ_DATA_HI=0x0647 */

 +EQ_WRT, +EQ_ACC, EQ_ADR=1, EQ_DATA_LO=0x67 */

 EQ_DATA_HI=0xf370 */

 +EQ_WRT, +EQ_ACC, EQ_ADR=2, EQ_DATA_LO=0x71 */

 EQ_DATA_HI=0x1ef8 */

 +EQ_WRT, +EQ_ACC, EQ_ADR=3, EQ_DATA_LO=0x48 */

 EQ_DATA_HI=0xc110 */

 +EQ_WRT, +EQ_ACC, EQ_ADR=4, EQ_DATA_LO=0x5a */

 EQ_DATA_HI=0x1f29 */

 +EQ_WRT, +EQ_ACC, EQ_ADR=5, EQ_DATA_LO=0x74 */

 EQ_DATA_HI=0x1d7a */

 +EQ_WRT, +EQ_ACC, EQ_ADR=6, EQ_DATA_LO=0x53 */

 EQ_DATA_HI=0xc38c */

 +EQ_WRT, +EQ_ACC, EQ_ADR=7, EQ_DATA_LO=0x14 */

 EQ_DATA_HI=0x1ca3 */

 +EQ_WRT, +EQ_ACC, EQ_ADR=8, EQ_DATA_LO=0xc7 */

 EQ_DATA_HI=0xc38c */

 +EQ_WRT, +EQ_ACC, EQ_ADR=9, EQ_DATA_LO=0x14 */

 -EQ_ACC, -EQ_WRT */

 Terminator */

/******************************************************************************

 *                          Dolphin Specific Arrays

 *                            CS8409/ 2 X CS42L42

 WAKE from GPIO 0,4 */

 Enable VPW processing  */

 Configure GPIO 6,7 */

 I2C mode */

 Set I2C bus speed */

 100kHz I2C_STO = 2 */

 terminator */

 ASP-1-TX-A */

 ASP-1-TX-B */

 ASP-1-RX */

 terminator */

 Vendor specific HW configuration for CS42L42 */

 Vendor specific hw configuration for CS8409 */

 +PLL1/2_EN, +I2C_EN */

 ASP1_EN=0, ASP1_STP=1 */

 ASP1/2_BUS_IDLE=10, +GPIO_I2C */

 ASP1.A: TX.LAP=0, TX.LSZ=24 bits, TX.LCS=0 */

 ASP1.A: TX.RAP=0, TX.RSZ=24 bits, TX.RCS=32 */

 ASP1.B: TX.LAP=0, TX.LSZ=24 bits, TX.LCS=128 */

 ASP1.B: TX.RAP=0, TX.RSZ=24 bits, TX.RCS=160 */

 ASP1.A: RX.LAP=0, RX.LSZ=24 bits, RX.LCS=0 */

 ASP1.A: RX.RAP=0, RX.RSZ=24 bits, RX.RCS=0 */

 ASP1: LCHI = 00h */

 ASP1: MC/SC_SRCSEL=PLL1, LCPR=FFh */

 ASP1: MCEN=0, FSD=011, SCPOL_IN/OUT=0, SCDIV=1:4 */

 ASP1/2_BEEP=0 */

 ASP1_EN=1, ASP1_STP=1 */

 -PLL2_EN */

 ASP1_xxx_EN=1, ASP1_MCLK_EN=0 */

 test mode on */

 GPIO hysteresis = 30 us */

 test mode off */

 Terminator */

/******************************************************************************

 *                         CS8409 Patch Driver Structs

 *                    Arrays Used for all projects using CS8409

 terminator */

 Dell Inspiron models with cs8409/cs42l42 */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * BIOS auto-parser helper functions for HD-audio

 *

 * Copyright (c) 2012 Takashi Iwai <tiwai@suse.de>

/*

 * Helper for automatic pin configuration

 a pair of input pin and its sequence */

/*

 * Sort an associated group of pins according to their sequence numbers.

 * then store it to a pin array.

 add the found input-pin to the cfg->inputs[] table */

 If has both hs_mic and hp_mic, pick the hs_mic ahead of hp_mic. */

 don't swap */

 swap */

	/* In case one has boost and the other one has not,

/* Reorder the surround channels

 * ALSA sequence is front/surr/clfe/side

 * HDA sequence is:

 *    4-ch: front/surr  =>  OK as it is

 *    6-ch: front/clfe/surr

 *    8-ch: front/clfe/rear/side|fc

 check whether the given pin has a proper pin I/O capability bit */

 some old hardware don't return the proper pincaps */

 Already assigned */

/*

 * Parse all pin widgets and store the useful pin nids to cfg

 *

 * The number of line-outs or any primary output is stored in line_outs,

 * and the corresponding output pins are assigned to line_out_pins[],

 * in the order of front, rear, CLFE, side, ...

 *

 * If more extra outputs (speaker and headphone) are found, the pins are

 * assisnged to hp_pins[] and speaker_pins[], respectively.  If no line-out jack

 * is detected, one of speaker of HP pins is assigned as the primary

 * output, i.e. to line_out_pins[0].  So, line_outs is always positive

 * if any analog output exists.

 *

 * The analog input pins are assigned to inputs array.

 * The digital input/output pins are assigned to dig_in_pin and dig_out_pin,

 * respectively.

 read all default configuration for pin complex */

 ignore the given nids (e.g. pc-beep returns error) */

 workaround for buggy BIOS setups */

 Find a pin that could be a headset or headphone mic */

 If we didn't find our sequence number mark, fall back to any sequence number */

	/* FIX-UP:

	 * If no line-out is defined but multiple HPs are found,

	 * some of them might be the real line-outs.

 The real HPs should have the sequence 0x0f */

 Move it to the line-out table */

 sort by sequence */

	/*

	 * FIX-UP: if no line-outs are detected, try to use speaker or HP pin

	 * as a primary output

 sort inputs in the order of AUTO_PIN_* type */

	/*

	 * debug prints of the parsed results

/**

 * snd_hda_get_input_pin_attr - Get the input pin attribute from pin config

 * @def_conf: pin configuration value

 *

 * Guess the input pin attribute (INPUT_PIN_ATTR_XXX) from the given

 * default pin configuration value.

 Windows may claim the internal mic to be BOTH, too */

/**

 * hda_get_input_pin_label - Give a label for the given input pin

 * @codec: the HDA codec

 * @item: ping config item to refer

 * @pin: the pin NID

 * @check_location: flag to add the jack location prefix

 *

 * When @check_location is true, the function checks the pin location

 * for mic and line-in pins, and set an appropriate prefix like "Front",

 * "Rear", "Internal".

/* Check whether the location prefix needs to be added to the label.

 * If all mic-jacks are in the same location (e.g. rear panel), we don't

 * have to put "Front" prefix to each label.  In such a case, returns false.

 for internal or docking mics, we need locations */

 different locations found */

/**

 * hda_get_autocfg_input_label - Get a label for the given input

 * @codec: the HDA codec

 * @cfg: the parsed pin configuration

 * @input: the input index number

 *

 * Get a label for the given input pin defined by the autocfg item.

 * Unlike hda_get_input_pin_label(), this function checks all inputs

 * defined in autocfg and avoids the redundant mic/line prefix as much as

 * possible.

 return the position of NID in the list, or -1 if not found */

 get a unique suffix or an index number */

 check the location */

 handle as a speaker if it's a fixed line-out */

 try to give a unique suffix if needed */

 don't add channel suffix for Headphone controls */

/**

 * snd_hda_get_pin_label - Get a label for the given I/O pin

 * @codec: the HDA codec

 * @nid: pin NID

 * @cfg: the parsed pin configuration

 * @label: the string buffer to store

 * @maxlen: the max length of string buffer (including termination)

 * @indexp: the pointer to return the index number (for multiple ctls)

 *

 * Get a label for the given pin.  This function works for both input and

 * output pins.  When @cfg is given as non-NULL, the function tries to get

 * an optimized label using hda_get_autocfg_input_label().

 *

 * This function tries to give a unique label string for the pin as much as

 * possible.  For example, when the multiple line-outs are present, it adds

 * the channel suffix like "Front", "Surround", etc (only when @cfg is given).

 * If no unique name with a suffix is available and @indexp is non-NULL, the

 * index number is stored in the pointer.

/**

 * snd_hda_add_verbs - Add verbs to the init list

 * @codec: the HDA codec

 * @list: zero-terminated verb list to add

 *

 * Append the given verb list to the execution list.  The verbs will be

 * performed at init and resume time via snd_hda_apply_verbs().

/**

 * snd_hda_apply_verbs - Execute the init verb lists

 * @codec: the HDA codec

/**

 * snd_hda_apply_pincfgs - Set each pin config in the given list

 * @codec: the HDA codec

 * @cfg: NULL-terminated pin config table

/**

 * snd_hda_apply_fixup - Apply the fixup chain with the given action

 * @codec: the HDA codec

 * @action: fixup action (HDA_FIXUP_ACT_XXX)

/**

 * snd_hda_pick_pin_fixup - Pick up a fixup matching with the pin quirk list

 * @codec: the HDA codec

 * @pin_quirk: zero-terminated pin quirk list

 * @fixlist: the fixup list

 * @match_all_pins: all valid pins must match with the table entries

/**

 * snd_hda_pick_fixup - Pick up a fixup matching with PCI/codec SSID or model string

 * @codec: the HDA codec

 * @models: NULL-terminated model string list

 * @quirk: zero-terminated PCI/codec SSID quirk list

 * @fixlist: the fixup list

 *

 * Pick up a fixup entry matching with the given model string or SSID.

 * If a fixup was already set beforehand, the function doesn't do anything.

 * When a special model string "nofixup" is given, also no fixup is applied.

 *

 * The function tries to find the matching model name at first, if given.

 * If the model string contains the SSID alias, try to look up with the given

 * alias ID.

 * If nothing matched, try to look up the PCI SSID.

 * If still nothing matched, try to look up the codec SSID.

 when model=nofixup is given, don't pick up any fixups */

 match with the model name string */

 match with the SSID alias given by the model string "XXXX:YYYY" */

 match with the PCI SSID */

 match with the codec SSID */

 no matching */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Universal Interface for Intel High Definition Audio Codec

 *

 * HD audio interface patch for VIA VT17xx/VT18xx/VT20xx codec

 *

 *  (C) 2006-2009 VIA Technology, Inc.

 *  (C) 2006-2008 Takashi Iwai <tiwai@suse.de>

 * * * * * * * * * * * * * Release History * * * * * * * * * * * * * * * * */

									     */

 2006-03-03  Lydia Wang  Create the basic patch to support VT1708 codec    */

 2006-03-14  Lydia Wang  Modify hard code for some pin widget nid	     */

 2006-08-02  Lydia Wang  Add support to VT1709 codec			     */

 2006-09-08  Lydia Wang  Fix internal loopback recording source select bug */

 2007-09-12  Lydia Wang  Add EAPD enable during driver initialization	     */

 2007-09-17  Lydia Wang  Add VT1708B codec support			    */

 2007-11-14  Lydia Wang  Add VT1708A codec HP and CD pin connect config    */

 2008-02-03  Lydia Wang  Fix Rear channels and Back channels inverse issue */

 2008-03-06  Lydia Wang  Add VT1702 codec and VT1708S codec support	     */

 2008-04-09  Lydia Wang  Add mute front speaker when HP plugin	     */

 2008-04-09  Lydia Wang  Add Independent HP feature			     */

 2008-05-28  Lydia Wang  Add second S/PDIF Out support for VT1702	     */

 2008-09-15  Logan Li	   Add VT1708S Mic Boost workaround/backdoor	     */

 2009-02-16  Logan Li	   Add support for VT1718S			     */

 2009-03-13  Logan Li	   Add support for VT1716S			     */

 2009-04-14  Lydai Wang  Add support for VT1828S and VT2020		     */

 2009-07-08  Lydia Wang  Add support for VT2002P			     */

 2009-07-21  Lydia Wang  Add support for VT1812			     */

 2009-09-19  Lydia Wang  Add support for VT1818S			     */

									     */

 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

 Pin Widget NID */

 HP mode source */

 analog low-power control */

 work to check hp jack state */

 defined below */

 VT1708BCE & VT1708S are almost same */

 get codec type */

 codec->power_save_node = val; */ 
 additional beep mixers; the actual parameters are overwritten at build */

 check AA path's mute status */

 enter/exit analog low-current mode */

 decide low current mode's verb & parameter */

 0x02: 2/3x, 0x00: 1x */

 0x51: 4/28x, 0xe1: 1x */

 0x01: 4/40x, 0x1d: 1x */

 0x00: 4/40x, 0xe0: 1x */

 0x00: 4/40x, 0xe0: 1x */

 other codecs are not supported */

 send verb */

 Fix pop noise on headphones */

 some delay here to make jack detection working (bko#98921) */

/*

 power down jack detect function */

 disable widget PM at start for compatibility */

 init power states */

	/* In order not to create "Phantom Jack" controls,

	/* We got noisy outputs on the right channel on VT1708 when

	 * 24bit samples are used.  Until any workaround is found,

	 * disable the 24bit format, so far.

 create a codec specific record */

 override some patch_ops */

 set jackpoll_interval while parsing the codec */

 don't support the input jack switching due to lack of unsol event */

 (it may work with polling, though, but it needs testing) */

 Some machines show the broken speaker mute */

 Add HP and CD pin config connect bit re-config action */

 automatic parse from the BIOS config */

 add jack detect on/off control */

 clear jackpoll_interval again; it's set dynamically */

 create a codec specific record */

 create a codec specific record */

 automatic parse from the BIOS config */

 Patch for VT1708S */

 Enable Mic Boost Volume backdoor */

 don't bybass mixer */

 create a codec specific record */

 correct names for VT1708BCE */

 correct names for VT1705 */

 automatic parse from the BIOS config */

 Patch for VT1702 */

 mixer enable */

 GPIO 0~2 */

 create a codec specific record */

 limit AA path volume to 0 dB */

 automatic parse from the BIOS config */

 Patch for VT1718S */

 Enable MW0 adjust Gain 5 */

 Enable Boost Volume backdoor */

/* Add a connection to the primary DAC from AA-mixer for some codecs

 * This isn't listed from the raw info, but the chip has a secret connection.

 find the primary DAC and add to the connection list */

 create a codec specific record */

 automatic parse from the BIOS config */

 Patch for VT1716S */

 mono-out mixer elements */

 Enable Boost Volume backdoor */

 don't bybass mixer */

 Enable mono output */

 create a codec specific record */

 automatic parse from the BIOS config */

 for vt2002P */

 Class-D speaker related verbs */

 Enable Boost Volume backdoor */

 Enable AOW0 to MW9 */

 Enable Boost Volume backdoor */

 Enable AOW0 to MW9 */

/*

 * pin fix-up

 set 0x24 and 0x33 as speakers */

 subwoofer */

/* NIDs 0x24 and 0x33 on VT1802 have connections to non-existing NID 0x3e

 * Replace this with mixer NID 0x1c

 patch for vt2002P */

 create a codec specific record */

 automatic parse from the BIOS config */

 for vt1812 */

 Enable Boost Volume backdoor */

 Enable AOW0 to MW9 */

 patch for vt1812 */

 create a codec specific record */

 automatic parse from the BIOS config */

 patch for vt3476 */

 Enable DMic 8/16/32K */

 Enable Boost Volume backdoor */

 Enable AOW-MW9 path */

 create a codec specific record */

 automatic parse from the BIOS config */

/*

 * patch entries

 terminator */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * HD audio interface patch for AD1882, AD1884, AD1981HD, AD1983, AD1984,

 *   AD1986A, AD1988

 *

 * Copyright (c) 2005-2007 Takashi Iwai <tiwai@suse.de>

 for auto parser */

 beep amp value, set via set_beep_amp() */

 additional beep mixers; the actual parameters are overwritten at build */

 end */

 mono */

 NOP */

 We currently only handle front, HP */

 follow EAPD via vmaster hook */

/*

 * Automatic parse of I/O pins from the BIOS configuration

/*

 * AD1986A specific

/*

 * AD1986A fixup codes

 Lenovo N100 seems to report the reversed bit for HP jack-sensing */

 Toshiba Satellite L40 implements EAPD in a standard way unlike others */

 enable stereo-mix input for avoiding regression on KDE (bko#88251) */

 speaker */

 int mic */

 speaker */

 int mic */

 N/A */

 N/A */

 headphone */

 front */

 line-in */

 rear mic */

 N/A */

 mic */

 N/A */

 headphone */

 speaker */

 N/A */

 N/A */

 N/A */

 mic */

 N/A */

 int mic */

 headphone */

 speaker */

 N/A */

 int mic */

 N/A */

 mic */

 N/A */

 N/A */

 N/A */

 N/A */

 N/A */

 N/A */

 alias */

/*

 AD1986A has the inverted EAPD implementation */

	/* AD1986A has a hardware problem that it can't share a stream

	 * with multiple output pins.  The copy of front to surrounds

	 * causes noisy or silent outputs at a certain timing, e.g.

	 * changing the volume.

	 * So, let's disable the shared stream.

 give fixed DAC/pin pairs */

 AD1986A can't manage the dynamic pin on/off smoothly */

/*

 * AD1983 specific

/*

 * SPDIF mux control for AD1983 auto-parser

 limit the loopback routes not to confuse the parser */

/*

 * AD1981 HD specific

/* set the upper-limit for mixer amp to 0dB for avoiding the possible

 * damage by overloading

 HP nx6320 (reversed SSID, H/W bug) */

/*

 * AD1988

 *

 * Output pins and routes

 *

 *        Pin               Mix     Sel     DAC (*)

 * port-A 0x11 (mute/hp) <- 0x22 <- 0x37 <- 03/04/06

 * port-B 0x14 (mute/hp) <- 0x2b <- 0x30 <- 03/04/06

 * port-C 0x15 (mute)    <- 0x2c <- 0x31 <- 05/0a

 * port-D 0x12 (mute/hp) <- 0x29         <- 04

 * port-E 0x17 (mute/hp) <- 0x26 <- 0x32 <- 05/0a

 * port-F 0x16 (mute)    <- 0x2a         <- 06

 * port-G 0x24 (mute)    <- 0x27         <- 05

 * port-H 0x25 (mute)    <- 0x28         <- 0a

 * mono   0x13 (mute/amp)<- 0x1e <- 0x36 <- 03/04/06

 *

 * DAC0 = 03h, DAC1 = 04h, DAC2 = 05h, DAC3 = 06h, DAC4 = 0ah

 * (*) DAC2/3/4 are swapped to DAC3/4/2 on AD198A rev.2 due to a h/w bug.

 *

 * Input pins and routes

 *

 *        pin     boost   mix input # / adc input #

 * port-A 0x11 -> 0x38 -> mix 2, ADC 0

 * port-B 0x14 -> 0x39 -> mix 0, ADC 1

 * port-C 0x15 -> 0x3a -> 33:0 - mix 1, ADC 2

 * port-D 0x12 -> 0x3d -> mix 3, ADC 8

 * port-E 0x17 -> 0x3c -> 34:0 - mix 4, ADC 4

 * port-F 0x16 -> 0x3b -> mix 5, ADC 3

 * port-G 0x24 -> N/A  -> 33:1 - mix 1, 34:1 - mix 4, ADC 6

 * port-H 0x25 -> N/A  -> 33:2 - mix 1, 34:2 - mix 4, ADC 7

 *

 *

 * DAC assignment

 *   6stack - front/surr/CLFE/side/opt DACs - 04/06/05/0a/03

 *   3stack - front/surr/CLFE/opt DACs - 04/05/0a/03

 *

 * Inputs of Analog Mix (0x20)

 *   0:Port-B (front mic)

 *   1:Port-C/G/H (line-in)

 *   2:Port-A

 *   3:Port-D (line-in/2)

 *   4:Port-E/G/H (mic-in)

 *   5:Port-F (mic2-in)

 *   6:CD

 *   7:Beep

 *

 * ADC selection

 *   0:Port-A

 *   1:Port-B (front mic-in)

 *   2:Port-C (line-in)

 *   3:Port-F (mic2-in)

 *   4:Port-E (mic-in)

 *   5:CD

 *   6:Port-G

 *   7:Port-H

 *   8:Port-D (line-in/2)

 *   9:Mix

 *

 * Proposed pin assignments by the datasheet

 *

 * 6-stack

 * Port-A front headphone

 *      B front mic-in

 *      C rear line-in

 *      D rear front-out

 *      E rear mic-in

 *      F rear surround

 *      G rear CLFE

 *      H rear side

 *

 * 3-stack

 * Port-A front headphone

 *      B front mic

 *      C rear line-in/surround

 *      D rear front-out

 *      E rear mic-in/CLFE

 *

 * laptop

 * Port-A headphone

 *      B mic-in

 *      C docking station

 *      D internal speaker (with EAPD)

 *      E/F quad mic array

	/* we create four static faked paths, since AD codecs have odd

	 * widget connections regarding the SPDIF out source

 SPDIF source mux appears to be present only on AD1988A */

/*

 front-hp */

 line-out */

 front-mic */

 line-in */

 line-out */

 mic */

 SPDIF */

 line-out */

 line-out */

/*

 * AD1884 / AD1984

 *

 * port-B - front line/mic-in

 * port-E - aux in/out

 * port-F - aux in/out

 * port-C - rear line/mic-in

 * port-D - rear line/hp-out

 * port-A - front line/hp-out

 *

 * AD1984 = AD1884 + two digital mic-ins

 *

 * AD1883 / AD1884A / AD1984A / AD1984B

 *

 * port-B (0x14) - front mic-in

 * port-E (0x1c) - rear mic-in

 * port-F (0x16) - CD / ext out

 * port-C (0x15) - rear line-in

 * port-D (0x12) - rear line-out

 * port-A (0x11) - front hp-out

 *

 * AD1984A = AD1884A + digital-mic

 * AD1883 = equivalent with AD1984A

 * AD1984B = AD1984A + extra SPDIF-out

/* set the upper-limit for mixer amp to 0dB for avoiding the possible

 * damage by overloading

 toggle GPIO1 according to the mute state */

 Analog PC Beeper - allow firmware/ACPI beeps */

 no digital beep */

 set magic COEFs for dmic */

/*

 * AD1882 / AD1882A

 *

 * port-A - front hp-out

 * port-B - front mic-in

 * port-C - rear line-in, shared surr-out (3stack)

 * port-D - rear line-out

 * port-E - rear mic-in, shared clfe-out (3stack)

 * port-F - rear surr-out (6stack)

 * port-G - rear clfe-out (6stack)

/*

 * patch entries

 terminator */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Universal Interface for Intel High Definition Audio Codec

 *

 * HD audio interface patch for SigmaTel STAC92xx

 *

 * Copyright (c) 2005 Embedded Alley Solutions, Inc.

 * Matt Porter <mporter@embeddedalley.com>

 *

 * Based on patch_cmedia.c and patch_realtek.c

 * Copyright (c) 2004 Takashi Iwai <tiwai@suse.de>

 no jack-detection */

 no jack-detection */

 4-pin headset jack (hp + mono mic) */

 special volume-knob initialization */

 gpio lines */

 pin NID for mute-LED vref control */

 capture mute LED GPIO */

 current mic mute state (bitmask) */

 stream */

 analog loopback */

 power management */

 beep widgets */

 SPDIF-out mux */

/*

 * PCM hooks

/*

 * Early 2006 Intel Macintoshes with STAC9220X5 codecs seem to have a

 * funky external mute control using GPIO pins.

 Configure GPIOx as CMOS */

 sync */

 sync */

 hook for controlling mic-mute LED GPIO */

 prevent codec AFG to D3 state when vref-out pin is used for mute LED */

 this hook is set in stac_setup_gpio() */

 update mute-LED accoring to the master switch */

 LED state is inverted on these systems */

 vmaster hook to update mute LED */

 automute hook to handle GPIO mute and EAPD updates */

 power down unused output ports */

 update power bit per jack plug/unplug */

 update all jacks */

 toggle VREF state based on GPIOx status */

/* initialize the power map and enable the power event to jacks that

 * haven't been assigned to automute

/*

 override some hints from the hwdep entry */

/*

 * loopback controls

	/* Only return the bits defined by the shift value of the

	 * first two bytes of the mask

/*

 * Mute LED handling on HP laptops

 check whether it's a HP laptop with a docking port */

 HP ProBook 6550b */

 GPIO 3 */

 GPIO 0 */

/*

 * This method searches for the mute LED GPIO configuration

 * provided as OEM string in SMBIOS. The format of that string

 * is HP_Mute_LED_P_G or HP_Mute_LED_P

 * where P can be 0 or 1 and defines mute LED GPIO control state (low/high)

 * that corresponds to the NOT muted state of the master volume

 * and G is the index of the GPIO to use as the mute LED control (0..9)

 * If _G portion is missing it is assigned based on the codec ID

 *

 * So, HP B-series like systems may have HP_Mute_LED_0 (current models)

 * or  HP_Mute_LED_0_3 (future models) OEM SMBIOS strings

 *

 *

 * The dv-series laptops don't seem to have the HP_Mute_LED* strings in

 * SMBIOS - at least the ones I have seen do not have them - which include

 * my own system (HP Pavilion dv6-1110ax) and my cousin's

 * HP Pavilion dv9500t CTO.

 * Need more information on whether it is true across the entire series.

 * -- kunal

 BIOS bug: unfilled OEM string */

	/*

	 * Fallback case - if we don't find the DMI strings,

	 * we statically set the GPIO - if not a B-series system

	 * and default polarity is provided

 check whether a built-in speaker is included in parsed pins */

/*

 * PC beep controls

 create PC beep volume controls */

 check for mute support for the amp */

 check to see if there is volume support for the amp */

/*

 * SPDIF-out mux controls

 count set later */

 set dac0mux for dac converter */

	/* set master volume to max value without distortion

 set master volume and direct control */

 power state controls amps */

 set master volume and direct control */

 unmute right and left channels for nodes 0x0f, 0xa, 0x0d */

 set dac0mux for dac converter */

 mute the master volume */

 set master volume and direct control */

 unmute node 0x1b */

 select node 0x03 as DAC */

 don't set delta bit */

 unmute node 0x1b */

 select node 0x03 as DAC */

 set master volume and direct control */

 enable analog pc beep path */

 don't set delta bit */

 enable analog pc beep path */

 set master volume and direct control */

 enable analog pc beep path */

/*

    STAC 9200 pin configs for

    102801A8

    102801DE

    102801E8

/*

    STAC 9200 pin configs for

    102801C0

    102801C1

/*

    STAC 9200 pin configs for

    102801C4 (Dell Dimension E310)

    102801C5

    102801C7

    102801D9

    102801DA

    102801E3

/* 

    STAC 9200-32 pin configs for

    102801B5 (Dell Inspiron 630m)

    102801D8 (Dell Inspiron 640m)

/* 

    STAC 9200-32 pin configs for

    102801C2 (Dell Latitude D620)

    102801C8 

    102801CC (Dell Latitude D820)

    102801D4 

    102801D6 

/* 

    STAC 9200-32 pin configs for

    102801CE (Dell XPS M1710)

    102801CF (Dell Precision M90)

/*

    STAC 9200-32 pin configs for 

    102801C9

    102801CA

    102801CB (Dell Latitude 120L)

    102801D3

/*

    STAC 9200-32 pin configs for

    102801BD (Dell Inspiron E1505n)

    102801EE

    102801EF

/*

    STAC 9200-32 pin configs for

    102801F5 (Dell Inspiron 1501)

    102801F6

/*

    STAC 9200-32

    102801CD (Dell Inspiron E1705/9400)

/*

 *  STAC 92HD700

 *  18881000 Amigaone X1000

 Front panel HP socket */

 Front Mic */

 Line in */

 Line out */

 Rear Mic */

 Rear speakers */

 Center speaker */

 Side speakers (7.1) */

 Motherboard CD line in connector */

 Unused */

 Unused */

 S/PDIF line out */

 Unused */

 Unused */

		/* CF-74 has no headphone detection, and the driver should *NOT*

		 * do detection and HP/speaker toggle because the hardware does it.

 SigmaTel reference board */

 Dell laptops have BIOS problem */

 Panasonic */

 Gateway machines needs EAPD to be set on resume */

 OQO Mobile */

 terminator */

 SigmaTel reference board */

 Default table for unknown ID */

 gateway machines are checked via codec ssid */

 Not sure about the brand name for those */

 terminator */

 Analog Mics */

 Digital Mics */

 Both */

 enable 5.1 and SPDIF out */

 SigmaTel reference board */

 codec SSID matching */

 terminator */

 allow auto-switching of dock line-in */

 GPIO3 */

 resetting controller clears GPIO, so we need to keep on */

 GPIO4 */

 44.1KHz base */

 48KHz base */

 common */

 SigmaTel reference board */

 match both for 0xfa91 and 0xfa93 */

 terminator */

 HP dv7 bass switch - GPIO5 */

 Enable VREF power saving on GPIO1 detect */

 enable internal microphone */

 enable bass on HP dv7 */

 count line-out, too, as BIOS sets often so */

	/* It was changed in the BIOS to just satisfy MS DTM.

	 * Lets turn it back into follower HP

	/* when both output A and F are assigned, these are supposedly

	 * dock and built-in headphones; fix both pin configs

 SigmaTel reference board */

 HDX18 */

 HDX16 */

 HP dv6-1110ax */

 terminator */

/*

    STAC 922X pin configs for

    102801A7

    102801AB

    102801A9

    102801D1

    102801D2

/*

    STAC 922X pin configs for

    102801AC

    102801D0

/*

    STAC 922X pin configs for

    102801BF

/*

    STAC 9221 A1 pin configs for

    102801D7 (Dell XPS M1210)

 codec SSIDs for Intel Mac sharing the same PCI SSID 8384:7680 */

 remap the fixup from codec SSID and apply it */

 for backward compatibility */

 SigmaTel reference board */

 Intel 945G based systems */

 Intel D945G 5-stack systems */

 Intel 945P based systems */

 other intel */

 other systems  */

 Apple Intel Mac (Mac Mini, MacBook, MacBook Pro...) */

 Dell systems  */

 ECS/PC Chips boards */

 terminator */

 no jack detecion for ref-no-jd model */

 GPIO2 High = Enable EAPD */

 correct the front output jack as a hp out */

 correct the front input jack as a mic */

 configure the analog microphone on some laptops */

 correct the device field to SPDIF out */

 SigmaTel reference board */

 Intel 946 based systems */

 965 based 3 stack systems */

 Dell 3 stack systems */

 Dell 3 stack systems with verb table in BIOS */

 965 based 5 stack systems */

 Nemo */

 volume-knob fixes */

 terminator */

/*

    STAC 9205 pin configs for

    102801F1

    102801F2

    102801FC

    102801FD

    10280204

    1028021F

    10280228 (Dell Vostro 1500)

    10280229 (Dell Vostro 1700)

/*

    STAC 9205 pin configs for

    102801F9

    102801FA

    102801FE

    102801FF (Dell Precision M4300)

    10280206

    10280200

    10280201

 Enable SPDIF in/out */

 SPDIF-In enabled */

 Enable unsol response for GPIO4/Dock HP connection */

		/* GPIO0 High = EAPD, GPIO1 Low = Headphone Mute,

		 * GPIO3 Low = DRM

 SigmaTel reference board */

 Dell */

 Gateway */

 terminator */

 HPF to 100Hz */

 terminator */

 add hooks */

 setup analog beep controls */

 setup digital beep controls and input device */

 IDT/STAC codecs have linear beep tone parameter */

 if no beep switch is available, make its own one */

 override some hints */

 set up GPIO */

	/* turn on EAPD statically when spec->eapd_switch isn't set.

	 * otherwise, unsol event will turn it on/off dynamically

 sync the power-map */

 power down inactive ADCs */

 stac92hd71bxx, stac92hd73xx */

 CONFIG_PM */

 seems common with STAC/IDT codecs */

	/* enable power_save_node only for new 92HD89xx chips, as it causes

	 * click noises on old 92HD73xx chips.

 6 Channel */

 8 Channel */

 10 Channel */

 digital beep */

 GPIO0 High = Enable EAPD */

	/* Don't GPIO-mute speakers if there are no internal speakers, because

	 * the GPIO might be necessary for Headphone

 longer delay needed for D3 */

 digital beep */

 no default cfg */

 longer delay needed for D3 */

 digital beep */

 disabled power_save_node since it causes noises on a Dell machine */

 codec->power_save_node = 1; */

 GPIO0 = EAPD */

 4 Port without Analog Mixer */

 5 Port with Analog Mixer */

 40 milliseconds */

 disable VSW */

 6 Port with Analog Mixer */

 40 milliseconds */

 digital beep */

 Fix Mux capture level; max to 2 */

 digital beep */

 GPIO0 High = Enable EAPD */

	/*

	 * !!FIXME!!

	 * The STAC927x seem to require fairly long delays for certain

	 * command sequences.  With too short delays (even if the answer

	 * is set to RIRB properly), it results in the silence output

	 * on some hardwares like Dell.

	 *

	 * The below flag enables the longer delay (see get_response

	 * in hda_intel.c).

 digital beep */

 GPIO0 High = EAPD */

 Turn on/off EAPD per HP plugging */

/*

 * STAC9872 hack

 mic-sel: 0a,0d,14,02 */

 Mic-in -> 0x9 */

 terminator */

/*

 * patch entries

	/* The following does not take into account .id=0x83847661 when subsys =

	 * 104D0C00 which is STAC9225s. Because of this, some SZ Notebooks are

	 * currently not fully supported.

 terminator */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>

 *  Routines for control of YMF724/740/744/754 chips

/*

 *  common I/O routines

/*

 *  Misc routines

 FIXME: What's the right value? */

/*

 *  Hardware start management

/*

 *  Playback voice management

 TODO: synth/midi voice deallocation */

/*

 *  PCM part

			/*

			dev_dbg(chip->card->dev,

			       "done - active_bank = 0x%x, start = 0x%x\n",

			       chip->active_bank,

			       voice->bank[chip->active_bank].start);

			/*

			dev_dbg(chip->card->dev,

			       "done - active_bank = 0x%x, start = 0x%x\n",

			       chip->active_bank,

			       voice->bank[chip->active_bank].start);

 already allocated */

 already allocated */

        			/* The SPDIF out channels seem to be swapped, so we have

        			 * to swap them here, too.  The rear analog out channels

        			 * will be wrong, but otherwise AC3 would not work.

 snd_ymfpci_irq_wait(chip);

 wait, until the PCI operations are not finished */

 wait, until the PCI operations are not finished */

 FIXME: enough? */

 FIXME: enough? */

 FIXME: enough? */

 FIXME: enough? */

 FIXME? True value is 256/48 = 5.33333 ms */

 call with spinlock held */

 set AC3 */

 enable second codec (4CHEN) */

 call with spinlock held */

 FIXME? True value is 256/48 = 5.33333 ms */

 global setup */

 global setup */

 global setup */

 global setup */

/*

 *  Mixer controls

/*

 * 4ch duplication

/*

 * GPIO

 set the level mode for input line */

/*

 * PCM voice volume

/*

 *  Mixer routines

 YMFPCI doesn't need VRA */

 to be sure */

 add S/PDIF control */

 direct recording source */

	/*

	 * shared rear/line-in

 per-voice volume */

/*

 * timer

		/*

		 * Divisor 1 is not allowed; fake it by using divisor 2 and

		 * counting two ticks for each interrupt.

 1 / 96 kHz = 10.41666...us */

/*

 *  proc interface

/*

 *  initialization routines

 force to reset

 setup DSP instruction code */

 setup control instruction code */

	/* work_ptr must be aligned to 256 bytes, but it's already

 for sure */

 S/PDIF output initialization */

 S/PDIF input initialization */

 digital mixer setup */

 spdif */

 volumes */

 address bases */

 capture set up */

 start hw again */

 CONFIG_PM_SLEEP */

 enable PCI device */

 seems we need a delay after downloading image.. */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  The driver for the Yamaha's DS1/DS1E cards

 *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>

 Index 0-MAX */

 ID for this card */

 Enable this card */

 YMF724 */

 YMF724F */

 YMF740 */

 YMF740C */

 YMF744 */

 YMF754 */

 YMF 744/754 */

 auto-detect */

 auto-detect */

 YMF 744/754 */

 SUPPORT_JOYSTICK */

 SBEN = 0, SMOD = 01, LAD = 0 */

 YMF 744/754 */

 auto-detect */

 auto-detect */

 disable MPU401 irq */

 SPDX-License-Identifier: GPL-2.0-only

/*****************************************************************************

 *

 * Copyright (C) 2008 Cedric Bregardis <cedric.bregardis@free.fr> and

 * Jean-Christian Hassler <jhassler@free.fr>

 *

 * This file is part of the Audiowerk2 ALSA driver

 *

 chip-specific destructor */

 disable all irqs */

 reset saa7146 */

 Unset base addr */

	/* set PCI burst/threshold



	   Burst length definition

	   VALUE    BURST LENGTH

	   000      1 Dword

	   001      2 Dwords

	   010      4 Dwords

	   011      8 Dwords

	   100      16 Dwords

	   101      32 Dwords

	   110      64 Dwords

	   111      128 Dwords



	   Threshold definition

	   VALUE    WRITE MODE              READ MODE

	   00       1 Dword of valid data   1 empty Dword

	   01       4 Dwords of valid data  4 empty Dwords

	   10       8 Dwords of valid data  8 empty Dwords

 Set base addr */

 disable all irqs */

 reset saa7146 */

 enable audio interface */

 WS0_CTRL, WS0_SYNC: input TSL1, I2S */

 At initialization WS1 and WS2 are disabled (configured as input) */

	/* WS4 is not used. So it must not restart A2.

 WS3_CTRL, WS3_SYNC: output TSL2, I2S */

 A1 and A2 are active and asynchronous */

	/* The following comes from original windows driver.

	   It is needed to have a correct behavior of input and output

 enable audio port pins */

 enable I2C */

 enable interrupts */

 audio configuration */

 By default use analog input */

 TSL setup */

	/* Configure DMA for substream

	   Configuration informations: ALSA has allocated continuous memory

	   pages. So we don't need to use MMU of saa7146.

	/* No MMU -> nothing to do with PageA1, we only configure the limit of

 Disable MMU */

	/* Configure Limit for DMA access.

	   The limit register defines an address limit, which generates

	   an interrupt if passed by the actual PCI address pointer.

	   '0001' means an interrupt will be generated if the lower

	   6 bits (64 bytes) of the PCI address are zero. '0010'

	   defines a limit of 128 bytes, '0011' one of 256 bytes, and

	   so on up to 1 Mbyte defined by '1111'. This interrupt range

	   can be calculated as follows:

	   Range = 2^(5 + Limit) bytes.

 Base address for DMA transfert. */

 This address has been reserved by ALSA. */

 This is a physical address */

 Define upper limit for DMA access */

 Base address for DMA transfert. */

 This address has been reserved by ALSA. */

 This is a physical address */

 Define upper limit for DMA access */

	/* Configure DMA for substream

	   Configuration informations: ALSA has allocated continuous memory

	   pages. So we don't need to use MMU of saa7146.

	/* No MMU -> nothing to do with PageA1, we only configure the limit of

 Disable MMU */

	/* Configure Limit for DMA access.

	   The limit register defines an address limit, which generates

	   an interrupt if passed by the actual PCI address pointer.

	   '0001' means an interrupt will be generated if the lower

	   6 bits (64 bytes) of the PCI address are zero. '0010'

	   defines a limit of 128 bytes, '0011' one of 256 bytes, and

	   so on up to 1 Mbyte defined by '1111'. This interrupt range

	   can be calculated as follows:

	   Range = 2^(5 + Limit) bytes.

 Base address for DMA transfert. */

 This address has been reserved by ALSA. */

 This is a physical address */

 Define upper limit for DMA access  */

	/* In aw8 driver, dma transfert is always active. It is

 WS2_CTRL, WS2_SYNC: output TSL2, I2S */

 WS1_CTRL, WS1_SYNC: output TSL1, I2S */

 WS2_CTRL, WS2_SYNC: output TSL2, I2S */

 WS1_CTRL, WS1_SYNC: output TSL1, I2S */

	/* In aw8 driver, dma transfert is always active. It is

	/* FIXME: switch between analog and digital input does not always work.

	   It can produce a kind of white noise. It seams that received data

	   are inverted sometime (endian inversion). Why ? I don't know, maybe

	   a problem of synchronization... However for the time being I have

	   not found the problem. Workaround: switch again (and again) between

 SPDX-License-Identifier: GPL-2.0-only

/*****************************************************************************

 *

 * Copyright (C) 2008 Cedric Bregardis <cedric.bregardis@free.fr> and

 * Jean-Christian Hassler <jhassler@free.fr>

 *

 * This file is part of the Audiowerk2 ALSA driver

 *

/*********************************

 * DEFINES

/*********************************

 * TYPEDEFS

 hardware definition */

/*********************************

 * FUNCTION DECLARATIONS

/*********************************

 * VARIABLES

 pci_driver definition */

 operators for playback PCM alsa interface */

 operators for capture PCM alsa interface */

/*********************************

 * FUNCTION IMPLEMENTATIONS

 component-destructor */

 Free hardware */

 chip-specific constructor */

 initialize the PCI entry */

 check PCI availability (32bit DMA) */

 initialize the stuff */

 (1) PCI resource allocation */

 (2) initialization of the chip hardware */

 constructor */

 (1) Continue if device is not enabled, else inc dev */

 (2) Create card instance */

 (3) Create main component */

 initialize mutex */

 init spinlock */

 (4) Define driver ID and name string */

 (5) Create other components */

 (6) Register card instance */

 (7) Set PCI driver data */

 open callback */

 close callback */

 close callback */

 TODO: something to do ? */

 prepare callback for playback */

 Define Interrupt callback */

 prepare callback for capture */

 Define Interrupt callback */

 playback trigger callback */

 capture trigger callback */

 playback pointer callback */

 get the current hardware pointer */

 capture pointer callback */

 get the current hardware pointer */

 create a pcm device */

 Create new Alsa PCM device */

 Creation ok */

 Set PCM device name */

 Associate private data to PCM device */

 set operators of PCM device */

 store PCM device */

	/* give base chip pointer to our internal pcm device

 Give stream number to PCM device */

 pre-allocation of buffers */

 Preallocate continuous pages. */

 Creation ok */

 Set PCM device name */

 Associate private data to PCM device */

 set operators of PCM device */

 store PCM device */

	/* give base chip pointer to our internal pcm device

 Give stream number to PCM device */

 pre-allocation of buffers */

 Preallocate continuous pages. */

 Creation ok */

 Set PCM device name */

 Associate private data to PCM device */

 set operators of PCM device */

 store PCM device */

	/* give base chip pointer to our internal pcm device

 Give stream number to PCM device */

 pre-allocation of buffers */

 Preallocate continuous pages. */

 Create control */

 SPDX-License-Identifier: GPL-2.0-only

/*****************************************************************************

 *

 * Copyright (C) 2008 Cedric Bregardis <cedric.bregardis@free.fr> and

 * Jean-Christian Hassler <jhassler@free.fr>

 * Copyright 1998 Emagic Soft- und Hardware GmbH

 * Copyright 2002 Martijn Sipkema

 *

 * This file is part of the Audiowerk2 ALSA driver

 *

 Audiowerk8 hardware setup: */

      WS0, SD4, TSL1  - Analog/ digital in */

      WS1, SD0, TSL1  - Analog out #1, digital out */

      WS2, SD2, TSL1  - Analog out #2 */

      WS3, SD1, TSL2  - Analog out #3 */

      WS4, SD3, TSL2  - Analog out #4 */

 Audiowerk8 timing: */

      Timeslot:     | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | ... */

      A1_INPUT: */

      SD4:          <_ADC-L_>-------<_ADC-R_>-------< */

      WS0:          _______________/---------------\_ */

      A1_OUTPUT: */

      SD0:          <_1-L___>-------<_1-R___>-------< */

      WS1:          _______________/---------------\_ */

      SD2:          >-------<_2-L___>-------<_2-R___> */

      WS2:          -------\_______________/--------- */

      A2_OUTPUT: */

      SD1:          <_3-L___>-------<_3-R___>-------< */

      WS3:          _______________/---------------\_ */

      SD3:          >-------<_4-L___>-------<_4-R___> */

      WS4:          -------\_______________/--------- */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *   Driver for the Korg 1212 IO PCI card

 *

 *	Copyright (c) 2001 Haroldo Gamal <gamal@alternex.com.br>

 ----------------------------------------------------------------------------

 Debug Stuff

 ----------------------------------------------------------------------------

 ----------------------------------------------------------------------------

 Record/Play Buffer Allocation Method. If K1212_LARGEALLOC is defined all 

 buffers are alocated as a large piece inside KorgSharedBuffer.

 ----------------------------------------------------------------------------

#define K1212_LARGEALLOC		1

 ----------------------------------------------------------------------------

 Valid states of the Korg 1212 I/O card.

 ----------------------------------------------------------------------------

 there is no card here

 the card is awaiting DSP download

 the card is currently downloading its DSP code

 the card has finished the DSP download

 the card can be opened by an application.  Any application

    requests prior to this state should fail.  Only an open

    request can be made at this state.

 an application has opened the card

 the card has been setup for play

 the card is playing

 the card is in the monitor mode

 the card is currently calibrating

 the card has stopped itself because of an error and we

    are in the process of cleaning things up.

 state values of this and beyond are invalid

 ----------------------------------------------------------------------------

 The following enumeration defines the constants written to the card's

 host-to-card doorbell to initiate a command.

 ----------------------------------------------------------------------------

 sent by the card to request a buffer fill.

 starts playback/record on the card.

 select monitor, playback setup, or stop.

 tells card where the host audio buffers are.

 asks the card for the latest ADAT timecode value.

 sets the clock source and rate for the card.

 tells card where other buffers are.

 tells card to trigger from Adat at a specific

    timecode value.

 DMA Error - the PCI bus is congestioned.

 Card has stopped by user request.

 instructs the card to reboot.

 instructs the card to boot from the DSP microcode

    on page 4 (local page to card).

 sent by the card to indicate the download has

    completed.

 tells the card to download its DSP firmware.

 ----------------------------------------------------------------------------

 The following enumeration defines return codes 

 to the Korg 1212 I/O driver.

 ----------------------------------------------------------------------------

 command was successfully placed

 the DeviceIoControl call failed

 the protected mode call failed

 unspecified failure

 the specified command can not be given in

    the card's current state. (or the wave device's

    state)

 the card is uninitialized and cannot be used

 an out of range card index was specified

 an invalid card handle was specified

 a play request has been made before a fill routine set

 can't set a new fill routine while one is in use

 the card never acknowledged a command

 bad parameters were provided by the caller

 the specified wave device was out of range

 the specified wave format is unsupported

 ----------------------------------------------------------------------------

 The following enumeration defines the constants used to select the play

 mode for the card in the SelectPlayMode command.

 ----------------------------------------------------------------------------

 provides card with pre-play information

 tells card to turn on monitor mode

 tells card to turn off monitor mode

 stops playback on the card

 ----------------------------------------------------------------------------

 The following enumeration defines the constants used to select the monitor

 mode for the card in the SetMonitorMode command.

 ----------------------------------------------------------------------------

 tells card to turn off monitor mode

 tells card to turn on monitor mode

 location of mailbox 0 relative to base address

 location of mailbox 1 relative to base address

 location of mailbox 2 relative to base address

 location of mailbox 3 relative to base address

 location of PCI to local doorbell

 location of local to PCI doorbell

 location of interrupt control/status register

 location of the EEPROM, PCI, User I/O, init control

    register

 location of the input sensitivity setting register.

    this is the upper word of the PCI control reg.

 location of the device and vendor ID register

 maximum number of times the driver will attempt

    to send a command before giving up.

 the MSB is set in the command acknowledgment from

    the card.

 the doorbell value is one byte

 -----------------------------------------------------------------

 the following bits are used for controlling interrupts in the

 interrupt control/status reg

 -----------------------------------------------------------------

 -----------------------------------------------------------------

 the following bits are defined for the PCI command register

 -----------------------------------------------------------------

 -----------------------------------------------------------------

 the following bits are defined for the PCI status register

 -----------------------------------------------------------------

 ------------------------------------------------------------------------

 the following constants are used in setting the 1212 I/O card's input

 sensitivity.

 ------------------------------------------------------------------------

 --------------------------------------------------------------------------

 WaitRTCTicks



    This function waits the specified number of real time clock ticks.

    According to the DDK, each tick is ~0.8 microseconds.

    The defines following the function declaration can be used for the

    numTicksToWait parameter.

 --------------------------------------------------------------------------

 max # RTC ticks for the card to stop once we write

    the command register.  (could be up to 180 us)

 number of RTC ticks to wait for an acknowledgement

    from the card after sending a command.

 selects source as ADAT at 44.1 kHz

 selects source as ADAT at 48 kHz

 selects source as S/PDIF at 44.1 kHz

 selects source as S/PDIF at 48 kHz

 selects source as local clock at 44.1 kHz

 selects source as local clock at 48 kHz

 used to check validity of the index

 selects source as ADAT

 selects source as S/PDIF

 selects source as local clock

 channels 0-9 use 16 bit samples */

 channels 10-11 use 32 bits - only 20 are sent across S/PDIF */

 holds the ADAT timecode value */

 buffer definition */

 ADAT timecode value

 timer callback for checking ack of stop request */

 counter for stop pending check */

 address of the interrupt status/control register

 address of the host->card doorbell register

 address of the card->host doorbell register

 address of mailbox 0 on the card

 address of mailbox 1 on the card

 address of mailbox 2 on the card

 address of mailbox 3 on the card

 address of the EEPROM, PCI, I/O, Init ctrl reg

 address of the sensitivity setting register

 address of the device and vendor ID registers

 indicates whether the card is in idle monitor mode.

 tracks how many times we have retried sending to the card.

 sample rate and clock source

 clock source

 clock rate

 ADC left channel input sensitivity

 ADC right channel input sensitivity

 Open/Close count

 SetupForPlay count

 TriggerPlay count

 Error Count

 Total Error Count

 Index 0-MAX */

 ID for this card */

 Enable this card */

 selects source as ADAT at 44.1 kHz

 selects source as ADAT at 48 kHz

 selects source as S/PDIF at 44.1 kHz

 selects source as S/PDIF at 48 kHz

 selects source as local clock at 44.1 kHz

 selects source as local clock at 48 kHz

 interrupt the card

 --------------------------------------------------------------

 the reboot command will not give an acknowledgement.

 --------------------------------------------------------------

 --------------------------------------------------------------

 See if the card acknowledged the command.  Wait a bit, then

 read in the low word of mailbox3.  If the MSB is set and the

 low byte is equal to the doorbell value, then it ack'd.

 --------------------------------------------------------------

 spinlock already held */

 program the timer */

 timer callback for checking the ack of stop request */

 ack'ed */

 reprogram timer */

 spinlock already held */

 spinlock already held */

 spinlock already held */

 not used */

 not used */

 this keeps the current value to be written to

  the card's eeprom control register.

 ----------------------------------------------------------------------------

 initialize things.  The local init bit is always set when writing to the

 card's control register.

 ----------------------------------------------------------------------------

 init the control value

 ----------------------------------------------------------------------------

 make sure the card is not in monitor mode when we do this update.

 ----------------------------------------------------------------------------

 ----------------------------------------------------------------------------

 we are about to send new values to the card, so clear the new values queued

 flag.  Also, clear out mailbox 3, so we don't lockup.

 ----------------------------------------------------------------------------

 ----------------------------------------------------------------------------

 determine whether we are running a 48K or 44.1K clock.  This info is used

 later when setting the SPDIF FF after the volume has been shifted in.

 ----------------------------------------------------------------------------

 ----------------------------------------------------------------------------

 start the update.  Setup the bit structure and then shift the bits.

 ----------------------------------------------------------------------------

 ----------------------------------------------------------------------------

 now start shifting the bits in.  Start with the left channel then the right.

 ----------------------------------------------------------------------------

 ----------------------------------------------------------------------------

 Bring the load/shift line low, then wait - the spec says >150ns from load/

 shift low to the first rising edge of the clock.

 ----------------------------------------------------------------------------

 load/shift goes low

 for all the bits

 data bit set high

 data bit set low

 data bit set high

 data bit set low

 clock goes low

 clock goes high

 ----------------------------------------------------------------------------

 finish up SPDIF for left.  Bring the load/shift line high, then write a one

 bit if the clock rate is 48K otherwise write 0.

 ----------------------------------------------------------------------------

 load shift goes high - clk low

 set/clear data bit

 clock goes high

 clock goes low

 ----------------------------------------------------------------------------

 The update is complete.  Set a timeout.  This is the inter-update delay.

 Also, if the card was in monitor mode, restore it.

 ----------------------------------------------------------------------------

 ----------------------------------------------------

 tell the card to boot

 ----------------------------------------------------

 --------------------------------------------------------------------------------

 Let the card know where all the buffers are.

 --------------------------------------------------------------------------------

 size given to the card

 is based on 2 buffers

 --------------------------------------------------------------------------------

 Initialize the routing and volume tables, then update the card's state.

 --------------------------------------------------------------------------------

korg1212->sharedBufferPtr->routeData[channel] = channel;

 ------------------------------------------------------------------------

 an error occurred - stop the card

 ------------------------------------------------------------------------

 ------------------------------------------------------------------------

 the card has stopped by our request.  Clear the command word and signal

 the semaphore in case someone is waiting for this.

 ------------------------------------------------------------------------

 ---------------------------------------------------------------

 verify the state of the card before proceeding.

 ---------------------------------------------------------------

 timeout */

		/* The other stream is open, and not by the same

		   task as this one. Make sure that the parameters

		   that matter are the same.

 FIXME: we should wait for ack! */

		/*

		korg1212->sharedBufferPtr->cardCommand = 0;

		del_timer(&korg1212->timer);

		korg1212->stop_pending_cnt = 0;

/*

			if (korg1212->running) {

				K1212_DEBUG_PRINTK_VERBOSE("K1212_DEBUG: snd_korg1212_trigger: Already running?\n");

				break;

			}

/*

			if (!korg1212->running) {

				K1212_DEBUG_PRINTK_VERBOSE("K1212_DEBUG: snd_korg1212_trigger: Already stopped?\n");

				break;

			}

 not used (interleaved data) */

/*

 * Control Interface

/*

 * proc interface

 K1212_LARGEALLOC

 K1212_LARGEALLOC

/*

 * Card initialisation

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Driver for Digigram pcxhr compatible soundcards

 *

 * hwdep device manager

 *

 * Copyright (c) 2004 by Digigram <alsa@digigram.com>

/*

 * get basic information and init pcxhr card

 calc the number of all streams used */

 enable interrupts */

 test 4, 8 or 12 phys out */

 test 4, 8 or 2 phys in */

 test max nb substream per board */

 test max nb substream per pipe */

 firmware num for DSP */

 transfer granularity in samples (should be multiple of 48) */

 get options */

 analog addon board found */

 unmute inputs */

 unmute outputs (a write to IO_NUM_REG_MUTE_OUT mutes!) */

 unmute digital plugs */

 mute outputs */

 a read to IO_NUM_REG_MUTE_OUT register unmutes! */

 mute inputs */

 stereo cards mute with reset of dsp */

 reset pcxhr dsp */

 reset second xilinx */

/*

 *  allocate a playback/capture pipe (pcmp0/pcmc0)

 always stereo */

 define pipe (P_PCM_ONLY_MASK (0x020000) is not necessary) */

 add P_PCM_ONLY_MASK */

 add channel mask to command */

/*

 *  free playback/capture pipe (pcmp0/pcmc0)

 stop one pipe */

 release the pipe */

 allocate the pipes on the dsp */

 start all the pipes on the dsp */

 continue with first init */

 end of switch file index*/

 first communication with embedded */

 create devices and mixer in accordance with HW options*/

/*

 * fw loader entry

 fake hwdep dsp record */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Driver for Digigram pcxhr compatible soundcards

 *

 * low level interface with interrupt and message handling implementation

 *

 * Copyright (c) 2004 by Digigram <alsa@digigram.com>

 registers used on the PLX (port 1) */

 registers used on the DSP (port 2) */

 access to the card */

 attention : access the PCXHR_DSP_* registers with inb and outb only ! */

 params used with PCXHR_PLX_MBOX0 */

 params used with PCXHR_PLX_IRQCS */

 params used with PCXHR_PLX_CHIPSC */

 params used with PCXHR_DSP_ICR */

 params used with PCXHR_DSP_CVR */

 params used with PCXHR_DSP_ISR */

 constants used for delay in msec */

/*

 * pcxhr_check_reg_bit - wait for the specified bit is set/reset on a register

 * @reg: register to check

 * @mask: bit mask

 * @bit: resultant bit to be checked

 * @time: time-out of loop in msec

 *

 * returns zero if a bit matches, or a negative error code.

 constants used with pcxhr_check_reg_bit() */

 clear hf5 bit */

 wait for CVR_HI08_HC == 0 */

 wait for hf5 bit */

 retry not handled here */

 reset second xilinx */

 enable/disable interrupts */

 disable interrupts */

 let's reset the DSP */

 wait 2 msec */

 wait 2 msec */

 reset mailbox */

 enable interrupts */

/*

 * load the xilinx image

 test first xilinx */

 REV01 cards do not support the PCXHR_CHIPSC_GPI_USERI bit anymore */

	/* this bit will always be 1;

	 * no possibility to test presence of first xilinx

 activate second xilinx */

 wait 2 msec */

 don't take too much time in this loop... */

 wait 2 msec (time to boot the xilinx before any access) */

/*

 * send an executable file to the DSP

 check the length of boot image */

 transfert data buffer from PC to DSP */

 test data header consistency */

 wait DSP ready for new transfer */

 send host data */

 don't take too much time in this loop... */

 give some time to boot the DSP */

/*

 * load the eeprom image

 init value of the ICR register */

		/* no need to load the eeprom binary,

		 * but init the HI08 interface

 wait for chk bit */

/*

 * load the boot image

 send the hostport address to the DSP (only the upper 24 bit !) */

 clear hf5 bit */

 wait for hf5 bit */

/*

 * load the final dsp image

 wait for chk bit */

 command word */

 status length */

 status type (RMH_SSIZE_XXX) */

 RMH status type */

 status size fix (st_length = 0..x) */

 status size given in the LSB byte */

 status size given in bitmask */

/*

 * Array of DSP commands

 wait for receiver full */

 read data */

 need to update rmh->stat_len on the fly ?? */

 rmh->dsp_stat == RMH_SSIZE_MASK */

 wait for chk bit */

 reset irq chk */

 wait for chk bit == 0*/

 MASK_MORE_THAN_1_WORD_COMMAND */

 MASK_1_WORD_COMMAND */

 send length */

 send other words */

 wait for chk bit */

 test status ISR */

 ERROR, wait for receiver full */

 read error code */

 read the response data */

 reset semaphore */

/**

 * pcxhr_init_rmh - initialize the RMH instance

 * @rmh: the rmh pointer to be initialized

 * @cmd: the rmh command to be set

 COMMAND_RECORD_MASK */

/*

 * pcxhr_send_msg - send a DSP message with spinlock

 * @rmh: the rmh record to send and receive

 *

 * returns 0 if successful, or a negative error code.

	/* least segnificant 12 bits are the pipe states

	 * for the playback audios

	 * next 12 bits are the pipe states for the capture audios

	 * (PCXHR_PIPE_STATE_CAPTURE_OFFSET)

 can start playback pipe */

 can start capture pipe */

			/* if the pipe couldn't be prepaired for start,

			 * retry it later

 stop playback pipe */

 stop capture pipe */

 now fire the interrupt on the card */

 current pipe state (playback + record) */

 start only pipes that are not yet started */

 success, all pipes prepaired */

 wait 1 millisecond and retry */

 stop only pipes that are started */

 have all pipes the new state ? */

 wait 10 microseconds */

 already programmed */

 clear events FREQ_CHANGE and TIME_CODE */

 add SEL_ASYNC_EVENTS */

 this is the only one extra long response command */

 if BIT_END */

 get sample count for one stream */

 rmh.stat_len = 2; */	
 add default if no hardware_read possible */

					/* sub security offset because of

					 * jitter and finer granularity of

					 * dsp time (MBOX4)

			/* if we didn't try to sync the position, increment it

			 * by PCXHR_GRANULARITY every timer interrupt

 this device did not cause the interrupt */

 clear interrupt */

 timer irq occurred */

 other irq's handled in the thread */

			/* as we didn't request any async notifications,

			 * some kind of xrun error will probably occurred

 better resynchronize all streams next interrupt : */

 is a 24 bit counter */

 handle dsp counter wraparound without resync */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Driver for Digigram pcxhr compatible soundcards

 *

 * main file with alsa callbacks

 *

 * Copyright (c) 2004 by Digigram <alsa@digigram.com>

 Index 0-MAX */

 ID for this card */

 Enable this card */

 capture  mono only */

 boards without hw AES1 and SRC onboard are all using fw_file_set==4 */

 VX222HR, VX222e, PCX22HR and PCX22e */

 some boards do not support 192kHz on digital AES input plugs */

 clock by quartz or pll */

 get the value for the pll register */

 codec speed modes */

 single speed */

 dual speed */

 quad speed */

 mute outputs */

 set speed ratio */

 set the new frequency */

 unmute after codec speed modes */

 unmute outputs */

 save new codec speed */

 nothing to do */

 resync fifos  */

 wait minimum 2 sample_frames at 32kHz ! */

/*

 *  start or stop playback/capture substream

 reset theoretical stream pos */

 bug with old dsp versions: */

 bit 12 also sets the format of the playback stream */

 add channels and set bit 19 if channels>2 */

 playback : add channel mask to command */

 max buffer size is 2 MByte */

 size in bits */

 most significant byte */

 this is a circular buffer */

 least 3 significant bytes */

 check the pipes concerned and build pipe_array */

				break;	/* add only once, as all playback

					 * streams of one chip use the same pipe

 synchronous stop of all the pipes concerned */

 the dsp lost format and buffer info with the stop pipe */

 start all the streams */

 synchronous start of all the pipes concerned */

	/* put the streams into the running state now

	 * (increment pointer by interrupt)

 playback will already have advanced ! */

/*

 *  trigger callback

 TODO */

 last dsp time invalid */

/*

 *  prepare callback for all pcms

 only the first stream can choose the sample rate */

 set the clock only once (first stream) */

 start the DSP-timer */

 do only once (so we can use break instead of goto) */

/*

 *  HW_PARAMS callback for all pcms

 set up channels */

 set up format for the stream */

/*

 *  CONFIGURATION SPACE for all pcms, mono pcm must update channels_max

 1 byte == 1 frame U8 mono (PCXHR_GRANULARITY is frames!) */

 copy the struct snd_pcm_hardware struct */

 streams in use */

 float format support is in some cases buggy on stereo cards */

 buffer-size should better be multiple of period-size */

	/* if a sample rate is already used or fixed by external clock,

	 * the stream cannot change

 cannot detect the external clock rate */

 not configured yet */

 better get a divisor of granularity values (96 or 192) */

 sample rate released */

 the sample rate is no more locked */

 stop the DSP-timer */

 get the period fragment and the nb of periods in the buffer */

/*

/*

 stereo or mono streams */

 2 mono streams */

 or 1 stereo stream */

 proc interface */

 stats available when embedded DSP is running */

 calc cpu load of the dsp */

 debug zone dsp */

 commands available when embedded DSP is running */

 commands available when embedded DSP is running */

 gpio ports on stereo boards only available */

 GPI */

 GP0 */

 commands available when embedded DSP is running */

 GP0 */

 Access to the results of the CMD_GET_TIME_CODE RMH */

 Values for the CMD_MANAGE_SIGNAL RMH */

 linear time code read proc*/

 commands available when embedded DSP is running */

	/*snd_iprintf(buffer, "dsp ref time: 0x%06x%06x\n",

 gpio available on stereo sound cards only */

 end of proc interface */

/*

 * release all the cards assigned to a manager instance

 reset board if some firmware was loaded */

 release irq  */

 free hostport purgebuffer */

/*

 *    probe function - creates the card manager

 enable PCI device */

 check if we can restrict PCI DMA transfers to 32 bits */

 alloc card manager */

 resource assignment */

 ISR lock  */

 init setup mutex*/

 init proc interface only for chip0 */

 create hostport purgebuffer */

 init purgebuffer */

 create a DSP loader */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Driver for Digigram pcxhr compatible soundcards

 *

 * mixer callbacks

 *

 * Copyright (c) 2004 by Digigram <alsa@digigram.com>

 -112.0 dB */

 +15.5 dB */

 0.0 dB ( 0 dBu -> 0 dBFS ) */

 -104.0 dB */

 +24.0 dB */

 0.0 dB ( 0 dBFS -> 0 dBu ) */

 playback analog levels are inversed */

 audio mask */

/*

 * analog level control

 playback */

 -25 dB */

 +24 dB */

-104 dB */

 +24 dB */

 capture */

-112 dB */

 +15.5 dB */

-112 dB */

 +15.5 dB */

 playback */

 capture */

 name will be filled later */

 tlv will be filled later */

 shared */

 update playback levels */

 shared */

 -110 dB */

 +18 dB */

  0 dB */

 add pipe and stream mask */

 volume left->left / right->right panoramic level */

 add channel mask */

	/* TODO : if mask (3 << pipe->first_audio) is used, left and right

		/* VALID_AUDIO_IO_MUTE_LEVEL not yet handled

		/* VALID_AUDIO_IO_DIGITAL_LEVEL and VALID_AUDIO_IO_MUTE_LEVEL

		 * not yet handled (playback pipe level)

 shared */

 -109.5 dB */

   18.0 dB */

 index */

 digital capture */

 digital playback */

 index */

 digital capture */

 digital playback */

 update capture volume */

 update playback volume */

 name will be filled later */

 count will be filled later */

 shared */

 index */

 index */

 shared */

/*

 * monitoring level control

 update monitoring volume and mute */

 do only when monitoring is unmuted */

 shared */

/*

 * monitoring switch control

 mask 0x01 and 0x02 */

 update left monitoring volume and mute */

 update right monitoring volume and mute */

 shared */

/*

 * audio source select

 audio source from digital plug */

 audio source from analog plug */

 set the input source */

 resync them (otherwise channel inversion possible) */

 update all src configs with one call */

 set codec SRC on off */

 set codec SRC on off */

 no SRC, no Mic available */

 SRC available */

 Mic and MicroMix available */

 no SRC, no Mic available */

 SRC available */

 Mic and MicroMix available */

/*

 * clock type selection

 * enum pcxhr_clock_type {

 *	PCXHR_CLOCK_TYPE_INTERNAL = 0,

 *	PCXHR_CLOCK_TYPE_WORD_CLOCK,

 *	PCXHR_CLOCK_TYPE_AES_SYNC,

 *	PCXHR_CLOCK_TYPE_AES_1,

 *	PCXHR_CLOCK_TYPE_AES_2,

 *	PCXHR_CLOCK_TYPE_AES_3,

 *	PCXHR_CLOCK_TYPE_AES_4,

 *	PCXHR_CLOCK_TYPE_MAX = PCXHR_CLOCK_TYPE_AES_4,

 *	HR22_CLOCK_TYPE_INTERNAL = PCXHR_CLOCK_TYPE_INTERNAL,

 *	HR22_CLOCK_TYPE_AES_SYNC,

 *	HR22_CLOCK_TYPE_AES_1,

 *	HR22_CLOCK_TYPE_MAX = HR22_CLOCK_TYPE_AES_1,

 * };

 at least Internal and AES Sync clock */

 add AES x */

 add word clock */

 at least Internal and AES Sync clock */

 add AES x */

 add word clock */

 return 1 even if the set was not done. ok ? */

/*

 * clock rate control

 * specific control that scans the sample rates on the external plugs

 clock not present */

 max sample rate 192 kHz */

/*

 * IEC958 status bits

 instead of CS8420_01_CS use CS8416_01_CS for AES SYNC plug */

 instead of CS8420_CSB0 use CS8416_CSBx for AES SYNC plug */

 size and code the chip id for the fpga */

 chip signature + map for spi read */

 reversed bit order (not with CS8416_01_CS) */

 playback */

 capture */

 chip index 0..3 */

 new bit used if chip_idx>3 (PCX1222HR) */

 add bit offset */

 add bit value */

 playback */

 playback */

 capture */

 at boot time the digital volumes are unmuted 0dB */

			/* after boot, only two bits are set on the uer

			 * interface

			/* analog volumes for playback

			 * (is LEVEL_MIN after boot)

 stereo cards need to be initialised after boot */

 at boot time the digital volumes are unmuted 0dB */

			/* analog volumes for playback

			 * (is LEVEL_MIN after boot)

 stereo cards need to be initialised after boot */

 can be in another place */

 analog output level control */

 playback */

 output mute controls */

 playback */

 IEC958 controls */

 analog input level control */

 capture */

 capture */

 Audio source */

 IEC958 controls */

 monitoring only if playback and capture device available */

 monitoring */

 clock mode only one control per pcxhr */

			/* non standard control used to scan

			 * the external clock presence/frequencies

 init values for the mixer data */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Driver for Digigram pcxhr compatible soundcards

 *

 * mixer interface for stereo cards

 *

 * Copyright (c) 2004 by Digigram <alsa@digigram.com>

 registers used on the DSP and Xilinx (port 2) : HR stereo cards only */

 byte access only ! */

 values for PCHR_DSP_RESET register */

 values for PCHR_XLX_CFG register */

 0 (UER0), 1(UER1) */

 0 (ana), 1 (UER) */

 0 (Bypass), 1 (SRC Actif) */

 0 (UER0), 1(UER1) */

 0 (internal), 1 (AES/EBU) */

 values for PCHR_XLX_DATA register */

 values for PCHR_XLX_STATUS register - READ */

 values for PCHR_XLX_STATUS register - WRITE */

 values for PCHR_XLX_CSUER register */

 values for PCXHR_XLX_SELMIC register - WRITE */

 [000] -49.5 dB:	AKM[000] = -1.#INF dB	(mute) */

 [001] -49.0 dB:	AKM[001] = -48.131 dB	(diff=0.86920 dB) */

 [002] -48.5 dB:	AKM[001] = -48.131 dB	(diff=0.36920 dB) */

 [003] -48.0 dB:	AKM[001] = -48.131 dB	(diff=0.13080 dB) */

 [004] -47.5 dB:	AKM[001] = -48.131 dB	(diff=0.63080 dB) */

 [005] -46.5 dB:	AKM[001] = -48.131 dB	(diff=1.63080 dB) */

 [006] -47.0 dB:	AKM[001] = -48.131 dB	(diff=1.13080 dB) */

 [007] -46.0 dB:	AKM[001] = -48.131 dB	(diff=2.13080 dB) */

 [008] -45.5 dB:	AKM[001] = -48.131 dB	(diff=2.63080 dB) */

 [009] -45.0 dB:	AKM[002] = -42.110 dB	(diff=2.88980 dB) */

 [010] -44.5 dB:	AKM[002] = -42.110 dB	(diff=2.38980 dB) */

 [011] -44.0 dB:	AKM[002] = -42.110 dB	(diff=1.88980 dB) */

 [012] -43.5 dB:	AKM[002] = -42.110 dB	(diff=1.38980 dB) */

 [013] -43.0 dB:	AKM[002] = -42.110 dB	(diff=0.88980 dB) */

 [014] -42.5 dB:	AKM[002] = -42.110 dB	(diff=0.38980 dB) */

 [015] -42.0 dB:	AKM[002] = -42.110 dB	(diff=0.11020 dB) */

 [016] -41.5 dB:	AKM[002] = -42.110 dB	(diff=0.61020 dB) */

 [017] -41.0 dB:	AKM[002] = -42.110 dB	(diff=1.11020 dB) */

 [018] -40.5 dB:	AKM[002] = -42.110 dB	(diff=1.61020 dB) */

 [019] -40.0 dB:	AKM[003] = -38.588 dB	(diff=1.41162 dB) */

 [020] -39.5 dB:	AKM[003] = -38.588 dB	(diff=0.91162 dB) */

 [021] -39.0 dB:	AKM[003] = -38.588 dB	(diff=0.41162 dB) */

 [022] -38.5 dB:	AKM[003] = -38.588 dB	(diff=0.08838 dB) */

 [023] -38.0 dB:	AKM[003] = -38.588 dB	(diff=0.58838 dB) */

 [024] -37.5 dB:	AKM[003] = -38.588 dB	(diff=1.08838 dB) */

 [025] -37.0 dB:	AKM[004] = -36.090 dB	(diff=0.91040 dB) */

 [026] -36.5 dB:	AKM[004] = -36.090 dB	(diff=0.41040 dB) */

 [027] -36.0 dB:	AKM[004] = -36.090 dB	(diff=0.08960 dB) */

 [028] -35.5 dB:	AKM[004] = -36.090 dB	(diff=0.58960 dB) */

 [029] -35.0 dB:	AKM[005] = -34.151 dB	(diff=0.84860 dB) */

 [030] -34.5 dB:	AKM[005] = -34.151 dB	(diff=0.34860 dB) */

 [031] -34.0 dB:	AKM[005] = -34.151 dB	(diff=0.15140 dB) */

 [032] -33.5 dB:	AKM[005] = -34.151 dB	(diff=0.65140 dB) */

 [033] -33.0 dB:	AKM[006] = -32.568 dB	(diff=0.43222 dB) */

 [034] -32.5 dB:	AKM[006] = -32.568 dB	(diff=0.06778 dB) */

 [035] -32.0 dB:	AKM[006] = -32.568 dB	(diff=0.56778 dB) */

 [036] -31.5 dB:	AKM[007] = -31.229 dB	(diff=0.27116 dB) */

 [037] -31.0 dB:	AKM[007] = -31.229 dB	(diff=0.22884 dB) */

 [038] -30.5 dB:	AKM[008] = -30.069 dB	(diff=0.43100 dB) */

 [039] -30.0 dB:	AKM[008] = -30.069 dB	(diff=0.06900 dB) */

 [040] -29.5 dB:	AKM[009] = -29.046 dB	(diff=0.45405 dB) */

 [041] -29.0 dB:	AKM[009] = -29.046 dB	(diff=0.04595 dB) */

 [042] -28.5 dB:	AKM[010] = -28.131 dB	(diff=0.36920 dB) */

 [043] -28.0 dB:	AKM[010] = -28.131 dB	(diff=0.13080 dB) */

 [044] -27.5 dB:	AKM[011] = -27.303 dB	(diff=0.19705 dB) */

 [045] -27.0 dB:	AKM[011] = -27.303 dB	(diff=0.30295 dB) */

 [046] -26.5 dB:	AKM[012] = -26.547 dB	(diff=0.04718 dB) */

 [047] -26.0 dB:	AKM[013] = -25.852 dB	(diff=0.14806 dB) */

 [048] -25.5 dB:	AKM[014] = -25.208 dB	(diff=0.29176 dB) */

 [049] -25.0 dB:	AKM[014] = -25.208 dB	(diff=0.20824 dB) */

 [050] -24.5 dB:	AKM[015] = -24.609 dB	(diff=0.10898 dB) */

 [051] -24.0 dB:	AKM[016] = -24.048 dB	(diff=0.04840 dB) */

 [052] -23.5 dB:	AKM[017] = -23.522 dB	(diff=0.02183 dB) */

 [053] -23.0 dB:	AKM[018] = -23.025 dB	(diff=0.02535 dB) */

 [054] -22.5 dB:	AKM[019] = -22.556 dB	(diff=0.05573 dB) */

 [055] -22.0 dB:	AKM[020] = -22.110 dB	(diff=0.11020 dB) */

 [056] -21.5 dB:	AKM[021] = -21.686 dB	(diff=0.18642 dB) */

 [057] -21.0 dB:	AKM[023] = -20.896 dB	(diff=0.10375 dB) */

 [058] -20.5 dB:	AKM[024] = -20.527 dB	(diff=0.02658 dB) */

 [059] -20.0 dB:	AKM[026] = -19.831 dB	(diff=0.16866 dB) */

 [060] -19.5 dB:	AKM[027] = -19.504 dB	(diff=0.00353 dB) */

 [061] -19.0 dB:	AKM[029] = -18.883 dB	(diff=0.11716 dB) */

 [062] -18.5 dB:	AKM[030] = -18.588 dB	(diff=0.08838 dB) */

 [063] -18.0 dB:	AKM[032] = -18.028 dB	(diff=0.02780 dB) */

 [064] -17.5 dB:	AKM[034] = -17.501 dB	(diff=0.00123 dB) */

 [065] -17.0 dB:	AKM[036] = -17.005 dB	(diff=0.00475 dB) */

 [066] -16.5 dB:	AKM[038] = -16.535 dB	(diff=0.03513 dB) */

 [067] -16.0 dB:	AKM[040] = -16.090 dB	(diff=0.08960 dB) */

 [068] -15.5 dB:	AKM[043] = -15.461 dB	(diff=0.03857 dB) */

 [069] -15.0 dB:	AKM[045] = -15.067 dB	(diff=0.06655 dB) */

 [070] -14.5 dB:	AKM[048] = -14.506 dB	(diff=0.00598 dB) */

 [071] -14.0 dB:	AKM[051] = -13.979 dB	(diff=0.02060 dB) */

 [072] -13.5 dB:	AKM[054] = -13.483 dB	(diff=0.01707 dB) */

 [073] -13.0 dB:	AKM[057] = -13.013 dB	(diff=0.01331 dB) */

 [074] -12.5 dB:	AKM[060] = -12.568 dB	(diff=0.06778 dB) */

 [075] -12.0 dB:	AKM[064] = -12.007 dB	(diff=0.00720 dB) */

 [076] -11.5 dB:	AKM[068] = -11.481 dB	(diff=0.01937 dB) */

 [077] -11.0 dB:	AKM[072] = -10.984 dB	(diff=0.01585 dB) */

 [078] -10.5 dB:	AKM[076] = -10.515 dB	(diff=0.01453 dB) */

 [079] -10.0 dB:	AKM[081] = -9.961 dB	(diff=0.03890 dB) */

 [080] -9.5 dB:	AKM[085] = -9.542 dB	(diff=0.04243 dB) */

 [081] -9.0 dB:	AKM[090] = -9.046 dB	(diff=0.04595 dB) */

 [082] -8.5 dB:	AKM[096] = -8.485 dB	(diff=0.01462 dB) */

 [083] -8.0 dB:	AKM[102] = -7.959 dB	(diff=0.04120 dB) */

 [084] -7.5 dB:	AKM[108] = -7.462 dB	(diff=0.03767 dB) */

 [085] -7.0 dB:	AKM[114] = -6.993 dB	(diff=0.00729 dB) */

 [086] -6.5 dB:	AKM[121] = -6.475 dB	(diff=0.02490 dB) */

 [087] -6.0 dB:	AKM[128] = -5.987 dB	(diff=0.01340 dB) */

 [088] -5.5 dB:	AKM[135] = -5.524 dB	(diff=0.02413 dB) */

 [089] -5.0 dB:	AKM[143] = -5.024 dB	(diff=0.02408 dB) */

 [090] -4.5 dB:	AKM[152] = -4.494 dB	(diff=0.00607 dB) */

 [091] -4.0 dB:	AKM[161] = -3.994 dB	(diff=0.00571 dB) */

 [092] -3.5 dB:	AKM[170] = -3.522 dB	(diff=0.02183 dB) */

 [093] -3.0 dB:	AKM[181] = -2.977 dB	(diff=0.02277 dB) */

 [094] -2.5 dB:	AKM[191] = -2.510 dB	(diff=0.01014 dB) */

 [095] -2.0 dB:	AKM[203] = -1.981 dB	(diff=0.01912 dB) */

 [096] -1.5 dB:	AKM[215] = -1.482 dB	(diff=0.01797 dB) */

 [097] -1.0 dB:	AKM[227] = -1.010 dB	(diff=0.01029 dB) */

 [098] -0.5 dB:	AKM[241] = -0.490 dB	(diff=0.00954 dB) */

 [099] +0.0 dB:	AKM[255] = +0.000 dB	(diff=0.00000 dB) */

 activate access to codec registers */

 termiate access to codec registers */

 conversion from PmBoardCodedLevel to AKM nonlinear programming */

 program all input levels at the same time */

 no PCX22 */

 micro is mono, but apply */

 level on both channels */

 line input right channel */

 line input left channel */

 activate input codec */

 send 32 bits (4 x 8 bits) */

 close input level codec */

 analog always available */

 microphone available */

 reset codec */

 hr222_write_gpo(mgr, 0); does the same */

 config AKM */

 init micro boost */

 calc PLL register */

 TODO : there is a very similar fct in pcxhr.c */

 set clock source */

 codec speed modes */

 other clocks not supported */

 no external clock locked */

 calculate freq */

 save the measured clock frequency */

 wait min 2 cycles of lowest freq (8000) */

 save */

 get the frequency */

 rounding */

 we have to update all levels */

texts[5] = {"Line", "Digital", "Digi+SRC", "Mic", "Line+Mic"}*/

 default analog source */

 get data from the AES1 plug */

 chip->mic_active = 0; */

 chip->analog_capture_active = 0; */

 capture: update all 3 mutes/unmutes with one call */

 set the source infos (max 3 bits modified) */

 idx < 192 */

 idx < 192 */

 write C and U bit */

 only values form 0 to 3 accepted */

 mic level */

 -98 dB */

 gains from 9 dB to 31.5 dB not recommended; use micboost instead */

  +7 dB */

 mic boost level */

  0 dB */

 54 dB */

****************** Phantom power switch *******************/

 controls */

/***************************************************************************



   Copyright Echo Digital Audio Corporation (c) 1998 - 2004

   All rights reserved

   www.echoaudio.com



   This file is part of Echo Digital Audio's generic driver library.



   Echo Digital Audio's generic driver library is free software;

   you can redistribute it and/or modify it under the terms of

   the GNU General Public License as published by the Free Software

   Foundation.



   This program is distributed in the hope that it will be useful,

   but WITHOUT ANY WARRANTY; without even the implied warranty of

   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

   GNU General Public License for more details.



   You should have received a copy of the GNU General Public License

   along with this program; if not, write to the Free Software

   Foundation, Inc., 59 Temple Place - Suite 330, Boston,

   MA  02111-1307, USA.



   *************************************************************************



 Translation from C++ and adaptation for use in ALSA-Driver

 were made by Giuliano Pochini <pochini@shiny.it>



	/* Since this card has no ASIC, mark it as loaded so everything

	/* Map the DSP clock detect bits to the generic driver clock

 The Darla24 has no ASIC. Just do nothing */

 Override the sample rate if this card is set to Echo sync. */

 ignored by the DSP ? */

/************************************************************************



This file is part of Echo Digital Audio's generic driver library.

Copyright Echo Digital Audio Corporation (c) 1998 - 2005

All rights reserved

www.echoaudio.com



This library is free software; you can redistribute it and/or

modify it under the terms of the GNU Lesser General Public

License as published by the Free Software Foundation; either

version 2.1 of the License, or (at your option) any later version.



This library is distributed in the hope that it will be useful,

but WITHOUT ANY WARRANTY; without even the implied warranty of

MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU

Lesser General Public License for more details.



You should have received a copy of the GNU Lesser General Public

License along with this library; if not, write to the Free Software

Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA



*************************************************************************



 Translation from C++ and adaptation for use in ALSA-Driver

 were made by Giuliano Pochini <pochini@shiny.it>



	/* Since this card has no ASIC, mark it as loaded so everything

/************************************************************************



This file is part of Echo Digital Audio's generic driver library.

Copyright Echo Digital Audio Corporation (c) 1998 - 2005

All rights reserved

www.echoaudio.com



This library is free software; you can redistribute it and/or

modify it under the terms of the GNU Lesser General Public

License as published by the Free Software Foundation; either

version 2.1 of the License, or (at your option) any later version.



This library is distributed in the hope that it will be useful,

but WITHOUT ANY WARRANTY; without even the implied warranty of

MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU

Lesser General Public License for more details.



You should have received a copy of the GNU Lesser General Public

License along with this library; if not, write to the Free Software

Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA



*************************************************************************



 Translation from C++ and adaptation for use in ALSA-Driver

 were made by Giuliano Pochini <pochini@shiny.it>



	/* Since this card has no ASIC, mark it as loaded so everything

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  ALSA driver for Echoaudio soundcards.

 *  Copyright (C) 2003-2004 Giuliano Pochini <pochini@shiny.it>

 Pipe indexes */

 8 */

 0 */

 2 */

 0 */

 Bus indexes */

 2 */

 0 */

 2 */

 0 */

 Indigo IO*/

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  ALSA driver for Echoaudio soundcards.

 *  Copyright (C) 2003-2004 Giuliano Pochini <pochini@shiny.it>

 *  Copyright (C) 2020 Mark Hills <mark@xwax.org>

/******************************************************************************

	PCM interface

 >=2 channels cannot be S32_BE */

 > 2 channels cannot be U8 and S32_BE */

 Mono is ok with any format */

 S32_BE is mono (and stereo) only */

 U8 can be only mono or stereo */

 S16_LE, S24_3LE and S32_LE support any number of channels. */

 >2 channels must be S16_LE, S24_3LE or S32_LE */

 1 channel must be S32_BE or S32_LE */

 2 channels cannot be S32_BE */

 S32_BE is mono (and stereo) only */

 U8 is stereo only */

 S16_LE and S24_3LE must be at least stereo */

/* Since the sample rate is a global setting, do allow the user to change the

 Not configured yet */

 Set up hw capabilities and contraints */

 Only mono and any even number of channels are allowed */

 All periods should have the same size */

	/* The hw accesses memory in chunks 32 frames long and they should be

	32-bytes-aligned. It's not a requirement, but it seems that IRQs are

 Allocate a page for the scatter-gather list */

	/*

	 * Sole ownership required to set the rate

	else	/* If the card has ADAT, subtract the 6 channels

		 * that S/PDIF doesn't have

 See the note in snd_echo_new_pcm() */

	else	/* If the card has ADAT, subtract the 6 channels

		 * that S/PDIF doesn't have

 !ECHOCARD_HAS_VMIXER */

 ECHOCARD_HAS_DIGITAL_IO */

	/* Nothing to do here. Audio is already off and pipe will be

	 * freed by its callback

 Channel allocation and scatter-gather list setup */

	/* Sets up che hardware. If it's already initialized, reset and

	 * redo with the new parameters

 Close the ring buffer */

	/* This stuff is used by the irq handler, so it must be

	 * initialized before chip->substream

 See the note in snd_echo_new_pcm() */

 !ECHOCARD_HAS_VMIXER */

 ECHOCARD_HAS_DIGITAL_IO */

	/*

	 * We passed checks we can do independently; now take

	 * exclusive control

	/*

	 * IRQ handling runs concurrently. Do not share tracking of

	 * counter with it, which would race or require locking

 presumed atomic */

 handles wrapping */

	/* counter doesn't neccessarily wrap on a multiple of

	 * buffer_size, so can't derive the position; must

 wrap */

 pcm *_ops structures */

 !ECHOCARD_HAS_VMIXER */

 ECHOCARD_HAS_DIGITAL_IO */

/* Preallocate memory only for the first substream because it's the most

 * used one

<--snd_echo_probe() */

	/* This card has a Vmixer, that is there is no direct mapping from PCM

	streams to physical outputs. The user can mix the streams as he wishes

	via control interface and it's possible to send any stream to any

	output, thus it makes no sense to keep analog and digital outputs

 PCM#0 Virtual outputs and analog inputs */

 PCM#1 Digital inputs, no outputs */

 ECHOCARD_HAS_DIGITAL_IO */

 ECHOCARD_HAS_VMIXER */

	/* The card can manage substreams formed by analog and digital channels

	at the same time, but I prefer to keep analog and digital channels

	separated, because that mixed thing is confusing and useless. So we

 PCM#0 Analog i/o */

 PCM#1 Digital i/o */

 ECHOCARD_HAS_DIGITAL_IO */

 ECHOCARD_HAS_VMIXER */

/******************************************************************************

	Control interface

****************** PCM output volume *******************/

 Ignore out of range values */

 On the Mia this one controls the line-out volume */

 !ECHOCARD_HAS_VMIXER || ECHOCARD_HAS_LINE_OUT_GAIN */

****************** Analog input volume *******************/

 Ignore out of range values */

 ECHOCARD_HAS_INPUT_GAIN */

*********** Analog output nominal level (+4dBu / -10dBV) ***************/

 ECHOCARD_HAS_OUTPUT_NOMINAL_LEVEL */

************** Analog input nominal level (+4dBu / -10dBV) ***************/

		update_output_line_level(chip);	/* "Output" is not a mistake

						 * here.

 ECHOCARD_HAS_INPUT_NOMINAL_LEVEL */

****************** Monitor mixer *******************/

 ECHOCARD_HAS_MONITOR */

****************** Vmixer *******************/

 ECHOCARD_HAS_VMIXER */

****************** Digital mode switch *******************/

		/* mode_mutex is required to make this operation atomic wrt

		/* Do not allow the user to change the digital mode when a pcm

		device is open because it also changes the number of channels

 If we had to change the clock source, report it */

 No errors */

 ECHOCARD_HAS_DIGITAL_MODE_SWITCH */

****************** S/PDIF mode switch *******************/

 ECHOCARD_HAS_DIGITAL_IO */

****************** Select input clock source *******************/

 no errors */

 ECHOCARD_HAS_EXTERNAL_CLOCK */

****************** Phantom power switch *******************/

 no errors */

 ECHOCARD_HAS_PHANTOM_POWER */

****************** Digital input automute switch *******************/

 no errors */

 ECHOCARD_HAS_DIGITAL_IN_AUTOMUTE */

****************** VU-meters switch *******************/

**** Read VU-meters (input, output, analog and digital together) *****/

** Channels info - it exports informations about the number of channels ***/

 Compute the bitmask of the currently valid input clocks */

/******************************************************************************

	IRQ Handling

/* Check if a period has elapsed since last interrupt

 *

 * Don't make any updates to state; PCM core handles this with the

 * correct locks.

 *

 * \return true if a period has elapsed, otherwise false

 presumed atomic */

 handles wrapping */

 acknowledge whole periods only */

 haven't advanced a whole period yet */

 used exclusively by us */

	/* The hardware doesn't tell us which substream caused the irq,

/******************************************************************************

	Module construction / destruction

 release chip data */

 <--snd_echo_probe() */

 Allocate chip if needed */

 PCI resource allocation */

 We map only the required part */

	/* Create the DSP comm page - this is the area of memory used for most

 constructor */

 Some Mia's do not have midi */

 ECHOCARD_HAS_VMIXER */

 ECHOCARD_HAS_VMIXER */

 Creates a list of available digital modes */

 ECHOCARD_HAS_DIGITAL_MODE_SWITCH */

 Creates a list of available clock sources */

 ECHOCARD_HAS_EXTERNAL_CLOCK */

 This call can sleep */

	/* Temporarily set chip->pipe_alloc_mask=0 otherwise

	 * restore_dsp_settings() fails.

 CONFIG_PM_SLEEP */

/******************************************************************************

	Everything starts and ends here

 pci_driver definition */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  ALSA driver for Echoaudio soundcards.

 *  Copyright (C) 2003-2004 Giuliano Pochini <pochini@shiny.it>

 Pipe indexes */

 8 */

 2 */

 2 */

 2 */

 Bus indexes */

 8 */

 2 */

 2 */

 2 */

 DSP 56301 Gina20 rev.0 */

	/* One page (4k) contains 512 instructions. I don't know if the hw

	supports lists longer than this. In this case periods_max=220 is a

/****************************************************************************



   Copyright Echo Digital Audio Corporation (c) 1998 - 2004

   All rights reserved

   www.echoaudio.com



   This file is part of Echo Digital Audio's generic driver library.



   Echo Digital Audio's generic driver library is free software;

   you can redistribute it and/or modify it under the terms of

   the GNU General Public License as published by the Free Software

   Foundation.



   This program is distributed in the hope that it will be useful,

   but WITHOUT ANY WARRANTY; without even the implied warranty of

   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

   GNU General Public License for more details.



   You should have received a copy of the GNU General Public License

   along with this program; if not, write to the Free Software

   Foundation, Inc., 59 Temple Place - Suite 330, Boston,

   MA  02111-1307, USA.



   *************************************************************************



 Translation from C++ and adaptation for use in ALSA-Driver

 were made by Giuliano Pochini <pochini@shiny.it>



 These functions are common for all "3G" cards */

/* Most configuration of 3G cards is accomplished by writing the control

 Set the digital mode - currently for Gina24, Layla24, Mona, 3G */

 All audio channels must be closed before changing the digital mode */

	/* If we successfully changed the digital mode from or to ADAT,

	 * then make sure all output, input and monitor levels are

 Set the S/PDIF output format */

/* detect_input_clocks() returns a bitmask consisting of all the input clocks

currently connected to the hardware; this changes as the user connects and

disconnects clock inputs. You should use this information to determine which

	/* Map the DSP clock detect bits to the generic driver clock

 Give the DSP a few milliseconds to settle down */

 Now give the new ASIC some time to set up */

 See if it worked */

	/* Set up the control register if the load succeeded -

 Only set the clock for internal mode. */

 Save the rate anyhow */

 ignored by the DSP */

 Tell the DSP about it - DSP reads both control reg & freq reg */

 Set the sample clock source to internal, S/PDIF, ADAT */

 Mask off the clock select bits */

 Set clock to "internal" if it's not compatible with the new mode */

 Clear the current digital mode */

 Tweak the control reg */

 E3G_SPDIF_OPTICAL_MODE bit cleared */

 @@ useless */

/****************************************************************************



   Copyright Echo Digital Audio Corporation (c) 1998 - 2004

   All rights reserved

   www.echoaudio.com



   This file is part of Echo Digital Audio's generic driver library.



   Echo Digital Audio's generic driver library is free software;

   you can redistribute it and/or modify it under the terms of

   the GNU General Public License as published by the Free Software

   Foundation.



   This program is distributed in the hope that it will be useful,

   but WITHOUT ANY WARRANTY; without even the implied warranty of

   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

   GNU General Public License for more details.



   You should have received a copy of the GNU General Public License

   along with this program; if not, write to the Free Software

   Foundation, Inc., 59 Temple Place - Suite 330, Boston,

   MA  02111-1307, USA.



   *************************************************************************



 Translation from C++ and adaptation for use in ALSA-Driver

 were made by Giuliano Pochini <pochini@shiny.it>



 Map the DSP clock detect bits to the generic driver clock detect bits */

/* ASIC status check - some cards have one or two ASICs that need to be

loaded.  Once that load is complete, this function is called to see if

the load was successful.

If this load fails, it does not necessarily mean that the hardware is

defective - the external box may be disconnected or turned off.

This routine sometimes fails for Layla20; for Layla20, the loop runs

		/* The DSP will return a value to indicate whether or not

 Layla20 has an ASIC in the external box */

 Check if ASIC is alive and well. */

	/* Only set the clock for internal mode. Do not return failure,

 Set input bus gain (one unit is 0.5dB !) */

 Tell the DSP to reread the flags from the comm page */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  ALSA driver for Echoaudio soundcards.

 *  Copyright (C) 2003-2004 Giuliano Pochini <pochini@shiny.it>

 Pipe indexes */

 8 */

 0 */

 2 */

 0 */

 Bus indexes */

 8 */

 0 */

 2 */

 0 */

 DSP 56301 Darla24 rev.0 */

 DSP 56301 Darla24 rev.1 */

	/* One page (4k) contains 512 instructions. I don't know if the hw

	supports lists longer than this. In this case periods_max=220 is a

/****************************************************************************



   Copyright Echo Digital Audio Corporation (c) 1998 - 2004

   All rights reserved

   www.echoaudio.com



   This file is part of Echo Digital Audio's generic driver library.



   Echo Digital Audio's generic driver library is free software;

   you can redistribute it and/or modify it under the terms of

   the GNU General Public License as published by the Free Software

   Foundation.



   This program is distributed in the hope that it will be useful,

   but WITHOUT ANY WARRANTY; without even the implied warranty of

   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

   GNU General Public License for more details.



   You should have received a copy of the GNU General Public License

   along with this program; if not, write to the Free Software

   Foundation, Inc., 59 Temple Place - Suite 330, Boston,

   MA  02111-1307, USA.



   *************************************************************************



 Translation from C++ and adaptation for use in ALSA-Driver

 were made by Giuliano Pochini <pochini@shiny.it>



 Gina24 comes in both '301 and '361 flavors */

	/* Map the DSP clock detect bits to the generic driver clock

/* Gina24 has an ASIC on the PCI card which must be loaded for anything

 Give the DSP a few milliseconds to settle down */

 Pick the correct ASIC for '301 or '361 Gina24 */

 Now give the new ASIC a little time to set up */

 See if it worked */

	/* Set up the control register if the load succeeded -

 Only set the clock for internal mode. */

 Save the rate anyhow */

 Professional mode ? */

 ignored by the DSP */

 Mask off the clock select bits */

 Set clock to "internal" if it's not compatible with the new mode */

 Switch to 48KHz, internal */

 Clear the current digital mode */

 Tweak the control reg */

 '361 Gina24 cards do not have the S/PDIF CD-ROM mode */

 GML_SPDIF_OPTICAL_MODE bit cleared */

/****************************************************************************



   Copyright Echo Digital Audio Corporation (c) 1998 - 2004

   All rights reserved

   www.echoaudio.com



   This file is part of Echo Digital Audio's generic driver library.



   Echo Digital Audio's generic driver library is free software;

   you can redistribute it and/or modify it under the terms of

   the GNU General Public License as published by the Free Software

   Foundation.



   This program is distributed in the hope that it will be useful,

   but WITHOUT ANY WARRANTY; without even the implied warranty of

   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

   GNU General Public License for more details.



   You should have received a copy of the GNU General Public License

   along with this program; if not, write to the Free Software

   Foundation, Inc., 59 Temple Place - Suite 330, Boston,

   MA  02111-1307, USA.



   *************************************************************************



 Translation from C++ and adaptation for use in ALSA-Driver

 were made by Giuliano Pochini <pochini@shiny.it>



	/* Since this card has no ASIC, mark it as loaded so everything

 The IndigoIO has no ASIC. Just do nothing */

 This function routes the sound from a virtual channel to a real output */

 Tell the DSP to read and update virtual mixer levels in comm page. */

/****************************************************************************



   Copyright Echo Digital Audio Corporation (c) 1998 - 2004

   All rights reserved

   www.echoaudio.com



   This file is part of Echo Digital Audio's generic driver library.



   Echo Digital Audio's generic driver library is free software;

   you can redistribute it and/or modify it under the terms of

   the GNU General Public License as published by the Free Software

   Foundation.



   This program is distributed in the hope that it will be useful,

   but WITHOUT ANY WARRANTY; without even the implied warranty of

   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

   GNU General Public License for more details.



   You should have received a copy of the GNU General Public License

   along with this program; if not, write to the Free Software

   Foundation, Inc., 59 Temple Place - Suite 330, Boston,

   MA  02111-1307, USA.



   *************************************************************************



 Translation from C++ and adaptation for use in ALSA-Driver

 were made by Giuliano Pochini <pochini@shiny.it>



/* Some vector commands involve the DSP reading or writing data to and from the

comm page; if you send one of these commands to the DSP, it will complete the

command and then write a non-zero value to the Handshake field in the

 Wait up to 20ms for the handshake from the DSP */

 Look for the handshake value */

/* Much of the interaction between the DSP and the driver is done via vector

commands; send_vector writes a vector command to the DSP.  Typically, this

causes the DSP to read or write fields in the comm page.

 Flush all pending writes before sending the command */

 Wait up to 100ms for the "vector busy" bit to be off */

if (i)  DE_ACT(("send_vector time: %d\n", i));*/

/* write_dsp writes a 32-bit value to the DSP; this is used almost

 timeout = 10s */

 write it immediately */

 Set true until DSP re-loaded */

/* read_dsp reads a 32-bit value from the DSP; this is used almost

 Set true until DSP re-loaded */

/****************************************************************************

	Firmware loading functions

/* This function is used to read back the serial number from the DSP;

this is triggered by the SET_COMMPAGE_ADDR command.

Only some early Echogals products have serial numbers in the ROM;

the serial number is not used, but you still need to do this as

 This card has no ASIC, just return ok */

 !ECHOCARD_HAS_ASIC */

 Load ASIC code - done after the DSP is loaded */

 Send the "Here comes the ASIC" command */

 Write length of ASIC file in bytes */

 ECHOCARD_HAS_ASIC */

/* Install the resident loader for 56361 DSPs;  The resident loader is on

the EPROM on the board for 56301 DSP. The resident loader is a tiny little

	/* 56361 cards only!  This check is required by the old 56301-based

	/* Look to see if the resident loader is present.  If the resident

	/* The DSP code is an array of 16 bit words.  The array is divided up

	into sections.  The first word of each section is the size in words,

	followed by the section type.

	Since DSP addresses and data are 24 bits wide, they each take up two

	16 bit words in the array.

	This is a lot like the other loader loop, but it's not a loop, you

 Set DSP format bits for 24 bit mode */

	/* Skip the header section; the first word in the array is the size

	of the first section, so the first real section of code is pointed

 Skip the section size, LRS block type, and DSP memory type */

 Get the number of DSP words to write */

 Get the DSP address for this block; 24 bits, so build from two words */

 Write the count to the DSP */

 Write the DSP address */

 Write out this block of code to the DSP */

 Wait for flag 5 to come up */

 Timeout is 50us * 200 = 10ms */

 DSP_56361 */

 Set true until DSP loaded */

 Current DSP code not loaded */

 Loading the DSP code will reset the ASIC */

 If this board requires a resident loader, install it. */

 Send software reset command */

 Delay 10us */

 Wait 10ms for HF3 to indicate that software reset is complete */

 Timeout is 10us * 1000 = 10ms */

 Set DSP format bits for 24 bit mode now that soft reset is done */

 Main loader loop */

 Total Block Size */

 Block Type */

 We're finished */

 Memory Type  P=0,X=1,Y=2 */

 Block Code Size */

 We're finished */

 Start Address */

 Code */

 We're done!!! */

 Timeout is 100us * 5000 = 500ms */

 Wait for flag 4 - indicates that the DSP loaded OK */

			/* Get the serial number via slave mode.

			This is triggered by the SET_COMMPAGE_ADDR command.

			We don't actually use the serial number but we have to

 Show which DSP code loaded */

 DSP OK */

 load_firmware takes care of loading the DSP and any ASIC code. */

 See if the ASIC is present and working - only if the DSP is already loaded */

 ASIC check failed; force the DSP to reload */

 error */

/****************************************************************************

	Mixer functions

 Set the nominal level for an input or output bus (true = -10dBV, false = +4dBu) */

 Wait for the handshake (OK even if ASIC is not loaded) */

 ECHOCARD_HAS_*_NOMINAL_LEVEL */

 Set the gain for a single physical output channel (dB). */

 Save the new value */

 Set the monitor level from an input bus to an output bus. */

 ECHOCARD_HAS_MONITOR */

 Tell the DSP to read and update output, nominal & monitor levels in comm page. */

 Tell the DSP to read and update input levels in comm page */

/* set_meters_on turns the meters on or off.  If meters are turned on, the DSP

/* Fill out an the given array using the current values in the comm page.

Meters are written in the comm page by the DSP in this order:

 Output busses

 Input busses

 Output pipes (vmixer cards only)



This function assumes there are no more than 16 in/out busses or pipes

 Skip unused meters */

 Gina20/Darla20 only. Should be harmless for other cards. */

 Restore output busses */

 ECHOCARD_HAS_VMIXER */

 ECHOCARD_HAS_MONITOR */

 ECHOCARD_HAS_INPUT_GAIN */

 set_input_clock() also restores automute setting */

/****************************************************************************

	Transport functions

/* set_audio_format() sets the format of the audio data in host memory for

this pipe.  Note that _MS_ (mono-to-stereo) playback modes are not used by ALSA

 Look for super-interleave (no big-endian and 8 bits) */

 For big-endian data, only 32 bit samples are supported */

 32 bit little-endian mono->mono case */

 Handle the other little-endian formats */

/* start_transport starts transport for a set of pipes.

The bits 1 in channel_mask specify what pipes to start. Only the bit of the

first channel must be set, regardless its interleave.

 Keep track of which pipes are transporting */

 Keep track of which pipes are transporting */

 Keep track of which pipes are transporting */

/* Stops everything and turns off the DSP. All pipes should be already

 Stops all active pipes (just to be sure) */

 Go to sleep */

 Make load_firmware do a complete reload */

 Put the DSP to sleep */

 Fills the comm page with default values */

 Check if the compiler added extra padding inside the structure */

 Init all the basic stuff */

 Set true until DSP loaded */

 Current DSP code not loaded */

 Init the comm page */

 Set line levels so we don't blast any inputs on startup */

/* This function initializes the chip structure with default values, ie. all

 * muted and internal clock source. Then it copies the settings to the DSP.

 * This MUST be called after the DSP is up and running !

/* This is low level part of the interrupt handler.

It returns -1 if the IRQ is not ours, or N>=0 if it is, where N is the number

 Read the DSP status register and see if this DSP generated this interrupt */

 Get and parse midi data if present */

 The count is at index 0 */

 Returns how many midi bytes we received */

 Clear the hardware interrupt */

/******************************************************************************

	Functions for opening and closing pipes

/* allocate_pipes is used to reserve audio pipes for your exclusive use.

 This driver uses cyclic buffers only */

	/* The counter register is where the DSP writes the 32 bit DMA

	position for a pipe.  The DSP is constantly updating this value as

/******************************************************************************

	Functions for managing the scatter-gather list

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  ALSA driver for Echoaudio soundcards.

 *  Copyright (C) 2003-2004 Giuliano Pochini <pochini@shiny.it>

 Pipe indexes */

 Bus indexes */

 Echo 3G */

/****************************************************************************



   Copyright Echo Digital Audio Corporation (c) 1998 - 2004

   All rights reserved

   www.echoaudio.com



   This file is part of Echo Digital Audio's generic driver library.



   Echo Digital Audio's generic driver library is free software;

   you can redistribute it and/or modify it under the terms of

   the GNU General Public License as published by the Free Software Foundation.



   This program is distributed in the hope that it will be useful,

   but WITHOUT ANY WARRANTY; without even the implied warranty of

   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

   GNU General Public License for more details.



   You should have received a copy of the GNU General Public License

   along with this program; if not, write to the Free Software

   Foundation, Inc., 59 Temple Place - Suite 330, Boston,

   MA  02111-1307, USA.



   *************************************************************************



 Translation from C++ and adaptation for use in ALSA-Driver

 were made by Giuliano Pochini <pochini@shiny.it>



 Map the DSP clock detect bits to the generic driver clock detect bits */

/* Layla24 has an ASIC on the PCI card and another ASIC in the external box;

 Give the DSP a few milliseconds to settle down */

 Load the ASIC for the PCI card */

 Now give the new ASIC a little time to set up */

 Do the external one */

 Now give the external ASIC a little time to set up */

 See if it worked */

	/* Set up the control register if the load succeeded -

 Only set the clock for internal mode. */

 Save the rate anyhow */

 Get the control register & clear the appropriate bits */

 Professional mode */

		/* If this is a non-standard rate, then the driver needs to

 ignored by the DSP ? */

 Mask off the clock select bits */

 Pick the new clock */

 Layla24 doesn't support 96KHz S/PDIF */

/* Depending on what digital mode you want, Layla24 needs different ASICs

loaded.  This function checks the ASIC needed for the new mode and sees

  Check to see if this is already loaded */

 Load the desired ASIC */

 Set clock to "internal" if it's not compatible with the new mode */

 Switch to 48KHz, internal */

 switch_asic() can sleep */

 Tweak the control register */

 GML_SPDIF_OPTICAL_MODE bit cleared */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  ALSA driver for Echoaudio soundcards.

 *  Copyright (C) 2003-2004 Giuliano Pochini <pochini@shiny.it>

 Pipe indexes */

 8 */

 0 */

 0 */

 0 */

 Bus indexes */

 2 */

 0 */

 0 */

 0 */

 Indigo */

/****************************************************************************



   Copyright Echo Digital Audio Corporation (c) 1998 - 2004

   All rights reserved

   www.echoaudio.com



   This file is part of Echo Digital Audio's generic driver library.



   Echo Digital Audio's generic driver library is free software;

   you can redistribute it and/or modify it under the terms of

   the GNU General Public License as published by the Free Software

   Foundation.



   This program is distributed in the hope that it will be useful,

   but WITHOUT ANY WARRANTY; without even the implied warranty of

   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

   GNU General Public License for more details.



   You should have received a copy of the GNU General Public License

   along with this program; if not, write to the Free Software

   Foundation, Inc., 59 Temple Place - Suite 330, Boston,

   MA  02111-1307, USA.



   *************************************************************************



 Translation from C++ and adaptation for use in ALSA-Driver

 were made by Giuliano Pochini <pochini@shiny.it>



	/* Since this card has no ASIC, mark it as loaded so everything

 The Indigo has no ASIC. Just do nothing */

 Set the control register if it has changed */

 ignored by the DSP */

 This function routes the sound from a virtual channel to a real output */

 Tell the DSP to read and update virtual mixer levels in comm page. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  ALSA driver for Echoaudio soundcards.

 *  Copyright (C) 2009 Giuliano Pochini <pochini@shiny.it>

 Pipe indexes */

 8 */

 0 */

 2 */

 0 */

 Bus indexes */

 2 */

 0 */

 2 */

 0 */

 Indigo IOx */

/****************************************************************************



   Copyright Echo Digital Audio Corporation (c) 1998 - 2004

   All rights reserved

   www.echoaudio.com



   This file is part of Echo Digital Audio's generic driver library.



   Echo Digital Audio's generic driver library is free software;

   you can redistribute it and/or modify it under the terms of

   the GNU General Public License as published by the Free Software

   Foundation.



   This program is distributed in the hope that it will be useful,

   but WITHOUT ANY WARRANTY; without even the implied warranty of

   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

   GNU General Public License for more details.



   You should have received a copy of the GNU General Public License

   along with this program; if not, write to the Free Software

   Foundation, Inc., 59 Temple Place - Suite 330, Boston,

   MA  02111-1307, USA.



   *************************************************************************



 Translation from C++ and adaptation for use in ALSA-Driver

 were made by Giuliano Pochini <pochini@shiny.it>



/******************************************************************************

	MIDI lowlevel code

 Start and stop Midi input */

/* Send a buffer full of MIDI data to the DSP

 HF4 indicates that it is safe to write MIDI output data */

/* Run the state machine for MIDI input data

MIDI time code sync isn't supported by this code right now, but you still need

this state machine to parse the incoming MIDI data stream.  Every time the DSP

sees a 0xF1 byte come in, it adds the DSP sample position to the MIDI data

stream. The DSP sample position is represented as a 32 bit unsigned value,

with the high 16 bits first, followed by the low 16 bits. Since these aren't

/* This function is called from the IRQ handler and it reads the midi data

 The count is at index 0, followed by actual data */

 Get the MIDI data from the comm page */

 Get the MIDI byte */

		/* Parse the incoming MIDI stream. The incoming MIDI data

		consists of MIDI bytes and timestamps for the MIDI time code

		0xF1 bytes. mtc_process_data() is a little state machine that

		parses the stream. If you get MIDI_IN_SKIP_DATA back, then

		this is a timestamp byte, not a MIDI byte, so don't store it

/******************************************************************************

	MIDI interface

	/* No interrupts are involved: we have to check at regular intervals

 retry later */

			/* Buffer is full. DSP's internal buffer is 64 (128 ?)

 We restart the timer only if there is some data left to send */

		/* The timer will expire slightly after the data has been

 8/25=0.32ms to send a byte */

 <--snd_echo_probe() */

/****************************************************************************



   Copyright Echo Digital Audio Corporation (c) 1998 - 2004

   All rights reserved

   www.echoaudio.com



   This file is part of Echo Digital Audio's generic driver library.



   Echo Digital Audio's generic driver library is free software;

   you can redistribute it and/or modify it under the terms of

   the GNU General Public License as published by the Free Software

   Foundation.



   This program is distributed in the hope that it will be useful,

   but WITHOUT ANY WARRANTY; without even the implied warranty of

   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

   GNU General Public License for more details.



   You should have received a copy of the GNU General Public License

   along with this program; if not, write to the Free Software

   Foundation, Inc., 59 Temple Place - Suite 330, Boston,

   MA  02111-1307, USA.



   *************************************************************************



 Translation from C++ and adaptation for use in ALSA-Driver

 were made by Giuliano Pochini <pochini@shiny.it>



	/* Since this card has no ASIC, mark it as loaded so everything

 The IndigoDJ has no ASIC. Just do nothing */

 Set the control register if it has changed */

 ignored by the DSP */

 This function routes the sound from a virtual channel to a real output */

 Tell the DSP to read and update virtual mixer levels in comm page. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  ALSA driver for Echoaudio soundcards.

 *  Copyright (C) 2003-2004 Giuliano Pochini <pochini@shiny.it>

 Pipe indexes */

 8 */

 0 */

 2 */

 0 */

 Bus indexes */

 8 */

 0 */

 2 */

 0 */

 DSP 56301 Darla20 rev.0 */

	/* One page (4k) contains 512 instructions. I don't know if the hw

	supports lists longer than this. In this case periods_max=220 is a

/****************************************************************************



   Copyright Echo Digital Audio Corporation (c) 1998 - 2004

   All rights reserved

   www.echoaudio.com



   This file is part of Echo Digital Audio's generic driver library.



   Echo Digital Audio's generic driver library is free software;

   you can redistribute it and/or modify it under the terms of

   the GNU General Public License as published by the Free Software

   Foundation.



   This program is distributed in the hope that it will be useful,

   but WITHOUT ANY WARRANTY; without even the implied warranty of

   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

   GNU General Public License for more details.



   You should have received a copy of the GNU General Public License

   along with this program; if not, write to the Free Software

   Foundation, Inc., 59 Temple Place - Suite 330, Boston,

   MA  02111-1307, USA.



   *************************************************************************



 Translation from C++ and adaptation for use in ALSA-Driver

 were made by Giuliano Pochini <pochini@shiny.it>



	/* Load the DSP code and the ASIC on the PCI card and get

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  ALSA driver for Echoaudio soundcards.

 *  Copyright (C) 2003-2004 Giuliano Pochini <pochini@shiny.it>

 Pipe indexes */

 10 */

  2 */

  8 */

  2 */

 Bus indexes */

 10 */

  2 */

  8 */

  2 */

 DSP 56301 Layla20 rev.0 */

 DSP 56301 Layla20 rev.1 */

	/* One page (4k) contains 512 instructions. I don't know if the hw

	supports lists longer than this. In this case periods_max=220 is a

/***************************************************************************



   Copyright Echo Digital Audio Corporation (c) 1998 - 2004

   All rights reserved

   www.echoaudio.com



   This file is part of Echo Digital Audio's generic driver library.



   Echo Digital Audio's generic driver library is free software;

   you can redistribute it and/or modify it under the terms of

   the GNU General Public License as published by the Free Software

   Foundation.



   This program is distributed in the hope that it will be useful,

   but WITHOUT ANY WARRANTY; without even the implied warranty of

   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

   GNU General Public License for more details.



   You should have received a copy of the GNU General Public License

   along with this program; if not, write to the Free Software

   Foundation, Inc., 59 Temple Place - Suite 330, Boston,

   MA  02111-1307, USA.



   *************************************************************************



 Translation from C++ and adaptation for use in ALSA-Driver

 were made by Giuliano Pochini <pochini@shiny.it>



	/* Since this card has no ASIC, mark it as loaded so everything

 The Darla20 has no external clock sources */

 The Darla20 has no ASIC. Just do nothing */

 magic number - should always be 3 */

 Save the new audio state if it changed */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  ALSA driver for Echoaudio soundcards.

 *  Copyright (C) 2003-2004 Giuliano Pochini <pochini@shiny.it>

 Pipe indexes */

 8 */

 8 */

 2 */

 8 */

 Bus indexes */

 8 */

 8 */

 2 */

 8 */

 DSP 56301 Gina24 rev.0 */

 DSP 56301 Gina24 rev.1 */

 DSP 56361 Gina24 rev.0 */

 DSP 56361 Gina24 rev.1 */

	/* One page (4k) contains 512 instructions. I don't know if the hw

	supports lists longer than this. In this case periods_max=220 is a

	safe limit to make sure the list never exceeds 512 instructions.

/************************************************************************



This file is part of Echo Digital Audio's generic driver library.

Copyright Echo Digital Audio Corporation (c) 1998 - 2005

All rights reserved

www.echoaudio.com



This library is free software; you can redistribute it and/or

modify it under the terms of the GNU Lesser General Public

License as published by the Free Software Foundation; either

version 2.1 of the License, or (at your option) any later version.



This library is distributed in the hope that it will be useful,

but WITHOUT ANY WARRANTY; without even the implied warranty of

MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU

Lesser General Public License for more details.



You should have received a copy of the GNU Lesser General Public

License along with this library; if not, write to the Free Software

Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA



*************************************************************************



 Translation from C++ and adaptation for use in ALSA-Driver

 were made by Giuliano Pochini <pochini@shiny.it>



 This function routes the sound from a virtual channel to a real output */

 Tell the DSP to read and update virtual mixer levels in comm page. */

 The IndigoIO has no ASIC. Just do nothing */

/****************************************************************************



   Copyright Echo Digital Audio Corporation (c) 1998 - 2004

   All rights reserved

   www.echoaudio.com



   This file is part of Echo Digital Audio's generic driver library.



   Echo Digital Audio's generic driver library is free software;

   you can redistribute it and/or modify it under the terms of

   the GNU General Public License as published by the Free Software

   Foundation.



   This program is distributed in the hope that it will be useful,

   but WITHOUT ANY WARRANTY; without even the implied warranty of

   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

   GNU General Public License for more details.



   You should have received a copy of the GNU General Public License

   along with this program; if not, write to the Free Software

   Foundation, Inc., 59 Temple Place - Suite 330, Boston,

   MA  02111-1307, USA.



   *************************************************************************



 Translation from C++ and adaptation for use in ALSA-Driver

 were made by Giuliano Pochini <pochini@shiny.it>



 Mona comes in both '301 and '361 flavors */

	/* Map the DSP clock detect bits to the generic driver clock

/* Mona has an ASIC on the PCI card and another ASIC in the external box; 

 Do the external one */

	/* Set up the control register if the load succeeded -

/* Depending on what digital mode you want, Mona needs different ASICs

loaded.  This function checks the ASIC needed for the new mode and sees

	/* Check the clock detect bits to see if this is

	a single-speed clock or a double-speed clock; load

 Load the desired ASIC */

 Only set the clock for internal mode. */

 Save the rate anyhow */

 Now, check to see if the required ASIC is loaded */

 Load the desired ASIC (load_asic_generic() can sleep) */

 Compute the new control register value */

 Professional mode */

 ignored by the DSP */

 Mask off the clock select bits */

 Set clock to "internal" if it's not compatible with the new mode */

 Switch to 48KHz, internal */

 Clear the current digital mode */

 Tweak the control reg */

 GML_SPDIF_OPTICAL_MODE bit cleared */

		/* If the current ASIC is the 96KHz ASIC, switch the ASIC

/****************************************************************************



   Copyright Echo Digital Audio Corporation (c) 1998 - 2004

   All rights reserved

   www.echoaudio.com



   This file is part of Echo Digital Audio's generic driver library.



   Echo Digital Audio's generic driver library is free software;

   you can redistribute it and/or modify it under the terms of

   the GNU General Public License as published by the Free Software

   Foundation.



   This program is distributed in the hope that it will be useful,

   but WITHOUT ANY WARRANTY; without even the implied warranty of

   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

   GNU General Public License for more details.



   You should have received a copy of the GNU General Public License

   along with this program; if not, write to the Free Software

   Foundation, Inc., 59 Temple Place - Suite 330, Boston,

   MA  02111-1307, USA.



   *************************************************************************



 Translation from C++ and adaptation for use in ALSA-Driver

 were made by Giuliano Pochini <pochini@shiny.it>



	/* Since this card has no ASIC, mark it as loaded so everything

	/* Map the DSP clock detect bits to the generic driver clock

 The Gina20 has no ASIC. Just do nothing */

 magic number - should always be 3 */

 Save the new audio state if it changed */

 Reset the audio state to unknown (just in case) */

 Set input bus gain (one unit is 0.5dB !) */

 Tell the DSP to reread the flags from the comm page */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  ALSA driver for Echoaudio soundcards.

 *  Copyright (C) 2003-2004 Giuliano Pochini <pochini@shiny.it>

 Pipe indexes */

 6 */

 8 */

 4 */

 8 */

 Bus indexes */

 6 */

 8 */

 4 */

 8 */

 DSP 56301 Mona rev.0 */

 DSP 56301 Mona rev.1 */

 DSP 56301 Mona rev.2 */

 DSP 56361 Mona rev.0 */

 DSP 56361 Mona rev.1 */

 DSP 56361 Mona rev.2 */

	/* One page (4k) contains 512 instructions. I don't know if the hw

	supports lists longer than this. In this case periods_max=220 is a

/****************************************************************************



   Copyright Echo Digital Audio Corporation (c) 1998 - 2004

   All rights reserved

   www.echoaudio.com



   This file is part of Echo Digital Audio's generic driver library.



   Echo Digital Audio's generic driver library is free software;

   you can redistribute it and/or modify it under the terms of

   the GNU General Public License as published by the Free Software

   Foundation.



   This program is distributed in the hope that it will be useful,

   but WITHOUT ANY WARRANTY; without even the implied warranty of

   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

   GNU General Public License for more details.



   You should have received a copy of the GNU General Public License

   along with this program; if not, write to the Free Software

   Foundation, Inc., 59 Temple Place - Suite 330, Boston,

   MA  02111-1307, USA.



   *************************************************************************



 Translation from C++ and adaptation for use in ALSA-Driver

 were made by Giuliano Pochini <pochini@shiny.it>



 These functions are common for Gina24, Layla24 and Mona cards */

/* ASIC status check - some cards have one or two ASICs that need to be

loaded.  Once that load is complete, this function is called to see if

the load was successful.

If this load fails, it does not necessarily mean that the hardware is

	/* The DSP will return a value to indicate whether or not the

/* Most configuration of Gina24, Layla24, or Mona is accomplished by writing

the control register.  write_control_reg sends the new control register

 Handle the digital input auto-mute */

 Write the control register */

/* Gina24, Layla24, and Mona support digital input auto-mute.  If the digital

input auto-mute is enabled, the DSP will only enable the digital inputs if

the card is syncing to a valid clock on the ADAT or S/PDIF inputs.

If the auto-mute is disabled, the digital inputs are enabled regardless of

	/* Re-set the input clock to the current value - indirectly causes

 S/PDIF coax / S/PDIF optical / ADAT - switch */

 All audio channels must be closed before changing the digital mode */

	/* If we successfully changed the digital mode from or to ADAT,

	   then make sure all output, input and monitor levels are

 Set the S/PDIF output format */

 Clear the current S/PDIF flags */

 Set the new S/PDIF flags depending on the mode */

 Professional mode */

 Consumer mode */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  ALSA driver for Echoaudio soundcards.

 *  Copyright (C) 2003-2004 Giuliano Pochini <pochini@shiny.it>

 Pipe indexes */

 8 */

 8 */

 8 */

 8 */

 Bus indexes */

 8 */

 8 */

 8 */

 8 */

 DSP 56361 Layla24 rev.0 */

	/* One page (4k) contains 512 instructions. I don't know if the hw

	supports lists longer than this. In this case periods_max=220 is a

/****************************************************************************



   Copyright Echo Digital Audio Corporation (c) 1998 - 2004

   All rights reserved

   www.echoaudio.com



   This file is part of Echo Digital Audio's generic driver library.



   Echo Digital Audio's generic driver library is free software;

   you can redistribute it and/or modify it under the terms of

   the GNU General Public License as published by the Free Software

   Foundation.



   This program is distributed in the hope that it will be useful,

   but WITHOUT ANY WARRANTY; without even the implied warranty of

   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

   GNU General Public License for more details.



   You should have received a copy of the GNU General Public License

   along with this program; if not, write to the Free Software

   Foundation, Inc., 59 Temple Place - Suite 330, Boston,

   MA  02111-1307, USA.



   *************************************************************************



 Translation from C++ and adaptation for use in ALSA-Driver

 were made by Giuliano Pochini <pochini@shiny.it>



	/* Since this card has no ASIC, mark it as loaded so everything

	/* Map the DSP clock detect bits to the generic driver clock

 The Mia has no ASIC. Just do nothing */

 Override the clock setting if this Mia is set to S/PDIF clock */

 Set the control register if it has changed */

 ignored by the DSP */

 This function routes the sound from a virtual channel to a real output */

 Tell the DSP to read and update virtual mixer levels in comm page. */

 Tell the DSP to reread the flags from the comm page */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  ALSA driver for Echoaudio soundcards.

 *  Copyright (C) 2003-2004 Giuliano Pochini <pochini@shiny.it>

 Pipe indexes */

 8 */

 0 */

 0 */

 0 */

 Bus indexes */

 4 */

 0 */

 0 */

 0 */

 Indigo DJ*/

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  ALSA driver for Echoaudio soundcards.

 *  Copyright (C) 2009 Giuliano Pochini <pochini@shiny.it>

 Pipe indexes */

 8 */

 0 */

 0 */

 0 */

 Bus indexes */

 4 */

 0 */

 0 */

 0 */

 Indigo DJx*/

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  ALSA driver for Echoaudio soundcards.

 *  Copyright (C) 2003-2004 Giuliano Pochini <pochini@shiny.it>

 Pipe indexes */

 8 */

 0 */

 2 */

 2 */

 Bus indexes */

 2 */

 2 */

 2 */

 2 */

 DSP 56361 Mia rev.0 */

 DSP 56361 Mia rev.1 */

	/* One page (4k) contains 512 instructions. I don't know if the hw

	supports lists longer than this. In this case periods_max=220 is a

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  The driver for the Cirrus Logic's Sound Fusion CS46XX based soundcards

 *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>

/*

  NOTES:

  - sometimes the sound is metallic and sibilant, unloading and 

    reloading the module may solve this.

 Index 0-MAX */

 ID for this card */

 Enable this card */

 CS4280 */

 CS4612 */

 CS4615 */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>

 *                   Abramo Bagnara <abramo@alsa-project.org>

 *                   Cirrus Logic, Inc.

 *  Routines for control of Cirrus Logic CS461x chips

 *

 *  KNOWN BUGS:

 *    - Sometimes the SPDIF input DSP tasks get's unsynchronized

 *      and the SPDIF get somewhat "distorcionated", or/and left right channel

 *      are swapped. To get around this problem when it happens, mute and unmute 

 *      the SPDIF input mixer control.

 *    - On the Hercules Game Theater XP the amplifier are sometimes turned

 *      off on inadecuate moments which causes distorcions on sound.

 *

 *  TODO:

 *    - Secondary CODEC on some soundcards

 *    - SPDIF input support for other sample rates then 48khz

 *    - Posibility to mix the SPDIF output with analog sources.

 *    - PCM channels for Center and LFE on secondary codec

 *

 *  NOTE: with CONFIG_SND_CS46XX_NEW_DSP unset uses old DSP image (which

 *        is default configuration), no SPDIF, no secondary codec, no

 *        multi channel PCM.  But known to work.

 *

 *  FINALLY: A credit to the developers Tom and Jordan 

 *           at Cirrus for have helping me out with the DSP, however we

 *           still don't have sufficient documentation and technical

 *           references to be able to implement all fancy feutures

 *           supported by the cs46xx DSP's. 

 *           Benny <benny@hostmobility.com>

	/*

	 *  1. Write ACCAD = Command Address Register = 46Ch for AC97 register address

	 *  2. Write ACCDA = Command Data Register = 470h    for data to write to AC97 

	 *  3. Write ACCTL = Control Register = 460h for initiating the write7---55

	 *  4. Read ACCTL = 460h, DCV should be reset by now and 460h = 17h

	 *  5. if DCV not cleared, break and return error

	 *  6. Read ACSTS = Status Register = 464h, check VSTS bit

	/*

	 *  Setup the AC97 control registers on the CS461x to send the

	 *  appropriate command to the AC97 to perform the read.

	 *  ACCAD = Command Address Register = 46Ch

	 *  ACCDA = Command Data Register = 470h

	 *  ACCTL = Control Register = 460h

	 *  set DCV - will clear when process completed

	 *  set CRW - Read command

	 *  set VFRM - valid frame enabled

	 *  set ESYN - ASYNC generation enabled

	 *  set RSTN - ARST# inactive, AC97 codec not reset

 clear ACCTL_DCV */ ACCTL_CRW | 

	/*

	 *  Wait for the read to occur.

		/*

		 *  First, we want to wait for a short time.

		/*

		 *  Now, check to see if the read has completed.

		 *  ACCTL = 460h, DCV should be reset by now and 460h = 17h

	/*

	 *  Wait for the valid status bit to go active.

		/*

		 *  Read the AC97 status register.

		 *  ACSTS = Status Register = 464h

		 *  VSTS - Valid Status

	/*

	 *  Read the data returned from the AC97 register.

	 *  ACSDA = Status Data Register = 474h

snd_cs46xx_peekBA0(chip, BA0_ACCAD);

	/*

	 *  1. Write ACCAD = Command Address Register = 46Ch for AC97 register address

	 *  2. Write ACCDA = Command Data Register = 470h    for data to write to AC97

	 *  3. Write ACCTL = Control Register = 460h for initiating the write

	 *  4. Read ACCTL = 460h, DCV should be reset by now and 460h = 07h

	 *  5. if DCV not cleared, break and return error

	/*

	 *  Setup the AC97 control registers on the CS461x to send the

	 *  appropriate command to the AC97 to perform the read.

	 *  ACCAD = Command Address Register = 46Ch

	 *  ACCDA = Command Data Register = 470h

	 *  ACCTL = Control Register = 460h

	 *  set DCV - will clear when process completed

	 *  reset CRW - Write command

	 *  set VFRM - valid frame enabled

	 *  set ESYN - ASYNC generation enabled

	 *  set RSTN - ARST# inactive, AC97 codec not reset

 clear ACCTL_DCV */ ACCTL_VFRM |

		/*

		 *  First, we want to wait for a short time.

		/*

		 *  Now, check to see if the write has completed.

		 *  ACCTL = 460h, DCV should be reset by now and 460h = 07h

/*

 *  Chip initialization

 writel already converts 32-bit value to right endianess */

/* firmware binary format:

 * le32 nsymbols;

 * struct {

 *	le32 address;

 *	char symbol_name[DSP_MAX_SYMBOL_NAME];

 *	le32 symbol_type;

 * } symbols[nsymbols];

 * le32 nsegments;

 * struct {

 *	le32 segment_type;

 *	le32 offset;

 *	le32 size;

 *	le32 data[size];

 * } segments[nsegments];

 writel already converts 32-bit value to right endianess */

 old DSP image */

 sanity check */

 CONFIG_SND_CS46XX_NEW_DSP */

/*

 *  Chip reset

	/*

	 *  Write the reset bit of the SP control register.

	/*

	 *  Write the control register.

	/*

	 *  Clear the trap registers.

	/*

	 *  Set the frame timer to reflect the number of cycles per frame.

	/*

	 * Make sure the previous FIFO write operation has completed.

	/*

	 *  See if the devices are powered down.  If so, we must power them up first

	 *  or they will not respond.

	/*

	 *  We want to clear out the serial port FIFOs so we don't end up playing

	 *  whatever random garbage happens to be in them.  We fill the sample FIFOS

	 *  with zero (silence).

	/*

	 *  Fill all 256 sample FIFO locations.

		/*

		 *  Make sure the previous FIFO write operation has completed.

		/*

		 *  Write the serial port FIFO index.

		/*

		 *  Tell the serial port to load the new value into the FIFO location.

	/*

	 *  Now, if we powered up the devices, then power them back down again.

	 *  This is kinda ugly, but should never happen.

	/*

	 *  Set the frame timer to reflect the number of cycles per frame.

	/*

	 *  Turn on the run, run at frame, and DMA enable bits in the local copy of

	 *  the SP control register.

	/*

	 *  Wait until the run at frame bit resets itself in the SP control

	 *  register.

	/*

	 *  Turn off the run, run at frame, and DMA enable bits in the local copy of

	 *  the SP control register.

/*

 *  Sample rate routines

	/*

	 *  Compute the values used to drive the actual sample rate conversion.

	 *  The following formulas are being computed, using inline assembly

	 *  since we need to use 64 bit arithmetic to compute the values:

	 *

	 *  phiIncr = floor((Fs,in * 2^26) / Fs,out)

	 *  correctionPerGOF = floor((Fs,in * 2^26 - Fs,out * phiIncr) /

         *                                   GOF_PER_SEC)

         *  ulCorrectionPerSec = Fs,in * 2^26 - Fs,out * phiIncr -M

         *                       GOF_PER_SEC * correctionPerGOF

	 *

	 *  i.e.

	 *

	 *  phiIncr:other = dividend:remainder((Fs,in * 2^26) / Fs,out)

	 *  correctionPerGOF:correctionPerSec =

	 *      dividend:remainder(ulOther / GOF_PER_SEC)

	/*

	 *  Fill in the SampleRateConverter control block.

	/*

	 *  We can only decimate by up to a factor of 1/9th the hardware rate.

	 *  Correct the value if an attempt is made to stray outside that limit.

	/*

	 *  We can not capture at a rate greater than the Input Rate (48000).

	 *  Return an error if an attempt is made to stray outside that limit.

	/*

	 *  Compute the values used to drive the actual sample rate conversion.

	 *  The following formulas are being computed, using inline assembly

	 *  since we need to use 64 bit arithmetic to compute the values:

	 *

	 *     coeffIncr = -floor((Fs,out * 2^23) / Fs,in)

	 *     phiIncr = floor((Fs,in * 2^26) / Fs,out)

	 *     correctionPerGOF = floor((Fs,in * 2^26 - Fs,out * phiIncr) /

	 *                                GOF_PER_SEC)

	 *     correctionPerSec = Fs,in * 2^26 - Fs,out * phiIncr -

	 *                          GOF_PER_SEC * correctionPerGOF

	 *     initialDelay = ceil((24 * Fs,in) / Fs,out)

	 *

	 * i.e.

	 *

	 *     coeffIncr = neg(dividend((Fs,out * 2^23) / Fs,in))

	 *     phiIncr:ulOther = dividend:remainder((Fs,in * 2^26) / Fs,out)

	 *     correctionPerGOF:correctionPerSec =

	 * 	    dividend:remainder(ulOther / GOF_PER_SEC)

	 *     initialDelay = dividend(((24 * Fs,in) + Fs,out - 1) / Fs,out)

	/*

	 *  Fill in the VariDecimate control block.

	/*

	 *  Figure out the frame group length for the write back task.  Basically,

	 *  this is just the factors of 24000 (2^6*3*5^3) that are not present in

	 *  the output sample rate.

	/*

	 * Fill in the WriteBack control block.

/*

 *  PCM part

struct snd_pcm_runtime *runtime = substream->runtime;*/

 magic value to unmute PCM stream  playback volume */

 magic mute channel */

 If PCMReaderSCB and SrcTaskSCB not created yet ... */

 if sample rate is changed */

struct snd_cs46xx *chip = snd_pcm_substream_chip(substream);*/

	/* if play_back open fails, then this function

 old dsp */

 if to convert from stereo to mono */

 if to convert from 8 bit to 16 bit */

 if to convert to unsigned */

 Never convert byte order when sample stream is 8 bit */

 convert from big endian to little endian */

 playback transaction count register */

 playback format && interrupt enable */

	/*

	 *  Read the Interrupt Status Register to clear the interrupt

 old dsp */

	/*

	 *  EOI to the PCI part....reenables interrupts

|*/

SNDRV_PCM_INFO_RESUME*/ |

|*/

SNDRV_PCM_INFO_RESUME*/ |

 HACK */

 when playback_open fails, then cpcm can be NULL */

 global setup */

 global setup */

 global setup */

 global setup */

/*

 *  Mixer routines

 restore volume */

 should never happen ... */

/*

 *	Game Theatre XP card - EGPIO[0] is used to select SPDIF input optical or coaxial.

 optical is default */

 enable EGPIO0 output */

 open-drain on output */

 coaxial */

 disable */

 disable */

	/* checking diff from the EGPIO direction register 

 left and right validity bit */

 left and right validity bit */

 CONFIG_SND_CS46XX_NEW_DSP */

 Input IEC958 volume does not work for the moment. (Benny) */

 set primary cs4294 codec into Extended Audio Mode */

 Only available on the Hercules Game Theater XP soundcard */

 reset to defaults */

 set the desired CODEC mode */

 should never happen ... */

 it's necessary to wait awhile until registers are accessible after RESET */

 because the PCM or MASTER volume registers can be modified, */

 the REC_GAIN register is used for tests */

 use preliminary reads to settle the communication */

 modem? */

 test if we can write to the record gain volume register */

 detect primary codec */

 try detect a secondary codec */

 CONFIG_SND_CS46XX_NEW_DSP */

 add cs4630 mixer controls */

 get EAPD mixer switch (for voyetra hack) */

 CS4294 and CS4298 */

 do soundcard specific mixer setup */

 turn on amplifier */

/*

 *  RawMIDI interface

 fill UART FIFO buffer at first, and turn Tx interrupts only if necessary */

/*

 * gameport interface

outb(gameport->io, 0xFF);

inb(gameport->io);

 ?

 CONFIG_GAMEPORT */

/*

 *  proc interface

 !CONFIG_SND_PROC_FS */

/*

 * stop the h/w

 playback interrupt disable */

 capture interrupt disable */

	/*

         *  Stop playback DMA.

	/*

         *  Stop capture DMA.

	/*

         *  Reset the processor.

	/*

	 *  Power down the PLL.

	/*

	 *  Turn off the Processor by turning off the software clock enable flag in 

	 *  the clock control register.

 force to off */

/*

 *  initialize chip

	/* 

	 *  First, blast the clock control register to zero so that the PLL starts

         *  out in a known state, and blast the master serial port control register

         *  to zero so that the serial ports also start out in a known state.

	/*

	 *  If we are in AC97 mode, then we must set the part to a host controlled

         *  AC-link.  Otherwise, we won't be able to bring up the link.

 2.00 dual codecs */

 snd_cs46xx_pokeBA0(chip, BA0_SERACC, SERACC_HSP | SERACC_CHIP_TYPE_2_0); */ 
 1.03 codec */

        /*

         *  Drive the ARST# pin low for a minimum of 1uS (as defined in the AC97

         *  spec) and then drive it high.  This is done for non AC97 modes since

         *  there might be logic external to the CS461x that uses the ARST# line

         *  for a reset.

	/*

	 *  The first thing we do here is to enable sync generation.  As soon

	 *  as we start receiving bit clock, we'll start producing the SYNC

	 *  signal.

	/*

	 *  Now wait for a short while to allow the AC97 part to start

	 *  generating bit clock (so we don't try to start the PLL without an

	 *  input clock).

	/*

	 *  Set the serial port timing configuration, so that

	 *  the clock control circuit gets its clock from the correct place.

	/*

	 *  Write the selected clock control setup to the hardware.  Do not turn on

	 *  SWCE yet (if requested), so that the devices clocked by the output of

	 *  PLL are not clocked until the PLL is stable.

	/*

	 *  Power up the PLL.

	/*

         *  Wait until the PLL has stabilized.

	/*

	 *  Turn on clocking of the core so that we can setup the serial ports.

	/*

	 * Enable FIFO  Host Bypass

	/*

	 *  Fill the serial port FIFOs with silence.

	/*

	 *  Set the serial port FIFO pointer to the first sample in the FIFO.

 snd_cs46xx_pokeBA0(chip, BA0_SERBSP, 0); */

	/*

	 *  Write the serial port configuration to the part.  The master

	 *  enable bit is not set until all other values have been written.

	/*

	 * Wait for the codec ready signal from the AC97 codec.

		/*

		 *  Read the AC97 status register to see if we've seen a CODEC READY

		 *  signal from the AC97 codec.

 First, we want to wait for a short time. */

		/*

		 *  Make sure CODEC is READY.

	/*

	 *  Assert the vaid frame signal so that we can start sending commands

	 *  to the AC97 codec.

	/*

	 *  Wait until we've sampled input slots 3 and 4 as valid, meaning that

	 *  the codec is pumping ADC data across the AC-link.

		/*

		 *  Read the input slot valid register and see if input slots 3 and

		 *  4 are valid yet.

	/* This may happen on a cold boot with a Terratec SiXPack 5.1.

	   Reloading the driver may help, if there's other soundcards 

	/*

	 *  Now, assert valid frame and the slot 3 and 4 valid bits.  This will

	 *  commense the transfer of digital audio data to the AC97 codec.

	/*

	 *  Power down the DAC and ADC.  We will power them up (if) when we need

	 *  them.

 snd_cs46xx_pokeBA0(chip, BA0_AC97_POWERDOWN, 0x300); */

	/*

	 *  Turn off the Processor by turning off the software clock enable flag in 

	 *  the clock control register.

 tmp = snd_cs46xx_peekBA0(chip, BA0_CLKCR1) & ~CLKCR1_SWCE; */

 snd_cs46xx_pokeBA0(chip, BA0_CLKCR1, tmp); */

/*

 *  start and load DSP 

 playback interrupt enable */

 capture interrupt enable */

	/*

	 *  Reset the processor.

	/*

	 *  Download the image to the processor.

 old image */

	/*

         *  Stop playback DMA.

	/*

         *  Stop capture DMA.

 set the attenuation to 0dB */ 

/*

 *	AMP control - null AMP

	/*

	 *  See if the devices are powered down.  If so, we must power them up first

	 *  or they will not respond.

	/*

	 * Clear PRA.  The Bonzo chip will be used for GPIO not for modem

	 * stuff.

	/*

	 * Set GPIO pin's 7 and 8 so that they are configured for output.

	/*

	 * Set GPIO pin's 7 and 8 so that they are compatible with CMOS logic.

	/*

	 * Fill slots 12 with the correct value for the GPIO pins. 

		/*

		 * Initialize the fifo so that bits 7 and 8 are on.

		 *

		 * Remember that the GPIO pins in bonzo are shifted by 4 bits to

		 * the left.  0x1800 corresponds to bits 7 and 8.

		/*

		 * Wait for command to complete

		/*

		 * Write the serial port FIFO index.

		/*

		 * Tell the serial port to load the new value into the FIFO location.

 wait for last command to complete */

	/*

	 *  Now, if we powered up the devices, then power them back down again.

	 *  This is kinda ugly, but should never happen.

/*

 *	Crystal EAPD mode

	/* Manage the EAPD bit on the Crystal 4297 

 Turn the EAPD amp on */

 Turn the EAPD amp off */

 default: AMP off, and SPDIF input optical */

/*

 *	Game Theatre XP card - EGPIO[2] is used to enable the external amp.

 enable EGPIO2 output */

 open-drain on output */

 disable */

 disable */

 Enable SPDIF out */

 set EGPIO to default */

/*

 *	Untested

 Switch the GPIO pins 7 and 8 to open drain */

 Now wake the AMP (this might be backwards) */

/*

 *	Handle the CLKRUN on a thinkpad. We must disable CLKRUN support

 *	whenever we need to beat on the chip.

 *

 *	The original idea and code for this hack comes from David Kaiser at

 *	Linuxcare. Perhaps one day Crystal will document their chips well

 *	enough to make them useful.

 Read ACPI port */	

 Flip CLKRUN off while running */

/*

 * detect intel piix4

 Not a thinkpad thats for sure */

 Find the control port */		

/*

 * Card subid table

 nothing special */

 Hercules Game Theatre XP */

 Guillemot Corporation */

 Herculess Fortissimo */

 Teratec */

 Not sure if the 570 needs the clkrun hack */

 terminator */

/*

 * APM support

BA0_ASER_FADDR,*/

 chip->ac97_powerdown = snd_cs46xx_codec_read(chip, AC97_POWER_CONTROL);

 chip->ac97_general_purpose = snd_cs46xx_codec_read(chip, BA0_AC97_GENERAL_PURPOSE);

 save some registers */

 turn off amp */

 disable CLKRUN */

 restore the status */

 force to on */

 restore some registers */

	/*

         *  Stop capture DMA.

 reset playback/capture */

 turn amp on */

 disable CLKRUN */

 CONFIG_PM_SLEEP */

/*

 enable PCI device */

 set up amp and clkrun hack */

 enable CLKRUN */

 disable CLKRUN */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

/*

 * 2002-07 Benny Sjostrand benny@hostmobility.com

 unlink parent SCB */

 last and only node in parent sublist */

 first node in parent sublist */

 update next node parent ptr. */

 update next node parent ptr. */

 update parent first entry in DSP RAM */

 then update entry in DSP RAM */

 check integrety */

	/* can't remove a SCB with childs before 

 !!!! THIS IS A PIECE OF SHIT MADE BY ME !!! */

 register to proc */

 CONFIG_SND_PROC_FS */

 fill the data that will be wroten to DSP */

 update parent SCB */

 link to  parent SCB */

 update entry in DSP RAM */

 extraSampleAccum:TMreserved */

 codecFIFOptr:codecFIFOsyncd */

 fracSampAccumQm1:TMfrmsLeftInGroup */

 fracSampCorrectionQm1:TMfrmGroupLength */

 nSampPerFrmQ15 */

 COstrmRsConfig */

 COstrmBufPtr */

 leftChanBaseIOaddr:rightChanIOdisp */

 (!AC97!) COexpVolChangeRate:COscaleShiftCount */

 COreserved - need child scb to work with rom code */

 cs4620 */

 strmRsConfig */

 strmBufPtr; defined as a dword ptr, used as a byte ptr */

		channel_disp,fifo_addr,           /* (!AC97!) leftChanBaseINaddr=AC97primary 

		0x0000,0x0000,                    /* (!AC97!) ????:scaleShiftCount; no shift needed 

 ??clw cwcgame.scb has 0 */

		/*

		  Play DMA Task xfers data from host buffer to SP buffer

		  init/runtime variables:

		  PlayAC: Play Audio Data Conversion - SCB loc: 2nd dword, mask: 0x0000F000L

		  DATA_FMT_16BIT_ST_LTLEND(0x00000000L)   from 16-bit stereo, little-endian

		  DATA_FMT_8_BIT_ST_SIGNED(0x00001000L)   from 8-bit stereo, signed

		  DATA_FMT_16BIT_MN_LTLEND(0x00002000L)   from 16-bit mono, little-endian

		  DATA_FMT_8_BIT_MN_SIGNED(0x00003000L)   from 8-bit mono, signed

		  DATA_FMT_16BIT_ST_BIGEND(0x00004000L)   from 16-bit stereo, big-endian

		  DATA_FMT_16BIT_MN_BIGEND(0x00006000L)   from 16-bit mono, big-endian

		  DATA_FMT_8_BIT_ST_UNSIGNED(0x00009000L) from 8-bit stereo, unsigned

		  DATA_FMT_8_BIT_MN_UNSIGNED(0x0000b000L) from 8-bit mono, unsigned

		  ? Other combinations possible from:

		  DMA_RQ_C2_AUDIO_CONVERT_MASK    0x0000F000L

		  DMA_RQ_C2_AC_NONE               0x00000000L

		  DMA_RQ_C2_AC_8_TO_16_BIT        0x00001000L

		  DMA_RQ_C2_AC_MONO_TO_STEREO     0x00002000L

		  DMA_RQ_C2_AC_ENDIAN_CONVERT     0x00004000L

		  DMA_RQ_C2_AC_SIGNED_CONVERT     0x00008000L

        

		  HostBuffAddr: Host Buffer Physical Byte Address - SCB loc:3rd dword, Mask: 0xFFFFFFFFL

		  aligned to dword boundary

 Basic (non scatter/gather) DMA requestor (4 ints) */

 source buffer is on the host */

 source buffer is 1024 dwords (4096 bytes) */

 dest buffer(PCMreaderBuf) is 32 dwords*/

 ?? */

 ?? */

 DwordCount-1: picked 16 for DwordCount because Jim */

        Barnette said that is what we should use since */

        we are not running in optimized mode? */

 set play interrupt (bit0) in HISR when source */

   buffer (on host) crosses half-way point */

 Play DMA channel arbitrarily set to 0 */

 HostBuffAddr (source) */

 destination buffer is in SP Sample Memory */

 SP Buffer Address (destination) */

 Scatter/gather DMA requestor extension   (5 ints) */

 Sublist pointer & next stream control block (SCB) link. */

 Pointer to this tasks parameter block & stream function pointer */

 rsConfig register for stream buffer (rsDMA reg. is loaded from basicReq.daw */

   for incoming streams, or basicReq.saw, for outgoing streams) */

 enable DMA */

 MAX_DMA_SIZE picked to be 19 since SPUD  */

  uses it for some reason */

 stream number = SCBaddr/16 */

 dest buffer(PCMreaderBuf) is 32 dwords (256 bytes) */

 Stream sample pointer & MAC-unit mode for this stream */

 Fractional increment per output sample in the input sample buffer */

			/* Standard stereo volume control

	/*

	 *  Compute the values used to drive the actual sample rate conversion.

	 *  The following formulas are being computed, using inline assembly

	 *  since we need to use 64 bit arithmetic to compute the values:

	 *

	 *  phiIncr = floor((Fs,in * 2^26) / Fs,out)

	 *  correctionPerGOF = floor((Fs,in * 2^26 - Fs,out * phiIncr) /

	 *                                   GOF_PER_SEC)

	 *  ulCorrectionPerSec = Fs,in * 2^26 - Fs,out * phiIncr -M

	 *                       GOF_PER_SEC * correctionPerGOF

	 *

	 *  i.e.

	 *

	 *  phiIncr:other = dividend:remainder((Fs,in * 2^26) / Fs,out)

	 *  correctionPerGOF:correctionPerSec =

	 *      dividend:remainder(ulOther / GOF_PER_SEC)

 next_scb, sub_list_ptr */

 entry, this_spb */

 clear buffers */

			/* wont work with any other rate than

 not used */

 not used */

 0 */ { 0,

 1 */   0,

 2 */  mix_buffer_addr,

 3 */  0

   */ },

 4 */  0,

 5 */  0,

 6 */  0,

 7 */  0,

 8 */  0x00000080

 9 */ 0,0,

 A */ 0,0,

 B */ RSCONFIG_SAMPLE_16STEREO + RSCONFIG_MODULO_32,

 C */ (mix_buffer_addr  + (16 * 4)) << 0x10, 

 D */ 0,

 E */ 0x8000,0x8000,

 F */ 0x8000,0x8000

 Basic (non scatter/gather) DMA requestor (4 ints) */

 0xD */ 0,input_scb->address,

 0xE */   0x8000,0x8000,

 0xF */	  0x8000,0x8000

  Prototype sample buffer size of 256 dwords */

 Min Delta 7 dwords == 28 bytes */

 : Max delta 25 dwords == 100 bytes */

 Point to HFG task SCB */

 Initialize current Delta and Consumer ptr adjustment count */

 Initialize accumulated Phi to 0 */

 Const 1/3 */

 Define the unused elements */

 Stereo, 256 dword */

		(asynch_buffer_address) << 0x10,  /* This should be automagically synchronized

		/* There is no correct initial value, it will depend upon the detected

 Phi increment for approx 32k operation */

 Volume controls are unused at this time */

  Prototype sample buffer size of 128 dwords */

 Min Delta 7 dwords == 28 bytes */

 : Max delta 25 dwords == 100 bytes */

 Point to HFG task SCB */

 Initialize current Delta and Consumer ptr adjustment count */

 Define the unused elements */

 Stereo, 128 dword */

		( (asynch_buffer_address + (16 * 4))  << 0x10),   /* This should be automagically 

		/* There is no correct initial value, it will depend upon the detected

 Set IEC958 input volume */

 not used */

  not used.  Zero */

 not used.  Zero */

 not used */

   SPIOWAddress2:SPIOWAddress1; */

   SPIOWData1; */

   SPIOWData2; */

   SPIOWAddress4:SPIOWAddress3; */

   SPIOWData3; */

   SPIOWData4; */

   SPIOWDataPtr:Unused1; */

   Unused2[2]; */

   SPIOWChildPtr:SPIOWSiblingPtr; */

   SPIOWThisPtr:SPIOWEntryPoint; */

   Unused3[5];  */

 0 */ 0, 
 1 */ 0, 
 2 */ snoop_buffer_address << 0x10,

 3 */ 0,snoop_scb->address,

 4 */ 0, 
 5 */ 0, 
 6 */ 0, 
 7 */ 0, 
 8 */ 0, 
 9 */ 0,0, 
 A */ 0,0, 
 B */ RSCONFIG_SAMPLE_16STEREO + RSCONFIG_MODULO_64,

 C */ snoop_buffer_address  << 0x10,

 D */ 0,

 E */ { 0x8000,0x8000,

 F */   0xffff,0xffff

 1 */

 2 */

 3 */

 4 */

 5 */

 6 */

 7 */

 8 */

 9 */

 10 */

 11 */

 12 */

 13 */

 14 */

 15 */

 16 */

 17 */

 18 */

 19 */

 20 */

 21 */

 22 */

 23 */

 24 */

 25 */

 26 */

 27 */

 28 */

 29 */

 30 */

 31 */

 32 */

 struct dsp_scb_descriptor * pcm_parent_scb; */

 TODO */

		/* if sample rate is set to 48khz we pass

		   the Sample Rate Converted (which could

 Hack to bypass creating a new SRC */

 default sample rate is 44100 */

 search for a already created SRC SCB with the same sample rate */

		/* virtual channel reserved 

 find a free slot */

 we need to create a new SRC SCB */

 0x400 - 0x600 source SCBs */

 cs46xx_dsp_set_src_sample_rate(chip,src_scb,sample_rate); */

 0x200 - 400 PCMreader SCBs */

 virtual channel 0-31 */

 pcm hw addr */

 parent SCB ptr */

 insert point */ 

 update SCB entry in DSP RAM */

 update parent SCB entry */

 mute SCB */

 update entry in DSP RAM */

 dont touch anything if SPDIF is open */

		/* when cs46xx_iec958_post_close(...) is called it

		   will call this function if necessary depending on

 reset output snooper sample buffer pointer */

 The asynch. transfer task */

 monitor state */

 dont touch anything if SPDIF is open */

 check integrety */

 clear buffer to prevent any undesired noise */

 monitor state */

 remove AsynchFGTxSCB and PCMSerialInput_II */

 save state */

 if not enabled already */

 Create the asynch. transfer task  for playback */

 set spdif channel status value for streaming */

 restore settings */

 deallocate stuff */

 clear buffer to prevent any undesired noise */

 restore state */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

/*

 * 2002-07 Benny Sjostrand benny@hostmobility.com

 check for wide type instruction */

 need to reallocate instruction */

 wide_opcodes[j] == wide_op */

 for */

 mod_type == 0 ... */

 ins->code.offset > 0 */

				module->symbol_table.symbols[i].symbol_name); */

#endif

		}

	}



	return 0;

}



static struct dsp_symbol_entry *

add_symbol (struct snd_cs46xx * chip, char * symbol_name, u32 address, int type)

{

	struct dsp_spos_instance * ins = chip->dsp_spos_instance;

	struct dsp_symbol_entry * symbol = NULL;

	int index;



	if (ins->symbol_table.nsymbols == (DSP_MAX_SYMBOLS - 1)) {

		dev_err(chip->card->dev, "dsp_spos: symbol table is full\n");

		return NULL;

	}

  

	if (cs46xx_dsp_lookup_symbol(chip,

				     symbol_name,

				     type) != NULL) {

		dev_err(chip->card->dev,

			"dsp_spos: symbol <%s> duplicated\n", symbol_name);

		return NULL;

	}



	index = find_free_symbol_index (ins);



	strcpy (ins->symbol_table.symbols[index].symbol_name, symbol_name);

	ins->symbol_table.symbols[index].address = address;

	ins->symbol_table.symbols[index].symbol_type = type;

	ins->symbol_table.symbols[index].module = NULL;

	ins->symbol_table.symbols[index].deleted = 0;

	symbol = (ins->symbol_table.symbols + index);



	if (index > ins->symbol_table.highest_frag_index) 

		ins->symbol_table.highest_frag_index = index;



	if (index == ins->symbol_table.nsymbols)

		ins->symbol_table.nsymbols++; /* no frag. in list */



	return symbol;

}



struct dsp_spos_instance *cs46xx_dsp_spos_create (struct snd_cs46xx * chip)

{

	struct dsp_spos_instance * ins = kzalloc(sizeof(struct dsp_spos_instance), GFP_KERNEL);



	if (ins == NULL)

		return NULL;



	/* better to use vmalloc for this big table */

	ins->symbol_table.symbols =

		vmalloc(array_size(DSP_MAX_SYMBOLS,

				   sizeof(struct dsp_symbol_entry)));

	ins->code.data = kmalloc(DSP_CODE_BYTE_SIZE, GFP_KERNEL);

	ins->modules = kmalloc_array(DSP_MAX_MODULES,

				     sizeof(struct dsp_module_desc),

				     GFP_KERNEL);

	if (!ins->symbol_table.symbols || !ins->code.data || !ins->modules) {

		cs46xx_dsp_spos_destroy(chip);

		goto error;

	}

	ins->symbol_table.nsymbols = 0;

	ins->symbol_table.highest_frag_index = 0;

	ins->code.offset = 0;

	ins->code.size = 0;

	ins->nscb = 0;

	ins->ntask = 0;

	ins->nmodules = 0;



 default SPDIF input sample rate

	   to 48000 khz */

	ins->spdif_in_sample_rate = 48000;



	/* maximize volume */

	ins->dac_volume_right = 0x8000;

	ins->dac_volume_left = 0x8000;

	ins->spdif_input_volume_right = 0x8000;

	ins->spdif_input_volume_left = 0x8000;



 set left and right validity bits and

	   default channel status */

	ins->spdif_csuv_default =

		ins->spdif_csuv_stream =

	 /* byte 0 */  ((unsigned int)_wrap_all_bits(  (SNDRV_PCM_DEFAULT_CON_SPDIF        & 0xff)) << 24) |

	 /* byte 1 */  ((unsigned int)_wrap_all_bits( ((SNDRV_PCM_DEFAULT_CON_SPDIF >> 8) & 0xff)) << 16) |

	 /* byte 3 */   (unsigned int)_wrap_all_bits(  (SNDRV_PCM_DEFAULT_CON_SPDIF >> 24) & 0xff) |

	 /* left and right validity bits */ (1 << 13) | (1 << 12);



	return ins;



error:

	kfree(ins->modules);

	kfree(ins->code.data);

	vfree(ins->symbol_table.symbols);

	kfree(ins);

	return NULL;

}



void  cs46xx_dsp_spos_destroy (struct snd_cs46xx * chip)

{

	int i;

	struct dsp_spos_instance * ins = chip->dsp_spos_instance;



	if (snd_BUG_ON(!ins))

		return;



	mutex_lock(&chip->spos_mutex);

	for (i = 0; i < ins->nscb; ++i) {

		if (ins->scbs[i].deleted) continue;



		cs46xx_dsp_proc_free_scb_desc ( (ins->scbs + i) );

#ifdef CONFIG_PM_SLEEP

		kfree(ins->scbs[i].data);

#endif

	}



	kfree(ins->code.data);

	vfree(ins->symbol_table.symbols);

	kfree(ins->modules);

	kfree(ins);

	mutex_unlock(&chip->spos_mutex);

}



static int dsp_load_parameter(struct snd_cs46xx *chip,

			      struct dsp_segment_desc *parameter)

{

	u32 doffset, dsize;



	if (!parameter) {

		dev_dbg(chip->card->dev,

			"dsp_spos: module got no parameter segment\n");

		return 0;

	}



	doffset = (parameter->offset * 4 + DSP_PARAMETER_BYTE_OFFSET);

	dsize   = parameter->size * 4;



	dev_dbg(chip->card->dev,

		"dsp_spos: downloading parameter data to chip (%08x-%08x)\n",

		    doffset,doffset + dsize);

	if (snd_cs46xx_download (chip, parameter->data, doffset, dsize)) {

		dev_err(chip->card->dev,

			"dsp_spos: failed to download parameter data to DSP\n");

		return -EINVAL;

	}

	return 0;

}



static int dsp_load_sample(struct snd_cs46xx *chip,

			   struct dsp_segment_desc *sample)

{

	u32 doffset, dsize;



	if (!sample) {

		dev_dbg(chip->card->dev,

			"dsp_spos: module got no sample segment\n");

		return 0;

	}



	doffset = (sample->offset * 4  + DSP_SAMPLE_BYTE_OFFSET);

	dsize   =  sample->size * 4;



	dev_dbg(chip->card->dev,

		"dsp_spos: downloading sample data to chip (%08x-%08x)\n",

		    doffset,doffset + dsize);



	if (snd_cs46xx_download (chip,sample->data,doffset,dsize)) {

		dev_err(chip->card->dev,

			"dsp_spos: failed to sample data to DSP\n");

		return -EINVAL;

	}

	return 0;

}



int cs46xx_dsp_load_module (struct snd_cs46xx * chip, struct dsp_module_desc * module)

{

	struct dsp_spos_instance * ins = chip->dsp_spos_instance;

	struct dsp_segment_desc * code = get_segment_desc (module,SEGTYPE_SP_PROGRAM);

	u32 doffset, dsize;

	int err;



	if (ins->nmodules == DSP_MAX_MODULES - 1) {

		dev_err(chip->card->dev,

			"dsp_spos: to many modules loaded into DSP\n");

		return -ENOMEM;

	}



	dev_dbg(chip->card->dev,

		"dsp_spos: loading module %s into DSP\n", module->module_name);

  

	if (ins->nmodules == 0) {

		dev_dbg(chip->card->dev, "dsp_spos: clearing parameter area\n");

		snd_cs46xx_clear_BA1(chip, DSP_PARAMETER_BYTE_OFFSET, DSP_PARAMETER_BYTE_SIZE);

	}

  

	err = dsp_load_parameter(chip, get_segment_desc(module,

							SEGTYPE_SP_PARAMETER));

	if (err < 0)

		return err;



	if (ins->nmodules == 0) {

		dev_dbg(chip->card->dev, "dsp_spos: clearing sample area\n");

		snd_cs46xx_clear_BA1(chip, DSP_SAMPLE_BYTE_OFFSET, DSP_SAMPLE_BYTE_SIZE);

	}



	err = dsp_load_sample(chip, get_segment_desc(module,

						     SEGTYPE_SP_SAMPLE));

	if (err < 0)

		return err;



	if (ins->nmodules == 0) {

		dev_dbg(chip->card->dev, "dsp_spos: clearing code area\n");

		snd_cs46xx_clear_BA1(chip, DSP_CODE_BYTE_OFFSET, DSP_CODE_BYTE_SIZE);

	}



	if (code == NULL) {

		dev_dbg(chip->card->dev,

			"dsp_spos: module got no code segment\n");

	} else {

		if (ins->code.offset + code->size > DSP_CODE_BYTE_SIZE) {

			dev_err(chip->card->dev,

				"dsp_spos: no space available in DSP\n");

			return -ENOMEM;

		}



		module->load_address = ins->code.offset;

		module->overlay_begin_address = 0x000;



 if module has a code segment it must have

		   symbol table */

		if (snd_BUG_ON(!module->symbol_table.symbols))

			return -ENOMEM;

		if (add_symbols(chip,module)) {

			dev_err(chip->card->dev,

				"dsp_spos: failed to load symbol table\n");

			return -ENOMEM;

		}

    

		doffset = (code->offset * 4 + ins->code.offset * 4 + DSP_CODE_BYTE_OFFSET);

		dsize   = code->size * 4;

		dev_dbg(chip->card->dev,

			"dsp_spos: downloading code to chip (%08x-%08x)\n",

			    doffset,doffset + dsize);   



		module->nfixups = shadow_and_reallocate_code(chip,code->data,code->size,module->overlay_begin_address);



		if (snd_cs46xx_download (chip,(ins->code.data + ins->code.offset),doffset,dsize)) {

			dev_err(chip->card->dev,

				"dsp_spos: failed to download code to DSP\n");

			return -EINVAL;

		}



		ins->code.offset += code->size;

	}



 NOTE: module segments and symbol table must be

	   not generated by the ospparser */

	ins->modules[ins->nmodules] = *module;

	ins->nmodules++;



	return 0;

}



struct dsp_symbol_entry *

cs46xx_dsp_lookup_symbol (struct snd_cs46xx * chip, char * symbol_name, int symbol_type)

{

	int i;

	struct dsp_spos_instance * ins = chip->dsp_spos_instance;



	for ( i = 0; i < ins->symbol_table.nsymbols; ++i ) {



		if (ins->symbol_table.symbols[i].deleted)

			continue;



		if (!strcmp(ins->symbol_table.symbols[i].symbol_name,symbol_name) &&

		    ins->symbol_table.symbols[i].symbol_type == symbol_type) {

			return (ins->symbol_table.symbols + i);

		}

	}



#if 0

	dev_err(chip->card->dev, "dsp_spos: symbol <%s> type %02x not found\n",

		symbol_name,symbol_type);

#endif



	return NULL;

}





#ifdef CONFIG_SND_PROC_FS

static struct dsp_symbol_entry *

cs46xx_dsp_lookup_symbol_addr (struct snd_cs46xx * chip, u32 address, int symbol_type)

{

	int i;

	struct dsp_spos_instance * ins = chip->dsp_spos_instance;



	for ( i = 0; i < ins->symbol_table.nsymbols; ++i ) {



		if (ins->symbol_table.symbols[i].deleted)

			continue;



		if (ins->symbol_table.symbols[i].address == address &&

		    ins->symbol_table.symbols[i].symbol_type == symbol_type) {

			return (ins->symbol_table.symbols + i);

		}

	}





	return NULL;

}





static void cs46xx_dsp_proc_symbol_table_read (struct snd_info_entry *entry,

					       struct snd_info_buffer *buffer)

{

	struct snd_cs46xx *chip = entry->private_data;

	struct dsp_spos_instance * ins = chip->dsp_spos_instance;

	int i;



	snd_iprintf(buffer, "SYMBOLS:\n");

	for ( i = 0; i < ins->symbol_table.nsymbols; ++i ) {

		char *module_str = "system";



		if (ins->symbol_table.symbols[i].deleted)

			continue;



		if (ins->symbol_table.symbols[i].module != NULL) {

			module_str = ins->symbol_table.symbols[i].module->module_name;

		}



    

		snd_iprintf(buffer, "%04X <%02X> %s [%s]\n",

			    ins->symbol_table.symbols[i].address,

			    ins->symbol_table.symbols[i].symbol_type,

			    ins->symbol_table.symbols[i].symbol_name,

			    module_str);    

	}

}





static void cs46xx_dsp_proc_modules_read (struct snd_info_entry *entry,

					  struct snd_info_buffer *buffer)

{

	struct snd_cs46xx *chip = entry->private_data;

	struct dsp_spos_instance * ins = chip->dsp_spos_instance;

	int i,j;



	mutex_lock(&chip->spos_mutex);

	snd_iprintf(buffer, "MODULES:\n");

	for ( i = 0; i < ins->nmodules; ++i ) {

		snd_iprintf(buffer, "\n%s:\n", ins->modules[i].module_name);

		snd_iprintf(buffer, "   %d symbols\n", ins->modules[i].symbol_table.nsymbols);

		snd_iprintf(buffer, "   %d fixups\n", ins->modules[i].nfixups);



		for (j = 0; j < ins->modules[i].nsegments; ++ j) {

			struct dsp_segment_desc * desc = (ins->modules[i].segments + j);

			snd_iprintf(buffer, "   segment %02x offset %08x size %08x\n",

				    desc->segment_type,desc->offset, desc->size);

		}

	}

	mutex_unlock(&chip->spos_mutex);

}



static void cs46xx_dsp_proc_task_tree_read (struct snd_info_entry *entry,

					    struct snd_info_buffer *buffer)

{

	struct snd_cs46xx *chip = entry->private_data;

	struct dsp_spos_instance * ins = chip->dsp_spos_instance;

	int i, j, col;

	void __iomem *dst = chip->region.idx[1].remap_addr + DSP_PARAMETER_BYTE_OFFSET;



	mutex_lock(&chip->spos_mutex);

	snd_iprintf(buffer, "TASK TREES:\n");

	for ( i = 0; i < ins->ntask; ++i) {

		snd_iprintf(buffer,"\n%04x %s:\n",ins->tasks[i].address,ins->tasks[i].task_name);



		for (col = 0,j = 0;j < ins->tasks[i].size; j++,col++) {

			u32 val;

			if (col == 4) {

				snd_iprintf(buffer,"\n");

				col = 0;

			}

			val = readl(dst + (ins->tasks[i].address + j) * sizeof(u32));

			snd_iprintf(buffer,"%08x ",val);

		}

	}



	snd_iprintf(buffer,"\n");  

	mutex_unlock(&chip->spos_mutex);

}



static void cs46xx_dsp_proc_scb_read (struct snd_info_entry *entry,

				      struct snd_info_buffer *buffer)

{

	struct snd_cs46xx *chip = entry->private_data;

	struct dsp_spos_instance * ins = chip->dsp_spos_instance;

	int i;



	mutex_lock(&chip->spos_mutex);

	snd_iprintf(buffer, "SCB's:\n");

	for ( i = 0; i < ins->nscb; ++i) {

		if (ins->scbs[i].deleted)

			continue;

		snd_iprintf(buffer,"\n%04x %s:\n\n",ins->scbs[i].address,ins->scbs[i].scb_name);



		if (ins->scbs[i].parent_scb_ptr != NULL) {

			snd_iprintf(buffer,"parent [%s:%04x] ", 

				    ins->scbs[i].parent_scb_ptr->scb_name,

				    ins->scbs[i].parent_scb_ptr->address);

		} else snd_iprintf(buffer,"parent [none] ");



		snd_iprintf(buffer,"sub_list_ptr [%s:%04x]\nnext_scb_ptr [%s:%04x]  task_entry [%s:%04x]\n",

			    ins->scbs[i].sub_list_ptr->scb_name,

			    ins->scbs[i].sub_list_ptr->address,

			    ins->scbs[i].next_scb_ptr->scb_name,

			    ins->scbs[i].next_scb_ptr->address,

			    ins->scbs[i].task_entry->symbol_name,

			    ins->scbs[i].task_entry->address);

	}



	snd_iprintf(buffer,"\n");

	mutex_unlock(&chip->spos_mutex);

}



static void cs46xx_dsp_proc_parameter_dump_read (struct snd_info_entry *entry,

						 struct snd_info_buffer *buffer)

{

	struct snd_cs46xx *chip = entry->private_data;

	/*struct dsp_spos_instance * ins = chip->dsp_spos_instance; */

	unsigned int i, col = 0;

	void __iomem *dst = chip->region.idx[1].remap_addr + DSP_PARAMETER_BYTE_OFFSET;

	struct dsp_symbol_entry * symbol; 



	for (i = 0;i < DSP_PARAMETER_BYTE_SIZE; i += sizeof(u32),col ++) {

		if (col == 4) {

			snd_iprintf(buffer,"\n");

			col = 0;

		}



		symbol = cs46xx_dsp_lookup_symbol_addr(chip, i / sizeof(u32), SYMBOL_PARAMETER);

		if (symbol) {

			col = 0;

			snd_iprintf (buffer,"\n%s:\n",symbol->symbol_name);

		}



		if (col == 0) {

			snd_iprintf(buffer, "%04X ", i / (unsigned int)sizeof(u32));

		}



		snd_iprintf(buffer,"%08X ",readl(dst + i));

	}

}



static void cs46xx_dsp_proc_sample_dump_read (struct snd_info_entry *entry,

					      struct snd_info_buffer *buffer)

{

	struct snd_cs46xx *chip = entry->private_data;

	int i,col = 0;

	void __iomem *dst = chip->region.idx[2].remap_addr;



	snd_iprintf(buffer,"PCMREADER:\n");

	for (i = PCM_READER_BUF1;i < PCM_READER_BUF1 + 0x30; i += sizeof(u32),col ++) {

		if (col == 4) {

			snd_iprintf(buffer,"\n");

			col = 0;

		}



		if (col == 0) {

			snd_iprintf(buffer, "%04X ",i);

		}



		snd_iprintf(buffer,"%08X ",readl(dst + i));

	}



	snd_iprintf(buffer,"\nMIX_SAMPLE_BUF1:\n");



	col = 0;

	for (i = MIX_SAMPLE_BUF1;i < MIX_SAMPLE_BUF1 + 0x40; i += sizeof(u32),col ++) {

		if (col == 4) {

			snd_iprintf(buffer,"\n");

			col = 0;

		}



		if (col == 0) {

			snd_iprintf(buffer, "%04X ",i);

		}



		snd_iprintf(buffer,"%08X ",readl(dst + i));

	}



	snd_iprintf(buffer,"\nSRC_TASK_SCB1:\n");

	col = 0;

	for (i = 0x2480 ; i < 0x2480 + 0x40 ; i += sizeof(u32),col ++) {

		if (col == 4) {

			snd_iprintf(buffer,"\n");

			col = 0;

		}

		

		if (col == 0) {

			snd_iprintf(buffer, "%04X ",i);

		}



		snd_iprintf(buffer,"%08X ",readl(dst + i));

	}





	snd_iprintf(buffer,"\nSPDIFO_BUFFER:\n");

	col = 0;

	for (i = SPDIFO_IP_OUTPUT_BUFFER1;i < SPDIFO_IP_OUTPUT_BUFFER1 + 0x30; i += sizeof(u32),col ++) {

		if (col == 4) {

			snd_iprintf(buffer,"\n");

			col = 0;

		}



		if (col == 0) {

			snd_iprintf(buffer, "%04X ",i);

		}



		snd_iprintf(buffer,"%08X ",readl(dst + i));

	}



	snd_iprintf(buffer,"\n...\n");

	col = 0;



	for (i = SPDIFO_IP_OUTPUT_BUFFER1+0xD0;i < SPDIFO_IP_OUTPUT_BUFFER1 + 0x110; i += sizeof(u32),col ++) {

		if (col == 4) {

			snd_iprintf(buffer,"\n");

			col = 0;

		}



		if (col == 0) {

			snd_iprintf(buffer, "%04X ",i);

		}



		snd_iprintf(buffer,"%08X ",readl(dst + i));

	}





	snd_iprintf(buffer,"\nOUTPUT_SNOOP:\n");

	col = 0;

	for (i = OUTPUT_SNOOP_BUFFER;i < OUTPUT_SNOOP_BUFFER + 0x40; i += sizeof(u32),col ++) {

		if (col == 4) {

			snd_iprintf(buffer,"\n");

			col = 0;

		}



		if (col == 0) {

			snd_iprintf(buffer, "%04X ",i);

		}



		snd_iprintf(buffer,"%08X ",readl(dst + i));

	}



	snd_iprintf(buffer,"\nCODEC_INPUT_BUF1: \n");

	col = 0;

	for (i = CODEC_INPUT_BUF1;i < CODEC_INPUT_BUF1 + 0x40; i += sizeof(u32),col ++) {

		if (col == 4) {

			snd_iprintf(buffer,"\n");

			col = 0;

		}



		if (col == 0) {

			snd_iprintf(buffer, "%04X ",i);

		}



		snd_iprintf(buffer,"%08X ",readl(dst + i));

	}

#if 0

	snd_iprintf(buffer,"\nWRITE_BACK_BUF1: \n");

	col = 0;

	for (i = WRITE_BACK_BUF1;i < WRITE_BACK_BUF1 + 0x40; i += sizeof(u32),col ++) {

		if (col == 4) {

			snd_iprintf(buffer,"\n");

			col = 0;

		}



		if (col == 0) {

			snd_iprintf(buffer, "%04X ",i);

		}



		snd_iprintf(buffer,"%08X ",readl(dst + i));

	}

#endif



	snd_iprintf(buffer,"\nSPDIFI_IP_OUTPUT_BUFFER1: \n");

	col = 0;

	for (i = SPDIFI_IP_OUTPUT_BUFFER1;i < SPDIFI_IP_OUTPUT_BUFFER1 + 0x80; i += sizeof(u32),col ++) {

		if (col == 4) {

			snd_iprintf(buffer,"\n");

			col = 0;

		}



		if (col == 0) {

			snd_iprintf(buffer, "%04X ",i);

		}

		

		snd_iprintf(buffer,"%08X ",readl(dst + i));

	}

	snd_iprintf(buffer,"\n");

}



int cs46xx_dsp_proc_init (struct snd_card *card, struct snd_cs46xx *chip)

{

	struct snd_info_entry *entry;

	struct dsp_spos_instance * ins = chip->dsp_spos_instance;

	int i;



	ins->snd_card = card;



	entry = snd_info_create_card_entry(card, "dsp", card->proc_root);

	if (entry)

		entry->mode = S_IFDIR | 0555;

	ins->proc_dsp_dir = entry;



	if (!ins->proc_dsp_dir)

		return -ENOMEM;



	entry = snd_info_create_card_entry(card, "spos_symbols",

					   ins->proc_dsp_dir);

	if (entry)

		snd_info_set_text_ops(entry, chip,

				      cs46xx_dsp_proc_symbol_table_read);

    

	entry = snd_info_create_card_entry(card, "spos_modules",

					   ins->proc_dsp_dir);

	if (entry)

		snd_info_set_text_ops(entry, chip,

				      cs46xx_dsp_proc_modules_read);



	entry = snd_info_create_card_entry(card, "parameter",

					   ins->proc_dsp_dir);

	if (entry)

		snd_info_set_text_ops(entry, chip,

				      cs46xx_dsp_proc_parameter_dump_read);



	entry = snd_info_create_card_entry(card, "sample",

					   ins->proc_dsp_dir);

	if (entry)

		snd_info_set_text_ops(entry, chip,

				      cs46xx_dsp_proc_sample_dump_read);



	entry = snd_info_create_card_entry(card, "task_tree",

					   ins->proc_dsp_dir);

	if (entry)

		snd_info_set_text_ops(entry, chip,

				      cs46xx_dsp_proc_task_tree_read);



	entry = snd_info_create_card_entry(card, "scb_info",

					   ins->proc_dsp_dir);

	if (entry)

		snd_info_set_text_ops(entry, chip,

				      cs46xx_dsp_proc_scb_read);



	mutex_lock(&chip->spos_mutex);

	/* register/update SCB's entries on proc */

	for (i = 0; i < ins->nscb; ++i) {

		if (ins->scbs[i].deleted) continue;



		cs46xx_dsp_proc_register_scb_desc (chip, (ins->scbs + i));

	}

	mutex_unlock(&chip->spos_mutex);



	return 0;

}



int cs46xx_dsp_proc_done (struct snd_cs46xx *chip)

{

	struct dsp_spos_instance * ins = chip->dsp_spos_instance;

	int i;



	if (!ins)

		return 0;



	mutex_lock(&chip->spos_mutex);

	for (i = 0; i < ins->nscb; ++i) {

		if (ins->scbs[i].deleted) continue;

		cs46xx_dsp_proc_free_scb_desc ( (ins->scbs + i) );

	}

	mutex_unlock(&chip->spos_mutex);



	snd_info_free_entry(ins->proc_dsp_dir);

	ins->proc_dsp_dir = NULL;



	return 0;

}

#endif /* CONFIG_SND_PROC_FS */



static void _dsp_create_task_tree (struct snd_cs46xx *chip, u32 * task_data,

				   u32  dest, int size)

{

	void __iomem *spdst = chip->region.idx[1].remap_addr + 

		DSP_PARAMETER_BYTE_OFFSET + dest * sizeof(u32);

	int i;



	for (i = 0; i < size; ++i) {

		dev_dbg(chip->card->dev, "addr %p, val %08x\n",

			spdst, task_data[i]);

		writel(task_data[i],spdst);

		spdst += sizeof(u32);

	}

}



static void _dsp_create_scb (struct snd_cs46xx *chip, u32 * scb_data, u32 dest)

{

	void __iomem *spdst = chip->region.idx[1].remap_addr + 

		DSP_PARAMETER_BYTE_OFFSET + dest * sizeof(u32);

	int i;



	for (i = 0; i < 0x10; ++i) {

		dev_dbg(chip->card->dev, "addr %p, val %08x\n",

			spdst, scb_data[i]);

		writel(scb_data[i],spdst);

		spdst += sizeof(u32);

	}

}



static int find_free_scb_index (struct dsp_spos_instance * ins)

{

	int index = ins->nscb, i;



	for (i = ins->scb_highest_frag_index; i < ins->nscb; ++i) {

		if (ins->scbs[i].deleted) {

			index = i;

			break;

		}

	}



	return index;

}



static struct dsp_scb_descriptor * _map_scb (struct snd_cs46xx *chip, char * name, u32 dest)

{

	struct dsp_spos_instance * ins = chip->dsp_spos_instance;

	struct dsp_scb_descriptor * desc = NULL;

	int index;



	if (ins->nscb == DSP_MAX_SCB_DESC - 1) {

		dev_err(chip->card->dev,

			"dsp_spos: got no place for other SCB\n");

		return NULL;

	}



	index = find_free_scb_index (ins);



	memset(&ins->scbs[index], 0, sizeof(ins->scbs[index]));

	strcpy(ins->scbs[index].scb_name, name);

	ins->scbs[index].address = dest;

	ins->scbs[index].index = index;

	ins->scbs[index].ref_count = 1;



	desc = (ins->scbs + index);

	ins->scbs[index].scb_symbol = add_symbol (chip, name, dest, SYMBOL_PARAMETER);



	if (index > ins->scb_highest_frag_index)

		ins->scb_highest_frag_index = index;



	if (index == ins->nscb)

		ins->nscb++;



	return desc;

}



static struct dsp_task_descriptor *

_map_task_tree (struct snd_cs46xx *chip, char * name, u32 dest, u32 size)

{

	struct dsp_spos_instance * ins = chip->dsp_spos_instance;

	struct dsp_task_descriptor * desc = NULL;



	if (ins->ntask == DSP_MAX_TASK_DESC - 1) {

		dev_err(chip->card->dev,

			"dsp_spos: got no place for other TASK\n");

		return NULL;

	}



	if (name)

		strcpy(ins->tasks[ins->ntask].task_name, name);

	else

		strcpy(ins->tasks[ins->ntask].task_name, "(NULL)");

	ins->tasks[ins->ntask].address = dest;

	ins->tasks[ins->ntask].size = size;



	/* quick find in list */

	ins->tasks[ins->ntask].index = ins->ntask;

	desc = (ins->tasks + ins->ntask);

	ins->ntask++;



	if (name)

		add_symbol (chip,name,dest,SYMBOL_PARAMETER);

	return desc;

}



#define SCB_BYTES	(0x10 * 4)



struct dsp_scb_descriptor *

cs46xx_dsp_create_scb (struct snd_cs46xx *chip, char * name, u32 * scb_data, u32 dest)

{

	struct dsp_scb_descriptor * desc;



#ifdef CONFIG_PM_SLEEP

	/* copy the data for resume */

	scb_data = kmemdup(scb_data, SCB_BYTES, GFP_KERNEL);

	if (!scb_data)

		return NULL;

#endif



	desc = _map_scb (chip,name,dest);

	if (desc) {

		desc->data = scb_data;

		_dsp_create_scb(chip,scb_data,dest);

	} else {

		dev_err(chip->card->dev, "dsp_spos: failed to map SCB\n");

#ifdef CONFIG_PM_SLEEP

		kfree(scb_data);

#endif

	}



	return desc;

}





static struct dsp_task_descriptor *

cs46xx_dsp_create_task_tree (struct snd_cs46xx *chip, char * name, u32 * task_data,

			     u32 dest, int size)

{

	struct dsp_task_descriptor * desc;



	desc = _map_task_tree (chip,name,dest,size);

	if (desc) {

		desc->data = task_data;

		_dsp_create_task_tree(chip,task_data,dest,size);

	} else {

		dev_err(chip->card->dev, "dsp_spos: failed to map TASK\n");

	}



	return desc;

}



int cs46xx_dsp_scb_and_task_init (struct snd_cs46xx *chip)

{

	struct dsp_spos_instance * ins = chip->dsp_spos_instance;

	struct dsp_symbol_entry * fg_task_tree_header_code;

	struct dsp_symbol_entry * task_tree_header_code;

	struct dsp_symbol_entry * task_tree_thread;

	struct dsp_symbol_entry * null_algorithm;

	struct dsp_symbol_entry * magic_snoop_task;



	struct dsp_scb_descriptor * timing_master_scb;

	struct dsp_scb_descriptor * codec_out_scb;

	struct dsp_scb_descriptor * codec_in_scb;

	struct dsp_scb_descriptor * src_task_scb;

	struct dsp_scb_descriptor * master_mix_scb;

	struct dsp_scb_descriptor * rear_mix_scb;

	struct dsp_scb_descriptor * record_mix_scb;

	struct dsp_scb_descriptor * write_back_scb;

	struct dsp_scb_descriptor * vari_decimate_scb;

	struct dsp_scb_descriptor * rear_codec_out_scb;

	struct dsp_scb_descriptor * clfe_codec_out_scb;

	struct dsp_scb_descriptor * magic_snoop_scb;

	

	int fifo_addr, fifo_span, valid_slots;



	static const struct dsp_spos_control_block sposcb = {

		/* 0 */ HFG_TREE_SCB,HFG_STACK,

		/* 1 */ SPOSCB_ADDR,BG_TREE_SCB_ADDR,

		/* 2 */ DSP_SPOS_DC,0,

		/* 3 */ DSP_SPOS_DC,DSP_SPOS_DC,

		/* 4 */ 0,0,

		/* 5 */ DSP_SPOS_UU,0,

		/* 6 */ FG_TASK_HEADER_ADDR,0,

		/* 7 */ 0,0,

		/* 8 */ DSP_SPOS_UU,DSP_SPOS_DC,

		/* 9 */ 0,

		/* A */ 0,HFG_FIRST_EXECUTE_MODE,

		/* B */ DSP_SPOS_UU,DSP_SPOS_UU,

		/* C */ DSP_SPOS_DC_DC,

		/* D */ DSP_SPOS_DC_DC,

		/* E */ DSP_SPOS_DC_DC,

		/* F */ DSP_SPOS_DC_DC

	};



	cs46xx_dsp_create_task_tree(chip, "sposCB", (u32 *)&sposcb, SPOSCB_ADDR, 0x10);



	null_algorithm  = cs46xx_dsp_lookup_symbol(chip, "NULLALGORITHM", SYMBOL_CODE);

	if (null_algorithm == NULL) {

		dev_err(chip->card->dev,

			"dsp_spos: symbol NULLALGORITHM not found\n");

		return -EIO;

	}



	fg_task_tree_header_code = cs46xx_dsp_lookup_symbol(chip, "FGTASKTREEHEADERCODE", SYMBOL_CODE);  

	if (fg_task_tree_header_code == NULL) {

		dev_err(chip->card->dev,

			"dsp_spos: symbol FGTASKTREEHEADERCODE not found\n");

		return -EIO;

	}



	task_tree_header_code = cs46xx_dsp_lookup_symbol(chip, "TASKTREEHEADERCODE", SYMBOL_CODE);  

	if (task_tree_header_code == NULL) {

		dev_err(chip->card->dev,

			"dsp_spos: symbol TASKTREEHEADERCODE not found\n");

		return -EIO;

	}

  

	task_tree_thread = cs46xx_dsp_lookup_symbol(chip, "TASKTREETHREAD", SYMBOL_CODE);

	if (task_tree_thread == NULL) {

		dev_err(chip->card->dev,

			"dsp_spos: symbol TASKTREETHREAD not found\n");

		return -EIO;

	}



	magic_snoop_task = cs46xx_dsp_lookup_symbol(chip, "MAGICSNOOPTASK", SYMBOL_CODE);

	if (magic_snoop_task == NULL) {

		dev_err(chip->card->dev,

			"dsp_spos: symbol MAGICSNOOPTASK not found\n");

		return -EIO;

	}

  

	{

		/* create the null SCB */

		static struct dsp_generic_scb null_scb = {

			{ 0, 0, 0, 0 },

			{ 0, 0, 0, 0, 0 },

			NULL_SCB_ADDR, NULL_SCB_ADDR,

			0, 0, 0, 0, 0,

			{

				0,0,

				0,0,

			}

		};



		null_scb.entry_point = null_algorithm->address;

		ins->the_null_scb = cs46xx_dsp_create_scb(chip, "nullSCB", (u32 *)&null_scb, NULL_SCB_ADDR);

		ins->the_null_scb->task_entry = null_algorithm;

		ins->the_null_scb->sub_list_ptr = ins->the_null_scb;

		ins->the_null_scb->next_scb_ptr = ins->the_null_scb;

		ins->the_null_scb->parent_scb_ptr = NULL;

		cs46xx_dsp_proc_register_scb_desc (chip,ins->the_null_scb);

	}



	{

		/* setup foreground task tree */

		static struct dsp_task_tree_control_block fg_task_tree_hdr =  {

			{ FG_TASK_HEADER_ADDR | (DSP_SPOS_DC << 0x10),

			  DSP_SPOS_DC_DC,

			  DSP_SPOS_DC_DC,

			  0x0000,DSP_SPOS_DC,

			  DSP_SPOS_DC, DSP_SPOS_DC,

			  DSP_SPOS_DC_DC,

			  DSP_SPOS_DC_DC,

			  DSP_SPOS_DC_DC,

			  DSP_SPOS_DC,DSP_SPOS_DC },

    

			{

				BG_TREE_SCB_ADDR,TIMINGMASTER_SCB_ADDR, 

				0,

				FG_TASK_HEADER_ADDR + TCBData,                  

			},



			{    

				4,0,

				1,0,

				2,SPOSCB_ADDR + HFGFlags,

				0,0,

				FG_TASK_HEADER_ADDR + TCBContextBlk,FG_STACK

			},



			{

				DSP_SPOS_DC,0,

				DSP_SPOS_DC,DSP_SPOS_DC,

				DSP_SPOS_DC,DSP_SPOS_DC,

				DSP_SPOS_DC,DSP_SPOS_DC,

				DSP_SPOS_DC,DSP_SPOS_DC,

				DSP_SPOS_DCDC,

				DSP_SPOS_UU,1,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC 

			},                                               

			{ 

				FG_INTERVAL_TIMER_PERIOD,DSP_SPOS_UU,

				0,0

			}

		};



		fg_task_tree_hdr.links.entry_point = fg_task_tree_header_code->address;

		fg_task_tree_hdr.context_blk.stack0 = task_tree_thread->address;

		cs46xx_dsp_create_task_tree(chip,"FGtaskTreeHdr",(u32 *)&fg_task_tree_hdr,FG_TASK_HEADER_ADDR,0x35);

	}





	{

		/* setup foreground task tree */

		static struct dsp_task_tree_control_block bg_task_tree_hdr =  {

			{ DSP_SPOS_DC_DC,

			  DSP_SPOS_DC_DC,

			  DSP_SPOS_DC_DC,

			  DSP_SPOS_DC, DSP_SPOS_DC,

			  DSP_SPOS_DC, DSP_SPOS_DC,

			  DSP_SPOS_DC_DC,

			  DSP_SPOS_DC_DC,

			  DSP_SPOS_DC_DC,

			  DSP_SPOS_DC,DSP_SPOS_DC },

    

			{

				NULL_SCB_ADDR,NULL_SCB_ADDR,  /* Set up the background to do nothing */

				0,

				BG_TREE_SCB_ADDR + TCBData,

			},



			{    

				9999,0,

				0,1,

				0,SPOSCB_ADDR + HFGFlags,

				0,0,

				BG_TREE_SCB_ADDR + TCBContextBlk,BG_STACK

			},



			{

				DSP_SPOS_DC,0,

				DSP_SPOS_DC,DSP_SPOS_DC,

				DSP_SPOS_DC,DSP_SPOS_DC,

				DSP_SPOS_DC,DSP_SPOS_DC,

				DSP_SPOS_DC,DSP_SPOS_DC,

				DSP_SPOS_DCDC,

				DSP_SPOS_UU,1,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC,

				DSP_SPOS_DCDC 

			},                                               

			{ 

				BG_INTERVAL_TIMER_PERIOD,DSP_SPOS_UU,

				0,0

			}

		};



		bg_task_tree_hdr.links.entry_point = task_tree_header_code->address;

		bg_task_tree_hdr.context_blk.stack0 = task_tree_thread->address;

		cs46xx_dsp_create_task_tree(chip,"BGtaskTreeHdr",(u32 *)&bg_task_tree_hdr,BG_TREE_SCB_ADDR,0x35);

	}



	/* create timing master SCB */

	timing_master_scb = cs46xx_dsp_create_timing_master_scb(chip);



	/* create the CODEC output task */

	codec_out_scb = cs46xx_dsp_create_codec_out_scb(chip,"CodecOutSCB_I",0x0010,0x0000,

							MASTERMIX_SCB_ADDR,

							CODECOUT_SCB_ADDR,timing_master_scb,

							SCB_ON_PARENT_SUBLIST_SCB);



	if (!codec_out_scb) goto _fail_end;

	/* create the master mix SCB */

	master_mix_scb = cs46xx_dsp_create_mix_only_scb(chip,"MasterMixSCB",

							MIX_SAMPLE_BUF1,MASTERMIX_SCB_ADDR,

							codec_out_scb,

							SCB_ON_PARENT_SUBLIST_SCB);

	ins->master_mix_scb = master_mix_scb;



	if (!master_mix_scb) goto _fail_end;



	/* create codec in */

	codec_in_scb = cs46xx_dsp_create_codec_in_scb(chip,"CodecInSCB",0x0010,0x00A0,

						      CODEC_INPUT_BUF1,

						      CODECIN_SCB_ADDR,codec_out_scb,

						      SCB_ON_PARENT_NEXT_SCB);

	if (!codec_in_scb) goto _fail_end;

	ins->codec_in_scb = codec_in_scb;



	/* create write back scb */

	write_back_scb = cs46xx_dsp_create_mix_to_ostream_scb(chip,"WriteBackSCB",

							      WRITE_BACK_BUF1,WRITE_BACK_SPB,

							      WRITEBACK_SCB_ADDR,

							      timing_master_scb,

							      SCB_ON_PARENT_NEXT_SCB);

	if (!write_back_scb) goto _fail_end;



	{

		static struct dsp_mix2_ostream_spb mix2_ostream_spb = {

			0x00020000,

			0x0000ffff

		};

    

		if (!cs46xx_dsp_create_task_tree(chip, NULL,

						 (u32 *)&mix2_ostream_spb,

						 WRITE_BACK_SPB, 2))

			goto _fail_end;

	}



	/* input sample converter */

	vari_decimate_scb = cs46xx_dsp_create_vari_decimate_scb(chip,"VariDecimateSCB",

								VARI_DECIMATE_BUF0,

								VARI_DECIMATE_BUF1,

								VARIDECIMATE_SCB_ADDR,

								write_back_scb,

								SCB_ON_PARENT_SUBLIST_SCB);

	if (!vari_decimate_scb) goto _fail_end;



	/* create the record mixer SCB */

	record_mix_scb = cs46xx_dsp_create_mix_only_scb(chip,"RecordMixerSCB",

							MIX_SAMPLE_BUF2,

							RECORD_MIXER_SCB_ADDR,

							vari_decimate_scb,

							SCB_ON_PARENT_SUBLIST_SCB);

	ins->record_mixer_scb = record_mix_scb;



	if (!record_mix_scb) goto _fail_end;



	valid_slots = snd_cs46xx_peekBA0(chip, BA0_ACOSV);



	if (snd_BUG_ON(chip->nr_ac97_codecs != 1 && chip->nr_ac97_codecs != 2))

		goto _fail_end;



	if (chip->nr_ac97_codecs == 1) {

 output on slot 5 and 11 

		   on primary CODEC */

		fifo_addr = 0x20;

		fifo_span = 0x60;



		/* enable slot 5 and 11 */

		valid_slots |= ACOSV_SLV5 | ACOSV_SLV11;

	} else {

 output on slot 7 and 8 

		   on secondary CODEC */

		fifo_addr = 0x40;

		fifo_span = 0x10;



		/* enable slot 7 and 8 */

		valid_slots |= ACOSV_SLV7 | ACOSV_SLV8;

	}

	/* create CODEC tasklet for rear speakers output*/

	rear_codec_out_scb = cs46xx_dsp_create_codec_out_scb(chip,"CodecOutSCB_Rear",fifo_span,fifo_addr,

							     REAR_MIXER_SCB_ADDR,

							     REAR_CODECOUT_SCB_ADDR,codec_in_scb,

							     SCB_ON_PARENT_NEXT_SCB);

	if (!rear_codec_out_scb) goto _fail_end;

	

	

	/* create the rear PCM channel  mixer SCB */

	rear_mix_scb = cs46xx_dsp_create_mix_only_scb(chip,"RearMixerSCB",

						      MIX_SAMPLE_BUF3,

						      REAR_MIXER_SCB_ADDR,

						      rear_codec_out_scb,

						      SCB_ON_PARENT_SUBLIST_SCB);

	ins->rear_mix_scb = rear_mix_scb;

	if (!rear_mix_scb) goto _fail_end;

	

	if (chip->nr_ac97_codecs == 2) {

 create CODEC tasklet for rear Center/LFE output 

		   slot 6 and 9 on secondary CODEC */

		clfe_codec_out_scb = cs46xx_dsp_create_codec_out_scb(chip,"CodecOutSCB_CLFE",0x0030,0x0030,

								     CLFE_MIXER_SCB_ADDR,

								     CLFE_CODEC_SCB_ADDR,

								     rear_codec_out_scb,

								     SCB_ON_PARENT_NEXT_SCB);

		if (!clfe_codec_out_scb) goto _fail_end;

		

		

		/* create the rear PCM channel  mixer SCB */

		ins->center_lfe_mix_scb = cs46xx_dsp_create_mix_only_scb(chip,"CLFEMixerSCB",

									 MIX_SAMPLE_BUF4,

									 CLFE_MIXER_SCB_ADDR,

									 clfe_codec_out_scb,

									 SCB_ON_PARENT_SUBLIST_SCB);

		if (!ins->center_lfe_mix_scb) goto _fail_end;



		/* enable slot 6 and 9 */

		valid_slots |= ACOSV_SLV6 | ACOSV_SLV9;

	} else {

		clfe_codec_out_scb = rear_codec_out_scb;

		ins->center_lfe_mix_scb = rear_mix_scb;

	}



	/* enable slots depending on CODEC configuration */

	snd_cs46xx_pokeBA0(chip, BA0_ACOSV, valid_slots);



	/* the magic snooper */

	magic_snoop_scb = cs46xx_dsp_create_magic_snoop_scb (chip,"MagicSnoopSCB_I",OUTPUTSNOOP_SCB_ADDR,

							     OUTPUT_SNOOP_BUFFER,

							     codec_out_scb,

							     clfe_codec_out_scb,

							     SCB_ON_PARENT_NEXT_SCB);



    

	if (!magic_snoop_scb) goto _fail_end;

	ins->ref_snoop_scb = magic_snoop_scb;



	/* SP IO access */

	if (!cs46xx_dsp_create_spio_write_scb(chip,"SPIOWriteSCB",SPIOWRITE_SCB_ADDR,

					      magic_snoop_scb,

					      SCB_ON_PARENT_NEXT_SCB))

		goto _fail_end;



	/* SPDIF input sampel rate converter */

	src_task_scb = cs46xx_dsp_create_src_task_scb(chip,"SrcTaskSCB_SPDIFI",

						      ins->spdif_in_sample_rate,

						      SRC_OUTPUT_BUF1,

						      SRC_DELAY_BUF1,SRCTASK_SCB_ADDR,

						      master_mix_scb,

						      SCB_ON_PARENT_SUBLIST_SCB,1);



	if (!src_task_scb) goto _fail_end;

	cs46xx_src_unlink(chip,src_task_scb);



 NOTE: when we now how to detect the SPDIF input

	   sample rate we will use this SRC to adjust it */

	ins->spdif_in_src = src_task_scb;



	cs46xx_dsp_async_init(chip,timing_master_scb);

	return 0;



 _fail_end:

	dev_err(chip->card->dev, "dsp_spos: failed to setup SCB's in DSP\n");

	return -EINVAL;

}



static int cs46xx_dsp_async_init (struct snd_cs46xx *chip,

				  struct dsp_scb_descriptor * fg_entry)

{

	struct dsp_spos_instance * ins = chip->dsp_spos_instance;

	struct dsp_symbol_entry * s16_async_codec_input_task;

	struct dsp_symbol_entry * spdifo_task;

	struct dsp_symbol_entry * spdifi_task;

	struct dsp_scb_descriptor * spdifi_scb_desc, * spdifo_scb_desc, * async_codec_scb_desc;



	s16_async_codec_input_task = cs46xx_dsp_lookup_symbol(chip, "S16_ASYNCCODECINPUTTASK", SYMBOL_CODE);

	if (s16_async_codec_input_task == NULL) {

		dev_err(chip->card->dev,

			"dsp_spos: symbol S16_ASYNCCODECINPUTTASK not found\n");

		return -EIO;

	}

	spdifo_task = cs46xx_dsp_lookup_symbol(chip, "SPDIFOTASK", SYMBOL_CODE);

	if (spdifo_task == NULL) {

		dev_err(chip->card->dev,

			"dsp_spos: symbol SPDIFOTASK not found\n");

		return -EIO;

	}



	spdifi_task = cs46xx_dsp_lookup_symbol(chip, "SPDIFITASK", SYMBOL_CODE);

	if (spdifi_task == NULL) {

		dev_err(chip->card->dev,

			"dsp_spos: symbol SPDIFITASK not found\n");

		return -EIO;

	}



	{

		/* 0xBC0 */

		struct dsp_spdifoscb spdifo_scb = {

			/* 0 */ DSP_SPOS_UUUU,

			{

				/* 1 */ 0xb0, 

				/* 2 */ 0, 

				/* 3 */ 0, 

				/* 4 */ 0, 

			},

 NOTE: the SPDIF output task read samples in mono

			*/

			/* 5 */ RSCONFIG_SAMPLE_16MONO + RSCONFIG_MODULO_256,

			/* 6 */ ( SPDIFO_IP_OUTPUT_BUFFER1 << 0x10 )  |  0xFFFC,

			/* 7 */ 0,0, 

			/* 8 */ 0, 

			/* 9 */ FG_TASK_HEADER_ADDR, NULL_SCB_ADDR, 

			/* A */ spdifo_task->address,

			SPDIFO_SCB_INST + SPDIFOFIFOPointer,

			{

				/* B */ 0x0040, /*DSP_SPOS_UUUU,*/

				/* C */ 0x20ff, /*DSP_SPOS_UUUU,*/

			},

			/* D */ 0x804c,0,							  /* SPDIFOFIFOPointer:SPDIFOStatRegAddr; */

			/* E */ 0x0108,0x0001,					  /* SPDIFOStMoFormat:SPDIFOFIFOBaseAddr; */

			/* F */ DSP_SPOS_UUUU	  			          /* SPDIFOFree; */

		};



		/* 0xBB0 */

		struct dsp_spdifiscb spdifi_scb = {

			/* 0 */ DSP_SPOS_UULO,DSP_SPOS_UUHI,

			/* 1 */ 0,

			/* 2 */ 0,

			/* 3 */ 1,4000,        /* SPDIFICountLimit SPDIFICount */ 

			/* 4 */ DSP_SPOS_UUUU, /* SPDIFIStatusData */

			/* 5 */ 0,DSP_SPOS_UUHI, /* StatusData, Free4 */

			/* 6 */ DSP_SPOS_UUUU,  /* Free3 */

			/* 7 */ DSP_SPOS_UU,DSP_SPOS_DC,  /* Free2 BitCount*/

			/* 8 */ DSP_SPOS_UUUU,	/* TempStatus */

			/* 9 */ SPDIFO_SCB_INST, NULL_SCB_ADDR,

			/* A */ spdifi_task->address,

			SPDIFI_SCB_INST + SPDIFIFIFOPointer,

 NOTE: The SPDIF input task write the sample in mono

			*/

			/* B */ RSCONFIG_SAMPLE_16MONO + RSCONFIG_MODULO_128,

			/* C */ (SPDIFI_IP_OUTPUT_BUFFER1 << 0x10) | 0xFFFC,

			/* D */ 0x8048,0,

			/* E */ 0x01f0,0x0001,

			/* F */ DSP_SPOS_UUUU /* SPDIN_STATUS monitor */

		};



		/* 0xBA0 */

		struct dsp_async_codec_input_scb async_codec_input_scb = {

			/* 0 */ DSP_SPOS_UUUU,

			/* 1 */ 0,

			/* 2 */ 0,

			/* 3 */ 1,4000,

			/* 4 */ 0x0118,0x0001,

			/* 5 */ RSCONFIG_SAMPLE_16MONO + RSCONFIG_MODULO_64,

			/* 6 */ (ASYNC_IP_OUTPUT_BUFFER1 << 0x10) | 0xFFFC,

			/* 7 */ DSP_SPOS_UU,0x3,

			/* 8 */ DSP_SPOS_UUUU,

			/* 9 */ SPDIFI_SCB_INST,NULL_SCB_ADDR,

			/* A */ s16_async_codec_input_task->address,

			HFG_TREE_SCB + AsyncCIOFIFOPointer,

              

			/* B */ RSCONFIG_SAMPLE_16STEREO + RSCONFIG_MODULO_64,

			/* C */ (ASYNC_IP_OUTPUT_BUFFER1 << 0x10),  /*(ASYNC_IP_OUTPUT_BUFFER1 << 0x10) | 0xFFFC,*/

      

#ifdef UseASER1Input

 short AsyncCIFIFOPointer:AsyncCIStatRegAddr;	       

			   0000:8044: for ASER2 */

			/* D */ 0x8042,0,

      

 short AsyncCIStMoFormat:AsyncCIFIFOBaseAddr;

			   Init 1 Stereo : 0100 ASER1 (Set by script) */

			/* E */ 0x0100,0x0001,

      

#endif

      

#ifdef UseASER2Input

 short AsyncCIFIFOPointer:AsyncCIStatRegAddr;

			   0000:8044: for ASER2 */

			/* D */ 0x8044,0,

      

 short AsyncCIStMoFormat:AsyncCIFIFOBaseAddr;

			   Init 1 Stereo : 0100 ASER1 (Set by script) */

			/* E */ 0x0110,0x0001,

      

#endif

      

 short AsyncCIOutputBufModulo:AsyncCIFree;

			   the output buffer of this task */

			/* F */ 0, /* DSP_SPOS_UUUU */

		};



		spdifo_scb_desc = cs46xx_dsp_create_scb(chip,"SPDIFOSCB",(u32 *)&spdifo_scb,SPDIFO_SCB_INST);



		if (snd_BUG_ON(!spdifo_scb_desc))

			return -EIO;

		spdifi_scb_desc = cs46xx_dsp_create_scb(chip,"SPDIFISCB",(u32 *)&spdifi_scb,SPDIFI_SCB_INST);

		if (snd_BUG_ON(!spdifi_scb_desc))

			return -EIO;

		async_codec_scb_desc = cs46xx_dsp_create_scb(chip,"AsynCodecInputSCB",(u32 *)&async_codec_input_scb, HFG_TREE_SCB);

		if (snd_BUG_ON(!async_codec_scb_desc))

			return -EIO;



		async_codec_scb_desc->parent_scb_ptr = NULL;

		async_codec_scb_desc->next_scb_ptr = spdifi_scb_desc;

		async_codec_scb_desc->sub_list_ptr = ins->the_null_scb;

		async_codec_scb_desc->task_entry = s16_async_codec_input_task;



		spdifi_scb_desc->parent_scb_ptr = async_codec_scb_desc;

		spdifi_scb_desc->next_scb_ptr = spdifo_scb_desc;

		spdifi_scb_desc->sub_list_ptr = ins->the_null_scb;

		spdifi_scb_desc->task_entry = spdifi_task;



		spdifo_scb_desc->parent_scb_ptr = spdifi_scb_desc;

		spdifo_scb_desc->next_scb_ptr = fg_entry;

		spdifo_scb_desc->sub_list_ptr = ins->the_null_scb;

		spdifo_scb_desc->task_entry = spdifo_task;



 this one is faked, as the parnet of SPDIFO task

		   is the FG task tree */

		fg_entry->parent_scb_ptr = spdifo_scb_desc;



		/* for proc fs */

		cs46xx_dsp_proc_register_scb_desc (chip,spdifo_scb_desc);

		cs46xx_dsp_proc_register_scb_desc (chip,spdifi_scb_desc);

		cs46xx_dsp_proc_register_scb_desc (chip,async_codec_scb_desc);



		/* Async MASTER ENABLE, affects both SPDIF input and output */

		snd_cs46xx_pokeBA0(chip, BA0_ASER_MASTER, 0x1 );

	}



	return 0;

}



static void cs46xx_dsp_disable_spdif_hw (struct snd_cs46xx *chip)

{

	struct dsp_spos_instance * ins = chip->dsp_spos_instance;



	/* set SPDIF output FIFO slot */

	snd_cs46xx_pokeBA0(chip, BA0_ASER_FADDR, 0);



	/* SPDIF output MASTER ENABLE */

	cs46xx_poke_via_dsp (chip,SP_SPDOUT_CONTROL, 0);



	/* right and left validate bit */

	/*cs46xx_poke_via_dsp (chip,SP_SPDOUT_CSUV, ins->spdif_csuv_default);*/

	cs46xx_poke_via_dsp (chip,SP_SPDOUT_CSUV, 0x0);



	/* clear fifo pointer */

	cs46xx_poke_via_dsp (chip,SP_SPDIN_FIFOPTR, 0x0);



	/* monitor state */

	ins->spdif_status_out &= ~DSP_SPDIF_STATUS_HW_ENABLED;

}



int cs46xx_dsp_enable_spdif_hw (struct snd_cs46xx *chip)

{

	struct dsp_spos_instance * ins = chip->dsp_spos_instance;



	/* if hw-ctrl already enabled, turn off to reset logic ... */

	cs46xx_dsp_disable_spdif_hw (chip);

	udelay(50);



	/* set SPDIF output FIFO slot */

	snd_cs46xx_pokeBA0(chip, BA0_ASER_FADDR, ( 0x8000 | ((SP_SPDOUT_FIFO >> 4) << 4) ));



	/* SPDIF output MASTER ENABLE */

	cs46xx_poke_via_dsp (chip,SP_SPDOUT_CONTROL, 0x80000000);



	/* right and left validate bit */

	cs46xx_poke_via_dsp (chip,SP_SPDOUT_CSUV, ins->spdif_csuv_default);



	/* monitor state */

	ins->spdif_status_out |= DSP_SPDIF_STATUS_HW_ENABLED;



	return 0;

}



int cs46xx_dsp_enable_spdif_in (struct snd_cs46xx *chip)

{

	struct dsp_spos_instance * ins = chip->dsp_spos_instance;



	/* turn on amplifier */

	chip->active_ctrl(chip, 1);

	chip->amplifier_ctrl(chip, 1);



	if (snd_BUG_ON(ins->asynch_rx_scb))

		return -EINVAL;

	if (snd_BUG_ON(!ins->spdif_in_src))

		return -EINVAL;



	mutex_lock(&chip->spos_mutex);



	if ( ! (ins->spdif_status_out & DSP_SPDIF_STATUS_INPUT_CTRL_ENABLED) ) {

		/* time countdown enable */

		cs46xx_poke_via_dsp (chip,SP_ASER_COUNTDOWN, 0x80000005);

 NOTE: 80000005 value is just magic. With all values

		   Got no explication why. (Benny) */



		/* SPDIF input MASTER ENABLE */

		cs46xx_poke_via_dsp (chip,SP_SPDIN_CONTROL, 0x800003ff);



		ins->spdif_status_out |= DSP_SPDIF_STATUS_INPUT_CTRL_ENABLED;

	}



	/* create and start the asynchronous receiver SCB */

	ins->asynch_rx_scb = cs46xx_dsp_create_asynch_fg_rx_scb(chip,"AsynchFGRxSCB",

								ASYNCRX_SCB_ADDR,

								SPDIFI_SCB_INST,

								SPDIFI_IP_OUTPUT_BUFFER1,

								ins->spdif_in_src,

								SCB_ON_PARENT_SUBLIST_SCB);



	spin_lock_irq(&chip->reg_lock);



	/* reset SPDIF input sample buffer pointer */

snd_cs46xx_poke (chip, (SPDIFI_SCB_INST + 0x0c) << 2,

	  (SPDIFI_IP_OUTPUT_BUFFER1 << 0x10) | 0xFFFC);*/



	/* reset FIFO ptr */

	/*cs46xx_poke_via_dsp (chip,SP_SPDIN_FIFOPTR, 0x0);*/

	cs46xx_src_link(chip,ins->spdif_in_src);



	/* unmute SRC volume */

	cs46xx_dsp_scb_set_volume (chip,ins->spdif_in_src,0x7fff,0x7fff);



	spin_unlock_irq(&chip->reg_lock);



 set SPDIF input sample rate and unmute

	   NOTE: only 48khz support for SPDIF input this time */

	/* cs46xx_dsp_set_src_sample_rate(chip,ins->spdif_in_src,48000); */



	/* monitor state */

	ins->spdif_status_in = 1;

	mutex_unlock(&chip->spos_mutex);



	return 0;

}



int cs46xx_dsp_disable_spdif_in (struct snd_cs46xx *chip)

{

	struct dsp_spos_instance * ins = chip->dsp_spos_instance;



	if (snd_BUG_ON(!ins->asynch_rx_scb))

		return -EINVAL;

	if (snd_BUG_ON(!ins->spdif_in_src))

		return -EINVAL;



	mutex_lock(&chip->spos_mutex);



	/* Remove the asynchronous receiver SCB */

	cs46xx_dsp_remove_scb (chip,ins->asynch_rx_scb);

	ins->asynch_rx_scb = NULL;



	cs46xx_src_unlink(chip,ins->spdif_in_src);



	/* monitor state */

	ins->spdif_status_in = 0;

	mutex_unlock(&chip->spos_mutex);



	/* restore amplifier */

	chip->active_ctrl(chip, -1);

	chip->amplifier_ctrl(chip, -1);



	return 0;

}



int cs46xx_dsp_enable_pcm_capture (struct snd_cs46xx *chip)

{

	struct dsp_spos_instance * ins = chip->dsp_spos_instance;



	if (snd_BUG_ON(ins->pcm_input))

		return -EINVAL;

	if (snd_BUG_ON(!ins->ref_snoop_scb))

		return -EINVAL;



	mutex_lock(&chip->spos_mutex);

	ins->pcm_input = cs46xx_add_record_source(chip,ins->ref_snoop_scb,PCMSERIALIN_PCM_SCB_ADDR,

                                                  "PCMSerialInput_Wave");

	mutex_unlock(&chip->spos_mutex);



	return 0;

}



int cs46xx_dsp_disable_pcm_capture (struct snd_cs46xx *chip)

{

	struct dsp_spos_instance * ins = chip->dsp_spos_instance;



	if (snd_BUG_ON(!ins->pcm_input))

		return -EINVAL;



	mutex_lock(&chip->spos_mutex);

	cs46xx_dsp_remove_scb (chip,ins->pcm_input);

	ins->pcm_input = NULL;

	mutex_unlock(&chip->spos_mutex);



	return 0;

}



int cs46xx_dsp_enable_adc_capture (struct snd_cs46xx *chip)

{

	struct dsp_spos_instance * ins = chip->dsp_spos_instance;



	if (snd_BUG_ON(ins->adc_input))

		return -EINVAL;

	if (snd_BUG_ON(!ins->codec_in_scb))

		return -EINVAL;



	mutex_lock(&chip->spos_mutex);

	ins->adc_input = cs46xx_add_record_source(chip,ins->codec_in_scb,PCMSERIALIN_SCB_ADDR,

						  "PCMSerialInput_ADC");

	mutex_unlock(&chip->spos_mutex);



	return 0;

}



int cs46xx_dsp_disable_adc_capture (struct snd_cs46xx *chip)

{

	struct dsp_spos_instance * ins = chip->dsp_spos_instance;



	if (snd_BUG_ON(!ins->adc_input))

		return -EINVAL;



	mutex_lock(&chip->spos_mutex);

	cs46xx_dsp_remove_scb (chip,ins->adc_input);

	ins->adc_input = NULL;

	mutex_unlock(&chip->spos_mutex);



	return 0;

}



int cs46xx_poke_via_dsp (struct snd_cs46xx *chip, u32 address, u32 data)

{

	u32 temp;

	int  i;



 santiy check the parameters.  (These numbers are not 100% correct.  They are

	   a rough guess from looking at the controller spec.) */

	if (address < 0x8000 || address >= 0x9000)

		return -EINVAL;

        

	/* initialize the SP_IO_WRITE SCB with the data. */

	temp = ( address << 16 ) | ( address & 0x0000FFFF);   /* offset 0 <-- address2 : address1 */



	snd_cs46xx_poke(chip,( SPIOWRITE_SCB_ADDR      << 2), temp);

	snd_cs46xx_poke(chip,((SPIOWRITE_SCB_ADDR + 1) << 2), data); /* offset 1 <-- data1 */

	snd_cs46xx_poke(chip,((SPIOWRITE_SCB_ADDR + 2) << 2), data); /* offset 1 <-- data2 */

    

	/* Poke this location to tell the task to start */

	snd_cs46xx_poke(chip,((SPIOWRITE_SCB_ADDR + 6) << 2), SPIOWRITE_SCB_ADDR << 0x10);



	/* Verify that the task ran */

	for (i=0; i<25; i++) {

		udelay(125);



		temp =  snd_cs46xx_peek(chip,((SPIOWRITE_SCB_ADDR + 6) << 2));

		if (temp == 0x00000000)

			break;

	}



	if (i == 25) {

		dev_err(chip->card->dev,

			"dsp_spos: SPIOWriteTask not responding\n");

		return -EBUSY;

	}



	return 0;

}



int cs46xx_dsp_set_dac_volume (struct snd_cs46xx * chip, u16 left, u16 right)

{

	struct dsp_spos_instance * ins = chip->dsp_spos_instance;

	struct dsp_scb_descriptor * scb; 



	mutex_lock(&chip->spos_mutex);

	

	/* main output */

	scb = ins->master_mix_scb->sub_list_ptr;

	while (scb != ins->the_null_scb) {

		cs46xx_dsp_scb_set_volume (chip,scb,left,right);

		scb = scb->next_scb_ptr;

	}



	/* rear output */

	scb = ins->rear_mix_scb->sub_list_ptr;

	while (scb != ins->the_null_scb) {

		cs46xx_dsp_scb_set_volume (chip,scb,left,right);

		scb = scb->next_scb_ptr;

	}



	ins->dac_volume_left = left;

	ins->dac_volume_right = right;



	mutex_unlock(&chip->spos_mutex);



	return 0;

}



int cs46xx_dsp_set_iec958_volume (struct snd_cs46xx * chip, u16 left, u16 right)

{

	struct dsp_spos_instance * ins = chip->dsp_spos_instance;



	mutex_lock(&chip->spos_mutex);



	if (ins->asynch_rx_scb != NULL)

		cs46xx_dsp_scb_set_volume (chip,ins->asynch_rx_scb,

					   left,right);



	ins->spdif_input_volume_left = left;

	ins->spdif_input_volume_right = right;



	mutex_unlock(&chip->spos_mutex);



	return 0;

}



#ifdef CONFIG_PM_SLEEP

int cs46xx_dsp_resume(struct snd_cs46xx * chip)

{

	struct dsp_spos_instance * ins = chip->dsp_spos_instance;

	int i, err;



	/* clear parameter, sample and code areas */

	snd_cs46xx_clear_BA1(chip, DSP_PARAMETER_BYTE_OFFSET,

			     DSP_PARAMETER_BYTE_SIZE);

	snd_cs46xx_clear_BA1(chip, DSP_SAMPLE_BYTE_OFFSET,

			     DSP_SAMPLE_BYTE_SIZE);

	snd_cs46xx_clear_BA1(chip, DSP_CODE_BYTE_OFFSET, DSP_CODE_BYTE_SIZE);



	for (i = 0; i < ins->nmodules; i++) {

		struct dsp_module_desc *module = &ins->modules[i];

		struct dsp_segment_desc *seg;

		u32 doffset, dsize;



		seg = get_segment_desc(module, SEGTYPE_SP_PARAMETER);

		err = dsp_load_parameter(chip, seg);

		if (err < 0)

			return err;



		seg = get_segment_desc(module, SEGTYPE_SP_SAMPLE);

		err = dsp_load_sample(chip, seg);

		if (err < 0)

			return err;



		seg = get_segment_desc(module, SEGTYPE_SP_PROGRAM);

		if (!seg)

			continue;



		doffset = seg->offset * 4 + module->load_address * 4

			+ DSP_CODE_BYTE_OFFSET;

		dsize   = seg->size * 4;

		err = snd_cs46xx_download(chip,

					  ins->code.data + module->load_address,

					  doffset, dsize);

		if (err < 0)

			return err;

	}



	for (i = 0; i < ins->ntask; i++) {

		struct dsp_task_descriptor *t = &ins->tasks[i];

		_dsp_create_task_tree(chip, t->data, t->address, t->size);

	}



	for (i = 0; i < ins->nscb; i++) {

		struct dsp_scb_descriptor *s = &ins->scbs[i];

		if (s->deleted)

			continue;

		_dsp_create_scb(chip, s->data, s->address);

	}

	for (i = 0; i < ins->nscb; i++) {

		struct dsp_scb_descriptor *s = &ins->scbs[i];

		if (s->deleted)

			continue;

		if (s->updated)

			cs46xx_dsp_spos_update_scb(chip, s);

		if (s->volume_set)

			cs46xx_dsp_scb_set_volume(chip, s,

						  s->volume[0], s->volume[1]);

	}

	if (ins->spdif_status_out & DSP_SPDIF_STATUS_HW_ENABLED) {

		cs46xx_dsp_enable_spdif_hw(chip);

		snd_cs46xx_poke(chip, (ins->ref_snoop_scb->address + 2) << 2,

				(OUTPUT_SNOOP_BUFFER + 0x10) << 0x10);

		if (ins->spdif_status_out & DSP_SPDIF_STATUS_PLAYBACK_OPEN)

			cs46xx_poke_via_dsp(chip, SP_SPDOUT_CSUV,

					    ins->spdif_csuv_stream);

	}

	if (chip->dsp_spos_instance->spdif_status_in) {

		cs46xx_poke_via_dsp(chip, SP_ASER_COUNTDOWN, 0x80000005);

		cs46xx_poke_via_dsp(chip, SP_SPDIN_CONTROL, 0x800003ff);

	}

	return 0;

}

#endif

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Driver for audio on multifunction CS5535/6 companion device

 * Copyright (C) Jaya Kumar

 *

 * Based on Jaroslav Kysela and Takashi Iwai's examples.

 * This work was sponsored by CIS(M) Sdn Bhd.

 Not yet confirmed if all 5536 boards are HP only */

 set any OLPC-specific scaps */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * OLPC XO-1 additional sound features

 *

 * Copyright  2006  Jaya Kumar <jayakumar.lkml@gmail.com>

 * Copyright  2007-2008  Andres Salomon <dilinger@debian.org>

/*

 * OLPC has an additional feature on top of the regular AD1888 codec features.

 * It has an Analog Input mode that is switched into (after disabling the

 * High Pass Filter) via GPIO.  It is supported on B2 and later models.

 update the High Pass Filter (via AC97_AD_TEST2) */

 set Analog Input through GPIO */

/*

 * OLPC XO-1's V_REFOUT is a mic bias enable.

 invert EAPD if on an OLPC B3 or higher */

 drop the original AD1888 HPF control */

 drop the original V_REFOUT control */

 add the OLPC-specific controls */

 turn off the mic by default */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Driver for audio on multifunction CS5535 companion device

 * Copyright (C) Jaya Kumar

 *

 * Based on Jaroslav Kysela and Takashi Iwai's examples.

 * This work was sponsored by CIS(M) Sdn Bhd.

 *

 * todo: add be fmt support, spdif, pm

	/* the u32 cast is okay because in snd*create we successfully told

 we reserved one dummy descriptor at the end to do the PRD jump */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Power management for audio on multifunction CS5535 companion device

 * Copyright (C) Jaya Kumar

	/* 

	we depend on snd_ac97_suspend to tell the

	AC97 codec to shutdown. the amd spec suggests

	that the LNK_SHUTDOWN be done at the same time

	that the codec power-down is issued. instead,

	we do it just after rather than at the same 

	time. excluding codec specific build_ops->suspend

	ac97 powerdown hits:

	0x8000 EAPD 

	0x4000 Headphone amplifier 

	0x0300 ADC & DAC 

	0x0400 Analog Mixer powerdown (Vref on) 

	I am not sure if this is the best that we can do.

	The remainder to be investigated are:

	- analog mixer (vref off) 0x0800

	- AC-link powerdown 0x1000

	- codec internal clock 0x2000

 set LNK_SHUTDOWN to shutdown AC link */

 save important regs, then disable aclink in hw */

 set LNK_WRM_RST to reset AC link */

 set up rate regs, dma. actual initiation is done in trig */

 we depend on ac97 to perform the codec power up */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Driver for Trident 4DWave DX/NX & SiS SI7018 Audio PCI soundcard

 *

 *  Driver was originated by Trident <audio@tridentmicro.com>

 *  			     Fri Feb 19 15:55:28 MST 1999

 Index 0-MAX */

 ID for this card */

 Enable this card */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>

 *  Copyright (c) by Takashi Iwai <tiwai@suse.de>

 *  Copyright (c) by Scott McNab <sdm@fractalgraphics.com.au>

 *

 *  Trident 4DWave-NX memory page allocation (TLB area)

 *  Trident chip can handle only 16MByte of the memory at the same time.

/* page arguments of these two macros are Trident page (4096 bytes), not like

 * aligned pages in others

 page size == SNDRV_TRIDENT_PAGE_SIZE */

 minimum page size for allocation */

 maxmium aligned pages */

 fill TLB entrie(s) corresponding to page with ptr */

 fill TLB entrie(s) corresponding to page with silence pointer */

 get aligned page from offset address */

 get offset address from aligned page */

 get PCI physical address from aligned page */

 page size == SNDRV_TRIDENT_PAGE_SIZE x 2*/

 fill TLB entries -- we need to fill two entries */

 arbitrary size */

/* Note: if alignment doesn't match to the maximum size, the last few blocks

 * become unusable.  To use such blocks, you'll need to check the validity

 * of accessing page in set_tlb_bus and set_silent_tlb.  search_empty()

 * should also check it, too.

 fill TLB entries -- UNIT_PAGES entries must be filled */

 PAGE_SIZE */

 first and last (aligned) pages of memory block */

/*

 * search empty pages which may contain given size

 create a new memory block */

 set aligned offset */

/*

 * check if the given pointer is valid for pages

/*

 * page allocation for DMA (Scatter-Gather version)

 set TLB entries */

/*

 * page allocation for DMA (contiguous version)

 set TLB entries */

/*

 * page allocation for DMA

/*

 * release DMA buffer from page table

 reset TLB entries */

 free memory block */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Maintained by Jaroslav Kysela <perex@perex.cz>

 *  Originated by audio@tridentmicro.com

 *  Fri Feb 19 15:55:28 MST 1999

 *  Routines for control of Trident 4DWave (DX and NX) chip

 *

 *  BUGS:

 *

 *  TODO:

 *    ---

 *

 *  SiS7018 S/PDIF support by Thomas Winischhofer <thomas@winischhofer.net>

/*

 *  common I/O routines

 TRIDENT_DEVICE_ID_NX

/*---------------------------------------------------------------------------

   unsigned short snd_trident_codec_read(struct snd_ac97 *ac97, unsigned short reg)

  

   Description: This routine will do all of the reading from the external

                CODEC (AC97).

  

   Parameters:  ac97 - ac97 codec structure

                reg - CODEC register index, from AC97 Hal.

 

   returns:     16 bit value read from the AC97.

  

/*---------------------------------------------------------------------------

   void snd_trident_codec_write(struct snd_ac97 *ac97, unsigned short reg,

   unsigned short wdata)

  

   Description: This routine will do all of the writing to the external

                CODEC (AC97).

  

   Parameters:	ac97 - ac97 codec structure

   	        reg - CODEC register index, from AC97 Hal.

                data  - Lower 16 bits are the data to write to CODEC.

  

   returns:     TRUE if everything went ok, else FALSE.

  

 read AC-97 write register status */

 read AC-97 write register status */

 read AC-97 write register status */

 keep GCC happy */

 return */

/*---------------------------------------------------------------------------

   void snd_trident_enable_eso(struct snd_trident *trident)

  

   Description: This routine will enable end of loop interrupts.

                End of loop interrupts will occur when a running

                channel reaches ESO.

                Also enables middle of loop interrupts.

  

   Parameters:  trident - pointer to target device class for 4DWave.

  

/*---------------------------------------------------------------------------

   void snd_trident_disable_eso(struct snd_trident *trident)

  

   Description: This routine will disable end of loop interrupts.

                End of loop interrupts will occur when a running

                channel reaches ESO.

                Also disables middle of loop interrupts.

  

   Parameters:  

                trident - pointer to target device class for 4DWave.

  

   returns:     TRUE if everything went ok, else FALSE.

  

/*---------------------------------------------------------------------------

   void snd_trident_start_voice(struct snd_trident * trident, unsigned int voice)



    Description: Start a voice, any channel 0 thru 63.

                 This routine automatically handles the fact that there are

                 more than 32 channels available.



    Parameters : voice - Voice number 0 thru n.

                 trident - pointer to target device class for 4DWave.



    Return Value: None.



/*---------------------------------------------------------------------------

   void snd_trident_stop_voice(struct snd_trident * trident, unsigned int voice)



    Description: Stop a voice, any channel 0 thru 63.

                 This routine automatically handles the fact that there are

                 more than 32 channels available.



    Parameters : voice - Voice number 0 thru n.

                 trident - pointer to target device class for 4DWave.



    Return Value: None.



/*---------------------------------------------------------------------------

    int snd_trident_allocate_pcm_channel(struct snd_trident *trident)

  

    Description: Allocate hardware channel in Bank B (32-63).

  

    Parameters :  trident - pointer to target device class for 4DWave.

  

    Return Value: hardware channel - 32-63 or -1 when no channel is available

  

/*---------------------------------------------------------------------------

    void snd_trident_free_pcm_channel(int channel)

  

    Description: Free hardware channel in Bank B (32-63)

  

    Parameters :  trident - pointer to target device class for 4DWave.

	          channel - hardware channel number 0-63

  

    Return Value: none

  

/*---------------------------------------------------------------------------

    unsigned int snd_trident_allocate_synth_channel(void)

  

    Description: Allocate hardware channel in Bank A (0-31).

  

    Parameters :  trident - pointer to target device class for 4DWave.

  

    Return Value: hardware channel - 0-31 or -1 when no channel is available

  

/*---------------------------------------------------------------------------

    void snd_trident_free_synth_channel( int channel )

  

    Description: Free hardware channel in Bank B (0-31).

  

    Parameters :  trident - pointer to target device class for 4DWave.

	          channel - hardware channel number 0-63

  

    Return Value: none

  

/*---------------------------------------------------------------------------

   snd_trident_write_voice_regs

  

   Description: This routine will complete and write the 5 hardware channel

                registers to hardware.

  

   Parameters:  trident - pointer to target device class for 4DWave.

                voice - synthesizer voice structure

                Each register field.

  

/*---------------------------------------------------------------------------

   snd_trident_write_cso_reg

  

   Description: This routine will write the new CSO offset

                register to hardware.

  

   Parameters:  trident - pointer to target device class for 4DWave.

                voice - synthesizer voice structure

                CSO - new CSO value

  

/*---------------------------------------------------------------------------

   snd_trident_write_eso_reg

  

   Description: This routine will write the new ESO offset

                register to hardware.

  

   Parameters:  trident - pointer to target device class for 4DWave.

                voice - synthesizer voice structure

                ESO - new ESO value

  

/*---------------------------------------------------------------------------

   snd_trident_write_vol_reg

  

   Description: This routine will write the new voice volume

                register to hardware.

  

   Parameters:  trident - pointer to target device class for 4DWave.

                voice - synthesizer voice structure

                Vol - new voice volume

  

 dev_dbg(trident->card->dev, "voice->Vol = 0x%x\n", voice->Vol); */

/*---------------------------------------------------------------------------

   snd_trident_write_pan_reg

  

   Description: This routine will write the new voice pan

                register to hardware.

  

   Parameters:  trident - pointer to target device class for 4DWave.

                voice - synthesizer voice structure

                Pan - new pan value

  

/*---------------------------------------------------------------------------

   snd_trident_write_rvol_reg

  

   Description: This routine will write the new reverb volume

                register to hardware.

  

   Parameters:  trident - pointer to target device class for 4DWave.

                voice - synthesizer voice structure

                RVol - new reverb volume

  

/*---------------------------------------------------------------------------

   snd_trident_write_cvol_reg

  

   Description: This routine will write the new chorus volume

                register to hardware.

  

   Parameters:  trident - pointer to target device class for 4DWave.

                voice - synthesizer voice structure

                CVol - new chorus volume

  

/*---------------------------------------------------------------------------

   snd_trident_convert_rate



   Description: This routine converts rate in HZ to hardware delta value.

  

   Parameters:  trident - pointer to target device class for 4DWave.

                rate - Real or Virtual channel number.

  

   Returns:     Delta value.

  

 We special case 44100 and 8000 since rounding with the equation

 does not give us an accurate enough value. For 11025 and 22050

 the equation gives us the best answer. All other frequencies will

 also use the equation. JDW

/*---------------------------------------------------------------------------

   snd_trident_convert_adc_rate



   Description: This routine converts rate in HZ to hardware delta value.

  

   Parameters:  trident - pointer to target device class for 4DWave.

                rate - Real or Virtual channel number.

  

   Returns:     Delta value.

  

 We special case 44100 and 8000 since rounding with the equation

 does not give us an accurate enough value. For 11025 and 22050

 the equation gives us the best answer. All other frequencies will

 also use the equation. JDW

/*---------------------------------------------------------------------------

   snd_trident_spurious_threshold



   Description: This routine converts rate in HZ to spurious threshold.

  

   Parameters:  trident - pointer to target device class for 4DWave.

                rate - Real or Virtual channel number.

  

   Returns:     Delta value.

  

/*---------------------------------------------------------------------------

   snd_trident_control_mode



   Description: This routine returns a control mode for a PCM channel.

  

   Parameters:  trident - pointer to target device class for 4DWave.

                substream  - PCM substream

  

   Returns:     Control value.

  

	/* set ctrl mode

	   CTRL default: 8-bit (unsigned) mono, loop mode enabled

 16-bit data

 signed data

 stereo data

/*

 *  PCM part

/*---------------------------------------------------------------------------

   snd_trident_allocate_pcm_mem

  

   Description: Allocate PCM ring buffer for given substream

  

   Parameters:  substream  - PCM substream class

		hw_params  - hardware parameters

  

   Returns:     Error status

  

/*---------------------------------------------------------------------------

   snd_trident_allocate_evoice

  

   Description: Allocate extra voice as interrupt generator

  

   Parameters:  substream  - PCM substream class

		hw_params  - hardware parameters

  

   Returns:     Error status

  

 voice management */

/*---------------------------------------------------------------------------

   snd_trident_hw_params

  

   Description: Set the hardware parameters for the playback device.

  

   Parameters:  substream  - PCM substream class

		hw_params  - hardware parameters

  

   Returns:     Error status

  

/*---------------------------------------------------------------------------

   snd_trident_playback_hw_free

  

   Description: Release the hardware resources for the playback device.

  

   Parameters:  substream  - PCM substream class

  

   Returns:     Error status

  

/*---------------------------------------------------------------------------

   snd_trident_playback_prepare

  

   Description: Prepare playback device for playback.

  

   Parameters:  substream  - PCM substream class

  

   Returns:     Error status

  

 set delta (rate) value */

 set Loop Begin Address */

 in samples */

 in samples */

 mute */

 mute */

 mute */

/*---------------------------------------------------------------------------

   snd_trident_capture_hw_params

  

   Description: Set the hardware parameters for the capture device.

  

   Parameters:  substream  - PCM substream class

		hw_params  - hardware parameters

  

   Returns:     Error status

  

/*---------------------------------------------------------------------------

   snd_trident_capture_prepare

  

   Description: Prepare capture device for playback.

  

   Parameters:  substream  - PCM substream class

  

   Returns:     Error status

  

 Initialize the channel and set channel Mode

 Set DMA channel operation mode register

 Set channel buffer Address, DMAR0 expects contiguous PCI memory area	

 set ESO

 Set channel sample rate, 4.12 format

 Set channel interrupt blk length

 Right now, set format and start to run captureing, 

 continuous run loop enable.

 0001 1001b

 Prepare capture intr channel

 Set voice parameters

 mute */

 mute */

/*---------------------------------------------------------------------------

   snd_trident_si7018_capture_hw_params

  

   Description: Set the hardware parameters for the capture device.

  

   Parameters:  substream  - PCM substream class

		hw_params  - hardware parameters

  

   Returns:     Error status

  

/*---------------------------------------------------------------------------

   snd_trident_si7018_capture_hw_free

  

   Description: Release the hardware resources for the capture device.

  

   Parameters:  substream  - PCM substream class

  

   Returns:     Error status

  

/*---------------------------------------------------------------------------

   snd_trident_si7018_capture_prepare

  

   Description: Prepare capture device for playback.

  

   Parameters:  substream  - PCM substream class

  

   Returns:     Error status

  

 Set voice parameters

 in samples */

 in samples, 20 means correction */

 mute */

 mute */

 mute */

/*---------------------------------------------------------------------------

   snd_trident_foldback_prepare

  

   Description: Prepare foldback capture device for playback.

  

   Parameters:  substream  - PCM substream class

  

   Returns:     Error status

  

 Set channel buffer Address */

 set target ESO for channel */

 in samples */

 set sample rate */

 mute */

 mute */

 set up capture channel */

 in samples */

 mute */

 mute */

 mute */

/*---------------------------------------------------------------------------

   snd_trident_spdif_hw_params

  

   Description: Set the hardware parameters for the spdif device.

  

   Parameters:  substream  - PCM substream class

		hw_params  - hardware parameters

  

   Returns:     Error status

  

 prepare SPDIF channel */

 48000 Hz

 44100 Hz

 32000 Hz

/*---------------------------------------------------------------------------

   snd_trident_spdif_prepare

  

   Description: Prepare SPDIF device for playback.

  

   Parameters:  substream  - PCM substream class

  

   Returns:     Error status

  

 set delta (rate) value */

 set Loop Back Address */

 set target ESO for channel */

 set ctrl mode */

 prepare surrogate IRQ channel */

 set SPDIF setting */

 SiS */

 set delta (rate) value */

 set Loop Begin Address */

 in samples */

 in samples */

 mute */

 mute */

 mute */

/*---------------------------------------------------------------------------

   snd_trident_trigger

  

   Description: Start/stop devices

  

   Parameters:  substream  - PCM substream class

   		cmd	- trigger command (STOP, GO)

  

   Returns:     Error status

  

/*---------------------------------------------------------------------------

   snd_trident_playback_pointer

  

   Description: This routine return the playback position

                

   Parameters:	substream  - PCM substream class



   Returns:     position of buffer

  

 ID_4DWAVE_NX

/*---------------------------------------------------------------------------

   snd_trident_capture_pointer

  

   Description: This routine return the capture position

                

   Parameters:   pcm1    - PCM device class



   Returns:     position of buffer

  

/*---------------------------------------------------------------------------

   snd_trident_spdif_pointer

  

   Description: This routine return the SPDIF playback position

                

   Parameters:	substream  - PCM substream class



   Returns:     position of buffer

  

/*

 *  Playback support device description

 | SNDRV_PCM_INFO_RESUME */),

/*

 *  Capture support device description

 | SNDRV_PCM_INFO_RESUME */),

/*

 *  Foldback capture support device description

 | SNDRV_PCM_INFO_RESUME */),

/*

 *  SPDIF playback support device description

 | SNDRV_PCM_INFO_RESUME */),

 | SNDRV_PCM_INFO_RESUME */),

/*---------------------------------------------------------------------------

   snd_trident_playback_close

  

   Description: This routine will close the 4DWave playback device. For now 

                we will simply free the dma transfer buffer.

                

   Parameters:	substream  - PCM substream class



/*---------------------------------------------------------------------------

   snd_trident_spdif_open

  

   Description: This routine will open the 4DWave SPDIF device.



   Parameters:	substream  - PCM substream class



   Returns:     status  - success or failure flag

  

/*---------------------------------------------------------------------------

   snd_trident_spdif_close

  

   Description: This routine will close the 4DWave SPDIF device.

                

   Parameters:	substream  - PCM substream class



 restore default SPDIF setting

/*---------------------------------------------------------------------------

   snd_trident_capture_open

  

   Description: This routine will open the 4DWave capture device.



   Parameters:	substream  - PCM substream class



   Returns:     status  - success or failure flag



/*---------------------------------------------------------------------------

   snd_trident_capture_close

  

   Description: This routine will close the 4DWave capture device. For now 

                we will simply free the dma transfer buffer.

                

   Parameters:	substream  - PCM substream class



/*---------------------------------------------------------------------------

   snd_trident_foldback_open

  

   Description: This routine will open the 4DWave foldback capture device.



   Parameters:	substream  - PCM substream class



   Returns:     status  - success or failure flag



/*---------------------------------------------------------------------------

   snd_trident_foldback_close

  

   Description: This routine will close the 4DWave foldback capture device. 

		For now we will simply free the dma transfer buffer.

                

   Parameters:	substream  - PCM substream class



 stop capture channel */

/*---------------------------------------------------------------------------

   PCM operations

/*---------------------------------------------------------------------------

   snd_trident_pcm

  

   Description: This routine registers the 4DWave device for PCM support.

                

   Parameters:  trident - pointer to target device class for 4DWave.



   Returns:     None

  

/*---------------------------------------------------------------------------

   snd_trident_foldback_pcm

  

   Description: This routine registers the 4DWave device for foldback PCM support.

                

   Parameters:  trident - pointer to target device class for 4DWave.



   Returns:     None

  

/*---------------------------------------------------------------------------

   snd_trident_spdif

  

   Description: This routine registers the 4DWave-NX device for SPDIF support.

                

   Parameters:  trident - pointer to target device class for 4DWave-NX.



   Returns:     None

  

/*

 *  Mixer part

/*---------------------------------------------------------------------------

    snd_trident_spdif_control



    Description: enable/disable S/PDIF out from ac97 mixer

 S/PDIF C Channel bits 0-31 : 48khz, SCMS disabled */

/*---------------------------------------------------------------------------

    snd_trident_spdif_default



    Description: put/get the S/PDIF default settings

/*---------------------------------------------------------------------------

    snd_trident_spdif_mask



    Description: put/get the S/PDIF mask

/*---------------------------------------------------------------------------

    snd_trident_spdif_stream



    Description: put/get the S/PDIF stream settings

/*---------------------------------------------------------------------------

    snd_trident_ac97_control



    Description: enable/disable rear path for ac97

/*---------------------------------------------------------------------------

    snd_trident_vol_control



    Description: wave & music volume control

/*---------------------------------------------------------------------------

    snd_trident_pcm_vol_control



    Description: PCM front volume control

 FIXME: no tlv yet */

/*---------------------------------------------------------------------------

    snd_trident_pcm_pan_control



    Description: PCM front pan control

/*---------------------------------------------------------------------------

    snd_trident_pcm_rvol_control



    Description: PCM reverb volume control

/*---------------------------------------------------------------------------

    snd_trident_pcm_cvol_control



    Description: PCM chorus volume control

/*---------------------------------------------------------------------------

   snd_trident_mixer

  

   Description: This routine registers the 4DWave device for mixer support.

                

   Parameters:  trident - pointer to target device class for 4DWave.



   Returns:     None

  

 secondary codec? */

 only for my testing purpose --jk

/*

 * gameport interface

 CONFIG_GAMEPORT */

/*

 * delay for 1 tick

/*

 *  SiS reset routine

 count of retries */

 SOFTWARE RESET */

 disable AC97 GPIO interrupt */

 initialize serial interface, force cold reset */

 remove cold reset */

 wait, until the codec is ready */

 wait for the second codec */

 enable 64 channel mode */

/*  

 *  /proc interface

/*---------------------------------------------------------------------------

   snd_trident_tlb_alloc

  

   Description: Allocate and set up the TLB page table on 4D NX.

		Each entry has 4 bytes (physical PCI address).

                

   Parameters:  trident - pointer to target device class for 4DWave.



   Returns:     0 or negative error code

  

	/* TLB array must be aligned to 16kB !!! so we allocate

 allocate and setup silent page and initialise TLB entries */

 use emu memory block manager code to manage tlb page allocation */

/*

 * initialize 4D DX chip

 reset the legacy configuration and whole audio/wavetable block */

 DDMA */

 ports */

 Legacy DMA */

 reset */

 release reset */

 warm reset of the AC'97 codec */

 DAC on, disable SB IRQ and try to force ADC valid signal */

 wait, until the codec is ready */

/*

 * initialize 4D NX chip

 reset the legacy configuration and whole audio/wavetable block */

 DDMA */

 ports */

 Legacy DMA */

 reset */

 release reset */

 warm reset of the AC'97 codec */

 wait, until the codec is ready */

 DAC on */

 disable SB IRQ */

 enable virtual addressing via TLB */

 initialize S/PDIF */

/*

 * initialize sis7018 chip

 initialize S/PDIF */

/*---------------------------------------------------------------------------

   snd_trident_create

  

   Description: This routine will create the device specific class for

                the 4DWave card. It will also perform basic initialization.

                

   Parameters:  card  - which card to create

                pci   - interface to PCI bus resource info

                dma1ptr - playback dma buffer

                dma2ptr - capture dma buffer

                irqptr  -  interrupt resource info



   Returns:     4DWave device class private data

  

 enable PCI device */

 check, if we can restrict PCI DMA transfers to 30 bits */

 allocate 16k-aligned TLB for NX cards */

 initialize chip */

 initialise synth voices */

 initialize pcm mixer entries */

/*---------------------------------------------------------------------------

   snd_trident_free

  

   Description: This routine will free the device specific class for

                the 4DWave card. 

                

   Parameters:  card - card to release



   Returns:     None.

  

 Disable S/PDIF out

/*---------------------------------------------------------------------------

   snd_trident_interrupt

  

   Description: ISR for Trident 4DWave device

                

   Parameters:  trident  - device specific private data for 4DWave card



   Problems:    It seems that Trident chips generates interrupts more than

                one time in special cases. The spurious interrupts are

                detected via sample timer (T4D_STIMER) and computing

                corresponding delta value. The limits are detected with

                the method try & fail so it is possible that it won't

                work on all computers. [jaroslav]



   Returns:     None.

  

 get interrupt status for all channels

 ack */

 do some statistics here */

 update ESO for IRQ voice to preserve sync */

 write original ESO and update CSO for IRQ voice to preserve sync */

 update CSO for extra voice to preserve sync */

 ack */

 outl((ST_TARGET_REACHED | MIXER_OVERFLOW | MIXER_UNDERFLOW), TRID_REG(trident, T4D_MISCINT));

 restore some registers */

 CONFIG_PM_SLEEP */

 SPDX-License-Identifier: GPL-2.0-or-later

/***************************************************************************

 *            au88x0_a3d.c

 *

 *  Fri Jul 18 14:16:22 2003

 *  Copyright  2003  mjander

 *  mjander@users.sourceforge.net

 *

 * A3D. You may think i'm crazy, but this may work someday. Who knows...

/*

 stub!

 Atmospheric absorption. */

 HRTF */

 FIXME: verify this!

/* Interaural Time Difference. 

 * "The other main clue that humans use to locate sounds, is called 

 * Interaural Time Difference (ITD). The differences in distance from 

 * the sound source to a listeners ears means  that the sound will 

hwwrite(vortex->mmio, addr(0x191DF+5, this04, this08), (ritd<<0x10)|litd);

hwwrite(vortex->mmio, addr(0x191DF+1, this04, this08), (ritd<<0x10)|litd);

 45 != 40 -> Check this ! */

 This is may be used for ILD Interaural Level Difference. */

 CA3dIO this func seems to be inlined all over this place. */

 Generic A3D stuff */

hwwrite(vortex->mmio, 0x19C38 + (this08<<0xd), esp0);

hwwrite(vortex->mmio, 0x19C38 + (this08<<0xd), 0xF0000001);

	//*sr = ((hwread(vortex->mmio, 0x19C38 + (this08<<0xd))>>3)&0x1f);

}



static void a3dsrc_GetA3DControlReg(a3dsrc_t * a, unsigned long *ctrl)

{

	vortex_t *vortex = (vortex_t *) (a->vortex);

	*ctrl = hwread(vortex->mmio, A3D_SLICE_Control + ((a->slice) << 0xd));

}



static void a3dsrc_GetA3DPointerReg(a3dsrc_t * a, unsigned long *ptr)

{

	vortex_t *vortex = (vortex_t *) (a->vortex);

	*ptr = hwread(vortex->mmio, A3D_SLICE_Pointers + ((a->slice) << 0xd));

}



#endif

static void a3dsrc_ZeroSliceIO(a3dsrc_t * a)

{

	vortex_t *vortex = (vortex_t *) (a->vortex);

	int i;



	for (i = 0; i < 8; i++)

		hwwrite(vortex->mmio,

			A3D_SLICE_VDBDest +

			((((a->slice) << 0xb) + i) << 2), 0);

	for (i = 0; i < 4; i++)

		hwwrite(vortex->mmio,

			A3D_SLICE_VDBSource +

			((((a->slice) << 0xb) + i) << 2), 0);

}



/* Reset Single A3D source. */

static void a3dsrc_ZeroState(a3dsrc_t * a)

{



	*/

	a3dsrc_SetAtmosState(a, 0, 0, 0, 0);

	a3dsrc_SetHrtfState(a, A3dHrirZeros, A3dHrirZeros);

	a3dsrc_SetItdDline(a, A3dItdDlineZeros);

	a3dsrc_SetHrtfOutput(a, 0, 0);

	a3dsrc_SetTimeConsts(a, 0, 0, 0, 0);



	a3dsrc_SetAtmosCurrent(a, 0, 0, 0, 0, 0);

	a3dsrc_SetAtmosTarget(a, 0, 0, 0, 0, 0);

	a3dsrc_SetItdCurrent(a, 0, 0);

	a3dsrc_SetItdTarget(a, 0, 0);

	a3dsrc_SetGainCurrent(a, 0, 0);

	a3dsrc_SetGainTarget(a, 0, 0);



	a3dsrc_SetHrtfCurrent(a, A3dHrirZeros, A3dHrirZeros);

	a3dsrc_SetHrtfTarget(a, A3dHrirZeros, A3dHrirZeros);

}



/* Reset entire A3D engine */

static void a3dsrc_ZeroStateA3D(a3dsrc_t *a, vortex_t *v)

{

	int i, var, var2;



	if ((a->vortex) == NULL) {

		dev_err(v->card->dev,

			"ZeroStateA3D: ERROR: a->vortex is NULL\n");

		return;

	}



	a3dsrc_SetA3DControlReg(a, 0);

	a3dsrc_SetA3DPointerReg(a, 0);



	var = a->slice;

	var2 = a->source;

	for (i = 0; i < 4; i++) {

		a->slice = i;

		a3dsrc_ZeroSliceIO(a);

		//a3dsrc_ZeroState(a);

	}

	a->source = var2;

	a->slice = var;

}



/* Program A3D block as pass through */

static void a3dsrc_ProgramPipe(a3dsrc_t * a)

{

	a3dsrc_SetTimeConsts(a, 0, 0, 0, 0);

	a3dsrc_SetAtmosCurrent(a, 0, 0x4000, 0, 0, 0);

	a3dsrc_SetAtmosTarget(a, 0x4000, 0, 0, 0, 0);

	a3dsrc_SetItdCurrent(a, 0, 0);

	a3dsrc_SetItdTarget(a, 0, 0);

	a3dsrc_SetGainCurrent(a, 0x7fff, 0x7fff);

	a3dsrc_SetGainTarget(a, 0x7fff, 0x7fff);



	/* SET HRTF HERE */



	/* Single spike leads to identity transfer function. */

	a3dsrc_SetHrtfCurrent(a, A3dHrirImpulse, A3dHrirImpulse);

	a3dsrc_SetHrtfTarget(a, A3dHrirImpulse, A3dHrirImpulse);



	/* Test: Sounds saturated. */

	//a3dsrc_SetHrtfCurrent(a, A3dHrirSatTest, A3dHrirSatTest);

	//a3dsrc_SetHrtfTarget(a, A3dHrirSatTest, A3dHrirSatTest);      

}



/* VDB = Vortex audio Dataflow Bus */

#if 0

static void a3dsrc_ClearVDBData(a3dsrc_t * a, unsigned long aa)

{

	vortex_t *vortex = (vortex_t *) (a->vortex);



	// ((aa >> 2) << 8) - (aa >> 2)

	hwwrite(vortex->mmio,

		a3d_addrS(a->slice, A3D_SLICE_VDBDest) + (a->source << 2), 0);

	hwwrite(vortex->mmio,

		a3d_addrS(a->slice,

			  A3D_SLICE_VDBDest + 4) + (a->source << 2), 0);



	 */

}

#endif



/* A3D HwSource stuff. */



static void vortex_A3dSourceHw_Initialize(vortex_t * v, int source, int slice)

{

	a3dsrc_t *a3dsrc = &(v->a3d[source + (slice * 4)]);

	//a3dsrc_t *a3dsrc = &(v->a3d[source + (slice*4)]);



	a3dsrc->vortex = (void *)v;

	a3dsrc->source = source;	/* source */

	a3dsrc->slice = slice;	/* slice */

	a3dsrc_ZeroState(a3dsrc);

	/* Added by me. */

	a3dsrc_SetA3DSampleRate(a3dsrc, 0x11);

}



static int Vort3DRend_Initialize(vortex_t * v, unsigned short mode)

{

	v->xt_mode = mode;	/* this_14 */



	vortex_XtalkHw_init(v);

	vortex_XtalkHw_SetGainsAllChan(v);

	switch (v->xt_mode) {

	case XT_SPEAKER0:

		vortex_XtalkHw_ProgramXtalkNarrow(v);

		break;

	case XT_SPEAKER1:

		vortex_XtalkHw_ProgramXtalkWide(v);

		break;

	default:

	case XT_HEADPHONE:

		vortex_XtalkHw_ProgramPipe(v);

		break;

	case XT_DIAMOND:

		vortex_XtalkHw_ProgramDiamondXtalk(v);

		break;

	}

	vortex_XtalkHw_SetSampleRate(v, 0x11);

	vortex_XtalkHw_Enable(v);

	return 0;

}



/* 3D Sound entry points. */



static int vortex_a3d_register_controls(vortex_t * vortex);

static void vortex_a3d_unregister_controls(vortex_t * vortex);

/* A3D base support init/shudown */

static void vortex_Vort3D_enable(vortex_t *v)

{

	int i;



	Vort3DRend_Initialize(v, XT_HEADPHONE);

	for (i = 0; i < NR_A3D; i++) {

		vortex_A3dSourceHw_Initialize(v, i % 4, i >> 2);

		a3dsrc_ZeroStateA3D(&v->a3d[0], v);

	}

	/* Register ALSA controls */

	vortex_a3d_register_controls(v);

}



static void vortex_Vort3D_disable(vortex_t * v)

{

	vortex_XtalkHw_Disable(v);

	vortex_a3d_unregister_controls(v);

}



/* Make A3D subsystem connections. */

static void vortex_Vort3D_connect(vortex_t * v, int en)

{

	int i;

	

// Disable AU8810 routes, since they seem to be wrong (in au8810.h).

#ifdef CHIP_AU8810

	return;

#endif

	

#if 1

	/* Alloc Xtalk mixin resources */

	v->mixxtlk[0] =

	    vortex_adb_checkinout(v, v->fixed_res, en, VORTEX_RESOURCE_MIXIN);

	if (v->mixxtlk[0] < 0) {

		dev_warn(v->card->dev,

			 "vortex_Vort3D: ERROR: not enough free mixer resources.\n");

		return;

	}

	v->mixxtlk[1] =

	    vortex_adb_checkinout(v, v->fixed_res, en, VORTEX_RESOURCE_MIXIN);

	if (v->mixxtlk[1] < 0) {

		dev_warn(v->card->dev,

			 "vortex_Vort3D: ERROR: not enough free mixer resources.\n");

		return;

	}

#endif



	/* Connect A3D -> XTALK */

	for (i = 0; i < 4; i++) {

		// 2 outputs per each A3D slice. 

		vortex_route(v, en, 0x11, ADB_A3DOUT(i * 2), ADB_XTALKIN(i));

		vortex_route(v, en, 0x11, ADB_A3DOUT(i * 2) + 1, ADB_XTALKIN(5 + i));

	}

#if 0

	vortex_route(v, en, 0x11, ADB_XTALKOUT(0), ADB_EQIN(2));

	vortex_route(v, en, 0x11, ADB_XTALKOUT(1), ADB_EQIN(3));

#else

	/* Connect XTalk -> mixer */

	vortex_route(v, en, 0x11, ADB_XTALKOUT(0), ADB_MIXIN(v->mixxtlk[0]));

	vortex_route(v, en, 0x11, ADB_XTALKOUT(1), ADB_MIXIN(v->mixxtlk[1]));

	vortex_connection_mixin_mix(v, en, v->mixxtlk[0], v->mixplayb[0], 0);

	vortex_connection_mixin_mix(v, en, v->mixxtlk[1], v->mixplayb[1], 0);

	vortex_mix_setinputvolumebyte(v, v->mixplayb[0], v->mixxtlk[0],

				      en ? MIX_DEFIGAIN : VOL_MIN);

	vortex_mix_setinputvolumebyte(v, v->mixplayb[1], v->mixxtlk[1],

				      en ? MIX_DEFIGAIN : VOL_MIN);

	if (VORTEX_IS_QUAD(v)) {

		vortex_connection_mixin_mix(v, en, v->mixxtlk[0],

					    v->mixplayb[2], 0);

		vortex_connection_mixin_mix(v, en, v->mixxtlk[1],

					    v->mixplayb[3], 0);

		vortex_mix_setinputvolumebyte(v, v->mixplayb[2],

					      v->mixxtlk[0],

					      en ? MIX_DEFIGAIN : VOL_MIN);

		vortex_mix_setinputvolumebyte(v, v->mixplayb[3],

					      v->mixxtlk[1],

					      en ? MIX_DEFIGAIN : VOL_MIN);

	}

#endif

}



/* Initialize one single A3D source. */

static void vortex_Vort3D_InitializeSource(a3dsrc_t *a, int en, vortex_t *v)

{

	if (a->vortex == NULL) {

		dev_warn(v->card->dev,

			 "Vort3D_InitializeSource: A3D source not initialized\n");

		return;

	}

	if (en) {

		a3dsrc_ProgramPipe(a);

		a3dsrc_SetA3DSampleRate(a, 0x11);

		a3dsrc_SetTimeConsts(a, HrtfTCDefault,

				     ItdTCDefault, GainTCDefault,

				     CoefTCDefault);

		/* Remark: zero gain is muted. */

		//a3dsrc_SetGainTarget(a,0,0);

		//a3dsrc_SetGainCurrent(a,0,0);

		a3dsrc_EnableA3D(a);

	} else {

		a3dsrc_DisableA3D(a);

		a3dsrc_ZeroState(a);

	}

}



/* Conversion of coordinates into 3D parameters. */



static void vortex_a3d_coord2hrtf(a3d_Hrtf_t hrtf, int *coord)

{

	/* FIXME: implement this. */



}

static void vortex_a3d_coord2itd(a3d_Itd_t itd, int *coord)

{

	/* FIXME: implement this. */



}

static void vortex_a3d_coord2ild(a3d_LRGains_t ild, int left, int right)

{

	/* FIXME: implement this. */



}

static void vortex_a3d_translate_filter(a3d_atmos_t filter, int *params)

{

	/* FIXME: implement this. */



}



/* ALSA control interface.  */



static int

snd_vortex_a3d_hrtf_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)

{

	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;

	uinfo->count = 6;

	uinfo->value.integer.min = 0x00000000;

	uinfo->value.integer.max = 0xffffffff;

	return 0;

}

static int

snd_vortex_a3d_itd_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)

{

	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;

	uinfo->count = 2;

	uinfo->value.integer.min = 0x00000000;

	uinfo->value.integer.max = 0xffffffff;

	return 0;

}

static int

snd_vortex_a3d_ild_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)

{

	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;

	uinfo->count = 2;

	uinfo->value.integer.min = 0x00000000;

	uinfo->value.integer.max = 0xffffffff;

	return 0;

}

static int

snd_vortex_a3d_filter_info(struct snd_kcontrol *kcontrol,

			   struct snd_ctl_elem_info *uinfo)

{

	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;

	uinfo->count = 4;

	uinfo->value.integer.min = 0x00000000;

	uinfo->value.integer.max = 0xffffffff;

	return 0;

}



static int

snd_vortex_a3d_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)

{

	//a3dsrc_t *a = kcontrol->private_data;

	/* No read yet. Would this be really useable/needed ? */



	return 0;

}



static int

snd_vortex_a3d_hrtf_put(struct snd_kcontrol *kcontrol,

			struct snd_ctl_elem_value *ucontrol)

{

	a3dsrc_t *a = kcontrol->private_data;

	int i;

	int coord[6];

	for (i = 0; i < 6; i++)

		coord[i] = ucontrol->value.integer.value[i];

	/* Translate orientation coordinates to a3d params. */

	vortex_a3d_coord2hrtf(a->hrtf[0], coord);

	vortex_a3d_coord2hrtf(a->hrtf[1], coord);

	a3dsrc_SetHrtfTarget(a, a->hrtf[0], a->hrtf[1]);

	a3dsrc_SetHrtfCurrent(a, a->hrtf[0], a->hrtf[1]);

	return 1;

}



static int

snd_vortex_a3d_itd_put(struct snd_kcontrol *kcontrol,

		       struct snd_ctl_elem_value *ucontrol)

{

	a3dsrc_t *a = kcontrol->private_data;

	int coord[6];

	int i;

	for (i = 0; i < 6; i++)

		coord[i] = ucontrol->value.integer.value[i];

	/* Translate orientation coordinates to a3d params. */

	vortex_a3d_coord2itd(a->hrtf[0], coord);

	vortex_a3d_coord2itd(a->hrtf[1], coord);

	/* Inter aural time difference. */

	a3dsrc_SetItdTarget(a, a->itd[0], a->itd[1]);

	a3dsrc_SetItdCurrent(a, a->itd[0], a->itd[1]);

	a3dsrc_SetItdDline(a, a->dline);

	return 1;

}



static int

snd_vortex_a3d_ild_put(struct snd_kcontrol *kcontrol,

		       struct snd_ctl_elem_value *ucontrol)

{

	a3dsrc_t *a = kcontrol->private_data;

	int l, r;

	/* There may be some scale tranlation needed here. */

	l = ucontrol->value.integer.value[0];

	r = ucontrol->value.integer.value[1];

	vortex_a3d_coord2ild(a->ild, l, r);

	/* Left Right panning. */

	a3dsrc_SetGainTarget(a, l, r);

	a3dsrc_SetGainCurrent(a, l, r);

	return 1;

}



static int

snd_vortex_a3d_filter_put(struct snd_kcontrol *kcontrol,

			  struct snd_ctl_elem_value *ucontrol)

{

	a3dsrc_t *a = kcontrol->private_data;

	int i;

	int params[6];

	for (i = 0; i < 6; i++)

		params[i] = ucontrol->value.integer.value[i];

	/* Translate generic filter params to a3d filter params. */

	vortex_a3d_translate_filter(a->filter, params);

	/* Atmospheric absorption and filtering. */

	a3dsrc_SetAtmosTarget(a, a->filter[0],

			      a->filter[1], a->filter[2],

			      a->filter[3], a->filter[4]);

	a3dsrc_SetAtmosCurrent(a, a->filter[0],

			       a->filter[1], a->filter[2],

			       a->filter[3], a->filter[4]);

	return 1;

}



static const struct snd_kcontrol_new vortex_a3d_kcontrol = {

	.iface = SNDRV_CTL_ELEM_IFACE_PCM,

	.name = "Playback PCM advanced processing",

	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,

	.info = snd_vortex_a3d_hrtf_info,

	.get = snd_vortex_a3d_get,

	.put = snd_vortex_a3d_hrtf_put,

};



/* Control (un)registration. */

static int vortex_a3d_register_controls(vortex_t *vortex)

{

	struct snd_kcontrol *kcontrol;

	int err, i;

	/* HRTF controls. */

	for (i = 0; i < NR_A3D; i++) {

		kcontrol = snd_ctl_new1(&vortex_a3d_kcontrol, &vortex->a3d[i]);

		if (!kcontrol)

			return -ENOMEM;

		kcontrol->id.numid = CTRLID_HRTF;

		kcontrol->info = snd_vortex_a3d_hrtf_info;

		kcontrol->put = snd_vortex_a3d_hrtf_put;

		err = snd_ctl_add(vortex->card, kcontrol);

		if (err < 0)

			return err;

	}

	/* ITD controls. */

	for (i = 0; i < NR_A3D; i++) {

		kcontrol = snd_ctl_new1(&vortex_a3d_kcontrol, &vortex->a3d[i]);

		if (!kcontrol)

			return -ENOMEM;

		kcontrol->id.numid = CTRLID_ITD;

		kcontrol->info = snd_vortex_a3d_itd_info;

		kcontrol->put = snd_vortex_a3d_itd_put;

		err = snd_ctl_add(vortex->card, kcontrol);

		if (err < 0)

			return err;

	}

	/* ILD (gains) controls. */

	for (i = 0; i < NR_A3D; i++) {

		kcontrol = snd_ctl_new1(&vortex_a3d_kcontrol, &vortex->a3d[i]);

		if (!kcontrol)

			return -ENOMEM;

		kcontrol->id.numid = CTRLID_GAINS;

		kcontrol->info = snd_vortex_a3d_ild_info;

		kcontrol->put = snd_vortex_a3d_ild_put;

		err = snd_ctl_add(vortex->card, kcontrol);

		if (err < 0)

			return err;

	}

	/* Filter controls. */

	for (i = 0; i < NR_A3D; i++) {

		kcontrol = snd_ctl_new1(&vortex_a3d_kcontrol, &vortex->a3d[i]);

		if (!kcontrol)

			return -ENOMEM;

		kcontrol->id.numid = CTRLID_FILTER;

		kcontrol->info = snd_vortex_a3d_filter_info;

		kcontrol->put = snd_vortex_a3d_filter_put;

		err = snd_ctl_add(vortex->card, kcontrol);

		if (err < 0)

			return err;

	}

	return 0;

}



static void vortex_a3d_unregister_controls(vortex_t * vortex)

{



}



/* End of File*/

 SPDX-License-Identifier: GPL-2.0-or-later

/***************************************************************************

 *            au88x0_a3ddata.c

 *

 *  Wed Nov 19 21:11:32 2003

 *  Copyright  2003  mjander

 *  mjander@users.sourceforge.org

/*

 Constant initializer values. */

 SPDX-License-Identifier: GPL-2.0

 Data structs */

 More coef sets can be found in the win2k "inf" file. */

 _rodatab60 */

 _rodatab7c:  ProgramPipe */

 _rodatab78 */

_rodataba0:*/

 SPDX-License-Identifier: GPL-2.0

/*

 * Vortex Mixer support.

 *

 * There is much more than just the AC97 mixer...

 *

 Initialize AC97 codec stuff.

 SPDX-License-Identifier: GPL-2.0-or-later

/***************************************************************************

 *            au88x0_eq.c

 *  Aureal Vortex Hardware EQ control/access.

 *

 *  Sun Jun  8 18:19:19 2003

 *  2003  Manuel Jander (mjander@users.sourceforge.net)

 *  

 *  02 July 2003: First time something works :)

 *  November 2003: A3D Bypass code completed but untested.

 *

 *  TODO:

 *     - Debug (testing)

 *     - Test peak visualization support.

 *

/*

/*

 The Aureal Hardware EQ is found on AU8810 and AU8830 chips only.

 it has 4 inputs (2 for general mix, 2 for A3D) and 2 outputs (supposed 

 to be routed to the codec).

 CEqHw.s */

 -(-32768) -> -32768 so we do -(-32768) -> 32767 to make the result positive */

esp2c */;

esp2c */;

 Mix Gains */

 EQ band levels settings */

 set left peaks */

 set right peaks */

 Global Control */

 Reset (zero) buffers */

vortex_EqHw_SetCurrBypassGain(vortex, 0, 0);

vortex_EqHw_SetCurrA3DBypassGain(vortex, 0, 0);

 Program coeficients as pass through */

 Program EQ block as 10 band Equalizer */

 Read all EQ peaks. (think VU meter) */

 CEqlzr.s */

 EQ enabled */

 EQ disabled. */

 Set EQ BiQuad filter coeficients */

 Set EQ Band gain levels and dump into hardware registers. */

 Object constructor */

eq->this04 = 0;

 Bypass gain with EQ in use. */

 Bypass gain with EQ disabled. */

 10 eq frequency bands. */

 if 1 => Allow read access to this130 (gains) */

 if 1 => Dont Allow access to hardware (gains) */

 Set gains. */

 Actual init. */

 ALSA interface */

 Control interface */

int i = kcontrol->private_value;

int i = kcontrol->private_value;

 Allways changes */

 EQ band gain labels. */

 ALSA driver entry points. Init and exit. */

 EQ gain controls */

vortex->eqctrl[i] = kcontrol;

 EQ band levels */

	/*

	   //FIXME: segfault because vortex->eqctrl[i] == 4

	   int i;

	   for (i=0; i<10; i++) {

	   if (vortex->eqctrl[i])

	   snd_ctl_remove(vortex->card, vortex->eqctrl[i]);

	   }

 End */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Manuel Jander.

 *

 *  Based on the work of:

 *  Vojtech Pavlik

 *  Raymond Ingles

 *

 * Should you need to contact me, the author, you can do so either by

 * e-mail - mail your message to <vojtech@suse.cz>, or by paper mail:

 * Vojtech Pavlik, Ucitelska 1576, Prague 8, 182 00 Czech Republic

 *

 * Based 90% on Vojtech Pavlik pcigame driver.

 * Merged and modified by Manuel Jander, for the OpenVortex

 * driver. (email: mjander@embedded.cl).

 20 ms */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

/*

 * Vortex PCM ALSA driver.

 *

 * Supports ADB and WT DMA. Unfortunately, WT channels do not run yet.

 * It remains stuck,and DMA transfers do not happen. 

 hardware definition */

 SNDRV_PCM_INFO_RESUME | */

 SNDRV_PCM_INFO_RESUME | */

 SNDRV_PCM_INFO_RESUME | */

 SNDRV_PCM_RATE_48000,

 open callback */

 Force equal size periods */

 Avoid PAGE_SIZE boundary to fall inside of a period. */

 close callback */

vortex_t *chip = snd_pcm_substream_chip(substream);

 the hardware-specific codes will be here

 hw_params callback */

	/*

	   pr_info( "Vortex: periods %d, period_bytes %d, channels = %d\n", params_periods(hw_params),

	   params_period_bytes(hw_params), params_channels(hw_params));

 Make audio routes and config buffer DMA.

 Dealloc any routes. */

 Alloc routes. */

 Setup Buffers. */

		/* if (stream != NULL)

 hw_free callback */

 Delete audio routes.

 prepare callback */

 set up the hardware with the current configuration.

 FIXME: Set rate (i guess using vortex_wt_writereg() somehow).

 trigger callback */

 do something to start the PCM engine

printk(KERN_INFO "vortex: start %d\n", dma);

 do something to stop the PCM engine

printk(KERN_INFO "vortex: stop %d\n", dma);

printk(KERN_INFO "vortex: pause %d\n", dma);

printk(KERN_INFO "vortex: resume %d\n", dma);

 pointer callback */

printk(KERN_INFO "vortex: pointer = 0x%x\n", current_ptr);

 operators */

/*

*  definitions of capture are omitted here...

 SPDIF kcontrol */

 spdif controls */

 subdevice PCM Volume control */

 create a pcm device */

	/* idx indicates which kind of PCM device. ADB, SPDIF, I2S and A3D share the 

 This is an evil hack, but it saves a lot of duplicated code.

 set operators */

 pre-allocation of Scatter-Gather buffers */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

/*

 * Someday its supposed to make use of the WT DMA engine

 * for a Wavetable synthesizer.

 WT */

 Put 2 WT channels together for one stereo interlaced channel. */

temp = hwread(vortex->mmio, 0x80 + ((wt >> 0x5)<< 0xf) + (((wt & 0x1f) >> 1) << 2));

hwwrite(vortex->mmio, 0x80 + ((wt >> 0x5)<< 0xf) + (((wt & 0x1f) >> 1) << 2), temp);

 Join to mixdown route. */

 There is one DSREG register for each bank (32 voices each). */

 Setup WT route. */

FIXME: WT audio routing.

 Set mixdown mode. */

 Set other parameter registers. */

hwwrite(vortex->mmio, WT_GMODE(0), 0xffffffff);

hwwrite(vortex->mmio, WT_GMODE(1), 0xffffffff);

hwwrite(vortex->mmio, WT_PARM(wt, 3), temp);

 Read WT Register */

int eax, esi;

 WT hardware abstraction layer generic register interface. */

	/*

	   int eax, edx;



	   if (wt >= NR_WT)  // 0x40 -> NR_WT

	   return 0;



	   if ((reg - 0x20) > 0) {

	   if ((reg - 0x21) != 0) 

	   return 0;

	   eax = ((((b & 0xff) << 0xb) + (edx & 0xff)) << 4) + 0x208; // param 2

	   } else {

	   eax = ((((b & 0xff) << 0xb) + (edx & 0xff)) << 4) + 0x20a; // param 3

	   }

	   hwwrite(vortex->mmio, eax, c);

public: static void __thiscall CWTHal::SetReg(unsigned char,int,unsigned long) */

 Voice specific parameters */

 running */

		/*

		pr_debug( "vortex: WT SetReg(0x%x) = 0x%08x\n",

		       WT_RUN(wt), (int)val);

 param 0 */

		/*

		pr_debug( "vortex: WT SetReg(0x%x) = 0x%08x\n",

		       WT_PARM(wt,0), (int)val);

 param 1 */

		/*

		pr_debug( "vortex: WT SetReg(0x%x) = 0x%08x\n",

		       WT_PARM(wt,1), (int)val);

 param 2 */

		/*

		pr_debug( "vortex: WT SetReg(0x%x) = 0x%08x\n",

		       WT_PARM(wt,2), (int)val);

 param 3 */

		/*

		pr_debug( "vortex: WT SetReg(0x%x) = 0x%08x\n",

		       WT_PARM(wt,3), (int)val);

 mute */

		/*

		pr_debug( "vortex: WT SetReg(0x%x) = 0x%08x\n",

		       WT_MUTE(wt), (int)val);

 delay */

		/*

		pr_debug( "vortex: WT SetReg(0x%x) = 0x%08x\n",

		       WT_DELAY(wt,0), (int)val);

 Global WT block parameters */

 sramp */

 aramp */

 mramp */

 ctrl */

 ds_reg */

	/*

	pr_debug( "vortex: WT SetReg(0x%x) = 0x%08x\n", ecx, (int)val);

 var10 = 0x1AA2

 Init Bank registers. */

 ds_reg */

 ctrl  */

 mramp */

 aramp */

 sramp */

 Init Voice registers. */

 param 3 0x20c */

 param 2 0x208 */

 param 1 0x204 */

 param 0 0x200 */

 delay 0x400 - 0x40c */

 ctrl */

 Extract of CAdbTopology::SetVolume(struct _ASPVOLUME *) */

 This is pure guess */

 This is real */

 Extract of CAdbTopology::SetFrequency(unsigned long arg_0) */

FIXME: 64 bit operation.

 Wt: this_1D4

AuWt::WriteReg((ulong)(this_1DC<<4)+0x200, (ulong)this_1E4);

AuWt::WriteReg((ulong)(this_1DC<<4)+0x204, (ulong)this_1E8);

 End of File */

 SPDX-License-Identifier: GPL-2.0-or-later

/***************************************************************************

 *            au88x0_cxtalk.c

 *

 *  Wed Nov 19 16:29:47 2003

 *  Copyright  2003  mjander

 *  mjander@users.sourceforge.org

/*

 Data (a whole lot of data.... ) */

 Input gain for 4 A3D slices. One possible input pair is left zero.

*/

 XTalk EQ and XT */

 Gains */

 Delay parameters */

 Control/Global stuff */

 inlined

 inlined

 inlined

 inlined

 inlined

 inlined

 inlined

 inlined

 inlined

 inlined

sDiamondKLeftEq,sDiamondKRightXt,asDiamondCoefsLeftEq

 inlined

 End of file */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>

 *  Routines for control of MPU-401 in UART mode

 *

 *   Modified for the Aureal Vortex based Soundcards

 *   by Manuel Jander (mjande@embedded.cl).

 Check for mpu401 mmio support. */

/* MPU401 legacy support is only provided as a emergency fallback *

 Vortex MPU401 defines. */

 Standart MPU401 defines. */

 EnableHardCodedMPU401Port() */

 Enable Legacy MIDI Interface port. */

 FIXME: static address. 0x330 */

 Disable Legacy MIDI Interface port. */

 Mpu401UartInit() */

 Check if anything is OK. */

0xfe */ ) {

 Enable MPU401 interrupts. */

 Create MPU401 instance. */

 Overwrite MIDI name */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ALSA driver for the Aureal Vortex family of soundprocessors.

 * Author: Manuel Jander (mjander@embedded.cl)

 *

 *   This driver is the result of the OpenVortex Project from Savannah

 * (savannah.nongnu.org/projects/openvortex). I would like to thank

 * the developers of OpenVortex, Jeff Muizelaar and Kester Maddock, from

 * whom i got plenty of help, and their codebase was invaluable.

 *   Thanks to the ALSA developers, they helped a lot working out

 * the ALSA part.

 *   Thanks also to Sourceforge for maintaining the old binary drivers,

 * and the forum, where developers could comunicate.

 *

 * Now at least i can play Legacy DOOM with MIDI music :-)

 module parameters (see "Module Parameters")

	/*

	 * only set the bit (Extend PCI#2 Internal Master for

	 * Efficient Handling of Dummy Requests) if the can

	 * read the config and it is not already set

 autodetect if workarounds are required */

 VIA KT133 */

 VIA Apollo */

 AMD Irongate */

 component-destructor

 (see "Management of Cards and Components")

 chip-specific constructor

 (see "Management of Cards and Components")

 check PCI availability (DMA).

 initialize the stuff

 (1) PCI resource allocation

 Get MMIO area



	/* Init audio core.

	 * This must be done before we do request_irq otherwise we can get spurious

 End of PCI setup.

 constructor -- see "Constructor" sub-section

 (1)

 (2)

 (3)

 Card details needed in snd_vortex_midi

 (4) Alloc components.

 ADB pcm.

 ADB SPDIF

 A3D

	/*

	   // ADB I2S

	   if ((err = snd_vortex_new_pcm(chip, VORTEX_PCM_I2S, 1)) < 0) {

	   return err;

	   }

 WT pcm.

 (5)

 (6)

 (7)

 pci_driver definition

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0-or-later

/*

/*

    Vortex core low level functions.

	

 Author: Manuel Jander (mjander@users.sourceforge.cl)

 These functions are mainly the result of translations made

 from the original disassembly of the au88x0 binary drivers,

 written by Aureal before they went down.

 Many thanks to the Jeff Muizelaar, Kester Maddock, and whoever

 contributed to the OpenVortex project.

 The author of this file, put the few available pieces together

 and translated the rest of the riddle (Mix, Src and connection stuff).

 Some things are still to be discovered, and their meanings are unclear.



 Some of these functions aren't intended to be really used, rather

 to help to understand how does the AU88X0 chips work. Keep them in, because

 they could be used somewhere in the future.



 This code hasn't been tested or proof read thoroughly. If you wanna help,

 take a look at the AU88X0 assembly and check if this matches.

 Functions tested ok so far are (they show the desired effect

 at least):

   vortex_routes(); (1 bug fixed).

   vortex_adb_addroute();

   vortex_adb_addroutes();

   vortex_connect_codecplay();

   vortex_src_flushbuffers();

   vortex_adbdma_setmode();  note: still some unknown arguments!

   vortex_adbdma_startfifo();

   vortex_adbdma_stopfifo();

   vortex_fifo_setadbctrl(); note: still some unknown arguments!

   vortex_mix_setinputvolumebyte();

   vortex_mix_enableinput();

   vortex_mixer_addWTD(); (fixed)

   vortex_connection_adbdma_src_src();

   vortex_connection_adbdma_src();

   vortex_src_change_convratio();

   vortex_src_addWTD(); (fixed)



 History:



 01-03-2003 First revision.

 01-21-2003 Some bug fixes.

 17-02-2003 many bugfixes after a big versioning mess.

 18-02-2003 JAAAAAHHHUUUUUU!!!! The mixer works !! I'm just so happy !

			 (2 hours later...) I cant believe it! Im really lucky today.

			 Now the SRC is working too! Yeah! XMMS works !

 20-02-2003 First steps into the ALSA world.

 28-02-2003 As my birthday present, i discovered how the DMA buffer pages really

            work :-). It was all wrong.

 12-03-2003 ALSA driver starts working (2 channels).

 16-03-2003 More srcblock_setupchannel discoveries.

 12-04-2003 AU8830 playback support. Recording in the works.

 17-04-2003 vortex_route() and vortex_routes() bug fixes. AU8830 recording

 			works now, but chipn' dale effect is still there.

 16-05-2003 SrcSetupChannel cleanup. Moved the Src setup stuff entirely

            into au88x0_pcm.c .

 06-06-2003 Buffer shifter bugfix. Mixer volume fix.

 07-12-2003 A3D routing finally fixed. Believed to be OK.

 25-03-2004 Many thanks to Claudia, for such valuable bug reports.

 

  MIXER (CAsp4Mix.s and CAsp4Mixer.s) */

 FIXME: get rid of this.

FP2LinearFrac(a);

	/*

	   if (rampchs[mix] == 0)

	   a = FP2LinearFrac(a);

	   else

	   a = FP2LinearFracWT(a);

 WOW! what a complex function! */

 This function is intended for ramping down only (see vortex_disableinput()).

if (this_10) */

 this_10, initialized to 1. */

 Mute input. Astatic void crackling? */

 Looks like clear buffer. */

 Write enable bit. */

0x80 : mute */

 Register callback.

vortex_mix_startrampvolume(vortex);

printk(KERN_INFO "vortex: mixAddWTD: while addr=%x, val=%x\n", prev, temp);

int esp1f=edi(while)=src, esp10=ch;

7b60

7ad3

printk(KERN_INFO "vortex: mixdelWTD: 1 addr=%x, val=%x, src=%x\n", ebx, edx, src);

printk(KERN_INFO "vortex: mixdelWTD: while addr=%x, val=%x\n", ebp, edx);

7b30

 Delete entry in between others */

7b60

printk(KERN_INFO "vortex mixdelWTD between addr= 0x%x, val= 0x%x\n", ebp, edx);

 Delete last entry */

7b83

printk(KERN_INFO "vortex mixdelWTD last addr= 0x%x, val= 0x%x\n", esp14, ebx);

printk(KERN_INFO "removed last mix\n");

7be0

 FIXME: get rid of this crap.

 Set clipping ceiling (this may be all wrong). */

	/*

	for (x = 0; x < 0x80; x++) {

		hwwrite(vortex->mmio, VORTEX_MIXER_CLIP + (x << 2), 0x3ffff);

	}

	/*

	   call CAsp4Mix__Initialize_CAsp4HwIO____CAsp4Mixer____

	   Register ISR callback for volume smooth fade out.

	   Maybe this avoids clicks when press "stop" ?

  SRC (CAsp4Src.s and CAsp4SrcBlock) */

/*

 Objective: Set samplerate for given SRC module.

 Arguments:

	card:	pointer to vortex_t strcut.

	src:	Integer index of the SRC module.

	cr:		Current sample rate conversion factor.

	b:		unknown 16 bit value.

	sweep:	Enable Samplerate fade from cr toward tr flag.

	dirplay: 1: playback, 0: recording.

	sl:		Slow Lock flag.

	tr:		Target samplerate conversion.

	thsource: Throttle source flag (no idea what that means).

 noplayback: d=2,4,7,0xa,0xb when using first 2 src's.

 c: enables pitch sweep.

 looks like g is c related. Maybe g is a sweep parameter ?

 g = cvr

 dirplay: 0 = recording, 1 = playback

 d = src hw index.

ebx = 0 */

 0xc0   esi=0xc c=f=0 d=0 */

 0   b=0 */

 0x30f00 e=g=1 esp10=0 ebp=f */

printk(KERN_INFO "vortex: SRC %d, d=0x%x, esi=0x%x, esp10=0x%x, ebp=0x%x\n", src, d, esi, esp10, ebp);

	/*

	   for (x=0; x<0x10; x++) {

	   vortex_src_init(&vortex_src[x], x);

	   }

addr = 0xcc3c;

addr = 0x26c3c;

addr = 0xcc94;

addr = 0x26c94;

 esp13 = src

ebp */

while (temp & NR_SRC) {

esp12 */

prev = VORTEX_SRC_RTBASE + ((temp & (NR_SRC-1)) << 2); /*esp12*/

printk(KERN_INFO "vortex: srcAddWTD: while addr=%x, val=%x\n", prev, temp);

hwwrite(vortex->mmio, prev, (temp & (NR_SRC-1)) | NR_SRC);

int esp1f=edi(while)=src, esp10=ch;

7b60

7ad3

printk(KERN_INFO "vortex: srcdelWTD: 1 addr=%x, val=%x, src=%x\n", ebx, edx, src);

printk(KERN_INFO "vortex: srcdelWTD: while addr=%x, val=%x\n", ebp, edx);

7b30

 Delete entry in between others */

7b60

printk(KERN_INFO "vortex srcdelWTD between addr= 0x%x, val= 0x%x\n", ebp, edx);

 Delete last entry */

7b83

printk(KERN_INFO"vortex srcdelWTD last addr= 0x%x, val= 0x%x\n", esp14, ebx);

7be0

FIFO*/ 

int this_8[NR_ADB] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; /* position */

	/* f seems priority related.

	 * CAsp4AdbDma::SetPriority is the only place that calls SetAdbCtrl with f set to 1

	 * every where else it is set to 0. It seems, however, that CAsp4AdbDma::SetPriority

	 * is never called, thus the f related bits remain a mystery for now.

 AU8830 semes to take some special care about fifo content (data).

 But i'm just to lazy to translate that :)

this_8[fifo] = 0;

 this_4

if (this_8[fifo]) */

 this_4

if (this_8[fifo]) */

/*	

    do {

		temp = hwread(vortex->mmio, VORTEX_FIFO_WTCTRL + (fifo << 2));

		if (lifeboat++ > 0xbb8) {

			pr_err( "Vortex: vortex_fifo_setwtctrl fail (hanging)\n");

			break;

		}

    } while ((temp & FIFO_RDONLY)&&(temp & FIFO_VALID)&&(temp != 0xFFFFFFFF));

	

	

	if (valid) {

		if (temp & FIFO_VALID) {

			temp = 0x40000;

			//temp |= 0x08000000;

			//temp |= 0x10000000;

			//temp |= 0x04000000;

			//temp |= 0x00400000;

			temp |= 0x1c400000;

			temp &= 0xFFFFFFF3;

			temp &= 0xFFFFFFEF;

			temp |= (valid & 1) << 4;

			hwwrite(vortex->mmio, VORTEX_FIFO_WTCTRL + (fifo << 2), temp);

			return;

		} else {

			vortex_fifo_clearwtdata(vortex, fifo, FIFO_SIZE);

			return;

		}

	} else {

		temp &= 0xffffffef;

		temp |= 0x08000000;

		temp |= 0x10000000;

		temp |= 0x04000000;

		temp |= 0x00400000;

		hwwrite(vortex->mmio, VORTEX_FIFO_WTCTRL + (fifo << 2), temp);

		temp = hwread(vortex->mmio, VORTEX_FIFO_WTCTRL + (fifo << 2));

		//((temp >> 6) & 0x3f) 

		

		priority = 0;

		if (((temp & 0x0fc0) ^ ((temp >> 6) & 0x0fc0)) & 0FFFFFFC0)

			vortex_fifo_clearwtdata(vortex, fifo, FIFO_SIZE);

		valid = 0xfb;

		temp = (temp & 0xfffffffd) | ((ctrl & 1) << 1);

		temp = (temp & 0xfffdffff) | ((f & 1) << 0x11);

		temp = (temp & 0xfffffff3) | ((priority & 3) << 2);

		temp = (temp & 0xffffffef) | ((valid & 1) << 4);

		temp = (temp & 0xffffffdf) | ((empty & 1) << 5);

		hwwrite(vortex->mmio, VORTEX_FIFO_WTCTRL + (fifo << 2), temp);

	}

	

	/*

	   temp = (temp & 0xfffffffd) | ((ctrl & 1) << 1);

	   temp = (temp & 0xfffdffff) | ((f & 1) << 0x11);

	   temp = (temp & 0xfffffff3) | ((priority & 3) << 2);

	   temp = (temp & 0xffffffef) | ((valid & 1) << 4);

	   temp = (temp & 0xffffffdf) | ((empty & 1) << 5);

	   #ifdef FIFO_BITS

	   temp = temp | FIFO_BITS | 40000;

	   #endif

	   // 0x1c440010, 0x1c400000

	   hwwrite(vortex->mmio, VORTEX_FIFO_WTCTRL + (fifo << 2), temp);

 ADB DMA channels fifos. */

 WT DMA channels fifos. */

 trigger... */

0x0843 0xd6b

 wt a */

 wt b */

 adb */

 ADBDMA */

hwwrite(vortex->mmio, VORTEX_ADBDMA_START + (adbdma << 2), sb << (((NR_ADB-1)-((adbdma&0xf)*2))));

 Four or more pages */

 3 pages */

 2 pages */

 1 page */

	/*

	pr_debug( "vortex: cfg0 = 0x%x\nvortex: cfg1=0x%x\n",

	       dma->cfg0, dma->cfg1);

 Enable PCMOUT interrupts. */

 refresh hw page table */

 p: audio buffer page index */

 pp: hardware DMA page index. */

hwwrite(vortex->mmio, VORTEX_ADBDMA_BUFBASE+(((adbdma << 2)+pp) << 2), dma->table[p].addr);

 Force write thru cache. */

 refresh hw page table */

 p: audio buffer page index */

 pp: hardware DMA page index. */

 Force write thru cache. */

empty */ , this_4 = 0 
 WTDMA */

int this_7c=dma_ctrl;

hwwrite(vortex->mmio, VORTEX_WTDMA_START + (wtdma << 2), sb << ((0x1f-(wtdma&0xf)*2)));

 Four or more pages */

 3 pages */

 2 pages */

 1 page */

int e, */ u32 offset)

dma->this_08 = e;

 PCMOUT interrupt */

 Always playback. */

 Audio Format */

 Write into hardware */

 refresh hw page table */

 p: audio buffer page index */

 pp: hardware DMA page index. */

 Force write thru cache. */

 ADB Routes */

	/* it looks like we are writing more than we need to...

 Write last routes. */

 Write first route. */

 First entry on this channel. */

 Not first entry on this channel. Need to link. */

 Find route. */

 Make bridge over deleted route. */

 Route two sources to same target. Sources must be of same class !!! */

 fifo A */

 Connection stuff */

 Connect adbdma to src('s).

 Connect SRC to mixin.

 Connect mixin with mix output.

 added to original code.

 Connect absolut address to mixin.

 mix to absolut address.

 added to original code.

 mixer to src.

 added to original code.

 Connect two mix to AdbDma.

 CODEC connect. */

 Connect front channels through EQ.

 Lower volume, since EQ has some gain. */

 Check if reg 0x28 has SDAC bit set. */

 Rear channel. Note: ADB_CODECOUT(0+2) and (1+2) is for AC97 modem */

 pr_debug( "SDAC detected "); */

 Use plain direct output to codec.

	/*

	   Enable: 0x1, 0x1

	   Channel: 0x11, 0x11

	   ADB Source address: 0x48, 0x49

	   Destination Asp4Topology_0x9c,0x98

 Higher level ADB audio path (de)allocator.

 Resource manager */

/*

 Checkout/Checkin resource of given type. 

 resmap: resource map to be used. If NULL means that we want to allocate

 a DMA resource (root of all other resources of a dma channel).

 out: Mean checkout if != 0. Else mean Checkin resource.

 restype: Indicates type of resource to be checked in or out.

 Gather used resources by all streams. */

 Find and take free resource. */

				/*

				pr_debug(

				       "vortex: ResManager: type %d out %d\n",

				       restype, i);

 Checkin first resource of type restype. */

				/*

				pr_debug(

				       "vortex: ResManager: type %d in %d\n",

				       restype, i);

 Default Connections  */

 Connect AC97 codec.

 Connect SPDIF

 Connect WT

 A3D (crosstalk canceler and A3D slices). AU8810 disabled for now.

 Connect I2S

 Connect DSP interface for SQ3500 turbo (not here i think...)

 Connect AC98 modem codec

/*

  Allocate nr_ch pcm audio routes if dma < 0. If dma >= 0, existing routes

  are deallocated.

  dma: DMA engine routes to be deallocated when dma >= 0.

  nr_ch: Number of channels to be de/allocated.

  dir: direction of stream. Uses same values as substream->stream.

  type: Type of audio output/source (codec, spdif, i2s, dsp, etc)

  Return: Return allocated DMA or same DMA passed as "dma" when dma >= 0.

 PLAYBACK ROUTES. */

 Get SRC and MIXER hardware resources. */

 (De)Initialize A3D hardware source. */

 Make SPDIF out exclusive to "spdif" device when in use. */

 Make playback routes. */

 XTalk test. */

vortex_route(vortex, en, 0x11, dma, ADB_XTALKIN(i?9:4));

vortex_route(vortex, en, 0x11, ADB_SRCOUT(src[i]), ADB_XTALKIN(i?4:9));

 Reconnect SPDIF out when "spdif" device is down. */

 CAPTURE ROUTES. */

 Get SRC and MIXER hardware resources. */

 Make capture routes. */

 AC97 Codec channel setup. FIXME: this has no effect on some cards !! */

 Copy stereo to rear channel (surround) */

 Allow separate front and rear channels. */

/*

 Set the SampleRate of the SRC's attached to the given DMA engine.

 dir=1:play ; dir=0:rec */

 Setup SRC's */

 Timer and ISR functions.

set the timer period to <period> 48000ths of a second.

 CAsp4ISR__EnableVortexInt_void_

check if the interrupt is ours.

 This is the Interrupt Enable flag we set before (consistency check).

 Reset IRQ flags.

 Is at least one IRQ flag set?

 Attend every interrupt source.

 ALSA period acknowledge. */

				/* FIXME: we ignore the return value from

				 * vortex_wtdma_bufshift() below as the delta

				 * calculation seems not working for wavetable

				 * by some reason

Acknowledge the Timer interrupt

 Codec */

 the windows driver writes -i, so we write -i */

 Enable codec channels 0 and 1. */

 wait for transactions to clear */

 write register */

 Flush Caches. */

 wait for transactions to clear */

 set up read address */

 wait for address */

 return data. */

 SPDIF support  */

 CAsp4Spdif::InitializeSpdifHardware(void) */

for (i=0x291D4; i<0x29200; i+=4)

hwwrite(vortex->mmio, 0x29190, hwread(vortex->mmio, 0x29190) | 0xc0000);

 CAsp4Spdif::ProgramSRCInHardware(enum  SPDIF_SR,enum  SPDIFMODE) */

 this_04 and this_08 are the CASp4Src's (samplerate converters) */

 set 32khz samplerate */

 set 48khz samplerate */

 J. Gordon Wolfe: I think this stuff is for AC3 */

	/* looks like the next 2 lines transfer a 16-bit value into 2 8-bit 

	   registers. seems to be for the standard IEC/SPDIF initialization 

 Initialization */

 Hardware Init. */

 Reset IRQ flags */

 Init audio engine. */

, 0xc83c7e58, 0xc5f93e58

 Init processing blocks. */

 Moved to au88x0.c

vortex_connect_default(vortex, 1);

 Enable Interrupts.

 vortex_enable_int() must be first !!

  hwwrite(vortex->mmio, VORTEX_IRQ_CTRL, 0);

 vortex_enable_int(vortex);

vortex_enable_timer_int(vortex);

vortex_disable_timer_int(vortex);

vortex_disable_timer_int(vortex);

 Reset all DMA fifos. */

 Erase all audio routes. */

 Disable MPU401 */

hwwrite(vortex->mmio, VORTEX_IRQ_CTRL, hwread(vortex->mmio, VORTEX_IRQ_CTRL) & ~IRQ_MIDI);

hwwrite(vortex->mmio, VORTEX_CTRL, hwread(vortex->mmio, VORTEX_CTRL) & ~CTRL_MIDI_EN);

 Alsa support. */

 guess. */

 guess. */

 check this... */

 Some not yet useful translations. */

 0x8 */

 0x1 */

 0x2 */

 0x3 */

 ? */

 ? */

 16 bit

 8 bit

 U_LAW

 A_LAW

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *   Driver for the Conexant Riptide Soundchip

 *

 *	Copyright (c) 2004 Peter Gruber <nokos@gmx.net>

/*

  History:

   - 02/15/2004 first release

   

  This Driver is based on the OSS Driver version from Linuxant (riptide-0.6lnxtbeta03111100)

  credits from the original files:

  

  MODULE NAME:        cnxt_rt.h                       

  AUTHOR:             K. Lazarev  (Transcribed by KNL)

  HISTORY:         Major Revision               Date        By

            -----------------------------     --------     -----

            Created                           02/1/2000     KNL



  MODULE NAME:     int_mdl.c                       

  AUTHOR:          Konstantin Lazarev    (Transcribed by KNL)

  HISTORY:         Major Revision               Date        By

            -----------------------------     --------     -----

            Created                           10/01/99      KNL

	    

  MODULE NAME:        riptide.h                       

  AUTHOR:             O. Druzhinin  (Transcribed by OLD)

  HISTORY:         Major Revision               Date        By

            -----------------------------     --------     -----

            Created                           10/16/97      OLD



  MODULE NAME:        Rp_Cmdif.cpp                       

  AUTHOR:             O. Druzhinin  (Transcribed by OLD)

                      K. Lazarev    (Transcribed by KNL)

  HISTORY:         Major Revision               Date        By

            -----------------------------     --------     -----

            Adopted from NT4 driver            6/22/99      OLD

            Ported to Linux                    9/01/99      KNL



  MODULE NAME:        rt_hw.c                       

  AUTHOR:             O. Druzhinin  (Transcribed by OLD)

                      C. Lazarev    (Transcribed by CNL)

  HISTORY:         Major Revision               Date        By

            -----------------------------     --------     -----

            Created                           11/18/97      OLD

            Hardware functions for RipTide    11/24/97      CNL

            (ES1) are coded

            Hardware functions for RipTide    12/24/97      CNL

            (A0) are coded

            Hardware functions for RipTide    03/20/98      CNL

            (A1) are coded

            Boot loader is included           05/07/98      CNL

            Redesigned for WDM                07/27/98      CNL

            Redesigned for Linux              09/01/99      CNL



  MODULE NAME:        rt_hw.h

  AUTHOR:             C. Lazarev    (Transcribed by CNL)

  HISTORY:         Major Revision               Date        By

            -----------------------------     --------     -----

            Created                           11/18/97      CNL



  MODULE NAME:     rt_mdl.c                       

  AUTHOR:          Konstantin Lazarev    (Transcribed by KNL)

  HISTORY:         Major Revision               Date        By

            -----------------------------     --------     -----

            Created                           10/01/99      KNL



  MODULE NAME:        mixer.h                        

  AUTHOR:             K. Kenney

  HISTORY:         Major Revision                   Date          By

            -----------------------------          --------     -----

            Created from MS W95 Sample             11/28/95      KRS

            RipTide                                10/15/97      KRS

            Adopted for Windows NT driver          01/20/98      CNL

/*

 legacy device options */

 cmd interface limits */

 global reset switch */

 interrupt enable */

 interrupt acknowledge */

 cmd empty */

 data filled */

 error ! */

 interrupt status */

 command flags */

 shifts and masks */

 get version */

 memory access for firmware write */

 memory access for firmware write */

 memory access for firmware write */

 memory access for firmware write */

 memory access for firmware write */

 start stream */

 pause stream */

 stop stream */

 stop all dma */

 get position in dma */

 set sample format at mixer */

 activate lbus path */

 deactivate lbus path */

 select paths for internal connections */

 configure source */

 read source config */

 set digital mixer */

 read digital mixer */

 set AC97 register */

 get AC97 register */

 status flags : block boundary */

              : stoppped */

              : stream end */

 enable interrupts for status notification above */

 stream states */

 config for I2S link */

 config for modem link */

 config for FM/OPL3 link */

 path splitting flag */

 cmd,param */

 param */

 status */

 status registers */

 command ports */

 cmd statistics */

 scatter gather desriptor */

 pcm descriptor */

/*

/*

 free pending data */

 put data */

 write cmd */

 read response */

 update command statistics */

 CONFIG_PM_SLEEP */

 OK */

 OK */

 On failure unregister formerly registered audio driver */

 SPDX-License-Identifier: GPL-2.0

/* getdelays.c

 *

 * Utility to get per-pid and per-tgid delay accounting statistics

 * Also illustrates usage of the taskstats interface

 *

 * Copyright (C) Shailabh Nagar, IBM Corp. 2005

 * Copyright (C) Balbir Singh, IBM Corp. 2006

 * Copyright (c) Jay Lan, SGI. 2006

 *

 * Compile with

 *	gcc -I/usr/src/linux/include getdelays.c -o getdelays

/*

 * Generic macros for dealing with netlink sockets. Might be duplicated

 * elsewhere. It is recommended that commercial grade applications use

 * libnl or libnetlink and use the interfaces provided by the library

 Maximum size of response requested or message sent */

 Maximum number of cpus expected to be specified in a cpumask */

/*

 * Create a raw netlink socket and bind

/*

 * Probe the controller in genetlink to find the family id

 * for the TASKSTATS family

 sendto() failure? */

 Block SIGCHLD for sigwait() later */

 fork/exec a child */

 Set the command type and avoid further processing */

	/*

	 * If we forked a child, wait for it to exit. Cannot use waitpid()

	 * as all the delicious data would be reaped as part of the wait

 Fall through */

 For nested attributes, na follows */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * lsgpio - example on how to list the GPIO lines on a system

 *

 * Copyright (C) 2015 Linus Walleij

 *

 * Usage:

 *	lsgpio <-n device-name>

 Inspect this GPIO chip */

 Loop over the lines and print info */

 List all GPIO devices one at a time */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * gpio-watch - monitor unrequested lines for property changes using the

 *              character device

 *

 * Copyright (C) 2019 BayLibre SAS

 * Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * GPIO tools - helpers library for the GPIO tools

 *

 * Copyright (C) 2015 Linus Walleij

 * Copyright (C) 2016 Bamvor Jian Zhang

/**

 * DOC: Operation of gpio

 *

 * Provide the api of gpiochip for chardev interface. There are two

 * types of api.  The first one provide as same function as each

 * ioctl, including request and release for lines of gpio, read/write

 * the value of gpio. If the user want to do lots of read and write of

 * lines of gpio, user should use this type of api.

 *

 * The second one provide the easy to use api for user. Each of the

 * following api will request gpio lines, do the operation and then

 * release these lines.

/**

 * gpiotools_request_line() - request gpio lines in a gpiochip

 * @device_name:	The name of gpiochip without prefix "/dev/",

 *			such as "gpiochip0"

 * @lines:		An array desired lines, specified by offset

 *			index for the associated GPIO device.

 * @num_lines:		The number of lines to request.

 * @config:		The new config for requested gpio. Reference

 *			"linux/gpio.h" for config details.

 * @consumer:		The name of consumer, such as "sysfs",

 *			"powerkey". This is useful for other users to

 *			know who is using.

 *

 * Request gpio lines through the ioctl provided by chardev. User

 * could call gpiotools_set_values() and gpiotools_get_values() to

 * read and write respectively through the returned fd. Call

 * gpiotools_release_line() to release these lines after that.

 *

 * Return:		On success return the fd;

 *			On failure return the errno.

/**

 * gpiotools_set_values() - Set the value of gpio(s)

 * @fd:			The fd returned by

 *			gpiotools_request_line().

 * @values:		The array of values want to set.

 *

 * Return:		On success return 0;

 *			On failure return the errno.

/**

 * gpiotools_get_values() - Get the value of gpio(s)

 * @fd:			The fd returned by

 *			gpiotools_request_line().

 * @values:		The array of values get from hardware.

 *

 * Return:		On success return 0;

 *			On failure return the errno.

/**

 * gpiotools_release_line() - Release the line(s) of gpiochip

 * @fd:			The fd returned by

 *			gpiotools_request_line().

 *

 * Return:		On success return 0;

 *			On failure return the errno.

/**

 * gpiotools_get() - Get value from specific line

 * @device_name:	The name of gpiochip without prefix "/dev/",

 *			such as "gpiochip0"

 * @line:		number of line, such as 2.

 *

 * Return:		On success return 0;

 *			On failure return the errno.

/**

 * gpiotools_gets() - Get values from specific lines.

 * @device_name:	The name of gpiochip without prefix "/dev/",

 *			such as "gpiochip0".

 * @lines:		An array desired lines, specified by offset

 *			index for the associated GPIO device.

 * @num_lines:		The number of lines to request.

 * @values:		The array of values get from gpiochip.

 *

 * Return:		On success return 0;

 *			On failure return the errno.

/**

 * gpiotools_set() - Set value to specific line

 * @device_name:	The name of gpiochip without prefix "/dev/",

 *			such as "gpiochip0"

 * @line:		number of line, such as 2.

 * @value:		The value of gpio, must be 0(low) or 1(high).

 *

 * Return:		On success return 0;

 *			On failure return the errno.

/**

 * gpiotools_sets() - Set values to specific lines.

 * @device_name:	The name of gpiochip without prefix "/dev/",

 *			such as "gpiochip0".

 * @lines:		An array desired lines, specified by offset

 *			index for the associated GPIO device.

 * @num_lines:		The number of lines to request.

 * @values:		The array of values set to gpiochip, must be

 *			0(low) or 1(high).

 *

 * Return:		On success return 0;

 *			On failure return the errno.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * gpio-event-mon - monitor GPIO line events from userspace

 *

 * Copyright (C) 2016 Linus Walleij

 *

 * Usage:

 *	gpio-event-mon -n <device-name> -o <offset>

 Read initial states */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * gpio-hammer - example swiss army knife to shake GPIO lines on a system

 *

 * Copyright (C) 2016 Linus Walleij

 *

 * Usage:

 *	gpio-hammer -n <device-name> -o <offset1> -o <offset2>

 Hammertime! */

 Invert all lines so we blink */

 Re-read values to get status */

			/*

			 * Avoid overflow. Do not immediately error, we want to

			 * be able to accurately report on the amount of times

			 * '-o' was given to give an accurate error message

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Parser/loader for IHEX formatted data.

 *

 * Copyright  2008 David Woodhouse <dwmw2@infradead.org>

 * Copyright  2005 Jan Harkes <jaharkes@cs.cmu.edu>

 not part of the real data structure */

/**

 * nybble/hex are little helpers to parse hexadecimal numbers to a byte value

 search for the start of record character */

 Minimum record length would be about 10 characters */

 now check if we have enough data to read everything */

 check CRC */

 Done reading the record */

 old style EOF record? */

 End-Of-File Record */

 Extended Segment Address Record (HEX86) */

 Extended Linear Address Record (HEX386) */

		/* We shouldn't really be using the offset for HEX86 because

 Start Segment Address Record */

 Start Linear Address Record */

		/* These records contain the CS/IP or EIP where execution

	/* EOF record is zero length, since we don't bother to represent

 SPDX-License-Identifier: GPL-2.0-only

 crc32hash.c - derived from linux/lib/crc32.c, GNU GPL v2 */

/* Usage example:

$ ./crc32hash "Dual Speed"

 SPDX-License-Identifier: GPL-2.0

/*

 * "Optimize" a list of dependencies as spit out by gcc -MD

 * for the build framework.

 *

 * Original author:

 *   Copyright    2002 by Kai Germaschewski  <kai.germaschewski@gmx.de>

 *

 * This code has been borrowed from kbuild's fixdep (scripts/basic/fixdep.c),

 * Please check it for detailed explanation. This fixdep borow only the

 * base transformation of dependecies without the CONFIG mangle.

/*

 * Print out the commandline prefixed with cmd_<target filename> :=

/*

 * Important: The below generated source_foo.o and deps_foo.o variable

 * assignments are parsed not only by make, but also by the rather simple

 * parser in scripts/mod/sumversion.c.

 Skip any "white space" */

 Find next "white space" */

 Is the token we found a target name? */

 Don't write any target names into the dependency file */

 The /next/ file is the first dependency */

 Save this token/filename */

			/*

			 * Do not list the source file as dependency,

			 * so that kbuild is not confused if a .c file

			 * is rewritten into .S or vice versa. Storing

			 * it in source_* is needed for modpost to

			 * compute srcversions.

				/*

				 * If processing the concatenation of

				 * multiple dependency files, only

				 * process the first target name, which

				 * will be the original source name,

				 * and ignore any other target names,

				 * which will be intermediate temporary

				 * files.

		/*

		 * Start searching for next token immediately after the first

		 * "whitespace" character that follows this token.

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

/*

 * test for timerfd functions used by perf-kvm-stat-live

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

/*

 * test-all.c: Try to build all the main testcases at once.

 *

 * A well-configured system will have all the prereqs installed, so we can speed

 * up auto-detection on such systems.

/*

 * Quirk: Python and Perl headers cannot be in arbitrary places, so keep

 * these 3 testcases at the top:

/*

 * Disable libbabeltrace check for test-all, because the requested

 * library version is not released yet in most distributions. Will

 * reenable later.

 SPDX-License-Identifier: GPL-2.0

	/*

	 * This function is guarded via: __nonnull_attribute__ (1, 2).

	 * Passing '1' as arguments value. This code is never executed,

	 * only compiled.

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

SIGEV_NONE*/;

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Copyright (C) 2018, Red Hat Inc, Arnaldo Carvalho de Melo <acme@redhat.com>

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Check fields in attr */

	/*

	 * Test existence of __NR_bpf and BPF_PROG_LOAD.

	 * This call should fail if we run the testcase.

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Copyright (C) 2019, Red Hat Inc, Arnaldo Carvalho de Melo <acme@redhat.com>

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

/*

 * Check OpenCSD library version is sufficient to provide required features

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  Sample application for SMBIOS communication over WMI interface

 *  Performs the following:

 *  - Simple cmd_class/cmd_select lookup for TPM information

 *  - Simple query of known tokens and their values

 *  - Simple activation of a token

 *

 *  Copyright (C) 2017 Dell, Inc.

 if uapi header isn't installed, this might not yet exist */

/* It would be better to discover these using udev, but for a simple

 * application they're hardcoded

 simple SMBIOS call for looking up TPM info */

 query some tokens */

 activate UEFI capsule token if disabled */

 SPDX-License-Identifier: GPL-2.0-only

 Copyright(c) 2021 Intel Corporation. All rights reserved. */

 SPDX-License-Identifier: GPL-2.0-only

 Copyright(c) 2021 Intel Corporation. All rights reserved. */

 TODO walk DVSEC to find component register base */

 SPDX-License-Identifier: GPL-2.0

	/*

	 * These kconfig symbols must be set to "m" for cxl_test to load

	 * and operate.

 SPDX-License-Identifier: GPL-2.0-only

Copyright(c) 2021 Intel Corporation. All rights reserved.

		/*

		 * Simulate 2 root ports per host-bridge and no

		 * depth recursion.

 SPDX-License-Identifier: GPL-2.0-only

 Copyright(c) 2021 Intel Corporation. All rights reserved.

 FIXME: Add partition support */

 SPDX-License-Identifier: GPL-2.0-only

 Copyright(c) 2021 Intel Corporation. All rights reserved.

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0+

/*

 * xarray.c: Userspace shim for XArray test-suite

 * Copyright (c) 2018 Matthew Wilcox <willy@infradead.org>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * idr-test.c: Test the IDR API

 * Copyright (c) 2016 Matthew Wilcox <willy@infradead.org>

/*

 * Unlike the radix tree, you can put a NULL pointer -- with care -- into

 * the IDR.  Some interfaces, like idr_find() do not distinguish between

 * "present, value is NULL" and "not present", but that's exactly what some

 * users want.

/*

 * There are always either 1 or 2 objects in the IDR.  If we find nothing,

 * or we find something at an ID we didn't expect, that's a bug.

/*

 * Check that we get the correct error when we run out of memory doing

 * allocations.  In userspace, GFP_NOWAIT will always fail an allocation.

 * The first test is for not having a bitmap available, and the second test

 * is for not being able to allocate a level of the radix tree.

/*

 * Check handling of conversions between exceptional entries and full bitmaps.

 SPDX-License-Identifier: GPL-2.0

/*

 * Regression1

 * Description:

 * Salman Qazi describes the following radix-tree bug:

 *

 * In the following case, we get can get a deadlock:

 *

 * 0.  The radix tree contains two items, one has the index 0.

 * 1.  The reader (in this case find_get_pages) takes the rcu_read_lock.

 * 2.  The reader acquires slot(s) for item(s) including the index 0 item.

 * 3.  The non-zero index item is deleted, and as a consequence the other item

 *     is moved to the root of the tree. The place where it used to be is queued

 *     for deletion after the readers finish.

 * 3b. The zero item is deleted, removing it from the direct slot, it remains in

 *     the rcu-delayed indirect node.

 * 4.  The reader looks at the index 0 slot, and finds that the page has 0 ref

 *     count

 * 5.  The reader looks at it again, hoping that the item will either be freed

 *     or the ref count will increase. This never happens, as the slot it is

 *     looking at will never be updated. Also, this slot can never be reclaimed

 *     because the reader is holding rcu_read_lock and is in an infinite loop.

 *

 * The fix is to re-use the same "indirect" pointer case that requires a slot

 * lookup retry into a general "retry the lookup" bit.

 *

 * Running:

 * This test should run to completion in a few seconds. The above bug would

 * cause it to hang indefinitely.

 *

 * Upstream commit:

 * Not yet

 don't actually update page refcount */

 Has the page moved? */

 Regression #1 */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * benchmark.c:

 * Author: Konstantin Khlebnikov <koct9i@gmail.com>

 SPDX-License-Identifier: GPL-2.0

/*

 * Scan only the passed (start, start+nr] for present items

/*

 * Scan the entire tree, only expecting present items (start, start+nr]

	printf("%s(0x%08lx, 0x%08lx, %d)\n", __FUNCTION__, start, nr, chunk);

		printf("At 0x%08lx, nfound=%d\n", into, nfound);

		printf("Found 0x%08lx->0x%08lx\n",

			items[0]->index, items[nfound-1]->index);

 Use the same pattern as tag_pages_for_writeback() in mm/page-writeback.c */

 Verify consistency at this level */

 Go for next level */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * multiorder.c: Multi-order radix tree entry testing

 * Copyright (c) 2016 Intel Corporation

 * Author: Ross Zwisler <ross.zwisler@linux.intel.com>

 * Author: Matthew Wilcox <matthew.r.wilcox@intel.com>

 'order' is set up to ensure we have sibling entries */

 SPDX-License-Identifier: GPL-2.0

/*

 * Regression2

 * Description:

 * Toshiyuki Okajima describes the following radix-tree bug:

 *

 * In the following case, we can get a hangup on

 *   radix_radix_tree_gang_lookup_tag_slot.

 *

 * 0.  The radix tree contains RADIX_TREE_MAP_SIZE items. And the tag of

 *     a certain item has PAGECACHE_TAG_DIRTY.

 * 1.  radix_tree_range_tag_if_tagged(, start, end, , PAGECACHE_TAG_DIRTY,

 *     PAGECACHE_TAG_TOWRITE) is called to add PAGECACHE_TAG_TOWRITE tag

 *     for the tag which has PAGECACHE_TAG_DIRTY. However, there is no tag with

 *     PAGECACHE_TAG_DIRTY within the range from start to end. As the result,

 *     There is no tag with PAGECACHE_TAG_TOWRITE but the root tag has

 *     PAGECACHE_TAG_TOWRITE.

 * 2.  An item is added into the radix tree and then the level of it is

 *     extended into 2 from 1. At that time, the new radix tree node succeeds

 *     the tag status of the root tag. Therefore the tag of the new radix tree

 *     node has PAGECACHE_TAG_TOWRITE but there is not slot with

 *     PAGECACHE_TAG_TOWRITE tag in the child node of the new radix tree node.

 * 3.  The tag of a certain item is cleared with PAGECACHE_TAG_DIRTY.

 * 4.  All items within the index range from 0 to RADIX_TREE_MAP_SIZE - 1 are

 *     released. (Only the item which index is RADIX_TREE_MAP_SIZE exist in the

 *     radix tree.) As the result, the slot of the radix tree node is NULL but

 *     the tag which corresponds to the slot has PAGECACHE_TAG_TOWRITE.

 * 5.  radix_tree_gang_lookup_tag_slot(PAGECACHE_TAG_TOWRITE) calls

 *     __lookup_tag. __lookup_tag returns with 0. And __lookup_tag doesn't

 *     change the index that is the input and output parameter. Because the 1st

 *     slot of the radix tree node is NULL, but the tag which corresponds to

 *     the slot has PAGECACHE_TAG_TOWRITE.

 *     Therefore radix_tree_gang_lookup_tag_slot tries to get some items by

 *     calling __lookup_tag, but it cannot get any items forever.

 *

 * The fix is to change that radix_tree_tag_if_tagged doesn't tag the root tag

 * if it doesn't set any tags within the specified range.

 *

 * Running:

 * This test should run to completion immediately. The above bug would cause it

 * to hang indefinitely.

 *

 * Upstream commit:

 * Not yet

 0. */

 1. */

 2. */

 3. */

 4. */

 5. */

 NOTE: start should not be 0 because radix_tree_gang_lookup_tag_slot

       can return.

 We remove all the remained nodes */

 lib/bitmap.c pulls in at least two other files. */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * iteration_check_2.c: Check that deleting a tagged entry doesn't cause

 * an RCU walker to finish early.

 * Copyright (c) 2020 Oracle

 * Author: Matthew Wilcox <willy@infradead.org>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * iteration_check.c: test races having to do with xarray iteration

 * Copyright (c) 2016 Intel Corporation

 * Author: Ross Zwisler <ross.zwisler@linux.intel.com>

 relentlessly fill the array with tagged entries */

/*

 * Iterate over tagged entries, retrying when we find ourselves in a deleted

 * node and randomly pausing the iteration.

/*

 * Iterate over the entries, retrying when we find ourselves in a deleted

 * node and randomly pausing the iteration.

/*

 * Randomly remove entries to help induce retries in the

 * two iteration functions.

 This is a unit test for a bug found by the syzkaller tester */

 SPDX-License-Identifier: GPL-2.0

/*

 * Regression3

 * Description:

 * Helper radix_tree_iter_retry resets next_index to the current index.

 * In following radix_tree_next_slot current chunk size becomes zero.

 * This isn't checked and it tries to dereference null pointer in slot.

 *

 * Helper radix_tree_iter_resume reset slot to NULL and next_index to index + 1,

 * for tagger iteraction it also must reset cached tags in iterator to abort

 * next radix_tree_next_slot and go to slow-path into radix_tree_next_chunk.

 *

 * Running:

 * This test should run to completion immediately. The above bug would

 * cause it to segfault.

 *

 * Upstream commit:

 * Not yet

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

/*

 * Check that tags propagate correctly when extending a tree.

 crash */

/*

 * Check that tags propagate correctly when contracting a tree.

/*

 * Stupid tag thrasher

 *

 * Create a large linear array corresponding to the tree.   Each element in

 * the array is coherent with each node in the tree

 SPDX-License-Identifier: GPL-2.0

		printf("0x%08lx\n", start);

/*		if (i % 1000 == 0)

	printf("generating radix tree indices...\n");

	/* Specifically create items around the start and the end of the range

/*		if (i % 1000 == 0)

	printf("\ncopying tags...\n");

	printf("checking copied tags\n");

 Copy tags in several rounds */

	printf("\ncopying tags...\n");

	printf("%lu %lu %lu\n", tagged, tmp, count);

	printf("checking copied tags\n");

	printf("\n");

 Free any remaining preallocated nodes */

/* ADJ_FREQ Skew change test

 *		by: john stultz (johnstul@us.ibm.com)

 *		(C) Copyright IBM 2012

 *		Licensed under the GPLv2

 *

 *  NOTE: This is a meta-test which cranks the ADJ_FREQ knob and

 *  then uses other tests to detect problems. Thus this test requires

 *  that the raw_skew, inconsistency-check and nanosleep tests be

 *  present in the same directory it is run from.

 *

 *  To build:

 *	$ gcc change_skew.c -o change_skew -lrt

 *

 *   This program is free software: you can redistribute it and/or modify

 *   it under the terms of the GNU General Public License as published by

 *   the Free Software Foundation, either version 2 of the License, or

 *   (at your option) any later version.

 *

 *   This program is distributed in the hope that it will be useful,

 *   but WITHOUT ANY WARRANTY; without even the implied warranty of

 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 *   GNU General Public License for more details.

 Kill ntpd */

 Make sure there's no offset adjustment going on */

 Set things back */

/* Set tai offset

 *              by: John Stultz <john.stultz@linaro.org>

 *              (C) Copyright Linaro 2013

 *              Licensed under the GPLv2

 *

 *   This program is free software: you can redistribute it and/or modify

 *   it under the terms of the GNU General Public License as published by

 *   the Free Software Foundation, either version 2 of the License, or

 *   (at your option) any later version.

 *

 *   This program is distributed in the hope that it will be useful,

 *   but WITHOUT ANY WARRANTY; without even the implied warranty of

 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 *   GNU General Public License for more details.

/* Time inconsistency check test

 *		by: john stultz (johnstul@us.ibm.com)

 *		(C) Copyright IBM 2003, 2004, 2005, 2012

 *		(C) Copyright Linaro Limited 2015

 *		Licensed under the GPLv2

 *

 *  To build:

 *	$ gcc inconsistency-check.c -o inconsistency-check -lrt

 *

 *   This program is free software: you can redistribute it and/or modify

 *   it under the terms of the GNU General Public License as published by

 *   the Free Software Foundation, either version 2 of the License, or

 *   (at your option) any later version.

 *

 *   This program is distributed in the hope that it will be useful,

 *   but WITHOUT ANY WARRANTY; without even the implied warranty of

 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 *   GNU General Public License for more details.

 returns 1 if a <= b, 0 otherwise */

 use unsigned to avoid false positives on 2038 rollover */

 timestamp start of test */

 Fill list */

 Check for inconsistencies */

 display inconsistency */

 timestamp inconsistency*/

 Process arguments */

/* Make sure timers don't return early

 *              by: john stultz (johnstul@us.ibm.com)

 *		    John Stultz (john.stultz@linaro.org)

 *              (C) Copyright IBM 2012

 *              (C) Copyright Linaro 2013 2015

 *              Licensed under the GPLv2

 *

 *  To build:

 *	$ gcc nanosleep.c -o nanosleep -lrt

 *

 *   This program is free software: you can redistribute it and/or modify

 *   it under the terms of the GNU General Public License as published by

 *   the Free Software Foundation, either version 2 of the License, or

 *   (at your option) any later version.

 *

 *   This program is distributed in the hope that it will be useful,

 *   but WITHOUT ANY WARRANTY; without even the implied warranty of

 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 *   GNU General Public License for more details.

 returns 1 if a <= b, 0 otherwise */

 First check abs time */

 Second check reltime */

 Skip cputime clockids since nanosleep won't increment cputime */

/* ADJ_FREQ Skew consistency test

 *		by: john stultz (johnstul@us.ibm.com)

 *		(C) Copyright IBM 2012

 *		Licensed under the GPLv2

 *

 *  NOTE: This is a meta-test which cranks the ADJ_FREQ knob back

 *  and forth and watches for consistency problems. Thus this test requires

 *  that the inconsistency-check tests be present in the same directory it

 *  is run from.

 *

 *  To build:

 *	$ gcc skew_consistency.c -o skew_consistency -lrt

 *

 *   This program is free software: you can redistribute it and/or modify

 *   it under the terms of the GNU General Public License as published by

 *   the Free Software Foundation, either version 2 of the License, or

 *   (at your option) any later version.

 *

 *   This program is distributed in the hope that it will be useful,

 *   but WITHOUT ANY WARRANTY; without even the implied warranty of

 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 *   GNU General Public License for more details.

 Set things back */

/* Clocksource change test

 *		by: john stultz (johnstul@us.ibm.com)

 *		(C) Copyright IBM 2012

 *		Licensed under the GPLv2

 *

 *  NOTE: This is a meta-test which quickly changes the clocksource and

 *  then uses other tests to detect problems. Thus this test requires

 *  that the inconsistency-check and nanosleep tests be present in the

 *  same directory it is run from.

 *

 *  To build:

 *	$ gcc clocksource-switch.c -o clocksource-switch -lrt

 *

 *   This program is free software: you can redistribute it and/or modify

 *   it under the terms of the GNU General Public License as published by

 *   the Free Software Foundation, either version 2 of the License, or

 *   (at your option) any later version.

 *

 *   This program is distributed in the hope that it will be useful,

 *   but WITHOUT ANY WARRANTY; without even the implied warranty of

 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 *   GNU General Public License for more details.

 Find the next space */

 Check everything is sane before we start switching asynchronously */

/* Set tz value

 *              by: John Stultz <john.stultz@linaro.org>

 *              (C) Copyright Linaro 2016

 *              Licensed under the GPLv2

 *

 *   This program is free software: you can redistribute it and/or modify

 *   it under the terms of the GNU General Public License as published by

 *   the Free Software Foundation, either version 2 of the License, or

 *   (at your option) any later version.

 *

 *   This program is distributed in the hope that it will be useful,

 *   but WITHOUT ANY WARRANTY; without even the implied warranty of

 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 *   GNU General Public License for more details.

/* alarmtimer suspend test

 *		John Stultz (john.stultz@linaro.org)

 *              (C) Copyright Linaro 2013

 *              Licensed under the GPLv2

 *

 *   This test makes sure the alarmtimer & RTC wakeup code is

 *   functioning.

 *

 *  To build:

 *	$ gcc alarmtimer-suspend.c -o alarmtimer-suspend -lrt

 *

 *   This program is free software: you can redistribute it and/or modify

 *   it under the terms of the GNU General Public License as published by

 *   the Free Software Foundation, either version 2 of the License, or

 *   (at your option) any later version.

 *

 *   This program is distributed in the hope that it will be useful,

 *   but WITHOUT ANY WARRANTY; without even the implied warranty of

 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 *   GNU General Public License for more details.

 hopefully we resume in 5 secs */

 Set up signal handler: */

 Set up timer: */

 First 5 alarms, do nothing */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * This test checks the response of the system clock to frequency

 * steps made with adjtimex(). The frequency error and stability of

 * the CLOCK_MONOTONIC clock relative to the CLOCK_MONOTONIC_RAW clock

 * is measured in two intervals following the step. The test fails if

 * values from the second interval exceed specified limits.

 *

 * Copyright (C) Miroslav Lichvar <mlichvar@redhat.com>  2017

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2013 Red Hat, Inc., Frederic Weisbecker <fweisbec@redhat.com>

 *

 * Selftests for a few posix timers interface.

 *

 * Kernel loop code stolen from Steven Rostedt <srostedt@redhat.com>

 Busy loop in userspace to elapse ITIMER_VIRTUAL */

/*

 * Try to spend as much time as possible in kernelspace

 * to elapse ITIMER_PROF.

/*

 * Sleep until ITIMER_REAL expiration.

/*

 * Check the expected timer expiration matches the GTOD elapsed delta since

 * we armed the timer. Keep a 0.5 sec error margin due to various jitter.

	/*

	 * It's unfortunately hard to reliably test a timer expiration

	 * on parallel multithread cputime. We could arm it to expire

	 * on DELAY * nr_threads, with nr_threads busy looping, then wait

	 * the normal DELAY since the time is elapsing nr_threads faster.

	 * But for that we need to ensure we have real physical free CPUs

	 * to ensure true parallelism. So test only one thread until we

	 * find a better solution.

/* adjtimex() tick adjustment test

 *		by:   John Stultz <john.stultz@linaro.org>

 *		(C) Copyright Linaro Limited 2015

 *		Licensed under the GPLv2

 *

 *  To build:

 *	$ gcc adjtick.c -o adjtick -lrt

 *

 *   This program is free software: you can redistribute it and/or modify

 *   it under the terms of the GNU General Public License as published by

 *   the Free Software Foundation, either version 2 of the License, or

 *   (at your option) any later version.

 *

 *   This program is distributed in the hope that it will be useful,

 *   but WITHOUT ANY WARRANTY; without even the implied warranty of

 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 *   GNU General Public License for more details.

 Try to get a more tightly bound pairing */

	/*

	 * Here we use 100ppm difference as an error bound.

	 * We likely should see better, but some coarse clocksources

	 * cannot match the HZ tick size accurately, so we have a

	 * internal correction factor that doesn't scale exactly

	 * with the adjustment, resulting in > 10ppm error during

	 * a 10% adjustment. 100ppm also gives us more breathing

	 * room for interruptions during the measurement.

 +/- 10% */

 in 4 steps each side */

 Reset things to zero */

/* Time bounds setting test

 *		by: john stultz (johnstul@us.ibm.com)

 *		(C) Copyright IBM 2012

 *		Licensed under the GPLv2

 *

 *  NOTE: This is a meta-test which sets the time to edge cases then

 *  uses other tests to detect problems. Thus this test requires that

 *  the inconsistency-check and nanosleep tests be present in the same

 *  directory it is run from.

 *

 *  To build:

 *	$ gcc set-2038.c -o set-2038 -lrt

 *

 *   This program is free software: you can redistribute it and/or modify

 *   it under the terms of the GNU General Public License as published by

 *   the Free Software Foundation, either version 2 of the License, or

 *   (at your option) any later version.

 *

 *   This program is distributed in the hope that it will be useful,

 *   but WITHOUT ANY WARRANTY; without even the implied warranty of

 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 *   GNU General Public License for more details.

overflows 32bit time_t */

overflows 64bit ktime_t */

overflows 64bit time_t */

 Process arguments */

 First test that crazy values don't work */

 Now test behavior near edges */

 The rest of the tests can blowup on 32bit systems */

 Test rollover behavior 32bit edge */

 restore clock */

/* threadtest.c

 *		by: john stultz (johnstul@us.ibm.com)

 *		(C) Copyright IBM 2004, 2005, 2006, 2012

 *		Licensed under the GPLv2

 *

 *  To build:

 *	$ gcc threadtest.c -o threadtest -lrt

 *

 *   This program is free software: you can redistribute it and/or modify

 *   it under the terms of the GNU General Public License as published by

 *   the Free Software Foundation, either version 2 of the License, or

 *   (at your option) any later version.

 *

 *   This program is distributed in the hope that it will be useful,

 *   but WITHOUT ANY WARRANTY; without even the implied warranty of

 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 *   GNU General Public License for more details.

 serializes shared list access */

 serializes console output */

 scan the list */

 look for any time inconsistencies */

 flag other threads */

serialize printing to avoid junky output*/

 dump the list */

/* The shared thread shares a global list

 * that each thread fills while holding the lock.

 * This stresses clock synchronization across cpus.

 protect the list */

 see if we're ready to check the list */

/* Each independent thread fills in its own

 * list. This stresses clock_gettime() lock contention.

 fill the list */

 Process arguments */

 spawn */

 wait */

 die */

/* CLOCK_MONOTONIC vs CLOCK_MONOTONIC_RAW skew test

 *		by: john stultz (johnstul@us.ibm.com)

 *		    John Stultz <john.stultz@linaro.org>

 *		(C) Copyright IBM 2012

 *		(C) Copyright Linaro Limited 2015

 *		Licensed under the GPLv2

 *

 *  To build:

 *	$ gcc raw_skew.c -o raw_skew -lrt

 *

 *   This program is free software: you can redistribute it and/or modify

 *   it under the terms of the GNU General Public License as published by

 *   the Free Software Foundation, either version 2 of the License, or

 *   (at your option) any later version.

 *

 *   This program is distributed in the hope that it will be useful,

 *   but WITHOUT ANY WARRANTY; without even the implied warranty of

 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 *   GNU General Public License for more details.

 calculate measured ppm between MONOTONIC and MONOTONIC_RAW */

 Avg the two actual freq samples adjtimex gave us */

/* Measure mqueue timeout latency

 *              by: john stultz (john.stultz@linaro.org)

 *		(C) Copyright Linaro 2013

 *

 *		Inspired with permission from example test by:

 *			Romain Francoise <romain@orebokech.com>

 *              Licensed under the GPLv2

 *

 *  To build:

 *	$ gcc mqueue-lat.c -o mqueue-lat -lrt

 *

 *   This program is free software: you can redistribute it and/or modify

 *   it under the terms of the GNU General Public License as published by

 *   the Free Software Foundation, either version 2 of the License, or

 *   (at your option) any later version.

 *

 *   This program is distributed in the hope that it will be useful,

 *   but WITHOUT ANY WARRANTY; without even the implied warranty of

 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 *   GNU General Public License for more details.

 100ms in nanoseconds */

 40ms in nanosecs */

 100ms */

 SPDX-License-Identifier: GPL-2.0

/*

 * Real Time Clock Periodic Interrupt test program

 *

 * Since commit 6610e0893b8bc ("RTC: Rework RTC code to use timerqueue for

 * events"), PIE are completely handled using hrtimers, without actually using

 * any underlying hardware RTC.

 *

/*

 * This expects the new RTC class driver framework, working with

 * clocks that will often not be clones of what the PC-AT had.

 * Use the command line to specify another RTC if you need one.

 Read periodic IRQ rate */

 not all RTCs support periodic IRQs */

 The frequencies 128Hz, 256Hz, ... 8192Hz are only allowed for root. */

 not all RTCs can change their periodic IRQ rate */

 Enable periodic interrupts */

 This blocks */

 Disable periodic interrupts */

/* valid adjtimex test

 *              by: John Stultz <john.stultz@linaro.org>

 *              (C) Copyright Linaro 2015

 *              Licensed under the GPLv2

 *

 *  This test validates adjtimex interface with valid

 *  and invalid test data.

 *

 *  Usage: valid-adjtimex

 *

 *  To build:

 *	$ gcc valid-adjtimex.c -o valid-adjtimex -lrt

 *

 *   This program is free software: you can redistribute it and/or modify

 *   it under the terms of the GNU General Public License as published by

 *   the Free Software Foundation, either version 2 of the License, or

 *   (at your option) any later version.

 *

 *   This program is distributed in the hope that it will be useful,

 *   but WITHOUT ANY WARRANTY; without even the implied warranty of

 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 *   GNU General Public License for more details.

 clear NTP time_status & time_state */

 Set the leap second insert flag */

 this case only applies to 64bit systems */

 reset freq to zero */

 Test valid values */

 Test invalid values */

/* Leap second stress test

 *              by: John Stultz (john.stultz@linaro.org)

 *              (C) Copyright IBM 2012

 *              (C) Copyright 2013, 2015 Linaro Limited

 *              Licensed under the GPLv2

 *

 *  This test signals the kernel to insert a leap second

 *  every day at midnight GMT. This allows for stressing the

 *  kernel's leap-second behavior, as well as how well applications

 *  handle the leap-second discontinuity.

 *

 *  Usage: leap-a-day [-s] [-i <num>]

 *

 *  Options:

 *	-s:	Each iteration, set the date to 10 seconds before midnight GMT.

 *		This speeds up the number of leapsecond transitions tested,

 *		but because it calls settimeofday frequently, advancing the

 *		time by 24 hours every ~16 seconds, it may cause application

 *		disruption.

 *

 *	-i:	Number of iterations to run (default: infinite)

 *

 *  Other notes: Disabling NTP prior to running this is advised, as the two

 *		 may conflict in their commands to the kernel.

 *

 *  To build:

 *	$ gcc leap-a-day.c -o leap-a-day -lrt

 *

 *   This program is free software: you can redistribute it and/or modify

 *   it under the terms of the GNU General Public License as published by

 *   the Free Software Foundation, either version 2 of the License, or

 *   (at your option) any later version.

 *

 *   This program is distributed in the hope that it will be useful,

 *   but WITHOUT ANY WARRANTY; without even the implied warranty of

 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 *   GNU General Public License for more details.

 returns 1 if a <= b, 0 otherwise */

 clear NTP time_status & time_state */

	/*

	 * We have to call adjtime twice here, as kernels

	 * prior to 6b1859dba01c7 (included in 3.5 and

	 * -stable), had an issue with the state machine

	 * and wouldn't clear the STA_INS/DEL flag directly.

 Clear maxerror, as it can cause UNSYNC to be set */

 Clear the status */

 Make sure we cleanup on ctrl-c */

 Test for known hrtimer failure */

 Process arguments */

 Make sure TAI support is present if -t was used */

 Set up timer signal handler: */

 Get the current time */

 Calculate the next possible leap second 23:59:60 GMT */

 Reset NTP time state */

 Set the leap second insert flag */

 Validate STA_INS was set */

 Set up timer */

 Wake up 3 seconds before leap */

 Validate STA_INS is still set */

 Check adjtimex output every half second */

remove trailing\n */

 Sleep for another half second */

 Switch to using other mode */

 Note if kernel has known hrtimer failure */

/* set_timer latency test

 *		John Stultz (john.stultz@linaro.org)

 *              (C) Copyright Linaro 2014

 *              Licensed under the GPLv2

 *

 *   This test makes sure the set_timer api is correct

 *

 *  To build:

 *	$ gcc set-timer-lat.c -o set-timer-lat -lrt

 *

 *   This program is free software: you can redistribute it and/or modify

 *   it under the terms of the GNU General Public License as published by

 *   the Free Software Foundation, either version 2 of the License, or

 *   (at your option) any later version.

 *

 *   This program is distributed in the hope that it will be useful,

 *   but WITHOUT ANY WARRANTY; without even the implied warranty of

 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 *   GNU General Public License for more details.

 40ms in nanosecs */

 Set up timer: */

 Indicate timer isn't set, so caller doesn't wait */

 Unsupported case - return 0 to not fail the test */

 Unsupported case - return 0 to not fail the test */

 Set up signal handler: */

/* Demo leapsecond deadlock

 *              by: John Stultz (john.stultz@linaro.org)

 *              (C) Copyright IBM 2012

 *              (C) Copyright 2013, 2015 Linaro Limited

 *              Licensed under the GPL

 *

 * This test demonstrates leapsecond deadlock that is possible

 * on kernels from 2.6.26 to 3.3.

 *

 * WARNING: THIS WILL LIKELY HARD HANG SYSTEMS AND MAY LOSE DATA

 * RUN AT YOUR OWN RISK!

 *  To build:

 *	$ gcc leapcrash.c -o leapcrash -lrt

 clear NTP time_status & time_state */

	/*

	 * We have to call adjtime twice here, as kernels

	 * prior to 6b1859dba01c7 (included in 3.5 and

	 * -stable), had an issue with the state machine

	 * and wouldn't clear the STA_INS/DEL flag directly.

 Make sure we cleanup on ctrl-c */

 Get the current time */

 Calculate the next possible leap second 23:59:60 GMT */

 set the time to 2 seconds before the leap */

 hammer on adjtime w/ STA_INS */

 Set the leap second insert flag */

/* Measure nanosleep timer latency

 *              by: john stultz (john.stultz@linaro.org)

 *		(C) Copyright Linaro 2013

 *              Licensed under the GPLv2

 *

 *  To build:

 *	$ gcc nsleep-lat.c -o nsleep-lat -lrt

 *

 *   This program is free software: you can redistribute it and/or modify

 *   it under the terms of the GNU General Public License as published by

 *   the Free Software Foundation, either version 2 of the License, or

 *   (at your option) any later version.

 *

 *   This program is distributed in the hope that it will be useful,

 *   but WITHOUT ANY WARRANTY; without even the implied warranty of

 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 *   GNU General Public License for more details.

 40ms in nanosecs */

 First check relative latency */

 Next check absolute latency */

 Skip cputime clockids since nanosleep won't increment cputime */

 SPDX-License-Identifier: GPL-2.0

/*

 * GPIO mockup cdev test helper

 *

 * Copyright (C) 2020 Kent Gibson

 SPDX-License-Identifier: GPL-2.0

/*

 * Memory Bandwidth Monitoring (MBM) test

 *

 * Copyright (C) 2018 Intel Corporation

 *

 * Authors:

 *    Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>,

 *    Fenghua Yu <fenghua.yu@intel.com>

	/*

	 * Discard the first value which is inaccurate due to monitoring setup

	 * transition phase.

 Run NUM_OF_RUNS times */

 Set up shemata with 100% allocation on the first run. */

 SPDX-License-Identifier: GPL-2.0

/*

 * Memory Bandwidth Allocation (MBA) test

 *

 * Copyright (C) 2018 Intel Corporation

 *

 * Authors:

 *    Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>,

 *    Fenghua Yu <fenghua.yu@intel.com>

/*

 * Change schemata percentage from 100 to 10%. Write schemata to specified

 * con_mon grp, mon_grp in resctrl FS.

 * For each allocation, run 5 times in order to get average values.

 Only set up schemata once every NUM_OF_RUNS of allocations */

 Memory bandwidth from 100% down to 10% */

		/*

		 * The first run is discarded due to inaccurate value from

		 * phase transition.

 Field 3 is perf imc value */

 Field 5 is resctrl value */

 SPDX-License-Identifier: GPL-2.0

/*

 * Memory bandwidth monitoring and allocation library

 *

 * Copyright (C) 2018 Intel Corporation

 *

 * Authors:

 *    Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>,

 *    Fenghua Yu <fenghua.yu@intel.com>

 The value of the event */

 if PERF_FORMAT_TOTAL_TIME_ENABLED */

 if PERF_FORMAT_TOTAL_TIME_RUNNING */

 if PERF_FORMAT_ID */

/*

 * get_event_and_umask:	Parse config into event and umask

 * @cas_count_cfg:	Config

 * @count:		iMC number

 * @op:			Operation (read/write)

 Get type and config (read and write) of an iMC counter */

 Get type of iMC counter */

 Get read config */

 Get write config */

/*

 * A system can have 'n' number of iMC (Integrated Memory Controller)

 * counters, get that 'n'. For each iMC counter get it's type and config.

 * Also, each counter has two configs, one for read and the other for write.

 * A config again has two parts, event and umask.

 * Enumerate all these details into an array of structures.

 *

 * Return: >= 0 on success. < 0 on failure.

			/*

			 * imc counters are named as "uncore_imc_<n>", hence

			 * increment the pointer to point to <n>. Note that

			 * sizeof(UNCORE_IMC) would count for null character as

			 * well and hence the last underscore character in

			 * uncore_imc'_' need not be counted.

			/*

			 * Some directories under "DYN_PMU_PATH" could have

			 * names like "uncore_imc_free_running", hence, check if

			 * first character is a numerical digit or not.

 Initialize perf_event_attr structures for all iMC's */

/*

 * get_mem_bw_imc:	Memory band width as reported by iMC counters

 * @cpu_no:		CPU number that the benchmark PID is binded to

 * @bw_report:		Bandwidth report type (reads, writes)

 *

 * Memory B/W utilized by a process on a socket can be calculated using

 * iMC counters. Perf events are used to read these counters.

 *

 * Return: = 0 on success. < 0 on failure.

 Start all iMC counters to log values (both read and write) */

 Stop counters after a second to get results (both read and write) */

	/*

	 * Get results which are stored in struct type imc_counter_config

	 * Take over flow into consideration before calculating total b/w

/*

 * initialize_mem_bw_resctrl:	Appropriately populate "mbm_total_path"

 * @ctrlgrp:			Name of the control monitor group (con_mon grp)

 * @mongrp:			Name of the monitor group (mon grp)

 * @cpu_no:			CPU number that the benchmark PID is binded to

 * @resctrl_val:		Resctrl feature (Eg: mbm, mba.. etc)

/*

 * Get MBM Local bytes as reported by resctrl FS

 * For MBM,

 * 1. If con_mon grp and mon grp are given, then read from con_mon grp's mon grp

 * 2. If only con_mon grp is given, then read from con_mon grp

 * 3. If both are not given, then read from root con_mon grp

 * For MBA,

 * 1. If con_mon grp is given, then read from it

 * 2. If con_mon grp is not given, then read from root con_mon grp

/*

 * print_results_bw:	the memory bandwidth results are stored in a file

 * @filename:		file that stores the results

 * @bm_pid:		child pid that runs benchmark

 * @bw_imc:		perf imc counter value

 * @bw_resc:		memory bandwidth value

 *

 * Return:		0 on success. non-zero on failure.

/*

 * initialize_llc_occu_resctrl:	Appropriately populate "llc_occup_path"

 * @ctrlgrp:			Name of the control monitor group (con_mon grp)

 * @mongrp:			Name of the monitor group (mon grp)

 * @cpu_no:			CPU number that the benchmark PID is binded to

 * @resctrl_val:		Resctrl feature (Eg: cat, cmt.. etc)

	/*

	 * Measure memory bandwidth from resctrl and from

	 * another source which is perf imc value or could

	 * be something else if perf imc event is not available.

	 * Compare the two values to validate resctrl value.

	 * It takes 1sec to measure the data.

/*

 * resctrl_val:	execute benchmark and measure memory bandwidth on

 *			the benchmark

 * @benchmark_cmd:	benchmark command and its arguments

 * @param:		parameters passed to resctrl_val()

 *

 * Return:		0 on success. non-zero on failure.

	/*

	 * If benchmark wasn't successfully started by child, then child should

	 * kill parent, so save parent's pid

	/*

	 * Fork to start benchmark, save child's pid so that it can be killed

	 * when needed

		/*

		 * Mask all signals except SIGUSR1, parent uses SIGUSR1 to

		 * start benchmark

 Register for "SIGUSR1" signal from parent */

 Tell parent that child is ready */

 Suspend child until delivery of "SIGUSR1" from parent */

	/*

	 * Register CTRL-C handler for parent, as it has to kill benchmark

	 * before exiting

 Taskset benchmark to specified cpu */

 Write benchmark to specified control&monitoring grp in resctrl FS */

 Parent waits for child to be ready. */

 Signal child to start benchmark */

 Give benchmark enough time to fully run */

 Test runs until the callback setup() tells the test to stop. */

 SPDX-License-Identifier: GPL-2.0

/*

 * Resctrl tests

 *

 * Copyright (C) 2018 Intel Corporation

 *

 * Authors:

 *    Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>,

 *    Fenghua Yu <fenghua.yu@intel.com>

	/*

	 * Typically we need root privileges, because:

	 * 1. We write to resctrl FS

	 * 2. We execute perf commands

 Detect AMD vendor */

 Extract benchmark command from command line. */

 If no benchmark is given by "-b" argument, use fill_buf. */

 SPDX-License-Identifier: GPL-2.0

/*

 * fill_buf benchmark

 *

 * Copyright (C) 2018 Intel Corporation

 *

 * Authors:

 *    Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>,

 *    Fenghua Yu <fenghua.yu@intel.com>

 mem size in cache llines */

 Consume read result so that reading memory is not optimized out. */

	/*

	 * It's better to touch the memory once to avoid any compiler

	 * optimizations

 Flush the memory before using to avoid "cache hot pages" effect */

 set up ctrl-c handler */

 SPDX-License-Identifier: GPL-2.0

 The number of events */

 The value of the event */

 Initialize perf_event_attr structures for HW_CACHE_MISSES */

 Start counters to log values */

/*

 * get_llc_perf:	llc cache miss through perf events

 * @cpu_no:		CPU number that the benchmark PID is binded to

 *

 * Perf events like HW_CACHE_MISSES could be used to validate number of

 * cache lines allocated.

 *

 * Return: =0 on success.  <0 on failure.

 Stop counters after one span to get miss rate */

/*

 * Get LLC Occupancy as reported by RESCTRL FS

 * For CMT,

 * 1. If con_mon grp and mon grp given, then read from mon grp in

 * con_mon grp

 * 2. If only con_mon grp given, then read from con_mon grp

 * 3. If both not given, then read from root con_mon grp

 * For CAT,

 * 1. If con_mon grp given, then read from it

 * 2. If con_mon grp not given, then read from root con_mon grp

 *

 * Return: =0 on success.  <0 on failure.

/*

 * print_results_cache:	the cache results are stored in a file

 * @filename:		file that stores the results

 * @bm_pid:		child pid that runs benchmark

 * @llc_value:		perf miss value /

 *			llc occupancy value reported by resctrl FS

 *

 * Return:		0 on success. non-zero on failure.

	/*

	 * Measure cache miss from perf.

	/*

	 * Measure llc occupancy from resctrl.

/*

 * cache_val:		execute benchmark and measure LLC occupancy resctrl

 * and perf cache miss for the benchmark

 * @param:		parameters passed to cache_val()

 *

 * Return:		0 on success. non-zero on failure.

 Taskset benchmark to specified cpu */

 Write benchmark to specified con_mon grp, mon_grp in resctrl FS*/

 Test runs until the callback setup() tells the test to stop. */

/*

 * show_cache_info:	show cache test result information

 * @sum_llc_val:	sum of LLC cache result data

 * @no_of_bits:		number of bits

 * @cache_span:		cache span in bytes for CMT or in lines for CAT

 * @max_diff:		max difference

 * @max_diff_percent:	max difference percentage

 * @num_of_runs:	number of runs

 * @platform:		show test information on this platform

 * @cmt:		CMT test or CAT test

 *

 * Return:		0 on success. non-zero on failure.

 SPDX-License-Identifier: GPL-2.0

/*

 * Cache Allocation Technology (CAT) test

 *

 * Copyright (C) 2018 Intel Corporation

 *

 * Authors:

 *    Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>,

 *    Fenghua Yu <fenghua.yu@intel.com>

/*

 * Change schemata. Write schemata to specified

 * con_mon grp, mon_grp in resctrl FS.

 * Run 5 times in order to get average values.

 Run NUM_OF_RUNS times */

		/*

		 * Discard the first value which is inaccurate due to monitoring

		 * setup transition phase.

 Get default cbm mask for L3/L2 cache */

 Get L3/L2 cache size */

 Get max number of bits from default-cabm mask */

 Get core id from same socket for running another thread */

	/* Set param values for parent thread which will be allocated bitmask

	 * with (max_bits - n) bits

	/* Set param values for child thread which will be allocated bitmask

	 * with n bits

 Tell parent that child is ready */

 Parent waits for child to be ready. */

 SPDX-License-Identifier: GPL-2.0

/*

 * Basic resctrl file system operations

 *

 * Copyright (C) 2018 Intel Corporation

 *

 * Authors:

 *    Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>,

 *    Fenghua Yu <fenghua.yu@intel.com>

/*

 * remount_resctrlfs - Remount resctrl FS at /sys/fs/resctrl

 * @mum_resctrlfs:	Should the resctrl FS be remounted?

 *

 * If not mounted, mount it.

 * If mounted and mum_resctrlfs then remount resctrl FS.

 * If mounted and !mum_resctrlfs then noop

 *

 * Return: 0 on success, non-zero on failure

/*

 * get_resource_id - Get socket number/l3 id for a specified CPU

 * @cpu_no:	CPU number

 * @resource_id: Socket number or l3_id

 *

 * Return: >= 0 on success, < 0 on failure.

/*

 * get_cache_size - Get cache size for a specified CPU

 * @cpu_no:	CPU number

 * @cache_type:	Cache level L2/L3

 * @cache_size:	pointer to cache_size

 *

 * Return: = 0 on success, < 0 on failure.

/*

 * get_cbm_mask - Get cbm mask for given cache

 * @cache_type:	Cache level L2/L3

 * @cbm_mask:	cbm_mask returned as a string

 *

 * Return: = 0 on success, < 0 on failure.

/*

 * get_core_sibling - Get sibling core id from the same socket for given CPU

 * @cpu_no:	CPU number

 *

 * Return:	> 0 on success, < 0 on failure.

 Skipping core 0 as we don't want to run test on core 0 */

/*

 * taskset_benchmark - Taskset PID (i.e. benchmark) to a specified cpu

 * @bm_pid:	PID that should be binded

 * @cpu_no:	CPU number at which the PID would be binded

 *

 * Return: 0 on success, non-zero on failure

/*

 * run_benchmark - Run a specified benchmark or fill_buf (default benchmark)

 *		   in specified signal. Direct benchmark stdio to /dev/null.

 * @signum:	signal number

 * @info:	signal info

 * @ucontext:	user context in signal handling

 *

 * Return: void

	/*

	 * Direct stdio of child to /dev/null, so that only parent writes to

	 * stdio (console)

 Execute default fill_buf benchmark */

 Execute specified benchmark */

/*

 * create_grp - Create a group only if one doesn't exist

 * @grp_name:	Name of the group

 * @grp:	Full path and name of the group

 * @parent_grp:	Full path and name of the parent group

 *

 * Return: 0 on success, non-zero on failure

	/*

	 * At this point, we are guaranteed to have resctrl FS mounted and if

	 * length of grp_name == 0, it means, user wants to use root con_mon

	 * grp, so do nothing

 Check if requested grp exists or not */

 Requested grp doesn't exist, hence create it */

/*

 * write_bm_pid_to_resctrl - Write a PID (i.e. benchmark) to resctrl FS

 * @bm_pid:		PID that should be written

 * @ctrlgrp:		Name of the control monitor group (con_mon grp)

 * @mongrp:		Name of the monitor group (mon grp)

 * @resctrl_val:	Resctrl feature (Eg: mbm, mba.. etc)

 *

 * If a con_mon grp is requested, create it and write pid to it, otherwise

 * write pid to root con_mon grp.

 * If a mon grp is requested, create it and write pid to it, otherwise

 * pid is not written, this means that pid is in con_mon grp and hence

 * should consult con_mon grp's mon_data directory for results.

 *

 * Return: 0 on success, non-zero on failure

 Create control and monitoring group and write pid into it */

 Create mon grp and write pid into it for "mbm" and "cmt" test */

/*

 * write_schemata - Update schemata of a con_mon grp

 * @ctrlgrp:		Name of the con_mon grp

 * @schemata:		Schemata that should be updated to

 * @cpu_no:		CPU number that the benchmark PID is binded to

 * @resctrl_val:	Resctrl feature (Eg: mbm, mba.. etc)

 *

 * Update schemata of a con_mon grp *only* if requested resctrl feature is

 * allocation type

 *

 * Return: 0 on success, non-zero on failure

/*

 * validate_resctrl_feature_request - Check if requested feature is valid.

 * @resctrl_val:	Requested feature

 *

 * Return: True if the feature is supported, else false

 SPDX-License-Identifier: GPL-2.0

/*

 * Cache Monitoring Technology (CMT) test

 *

 * Copyright (C) 2018 Intel Corporation

 *

 * Authors:

 *    Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>,

 *    Fenghua Yu <fenghua.yu@intel.com>

 Run NUM_OF_RUNS times */

 Field 3 is llc occ resc value */

 SPDX-License-Identifier: GPL-2.0

/*

 * vdso_full_test.c: Sample code to test all the timers.

 * Copyright (c) 2019 Arm Ltd.

 *

 * Compile with:

 * gcc -std=gnu99 vdso_full_test.c parse_vdso.c

 *

 Find gettimeofday. */

 Find clock_gettime. */

 Find time. */

 Find clock_getres. */

/*

 * This function calls vdso_test_clock_gettime and vdso_test_clock_getres

 * with different values for clock_id.

 A skipped test is considered passed */

 A skipped test is considered passed */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * vdso_test.c: Sample code to test parse_vdso.c on x86

 * Copyright (c) 2011-2014 Andy Lutomirski

 *

 * You can amuse yourself by compiling with:

 * gcc -std=gnu99 -nostdlib

 *     -Os -fno-asynchronous-unwind-tables -flto -lgcc_s

 *      vdso_standalone_test_x86.c parse_vdso.c

 * to generate a small binary.  On x86_64, you can omit -lgcc_s

 * if you want the binary to be completely standalone.

 We need a libc functions... */

 This implementation is buggy: it never returns -1. */

 ...and two syscalls.  This is x86-specific. */

 Parse the stack */

 Now we're pointing at the environment.  Skip it. */

 Now we're pointing at auxv.  Initialize the vDSO parser. */

 Find gettimeofday. */

/*

 * This is the real entry point.  It passes the initial stack into

 * the C entry point.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * vdso_test_gettimeofday.c: Sample code to test parse_vdso.c and

 *                           vDSO gettimeofday()

 * Copyright (c) 2014 Andy Lutomirski

 *

 * Compile with:

 * gcc -std=gnu99 vdso_test_gettimeofday.c parse_vdso_gettimeofday.c

 *

 * Tested on x86, 32-bit and 64-bit.  It may work on other architectures, too.

/*

 * ARM64's vDSO exports its gettimeofday() implementation with a different

 * name and version from other architectures, so we need to handle it as

 * a special case.

 Find gettimeofday. */

 SPDX-License-Identifier: GPL-2.0

/*

 * ldt_gdt.c - Test cases for LDT and GDT access

 * Copyright (c) 2011-2015 Andrew Lutomirski

 max length of lines in /proc/self/maps - anything longer is skipped here */

 might still be present, but ignore it here, as we test vDSO not vsyscall */

 sscanf() is safe here as strlen(name) >= strlen(line) */

 assume entries are OK, as we test vDSO here not vsyscall */

 Also test some invalid clock ids */

 Also test some invalid clock ids */

 And make sure that passing NULL for tz doesn't crash. */

	/*

	 * Test getcpu() last so that, if something goes wrong setting affinity,

	 * we still run the other tests.

 SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note

/*

 * vdso_clock_getres.c: Sample code to test clock_getres.

 * Copyright (c) 2019 Arm Ltd.

 *

 * Compile with:

 * gcc -std=gnu99 vdso_clock_getres.c

 *

 * Tested on ARM, ARM64, MIPS32, x86 (32-bit and 64-bit),

 * Power (32-bit and 64-bit), S390x (32-bit and 64-bit).

 * Might work on other architectures.

/*

 * This function calls clock_getres in vdso and by system call

 * with different values for clock_id.

 *

 * Example of output:

 *

 * clock_id: CLOCK_REALTIME [PASS]

 * clock_id: CLOCK_BOOTTIME [PASS]

 * clock_id: CLOCK_TAI [PASS]

 * clock_id: CLOCK_REALTIME_COARSE [PASS]

 * clock_id: CLOCK_MONOTONIC [PASS]

 * clock_id: CLOCK_MONOTONIC_RAW [PASS]

 * clock_id: CLOCK_MONOTONIC_COARSE [PASS]

 SPDX-License-Identifier: GPL-2.0-only

/*

 * vdso_test_getcpu.c: Sample code to test parse_vdso.c and vDSO getcpu()

 *

 * Copyright (c) 2020 Arm Ltd

/*

 * parse_vdso.c: Linux reference vDSO parser

 * Written by Andrew Lutomirski, 2011-2014.

 *

 * This code is meant to be linked in to various programs that run on Linux.

 * As such, it is available with as few restrictions as possible.  This file

 * is licensed under the Creative Commons Zero License, version 1.0,

 * available at http://creativecommons.org/publicdomain/zero/1.0/legalcode

 *

 * The vDSO is a regular ELF DSO that the kernel maps into user space when

 * it starts a program.  It works equally well in statically and dynamically

 * linked binaries.

 *

 * This code is tested on x86.  In principle it should work on any

 * architecture that has a vDSO.

 And here's the code. */

 Load information */

 load_addr - recorded vaddr */

 Symbol table */

 Version table */

 Straight from the ELF specification. */

 Wrong ELF class -- check ELF_BITS */

	/*

	 * We need two things from the segment table: the load offset

	 * and the dynamic table.

 Failed */

	/*

	 * Fish out the useful bits of the dynamic table.

 Failed */

 Parse the hash table header. */

 That's all we need. */

	/*

	 * This is a helper function to check if the version indexed by

	 * ver matches name (which hashes to hash).

	 *

	 * The version definition table is a mess, and I don't know how

	 * to do this in better than linear time without allocating memory

	 * to build an index.  I also don't know why the table has

	 * variable size entries in the first place.

	 *

	 * For added fun, I can't find a comprehensible specification of how

	 * to parse all the weird flags in the table.

	 *

	 * So I just parse the whole table every time.

 First step: find the version definition */

 Apparently bit 15 means "hidden" */

 No definition. */

 Now figure out whether it matches. */

 Check for a defined global or weak function w/ right name. */

 Check symbol version. */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Functions needed from modify_srcu.c */

 Simpler implementation of synchronize_srcu that ignores batching. */

	/*

	 * This code assumes that try_check_zero will succeed anyway,

	 * so there is no point in multiple tries.

 Ignore the lock, as multiple writers aren't working yet anyway. */

 For comments see srcu_advance_batches. */

 SPDX-License-Identifier: GPL-2.0

 Support NR_CPUS of at most 64 */

/*

 * Simulate disabling preemption by locking a particular cpu. NR_CPUS

 * should be the actual number of cpus, not just the maximum.

 SPDX-License-Identifier: GPL-2.0

 Include all source files. */

 Used by test.c files */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0+

 Remove a file, ignoring the result if it didn't exist. */

 for mknod() */

 /dev/loop0 */

 /dev/zero */

 S_IFSOCK */

/*

 * Copyright (c) 2019 Alexey Dobriyan <adobriyan@gmail.com>

 *

 * Permission to use, copy, modify, and distribute this software for any

 * purpose with or without fee is hereby granted, provided that the above

 * copyright notice and this permission notice appear in all copies.

 *

 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES

 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF

 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR

 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES

 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN

 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF

 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

 Test that pointing #! script interpreter to self doesn't recurse. */

 Require "exec" filesystem. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2014 Google, Inc.

 *

 * Selftests for execveat(2).

 to get O_PATH, AT_EMPTY_PATH */

 Child: do execveat(). */

 should not reach here */

 Parent: wait for & check child's exit status. */

 Create a filename close to PATH_MAX in length */

	/*

	 * Execute as a pre-opened file descriptor, which works whether this is

	 * a script or not (because the interpreter sees a filename like

	 * "/dev/fd/20").

	/*

	 * Execute as a long pathname relative to "/".  If this is a script,

	 * the interpreter will launch but fail to open the script because its

	 * name ("/dev/fd/5/xxx....") is bigger than PATH_MAX.

	 *

	 * The failure code is usually 127 (POSIX: "If a command is not found,

	 * the exit status shall be 127."), but some systems give 126 (POSIX:

	 * "If the command name is found, but it is not an executable utility,

	 * the exit status shall be 126."), so allow either.

 Check if we have execveat at all, and bail early if not */

 Change file position to confirm it doesn't affect anything */

 Normal executable file: */

   dfd + path */

   absolute path */

   absolute path with nonsense dfd */

   fd + no path */

   O_CLOEXEC fd + no path */

   O_PATH fd */

 Mess with executable file that's already open: */

   fd + no path to a file that's been renamed */

   fd + no path to a file that's been deleted */

 remove the file now fd open */

 Mess with executable file that's already open with O_PATH */

   fd + no path to a file that's been deleted */

 Invalid argument failures */

 Symlink to executable file: */

   dfd + path */

   absolute path */

   fd + no path, even with AT_SYMLINK_NOFOLLOW (already followed) */

 Symlink fails when AT_SYMLINK_NOFOLLOW set: */

   dfd + path */

   absolute path */

  Non-regular file failure */

 Shell script wrapping executable file: */

   dfd + path */

   absolute path */

   fd + no path */

   O_CLOEXEC fd fails for a script (as script file inaccessible) */

 Mess with script file that's already open: */

   fd + no path to a file that's been renamed */

   fd + no path to a file that's been deleted */

 remove the file while fd open */

 Rename a subdirectory in the path: */

 Remove the subdir and its contents */

 Shell loads via deleted subdir OK because name starts with .. */

 Flag values other than AT_SYMLINK_NOFOLLOW => EINVAL */

 Invalid path => ENOENT */

 Attempt to execute directory => EACCES */

 Attempt to execute non-executable => EACCES */

 Attempt to execute nonsense FD => EBADF */

 Attempt to execute relative to non-directory => ENOTDIR */

 Create ephemeral copies of files */

 If we are invoked with an argument, don't run tests. */

 Check expected environment transferred. */

 Use the final argument as an exit code. */

 SPDX-License-Identifier: GPL-2.0-only

 Ignore headers from other than the executable.

 Terminate dl_iterate_phdr.

 SPDX-License-Identifier: GPL-2.0

 Do not follow symlinks */

 Do not follow symlinks */

 SPDX-License-Identifier: GPL-2.0

 parent */

 system("cat /proc/self/mounts"); */

 system("cat /proc/self/mounts"); */

 parent */

 system("cat /proc/self/mounts"); */

 SPDX-License-Identifier: GPL-2.0

/* Test triggering of loading of firmware from different mount

 * namespaces. Expect firmware to be always loaded from the mount

 parent */

	/* Mount tmpfs to /lib/firmware so we don't have to assume

 Positive case: firmware in PID1 mount namespace */

 Negative case: firmware in child mount namespace, expected to fail */

 SPDX-License-Identifier: GPL-2.0

/*

 * Watchdog Driver Test Program

/*

 * This function simply sends an IOCTL to the driver, which in turn ticks

 * the PC Watchdog card to reset its internal timer so it doesn't trigger

 * a computer reset.

/*

 * The main program.  Run the program with "-d" to disable the card,

 * or "-e" to enable the card.

	/*

	 * Validate that `file` is a watchdog device

 Handled above */

			/*

			 * watchdog_info was obtained as part of file open

			 * validation. So we just show it here.

 SPDX-License-Identifier: GPL-2.0

/*

 * memfd GUP test-case

 * This tests memfd interactions with get_user_pages(). We require the

 * fuse_mnt.c program to provide a fake direct-IO FUSE mount-point for us. This

 * file-system delays _all_ reads by 1s and forces direct-IO. This means, any

 * read() on files in that file-system will pin the receive-buffer pages for at

 * least 1s via get_user_pages().

 *

 * We use this trick to race ADD_SEALS against a write on a memfd object. The

 * ADD_SEALS must fail if the memfd pages are still pinned. Note that we use

 * the read() syscall with our memory-mapped memfd object as receive buffer to

 * force the kernel to write into our memfd object.

	/*

	 * This thread first waits 200ms so any pending operation in the parent

	 * is correctly started. After that, it tries to seal @global_mfd as

	 * SEAL_WRITE. This _must_ fail as the parent thread has a read() into

	 * that memory mapped object still ongoing.

	 * We then wait one more second and try sealing again. This time it

	 * must succeed as there shouldn't be anyone else pinning the pages.

 wait 200ms for FUSE-request to be active */

 unmount mapping before sealing to avoid i_mmap_writable failures */

	/* Try sealing the global file; expect EBUSY or success. Current

	 * kernels will never succeed, but in the future, kernels might

	 * implement page-replacements or other fancy ways to avoid racing

 wait 1s more so the FUSE-request is done */

 try sealing the global file again */

 open FUSE memfd file for GUP testing */

 create new memfd-object */

 mmap memfd-object for writing */

	/* pass mfd+mapping to a separate sealing-thread which tries to seal

	/* Use read() on the FUSE file to read into our memory-mapped memfd

	 * object. This races the other thread which tries to seal the

	 * memfd-object.

	 * If @fd is on the memfd-fake-FUSE-FS, the read() is delayed by 1s.

	 * This guarantees that the receive-buffer is pinned for 1s until the

	 * data is written into it. The racing ADD_SEALS should thus fail as

	/* Wait for sealing-thread to finish and verify that it

	/* *IF* the memfd-object was sealed at the time our read() returned,

	 * then the kernel did a page-replacement or canceled the read() (or

	 * whatever magic it did..). In that case, the memfd object is still

	 * all zero.

	 * In case the memfd-object was *not* sealed, the read() was successfull

	 * and the memfd object must *not* be all zero.

	 * Note that in real scenarios, there might be a mixture of both, but

	 * in this test-cases, we have explicit 200ms delays which should be

 SPDX-License-Identifier: GPL-2.0

/*

 * memfd test file-system

 * This file uses FUSE to create a dummy file-system with only one file /memfd.

 * This file is read-only and takes 1s per read.

 *

 * This file-system is used by the memfd test-cases to force the kernel to pin

 * pages during reads(). Due to the 1s delay of this file-system, this is a

 * nice way to test race-conditions against get_user_pages() in the kernel.

 *

 * We use direct_io==1 to force the kernel to use direct-IO for this

 * file-system.

 force direct-IO */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copied from mlock2-tests.c

 SPDX-License-Identifier: GPL-2.0

/*

 * Default is not to test hugetlbfs

 verify PROT_READ *is* allowed */

 verify MAP_PRIVATE is *always* allowed (even writable) */

 Test that PROT_READ + MAP_SHARED mappings work. */

 verify PROT_READ and MAP_SHARED *is* allowed */

	/*

	 * huegtlbfs does not support write, but we want to

	 * verify everything else here.

 verify write() succeeds */

 verify PROT_READ | PROT_WRITE is allowed */

 verify PROT_WRITE is allowed */

	/* verify PROT_READ with MAP_SHARED is allowed and a following

 verify PUNCH_HOLE works */

 verify write() fails */

 verify PROT_READ | PROT_WRITE is not allowed */

 verify PROT_WRITE is not allowed */

	/* Verify PROT_READ with MAP_SHARED with a following mprotect is not

 verify PUNCH_HOLE fails */

 hugetlbfs does not support write */

 hugetlbfs does not support write */

 dummy waiter; SIGTERM terminates us anyway */

/*

 * Test memfd_create() syscall

 * Verify syscall-argument validation, including name checks, flag validation

 * and more.

 test NULL name */

 test over-long name (not zero-terminated) */

 test over-long zero-terminated name */

 verify "" is a valid name */

 verify invalid O_* open flags */

 verify MFD_CLOEXEC is allowed */

 verify MFD_ALLOW_SEALING is allowed */

 verify MFD_ALLOW_SEALING | MFD_CLOEXEC is allowed */

/*

 * Test basic sealing

 * A very basic sealing test to see whether setting/retrieving seals works.

 add basic seals */

 add them again */

 add more seals and seal against sealing */

 verify that sealing no longer works */

 verify sealing does not work without MFD_ALLOW_SEALING */

/*

 * Test SEAL_WRITE

 * Test whether SEAL_WRITE actually prevents modifications.

/*

 * Test SEAL_FUTURE_WRITE

 * Test whether SEAL_FUTURE_WRITE actually prevents modifications.

 read should pass, writes should fail */

 read should pass, writes should still fail */

/*

 * Test SEAL_SHRINK

 * Test whether SEAL_SHRINK actually prevents shrinking

/*

 * Test SEAL_GROW

 * Test whether SEAL_GROW actually prevents growing

/*

 * Test SEAL_SHRINK | SEAL_GROW

 * Test whether SEAL_SHRINK | SEAL_GROW actually prevents resizing

/*

 * Test sharing via dup()

 * Test that seals are shared between dupped FDs and they're all equal.

/*

 * Test sealing with active mmap()s

 * Modifying seals is only allowed if no other mmap() refs exist.

 shared/writable ref prevents sealing WRITE, but allows others */

 readable ref allows sealing */

/*

 * Test sealing with open(/proc/self/fd/%d)

 * Via /proc we can get access to a separate file-context for the same memfd.

 * This is *not* like dup(), but like a real separate open(). Make sure the

 * semantics are as expected and we correctly check for RDONLY / WRONLY / RDWR.

/*

 * Test sharing via fork()

 * Test whether seal-modifications work as expected with forked childs.

	/* Run test-suite in a multi-threaded environment with a shared

 SPDX-License-Identifier: GPL-2.0+

/* This testcase operates with the test_fpu kernel driver.

 * It modifies the FPU control register in user mode and calls the kernel

 * module to perform floating point operations in the kernel. The control

 * register value should be independent between kernel and user mode.

	/* Note: the tests up to this point are quite safe and will only return

	 * an error. But the exception mask setting can cause misbehaving kernel

	 * to crash.

 SPDX-License-Identifier: GPL-2.0

 test ir decoder



 Copyright (C) 2018 Sean Young <sean@mess.org>

 When sending LIRC_MODE_SCANCODE, the IR will be encoded. rc-loopback

 will send this IR to the receiver side, where we try to read the decoded

 IR. Decoding happens in a separate kernel thread, so we will need to

 wait until that is scheduled, hence we use poll to check for read

 readiness.

RESULT=`echo $RESULT | sed -e 's/.* \((.*)\) \((.*)\) .*/\1 \2/'`

'`

"`

    cat trace | grep -v '^#' | sed -e 's/[^-]*-\([0-9]*\).*/\1/' | grep $pid | wc -l

}



count_no_pid() {

    pid=$1

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2020 HiSilicon Limited.

 average map latency in 100ns */

 standard deviation of map latency */

 as above */

 how many threads will do map/unmap in parallel */

 how long the test will last */

 which numa node this benchmark will run on */

 DMA addressing capability */

 DMA data direction */

 time for DMA transmission in ns */

 how many PAGE_SIZE will do map/unmap once a time */

 For future use */

 default single thread, run 20 seconds on NUMA_NO_NODE */

 default dma mask 32bit, bidirectional DMA */

 default granule 1 PAGESIZE */

 suppose the mininum DMA zone is 1MB in the world */

 SPDX-License-Identifier: GPL-2.0

/*

 * Landlock tests - Common user space base

 *

 * Copyright  2017-2020 Mickal Salan <mic@digikod.net>

 * Copyright  2019-2020 ANSSI

 Checks copy_from_user(). */

 The size if less than sizeof(struct landlock_attr_enforce). */

 The size if less than sizeof(struct landlock_attr_enforce). */

 Checks non-zero value. */

 Similar to struct landlock_path_beneath_attr.parent_fd = 0 */

 Tests enforcement of a ruleset FD transferred through a UNIX socket. */

 Aligned ancillary data buffer. */

 Creates a test ruleset with a simple rule. */

 Sends the ruleset FD over a socketpair and then close it. */

 Enforces the received ruleset on the child. */

 Checks that the ruleset enforcement. */

 Checks that the parent is unrestricted. */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

/*

 * Landlock tests - Filesystem

 *

 * Copyright  2017-2020 Mickal Salan <mic@digikod.net>

 * Copyright  2020 ANSSI

 * Copyright  2020-2021 Microsoft Corporation

 Paths (sibling number and depth) */

 dir_s3d2 is a mount point. */

/*

 * layout1 hierarchy:

 *

 * tmp

 *  s1d1

 *   f1

 *   f2

 *   s1d2

 *       f1

 *       f2

 *       s1d3

 *           f1

 *           f2

 *  s2d1

 *   f1

 *   s2d2

 *       f1

 *       s2d3

 *           f1

 *           f2

 *  s3d1

 *      s3d2

 *          s3d3

	/*

	 * Do not pollute the rest of the system: creates a private mount point

	 * for tests relying on pivot_root(2) and move_mount(2).

/*

 * This helper enables to use the ASSERT_* macros and print the line number

 * pointing to the test caller.

 Works with file and directories. */

	/*

	 * Mixing error codes from close(2) and open(2) should not lead to any

	 * (access type) confusion for this test.

 Returns EBADF because ruleset_fd is not a landlock-ruleset FD. */

 Returns EBADFD because ruleset_fd is not a valid ruleset. */

 Gets a real ruleset. */

 Tests without O_PATH. */

 Tests with a ruleset FD. */

 Checks unhandled allowed_access. */

 Test with legitimate values. */

 Test with unknown (64-bits) value. */

 Test with no access. */

 Enforces the ruleset. */

 Tests access rights for files. */

	/*

	 * Because nsfs is an internal filesystem, /proc/self/ns/mnt is a

	 * disconnected path.  Such path cannot be identified and must then be

	 * allowed.

	/*

	 * Checks that it is not possible to add nsfs-like filesystem

	 * references to a ruleset.

 enforce_ruleset() calls prctl(no_new_privs). */

 Tests on a directory. */

 Tests on a file. */

 Checks effective read and write actions. */

 Just in case, double-checks effective actions. */

 Here, we only handle read accesses, not write accesses. */

	/*

	 * Because the policy does not handle LANDLOCK_ACCESS_FS_WRITE_FILE,

	 * opening for write-only should be allowed, but not read-write.

 These rules should be ORed among them. */

 Checks s1d1 hierarchy. */

 Checks s1d2 hierarchy. */

 Checks s1d3 hierarchy. */

 Unchanged accesses for file creation. */

 Checks file removing. */

	/*

	 * Checks overly restrictive rules:

	 * layer 1: allows R   s1d1/s1d2/s1d3/file1

	 * layer 2: allows RW  s1d1/s1d2/s1d3

	 *          allows  W  s1d1/s1d2

	 *          denies R   s1d1/s1d2

	 * layer 3: allows R   s1d1

	 * layer 4: allows R   s1d1/s1d2

	 *          denies  W  s1d1/s1d2

	 * layer 5: allows R   s1d1/s1d2

	 * layer 6: allows   X ----

	 * layer 7: allows  W  s1d1/s1d2

	 *          denies R   s1d1/s1d2

 Allows read access to file1_s1d3 with the first layer. */

 First rule with write restrictions. */

 Start by granting read-write access via its parent directory... */

 ...but also denies read access via its grandparent directory. */

 Allows read access via its great-grandparent directory. */

		/*

		 * Try to confuse the deny access by denying write (but not

		 * read) access via its grandparent directory.

		/*

		 * Try to override layer2's deny read access by explicitly

		 * allowing read access via file1_s1d3's grandparent.

		/*

		 * Restricts an unrelated file hierarchy with a new access

		 * (non-overlapping) type.

		/*

		 * Finally, denies read access to file1_s1d3 via its

		 * grandparent.

 Checks that read access is granted for file1_s1d3 with layer 1. */

 Checks that previous access rights are unchanged with layer 2. */

 Checks that previous access rights are unchanged with layer 3. */

 This time, denies write access for the file hierarchy. */

	/*

	 * Checks that the only change with layer 4 is that write access is

	 * denied.

 Checks that previous access rights are unchanged with layer 5. */

 Checks that previous access rights are unchanged with layer 6. */

 Checks read access is now denied with layer 7. */

 Write access is forbidden. */

 Readdir access is allowed. */

 Write access is forbidden. */

 Readdir access is allowed. */

	/*

	 * Tests shared rule extension: the following rules should not grant

	 * any new access, only remove some.  Once enforced, these rules are

	 * ANDed with the previous ones.

	/*

	 * According to ruleset_fd, dir_s1d2 should now have the

	 * LANDLOCK_ACCESS_FS_READ_FILE and LANDLOCK_ACCESS_FS_WRITE_FILE

	 * access rights (even if this directory is opened a second time).

	 * However, when enforcing this updated ruleset, the ruleset tied to

	 * the current process (i.e. its domain) will still only have the

	 * dir_s1d2 with LANDLOCK_ACCESS_FS_READ_FILE and

	 * LANDLOCK_ACCESS_FS_READ_DIR accesses, but

	 * LANDLOCK_ACCESS_FS_WRITE_FILE must not be allowed because it would

	 * be a privilege escalation.

 Same tests and results as above. */

 It is still forbidden to write in file1_s1d2. */

 Readdir access is still allowed. */

 It is still forbidden to write in file1_s1d3. */

 Readdir access is still allowed. */

	/*

	 * Try to get more privileges by adding new access rights to the parent

	 * directory: dir_s1d1.

 Same tests and results as above. */

 It is still forbidden to write in file1_s1d2. */

 Readdir access is still allowed. */

 It is still forbidden to write in file1_s1d3. */

 Readdir access is still allowed. */

	/*

	 * Now, dir_s1d3 get a new rule tied to it, only allowing

	 * LANDLOCK_ACCESS_FS_WRITE_FILE.  The (kernel internal) difference is

	 * that there was no rule tied to it before.

	/*

	 * Same tests and results as above, except for open(dir_s1d3) which is

	 * now denied because the new rule mask the rule previously inherited

	 * from dir_s1d2.

 Same tests and results as above. */

 It is still forbidden to write in file1_s1d2. */

 Readdir access is still allowed. */

 It is still forbidden to write in file1_s1d3. */

	/*

	 * Readdir of dir_s1d3 is still allowed because of the OR policy inside

	 * the same layer.

 Readdir access is denied for dir_s1d2. */

 Readdir access is allowed for dir_s1d3. */

 File access is allowed for file1_s1d3. */

 Now dir_s1d2, parent of dir_s1d3, gets a new rule tied to it. */

 Readdir access is still denied for dir_s1d2. */

 Readdir access is still allowed for dir_s1d3. */

 File access is still allowed for file1_s1d3. */

 Tests empty handled_access_fs. */

 Enforces policy which deny read access to all files. */

 Nests a policy which deny read access to all directories. */

 Enforces a second time with the same ruleset. */

 dir_s3d2 is a mount point. */

 dir_s3d2 is a mount point. */

/*

 * This test verifies that we can apply a landlock rule on the root directory

 * (which might require special handling).

 Checks allowed access. */

 Checks denied access (on a directory). */

 Checks denied access (on a directory). */

 Unmount a file hierarchy while it is being used by a ruleset. */

 This dir_s3d3 would not be allowed and does not exist anyway. */

	/*

	 * Common layer to check that chroot doesn't ignore it (i.e. a chroot

	 * is not a disconnected root directory).

 Do chroot into dir_s1d2 (relative to dir_s2d2). */

 Do chroot into dir_s1d2. */

 The current directory is dir_s2d2. */

 The current directory is dir_s1d2. */

 Checks the root dir_s1d2. */

 Denies linking because of reparenting. */

	/*

	 * Tries to replace a file, from a directory that allows file removal,

	 * but to a different directory (which also allows file removal).

	/*

	 * Tries to replace a file, from a directory that denies file removal,

	 * to a different directory (which allows file removal).

 Exchanges files and directories that partially allow removal. */

 Renames files with different parents. */

 Exchanges and renames files with same parent. */

 Exchanges files and directories with same parent, twice. */

 Empties dir_s1d3 to allow renaming. */

 Exchanges and renames directory to a different parent. */

	/*

	 * Exchanges directory to the same parent, which doesn't allow

	 * directory removal.

	/*

	 * Exchanges and renames directory to the same parent, which allows

	 * directory removal.

 dir_s1d2 itself cannot be removed. */

 Creates a /dev/null device. */

 Creates a /dev/loop0 device. */

 Uses file_* as directory names. */

 Limits read and write access to files tied to the filesystem. */

 Checks enforcement for normal files. */

 Checks access to pipes through FD. */

 Checks write access to pipe through /proc/self/fd . */

 Checks read access to pipe through /proc/self/fd . */

/*

 * layout1_bind hierarchy:

 *

 * tmp

 *  s1d1

 *   f1

 *   f2

 *   s1d2

 *       f1

 *       f2

 *       s1d3

 *           f1

 *           f2

 *  s2d1

 *   f1

 *   s2d2

 *       f1

 *       f2

 *       s1d3

 *           f1

 *           f2

 *  s3d1

 *      s3d2

 *          s3d3

	/*

	 * Sets access right on parent directories of both source and

	 * destination mount points.

	/*

	 * Sets access rights on the same bind-mounted directories.  The result

	 * should be ACCESS_RW for both directories, but not both hierarchies

	 * because of the first layer.

 Only allow read-access to the s1d3 hierarchies. */

 Removes all access rights. */

 Sets rules for the parent directories. */

 Checks source hierarchy. */

 Checks destination hierarchy. */

 Sets rules for the mount points. */

 Checks source hierarchy. */

 Checks destination hierarchy. */

 Sets a (shared) rule only on the source. */

 Checks source hierarchy. */

 Checks destination hierarchy. */

 Sets a (shared) rule only on the destination. */

 Checks source hierarchy. */

 Checks destination hierarchy. */

/*

 * layout2_overlay hierarchy:

 *

 * tmp

 *  lower

 *   data

 *       dl1

 *        fl2

 *       do1

 *        fl3

 *        fo2

 *       fl1

 *       fo1

 *  merge

 *   data

 *       dl1

 *        fl2

 *       do1

 *        fl3

 *        fo2

 *        fu3

 *       du1

 *        fu2

 *       fl1

 *       fo1

 *       fu1

 *  upper

 *      data

 *       do1

 *        fo2

 *        fu3

 *       du1

 *        fu2

 *       fo1

 *       fu1

 *      work

 *          work

 Creates tmpfs mount points to get deterministic overlayfs. */

 Sets access right on parent directories of both layers. */

 Sets access right on directories inside both layers. */

 Tighten access rights to the files. */

 Sets rules on base directories (i.e. outside overlay scope). */

 Checks lower layer. */

 Checks upper layer. */

	/*

	 * Checks that access rights are independent from the lower and upper

	 * layers: write access to upper files viewed through the merge point

	 * is still allowed, and write access to lower file viewed (and copied)

	 * through the merge point is still allowed.

 Sets rules on data directories (i.e. inside overlay scope). */

 Checks merge. */

 Same checks with tighter rules. */

 Checks changes for lower layer. */

 Checks changes for upper layer. */

 Checks all merge accesses. */

 Sets rules directly on overlayed files. */

 Checks unchanged accesses on lower layer. */

 Checks unchanged accesses on upper layer. */

 Checks all merge accesses. */

 Only allowes access to the merge hierarchy. */

 Checks new accesses on lower layer. */

 Checks new accesses on upper layer. */

 Checks all merge accesses. */

 SPDX-License-Identifier: GPL-2.0

/*

 * Landlock tests - Ptrace

 *

 * Copyright  2017-2020 Mickal Salan <mic@digikod.net>

 * Copyright  2019-2020 ANSSI

	/*

	 * Mixing error codes from close(2) and open(2) should not lead to any

	 * (access type) confusion for this test.

/*

 * Test multiple tracing combinations between a parent process P1 and a child

 * process P2.

 *

 * Yama's scoped ptrace is presumed disabled.  If enabled, this optional

 * restriction is enforced in addition to any Landlock check, which means that

 * all P2 requests to trace P1 would be denied.

/*

 *        No domain

 *

 *   P1-.               P1 -> P2 : allow

 *       \              P2 -> P1 : allow

 *        'P2

/*

 *        Child domain

 *

 *   P1--.              P1 -> P2 : allow

 *        \             P2 -> P1 : deny

 *        .'-----.

 *        |  P2  |

 *        '------'

/*

 *        Parent domain

 * .------.

 * |  P1  --.           P1 -> P2 : deny

 * '------'  \          P2 -> P1 : allow

 *            '

 *            P2

/*

 *        Parent + child domain (siblings)

 * .------.

 * |  P1  ---.          P1 -> P2 : deny

 * '------'   \         P2 -> P1 : deny

 *         .---'--.

 *         |  P2  |

 *         '------'

/*

 *         Same domain (inherited)

 * .-------------.

 * | P1----.     |      P1 -> P2 : allow

 * |        \    |      P2 -> P1 : allow

 * |         '   |

 * |         P2  |

 * '-------------'

/*

 *         Inherited + child domain

 * .-----------------.

 * |  P1----.        |  P1 -> P2 : allow

 * |         \       |  P2 -> P1 : deny

 * |        .-'----. |

 * |        |  P2  | |

 * |        '------' |

 * '-----------------'

/*

 *         Inherited + parent domain

 * .-----------------.

 * |.------.         |  P1 -> P2 : deny

 * ||  P1  ----.     |  P2 -> P1 : allow

 * |'------'    \    |

 * |             '   |

 * |             P2  |

 * '-----------------'

/*

 *         Inherited + parent and child domain (siblings)

 * .-----------------.

 * | .------.        |  P1 -> P2 : deny

 * | |  P1  .        |  P2 -> P1 : deny

 * | '------'\       |

 * |          \      |

 * |        .--'---. |

 * |        |  P2  | |

 * |        '------' |

 * '-----------------'

 Test PTRACE_TRACEME and PTRACE_ATTACH for parent and child. */

	/*

	 * Removes all effective and permitted capabilities to not interfere

	 * with cap_ptrace_access_check() in case of PTRACE_MODE_FSCREDS.

 Aborts before forking. */

 Waits for the parent to be in a domain, if any. */

 Tests PTRACE_ATTACH and PTRACE_MODE_READ on the parent. */

 Tests child PTRACE_TRACEME. */

		/*

		 * Signals that the PTRACE_ATTACH test is done and the

		 * PTRACE_TRACEME test is ongoing.

 Waits for the parent PTRACE_ATTACH test. */

 Signals that the parent is in a domain, if any. */

	/*

	 * Waits for the child to test PTRACE_ATTACH on the parent and start

	 * testing PTRACE_TRACEME.

 Tests child PTRACE_TRACEME. */

 The child should not be traced by the parent. */

 Tests PTRACE_ATTACH and PTRACE_MODE_READ on the child. */

 Signals that the parent PTRACE_ATTACH test is done. */

 SPDX-License-Identifier: GPL-2.0

 skip unsupported attribute in user-space */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2013-2015, Michael Ellerman, IBM Corp.

 For CPU_ZERO etc. */

 We prefer a primary thread, but skip 0 */

 Search for anything, but in reverse */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2013, Michael Ellerman, IBM Corp.

 Setting timeout to -1 disables the alarm */

 Make sure output is flushed before forking */

 Wake us up in timeout seconds */

 Kill anything else in the process group that is still running */

 Signal or other */

 Just wake us up from waitpid */

 so that skipped test is not marked as failed */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * POWER Data Stream Control Register (DSCR) SPR test

 *

 * This test modifies the DSCR value through both the SPR number

 * based mtspr instruction and then makes sure that the same is

 * reflected through mfspr instruction using either of the SPR

 * numbers.

 *

 * When using the privilege state SPR, the instructions such as

 * mfspr or mtspr are priviledged and the kernel emulates them

 * for us. Instructions using problem state SPR can be exuecuted

 * directly without any emulation if the HW supports them. Else

 * they also get emulated by the kernel.

 *

 * Copyright 2013, Anton Blanchard, IBM Corporation.

 * Copyright 2015, Anshuman Khandual, IBM Corporation.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * POWER Data Stream Control Register (DSCR) explicit test

 *

 * This test modifies the DSCR value using mtspr instruction and

 * verifies the change with mfspr instruction. It uses both the

 * privilege state SPR and the problem state SPR for this purpose.

 *

 * When using the privilege state SPR, the instructions such as

 * mfspr or mtspr are priviledged and the kernel emulates them

 * for us. Instructions using problem state SPR can be exuecuted

 * directly without any emulation if the HW supports them. Else

 * they also get emulated by the kernel.

 *

 * Copyright 2012, Anton Blanchard, IBM Corporation.

 * Copyright 2015, Anshuman Khandual, IBM Corporation.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * POWER Data Stream Control Register (DSCR) fork exec test

 *

 * This testcase modifies the DSCR using mtspr, forks & execs and

 * verifies that the child is using the changed DSCR using mfspr.

 *

 * When using the privilege state SPR, the instructions such as

 * mfspr or mtspr are privileged and the kernel emulates them

 * for us. Instructions using problem state SPR can be executed

 * directly without any emulation if the HW supports them. Else

 * they also get emulated by the kernel.

 *

 * Copyright 2012, Anton Blanchard, IBM Corporation.

 * Copyright 2015, Anshuman Khandual, IBM Corporation.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * POWER Data Stream Control Register (DSCR) default test

 *

 * This test modifies the system wide default DSCR through

 * it's sysfs interface and then verifies that all threads

 * see the correct changed DSCR value immediately.

 *

 * Copyright 2012, Anton Blanchard, IBM Corporation.

 * Copyright 2015, Anshuman Khandual, IBM Corporation.

 System DSCR default */

 Initial DSCR default */

 Spawn all testing threads */

 Keep changing the DSCR default */

 Individual testing thread exit status */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * POWER Data Stream Control Register (DSCR) sysfs thread test

 *

 * This test updates the system wide DSCR default value through

 * sysfs interface which should then update all the CPU specific

 * DSCR default values which must also be then visible to threads

 * executing on individual CPUs on the system.

 *

 * Copyright 2015, Anshuman Khandual, IBM Corporation.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * POWER Data Stream Control Register (DSCR) fork test

 *

 * This testcase modifies the DSCR using mtspr, forks and then

 * verifies that the child process has the correct changed DSCR

 * value using mfspr.

 *

 * When using the privilege state SPR, the instructions such as

 * mfspr or mtspr are priviledged and the kernel emulates them

 * for us. Instructions using problem state SPR can be exuecuted

 * directly without any emulation if the HW supports them. Else

 * they also get emulated by the kernel.

 *

 * Copyright 2012, Anton Blanchard, IBM Corporation.

 * Copyright 2015, Anshuman Khandual, IBM Corporation.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * POWER Data Stream Control Register (DSCR) sysfs interface test

 *

 * This test updates to system wide DSCR default through the sysfs interface

 * and then verifies that all the CPU specific DSCR defaults are updated as

 * well verified from their sysfs interfaces.

 *

 * Copyright 2015, Anshuman Khandual, IBM Corporation.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Test that a syscall does not get restarted twice, handled by trap_norestart()

 *

 * Based on Al's description, and a test for the bug fixed in this commit:

 *

 * commit 9a81c16b527528ad307843be5571111aa8d35a80

 * Author: Al Viro <viro@zeniv.linux.org.uk>

 * Date:   Mon Sep 20 21:48:57 2010 +0100

 *

 *  powerpc: fix double syscall restarts

 *

 *  Make sigreturn zero regs->trap, make do_signal() do the same on all

 *  paths.  As it is, signal interrupting e.g. read() from fd 512 (==

 *  ERESTARTSYS) with another signal getting unblocked when the first

 *  handler finishes will lead to restart one insn earlier than it ought

 *  to.  Same for multiple signals with in-kernel handlers interrupting

 *  that sucker at the same time.  Same for multiple signals of any kind

 *  interrupting that sucker on 64bit...

	/*

	 * SIGUSR2 is blocked until the handler exits, at which point it will

	 * be raised again and think there is a restart to be done because the

	 * pending restarted syscall has 512 (ERESTARTSYS) in r3. The second

	 * restart will retreat NIP another 4 bytes to fail case branch.

 Child reads from pipe */

 Let's get ERESTARTSYS into r3 */

 Hack to get reader waiting */

 SPDX-License-Identifier: GPL-2.0

/*

 * Test that we can take signals with and without the VDSO mapped, which trigger

 * different paths in the signal handling code.

 *

 * See handle_rt_signal64() and setup_trampoline() in signal_64.c

 Ensure assert() is not compiled out

 Confirm the VDSO is mapped, and work out where it is

 Remap the VDSO somewhere else

 Confirm the VDSO is not mapped anymore

 Make the stack executable

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright 2018, Breno Leitao, IBM Corp.

 * Licensed under GPLv2.

 *

 * Sigfuz(tm): A PowerPC TM-aware signal fuzzer.

 *

 * This is a new selftest that raises SIGUSR1 signals and handles it in a set

 * of different ways, trying to create different scenario for testing

 * purpose.

 *

 * This test works raising a signal and calling sigreturn interleaved with

 * TM operations, as starting, suspending and terminating a transaction. The

 * test depends on random numbers, and, based on them, it sets different TM

 * states.

 *

 * Other than that, the test fills out the user context struct that is passed

 * to the sigreturn system call with random data, in order to make sure that

 * the signal handler syscall can handle different and invalid states

 * properly.

 *

 * This selftest has command line parameters to control what kind of tests the

 * user wants to run, as for example, if a transaction should be started prior

 * to signal being raised, or, after the signal being raised and before the

 * sigreturn. If no parameter is given, the default is enabling all options.

 *

 * This test does not check if the user context is being read and set

 * properly by the kernel. Its purpose, at this time, is basically

 * guaranteeing that the kernel does not crash on invalid scenarios.

 Selftest defaults */

 Number of interactions */

 Number of threads */

 Arguments options */

 checkpoint context */

 Return true with 1/x probability */

 Change TM states */

 Starts a transaction 33% of the time */

 And suspended half of them */

 Call 'tend' in 5% of the runs */

 Signal handler that will be invoked with raise() */

	/*

	 * Set uc_link in three possible ways:

	 *  - Setting a single 'int' in the whole chunk

	 *  - Cloning ucp into uc_link

	 *  - Allocating a new memory chunk

 Trying to cause a major page fault at Kernel level */

 Changing the checkpointed registers */

 Checking the current register context */

 Nested transaction start */

 Return without changing any other context info */

 Clear exit for process that segfaults */

 Main signal handler */

 SIGSEGV signal handler */

 The signal handler will enable MSR_TS */

 If it does not crash, it will segfault, avoid it to retest */

 Once seed per process */

 If not freed already, free now */

 Default test suite */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2016, Cyril Bur, IBM Corp.

 *

 * Sending one self a signal should always get delivered.

 Don't do this for MAX_ATTEMPT, its simply too long */

 Disable any pending */

 For the line number */

 Otherwise we'll loop too fast and fork() will eventually fail */

 Disable any pending */

 For the line number */

 For the line number */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2016, Cyril Bur, IBM Corp.

 *

 * Sending one self a signal should always get delivered.

		/*

		 * If anything bad happens in ASM and we fail to set ret

		 * because *handwave* TM this will cause failure

 Disable any pending */

			/*

			 * This basically means the transaction aborted before we

			 * even got to the suspend... this is crazy but it

			 * happens.

			 * Yes this also means we might never make forward

			 * progress... the alarm() will trip eventually...

 Ret is actually an errno */

 For the line number */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2014, Michael Ellerman, IBM Corp.

 For CPU_ZERO etc. */

 sometimes expected */

 Signal or other */

	/*

	 * We are just here to eat cpu and die. So make sure we can be killed,

	 * and also don't do any custom SIGTERM handling.

 Soak up cpu forever */

 This skips line with no executable which is what we want */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2013, Michael Ellerman, IBM Corp.

 Run for 1M instructions */

 Tolerate a difference below 0.0001 % */

 Count how many instructions it takes to do a null loop */

 Run for 1Mi instructions */

 Run for 10Mi instructions */

 Run for 100Mi instructions */

 Run for 1Bi instructions */

 Run for 16Bi instructions */

 Run for 64Bi instructions */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2014, Michael Ellerman, IBM Corp.

/*

 * Test that per-event excludes work.

	/*

	 * We need to create the events disabled, otherwise the running/enabled

	 * counts don't match up.

	/*

	 * The open here will fail if we don't have per event exclude support,

	 * because the second event has an incompatible set of exclude settings

	 * and we're asking for the events to be in a group.

	/*

	 * Even though the above will fail without per-event excludes we keep

	 * testing in order to be thorough.

 Spin for a while */

	/*

	 * We should see that all events have enabled == running. That

	 * shows that they were all on the PMU at once.

	/*

	 * We can also check that the result for instructions is >= all the

	 * other counts. That's because it is counting all instructions while

	 * the others are counting a subset.

/*

 * Copyright 2013, Michael Ellerman, IBM Corp.

 * Licensed under GPLv2.

 Run for 1M instructions */

 Tolerate a difference below 0.0001 % */

 Count how many instructions it takes to do a null loop */

 The STCX_FAIL event we use works on Power8 or later

 Run for 1Mi instructions */

 Run for 10Mi instructions */

 Run for 100Mi instructions */

 Run for 1Bi instructions */

 Run for 16Bi instructions */

 Run for 64Bi instructions */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2013, Michael Ellerman, IBM Corp.

 This has to match the structure layout in the header */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2014, Michael Ellerman, IBM Corp.

 Ought to be enough .. */

/*

 * Tests that the L3 bank handling is correct. We fixed it in commit e9aaac1.

 The L3 bank logic is only used on Power8 or later

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2014, Michael Ellerman, IBM Corp.

/*

 * Test of counting cycles while manipulating the user accessible bits in MMCR2.

 We use two values because the first freezes PMC1 and so we would get no EBBs */

 (FC1P|FC2P|FC3P|FC4P|FC5P|FC6P) */

 (     FC2P|FC3P|FC4P|FC5P|FC6P) */

 XXX Set of MMCR2 must be after enable */

 Make sure we loop until we take at least one EBB */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2014, Michael Ellerman, IBM Corp.

/*

 * Test that PMC5 & 6 are frozen (ie. don't overflow) when they are not being

 * used. Tests the MMCR0_FC56 logic in the kernel.

 Use PMC2 so we set PMCjCE, which enables PMC5/6 */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2014, Michael Ellerman, IBM Corp.

/*

 * Test that if we overflow the counter while in the EBB handler, we take

 * another EBB on exiting from the handler.

 *

 * We do this by counting with a stupidly low sample period, causing us to

 * overflow the PMU while we're still in the EBB handler, leading to another

 * EBB.

 *

 * We get out of what would otherwise be an infinite loop by leaving the

 * counter frozen once we've taken enough EBBs.

 Resets the PMC */

 Reset but leave counters frozen */

 Unfreezes */

 Do some stuff to chew some cycles and pop the counter */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2014, Michael Ellerman, IBM Corp.

/*

 * Test that the kernel properly handles PMAE across context switches.

 *

 * We test this by calling into the kernel inside our EBB handler, where PMAE

 * is clear. A cpu eater companion thread is running on the same CPU as us to

 * encourage the scheduler to switch us.

 *

 * The kernel must make sure that when it context switches us back in, it

 * honours the fact that we had PMAE clear.

 *

 * Observed to hit the failing case on the first EBB with a broken kernel.

 Try and get ourselves scheduled, to force a PMU context switch */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2021, Athira Rajeev, IBM Corp.

/*

 * Test that closing the EBB event clears MMCR0_PMCC and

 * sets MMCR0_PMCCEXT preventing further read access to the

 * group B PMU registers.

	/*

	 * For ISA v3.1, verify the test takes a SIGILL when reading

	 * PMU regs after the event is closed. With the control bit

	 * in MMCR0 (PMCCEXT) restricting access to group B PMU regs,

	 * sigill is expected.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2014, Michael Ellerman, IBM Corp.

/*

 * Test that a fork clears the PMU state of the child. eg. BESCR/EBBHR/EBBRR

 * are cleared, and MMCR0_PMCC is reset, preventing the child from accessing

 * the PMU.

 Even though we have EBE=0 we can still see the EBB regs */

 We can still read from the event, though it is on our parent */

 Tests that fork clears EBB state */

 Don't need to actually take any EBBs */

 Child does the actual testing */

 After fork */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2014, Michael Ellerman, IBM Corp.

/*

 * Test that closing the EBB event clears MMCR0_PMCC, preventing further access

 * by userspace to the PMU hardware.

	/* The real test is here, do we take a SIGILL when writing PMU regs now

 We should still be able to read EBB regs though */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2014, Michael Ellerman, IBM Corp.

/*

 * Basic test that counts user cycles and takes EBBs.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2014, Michael Ellerman, IBM Corp.

/*

 * Tests a per-task event vs an EBB - in that order. The EBB should push the

 * per-task event off the PMU.

 NB order of pipes looks reversed */

 We setup the task event first */

 Signal the child to install its EBB event and wait */

 If it fails, wait for it to exit */

 Signal the child to run */

 The EBB event should push the task event off so the child should succeed */

 The task event may have run, or not so we can't assert anything about it */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2014, Michael Ellerman, IBM Corp.

/*

 * Run a calibrated instruction loop and count instructions executed using

 * EBBs. Make sure the counts look right.

 Tolerate a difference of up to 0.0001 % */

 Count how many instructions it takes to do a null loop */

 Run for 1M instructions */

 Run for 10M instructions */

 Run for 100M instructions */

 Run for 1G instructions */

 Run for 16G instructions */

 Run for 64G instructions */

 Run for 128G instructions */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2014, Michael Ellerman, IBM Corp.

/*

 * Test basic access to the EBB regs, they should be user accessible with no

 * kernel interaction required.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2014, Michael Ellerman, IBM Corp.

/*

 * Test of counting cycles while using MMCR0_FC (freeze counters) to only count

 * parts of the code. This is complicated by the fact that FC is set by the

 * hardware when the event overflows. We may take the EBB after we have set FC,

 * so we have to be careful about whether we clear FC at the end of the EBB

 * handler or not.

 Make sure we loop until we take at least one EBB */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2014, Michael Ellerman, IBM Corp.

/*

 * Tests an EBB vs a cpu event - in that order. The EBB should force the cpu

 * event off the PMU.

 NB order of pipes looks reversed */

 Signal the child to install its EBB event and wait */

 Now try to install our CPU event */

 Signal the child to run */

 .. and wait for it to complete */

 The cpu event may have run, but we don't expect 100% */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2014, Michael Ellerman, IBM Corp.

/*

 * Tests a pinned cpu event vs an EBB - in that order. The pinned cpu event

 * should remain and the EBB event should fail to enable.

 NB order of pipes looks reversed */

 We setup the cpu event first */

 Signal the child to install its EBB event and wait */

 If it fails, wait for it to exit */

 Signal the child to run */

 We expect it to fail to read the event */

 The cpu event should have run */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2014, Michael Ellerman, IBM Corp.

/*

 * Test that tries to trigger CPU_FTR_PMAO_BUG. Which is a hardware defect

 * where an exception triggers but we context switch before it is delivered and

 * lose the exception.

 We use PMC4 to make sure the kernel switches all counters correctly */

	/*

	 * We want a low sample period, but we also want to get out of the EBB

	 * handler without tripping up again.

	 *

	 * This value picked after much experimentation.

		/*

		 * We are trying to get the EBB exception to race exactly with

		 * us entering the kernel to do the syscall. We then need the

		 * kernel to decide our timeslice is up and context switch to

		 * the other thread. When we come back our EBB will have been

		 * lost and we'll spin in this while loop forever.

 Change the sample period slightly to try and hit the race */

 We vary our sample period so we need extra fudge here */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2014, Michael Ellerman, IBM Corp.

/*

 * Test counting multiple events using EBBs.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2014, Michael Ellerman, IBM Corp.

 For CPU_ZERO etc. */

 2) clear MMCR0[PMAO] - docs say BESCR[PMEO] should do this */

 3) set MMCR0[PMAE]	- docs say BESCR[PME] should do this */

 4) clear BESCR[PMEO] */

 5) set BESCR[PME] */

 6) rfebb 1 - done in our caller */

 Called outside of the EBB handler to check MMCR0 is sane */

 It's OK if we see FC & PMAO, but not FC by itself */

 Ensure ebb_user_func is set before we set the handler */

 Make sure the handler is set before we return */

 0) Read PMC */

 1) Reset PMC */

 Report if we overflowed */

 Ensure any SPR writes are ordered vs us */

 Ditto */

 Unfreeze counters */

 Enable EBBs globally and PMU EBBs */

 Disable EBBs & freeze counters, events are still scheduled */

 EBB requires at least POWER8 */

		/*

		 * Some tests expect to fail here, so don't report an error on

		 * this line, and return a distinguisable error code. Tell the

		 * parent an error happened.

 To try and hit SIGILL case */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2014, Michael Ellerman, IBM Corp.

/*

 * Tests a cpu event vs an EBB - in that order. The EBB should force the cpu

 * event off the PMU.

 NB order of pipes looks reversed */

 We setup the cpu event first */

 Signal the child to install its EBB event and wait */

 If it fails, wait for it to exit */

 Signal the child to run */

 We expect the child to succeed */

 The cpu event may have run */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2014, Michael Ellerman, IBM Corp.

/*

 * Test various attributes of the EBB event are enforced.

 Expected to succeed */

 CYCLES - no PMC specified */

 Expected to fail, no PMC specified */

 Expected to fail, not exclusive */

 Expected to fail, sets freq */

 Expected to fail, sets sample_period */

 Expected to fail, sets enable_on_exec */

 Expected to fail, sets inherit */

 Expected to succeed */

 Expected to fail, event doesn't request EBB, leader does */

 Clear the EBB flag */

 Expected to fail, leader doesn't request EBB */

 Expected to fail, leader isn't exclusive */

 Expected to fail, leader isn't pinned */

 Expected to fail, not a task event */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2014, Michael Ellerman, IBM Corp.

/*

 * Tests we can setup an EBB on our child. The child expects this and enables

 * EBBs, which are then delivered to the child, even though the event is

 * created by the parent.

 Setup our EBB handler, before the EBB event is created */

 Tests we can setup an EBB on our child - if it's expecting it */

 NB order of pipes looks reversed */

 Signal the child to setup its EBB handler */

 Child is running now */

 Child show now take EBBs and then exit */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2014, Michael Ellerman, IBM Corp.

/*

 * Tests a pinned per-task event vs an EBB - in that order. The pinned per-task

 * event should prevent the EBB event from being enabled.

 NB order of pipes looks reversed */

 We setup the task event first */

 Signal the child to install its EBB event and wait */

 If it fails, wait for it to exit */

 Signal the child to run */

 We expect it to fail to read the event */

	/*

	 * For reasons I don't understand enabled is usually just slightly

	 * lower than running. Would be good to confirm why.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2014, Michael Ellerman, IBM Corp.

/*

 * Tests we can setup an EBB on our child. Nothing interesting happens, because

 * even though the event is enabled and running the child hasn't enabled the

 * actual delivery of the EBBs.

 Parent creates EBB event */

 Check the EBB is enabled by writing PMC1 */

 EBB event is enabled here */

 NB order of pipes looks reversed */

 Child is running now */

 Child should just exit happily */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2014, Michael Ellerman, IBM Corp.

 Test that things work sanely if we have no handler */

 Make sure it overflows quickly */

 Spin to make sure the event has time to overflow */

 We expect to see the PMU frozen & PMAO set */

 The real test is that we never took an EBB at 0x0 */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2014, Michael Ellerman, IBM Corp.

/*

 * Test running multiple EBB using processes at once on a single CPU. They

 * should all run happily without interfering with each other.

 Have them all run for "a while" */

 Tell them to stop */

 And wait */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2014, Michael Ellerman, IBM Corp.

	/*

	 * If we ever overflowed don't allow any more input. This prevents us

	 * from dropping a large item and then later logging a small one. The

	 * buffer should just stop when overflow happened, not be patchy. If

	 * you're overflowing, make your buffer bigger.

 We NULL terminate to make printing easier */

 SPDX-License-Identifier: GPL-2.0

 test all offsets and lengths */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copied from linux/lib/string.c

 *

 *  Copyright (C) 1991, 1992  Linus Torvalds

/**

 * strlen - Find the length of a string

 * @s: The string to be sized

 nothing */;

 SPDX-License-Identifier: GPL-2.0

 This is big enough to fit LARGE_SIZE and works on 4K & 64K kernels */

 test all offsets and lengths */

 Trick to compare sign */

 check for zero */

 Put s1/s2 at the end of a page */

 And unmap the subsequent page to force a fault if we overread */

 change one byte */

 change multiple bytes, 1/8 of total */

 vcmpequd used in memcmp_64.S is v2.07

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2016, Chris Smart, IBM Corporation.

 *

 * Calls to copy_first which are not 128-byte aligned should be

 * caught and sent a SIGBUS.

	/*

	 * Check that the signal was on the correct instruction, using a

	 * mask because the compiler assigns the register at RB.

 We hit the right instruction */

 Only run this test on a P9 or later */

 Register our signal handler with SIGBUS */

 +1 makes buf unaligned */

 We should not get here */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Test the powerpc alignment handler on POWER8/POWER9

 *

 * Copyright (C) 2017 IBM Corporation (Michael Neuling, Andrew Donnellan)

/*

 * This selftest exercises the powerpc alignment fault handler.

 *

 * We create two sets of source and destination buffers, one in regular memory,

 * the other cache-inhibited (by default we use /dev/fb0 for this, but an

 * alterative path for cache-inhibited memory may be provided, e.g. memtrace).

 *

 * We initialise the source buffers, then use whichever set of load/store

 * instructions is under test to copy bytes from the source buffers to the

 * destination buffers. For the regular buffers, these instructions will

 * execute normally. For the cache-inhibited buffers, these instructions

 * will trap and cause an alignment fault, and the alignment fault handler

 * will emulate the particular instruction under test. We then compare the

 * destination buffers to ensure that the native and emulated cases give the

 * same result.

 *

 * TODO:

 *   - Any FIXMEs below

 *   - Test VSX regs < 32 and > 32

 *   - Test all loads and stores

 *   - Check update forms do update register

 *   - Test alignment faults over page boundary

 *

 * Some old binutils may not support all the instructions.

 FIXME: Unimplemented tests: */

 STORE_DFORM_TEST(stq)   /* FIXME: need two registers for quad */

 STORE_DFORM_TEST(stswi) /* FIXME: string instruction */

 STORE_XFORM_TEST(stwat) /* AMO can't emulate or run on CI */

 STORE_XFORM_TEST(stdat) /* ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ */

 preload byte by byte */

 run the actual test */

/*

 * Do two memcpy tests using the same instructions. One cachable

 * memory and the other doesn't.

	/*

	 * offset = 0 is aligned but tests the workaround for the P9N

	 * DD2.1 vector CI load issue (see 5080332c2c89 "powerpc/64s:

	 * Add workaround for P9 vector CI load issue")

 vsx == 16 bytes */

 load pattern into memory byte by byte */

 FIXME: remove??

 initialise output to the same */

 sanity check */

	/*

	 * FIXME: These loads only load part of the register, so our

	 * testing method doesn't work. Also they don't take alignment

	 * faults, so it's kinda pointless anyway

	 *

	 LOAD_VMX_XFORM_TEST(lvebx)

	 LOAD_VMX_XFORM_TEST(lvehx)

	 LOAD_VMX_XFORM_TEST(lvewx)

	 LOAD_VMX_XFORM_TEST(lvxl)

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2015, Michael Neuling, IBM Corp.

 *

 * Test the kernel's signal delievery code to ensure that we don't

 * trelaim twice in the kernel signal delivery code.  This can happen

 * if we trigger a signal when in a transaction and the stack pointer

 * is bogus.

 *

 * This test case registers a SEGV handler, sets the stack pointer

 * (r1) to NULL, starts a transaction and then generates a SEGV.  The

 * SEGV should be handled but we exit here as the stack pointer is

 * invalid and hance we can't sigreturn.  We only need to check that

 * this flow doesn't crash the kernel.

 This should never actually run since stack is foobar */

 Parent */

		/*

		 * It's likely the whole machine will crash here so if

		 * the child ever exits, we are good.

	/*

	 * The flow here is:

	 * 1) register a signal handler (so signal delievery occurs)

	 * 2) make stack pointer (r1) = NULL

	 * 3) start transaction

	 * 4) cause segv

 stack ptr == NULL */

 retry forever */

 trigger segv" */

 This should never get here due to above segv */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2017, Michael Neuling, IBM Corp.

 * Original: Breno Leitao <brenohl@br.ibm.com> &

 *           Gustavo Bueno Romero <gromero@br.ibm.com>

 * Edited: Michael Neuling

 *

 * Force VMX unavailable during a transaction and see if it corrupts

 * the checkpointed VMX register state after the abort.

 Stick non-zero value in VMX0 */

 Wait here a bit so we get scheduled out 255 times */

 Kernel will hopefully turn VMX off now */

 Cause VMX unavail. Any VMX instruction */

 Check VMX0 sanity after abort */

 HTM aborted and VMX0 is corrupted */

 HTM aborted but VMX0 is correct */

	printf("!");

	printf(".");

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2016, Cyril Bur, IBM Corp.

 *

 * Test the kernel's signal frame code.

 *

 * The kernel sets up two sets of ucontexts if the signal was to be

 * delivered while the thread was in a transaction (referred too as

 * first and second contexts).

 * Expected behaviour is that the checkpointed state is in the user

 * context passed to the signal handler (first context). The speculated

 * state can be accessed with the uc_link pointer (second context).

 *

 * The rationale for this is that if TM unaware code (which linked

 * against TM libs) installs a signal handler it will not know of the

 * speculative nature of the 'live' registers and may infer the wrong

 * thing.

 Number of non-volatile FP registers */

 First non-volatile FP register to check in f14-31 subset */

 Test only non-volatile registers, i.e. 18 fpr registers from f14 to f31 */

 First context will be set with these values, i.e. non-speculative */

 Second context will be set with these values, i.e. speculative */

 Check first context. Print all mismatches. */

 Check second context. Print all mismatches. */

		/*

		 * tm_signal_self_context_load will set both first and second

		 * contexts accordingly to the values passed through non-NULL

		 * array pointers to it, in that case 'fps', and invoke the

		 * signal handler installed for SIGUSR1.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright 2018, Breno Leitao, Gustavo Romero, IBM Corp.

 *

 * A test case that creates a signal and starts a suspended transaction

 * inside the signal handler.

 *

 * It returns from the signal handler with the CPU at suspended state, but

 * without setting usercontext MSR Transaction State (TS) fields.

 Skip 'trap' instruction if it succeed */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2016, Cyril Bur, IBM Corp.

 *

 * Test the kernel's signal frame code.

 *

 * The kernel sets up two sets of ucontexts if the signal was to be

 * delivered while the thread was in a transaction (referred too as

 * first and second contexts).

 * Expected behaviour is that the checkpointed state is in the user

 * context passed to the signal handler (first context). The speculated

 * state can be accessed with the uc_link pointer (second context).

 *

 * The rationale for this is that if TM unaware code (which linked

 * against TM libs) installs a signal handler it will not know of the

 * speculative nature of the 'live' registers and may infer the wrong

 * thing.

 Number of VSX registers to check. */

 First VSX register to check in vsr20-vsr31 subset */

 FPR20 overlaps VSX20 most significant doubleword */

 Test only 12 vsx registers from vsr20 to vsr31 */

 First context will be set with these values, i.e. non-speculative */

 VSX20     ,  VSX21      , ... */

 Second context will be set with these values, i.e. speculative */

 VSX20         ,  VSX21          , ... */

	/*

	 * FP registers and VMX registers overlap the VSX registers.

	 *

	 * FP registers (f0-31) overlap the most significant 64 bits of VSX

	 * registers vsr0-31, whilst VMX registers vr0-31, being 128-bit like

	 * the VSX registers, overlap fully the other half of VSX registers,

	 * i.e. vr0-31 overlaps fully vsr32-63.

	 *

	 * Due to compatibility and historical reasons (VMX/Altivec support

	 * appeared first on the architecture), VMX registers vr0-31 (so VSX

	 * half vsr32-63 too) are stored right after the v_regs pointer, in an

	 * area allocated for 'vmx_reverse' array (please see

	 * arch/powerpc/include/uapi/asm/sigcontext.h for details about the

	 * mcontext_t structure on Power).

	 *

	 * The other VSX half (vsr0-31) is hence stored below vr0-31/vsr32-63

	 * registers, but only the least significant 64 bits of vsr0-31. The

	 * most significant 64 bits of vsr0-31 (f0-31), as it overlaps the FP

	 * registers, is kept in fp_regs.

	 *

	 * v_regs is a 16 byte aligned pointer at the start of vmx_reserve

	 * (vmx_reserve may or may not be 16 aligned) where the v_regs structure

	 * exists, so v_regs points to where vr0-31 / vsr32-63 registers are

	 * fully stored. Since v_regs type is elf_vrregset_t, v_regs + 1

	 * skips all the slots used to store vr0-31 / vsr32-64 and points to

	 * part of one VSX half, i.e. v_regs + 1 points to the least significant

	 * 64 bits of vsr0-31. The other part of this half (the most significant

	 * part of vsr0-31) is stored in fp_regs.

	 *

 Get pointer to least significant doubleword of vsr0-31 */

 Check first context. Print all mismatches. */

		/*

		 * Copy VSX most significant doubleword from fp_regs and

		 * copy VSX least significant one from 64-bit slots below

		 * saved VMX registers.

 Check second context. Print all mismatches. */

		/*

		 * Copy VSX most significant doubleword from fp_regs and

		 * copy VSX least significant one from 64-bit slots below

		 * saved VMX registers.

               /*

                * tm_signal_self_context_load will set both first and second

                * contexts accordingly to the values passed through non-NULL

                * array pointers to it, in that case 'vsxs', and invoke the

                * signal handler installed for SIGUSR1.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2017, Gustavo Romero, IBM Corp.

 *

 * Check if thread endianness is flipped inadvertently to BE on trap

 * caught in TM whilst MSR.FP and MSR.VEC are zero (i.e. just after

 * load_fp and load_vec overflowed).

 *

 * The issue can be checked on LE machines simply by zeroing load_fp

 * and load_vec and then causing a trap in TM. Since the endianness

 * changes to BE on return from the signal handler, 'nop' is

 * thread as an illegal instruction in following sequence:

 *	tbegin.

 *	beq 1f

 *	trap

 *	tend.

 * 1:	nop

 *

 * However, although the issue is also present on BE machines, it's a

 * bit trickier to check it on BE machines because MSR.LE bit is set

 * to zero which determines a BE endianness that is the native

 * endianness on BE machines, so nothing notably critical happens,

 * i.e. no illegal instruction is observed immediately after returning

 * from the signal handler (as it happens on LE machines). Thus to test

 * it on BE machines LE endianness is forced after a first trap and then

 * the endianness is verified on subsequent traps to determine if the

 * endianness "flipped back" to the native endianness (BE).

 Get thread endianness: extract bit LE from MSR */

	/*

	 * Little-Endian Machine

 First trap event */

			/* Do nothing. Since it is returning from this trap

			 * event that endianness is flipped by the bug, so just

			 * let the process return from the signal handler and

			 * check on the second trap event if endianness is

			 * flipped or not.

 Second trap event */

			/*

			 * Since trap was caught in TM on first trap event, if

			 * endianness was still LE (not flipped inadvertently)

			 * after returning from the signal handler instruction

			 * (1) is executed (basically a 'nop'), as it's located

			 * at address of tbegin. +4 (rollback addr). As (1) on

			 * LE endianness does in effect nothing, instruction (2)

			 * is then executed again as 'trap', generating a second

			 * trap event (note that in that case 'trap' is caught

			 * not in transacional mode). On te other hand, if after

			 * the return from the signal handler the endianness in-

			 * advertently flipped, instruction (1) is tread as a

			 * branch instruction, i.e. b .+8, hence instruction (3)

			 * and (4) are executed (tbegin.; trap;) and we get sim-

			 * ilaly on the trap signal handler, but now in TM mode.

			 * Either way, it's now possible to check the MSR LE bit

			 * once in the trap handler to verify if endianness was

			 * flipped or not after the return from the second trap

			 * event. If endianness is flipped, the bug is present.

			 * Finally, getting a trap in TM mode or not is just

			 * worth noting because it affects the math to determine

			 * the offset added to the NIP on return: the NIP for a

			 * trap caught in TM is the rollback address, i.e. the

			 * next instruction after 'tbegin.', whilst the NIP for

			 * a trap caught in non-transactional mode is the very

			 * same address of the 'trap' instruction that generated

			 * the trap event.

 Go to 'success', i.e. instruction (6) */

				/*

				 * Thread endianness is BE, so it flipped

				 * inadvertently. Thus we flip back to LE and

				 * set NIP to go to 'failure', instruction (5).

	/*

	 * Big-Endian Machine

 First trap event */

			/*

			 * Force thread endianness to be LE. Instructions (1),

			 * (3), and (4) will be executed, generating a second

			 * trap in TM mode.

 Second trap event */

			/*

			 * Do nothing. If bug is present on return from this

			 * second trap event endianness will flip back "automat-

			 * ically" to BE, otherwise thread endianness will

			 * continue to be LE, just as it was set above.

 A third trap event */

			/*

			 * Once here it means that after returning from the sec-

			 * ond trap event instruction (4) (trap) was executed

			 * as LE, generating a third trap event. In that case

			 * endianness is still LE as set on return from the

			 * first trap event, hence no bug. Otherwise, bug

			 * flipped back to BE on return from the second trap

			 * event and instruction (4) was executed as 'tdi' (so

			 * basically a 'nop') and branch to 'failure' in

			 * instruction (5) was taken to indicate failure and we

			 * never get here.

			/*

			 * Flip back to BE and go to instruction (6), i.e. go to

			 * 'success'.

 Got a USR1 signal from ping(), so just tell pong() to exit */

	/*

	 * Wait an amount of context switches so load_fp and load_vec overflows

	 * and MSR_[FP|VEC|V] is 0.

		/*

		 * [NA] means "Native Endianness", i.e. it tells how a

		 * instruction is executed on machine's native endianness (in

		 * other words, native endianness matches kernel endianness).

		 * [OP] means "Opposite Endianness", i.e. on a BE machine, it

		 * tells how a instruction is executed as a LE instruction; con-

		 * versely, on a LE machine, it tells how a instruction is

		 * executed as a BE instruction. When [NA] is omitted, it means

		 * that the native interpretation of a given instruction is not

		 * relevant for the test. Likewise when [OP] is omitted.

 (0) tbegin. [NA]                    */

 (1) nop     [NA]; b (3) [OP]        */

 (2) trap    [NA]                    */

 (3) tbegin. [OP]                    */

 (4) trap    [OP]; nop   [NA]        */

 (5) b [NA]; MSR.LE flipped (bug)    */

 (6) b [NA]; MSR.LE did not flip (ok)*/

 Tell pong() to exit before leaving */

		/*

		 * Induce context switches on ping() thread

		 * until ping() finishes its job and signs

		 * to exit from this loop.

 Set only one CPU in the mask. Both threads will be bound to that CPU.

 Init pthread attribute */

	/*

	 * Bind thread ping() and pong() both to CPU 0 so they ping-pong and

	 * speed up context switches on ping() thread, speeding up the load_fp

	 * and load_vec overflow.

 Figure out the machine endianness */

 Launch ping() */

 Launch pong() */

 no, endianness did not flip inadvertently */

 yes, endianness did flip inadvertently */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright 2020, Gustavo Luiz Duarte, IBM Corp.

 *

 * This test starts a transaction and triggers a signal, forcing a pagefault to

 * happen when the kernel signal handling code touches the user signal stack.

 *

 * In order to avoid pre-faulting the signal stack memory and to force the

 * pagefault to happen precisely in the kernel signal handling code, the

 * pagefault handling is done in userspace using the userfaultfd facility.

 *

 * Further pagefaults are triggered by crafting the signal handler's ucontext

 * to point to additional memory regions managed by the userfaultfd, so using

 * the same mechanism used to avoid pre-faulting the signal stack memory.

 *

 * On failure (bug is present) kernel crashes or never returns control back to

 * userspace. If bug is not present, tests completes almost immediately.

 10 x 64k pages */

 Memory handled by userfaultfd */

/*

 * Data that will be copied into the faulting pages (instead of zero-filled

 * pages). This is used to make the test more reliable and avoid segfaulting

 * when we return from the signal handler. Since we are making the signal

 * handler's ucontext point to newly allocated memory, when that memory is

 * paged-in it will contain the expected content.

/*

 * Return a chunk of at least 'size' bytes of memory that will be handled by

 * userfaultfd. If 'backing_data' is not NULL, its content will be save to

 * 'backing_mem' and then copied into the faulting pages when the page fault

 * is handled.

 Save the data that will be copied into the faulting page */

 Reserve the requested amount of uf_mem */

 Keep uf_mem_offset aligned to the page size (round up) */

 Data read from userfaultfd */

 userfaultfd file descriptor */

 We expect only one kind of event */

		/*

		 * We need to handle page faults in units of pages(!).

		 * So, round faulting address down to page boundary.

 userfaultfd file descriptor */

 Create and enable userfaultfd object */

	/*

	 * Create a private anonymous mapping. The memory will be demand-zero

	 * paged, that is, not yet allocated. When we actually touch the memory

	 * the related page will be allocated via the userfaultfd mechanism.

	/*

	 * Register the memory range of the mapping we've just mapped to be

	 * handled by the userfaultfd object. In 'mode' we request to track

	 * missing pages (i.e. pages that have not yet been faulted-in).

 Create a thread that will process the userfaultfd events */

/*

 * Assumption: the signal was delivered while userspace was in transactional or

 * suspended state, i.e. uc->uc_link != NULL.

 Skip 'trap' after returning, otherwise we get a SIGTRAP again */

	/*

	 * Set an alternative stack that will generate a page fault when the

	 * signal is raised. The page fault will be treated via userfaultfd,

	 * i.e. via fault_handler_thread.

 Trigger a SIGTRAP in transactional state */

 Trigger a SIGTRAP in suspended state */

	/*

	 * Depending on kernel config, the TM Bad Thing might not result in a

	 * crash, instead the kernel never returns control back to userspace, so

	 * set a tight timeout. If the test passes it completes almost

	 * immediately.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright 2015, Laurent Dufour, IBM Corp.

 *

 * Test the kernel's signal returning code to check reclaim is done if the

 * sigreturn() is called while in a transaction (suspended since active is

 * already dropped trough the system call path).

 *

 * The kernel must discard the transaction when entering sigreturn, since

 * restoring the potential TM SPRS from the signal frame is requiring to not be

 * in a transaction.

	/*

	 * We return from the signal handle while in a suspended transaction

 trigger SEGV */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2015, Michael Neuling, IBM Corp.

 *

 * Original: Michael Neuling 3/4/2014

 * Modified: Rashmica Gupta 8/12/2015

 *

 * Check if any of the Transaction Memory SPRs get corrupted.

 * - TFIAR  - stores address of location of transaction failure

 * - TFHAR  - stores address of software failure handler (if transaction

 *   fails)

 * - TEXASR - lots of info about the transacion(s)

 *

 * (1) create more threads than cpus

 * (2) in each thread:

 * 	(a) set TFIAR and TFHAR a unique value

 * 	(b) loop for awhile, continually checking to see if

 * 	either register has been corrupted.

 *

 * (3) Loop:

 * 	(a) begin transaction

 *    	(b) abort transaction

 *	(c) check TEXASR to see if FS has been corrupted

 TFIAR: Last bit has to be high so userspace can read register */

 TFHAR: Last two bits are reserved */

 Abort handler */

 Check the TEXASR */

 To cause some context switching */

 Test TFIAR and TFHAR */

 Test TEXASR */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2019, Gustavo Romero, Michael Neuling, IBM Corp.

 *

 * This test will spawn two processes. Both will be attached to the same

 * CPU (CPU 0). The child will be in a loop writing to FP register f31 and

 * VMX/VEC/Altivec register vr31 a known value, called poison, calling

 * sched_yield syscall after to allow the parent to switch on the CPU.

 * Parent will set f31 and vr31 to 1 and in a loop will check if f31 and

 * vr31 remain 1 as expected until a given timeout (2m). If the issue is

 * present child's poison will leak into parent's f31 or vr31 registers,

 * otherwise, poison will never leak into parent's f31 and vr31 registers.

 Attach both Child and Parent to the same CPU

		/**

		 * child

 f31 = poison

 vr31 = poison

	/**

	 * parent

		/*

		 * Set r3, r4, and f31 to known value 1 before entering

		 * in transaction. They won't be written after that.

		/*

		 * The Time Base (TB) is a 64-bit counter register that is

		 * independent of the CPU clock and which is incremented

		 * at a frequency of 512000000 Hz, so every 1.953125ns.

		 * So it's necessary 120s/0.000000001953125s = 61440000000

		 * increments to get a 2 minutes timeout. Below we set that

		 * value in r5 and then use r6 to track initial TB value,

		 * updating TB values in r7 at every iteration and comparing it

		 * to r6. When r7 (current) - r6 (initial) > 61440000000 we bail

		 * out since for sure we spent already 2 minutes in the loop.

		 * SPR 268 is the TB register.

 r5 = 61440000000

 r6 (TB initial)

 r7 (TB current)

 r7 - r6 > 61440000000 ?

 yes, exit

		/*

		 * Main loop to check f31

 no, try again

 restart if no timeout

 read f31

 f31 == 1 ?

 broken :-(

 try another transaction

 commit transaction

 record r3

	/*

	 * On leak 'unknown' will contain 'poison' value from child,

	 * otherwise (no leak) 'unknown' will contain the same value

	 * as r3 before entering in transactional mode, i.e. 0x1.

		/*

		 * Set r3, r4, and vr31 to known value 1 before entering

		 * in transaction. They won't be written after that.

 r5 = 61440000000

 r6 (TB initial)

 r7 (TB current)

 r7 - r6 > 61440000000 ?

 yes, exit

		/*

		 * Main loop to check vr31

 no, try again

 restart if no timeout

 read vr31

 vr31 == 1 ?

 broken :-(

 try another transaction

 commit transaction

 record r3

	/*

	 * On leak 'unknown' will contain 'poison' value from child,

	 * otherwise (no leak) 'unknown' will contain the same value

	 * as r3 before entering in transactional mode, i.e. 0x1.

 Test completes in about 4m */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2016, Cyril Bur, IBM Corp.

 *

 * Test the kernel's signal frame code.

 *

 * The kernel sets up two sets of ucontexts if the signal was to be

 * delivered while the thread was in a transaction (referred too as

 * first and second contexts).

 * Expected behaviour is that the checkpointed state is in the user

 * context passed to the signal handler (first context). The speculated

 * state can be accessed with the uc_link pointer (second context).

 *

 * The rationale for this is that if TM unaware code (which linked

 * against TM libs) installs a signal handler it will not know of the

 * speculative nature of the 'live' registers and may infer the wrong

 * thing.

 Number of non-volatile GPR registers */

 First non-volatile register to check in r14-r31 subset */

 Test only non-volatile general purpose registers, i.e. r14-r31 */

 First context will be set with these values, i.e. non-speculative */

 R14, R15, ... */

 Second context will be set with these values, i.e. speculative */

 R14, R15, ... */

 Check first context. Print all mismatches. */

 Check second context. Print all mismatches. */

                /*

                 * tm_signal_self_context_load will set both first and second

                 * contexts accordingly to the values passed through non-NULL

                 * array pointers to it, in that case 'gprs', and invoke the

                 * signal handler installed for SIGUSR1.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2015, Michael Neuling, IBM Corp.

 *

 * Edited: Rashmica Gupta, Nov 2015

 *

 * This test does a fork syscall inside a transaction. Basic sniff test

 * to see if we can enter the kernel during a transaction.

 fork syscall */

	/* If we reach here, we've passed.  Otherwise we've probably crashed

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2016, Cyril Bur, IBM Corp.

 *

 * Syscalls can be performed provided the transactions are suspended.

 * The exec() class of syscall is unique as a new process is loaded.

 *

 * It makes little sense for after an exec() call for the previously

 * suspended transaction to still exist.

 Shouldn't get here */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2017, Gustavo Romero, Breno Leitao, Cyril Bur, IBM Corp.

 *

 * Force FP, VEC and VSX unavailable exception during transaction in all

 * possible scenarios regarding the MSR.FP and MSR.VEC state, e.g. when FP

 * is enable and VEC is disable, when FP is disable and VEC is enable, and

 * so on. Then we check if the restored state is correctly set for the

 * FP and VEC registers to the previous state we set just before we entered

 * in TM, i.e. we check if it corrupts somehow the recheckpointed FP and

 * VEC/Altivec registers on abortion due to an unavailable exception in TM.

 * N.B. In this test we do not test all the FP/Altivec/VSX registers for

 * corruption, but only for registers vs0 and vs32, which are respectively

 * representatives of FP and VEC/Altivec reg sets.

 Unavailable exceptions to test in HTM */

	/*

	 * If both FP and VEC are touched it does not mean that touching VSX

	 * won't raise an exception. However since FP and VEC state are already

	 * correctly loaded, the transaction is not aborted (i.e.

	 * treclaimed/trecheckpointed) and MSR.VSX is just set as 1, so a TM

	 * failure is not expected also in this case.

 Check if failure occurred whilst in transaction. */

	/*

	 * When failure handling occurs, CR0 is set to 0b1010 (0xa). Otherwise

	 * transaction completes without failure and hence reaches out 'tend.'

	 * that sets CR0 to 0b0100 (0x4).

	/*

	 * Expected values for vs0 and vs32 after a TM failure. They must never

	 * change, otherwise they got corrupted.

 Counter for busy wait */

	/*

	 * Variable to keep a copy of CR register content taken just after we

	 * leave the transactional state.

	/*

	 * Wait a bit so thread can get its name "ping". This is not important

	 * to reproduce the issue but it's nice to have for systemtap debugging.

 Prepare to merge low and high. */

		/*

		 * Adjust VS0 expected value after an TM failure,

		 * i.e. vs0 = 0x5555555555555555555FFFFFFFFFFFFFFFF

		/*

		 * Adjust VS32 expected value after an TM failure,

		 * i.e. vs32 = 0x5555555555555555555FFFFFFFFFFFFFFFF

		/*

		 * Wait an amount of context switches so load_fp and load_vec

		 * overflow and MSR.FP, MSR.VEC, and MSR.VSX become zero (off).

 Decrement CTR branch if CTR non zero. */

		/*

		 * Check if we want to touch FP prior to the test in order

		 * to set MSR.FP = 1 before provoking an unavailable

		 * exception in TM.

		/*

		 * Check if we want to touch VEC prior to the test in order

		 * to set MSR.VEC = 1 before provoking an unavailable

		 * exception in TM.

		/*

		 * Perhaps it would be a better idea to do the

		 * compares outside transactional context and simply

		 * duplicate code.

 Do we do FP Unavailable? */

 Do we do VEC Unavailable? */

		/*

		 * Not FP or VEC, therefore VSX. Ensure this

		 * instruction always generates a VSX Unavailable.

		 * ISA 3.0 is tricky here.

		 * (xxmrghd will on ISA 2.07 and ISA 3.0)

 Give values back to C. */

 Give CR back to C so that it can check what happened. */

	/*

	 * Check if we were expecting a failure and it did not occur by checking

	 * CR0 state just after we leave the transaction. Either way we check if

	 * vs0 or vs32 got corrupted.

 Check if we were not expecting a failure and a it occurred. */

	/*

	 * Check if TM failed due to the cause we were expecting. 0xda is a

	 * TM_CAUSE_FAC_UNAV cause, otherwise it's an unexpected cause, unless

	 * it was caused by a reschedule.

 0x4 is a success and 0xa is a fail. See comment in is_failure(). */

 Check FP (vs0) for the expected value. */

 Check VEC (vs32) for the expected value. */

 Thread to force context switch */

 Wait thread get its name "pong". */

 Classed as an interactive-like thread. */

 Function that creates a thread and launches the "ping" task. */

	/*

	 * Without luck it's possible that the transaction is aborted not due to

	 * the unavailable exception caught in the middle as we expect but also,

	 * for instance, due to a context switch or due to a KVM reschedule (if

	 * it's running on a VM). Thus we try a few times before giving up,

	 * checking if the failure cause is the one we expect.

 Bind to CPU 0, as specified in 'attr'. */

 FP = 0, VEC = 1, VSX = 2 */

 Set only one CPU in the mask. Both threads will be bound to that CPU.

 Init pthread attribute. */

 Set CPU 0 mask into the pthread attribute. */

 Bind to CPU 0 */, tm_una_pong, NULL);

 Name it for systemtap convenience */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2015, Michael Neuling, IBM Corp.

 *

 * Test the kernel's signal return code to ensure that it doesn't

 * crash when both the transactional and suspend MSR bits are set in

 * the signal context.

 *

 * For this test, we send ourselves a SIGUSR1.  In the SIGUSR1 handler

 * we modify the signal context to set both MSR TM S and T bits (which

 * is "reserved" by the PowerISA). When we return from the signal

 * handler (implicit sigreturn), the kernel should detect reserved MSR

 * value and send us with a SIGSEGV.

 Link tm checkpointed context to normal context */

 Set all TM bits so that the context is now invalid */

 Should segv on return becuase of invalid context */

 We shouldn't get here as we exit in the segv handler */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright 2018, Breno Leitao, Gustavo Romero, IBM Corp.

 *

 * This test raises a SIGUSR1 signal, and toggle the MSR[TS]

 * fields at the signal handler. With MSR[TS] being set, the kernel will

 * force a recheckpoint, which may cause a segfault when returning to

 * user space. Since the test needs to re-run, the segfault needs to be

 * caught and handled.

 *

 * In order to continue the test even after a segfault, the context is

 * saved prior to the signal being raised, and it is restored when there is

 * a segmentation fault. This happens for COUNT_MAX times.

 *

 * This test never fails (as returning EXIT_FAILURE). It either succeeds,

 * or crash the kernel (on a buggy kernel).

 Number of interactions */

/*

 * This test only runs on 64 bits system. Unsetting MSR_TS_S to avoid

 * compilation issue on 32 bits system. There is no side effect, since the

 * whole test will be skipped if it is not running on 64 bits system.

 Setting contexts because the test will crash and we want to recover */

 count is changed in the signal handler, so it must be volatile */

	/*

	 * Allocating memory in a signal handler, and never freeing it on

	 * purpose, forcing the heap increase, so, the memory leak is what

	 * we want here.

 Forcing the page to be allocated in a page fault */

 Forcing to enable MSR[TM] */

	/*

	 * A fork inside a signal handler seems to be more efficient than a

	 * fork() prior to the signal being raised.

		/*

		 * Both child and parent will return, but, child returns

		 * with count set so it will exit in the next segfault.

		 * Parent will continue to loop.

	/*

	 * If the change above does not hit the bug, it will cause a

	 * segmentation fault, since the ck structures are NULL.

 Reexecute the test */

	/*

	 * Set initial context. Will get back here from

	 * seg_signal_handler()

 Allocated an alternative signal stack area */

 Force the allocation through a page fault */

		/*

		 * Setting an alternative stack to generate a page fault when

		 * the signal is raised.

 The signal handler will enable MSR_TS */

 If it does not crash, it might segfault, avoid it to retest */

	/*

	 * Skipping if not running on 64 bits system, since I think it is

	 * not possible to set mcontext's [MSR] with TS, due to it being 32

	 * bits.

 SPDX-License-Identifier: GPL-2.0

/* Test context switching to see if the DSCR SPR is correctly preserved

 * when within a transaction.

 *

 * Note: We assume that the DSCR has been left at the default value (0)

 * for all CPUs.

 *

 * Method:

 *

 * Set a value into the DSCR.

 *

 * Start a transaction, and suspend it (*).

 *

 * Hard loop checking to see if the transaction has become doomed.

 *

 * Now that we *may* have been preempted, record the DSCR and TEXASR SPRS.

 *

 * If the abort was because of a context switch, check the DSCR value.

 * Otherwise, try again.

 *

 * (*) If the transaction is not suspended we can't see the problem because

 * the transaction abort handler will restore the DSCR to it's checkpointed

 * value before we regain control.

 set a known value into the DSCR */

 start and suspend a transaction */

 hard loop until the transaction becomes doomed */

 record DSCR and TEXASR */

 make sure the transaction aborted */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2016, Cyril Bur, IBM Corp.

 *

 * Test the kernel's signal frame code.

 *

 * The kernel sets up two sets of ucontexts if the signal was to be

 * delivered while the thread was in a transaction (referred too as

 * first and second contexts).

 * Expected behaviour is that the checkpointed state is in the user

 * context passed to the signal handler (first context). The speculated

 * state can be accessed with the uc_link pointer (second context).

 *

 * The rationale for this is that if TM unaware code (which linked

 * against TM libs) installs a signal handler it will not know of the

 * speculative nature of the 'live' registers and may infer the wrong

 * thing.

 Number of non-volatile VMX registers */

 First non-volatile register to check in vr20-31 subset */

 Test only non-volatile registers, i.e. 12 vmx registers from vr20 to vr31 */

 First context will be set with these values, i.e. non-speculative */

 VMX20     ,  VMX21      , ... */

 Second context will be set with these values, i.e. speculative */

 VMX20        , VMX21            , ... */

 Check first context. Print all mismatches. */

 Print actual value in first context. */

 Print expected value. */

 Check second context. Print all mismatches. */

 Print actual value in second context. */

 Print expected value. */

		/*

		 * tm_signal_self_context_load will set both first and second

		 * contexts accordingly to the values passed through non-NULL

		 * array pointers to it, in that case 'vms', and invoke the

		 * signal handler installed for SIGUSR1.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2015, Sam Bobroff, IBM Corp.

 *

 * Test the kernel's system call code to ensure that a system call

 * made from within an active HTM transaction is aborted with the

 * correct failure code.

 * Conversely, ensure that a system call made from within a

 * suspended transaction can succeed.

 scv syscall */

 seconds */

		/*

		 * Test a syscall within a suspended transaction and verify

		 * that it succeeds.

 Should succeed. */

		/*

		 * Test a syscall within an active transaction and verify that

		 * it fails with the correct failure code.

 Should fail... */

 ...persistently... */

 ...with code syscall. */

 Now do it all again with scv if it is available. */

 Should succeed. */

 Should fail... */

 ...persistently... */

 ...with code syscall. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2015, Michael Neuling, IBM Corp.

 * Original: Michael Neuling 19/7/2013

 * Edited: Rashmica Gupta 01/12/2015

 *

 * Do some transactions, see if the tar is corrupted.

 * If the transaction is aborted, the TAR should be rolled back to the

 * checkpointed value before the transaction began. The value written to

 * TAR in suspended mode should only remain in TAR if the transaction

 * completes.

 tar = 1 */

 Loop lots, to use time */

 Start loop */

 tar = 2 */

 tar = 3 */

 Transaction sucess! TAR should be 3 */

 res = 3|4 = 7

 Abort handler. TAR should be rolled back to 1 */

 res = 1|8 = 9

		/* If result is anything else other than 7 or 9, the tar

 A low number of iterations (eg 100) can cause a false pass */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2015, Michael Neuling, IBM Corp.

 *

 * Original: Michael Neuling 4/12/2013

 * Edited: Rashmica Gupta 4/12/2015

 *

 * See if the altivec state is leaked out of an aborted transaction due to

 * kernel vmx copy loops.

 *

 * When the transaction aborts, VSR values should rollback to the values

 * they held before the transaction commenced. Using VSRs while transaction

 * is suspended should not affect the checkpointed values.

 *

 * (1) write A to a VSR

 * (2) start transaction

 * (3) suspend transaction

 * (4) change the VSR to B

 * (5) trigger kernel vmx copy loop

 * (6) abort transaction

 * (7) check that the VSR value is A

 set 40 to initial value*/

 set 40 to 0 */

 cause kernel vmx copy page */

 Abort handler */

 SPDX-License-Identifier: GPL-2.0

/*

 * Test that loads/stores expand the stack segment, or trigger a SEGV, in

 * various conditions.

 *

 * Based on test code by Tom Lane.

/*

 * Consume stack until the stack pointer is below @target_sp, then do an access

 * (load or store) at offset @delta from either the base of the stack or the

 * current stack pointer.

 We don't really need this, but without it GCC might not

 generate a recursive call above.

 Do something to prevent the stack frame being popped prior to

 our access above.

 We don't expect a non-zero exit that's not a signal

 This is fairly arbitrary but is well below any of the targets below,

 so that the delta between the stack pointer and the target is large.

 We should be able to access anywhere within the rlimit

 But if we go past the rlimit it should fail

 SPDX-License-Identifier: GPL-2.0

 This must match the huge page & THP size */

		/*

		 * Typically the mmap will fail because no huge pages are

		 * allocated on the system. But if there are huge pages

		 * allocated the mmap will succeed. That's fine too, we just

		 * munmap here before continuing.  munmap() length of

		 * MAP_HUGETLB memory must be hugepage aligned.

	/*

	 * Either a user or kernel access is sufficient to trigger the bug.

	 * A kernel access is easier to spot & debug, as it will trigger the

	 * softlockup or RCU stall detectors, and when the system is kicked

	 * into xmon we get a backtrace in the kernel.

	 *

	 * A good option is:

	 *  getcwd(p, SIZE);

	 *

	 * For the purposes of this testcase it's preferable to spin in

	 * userspace, so the harness can kill us if we get stuck. That way we

	 * see a test failure rather than a dead system.

 10,000 because it's a "bunch", and completes reasonably quickly */

 SPDX-License-Identifier: GPL-2.0+



 Copyright 2019, Michael Ellerman, IBM Corp.



 Test that allocating memory beyond the memory limit and then forking is

 handled correctly, ie. the child is able to access the mappings beyond the

 memory limit and the child's writes are not visible to the parent.

 "Should be safe" above 512TB

 Create a mapping at 512TB to allocate an extended_id

 Prevent compiler optimisation

 SPDX-License-Identifier: GPL-2.0+

/*

 * Copyright 2018, Michael Ellerman, IBM Corp.

 *

 * Test that an out-of-bounds branch to counter behaves as expected.

 inputs

 outputs

 we didn't segv? */

 SPDX-License-Identifier: GPL-2.0

/*

 * Test that signal delivery is able to expand the stack segment without

 * triggering a SEGV.

 *

 * Based on test code by Tom Lane.

 Test with used stack from 1MB - 64K to 1MB + 64K

 Increment by 64 to get more coverage of odd sizes

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright 2020, Sandipan Das, IBM Corp.

 *

 * Test if the signal information reports the correct memory protection

 * key upon getting a key access violation fault for a page that was

 * attempted to be protected by two different keys from two competing

 * threads at the same time.

 Check if this fault originated from a pkey access violation */

 Check if this fault originated from the expected address */

 Check if this fault originated from the restrictive pkey */

 Check if too many faults have occurred for the same iteration */

	/*

	 * If the current fault occurred due to lack of execute rights,

	 * reassociate the page with the exec-only pkey since execute

	 * rights cannot be changed directly for the faulting pkey as

	 * IAMR is inaccessible from userspace.

	 *

	 * Otherwise, if the current fault occurred due to lack of

	 * read-write rights, change the AMR permission bits for the

	 * pkey.

	 *

	 * This will let the test continue.

 No read, write and execute restrictions */

 Allocate the permissive pkey */

	/*

	 * Repeatedly try to protect the common region with a permissive

	 * pkey

		/*

		 * Wait until the other thread has finished allocating the

		 * restrictive pkey or until the next iteration has begun

 Try to associate the permissive pkey with the region */

 Free the permissive pkey */

 Allocate the restrictive pkey */

	/*

	 * Repeatedly try to protect the common region with a restrictive

	 * pkey and read, write or execute from it

		/*

		 * Wait until the other thread has finished allocating the

		 * permissive pkey or until the next iteration has begun

 Try to associate the restrictive pkey with the region */

 Choose a random instruction word address from the region */

 Read protection test */

			/*

			 * Read an instruction word from the region and

			 * verify if it has not been overwritten to

			 * something unexpected

 Write protection test */

			/*

			 * Write an instruction word to the region and

			 * verify if the overwrite has succeeded

 Execute protection test */

 Jump to the region and execute instructions */

		/*

		 * Restore the restrictions originally imposed by the

		 * restrictive pkey as the signal handler would have

		 * cleared out the corresponding AMR bits

 Free restrictive pkey */

 Exhaustively allocate all available pkeys */

 Free all allocated pkeys */

 Allocate the region */

	/*

	 * Fill the region with no-ops with a branch at the end

	 * for returning to the caller

 Setup SIGSEGV handler */

	/*

	 * For these tests, the parent process should clear all bits of

	 * AMR and IAMR, i.e. impose no restrictions, for all available

	 * pkeys. This will be the base for the initial AMR and IAMR

	 * values for all the test thread pairs.

	 *

	 * If the AMR and IAMR bits of all available pkeys are cleared

	 * before running the tests and a fault is generated when

	 * attempting to read, write or execute instructions from a

	 * pkey protected region, the pkey responsible for this must be

	 * the one from the protect-and-access thread since the other

	 * one is fully permissive. Despite that, if the pkey reported

	 * by siginfo is not the restrictive pkey, then there must be a

	 * kernel bug.

 Setup barrier for protect and protect-and-access threads */

 Setup and start protect and protect-and-read threads */

 Setup and start protect and protect-and-write threads */

 Setup and start protect and protect-and-execute threads */

 Cleanup */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright 2017 John Sperbeck

 *

 * Test that an access to a mapped but inaccessible area causes a SEGV and

 * reports si_code == SEGV_ACCERR.

	/*

	 * We just need a compiler barrier, but mb() works and has the nice

	 * property of being easy to spot in the disassembly.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright 2019, Nick Piggin, Gautham R. Shenoy, Aneesh Kumar K.V, IBM Corp.

/*

 *

 * Test tlbie/mtpidr race. We have 4 threads doing flush/load/compare/store

 * sequence in a loop. The same threads also rung a context switch task

 * that does sched_yield() in loop.

 *

 * The snapshot thread mark the mmap area PROT_READ in between, make a copy

 * and copy it back to the original area. This helps us to detect if any

 * store continued to happen after we marked the memory PROT_READ.

/*

 * A "rim-sequence" is defined to be the sequence of the following

 * operations performed on a memory word:

 *	1) FLUSH the contents of that word.

 *	2) LOAD the contents of that word.

 *	3) COMPARE the contents of that word with the content that was

 *	           previously stored at that word

 *	4) STORE new content into that word.

 *

 * The threads in this test that perform the rim-sequence are termed

 * as rim_threads.

/*

 * A "corruption" is defined to be the failed COMPARE operation in a

 * rim-sequence.

 *

 * A rim_thread that detects a corruption informs about it to all the

 * other rim_threads, and the mem_snapshot thread.

/*

 * This defines the maximum number of rim_threads in this test.

 *

 * The THREAD_ID_BITS denote the number of bits required

 * to represent the thread_ids [0..MAX_THREADS - 1].

 * We are being a bit paranoid here and set it to 8 bits,

 * though 6 bits suffice.

 *

/*

 * Each rim_thread works on an exclusive "chunk" of size

 * RIM_CHUNK_SIZE.

 *

 * The ith rim_thread works on the ith chunk.

 *

 * The ith chunk begins at

 * map1 + (i * RIM_CHUNK_SIZE)

/*

 * The "word-offset" of a word-aligned address inside a chunk, is

 * defined to be the number of words that precede the address in that

 * chunk.

 *

 * WORD_OFFSET_BITS denote the number of bits required to represent

 * the word-offsets of all the word-aligned addresses of a chunk.

/*

 * A "sweep" is defined to be the sequential execution of the

 * rim-sequence by a rim_thread on its chunk one word at a time,

 * starting from the first word of its chunk and ending with the last

 * word of its chunk.

 *

 * Each sweep of a rim_thread is uniquely identified by a sweep_id.

 * SWEEP_ID_BITS denote the number of bits required to represent

 * the sweep_ids of rim_threads.

 *

 * As to why SWEEP_ID_BITS are computed as a function of THREAD_ID_BITS,

 * WORD_OFFSET_BITS, and WORD_BITS, see the "store-pattern" below.

/*

 * A "store-pattern" is the word-pattern that is stored into a word

 * location in the 4)STORE step of the rim-sequence.

 *

 * In the store-pattern, we shall encode:

 *

 *      - The thread-id of the rim_thread performing the store

 *        (The most significant THREAD_ID_BITS)

 *

 *      - The word-offset of the address into which the store is being

 *        performed (The next WORD_OFFSET_BITS)

 *

 *      - The sweep_id of the current sweep in which the store is

 *        being performed. (The lower SWEEP_ID_BITS)

 *

 * Store Pattern: 32 bits

 * |------------------|--------------------|---------------------------------|

 * |    Thread id     |  Word offset       |         sweep_id                |

 * |------------------|--------------------|---------------------------------|

 *    THREAD_ID_BITS     WORD_OFFSET_BITS          SWEEP_ID_BITS

 *

 * In the store pattern, the (Thread-id + Word-offset) uniquely identify the

 * address to which the store is being performed i.e,

 *    address == map1 +

 *              (Thread-id * RIM_CHUNK_SIZE) + (Word-offset * WORD_SIZE)

 *

 * And the sweep_id in the store pattern identifies the time when the

 * store was performed by the rim_thread.

 *

 * We shall use this property in the 3)COMPARE step of the

 * rim-sequence.

/*

 * Compute the store pattern for a given thread with id @tid, at

 * location @addr in the sweep identified by @sweep_id

 Extract the thread-id from the given store-pattern */

 Extract the word-offset from the given store-pattern */

 Extract the sweep-id from the given store-pattern */

/************************************************************

 *                                                          *

 *          Logging the output of the verification          *

 *                                                          *

/*

 * When a COMPARE step of a rim-sequence fails, the rim_thread informs

 * everyone else via the shared_memory pointed to by

 * corruption_found variable. On seeing this, every thread verifies the

 * content of its chunk as follows.

 *

 * Suppose a thread identified with @tid was about to store (but not

 * yet stored) to @next_store_addr in its current sweep identified

 * @cur_sweep_id. Let @prev_sweep_id indicate the previous sweep_id.

 *

 * This implies that for all the addresses @addr < @next_store_addr,

 * Thread @tid has already performed a store as part of its current

 * sweep. Hence we expect the content of such @addr to be:

 *    |-------------------------------------------------|

 *    | tid   | word_offset(addr) |    cur_sweep_id     |

 *    |-------------------------------------------------|

 *

 * Since Thread @tid is yet to perform stores on address

 * @next_store_addr and above, we expect the content of such an

 * address @addr to be:

 *    |-------------------------------------------------|

 *    | tid   | word_offset(addr) |    prev_sweep_id    |

 *    |-------------------------------------------------|

 *

 * The verifier function @verify_chunk does this verification and logs

 * any anamolies that it finds.

Flush before reading

 haven't reproduced with this setting, it kills random preemption which may be a factor */

/*

 * This function is executed by every rim_thread.

 *

 * This function performs sweeps over the exclusive chunks of the

 * rim_threads executing the rim-sequence one word at a time.

 word access */

	/*

	 * Let us initialize the chunk:

	 *

	 * Each word-aligned address addr in the chunk,

	 * is initialized to :

	 *    |-------------------------------------------------|

	 *    | tid   | word_offset(addr) |         0           |

	 *    |-------------------------------------------------|

			/*

			 * Compute the pattern that we would have

			 * stored at this location in the previous

			 * sweep.

			/*

			 * FLUSH:Ensure that we flush the contents of

			 *       the cache before loading

Flush

 LOAD: Read the value */

Load

			/*

			 * COMPARE: Is it the same as what we had stored

			 *          in the previous sweep ? It better be!

 No it isn't! Tell everyone */

			/*

			 * Before performing a store, let us check if

			 * any rim_thread has found a corruption.

				/*

				 * Yes. Someone (including us!) has found

				 * a corruption :(

				 *

				 * Let us verify that our chunk is

				 * correct.

 But first, let us allow the dust to settle down! */

			/*

			 * Compute the new pattern that we are going

			 * to write to this location

			/*

			 * STORE: Now let us write this pattern into

			 *        the location

 Stop memory migration once corruption is found */

		/*

		 * Load from the working alias (map1). Loading from map2

		 * also fails.

		/*

		 * Stores must go via map2 which has write permissions, but

		 * the corrupted data tends to be seen in the snapshot buffer,

		 * so corruption does not appear to be introduced at the

		 * copy-back via map2 alias here.

		/*

		 * Before releasing other threads, must ensure the copy

		 * back to

 This value makes a big difference */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2016, Michael Ellerman, IBM Corp.

	/*

	 * SAO was introduced in 2.06 and removed in 3.1. It's disabled in

	 * guests/LPARs by default, so also skip if we are running in a guest.

	/*

	 * Ensure we can ask for PROT_SAO.

	 * We can't really verify that it does the right thing, but at least we

	 * confirm the kernel will accept it.

 Write to the mapping, to at least cause a fault */

 SPDX-License-Identifier: GPL-2.0+

/*

 * Copyright 2020, Sandipan Das, IBM Corp.

 *

 * Test if applying execute protection on pages using memory

 * protection keys works as expected.

 Check if this fault originated from the expected address */

 Check if this fault originated from the expected address */

 Check if too many faults have occurred for a single test case */

 Restore permissions in order to continue */

			/*

			 * Reassociate the exec-only pkey with the region

			 * to be able to continue. Unlike AMR, we cannot

			 * set IAMR directly from userspace to restore the

			 * permissions.

 Setup SIGSEGV handler */

 Setup SIGTRAP handler */

 Setup executable region */

 Write the instruction words */

	/*

	 * Set the first instruction as an unconditional trap. If

	 * the last write to this address succeeds, this should

	 * get overwritten by a no-op.

	/*

	 * Later, to jump to the executable region, we use a branch

	 * and link instruction (bctrl) which sets the return address

	 * automatically in LR. Use that to return back.

 Allocate a pkey that restricts execution */

	/*

	 * Pick the first instruction's address from the executable

	 * region.

 The following two cases will avoid SEGV_PKUERR */

	/*

	 * Read an instruction word from the address when AMR bits

	 * are not set i.e. the pkey permits both read and write

	 * access.

	 *

	 * This should not generate a fault as having PROT_EXEC

	 * implies PROT_READ on GNU systems. The pkey currently

	 * restricts execution only based on the IAMR bits. The

	 * AMR bits are cleared.

	/*

	 * Write an instruction word to the address when AMR bits

	 * are not set i.e. the pkey permits both read and write

	 * access.

	 *

	 * This should generate an access fault as having just

	 * PROT_EXEC also restricts writes. The pkey currently

	 * restricts execution only based on the IAMR bits. The

	 * AMR bits are cleared.

 The following three cases will generate SEGV_PKUERR */

	/*

	 * Read an instruction word from the address when AMR bits

	 * are set i.e. the pkey permits neither read nor write

	 * access.

	 *

	 * This should generate a pkey fault based on AMR bits only

	 * as having PROT_EXEC implicitly allows reads.

	/*

	 * Write an instruction word to the address when AMR bits

	 * are set i.e. the pkey permits neither read nor write

	 * access.

	 *

	 * This should generate two faults. First, a pkey fault

	 * based on AMR bits and then an access fault since

	 * PROT_EXEC does not allow writes.

 Free the current pkey */

		/*

		 * Allocate pkeys with all valid combinations of read,

		 * write and execute restrictions.

		/*

		 * Jump to the executable region. AMR bits may or may not

		 * be set but they should not affect execution.

		 *

		 * This should generate pkey faults based on IAMR bits which

		 * may be set to restrict execution.

		 *

		 * The first iteration also checks if the overwrite of the

		 * first instruction word from a trap to a no-op succeeded.

 Free the current pkey */

 Find next valid combination of pkey rights */

 Cleanup */

/*

 * Copyright IBM Corp.

 *

 * This program is free software; you can redistribute it and/or modify it

 * under the terms of version 2.1 of the GNU Lesser General Public License

 * as published by the Free Software Foundation.

 *

 * This program is distributed in the hope that it would be useful, but

 * WITHOUT ANY WARRANTY; without even the implied warranty of

 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

 *

	/*

	 * for each page, mark subpage i % 16 read only and subpage

	 * (i + 3) % 16 inaccessible

 SPDX-License-Identifier: GPL-2.0+



 Copyright 2019, Michael Ellerman, IBM Corp.



 Test that out-of-bounds reads/writes behave as expected.

 Old distros (Ubuntu 16.04 at least) don't define this

 64-bit kernel is always here

 If we see MAPERR that means we took a page fault rather than an SLB

 miss. We only expect to take page faults for addresses within the

 valid kernel range.

 We have 7 512T regions (4 kernel linear, vmalloc, io, vmemmap)

 We have 7 64T regions (4 kernel linear, vmalloc, io, vmemmap)

 This generates access patterns like:

   0x0010000000000000

   0x0010000000010000

   0x0010000000020000

   ...

   0x0014000000000000

   0x0018000000000000

   0x0020000000000000

   0x0020000000010000

   0x0020000000020000

   ...

   0xf400000000000000

   0xf800000000000000

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Ptrace test for GPR/FPR registers

 *

 * Copyright (C) 2015 Anshuman Khandual, IBM Corporation.

 Tracer and Tracee Shared Data */

 SPDX-License-Identifier: GPL-2.0+

/*

 * Ptrace test for Memory Protection Key registers

 *

 * Copyright (C) 2015 Anshuman Khandual, IBM Corporation.

 * Copyright (C) 2018 IBM Corporation.

 Information shared between the parent and the child. */

 AMR value the parent expects to read from the child. */

 AMR value the parent is expected to write to the child. */

 AMR value that ptrace should refuse to write to the child. */

 IAMR value the parent expects to read from the child. */

 UAMOR value the parent expects to read from the child. */

	/*

	 * IAMR and UAMOR values that ptrace should refuse to write to the child

	 * (even though they're valid ones) because userspace doesn't have

	 * access to those registers.

 Wait until parent fills out the initial register values. */

 Get some pkeys so that we can change their bits in the AMR. */

	/*

	 * invalid amr value where we try to force write

	 * things which are deined by a uamor setting.

	/*

	 * if PKEY_DISABLE_EXECUTE succeeded we should update the expected_iamr

	/*

	 * We allocated pkey2 and pkey 3 above. Clear the IAMR bits.

	/*

	 * Create an IAMR value different from expected value.

	 * Kernel will reject an IAMR and UAMOR change.

 Wait for parent to read our AMR value and write a new one. */

	/*

	 * Wait for parent to try to write an invalid AMR value.

	/*

	 * Wait for parent to try to write an IAMR and a UAMOR value. We can't

	 * verify them, but we can verify that the AMR didn't change.

 Now let parent now that we are finished. */

	/*

	 * Get the initial values for AMR, IAMR and UAMOR and communicate them

	 * to the child.

 Wake up child so that it can set itself up. */

 Verify that we can read the pkey registers from the child. */

 Write valid AMR value in child. */

 Wake up child so that it can verify it changed. */

 Write invalid AMR value in child. */

 Wake up child so that it can verify it didn't change. */

 Try to write to IAMR. */

 Try to write to IAMR and UAMOR. */

 Verify that all registers still have their expected values. */

 Wake up child so that it can verify AMR didn't change and wrap up. */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Ptrace test for GPR/FPR registers in TM context

 *

 * Copyright (C) 2015 Anshuman Khandual, IBM Corporation.

 Tracer and Tracee Shared Data */

 Transaction abort handler */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Ptrace test for VMX/VSX registers in the TM Suspend context

 *

 * Copyright (C) 2015 Anshuman Khandual, IBM Corporation.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Ptrace test for VMX/VSX registers

 *

 * Copyright (C) 2015 Anshuman Khandual, IBM Corporation.

 Tracer and Tracee Shared Data */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Ptrace test for TAR, PPR, DSCR registers

 *

 * Copyright (C) 2015 Anshuman Khandual, IBM Corporation.

 Tracer and Tracee Shared Data */

 Wait on parent */

 Unblock the parent now */

 TAR was added in v2.07

 Unblock the child now */

 Wait on child */

 SPDX-License-Identifier: GPL-2.0

/*

 * A ptrace test for testing PTRACE_SYSEMU, PTRACE_SETREGS and

 * PTRACE_GETREG.  This test basically create a child process that executes

 * syscalls and the parent process check if it is being traced appropriated.

 *

 * This test is heavily based on tools/testing/selftests/x86/ptrace_syscall.c

 * test, and it was adapted to run on Powerpc by

 * Breno Leitao <leitao@debian.org>

 Bitness-agnostic defines for user_regs_struct fields. */

	/*

	 * Child process is running 4 syscalls after ptrace.

	 *

	 * 1) getpid()

	 * 2) gettid()

	 * 3) tgkill() -> Send SIGSTOP

	 * 4) gettid() -> Where the tests will happen essentially

 Parent process below */

 Wait for SIGSTOP sent by tgkill above. */

	/*

	 * Ptrace trapped prior to executing the syscall, thus r3 still has

	 * the syscall number instead of the sys_gettid() result

	/*

	 * Rewind to retry the same syscall again. This will basically test

	 * the rewind process together with PTRACE_SETREGS and PTRACE_GETREGS.

	/*

	 * Inject a new syscall (getpid) in the same place the previous

	 * syscall (gettid), rewind and re-execute.

	/* Check that ptrace stopped at the new syscall that was

	 * injected, and guarantee that it haven't executed, i.e, user_args

	 * contain the arguments and not the syscall return value, for

	 * instance.

 Guarantee that the process executed properly, returning 0 */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * perf events self profiling example test case for hw breakpoints.

 *

 * This tests perf PERF_TYPE_BREAKPOINT parameters

 * 1) tests all variants of the break on read/write flags

 * 2) tests exclude_user == 0 and 1

 * 3) test array matches (if DAWR is supported))

 * 4) test different numbers of breakpoints matches

 *

 * Configure this breakpoint, then read and write the data a number of

 * times. Then check the output count from perf is as expected.

 *

 * Based on:

 *   http://ozlabs.org/~anton/junkcode/perf_events_example1.c

 *

 * Copyright (C) 2018 Michael Neuling, IBM Corporation.

 Assume online processors are 0 to nprocs for simplisity */

 bp_addr can point anywhere but needs to be aligned */

 provide some variability */

 align to 0x400 boundary as required by DAWR */

 start counters */

 Test a bunch of reads and writes */

 stop counters */

 read and check counters */

 we read and write each loop, so subtract the ones we are counting */

 watch middle half of target array */

 Shouldn't hit. */

 Hit */

 Hit */

 Shouldn't Hit */

 Hit */

 There is no perf api to find number of available watchpoints. Use ptrace. */

	/*

	 * perf defines rwflag as two bits read and write and at least

	 * one must be set.  So range 1-3.

 if we have the dawr, we can do an array test */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Ptrace test for TAR, PPR, DSCR registers in the TM Suspend context

 *

 * Copyright (C) 2015 Anshuman Khandual, IBM Corporation.

 TAR_1 */

 DSCR_1 */

 PPR_1*/

 TAR_2 */

 DSCR_2 */

 PPR_2 */

 TAR_3 */

 DSCR_3 */

 PPR_3 */

 Transaction abort handler */

 TM failed, analyse */

 SPDX-License-Identifier: GPL-2.0+

/*

 * Ptrace test for hw breakpoints

 *

 * Based on tools/testing/selftests/breakpoints/breakpoint_test.c

 *

 * This test forks and the parent then traces the child doing various

 * types of ptrace enabled breakpoints

 *

 * Copyright (C) 2018 Michael Neuling, IBM Corporation.

/*

 * Use volatile on all global var so that compiler doesn't

 * optimise their load/stores. Otherwise selftest can fail.

 double word aligned */

 double word unaligned */

 Wake up father so that it sets up the first test */

 PTRACE_SET_DEBUGREG, WO test */

 PTRACE_SET_DEBUGREG, RO test */

 PTRACE_SET_DEBUGREG, RW test */

 PTRACE_SET_DEBUGREG, Kernel Access Userspace test */

 PPC_PTRACE_SETHWDEBUG, MODE_EXACT, WO test */

 PPC_PTRACE_SETHWDEBUG, MODE_EXACT, RO test */

 PPC_PTRACE_SETHWDEBUG, MODE_EXACT, RW test */

 PPC_PTRACE_SETHWDEBUG, MODE_EXACT, Kernel Access Userspace test */

 PPC_PTRACE_SETHWDEBUG, MODE_RANGE, DW ALIGNED, WO test */

 PPC_PTRACE_SETHWDEBUG, MODE_RANGE, DW ALIGNED, RO test */

 PPC_PTRACE_SETHWDEBUG, MODE_RANGE, DW ALIGNED, RW test */

 PPC_PTRACE_SETHWDEBUG, MODE_RANGE, DW UNALIGNED, WO test */

 PPC_PTRACE_SETHWDEBUG, MODE_RANGE, DW UNALIGNED, RO test */

 PPC_PTRACE_SETHWDEBUG, MODE_RANGE, DW UNALIGNED, RW test */

 PPC_PTRACE_SETHWDEBUG, MODE_RANGE, DW UNALIGNED, DAR OUTSIDE, RW test */

 PPC_PTRACE_SETHWDEBUG. DAWR_MAX_LEN. RW test */

 PPC_PTRACE_SETHWDEBUG 2, MODE_RANGE, DW ALIGNED, WO test */

 PPC_PTRACE_SETHWDEBUG 2, MODE_RANGE, DW UNALIGNED, RO test */

 PPC_PTRACE_SETHWDEBUG 2, MODE_RANGE, DAWR Overlap, WO test */

 PPC_PTRACE_SETHWDEBUG 2, MODE_RANGE, DAWR Overlap, RO test */

 Wait for the child to SIGTRAP */

		/*

		 * For ptrace registered watchpoint, signal is generated

		 * before executing load/store. Singlestep the instruction

		 * and then continue the test.

 PTRACE_SET_DEBUGREG, WO test*/

 PTRACE_SET_DEBUGREG, RO test */

 PTRACE_SET_DEBUGREG, RW test */

 PTRACE_SET_DEBUGREG, Kernel Access Userspace test */

 hardcoded in kernel */

 PPC_PTRACE_SETHWDEBUG, MODE_EXACT, WO test */

 PPC_PTRACE_SETHWDEBUG, MODE_EXACT, RO test */

 PPC_PTRACE_SETHWDEBUG, MODE_EXACT, RW test */

 hardcoded in kernel */

 PPC_PTRACE_SETHWDEBUG, MODE_EXACT, Kernel Access Userspace test */

 PPC_PTRACE_SETHWDEBUG, MODE_RANGE, DW ALIGNED, WO test */

 PPC_PTRACE_SETHWDEBUG, MODE_RANGE, DW ALIGNED, RO test */

 PPC_PTRACE_SETHWDEBUG, MODE_RANGE, DW ALIGNED, RW test */

 PPC_PTRACE_SETHWDEBUG 2, MODE_RANGE, DW ALIGNED, WO test */

 PPC_PTRACE_SETHWDEBUG 2, MODE_RANGE, DW UNALIGNED, RO test */

 PPC_PTRACE_SETHWDEBUG 2, MODE_RANGE, DAWR Overlap, WO test */

 PPC_PTRACE_SETHWDEBUG 2, MODE_RANGE, DAWR Overlap, RO test */

 PPC_PTRACE_SETHWDEBUG, MODE_RANGE, DW UNALIGNED, WO test */

 PPC_PTRACE_SETHWDEBUG, MODE_RANGE, DW UNALIGNED, RO test */

 PPC_PTRACE_SETHWDEBUG, MODE_RANGE, DW UNALIGNED, RW test */

 PPC_PTRACE_SETHWDEBUG, MODE_RANGE, DW UNALIGNED, DAR OUTSIDE, RW test */

 PPC_PTRACE_SETHWDEBUG, DAWR_MAX_LEN, RW test */

 Set the breakpoints and check the child successfully trigger them */

 Let the child exit first. */

	/*

	 * Testcases exits immediately with -1 on any failure. If

	 * it has reached here, it means all tests were successful.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Ptrace test for TAR, PPR, DSCR registers in the TM context

 *

 * Copyright (C) 2015 Anshuman Khandual, IBM Corporation.

 TAR_1 */

 DSCR_1 */

 PPR_1*/

 TAR_2 */

 DSCR_2 */

 PPR_2 */

 Transaction abort handler */

 TM failed, analyse */

 SPDX-License-Identifier: GPL-2.0+

/*

 * Ptrace test for Memory Protection Key registers

 *

 * Copyright (C) 2015 Anshuman Khandual, IBM Corporation.

 * Copyright (C) 2018 IBM Corporation.

 5 MB should be enough */

 Information shared between the parent and the child. */

 AMR value the parent expects to read in the core file. */

 IAMR value the parent expects to read in the core file. */

 UAMOR value the parent expects to read in the core file. */

 When the child crashed. */

 Wait until parent fills out the initial register values. */

 Get some pkeys so that we can change their bits in the AMR. */

	/*

	 * We won't use pkey3. This tests whether the kernel restores the UAMOR

	 * permissions after a key is freed.

 Crash. */

 Shouldn't get here. */

 Return file size if filename exists and pass sanity check, or zero if not. */

 Make sure we're not using a stale core file. */

	/*

	 * e_phnum is at most 65535 so calculating the size of the

	 * program header cannot overflow.

 Sanity check the program header table location. */

 Find the PT_NOTE segment. */

 Find the NT_PPC_PKEY note. */

	/*

	 * Get the initial values for AMR, IAMR and UAMOR and communicate them

	 * to the child.

 Wake up child so that it can set itself up. */

 Construct array of core file names to try. */

 Check whether we can predict the name of the core file. */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Ptrace test for VMX/VSX registers in the TM context

 *

 * Copyright (C) 2015 Anshuman Khandual, IBM Corporation.

 SPDX-License-Identifier: GPL-2.0+

 Overlapping address range */

 Non-overlapping address range */

 --> parent (SIGUSR1) */

	/* Test:

	 * if (new per thread event by ptrace)

	 *	if (existing cpu event by perf)

	 *		if (addr range overlaps)

	 *			fail;

	/* Test:

	 * if (new per thread event by ptrace)

	 *	if (existing cpu event by perf)

	 *		if (addr range does not overlaps)

	 *			allow;

	/* Test:

	 * if (new per thread event by ptrace)

	 *	if (existing thread event by perf on the same thread)

	 *		if (addr range overlaps)

	 *			fail;

	/* Test:

	 * if (new per thread event by ptrace)

	 *	if (existing thread event by perf on the same thread)

	 *		if (addr range does not overlaps)

	 *			fail;

	/* Test:

	 * if (new per thread event by ptrace)

	 *	if (existing thread event by perf on the different thread)

	 *		allow;

 Temporary Child */

	/* Test:

	 * if (new per thread kernel event by perf)

	 *	if (existing thread event by ptrace on the same thread)

	 *		allow;

	 * -- OR --

	 * if (new per cpu kernel event by perf)

	 *	if (existing thread event by ptrace)

	 *		allow;

	/* Test:

	 * if (new per thread event by perf)

	 *	if (existing thread event by ptrace on the same thread)

	 *		if (addr range overlaps)

	 *			fail;

	/* Test:

	 * if (new per thread event by perf)

	 *	if (existing thread event by ptrace on the same thread)

	 *		if (addr range does not overlaps)

	 *			allow;

	/* Test:

	 * if (new per thread event by perf)

	 *	if (existing thread event by ptrace on the other thread)

	 *		allow;

 Temporary Child */

	/* Test:

	 * if (new per cpu event by perf)

	 *	if (existing thread event by ptrace on the same thread)

	 *		if (addr range overlaps)

	 *			fail;

	/* Test:

	 * if (new per cpu event by perf)

	 *	if (existing thread event by ptrace on the same thread)

	 *		if (addr range does not overlap)

	 *			allow;

	/* Test:

	 * if (new per thread and per cpu event by perf)

	 *	if (existing thread event by ptrace on the same thread)

	 *		if (addr range overlaps)

	 *			fail;

	/* Test:

	 * if (new per thread and per cpu event by perf)

	 *	if (existing thread event by ptrace on the same thread)

	 *		if (addr range does not overlap)

	 *			allow;

	/* Test:

	 * if (new per thread and per cpu event by perf)

	 *	if (existing thread event by ptrace on the other thread)

	 *		allow;

 Temporary Child */

 parent */

 <-- child (SIGUSR1) */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Ptrace test for GPR/FPR registers in TM Suspend context

 *

 * Copyright (C) 2015 Anshuman Khandual, IBM Corporation.

 Tracer and Tracee Shared Data */

 Transaction abort handler */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Ptrace test TM SPR registers

 *

 * Copyright (C) 2015 Anshuman Khandual, IBM Corporation.

 Tracee and tracer shared data */

 TM failover handler should follow "tbegin.;" */

 $ = TFHAR - 12 */

 There are 2 32bit instructions before tbegin. */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2020 IBM Corp.

 *

 * Author: Bulent Abali <abali@us.ibm.com>

 *

	/* Save power and let other threads use the h/w. top may show

	 * 100% but only because OS doesn't know we slowed the this

	 * h/w thread while polling. We're letting other threads have

	 * higher throughput on the core.

		/* usleep(0) takes around 29000 ticks ~60 us.

		 * 300000 is spinning for about 600 us then

		 * start sleeping.

 Fault address from signal handler */

 hw has updated csb and output buffer */

 Check CSB flags. */

 spin for few ticks */

 sleep */

 CC Table 6-8 */

/*

 * Fault in pages prior to NX job submission.  wr=1 may be required to

 * touch writeable pages.  System zero pages do not fault-in the page as

 * intended.  Typically set wr=1 for NX target pages and set wr=0 for NX

 * source pages.

 When buf_sz is small or buf tail is in another page */

 SPDX-License-Identifier: GPL-2.0-or-later

/* P9 gunzip sample code for demonstrating the P9 NX hardware

 * interface.  Not intended for productive uses or for performance or

 * compression ratio measurements.  Note also that /dev/crypto/gzip,

 * VAS and skiboot support are required

 *

 * Copyright 2020 IBM Corp.

 *

 * Author: Bulent Abali <abali@us.ibm.com>

 *

 * https://github.com/libnxz/power-gzip for zlib api and other utils

 * Definitions of acronyms used here.  See

 * P9 NX Gzip Accelerator User's Manual for details:

 * https://github.com/libnxz/power-gzip/blob/develop/doc/power_nx_gzip_um.pdf

 *

 * adler/crc: 32 bit checksums appended to stream tail

 * ce:       completion extension

 * cpb:      coprocessor parameter block (metadata)

 * crb:      coprocessor request block (command)

 * csb:      coprocessor status block (status)

 * dht:      dynamic huffman table

 * dde:      data descriptor element (address, length)

 * ddl:      list of ddes

 * dh/fh:    dynamic and fixed huffman types

 * fc:       coprocessor function code

 * histlen:  history/dictionary length

 * history:  sliding window of up to 32KB of data

 * lzcount:  Deflate LZ symbol counts

 * rembytecnt: remaining byte count

 * sfbt:     source final block type; last block's type during decomp

 * spbc:     source processed byte count

 * subc:     source unprocessed bit count

 * tebc:     target ending bit count; valid bits in the last byte

 * tpbc:     target processed byte count

 * vas:      virtual accelerator switch; the user mode interface

 For aligned_alloc()

 For endian.h

 fifo queue management */

 amount of free bytes in the first and last parts */

 amount of used bytes in the first and last parts */

 first and last free parts start here */

 first and last used parts start here */

/*

 * Adds an (address, len) pair to the list of ddes (ddl) and updates

 * the base dde.  ddl[0] is the only dde in a direct dde which

 * contains a single (addr,len) pair.  For more pairs, ddl[0] becomes

 * the indirect (base) dde that points to a list of direct ddes.

 * See Section 6.4 of the NX-gzip user manual for DDE description.

 * Addr=NULL, len=0 clears the ddl[0].  Returns the total number of

 * bytes in ddl.  Caller is responsible for allocting the array of

 * nx_dde_t *ddl.  If N addresses are required in the scatter-gather

 * list, the ddl array must have N+1 entries minimum.

 Number of ddes in the dde list ; == 0 when it is a direct dde */

 First dde is unused; make it a direct dde */

		/* Converting direct to indirect dde

		 * ddl[0] becomes head dde of ddl

		 * copy direct to indirect first.

 Add the new dde next */

 Ddl head points to 2 direct ddes */

 Pointer to the first direct dde */

 Append a dde to an existing indirect ddl */

 byte sum of all dde */

/*

 * Touch specified number of pages represented in number bytes

 * beginning from the first buffer in a dde list.

 * Do not touch the pages past buf_sz-th byte's page.

 *

 * Set buf_sz = 0 to touch all pages described by the ddep.

 Direct dde */

 Indirect dde */

 First address of the list */

 Touching fewer pages than encoded in the ddebc */

/*

 * Src and dst buffers are supplied in scatter gather lists.

 * NX function code and other parameters supplied in cmdp.

 Status, output byte count in tpbc */

 NX reports input bytes in spbc; cleared */

 Clear output */

 Submit the crb, the job descriptor, to the accelerator. */

 Queuing, file ops, byte counting */

 1000 max */

 nx hardware */

 when using mmap'ed files */

 Make a new file name to write to.  Ignoring '.gz' */

 Decode the gzip header */

 ID1 */

 ID2 */

 CM */

 FLG */

	/* Read 6 bytes; ignoring the MTIME, XFL, OS fields in this

	 * sample code.

 FNAME */

 FHCRC */

	/* Allocate one page larger to prevent page faults due to NX

	 * overfetching.

	 * Either do this (char*)(uintptr_t)aligned_alloc or use

	 * -std=c11 flag to make the int-to-pointer warning go away.

 Leave unused space due to history rounding rules */

 Read from .gz file */

	/* We read in to fifo_in in two steps: first: read in to from

	 * cur_in to the end of the buffer.  last: if free space wrapped

	 * around, read from fifo_in offset 0 to offset cur_in.

 Reset fifo head to reduce unnecessary wrap arounds */

 Free space total is reduced by a gap */

 Free space may wrap around as first and last */

 Start offsets of the free memory */

 Reduce read_sz because of the line_sz gap */

 Read in to offset cur_in + used_in */

 Either EOF or error; exit the read loop */

 If free space wrapped around */

 Reduce read_sz because of the line_sz gap */

 Increase used space */

 Decrease free space */

 Either EOF or error; exit the read loop */

	/* At this point we have used_in bytes in fifo_in with the

	 * data head starting at cur_in and possibly wrapping around.

 Write decompressed data to output file */

	/* If fifo_out has data waiting, write it out to the file to

	 * make free target space for the accelerator used bytes in

	 * the first and last parts of fifo_out.

 Move head of the fifo */

 If more data available in the last part */

 Keep it here for later */

 NX decompresses input data */

 Address/len lists */

 FC, CRC, HistLen, Table 6-6 */

		/* Resuming a partially decompressed input.

		 * The key to resume is supplying the 32KB

		 * dictionary (history) to NX, which is basically

		 * the last 32KB of output produced.

 Round up the history size to quadword.  Section 2.10 */

 bytes */

 Chain in the history buffer to the DDE list */

 Up to 32KB history wraps around fifo_out */

 First decompress job */

 Writing 0 clears out subc as well */

		/* Assuming 10% compression ratio initially; use the

		 * most recently measured compression ratio as a

		 * heuristic to estimate the input and output

		 * sizes.  If we give too much input, the target buffer

		 * overflows and NX cycles are wasted, and then we

		 * must retry with smaller input size.  1000 is 100%.

	/*

	 * NX source buffers

	/*

	 * NX target buffers

 Reduce output free space amount not to overwrite the history */

	/* Target buffer size is used to limit the source data size

	 * based on previous measurements of compression ratio.

 source_sz includes history */

	/* Estimating how much source is needed to 3/4 fill a

	 * target_max size target buffer.  If we overshoot, then NX

	 * must repeat the job with smaller input and we waste

	 * bandwidth.  If we undershoot then we use more NX calls than

	 * necessary.

		/* Target might be small, therefore limiting the

		 * source data.

		/* Source file might be small, therefore limiting target

		 * touch pages to a smaller value to save processor cycles.

	/* Some NX condition codes require submitting the NX job again.

	 * Kernel doesn't handle NX page faults. Expects user code to

	 * touch pages.

 Fault in pages */

 Send job to NX */

		/* We touched the pages ahead of time.  In the most common case

		 * we shouldn't be here.  But may be some pages were paged out.

		 * Kernel should have placed the faulting address to fsaddr.

 Try once with exact number of pages */

			/* If still faulting try fewer input pages

			 * assuming memory outage

		/* Not an error in the most common case; it just says

		 * there is trailing data that we must examine.

		 *

		 * CC=3 CE(1)=0 CE(0)=1 indicates partial completion

		 * Fig.6-7 and Table 6-8.

			/* Check CPB for more information

			 * spbc and tpbc are valid

 Table 6-4 */

 Table 6-4 */

 not an error */

 History length error when CE(1)=1 CE(0)=0. */

		/* Target buffer not large enough; retry smaller input

		 * data; give at least 1 byte.  SPBC/TPBC are not valid.

		/* This should not happen for gzip formatted data;

		 * we need trailing crc and isize

	/* Table 6-4: Source Final Block Type (SFBT) describes the

	 * last processed deflate block and clues the software how to

	 * resume the next job.  SUBC indicates how many input bits NX

	 * consumed but did not process.  SPBC indicates how many

	 * bytes of source were given to the accelerator including

	 * history bytes.

 Deflate final EOB received */

 Calculating the checksum start position. */

		/* Resume decompression cases are below. Basically

		 * indicates where NX has suspended and how to resume

		 * the input stream.

 Within a literal block; use rembytecount */

 Within a literal block; use rembytecount; bfinal=1 */

 Supply the partially processed source byte again */

		/* SUBC LS 3bits: number of bits in the first source byte need

		 * to be processed.

		 * 000 means all 8 bits;  Table 6-3

		 * Clear subc, histlen, sfbt, rembytecnt, dhtlen

 Within a FH block; */

 Within a FH block; bfinal=1 */

 Clear subc, histlen, sfbt, rembytecnt, dhtlen */

 Within a DH block; */

 Within a DH block; bfinal=1 */

 Clear subc, histlen, sfbt, rembytecnt, dhtlen */

 Round up to a qword */

 Copy dht from cpb.out to cpb.in */

 Within a block header; bfinal=0; */

		     /* Also given if source data exactly ends (SUBC=0) with

		      * EOB code with BFINAL=0.  Means the next byte will

		      * contain a block header.

 within a block header with BFINAL=1. */

 Clear subc, histlen, sfbt, rembytecnt, dhtlen */

 Engine did not process any data */

 Adjust the source and target buffer offsets and lengths  */

 Delete input data from fifo_in */

 Add output data to fifo_out */

	/* Deflate history is 32KB max.  No need to supply more

	 * than 32KB on a resume.

	/* To estimate expected expansion in the next NX job; 500 means 50%.

	 * Deflate best case is around 1 to 1000.

 More data to write out */

			/* Need at least 8 more bytes containing gzip crc

			 * and isize.

 Compare checksums and exit */

 SPDX-License-Identifier: GPL-2.0-or-later

/* P9 gzip sample code for demonstrating the P9 NX hardware interface.

 * Not intended for productive uses or for performance or compression

 * ratio measurements.  For simplicity of demonstration, this sample

 * code compresses in to fixed Huffman blocks only (Deflate btype=1)

 * and has very simple memory management.  Dynamic Huffman blocks

 * (Deflate btype=2) are more involved as detailed in the user guide.

 * Note also that /dev/crypto/gzip, VAS and skiboot support are

 * required.

 *

 * Copyright 2020 IBM Corp.

 *

 * https://github.com/libnxz/power-gzip for zlib api and other utils

 *

 * Author: Bulent Abali <abali@us.ibm.com>

 *

 * Definitions of acronyms used here. See

 * P9 NX Gzip Accelerator User's Manual for details:

 * https://github.com/libnxz/power-gzip/blob/develop/doc/power_nx_gzip_um.pdf

 *

 * adler/crc: 32 bit checksums appended to stream tail

 * ce:       completion extension

 * cpb:      coprocessor parameter block (metadata)

 * crb:      coprocessor request block (command)

 * csb:      coprocessor status block (status)

 * dht:      dynamic huffman table

 * dde:      data descriptor element (address, length)

 * ddl:      list of ddes

 * dh/fh:    dynamic and fixed huffman types

 * fc:       coprocessor function code

 * histlen:  history/dictionary length

 * history:  sliding window of up to 32KB of data

 * lzcount:  Deflate LZ symbol counts

 * rembytecnt: remaining byte count

 * sfbt:     source final block type; last block's type during decomp

 * spbc:     source processed byte count

 * subc:     source unprocessed bit count

 * tebc:     target ending bit count; valid bits in the last byte

 * tpbc:     target processed byte count

 * vas:      virtual accelerator switch; the user mode interface

 For aligned_alloc()

 For endian.h

/*

 * LZ counts returned in the user supplied nx_gzip_crb_cpb_t structure.

 clear */

 resuming with no history */

	/* Section 6.6 programming notes; spbc may be in two different

	 * places depending on FC.

 Figure 6-3 6-4; CSB location */

 Source direct dde (scatter-gather list) */

 Target direct dde (scatter-gather list) */

 Submit the crb, the job descriptor, to the accelerator */

/*

 * Prepares a blank no filename no timestamp gzip header and returns

 * the number of bytes written to buf.

 * Gzip specification at https://tools.ietf.org/html/rfc1952

 ID1 */

 ID2 */

 CM  */

 FLG */

 MTIME */

 MTIME */

 MTIME */

 MTIME */

 XFL 4=fastest */

 OS UNIX */

 Caller must free the allocated buffer return nonzero on error. */

 Returns nonzero on error */

/*

 * Z_SYNC_FLUSH as described in zlib.h.

 * Returns number of appended bytes

 Last byte is partially full */

 BFINAL and BTYPE written */

 Zero length block */

/*

 * Final deflate block bit.  This call assumes the block

 * beginning is byte aligned.

 Generous output buffer for header/trailer */

	/*

	 * On PowerVM, the hypervisor defines the maximum request buffer

	 * size is defined and this value is available via sysfs.

 sysfs entry is not available on PowerNV */

 Compress piecemeal in smallish chunks */

 Write the gzip header to the stream */

 Init the CRB, the coprocessor request block */

 Initial gzip crc32 */

 Submit chunk size source data per job */

 Supply large target in case data expands */

 Page faults are handled by the user code */

		/* Fault-in pages; an improved code wouldn't touch so

		 * many pages but would try to estimate the

		 * compression ratio and adjust both the src and dst

		 * touch amounts.

 Page faults are handled by the user code */

 Reset for the next chunk */

		/* Two possible locations for spbc depending on the function

		 * code.

 Target byte count */

 Target ending bit count */

 More chunks to go */

			/* Round up to the next byte with a flush

			 * block; do not set the BFINAqL bit.

 Done */

			/* Set the BFINAL bit of the last block per Deflate

			 * specification.

 Resuming crc32 for the next chunk */

 Append crc32 and ISIZE to the end */

 SPDX-License-Identifier: GPL-2.0+

/*

 * Copyright 2018 IBM Corporation.

 mtspr 3,RS to check for move to DSCR below */

 SPDX-License-Identifier: GPL-2.0+

/*

 * Copyright 2018 IBM Corporation.

 The PMU event we use only works on Power7 or later

 disable L1 prefetching

	/*

	 * We expect to see l1d miss for each cacheline access when entry_flush

	 * is set. Allow a small variation on this.

 SPDX-License-Identifier: GPL-2.0+

/*

 * Copyright 2018-2019 IBM Corporation.

 We could scale all the events by running/enabled but we're lazy

 As long as the PMU is uncontended they should all run

 Works with FAIL_IF()

 Make sure it's NULL terminated

 Trim the trailing newline

 Order matters

 P8 + P9

 P8 + P9

 P9 only

 P9 only

 The PMU events we use only work on Power8 or later

 Count pattern cache too

 These should all not affect userspace branch prediction

			/*

			 * Such a mismatch may be caused by a guest system

			 * reporting as vulnerable when the host is mitigated.

			 * Return skip code to avoid detecting this as an error.

			 * We are not vulnerable and reporting otherwise, so

			 * missing such a mismatch is safe.

 This seems to affect userspace branch prediction a bit?

 SPDX-License-Identifier: GPL-2.0+

/*

 * Copyright 2018 IBM Corporation.

 The PMU event we use only works on Power7 or later

 disable L1 prefetching

	/*

	 * We expect to see l1d miss for each cacheline access when rfi_flush

	 * is set. Allow a small variation on this.

 SPDX-License-Identifier: GPL-2.0+

/*

 * Copyright 2018 IBM Corporation.

 * Copyright 2020 Canonical Ltd.

 The PMU event we use only works on Power7 or later

 disable L1 prefetching

	/*

	 * We expect to see l1d miss for each cacheline access when entry_flush

	 * is set. Allow a small variation on this.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2017, Michael Ellerman, IBM Corp.

 If we found none we're probably on a system where they don't exist */

 But if we found any, we expect to find them all */

 SPDX-License-Identifier: GPL-2.0

/*

 * The associativity domain numbers are returned from the hypervisor as a

 * stream of mixed 16-bit and 32-bit fields. The stream is terminated by the

 * special value of "all ones" (aka. 0xffff) and its size may not exceed 48

 * bytes.

 *

 *    --- 16-bit fields -->

 *  _________________________

 *  |  0  |  1  |  2  |  3  |   be_packed[0]

 *  ------+-----+-----+------

 *  _________________________

 *  |  4  |  5  |  6  |  7  |   be_packed[1]

 *  -------------------------

 *            ...

 *  _________________________

 *  | 20  | 21  | 22  | 23  |   be_packed[5]

 *  -------------------------

 *

 * Convert to the sequence they would appear in the ibm,associativity property.

 Let's fix the values returned by plpar_hcall9() */

			/*

			 * Let's concatenate the 16 bits of this field to the

			 * 15 lower bits of the previous field

 This is the list terminator */

 Data is in the lower 15 bits of this field */

			/*

			 * Data is in the lower 15 bits of this field

			 * concatenated with the next 16 bit field

 The first cell contains the length of the property */

 NOTE: This file is included by a selftest and built in userspace. */

 SPDX-License-Identifier: GPL-2.0

		/* Parsing the next 16-bit value out of the next 64-bit input

		 * value.

 Parse at most 6 x 64-bit input values */

		/* Parsing the next 32-bit value out of the next 64-bit input

		 * value.

 Parse at most 6 x 64-bit input values */

		/* Parse a 32-bit value split accross two consecutives 64-bit

		 * input values.

		/* The lower bits in 0x0001ffff don't get mixed up with the

		 * 0xffff terminator.

		/* The following input doesn't follow the specification.

abort();

#define MAX_LEN 512

 printf("from=%p to=%p len=%ld\n", q+dst, q+src, len);

 SPDX-License-Identifier: GPL-2.0

 Fill with sequential bytes */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Userspace test harness for load_unaligned_zeropad. Creates two

 * pages and uses mprotect to prevent access to the second page and

 * a SEGV handler that walks the exception tables and runs the fixup

 * routine.

 *

 * The results are compared against a normal load that is that is

 * performed while access to the second page is enabled via mprotect.

 *

 * Copyright (C) 2014 Anton Blanchard <anton@au.ibm.com>, IBM

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2015, Cyril Bur, IBM Corp.

 *

 * This test attempts to see if the FPU registers are correctly reported in a

 * signal context. Each worker just spins checking its FPU registers, at some

 * point a signal will interrupt it and C code will check the signal context

 * ensuring it is also the same.

 Number of times each thread should receive the signal */

/*

 * Factor by which to multiply number of online CPUs for total number of

 * worker threads

 Only the non volatiles were loaded up */

		/*

		 * Harness will say the fail was here, look at why signal_fpu

		 * returned

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2015, Cyril Bur, IBM Corp.

 *

 * This test attempts to see if the FPU registers change across preemption.

 * Two things should be noted here a) The check_fpu function in asm only checks

 * the non volatile registers as it is reused from the syscall test b) There is

 * no way to be sure preemption happened so this test just uses many threads

 * and a long wait. As such, a successful test doesn't mean much but a failure

 * is bad.

 Time to wait for workers to get preempted (seconds) */

/*

 * Factor by which to multiply number of online CPUs for total number of

 * worker threads

 Test failed if it ever returns */

 Not really necessary but nice to wait for every thread to start */

	/*

	 * Working are checking this value every loop. In preempt_fpu 'cmpwi r5,0; bne 2b'.

	 * r5 will have loaded the value of running.

		/*

		 * Harness will say the fail was here, look at why preempt_fpu

		 * returned

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright IBM Corp. 2020

 *

 * This test attempts to cause a FP denormal exception on POWER8 CPUs. Unfortunately

 * if the denormal handler is not configured or working properly, this can cause a bad

 * crash in kernel mode when the kernel tries to save FP registers when the process

 * exits.

 try to induce lfs <denormal> ; stfd */

 random denormal */

 renormalised value */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2015, Cyril Bur, IBM Corp.

 *

 * This test attempts to see if the VMX registers change across preemption.

 * Two things should be noted here a) The check_vmx function in asm only checks

 * the non volatile registers as it is reused from the syscall test b) There is

 * no way to be sure preemption happened so this test just uses many threads

 * and a long wait. As such, a successful test doesn't mean much but a failure

 * is bad.

 Time to wait for workers to get preempted (seconds) */

/*

 * Factor by which to multiply number of online CPUs for total number of

 * worker threads

 Test fails if it ever returns */

 vcmpequd used in vmx_asm.S is v2.07

 Not really nessesary but nice to wait for every thread to start */

	/*

	 * Working are checking this value every loop. In preempt_vmx 'cmpwi r5,0; bne 2b'.

	 * r5 will have loaded the value of running.

		/*

		 * Harness will say the fail was here, look at why preempt_vmx

		 * returned

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2015, Cyril Bur, IBM Corp.

 *

 * This test attempts to see if the VSX registers change across preemption.

 * There is no way to be sure preemption happened so this test just

 * uses many threads and a long wait. As such, a successful test

 * doesn't mean much but a failure is bad.

 Time to wait for workers to get preempted (seconds) */

/*

 * Factor by which to multiply number of online CPUs for total number of

 * worker threads

/*

 * Ensure there is twice the number of non-volatile VMX regs!

 * check_vmx() is going to use the other half as space to put the live

 * registers before calling vsx_memcmp()

 Don't want zero because it hides kernel problems */

 Not really nessesary but nice to wait for every thread to start */

	/*

	 * Working are checking this value every loop. In preempt_vsx 'cmpwi r5,0; bne 2b'.

	 * r5 will have loaded the value of running.

		/*

		 * Harness will say the fail was here, look at why preempt_vsx

		 * returned

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2015, Cyril Bur, IBM Corp.

 *

 * This test attempts to see if the VMX registers change across a syscall (fork).

 test_vmx will fork() */

	/*

	 * Setup an environment with much context switching

 vcmpequd used in vmx_asm.S is v2.07

 Can't FAIL_IF(pid2 == -1); because we've already forked */

		/*

		 * Couldn't fork, ensure child_ret is set and is a fail

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2015, Cyril Bur, IBM Corp.

 *

 * This test attempts to see if the VMX registers are correctly reported in a

 * signal context. Each worker just spins checking its VMX registers, at some

 * point a signal will interrupt it and C code will check the signal context

 * ensuring it is also the same.

 Number of times each thread should receive the signal */

/*

 * Factor by which to multiply number of online CPUs for total number of

 * worker threads

 Only the non volatiles were loaded up */

			/*

			 * Shouldn't printf() in a signal handler, however, this is a

			 * test and we've detected failure. Understanding what failed

			 * is paramount. All that happens after this is tests exit with

			 * failure.

 vcmpequd used in vmx_asm.S is v2.07

		/*

		 * Harness will say the fail was here, look at why signal_vmx

		 * returned

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2015, Cyril Bur, IBM Corp.

 *

 * This test attempts to see if the FPU registers change across a syscall (fork).

 test_fpu will fork() */

	/*

	 * Setup an environment with much context switching

 Can't FAIL_IF(pid2 == -1); because already forked once */

		/*

		 * Couldn't fork, ensure test is a fail

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2015, Anton Blanchard, IBM Corp.

 SPDX-License-Identifier: GPL-2.0+

/*

 * Part of fork context switch microbenchmark.

 *

 * Copyright 2018, Anton Blanchard, IBM Corp.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Test null syscall performance

 *

 * Copyright (C) 2009-2015 Anton Blanchard, IBM

/*

 * Use a timer instead of busy looping on clock_gettime() so we don't

 * pollute profiles with glibc and VDSO hits.

/*

 * This only works with recent kernels where cpufreq modifies

 * /proc/cpuinfo dynamically.

 Try to get out of low power/low frequency mode */

 Find fastest clock frequency */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2016, Anton Blanchard, Michael Ellerman, IBM Corp.

 SPDX-License-Identifier: GPL-2.0+

/*

 * Context switch microbenchmark.

 *

 * Copyright 2018, Anton Blanchard, IBM Corp.

 Create a new process group so we can signal everyone for exit */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Context switch microbenchmark.

 *

 * Copyright (C) 2015 Anton Blanchard <anton@au.ibm.com>, IBM

/*

 * Note: LTO (Link Time Optimisation) doesn't play well with this function

 * attribute. Be very careful enabling LTO for this test.

 Create a new process group so we can signal everyone for exit */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2016, Anton Blanchard, Michael Ellerman, IBM Corp.

 SPDX-License-Identifier: GPL-2.0+

/*

 * Copyright 2005-2020 IBM Corporation.

 *

 * Includes code from librtas (https://github.com/ibm-power-utilities/librtas/)

 Unexpected I/O Error */

 No Firmware Implementation of Function */

 Pointer to return values in args[]. */

 allocate enough for two string, a slash and trailing NULL */

 We don't care if the call doesn't exist

 Test a legitimate harmless call

 Expected: call succeeds

 Test a prohibited call

 Expected: call returns -EINVAL

 Get RMO

 Test a permitted call, user-supplied size, buffer inside RMO

 Expected: call succeeds

 Test a permitted call, user-supplied size, buffer start outside RMO

 Expected: call returns -EINVAL

 Test a permitted call, user-supplied size, buffer end outside RMO

 Expected: call returns -EINVAL

 Test a permitted call, fixed size, buffer end outside RMO

 Expected: call returns -EINVAL

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright 2015, Michael Ellerman, IBM Corp.

 *

 * This test simply tests that certain syscalls are implemented. It doesn't

 * actually exercise their logic in any way.

	/*

	 * If we ran no tests then it means none of the syscall numbers were

	 * defined, possibly because we were built against old headers. But it

	 * means we didn't really test anything, so instead of passing mark it

	 * as a skip to give the user a clue.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2021, Google LLC.

 *

 * Tests for adjusting the system counter from userspace

 __x86_64__ */

 SPDX-License-Identifier: GPL-2.0

/*

 * KVM dirty page logging test

 *

 * Copyright (C) 2018, Red Hat, Inc.

 for program_invocation_name */

 The memory slot index to track dirty pages */

 Default guest test virtual memory offset */

 How many pages to dirty for each guest loop */

 How many host loops to run (one KVM_GET_DIRTY_LOG for each loop) */

 Interval for each host loop (ms) */

 Dirty bitmaps are always little endian, so we need to swap on big endian */

/*

 * Guest/Host shared variables. Ensure addr_gva2hva() and/or

 * sync_global_to/from_guest() are used when accessing from

 * the host. READ/WRITE_ONCE() should also be used with anything

 * that may change.

/*

 * Guest physical memory offset of the testing memory slot.

 * This will be set to the topmost valid physical address minus

 * the test memory size.

/*

 * Guest virtual memory offset of the testing memory slot.

 * Must not conflict with identity mapped test code.

/*

 * Continuously write to the first 8 bytes of a random pages within

 * the testing memory region.

	/*

	 * On s390x, all pages of a 1M segment are initially marked as dirty

	 * when a page of the segment is written to for the very first time.

	 * To compensate this specialty in this test, we need to touch all

	 * pages during the first iteration.

 Tell the host that we need more random numbers */

 Host variables */

 Points to the test VM memory region on which we track dirty logs */

 For statistics only */

 Whether dirty ring reset is requested, or finished */

/*

 * This is only set by main thread, and only cleared by vcpu thread.  It is

 * used to request vcpu thread to stop at the next GUEST_SYNC, since GUEST_SYNC

 * is the only place that we'll guarantee both "dirty bit" and "dirty data"

 * will match.  E.g., SIG_IPI won't guarantee that if the vcpu is interrupted

 * after setting dirty bit but before the data is written.

/*

 * This is updated by the vcpu thread to tell the host whether it's a

 * ring-full event.  It should only be read until a sem_wait() of

 * sem_vcpu_stop and before vcpu continues to run.

/*

 * This is only used for verifying the dirty pages.  Dirty ring has a very

 * tricky case when the ring just got full, kvm will do userspace exit due to

 * ring full.  When that happens, the very last PFN is set but actually the

 * data is not changed (the guest WRITE is not really applied yet), because

 * we found that the dirty ring is full, refused to continue the vcpu, and

 * recorded the dirty gfn with the old contents.

 *

 * For this specific case, it's safe to skip checking this pfn for this

 * bit, because it's a redundant bit, and when the write happens later the bit

 * will be set again.  We use this variable to always keep track of the latest

 * dirty gfn we've collected, so that if a mismatch of data found later in the

 * verifying process, we let it pass.

 Only use KVM_GET_DIRTY_LOG for logging */

 Use both KVM_[GET|CLEAR]_DIRTY_LOG for logging */

 Use dirty ring for logging */

 Run all supported modes */

 Mode of logging to test.  Default is to run all supported modes */

 Logging mode for current run */

/*

 * In our test we do signal tricks, let's use a better version of

 * sem_wait to avoid signal interrupts

 Should only be called after a GUEST_SYNC */

 It means main thread is sleeping waiting */

	/*

	 * Switch to dirty ring mode after VM creation but before any

	 * of the vcpu creation.

pr_info("fetch 0x%x page %llu\n", *fetch_index, cur->offset);

 This makes sure that hardware PML cache flushed */

 We only have one vcpu */

		/*

		 * This is not a ring-full event, it's safe to allow

		 * vcpu to continue

 Only have one vcpu */

 Cleared pages should be the same as collected */

 A ucall-sync or ring-full event is allowed */

 We should allow this to continue */

 Update the flag first before pause */

 Kick another round of vcpu just to make sure it will quit */

 Return true if this mode is supported, otherwise false */

 Hook when the vm creation is done (before vcpu creation) */

 Hook to collect the dirty pages into the bitmap provided */

 Hook to call when after each vcpu run */

/*

 * We use this bitmap to track some pages that should have its dirty

 * bit set in the _next_ iteration.  For example, if we detected the

 * page value changed to current iteration but at the same time the

 * page bit is cleared in the latest bitmap, then the system must

 * report that write in the next get dirty log call.

	/*

	 * SIG_IPI is unblocked atomically while in KVM_RUN.  It causes the

	 * ioctl to return with -EINTR, but it is still pending and we need

	 * to accept it with the sigwait.

 Clear any existing kick signals */

 Let the guest dirty the random pages */

 If this is a special page that we were tracking... */

			/*

			 * If the bit is set, the value written onto

			 * the corresponding page should be either the

			 * previous iteration number or the current one.

					/*

					 * Short answer: this case is special

					 * only for dirty ring test where the

					 * page is the last page before a kvm

					 * dirty ring full in iteration N-2.

					 *

					 * Long answer: Assuming ring size R,

					 * one possible condition is:

					 *

					 *      main thr       vcpu thr

					 *      --------       --------

					 *    iter=1

					 *                   write 1 to page 0~(R-1)

					 *                   full, vmexit

					 *    collect 0~(R-1)

					 *    kick vcpu

					 *                   write 1 to (R-1)~(2R-2)

					 *                   full, vmexit

					 *    iter=2

					 *    collect (R-1)~(2R-2)

					 *    kick vcpu

					 *                   write 1 to (2R-2)

					 *                   (NOTE!!! "1" cached in cpu reg)

					 *                   write 2 to (2R-1)~(3R-3)

					 *                   full, vmexit

					 *    iter=3

					 *    collect (2R-2)~(3R-3)

					 *    (here if we read value on page

					 *     "2R-2" is 1, while iter=3!!!)

					 *

					 * This however can only happen once per iteration.

					/*

					 * Please refer to comments in

					 * dirty_ring_last_page.

			/*

			 * If cleared, the value written can be any

			 * value smaller or equals to the iteration

			 * number.  Note that the value can be exactly

			 * (iteration-1) if that write can happen

			 * like this:

			 *

			 * (1) increase loop count to "iteration-1"

			 * (2) write to page P happens (with value

			 *     "iteration-1")

			 * (3) get dirty log for "iteration-1"; we'll

			 *     see that page P bit is set (dirtied),

			 *     and not set the bit in host_bmap_track

			 * (4) increase loop count to "iteration"

			 *     (which is current iteration)

			 * (5) get dirty log for current iteration,

			 *     we'll see that page P is cleared, with

			 *     value "iteration-1".

				/*

				 * This page is _just_ modified; it

				 * should report its dirtyness in the

				 * next run

 1G */

	/*

	 * We reserve page table for 2 times of extra dirty mem which

	 * will definitely cover the original (1G+) test range.  Here

	 * we do the calculation with 4K page size which is the

	 * smallest so the page number will be enough for all archs

	 * (e.g., 64K page size guest will need even less memory for

	 * page tables).

	/*

	 * A little more than 1G of guest page sized pages.  Cover the

	 * case where the size is not aligned to 64 pages.

 Align to 1M (segment size) */

 Add an extra memory slot for testing dirty logging */

 Do mapping for the dirty track memory slot */

 Cache the HVA pointer of the region */

 Export the shared variables to the guest */

 Start the iterations */

 Give the vcpu thread some time to dirty some pages */

		/*

		 * See vcpu_sync_stop_requested definition for details on why

		 * we need to stop vcpu when verify data.

		/*

		 * NOTE: for dirty ring, it's possible that we didn't stop at

		 * GUEST_SYNC but instead we stopped because ring is full;

		 * that's okay too because ring full means we're only missing

		 * the flush of the last page, and since we handle the last

		 * page specially verification will succeed anyway.

 Tell the vcpu thread to quit */

 Ensure that vCPU threads start with SIG_IPI blocked.  */

 Run each log mode */

 SPDX-License-Identifier: GPL-2.0

/*

 * access_tracking_perf_test

 *

 * Copyright (C) 2021, Google, Inc.

 *

 * This test measures the performance effects of KVM's access tracking.

 * Access tracking is driven by the MMU notifiers test_young, clear_young, and

 * clear_flush_young. These notifiers do not have a direct userspace API,

 * however the clear_young notifier can be triggered by marking a pages as idle

 * in /sys/kernel/mm/page_idle/bitmap. This test leverages that mechanism to

 * enable access tracking on guest memory.

 *

 * To measure performance this test runs a VM with a configurable number of

 * vCPUs that each touch every page in disjoint regions of memory. Performance

 * is measured in the time it takes all vCPUs to finish touching their

 * predefined region.

 *

 * Note that a deterministic correctness test of access tracking is not possible

 * by using page_idle as it exists today. This is for a few reasons:

 *

 * 1. page_idle only issues clear_young notifiers, which lack a TLB flush. This

 *    means subsequent guest accesses are not guaranteed to see page table

 *    updates made by KVM until some time in the future.

 *

 * 2. page_idle only operates on LRU pages. Newly allocated pages are not

 *    immediately allocated to LRU lists. Instead they are held in a "pagevec",

 *    which is drained to LRU lists some time in the future. There is no

 *    userspace API to force this drain to occur.

 *

 * These limitations are worked around in this test by using a large enough

 * region of memory for each vCPU such that the number of translations cached in

 * the TLB and the number of pages held in pagevecs are a small fraction of the

 * overall workload. And if either of those conditions are not true this test

 * will fail rather than silently passing.

 Global variable used to synchronize all of the vCPU threads. */

 Defines what vCPU threads should do during a given iteration. */

 Run the vCPU to access all its memory. */

 Mark the vCPU's memory idle in page_idle. */

 Set to true when vCPU threads should exit. */

 The iteration that was last completed by each vCPU. */

 Whether to overlap the regions of memory vCPUs access. */

 The backing source for the region of memory. */

 The amount of memory to allocate for each vCPU. */

 The number of vCPUs to create in the VM. */

 If vCPUs are using an overlapping region, let vCPU 0 mark it idle. */

	/*

	 * Assumption: Less than 1% of pages are going to be swapped out from

	 * under us during this test.

	/*

	 * Test that at least 90% of memory has been marked idle (the rest might

	 * not be marked idle because the pages have not yet made it to an LRU

	 * list or the translations are still cached in the TLB). 90% is

	 * arbitrary; high enough that we ensure most memory access went through

	 * access tracking but low enough as to not make the test too brittle

	 * over time and across architectures.

 The type of memory accesses to perform in the VM. */

 Kick off the vCPUs by incrementing iteration. */

 Wait for all vCPUs to finish the iteration. */

	/*

	 * Even though this parallelizes the work across vCPUs, this is still a

	 * very slow operation because page_idle forces the test to mark one pfn

	 * at a time and the clear_young notifier serializes on the KVM MMU

	 * lock.

 As a control, read and write to the populated memory first. */

 Repeat on memory that has been marked as idle. */

 Set done to signal the vCPU threads to exit */

 SPDX-License-Identifier: GPL-2.0

/*

 * KVM demand paging test

 * Adapted from dirty_log_test.c

 *

 * Copyright (C) 2018, Red Hat, Inc.

 * Copyright (C) 2019, Google, Inc.

 for pipe2 */

 Let the guest access its memory */

 In order to get minor faults, prefault via the alias. */

 Cache the host addresses of the region */

			/*

			 * Set up user fault fd to handle demand paging

			 * requests.

 Tell the user fault fd handler threads to quit */

 __NR_userfaultfd */

 __NR_userfaultfd */

 SPDX-License-Identifier: GPL-2.0

/*

 * KVM dirty page logging performance test

 *

 * Based on dirty_log_test.c

 *

 * Copyright (C) 2018, Red Hat, Inc.

 * Copyright (C) 2020, Google, Inc.

 How many host loops to run by default (one KVM_GET_DIRTY_LOG for each loop)*/

 Host variables */

 Start the iterations */

 Allow the vCPUs to populate memory */

 Enable dirty logging */

		/*

		 * Incrementing the iteration number will start the vCPUs

		 * dirtying memory again.

 Disable dirty logging */

 Tell the vcpu thread to quit */

 SPDX-License-Identifier: GPL-2.0

/*

 * KVM memslot modification stress test

 * Adapted from demand_paging_test.c

 *

 * Copyright (C) 2018, Red Hat, Inc.

 * Copyright (C) 2020, Google, Inc.

 for program_invocation_name */

 Let the guest access its memory until a stop signal is received */

	/*

	 * Add the dummy memslot just below the perf_test_util memslot, which is

	 * at the top of the guest physical address space.

 SPDX-License-Identifier: GPL-2.0-only

 for program_invocation_short_name */

/*

 * Use an arbitrary, bogus signature for configuring rseq, this test does not

 * actually enter an rseq critical section.

/*

 * Any bug related to task migration is likely to be timing-dependent; perform

 * a large number of migrations to reduce the odds of a false negative.

	/*

	 * Advance to the next CPU, skipping those that weren't in the original

	 * affinity set.  Sadly, there is no CPU_SET_FOR_EACH, and cpu_set_t's

	 * data storage is considered as opaque.  Note, if this task is pinned

	 * to a small set of discontigous CPUs, e.g. 2 and 1023, this loop will

	 * burn a lot cycles and the test will take longer than normal to

	 * complete.

		/*

		 * Bump the sequence count twice to allow the reader to detect

		 * that a migration may have occurred in between rseq and sched

		 * CPU ID reads.  An odd sequence count indicates a migration

		 * is in-progress, while a completely different count indicates

		 * a migration occurred since the count was last read.

		/*

		 * Ensure the odd count is visible while sched_getcpu() isn't

		 * stable, i.e. while changing affinity is in-progress.

		/*

		 * Wait 1-10us before proceeding to the next iteration and more

		 * specifically, before bumping seq_cnt again.  A delay is

		 * needed on three fronts:

		 *

		 *  1. To allow sched_setaffinity() to prompt migration before

		 *     ioctl(KVM_RUN) enters the guest so that TIF_NOTIFY_RESUME

		 *     (or TIF_NEED_RESCHED, which indirectly leads to handling

		 *     NOTIFY_RESUME) is handled in KVM context.

		 *

		 *     If NOTIFY_RESUME/NEED_RESCHED is set after KVM enters

		 *     the guest, the guest will trigger a IO/MMIO exit all the

		 *     way to userspace and the TIF flags will be handled by

		 *     the generic "exit to userspace" logic, not by KVM.  The

		 *     exit to userspace is necessary to give the test a chance

		 *     to check the rseq CPU ID (see #2).

		 *

		 *     Alternatively, guest_code() could include an instruction

		 *     to trigger an exit that is handled by KVM, but any such

		 *     exit requires architecture specific code.

		 *

		 *  2. To let ioctl(KVM_RUN) make its way back to the test

		 *     before the next round of migration.  The test's check on

		 *     the rseq CPU ID must wait for migration to complete in

		 *     order to avoid false positive, thus any kernel rseq bug

		 *     will be missed if the next migration starts before the

		 *     check completes.

		 *

		 *  3. To ensure the read-side makes efficient forward progress,

		 *     e.g. if sched_getcpu() involves a syscall.  Stalling the

		 *     read-side means the test will spend more time waiting for

		 *     sched_getcpu() to stabilize and less time trying to hit

		 *     the timing-dependent bug.

		 *

		 * Because any bug in this area is likely to be timing-dependent,

		 * run with a range of delays at 1us intervals from 1us to 10us

		 * as a best effort to avoid tuning the test to the point where

		 * it can hit _only_ the original bug and not detect future

		 * regressions.

		 *

		 * The original bug can reproduce with a delay up to ~500us on

		 * x86-64, but starts to require more iterations to reproduce

		 * as the delay creeps above ~10us, and the average runtime of

		 * each iteration obviously increases as well.  Cap the delay

		 * at 10us to keep test runtime reasonable while minimizing

		 * potential coverage loss.

		 *

		 * The lower bound for reproducing the bug is likely below 1us,

		 * e.g. failures occur on x86-64 with nanosleep(0), but at that

		 * point the overhead of the syscall likely dominates the delay.

		 * Use usleep() for simplicity and to avoid unnecessary kernel

		 * dependencies.

	/*

	 * CPU_SET doesn't provide a FOR_EACH helper, get the min/max CPU that

	 * this task is affined to in order to reduce the time spent querying

	 * unusable CPUs, e.g. if this task is pinned to a small percentage of

	 * total CPUs.

 Tell stdout not to buffer its content */

	/*

	 * Create and run a dummy VM that immediately exits to userspace via

	 * GUEST_SYNC, while concurrently migrating the process by setting its

	 * CPU affinity.

		/*

		 * Verify rseq's CPU matches sched's CPU.  Ensure migration

		 * doesn't occur between sched_getcpu() and reading the rseq

		 * cpu_id by rereading both if the sequence count changes, or

		 * if the count is odd (migration in-progress).

			/*

			 * Drop bit 0 to force a mismatch if the count is odd,

			 * i.e. if a migration is in-progress.

			/*

			 * Ensure reading sched_getcpu() and rseq.cpu_id

			 * complete in a single "no migration" window, i.e. are

			 * not reordered across the seq_cnt reads.

	/*

	 * Sanity check that the test was able to enter the guest a reasonable

	 * number of times, e.g. didn't get stalled too often/long waiting for

	 * sched_getcpu() to stabilize.  A 2:1 migration:KVM_RUN ratio is a

	 * fairly conservative ratio on x86-64, which can do _more_ KVM_RUNs

	 * than migrations given the 1us+ delay in the migration task.

 SPDX-License-Identifier: GPL-2.0

/*

 * KVM page table test

 *

 * Copyright (C) 2021, Huawei, Inc.

 *

 * Make sure that THP has been enabled or enough HUGETLB pages with specific

 * page size have been pre-allocated on your system, if you are planning to

 * use hugepages to back the guest memory for testing.

 for program_invocation_name */

 Default size(1GB) of the memory for testing */

 Default guest test virtual memory offset */

 Different guest memory accessing stages */

/*

 * Guest variables. Use addr_gva2hva() if these variables need

 * to be changed in host.

 Host variables */

 Whether the test stage is updated, or completed */

/*

 * Guest physical memory offset of the testing memory slot.

 * This will be set to the topmost valid physical address minus

 * the test memory size.

/*

 * Guest virtual memory offset of the testing memory slot.

 * Must not conflict with identity mapped test code.

 Make sure vCPU args data structure is not corrupt */

		/*

		 * All vCPU threads will be started in this stage,

		 * where guest code of each vCPU will do nothing.

		/*

		 * Before dirty logging, vCPUs concurrently access the first

		 * 8 bytes of each page (host page/large page) within the same

		 * memory region with different accessing types (read/write).

		 * Then KVM will create normal page mappings or huge block

		 * mappings for them.

		/*

		 * During dirty logging, KVM will only update attributes of the

		 * normal page mappings from RO to RW if memory backing src type

		 * is anonymous. In other cases, KVM will split the huge block

		 * mappings into normal page mappings if memory backing src type

		 * is THP or HUGETLB.

				/*

				 * Write to the first host page in each large

				 * page region, and triger break of large pages.

				/*

				 * Access the middle host pages in each large

				 * page region. Since dirty logging is enabled,

				 * this will create new mappings at the smallest

				 * granularity.

		/*

		 * After dirty logging is stopped, vCPUs concurrently read

		 * from every single host page. Then KVM will coalesce the

		 * split page mappings back to block mappings. And a TLB

		 * conflict abort could occur here if TLB entries of the

		 * page mappings are not fully invalidated.

		/*

		 * Here we can know the execution time of every

		 * single vcpu running in different test stages.

 Align up the test memory size */

 Create a VM with enough guest pages */

 Align down GPA of the testing memslot */

 Set up the shared data structure test_args */

 Add an extra memory slot with specified backing src type */

 Do mapping(GVA->GPA) for the testing memory slot */

 Cache the HVA pointer of the region */

 Export shared structure test_args to guest */

 Wake up all the vcpus to run new test stage */

 Wait for all the vcpus to complete new test stage */

 Create VM with vCPUs and make some pre-initialization */

 Test the stage of KVM creating mappings */

 Test the stage of KVM updating mappings */

 Test the stage of KVM adjusting mappings */

 Tell the vcpu thread to quit */

 SPDX-License-Identifier: GPL-2.0

/*

 * A memslot-related performance benchmark.

 *

 * Copyright (C) 2021 Oracle and/or its affiliates.

 *

 * Basic guest setup / host vCPU thread code lifted from set_memory_region_test.

/*

 * 32 MiB is max size that gets well over 100 iterations on 509 slots.

 * Considering that each slot needs to have at least one page up to

 * 8194 slots in use can then be tested (although with slightly

 * limited resolution).

/*

 * 128 MiB is min size that fills 32k slots with at least one page in each

 * while at the same time gets 100+ iterations in such test

 2 MiB chunk size like a typical huge page */

/*

 * For the move active test the middle of the test area is placed on

 * a memslot boundary: half lies in the memslot being moved, half in

 * other memslot(s).

 *

 * When running this test with 32k memslots (32764, really) each memslot

 * contains 4 pages.

 * The last one additionally contains the remaining 21 pages of memory,

 * for the total size of 25 pages.

 * Hence, the maximum size here is 50 pages.

/*

 * Technically, we need also for the atomic bool to be address-free, which

 * is recommended, but not strictly required, by C11 for lockless

 * implementations.

 * However, in practice both GCC and Clang fulfill this requirement on

 * all KVM-supported platforms.

 Ensure the guest thread is spun up. */

/*

 * noinline so we can easily see how much time the host spends waiting

 * for the guest.

 * For the same reason use alarm() instead of polling clock_gettime()

 * to implement a wait timeout.

		/*

		 * No host sync here since the MMIO exits are so expensive

		 * that the host would spend most of its time waiting for

		 * the guest and so instead of measuring memslot move

		 * performance we would measure the performance and

		 * likelihood of MMIO exits

		/*

		 * We can afford to access (map) just a small number of pages

		 * per host sync as otherwise the host will spend

		 * a significant amount of its time waiting for the guest

		 * (instead of doing unmap operations), so this will

		 * effectively turn this test into a map performance test.

		 *

		 * Just access a single page to be on the safe side.

	/*

	 * Unmap the second half of the test area while guest writes to (maps)

	 * the first half.

	/*

	 * Wait for the guest to finish writing the first half of the test

	 * area, verify the written value on the first and the last page of

	 * this area and then unmap it.

	 * Meanwhile, the guest is writing to (mapping) the second half of

	 * the test area.

	/*

	 * Wait for the guest to finish writing the second half of the test

	 * area and verify the written value on the first and the last page

	 * of this area.

	 * The area will be unmapped at the beginning of the next loop

	 * iteration.

	 * Meanwhile, the guest is writing to (mapping) the first half of

	 * the test area.

	/*

	 * Wait for the guest to finish mapping page(s) in the first half

	 * of the test area, verify the written value and then perform unmap

	 * of this area.

	 * Meanwhile, the guest is writing to (mapping) page(s) in the second

	 * half of the test area.

 Likewise, but for the opposite host / guest areas */

	/*

	 * Only rank the slot setup time for tests using the whole test memory

	 * area so they are comparable

 Tell stdout not to buffer its content */

 SPDX-License-Identifier: GPL-2.0

 for program_invocation_short_name */

/*

 * s390x needs at least 1MB alignment, and the x86_64 MOVE/DELETE tests need a

 * 2MB sized and aligned region so that the initial region corresponds to

 * exactly one large page.

/*

 * Somewhat arbitrary location and slot, intended to not overlap anything.

	/*

	 * Loop until the guest is done.  Re-enter the guest on all MMIO exits,

	 * which will occur if the guest attempts to access a memslot after it

	 * has been deleted or while it is being moved .

 Wait for the vCPU thread to reenter the guest. */

	/*

	 * Allocate and map two pages so that the GPA accessed by guest_code()

	 * stays valid across the memslot move.

 Ditto for the host mapping so that both pages can be zeroed. */

 Ensure the guest thread is spun up. */

	/*

	 * Spin until the memory region starts getting moved to a

	 * misaligned address.

	 * Every region move may or may not trigger MMIO, as the

	 * window where the memslot is invalid is usually quite small.

 Spin until the misaligning memory region move completes. */

 Spin until the memory region starts to get re-aligned. */

 Spin until the re-aligning memory region move completes. */

	/*

	 * Shift the region's base GPA.  The guest should not see "2" as the

	 * hva->gpa translation is misaligned, i.e. the guest is accessing a

	 * different host pfn.

	/*

	 * The guest _might_ see an invalid memslot and trigger MMIO, but it's

	 * a tiny window.  Spin and defer the sync until the memslot is

	 * restored and guest behavior is once again deterministic.

	/*

	 * Note, value in memory needs to be changed *before* restoring the

	 * memslot, else the guest could race the update and see "2".

 Restore the original base, the guest should see "1". */

 Defered sync from when the memslot was misaligned (above). */

 Spin until the memory region is deleted. */

 Spin until the memory region is recreated. */

 Spin until the memory region is deleted. */

 Spin indefinitely (until the code memslot is deleted). */

 Delete the memory region, the guest should not die. */

 Recreate the memory region.  The guest should see "0". */

 Delete the region again so that there's only one memslot left. */

	/*

	 * Delete the primary memslot.  This should cause an emulation error or

	 * shutdown due to the page tables getting nuked.

	/*

	 * On AMD, after KVM_EXIT_SHUTDOWN the VMCB has been reinitialized already,

	 * so the instruction pointer would point to the reset vector.

 __x86_64__ */

/*

 * Test it can be added memory slots up to KVM_CAP_NR_MEMSLOTS, then any

 * tentative to add further slots should fail.

 On s390x, the host address must be aligned to 1M (due to PGSTEs) */

 Check it can be added memory slots up to the maximum allowed */

 Check it cannot be added memory slots beyond the limit */

 Tell stdout not to buffer its content */

	/*

	 * FIXME: the zero-memslot test fails on aarch64 and s390x because

	 * KVM_RUN fails with ENOEXEC or EFAULT.

 SPDX-License-Identifier: GPL-2.0

/*

 * steal/stolen time test

 *

 * Copyright (C) 2020, Red Hat, Inc.

 steal_time must have 64-byte alignment */

 ST_GPA_BASE is identity mapped */

 PV_TIME_ST must have 64-byte alignment */

 ST_GPA_BASE is identity mapped */

 Set CPU affinity so we can force preemption of the VCPU */

 Create a one VCPU guest and an identity mapped memslot for the steal time structure */

 Add the rest of the VCPUs */

 Run test on each VCPU */

 First VCPU run initializes steal-time */

 Second VCPU run, expect guest stolen time to be <= run_delay */

 Steal time from the VCPU. The steal time thread has the same CPU affinity as the VCPUs. */

 Run VCPU again to confirm stolen time is consistent with run_delay */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * kvm_binary_stats_test

 *

 * Copyright (C) 2021, Google LLC.

 *

 * Test the fd-based interface for KVM statistics.

 for program_invocation_short_name */

 Read kvm stats header */

 Read kvm stats id string */

 Check id string, that should start with "kvm" */

 Sanity check for other fields in header */

 Check overlap */

 Allocate memory for stats descriptors */

 Read kvm stats descriptors */

 Sanity check for fields in descriptors */

 Check type,unit,base boundaries */

		/* Check exponent for stats unit

		 * Exponent for counter should be greater than or equal to 0

		 * Exponent for unit bytes should be greater than or equal to 0

		 * Exponent for unit seconds should be less than or equal to 0

		 * Exponent for unit clock cycles should be greater than or

		 * equal to 0

 Check name string */

 Check size field, which should not be zero */

 Check bucket_size field */

 Check overlap */

 Check validity of all stats data size */

 Check stats offset */

 Allocate memory for stats data */

 Read kvm stats data as a bulk */

 Read kvm stats data one by one */

 Get fd for VM stats */

 Get fd for VCPU stats */

/*

 * Usage: kvm_bin_form_stats [#vm] [#vcpu]

 * The first parameter #vm set the number of VMs being created.

 * The second parameter #vcpu set the number of VCPUs being created.

 * By default, DEFAULT_NUM_VM VM and DEFAULT_NUM_VCPU VCPU for the VM would be

 * created for testing.

 Get the number of VMs and VCPUs that would be created for testing. */

 Check the extension for binary stats */

 Create VMs and VCPUs */

 Check stats read for every VM and VCPU */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * kvm_create_max_vcpus

 *

 * Copyright (C) 2019, Google LLC.

 *

 * Test for KVM_CAP_MAX_VCPUS and KVM_CAP_MAX_VCPU_ID.

 for program_invocation_short_name */

 This asserts that the vCPU was created. */

	/*

	 * Upstream KVM prior to 4.8 does not support KVM_CAP_MAX_VCPU_ID.

	 * Userspace is supposed to use KVM_CAP_MAX_VCPUS as the maximum ID

	 * in this case.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * This test is intended to reproduce a crash that happens when

 * kvm_arch_hardware_disable is called and it attempts to unregister the user

 * return notifiers.

 Arguments for the pthreads */

 Some busy work */

 Should not be reached */

	/*

	 * Wait for the child to post to the semaphore, but wake up periodically

	 * to check if the child exited prematurely.

 Child is still running, keep waiting. */

		/*

		 * Child is no longer running, which is not expected.

		 *

		 * If it exited with a non-zero status, we explicitly forward

		 * the child's status in case it exited with KSFT_SKIP.

 This function always exits */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * arch_timer.c - Tests the aarch64 timer IRQ functionality

 *

 * The test validates both the virtual and physical timer IRQs using

 * CVAL and TVAL registers. This consitutes the four stages in the test.

 * The guest's main thread configures the timer interrupt for a stage

 * and waits for it to fire, with a timeout equal to the timer period.

 * It asserts that the timeout doesn't exceed the timer period.

 *

 * On the other hand, upon receipt of an interrupt, the guest's interrupt

 * handler validates the interrupt by checking if the architectural state

 * is in compliance with the specifications.

 *

 * The test provides command-line options to configure the timer's

 * period (-p), number of vCPUs (-n), and iterations per stage (-i).

 * To stress-test the timer stack even more, an option to migrate the

 * vCPUs across pCPUs (-m), at a particular rate, is also provided.

 *

 * Copyright (c) 2021, Google LLC.

 Shared variables between host and guest */

 Make sure we are dealing with the correct timer IRQ */

 Basic 'timer condition met' check */

 Setup the next interrupt */

 Setup a timeout for the interrupt to arrive */

 Currently, any exit from guest is an indication of completion */

 Randomly find an available pCPU to place a vCPU on */

 Allow the error where the vCPU thread is already finished */

 Spawn a thread to control the vCPU migrations */

 Timer initid should be same for all the vCPUs, so query only vCPU-0 */

 Make all the test's cmdline args visible to the guest */

 Tell stdout not to buffer its content */

 SPDX-License-Identifier: GPL-2.0

/*

 * Check for KVM_GET_REG_LIST regressions.

 *

 * Copyright (C) 2020, Red Hat, Inc.

 *

 * When attempting to migrate from a host with an older kernel to a host

 * with a newer kernel we allow the newer kernel on the destination to

 * list new registers with get-reg-list. We assume they'll be unused, at

 * least until the guest reboots, and so they're relatively harmless.

 * However, if the destination host with the newer kernel is missing

 * registers which the source host with the older kernel has, then that's

 * a regression in get-reg-list. This test checks for that regression by

 * checking the current list against a blessed list. We should never have

 * missing registers, but if new ones appear then they can probably be

 * added to the blessed list. A completely new blessed list can be created

 * by running the test with the --list command line argument.

 *

 * Note, the blessed list should be created from the oldest possible

 * kernel. We can't go older than v4.15, though, because that's the first

 * release to expose the ID system registers in KVM_GET_REG_LIST, see

 * commit 93390c0a1b20 ("arm64: KVM: Hide unsupported AArch64 CPU features

 * from guests"). Also, one must use the --core-reg-fixup command line

 * option when running on an older kernel that doesn't include df205b5c6328

 * ("KVM: arm64: Filter out invalid core register IDs in KVM_GET_REG_LIST")

	/*

	 * DEMUX register presence depends on the host's CLIDR_EL1.

	 * This means there's no set of them that we can bless.

	/*

	 * core_off is the offset into struct kvm_regs

/*

 * Older kernels listed each 32-bit word of CORE registers separately.

 * For 64 and 128-bit registers we need to ignore the extra words. We

 * also need to fixup the sizes, because the older kernels stated all

 * registers were 64-bit, even when they weren't.

			/*

			 * These offsets are pointing at padding.

			 * We need to ignore them too.

	/*

	 * We only test that we can get the register and then write back the

	 * same value. Some registers may allow other values to be written

	 * back, but others only allow some bits to be changed, and at least

	 * for ID registers set will fail if the value does not exactly match

	 * what was returned by get. If registers that allow other values to

	 * be written need to have the other values tested, then we should

	 * create a new set of tests for those in a new independent test

	 * executable.

 rejects_set registers are rejected after KVM_ARM_VCPU_FINALIZE */

		/*

		 * We only want to print the register list of a single config.

/*

 * The current blessed list was primed with the output of kernel version

 * v4.15 with --core-reg-fixup and then later updated with new registers.

 *

 * The blessed list is up to date with kernel version v5.13-rc3

 CNTV_CTL_EL0 */

 CNTV_CVAL_EL0 */

 MIDR_EL1 */

 REVIDR_EL1 */

 CLIDR_EL1 */

 AIDR_EL1 */

 CTR_EL0 */

 MDCCINT_EL1 */

 MDSCR_EL1 */

 DBGVCR32_EL2 */

 MPIDR_EL1 */

 ID_PFR0_EL1 */

 ID_PFR1_EL1 */

 ID_DFR0_EL1 */

 ID_AFR0_EL1 */

 ID_MMFR0_EL1 */

 ID_MMFR1_EL1 */

 ID_MMFR2_EL1 */

 ID_MMFR3_EL1 */

 ID_ISAR0_EL1 */

 ID_ISAR1_EL1 */

 ID_ISAR2_EL1 */

 ID_ISAR3_EL1 */

 ID_ISAR4_EL1 */

 ID_ISAR5_EL1 */

 ID_MMFR4_EL1 */

 ID_ISAR6_EL1 */

 MVFR0_EL1 */

 MVFR1_EL1 */

 MVFR2_EL1 */

 ID_PFR2_EL1 */

 ID_DFR1_EL1 */

 ID_MMFR5_EL1 */

 ID_AA64PFR0_EL1 */

 ID_AA64PFR1_EL1 */

 ID_AA64ZFR0_EL1 */

 ID_AA64DFR0_EL1 */

 ID_AA64DFR1_EL1 */

 ID_AA64AFR0_EL1 */

 ID_AA64AFR1_EL1 */

 ID_AA64ISAR0_EL1 */

 ID_AA64ISAR1_EL1 */

 ID_AA64MMFR0_EL1 */

 ID_AA64MMFR1_EL1 */

 ID_AA64MMFR2_EL1 */

 SCTLR_EL1 */

 ACTLR_EL1 */

 CPACR_EL1 */

 TTBR0_EL1 */

 TTBR1_EL1 */

 TCR_EL1 */

 AFSR0_EL1 */

 AFSR1_EL1 */

 ESR_EL1 */

 FAR_EL1 */

 PAR_EL1 */

 MAIR_EL1 */

 AMAIR_EL1 */

 VBAR_EL1 */

 DISR_EL1 */

 CONTEXTIDR_EL1 */

 TPIDR_EL1 */

 CNTKCTL_EL1 */

 CSSELR_EL1 */

 TPIDR_EL0 */

 TPIDRRO_EL0 */

 DACR32_EL2 */

 IFSR32_EL2 */

 FPEXC32_EL2 */

 PMINTENSET_EL1 */

 PMINTENCLR_EL1 */

 PMCR_EL0 */

 PMCNTENSET_EL0 */

 PMCNTENCLR_EL0 */

 PMOVSCLR_EL0 */

 PMSWINC_EL0 */

 PMSELR_EL0 */

 PMCCNTR_EL0 */

 PMUSERENR_EL0 */

 PMOVSSET_EL0 */

 PMCCFILTR_EL0 */

 ZCR_EL1 */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * psci_cpu_on_test - Test that the observable state of a vCPU targeted by the

 * CPU_ON PSCI call matches what the caller requested.

 *

 * Copyright (c) 2021 Google LLC.

 *

 * This is a regression test for a race between KVM servicing the PSCI call and

 * userspace reading the vCPUs registers.

	/*

	 * make sure the target is already off when executing the test.

 SPDX-License-Identifier: GPL-2.0

 This test only uses the first bp and wp slot. */

 Software-breakpoint */

 Hardware-breakpoint */

 Hardware-breakpoint + svc */

 Hardware-breakpoint + software-breakpoint */

 Watchpoint */

 Single-step */

 SPDX-License-Identifier: GPL-2.0

/*

 * vgic init sequence tests

 *

 * Copyright (C) 2020, Red Hat, Inc.

 helper to access a redistributor register */

 dummy guest code */

 we don't want to assert on run execution, hence that helper */

/**

 * Helper routine that performs KVM device tests in general. Eventually the

 * ARM_VGIC (GICv2 or GICv3) device gets created with an overlapping

 * DIST/REDIST (or DIST/CPUIF for GICv2). Assumption is 4 vcpus are going to be

 * used hence the overlap. In the case of GICv3, A RDIST region is set at @0x0

 * and a DIST region is set @0x70000. The GICv2 case sets a CPUIF @0x0 and a

 * DIST region @0x1000.

 CPU interface in GICv2*/

 Check existing group/attributes */

 check non existing attribute */

 misaligned DIST and REDIST address settings */

 out of range address */

 Space for half a rdist (a rdist is: 2 * rdist.alignment). */

 set REDIST base address @0x0*/

 Attempt to create a second legacy redistributor region */

 Attempt to mix legacy and new redistributor regions */

	/*

	 * Set overlapping DIST / REDIST, cannot be detected here. Will be detected

	 * on first vcpu run instead.

 Test the new REDIST region API */

 The last redist is above the pa range. */

	/*

	 * Now there are 2 redist regions:

	 * region 0 @ 0x200000 2 redists

	 * region 1 @ 0x240000 1 redist

	 * Attempt to read their characteristics

/*

 * VGIC KVM device is created and initialized before the secondary CPUs

 * get created

 Add the rest of the VCPUs */

 All the VCPUs are created before the VGIC KVM device gets initialized */

 step2 */

 step 3 */

 The 2 first rdists should be put there (vcpu 0 and 3) */

/**

 * Test GICR_TYPER last bit with new redist regions

 * rdist regions #1 and #2 are contiguous

 * rdist region #0 @0x100000 2 rdist capacity

 *     rdists: 0, 3 (Last)

 * rdist region #1 @0x240000 2 rdist capacity

 *     rdists:  5, 4 (Last)

 * rdist region #2 @0x200000 2 rdist capacity

 *     rdists: 1, 2

 Test last bit with legacy region */

 Uses the legacy REDIST region API. */

 Set space for 3 redists, we have 1 vcpu, so this succeeds. */

 Add the rest of the VCPUs */

 Attempt to run a vcpu without enough redist space. */

 This one succeeds setting the ITS base */

/*

 * Returns 0 if it's possible to create GIC device of a given type (V2 or V3).

 try to create a non existing KVM device */

 trial mode */

 try to create the other gic_dev_type */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * tools/testing/selftests/kvm/lib/elf.c

 *

 * Copyright (C) 2018, Google LLC.

 Open the ELF file. */

	/* Read in and validate ELF Identification Record.

	 * The ELF Identification record is the first 16 (EI_NIDENT) bytes

	 * of the ELF header, which is at the beginning of the ELF file.

	 * For now it is only safe to read the first EI_NIDENT bytes.  Once

	 * read and validated, the value of e_ehsize can be used to determine

	 * the real size of the ELF header.

	/* Read in the ELF header.

	 * With the ELF Identification portion of the ELF header

	 * validated, especially that the value at EI_VERSION is

	 * as expected, it is now safe to read the entire ELF header.

/* VM ELF Load

 *

 * Input Args:

 *   filename - Path to ELF file

 *

 * Output Args: None

 *

 * Input/Output Args:

 *   vm - Pointer to opaque type that describes the VM.

 *

 * Return: None, TEST_ASSERT failures for all error conditions

 *

 * Loads the program image of the ELF file specified by filename,

 * into the virtual address space of the VM pointed to by vm.  On entry

 * the VM needs to not be using any of the virtual address space used

 * by the image and it needs to have sufficient available physical pages, to

 * back the virtual pages used to load the image.

 Open the ELF file. */

 Read in the ELF header. */

	/* For each program header.

	 * The following ELF header members specify the location

	 * and size of the program headers:

	 *

	 *   e_phoff - File offset to start of program headers

	 *   e_phentsize - Size of each program header

	 *   e_phnum - Number of program header entries

 Seek to the beginning of the program header. */

 Read in the program header. */

 Skip if this header doesn't describe a loadable segment. */

 Allocate memory for this segment within the VM. */

		/* TODO(lhuemill): Set permissions of each memory segment

		 * based on the least-significant 3 bits of phdr.p_flags.

		/* Load portion of initial state that is contained within

		 * the ELF file.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * tools/testing/selftests/kvm/lib/assert.c

 *

 * Copyright (C) 2018, Google LLC.

 for getline(3) and strchrnul(3)*/

 Dumps the current stack trace to stderr. */

	/*

	 * Build and run this command:

	 *

	 *	addr2line -s -e /proc/$PPID/exe -fpai {backtrace addresses} | \

	 *		grep -v test_dump_stack | cat -n 1>&2

	 *

	 * Note that the spacing is different and there's no newline.

 N bytes per addr * 2 digits per byte + 1 space per addr: */

 Null terminator: */

	/*

	 * Skip the first 3 frames: backtrace, test_dump_stack, and

	 * test_assert. We hope that backtrace isn't inlined and the other two

	 * we've declared noinline.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * tools/testing/selftests/kvm/lib/io.c

 *

 * Copyright (C) 2018, Google LLC.

/* Test Write

 *

 * A wrapper for write(2), that automatically handles the following

 * special conditions:

 *

 *   + Interrupted system call (EINTR)

 *   + Write of less than requested amount

 *   + Non-block return (EAGAIN)

 *

 * For each of the above, an additional write is performed to automatically

 * continue writing the requested data.

 * There are also many cases where write(2) can return an unexpected

 * error (e.g. EIO).  Such errors cause a TEST_ASSERT failure.

 *

 * Note, for function signature compatibility with write(2), this function

 * returns the number of bytes written, but that value will always be equal

 * to the number of requested bytes.  All other conditions in this and

 * future enhancements to this function either automatically issue another

 * write(2) or cause a TEST_ASSERT failure.

 *

 * Args:

 *  fd    - Opened file descriptor to file to be written.

 *  count - Number of bytes to write.

 *

 * Output:

 *  buf   - Starting address of data to be written.

 *

 * Return:

 *  On success, number of bytes written.

 *  On failure, a TEST_ASSERT failure is caused.

	/* Note: Count of zero is allowed (see "RETURN VALUE" portion of

	 * write(2) manpage for details.

/* Test Read

 *

 * A wrapper for read(2), that automatically handles the following

 * special conditions:

 *

 *   + Interrupted system call (EINTR)

 *   + Read of less than requested amount

 *   + Non-block return (EAGAIN)

 *

 * For each of the above, an additional read is performed to automatically

 * continue reading the requested data.

 * There are also many cases where read(2) can return an unexpected

 * error (e.g. EIO).  Such errors cause a TEST_ASSERT failure.  Note,

 * it is expected that the file opened by fd at the current file position

 * contains at least the number of requested bytes to be read.  A TEST_ASSERT

 * failure is produced if an End-Of-File condition occurs, before all the

 * data is read.  It is the callers responsibility to assure that sufficient

 * data exists.

 *

 * Note, for function signature compatibility with read(2), this function

 * returns the number of bytes read, but that value will always be equal

 * to the number of requested bytes.  All other conditions in this and

 * future enhancements to this function either automatically issue another

 * read(2) or cause a TEST_ASSERT failure.

 *

 * Args:

 *  fd    - Opened file descriptor to file to be read.

 *  count - Number of bytes to read.

 *

 * Output:

 *  buf   - Starting address of where to write the bytes read.

 *

 * Return:

 *  On success, number of bytes read.

 *  On failure, a TEST_ASSERT failure is caused.

	/* Note: Count of zero is allowed (see "If count is zero" portion of

	 * read(2) manpage for details.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2020, Red Hat, Inc.

 Starting with z13 we have 47bits of physical address */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Sparse bit array

 *

 * Copyright (C) 2018, Google LLC.

 * Copyright (C) 2018, Red Hat, Inc. (code style cleanup and fuzzing driver)

 *

 * This library provides functions to support a memory efficient bit array,

 * with an index size of 2^64.  A sparsebit array is allocated through

 * the use sparsebit_alloc() and free'd via sparsebit_free(),

 * such as in the following:

 *

 *   struct sparsebit *s;

 *   s = sparsebit_alloc();

 *   sparsebit_free(&s);

 *

 * The struct sparsebit type resolves down to a struct sparsebit.

 * Note that, sparsebit_free() takes a pointer to the sparsebit

 * structure.  This is so that sparsebit_free() is able to poison

 * the pointer (e.g. set it to NULL) to the struct sparsebit before

 * returning to the caller.

 *

 * Between the return of sparsebit_alloc() and the call of

 * sparsebit_free(), there are multiple query and modifying operations

 * that can be performed on the allocated sparsebit array.  All of

 * these operations take as a parameter the value returned from

 * sparsebit_alloc() and most also take a bit index.  Frequently

 * used routines include:

 *

 *  ---- Query Operations

 *  sparsebit_is_set(s, idx)

 *  sparsebit_is_clear(s, idx)

 *  sparsebit_any_set(s)

 *  sparsebit_first_set(s)

 *  sparsebit_next_set(s, prev_idx)

 *

 *  ---- Modifying Operations

 *  sparsebit_set(s, idx)

 *  sparsebit_clear(s, idx)

 *  sparsebit_set_num(s, idx, num);

 *  sparsebit_clear_num(s, idx, num);

 *

 * A common operation, is to itterate over all the bits set in a test

 * sparsebit array.  This can be done via code with the following structure:

 *

 *   sparsebit_idx_t idx;

 *   if (sparsebit_any_set(s)) {

 *     idx = sparsebit_first_set(s);

 *     do {

 *       ...

 *       idx = sparsebit_next_set(s, idx);

 *     } while (idx != 0);

 *   }

 *

 * The index of the first bit set needs to be obtained via

 * sparsebit_first_set(), because sparsebit_next_set(), needs

 * the index of the previously set.  The sparsebit_idx_t type is

 * unsigned, so there is no previous index before 0 that is available.

 * Also, the call to sparsebit_first_set() is not made unless there

 * is at least 1 bit in the array set.  This is because sparsebit_first_set()

 * aborts if sparsebit_first_set() is called with no bits set.

 * It is the callers responsibility to assure that the

 * sparsebit array has at least a single bit set before calling

 * sparsebit_first_set().

 *

 * ==== Implementation Overview ====

 * For the most part the internal implementation of sparsebit is

 * opaque to the caller.  One important implementation detail that the

 * caller may need to be aware of is the spatial complexity of the

 * implementation.  This implementation of a sparsebit array is not

 * only sparse, in that it uses memory proportional to the number of bits

 * set.  It is also efficient in memory usage when most of the bits are

 * set.

 *

 * At a high-level the state of the bit settings are maintained through

 * the use of a binary-search tree, where each node contains at least

 * the following members:

 *

 *   typedef uint64_t sparsebit_idx_t;

 *   typedef uint64_t sparsebit_num_t;

 *

 *   sparsebit_idx_t idx;

 *   uint32_t mask;

 *   sparsebit_num_t num_after;

 *

 * The idx member contains the bit index of the first bit described by this

 * node, while the mask member stores the setting of the first 32-bits.

 * The setting of the bit at idx + n, where 0 <= n < 32, is located in the

 * mask member at 1 << n.

 *

 * Nodes are sorted by idx and the bits described by two nodes will never

 * overlap. The idx member is always aligned to the mask size, i.e. a

 * multiple of 32.

 *

 * Beyond a typical implementation, the nodes in this implementation also

 * contains a member named num_after.  The num_after member holds the

 * number of bits immediately after the mask bits that are contiguously set.

 * The use of the num_after member allows this implementation to efficiently

 * represent cases where most bits are set.  For example, the case of all

 * but the last two bits set, is represented by the following two nodes:

 *

 *   node 0 - idx: 0x0 mask: 0xffffffff num_after: 0xffffffffffffffc0

 *   node 1 - idx: 0xffffffffffffffe0 mask: 0x3fffffff num_after: 0

 *

 * ==== Invariants ====

 * This implementation usses the following invariants:

 *

 *   + Node are only used to represent bits that are set.

 *     Nodes with a mask of 0 and num_after of 0 are not allowed.

 *

 *   + Sum of bits set in all the nodes is equal to the value of

 *     the struct sparsebit_pvt num_set member.

 *

 *   + The setting of at least one bit is always described in a nodes

 *     mask (mask >= 1).

 *

 *   + A node with all mask bits set only occurs when the last bit

 *     described by the previous node is not equal to this nodes

 *     starting index - 1.  All such occurences of this condition are

 *     avoided by moving the setting of the nodes mask bits into

 *     the previous nodes num_after setting.

 *

 *   + Node starting index is evenly divisible by the number of bits

 *     within a nodes mask member.

 *

 *   + Nodes never represent a range of bits that wrap around the

 *     highest supported index.

 *

 *      (idx + MASK_BITS + num_after - 1) <= ((sparsebit_idx_t) 0) - 1)

 *

 *     As a consequence of the above, the num_after member of a node

 *     will always be <=:

 *

 *       maximum_index - nodes_starting_index - number_of_mask_bits

 *

 *   + Nodes within the binary search tree are sorted based on each

 *     nodes starting index.

 *

 *   + The range of bits described by any two nodes do not overlap.  The

 *     range of bits described by a single node is:

 *

 *       start: node->idx

 *       end (inclusive): node->idx + MASK_BITS + node->num_after - 1;

 *

 * Note, at times these invariants are temporarily violated for a

 * specific portion of the code.  For example, when setting a mask

 * bit, there is a small delay between when the mask bit is set and the

 * value in the struct sparsebit_pvt num_set member is updated.  Other

 * temporary violations occur when node_split() is called with a specified

 * index and assures that a node where its mask represents the bit

 * at the specified index exists.  At times to do this node_split()

 * must split an existing node into two nodes or create a node that

 * has no bits set.  Such temporary violations must be corrected before

 * returning to the caller.  These corrections are typically performed

 * by the local function node_reduce().

 Does not include indent amount */

 index of least-significant bit in mask */

 num contiguously set after mask */

	/*

	 * Points to root node of the binary search

	 * tree.  Equal to NULL when no bits are set in

	 * the entire sparsebit array.

	/*

	 * A redundant count of the total number of bits set.  Used for

	 * diagnostic purposes and to change the time complexity of

	 * sparsebit_num_set() from O(n) to O(1).

	 * Note: Due to overflow, a value of 0 means none or all set.

/* Returns the number of set bits described by the settings

 * of the node pointed to by nodep.

/* Returns a pointer to the node that describes the

 * lowest bit index.

/* Returns a pointer to the node that describes the

 * lowest bit index > the index of the node pointed to by np.

 * Returns NULL if no node with a higher index exists.

	/*

	 * If current node has a right child, next node is the left-most

	 * of the right child.

	/*

	 * No right child.  Go up until node is left child of a parent.

	 * That parent is then the next node.

/* Searches for and returns a pointer to the node that describes the

 * highest index < the index of the node pointed to by np.

 * Returns NULL if no node with a lower index exists.

	/*

	 * If current node has a left child, next node is the right-most

	 * of the left child.

	/*

	 * No left child.  Go up until node is right child of a parent.

	 * That parent is then the next node.

/* Allocates space to hold a copy of the node sub-tree pointed to by

 * subtree and duplicates the bit settings to the newly allocated nodes.

 * Returns the newly allocated copy of subtree.

 Duplicate the node at the root of the subtree */

 As needed, recursively duplicate the left and right subtrees */

/* Searches for and returns a pointer to the node that describes the setting

 * of the bit given by idx.  A node describes the setting of a bit if its

 * index is within the bits described by the mask bits or the number of

 * contiguous bits set after the mask.  Returns NULL if there is no such node.

 Find the node that describes the setting of the bit at idx */

/* Entry Requirements:

 *   + A node that describes the setting of idx is not already present.

 *

 * Adds a new node to describe the setting of the bit at the index given

 * by idx.  Returns a pointer to the newly added node.

 *

 * TODO(lhuemill): Degenerate cases causes the tree to get unbalanced.

 Allocate and initialize the new node. */

 If no nodes, set it up as the root node. */

	/*

	 * Find the parent where the new node should be attached

	 * and add the node there.

	/*

	 * Does num_after bits of previous node overlap with the mask

	 * of the new node?  If so set the bits in the new nodes mask

	 * and reduce the previous nodes num_after.

 Returns whether all the bits in the sparsebit array are set.  */

	/*

	 * If any nodes there must be at least one bit set.  Only case

	 * where a bit is set and total num set is 0, is when all bits

	 * are set.

/* Clears all bits described by the node pointed to by nodep, then

 * removes the node.

 Have both left and right child */

		/*

		 * Move left children to the leftmost leaf node

		 * of the right child.

 Left only child */

 Right only child */

 Leaf Node */

/* Splits the node containing the bit at idx so that there is a node

 * that starts at the specified index.  If no such node exists, a new

 * node at the specified index is created.  Returns the new node.

 *

 * idx must start of a mask boundary.

	/*

	 * Is there a node that describes the setting of idx?

	 * If not, add it.

	/*

	 * All done if the starting index of the node is where the

	 * split should occur.

	/*

	 * Split point not at start of mask, so it must be part of

	 * bits described by num_after.

	/*

	 * Calculate offset within num_after for where the split is

	 * to occur.

	/*

	 * Add a new node to describe the bits starting at

	 * the split point.

 Move bits after the split point into the new node */

/* Iteratively reduces the node pointed to by nodep and its adjacent

 * nodes into a more compact form.  For example, a node with a mask with

 * all bits set adjacent to a previous node, will get combined into a

 * single node with an increased num_after setting.

 *

 * After each reduction, a further check is made to see if additional

 * reductions are possible with the new previous and next nodes.  Note,

 * a search for a reduction is only done across the nodes nearest nodep

 * and those that became part of a reduction.  Reductions beyond nodep

 * and the adjacent nodes that are reduced are not discovered.  It is the

 * responsibility of the caller to pass a nodep that is within one node

 * of each possible reduction.

 *

 * This function does not fix the temporary violation of all invariants.

 * For example it does not fix the case where the bit settings described

 * by two or more nodes overlap.  Such a violation introduces the potential

 * complication of a bit setting for a specific index having different settings

 * in different nodes.  This would then introduce the further complication

 * of which node has the correct setting of the bit and thus such conditions

 * are not allowed.

 *

 * This function is designed to fix invariant violations that are introduced

 * by node_split() and by changes to the nodes mask or num_after members.

 * For example, when setting a bit within a nodes mask, the function that

 * sets the bit doesn't have to worry about whether the setting of that

 * bit caused the mask to have leading only or trailing only bits set.

 * Instead, the function can call node_reduce(), with nodep equal to the

 * node address that it set a mask bit in, and node_reduce() will notice

 * the cases of leading or trailing only bits and that there is an

 * adjacent node that the bit settings could be merged into.

 *

 * This implementation specifically detects and corrects violation of the

 * following invariants:

 *

 *   + Node are only used to represent bits that are set.

 *     Nodes with a mask of 0 and num_after of 0 are not allowed.

 *

 *   + The setting of at least one bit is always described in a nodes

 *     mask (mask >= 1).

 *

 *   + A node with all mask bits set only occurs when the last bit

 *     described by the previous node is not equal to this nodes

 *     starting index - 1.  All such occurences of this condition are

 *     avoided by moving the setting of the nodes mask bits into

 *     the previous nodes num_after setting.

 1) Potential reductions within the current node. */

 Nodes with all bits cleared may be removed. */

			/*

			 * About to remove the node pointed to by

			 * nodep, which normally would cause a problem

			 * for the next pass through the reduction loop,

			 * because the node at the starting point no longer

			 * exists.  This potential problem is handled

			 * by first remembering the location of the next

			 * or previous nodes.  Doesn't matter which, because

			 * once the node at nodep is removed, there will be

			 * no other nodes between prev and next.

			 *

			 * Note, the checks performed on nodep against both

			 * both prev and next both check for an adjacent

			 * node that can be reduced into a single node.  As

			 * such, after removing the node at nodep, doesn't

			 * matter whether the nodep for the next pass

			 * through the loop is equal to the previous pass

			 * prev or next node.  Either way, on the next pass

			 * the one not selected will become either the

			 * prev or next node.

		/*

		 * When the mask is 0, can reduce the amount of num_after

		 * bits by moving the initial num_after bits into the mask.

		/*

		 * 2) Potential reductions between the current and

		 * previous nodes.

 Nodes with no bits set can be removed. */

			/*

			 * All mask bits set and previous node has

			 * adjacent index.

			/*

			 * Is node adjacent to previous node and the node

			 * contains a single contiguous range of bits

			 * starting from the beginning of the mask?

				/*

				 * How many contiguous bits are there?

				 * Is equal to the total number of set

				 * bits, due to an earlier check that

				 * there is a single contiguous range of

				 * set bits.

				/*

				 * For predictable performance, handle special

				 * case where all mask bits are set and there

				 * is a non-zero num_after setting.  This code

				 * is functionally correct without the following

				 * conditionalized statements, but without them

				 * the value of num_after is only reduced by

				 * the number of mask bits per pass.  There are

				 * cases where num_after can be close to 2^64.

				 * Without this code it could take nearly

				 * (2^64) / 32 passes to perform the full

				 * reduction.

		/*

		 * 3) Potential reductions between the current and

		 * next nodes.

 Nodes with no bits set can be removed. */

			/*

			 * Is next node index adjacent to current node

			 * and has a mask with all bits set?

/* Returns whether the bit at the index given by idx, within the

 * sparsebit array is set or not.

 Find the node that describes the setting of the bit at idx */

 Bit is set if it is any of the bits described by num_after */

 Is the corresponding mask bit set */

/* Within the sparsebit array pointed to by s, sets the bit

 * at the index given by idx.

 Skip bits that are already set */

	/*

	 * Get a node where the bit at idx is described by the mask.

	 * The node_split will also create a node, if there isn't

	 * already a node that describes the setting of bit.

 Set the bit within the nodes mask */

/* Within the sparsebit array pointed to by s, clears the bit

 * at the index given by idx.

 Skip bits that are already cleared */

 Is there a node that describes the setting of this bit? */

	/*

	 * If a num_after bit, split the node, so that the bit is

	 * part of a node mask.

	/*

	 * After node_split above, bit at idx should be within the mask.

	 * Clear that bit.

/* Recursively dumps to the FILE stream given by stream the contents

 * of the sub-tree of nodes pointed to by nodep.  Each line of output

 * is prefixed by the number of spaces given by indent.  On each

 * recursion, the indent amount is increased by 2.  This causes nodes

 * at each level deeper into the binary search tree to be displayed

 * with a greater indent.

 Dump contents of node */

 If present, dump contents of left child nodes */

 If present, dump contents of right child nodes */

/* Dumps to the FILE stream specified by stream, the implementation dependent

 * internal state of s.  Each line of output is prefixed with the number

 * of spaces given by indent.  The output is completely implementation

 * dependent and subject to change.  Output from this function should only

 * be used for diagnostic purposes.  For example, this function can be

 * used by test cases after they detect an unexpected condition, as a means

 * to capture diagnostic information.

 Dump the contents of s */

/* Allocates and returns a new sparsebit array. The initial state

 * of the newly allocated sparsebit array has all bits cleared.

 Allocate top level structure. */

/* Frees the implementation dependent data for the sparsebit array

 * pointed to by s and poisons the pointer to that data.

/* Makes a copy of the sparsebit array given by s, to the sparsebit

 * array given by d.  Note, d must have already been allocated via

 * sparsebit_alloc().  It can though already have bits set, which

 * if different from src will be cleared.

 First clear any bits already set in the destination */

 Returns whether num consecutive bits starting at idx are all set.  */

 With num > 0, the first bit must be set. */

 Find the next cleared bit */

	/*

	 * If no cleared bits beyond idx, then there are at least num

	 * set bits. idx + num doesn't wrap.  Otherwise check if

	 * there are enough set bits between idx and the next cleared bit.

 Returns whether the bit at the index given by idx.  */

 Returns whether num consecutive bits starting at idx are all cleared.  */

 With num > 0, the first bit must be cleared. */

 Find the next set bit */

	/*

	 * If no set bits beyond idx, then there are at least num

	 * cleared bits. idx + num doesn't wrap.  Otherwise check if

	 * there are enough cleared bits between idx and the next set bit.

/* Returns the total number of bits set.  Note: 0 is also returned for

 * the case of all bits set.  This is because with all bits set, there

 * is 1 additional bit set beyond what can be represented in the return

 * value.  Use sparsebit_any_set(), instead of sparsebit_num_set() > 0,

 * to determine if the sparsebit array has any bits set.

 Returns whether any bit is set in the sparsebit array.  */

	/*

	 * Nodes only describe set bits.  If any nodes then there

	 * is at least 1 bit set.

	/*

	 * Every node should have a non-zero mask.  For now will

	 * just assure that the root node has a non-zero mask,

	 * which is a quick check that at least 1 bit is set.

 Returns whether all the bits in the sparsebit array are cleared.  */

 Returns whether all the bits in the sparsebit array are set.  */

/* Returns the index of the first set bit.  Abort if no bits are set.

 Validate at least 1 bit is set */

/* Returns the index of the first cleared bit.  Abort if

 * no bits are cleared.

 Validate at least 1 bit is cleared. */

 If no nodes or first node index > 0 then lowest cleared is 0 */

 Does the mask in the first node contain any cleared bits. */

	/*

	 * All mask bits set in first node.  If there isn't a second node

	 * then the first cleared bit is the first bit after the bits

	 * described by the first node.

		/*

		 * No second node.  First cleared bit is first bit beyond

		 * bits described by first node.

	/*

	 * There is a second node.

	 * If it is not adjacent to the first node, then there is a gap

	 * of cleared bits between the nodes, and the first cleared bit

	 * is the first bit within the gap.

	/*

	 * Second node is adjacent to the first node.

	 * Because it is adjacent, its mask should be non-zero.  If all

	 * its mask bits are set, then with it being adjacent, it should

	 * have had the mask bits moved into the num_after setting of the

	 * previous node.

/* Returns index of next bit set within s after the index given by prev.

 * Returns 0 if there are no bits after prev that are set.

 A bit after the highest index can't be set. */

	/*

	 * Find the leftmost 'candidate' overlapping or to the right

	 * of lowest_possible.

 True iff lowest_possible is within candidate */

	/*

	 * Find node that describes setting of bit at lowest_possible.

	 * If such a node doesn't exist, find the node with the lowest

	 * starting index that is > lowest_possible.

 Does the candidate node describe the setting of lowest_possible? */

		/*

		 * Candidate doesn't describe setting of bit at lowest_possible.

		 * Candidate points to the first node with a starting index

		 * > lowest_possible.

	/*

	 * Candidate describes setting of bit at lowest_possible.

	 * Note: although the node describes the setting of the bit

	 * at lowest_possible, its possible that its setting and the

	 * setting of all latter bits described by this node are 0.

	 * For now, just handle the cases where this node describes

	 * a bit at or after an index of lowest_possible that is set.

	/*

	 * Although candidate node describes setting of bit at

	 * the index of lowest_possible, all bits at that index and

	 * latter that are described by candidate are cleared.  With

	 * this, the next bit is the first bit in the next node, if

	 * such a node exists.  If a next node doesn't exist, then

	 * there is no next set bit.

/* Returns index of next bit cleared within s after the index given by prev.

 * Returns 0 if there are no bits after prev that are cleared.

 A bit after the highest index can't be set. */

	/*

	 * Does a node describing the setting of lowest_possible exist?

	 * If not, the bit at lowest_possible is cleared.

 Does a mask bit in node 1 describe the next cleared bit. */

	/*

	 * Next cleared bit is not described by node 1.  If there

	 * isn't a next node, then next cleared bit is described

	 * by bit after the bits described by the first node.

	/*

	 * There is a second node.

	 * If it is not adjacent to the first node, then there is a gap

	 * of cleared bits between the nodes, and the next cleared bit

	 * is the first bit within the gap.

	/*

	 * Second node is adjacent to the first node.

	 * Because it is adjacent, its mask should be non-zero.  If all

	 * its mask bits are set, then with it being adjacent, it should

	 * have had the mask bits moved into the num_after setting of the

	 * previous node.

/* Starting with the index 1 greater than the index given by start, finds

 * and returns the index of the first sequence of num consecutively set

 * bits.  Returns a value of 0 of no such sequence exists.

		/*

		 * Does the sequence of bits starting at idx consist of

		 * num set bits?

		/*

		 * Sequence of set bits at idx isn't large enough.

		 * Skip this entire sequence of set bits.

/* Starting with the index 1 greater than the index given by start, finds

 * and returns the index of the first sequence of num consecutively cleared

 * bits.  Returns a value of 0 of no such sequence exists.

		/*

		 * Does the sequence of bits starting at idx consist of

		 * num cleared bits?

		/*

		 * Sequence of cleared bits at idx isn't large enough.

		 * Skip this entire sequence of cleared bits.

 Sets the bits * in the inclusive range idx through idx + num - 1.  */

	/*

	 * Leading - bits before first mask boundary.

	 *

	 * TODO(lhuemill): With some effort it may be possible to

	 *   replace the following loop with a sequential sequence

	 *   of statements.  High level sequence would be:

	 *

	 *     1. Use node_split() to force node that describes setting

	 *        of idx to be within the mask portion of a node.

	 *     2. Form mask of bits to be set.

	 *     3. Determine number of mask bits already set in the node

	 *        and store in a local variable named num_already_set.

	 *     4. Set the appropriate mask bits within the node.

	 *     5. Increment struct sparsebit_pvt num_set member

	 *        by the number of bits that were actually set.

	 *        Exclude from the counts bits that were already set.

	 *     6. Before returning to the caller, use node_reduce() to

	 *        handle the multiple corner cases that this method

	 *        introduces.

 Middle - bits spanning one or more entire mask */

		/*

		 * As needed, split just after end of middle bits.

		 * No split needed if end of middle bits is at highest

		 * supported bit index.

 Delete nodes that only describe bits within the middle. */

 As needed set each of the mask bits */

 Trailing - bits at and beyond last mask boundary */

 Clears the bits * in the inclusive range idx through idx + num - 1.  */

 Leading - bits before first mask boundary */

 Middle - bits spanning one or more entire mask */

		/*

		 * As needed, split just after end of middle bits.

		 * No split needed if end of middle bits is at highest

		 * supported bit index.

 Delete nodes that only describe bits within the middle. */

 As needed clear each of the mask bits */

 Clear any bits described by num_after */

		/*

		 * Delete the node that describes the beginning of

		 * the middle bits and perform any allowed reductions

		 * with the nodes prev or next of nodep.

 Trailing - bits at and beyond last mask boundary */

 Sets the bit at the index given by idx.  */

 Clears the bit at the index given by idx.  */

 Sets the bits in the entire addressable range of the sparsebit array.  */

 Clears the bits in the entire addressable range of the sparsebit array.  */

 Determine the printf format string */

	/*

	 * When stream is NULL, just determine the size of what would

	 * have been printed, else print the range.

/* Dumps to the FILE stream given by stream, the bit settings

 * of s.  Each line of output is prefixed with the number of

 * spaces given by indent.  The length of each line is implementation

 * dependent and does not depend on the indent amount.  The following

 * is an example output of a sparsebit array that has bits:

 *

 *   0x5, 0x8, 0xa:0xe, 0x12

 *

 * This corresponds to a sparsebit whose bits 5, 8, 10, 11, 12, 13, 14, 18

 * are set.  Note that a ':', instead of a '-' is used to specify a range of

 * contiguous bits.  This is done because '-' is used to specify command-line

 * options, and sometimes ranges are specified as command-line arguments.

 Display initial indent */

 For each node */

 For each group of bits in the mask */

				/*

				 * How much room will it take to display

				 * this range.

				/*

				 * If there is not enough room, display

				 * a newline plus the indent of the next

				 * line.

 Display the range */

		/*

		 * If num_after and most significant-bit of mask is not

		 * set, then still need to display a range for the bits

		 * described by num_after.

			/*

			 * How much room will it take to display

			 * this range.

			/*

			 * If there is not enough room, display

			 * a newline plus the indent of the next

			 * line.

 Display the range */

/* Validates the internal state of the sparsebit array given by

 * s.  On error, diagnostic information is printed to stderr and

 * abort is called.

 For each node */

		/*

		 * Increase total bits set by the number of bits set

		 * in this node.

		/*

		 * Arbitrary choice as to whether a mask of 0 is allowed

		 * or not.  For diagnostic purposes it is beneficial to

		 * have only one valid means to represent a set of bits.

		 * To support this an arbitrary choice has been made

		 * to not allow a mask of zero.

		/*

		 * Validate num_after is not greater than the max index

		 * - the number of mask bits.  The num_after member

		 * uses 0-based indexing and thus has no value that

		 * represents all bits set.  This limitation is handled

		 * by requiring a non-zero mask.  With a non-zero mask,

		 * MASK_BITS worth of bits are described by the mask,

		 * which makes the largest needed num_after equal to:

		 *

		 *    (~(sparsebit_num_t) 0) - MASK_BITS + 1

 Validate node index is divisible by the mask size */

		/*

		 * Validate bits described by node don't wrap beyond the

		 * highest supported index.

 Check parent pointers. */

			/*

			 * Is index of previous node before index of

			 * current node?

			/*

			 * Nodes occur in asscending order, based on each

			 * nodes starting index.

			/*

			 * When the node has all mask bits set, it shouldn't

			 * be adjacent to the last bit described by the

			 * previous node.

		/*

		 * Is sum of bits set in each node equal to the count

		 * of total bits set.

/* A simple but effective fuzzing driver.  Look for bugs with the help

 * of some invariants and of a trivial representation of sparsebit.

 * Just use 512 bytes of /dev/zero and /dev/urandom as inputs, and let

 * afl-fuzz do the magic. :)

 SPDX-License-Identifier: GPL-2.0-only

/*

 * tools/testing/selftests/kvm/lib/test_util.c

 *

 * Copyright (C) 2020, Google LLC.

/*

 * Parses "[0-9]+[kmgt]?".

			/*

			 * No MAP_HUGETLB, we use MFD_HUGETLB instead. Since

			 * we're using "file backed" memory, we need to specify

			 * this when the FD is created, not when the area is

			 * mapped.

 Return MIN_RUN_DELAY_NS upon failure just to be safe */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2020, Google LLC.

/*

 * Guest virtual memory offset of the testing memory slot.

 * Must not conflict with identity mapped test code.

 The id of the vCPU. */

 The pthread backing the vCPU. */

 Set to true once the vCPU thread is up and running. */

 The vCPU threads involved in this test. */

 The function run by each vCPU thread, as provided by the test. */

 Set to true once all vCPU threads are up and running. */

/*

 * Continuously write to the first 8 bytes of each page in the

 * specified region.

 Make sure vCPU args data structure is not corrupt. */

 By default vCPUs will write to memory. */

	/*

	 * Snapshot the non-huge page size.  This is used by the guest code to

	 * access/dirty pages at the logging granularity.

	/*

	 * Pass guest_num_pages to populate the page tables for test memory.

	 * The memory is also added to memslot 0, but that's a benign side

	 * effect as KVM allows aliasing HVAs in meslots.

	/*

	 * If there should be more memory in the guest test region than there

	 * can be pages in the guest, it will definitely cause problems.

 Align to 1M (segment size) */

 Add extra memory slots for testing */

 Do mapping for the demand paging memory slot */

 Export the shared variables to the guest. */

	/*

	 * Wait for all vCPU threads to be up and running before calling the test-

	 * provided vCPU thread function. This prevents thread creation (which

	 * requires taking the mmap_sem in write mode) from interfering with the

	 * guest faulting in its memory.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * tools/testing/selftests/kvm/lib/kvm_util.c

 *

 * Copyright (C) 2018, Google LLC.

 for program_invocation_name */

/*

 * Open KVM_DEV_PATH if available, otherwise exit the entire program.

 *

 * Input Args:

 *   flags - The flags to pass when opening KVM_DEV_PATH.

 *

 * Return:

 *   The opened file descriptor of /dev/kvm.

/*

 * Capability

 *

 * Input Args:

 *   cap - Capability

 *

 * Output Args: None

 *

 * Return:

 *   On success, the Value corresponding to the capability (KVM_CAP_*)

 *   specified by the value of cap.  On failure a TEST_ASSERT failure

 *   is produced.

 *

 * Looks up and returns the value corresponding to the capability

 * (KVM_CAP_*) given by cap.

/* VM Enable Capability

 *

 * Input Args:

 *   vm - Virtual Machine

 *   cap - Capability

 *

 * Output Args: None

 *

 * Return: On success, 0. On failure a TEST_ASSERT failure is produced.

 *

 * Enables a capability (KVM_CAP_*) on the VM.

/* VCPU Enable Capability

 *

 * Input Args:

 *   vm - Virtual Machine

 *   vcpu_id - VCPU

 *   cap - Capability

 *

 * Output Args: None

 *

 * Return: On success, 0. On failure a TEST_ASSERT failure is produced.

 *

 * Enables a capability (KVM_CAP_*) on the VCPU.

/*

 * VM Create

 *

 * Input Args:

 *   mode - VM Mode (e.g. VM_MODE_P52V48_4K)

 *   phy_pages - Physical memory pages

 *   perm - permission

 *

 * Output Args: None

 *

 * Return:

 *   Pointer to opaque structure that describes the created VM.

 *

 * Creates a VM with the mode specified by mode (e.g. VM_MODE_P52V48_4K).

 * When phy_pages is non-zero, a memory region of phy_pages physical pages

 * is created and mapped starting at guest physical address 0.  The file

 * descriptor to control the created VM is created with the permissions

 * given by perm (e.g. O_RDWR).

 Setup mode specific traits. */

		/*

		 * Ignore KVM support for 5-level paging (vm->va_bits == 57),

		 * it doesn't take effect unless a CR4.LA57 is set, which it

		 * isn't for this VM_MODE.

 Limit to VA-bit canonical virtual addresses. */

 Limit physical addresses to PA-bits. */

 Allocate and setup memory for guest. */

/*

 * VM Create with customized parameters

 *

 * Input Args:

 *   mode - VM Mode (e.g. VM_MODE_P52V48_4K)

 *   nr_vcpus - VCPU count

 *   slot0_mem_pages - Slot0 physical memory size

 *   extra_mem_pages - Non-slot0 physical memory total size

 *   num_percpu_pages - Per-cpu physical memory pages

 *   guest_code - Guest entry point

 *   vcpuids - VCPU IDs

 *

 * Output Args: None

 *

 * Return:

 *   Pointer to opaque structure that describes the created VM.

 *

 * Creates a VM with the mode specified by mode (e.g. VM_MODE_P52V48_4K),

 * with customized slot0 memory size, at least 512 pages currently.

 * extra_mem_pages is only used to calculate the maximum page table size,

 * no real memory allocation for non-slot0 memory in this function.

 Force slot0 memory size not small than DEFAULT_GUEST_PHY_PAGES */

	/* The maximum page table size for a memory region will be when the

	 * smallest pages are used. Considering each page contains x page

	 * table descriptors, the total extra size for page tables (for extra

	 * N pages) will be: N/x+N/x^2+N/x^3+... which is definitely smaller

	 * than N/x*2.

/*

 * VM Restart

 *

 * Input Args:

 *   vm - VM that has been released before

 *   perm - permission

 *

 * Output Args: None

 *

 * Reopens the file descriptors associated to the VM and reinstates the

 * global state, such as the irqchip and the memory regions that are mapped

 * into the guest.

/*

 * Userspace Memory Region Find

 *

 * Input Args:

 *   vm - Virtual Machine

 *   start - Starting VM physical address

 *   end - Ending VM physical address, inclusive.

 *

 * Output Args: None

 *

 * Return:

 *   Pointer to overlapping region, NULL if no such region.

 *

 * Searches for a region with any physical memory that overlaps with

 * any portion of the guest physical addresses from start to end

 * inclusive.  If multiple overlapping regions exist, a pointer to any

 * of the regions is returned.  Null is returned only when no overlapping

 * region exists.

/*

 * KVM Userspace Memory Region Find

 *

 * Input Args:

 *   vm - Virtual Machine

 *   start - Starting VM physical address

 *   end - Ending VM physical address, inclusive.

 *

 * Output Args: None

 *

 * Return:

 *   Pointer to overlapping region, NULL if no such region.

 *

 * Public interface to userspace_mem_region_find. Allows tests to look up

 * the memslot datastructure for a given range of guest physical memory.

/*

 * VCPU Find

 *

 * Input Args:

 *   vm - Virtual Machine

 *   vcpuid - VCPU ID

 *

 * Output Args: None

 *

 * Return:

 *   Pointer to VCPU structure

 *

 * Locates a vcpu structure that describes the VCPU specified by vcpuid and

 * returns a pointer to it.  Returns NULL if the VM doesn't contain a VCPU

 * for the specified vcpuid.

/*

 * VM VCPU Remove

 *

 * Input Args:

 *   vcpu - VCPU to remove

 *

 * Output Args: None

 *

 * Return: None, TEST_ASSERT failures for all error conditions

 *

 * Removes a vCPU from a VM and frees its resources.

/*

 * Destroys and frees the VM pointed to by vmp.

 Free userspace_mem_regions. */

 Free sparsebit arrays. */

 Free the structure describing the VM. */

/*

 * Memory Compare, host virtual to guest virtual

 *

 * Input Args:

 *   hva - Starting host virtual address

 *   vm - Virtual Machine

 *   gva - Starting guest virtual address

 *   len - number of bytes to compare

 *

 * Output Args: None

 *

 * Input/Output Args: None

 *

 * Return:

 *   Returns 0 if the bytes starting at hva for a length of len

 *   are equal the guest virtual bytes starting at gva.  Returns

 *   a value < 0, if bytes at hva are less than those at gva.

 *   Otherwise a value > 0 is returned.

 *

 * Compares the bytes starting at the host virtual address hva, for

 * a length of len, to the guest bytes starting at the guest virtual

 * address given by gva.

	/*

	 * Compare a batch of bytes until either a match is found

	 * or all the bytes have been compared.

		/*

		 * Determine host address for guest virtual address

		 * at offset.

		/*

		 * Determine amount to compare on this pass.

		 * Don't allow the comparsion to cross a page boundary.

		/*

		 * Perform the comparison.  If there is a difference

		 * return that result to the caller, otherwise need

		 * to continue on looking for a mismatch.

	/*

	 * No mismatch found.  Let the caller know the two memory

	 * areas are equal.

/*

 * VM Userspace Memory Region Add

 *

 * Input Args:

 *   vm - Virtual Machine

 *   src_type - Storage source for this region.

 *              NULL to use anonymous memory.

 *   guest_paddr - Starting guest physical address

 *   slot - KVM region slot

 *   npages - Number of physical pages

 *   flags - KVM memory region flags (e.g. KVM_MEM_LOG_DIRTY_PAGES)

 *

 * Output Args: None

 *

 * Return: None

 *

 * Allocates a memory area of the number of pages specified by npages

 * and maps it to the VM specified by vm, at a starting physical address

 * given by guest_paddr.  The region is created with a KVM region slot

 * given by slot, which must be unique and < KVM_MEM_SLOTS_NUM.  The

 * region is created with the flags given by flags.

	/*

	 * Confirm a mem region with an overlapping address doesn't

	 * already exist.

 Confirm no region with the requested slot already exists. */

 Allocate and initialize new mem region structure. */

 On s390x, the host address must be aligned to 1M (due to PGSTEs) */

	/*

	 * When using THP mmap is not guaranteed to returned a hugepage aligned

	 * address so we have to pad the mmap. Padding is not needed for HugeTLB

	 * because mmap will always return an address aligned to the HugeTLB

	 * page size.

 Add enough memory to align up if necessary */

 Align host address */

 As needed perform madvise */

 Add to quick lookup data structures */

 If shared memory, create an alias. */

 Align host alias address */

/*

 * Memslot to region

 *

 * Input Args:

 *   vm - Virtual Machine

 *   memslot - KVM memory slot ID

 *

 * Output Args: None

 *

 * Return:

 *   Pointer to memory region structure that describe memory region

 *   using kvm memory slot ID given by memslot.  TEST_ASSERT failure

 *   on error (e.g. currently no memory region using memslot as a KVM

 *   memory slot ID).

/*

 * VM Memory Region Flags Set

 *

 * Input Args:

 *   vm - Virtual Machine

 *   flags - Starting guest physical address

 *

 * Output Args: None

 *

 * Return: None

 *

 * Sets the flags of the memory region specified by the value of slot,

 * to the values given by flags.

/*

 * VM Memory Region Move

 *

 * Input Args:

 *   vm - Virtual Machine

 *   slot - Slot of the memory region to move

 *   new_gpa - Starting guest physical address

 *

 * Output Args: None

 *

 * Return: None

 *

 * Change the gpa of a memory region.

/*

 * VM Memory Region Delete

 *

 * Input Args:

 *   vm - Virtual Machine

 *   slot - Slot of the memory region to delete

 *

 * Output Args: None

 *

 * Return: None

 *

 * Delete a memory region.

/*

 * VCPU mmap Size

 *

 * Input Args: None

 *

 * Output Args: None

 *

 * Return:

 *   Size of VCPU state

 *

 * Returns the size of the structure pointed to by the return value

 * of vcpu_state().

/*

 * VM VCPU Add

 *

 * Input Args:

 *   vm - Virtual Machine

 *   vcpuid - VCPU ID

 *

 * Output Args: None

 *

 * Return: None

 *

 * Adds a virtual CPU to the VM specified by vm with the ID given by vcpuid.

 * No additional VCPU setup is done.

 Confirm a vcpu with the specified id doesn't already exist. */

 Allocate and initialize new vcpu structure. */

 Add to linked-list of VCPUs. */

/*

 * VM Virtual Address Unused Gap

 *

 * Input Args:

 *   vm - Virtual Machine

 *   sz - Size (bytes)

 *   vaddr_min - Minimum Virtual Address

 *

 * Output Args: None

 *

 * Return:

 *   Lowest virtual address at or below vaddr_min, with at least

 *   sz unused bytes.  TEST_ASSERT failure if no area of at least

 *   size sz is available.

 *

 * Within the VM specified by vm, locates the lowest starting virtual

 * address >= vaddr_min, that has at least sz unallocated bytes.  A

 * TEST_ASSERT failure occurs for invalid input or no area of at least

 * sz unallocated bytes >= vaddr_min is available.

 Determine lowest permitted virtual page index. */

 Loop over section with enough valid virtual page indexes. */

		/*

		 * Are there enough unused virtual pages available at

		 * the currently proposed starting virtual page index.

		 * If not, adjust proposed starting index to next

		 * possible.

		/*

		 * If needed, adjust proposed starting virtual address,

		 * to next range of valid virtual addresses.

 NOT REACHED */

/*

 * VM Virtual Address Allocate

 *

 * Input Args:

 *   vm - Virtual Machine

 *   sz - Size in bytes

 *   vaddr_min - Minimum starting virtual address

 *   data_memslot - Memory region slot for data pages

 *   pgd_memslot - Memory region slot for new virtual translation tables

 *

 * Output Args: None

 *

 * Return:

 *   Starting guest virtual address

 *

 * Allocates at least sz bytes within the virtual address space of the vm

 * given by vm.  The allocated bytes are mapped to a virtual address >=

 * the address given by vaddr_min.  Note that each allocation uses a

 * a unique set of pages, with the minimum real allocation being at least

 * a page.

	/*

	 * Find an unused range of virtual page addresses of at least

	 * pages in length.

 Map the virtual pages. */

/*

 * VM Virtual Address Allocate Pages

 *

 * Input Args:

 *   vm - Virtual Machine

 *

 * Output Args: None

 *

 * Return:

 *   Starting guest virtual address

 *

 * Allocates at least N system pages worth of bytes within the virtual address

 * space of the vm.

/*

 * VM Virtual Address Allocate Page

 *

 * Input Args:

 *   vm - Virtual Machine

 *

 * Output Args: None

 *

 * Return:

 *   Starting guest virtual address

 *

 * Allocates at least one system page worth of bytes within the virtual address

 * space of the vm.

/*

 * Map a range of VM virtual address to the VM's physical address

 *

 * Input Args:

 *   vm - Virtual Machine

 *   vaddr - Virtuall address to map

 *   paddr - VM Physical Address

 *   npages - The number of pages to map

 *   pgd_memslot - Memory region slot for new virtual translation tables

 *

 * Output Args: None

 *

 * Return: None

 *

 * Within the VM given by @vm, creates a virtual translation for

 * @npages starting at @vaddr to the page range starting at @paddr.

/*

 * Address VM Physical to Host Virtual

 *

 * Input Args:

 *   vm - Virtual Machine

 *   gpa - VM physical address

 *

 * Output Args: None

 *

 * Return:

 *   Equivalent host virtual address

 *

 * Locates the memory region containing the VM physical address given

 * by gpa, within the VM given by vm.  When found, the host virtual

 * address providing the memory to the vm physical address is returned.

 * A TEST_ASSERT failure occurs if no region containing gpa exists.

/*

 * Address Host Virtual to VM Physical

 *

 * Input Args:

 *   vm - Virtual Machine

 *   hva - Host virtual address

 *

 * Output Args: None

 *

 * Return:

 *   Equivalent VM physical address

 *

 * Locates the memory region containing the host virtual address given

 * by hva, within the VM given by vm.  When found, the equivalent

 * VM physical address is returned. A TEST_ASSERT failure occurs if no

 * region containing hva exists.

/*

 * Address VM physical to Host Virtual *alias*.

 *

 * Input Args:

 *   vm - Virtual Machine

 *   gpa - VM physical address

 *

 * Output Args: None

 *

 * Return:

 *   Equivalent address within the host virtual *alias* area, or NULL

 *   (without failing the test) if the guest memory is not shared (so

 *   no alias exists).

 *

 * When vm_create() and related functions are called with a shared memory

 * src_type, we also create a writable, shared alias mapping of the

 * underlying guest memory. This allows the host to manipulate guest memory

 * without mapping that memory in the guest's address space. And, for

 * userfaultfd-based demand paging, we can do so without triggering userfaults.

/*

 * VM Create IRQ Chip

 *

 * Input Args:

 *   vm - Virtual Machine

 *

 * Output Args: None

 *

 * Return: None

 *

 * Creates an interrupt controller chip for the VM specified by vm.

/*

 * VM VCPU State

 *

 * Input Args:

 *   vm - Virtual Machine

 *   vcpuid - VCPU ID

 *

 * Output Args: None

 *

 * Return:

 *   Pointer to structure that describes the state of the VCPU.

 *

 * Locates and returns a pointer to a structure that describes the

 * state of the VCPU with the given vcpuid.

/*

 * VM VCPU Run

 *

 * Input Args:

 *   vm - Virtual Machine

 *   vcpuid - VCPU ID

 *

 * Output Args: None

 *

 * Return: None

 *

 * Switch to executing the code for the VCPU given by vcpuid, within the VM

 * given by vm.

/*

 * VM VCPU Set MP State

 *

 * Input Args:

 *   vm - Virtual Machine

 *   vcpuid - VCPU ID

 *   mp_state - mp_state to be set

 *

 * Output Args: None

 *

 * Return: None

 *

 * Sets the MP state of the VCPU given by vcpuid, to the state given

 * by mp_state.

/*

 * VM VCPU Get Reg List

 *

 * Input Args:

 *   vm - Virtual Machine

 *   vcpuid - VCPU ID

 *

 * Output Args:

 *   None

 *

 * Return:

 *   A pointer to an allocated struct kvm_reg_list

 *

 * Get the list of guest registers which are supported for

 * KVM_GET_ONE_REG/KVM_SET_ONE_REG calls

/*

 * VM VCPU Regs Get

 *

 * Input Args:

 *   vm - Virtual Machine

 *   vcpuid - VCPU ID

 *

 * Output Args:

 *   regs - current state of VCPU regs

 *

 * Return: None

 *

 * Obtains the current register state for the VCPU specified by vcpuid

 * and stores it at the location given by regs.

/*

 * VM VCPU Regs Set

 *

 * Input Args:

 *   vm - Virtual Machine

 *   vcpuid - VCPU ID

 *   regs - Values to set VCPU regs to

 *

 * Output Args: None

 *

 * Return: None

 *

 * Sets the regs of the VCPU specified by vcpuid to the values

 * given by regs.

/*

 * VM VCPU System Regs Get

 *

 * Input Args:

 *   vm - Virtual Machine

 *   vcpuid - VCPU ID

 *

 * Output Args:

 *   sregs - current state of VCPU system regs

 *

 * Return: None

 *

 * Obtains the current system register state for the VCPU specified by

 * vcpuid and stores it at the location given by sregs.

/*

 * VM VCPU System Regs Set

 *

 * Input Args:

 *   vm - Virtual Machine

 *   vcpuid - VCPU ID

 *   sregs - Values to set VCPU system regs to

 *

 * Output Args: None

 *

 * Return: None

 *

 * Sets the system regs of the VCPU specified by vcpuid to the values

 * given by sregs.

/*

 * VCPU Ioctl

 *

 * Input Args:

 *   vm - Virtual Machine

 *   vcpuid - VCPU ID

 *   cmd - Ioctl number

 *   arg - Argument to pass to the ioctl

 *

 * Return: None

 *

 * Issues an arbitrary ioctl on a VCPU fd.

/*

 * VM Ioctl

 *

 * Input Args:

 *   vm - Virtual Machine

 *   cmd - Ioctl number

 *   arg - Argument to pass to the ioctl

 *

 * Return: None

 *

 * Issues an arbitrary ioctl on a VM fd.

/*

 * KVM system ioctl

 *

 * Input Args:

 *   vm - Virtual Machine

 *   cmd - Ioctl number

 *   arg - Argument to pass to the ioctl

 *

 * Return: None

 *

 * Issues an arbitrary ioctl on a KVM fd.

/*

 * Device Ioctl

/*

 * VM Dump

 *

 * Input Args:

 *   vm - Virtual Machine

 *   indent - Left margin indent amount

 *

 * Output Args:

 *   stream - Output FILE stream

 *

 * Return: None

 *

 * Dumps the current state of the VM given by vm, to the FILE stream

 * given by stream.

 Known KVM exit reasons */

/*

 * Exit Reason String

 *

 * Input Args:

 *   exit_reason - Exit reason

 *

 * Output Args: None

 *

 * Return:

 *   Constant string pointer describing the exit reason.

 *

 * Locates and returns a constant string that describes the KVM exit

 * reason given by exit_reason.  If no such string is found, a constant

 * string of "Unknown" is returned.

/*

 * Physical Contiguous Page Allocator

 *

 * Input Args:

 *   vm - Virtual Machine

 *   num - number of pages

 *   paddr_min - Physical address minimum

 *   memslot - Memory region to allocate page from

 *

 * Output Args: None

 *

 * Return:

 *   Starting physical address

 *

 * Within the VM specified by vm, locates a range of available physical

 * pages at or above paddr_min. If found, the pages are marked as in use

 * and their base address is returned. A TEST_ASSERT failure occurs if

 * not enough pages are available at or above paddr_min.

 Arbitrary minimum physical address used for virtual translation tables. */

/*

 * Address Guest Virtual to Host Virtual

 *

 * Input Args:

 *   vm - Virtual Machine

 *   gva - VM virtual address

 *

 * Output Args: None

 *

 * Return:

 *   Equivalent host virtual address

/*

 * Is Unrestricted Guest

 *

 * Input Args:

 *   vm - Virtual Machine

 *

 * Output Args: None

 *

 * Return: True if the unrestricted guest is set to 'Y', otherwise return false.

 *

 * Check if the unrestricted guest flag is enabled.

 Ensure that the KVM vendor-specific module is loaded. */

 SPDX-License-Identifier: GPL-2.0

/*

 * ucall support. A ucall is a "hypercall to userspace".

 *

 * Copyright (C) 2018, Red Hat, Inc.

	/*

	 * Find an address within the allowed physical and virtual address

	 * spaces, that does _not_ have a KVM memory region associated with

	 * it. Identity mapping an address like this allows the guest to

	 * access it, but as KVM doesn't know what to do with it, it

	 * will assume it's something userspace handles and exit with

	 * KVM_EXIT_MMIO. Well, at least that's how it works for AArch64.

	 * Here we start with a guess that the addresses around 5/8th

	 * of the allowed space are unmapped and then work both down and

	 * up from there in 1/16th allowed space sized steps.

	 *

	 * Note, we need to use VA-bits - 1 when calculating the allowed

	 * virtual address space for an identity mapping because the upper

	 * half of the virtual address space is the two's complement of the

	 * lower and won't match physical addresses.

 SPDX-License-Identifier: GPL-2.0

/*

 * ARM64 Spinlock support

 SPDX-License-Identifier: GPL-2.0

/*

 * ARM Generic Interrupt Controller (GIC) v3 support

 1s */

 1s */

 We should not be reaching here */

 We care about 'cpu' only for SGIs or PPIs */

 1s */

 Wait until the processor is 'active' */

 Align all the redistributors sequentially */

	/*

	 * Mark all the SGI and PPI interrupts as non-secure Group-1.

	 * Also, deactivate and disable them.

 Set a default priority for all the SGIs and PPIs */

 Enable the GIC system register (ICC_*) access */

 Set a default priority threshold */

 Enable non-secure Group-1 interrupts */

 Disable the distributor until we set things up */

	/*

	 * Mark all the SPI interrupts as non-secure Group-1.

	 * Also, deactivate and disable them.

 Set a default priority for all the SPIs */

 Wait for the settings to sync-in */

 Finally, enable the distributor globally with ARE */

	/*

	 * Initialize only the distributor for now.

	 * The redistributor and CPU interfaces are initialized

	 * later for every PE.

 SPDX-License-Identifier: GPL-2.0

/*

 * AArch64 code

 *

 * Copyright (C) 2018, Red Hat, Inc.

 fall through */

 fall through */

 Access Flag */;

 NORMAL (See DEFAULT_MAIR_EL1) */

 fall through */

 fall through */

	/*

	 * Enable FP/ASIMD to avoid trapping when accessing Q0-Q15

	 * registers, which the variable argument list macros do.

 TG0 = 64KB */

 IPS = 52 bits */

 TG0 = 4KB */

 IPS = 48 bits */

 TG0 = 64KB */

 IPS = 48 bits */

 TG0 = 4KB */

 IPS = 40 bits */

 TG0 = 64KB */

 IPS = 40 bits */

 M | C | I */;

 TCR_EL1 |= IRGN0:WBWA | ORGN0:WBWA | SH0:Inner-Shareable */;

 T0SZ */;

 valid_ec */ {

 SPDX-License-Identifier: GPL-2.0

/*

 * ARM Generic Interrupt Controller (GIC) v3 host support

/*

 * vGIC-v3 default host setup

 *

 * Input args:

 *	vm - KVM VM

 *	nr_vcpus - Number of vCPUs supported by this VM

 *	gicd_base_gpa - Guest Physical Address of the Distributor region

 *	gicr_base_gpa - Guest Physical Address of the Redistributor region

 *

 * Output args: None

 *

 * Return: GIC file-descriptor or negative error code upon failure

 *

 * The function creates a vGIC-v3 device and maps the distributor and

 * redistributor regions of the guest. Since it depends on the number of

 * vCPUs for the VM, it must be called after all the vCPUs have been created.

	/*

	 * Make sure that the caller is infact calling this

	 * function after all the vCPUs are added.

 Distributor setup */

 Redistributor setup */

 SPDX-License-Identifier: GPL-2.0

/*

 * ARM Generic Interrupt Controller (GIC) support

 Distributor initialization is needed only once per VM */

 Make sure that the initialized data is visible to all the vCPUs */

 SPDX-License-Identifier: GPL-2.0

/*

 * ucall support. A ucall is a "hypercall to userspace".

 *

 * Copyright (C) 2018, Red Hat, Inc.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * tools/testing/selftests/kvm/lib/x86_64/processor.c

 *

 * Copyright (C) 2021, Google LLC.

 Per SDM: to enable xAPIC when in x2APIC must first disable APIC */

	/*

	 * Per SDM: reset value of spurious interrupt vector register has the

	 * APIC software enabled bit=0. It must be enabled in addition to the

	 * enable bit in the MSR.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * tools/testing/selftests/kvm/lib/x86_64/svm.c

 * Helpers used for nested SVM testing

 * Largely inspired from KVM unit test svm.c

 *

 * Copyright (C) 2020, Red Hat, Inc.

/* Allocate memory regions for nested SVM tests.

 *

 * Input Args:

 *   vm - The VM to allocate guest-virtual addresses in.

 *

 * Output Args:

 *   p_svm_gva - The guest virtual address for the struct svm_test_data.

 *

 * Return:

 *   Pointer to structure with the addresses of the SVM areas.

/*

 * Avoid using memset to clear the vmcb, since libc may not be

 * available in L1 (and, even if it is, features that libc memset may

 * want to use, like AVX, may not be enabled).

/*

 * save/restore 64-bit general registers except rax, rip, rsp

 * which are directly handed through the VMCB guest processor state

/*

 * selftests do not use interrupts so we dropped clgi/sti/cli/stgi

 * for now. registers involved in LOAD/SAVE_GPR_C are eventually

 * unmodified so they do not need to be in the clobber list.

 rflags

 rax

 rflags

 rax

/*

 * Open SEV_DEV_PATH if available, otherwise exit the entire program.

 *

 * Return:

 *   The opened file descriptor of /dev/sev.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * tools/testing/selftests/kvm/lib/x86_64/processor.c

 *

 * Copyright (C) 2018, Google LLC.

 Virtual translation table structure declarations */

/*

 * Segment Dump

 *

 * Input Args:

 *   stream  - Output FILE stream

 *   segment - KVM segment

 *   indent  - Left margin indent amount

 *

 * Output Args: None

 *

 * Return: None

 *

 * Dumps the state of the KVM segment given by @segment, to the FILE stream

 * given by @stream.

/*

 * dtable Dump

 *

 * Input Args:

 *   stream - Output FILE stream

 *   dtable - KVM dtable

 *   indent - Left margin indent amount

 *

 * Output Args: None

 *

 * Return: None

 *

 * Dumps the state of the KVM dtable given by @dtable, to the FILE stream

 * given by @stream.

 If needed, create page map l4 table. */

		/*

		 * Entry already present.  Assert that the caller doesn't want

		 * a hugepage at this level, and that there isn't a hugepage at

		 * this level.

	/*

	 * Allocate upper level page tables, if not already present.  Return

	 * early if a hugepage was created.

 Fill in page table entry. */

 Set the bottom 52 bits. */

 Clear the bottom bits of the reserved mask. */

	/*

	 * SDM vol 3, fig 4-11 "Formats of CR3 and Paging-Structure Entries

	 * with 4-Level Paging and 5-Level Paging".

	 * If IA32_EFER.NXE = 0 and the P flag of a paging-structure entry is 1,

	 * the XD flag (bit 63) is reserved.

	/*

	 * Based on the mode check above there are 48 bits in the vaddr, so

	 * shift 16 to sign extend the last bit (bit-47),

/*

 * Set Unusable Segment

 *

 * Input Args: None

 *

 * Output Args:

 *   segp - Pointer to segment register

 *

 * Return: None

 *

 * Sets the segment register pointed to by @segp to an unusable state.

/*

 * Set Long Mode Flat Kernel Code Segment

 *

 * Input Args:

 *   vm - VM whose GDT is being filled, or NULL to only write segp

 *   selector - selector value

 *

 * Output Args:

 *   segp - Pointer to KVM segment

 *

 * Return: None

 *

 * Sets up the KVM segment pointed to by @segp, to be a code segment

 * with the selector value given by @selector.

 kTypeCodeData */

	segp->type = 0x08 | 0x01 | 0x02; /* kFlagCode | kFlagCodeAccessed

					  * | kFlagCodeReadable

/*

 * Set Long Mode Flat Kernel Data Segment

 *

 * Input Args:

 *   vm - VM whose GDT is being filled, or NULL to only write segp

 *   selector - selector value

 *

 * Output Args:

 *   segp - Pointer to KVM segment

 *

 * Return: None

 *

 * Sets up the KVM segment pointed to by @segp, to be a data segment

 * with the selector value given by @selector.

 kTypeCodeData */

	segp->type = 0x00 | 0x01 | 0x02; /* kFlagData | kFlagDataAccessed

					  * | kFlagDataWritable

 Set mode specific system register values. */

 Create VCPU */

 Setup guest general purpose registers */

 Setup the MP state */

/*

 * Allocate an instance of struct kvm_cpuid2

 *

 * Input Args: None

 *

 * Output Args: None

 *

 * Return: A pointer to the allocated struct. The caller is responsible

 * for freeing this struct.

 *

 * Since kvm_cpuid2 uses a 0-length array to allow a the size of the

 * array to be decided at allocation time, allocation is slightly

 * complicated. This function uses a reasonable default length for

 * the array and performs the appropriate allocation.

/*

 * KVM Supported CPUID Get

 *

 * Input Args: None

 *

 * Output Args:

 *

 * Return: The supported KVM CPUID

 *

 * Get the guest CPUID supported by KVM.

/*

 * KVM Get MSR

 *

 * Input Args:

 *   msr_index - Index of MSR

 *

 * Output Args: None

 *

 * Return: On success, value of the MSR. On failure a TEST_ASSERT is produced.

 *

 * Get value of MSR for VCPU.

/*

 * VM VCPU CPUID Set

 *

 * Input Args:

 *   vm - Virtual Machine

 *   vcpuid - VCPU id

 *

 * Output Args: None

 *

 * Return: KVM CPUID (KVM_GET_CPUID2)

 *

 * Set the VCPU's CPUID.

/*

 * Locate a cpuid entry.

 *

 * Input Args:

 *   function: The function of the cpuid entry to find.

 *   index: The index of the cpuid entry.

 *

 * Output Args: None

 *

 * Return: A pointer to the cpuid entry. Never returns NULL.

/*

 * VM VCPU CPUID Set

 *

 * Input Args:

 *   vm - Virtual Machine

 *   vcpuid - VCPU id

 *   cpuid - The CPUID values to set.

 *

 * Output Args: None

 *

 * Return: void

 *

 * Set the VCPU's CPUID.

/*

 * VCPU Get MSR

 *

 * Input Args:

 *   vm - Virtual Machine

 *   vcpuid - VCPU ID

 *   msr_index - Index of MSR

 *

 * Output Args: None

 *

 * Return: On success, value of the MSR. On failure a TEST_ASSERT is produced.

 *

 * Get value of MSR for VCPU.

/*

 * _VCPU Set MSR

 *

 * Input Args:

 *   vm - Virtual Machine

 *   vcpuid - VCPU ID

 *   msr_index - Index of MSR

 *   msr_value - New value of MSR

 *

 * Output Args: None

 *

 * Return: The result of KVM_SET_MSRS.

 *

 * Sets the value of an MSR for the given VCPU.

/*

 * VCPU Set MSR

 *

 * Input Args:

 *   vm - Virtual Machine

 *   vcpuid - VCPU ID

 *   msr_index - Index of MSR

 *   msr_value - New value of MSR

 *

 * Output Args: None

 *

 * Return: On success, nothing. On failure a TEST_ASSERT is produced.

 *

 * Set value of MSR for VCPU.

	/*

	 * When KVM exits to userspace with KVM_EXIT_IO, KVM guarantees

	 * guest state is consistent only after userspace re-enters the

	 * kernel with KVM_RUN.  Complete IO prior to migrating state

	 * to a new VM.

 output */ "=a"(eax), "=b"(ebx),

 input */ "0"(leaf), "2"(0));

 SDM 4.1.4 */

 Handlers have the same address in both address spaces.*/

 Need to skip KVM CPUID leaves 0x400000xx */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * tools/testing/selftests/kvm/lib/x86_64/vmx.c

 *

 * Copyright (C) 2018, Google LLC.

 KVM should return supported EVMCS version range */

/* Allocate memory regions for nested VMX tests.

 *

 * Input Args:

 *   vm - The VM to allocate guest-virtual addresses in.

 *

 * Output Args:

 *   p_vmx_gva - The guest virtual address for the struct vmx_pages.

 *

 * Return:

 *   Pointer to structure with the addresses of the VMX areas.

 Setup of a region of guest memory for the vmxon region. */

 Setup of a region of guest memory for a vmcs. */

 Setup of a region of guest memory for the MSR bitmap. */

 Setup of a region of guest memory for the shadow VMCS. */

 Setup of a region of guest memory for the VMREAD and VMWRITE bitmaps. */

 Setup of a region of guest memory for the VP Assist page. */

 Setup of a region of guest memory for the enlightened VMCS. */

	/*

	 * Ensure bits in CR0 and CR4 are valid in VMX operation:

	 * - Bit X is 1 in _FIXED0: bit X is fixed to 1 in CRx.

	 * - Bit X is 0 in _FIXED1: bit X is fixed to 0 in CRx.

 Enable VMX operation */

	/*

	 * Configure IA32_FEATURE_CONTROL MSR to allow VMXON:

	 *  Bit 0: Lock bit. If clear, VMXON causes a #GP.

	 *  Bit 2: Enables VMXON outside of SMX operation. If clear, VMXON

	 *    outside of SMX causes a #GP.

 Enter VMX root operation. */

 Load a VMCS. */

 Setup shadow VMCS, do not load it yet. */

/*

 * Initialize the control fields to the most basic settings possible.

 + 1 */

 Never match */

 64-bit host */

 64-bit guest */

/*

 * Initialize the host state fields based on the current host state, with

 * the exception of HOST_RSP and HOST_RIP, which should be set by vmlaunch

 * or vmresume.

/*

 * Initialize the guest state fields essentially as a clone of

 * the host state fields. Some host state fields have fixed

 * values, and we set the corresponding guest state fields accordingly.

 Allocate page directory pointer table if not present. */

 Allocate page directory table if not present. */

 Allocate page table if not present. */

 Fill in page table entry. */

	/*

	 * For now mark these as accessed and dirty because the only

	 * testcase we have needs that.  Can be reconsidered later.

/*

 * Map a range of EPT guest physical addresses to the VM's physical address

 *

 * Input Args:

 *   vm - Virtual Machine

 *   nested_paddr - Nested guest physical address to map

 *   paddr - VM Physical Address

 *   size - The size of the range to map

 *   eptp_memslot - Memory region slot for new virtual translation tables

 *

 * Output Args: None

 *

 * Return: None

 *

 * Within the VM given by vm, creates a nested guest translation for the

 * page range starting at nested_paddr to the page range starting at paddr.

/* Prepare an identity extended page table that maps all the

 * physical pages in VM.

 SPDX-License-Identifier: GPL-2.0

/*

 * ucall support. A ucall is a "hypercall to userspace".

 *

 * Copyright (C) 2019 Red Hat, Inc.

 Exit via DIAGNOSE 0x501 (normally used for breakpoints) */

 0x83 means DIAGNOSE */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Test handler for the s390x DIAGNOSE 0x0318 instruction.

 *

 * Copyright (C) 2020, IBM

/*

 * The DIAGNOSE 0x0318 instruction call must be handled via userspace. As such,

 * we create an ad-hoc VM here to handle the instruction then extract the

 * necessary data. It is up to the caller to decide what to do with that data.

	/*

	 * If KVM does not support diag318, then return 0 to

	 * ensure tests do not break.

	/*

	 * If a test has previously requested the diag318 info,

	 * then don't bother spinning up a temporary VM again.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * KVM selftest s390x library code - CPU-related functions (page tables...)

 *

 * Copyright (C) 2019, Red Hat, Inc.

/*

 * Allocate 4 pages for a region/segment table (ri < 4), or one page for

 * a page table (ri == 4). Returns a suitable region/segment table entry

 * which points to the freshly allocated pages.

 Walk through region and segment tables */

 Fill in page table entry */

 page index */

 page index */

 Setup guest registers */

 Enable floating point regs */

 Primary region table */

 DAT enabled + 64 bit mode */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * vmx_apic_access_test

 *

 * Copyright (C) 2020, Google LLC.

 *

 * This work is licensed under the terms of the GNU GPL, version 2.

 *

 * The first subtest simply checks to see that an L2 guest can be

 * launched with a valid APIC-access address that is backed by a

 * page of L1 physical memory.

 *

 * The second subtest sets the APIC-access address to a (valid) L1

 * physical address that is not backed by memory. KVM can't handle

 * this situation, so resuming L2 should result in a KVM exit for

 * internal error (emulation). This is not an architectural

 * requirement. It is just a shortcoming of KVM. The internal error

 * is unfortunate, but it's better than what used to happen!

 The virtual machine object. */

 Exit to L1 */

 Prepare the VMCS for L2 execution. */

 Try to launch L2 with the memory-backed APIC-access address. */

 Try to resume L2 with the unbacked APIC-access address. */

 NOT REACHED */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * svm_vmcall_test

 *

 * Copyright (C) 2020, Red Hat, Inc.

 *

 * Nested SVM testing: VMCALL

 Prepare for L2 execution. */

 NOT REACHED */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2018, Red Hat, Inc.

 *

 * Tests for SMM.

 for program_invocation_short_name */

/*

 * This is compiled as normal 64-bit code, however, SMI handler is executed

 * in real-address mode. To stay simple we're limiting ourselves to a mode

 * independent subset of asm here.

 * SMI handler always report back fixed stage SMRAM_STAGE.

 mov $SMRAM_STAGE, %al */

 in $SYNC_PORT, %al */

 rsm */

 Stages 8-11 are eaten by SMM (SMRAM_STAGE reported instead) */

 Create VM */

		/*

		 * Enter SMM during L2 execution and check that we correctly

		 * return from it. Do not perform save/restore while in SMM yet.

		/*

		 * Perform save/restore while the guest is in SMM triggered

		 * during L2 execution.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2021, Google LLC.

 *

 * Tests for adjusting the KVM clock from userspace

 SPDX-License-Identifier: GPL-2.0-only

/*

 * vmx_nested_tsc_scaling_test

 *

 * Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.

 *

 * This test case verifies that nested TSC scaling behaves as expected when

 * both L1 and L2 are scaled using different ratios. For this test we scale

 * L1 down and scale L2 up.

 L2 is scaled up (from L1's perspective) by this factor */

/*

 * This function checks whether the "actual" TSC frequency of a guest matches

 * its expected frequency. In order to account for delays in taking the TSC

 * measurements, a difference of 1% between the actual and the expected value

 * is tolerated.

	/*

	 * Reading the TSC twice with about a second's difference should give

	 * us an approximation of the TSC frequency from the guest's

	 * perspective. Now, this won't be completely accurate, but it should

	 * be good enough for the purposes of this test.

 exit to L1 */

 check that L1's frequency looks alright before launching L2 */

 prepare the VMCS for L2 execution */

 enable TSC offsetting and TSC scaling for L2 */

 launch L2 */

 check that L1's frequency still looks good */

	/*

	 * We set L1's scale factor to be a random number from 2 to 10.

	 * Ideally we would do the same for L2's factor but that one is

	 * referenced by both main() and l1_guest_code() and using a global

	 * variable does not work.

 scale down L1's TSC frequency */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2021, Red Hat Inc.

 *

 * Generic tests for KVM CPUID set/get ioctls

 CPUIDs known to differ */

	/*

	 * These entries depend on the vCPU's XCR0 register and IA32_XSS MSR,

	 * which are not controlled for by this test.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * xen_vmcall_test

 *

 * Copyright  2020 Amazon.com, Inc. or its affiliates.

 *

 * Userspace hypercall testing

 First a direct invocation of 'vmcall' */

 Fill in the Xen hypercall page */

 Set Hyper-V Guest OS ID */

 Hyper-V hypercall page */

 Invoke a Xen hypercall */

 Invoke a Hyper-V hypercall */

 code */

 ingpa (badly aligned) */

 Map a region for the hypercall pages */

 NOT REACHED */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * KVM_SET_SREGS tests

 *

 * Copyright (C) 2018, Google LLC.

 *

 * This is a regression test for the bug fixed by the following commit:

 * d3802286fa0f ("kvm: x86: Disallow illegal IA32_APIC_BASE MSR values")

 *

 * That bug allowed a user-mode program that called the KVM_SET_SREGS

 * ioctl to put a VCPU's local APIC into an invalid state.

 for program_invocation_short_name */

 Skip the sub-test, the feature is supported. */

 Sanity check that KVM didn't change anything. */

 Tell stdout not to buffer its content */

	/*

	 * Create a dummy VM, specifically to avoid doing KVM_SET_CPUID2, and

	 * use it to verify all supported CR4 bits can be set prior to defining

	 * the vCPU model, i.e. without doing KVM_SET_CPUID2.

 Verify all unsupported features are rejected by KVM. */

 Create a "real" VM and verify APIC_BASE can be set. */

 SPDX-License-Identifier: GPL-2.0

/*

 * KVM guest debug register tests

 *

 * Copyright (C) 2020, Red Hat, Inc.

 For testing data access debug BP */

 Create a pending interrupt on current vCPU */

	/*

	 * Software BP tests.

	 *

	 * NOTE: sw_bp need to be before the cmd here, because int3 is an

	 * exception rather than a normal trap for KVM_SET_GUEST_DEBUG (we

	 * capture it using the vcpu exception bitmap).

 Hardware instruction BP test */

 Hardware data BP test */

	/*

	 * Single step test, covers 2 basic instructions and 2 emulated

	 *

	 * Enable interrupts during the single stepping to see that

	 * pending interrupt we raised is not handled due to KVM_GUESTDBG_BLOCKIRQ

 DR6.BD test */

 Instruction lengths starting at ss_start */

 sti*/

 xor */

 cpuid */

 mov */

 rdmsr */

 cli */

 Test software BPs - int3 */

 Test instruction HW BP over DR[0-3] */

 Skip "nop" */

 Test data access HW BP over DR[0-3] */

 Rollback the 4-bytes "mov" */

 Skip the 4-bytes "mov" */

 Test single step */

 Finally test global disable */

 Disable all debug controls, run to the end */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2020, Google LLC.

 *

 * Tests for KVM paravirtual feature disablement

/*

 * KVM paravirtual msrs to test. Expect a #GP if any of these msrs are read or

 * written, as the KVM_CPUID_FEATURES leaf is cleared.

/*

 * KVM hypercalls to test. Expect -KVM_ENOSYS when called, as the corresponding

 * features have been cleared in KVM_CPUID_FEATURES.

 SPDX-License-Identifier: GPL-2.0-only

 Initial migration from the src to the first dst. */

 Migrate the guest back to the original VM. */

 es= */ false);

 es= */ false);

 es= */ true);

 es= */ false);

 es= */ true);

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2021, Red Hat, Inc.

 *

 * Tests for Hyper-V clocksources

 Simplified mul_u64_u64_shr() */

 First, check MSR-based clocksource */

 HV_X64_MSR_TIME_REF_COUNT is in 100ns */

 1% tolerance */

 Compare TSC page clocksource with HV_X64_MSR_TIME_REF_COUNT */

 10 ms tolerance */

 Set Guest OS id to enable Hyper-V emulation */

 Set up TSC page is disabled state, check that it's clean */

 Set up TSC page is enabled state */

 Call KVM_SET_CLOCK from userspace, check that TSC page was updated */

 Sanity check TSC page timestamp, it should be close to 0 */

	/*

	 * Enable Re-enlightenment and check that TSC page stays constant across

	 * KVM_SET_CLOCK.

	/*

	 * Disable re-enlightenment and TSC page, check that KVM doesn't update

	 * it anymore.

 First, check MSR-based clocksource */

 HV_X64_MSR_TIME_REF_COUNT is in 100ns */

 1% tolerance */

 NOT REACHED */

 Keep in sync with guest_main() */

 Reset kvmclock triggering TSC page update */

 SPDX-License-Identifier: GPL-2.0

/*

 * Tests for MSR_IA32_TSC and MSR_IA32_TSC_ADJUST.

 *

 * Copyright (C) 2020, Red Hat, Inc.

 Guest: writes to MSR_IA32_TSC affect both MSRs.  */

 Guest: writes to MSR_IA32_TSC_ADJUST affect both MSRs.  */

 Host: setting the TSC offset.  */

	/*

	 * Guest: writes to MSR_IA32_TSC_ADJUST do not destroy the

	 * host-side offset and affect both MSRs.

	/*

	 * Guest: writes to MSR_IA32_TSC affect both MSRs, so the host-side

	 * offset is now visible in MSR_IA32_TSC_ADJUST.

 Guest: writes to MSR_IA32_TSC affect both MSRs.  */

 Guest: writes to MSR_IA32_TSC_ADJUST affect both MSRs.  */

	/*

	 * Host: writes to MSR_IA32_TSC set the host-side offset

	 * and therefore do not change MSR_IA32_TSC_ADJUST.

 Host: writes to MSR_IA32_TSC_ADJUST do not modify the TSC.  */

 Restore previous value.  */

	/*

	 * Guest: writes to MSR_IA32_TSC_ADJUST do not destroy the

	 * host-side offset and affect both MSRs.

	/*

	 * Guest: writes to MSR_IA32_TSC affect both MSRs, so the host-side

	 * offset is now visible in MSR_IA32_TSC_ADJUST.

 SPDX-License-Identifier: GPL-2.0

/*

 * Test for x86 KVM_CAP_MSR_PLATFORM_INFO

 *

 * Copyright (C) 2018, Google LLC.

 *

 * This work is licensed under the terms of the GNU GPL, version 2.

 *

 * Verifies expected behavior of controlling guest access to

 * MSR_PLATFORM_INFO.

 for program_invocation_short_name */

 Tell stdout not to buffer its content */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * svm_vmcall_test

 *

 * Copyright  2021 Amazon.com, Inc. or its affiliates.

 *

 * Xen shared_info / pvclock testing

 32 bytes */

 sizeof(vcpu_info_t) == 64 */

 64 bytes (x86) */

 Trigger an interrupt injection */

 Test having the host set runstates manually */

 Test runstate time adjust */

 Test runstate time set */

 sched_yield() should result in some 'runnable' time */

 Map a region for the shared_info page */

 NOT REACHED */

 Yield until scheduler delay exceeds target */

	/*

	 * Just a *really* basic check that things are being put in the

	 * right place. The actual calculations are much the same for

	 * Xen as they are for the KVM variants, so no need to check.

		/*

		 * Fetch runstate and check sanity. Strictly speaking in the

		 * general case we might not expect the numbers to be identical

		 * but in this case we know we aren't running the vCPU any more.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2018, Red Hat, Inc.

 *

 * Tests for Enlightened VMCS, including nested guest state.

 for program_invocation_short_name */

 VMLAUNCH */

 Forced exit to L1 upon restore */

 Done, exit to L1 and never come back.  */

	/*

	 * NMI forces L2->L1 exit, resuming L2 and hope that EVMCS is

	 * up-to-date (RIP points where it should and not at the beginning

	 * of l2_guest_code(). GUEST_SYNC(9) checkes that.

 Try enlightened vmptrld with an incorrect GPA */

 Restore state in a new VM.  */

 Create VM */

 NOT REACHED */

 UCALL_SYNC is handled here.  */

 Force immediate L2->L1 exit before resuming */

		/*

		 * Do KVM_GET_NESTED_STATE/KVM_SET_NESTED_STATE for a freshly

		 * restored VM (before the first KVM_RUN) to check that

		 * KVM_STATE_NESTED_EVMCS is not lost.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Test for x86 KVM_CAP_SYNC_REGS

 *

 * Copyright (C) 2018, Google LLC.

 *

 * Verifies expected behavior of x86 KVM_CAP_SYNC_REGS functionality,

 * including requesting an invalid register set, updates to/from values

 * in kvm_run.s.regs when kvm_valid_regs and kvm_dirty_regs are toggled.

 for program_invocation_short_name */

/*

 * ucall is embedded here to protect against compiler reshuffling registers

 * before calling a function. In this test we only need to get KVM_EXIT_IO

 * vmexit and preserve RBX, no additional information is needed.

 Tell stdout not to buffer its content */

 Create VM */

 Request reading invalid register set from VCPU. */

 Request setting invalid register set into VCPU. */

 Request and verify all valid register sets. */

 TODO: BUILD TIME CHECK: TEST_ASSERT(KVM_SYNC_X86_NUM_FIELDS != 3); */

 Set and verify various register values. */

 TODO run->s.regs.events.XYZ = ABC; */

	/* Clear kvm_dirty_regs bits, verify new s.regs values are

	 * overwritten with existing guest values.

	/* Clear kvm_valid_regs bits and kvm_dirty_bits.

	 * Verify s.regs values are not overwritten with existing guest values

	 * and that guest values are not overwritten with kvm_sync_regs values.

	/* Clear kvm_valid_regs bits. Verify s.regs values are not overwritten

	 * with existing guest values but that guest values are overwritten

	 * with kvm_sync_regs values.

 SPDX-License-Identifier: GPL-2.0

/*

 * Test that KVM_SET_BOOT_CPU_ID works as intended

 *

 * Copyright (C) 2020, Red Hat, Inc.

 for program_invocation_name */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2019, Google LLC.

 *

 * Tests for the IA32_XSS MSR.

 for program_invocation_short_name */

 Create VM */

	/*

	 * At present, KVM only supports a guest IA32_XSS value of 0. Verify

	 * that trying to set the guest IA32_XSS to an unsupported value fails.

	 * Also, in the future when a non-zero value succeeds check that

	 * IA32_XSS is in the KVM_GET_MSR_INDEX_LIST.

 SPDX-License-Identifier: GPL-2.0

/*

 * xapic_ipi_test

 *

 * Copyright (C) 2020, Google LLC.

 *

 * This work is licensed under the terms of the GNU GPL, version 2.

 *

 * Test that when the APIC is in xAPIC mode, a vCPU can send an IPI to wake

 * another vCPU that is halted when KVM's backing page for the APIC access

 * address has been moved by mm.

 *

 * The test starts two vCPUs: one that sends IPIs and one that continually

 * executes HLT. The sender checks that the halter has woken from the HLT and

 * has reentered HLT before sending the next IPI. While the vCPUs are running,

 * the host continually calls migrate_pages to move all of the process' pages

 * amongst the available numa nodes on the machine.

 *

 * Migration is a command line option. When used on non-numa machines will 

 * exit with error. Test is still usefull on non-numa for testing IPIs.

 for program_invocation_short_name */

 Default running time for the test */

 Default delay between migrate_pages calls (microseconds) */

/*

 * Vector for IPI from sender vCPU to halting vCPU.

 * Value is arbitrary and was chosen for the alternating bit pattern. Any

 * value should work.

/*

 * Incremented in the IPI handler. Provides evidence to the sender that the IPI

 * arrived at the destination

 Data struct shared between host main thread and vCPUs */

	/*

	 *  Record local version register as a cross-check that APIC access

	 *  worked. Value should match what KVM reports (APIC_VERSION in

	 *  arch/x86/kvm/lapic.c). If test is failing, check that values match

	 *  to determine whether APIC access exits are working.

 host address of ipis_rcvd global */

	/*

	 * Loop forever HLTing and recording halts & wakes. Disable interrupts

	 * each time around to minimize window between signaling the pending

	 * halt to the sender vCPU and executing the halt. No need to disable on

	 * first run as this vCPU executes first and the host waits for it to

	 * signal going into first halt before starting the sender vCPU. Record

	 * TPR and PPR for diagnostic purposes in case the test fails.

/*

 * Runs on halter vCPU when IPI arrives. Write an arbitrary non-zero value to

 * enable diagnosing errant writes to the APIC access address backing page in

 * case of test failure.

	/*

	 * Init interrupt command register for sending IPIs

	 *

	 * Delivery mode=fixed, per SDM:

	 *   "Delivers the interrupt specified in the vector field to the target

	 *    processor."

	 *

	 * Destination mode=physical i.e. specify target by its local APIC

	 * ID. This vCPU assumes that the halter vCPU has already started and

	 * set data->halter_apic_id.

		/*

		 * Send IPI to halter vCPU.

		 * First IPI can be sent unconditionally because halter vCPU

		 * starts earlier.

		/*

		 * Wait up to ~1 sec for halter to indicate that it has:

		 * 1. Received the IPI

		 * 2. Woken up from the halt

		 * 3. Gone back into halt

		 * Current CPUs typically run at 2.x Ghz which is ~2

		 * billion ticks per second.

 Get set of first 64 numa nodes available */

	/* Init array of masks containing a single-bit in each, one for each

	 * available node. migrate_pages called below requires specifying nodes

	 * as bit masks.

		/*

		 * migrate_pages with PID=0 will migrate all pages of this

		 * process between the nodes specified as bitmasks. The page

		 * backing the APIC access address belongs to this process

		 * because it is allocated by KVM in the context of the

		 * KVM_CREATE_VCPU ioctl. If that assumption ever changes this

		 * test may break or give a false positive signal.

 Start halter vCPU thread and wait for it to execute first HLT. */

	/*

	 * Cancel threads and wait for them to stop.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * KVM_GET/SET_* tests

 *

 * Copyright (C) 2018, Red Hat, Inc.

 *

 * Tests for vCPU state save/restore, including nested guest state.

 for program_invocation_short_name */

 Exit to L1 */

 Done, exit to L1 and never come back.  */

 Prepare for L2 execution. */

 Exit to L1 */

 L1 has now set up a shadow VMCS for us.  */

 Done, exit to L1 and never come back.  */

 Check that the launched state is preserved.  */

 Create VM */

 NOT REACHED */

 UCALL_SYNC is handled here.  */

 Restore state in a new VM.  */

 SPDX-License-Identifier: GPL-2.0

/*

 * VMX-pmu related msrs test

 *

 * Copyright (C) 2021 Intel Corporation

 *

 * Test to check the effect of various CPUID settings

 * on the MSR_IA32_PERF_CAPABILITIES MSR, and check that

 * whatever we write with KVM_SET_MSR is _not_ modified

 * in the guest and test it can be retrieved with KVM_GET_MSR.

 *

 * Test to check that invalid LBR formats are rejected.

 for program_invocation_short_name */

 Create VM */

 testcase 1, set capabilities when we have PDCM bit */

 check capabilities can be retrieved with KVM_GET_MSR */

 check whatever we write with KVM_SET_MSR is _not_ modified */

 testcase 2, check valid LBR formats are accepted */

 testcase 3, check invalid LBR format is rejected */

 testcase 4, set capabilities when we don't have PDCM bit */

 testcase 5, set capabilities when we don't have PMU version bits */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2021, Red Hat, Inc.

 *

 * Tests for Hyper-V features enablement

			/*

			 * Only available when Hyper-V identification is set

			/*

			 * HV_X64_MSR_GUEST_OS_ID has to be written first to make

			 * HV_X64_MSR_HYPERCALL available.

 Read only */

 Read only */

 Read only */

			/*

			 * Remains unavailable even with KVM_CAP_HYPERV_SYNIC2

			 * capability enabled and guest visible CPUID bit unset.

 Direct mode test */

 Read only */

 Can only write '0' */

 END */

 Nothing in 'sparse banks' -> success */

 XMM fast hypercall */

 END */

 Test MSRs */

 Test hypercalls */

 Hypercall input/output */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * vmx_set_nested_state_test

 *

 * Copyright (C) 2019, Google LLC.

 *

 * This test verifies the integrity of calling the ioctl KVM_SET_NESTED_STATE.

/*

 * Mirror of VMCS12_REVISION in arch/x86/kvm/vmx/vmcs12.h. If that value

 * changes this should be updated.

 Set revision_id in vmcs12 to vmcs12_revision. */

 Add a page for VMCS12. */

 The format must be set to 0. 0 for VMX, 1 for SVM. */

	/*

	 * We cannot virtualize anything if the guest does not have VMX

	 * enabled.

	/*

	 * We cannot virtualize anything if the guest does not have VMX

	 * enabled.  We expect KVM_SET_NESTED_STATE to return 0 if vmxon_pa

	 * is set to -1ull, but the flags must be zero.

 Enable VMX in the guest CPUID. */

	/*

	 * Setting vmxon_pa == -1ull and vmcs_pa == -1ull exits early without

	 * setting the nested state but flags other than eVMCS must be clear.

	 * The eVMCS flag can be set if the enlightened VMCS capability has

	 * been enabled.

 It is invalid to have vmxon_pa == -1ull and SMM flags non-zero. */

 Invalid flags are rejected. */

 It is invalid to have vmxon_pa == -1ull and vmcs_pa != -1ull. */

 It is invalid to have vmxon_pa set to a non-page aligned address. */

	/*

	 * It is invalid to have KVM_STATE_NESTED_SMM_GUEST_MODE and

	 * KVM_STATE_NESTED_GUEST_MODE set together.

	/*

	 * It is invalid to have any of the SMM flags set besides:

	 *	KVM_STATE_NESTED_SMM_GUEST_MODE

	 *	KVM_STATE_NESTED_SMM_VMXON

 Outside SMM, SMM flags must be zero. */

	/*

	 * Size must be large enough to fit kvm_nested_state and vmcs12

	 * if VMCS12 physical address is set

	/*

	 * KVM_SET_NESTED_STATE succeeds with invalid VMCS

	 * contents but L2 not running.

 Invalid flags are rejected, even if no VMCS loaded. */

 vmxon_pa cannot be the same address as vmcs_pa. */

	/*

	 * Test that if we leave nesting the state reflects that when we get

	 * it again.

	/*

	 * AMD currently does not implement set_nested_state, so for now we

	 * just early out.

	/*

	 * First run tests with VMX disabled to check error handling.

 Passing a NULL kvm_nested_state causes a EFAULT. */

 'size' cannot be smaller than sizeof(kvm_nested_state). */

	/*

	 * Setting the flags 0xf fails the flags check.  The only flags that

	 * can be used are:

	 *     KVM_STATE_NESTED_GUEST_MODE

	 *     KVM_STATE_NESTED_RUN_PENDING

	 *     KVM_STATE_NESTED_EVMCS

	/*

	 * If KVM_STATE_NESTED_RUN_PENDING is set then

	 * KVM_STATE_NESTED_GUEST_MODE has to be set as well.

 SPDX-License-Identifier: GPL-2.0

 PFEC == RSVD | PRESENT (read, kernel). */

 Create VM */

 Map 1gb page without a backing memlot. */

 Guest access to the 1gb page should trigger MMIO. */

	/*

	 * Effect the CPUID change for the guest and re-enter the guest.  Its

	 * access should now #PF due to the PAGE_SIZE bit being reserved or

	 * the resulting GPA being invalid.  Note, kvm_get_supported_cpuid()

	 * returns the struct that contains the entry being modified.  Eww.

	/*

	 * Add a dummy memslot to coerce KVM into bumping the MMIO generation.

	 * KVM does not "officially" support mucking with CPUID after KVM_RUN,

	 * and will incorrectly reuse MMIO SPTEs.  Don't delete the memslot!

	 * KVM x86 zaps all shadow pages on memslot deletion.

 Set up a #PF handler to eat the RSVD #PF and signal all done! */

	/*

	 * Restore the happy CPUID value for the next test.  Yes, changes are

	 * indeed persistent across VM destruction.

	/*

	 * All tests are opt-in because TDP doesn't play nice with reserved #PF

	 * in the GVA->GPA translation.  The hardware page walker doesn't let

	 * software change GBPAGES or MAXPHYADDR, and KVM doesn't manually walk

	 * the GVA on fault for performance reasons.

 SPDX-License-Identifier: GPL-2.0

/*

 * Test for x86 KVM_CAP_HYPERV_CPUID

 *

 * Copyright (C) 2018, Red Hat, Inc.

 *

 * This work is licensed under the terms of the GNU GPL, version 2.

 *

 for program_invocation_short_name */

 0x4000000A */

		/*

		 * If needed for debug:

		 * fprintf(stdout,

		 *	"CPUID%lx EAX=0x%lx EBX=0x%lx ECX=0x%lx EDX=0x%lx\n",

		 *	entry->function, entry->eax, entry->ebx, entry->ecx,

		 *	entry->edx);

 Tell stdout not to buffer its content */

 Test vCPU ioctl version */

 Test system ioctl version */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * VMX-preemption timer test

 *

 * Copyright (C) 2020, Google, LLC.

 *

 * Test to ensure the VM-Enter after migration doesn't

 * incorrectly restarts the timer with the full timer

 * value instead of partially decayed timer value

 *

 for program_invocation_short_name */

	/*

	 * Wait until the 1st threshold has passed

	/*

	 * Force L2 through Save and Restore cycle

	/*

	 * Now wait for the preemption timer to fire and

	 * exit to L1

	/*

	 * Check for Preemption timer support

	/*

	 * Turn on PIN control and resume the guest

	/*

	 * Ensure exit from L2 happens after L2 goes through

	 * save and restore

	/*

	 * Ensure the exit from L2 is due to preemption timer expiry

	/*

	 * Sync with the host and pass the l1|l2 pt_expiry_finish times and

	 * tsc deadlines so that host can verify they are as expected

	/*

	 * AMD currently does not implement any VMX features, so for now we

	 * just early out.

 Create VM */

 NOT REACHED */

 UCALL_SYNC is handled here.  */

		/*

		 * If this stage 2 then we should verify the vmx pt expiry

		 * is as expected.

		 * From L1's perspective verify Preemption timer hasn't

		 * expired too early.

		 * From L2's perspective verify Preemption timer hasn't

		 * expired too late.

 Restore state in a new VM.  */

 SPDX-License-Identifier: GPL-2.0

/*

 * Test that KVM_GET_MSR_INDEX_LIST and

 * KVM_GET_MSR_FEATURE_INDEX_LIST work as intended

 *

 * Copyright (C) 2020, Red Hat, Inc.

 SPDX-License-Identifier: GPL-2.0

/*

 * CR4 and CPUID sync test

 *

 * Copyright 2018, Red Hat, Inc. and/or its affiliates.

 *

 * Author:

 *   Wei Huang <wei@redhat.com>

 turn on CR4.OSXSAVE */

 verify CR4.OSXSAVE == CPUID.OSXSAVE */

 notify hypervisor to change CR4 */

 check again */

 Tell stdout not to buffer its content */

 Create VM */

 emulate hypervisor clearing CR4.OSXSAVE */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * vmx_tsc_adjust_test

 *

 * Copyright (C) 2018, Google LLC.

 *

 * IA32_TSC_ADJUST test

 *

 * According to the SDM, "if an execution of WRMSR to the

 * IA32_TIME_STAMP_COUNTER MSR adds (or subtracts) value X from the TSC,

 * the logical processor also adds (or subtracts) value X from the

 * IA32_TSC_ADJUST MSR.

 *

 * Note that when L1 doesn't intercept writes to IA32_TSC, a

 * WRMSR(IA32_TSC) from L2 sets L1's TSC value, not L2's perceived TSC

 * value.

 *

 * This test verifies that this unusual case is handled correctly.

 The virtual machine object. */

 Exit to L1 */

 Prepare the VMCS for L2 execution. */

 Jump into L2.  First, test failure to load guest CR3.  */

 Allocate VMX pages and shared descriptors (vmx_pages). */

 NOT REACHED */

/*

 * mmio_warning_test

 *

 * Copyright (C) 2019, Google LLC.

 *

 * This work is licensed under the terms of the GNU GPL, version 2.

 *

 * Test that we don't get a kernel warning when we call KVM_RUN after a

 * triple fault occurs.  To get the triple fault to occur we call KVM_RUN

 * on a VCPU that hasn't been properly setup.

 *

 SPDX-License-Identifier: GPL-2.0

/*

 * KVM dirty page logging test

 *

 * Copyright (C) 2018, Red Hat, Inc.

 for program_invocation_name */

 The memory slot index to track dirty pages */

 L1 guest test virtual memory offset */

 L2 guest test virtual memory offset */

 Exit to L1 and never come back.  */

 Create VM */

 Add an extra memory slot for testing dirty logging */

	/*

	 * Add an identity map for GVA range [0xc0000000, 0xc0002000).  This

	 * affects both L1 and L2.  However...

	/*

	 * ... pages in the L2 GPA range [0xc0001000, 0xc0003000) will map to

	 * 0xc0000000.

	 *

	 * Note that prepare_eptp should be called only L1's GPA map is done,

	 * meaning after the last call to virt_map.

 NOT REACHED */

			/*

			 * The nested guest wrote at offset 0x1000 in the memslot, but the

			 * dirty bitmap must be filled in according to L1 GPA, not L2.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2020, Google LLC.

 *

 * Tests for exiting into userspace on registered MSRs

 for program_invocation_short_name */

 Forced emulation prefix, used to invoke the emulator unconditionally. */

 Test an MSR the kernel knows about. */

 Test an MSR the kernel doesn't know about. */

 Test a fabricated MSR that no one knows about. */

/*

 * Note: Force test_rdmsr() to not be inlined to prevent the labels,

 * rdmsr_start and rdmsr_end, from being defined multiple times.

/*

 * Note: Force test_wrmsr() to not be inlined to prevent the labels,

 * wrmsr_start and wrmsr_end, from being defined multiple times.

/*

 * Note: Force test_em_rdmsr() to not be inlined to prevent the labels,

 * rdmsr_start and rdmsr_end, from being defined multiple times.

/*

 * Note: Force test_em_wrmsr() to not be inlined to prevent the labels,

 * wrmsr_start and wrmsr_end, from being defined multiple times.

	/*

	 * Test userspace intercepting rdmsr / wrmsr for MSR_IA32_XSS.

	 *

	 * A GP is thrown if anything other than 0 is written to

	 * MSR_IA32_XSS.

	/*

	 * Test userspace intercepting rdmsr / wrmsr for MSR_IA32_FLUSH_CMD.

	 *

	 * A GP is thrown if MSR_IA32_FLUSH_CMD is read

	 * from or if a value other than 1 is written to it.

	/*

	 * Test userspace intercepting rdmsr / wrmsr for MSR_NON_EXISTENT.

	 *

	 * Test that a fabricated MSR can pass through the kernel

	 * and be handled in userspace.

	/*

	 * Test to see if the instruction emulator is available (ie: the module

	 * parameter 'kvm.force_emulation_prefix=1' is set).  This instruction

	 * will #UD if it isn't available.

 Let userspace know we aren't done. */

		/*

		 * Now run the same tests with the instruction emulator.

 This goes into the in-kernel emulation */

 This goes into user space emulation */

 If trapped == true, this goes into user space emulation */

 This goes into the in-kernel emulation */

 Invalid MSR, should always be handled by user space exit */

	/*

	 * Disable msr filtering, so that the kernel

	 * handles everything in the next round

 Let userspace know to switch the filter */

 Create VM */

 Process guest code userspace exits. */

 Process emulated rdmsr and wrmsr instructions. */

 Confirm the guest completed without issues. */

 ignore */

 Create VM */

 Create VM */

 Tell stdout not to buffer its content */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2020, Google LLC.

 *

 * Tests for KVM_CAP_EXIT_ON_EMULATION_FAILURE capability.

 for program_invocation_short_name */

/*

 * Accessors to get R/M, REG, and Mod bits described in the SDM vol 2,

 * figure 2-2 "Table Interpretation of ModR/M Byte (C8H)".

 Ensure we are dealing with a simple 2-byte flds instruction. */

 Ensure there is no SIB byte. */

 Ensure there is no displacement byte. */

			/*

			 * If is_flds() succeeded then the instruction bytes

			 * contained an flds instruction that is 2-bytes in

			 * length (ie: no prefix, no SIB, no displacement).

 Tell stdout not to buffer its content */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * svm_int_ctl_test

 *

 * Copyright (C) 2021, Red Hat, Inc.

 *

 * Nested SVM testing: test simultaneous use of V_IRQ from L1 and L0.

	/* This code raises interrupt INTR_IRQ_NUMBER in the L1's LAPIC,

	 * and since L1 didn't enable virtual interrupt masking,

	 * L2 should receive it and not L1.

	 *

	 * L2 also has virtual interrupt 'VINTR_IRQ_NUMBER' pending in V_IRQ

	 * so it should also receive it after the following 'sti'.

 Prepare for L2 execution. */

 No virtual interrupt masking */

 No intercepts for real and virtual interrupts */

 Make a virtual interrupt VINTR_IRQ_NUMBER pending */

 NOT REACHED */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * vmx_close_while_nested

 *

 * Copyright (C) 2019, Red Hat, Inc.

 *

 * Verify that nothing bad happens if a KVM user exits with open

 * file descriptors while executing a nested guest.

 The virtual machine object. */

 Exit to L0 */

 Prepare the VMCS for L2 execution. */

 Allocate VMX pages and shared descriptors (vmx_pages). */

 NOT REACHED */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Test for s390x CPU resets

 *

 * Copyright (C) 2020, IBM

 set several CRs to "safe" value */

 enable guarded storage */

 monitor mask = 1 */

 PER START */

 PER END */

 Dirty registers */

 Round toward 0 */

 set fpc to !=0 */

 now clobber some general purpose regs */

 now clobber a floating point reg */

 now clobber an access reg */

 We embed diag 501 here to control register content */

 no clobber list as this should not return */

	/*

	 * irqs contains the number of retrieved interrupts. Any interrupt

	 * (notably, the emergency call interrupt we have injected) should

	 * be cleared by the resets, so this should be 0.

 sync regs */

 KVM_GET_SREGS */

 sync regs */

 kvm_run */

 Inject IRQ */

 Create VM */

 must clears */

 must not clears */

 must clears */

 must not clears */

 must clears */

 Tell stdout not to buffer its content */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Test for s390x KVM_CAP_SYNC_REGS

 *

 * Based on the same test for x86:

 * Copyright (C) 2018, Google LLC.

 *

 * Adaptions for s390x:

 * Copyright (C) 2019, Red Hat, Inc.

 *

 * Test expected behavior of the KVM_CAP_SYNC_REGS functionality.

 for program_invocation_short_name */

	/*

	 * We embed diag 501 here instead of doing a ucall to avoid that

	 * the compiler has messed with r11 at the time of the ucall.

 Tell stdout not to buffer its content */

 Create VM */

 Request reading invalid register set from VCPU. */

 Request setting invalid register set into VCPU. */

 Request and verify all valid register sets. */

 Set and verify various register values */

	/* Clear kvm_dirty_regs bits, verify new s.regs values are

	 * overwritten with existing guest values.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Test for s390x KVM_S390_MEM_OP

 *

 * Copyright (C) 2019, Red Hat, Inc.

 Tell stdout not to buffer its content */

 Create VM */

 Set the first array */

 Let the guest code copy the first array to the second */

 Get the second array */

 Check error conditions - first bad size: */

 Zero size: */

 Bad flags: */

 Bad operation: */

 Bad guest address: */

 Bad host address: */

 Bad access register: */

 Enable AR mode */

 To sync new state to SIE block */

 Disable AR mode */

 Run to sync new state */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.

 Not a problem if it fails.*/

 Wait for any grace periods. */

 SPDX-License-Identifier: GPL-2.0-or-later

/******************************************************************************

 *

 *   Copyright  International Business Machines  Corp., 2009

 *

 * DESCRIPTION

 *      1. Block a thread using FUTEX_WAIT

 *      2. Attempt to use FUTEX_CMP_REQUEUE_PI on the futex from 1.

 *      3. The kernel must detect the mismatch and return -EINVAL.

 *

 * AUTHOR

 *      Darren Hart <dvhart@linux.intel.com>

 *

 * HISTORY

 *      2009-Nov-9: Initial version by Darren Hart <dvhart@linux.intel.com>

 *

 Allow the child to block in the kernel. */

	/*

	 * The kernel should detect the waiter did not setup the

	 * q->requeue_pi_key and return -EINVAL. If it does not,

	 * it likely gave the lock to the child, which is now hung

	 * in the kernel.

			/*

			 * The kernel correctly detected the mismatched

			 * requeue_pi target and aborted. Wake the child with

			 * FUTEX_WAKE.

 If the kernel crashes, we shouldn't return at all. */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright Collabora Ltd., 2021

 *

 * futex cmp requeue test by Andr Almeida <andrealmeid@collabora.com>

 Testing a private futex */

 Testing an anon page shared memory */

 Testing a file backed shared memory */

 Freeing resources */

 SPDX-License-Identifier: GPL-2.0-or-later

/******************************************************************************

 *

 * Copyright FUJITSU LIMITED 2010

 * Copyright KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>

 *

 * DESCRIPTION

 *      Internally, Futex has two handling mode, anon and file. The private file

 *      mapping is special. At first it behave as file, but after write anything

 *      it behave as anon. This test is intent to test such case.

 *

 * AUTHOR

 *      KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>

 *

 * HISTORY

 *      2010-Jan-6: Initial version by KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>

 *

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * futex_waitv() test by Andr Almeida <andrealmeid@collabora.com>

 *

 * Copyright 2021 Collabora Ltd.

 setting absolute timeout for futex2 */

 Private waitv */

 Shared waitv */

 Testing a waiter without FUTEX_32 flag */

 Testing a waiter with an unaligned address */

 Testing a NULL address for waiters.uaddr */

 Testing a NULL address for *waiters */

 Testing an invalid clockid */

 SPDX-License-Identifier: GPL-2.0-or-later

/******************************************************************************

 *

 *   Copyright  International Business Machines  Corp., 2006-2008

 *

 * DESCRIPTION

 *      This test exercises the futex_wait_requeue_pi() signal handling both

 *      before and after the requeue. The first should be restarted by the

 *      kernel. The latter should return EWOULDBLOCK to the waiter.

 *

 * AUTHORS

 *      Darren Hart <dvhart@linux.intel.com>

 *

 * HISTORY

 *      2008-May-5: Initial version by Darren Hart <dvhart@linux.intel.com>

 *

		/*

		 * signal the waiter before requeue, waiter should automatically

		 * restart futex_wait_requeue_pi() in the kernel. Wait for the

		 * waiter to block on f1 again.

		/*

		 * If res is non-zero, we either requeued the waiter or hit an

		 * error, break out and handle it. If it is zero, then the

		 * signal may have hit before the the waiter was blocked on f1.

		 * Try again.

	/*

	 * Signal the waiter after requeue, waiter should return from

	 * futex_wait_requeue_pi() with EWOULDBLOCK. Join the thread here so the

	 * futex_unlock_pi() can't happen before the signal wakeup is detected

	 * in the kernel.

 SPDX-License-Identifier: GPL-2.0-or-later

/******************************************************************************

 *

 *   Copyright  International Business Machines  Corp., 2009

 *

 * DESCRIPTION

 *      Block on a futex and wait for timeout.

 *

 * AUTHOR

 *      Darren Hart <dvhart@linux.intel.com>

 *

 * HISTORY

 *      2009-Nov-6: Initial version by Darren Hart <dvhart@linux.intel.com>

 *      2021-Apr-26: More test cases by Andr Almeida <andrealmeid@collabora.com>

 *

 100us default timeout */

/*

 * Get a PI lock and hold it forever, so the main thread lock_pi will block

 * and we can test the timeout

 Blocks forever */

/*

 * Check if the function returned the expected error

/*

 * Calculate absolute timeout and correct overflow

 initialize relative timeout */

 FUTEX_WAIT_BITSET with CLOCK_REALTIME */

 FUTEX_WAIT_BITSET with CLOCK_MONOTONIC */

 FUTEX_WAIT_REQUEUE_PI with CLOCK_REALTIME */

 FUTEX_WAIT_REQUEUE_PI with CLOCK_MONOTONIC */

	/*

	 * FUTEX_LOCK_PI with CLOCK_REALTIME

	 * Due to historical reasons, FUTEX_LOCK_PI supports only realtime

	 * clock, but requires the caller to not set CLOCK_REALTIME flag.

	 *

	 * If you call FUTEX_LOCK_PI with a monotonic clock, it'll be

	 * interpreted as a realtime clock, and (unless you mess your machine's

	 * time or your time machine) the monotonic clock value is always

	 * smaller than realtime and the syscall will timeout immediately.

 Test operations that don't support FUTEX_CLOCK_REALTIME */

 futex_waitv with CLOCK_MONOTONIC */

 futex_waitv with CLOCK_REALTIME */

 SPDX-License-Identifier: GPL-2.0-or-later

/******************************************************************************

 *

 *   Copyright  International Business Machines  Corp., 2006-2008

 *

 * DESCRIPTION

 *      This test excercises the futex syscall op codes needed for requeuing

 *      priority inheritance aware POSIX condition variables and mutexes.

 *

 * AUTHORS

 *      Sripathi Kodi <sripathik@in.ibm.com>

 *      Darren Hart <dvhart@linux.intel.com>

 *

 * HISTORY

 *      2008-Jan-13: Initial version by Sripathi Kodi <sripathik@in.ibm.com>

 *      2009-Nov-6: futex test adaptation by Darren Hart <dvhart@linux.intel.com>

 *

 Test option defaults */

	/* Each thread sleeps for a different amount of time

	 * This is to avoid races, because we don't lock the

 cond_signal */

 we have to loop at least THREAD_MAX times */

 Wait for threads to finish */

 Store the first error or failure encountered in waiter_ret */

	/*

	 * FIXME: unit_test is obsolete now that we parse options and the

	 * various style of runs are done by run.sh - simplify the code and move

	 * unit_test into main()

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright Collabora Ltd., 2021

 *

 * futex cmp requeue test by Andr Almeida <andrealmeid@collabora.com>

	/*

	 * Requeue a waiter from f1 to f2, and wake f2.

	/*

	 * Create 10 waiters at f1. At futex_requeue, wake 3 and requeue 7.

	 * At futex_wake, wake INT_MAX (should be exactly 7).

 SPDX-License-Identifier: GPL-2.0-or-later

/******************************************************************************

 *

 * Copyright FUJITSU LIMITED 2010

 * Copyright KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>

 *

 * DESCRIPTION

 *      Wait on uninitialized heap. It shold be zero and FUTEX_WAIT should

 *      return immediately. This test is intent to test zero page handling in

 *      futex.

 *

 * AUTHOR

 *      KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>

 *

 * HISTORY

 *      2010-Jan-6: Initial version by KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>

 *

 SPDX-License-Identifier: GPL-2.0-or-later

/******************************************************************************

 *

 *   Copyright  International Business Machines  Corp., 2009

 *

 * DESCRIPTION

 *      Test if FUTEX_WAIT op returns -EWOULDBLOCK if the futex value differs

 *      from the expected one.

 *

 * AUTHOR

 *      Gowrishankar <gowrishankar.m@in.ibm.com>

 *

 * HISTORY

 *      2009-Nov-14: Initial version by Gowrishankar <gowrishankar.m@in.ibm.com>

 *

 SPDX-License-Identifier: GPL-2.0 */

/*

 * Check if the cgroup is frozen by looking at the cgroup.events::frozen value.

		/*

		 * Check the cgroup.events::frozen value.

/*

 * Freeze the given cgroup.

/*

 * Attach a task to the given cgroup and wait for a cgroup frozen event.

 * All transient events (e.g. populated) are ignored.

/*

 * Freeze the given cgroup and wait for the inotify signal.

 * If there are no events in 10 seconds, treat this as an error.

 * Then check that the cgroup is in the desired state.

/*

 * A simple process running in a sleep loop until being

 * re-parented.

/*

 * A simple test for the cgroup freezer: populated the cgroup with 100

 * running processes and freeze it. Then unfreeze it. Then it kills all

 * processes and destroys the cgroup.

/*

 * The test creates the following hierarchy:

 *       A

 *    / / \ \

 *   B  E  I K

 *  /\  |

 * C  D F

 *      |

 *      G

 *      |

 *      H

 *

 * with a process in C, H and 3 processes in K.

 * Then it tries to freeze and unfreeze the whole tree.

	/*

	 * Wait until all child processes will enter

	 * corresponding cgroups.

	/*

	 * Freeze B.

	/*

	 * Freeze F.

	/*

	 * Freeze G.

	/*

	 * Check that A and E are not frozen.

	/*

	 * Freeze A. Check that A, B and E are frozen.

	/*

	 * Unfreeze B, F and G

	/*

	 * Check that C and H are still frozen.

	/*

	 * Unfreeze A. Check that A, C and K are not frozen.

/*

 * A fork bomb emulator.

/*

 * The test runs a fork bomb in a cgroup and tries to freeze it.

 * Then it kills all processes and checks that cgroup isn't populated

 * anymore.

/*

 * The test creates a cgroups and freezes it. Then it creates a child cgroup

 * and populates it with a task. After that it checks that the child cgroup

 * is frozen and the parent cgroup remains frozen too.

/*

 * The test creates two nested cgroups, freezes the parent

 * and removes the child. Then it checks that the parent cgroup

 * remains frozen and it's possible to create a new child

 * without unfreezing. The new child is frozen too.

/*

 * The test creates two cgroups: A and B, runs a process in A

 * and performs several migrations:

 * 1) A (running) -> B (frozen)

 * 2) B (frozen) -> A (running)

 * 3) A (frozen) -> B (frozen)

 *

 * On each step it checks the actual state of both cgroups.

	/*

	 * Migrate from A (running) to B (frozen)

	/*

	 * Migrate from B (frozen) to A (running)

	/*

	 * Migrate from A (frozen) to B (frozen)

/*

 * The test checks that ptrace works with a tracing process in a frozen cgroup.

	/*

	 * Cgroup has to remain frozen, however the test task

	 * is in traced state.

/*

 * Check if the process is stopped.

/*

 * Test that it's possible to freeze a cgroup with a stopped process.

/*

 * Test that it's possible to freeze a cgroup with a ptraced process.

	/*

	 * cg_check_frozen(cgroup, true) will fail here,

	 * because the task in in the TRACEd state.

/*

 * Test that it's possible to freeze a cgroup with a process,

 * which called vfork() and is waiting for a child.

 SPDX-License-Identifier: GPL-2.0 */

 Handle the case of comparing against empty string */

	/*

	 * Example:

	 * cgroup /sys/fs/cgroup cgroup2 rw,seclabel,noexec,relatime 0 0

 If cgroup.kill exists use it. */

	/*

	 * Verify that this is a genuine test failure:

	 * ENOSYS -> clone3() not available

	 * E2BIG  -> CLONE_INTO_CGROUP not available

 Genuine test failure. */

	/*

	 * We don't care whether this fails. We only care whether the initial

	 * clone succeeded.

 SPDX-License-Identifier: GPL-2.0 */

/*

 * This test creates two nested cgroups with and without enabling

 * the memory controller.

 Create two nested cgroups with the memory controller enabled */

 Create two nested cgroups without enabling memory controller */

/*

 * This test create a memory cgroup, allocates

 * some anonymous memory and some pagecache

 * and check memory.current and some memory.stat values.

/*

 * Wait until processes are killed asynchronously by the OOM killer

 * If we exceed a timeout, fail.

/*

 * First, this test creates the following hierarchy:

 * A       memory.min = 50M,  memory.max = 200M

 * A/B     memory.min = 50M,  memory.current = 50M

 * A/B/C   memory.min = 75M,  memory.current = 50M

 * A/B/D   memory.min = 25M,  memory.current = 50M

 * A/B/E   memory.min = 500M, memory.current = 0

 * A/B/F   memory.min = 0,    memory.current = 50M

 *

 * Usages are pagecache, but the test keeps a running

 * process in every leaf cgroup.

 * Then it creates A/G and creates a significant

 * memory pressure in it.

 *

 * A/B    memory.current ~= 50M

 * A/B/C  memory.current ~= 33M

 * A/B/D  memory.current ~= 17M

 * A/B/E  memory.current ~= 0

 *

 * After that it tries to allocate more than there is

 * unprotected memory in A available, and checks

 * checks that memory.min protects pagecache even

 * in this case.

/*

 * First, this test creates the following hierarchy:

 * A       memory.low = 50M,  memory.max = 200M

 * A/B     memory.low = 50M,  memory.current = 50M

 * A/B/C   memory.low = 75M,  memory.current = 50M

 * A/B/D   memory.low = 25M,  memory.current = 50M

 * A/B/E   memory.low = 500M, memory.current = 0

 * A/B/F   memory.low = 0,    memory.current = 50M

 *

 * Usages are pagecache.

 * Then it creates A/G an creates a significant

 * memory pressure in it.

 *

 * Then it checks actual memory usages and expects that:

 * A/B    memory.current ~= 50M

 * A/B/   memory.current ~= 33M

 * A/B/D  memory.current ~= 17M

 * A/B/E  memory.current ~= 0

 *

 * After that it tries to allocate more than there is

 * unprotected memory in A available,

 * and checks low and oom events in memory.events.

/*

 * This test checks that memory.high limits the amount of

 * memory which can be consumed by either anonymous memory

 * or pagecache.

/*

 * This test checks that memory.max limits the amount of

 * memory which can be consumed by either anonymous memory

 * or pagecache.

 Should be killed by OOM killer */

/*

 * This test checks that memory.swap.max limits the amount of

 * anonymous memory which can be swapped out.

 Should be killed by OOM killer */

/*

 * This test disables swapping and tries to allocate anonymous memory

 * up to OOM. Then it checks for oom and oom_kill events in

 * memory.events.

 nice round number */

/*

 * This test checks socket memory accounting.

 * The test forks a TCP server listens on a random port between 1000

 * and 61000. Once it gets a client connection, it starts writing to

 * its socket.

 * The TCP client interleaves reads from the socket with check whether

 * memory.current and memory.stat.sock are similar.

/*

 * This test disables swapping and tries to allocate anonymous memory

 * up to OOM with memory.group.oom set. Then it checks that all

 * processes in the leaf (but not the parent) were killed.

/*

 * This test disables swapping and tries to allocate anonymous memory

 * up to OOM with memory.group.oom set. Then it checks that all

 * processes in the parent and leaf were killed.

/*

 * This test disables swapping and tries to allocate anonymous memory

 * up to OOM with memory.group.oom set. Then it checks that all

 * processes were killed except those set with OOM_SCORE_ADJ_MIN

	/*

	 * Check that memory controller is available:

	 * memory is listed in cgroup.controllers

 SPDX-License-Identifier: GPL-2.0 */

/*

 * Kill the given cgroup and wait for the inotify signal.

 * If there are no events in 10 seconds, treat this as an error.

 * Then check that the cgroup is in the desired state.

/*

 * A simple process running in a sleep loop until being

 * re-parented.

/*

 * The test creates the following hierarchy:

 *       A

 *    / / \ \

 *   B  E  I K

 *  /\  |

 * C  D F

 *      |

 *      G

 *      |

 *      H

 *

 * with a process in C, H and 3 processes in K.

 * Then it tries to kill the whole tree.

	/*

	 * Wait until all child processes will enter

	 * corresponding cgroups.

	/*

	 * Kill A and check that we get an empty notification.

/*

 * The test runs a fork bomb in a cgroup and tries to kill it.

 SPDX-License-Identifier: GPL-2.0 */

/*

 * Create a child process that allocates and touches 100MB, then waits to be

 * killed. Wait until the child is attached to the cgroup, kill all processes

 * in that cgroup and wait until "cgroup.procs" is empty. At this point try to

 * destroy the empty cgroup. The test helps detect race conditions between

 * dying processes leaving the cgroup and cgroup destruction path.

 wait for the child to enter cgroup */

 wait for cgroup to be empty */

/*

 * A(0) - B(0) - C(1)

 *        \ D(0)

 *

 * A, B and C's "populated" fields would be 1 while D's 0.

 * test that after the one process in C is moved to root,

 * A,B and C's "populated" fields would flip to "0" and file

 * modified events will be generated on the

 * "cgroup.events" files of both cgroups.

 Test that we can directly clone into a new cgroup. */

 Remove cgroup. */

/*

 * A (domain threaded) - B (threaded) - C (domain)

 *

 * test that C can't be used until it is turned into a

 * threaded cgroup.  "cgroup.type" file will report "domain (invalid)" in

 * these cases. Operations which fail due to invalid topology use

 * EOPNOTSUPP as the errno.

/*

 * Test that when a child becomes threaded

 * the parent type becomes domain threaded.

/*

 * Test that there's no internal process constrain on threaded cgroups.

 * You can add threads/processes on a parent with a controller enabled.

/*

 * Test that you can't enable a controller on a child if it's not enabled

 * on the parent.

/*

 * Test that you can't disable a controller on a parent

 * if it's enabled in a child.

/*

 * Test internal process constraint.

 * You can't add a pid to a domain parent if a controller is enabled.

/*

 * Test threadgroup migration.

 * All threads of a process are migrated together.

/*

 * Test single thread migration.

 * Threaded cgroups allow successful migration of a thread.

 SPDX-License-Identifier: GPL-2.0

/*

 * Memory cgroup charging is performed using percpu batches 32 pages

 * big (look at MEMCG_CHARGE_BATCH), whereas memory.stat is exact. So

 * the maximum discrepancy between charge and vmstat entries is number

 * of cpus multiplied by 32 pages.

/*

 * This test allocates 100000 of negative dentries with long names.

 * Then it checks that "slab" in memory.stat is larger than 1M.

 * Then it sets memory.high to 1M and checks that at least 1/2

 * of slab memory has been reclaimed.

/*

 * The test creates and destroys a large number of cgroups. In each cgroup it

 * allocates some slab memory (mostly negative dentries) using 2 * NR_CPUS

 * threads. Then it checks the sanity of numbers on the parent level:

 * the total size of the cgroups should be roughly equal to

 * anon + file + slab + kernel_stack.

/*

 * The test reads the entire /proc/kpagecgroup. If the operation went

 * successfully (and the kernel didn't panic), the test is treated as passed.

/*

 * The test spawns a process, which spawns 1000 threads. Then it checks

 * that memory.stat's kernel_stack is at least 1000 pages large.

/*

 * This test sequentionally creates 30 child cgroups, allocates some

 * kernel memory in each of them, and deletes them. Then it checks

 * that the number of dying cgroups on the parent level is 0.

		/*

		 * Reclaiming cgroups might take some time,

		 * let's wait a bit and repeat.

/*

 * This test creates a sub-tree with 1000 memory cgroups.

 * Then it checks that the memory.current on the parent level

 * is greater than 0 and approximates matches the percpu value

 * from memory.stat.

	/*

	 * Check that memory controller is available:

	 * memory is listed in cgroup.controllers

/*

 * Copyright (c) 2019 Alexey Dobriyan <adobriyan@gmail.com>

 *

 * Permission to use, copy, modify, and distribute this software for any

 * purpose with or without fee is hereby granted, provided that the above

 * copyright notice and this permission notice appear in all copies.

 *

 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES

 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF

 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR

 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES

 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN

 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF

 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

 Test that open(O_TMPFILE), linkat() doesn't screw accounting. */

 Our heroes: 1 root inode, 1 O_TMPFILE inode, 1 permanent inode. */

 SPDX-License-Identifier: GPL-2.0

 should fail (offset not page aligned) */

 should fail (size not multiple of page) */

 should fail (not memfd) */

 stdin */

 should work */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2011 Red Hat, Inc., Frederic Weisbecker <fweisbec@redhat.com>

 *

 * Selftests for breakpoints (and more generally the do_debug() path) in x86.

 Breakpoint access modes */

/*

 * Ensures the child and parent are always "talking" about

 * the same test sequence. (ie: that we haven't forgotten

 * to call check_trapped() somewhere).

 Dummy variables to test read/write accesses */

 Dummy functions to test execution accesses */

	/*

	 * If we haven't trapped, wake up the parent

	 * so that it notices the failure.

/*

 * Do the r/w/x accesses to trigger the breakpoints. And run

 * the usual traps.

 Wake up father so that it sets up the first test */

 Test instruction breakpoints */

 Test write watchpoints */

 Test read/write watchpoints (on read accesses) */

 Icebp trap */

 Int 3 trap */

 Wait for the child to SIGTRAP */

 Set the breakpoints and check the child successfully trigger them */

 Instruction breakpoints */

 Write watchpoint */

 Read-Write watchpoint */

 Icebp traps */

 Int 3 traps */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2016 Google, Inc.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2016 Google, Inc.

 *

 * Original Code by Pavel Labath <labath@google.com>

 *

 * Code modified by Pratyush Anand <panand@redhat.com>

 * for testing different byte select for each access size.

 Write */

 SPDX-License-Identifier: GPL-2.0

 mmap and write a simple pattern */

 Allocate and fill a bunch of buffers */

 mmap and fill with simple pattern */

 close them all */

 Allocate and validate all buffers are zeroed */

 mmap and validate everything is zero */

 close them all */

 Test the ioctl version compatibility w/ a smaller structure then expected */

 Test the ioctl version compatibility w/ a larger structure then expected */

 SPDX-License-Identifier: GPL-2.0

/*

 * Tests for prctl(PR_GET_TSC, ...) / prctl(PR_SET_TSC, ...)

 *

 * Tests if the control register is updated correctly

 * when set with prctl()

 *

 * Warning: this test will cause a very high load for a few seconds

 *

 Get/set the process' ability to use the timestamp counter instruction */

 allow the use of the timestamp counter */

 throw a SIGSEGV instead of reading the TSC */

 snippet from wikipedia :-) */

 We cannot use "=A", since this would use %rax on x86_64 */

 SPDX-License-Identifier: GPL-2.0

/*

 * Tests for prctl(PR_GET_TSC, ...) / prctl(PR_SET_TSC, ...)

 *

 * Tests if the control register is updated correctly

 * at context switches

 *

 * Warning: this test will cause a very high load for a few seconds

 *

 Get/set the process' ability to use the timestamp counter instruction */

 allow the use of the timestamp counter */

 throw a SIGSEGV instead of reading the TSC */

 We cannot use "=A", since this would use %rax on x86_64 */

 */

 SPDX-License-Identifier: GPL-2.0

/*

 * Tests for prctl(PR_GET_TSC, ...) / prctl(PR_SET_TSC, ...)

 *

 * Basic test to test behaviour of PR_GET_TSC and PR_SET_TSC

 Get/set the process' ability to use the timestamp counter instruction */

 allow the use of the timestamp counter */

 throw a SIGSEGV instead of reading the TSC */

 We cannot use "=A", since this would use %rax on x86_64 */

/*

 * Strictly speaking, this is not a test. But it can report during test

 * runs so relative performace can be measured.

 Equal to, or within 1% or 2 digits */

 Avoid using "sysctl" which may not be installed. */

 Native call */

 One filter resulting in a bitmap */

 Second filter resulting in a bitmap */

 Third filter, can no longer be converted to bitmap */

 Fourth filter, can not be converted to bitmap because of filter 3 */

 Estimations */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2012 The Chromium OS Authors. All rights reserved.

 *

 * Test code for seccomp bpf.

/*

 * glibc 2.26 and later have SIGSYS in siginfo_t. Before that,

 * we need to use the kernel's siginfo.h file and trick glibc

 * into accepting it.

 Attempt to de-conflict with the selftests tree. */

 kill the process */

 kill the thread */

 disallow and force a SIGSYS */

 returns an errno */

 pass to a tracer or disallow */

 allow */

 allow after logging */

 Input: which filter */

 Output: filter's flags */

 Flags for seccomp notification fd ioctl. */

 On success, the return value is the remote process's added fd number */

 valid flags for seccomp_notif_addfd */

 Specify remote fd */

 Addfd and return it, atomically */

 Have TH_LOG report actual location filecmp() is used. */

 Note! This doesn't test no new privs behavior */

 Tests kernel support by checking for a copy_from_user() fault on NULL. */

 Succeeds with CAP_SYS_ADMIN, fails without */

 TODO(wad) check caps not euid */

 Too many filter instructions in a single filter. */

 One less is okay, though. */

 Too many total filter instructions. */

 getppid() should succeed and be logged (no check for logging) */

 return code >= 0x80000000 is unused. */

 getpid() should never return. */

 Only both with lower 32-bit for now. */

 times() should never return. */

 Only both with lower 32-bit for now. */

 mmap2() should never return. */

 The test failed, so clean up the resources. */

 This is a thread task to die via seccomp filter violation. */

 Prepare a thread that will kill itself or both of us. */

 Kill only when calling __NR_prctl. */

	/*

	 * Add the KILL_THREAD rule again to make sure that the KILL_PROCESS

	 * flag cannot be downgraded by a new filter.

 Start a thread that will exit immediately. */

 Start a thread that will die immediately. */

	/*

	 * If we get here, only the spawned thread died. Let the parent know

	 * the whole process didn't die (i.e. this thread, the spawner,

	 * stayed running).

 If only the thread was killed, we'll see exit 42. */

 If the entire process was killed, we'll see SIGSYS. */

 If the entire process was killed, we'll see SIGSYS. */

 TODO(wad) add 64-bit versus 32-bit arg tests. */

 Make sure basic errno values are correctly passed through a filter. */

 Make sure an errno of zero is correctly handled by the arch code. */

 "errno" of 0 is ok. */

/*

 * The SECCOMP_RET_DATA mask is 16 bits wide, but errno is smaller.

 * This tests that the errno value gets capped correctly, fixed by

 * 580c57f10768 ("seccomp: cap SECCOMP_RET_ERRNO data to MAX_ERRNO").

/*

 * Filters are processed in reverse order: last applied is executed first.

 * Since only the SECCOMP_RET_ACTION mask is tested for return values, the

 * SECCOMP_RET_DATA mask results will follow the most recently applied

 * matching filter return (and not the lowest or highest value).

 Ensure that SIGSYS overrides SIG_IGN */

	/* Expect the registers to be rolled back. (nr = error) may vary

 Silence gcc warning about volatile. */

 calling user insn */

 triggering system call number */

 AUDIT_ARCH_* of syscall */

 Make sure arch is non-zero. */

 Should work just fine. */

 Should work just fine. */

 getpid() should never return. */

 Should work just fine. */

 getpid() should never return. */

 Should work just fine. */

 getpid() should never return. */

 Should work just fine. */

 getpid() should never return. */

 Should work just fine. */

 Should work just fine. */

 Should work just fine. */

 No ptracer */

 Should work just fine. */

 No ptracer */

 Should work just fine. */

 Should also work just fine */

 Should work just fine. */

 Should also work just fine */

 Catch the Ubuntu 12.04 value error. */

 Allow external shutdown. */

 Wait for attach stop */

 Unblock the tracee */

 Run until we're shut down. Must assert to stop execution. */

 Child is dead. Time to go. */

 Check if this is a seccomp event. */

 Directly report the status of our test harness results. */

 Common tracer setup/teardown functions. */

 Setup a pipe for clean synchronization. */

 Fork a child which we'll promote to tracer */

		/*

		 * Extract the exit code from the other process and

		 * adopt it for ourselves in case its asserts failed.

 "poke" tracer arguments and function. */

 If this fails, don't try to recover. */

	/*

	 * Poke in the message.

	 * Registers are not touched to try to keep this relatively arch

	 * agnostic.

 Set up tracer args. */

 Launch tracer. */

			/*					\

			 * scv 0 system call uses -ve result	\

			 * for error, so no need to adjust.	\

			/*					\

			 * A syscall error is signaled by the	\

			 * CR0 SO bit and the code is stored as	\

			 * a positive value.			\

/*

 * On xtensa syscall return value is in the register

 * a2 of the current window which is not fixed.

/*

 * Most architectures can change the syscall by just updating the

 * associated register. This is the default if not defined above.

/*

 * Most architectures can change the syscall return value by just

 * writing to the SYSCALL_RET register. This is the default if not

 * defined above. If an architecture cannot set the return value

 * (for example when the syscall and return value register is

 * shared), report it with TH_LOG() in an arch-specific definition

 * of SYSCALL_RET_SET() above, and leave SYSCALL_RET undefined.

 When the syscall return can't be changed, stub out the tests for it. */

/*

 * Some architectures (e.g. powerpc) can only set syscall

 * return values on syscall exit during ptrace.

/*

 * Use PTRACE_GETREGS and PTRACE_SETREGS when available. This is useful for

 * architectures without HAVE_ARCH_TRACEHOOK (e.g. User-mode Linux).

 Architecture-specific syscall fetching routine. */

 Architecture-specific syscall changing routine. */

 Do not get/set registers if we have nothing to do. */

 Flush any register changes made. */

 Change only syscall number. */

 Change syscall return value (and set syscall number to -1). */

 Make sure we got the right message. */

 Validate and take action on expected syscalls. */

 change getpid to getppid. */

 skip gettid with valid return code. */

 skip openat with error. */

 do nothing (allow getppid) */

	/*

	 * The traditional way to tell PTRACE_SYSCALL entry/exit

	 * is by counting.

 Make sure we got an appropriate message. */

	/*

	 * Some architectures only support setting return values during

	 * syscall exit under ptrace, and on exit the syscall number may

	 * no longer be available. Therefore, save the initial sycall

	 * number here, so it can be examined during both entry and exit

	 * phases.

	/*

	 * Depending on the architecture's syscall setting abilities, we

	 * pick which things to set during this phase (entry or exit).

 Now handle the actual rewriting cases. */

 Never change syscall return for this case. */

 Unhandled, do nothing. */

	/*

	 * All of the SECCOMP_RET_TRACE behaviors can be tested with either

	 * SECCOMP_RET_TRACE+PTRACE_CONT or plain ptrace()+PTRACE_SYSCALL.

	 * This indicates if we should use SECCOMP_RET_TRACE (false), or

	 * ptrace (true).

 Prepare some testable syscall results. */

 Launch tracer. */

	/*

	 * There should be no difference between an "internal" skip

	 * and userspace asking for syscall "-1".

 And no difference for "still not valid but not -1". */

 getppid works as expected (no changes). */

 getpid has been redirected to getppid as expected. */

 Tracer should skip the open syscall, resulting in ESRCH. */

 Tracer skips the gettid syscall and store altered return value. */

 Install additional "errno on getppid" filter. */

 Tracer will redirect getpid to getppid, and we should see EPERM. */

 Install additional "death on getppid" filter. */

 Tracer will redirect getpid to getppid, and we should die. */

 Reject insane operation. */

 Reject strict with flags or pointer. */

 Reject insane args for filter. */

 Make sure neither entry point will switch to strict. */

/*

 * Test detection of known and unknown filter flags. Userspace needs to be able

 * to check if a filter flag is supported by the current kernel and a good way

 * of doing that is by attempting to enter filter mode, with the flag bit in

 * question set, and a NULL pointer for the _args_ parameter. EFAULT indicates

 * that the flag is valid and EINVAL indicates that the flag is invalid.

 Test detection of individual known-good filter flags */

 Make sure the flag is a single bit! */

	/*

	 * Test detection of all known-good filter flags combined. But

	 * for the exclusive flags we need to mask them out and try them

	 * individually for the "all flags" testing.

 Test detection of an unknown filter flags, without exclusives. */

	/*

	 * Test detection of an unknown filter flag that may simply need to be

	 * added to this test

/*

 * To avoid joining joined threads (which is not allowed by Bionic),

 * make sure we both successfully join and clear the tid to skip a

 * later join attempt during fixture teardown. Any remaining threads

 * will be directly killed during teardown.

		/*

		 * If a thread is still running, it may be stuck, so hit

		 * it over the head really hard.

 Just re-apply the root prog to fork the tree */

 Return outside of started so parent notices failures. */

 Check prctl failure detection by requesting sib 0 diverge. */

 Signal the threads to clean up*/

 Ensure diverging sibling failed to call prctl. */

 Tell the siblings to test the policy */

 Ensure they are both killed and don't exit cleanly. */

 start siblings before any prctl() operations */

 Tell the siblings to test no policy */

 Ensure they are both upset about lacking nnp. */

 start siblings before any prctl() operations */

 Tell the siblings to test the policy */

 Ensure they are both killed and don't exit cleanly. */

 Wake the threads */

 Ensure they are both unkilled. */

 Wake the threads */

 Ensure they are both unkilled. */

	/*

	 * Sibling 0 will have its own seccomp policy

	 * and Sibling 1 will not be under seccomp at

	 * all. Sibling 1 will enter seccomp and 0

	 * will cause failure.

	/* Increment the other siblings num_waits so we can clean up

	 * the one we just saw.

 Signal the thread to clean up*/

 Poll for actual task death. pthread_join doesn't guarantee it. */

 Switch to the remaining sibling */

	/* If remaining sibling didn't have a chance to wake up during

	 * the first broadcast, manually reduce the num_waits now.

 Poll for actual task death. pthread_join doesn't guarantee it. */

 just us chickens */

 Make sure restarted syscalls are seen directly as "restart_syscall". */

 Allow __NR_write for easy logging. */

 The nanosleep jump target. */

 The restart_syscall jump target. */

 Child uses EXPECT not ASSERT to deliver status correctly. */

 Attach parent as tracer and stop. */

 Start nanosleep to be interrupted. */

 Read final sync from parent. */

 Directly report the status of our test harness results. */

 Attach to child, setup options, and release. */

 Wait for nanosleep() to start. */

 Might as well check siginfo for sanity while we're here. */

 Verify signal delivery came from child (seccomp-triggered). */

 Interrupt nanosleep with SIGSTOP (which we'll need to handle). */

	/*

	 * There is no siginfo on SIGSTOP any more, so we can't verify

	 * signal delivery came from parent now (getpid() == info.si_pid).

	 * https://lkml.kernel.org/r/CAGXu5jJaZAOzP1qFz66tYrtbuywqb+UN2SOA1VLHpCCOiYvYeg@mail.gmail.com

	 * At least verify the SIGSTOP via PTRACE_GETSIGINFO.

 Restart nanosleep with SIGCONT, which triggers restart_syscall. */

 Wait for restart_syscall() to start. */

	/*

	 * FIXME:

	 * - native ARM registers do NOT expose true syscall.

	 * - compat ARM registers on ARM64 DO expose true syscall.

 Write again to end test. */

 Verify that the FILTER_FLAG_LOG flag isn't accepted in strict mode */

 Verify that a simple, permissive filter can be added with no flags */

 See if the same filter can be added with the FILTER_FLAG_LOG flag */

 Ensure that the kill filter works with the FILTER_FLAG_LOG flag */

 getpid() should never return. */

 Check that an unknown action is handled properly (EOPNOTSUPP) */

 Only real root can get metadata. */

 one with log, one without */

 Past here must not use ASSERT or child process is never killed. */

 Check that we get -ENOSYS with no listener attached */

 Add some no-op filters for grins. */

 Check that the basic notification machinery works */

 Installing a second listener in the chain should EBUSY */

 Test that we can't pass garbage to the kernel. */

 check that we make sure flags == 0 */

 these were exclusive */

 but now they're not */

	/*

	 * Check that nothing bad happens when we kill the task in the middle

	 * of a syscall.

		/*

		 * ERESTARTSYS behavior is a bit hard to test, because we need

		 * to rely on a signal that has not yet been handled. Let's at

		 * least check that the error code gets propagated through, and

		 * hope that it doesn't break when there is actually a signal :)

	/*

	 * Make sure the signal really is delivered, which means we're not

	 * stuck in the user notification code any more and the notification

	 * should be dead.

 -ERESTARTSYS */

	/*

	 * Check that we get an ENOSYS when the listener is closed.

/*

 * Check that a pid in a child namespace still shows up as valid in ours.

/*

 * Check that a pid in a sibling (i.e. unrelated) namespace shows up as 0, i.e.

 * invalid.

 Create the sibling ns, and sibling in it. */

		/*

		 * The pid should be 0, i.e. the task is in some namespace that

		 * we can't "see".

 Do a bad recv() */

 We should still be able to receive this notification, though. */

	/*

	 * Verify that setting SECCOMP_USER_NOTIF_FLAG_CONTINUE enforces other

	 * args be set to 0.

	/*

	 * The seccomp filter has become unused so we should be notified once

	 * the kernel gets around to cleaning up task struct.

	/*

	 * The seccomp filter has become unused so we should be notified once

	 * the kernel gets around to cleaning up task struct.

 100 ms */

 There may be arbitrary already-open fds at test start. */

 fd: 4 */

 Check that the basic notification machinery works */

 fds will be added and this value is expected */

 Atomic addfd+send is received here. Check it is a valid fd */

 Verify bad newfd_flags cannot be set */

 Verify bad flags cannot be set */

 Verify that remote_fd cannot be set without setting flags */

 Verify small size cannot be set */

 Verify we can't send bits filled in unknown buffer area */

 Verify we can set an arbitrary remote fd */

 Verify we can set an arbitrary remote fd with large size */

 Verify we can set a specific remote fd */

 Resume syscall */

	/*

	 * This sets the ID of the ADD FD to the last request plus 1. The

	 * notification ID increments 1 per notification.

 This spins until the underlying notification is generated */

 Verify we can do an atomic addfd and send */

	/*

	 * Child has earlier "low" fds and now 42, so we expect the next

	 * lowest available fd to be assigned here.

	/*

	 * This sets the ID of the ADD FD to the last request plus 1. The

	 * notification ID increments 1 per notification.

 This spins until the underlying notification is generated */

 Wait for child to finish. */

 Check that the basic notification machinery works */

 Should probably spot check /proc/sys/fs/file-nr */

 Wait for child to finish. */

/*

 * TODO:

 * - expand NNP testing

 * - better arch-specific TRACE and TRAP handlers.

 * - endianness checking when appropriate

 * - 64-bit arg prodding

 * - arch value testing (x86 modes especially)

 * - verify that FILTER_FLAG_LOG filters generate log messages

 * - verify that RET_LOG generates log messages

 SPDX-License-Identifier: GPL-2.0

  main() pid is used to avoid duplicate test counts */

	/*

	 * TODO: If we're already root, we could skip creating the userns.

 Re-enable effective caps

 no short writes on tmpfs */

 don't print this message for mpid */

 Make sure that i starts out clear */

 We should not be able to add ambient caps yet. */

 The remaining tests need real privilege */

 Find our path */

 SPDX-License-Identifier: GPL-2.0

	/*

	 * Be careful just in case a setgid or setcapped copy of this

	 * helper gets out.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Author: Alexey Gladkov <gladkov.alexey@gmail.com>

	/*

	 * This rlimit is not a problem for root because it can be exceeded.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2020 Collabora Ltd.

 *

 * Test code for syscall user dispatch

 Bad Linux syscall number */

 Bad Linux syscall number */

/* Test Summary:

 *

 * - dispatch_trigger_sigsys: Verify if PR_SET_SYSCALL_USER_DISPATCH is

 *   able to trigger SIGSYS on a syscall.

 *

 * - bad_selector: Test that a bad selector value triggers SIGSYS with

 *   si_errno EINVAL.

 *

 * - bad_prctl_param: Test that the API correctly rejects invalid

 *   parameters on prctl

 *

 * - dispatch_and_return: Test that a syscall is selectively dispatched

 *   to userspace depending on the value of selector.

 *

 * - disable_dispatch: Test that the PR_SYS_DISPATCH_OFF correctly

 *   disables the dispatcher

 *

 * - direct_dispatch_range: Test that a syscall within the allowed range

 *   can bypass the dispatcher.

 Invalid op */

 PR_SYS_DISPATCH_OFF */

 offset != 0 */

 len != 0 */

 sel != NULL */

 Valid parameter */

 PR_SYS_DISPATCH_ON */

 Dispatcher region is bad (offset > 0 && len == 0) */

 Invalid selector */

	/*

	 * Dispatcher range overflows unsigned long

	/*

	 * Allowed range overflows usigned long

/*

 * Use global selector for handle_sigsys tests, to avoid passing

 * selector to signal handler

 In preparation for sigreturn. */

 Make sure selector is good prior to prctl. */

 MAGIC_SYSCALL_1 doesn't exist. */

 MAGIC_SYSCALL_1 should be emulated. */

 Make sure selector is good prior to prctl. */

	/* Even though it is ready to catch SIGSYS, the signal is

	 * supposed to be uncatchable.

 MAGIC_SYSCALL_1 doesn't exist. */

 Shouldn't have any effect... */

	/*

	 * Instead of calculating libc addresses; allow the entire

	 * memory map and lock the selector.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2020 Collabora Ltd.

 *

 * Benchmark and test syscall user dispatch

 Bad Linux syscall number */

 Bad Linux syscall number */

/*

 * To test returning from a sigsys with selector blocked, the test

 * requires some per-architecture support (i.e. knowledge about the

 * signal trampoline address).  On i386, we know it is on the vdso, and

 * a small trampoline is open-coded for x86_64.  Other architectures

 * that have a trampoline in the vdso will support TEST_BLOCKED_RETURN

 * out of the box, but don't enable them until they support syscall user

 * dispatch.

 printf and friends are not signal-safe. */

 Landing pad within dispatcher area */

 SPDX-License-Identifier: GPL-2.0

 o32 */

 n32 */

 n64 */

 create a couple of gaps */

 test that the kernel caps and still closes all fds */

 create a couple of gaps */

 test that the kernel caps and still closes all fds */

 Ensure the FD_CLOEXEC bit is set also with a resource limit in place.  */

 Set close-on-exec for two ranges: [0-50] and [75-100].  */

 Test a common pattern.  */

 Ensure the FD_CLOEXEC bit is set also with a resource limit in place.  */

 Set close-on-exec for two ranges: [0-50] and [75-100].  */

 Test a common pattern.  */

/*

 * Regression test for syzbot+96cfd2b22b3213646a93@syzkaller.appspotmail.com

 Create a huge gap in the fd table. */

		/*

			 * We now have a private file descriptor table and all

			 * our open fds should still be open but made

			 * close-on-exec.

		/*

			 * Duplicating the file descriptor must remove the

			 * FD_CLOEXEC flag.

	/*

	 * We had a shared file descriptor table before along with requesting

	 * close-on-exec so the original fds must not be close-on-exec.

/*

 * Regression test for syzbot+96cfd2b22b3213646a93@syzkaller.appspotmail.com

	/*

	 * Create a huge gap in the fd table. When we now call

	 * CLOSE_RANGE_UNSHARE with a shared fd table and and with ~0U as upper

	 * bound the kernel will only copy up to fd1 file descriptors into the

	 * new fd table. If the kernel is buggy and doesn't handle

	 * CLOSE_RANGE_CLOEXEC correctly it will not have copied all file

	 * descriptors and we will oops!

	 *

	 * On a buggy kernel this should immediately oops. But let's loop just

	 * to be sure.

			/*

			 * We now have a private file descriptor table and all

			 * our open fds should still be open but made

			 * close-on-exec.

			/*

			 * Duplicating the file descriptor must remove the

			 * FD_CLOEXEC flag.

	/*

	 * We created a private file descriptor table before along with

	 * requesting close-on-exec so the original fds must not be

	 * close-on-exec.

 SPDX-License-Identifier: GPL-2.0

/*

 * Example of using hugepage memory in a user application using the mmap

 * system call with MAP_HUGETLB flag.  Before running this program make

 * sure the administrator has allocated enough default sized huge pages

 * to cover the 256 MB allocation.

 *

 * For ia64 architecture, Linux kernel reserves Region number 4 for hugepages.

 * That means the addresses starting with 0x800000... will need to be

 * specified.  Specifying a fixed address is not required on ppc64, i386

 * or x86_64.

 arch specific */

 Only ia64 requires this */

 munmap() length of MAP_HUGETLB memory must be hugepage aligned */

/*

 * Stress test for transparent huge pages, memory compaction and migration.

 *

 * Authors: Konstantin Khlebnikov <koct9i@gmail.com>

 *

 * This is free and unencumbered software released into the public domain.

 drop pmd */

 allocate transparent huge page */

 split transhuge page, keep last page */

 SPDX-License-Identifier: GPL-2.0

/*

 * A test of splitting PMD THPs and PTE-mapped THPs from a specified virtual

 * address range in a process via <debugfs>/split_huge_pages interface.

	/*

	 * Fetch the AnonHugePages: in the same block and check the number of

	 * hugepages.

 split all THPs */

 remap the first pagesize of first THP */

 remap the Nth pagesize of Nth THP */

 smap does not show THPs after mremap, use kpageflags instead */

 split all remapped THPs */

 smap does not show THPs after mremap, use kpageflags instead */

 write something to the file, so a file-backed THP can be allocated */

 split the file-backed THP */

 SPDX-License-Identifier: GPL-2.0

/*

 * Tests Memory Protection Keys (see Documentation/core-api/protection-keys.rst)

 *

 * There are examples in here of:

 *  * how to set protection keys on memory

 *  * how to set/clear bits in pkey registers (the rights register)

 *  * how to handle SEGV_PKUERR signals and extract pkey-relevant

 *    information from the siginfo

 *

 * Things to add:

 *	make sure KSM and KSM COW breaking works

 *	prefault pages in at malloc, or not

 *	protect MPX bounds tables with protection keys?

 *	make sure VMA splitting/merging is working correctly

 *	OOMs can destroy mm->mmap (see exit_mmap()), so make sure it is immune to pkeys

 *	look for pkey "leaks" where it is still set on a VMA but "freed" back to the kernel

 *	do a plain mprotect() to a mprotect_pkey() area and make sure the pkey sticks

 *

 * Compile like this:

 *	gcc      -o protection_keys    -O2 -g -std=gnu99 -pthread -Wall protection_keys.c -lrt -ldl -lm

 *	gcc -m32 -o protection_keys_32 -O2 -g -std=gnu99 -pthread -Wall protection_keys.c -lrt -ldl -lm

	/*

	 * these need to be raw because they are called under

	 * pkey_assert()

/*

 * This attempts to have roughly a page of instructions followed by a few

 * instructions that do a write, and another page of instructions.  That

 * way, we are pretty sure that the write is in the second page of

 * instructions and has at least a page of padding behind it.

 *

 * *That* lets us be sure to madvise() away the write instruction, which

 * will then fault, which makes sure that the fault code handles

 * execute-only memory properly.

 This way, both 4K and 64K alignment are maintained */

 Assume this happens in the second page of instructions: */

 pad out by another page: */

 make sure that 'rights' only contains the bits we expect: */

 modify bits accordingly in old pkey_reg and assign it */

 pkey_reg and flags have the same format */

 Failed address bound checks: */

 arch */

 arch */

 arch */

	/*

	 * 32-bit has some extra padding so that userspace can tell whether

	 * the XSTATE header is present in addition to the "legacy" FPU

	 * state.  We just assume that it is here.

 i386 */

	/*

	 * If we got a PKEY fault, we *HAVE* to have at least one bit set in

	 * here.

 arch */

	/*

	 * need __read_pkey_reg() version so we do not do shadow_pkey_reg

	 * checking

 arch */

 arch */

 restore access and let the faulting instruction continue */

 arch */

 #PF is mapped to sigsegv */

sigset_t - signals to block while in the handler */

 get the old signal mask. */

 call sa_sigaction, not sa_handler*/

 void(*)(), obsolete */

 in the child */

	/*

	 * pkey_alloc() sets PKEY register, so we need to reflect it in

	 * shadow_pkey_reg:

 clear both the bits: */

		/*

		 * move the new state in from init_val

		 * (remember, we cheated and init_val == pkey_reg format)

 for shadow checking: */

/*

 * I had a bug where pkey bits could be set by mprotect() but

 * not cleared.  This ensures we get lots of random bit sets

 * and clears on the vma and pte pkey bits.

 allocate every possible key and make a note of which ones we got */

 select a random one out of the allocated ones */

 now zero it out so we don't free it next */

 go through the allocated ones that we did not want and free them */

 find a free record */

 every record is full */

		/*

		 * realloc() does not initialize memory, so zero it from

		 * the first new record all the way to the end.

	/*

	 * Guarantee we can fit at least one huge page in the resulting

	 * allocation by allocating space for 2:

	/*

	 * Now go make sure that we got the pages and that they

	 * are PMD-level pages. Someone might have made PUD-level

	 * pages the default.

 -1 to guarantee leaving the trailing \0 */

/* can not do direct with the pkey_mprotect() API:

	malloc_pkey_mmap_direct,

	malloc_pkey_mmap_dax,

 try again if the malloc_type we tried is unsupported */

       /*

	* For exec-only memory, we do not know the pkey in

	* advance, so skip this check.

 arch */

	/*

	 * The signal handler shold have cleared out PKEY register to let the

	 * test program continue.  We now have to restore it.

 arch */

 arch */

	/*

	 * Keep GCC from optimizing this away somehow

	/*

	 * This is a bit of a hack.  But mprotect() requires

	 * huge-page-aligned sizes when operating on hugetlbfs.

	 * So, make sure that we use something that's a multiple

	 * of a huge page when we can.

 allocate every possible key and make sure key-0 never got allocated */

 free all the allocated keys */

 attach key-0 in various modes */

 Assumes that all pkeys other than 'pkey' are unallocated */

 Note: 0 is the default pkey, so don't mess with it */

 Assumes that all pkeys other than 'pkey' are unallocated */

 pass a known-invalid pkey in: */

 in the child */

 Assumes that all pkeys other than 'pkey' are unallocated */

 for shadow checking */

			/*

			 * Ensure the number of successes never

			 * exceeds the number of keys supported

			 * in the hardware.

		/*

		 * Make sure that allocation state is properly

		 * preserved across fork().

	/*

	 * On x86:

	 * There are 16 pkeys supported in hardware.  Three are

	 * allocated by the time we get here:

	 *   1. The default key (0)

	 *   2. One possibly consumed by an execute-only mapping.

	 *   3. One allocated by the test code and passed in via

	 *      'pkey' to this function.

	 * Ensure that we can allocate at least another 13 (16-3).

	 *

	 * On powerpc:

	 * There are either 5, 28, 29 or 32 pkeys supported in

	 * hardware depending on the page size (4K or 64K) and

	 * platform (powernv or powervm). Four are allocated by

	 * the time we get here. These include pkey-0, pkey-1,

	 * exec-only pkey and the one allocated by the test code.

	 * Ensure that we can allocate the remaining.

 for shadow checking */

 arch */

	/*

	 * All keys should be allocated and set to allow reads and

	 * writes, so the register should be all 0.  If not, just

	 * skip the test.

	/*

	 * Just allocate an absurd about of memory rather than

	 * doing the XSAVE size enumeration dance.

 These __builtins require compiling with -mxsave */

 XSAVE to build a valid buffer: */

 Clear XSTATE_BV[PKRU]: */

 XRSTOR will likely get PKRU back to the init state: */

/*

 * This is mostly useless on ppc for now.  But it will not

 * hurt anything and should give some better coverage as

 * a long-running test that continually checks the pkey

 * register.

	/*

	 * Loop for a bit, hoping to get exercise the kernel

	 * context switch code.

 for shadow checking */

/*

 * pkey 0 is special.  It is allocated by default, so you do not

 * have to call pkey_alloc() to use it first.  Make sure that it

 * is usable.

	/*

	 * This is a bit of a hack.  But mprotect() requires

	 * huge-page-aligned sizes when operating on hugetlbfs.

	 * So, make sure that we use something that's a multiple

	 * of a huge page when we can.

 Use pkey 0 */

 Make sure that we can set it back to the original pkey. */

	/*

	 * This is the "control" for our little expermient.  Make sure

	 * we can always access it when ptracing.

	/*

	 * Fork a child which is an exact copy of this process, of course.

	 * That means we can do all of our tests via ptrace() and then plain

	 * memory access and ensure they work differently.

	/* Write access, untested for now:

	ret = ptrace(PTRACE_POKEDATA, child_pid, peek_at, data);

	pkey_assert(ret != -1);

	dprintf1("poke at %p: %ld\n", peek_at, ret);

	/*

	 * Try to access the pkey-protected "ptr" via ptrace:

 expect it to work, without an error: */

 Now access from the current task, and expect an exception: */

	/*

	 * Try to access the NON-pkey-protected "plain_ptr" via ptrace:

 expect it to work, without an error: */

 Now access from the current task, and expect NO exception: */

 lots_o_noops_around_write should be page-aligned already */

 Point 'p1' at the *second* page of the function: */

	/*

	 * Try to ensure we fault this in on next touch to ensure

	 * we get an instruction fault as opposed to a data one

	/*

	 * Make sure this is an *instruction* fault

 Use a *normal* mprotect(), not mprotect_pkey(): */

	/*

	 * Reset the shadow, assuming that the above mprotect()

	 * correctly changed PKRU, but to an unknown value since

	 * the actual alllocated pkey is unknown.

 Make sure this is an *instruction* fault */

	/*

	 * Put the memory back to non-PROT_EXEC.  Should clear the

	 * exec-only pkey off the VMA and allow it to be readable

	 * again.  Go to PROT_NONE first to check for a kernel bug

	 * that did not clear the pkey when doing PROT_NONE.

 SPDX-License-Identifier: GPL-2.0

/*

 * hugepage-shm:

 *

 * Example of using huge page memory in a user application using Sys V shared

 * memory system calls.  In this example the app is requesting 256MB of

 * memory that is backed by huge pages.  The application uses the flag

 * SHM_HUGETLB in the shmget system call to inform the kernel that it is

 * requesting huge pages.

 *

 * For the ia64 architecture, the Linux kernel reserves Region number 4 for

 * huge pages.  That means that if one requires a fixed address, a huge page

 * aligned address starting with 0x800000... will be required.  If a fixed

 * address is not required, the kernel will select an address in the proper

 * range.

 * Other architectures, such as ppc64, i386 or x86_64 are not so constrained.

 *

 * Note: The default shared memory limit is quite low on many kernels,

 * you may need to increase it via:

 *

 * echo 268435456 > /proc/sys/kernel/shmmax

 *

 * This will increase the maximum size per shared memory segment to 256MB.

 * The other limit that you will hit eventually is shmall which is the

 * total amount of shared memory in pages. To set it to 16GB on a system

 * with a 4kB pagesize do:

 *

 * echo 4194304 > /proc/sys/kernel/shmall

 Only ia64 requires this */

 SPDX-License-Identifier: GPL-2.0

/*

 * Test that MAP_FIXED_NOREPLACE works.

 *

 * Copyright 2018, Jann Horn <jannh@google.com>

 * Copyright 2018, Michael Ellerman, IBM Corporation.

 Check we can map all the areas we need below

	/*

	 * Exact same mapping again:

	 *   base |  free  | new

	 *     +1 | mapped | new

	 *     +2 | mapped | new

	 *     +3 | mapped | new

	 *     +4 |  free  | new

	/*

	 * Second mapping contained within first:

	 *

	 *   base |  free  |

	 *     +1 | mapped |

	 *     +2 | mapped | new

	 *     +3 | mapped |

	 *     +4 |  free  |

	/*

	 * Overlap end of existing mapping:

	 *   base |  free  |

	 *     +1 | mapped |

	 *     +2 | mapped |

	 *     +3 | mapped | new

	 *     +4 |  free  | new

	/*

	 * Overlap start of existing mapping:

	 *   base |  free  | new

	 *     +1 | mapped | new

	 *     +2 | mapped |

	 *     +3 | mapped |

	 *     +4 |  free  |

	/*

	 * Adjacent to start of existing mapping:

	 *   base |  free  | new

	 *     +1 | mapped |

	 *     +2 | mapped |

	 *     +3 | mapped |

	 *     +4 |  free  |

	/*

	 * Adjacent to end of existing mapping:

	 *   base |  free  |

	 *     +1 | mapped |

	 *     +2 | mapped |

	 *     +3 | mapped |

	 *     +4 |  free  |  new

 SPDX-License-Identifier: GPL-2.0

/*

 * It tests the mlock/mlock2() when they are invoked

 * on randomly memory region.

 drop capabilities including CAP_IPC_LOCK */

/*

 * Get the MMUPageSize of the memory region including input

 * address from proc file.

 *

 * return value: on error case, 0 will be returned.

 * Otherwise the page size(in bytes) is returned.

 found the MMUPageSize of this section */

/*

 * Test mlock/mlock2() on provided memory chunk.

 * It expects the mlock/mlock2() to be successful (within rlimit)

 *

 * With allocated memory chunk [p, p + alloc_size), this

 * test will choose start/len randomly to perform mlock/mlock2

 * [start, start +  len] memory range. The range is within range

 * of the allocated chunk.

 *

 * The memory region size alloc_size is within the rlimit.

 * So we always expect a success of mlock/mlock2.

 *

 * VmLck is assumed to be 0 before this test.

 *

 *    return value: 0 - success

 *    else: failure

		/*

		 * - choose mlock/mlock2 randomly

		 * - choose lock_size randomly but lock_size < alloc_size

		 * - choose start_offset randomly but p+start_offset+lock_size

		 *   < p+alloc_size

	/*

	 * Check VmLck left by the tests.

/*

 * We expect the mlock/mlock2() to be fail (outof limitation)

 *

 * With allocated memory chunk [p, p + alloc_size), this

 * test will randomly choose start/len and perform mlock/mlock2

 * on [start, start+len] range.

 *

 * The memory region size alloc_size is above the rlimit.

 * And the len to be locked is higher than rlimit.

 * So we always expect a failure of mlock/mlock2.

 * No locked page number should be increased as a side effect.

 *

 *    return value: 0 - success

 *    else: failure

 SPDX-License-Identifier: GPL-2.0-only

/*

 *

 * Authors: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>

 * Authors: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>

/*

 * This will work with 16M and 2M hugepage size

/*

 * >= 128TB is the hint addr value we used to select

 * large address space.

		/*

		 * If stack is moved, we could possibly allocate

		 * this at the requested address.

		/*

		 * We should never allocate at the requested address or above it

		 * The len cross the 128TB boundary. Without MAP_FIXED

		 * we will always search in the lower address space.

		/*

		 * Exact mapping at 128TB, the area is free we should get that

		 * even without MAP_FIXED.

			/*

			 * Do a dereference of the address returned so that we catch

			 * bugs in page fault handling

 SPDX-License-Identifier: GPL-2.0

/*

 * hugepage-mmap:

 *

 * Example of using huge page memory in a user application using the mmap

 * system call.  Before running this application, make sure that the

 * administrator has mounted the hugetlbfs filesystem (on some directory

 * like /mnt) using the command mount -t hugetlbfs nodev /mnt. In this

 * example, the app is requesting memory of size 256MB that is backed by

 * huge pages.

 *

 * For the ia64 architecture, the Linux kernel reserves Region number 4 for

 * huge pages.  That means that if one requires a fixed address, a huge page

 * aligned address starting with 0x800000... will be required.  If a fixed

 * address is not required, the kernel will select an address in the proper

 * range.

 * Other architectures, such as ppc64, i386 or x86_64 are not so constrained.

 Only ia64 requires this */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2018 Dmitry Safonov, Arista Networks

 *

 * MAP_POPULATE | MAP_PRIVATE should COW VMA pages.

 Probably unnecessary, but let it be. */

 SPDX-License-Identifier: GPL-2.0

/*

 * HMM stands for Heterogeneous Memory Management, it is a helper layer inside

 * the linux kernel to help device drivers mirror a process address space in

 * the device. This allows the device to use the same address space which

 * makes communication and data exchange a lot easier.

 *

 * This framework's sole purpose is to exercise various code paths inside

 * the kernel to make sure that HMM performs as expected and to flush out any

 * bugs.

/*

 * This is a private UAPI to the kernel test module so it isn't exported

 * in the usual include/uapi/... directory.

 Simulate a device reading system memory. */

/*

 * Create a temporary file that will be deleted on close.

/*

 * Return a random unsigned number.

/*

 * Simple NULL test of device open/close.

/*

 * Read private anonymous memory.

	/*

	 * Initialize buffer in system memory but leave the first two pages

	 * zero (pte_none and pfn_zero).

 Set buffer permission to read-only. */

 Populate the CPU page table with a special zero page. */

 Simulate a device reading system memory. */

 Check what the device read. */

/*

 * Read private anonymous memory which has been protected with

 * mprotect() PROT_NONE.

 Initialize buffer in system memory. */

 Initialize mirror buffer so we can verify it isn't written. */

 Protect buffer from reading. */

 Simulate a device reading system memory. */

 Allow CPU to read the buffer so we can check it. */

 Check what the device read. */

/*

 * Write private anonymous memory.

 Initialize data that the device will write to buffer->ptr. */

 Simulate a device writing system memory. */

 Check what the device wrote. */

/*

 * Write private anonymous memory which has been protected with

 * mprotect() PROT_READ.

 Simulate a device reading a zero page of memory. */

 Initialize data that the device will write to buffer->ptr. */

 Simulate a device writing system memory. */

 Check what the device wrote. */

 Now allow writing and see that the zero page is replaced. */

 Simulate a device writing system memory. */

 Check what the device wrote. */

/*

 * Check that a device writing an anonymous private mapping

 * will copy-on-write if a child process inherits the mapping.

 Initialize buffer->ptr so we can tell if it is written. */

 Initialize data that the device will write to buffer->ptr. */

 Check that the parent's buffer did not change. */

 Check that we see the parent's values. */

 The child process needs its own mirror to its own mm. */

 Simulate a device writing system memory. */

 Check what the device wrote. */

/*

 * Check that a device writing an anonymous shared mapping

 * will not copy-on-write if a child process inherits the mapping.

 Initialize buffer->ptr so we can tell if it is written. */

 Initialize data that the device will write to buffer->ptr. */

 Check that the parent's buffer did change. */

 Check that we see the parent's values. */

 The child process needs its own mirror to its own mm. */

 Simulate a device writing system memory. */

 Check what the device wrote. */

/*

 * Write private anonymous huge page.

 Initialize data that the device will write to buffer->ptr. */

 Simulate a device writing system memory. */

 Check what the device wrote. */

/*

 * Write huge TLBFS page.

 Skip test if we can't allocate a hugetlbfs page. */

 Initialize data that the device will write to buffer->ptr. */

 Simulate a device writing system memory. */

 Check what the device wrote. */

 LOCAL_CONFIG_HAVE_LIBHUGETLBFS */

/*

 * Read mmap'ed file memory.

 Write initial contents of the file. */

 Simulate a device reading system memory. */

 Check what the device read. */

/*

 * Write mmap'ed file memory.

 Initialize data that the device will write to buffer->ptr. */

 Simulate a device writing system memory. */

 Check what the device wrote. */

 Check that the device also wrote the file. */

/*

 * Migrate anonymous memory to device private memory.

 Initialize buffer in system memory. */

 Migrate memory to device. */

 Check what the device read. */

/*

 * Migrate anonymous memory to device private memory and fault some of it back

 * to system memory, then try migrating the resulting mix of system and device

 * private memory to the device.

 Initialize buffer in system memory. */

 Migrate memory to device. */

 Check what the device read. */

 Fault half the pages back to system memory and check them. */

 Migrate memory to the device again. */

 Check what the device read. */

/*

 * Migrate anonymous shared memory to device private memory.

 Migrate memory to device. */

/*

 * Try to migrate various memory types to device private memory.

 Reserve a range of addresses. */

 Migrating a protected area should be an error. */

 Punch a hole after the first page address. */

 We expect an error if the vma doesn't cover the range. */

 Page 2 will be a read-only zero page. */

 Page 3 will be read-only. */

 Page 4-5 will be read-write. */

 Now try to migrate pages 2-5 to device 1. */

 Page 5 won't be migrated to device 0 because it's on device 1. */

/*

 * Migrate anonymous memory to device private memory and fault it back to system

 * memory multiple times.

 Initialize buffer in system memory. */

 Migrate memory to device. */

 Check what the device read. */

 Fault pages back to system memory and check them. */

/*

 * Read anonymous memory multiple times.

 Initialize buffer in system memory. */

 Simulate a device reading system memory. */

 Check what the device read. */

 Delay for a bit and then unmap buffer while it is being read. */

/*

 * Try reading anonymous memory while it is being unmapped.

 Initialize buffer in system memory. */

 Simulate a device reading system memory. */

 Check what the device read. */

/*

 * Test memory snapshot without faulting in pages accessed by the device.

 Reserve a range of addresses. */

 Punch a hole after the first page address. */

 Page 2 will be read-only zero page. */

 Page 3 will be read-only. */

 Page 4-6 will be read-write. */

 Page 5 will be migrated to device 0. */

 Page 6 will be migrated to device 1. */

 Simulate a device snapshotting CPU pagetables. */

 Check what the device saw. */

/*

 * Test the hmm_range_fault() HMM_PFN_PMD flag for large pages that

 * should be mapped by a large page table entry.

 Skip test if we can't allocate a hugetlbfs page. */

 Initialize the pages the device will snapshot in buffer->ptr. */

 Simulate a device snapshotting CPU pagetables. */

 Check what the device saw. */

 Make the region read-only. */

 Simulate a device snapshotting CPU pagetables. */

 Check what the device saw. */

 LOCAL_CONFIG_HAVE_LIBHUGETLBFS */

/*

 * Test two devices reading the same memory (double mapped).

 Reserve a range of addresses. */

 Initialize buffer in system memory. */

 Make region read-only. */

 Simulate device 0 reading system memory. */

 Check what the device read. */

 Simulate device 1 reading system memory. */

 Check what the device read. */

 Punch a hole after the first page address. */

/*

 * Basic check of exclusive faulting.

 Initialize buffer in system memory. */

 Map memory exclusively for device access. */

 Check what the device read. */

 Fault pages back to system memory and check them. */

 Check atomic access revoked */

 Initialize buffer in system memory. */

 Map memory exclusively for device access. */

 Check what the device read. */

 Simulate a device writing system memory. */

/*

 * Check copy-on-write works.

 Initialize buffer in system memory. */

 Map memory exclusively for device access. */

 Fault pages back to system memory and check them. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * MADV_POPULATE_READ and MADV_POPULATE_WRITE tests

 *

 * Copyright 2021, Red Hat, Inc.

 *

 * Author(s): David Hildenbrand <david@redhat.com>

/*

 * For now, we're using 2 MiB of private anonymous memory for all tests.

 Present or swapped. */

 Hole in the middle */

 Hole at end */

 Hole at beginning */

 Clear any softdirty bits. */

 Populating READ should set softdirty. */

 Populating WRITE should set softdirty. */

 SPDX-License-Identifier: GPL-2.0

/*

 *

 * A test for the patch "Allow compaction of unevictable pages".

 * With this patch we should be able to allocate at least 1/4

 * of RAM in huge pages. Without the patch much less is

 * allocated.

	/* We want to test with 80% of available memory. Else, OOM killer comes

 Start with the initial condition of 0 huge pages*/

	/* Request a large number of huge pages. The Kernel will allocate

	/* We should have been able to request at least 1/3 rd of the memory in

		/* Write something (in this case the address of the map) to

		 * ensure that KSM can't merge the mapped pages

 SPDX-License-Identifier: GPL-2.0

/*

 * hugepage-mremap:

 *

 * Example of remapping huge page memory in a user application using the

 * mremap system call.  Code assumes a hugetlbfs filesystem is mounted

 * at './huge'.  The code will use 10MB worth of huge pages.

 Definition of O_* constants */

 Definition of SYS_* constants */

 userfaultfd file descriptor */

 Create and enable userfaultfd object. */

	/* Create a private anonymous mapping. The memory will be

	 * demand-zero paged--that is, not yet allocated. When we

	 * actually touch the memory, it will be allocated via

	 * the userfaultfd.

	/* Register the memory range of the mapping we just created for

	 * handling by the userfaultfd object. In mode, we request to track

	 * missing pages (i.e., pages that have not yet been faulted in).

 mmap to a PUD aligned address to hopefully trigger pmd sharing. */

 mmap again to a dummy address to hopefully trigger pmd sharing. */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright 2020 Google LLC

 4MB */

 Verify the entire region */

 1KB -> not page aligned */

/*

 * Returns the start address of the mapping on success, else returns

 * NULL on failure.

	/*

	 * Check that the address is aligned to the specified alignment.

	 * Addresses which have alignments that are multiples of that

	 * specified are not considered valid. For instance, 1GB address is

	 * 2MB-aligned, however it will not be considered valid for a

	 * requested alignment of 2MB. This is done to reduce coincidental

	 * alignment in the tests.

 Returns the time taken for the remap on success else returns -1. */

 Set byte pattern */

 Mask to zero out lower bits of address for alignment */

 Offset of destination address from the end of the source region */

 See comment in get_source_mapping() */

 Verify byte pattern after remapping */

/*

 * Since the destination address is specified using MREMAP_FIXED, subsequent

 * mremap will unmap any previous mapping at the address range specified by

 * dest_addr and region_size. This significantly affects the remap time of

 * subsequent tests. So we clean up mappings after each test.

		/*

		 * Comparing mremap time is only applicable if entire region

		 * was faulted in.

 Expected mremap failures */

 Src addr PTE aligned */

 Src addr 1MB aligned */

 Src addr PMD aligned */

 Src addr PUD aligned */

	/*

	 * mremap 1GB region - Page table level aligned time

	 * comparison.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Stress userfaultfd syscall.

 *

 *  Copyright (C) 2015  Red Hat, Inc.

 *

 * This test allocates two virtual areas and bounces the physical

 * memory across the two virtual areas (from area_src to area_dst)

 * using userfaultfd.

 *

 * There are three threads running per CPU:

 *

 * 1) one per-CPU thread takes a per-page pthread_mutex in a random

 *    page of the area_dst (while the physical page may still be in

 *    area_src), and increments a per-page counter in the same page,

 *    and checks its value against a verification region.

 *

 * 2) another per-CPU thread handles the userfaults generated by

 *    thread 1 above. userfaultfd blocking reads or poll() modes are

 *    exercised interleaved.

 *

 * 3) one last per-CPU thread transfers the memory in the background

 *    at maximum bandwidth (if not already transferred by thread

 *    2). Each cpu thread takes cares of transferring a portion of the

 *    area.

 *

 * When all threads of type 3 completed the transfer, one bounce is

 * complete. area_src and area_dst are then swapped. All threads are

 * respawned and so the bounce is immediately restarted in the

 * opposite direction.

 *

 * per-CPU threads 1 by triggering userfaults inside

 * pthread_mutex_lock will also verify the atomicity of the memory

 * transfer (UFFDIO_COPY).

 exercise the test_uffdio_*_eexist every ALARM_INTERVAL_SECS */

 Whether to test uffd write-protection */

 Whether to test uffd minor faults */

 Userfaultfd test statistics */

 pthread_mutex_t starts at page offset 0 */

/*

 * count is placed in the page after pthread_mutex_t naturally aligned

 * to avoid non alignment faults on non-x86 archs.

	/*

	 * We can't zap just the pagetable with hugetlbfs because

	 * MADV_DONTEED won't work. So exercise -EEXIST on a alias

	 * mapping where the pagetables are not established initially,

	 * this way we'll exercise the -EEXEC at the fs level.

		/*

		 * In the transition between 255 to 256, powerpc will

		 * read out of order in my_bcmp and see both bytes as

		 * zero, so leave a placeholder below always non-zero

		 * after the count, to avoid my_bcmp to trigger false

		 * positives.

	/*

	 * After initialization of area_src, we must explicitly release pages

	 * for area_dst to make sure it's fully empty.  Otherwise we could have

	 * some area_dst pages be errornously initialized with zero pages,

	 * hence we could hit memory corruption later in the test.

	 *

	 * One example is when THP is globally enabled, above allocate_area()

	 * calls could have the two areas merged into a single VMA (as they

	 * will have the same VMA flags so they're mergeable).  When we

	 * initialize the area_src above, it's possible that some part of

	 * area_dst could have been faulted in via one huge THP that will be

	 * shared between area_src and area_dst.  It could cause some of the

	 * area_dst won't be trapped by missing userfaults.

	 *

	 * This release_pages() will guarantee even if that happened, we'll

	 * proactively split the thp and drop any accidentally initialized

	 * pages within area_dst.

 Write protection page faults */

 Undo write-protect, do wakeup after that */

	/*

	 * Error handling within the kernel for continue is subtly different

	 * from copy or zeropage, so it may be a source of bugs. Trigger an

	 * error (-EEXIST) on purpose, to verify doing so doesn't cause a BUG.

 uninitialized warning */

 real retval in ufdio_copy.copy */

 real retval in ufdio_copy.copy */

 Write protect page faults */

		/*

		 * Minor page faults

		 *

		 * To prove we can modify the original range for testing

		 * purposes, we're going to bit flip this range before

		 * continuing.

		 *

		 * Note that this requires all minor page fault tests operate on

		 * area_dst (non-UFFD-registered) and area_dst_alias

		 * (UFFD-registered).

 Missing page faults */

 from here cancellation is ok */

 Copy the first half of the pages */

	/*

	 * If we need to test uffd-wp, set it up now.  Then we'll have

	 * at least the first half of the pages mapped already which

	 * can be write-protected for testing

	/*

	 * Continue the 2nd half of the page copying, handling write

	 * protection faults if any

	/*

	 * Be strict and immediately zap area_src, the whole area has

	 * been transferred already by the background treads. The

	 * area_src could then be faulted in in a racy way by still

	 * running uffdio_threads reading zeropages after we zapped

	 * area_src (but they're guaranteed to get -EEXIST from

	 * UFFDIO_COPY without writing zero pages into area_dst

	 * because the background threads already completed).

/*

 * For non-cooperative userfaultfd test we fork() a process that will

 * generate pagefaults, will mremap the area monitored by the

 * userfaultfd and at last this process will release the monitored

 * area.

 * For the anonymous and shared memory the area is divided into two

 * parts, the first part is accessed before mremap, and the second

 * part is accessed after mremap. Since hugetlbfs does not support

 * mremap, the entire monitored area is accessed in a single pass for

 * HUGETLB_TEST.

 * The release of the pages currently generates event for shmem and

 * anonymous memory (UFFD_EVENT_REMOVE), hence it is not checked

 * for hugetlb.

 * For signal test(UFFD_FEATURE_SIGBUS), signal_test = 1, we register

 * monitored area, generate pagefaults and test that signal is delivered.

 * Use UFFDIO_COPY to allocate missing page and retry. For signal_test = 2

 * test robustness use case - we release monitored area, fork a process

 * that will generate pagefaults and verify signal is generated.

 * This also tests UFFD_FEATURE_EVENT_FORK event along with the signal

 * feature. Using monitor thread, verify no userfault events are generated.

 This is a MISSING request */

 This is a WP request */

		/*

		 * Trigger write protection if there is by writing

		 * the same value back.

 Reset area_src since we just clobbered it */

		/*

		 * Trigger write protection if there is by writing

		 * the same value back.

 real retval in ufdio_zeropage.zeropage */

 exercise UFFDIO_ZEROPAGE */

	/*

	 * After registering with UFFD, populate the non-UFFD-registered side of

	 * the shared mapping. This should *not* trigger any UFFD minor faults.

	/*

	 * Read each of the pages back using the UFFD-registered mapping. We

	 * expect that the first time we touch a page, it will result in a minor

	 * fault. uffd_poll_thread will resolve the fault by bit-flipping the

	 * page's contents, and then issuing a CONTINUE ioctl.

 This macro let __LINE__ works in err() */

 Open the pagemap fd of the child itself */

		/*

		 * After fork() uffd-wp bit should be gone as long as we're

		 * without UFFD_FEATURE_EVENT_FORK

 Succeed */

 Pagemap tests uffd-wp only */

 Not enough memory to test this page size */

 Flush so it doesn't flush twice in parent/child later */

 This is a thp test */

 This is normal page test; force no thp */

 Touch the page */

 Make sure uffd-wp bit dropped when fork */

 Exclusive required or PAGEOUT won't work */

 Uffd-wp should persist even swapped out */

 Make sure uffd-wp bit dropped when fork */

 Unprotect; this tests swap pte modifications */

 Fault in the page from disk */

 register */

		/*

		 * The madvise done previously isn't enough: some

		 * uffd_thread could have read userfaults (one of

		 * those already resolved by the background thread)

		 * and it may be in the process of calling

		 * UFFDIO_COPY. UFFDIO_COPY will read the zapped

		 * area_src and it would map a zero page in it (of

		 * course such a UFFDIO_COPY is perfectly safe as it'd

		 * return -EEXIST). The problem comes at the next

		 * bounce though: that racing UFFDIO_COPY would

		 * generate zeropages in the area_src, so invalidating

		 * the previous MADV_DONTNEED. Without this additional

		 * MADV_DONTNEED those zeropages leftovers in the

		 * area_src would lead to -EEXIST failure during the

		 * next bounce, effectively leaving a zeropage in the

		 * area_dst.

		 *

		 * Try to comment this out madvise to see the memory

		 * corruption being caught pretty quick.

		 *

		 * khugepaged is also inhibited to collapse THP after

		 * MADV_DONTNEED only after the UFFDIO_REGISTER, so it's

		 * required to MADV_DONTNEED here.

 bounce pass */

 Clear all the write protections if there is any */

 unregister */

 verification */

 prepare next bounce */

		/*

		 * shmem/hugetlb won't be able to run since they have different

		 * behavior on fork() (file-backed memory normally drops ptes

		 * directly when fork), meanwhile the pagemap test will verify

		 * pgtable entry of fork()ed child.

		/*

		 * Hard-code for x86_64 for now for 2M THP, as x86_64 is

		 * currently the only one that supports uffd-wp

/*

 * Copied from mlock2-tests.c

 Only enable write-protect test for anonymous test */

 Minor faults require shared hugetlb; only enable here. */

	/*

	 * Whether we can test certain features depends not just on test type,

	 * but also on whether or not this particular kernel supports the

	 * feature.

 __NR_userfaultfd */

 __NR_userfaultfd */

 SPDX-License-Identifier: GPL-2.0

/*

 * This program reserves and uses hugetlb memory, supporting a bunch of

 * scenarios needed by the charged_reserved_hugetlb.sh test.

 Global definitions. */

 Global variables. */

/*

 * Show usage and exit.

 Parse command-line arguments. */

 Signal to caller that we're done. */

 Hold memory until external kill signal is delivered. */

 SPDX-License-Identifier: GPL-2.0

/*

 * Tests for mremap w/ MREMAP_DONTUNMAP.

 *

 * Copyright 2020, Brian Geffon <bgeffon@google.com>

 Try a simple operation for to "test" for kernel support this prevents

 reporting tests as failed when it's run on an older kernel.

 This simple remap should only fail if MREMAP_DONTUNMAP isn't

 supported.

 This helper will just validate that an entire mapping contains the expected

 byte.

 Compare each page checking that it contains our expected byte.

 this test validates that MREMAP_DONTUNMAP moves the pagetables while leaving

 the source mapping mapped.

 Try to just move the whole mapping anywhere (not fixed).

 Validate that the pages have been moved, we know they were moved if

 the dest_mapping contains a's.

 This test validates that MREMAP_DONTUNMAP on a shared mapping works as expected.

 Try to just move the whole mapping anywhere (not fixed).

 Old kernel which doesn't support MREMAP_DONTUNMAP on shmem.

 Validate that the pages have been moved, we know they were moved if

 the dest_mapping contains a's.

 Because the region is backed by shmem, we will actually see the same

 memory at the source location still.

 This test validates MREMAP_DONTUNMAP will move page tables to a specific

 destination using MREMAP_FIXED, also while validating that the source

 remains intact.

 Since we want to guarantee that we can remap to a point, we will

 create a mapping up front.

 The dest mapping will have been unmap by mremap so we expect the Xs

 to be gone and replaced with a's.

 And the source mapping will have had its ptes dropped.

 This test validates that we can MREMAP_DONTUNMAP for a portion of an

 existing mapping.

	/*

	 *  source mapping:

	 *  --------------

	 *  | aaaaaaaaaa |

	 *  --------------

	 *  to become:

	 *  --------------

	 *  | aaaaa00000 |

	 *  --------------

	 *  With the destination mapping containing 5 pages of As.

	 *  ---------

	 *  | aaaaa |

	 *  ---------

 We will grab the last 5 pages of the source and move them.

 We expect the first 5 pages of the source to contain a's and the

 final 5 pages to contain zeros.

 Finally we expect the destination to have 5 pages worth of a's.

 This test validates that we can remap over only a portion of a mapping.

	/*

	 *  source mapping:

	 *  ---------

	 *  |aaaaa|

	 *  ---------

	 *  dest mapping initially:

	 *  -----------

	 *  |XXXXXXXXXX|

	 *  ------------

	 *  Source to become:

	 *  ---------

	 *  |00000|

	 *  ---------

	 *  With the destination mapping containing 5 pages of As.

	 *  ------------

	 *  |aaaaaXXXXX|

	 *  ------------

 We will grab the last 5 pages of the source and move them.

 Finally we expect the destination to have 5 pages worth of a's.

 Finally the last 5 pages shouldn't have been touched.

 test for kernel support for MREMAP_DONTUNMAP skipping the test if

 not.

 Keep a page sized buffer around for when we need it.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright IBM Corporation, 2021

 *

 * Author: Mike Rapoport <rppt@linux.ibm.com>

 drop capabilities including CAP_IPC_LOCK */

 __NR_memfd_secret */

 __NR_memfd_secret */

 Just the flags we need, copied from mm.h: */

 check pte is writable */

 mark page accessed */

 Serialize prints */

 Only report timing information on the *_BENCHMARK commands: */

			/*

			 * Dump page 0 (index 1). May be overridden later, by

			 * user's non-option arguments.

			 *

			 * .which_pages is zero-based, so that zero can mean "do

			 * nothing".

 works only with DUMP_USER_PAGES_TEST */

 strtol, so you can pass flags in hex form */

 fault pages in gup, do not fault in userland */

		/*

		 * For example:

		 *

		 *   ./gup_test -c 0 1 0x1001

		 *

		 * ...to dump pages 0, 1, and 4097

			/*

			 * Do the 1-based indexing here, so that the user can

			 * use normal 0-based indexing on the command line.

	/*

	 * FOLL_TOUCH, in gup_test, is used as an either/or case: either

	 * fault pages in from the kernel via FOLL_TOUCH, or fault them

	 * in here, from user space. This allows comparison of performance

	 * between those two cases.

 SPDX-License-Identifier: GPL-2.0

 Since merging occurs only after 2 scans, make sure to get at least 2 full scans */

	/*

	 * Since there must be at least 2 pages for merging and 1 page can be

	 * shared with the limited number of pages (max_page_sharing), sometimes

	 * there are 'leftover' pages that cannot be merged. For example, if there

	 * are 11 pages and max_page_sharing = 10, then only 10 pages will be

	 * merged and the 11th page won't be affected. As a result, when the number

	 * of duplicate pages is divided by max_page_sharing and the remainder is 1,

	 * pages_shared and pages_sharing values will be equal between dupl_page_count

	 * and dupl_page_count - 1.

 fill pages with the same data and merge them */

 verify that the right number of pages are merged */

 fill pages with the same data and merge them */

 change 1 byte in each of the 2 pages -- KSM must automatically unmerge them */

 get at least 1 scan, so KSM can detect that the pages were modified */

 check that unmerging was successful and 0 pages are currently merged */

 fill pages with zero and try to merge them */

       /*

	* verify that the right number of pages are merged:

	* 1) if use_zero_pages is set to 1, empty pages are merged

	*    with the kernel zero page instead of with each other;

	* 2) if use_zero_pages is set to 0, empty pages are not treated specially

	*    and merged as usual.

 allocate 2 pages in 2 different NUMA nodes and fill them with the same data */

 try to merge the pages */

       /*

	* verify that the right number of pages are merged:

	* 1) if merge_across_nodes was enabled, 2 duplicate pages will be merged;

	* 2) if merge_across_nodes = 0, there must be 0 merged pages, since there is

	*    only 1 unique page in each node and they can't be shared.

 drop pmd */

 allocate transparent huge page */

 page_count must be less than 2*page_size */

 Create 2000 pairs of duplicate pages */

 SPDX-License-Identifier: GPL-2.0

/* Test selecting other page sizes for mmap/shmget.



   Before running this huge pages for each huge page size must have been

   reserved.

   For large pages beyond MAX_ORDER (like 1GB on x86) boot options must be used.

   Also shmmax must be increased.

   And you need to run as root to work around some weird permissions in shm.

   And nothing using huge pages should run in parallel.

   When the program aborts you may need to clean up the shm segments with

   ipcrm -m by hand, like this

   sudo ipcs | awk '$1 == "0x00000000" {print $2}' | xargs -n1 sudo ipcrm -m

 segment will use huge TLB pages */

 printf(fmt)

 SPDX-License-Identifier: GPL-2.0

 only one page is faulted in */

 Now unlock and recheck attributes */

 Now unlock and recheck attributes */

	/*

	 * Before we unlock a portion, we need to that all three pages are in

	 * the same VMA.  If they are not we abort this test (Note that this is

	 * not a failure)

 All three VMAs should be different */

 Now unlock the first and third page and check the VMAs again */

 Now all three VMAs should be the same */

	/*

	 * Fetch the AnonHugePages: in the same block and check whether it got

	 * the expected number of hugeepages next.

	/*

	 * Fetch the Swap: in the same block and check whether it got

	 * the expected number of hugeepages next.

 3 seconds */

 Sanity check */

 Wait until the second full_scan completed */

 Do not touch settings on child exit */

 Do not touch settings on child exit */

 Do not touch settings on child exit */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2017, Anshuman Khandual, IBM Corp.

 *

 * Works on architectures which support 128TB virtual

 * address range and beyond.

/*

 * Maximum address range mapped with a single mmap()

 * call is little bit more than 16GB. Hence 16GB is

 * chosen as the single chunk size for address space

 * mapping.

 16GB */

/*

 * Address space till 128TB is mapped without any hint

 * and is enabled by default. Address space beyond 128TB

 * till 512TB is obtained by passing hint address as the

 * first argument into mmap() system call.

 *

 * The process heap address space is divided into two

 * different areas one below 128TB and one above 128TB

 * till it reaches 512TB. One with size 128TB and the

 * other being 384TB.

 *

 * On Arm64 the address space is 256TB and no high mappings

 * are supported so far.

 Number of 16GB chunks for 128TB */

 First address beyond 128TB */

 First address beyond 256TB */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Need to mount securityfs

 Code executed by child */

 Give parent 1 second to write map file

 Code executed by parent */

 Code executed by child */

 Code executed by parent */

 First test to make sure we can write userns mappings from a user

 that doesn't have any restrictions (as long as it has CAP_SETUID);

 Take away all but setid caps

 Need PR_SET_DUMPABLE flag set so we can write /proc/[pid]/uid_map

 from non-root parent process.

 Now take away all caps

 NOTE: this test doesn't clean up users that were created in

 /etc/passwd or flush policies that were added to the LSM.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2021 Samsung Electrnoics

 * Bongsu Jeon <bongsu.jeon@samsung.com>

 *

 * Test code for nci

 SPDX-License-Identifier: GPL-2.0

 o32 */

 n32 */

 n64 */

 o32 */

 n32 */

 n64 */

 Apply to the entire subtree */

 do not follow symlinks */

 Attempt to de-conflict with the selftests tree. */

	/*

	 * We're holding a fd open for writing so this needs to fail somewhere

	 * in the middle and the mount options need to be unchanged.

	/*

	 * We're holding a fd open to a mount somwhere in the middle so this

	 * needs to fail somewhere in the middle. After this the mount options

	 * need to be unchanged.

 All writers are gone so this should succeed. */

 Try to change mount options from multiple threads. */

/**

 * Validate that negative fd values are rejected.

/**

 * Validate that excessively large fd values are rejected.

/**

 * Validate that closed fd values are rejected.

/**

 * Validate that the initial user namespace is rejected.

/**

 * Validate that an attached mount in our mount namespace can be idmapped.

 * (The kernel enforces that the mount's mount namespace and the caller's mount

 *  namespace match.)

/**

 * Validate that idmapping a mount is rejected if the mount's mount namespace

 * and our mount namespace don't match.

 * (The kernel enforces that the mount's mount namespace and the caller's mount

 *  namespace match.)

/**

 * Validate that an attached mount in our mount namespace can be idmapped.

 Changing mount properties on a detached mount. */

/**

 * Validate that a detached mount not in our mount namespace can be idmapped.

 Changing mount properties on a detached mount. */

/**

 * Validate that currently changing the idmapping of an idmapped mount fails.

 Change idmapping on a detached mount that is already idmapped. */

 SPDX-License-Identifier: GPL-2.0

  Copyright(c) 2016-20 Intel Corporation. */

	/*

	 * Pages must be added before mapping VMAs because their permissions

	 * cap the VMA permissions.

 SPDX-License-Identifier: GPL-2.0

  Copyright(c) 2016-20 Intel Corporation. */

 SECINFO flags */

 sanity check */

 BE -> LE */

 SPDX-License-Identifier: GPL-2.0

  Copyright(c) 2016-20 Intel Corporation. */

 SPDX-License-Identifier: GPL-2.0

  Copyright(c) 2016-20 Intel Corporation. */

	/*

	 * An enclave consumer only must do this.

 Get vDSO base address */

/*

 *  sync / sw_sync abstraction

 *  Copyright 2015-2016 Collabora Ltd.

 *

 *  Based on the implementation from the Android Open Source Project,

 *

 *  Copyright 2012 Google, Inc

 *

 *  Permission is hereby granted, free of charge, to any person obtaining a

 *  copy of this software and associated documentation files (the "Software"),

 *  to deal in the Software without restriction, including without limitation

 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,

 *  and/or sell copies of the Software, and to permit persons to whom the

 *  Software is furnished to do so, subject to the following conditions:

 *

 *  The above copyright notice and this permission notice shall be included in

 *  all copies or substantial portions of the Software.

 *

 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR

 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,

 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL

 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR

 *  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,

 *  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR

 *  OTHER DEALINGS IN THE SOFTWARE.

 SW_SYNC ioctls */

 Same code! */

/*

 *  sync test runner

 *  Copyright 2015-2016 Collabora Ltd.

 *

 *  Based on the implementation from the Android Open Source Project,

 *

 *  Copyright 2012 Google, Inc

 *

 *  Permission is hereby granted, free of charge, to any person obtaining a

 *  copy of this software and associated documentation files (the "Software"),

 *  to deal in the Software without restriction, including without limitation

 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,

 *  and/or sell copies of the Software, and to permit persons to whom the

 *  Software is furnished to do so, subject to the following conditions:

 *

 *  The above copyright notice and this permission notice shall be included in

 *  all copies or substantial portions of the Software.

 *

 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR

 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,

 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL

 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR

 *  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,

 *  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR

 *  OTHER DEALINGS IN THE SOFTWARE.

 need this return to keep gcc happy */

/*

 *  sync stress test: producer/consumer

 *  Copyright 2015-2016 Collabora Ltd.

 *

 *  Based on the implementation from the Android Open Source Project,

 *

 *  Copyright 2012 Google, Inc

 *

 *  Permission is hereby granted, free of charge, to any person obtaining a

 *  copy of this software and associated documentation files (the "Software"),

 *  to deal in the Software without restriction, including without limitation

 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,

 *  and/or sell copies of the Software, and to permit persons to whom the

 *  Software is furnished to do so, subject to the following conditions:

 *

 *  The above copyright notice and this permission notice shall be included in

 *  all copies or substantial portions of the Software.

 *

 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR

 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,

 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL

 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR

 *  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,

 *  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR

 *  OTHER DEALINGS IN THE SOFTWARE.

/* IMPORTANT NOTE: if you see this test failing on your system, it may be

 * due to a shortage of file descriptors. Please ensure your system has

 * a sensible limit for this test to finish correctly.

 Returns 1 on error, 0 on success */

		/*

		 * Wait for the consumer to finish. Use alternate

		 * means of waiting on the fence

		/*

		 * Every producer increments the counter, the consumer

		 * checks and erases it

		/*

		 * Make sure we see an increment from every producer thread.

		 * Vary the means by which we wait.

 Release the producer threads */

 Consumer thread runs here */

/*

 *  sync fence merge tests

 *  Copyright 2015-2016 Collabora Ltd.

 *

 *  Based on the implementation from the Android Open Source Project,

 *

 *  Copyright 2012 Google, Inc

 *

 *  Permission is hereby granted, free of charge, to any person obtaining a

 *  copy of this software and associated documentation files (the "Software"),

 *  to deal in the Software without restriction, including without limitation

 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,

 *  and/or sell copies of the Software, and to permit persons to whom the

 *  Software is furnished to do so, subject to the following conditions:

 *

 *  The above copyright notice and this permission notice shall be included in

 *  all copies or substantial portions of the Software.

 *

 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR

 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,

 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL

 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR

 *  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,

 *  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR

 *  OTHER DEALINGS IN THE SOFTWARE.

/*

 *  sync fence wait tests

 *  Copyright 2015-2016 Collabora Ltd.

 *

 *  Based on the implementation from the Android Open Source Project,

 *

 *  Copyright 2012 Google, Inc

 *

 *  Permission is hereby granted, free of charge, to any person obtaining a

 *  copy of this software and associated documentation files (the "Software"),

 *  to deal in the Software without restriction, including without limitation

 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,

 *  and/or sell copies of the Software, and to permit persons to whom the

 *  Software is furnished to do so, subject to the following conditions:

 *

 *  The above copyright notice and this permission notice shall be included in

 *  all copies or substantial portions of the Software.

 *

 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR

 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,

 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL

 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR

 *  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,

 *  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR

 *  OTHER DEALINGS IN THE SOFTWARE.

 Confirm fence isn't signaled */

 confirm you can successfully wait */

/*

 *  sync stress test: parallelism

 *  Copyright 2015-2016 Collabora Ltd.

 *

 *  Based on the implementation from the Android Open Source Project,

 *

 *  Copyright 2012 Google, Inc

 *

 *  Permission is hereby granted, free of charge, to any person obtaining a

 *  copy of this software and associated documentation files (the "Software"),

 *  to deal in the Software without restriction, including without limitation

 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,

 *  and/or sell copies of the Software, and to permit persons to whom the

 *  Software is furnished to do so, subject to the following conditions:

 *

 *  The above copyright notice and this permission notice shall be included in

 *  all copies or substantial portions of the Software.

 *

 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR

 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,

 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL

 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR

 *  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,

 *  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR

 *  OTHER DEALINGS IN THE SOFTWARE.

 Wait on the prior thread to complete */

		/*

		 * Confirm the previous thread's writes are visible

		 * and then increment

 Kick off the other thread */

	/*

	 * Use a single timeline to synchronize two threads

	 * hammmering on the same counter.

 make sure the threads did not trample on one another */

/*

 *  sync allocation tests

 *  Copyright 2015-2016 Collabora Ltd.

 *

 *  Based on the implementation from the Android Open Source Project,

 *

 *  Copyright 2012 Google, Inc

 *

 *  Permission is hereby granted, free of charge, to any person obtaining a

 *  copy of this software and associated documentation files (the "Software"),

 *  to deal in the Software without restriction, including without limitation

 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,

 *  and/or sell copies of the Software, and to permit persons to whom the

 *  Software is furnished to do so, subject to the following conditions:

 *

 *  The above copyright notice and this permission notice shall be included in

 *  all copies or substantial portions of the Software.

 *

 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR

 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,

 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL

 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR

 *  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,

 *  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR

 *  OTHER DEALINGS IN THE SOFTWARE.

/*

 *  sync stress test: merging

 *  Copyright 2015-2016 Collabora Ltd.

 *

 *  Based on the implementation from the Android Open Source Project,

 *

 *  Copyright 2012 Google, Inc

 *

 *  Permission is hereby granted, free of charge, to any person obtaining a

 *  copy of this software and associated documentation files (the "Software"),

 *  to deal in the Software without restriction, including without limitation

 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,

 *  and/or sell copies of the Software, and to permit persons to whom the

 *  Software is furnished to do so, subject to the following conditions:

 *

 *  The above copyright notice and this permission notice shall be included in

 *  all copies or substantial portions of the Software.

 *

 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR

 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,

 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL

 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR

 *  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,

 *  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR

 *  OTHER DEALINGS IN THE SOFTWARE.

	/*

	 * Randomly create sync_points out of a fixed set of timelines,

	 * and merge them together

 Generate sync_point. */

 Keep track of the latest sync_point in each timeline. */

 Merge */

 Confirm our map matches the fence. */

 Trigger the merged fence */

 Increment the timeline to the last sync_point */

 Check that the fence is triggered. */

/*

 *  sync fence tests with one timeline

 *  Copyright 2015-2016 Collabora Ltd.

 *

 *  Based on the implementation from the Android Open Source Project,

 *

 *  Copyright 2012 Google, Inc

 *

 *  Permission is hereby granted, free of charge, to any person obtaining a

 *  copy of this software and associated documentation files (the "Software"),

 *  to deal in the Software without restriction, including without limitation

 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,

 *  and/or sell copies of the Software, and to permit persons to whom the

 *  Software is furnished to do so, subject to the following conditions:

 *

 *  The above copyright notice and this permission notice shall be included in

 *  all copies or substantial portions of the Software.

 *

 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR

 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,

 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL

 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR

 *  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,

 *  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR

 *  OTHER DEALINGS IN THE SOFTWARE.

 Wait on fence until timeout */

 Advance timeline from 0 -> 1 */

 Wait on fence until timeout */

 Signal the fence */

 Wait successfully */

 Go even further, and confirm wait still succeeds */

 create fence a,b,c and then merge them all into fence d */

 confirm all fences have one active point (even d) */

 confirm that d is not signaled until the max of a,b,c */

/*

 * Copyright (c) 2019 Alexey Dobriyan <adobriyan@gmail.com>

 *

 * Permission to use, copy, modify, and distribute this software for any

 * purpose with or without fee is hereby granted, provided that the above

 * copyright notice and this permission notice appear in all copies.

 *

 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES

 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF

 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR

 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES

 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN

 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF

 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

/*

 * Fork and exec tiny 1 page executable which precisely controls its VM.

 * Test /proc/$PID/maps

 * Test /proc/$PID/smaps

 * Test /proc/$PID/smaps_rollup

 * Test /proc/$PID/statm

 *

 * FIXME require CONFIG_TMPFS which can be disabled

 * FIXME test other values from "smaps"

 * FIXME support other archs

 Casually unmap stack, vDSO and everything else. */

 munmap */

 Ping parent. */

 write(0, &c, 1); */

 xor edi, edi */

 lea rsi, [rip] */

 mov edx, 1 */

 1: pause(); */

 jmp 1b */

 Avoid ETXTBSY on exec. */

/*

 * vsyscall page can't be unmapped, probe it with memory load.

 Hide "segfault at ffffffffff600000" messages. */

 Reserve fd 0 for 1-byte pipe ping from child. */

 Generate "head -n1 /proc/$PID/maps" */

 Test /proc/$PID/maps */

 Test /proc/$PID/smaps */

 Test /proc/$PID/smaps_rollup */

 Test /proc/$PID/statm */

 ->total_vm */

 rss */

 file rss */

 ELF executable segments */

 ->data_vm + ->stack_vm */

/*

 * Copyright  2018 Alexey Dobriyan <adobriyan@gmail.com>

 *

 * Permission to use, copy, modify, and distribute this software for any

 * purpose with or without fee is hereby granted, provided that the above

 * copyright notice and this permission notice appear in all copies.

 *

 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES

 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF

 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR

 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES

 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN

 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF

 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

 Test readlink /proc/self/map_files/... */

/*

 * Copyright  2020 Alexey Gladkov <gladkov.alexey@gmail.com>

 *

 * Permission to use, copy, modify, and distribute this software for any

 * purpose with or without fee is hereby granted, provided that the above

 * copyright notice and this permission notice appear in all copies.

 *

 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES

 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF

 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR

 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES

 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN

 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF

 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

/*

 * Copyright  2018 Alexey Dobriyan <adobriyan@gmail.com>

 *

 * Permission to use, copy, modify, and distribute this software for any

 * purpose with or without fee is hereby granted, provided that the above

 * copyright notice and this permission notice appear in all copies.

 *

 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES

 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF

 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR

 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES

 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN

 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF

 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

 Test /proc/*/fd lookup.

 lstat(2) has more "coverage" in case non-symlink pops up somehow. */

 leading junk */

 trailing junk */

 Wipe fdtable. */

 Now fdtable is clean. */

 Clean again! */

 Default RLIMIT_NOFILE-1 */

/*

 * Copyright  2018 Alexey Dobriyan <adobriyan@gmail.com>

 *

 * Permission to use, copy, modify, and distribute this software for any

 * purpose with or without fee is hereby granted, provided that the above

 * copyright notice and this permission notice appear in all copies.

 *

 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES

 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF

 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR

 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES

 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN

 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF

 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

 Test that /proc/self gives correct TGID.

/*

 * Copyright  2018 Alexey Dobriyan <adobriyan@gmail.com>

 *

 * Permission to use, copy, modify, and distribute this software for any

 * purpose with or without fee is hereby granted, provided that the above

 * copyright notice and this permission notice appear in all copies.

 *

 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES

 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF

 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR

 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES

 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN

 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF

 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

 Test that values in /proc/uptime increment monotonically

 while shifting across CPUs.

 find out "nr_cpu_ids" */

 CPU might not exist, ignore error */

/*

 * Copyright  2018 Alexey Dobriyan <adobriyan@gmail.com>

 *

 * Permission to use, copy, modify, and distribute this software for any

 * purpose with or without fee is hereby granted, provided that the above

 * copyright notice and this permission notice appear in all copies.

 *

 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES

 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF

 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR

 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES

 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN

 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF

 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

 Test

 1) read and lseek on every file in /proc

 2) readlink of every symlink in /proc

 3) recursively (1) + (2) for every directory in /proc

 4) write to /proc/*/clear_refs and /proc/*/task/*/clear_refs
/task
 5) write to /proc/sysrq-trigger

 read from /proc/kmsg can block */

 struct proc_ops::proc_lseek is mandatory if file is seekable. */

 Ensure /proc is proc. */

/*

 * Copyright  2018 Alexey Dobriyan <adobriyan@gmail.com>

 *

 * Permission to use, copy, modify, and distribute this software for any

 * purpose with or without fee is hereby granted, provided that the above

 * copyright notice and this permission notice appear in all copies.

 *

 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES

 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF

 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR

 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES

 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN

 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF

 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

 Test that /proc/loadavg correctly reports last pid in pid namespace. */

 pid 1 */

 pid 2 */

/*

 * Copyright  2020 Alexey Gladkov <gladkov.alexey@gmail.com>

 *

 * Permission to use, copy, modify, and distribute this software for any

 * purpose with or without fee is hereby granted, provided that the above

 * copyright notice and this permission notice appear in all copies.

 *

 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES

 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF

 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR

 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES

 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN

 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF

 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

/*

 * Copyright  2018 Alexey Dobriyan <adobriyan@gmail.com>

 *

 * Permission to use, copy, modify, and distribute this software for any

 * purpose with or without fee is hereby granted, provided that the above

 * copyright notice and this permission notice appear in all copies.

 *

 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES

 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF

 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR

 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES

 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN

 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF

 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

 Test that values in /proc/uptime increment monotonically.

/*

 * Copyright  2019 Alexey Dobriyan <adobriyan@gmail.com>

 *

 * Permission to use, copy, modify, and distribute this software for any

 * purpose with or without fee is hereby granted, provided that the above

 * copyright notice and this permission notice appear in all copies.

 *

 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES

 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF

 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR

 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES

 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN

 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF

 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

/*

 * Test that setns(CLONE_NEWNET) points to new /proc/net content even

 * if old one is in dcache.

 *

 * FIXME /proc/net/unix is under CONFIG_UNIX which can be disabled.

 Check for priviledges and syscall availability straight away. */

 Distinguisher between two otherwise empty net namespaces. */

 Reliably pin dentry into dcache. */

/*

 * Copyright  2019 Alexey Dobriyan <adobriyan@gmail.com>

 *

 * Permission to use, copy, modify, and distribute this software for any

 * purpose with or without fee is hereby granted, provided that the above

 * copyright notice and this permission notice appear in all copies.

 *

 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES

 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF

 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR

 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES

 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN

 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF

 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

/*

 * Test that setns(CLONE_NEWIPC) points to new /proc/sysvipc content even

 * if old one is in dcache.

 Check for priviledges and syscall availability straight away. */

 Distinguisher between two otherwise empty IPC namespaces. */

 Reliably pin dentry into dcache. */

/*

 * Copyright  2018 Alexey Dobriyan <adobriyan@gmail.com>

 *

 * Permission to use, copy, modify, and distribute this software for any

 * purpose with or without fee is hereby granted, provided that the above

 * copyright notice and this permission notice appear in all copies.

 *

 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES

 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF

 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR

 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES

 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN

 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF

 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

 Test that /proc/$KERNEL_THREAD/fd/ is empty.

/*

 * Test for kernel threadness atomically with openat().

 *

 * Return /proc/$PID/fd descriptor if process is kernel thread.

 * Return -1 if a process is userspace process.

	/*

	 * Believe it or not, struct task_struct::flags is directly exposed

	 * to userspace!

 Search backwards: ->comm can contain whitespace and ')'. */

	/*

	 * In theory this will loop indefinitely if kernel threads are exiled

	 * from /proc.

	 *

	 * Start with kthreadd.

 EACCES if run as non-root. */

/*

 * Copyright  2018 Alexey Dobriyan <adobriyan@gmail.com>

 *

 * Permission to use, copy, modify, and distribute this software for any

 * purpose with or without fee is hereby granted, provided that the above

 * copyright notice and this permission notice appear in all copies.

 *

 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES

 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF

 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR

 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES

 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN

 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF

 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

 Do direct system call as libc can wrap anything. */

/*

 * Copyright (c) 2021 Alexey Dobriyan <adobriyan@gmail.com>

 *

 * Permission to use, copy, modify, and distribute this software for any

 * purpose with or without fee is hereby granted, provided that the above

 * copyright notice and this permission notice appear in all copies.

 *

 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES

 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF

 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR

 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES

 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN

 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF

 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

/*

 * Test that "mount -t proc -o subset=pid" hides everything but pids,

 * /proc/self and /proc/thread-self.

/*

 * Copyright  2018 Alexey Dobriyan <adobriyan@gmail.com>

 *

 * Permission to use, copy, modify, and distribute this software for any

 * purpose with or without fee is hereby granted, provided that the above

 * copyright notice and this permission notice appear in all copies.

 *

 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES

 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF

 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR

 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES

 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN

 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF

 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

// Test that open(/proc/*/fd/*) opens the same file.

#undef NDEBUG

#include <assert.h>

#include <stdio.h>

#include <sys/types.h>

#include <sys/stat.h>

#include <fcntl.h>

#include <unistd.h>



int main(void)

{

	int fd0, fd1, fd2;

	struct stat st0, st1, st2;

	char buf[64];

	int rv;



	fd0 = open("/", O_DIRECTORY|O_RDONLY);

	assert(fd0 >= 0);



	snprintf(buf, sizeof(buf), "/proc/self/fd/%u", fd0);

	fd1 = open(buf, O_RDONLY);

	assert(fd1 >= 0);



	snprintf(buf, sizeof(buf), "/proc/thread-self/fd/%u", fd0);

	fd2 = open(buf, O_RDONLY);

	assert(fd2 >= 0);



	rv = fstat(fd0, &st0);

	assert(rv == 0);

	rv = fstat(fd1, &st1);

	assert(rv == 0);

	rv = fstat(fd2, &st2);

	assert(rv == 0);



	assert(st0.st_dev == st1.st_dev);

	assert(st0.st_ino == st1.st_ino);



	assert(st0.st_dev == st2.st_dev);

	assert(st0.st_ino == st2.st_ino);



	return 0;

}

/*

 * Copyright  2018 Alexey Dobriyan <adobriyan@gmail.com>

 *

 * Permission to use, copy, modify, and distribute this software for any

 * purpose with or without fee is hereby granted, provided that the above

 * copyright notice and this permission notice appear in all copies.

 *

 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES

 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF

 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR

 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES

 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN

 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF

 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

 Test that /proc/thread-self gives correct TGID/PID.

 main thread */

 side thread */

/*

 * Copyright  2018 Alexey Dobriyan <adobriyan@gmail.com>

 *

 * Permission to use, copy, modify, and distribute this software for any

 * purpose with or without fee is hereby granted, provided that the above

 * copyright notice and this permission notice appear in all copies.

 *

 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES

 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF

 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR

 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES

 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN

 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF

 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

/*

 * Copyright (c) 2021 Alexey Dobriyan <adobriyan@gmail.com>

 *

 * Permission to use, copy, modify, and distribute this software for any

 * purpose with or without fee is hereby granted, provided that the above

 * copyright notice and this permission notice appear in all copies.

 *

 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES

 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF

 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR

 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES

 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN

 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF

 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

 Test that /proc/*/task never contains "0".

 child */

 parent */

/*

 * Copyright  2018 Alexey Dobriyan <adobriyan@gmail.com>

 *

 * Permission to use, copy, modify, and distribute this software for any

 * purpose with or without fee is hereby granted, provided that the above

 * copyright notice and this permission notice appear in all copies.

 *

 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES

 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF

 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR

 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES

 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN

 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF

 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

 Test readlink /proc/self/map_files/... with minimum address. */

	/*

	 * va_max must be enough bigger than vm.mmap_min_addr, which is

	 * 64KB/32KB by default. (depends on CONFIG_LSM_MMAP_MIN_ADDR)

 SPDX-License-Identifier: GPL-2.0+

/*

 * Copyright (c) 2020 Bernd Edlinger <bernd.edlinger@hotmail.de>

 * All rights reserved.

 *

 * Check whether /proc/$pid/mem can be accessed without causing deadlocks

 * when de_thread is blocked with ->cred_guard_mutex held.

 SPDX-License-Identifier: GPL-2.0+

/*

 * Copyright (c) 2018 Dmitry V. Levin <ldv@altlinux.org>

 * All rights reserved.

 *

 * Check whether PTRACE_GET_SYSCALL_INFO semantics implemented in the kernel

 * matches userspace expectations.

 a sequence of architecture-agnostic syscalls */

 get the pid before PTRACE_TRACEME */

 cannot happen */

 unreachable */

 chdir */

 gettid */

 invalid PTRACE_SYSCALL_INFO_* op */

 cannot happen */

 the tracee is no more */

 the tracee is no more */

 cannot happen */

 entering chdir */

 entering gettid */

 entering exit_group */

 exiting chdir */

 exiting gettid */

 SPDX-License-Identifier: GPL-2.0

	/*

	 * Allocate two contiguous pages. The first one is for read-write,

	 * another is for read-only.

 Unsupported flags */

 A part of the buffer is read-only */

 Read-only buffer */

 Send signals in process-wide and per-thread queues */

 Dump signals one by one*/

 Dump all signals for one call */

	/*

	 * Dump signal from the process-wide queue.

	 * The number of signals is not multible to the buffer size

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Author: Aleksa Sarai <cyphar@cyphar.com>

 * Copyright (C) 2018-2019 SUSE LLC.

/*

 * Construct a test directory with the following structure:

 *

 * root/

 * |-- procexe -> /proc/self/exe

 * |-- procroot -> /proc/self/root

 * |-- root/

 * |-- mnt/ [mountpoint]

 * |   |-- self -> ../mnt/

 * |   `-- absself -> /mnt/

 * |-- etc/

 * |   `-- passwd

 * |-- creatlink -> /newfile3

 * |-- reletc -> etc/

 * |-- relsym -> etc/passwd

 * |-- absetc -> /etc/

 * |-- abssym -> /etc/passwd

 * |-- abscheeky -> /cheeky

 * `-- cheeky/

 *     |-- absself -> /

 *     |-- self -> ../../root/

 *     |-- garbageself -> /../../root/

 *     |-- passwd -> ../cheeky/../cheeky/../etc/../etc/passwd

 *     |-- abspasswd -> /../cheeky/../cheeky/../etc/../etc/passwd

 *     |-- dotdotlink -> ../../../../../../../../../../../../../../etc/passwd

 *     `-- garbagelink -> /../../../../../../../../../../../../../../etc/passwd

 Unshare and make /tmp a new directory. */

 Make the top-level directory. */

 A sub-directory which is actually used for tests. */

 There is no mountat(2), so use chdir. */

* RESOLVE_BENEATH **/

 Attempts to cross dirfd should be blocked. */

 Only relative paths that stay inside dirfd should work. */

 Tricky paths should fail. */

* RESOLVE_IN_ROOT **/

 All attempts to cross the dirfd will be scoped-to-root. */

 O_CREAT should handle trailing symlinks correctly. */

* RESOLVE_NO_XDEV **/

 Crossing *down* into a mountpoint is disallowed. */

 Crossing *up* out of a mountpoint is disallowed. */

 Jumping to "/" is ok, but later components cannot cross. */

 Magic-links are blocked since they can switch vfsmounts. */

 Except magic-link jumps inside the same vfsmount. */

* RESOLVE_NO_MAGICLINKS **/

 Regular symlinks should work. */

 Magic-links should not work. */

* RESOLVE_NO_SYMLINKS **/

 Normal paths should work. */

 Regular symlinks are blocked. */

 Trailing symlinks with NO_FOLLOW. */

 Auto-set O_PATH. */

 NOTE: We should be checking for CAP_SYS_ADMIN here... */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Author: Aleksa Sarai <cyphar@cyphar.com>

 * Copyright (C) 2018-2019 SUSE LLC.

 Check openat2(2) support. */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Author: Aleksa Sarai <cyphar@cyphar.com>

 * Copyright (C) 2018-2019 SUSE LLC.

/*

 * O_LARGEFILE is set to 0 by glibc.

 * XXX: This is wrong on {mips, parisc, powerpc, sparc}.

 Normal struct. */

 Bigger struct, with zeroed out end. */

 TODO: Once expanded, check zero-padding. */

 Smaller than version-0 struct. */

 Bigger struct, with non-zero trailing bytes. */

				/*

				 * Explicitly misalign the structure copying it with the given

				 * (mis)alignment offset. The other data is set to be non-zero to

				 * make sure that non-zero bytes outside the struct aren't checked

				 *

				 * This is effectively to check that is_zeroed_user() works.

 O_TMPFILE is incompatible with O_PATH and O_CREAT. */

 O_PATH only permits certain other flags to be set ... */

 ... and others are absolutely not permitted. */

 ->mode must only be set with O_{CREAT,TMPFILE}. */

 ->mode must only contain 0777 bits. */

 ->resolve flags must not conflict. */

 ->resolve must only contain RESOLVE_* flags. */

 currently unknown upper 32 bit rejected. */

 O_CLOEXEC isn't shown in F_GETFL. */

 O_CREAT is hidden from F_GETFL. */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Author: Aleksa Sarai <cyphar@cyphar.com>

 * Copyright (C) 2018-2019 SUSE LLC.

/* Construct a test directory with the following structure:

 *

 * root/

 * |-- a/

 * |   `-- c/

 * `-- b/

 Make the top-level directory. */

 Swap @dirfd/@a and @dirfd/@b constantly. Parent must kill this process. */

 If the parent (the test process) dies, kill ourselves too. */

 Swap @a and @b. */

 escaped outside and got ENOENT... */

 unexpected error */

 we got an unexpected fd */

 Should be killed anyway, but might as well make sure. */

 SPDX-License-Identifier: GPL-2.0

 Multi-threaded */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

/*

 * Test for remove_on_exec.

 *

 * Copyright (C) 2021, Google LLC.

 We need the latest siginfo from the kernel repo. */

		/*

		 * Children normally retain their inherited event on exec; with

		 * remove_on_exec, we'll remove their event, but the parent and

		 * any other non-exec'd children will keep their events.

 Initialize sigtrap handler. */

 Initialize perf event. */

 Verify event propagates to fork'd child. */

 Child enables event. */

/*

 * Verify that event does _not_ propagate to fork+exec'd child; event enabled

 * after fork+exec.

	/*

	 * Non-exec child, to ensure exec does not affect inherited events of

	 * other children.

 Block until parent enables event. */

 Child is running. */

 Wait for exec'd child to start spinning. */

 Now we can enable the event, knowing the child is doing work. */

 If the event propagated to the exec'd child, it will exit normally... */

 ... give time for event to trigger (in case of bug). */

 Should still be running. */

 Verify removal from child did not affect this task's event. */

 Should not hang! */

 Nor should it have affected the first child. */

/*

 * Verify that event does _not_ propagate to fork+exec'd child; event enabled

 * before fork+exec.

	/*

	 * The child may exit abnormally at any time if the event propagated and

	 * a SIGTRAP is sent before the handler was set up.

 ... give time for event to trigger (in case of bug). */

 Should still be running. */

 Verify removal from child did not affect this task's event. */

 Should not hang! */

 Some forked with event disabled, rest with enabled. */

 ... give time for event to trigger (in case of bug). */

 All children should still be running. */

 Verify event is still alive. */

 For exec'd child. */

 Set up sigtrap handler in case we erroneously receive a trap. */

 Signal parent that we're starting to spin. */

 Should hang here until killed. */

 SPDX-License-Identifier: GPL-2.0

/*

 * Test for perf events with SIGTRAP across all threads.

 *

 * Copyright (C) 2021, Google LLC.

 We need the latest siginfo from the kernel repo. */

 Data shared between test body, threads, and signal handler. */

 Which threads still want a signal. */

 Sanity check number of signals received. */

 Variable to set breakpoint on. */

 First observed siginfo_t. */

 Unique value to check si_perf_data is correctly set from perf_event_attr::sig_data. */

 Children inherit events ... */

 ... but only cloned with CLONE_THREAD. */

 Required by sigtrap. */

 Request synchronous SIGTRAP on event. */

	/*

	 * The data in siginfo_t we're interested in should all be the same

	 * across threads.

 read */

 idempotent write */

 Initialize sigtrap handler. */

 Initialize perf event. */

 Spawn threads inheriting perf event. */

 Check enabled for parent. */

 Test that modification propagates to all inherited events. */

 Check enabled for parent. */

 Stress test event + signal handling. */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 splice(2) file to stdout. */

 SPDX-License-Identifier: GPL-2.0

 Copyright (C) 2019 ARM Limited */

/*

 * The following handle_signal_* helpers are used by main default_handler

 * and are meant to return true when signal is handled successfully:

 * when false is returned instead, it means that the signal was somehow

 * unexpected in that context and it was NOT handled; default_handler will

 * take care of such unexpected situations.

 Mangling PC to avoid loops on original SIGILL */

 ->run was asserted NON-NULL in test_setup() already */

	/*

	 * it's a bug in the test code when this assert fail:

	 * if sig_trig was defined, it must have been used before getting here.

	/*

	 * fake_sigreturn tests, which have sanity_enabled=1, set, at the very

	 * last time, the token field to the SP address used to place the fake

	 * sigframe: so token==0 means we never made it to the end,

	 * segfaulting well-before, and the test is possibly broken.

	/*

	 * Trying to narrow down the SEGV to the ones generated by Kernel itself

	 * via arm64_notify_segfault(). This is a best-effort check anyway, and

	 * the si_code check may need to change if this aspect of the kernel

	 * ABI changes.

	/*

	 * Some tests can lead to SEGV loops: in such a case we want to

	 * terminate immediately exiting straight away; some others are not

	 * supposed to outlive the signal handler code, due to the content of

	 * the fake sigframe which caused the signal itself.

 Mangling PC to avoid loops on original BRK instr */

 uncatchable signals naturally skipped ... */

	/*

	 * RT Signals default disposition is Term but they cannot be

	 * generated by the Kernel in response to our tests; so just catch

	 * them all and report them as UNEXPECTED signals.

 just in case...unblock explicitly all we need */

 just in case */

		/*

		 * Checking for CPU required features using both the

		 * auxval and the arm64 MRS Emulation to read sysregs.

 Perform test specific additional initialization */

 assert core invariants symptom of a rotten testcase */

 Default result is FAIL if test setup fails */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2019 ARM Limited

 *

 * Generic test wrapper for arm64 signal tests.

 *

 * Each test provides its own tde struct tdescr descriptor to link with

 * this wrapper. Framework provides common helpers.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2019 ARM Limited

 *

 * Try to mangle the ucontext from inside a signal handler, toggling

 * the execution state bit: this attempt must be spotted by Kernel and

 * the test case is expected to be terminated via SEGV.

 This config should trigger a SIGSEGV by Kernel */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2021 ARM Limited

 *

 * Attempt to change the SVE vector length in a signal hander, this is not

 * supported and is expected to segfault.

	/*

	 * Enumerate up to SVE_VQ_MAX vector lengths

 Skip missing VLs */

 We need at least two VLs */

 Get a signal context with a SVE frame in it */

 No changes are supported; init left us at minimum VL so go to max */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2019 ARM Limited

 *

 * Try to mangle the ucontext from inside a signal handler, mangling the

 * DAIF bits in an illegal manner: this attempt must be spotted by Kernel

 * and the test case is expected to be terminated via SEGV.

 *

	/*

	 * This config should trigger a SIGSEGV by Kernel when it checks

	 * the sigframe consistency in valid_user_regs() routine.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2021 ARM Limited

 *

 * Check that the SVE vector length reported in signal contexts is the

 * expected one.

 Get a signal context which should have a SVE frame in it */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2021 ARM Limited

 *

 * Verify that the SVE register context in signal frames is set up as

 * expected.

	/*

	 * Enumerate up to SVE_VQ_MAX vector lengths

 Skip missing VLs */

 We need at least one VL */

 RDVL x16, #1 so we should have SVE regs; real data is TODO */

	/*

	 * Get a signal context which should have a SVE frame and registers

	 * in it.

 The actual size validation is done in get_current_context() */

		/*

		 * TODO: the signal test helpers can't currently cope

		 * with signal frames bigger than struct sigcontext,

		 * skip VLs that will trigger that.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2019 ARM Limited

 *

 * Place a fake sigframe on the stack including a bad record overflowing

 * the __reserved space: on sigreturn Kernel must spot this attempt and

 * the test case is expected to be terminated via SEGV.

 just to fill the ucontext_t with something real */

 at least HDR_SZ + bad sized esr_context needed */

	/*

	 * Use an esr_context to build a fake header with a

	 * size greater then the free __reserved area minus HDR_SZ;

	 * using ESR_MAGIC here since it is not checked for size nor

	 * is limited to one instance.

	 *

	 * At first inject an additional normal esr_context

 and terminate properly */

	/*

	 * now mess with fake esr_context size: leaving less space than

	 * needed while keeping size value 16-aligned

	 *

	 * It must trigger a SEGV from Kernel on:

	 *

	 *	resv_sz - offset < sizeof(*head)

 at first set the maximum good 16-aligned size */

 plus a bit more of 16-aligned sized stuff */

 and terminate properly */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2019 ARM Limited

 *

 * Try to mangle the ucontext from inside a signal handler, toggling

 * the mode bit to escalate exception level: this attempt must be spotted

 * by Kernel and the test case is expected to be termninated via SEGV.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2019 ARM Limited

 *

 * Try to mangle the ucontext from inside a signal handler, toggling

 * the mode bit to escalate exception level: this attempt must be spotted

 * by Kernel and the test case is expected to be termninated via SEGV.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2019 ARM Limited

 *

 * Place a fake sigframe on the stack including a BAD Unknown magic

 * record: on sigreturn Kernel must spot this attempt and the test

 * case is expected to be terminated via SEGV.

 just to fill the ucontext_t with something real */

 need at least 2*HDR_SZ space: KSFT_BAD_MAGIC + terminator. */

	/*

	 * use a well known NON existent bad magic...something

	 * we should pretty sure won't be ever defined in Kernel

 SPDX-License-Identifier: GPL-2.0

 Copyright (C) 2019 ARM Limited */

 Size will be rounded up to a multiple of 16 bytes */

 Either a bare sve_context or a sve_context followed by regs data */

 Walk till the end terminator verifying __reserved contents */

 Size is validated in validate_sve_context() */

			/*

			 * This is a BAD magic header defined

			 * artificially by a testcase and surely

			 * unknown to the Kernel parse_user_sigframe().

			 * It MUST cause a Kernel induced SEGV

			/*

			 * A still unknown Magic: potentially freshly added

			 * to the Kernel code and still unknown to the

			 * tests.

/*

 * This function walks through the records inside the provided reserved area

 * trying to find enough space to fit @need_sz bytes: if not enough space is

 * available and an extra_context record is present, it throws away the

 * extra_context record.

 *

 * It returns a pointer to a new header where it is possible to start storing

 * our need_sz bytes.

 *

 * @shead: points to the start of reserved area

 * @need_sz: needed bytes

 * @resv_sz: reserved area size in bytes

 * @offset: if not null, this will be filled with the offset of the return

 *	    head pointer from @shead

 *

 * @return: pointer to a new head where to start storing need_sz bytes, or

 *	    NULL if space could not be made available.

 not found a terminator...no need to update offset if any */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2019 ARM Limited

 *

 * Place a fake sigframe on the stack including a badly sized terminator

 * record: on sigreturn Kernel must spot this attempt and the test case

 * is expected to be terminated via SEGV.

 just to fill the ucontext_t with something real */

 at least HDR_SZ for the badly sized terminator. */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2019 ARM Limited

 *

 * Place a fake sigframe on the stack at a misaligned SP: on sigreturn

 * Kernel must spot this attempt and the test case is expected to be

 * terminated via SEGV.

 just to fill the ucontext_t with something real */

 Forcing sigframe on misaligned SP (16 + 3) */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2019 ARM Limited

 *

 * Try to mangle the ucontext from inside a signal handler, toggling

 * the mode bit to escalate exception level: this attempt must be spotted

 * by Kernel and the test case is expected to be termninated via SEGV.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2019 ARM Limited

 *

 * Try to mangle the ucontext from inside a signal handler, toggling

 * the mode bit to escalate exception level: this attempt must be spotted

 * by Kernel and the test case is expected to be termninated via SEGV.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2019 ARM Limited

 *

 * Place a fake sigframe on the stack including an additional FPSIMD

 * record: on sigreturn Kernel must spot this attempt and the test

 * case is expected to be terminated via SEGV.

 just to fill the ucontext_t with something real */

 Add a spurious fpsimd_context */

 and terminate */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2019 ARM Limited

 *

 * Place a fake sigframe on the stack missing the mandatory FPSIMD

 * record: on sigreturn Kernel must spot this attempt and the test

 * case is expected to be terminated via SEGV.

 just to fill the ucontext_t with something real */

 Just overwrite fpsmid_context */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2019 ARM Limited

 *

 * Try to mangle the ucontext from inside a signal handler, toggling

 * the mode bit to escalate exception level: this attempt must be spotted

 * by Kernel and the test case is expected to be termninated via SEGV.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2019 ARM Limited

 *

 * Try to mangle the ucontext from inside a signal handler, toggling

 * the mode bit to escalate exception level: this attempt must be spotted

 * by Kernel and the test case is expected to be termninated via SEGV.

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Copyright (C) 2020 ARM Limited

 Check the validity of the tagged pointer */

 Proceed further for nonzero tags */

 Check the validity outside the range */

 Try to catch a excluded tag by a number of tries. */

 Check tag value */

 Try to catch a excluded tag by a number of tries. */

 Check tag value */

 Try to catch a excluded tag by a number of tries. */

		/*

		 * Here tag byte can be between 0x0 to 0xF (full allowed range)

		 * so no need to match so just verify if it is writable.

 Try to catch a excluded tag by a number of tries. */

 Here all tags exluded so tag value generated should be 0 */

 Check the write validity of the untagged pointer */

 Register SIGSEGV handler */

 Set test plan */

 SPDX-License-Identifier: GPL-2.0

 Copyright (C) 2020 ARM Limited

 Compare the context for precise error */

 Adjust the pc by 4 */

 Adjust the pc by 4 */

 Initialize the file for mappable size */

 Initialize the file for mappable size */

 Enable address tagging ABI, mte error reporting mode and tag inclusion mask. */

 Get current mte mode */

 Disable PSTATE.TCO */

 Create a file in the tmpfs filesystem */

 SPDX-License-Identifier: GPL-2.0

 Copyright (C) 2020 ARM Limited

 page size - 1*/ 0,  page size + 1 */ 0

 Only mte enabled memory will allow tag insertion */

 Only mte enabled memory will allow tag insertion */

 Try to clear PROT_MTE property and verify it by tag checking */

 Try to clear PROT_MTE property and verify it by tag checking */

 Register signal handlers */

 Set test plan */

 SPDX-License-Identifier: GPL-2.0

 Copyright (C) 2020 ARM Limited

 Insert same data in all the pages */

 Tagged pages should not merge */

 Register signal handlers */

 Set test plan */

 Enable KSM */

 SPDX-License-Identifier: GPL-2.0

 Copyright (C) 2020 ARM Limited

 page size - 1*/ 0,  page size + 1 */ 0

 Do copy on write */

 Wait for child process to terminate */

 Only mte enabled memory will allow tag insertion */

 Register SIGSEGV handler */

 Set test plan */

 SPDX-License-Identifier: GPL-2.0

 Copyright (C) 2020 ARM Limited

 Copy from file into buffer with valid tag */

 Verify same pattern is read */

 Tag the next half of memory with different value */

 Copy from file into buffer with invalid tag */

	/*

	 * Accessing user memory in kernel with invalid tag should fail in sync

	 * mode without fault but may not fail in async mode as per the

	 * implemented MTE userspace support in Arm64 kernel.

 Register signal handlers */

 Set test plan */

 SPDX-License-Identifier: GPL-2.0

 Copyright (C) 2020 ARM Limited

 SPDX-License-Identifier: GPL-2.0

 Copyright (C) 2020 ARM Limited

 page size - 1*/ 0,  page size + 1 */ 0

 Set some value in tagged memory */

 Check the buffer whether it is filled. */

 Set some value in tagged memory and make the buffer underflow */

 Check whether the buffer is filled */

 There were no fault so the underflow area should be filled */

 Imprecise fault should occur otherwise return error */

			/*

			 * The imprecise fault is checked after the write to the buffer,

			 * so the underflow area before the fault should be filled.

 Precise fault should occur otherwise return error */

 Underflow area should not be filled */

 Set some value in tagged memory and make the buffer underflow */

 Check whether the buffer is filled */

 There were no fault so the overflow area should be filled */

 Imprecise fault should occur otherwise return error */

			/*

			 * The imprecise fault is checked after the write to the buffer,

			 * so the overflow area should be filled before the fault.

 Precise fault should occur otherwise return error */

 Underflow area should not be filled */

 Set some value in memory and copy*/

 Check the buffer whether it is filled. */

 check initial tags for anonymous mmap */

 check initial tags for file mmap */

 Register SIGSEGV handler */

 Set test plan */

 Buffer by byte tests */

 Check buffer underflow with underflow size as 16 */

 Check buffer underflow with underflow size as page size */

 Check buffer overflow with overflow size as 16 */

 Buffer by block tests */

 Initial tags are supposed to be 0 */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2015-2020 ARM Limited.

 * Original author: Dave Martin <Dave.Martin@arm.com>

	/*

	 * Enumerate up to SVE_VQ_MAX vector lengths

 Print out the vector lengths in ascending order: */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2015-2019 ARM Limited.

 * Original author: Dave Martin <Dave.Martin@arm.com>

 vector length */

 command */

 same as sh(1) command-not-executable error */

 same as sh(1) builtin incorrect-usage */

 same as sh(1) builtin incorrect-usage */

 same as sh(1) not-found error */

 same as sh(1) not-executable error */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2015-2021 ARM Limited.

 * Original author: Dave Martin <Dave.Martin@arm.com>

 <linux/elf.h> and <sys/auxv.h> don't like each other, so: */

 Validate setting and getting the inherit flag */

 First set the flag */

	/*

	 * Read back the new register state and verify that we have

	 * set the flags we expected.

 Now clear */

 Validate attempting to set the specfied VL via ptrace */

 Check if the VL is supported in this process */

 If the VL is not supported then a supported VL will be returned */

 Set the VL by doing a set with no register payload */

	/*

	 * Read back the new register state and verify that we have the

	 * same VL that we got from prctl() on ourselves.

 Access the FPSIMD registers via the SVE regset */

 New process should start with FPSIMD registers only */

 Try to set a known FPSIMD state via PT_REGS_SVE */

 Verify via the FPSIMD regset */

 Validate attempting to set SVE data and read SVE data */

 Set up some data and write it out */

 TODO: Generate a valid FFR pattern */

 Read the data back */

 We might read more data if there's extensions we don't know */

 Validate attempting to set SVE data and read SVE data */

 Set up some data and write it out */

 Read the data back */

		/*

		 * Z regs are stored endianness invariant, this won't

		 * work for big endian

 Attach to the child */

		/*

		 * This should never happen but it's hard to flag in

		 * the framework.

 bust group-stop */

 FPSIMD via SVE regset */

 prctl() flags */

 Step through every possible VQ */

 First, try to set this vector length */

 If the VL is supported validate data set/get */

 SPDX-License-Identifier: GPL-2.0-only

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2021 ARM Limited.

 * Original author: Mark Brown <broonie@kernel.org>

 Start a new process and return the vector length it sees */

 Child: put vector length on the pipe */

		/*

		 * Replace stdout with the pipe, errors to stderr from

		 * here as kselftest prints to stdout.

 exec() a new binary which puts the VL on stdout */

 Parent; wait for the exit status from the child & verify it */

/*

 * Verify that we can read the default VL via proc, checking that it

 * is set in a freshly spawned child.

 Is this the actual default seen by new processes? */

 Verify that we can write a minimum value and have it take effect */

 What was the new value? */

 Did it take effect in a new process? */

 Verify that we can write a maximum value and have it take effect */

 -1 is accepted by the /proc interface as the maximum VL */

 What was the new value? */

 Did it take effect in a new process? */

 Can we read back a VL from prctl? */

 Mask out any flags */

 Is that what we can read back directly? */

 Does the prctl let us set the VL we already have? */

 Can we set a new VL for this process? */

 Try to set the minimum VL */

 Try to set the maximum VL */

 The _INHERIT flag should not be present when we read the VL */

 If we didn't request it a new VL shouldn't affect the child */

 Ensure the default VL is different */

 Check that the child has the default we just set */

 If we didn't request it a new VL shouldn't affect the child */

 The _INHERIT flag should be present when we read the VL */

 Ensure the default VL is different */

 Check that the child inherited our VL */

 _ONEXEC takes effect only in the child process */

 Set a known value for the default and our current VL */

 Set a different value for the child to have on exec */

 Our current VL should stay the same */

 Check that the child inherited our VL */

 For each VQ verify that setting via prctl() does the right thing */

 Attempt to set the VL */

 Check that we actually have the reported new VL */

 Was that the VL we asked for? */

 Should round up to the minimum VL if below it */

 Should round down to maximum VL if above it */

 Otherwise we should've rounded down */

	/*

	 * The default/min/max tests must be first and in this order

	 * to provide data for other tests.

 SPDX-License-Identifier: GPL-2.0

 Copyright (C) 2020 ARM Limited

	/* don't try to execute illegal (unimplemented) instructions) caller

	 * should have checked this and keep worker simple

 SPDX-License-Identifier: GPL-2.0

 Copyright (C) 2020 ARM Limited

 output is encoded in the upper 32 bits */

 SPDX-License-Identifier: GPL-2.0

 Copyright (C) 2020 ARM Limited

/*

 * The kernel sets TBID by default. So bits 55 and above should remain

 * untouched no matter what.

 * The VA space size is 48 bits. Bigger is opt-in.

 data key instructions are not in NOP space. This prevents a SIGILL */ \

 generic key instructions are not in NOP space. This prevents a SIGILL */ \

	/*

	 * pin this process and all its children to a single CPU, so it can also

	 * guarantee a context switch with its child

 child

	/*

	 * wait for the worker to finish, so that read() reads all data

	 * will also context switch with worker so that this function can be used

	 * for context switch tests

 check that a corrupted PAC results in SIGSEGV or SIGILL */

/*

 * There are no separate pac* and aut* controls so checking only the pac*

 * instructions is sufficient

 generic and data key instructions are not in NOP space. This prevents a SIGILL */

	/*

	 * In Linux the PAC field can be up to 7 bits wide. Even if keys are

	 * different, there is about 5% chance for PACs to collide with

	 * different addresses. This chance rapidly increases with fewer bits

	 * allocated for the PAC (e.g. wider address). A comparison of the keys

	 * directly will be more reliable.

	 * All signed values need to be different at least once out of n

	 * attempts to be certain that the keys are different

/*

 * fork() does not change keys. Only exec() does so call a worker program.

 * Its only job is to sign a value and report back the resutls

 generic and data key instructions are not in NOP space. This prevents a SIGILL */

 will context switch with a process with different keys at least once */

 will context switch with a process with different keys at least once */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2019  Arm Limited

 * Original author: Dave Martin <Dave.Martin@arm.com>

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2019,2021  Arm Limited

 * Original author: Dave Martin <Dave.Martin@arm.com>

 zap BTYPE so that resuming the faulting code will work */

 Branch Target exceptions should only happen in BTI binaries: */

 Gross hack for finding AT_HWCAP2 from the initial process stack: */

 start of environment */

 step over environment */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2019  Arm Limited

 * Original author: Dave Martin <Dave.Martin@arm.com>

 SPDX-License-Identifier: GPL-2.0

 ignore libudev messages */

 ignore uevents we didn't trigger */

 If logging is enabled dump the received uevent. */

 Check whether we have been orphaned. */

 Make sure that we go away when our parent dies. */

	/* Trigger 10 uevents to account for the case where the kernel might

	 * drop some.

	/* Wait for 2 seconds before considering this failed. This should be

	 * plenty of time for the kernel to deliver the uevent even under heavy

	 * load.

 success */

 error */

	/*

	 * Setup:

	 * - Open uevent listening socket in initial network namespace owned by

	 *   initial user namespace.

	 * - Trigger uevent in initial network namespace owned by initial user

	 *   namespace.

	 * Expected Result:

	 * - uevent listening socket receives uevent

	/*

	 * Setup:

	 * - Open uevent listening socket in non-initial network namespace

	 *   owned by initial user namespace.

	 * - Trigger uevent in initial network namespace owned by initial user

	 *   namespace.

	 * Expected Result:

	 * - uevent listening socket receives uevent

	/*

	 * Setup:

	 * - unshare user namespace

	 * - Open uevent listening socket in initial network namespace

	 *   owned by initial user namespace.

	 * - Trigger uevent in initial network namespace owned by initial user

	 *   namespace.

	 * Expected Result:

	 * - uevent listening socket receives uevent

	/*

	 * Setup:

	 * - Open uevent listening socket in non-initial network namespace

	 *   owned by non-initial user namespace.

	 * - Trigger uevent in initial network namespace owned by initial user

	 *   namespace.

	 * Expected Result:

	 * - uevent listening socket receives no uevent

	/*

	 * Setup:

	 * - Open uevent listening socket in initial network namespace

	 *   owned by initial user namespace.

	 * - unshare network namespace

	 * - Trigger uevent in initial network namespace owned by initial user

	 *   namespace.

	 * Expected Result:

	 * - uevent listening socket receives uevent

	/*

	 * Setup:

	 * - Open uevent listening socket in initial network namespace

	 *   owned by initial user namespace.

	 * - unshare user namespace

	 * - Trigger uevent in initial network namespace owned by initial user

	 *   namespace.

	 * Expected Result:

	 * - uevent listening socket receives uevent

	/*

	 * Setup:

	 * - Open uevent listening socket in initial network namespace

	 *   owned by initial user namespace.

	 * - unshare user namespace

	 * - unshare network namespace

	 * - Trigger uevent in initial network namespace owned by initial user

	 *   namespace.

	 * Expected Result:

	 * - uevent listening socket receives uevent

 SPDX-License-Identifier: GPL-2.0-only

/*

 * entry_from_vm86.c - tests kernel entries from vm86 mode

 * Copyright (c) 2014-2015 Andrew Lutomirski

 *

 * This exercises a few paths that need to special-case vm86 mode.

 addressing via displacements */

 addressing via registers */

 register operands, only for smsw */

 Returns false if the test was skipped. */

 Initialize variables with arbitrary values */

 UMIP -- exit with INT3 unless kernel emulation did not trap #GP */

 Results from displacement-only addressing */

 Results from register-indirect addressing */

 Results when using register operands */

 Use the end of the page as our stack. */

 Looks like RPL = 0 */

 #BR -- should deliver SIG??? */

	/*

	 * SYSENTER -- should cause #GP or #UD depending on CPU.

	 * Expected return type -1 means that we shouldn't validate

	 * the vm86 return value.  This will avoid problems on non-SEP

	 * CPUs.

	/*

	 * SYSCALL would be a disaster in VM86 mode.  Fortunately,

	 * there is no kernel that both enables SYSCALL and sets

	 * EFER.SCE, so it's #UD on all systems.  But vm86 is

	 * buggy (or has a "feature"), so the SIGILL will actually

	 * be delivered.

 STI with VIP set */

 POPF with VIP set but IF clear: should not trap */

 POPF with VIP set and IF set: should trap */

 POPF with VIP clear and IF set: should not trap */

 INT3 -- should cause #BP */

 INT80 -- should exit with "INTx 0x80" */

 UMIP -- should exit with INTx 0x80 unless UMIP was not disabled */

 Execute a null pointer */

 Make sure nothing explodes if we fork. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * syscall_arg_fault.c - tests faults 32-bit fast syscall stack args

 * Copyright (c) 2015 Andrew Lutomirski

	/*

	 * KVM has some bugs that can cause us to stop making progress.

	 * detect them and complain, but don't infinite loop or fail the

	 * test.

 The trap was on SYSCALL or SYSENTER */

 one of the ud2 instructions faulted */

 Our sigaltstack scratch space. */

	/*

	 * The actual exception can vary.  On Atom CPUs, we get #SS

	 * instead of #PF when the vDSO fails to access the stack when

	 * ESP is too close to 2^32, and #SS causes SIGBUS.

	/*

	 * Exercise another nasty special case.  The 32-bit SYSCALL

	 * and SYSENTER instructions (even in compat mode) each

	 * clobber one register.  A Linux system call has a syscall

	 * number and six arguments, and the user stack pointer

	 * needs to live in some register on return.  That means

	 * that we need eight registers, but SYSCALL and SYSENTER

	 * only preserve seven registers.  As a result, one argument

	 * ends up on the stack.  The stack is user memory, which

	 * means that the kernel can fail to read it.

	 *

	 * The 32-bit fast system calls don't have a defined ABI:

	 * we're supposed to invoke them through the vDSO.  So we'll

	 * fudge it: we set all regs to invalid pointer values and

	 * invoke the entry instruction.  The return will fail no

	 * matter what, and we completely lose our program state,

	 * but we can fix it up with a signal handler.

 make sure we recover cleanly */

 make sure we recover cleanly */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * sigreturn.c - tests for x86 sigreturn(2) and exit-to-userspace

 * Copyright (c) 2014-2015 Andrew Lutomirski

 *

 * This is a series of tests that exercises the sigreturn(2) syscall and

 * the IRET / SYSRET paths in the kernel.

 *

 * For now, this focuses on the effects of unusual CS and SS values,

 * and it has a bunch of tests to make sure that ESP/RSP is restored

 * properly.

 *

 * The basic idea behind these tests is to raise(SIGUSR1) to create a

 * sigcontext frame, plug in the values to be tested, and then return,

 * which implicitly invokes sigreturn(2) and programs the user context

 * as desired.

 *

 * For tests for which we expect sigreturn and the subsequent return to

 * user mode to succeed, we return to a short trampoline that generates

 * SIGTRAP so that the meat of the tests can be ordinary C code in a

 * SIGTRAP handler.

 *

 * The inner workings of each test is documented below.

 *

 * Do not run on outdated, unpatched kernels at risk of nasty crashes.

 Pull in AR_xyz defines. */

/*

 * Copied from asm/ucontext.h, as asm/ucontext.h conflicts badly with the glibc

 * headers.

/*

 * UC_SIGCONTEXT_SS will be set when delivering 64-bit or x32 signals on

 * kernels that save SS in the sigcontext.  All kernels that set

 * UC_SIGCONTEXT_SS will correctly restore at least the low 32 bits of esp

 * regardless of SS (i.e. they implement espfix).

 *

 * Kernels that set UC_SIGCONTEXT_SS will also set UC_STRICT_RESTORE_SS

 * when delivering a signal that came from 64-bit code.

 *

 * Sigreturn restores SS as follows:

 *

 * if (saved SS is valid || UC_STRICT_RESTORE_SS is set ||

 *     saved CS is not 64-bit)

 *         new SS = saved SS  (will fail IRET and signal if invalid)

 * else

 *         new SS = a flat 32-bit data segment

/*

 * In principle, this test can run on Linux emulation layers (e.g.

 * Illumos "LX branded zones").  Solaris-based kernels reserve LDT

 * entries 0-5 for their own internal purposes, so start our LDT

 * allocations above that reservation.  (The tests don't pass on LX

 * branded zones, but at least this lets them run.)

 An aligned stack accessible through some of our segments. */

/*

 * An aligned int3 instruction used as a trampoline.  Some of the tests

 * want to fish out their ss values, so this trampoline copies ss to eax

 * before the int3.

/*

 * At startup, we prepapre:

 *

 * - ldt_nonexistent_sel: An LDT entry that doesn't exist (all-zero

 *   descriptor or out of bounds).

 * - code16_sel: A 16-bit LDT code segment pointing to int3.

 * - data16_sel: A 16-bit LDT data segment pointing to stack16.

 * - npcode32_sel: A 32-bit not-present LDT code segment pointing to int3.

 * - npdata32_sel: A 32-bit not-present LDT data segment pointing to stack16.

 * - gdt_data16_idx: A 16-bit GDT data segment pointing to stack16.

 * - gdt_npdata32_idx: A 32-bit not-present GDT data segment pointing to

 *   stack16.

 *

 * For no particularly good reason, xyz_sel is a selector value with the

 * RPL and LDT bits filled in, whereas xyz_idx is just an index into the

 * descriptor table.  These variables will be zero if their respective

 * segments could not be allocated.

 Code, not conforming */

 Data, grow-up */

 Code, not conforming */

 Data, grow-up */

 Data, grow-up */

		/*

		 * This probably indicates vulnerability to CVE-2014-8133.

		 * Merely getting here isn't definitive, though, and we'll

		 * diagnose the problem for real later on.

 Data, grow-up */

		/*

		 * As a hardening measure, newer kernels don't allow this.

 State used by our signal handlers. */

 Instructions for the SIGUSR1 handler. */

 Abstractions for some 32-bit vs 64-bit differences. */

/*

 * Checks a given selector for its code bitness or returns -1 if it's not

 * a usable code segment selector.

 Not code. */

 Unknown bitness. */

/*

 * Checks a given selector for its code bitness or returns -1 if it's not

 * a usable code segment selector.

 Number of errors in the current test case. */

		/*

		 * This happens on Linux 4.1.  The rest will fail, too, so

		 * return now to reduce the noise.

 UC_STRICT_RESTORE_SS is set iff we came from 64-bit mode. */

		/*

		 * DOSEMU was written before 64-bit sigcontext had SS, and

		 * it tries to figure out the signal source SS by looking at

		 * the physical register.  Make sure that keeps working.

/*

 * SIGUSR1 handler.  Sets CS and SS as requested and points IP to the

 * int3 trampoline.  Sets SP to a large known value so that we can see

 * whether the value round-trips back to user mode correctly.

	/*

	 * Make sure the kernel doesn't inadvertently use DS or ES-relative

	 * accesses in a region where user DS or ES is loaded.

	 *

	 * Skip this for 64-bit builds because long mode doesn't care about

	 * DS and ES and skipping it increases test coverage a little bit,

	 * since 64-bit kernels can still run the 32-bit build.

 The asm code does this. */

/*

 * Called after a successful sigreturn (via int3) or from a failed

 * sigreturn (directly by kernel).  Restores our state so that the

 * original raise(SIGUSR1) returns.

 Sanity check failure. */

			/*

			 * DOSEMU transitions from 32-bit to 64-bit mode by

			 * adjusting sigcontext, and it requires that this work

			 * even if the saved SS is bogus.

 Tests recovery if !UC_STRICT_RESTORE_SS */

 We can't do the rest. */

 Return.  The kernel should recover without sending another signal. */

 Finds a usable code segment of the requested bitness. */

	/*

	 * Check that each register had an acceptable value when the

	 * int3 trampoline was invoked.

 don't care */

			/*

			 * If we were using a 16-bit stack segment, then

			 * the kernel is a bit stuck: IRET only restores

			 * the low 16 bits of ESP/RSP if SS is 16-bit.

			 * The kernel uses a hack to restore bits 31:16,

			 * but that hack doesn't help with bits 63:32.

			 * On Intel CPUs, bits 63:32 end up zeroed, and, on

			 * AMD CPUs, they leak the high bits of the kernel

			 * espfix64 stack pointer.  There's very little that

			 * the kernel can do about it.

			 *

			 * Similarly, if we are returning to a 32-bit context,

			 * the CPU will often lose the high 32 bits of RSP.

 Sanity check on the kernel */

 X86_TRAP_IRET */

		/*

		 * This also implicitly tests UC_STRICT_RESTORE_SS:

		 * We check that these signals set UC_STRICT_RESTORE_SS and,

		 * if UC_STRICT_RESTORE_SS doesn't cause strict behavior,

		 * then we won't get SIGSEGV.

 Our sigaltstack scratch space. */

 Easy cases: return to a 32-bit SS in each possible CS bitness. */

	/*

	 * Test easy espfix cases: return to a 16-bit LDT SS in each possible

	 * CS bitness.  NB: with a long mode CS, the SS bitness is irrelevant.

	 *

	 * This catches the original missing-espfix-on-64-bit-kernels issue

	 * as well as CVE-2014-8134.

		/*

		 * For performance reasons, Linux skips espfix if SS points

		 * to the GDT.  If we were able to allocate a 16-bit SS in

		 * the GDT, see if it leaks parts of the kernel stack pointer.

		 *

		 * This tests for CVE-2014-8133.

 Nasty ABI case: check SS corruption handling. */

	/*

	 * We're done testing valid sigreturn cases.  Now we test states

	 * for which sigreturn itself will succeed but the subsequent

	 * entry to user mode will fail.

	 *

	 * Depending on the failure mode and the kernel bitness, these

	 * entry failures can generate SIGSEGV, SIGBUS, or SIGILL.

 32-bit kernels do this */

 Easy failures: invalid SS, resulting in #GP(0) */

 These fail because SS isn't a data segment, resulting in #GP(SS) */

 Try to return to a not-present code segment, triggering #NP(SS). */

	/*

	 * Try to return to a not-present but otherwise valid data segment.

	 * This will cause IRET to fail with #SS on the espfix stack.  This

	 * exercises CVE-2014-9322.

	 *

	 * Note that, if espfix is enabled, 64-bit Linux will lose track

	 * of the actual cause of failure and report #GP(0) instead.

	 * This would be very difficult for Linux to avoid, because

	 * espfix64 causes IRET failures to be promoted to #DF, so the

	 * original exception frame is never pushed onto the stack.

	/*

	 * Try to return to a not-present but otherwise valid data

	 * segment without invoking espfix.  Newer kernels don't allow

	 * this to happen in the first place.  On older kernels, though,

	 * this can trigger CVE-2014-9322.

 SPDX-License-Identifier: GPL-2.0

/*

 * iopl.c - Test case for a Linux on Xen 64-bit bug

 * Copyright (c) 2015 Andrew Lutomirski

 X86_FLAGS_IF */

 X86_FLAGS_IF */

/*

 * Returns whether it managed to disable interrupts.

 Probe for iopl support.  Note that iopl(0) works even as nonroot. */

 Make sure that CLI/STI are blocked even with IOPL level 3 */

 Establish an I/O bitmap to test the restore */

 Restore our original state prior to starting the fork test. */

	/*

	 * Verify that IOPL emulation is disabled and the I/O bitmap still

	 * works.

 Drop the I/O bitmap */

 Test the capability checks. */

 Trivial program to check that compilation with certain flags is working. */

 SPDX-License-Identifier: GPL-2.0 */

/*

 * mov_ss_trap.c: Exercise the bizarre side effects of a watchpoint on MOV SS

 *

 * This does MOV SS from a watchpointed address followed by various

 * types of kernel entries.  A MOV SS that hits a watchpoint will queue

 * up a #DB trap but will not actually deliver that trap.  The trap

 * will be delivered after the next instruction instead.  The CPU's logic

 * seems to be:

 *

 *  - Any fault: drop the pending #DB trap.

 *  - INT $N, INT3, INTO, SYSCALL, SYSENTER: enter the kernel and then

 *    deliver #DB.

 *  - ICEBP: enter the kernel but do not deliver the watchpoint trap

 *  - breakpoint: only one #DB is delivered (phew!)

 *

 * There are plenty of ways for a kernel to handle this incorrectly.  This

 * test tries to exercise all the cases.

 *

 * This should mostly cover CVE-2018-1087 and CVE-2018-8897.

 G0 */

 RW0 = read or write */

 LEN0 = 2 bytes */

 G1, RW1 = insn */

 Some emulators (e.g. QEMU TCG) don't emulate ICEBP. */

	/*

	 * INT $1: if #DB has DPL=3 and there isn't special handling,

	 * then the kernel will die.

	/*

	 * In principle, we should test 32-bit SYSCALL as well, but

	 * the calling convention is so unpredictable that it's

	 * not obviously worth the effort.

		/*

		 * Toggle the high bit of RSP to make it noncanonical to

		 * strengthen this test on non-SMAP systems.

	/*

	 * Invoking SYSENTER directly breaks all the rules.  Just handle

	 * the SIGSEGV.

 Clear EBP first to make sure we segfault cleanly. */

 We're unreachable here.  SYSENTER forgets RIP. */

 compat getpid */

 SPDX-License-Identifier: GPL-2.0

/*

 * ldt_gdt.c - Test cases for LDT and GDT access

 * Copyright (c) 2015 Andrew Lutomirski

 Points to an array of 1024 ints, each holding its own index. */

 Use to delete GDT entry */

 The SDM says "bits 19:16 are undefined".  Thanks. */

	/*

	 * NB: Different Linux versions do different things with the

	 * accessed bit in set_thread_area().

 No point testing set_thread_area in a 64-bit build */

 Should work in the GDT, too. */

 Code, not conforming */

 Test entry_number too high. */

 Test deletion and actions mistakeable for deletion. */

/*

 * 0: thread is idle

 * 1: thread armed

 * 2: thread should clear LDT entry 0

 * 3: thread should exit

 should never fail */

 clear LDT entry 0 */

 If ftx == 2, set it to zero.  If ftx == 100, quit. */

/*

 * The UAPI header calls this 'struct sigaction', which conflicts with

 * glibc.  Sigh.

 the real type is nasty */

		/*

		 * glibc has a nasty bug: it sometimes writes garbage to

		 * sa_restorer.  This interacts quite badly with anything

		 * that fiddles with SS because it can trigger legacy

		 * stack switching.  Patch it up.  See:

		 *

		 * https://sourceware.org/bugzilla/show_bug.cgi?id=21269

 64-bit glibc works fine. */

 True 32-bit kernels send SIGILL instead of SIGSEGV on IRET faults. */

 Make sure the thread is ready after the last test. */

 Data */

 Arm the thread. */

 Go! */

		/*

		 * On success, modify_ldt will segfault us synchronously,

		 * and we'll escape via siglongjmp.

 Kill the thread. */

	/*

	 * Older kernel versions did inherit the LDT on exec() which is

	 * wrong because exec() starts from a clean state.

 Code, not conforming */

 exec failed */

 Data, grow-up*/

 64-bit only system -- we can't use set_thread_area */

 Test DS */

 Should invalidate ds */

 Test ES */

 Should invalidate es */

 Test FS */

 Should invalidate fs */

 Restore FS/BASE for glibc */

 Test GS */

 Should invalidate gs */

 Restore GS/BASE for glibc */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Trivial program to check that we have a valid 64-bit build environment.

 * Copyright (c) 2015 Andy Lutomirski

 SPDX-License-Identifier: GPL-2.0-only

/*

 * check_initial_reg_state.c - check that execve sets the correct state

 * Copyright (c) 2014-2016 Andrew Lutomirski

 SPDX-License-Identifier: GPL-2.0

 Test truncation to zero (round-to-nearest would give 1 here) */

	/* SIGILL triggers on 32-bit kernels w/o fisttp emulation

	 * when run with "no387 nofxsr". Other signals are caught

	 * just in case.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * vdso_restorer.c - tests vDSO-based signal restore

 * Copyright (c) 2015 Andrew Lutomirski

 *

 * This makes sure that sa_restorer == NULL keeps working on 32-bit

 * configurations.  Modern glibc doesn't use it under any circumstances,

 * so it's easy to overlook breakage.

 *

 * 64-bit userspace has never supported sa_restorer == NULL, so this is

 * 32-bit only.

 Open-code this -- the headers are too messy to easily use them. */

 request kernel-provided restorer */

 SPDX-License-Identifier: GPL-2.0

	/* SIGILL triggers on 32-bit kernels w/o fcomi emulation

	 * when run with "no387 nofxsr". Other signals are caught

	 * just in case.

 If fcmovCC() returns 1.0, the move wasn't done */

 SPDX-License-Identifier: GPL-2.0

 Bitness-agnostic defines for user_regs_struct fields. */

/*

 * Helper to invoke int80 with controlled regs and capture the final regs.

/*

 * Nasty helper to invoke AT_SYSINFO (i.e. __kernel_vsyscall) with

 * controlled regs and capture the final regs.  This is so nasty that it

 * crashes my copy of gdb :)

 gettid */

 kill */

 Wait for SIGSTOP. */

	/*

	 * This does exactly what it appears to do if syscall is int80 or

	 * SYSCALL64.  For SYSCALL32 or SYSENTER, though, this is highly

	 * magical.  It needs to work so that ptrace and syscall restart

	 * work as expected.

 Wait for SIGSTOP. */

 We should be stopped at pause(2) entry. */

 Interrupt it. */

 Advance.  We should be stopped at exit. */

 Poke the regs back in.  This must not break anything. */

 Catch the (ignored) SIGUSR1. */

 The next event should be pause(2) again. */

 We should be stopped at pause(2) entry. */

 Kill it. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * sigreturn.c - tests that x86 avoids Intel SYSRET pitfalls

 * Copyright (c) 2014-2016 Andrew Lutomirski

 State used by our signal handlers. */

 Set IP and CX to match so that SYSRET can happen. */

 R11 and EFLAGS should already match. */

	/*

	 * When the kernel returns from a slow-path syscall, it will

	 * detect whether SYSRET is appropriate.  If it incorrectly

	 * thinks that SYSRET is appropriate when RIP is noncanonical,

	 * it'll crash on Intel CPUs.

 One extra test to check that we didn't screw up the mremap logic. */

 These are the interesting cases. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * sysret_ss_attrs.c - test that syscalls return valid hidden SS attributes

 * Copyright (c) 2015 Andrew Lutomirski

 *

 * On AMD CPUs, SYSRET can return with a valid SS descriptor with with

 * the hidden attributes set to an unusable state.  Make sure the kernel

 * doesn't let this happen.

	/*

	 * Do our best to cause sleeps on this CPU to exit the kernel and

	 * re-enter with SS = 0.

	/*

	 * Start a busy-looping thread on the same CPU we're on.

	 * For simplicity, just stick everything to CPU 0.  This will

	 * fail in some containers, but that's probably okay.

		/*

		 * Go to sleep and return using sysret (if we're 64-bit

		 * or we're 32-bit on AMD on a 64-bit kernel).  On AMD CPUs,

		 * SYSRET doesn't fix up the cached SS descriptor, so the

		 * kernel needs some kind of workaround to make sure that we

		 * end the system call with a valid stack segment.  This

		 * can be a confusing failure because the SS *selector*

		 * is the same regardless.

		/*

		 * On 32-bit, just doing a syscall through glibc is enough

		 * to cause a crash if our cached SS descriptor is invalid.

		 * On 64-bit, it's not, so try extra hard.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * 32-bit syscall ABI conformance test.

 *

 * Copyright (c) 2015 Denys Vlasenko

/*

 * Can be built statically:

 * gcc -Os -Wall -static -m32 test_syscall_vdso.c thunks_32.S

 register did not change */

			/*

			 * Non-INT80 syscall entrypoints are allowed to clobber R8+ regs:

			 * either clear them to 0, or for R11, load EFLAGS.

			/*

			 * INT80 syscall entrypoint can be used by

			 * 64-bit programs too, unlike SYSCALL/SYSENTER.

			 * Therefore it must preserve R12+

			 * (they are callee-saved registers in 64-bit C ABI).

			 *

			 * Starting in Linux 4.17 (and any kernel that

			 * backports the change), R8..11 are preserved.

			 * Historically (and probably unintentionally), they

			 * were clobbered or zeroed.

 bytes */

 Carry Flag */

 Bit 1 - always on */

 Parity Flag */

 Auxiliary carry Flag */

 Zero Flag */

 Sign Flag */

 Trap Flag */

 Interrupt Flag */

 Direction Flag */

 Overflow Flag */

 I/O Privilege Level (2 bits) */

 I/O Privilege Level (2 bits) */

 Nested Task */

 Resume Flag */

 Virtual Mode */

 Alignment Check/Access Control */

 Virtual Interrupt Flag */

 Virtual Interrupt Pending */

 CPUID detection */

print_regs64();*/

 Try 6-arg syscall: pselect. It should return quickly */

 PSELECT */

 ebx  arg1 */

 ecx  arg2 */

 edx  arg3 */

 esi  arg4 */

 edi  arg5 */

 %ebp arg6 */

 set almost all flags */

 except TF, IOPL, NT, RF, VM, AC, VIF, VIP */

 Check that registers are not clobbered */

 ebx  arg1 */

 ecx  arg2 */

 edx  arg3 */

 esi  arg4 */

 edi  arg5 */

 %ebp arg6 */

print_regs64();*/

	/*

	 * On paravirt kernels, flags are not preserved across syscalls.

	 * Thus, we do not consider it a bug if some are changed.

	 * We just show ones which do.

 child */

 parent */

 paranoia */

		/*

		 * Note: we do not inject sig = WSTOPSIG(status).

		 * We probably should, but careful: do not inject SIGTRAP

		 * generated by syscall entry/exit stops.

		 * That kills the child.

sig*/);

	/* This only works for non-static builds:

	 * syscall_addr = dlsym(dlopen("linux-gate.so.1", RTLD_NOW), "__kernel_vsyscall");

 SPDX-License-Identifier: GPL-2.0-only

/*

 * unwind_vdso.c - tests unwind info for AT_SYSINFO in the vDSO

 * Copyright (c) 2014-2015 Andrew Lutomirski

 *

 * This tests __kernel_vsyscall's unwind info.

 We need getauxval(). */

 trap source */

 -1 until we hit the trap source */

 Not there yet */

 Here we are. */

 Find the return address. */

 Not there yet */

 Force symbol binding without TF set. */

		/*

		 * The most likely cause of this is that you're on Debian or

		 * a Debian-based distro, you're missing libc6-i686, and you're

		 * affected by libc/19006 (https://sourceware.org/PR19006).

 New enough libc */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * 32-bit test to check vDSO mremap.

 *

 * Copyright (c) 2016 Dmitry Safonov

 * Suggested-by: Andrew Lutomirski

/*

 * Can be built statically:

 * gcc -Os -Wall -static -m32 test_mremap_vdso.c

 Searching for memory location where to remap */

 Retry with larger */

 Simpler than parsing ELF header */

 Glibc is likely to explode now - exit with raw syscall */

 __x86_64__ */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Trivial program to check that we have a valid 32-bit build environment.

 * Copyright (c) 2015 Andy Lutomirski

 SPDX-License-Identifier: GPL-2.0

/*

 * ioperm.c - Test case for ioperm(2)

 * Copyright (c) 2015 Andrew Lutomirski

	/*

	 * Probe for ioperm support.  Note that clearing ioperm bits

	 * works even as nonroot.

 Make sure that fork() preserves ioperm. */

 Verify that the child dropping 0x80 did not affect the parent */

 Test the capability checks. */

 SPDX-License-Identifier: GPL-2.0

 err() exits and will not return */

	/*

	 * CPUID.1:ECX.XSAVE[bit 26] enumerates general

	 * support for the XSAVE feature set, including

	 * XGETBV.

	/*

	 * EBX enumerates the size (in bytes) required by the XSAVE

	 * instruction for an XSAVE area containing all the user state

	 * components corresponding to bits currently set in XCR0.

	 *

	 * Stash that off so it can be used to allocate buffers later.

	/*

	 * eax: XTILEDATA state component size

	 * ebx: XTILEDATA state component offset in user buffer

 The helpers for managing XSAVE buffer and tile states: */

 XSAVE buffer should be 64B-aligned. */

 XSTATE_BV is at the beginning of the header: */

 XSTATE_BV is at the beginning of the header: */

	/*

	 * Ensure that 'data' is never 0.  This ensures that

	 * the registers are never in their initial configuration

	 * and thus never tracked as being in the init state.

 See 'struct _fpx_sw_bytes' at sigcontext.h */

 N.B. The struct's field name varies so read from the offset. */

 Work around printf() being unsafe in signals: */

/*

 * Signal handler for when AMX is used but

 * permission has not been obtained.

 Reset the signal message buffer: */

	/*

	 * Without permission, the signal XSAVE buffer should not

	 * have room for AMX register state (aka. xtiledata).

	 * Check that the size does not overlap with where xtiledata

	 * will reside.

	 *

	 * This also implies that no state components *PAST*

	 * XTILEDATA (features >=19) can be present in the buffer.

	/*

	 * Without permission, the XTILEDATA feature

	 * bit should not be set.

 Skip the faulting XRSTOR */

 Return true if XRSTOR is successful; otherwise, false. */

 Print any messages produced by the signal code: */

	/*

	 * Reset the buffer to make sure any future printing

	 * only outputs new messages:

/*

 * Use XRSTOR to populate the XTILEDATA registers with

 * random data.

 *

 * Return true if successful; otherwise, false.

 Return XTILEDATA to its initial configuration. */

 arch_prctl() and sigaltstack() test */

	/*

	 * getauxval() itself can return 0 for failure or

	 * success.  But, in this case, AT_MINSIGSTKSZ

	 * will always return a >=0 value if implemented.

	 * Just check for 0.

	/*

	 * Try setup_altstack() with a size which can not fit

	 * XTILEDATA.  ARCH_REQ_XCOMP_PERM should fail.

	/*

	 * Try setup_altstack() with a size derived from

	 * AT_MINSIGSTKSZ.  It should be more than large enough

	 * and thus ARCH_REQ_XCOMP_PERM should succeed.

	/*

	 * Try to coerce setup_altstack() to again accept a

	 * too-small altstack.  This ensures that big-enough

	 * sigaltstacks can not shrink to a too-small value

	 * once XTILEDATA permission is established.

 fork() failed */

 fork() succeeded.  Now in the parent. */

 fork() succeeded.  Now in the child . */

	/*

	 * The permission request should fail without an

	 * XTILEDATA-compatible signal stack

	/*

	 * Set up an XTILEDATA-compatible signal stack and

	 * also obtain permission to populate XTILEDATA.

 Ensure that XTILEDATA can be populated. */

 fork() failed */

 fork() succeeded.  Now in the (grand)child. */

		/*

		 * Ensure that the grandchild inherited

		 * permission and a compatible sigaltstack:

 fork() succeeded.  Now in the parent. */

/*

 * Save current register state and compare it to @xbuf1.'

 *

 * Returns false if @xbuf1 matches the registers.

 * Returns true  if @xbuf1 differs from the registers.

 tiledata inheritance test */

 fork() failed */

 fork() succeeded.  Now in the parent. */

 fork() succeeded.  Now in the child. */

 fork() failed */

 fork() succeeded.  Still in the first child. */

 fork() succeeded.  Now in the (grand)child. */

	/*

	 * TILEDATA registers are not preserved across fork().

	 * Ensure that their value has changed:

 Context switching test */

	/*

	 * Load random data into 'xbuf' and then restore

	 * it to the tile registers themselves.

		/*

		 * Ensure the register values have not

		 * diverged from those recorded in 'xbuf'.

 Load new, random values into xbuf and registers */

		/*

		 * The last thread's last unlock will be for

		 * thread 0's mutex.  However, thread 0 will

		 * have already exited the loop and the mutex

		 * will already be unlocked.

		 *

		 * Because this is not an ERRORCHECK mutex,

		 * that inconsistency will be silently ignored.

	/*

	 * Return this thread's finfo, which is

	 * a unique value for this thread.

		/*

		 * Thread 'i' will wait on this mutex to

		 * be unlocked.  Lock it immediately after

		 * initialization:

 Affinitize to one CPU to force context switches */

	/*

	 * This thread wakes up thread 0

	 * Thread 0 will wake up 1

	 * Thread 1 will wake up 2

	 * ...

	 * the last thread will wake up 0

	 *

	 * ... this will repeat for the configured

	 * number of iterations.

 Wait for all the threads to finish: */

 Check hardware availability at first */

 Request permission for the following tests */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * fsgsbase_restore.c, test ptrace vs fsgsbase

 * Copyright (c) 2020 Andy Lutomirski

 *

 * This test case simulates a tracer redirecting tracee execution to

 * a function and then restoring tracee state using PTRACE_GETREGS and

 * PTRACE_SETREGS.  This is similar to what gdb does when doing

 * 'p func()'.  The catch is that this test has the called function

 * modify a segment register.  This makes sure that ptrace correctly

 * restores segment state when using PTRACE_SETREGS.

 *

 * This is not part of fsgsbase.c, because that test is 64-bit only.

 Data, grow-up */

 No modify_ldt for us (configured out, perhaps) */

 32-bit set_thread_area */

	/*

	 * The tracer will redirect execution here.  This is meant to

	 * work like gdb's 'p func()' feature.  The tricky bit is that

	 * we modify a segment register in order to make sure that ptrace

	 * can correctly restore segment registers.

	/*

	 * Write a nonzero selector with base zero to the segment register.

	 * Using a null selector would defeat the test on AMD pre-Zen2

	 * CPUs, as such CPUs don't clear the base when loading a null

	 * selector.

 Should not get here. */

 Wait for SIGSTOP. */

 Don't clobber the redzone. */

 Wait for SIGSTOP. */

 Wait for SIGSTOP. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * single_step_syscall.c - single-steps various x86 syscalls

 * Copyright (c) 2014-2015 Andrew Lutomirski

 *

 * This is a very simple series of tests that makes system calls with

 * the TF flag set.  This exercises some nasty kernel code in the

 * SYSENTER case: SYSENTER does not clear TF, so SYSENTER with TF set

 * immediately issues #DB from CPL 0.  This requires special handling in

 * the kernel.

 Force a syscall */

	/*

	 * This test is particularly interesting if fast syscalls use

	 * SYSENTER: it triggers a nasty design flaw in SYSENTER.

	 * Specifically, SYSENTER does not clear TF, so either SYSENTER

	 * or the next instruction traps at CPL0.  (Of course, Intel

	 * mostly forgot to document exactly what happens here.)  So we

	 * get a CPL0 fault with usergs (on 64-bit kernels) and possibly

	 * no stack.  The only sane way the kernel can possibly handle

	 * it is to clear TF on return from the #DB handler, but this

	 * happens way too early to set TF in the saved pt_regs, so the

	 * kernel has to do something clever to avoid losing track of

	 * the TF bit.

	 *

	 * Needless to say, we've had bugs in this area.

 Force symbol binding without TF set. */

 Now make sure that another fast syscall doesn't set TF again. */

	/*

	 * And do a forced SYSENTER to make sure that this works even if

	 * fast syscalls don't use SYSENTER.

	 *

	 * Invoking SYSENTER directly breaks all the rules.  Just handle

	 * the SIGSEGV.

 Clear EBP first to make sure we segfault cleanly. */

 We're unreachable here.  SYSENTER forgets RIP. */

 Now make sure that another fast syscall doesn't set TF again. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Corrupt the XSTATE header in a signal frame

 *

 * Based on analysis and a test case from Thomas Gleixner.

 Is CR4.OSXSAVE enabled ? */

 Wreck the first reserved bytes in the header */

	/*

	 * Enforce that the child runs on the same CPU

	 * which in turn forces a schedule.

	/*

	 * We could try to confirm that extended state is still preserved

	 * when we schedule.  For now, the only indication of failure is

	 * a warning in the kernel logs.

 SPDX-License-Identifier: GPL-2.0 */

 max length of lines in /proc/self/maps - anything longer is skipped here */

 vsyscalls and vDSO */

 getcpu() was never wired up in the 32-bit vDSO. */

 sscanf() is safe here as strlen(name) >= strlen(line) */

 syscalls */

 We already tested this adequately. */

 INSTR */

/*

 * Debuggers expect ptrace() to be able to peek at the vsyscall page.

 * Use process_vm_readv() as a proxy for ptrace() to test this.  We

 * want it to work in the vsyscall=emulate case and to fail in the

 * vsyscall=xonly case.

 *

 * It's worth noting that this ABI is a bit nutty.  write(2) can't

 * read from the vsyscall page on any kernel version or mode.  The

 * fact that ptrace() ever worked was a nice courtesy of old kernels,

 * but the code to support it is fairly gross.

		/*

		 * We expect process_vm_readv() to work if and only if the

		 * vsyscall page is readable.

	/*

	 * If vsyscalls are emulated, we expect a single trap in the

	 * vsyscall page -- the call instruction will trap with RIP

	 * pointing to the entry point before emulation takes over.

	 * In native mode, we expect two traps, since whatever code

	 * the vsyscall page contains will be more than just a ret

	 * instruction.

 SPDX-License-Identifier: GPL-2.0-only

 sigaltstack()-enforced minimum stack */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * fsgsbase.c, an fsgsbase test

 * Copyright (c) 2014-2016 Andy Lutomirski

 Crash cleanly. */

 Skip the faulting mov */

	/*

	 * Unless we have FSGSBASE, there's no direct way to do this from

	 * user mode.  We can get at it indirectly using signals, though.

 Use a constant-length instruction here. */

	/*

	 * If that didn't segfault, try the other end of the address space.

	 * Unless we get really unlucky and run into the vsyscall page, this

	 * is guaranteed to segfault.

/*

 * ARCH_SET_FS/GS(0) may or may not program a selector of zero.  HARD_ZERO

 * means to force the selector to zero to improve test coverage.

	/*

	 * Sets GS != 0 and GSBASE != 0 but arranges for the kernel to think

	 * that GSBASE == 0 (i.e. thread.gsbase == 0).

 Step 1: tell the kernel that we have GSBASE == 0. */

 Step 2: change GSBASE without telling the kernel. */

 Data, grow-up */

 No modify_ldt for us (configured out, perhaps) */

 32-bit set_thread_area */

			/*

			 * On AMD chips, this causes GSBASE != 0, GS == 0, and

			 * thread.gsbase == 0.

		/*

		 * Signal delivery is quite likely to change a selector

		 * of 1, 2, or 3 back to 0 due to IRET being defective.

		/*

		 * IRET is misdesigned and will squash selectors 1, 2, or 3

		 * to zero.  Don't fail the test just because this happened.

 Read the initial base.  It should be 1. */

 Poke an LDT selector into GS. */

 And read the base. */

		/*

		 * In a non-FSGSBASE system, the nonzero selector will load

		 * GSBASE (again). But what is tested here is whether the

		 * selector value is changed or not by the GSBASE write in

		 * a ptracer.

			/*

			 * On older kernels, poking a nonzero value into the

			 * base would zero the selector.  On newer kernels,

			 * this behavior has changed -- poking the base

			 * changes only the base and, if FSGSBASE is not

			 * available, this may have no effect once the tracee

			 * is resumed.

 Do these tests before we have an LDT. */

 Probe FSGSBASE */

 Set up for multithreading. */

 should never fail */

 Kill the thread. */

 SPDX-License-Identifier: GPL-2.0

 sNaN is s|111 1111 1|1xx xxxx xxxx xxxx xxxx xxxx */

 qNaN is s|111 1111 1|0xx xxxx xxxx xxxx xxxx xxxx (some x must be nonzero) */

 sNaN80 is s|111 1111 1111 1111 |10xx xx...xx (some x must be nonzero) */

 fld of a qnan raised FE_INVALID, clear it

 fld of a qnan raised FE_INVALID, clear it

	"	flds	snan""\n"	
	"	fstpt	snan1""\n"	
	"	fnclex""\n"		
 fldt never raise FE_INVALID

	printf("snan:%x snan1:%04x %04x %04x %04x %04x\n", snan, snan1[4], snan1[3], snan1[2], snan1[1], snan1[0]);

 fld of a qnan raised FE_INVALID, clear it

 fld of a qnan raised FE_INVALID, clear it

	/* SIGILL triggers on 32-bit kernels w/o fcomi emulation

	 * when run with "no387 nofxsr". Other signals are caught

	 * just in case.

 SPDX-License-Identifier: GPL-2.0 */

/*

 * syscall_numbering.c - test calling the x86-64 kernel with various

 * valid and invalid system call numbers.

 *

 * Copyright (c) 2018 Andrew Lutomirski

 Common system call numbers */

 x64-only system call numbers */

 x32-only system call numbers (without X32_BIT) */

 File descriptor for /dev/null */

 x32 supported on this kernel? */

/*

 * Shared memory block between tracer and test

 Total error count */

 Message indentation level */

 In probe_syscall() */

 Sentinel for ptrace-modified return value */

/*

 * Directly invokes the given syscall with nullfd as the first argument

 * and the rest zero. Avoids involving glibc wrappers in case they ever

 * end up intercepting some system calls for some reason, or modify

 * the system call number itself.

	/*

	 * We pass in an extra copy of the extended system call number

	 * in %rbx, so we can examine it from the ptrace handler without

	 * worrying about it being possibly modified. This is to test

	 * the validity of struct user regs.orig_rax a.k.a.

	 * struct pt_regs.orig_ax.

	/*

	 * Improve readability by stripping the x32 bit, but round

	 * toward zero so we don't display -1 as -1073741825.

/*

 * Anyone diagnosing a failure will want to know whether the kernel

 * supports x32. Tell them. This can also be used to conditionalize

 * tests based on existence or nonexistence of x32.

	/*

	 * Syscalls 512-547 are "x32" syscalls.  They are

	 * intended to be called with the x32 (0x40000000) bit

	 * set.  Calling them without the x32 bit set is

	 * nonsense and should not work.

	/*

	 * The MSB is supposed to be ignored, so we loop over a few

	 * to test that out.

 Do this on entry only */

 For these, don't even getregs */

 Just read, no writeback */

 Write back the same register state verbatim */

 Thread exited? */

 Wait for the child process to terminate */

 wait some more */;

 Launch the test thread; this thread continues as the tracer thread */

	/*

	 * It is quite likely to get a segfault on a failure, so make

	 * sure the message gets out by setting stdout to nonbuffered.

	/*

	 * Harmless file descriptor to work on...

	/*

	 * Set up a block of shared memory...

 SPDX-License-Identifier: GPL-2.0-only

/*

 * syscall_nt.c - checks syscalls with NT set

 * Copyright (c) 2014-2015 Andrew Lutomirski

 *

 * Some obscure user-space code requires the ability to make system calls

 * with FLAGS.NT set.  Make sure it works.

	/*

	 * Now try it again with TF set -- TF forces returns via IRET in all

	 * cases except non-ptregs-using 64-bit full fast path syscalls.

	/*

	 * Now try DF.  This is evil and it's plausible that we will crash

	 * glibc, but glibc would have to do something rather surprising

	 * for this to happen.

 SPDX-License-Identifier: LGPL-2.1

 A simple percpu spinlock.  Returns the cpu lock was acquired on. */

 Retry if comparison fails or rseq aborts. */

	/*

	 * Acquire semantic when taking lock after control dependency.

	 * Matches rseq_smp_store_release().

	/*

	 * Release lock, with release semantic. Matches

	 * rseq_smp_acquire__after_ctrl_dep().

/*

 * A simple test which implements a sharded counter using a per-cpu

 * lock.  Obviously real applications might prefer to simply use a

 * per-cpu increment; however, this is reasonable for a test and the

 * lock can be extended to synchronize more complicated operations.

 Load list->c[cpu].head with single-copy atomicity. */

 Retry if comparison fails or rseq aborts. */

/*

 * Unlike a traditional lock-less linked list; the availability of a

 * rseq primitive allows us to implement pop without concerns over

 * ABA-type races.

 Retry if rseq aborts. */

/*

 * __percpu_list_pop is not safe against concurrent accesses. Should

 * only be used on lists that are not concurrently modified.

 encourage shuffling */

 Simultaneous modification to a per-cpu linked list from many threads.  */

 Generate list entries for every usable cpu. */

	/*

	 * All entries should now be accounted for (unless some external

	 * actor is interfering with our allowed affinity while this

	 * test is running).

 SPDX-License-Identifier: LGPL-2.1

/*

 * rseq.c

 *

 * Copyright (C) 2016 Mathieu Desnoyers <mathieu.desnoyers@efficios.com>

 *

 * This library is free software; you can redistribute it and/or

 * modify it under the terms of the GNU Lesser General Public

 * License as published by the Free Software Foundation; only

 * version 2.1 of the License.

 *

 * This library is distributed in the hope that it will be useful,

 * but WITHOUT ANY WARRANTY; without even the implied warranty of

 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU

 * Lesser General Public License for more details.

/*

 * Shared with other libraries. This library may take rseq ownership if it is

 * still 0 when executing the library constructor. Set to 1 by library

 * constructor when handling rseq. Set to 0 in destructor if handling rseq.

 Whether this library have ownership of rseq registration. */

 Check whether rseq is handled by another library. */

 SPDX-License-Identifier: LGPL-2.1

/*

 * Basic test coverage for critical regions and rseq_current_cpu().

 SPDX-License-Identifier: LGPL-2.1

 BENCHMARK */

 A simple percpu spinlock. Grabs lock on current cpu. */

 Retry if comparison fails or rseq aborts. */

	/*

	 * Acquire semantic when taking lock after control dependency.

	 * Matches rseq_smp_store_release().

	/*

	 * Release lock, with release semantic. Matches

	 * rseq_smp_acquire__after_ctrl_dep().

/*

 * A simple test which implements a sharded counter using a per-cpu

 * lock.  Obviously real applications might prefer to simply use a

 * per-cpu increment; however, this is reasonable for a test and the

 * lock can be extended to synchronize more complicated operations.

 Load list->c[cpu].head with single-copy atomicity. */

 Retry if comparison fails or rseq aborts. */

/*

 * Unlike a traditional lock-less linked list; the availability of a

 * rseq primitive allows us to implement pop without concerns over

 * ABA-type races.

 Retry if rseq aborts. */

/*

 * __percpu_list_pop is not safe against concurrent accesses. Should

 * only be used on lists that are not concurrently modified.

 encourage shuffling */

 Simultaneous modification to a per-cpu linked list from many threads.  */

 Generate list entries for every usable cpu. */

	/*

	 * All entries should now be accounted for (unless some external

	 * actor is interfering with our allowed affinity while this

	 * test is running).

 Retry if comparison fails or rseq aborts. */

 Load offset with single-copy atomicity. */

 Retry if comparison fails or rseq aborts. */

/*

 * __percpu_buffer_pop is not safe against concurrent accesses. Should

 * only be used on buffers that are not concurrently modified.

 encourage shuffling */

 Should increase buffer size. */

 Simultaneous modification to a per-cpu buffer from many threads.  */

 Generate list entries for every usable cpu. */

 Worse-case is every item in same CPU. */

			/*

			 * We could theoretically put the word-sized

			 * "data" directly in the buffer. However, we

			 * want to model objects that would not fit

			 * within a single word, so allocate an object

			 * for each node.

	/*

	 * All entries should now be accounted for (unless some external

	 * actor is interfering with our allowed affinity while this

	 * test is running).

 Load offset with single-copy atomicity. */

 copylen must be <= 4kB. */

 Retry if comparison fails or rseq aborts. */

 Load offset with single-copy atomicity. */

 copylen must be <= 4kB. */

 Retry if comparison fails or rseq aborts. */

/*

 * __percpu_memcpy_buffer_pop is not safe against concurrent accesses. Should

 * only be used on buffers that are not concurrently modified.

 encourage shuffling */

 Should increase buffer size. */

 Simultaneous modification to a per-cpu buffer from many threads.  */

 Generate list entries for every usable cpu. */

 Worse-case is every item in same CPU. */

			/*

			 * We could theoretically put the word-sized

			 * "data" directly in the buffer. However, we

			 * want to model objects that would not fit

			 * within a single word, so allocate an object

			 * for each node.

	/*

	 * All entries should now be accounted for (unless some external

	 * actor is interfering with our allowed affinity while this

	 * test is running).

 Test MEMBARRIER_CMD_PRIVATE_RESTART_RSEQ_ON_CPU membarrier command. */

 Worker threads modify data in their "active" percpu lists. */

 Wait for initialization. */

/*

 * The manager thread swaps per-cpu lists that worker threads see,

 * and validates that there are no unexpected modifications.

 Init lists. */

 list_a is "active". */

		/*

		 * As list_b is "inactive", we should never see changes

		 * to list_b.

 Make list_b "active". */

 missing CPU */) {

		/*

		 * Cpu A should now only modify list_b, so the values

		 * in list_a should be stable.

		/*

		 * As list_a is "inactive", we should never see changes

		 * to list_a.

 Make list_a "active". */

 missing CPU*/) {

 Remember a value from list_b. */

 RSEQ_ARCH_HAS_OFFSET_DEREF_ADDV */

/* SPDX-License-Identifier: GPL-2.0

 * Copyright (c) 2018 Davide Caratti, Red Hat inc.

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of version 2 of the GNU General Public

 * License as published by the Free Software Foundation.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2014 Sony Mobile Communications Inc.

 *

 * Selftest for runtime system size

 *

 * Prints the amount of RAM that the currently running system is using.

 *

 * This program tries to be as small as possible itself, to

 * avoid perturbing the system memory utilization with its

 * own execution.  It also attempts to have as few dependencies

 * on kernel features as possible.

 *

 * It should be statically linked, with startup libs avoided.  It uses

 * no library calls except the syscall() function for the following 3

 * syscalls:

 *   sysinfo(), write(), and _exit()

 *

 * For output, it avoids printf (which in some C libraries

 * has large external dependencies) by  implementing it's own

 * number output and print routines, and using __builtin_strlen()

 *

 * The test may crash if any of the above syscalls fails because in some

 * libc implementations (e.g. the GNU C Library) errno is saved in

 * thread-local storage, which does not get initialized due to avoiding

 * startup libs.

 put digits in buffer from back to front */

 this program has no main(), as startup libraries are not used */

 ignore cache complexities for now */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Use the core scheduling prctl() to test core scheduling cookies control.

 *

 * Copyright (c) 2021 Oracle and/or its affiliates.

 * Author: Chris Hyser <chris.hyser@oracle.com>

 *

 *

 * This library is free software; you can redistribute it and/or modify it

 * under the terms of version 2.1 of the GNU Lesser General Public License as

 * published by the Free Software Foundation.

 *

 * This library is distributed in the hope that it will be useful, but WITHOUT

 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or

 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License

 * for more details.

 *

 * You should have received a copy of the GNU Lesser General Public License

 * along with this library; if not, see <http://www.gnu.org/licenses>.

 create unique core_sched cookie */

 push core_sched cookie to pid */

 pull core_sched cookie to pid */

 put into separate process group */

 get a random process pid */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0-or-later

 SPDX-License-Identifier: GPL-2.0

 Send some data through with ULP but no keys */

 MSG_PEEK can only peek into the current record. */

	/* Non-MSG_PEEK will advance strparser (and therefore record)

	 * however.

	/* MSG_MORE will hold current record open, so later MSG_PEEK

	 * will see everything.

 Test timing out */

 Set timeout to inf. secs */

 Send 20 bytes */

 Poll with inf. timeout */

 Now the remaining 5 bytes of record data are in TLS ULP */

 parent */

 child */

	/* Ensure nonblocking behavior by imposing a small send

	 * buffer.

 parent */

 child */

 Only allow multiples for simplicity */

 prep a file to send */

 spawn children */

 parent waits for all children */

 Split threads for reading and writing */

 test sending non-record types. */

 Should fail because we didn't provide a control message */

 Recv the message again without MSG_PEEK */

 TLS ULP not supported */

 SPDX-License-Identifier: GPL-2.0

/*

 * Test key rotation for TFO.

 * New keys are 'rotated' in two steps:

 * 1) Add new key as the 'backup' key 'behind' the primary key

 * 2) Make new key the primary by swapping the backup and primary keys

 *

 * The rotation is done in stages using multiple sockets bound

 * to the same port via SO_REUSEPORT. This simulates key rotation

 * behind say a load balancer. We verify that across the rotation

 * there are no cases in which a cookie is not accepted by verifying

 * that TcpExtTCPFastOpenPassiveFail remains 0.

		/* clang does not recognize error() above as terminating

		 * the program, so it complains that saddr, sz are

		 * not initialized when this code path is taken. Silence it.

		/* clang does not recognize error() above as terminating

		 * the program, so it complains that saddr, daddr, sz are

		 * not initialized when this code path is taken. Silence it.

 first set new key as backups */

 swap the keys */

 SPDX-License-Identifier: GPL-2.0

 no events and more time to wait, do poll again */

 Flush all outstanding bytes for the tcp receive queue */

 MSG_TRUNC flushes up to len bytes */

 client detached */

 verify contents */

 Flush all outstanding datagrams. Verify first few bytes of each. */

 MSG_TRUNC will make return value full datagram length */

/*

 * Test for the regression introduced by

 *

 * b9470c27607b ("inet: kill smallest_size and smallest_port")

 *

 * If we open an ipv4 socket on a port with reuseaddr we shouldn't reset the tb

 * when we open the ipv6 conterpart, which is what was happening previously.

 SPDX-License-Identifier: GPL-2.0

/*

 * ipsec.c - Check xfrm on veth inside a net-ns.

 * Copyright (c) 2018 Dmitry Safonov

 xxx.xxx.xxx.xxx is longest + \0 */

 /16 mask divided by /30 subnets */

 10.0.0.0 */

 192.168.0.0 */

 /30 mask for one veth connection */

/*

 * ksft_cnt is static in kselftest, so isn't shared with children.

 * We have to send a test result back to parent and count there.

 * results_fd is a pipe with test feedback from children.

/*

 * Running the test inside a new parent net namespace to bother less

 * about cleanup on error-path.

 NLMSG_ALIGNTO == RTA_ALIGNTO, nlmsg_len already aligned */

 unsigned key_len; */

 Make sure that write/read is atomic to a pipe */

 EOF */

 EOF */

 The other end sends ip to ping */

 TODO: use set/map instead */

 Verify desc */

 Fill selector. */

 Fill id */

 Note: zero-spi cannot be deleted */

 Fill lifteme_cfg */

 XXX: check xfrm algo, see xfrm_state_pack_algo(). */

	/*

	 * Add dump filter by source address as there may be other tunnels

	 * in this netns (if tests run in parallel).

 0xffffffff mask see addr_match() */

 Check dumps for XFRM_MSG_GETSA */

 Fill selector. */

 Fill lifteme_cfg */

 Fill tmpl */

 Note: zero-spi cannot be deleted */

 Fill id */

 Note: zero-spi cannot be deleted */

 Fill selector. */

 Restore the default */

	/*

	 * At this moment xfrm uses nlmsg_parse_deprecated(), which

	 * implies NL_VALIDATE_LIBERAL - ignoring attributes with

	 * (type > maxtype). nla_parse_depricated_strict() would enforce

	 * it. Or even stricter nla_parse().

	 * Right now it's not expected to fail, but to be ignored.

 UDP pinging without xfrm */

 UDP pinging with xfrm tunnel */

 xfrm delete */

 Check that seq sock is ready, just for sure. */

 EOF */

 UDP pinging without xfrm */

 in parent - selftest */

 child */

 No compression backend realization */

 not implemented */

/*

 * Some structures in xfrm uapi header differ in size between

 * 64-bit and 32-bit ABI:

 *

 *             32-bit UABI               |            64-bit UABI

 *  -------------------------------------|-------------------------------------

 *   sizeof(xfrm_usersa_info)     = 220  |  sizeof(xfrm_usersa_info)     = 224

 *   sizeof(xfrm_userpolicy_info) = 164  |  sizeof(xfrm_userpolicy_info) = 168

 *   sizeof(xfrm_userspi_info)    = 228  |  sizeof(xfrm_userspi_info)    = 232

 *   sizeof(xfrm_user_acquire)    = 276  |  sizeof(xfrm_user_acquire)    = 280

 *   sizeof(xfrm_user_expire)     = 224  |  sizeof(xfrm_user_expire)     = 232

 *   sizeof(xfrm_user_polexpire)  = 168  |  sizeof(xfrm_user_polexpire)  = 176

 *

 * Check the affected by the UABI difference structures.

 * Also, check translation for xfrm_set_spdinfo: it has it's own attributes

 * which needs to be correctly copied, but not translated.

 EOF */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2018 Google Inc.

 * Author: Eric Dumazet (edumazet@google.com)

 *

 * Reference program demonstrating tcp mmap() usage,

 * and SO_RCVLOWAT hints for receiver.

 *

 * Note : NIC with header split is needed to use mmap() on TCP :

 * Each incoming frame must be a multiple of PAGE_SIZE bytes of TCP payload.

 *

 * How to use on loopback interface :

 *

 *  ifconfig lo mtu 61512  # 15*4096 + 40 (ipv6 header) + 32 (TCP with TS option header)

 *  tcp_mmap -s -z &

 *  tcp_mmap -H ::1 -z

 *

 *  Or leave default lo mtu, but use -M option to set TCP_MAXSEG option to (4096 + 12)

 *      (4096 : page size on x86, 12: TCP TS option length)

 *  tcp_mmap -s -z -M $((4096+12)) &

 *  tcp_mmap -H ::1 -z -M $((4096+12))

 *

 * Note: -z option on sender uses MSG_ZEROCOPY, which forces a copy when packets go through loopback interface.

 *       We might use sendfile() instead, but really this test program is about mmap(), for receivers ;)

 *

 * $ ./tcp_mmap -s &                                 # Without mmap()

 * $ for i in {1..4}; do ./tcp_mmap -H ::1 -z ; done

 * received 32768 MB (0 % mmap'ed) in 14.1157 s, 19.4732 Gbit

 *   cpu usage user:0.057 sys:7.815, 240.234 usec per MB, 65531 c-switches

 * received 32768 MB (0 % mmap'ed) in 14.6833 s, 18.7204 Gbit

 *  cpu usage user:0.043 sys:8.103, 248.596 usec per MB, 65524 c-switches

 * received 32768 MB (0 % mmap'ed) in 11.143 s, 24.6682 Gbit

 *   cpu usage user:0.044 sys:6.576, 202.026 usec per MB, 65519 c-switches

 * received 32768 MB (0 % mmap'ed) in 14.9056 s, 18.4413 Gbit

 *   cpu usage user:0.036 sys:8.193, 251.129 usec per MB, 65530 c-switches

 * $ kill %1   # kill tcp_mmap server

 *

 * $ ./tcp_mmap -s -z &                              # With mmap()

 * $ for i in {1..4}; do ./tcp_mmap -H ::1 -z ; done

 * received 32768 MB (99.9939 % mmap'ed) in 6.73792 s, 40.7956 Gbit

 *   cpu usage user:0.045 sys:2.827, 87.6465 usec per MB, 65532 c-switches

 * received 32768 MB (99.9939 % mmap'ed) in 7.26732 s, 37.8238 Gbit

 *   cpu usage user:0.037 sys:3.087, 95.3369 usec per MB, 65532 c-switches

 * received 32768 MB (99.9939 % mmap'ed) in 7.61661 s, 36.0893 Gbit

 *   cpu usage user:0.046 sys:3.559, 110.016 usec per MB, 65529 c-switches

 * received 32768 MB (99.9939 % mmap'ed) in 7.43764 s, 36.9577 Gbit

 *   cpu usage user:0.035 sys:3.467, 106.873 usec per MB, 65530 c-switches

 Default: autotuning.  Can be set with -r <integer> option */

 Default: autotuning.  Can be set with -w <integer> option */

 zero copy option. (MSG_ZEROCOPY for sender, mmap() for receiver */

 hash received data (simple xor) (-h option) */

 -k option: receiver shall keep all received file in memory (no munmap() calls) */

 Attempt to use huge pages if possible. */

				/* It is more efficient to unmap the pages right now,

				 * instead of doing this in next TCP_ZEROCOPY_RECEIVE.

/* Each thread should reserve a big enough vma to avoid

 * spinlock collisions in ptl locks.

 * This size is 2MB on x86_64, and is exported in /proc/meminfo.

 server : listen for incoming connections */

		/* if really /proc/meminfo is not helping,

		 * we use the default x86_64 hugepagesize.

 Note : we just want to fill the pipe with 0 bytes */

 SPDX-License-Identifier: GPL-2.0

 Test IPV6_FLOWINFO cmsg on send and recv */

 uapi/glibc weirdness may leave this undefined */

 do not pass IPV6_ADDR_ANY or IPV6_ADDR_MAPPED */

 SPDX-License-Identifier: GPL-2.0

 test sending up to max mtu + 1 */

 position check field exactly one byte beyond end of packet */

 BPF filter accepts only this length, vlan changes MAC */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2013 Red Hat, Inc.

 * Author: Daniel Borkmann <dborkman@redhat.com>

 *         Chetan Loke <loke.chetan@gmail.com> (TPACKET_V3 usage example)

 *

 * A basic test of packet socket's TPACKET_V1/TPACKET_V2/TPACKET_V3 behavior.

 *

 * Control:

 *   Test the setup of the TPACKET socket with different patterns that are

 *   known to fail (TODO) resp. succeed (OK).

 *

 * Datapath:

 *   Open a pair of packet sockets and send resp. receive an a priori known

 *   packet pattern accross the sockets and check if it was received resp.

 *   sent correctly. Fanout in combination with RX_RING is currently not

 *   tested here.

 *

 *   The test currently runs for

 *   - TPACKET_V1: RX_RING, TX_RING

 *   - TPACKET_V2: RX_RING, TX_RING

 *   - TPACKET_V3: RX_RING

	/* Lets create some broken crap, that still passes

	 * our BPF filter.

	/* TPACKET_V{1,2} sets up the ring->rd* related variables based

	 * on frames (e.g., rd_num is tp_frame_nr) whereas V3 sets these

	 * up based on blocks (e.g, rd_num is  tp_block_nr)

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2018 Google Inc.

 * Author: Soheil Hassas Yeganeh (soheil@google.com)

 *

 * Simple example on how to use TCP_INQ and TCP_CM_INQ.

		/* TCP_INQ can overestimate in-queue by one byte if we send

		 * the FIN packet. Sleep for 1 second, so that the client

		 * likely invoked recvmsg().

 SPDX-License-Identifier: GPL-2.0

 Got a TX timestamp from error queue */

 range of IDs acknowledged */

 cold cache when writing buffer */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Test IPV6_FLOWINFO_MGR */

 uapi/glibc weirdness may leave this undefined */

 from net/ipv6/ip6_flowlabel.c */

 do not pass IPV6_ADDR_ANY or IPV6_ADDR_MAPPED */

 SPDX-License-Identifier: GPL-2.0

/*

 * Test functionality of BPF filters with SO_REUSEPORT. Same test as

 * in reuseport_bpf_cpu, only as one socket per NUMA node.

 R0 = bpf_get_numa_node_id() */

 return R0 */

 Forward iterate */

 Reverse iterate */

 SPDX-License-Identifier: GPL-2.0

/*

 * Test functionality of BPF filters with SO_REUSEPORT.  This program creates

 * an SO_REUSEPORT receiver group containing one socket per CPU core. It then

 * creates a BPF program that will select a socket from this group based

 * on the core id that receives the packet.  The sending code artificially

 * moves itself to run on different core ids and sends one message from

 * each core.  Since these packets are delivered over loopback, they should

 * arrive on the same core that sent them.  The receiving code then ensures

 * that the packet was received on the socket for the corresponding core id.

 * This entire process is done for several different core id permutations

 * and for each IPv4/IPv6 and TCP/UDP combination.

 A = raw_smp_processor_id() */

 return A */

 Forward iterate */

 Reverse iterate */

 Even cores */

 Odd cores */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2014 Google Inc.

 * Author: willemb@google.com (Willem de Bruijn)

 *

 * Test software tx timestamping, including

 *

 * - SCHED, SND and ACK timestamps

 * - RAW, UDP and TCP

 * - IPv4 and IPv6

 * - various packet sizes (to test GSO and TSO)

 *

 * Consult the command line arguments for help on running

 * the various testcases.

 *

 * This test requires a dummy TCP server.

 * A simple `nc6 [-u] -l -p $DESTPORT` will do

 command line parameters */

	/* compare key for each subsequent request

	 * must only test for one type, the first one requested

 TODO: convert to check_and_print payload once API is stable */

 overprovision*/];

 checksum ip(v6) addresses + udp header + payload */

 set for udp csum calc */

 kernel writes saddr, csum, len */

 kernel does not write saddr in case of ipv6 */

 spoof */

		/* special case, only rawv6_sendmsg:

		 * pass proto in sin6_port if not connected

		 * also see ANK comment in net/ipv4/raw.c

 reset expected key on each new socket */

 wait for all errors to be queued, else ACKs arrive OOO */

	/* leave fd open, will be closed on process exit.

	 * this enables connect() to succeed and avoids icmp replies

 SPDX-License-Identifier: GPL-2.0

/* Toeplitz test

 *

 * 1. Read packets and their rx_hash using PF_PACKET/TPACKET_V3

 * 2. Compute the rx_hash in software based on the packet contents

 * 3. Compare the two

 *

 * Optionally, either '-C $rx_irq_cpu_list' or '-r $rps_bitmap' may be given.

 *

 * If '-C $rx_irq_cpu_list' is given, also

 *

 * 4. Identify the cpu on which the packet arrived with PACKET_FANOUT_CPU

 * 5. Compute the rxqueue that RSS would select based on this rx_hash

 * 6. Using the $rx_irq_cpu_list map, identify the arriving cpu based on rxq irq

 * 7. Compare the cpus from 4 and 6

 *

 * Else if '-r $rps_bitmap' is given, also

 *

 * 4. Identify the cpu on which the packet arrived with PACKET_FANOUT_CPU

 * 5. Compute the cpu that RPS should select based on rx_hash and $rps_bitmap

 * 6. Compare the cpus from 4 and 5

 hex encoded: AA:BB:CC:...:ZZ */

 real constraint is PACKET_FANOUT_MAX */

 must be a power of 2 */

 configuration options (cmdline arguments) */

 global vars */

 stats */

 tpacket ring */

 map from rxq to cpu */

 Compare computed cpu with arrival cpu from packet_fanout_cpu */

 Compare computed rxhash with rxhash received from tpacket_v3 */

 A single TPACKET_V3 block can hold multiple frames */

 simple test: sleep once unconditionally and then process all rings */

 filter on transport protocol and destination port */

 same for udp */

 drop everything: used temporarily during setup */

	/* block packets until all rings are added to the fanout group:

	 * else packets can arrive during setup and get misclassified

 must come after bind: verifies all programs in group match */

		/* on failure, retry using old API if that is sufficient:

		 * it has a hard limit of 256 sockets, so only try if

		 * (a) only testing rxhash, not RSS or (b) <= 256 cpus.

		 * in this API, the third argument is left implicit.

 setup inet(6) socket to blackhole the test traffic, if arg '-s' */

 accept packets once all rings in the fanout group are up */

 skip ','

 SPDX-License-Identifier: GPL-2.0

/*

 * This testsuite provides conformance testing for GRO coalescing.

 *

 * Test cases:

 * 1.data

 *  Data packets of the same size and same header setup with correct

 *  sequence numbers coalesce. The one exception being the last data

 *  packet coalesced: it can be smaller than the rest and coalesced

 *  as long as it is in the same flow.

 * 2.ack

 *  Pure ACK does not coalesce.

 * 3.flags

 *  Specific test cases: no packets with PSH, SYN, URG, RST set will

 *  be coalesced.

 * 4.tcp

 *  Packets with incorrect checksum, non-consecutive seqno and

 *  different TCP header options shouldn't coalesce. Nit: given that

 *  some extension headers have paddings, such as timestamp, headers

 *  that are padding differently would not be coalesced.

 * 5.ip:

 *  Packets with different (ECN, TTL, TOS) header, ip options or

 *  ip fragments (ipv6) shouldn't coalesce.

 * 6.large:

 *  Packets larger than GRO_MAX_SIZE packets shouldn't coalesce.

 *

 * MSS is defined as 4096 - header because if it is too small

 * (i.e. 1500 MTU - header), it will result in many packets,

 * increasing the "large" test case's flakiness. This is because

 * due to time sensitivity in the coalescing window, the receiver

 * may not coalesce all of the packets.

 *

 * Note the timing issue applies to all of the test cases, so some

 * flakiness is to be expected.

 *

 DF = 1, MF = 0 */

 send one extra flag, not first and not last pkt */

/* Test for data of same length, smaller than previous

 * and of different lengths

/* If incoming segments make tracked segment length exceed

 * legal IP datagram length, do not coalesce

 Pure acks and dup acks don't coalesce */

/* TCP with options is always a permutation of {TS, NOP, NOP}.

 * Implement different orders to verify coalescing stops.

 two NOP opts */,

 Packets with invalid checksum don't coalesce. */

 Packets with non-consecutive sequence number don't coalesce.*/

 /* Packet with different timestamp option or different timestamps

  * don't coalesce.

 Packet with different tcp options don't coalesce. */

 IPv4 options shouldn't coalesce */

  IPv4 fragments shouldn't coalesce */

	/* Once fragmented, packet would retain the total_len.

	 * Tcp header is prepared as if rest of data is in follow-up frags,

	 * but follow up frags aren't actually sent.

 DF = 1, MF = 1

 IPv4 packets with different ttl don't coalesce.*/

 Packets with different tos don't coalesce.*/

 Packets with different ECN don't coalesce.*/

 ECN set to 10

 ECN set to 10

 IPv6 fragments and packets with extensions don't coalesce.*/

		/* Min ethernet frame payload is 46(ETH_ZLEN - ETH_HLEN) by RFC 802.3.

		 * Ipv4/tcp packets without at least 6 bytes of data will be padded.

		 * Packet sockets are protocol agnostic, and will not trim the padding.

			/* Modified packets may be received out of order.

			 * Sleep function added to enforce test boundaries

			 * so that fin pkts are not received prior to other pkts.

		/* 20 is the difference between min iphdr size

		 * and min ipv6hdr size. Like MAX_HDR_SIZE,

		 * MAX_PAYLOAD is defined with the larger header of the two.

			/* GRO doesn't check for ipv6 hop limit when flushing.

			 * Hence no corresponding test to the ipv4 case.

 last segment sent individually, doesn't start new segment */

 Loopback device does not support hw timestamps. */

 for IPv4 header */

 setsockopt for SO_TIMESTAMPING is asynchronous */

 SPDX-License-Identifier: GPL-2.0

/* Test program for SIOC{G,S}HWTSTAMP

 * Copyright 2013 Solarflare Communications

 * Author: Ben Hutchings

 SPDX-License-Identifier: GPL-2.0+

/*

 * Author: Justin Iurman (justin.iurman@uliege.be)

 *

 * IOAM tester for IPv6, see ioam6.sh for details on each test case.

/*

 * Be careful if you modify structs below - everything MUST be kept synchronized

 * with configurations inside ioam6.sh and always reflect the same.

 default value */

 default value */

 default value */

 default value */

 default value */

	/**********

	 * OUTPUT *

	/*********

	 * INPUT *

	/**********

	 * GLOBAL *

 SPDX-License-Identifier: GPL-2.0

 IPv6 fragment header lenth. */

 Max UDP payload length. */

 IPv4 MF flag. */

 IPv6 MF flag. */

 Receive a UDP packet. Validate it matches udp_payload. */

 OK */

 This is the last fragment. */

 This is the last fragment. */

	/* Send the UDP datagram using raw IP fragments: the 0th fragment

	 * has the UDP header; other fragments are pieces of udp_payload

	 * split in chunks of frag_len size.

	 *

	 * Odd fragments (1st, 3rd, 5th, etc.) are sent out first, then

	 * even fragments (0th, 2nd, etc.) are sent out.

 Version. */

 Occasionally test in-order fragments. */

 Occasionally test IPv4 "runs" (see net/ipv4/ip_fragment.c) */

 Odd fragments. */

 IPv4 ignores duplicates, so randomly send a duplicate. */

		/* Send an extra random fragment.

		 *

		 * Duplicates and some fragments completely inside

		 * previously sent fragments are dropped/ignored. So

		 * random offset and frag_len can result in a dropped

		 * fragment instead of a dropped queue/packet. Thus we

		 * hard-code offset and frag_len.

 not enough payload for random offset and frag_len. */

 sendto() returns EINVAL if offset + frag_len is too small. */

 In IPv6 if !!(frag_len % 8), the fragment is dropped. */

 Event fragments. */

 IPv4 ignores duplicates, so randomly send a duplicate. */

	/* Frag queue timeout is set to one second in the calling script;

	 * socket timeout should be just a bit longer to avoid tests interfering

	 * with each other.

 Initialize the payload. */

 Open sockets. */

 Fail fast. */

			/* With overlaps, one send/receive pair below takes

			 * at least one second (== timeout) to run, so there

			 * is not enough test time to run a nested loop:

			 * the full overlap test takes 20-30 seconds.

			/* Without overlaps, each packet reassembly (== one

			 * send/receive pair below) takes very little time to

			 * run, so we can easily afford more thourough testing

			 * with a nested loop: the full non-overlap test takes

			 * less than one second).

 Cleanup. */

 !ipv6 */);

 ipv6 */);

 Print the seed to track/reproduce potential failures. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Check if we can fully utilize 4-tuples for connect().

 *

 * Rules to bind sockets to the same port when all ephemeral ports are

 * exhausted.

 *

 *   1. if there are TCP_LISTEN sockets on the port, fail to bind.

 *   2. if there are sockets without SO_REUSEADDR, fail to bind.

 *   3. if SO_REUSEADDR is disabled, fail to bind.

 *   4. if SO_REUSEADDR is enabled and SO_REUSEPORT is disabled,

 *        succeed to bind.

 *   5. if SO_REUSEADDR and SO_REUSEPORT are enabled and

 *        there is no socket having the both options and the same EUID,

 *        succeed to bind.

 *   6. fail to bind.

 *

 * Author: Kuniyuki Iwashima <kuniyu@amazon.co.jp>

 SPDX-License-Identifier: GPL-2.0

 dynamically allocate unused port */

 SPDX-License-Identifier: GPL-2.0

/*

 * Verify that consecutive sends over packet tx_ring are mirrored

 * with their original content intact.

 SPDX-License-Identifier: GPL-2.0

/*

 * Test the SO_TXTIME API

 *

 * Takes a stream of { payload, delivery time }[], to be sent across two

 * processes. Start this program on two separate network namespaces or

 * connected hosts, one instance in transmit mode and the other in receive

 * mode using the '-r' option. Receiver will compare arrival timestamps to

 * the expected stream. Sender will read transmit timestamps from the error

 * queue. The streams can differ due to out-of-order delivery and drops.

 encode one timed transmission (of a 1B payload) */

 only pass non-zero on first call */

 parse delay */

 parse character */

/* Evaluate MSG_ZEROCOPY

 *

 * Send traffic between two processes over one of the supported

 * protocols and modes:

 *

 * PF_INET/PF_INET6

 * - SOCK_STREAM

 * - SOCK_DGRAM

 * - SOCK_DGRAM with UDP_CORK

 * - SOCK_RAW

 * - SOCK_RAW with IP_HDRINCL

 *

 * PF_PACKET

 * - SOCK_DGRAM

 * - SOCK_RAW

 *

 * PF_RDS

 * - SOCK_SEQPACKET

 *

 * Start this program on two connected hosts, one in send mode and

 * the other with option '-r' to put it in receiver mode.

 *

 * If zerocopy mode ('-z') is enabled, the sender will verify that

 * the kernel queues completions on the error queue for all zerocopy

 * transfers.

 default: pin to last cpu */

 split up the packet. for non-multiple, make first buffer longer */

		/* in mixed-frags mode, alternate zerocopy and copy frags

		 * start with non-zerocopy, to ensure attach later works

	/* Detect notification gaps. These should not happen often, if at all.

	 * Gaps can occur due to drops, reordering and retransmissions.

 Read all outstanding messages on the errqueue */

 Wait for all remaining completions on the errqueue */

 sock_raw passes ll header as data */

 both sock_raw and sock_dgram expect name */

 packet and raw sockets with hdrincl must pass network header */

	/* If tx over PF_PACKET, rx over PF_INET(6)/SOCK_RAW,

	 * to recv the only copy of the packet, not a clone

 Flush all outstanding bytes for the tcp receive queue */

 MSG_TRUNC flushes up to len bytes */

 Flush all outstanding datagrams. Verify first few bytes of each. */

 MSG_TRUNC will return full datagram length */

 raw ipv4 return with header, raw ipv6 without */

 max tcp options */;

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2013 Google Inc.

 * Author: Willem de Bruijn (willemb@google.com)

 *

 * A basic test of packet socket fanout behavior.

 *

 * Control:

 * - create fanout fails as expected with illegal flag combinations

 * - join   fanout fails as expected with diverging types or flags

 *

 * Datapath:

 *   Open a pair of packet sockets and a pair of INET sockets, send a known

 *   number of packets across the two INET sockets and count the number of

 *   packets enqueued onto the two packet sockets.

 *

 *   The test currently runs for

 *   - PACKET_FANOUT_HASH

 *   - PACKET_FANOUT_HASH with PACKET_FANOUT_FLAG_ROLLOVER

 *   - PACKET_FANOUT_LB

 *   - PACKET_FANOUT_CPU

 *   - PACKET_FANOUT_ROLLOVER

 *   - PACKET_FANOUT_CBPF

 *   - PACKET_FANOUT_EBPF

 *

 * Todo:

 * - functionality: PACKET_FANOUT_FLAG_DEFRAG

 for sched_setaffinity */

 for __NR_bpf */

/* Open a socket in a given fanout mode.

 ldb [80] */

 ret A */

 Test illegal mode + flag combination */

 Test illegal group with different modes or flags */

 Test illegal max_num_members values */

 expected failure on greater than PACKET_FANOUT_MAX */

 expected failure on joining group with different max_num_members */

 success on joining group with same max_num_members */

 success on joining group with max_num_members unspecified */

 Test creating a unique fanout group ids */

 Send data, but not enough to overflow a queue */

 Send more data, overflow the queue */

 TODO: ensure consistent order between expect1 and expect2 */

 PACKET_FANOUT_MAX */

 find a set of ports that do not collide onto the same socket */

 TODO: test that choice alternates with previous */

/*

 * Test functionality of BPF filters for SO_REUSEPORT.  The tests below will use

 * a BPF program (both classic and extended) to read the first word from an

 * incoming packet (expected to be in network byte-order), calculate a modulus

 * of that number, and then dispatch the packet to the Nth socket using the

 * result.  These tests are run for each supported address family and protocol.

 * Additionally, a few edge cases in the implementation are tested.

 BPF_MOV64_REG(BPF_REG_6, BPF_REG_1) */

 BPF_LD_ABS(BPF_W, 0) R0 = (uint32_t)skb[0] */

 BPF_ALU64_IMM(BPF_MOD, BPF_REG_0, mod) */

 BPF_EXIT_INSN() */

 A = (uint32_t)skb[0] */

 A = A % mod */

 return A */

 bit 1: client side; bit-2 server side */

	/* NOTE: UDP socket lookups traverse a different code path when there

	 * are > 10 sockets in a group.  Run the bpf test through both paths.

 TCP fastopen is required for the TCP tests */

 SPDX-License-Identifier: GPL-2.0

/*

 * It is possible to use SO_REUSEPORT to open multiple sockets bound to

 * equivalent local addresses using AF_INET and AF_INET6 at the same time.  If

 * the AF_INET6 socket has IPV6_V6ONLY set, it's clear which socket should

 * receive a given incoming packet.  However, when it is not set, incoming v4

 * packets should prefer the AF_INET socket(s).  This behavior was defined with

 * the original SO_REUSEPORT implementation, but broke with

 * e32ea7e74727 ("soreuseport: fast reuseport UDP socket selection")

 * This test creates these mixed AF_INET/AF_INET6 sockets and asserts the

 * AF_INET preference for v4 packets.

	/* NOTE: UDP socket lookups traverse a different code path when there

	 * are > 10 sockets in a group.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * This program demonstrates how the various time stamping features in

 * the Linux kernel work. It emulates the behavior of a PTP

 * implementation in stand-alone master mode by sending PTPv1 Sync

 * multicasts once every second. It looks for similar packets, but

 * beyond that doesn't actually implement PTP.

 *

 * Outgoing packets are time stamped with SO_TIMESTAMPING with or

 * without hardware support.

 *

 * Incoming packets are time stamped with SO_TIMESTAMPING with or

 * without hardware support, SIOCGSTAMP[NS] (per-socket time stamp) and

 * SO_TIMESTAMP[NS].

 *

 * Copyright (C) 2009 Intel Corporation.

 * Author: Patrick Ohly <patrick.ohly@intel.com>

 fake uuid */

 fake uuid */

 fake uuid */

 skip deprecated HW transformed */

 bind to PTP port */

 PTP event port */);

 set multicast group for outgoing packets */

 alternate PTP domain 1 */

 join multicast group, loop our own packet */

 set socket options for time stamping */

 request IP_PKTINFO for debugging purposes */

 verify socket options */

 send packets forever every five seconds */

 continue waiting for timeout or data */

 write one packet */

 SPDX-License-Identifier: GPL-2.0

 send() buffer size, may exceed mss */

 send() call is expected to fail */

 mss after applying gso */

 recv(): number of calls of full mss */

 recv(): size of last non-mss dgram, if any */

 no GSO: send a single byte */

 no GSO: send a single MSS */

 no GSO: send a single MSS + 1B: fail */

 send a single MSS: will fall back to no GSO */

 send a single MSS + 1B */

 send exactly 2 MSS */

 send 2 MSS + 1B */

 send MAX segs */

 send MAX bytes */

 send MAX + 1: fail */

 send a single 1B MSS: will fall back to no GSO */

 send 2 1B segments */

 send 2B + 2B + 1B segments */

 send max number of min sized segments */

 send max number + 1 of min sized segments: fail */

 EOL */

 no GSO: send a single byte */

 no GSO: send a single MSS */

 no GSO: send a single MSS + 1B: fail */

 send a single MSS: will fall back to no GSO */

 send a single MSS + 1B */

 send exactly 2 MSS */

 send 2 MSS + 1B */

 send MAX segs */

 send MAX bytes */

 send MAX + 1: fail */

 send a single 1B MSS: will fall back to no GSO */

 send 2 1B segments */

 send 2B + 2B + 1B segments */

 send max number of min sized segments */

 send max number + 1 of min sized segments: fail */

 EOL */

 very wordy version of system("ip route add dev lo mtu 1500 127.0.0.3/32") */

if_nametoindex("lo");

 MTU is a subtype in a metrics type */

 now fill MTU subtype. Note that it fits within above rta_len */

 If MSG_MORE, send 1 byte followed by remainder */

 Recv all full MSS datagrams */

 Recv the non-full last datagram, if tlen was not a multiple of mss */

 Verify received all data */

 if a specific test is given, then skip all others */

 Have tests fail quickly instead of hang */

 Do not fragment these datagrams: only succeed if GSO works */

 use connected addr */);

 SPDX-License-Identifier: GPL-2.0

/* Test that sockets listening on a specific address are preferred

 * over sockets listening on addr_any.

		/* clang does not recognize error() above as terminating

		 * the program, so it complains that saddr, sz are

		 * not initialized when this code path is taken. Silence it.

		/* clang does not recognize error() above as terminating

		 * the program, so it complains that saddr, daddr, sz are

		 * not initialized when this code path is taken. Silence it.

	/* Below we test that a socket listening on a specific address

	 * is always selected in preference over a socket listening

	 * on addr_any. Bugs where this is not the case often result

	 * in sockets created first or last to get picked. So below

	 * we make sure that there are always addr_any sockets created

	 * before and after a specific socket is created.

 SPDX-License-Identifier: GPL-2.0

	/* 0    = valid file descriptor

	 * -foo = error foo

	/* If non-zero, accept EAFNOSUPPORT to handle the case

	 * of the protocol not being configured into the kernel.

 SPDX-License-Identifier: GPL-2.0

/* nettest - used for functional tests of networking APIs

 *

 * Copyright (c) 2013-2019 David Ahern <dsahern@gmail.com>. All rights reserved.

 local address */

 remote address */

 remote scope; v6 send only */

 multicast group */

 DGRAM, STREAM, RAW */

 AF_INET/AF_INET6 */

 prefix for MD5 password */

 0: default, -1: force off, +1: force on */

 expected addresses and device index for connection */

 local address */

 remote address */

 ESP in UDP encap test */

 ENOENT is harmless. Returned when a password is cleared */

	/* entire string should be consumed by conversion

	 * and value should be between min and max

 avoid PKTINFO conflicts with bindtodev */

				/* kernel is allowing scope_id to be set to VRF

				 * index for LLA. for sends to global address

				 * reset scope id

 client sends first message */

 Not in both_mode, so there's no process to signal */

 ipc_fd = -1 if no parent process to signal */

 to tell log_msg in case we are in both_mode */

	/* when running in both mode, address validation applies

	 * solely to client side

	/* do the client-side function here in the parent process,

	 * waiting to be told when to continue

 process inputs */

	/*

	 * process input args

 SPDX-License-Identifier: GPL-2.0

 check messages from kernel */

 do a netlink command and, if max > 0, fetch the reply  */

 Beware: the NLMSG_NEXT macro updates the 'rem' argument */

 addr data */

 family */

 flags */

 do not support flag list yet */

 the only argument is the address id (nonzero) */

 zero id with the IP address */

 build a dummy addr with only the ID set */

 addr data */

 family */

 bump unknown flags, if any */

 the only argument is the address id */

 build a dummy addr with only the ID set */

 limit */

 limit */

 do not expect a reply */

 addr data */

 family */

 flags */

 do not support flag list yet */

 SPDX-License-Identifier: GPL-2.0

 size of this structure in userspace */

 must be 0, set by kernel */

 must be 0, set by kernel */

 size of one element in data[] */

 success */

 success */

 0 size_subflow_data */

 bogus olen */

 must be unchanged */

 size_kernel not 0 */

 num_subflows not 0 */

 forward compat check: larger struct mptcp_subflow_data on 'old' kernel */

 olen must be truncated to real data size filled by kernel: */

 no truncation, kernel should have filled 1 byte of optname payload in buf[1]: */

 wait and repeat, might be that tx is still ongoing */

 un-block server */

 sequence advances due to FIN */

 wait for hangup */

 wait until server bound a socket */

 SPDX-License-Identifier: GPL-2.0

 success */

 success */

 let the join handshake complete, before going on */

				/* no more data to receive:

				 * peer has closed its write side

 and nothing more to send */

 Else, still have data to transmit */

 We have no more data to send. */

 ... and peer also closed already */

				/* ... but we still receive.

				 * Close our write side, ev. give some time

				 * for address notification and/or checking

				 * the current status

 leave some time for late join/announce */

		/* show the runtime only if this end shutdown(wr) before receiving the EOF,

		 * (that is, if this end got the longer runtime)

 listener is ready. */

 silence compiler warning */

 silence compiler warning */

 silence compiler warning */

 SPDX-License-Identifier: GPL-2.0-or-later

 Test 1: Test for SIGURG and OOB */

 Test 2: Test for OOB being overwitten */

 Test 3: Test for SIOCATMARK */

 Test 4: Test for 1byte OOB msg */

	/* Test 1:

	 * veriyf that SIGURG is

	 * delivered and 63 bytes are

	 * read and oob is '@'

	/* Test 2:

	 * Verify that the first OOB is over written by

	 * the 2nd one and the first OOB is returned as

	 * part of the read, and sigurg is received.

	/* Test 3:

	 * verify that 2nd oob over writes

	 * the first one and read breaks at

	 * oob boundary returning 127 bytes

	 * and sigurg is received and atmark

	 * is set.

	 * oob is '%' and second read returns

	 * 64 bytes.

	/* Test 4:

	 * verify that a single byte

	 * oob message is delivered.

	 * set non blocking mode and

	 * check proper error is

	 * returned and sigurg is

	 * received and correct

	 * oob is read.

 Inline Testing */

	/* Test 1 -- Inline:

	 * Check that SIGURG is

	 * delivered and 63 bytes are

	 * read and oob is '@'

	/* Test 2 -- Inline:

	 * Verify that the first OOB is over written by

	 * the 2nd one and read breaks correctly on

	 * 2nd OOB boundary with the first OOB returned as

	 * part of the read, and sigurg is delivered and

	 * siocatmark returns true.

	 * next read returns one byte, the oob byte

	 * and siocatmark returns false.

	/* Test 3 -- Inline:

	 * verify that 2nd oob over writes

	 * the first one and read breaks at

	 * oob boundary returning 127 bytes

	 * and sigurg is received and siocatmark

	 * is true after the read.

	 * subsequent read returns 65 bytes

	 * because of oob which should be '%'.

	/* Test 4 -- Inline:

	 * verify that a single

	 * byte oob message is delivered

	 * and read returns one byte, the oob

	 * byte and sigurg is received

 SPDX-License-Identifier: GPL-2.0

/*

 * Based on Christian Brauner's clone3() example.

 * These tests are assuming to be running in the host's

 * PID namespace.

 capabilities related code based on selftests/bpf/test_verifier.c */

 Drop all capabilities */

 40 -> CAP_CHECKPOINT_RESTORE */

 Find the current active PID */

 After the child has finished, its PID should be free. */

 This would fail without CAP_CHECKPOINT_RESTORE */

 This should work as we have CAP_CHECKPOINT_RESTORE as non-root */

 SPDX-License-Identifier: GPL-2.0 */

	/*

	 * Check that CLONE_CLEAR_SIGHAND and CLONE_SIGHAND are mutually

	 * exclusive.

 Register signal handler for SIGUSR1 */

 Register signal handler for SIGUSR2 */

 Check that CLONE_CLEAR_SIGHAND works. */

 SPDX-License-Identifier: GPL-2.0

/*

 * Based on Christian Brauner's clone3() example.

 * These tests are assuming to be running in the host's

 * PID namespace.

 Signal the parent that the child is ready */

 Try invalid settings */

	/*

	 * This can actually work if this test running in a MAX_PID_NS_LEVEL - 1

	 * nested PID namespace.

	/*

	 * This can actually work if this test running in a MAX_PID_NS_LEVEL - 1

	 * nested PID namespace.

 Try with an invalid PID */

 Claim that the set_tid array actually contains 2 elements. */

 Try it in a new PID namespace */

 Try with a valid PID (1) this should return -EEXIST. */

 Try it in a new PID namespace */

 pid_max should fail everywhere */

		/*

		 * All remaining tests require root. Tell the framework

		 * that all those tests are skipped as non-root.

 Find the current active PID */

 After the child has finished, its PID should be free. */

 This should fail as there is no PID 1 in that namespace */

	/*

	 * Creating a process with PID 1 in the newly created most nested

	 * PID namespace and PID 'pid' in the parent PID namespace. This

	 * needs to work.

 This should fail as there is no PID 1 in that namespace */

 Let's create a PID 1 */

		/*

		 * This and the next test cases check that all pid-s are

		 * released on error paths.

 This should fail as there is invalid PID at level '1'. */

		/*

		 * This should fail as there are not enough active PID

		 * namespaces. Again assuming this is running in the host's

		 * PID namespace. Not yet nested.

		/*

		 * This should work and from the parent we should see

		 * something like 'NSpid:	pid	42	1'.

 Verify that all generated PIDs are as expected. */

 Tell the clone3()'d child to finish. */

 SPDX-License-Identifier: GPL-2.0

 Based on Christian Brauner's clone3() example */

 Just a simple clone3() should return 0.*/

 Do a clone3() in a new PID NS.*/

 Do a clone3() with CLONE_ARGS_SIZE_VER0. */

 Do a clone3() with CLONE_ARGS_SIZE_VER0 - 8 */

 Do a clone3() with sizeof(struct clone_args) + 8 */

 Do a clone3() with exit_signal having highest 32 bits non-zero */

 Do a clone3() with negative 32-bit exit_signal */

 Do a clone3() with exit_signal not fitting into CSIGNAL mask */

 Do a clone3() with NSIG < exit_signal < CSIG */

 Do a clone3() with > page size */

 Do a clone3() with CLONE_ARGS_SIZE_VER0 in a new PID NS. */

 Do a clone3() with CLONE_ARGS_SIZE_VER0 - 8 in a new PID NS */

 Do a clone3() with sizeof(struct clone_args) + 8 in a new PID NS */

 Do a clone3() with > page size in a new PID NS */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * PTP 1588 clock support - User space test program

 *

 * Copyright (C) 2010 OMICRON electronics GmbH

 For PPC64, to get LL64 types */

 clock_adjtime is not available in GLIBC < 2.14 */

 sigh, uClibc ... */

	/*

	 * The 'freq' field in the 'struct timex' is in parts per

	 * million, but with a 16 bit binary fractional field.

	 * Instead of calculating either one of

	 *

	 *    scaled_ppm = (ppb / 1000) << 16  [1]

	 *    scaled_ppm = (ppb << 16) / 1000  [2]

	 *

	 * we simply use double precision math, in order to avoid the

	 * truncation in [1] and the possible overflow in [2].

 Disable the feature again. */

 SPDX-License-Identifier: GPL-2.0

 Wait when the thread will call clock_nanosleep(). */

 The maximum timeout is about 5 seconds. */

 Try to interrupt clock_nanosleep(). */

 Check whether clock_nanosleep() has been interrupted or not. */

*/

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Check that a child process is in the new timens. */

 Check for proper vvar offsets after execve. */

 SPDX-License-Identifier: GPL-2.0

 100ms

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

/*

 * Test shouldn't be run for a day, so add 10 days to child

 * time and check parent's time to be in the same day.

 SPDX-License-Identifier: GPL-2.0

/*

 * Test shouldn't be run for a day, so add 10 days to child

 * time and check parent's time to be in the same day.

	/*

	 * off_id is -1 if a clock has own offset, or it contains an index

	 * which contains a right offset of this clock.

 Let's play nice and put it closer to original */

 Offsets have to be set before tasks enter the namespace. */

/*

 * This application is Copyright 2012 Red Hat, Inc.

 *	Doug Ledford <dledford@redhat.com>

 *

 * mq_perf_tests is free software: you can redistribute it and/or modify

 * it under the terms of the GNU General Public License as published by

 * the Free Software Foundation, version 3.

 *

 * mq_perf_tests is distributed in the hope that it will be useful,

 * but WITHOUT ANY WARRANTY; without even the implied warranty of

 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

 *

 * For the full text of the license, see <http://www.gnu.org/licenses/>.

 *

 * mq_perf_tests.c

 *   Tests various types of message queue workloads, concentrating on those

 *   situations that invole large message sizes, large message queue depths,

 *   or both, and reports back useful metrics about kernel message queue

 *   performance.

 *

 In case we get called by multiple threads or from an sighandler */

		/*

		 * Be silent if this fails, if we cleaned up already it's

		 * expected to fail

/**

 * open_queue - open the global queue for testing

 * @attr - An attr struct specifying the desired queue traits

 * @result - An attr struct that lists the actual traits the queue has

 *

 * This open is not allowed to fail, failure will result in an orderly

 * shutdown of the program.  The global queue_path is used to set what

 * queue to open, the queue descriptor is saved in the global queue

 * variable.

/**

 * Tests to perform (all done with MSG_SIZE messages):

 *

 * 1) Time to add/remove message with 0 messages on queue

 * 1a) with constant prio

 * 2) Time to add/remove message when queue close to capacity:

 * 2a) with constant prio

 * 2b) with increasing prio

 * 2c) with decreasing prio

 * 2d) with random prio

 * 3) Test limits of priorities honored (double check _SC_MQ_PRIO_MAX)

			/* Double check that they didn't give us the same CPU

			/*

			 * Although we can create a msg queue with a

			 * non-absolute path name, unlink will fail.  So,

			 * if the name doesn't start with a /, add one

			 * when we save it.

 Load up the current system values for everything we can */

 Tell the user our initial state */

/*

 * This application is Copyright 2012 Red Hat, Inc.

 *	Doug Ledford <dledford@redhat.com>

 *

 * mq_open_tests is free software: you can redistribute it and/or modify

 * it under the terms of the GNU General Public License as published by

 * the Free Software Foundation, version 3.

 *

 * mq_open_tests is distributed in the hope that it will be useful,

 * but WITHOUT ANY WARRANTY; without even the implied warranty of

 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

 *

 * For the full text of the license, see <http://www.gnu.org/licenses/>.

 *

 * mq_open_tests.c

 *   Tests the various situations that should either succeed or fail to

 *   open a posix message queue and then reports whether or not they

 *   did as they were supposed to.

 *

 In case we get called recursively by a set() call below */

		/*

		 * Be silent if this fails, if we cleaned up already it's

		 * expected to fail

/*

 * test_queue - Test opening a queue, shutdown if we fail.  This should

 * only be called in situations that should never fail.  We clean up

 * after ourselves and return the queue attributes in *result.

/*

 * Same as test_queue above, but failure is not fatal.

 * Returns:

 * 0 - Failed to create a queue

 * 1 - Created a queue, attributes in *result

	/*

	 * Although we can create a msg queue with a non-absolute path name,

	 * unlink will fail.  So, if the name doesn't start with a /, add one

	 * when we save it.

 Find out what files there are for us to make tweaks in */

 Load up the current system values for everything we can */

 Tell the user our initial state */

		/*

		 * While we are here, go ahead and test that the kernel

		 * properly follows the default settings

 In case max was the same as the default */

	/*

	 * Test #2 - open with an attr struct that exceeds rlimit

 SPDX-License-Identifier: GPL-2.0 */

 Attempt to de-conflict with the selftests tree. */

	/*

	 * Callers need to see ECHILD with non-blocking pidfds when no child

	 * processes exists.

 pidfd_open() doesn't support PIDFD_NONBLOCK. */

 pidfd_open() doesn't support PIDFD_NONBLOCK. */

	/*

	 * Callers need to see EAGAIN/EWOULDBLOCK with non-blocking pidfd when

	 * child processes exist but none have exited.

	/*

	 * Callers need to continue seeing 0 with non-blocking pidfd and

	 * WNOHANG raised explicitly when child processes exist but none have

	 * exited.

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Child process just sleeps for a min and exits */

 Parent kills the child and waits for its death */

 Setup 3 sec alarm - plenty of time */

 Send SIGKILL to the child */

 Wait for the death notification */

 Check for error conditions */

 Wait for child to prevent zombies */

 SPDX-License-Identifier: GPL-2.0

/*

 * UNKNOWN_FD is an fd number that should never exist in the child, as it is

 * used to check the negative case.

	/*

	 * Ensure we don't leave around a bunch of orphaned children if our

	 * tests fail.

	/*

	 * The fixture setup is completed at this point. The tests will run.

	 *

	 * This blocking recv enables the parent to message the child.

	 * Either we will read 'P' off of the sk, indicating that we need

	 * to disable ptrace, or we will read a 0, indicating that the other

	 * side has closed the sk. This occurs during fixture teardown time,

	 * indicating that the child should exit.

	/*

	 * remote_fd is the number of the FD which we are trying to retrieve

	 * from the child.

 pid points to the child which we are fetching FDs from */

 pidfd is the pidfd of the child */

	/*

	 * sk is our side of the socketpair used to communicate with the child.

	 * When it is closed, the child will exit.

	/*

	 * Wait for the child to complete setup. It'll send the remote memfd's

	 * number when ready.

	/*

	 * Turn into nobody if we're root, to avoid CAP_SYS_PTRACE

	 *

	 * The tests should run in their own process, so even this test fails,

	 * it shouldn't result in subsequent tests failing.

 SPDX-License-Identifier: GPL-2.0 */

 seconds */

/*

 * Straightforward test to see whether pidfd_send_signal() works is to send

 * a signal to ourself.

/*

 * Maximum number of cycles we allow. This is equivalent to PID_MAX_DEFAULT.

 * If users set a higher limit or we have cycled PIDFD_MAX_DEFAULT number of

 * times then we skip the test to not go into an infinite loop or block for a

 * long time.

 pid 1 in new pid namespace */

 grab pid PID_RECYCLE */

		/*

		 * We want to be as predictable as we can so if we haven't been

		 * able to grab pid PID_RECYCLE skip the test.

 skip test */

			/*

			 * Stop the child so we can inspect whether we have

			 * recycled pid PID_RECYCLE.

			/*

			 * We have recycled the pid. Try to signal it. This

			 * needs to fail since this is a different process than

			 * the one the pidfd refers to.

 let the process move on */

 fallthrough */

 not reached */

			/*

			 * If the user set a custom pid_max limit we could be

			 * in the millions.

			 * Skip the test in this case.

 failed to recycle pid */

 PIDFD_ERROR */:

	/*

	 * Exec in the non-leader thread will destroy the leader immediately.

	 * If the wait in the parent returns too soon, the test fails.

	/*

	 * glibc exit calls exit_group syscall, so explicity call exit only

	 * so that only the group leader exits, leaving the threads alone.

		/*

		 * This sleep tests for the case where if the child exits, and is in

		 * EXIT_ZOMBIE, but the thread group leader is non-empty, then the poll

		 * doesn't prematurely return even though there are active threads

 SPDX-License-Identifier: GPL-2.0

 Create task that exits right away. */

 Create tasks that will be stopped. */

 processes are in the same namespace */

 processes are in different namespaces */

 Test that we can't pass garbage to the kernel. */

 Test that we can't attach to a task that has already exited. */

 Verify that we haven't changed any namespaces. */

 Verify that we have changed to the correct namespaces. */

 Verify that we have changed to the correct namespaces. */

 Verify that we have changed to the correct namespaces. */

 No use logging pid_for_children. */

	/*

	 * Can't setns to a user namespace outside of our hierarchy since we

	 * don't have caps in there and didn't create it. That means that under

	 * no circumstances should we be able to setns to any of the other

	 * ones since they aren't owned by our user namespace.

 SPDX-License-Identifier: GPL-2.0

 will be: not ok %d # error %s test: %s */

 will be: not ok %d # SKIP %s test: %s */

 In case of error we bail out and terminate the test program */

 if we got no fd for the sibling, we are done */

	/* verify that we can not resolve the pidfd for a process

	 * in a sibling pid namespace, i.e. a pid namespace it is

	 * not in our or a descended namespace

 Create a new child in a new pid and mount namespace */

	/* Pass the pidfd representing the first child to the

	 * second child, which will be in a sibling pid namespace,

	 * which means that the fdinfo NSpid entry for the pidfd

	 * should only contain '0'.

	/* The children will have pid 1 in the new pid namespace,

	 * so the line must be 'NSPid:\t<pid>\t1'.

	/* wait for the process, check the exit status and set

	 * 'err' accordingly, if it is not already set.

 Create a new child in a new pid and mount namespace */

/*

 * Regression test for:

 * 35f71bc0a09a ("fork: report pid reservation failure properly")

 * b26ebfe12f34 ("pid: Fix error return value in some cases")

 SPDX-License-Identifier: GPL-2.0

 An example of output and arguments */

 This one should fail */

 This one should return same fd */

 Compare with self */

 Compare epoll target */

 SPDX-License-Identifier: GPL-2.0

 needed to get the defines */

#include <fcntl.h>	/* in glibc 2.2 this has the needed

	/* we will now be notified if any of the files

 SPDX-License-Identifier: GPL-2.0

	/*

	 * grantpt() makes assumptions about /dev/pts/ so ignore it. It's also

	 * not really needed.

 SPDX-License-Identifier: GPL-2.0

/*

 *          t0

 *           | (ew)

 *          e0

 *           | (lt)

 *          s0

/*

 *          t0

 *           | (ew)

 *          e0

 *           | (et)

 *          s0

/*

 *           t0

 *            | (ew)

 *           e0

 *     (lt) /  \ (lt)

 *        s0    s2

/*

 *           t0

 *            | (ew)

 *           e0

 *     (et) /  \ (et)

 *        s0    s2

/*

 *          t0

 *           | (p)

 *          e0

 *           | (lt)

 *          s0

/*

 *          t0

 *           | (p)

 *          e0

 *           | (et)

 *          s0

/*

 *           t0

 *            | (p)

 *           e0

 *     (lt) /  \ (lt)

 *        s0    s2

/*

 *           t0

 *            | (p)

 *           e0

 *     (et) /  \ (et)

 *        s0    s2

/*

 *        t0    t1

 *     (ew) \  / (ew)

 *           e0

 *            | (lt)

 *           s0

/*

 *        t0    t1

 *     (ew) \  / (ew)

 *           e0

 *            | (et)

 *           s0

/*

 *        t0    t1

 *     (ew) \  / (ew)

 *           e0

 *     (lt) /  \ (lt)

 *        s0    s2

/*

 *        t0    t1

 *     (ew) \  / (ew)

 *           e0

 *     (et) /  \ (et)

 *        s0    s2

/*

 *        t0    t1

 *     (ew) \  / (p)

 *           e0

 *            | (lt)

 *           s0

/*

 *        t0    t1

 *     (ew) \  / (p)

 *           e0

 *            | (et)

 *           s0

/*

 *        t0    t1

 *     (ew) \  / (p)

 *           e0

 *     (lt) /  \ (lt)

 *        s0    s2

/*

 *        t0    t1

 *     (ew) \  / (p)

 *           e0

 *     (et) /  \ (et)

 *        s0    s2

/*

 *          t0

 *           | (ew)

 *          e0

 *           | (lt)

 *          e1

 *           | (lt)

 *          s0

/*

 *          t0

 *           | (ew)

 *          e0

 *           | (lt)

 *          e1

 *           | (et)

 *          s0

/*

 *           t0

 *            | (ew)

 *           e0

 *            | (et)

 *           e1

 *            | (lt)

 *           s0

/*

 *           t0

 *            | (ew)

 *           e0

 *            | (et)

 *           e1

 *            | (et)

 *           s0

/*

 *          t0

 *           | (p)

 *          e0

 *           | (lt)

 *          e1

 *           | (lt)

 *          s0

/*

 *          t0

 *           | (p)

 *          e0

 *           | (lt)

 *          e1

 *           | (et)

 *          s0

/*

 *          t0

 *           | (p)

 *          e0

 *           | (et)

 *          e1

 *           | (lt)

 *          s0

/*

 *          t0

 *           | (p)

 *          e0

 *           | (et)

 *          e1

 *           | (et)

 *          s0

/*

 *        t0    t1

 *     (ew) \  / (ew)

 *           e0

 *            | (lt)

 *           e1

 *            | (lt)

 *           s0

/*

 *        t0    t1

 *     (ew) \  / (ew)

 *           e0

 *            | (lt)

 *           e1

 *            | (et)

 *           s0

/*

 *        t0    t1

 *     (ew) \  / (ew)

 *           e0

 *            | (et)

 *           e1

 *            | (lt)

 *           s0

/*

 *        t0    t1

 *     (ew) \  / (ew)

 *           e0

 *            | (et)

 *           e1

 *            | (et)

 *           s0

/*

 *        t0    t1

 *     (ew) \  / (p)

 *           e0

 *            | (lt)

 *           e1

 *            | (lt)

 *           s0

/*

 *        t0    t1

 *     (ew) \  / (p)

 *           e0

 *            | (lt)

 *           e1

 *            | (et)

 *           s0

/*

 *        t0    t1

 *     (ew) \  / (p)

 *           e0

 *            | (et)

 *           e1

 *            | (lt)

 *           s0

/*

 *        t0    t1

 *     (ew) \  / (p)

 *           e0

 *            | (et)

 *           e1

 *            | (et)

 *           s0

/*

 *        t0   t1

 *    (ew) |    | (ew)

 *         |   e0

 *          \  / (lt)

 *           e1

 *            | (lt)

 *           s0

/*

 *        t0   t1

 *    (ew) |    | (ew)

 *         |   e0

 *          \  / (lt)

 *           e1

 *            | (et)

 *           s0

/*

 *        t0   t1

 *    (ew) |    | (ew)

 *         |   e0

 *          \  / (et)

 *           e1

 *            | (lt)

 *           s0

/*

 *        t0   t1

 *    (ew) |    | (ew)

 *         |   e0

 *          \  / (et)

 *           e1

 *            | (et)

 *           s0

/*

 *        t0   t1

 *     (p) |    | (ew)

 *         |   e0

 *          \  / (lt)

 *           e1

 *            | (lt)

 *           s0

/*

 *        t0   t1

 *     (p) |    | (ew)

 *         |   e0

 *          \  / (lt)

 *           e1

 *            | (et)

 *           s0

/*

 *        t0   t1

 *     (p) |    | (ew)

 *         |   e0

 *          \  / (et)

 *           e1

 *            | (lt)

 *           s0

/*

 *        t0   t1

 *     (p) |    | (ew)

 *         |   e0

 *          \  / (et)

 *           e1

 *            | (et)

 *           s0

/*

 *        t0   t1

 *    (ew) |    | (p)

 *         |   e0

 *          \  / (lt)

 *           e1

 *            | (lt)

 *           s0

/*

 *        t0   t1

 *    (ew) |    | (p)

 *         |   e0

 *          \  / (lt)

 *           e1

 *            | (et)

 *           s0

/*

 *        t0   t1

 *    (ew) |    | (p)

 *         |   e0

 *          \  / (et)

 *           e1

 *            | (lt)

 *           s0

/*

 *        t0   t1

 *    (ew) |    | (p)

 *         |   e0

 *          \  / (et)

 *           e1

 *            | (et)

 *           s0

/*

 *        t0   t1

 *     (p) |    | (p)

 *         |   e0

 *          \  / (lt)

 *           e1

 *            | (lt)

 *           s0

/*

 *        t0   t1

 *     (p) |    | (p)

 *         |   e0

 *          \  / (lt)

 *           e1

 *            | (et)

 *           s0

/*

 *        t0   t1

 *     (p) |    | (p)

 *         |   e0

 *          \  / (et)

 *           e1

 *            | (lt)

 *           s0

/*

 *        t0   t1

 *     (p) |    | (p)

 *         |   e0

 *          \  / (et)

 *           e1

 *            | (et)

 *           s0

/*

 *           t0

 *            | (ew)

 *           e0

 *     (lt) /  \ (lt)

 *        e1    e2

 *    (lt) |     | (lt)

 *        s0    s2

/*

 *           t0

 *            | (ew)

 *           e0

 *     (et) /  \ (et)

 *        e1    e2

 *    (lt) |     | (lt)

 *        s0    s2

/*

 *           t0

 *            | (p)

 *           e0

 *     (lt) /  \ (lt)

 *        e1    e2

 *    (lt) |     | (lt)

 *        s0    s2

/*

 *           t0

 *            | (p)

 *           e0

 *     (et) /  \ (et)

 *        e1    e2

 *    (lt) |     | (lt)

 *        s0    s2

/*

 *        t0    t1

 *     (ew) \  / (ew)

 *           e0

 *     (lt) /  \ (lt)

 *        e1    e2

 *    (lt) |     | (lt)

 *        s0    s2

/*

 *        t0    t1

 *     (ew) \  / (ew)

 *           e0

 *     (et) /  \ (et)

 *        e1    e2

 *    (lt) |     | (lt)

 *        s0    s2

/*

 *        t0    t1

 *     (ew) \  / (p)

 *           e0

 *     (lt) /  \ (lt)

 *        e1    e2

 *    (lt) |     | (lt)

 *        s0    s2

/*

 *        t0    t1

 *     (ew) \  / (p)

 *           e0

 *     (et) /  \ (et)

 *        e1    e2

 *    (lt) |     | (lt)

 *        s0    s2

/*

 *        t0    t1

 *      (p) \  / (p)

 *           e0

 *     (lt) /  \ (lt)

 *        e1    e2

 *    (lt) |     | (lt)

 *        s0    s2

/*

 *        t0    t1

 *      (p) \  / (p)

 *           e0

 *     (et) /  \ (et)

 *        e1    e2

 *    (lt) |     | (lt)

 *        s0    s2

/*

 *        t0

 *      (p) \

 *           e0

 *     (et) /

 *        e0

 *

 * Based on https://bugzilla.kernel.org/show_bug.cgi?id=205933

 Block SIGUSR1 */

 Prepare empty mask for epoll_pwait() */

 Mark we are ready */

 Start when all are ready */

 Account this waiter */

 We expect only signal delivery on stop */

 Since we are on ET mode, thus each thread gets its own fd. */

 Create event fds */

 Create waiter threads */

 Wait for all to be ready */

 Steady, go */

 Wait all have gone to kernel */

 1ms should be enough to schedule away */

 Quickly signal all handles at once */

 Busy loop for 1s and wait for all waiters to wake up */

 Stop waiters */

	/*

	 * If epoll returned the eventfd, write on the eventfd to wake up the

	 * blocking poller.

	/*

	 * We are testing a race.  Repeat the test case 1000 times to make it

	 * more likely to fail in case of a bug.

		/*

		 * Start 3 threads:

		 * Thread 1 sleeps for 10.9ms and writes to the evenfd.

		 * Thread 2 calls epoll with a timeout of 11ms.

		 * Thread 3 calls epoll with a timeout of -1.

		 *

		 * The eventfd write by Thread 1 should either wakeup Thread 2

		 * or Thread 3.  If it wakes up Thread 2, Thread 2 writes on the

		 * eventfd to wake up Thread 3.

		 *

		 * If no events are missed, all three threads should eventually

		 * be joinable.

 Equivalent to basic test epoll1, but exercising epoll_pwait2. */

 Epoll_pwait2 basic timeout test. */

/*

 *        t0    t1

 *     (ew) \  / (ew)

 *           e0

 *            | (lt)

 *           s0

	/*

	 * main will act as the emitter once both waiter threads are

	 * blocked and expects to both be awoken upon the ready event.

 SPDX-License-Identifier: GPL-2.0

 success: binderfs mounted */

 success: binder device allocation */

 success: binder transaction with binderfs binder device */

 success: binder device removal */

 success: binder-control device removal failed as expected */

 success: binder feature files found */

/*

 * Regression test:

 * 2669b8b0c798 ("binder: prevent UAF for binderfs devices")

 * f0fe2c0f050d ("binder: prevent UAF for binderfs devices II")

 * 211b64e4b5b6 ("binderfs: use refcount for binder control devices too")

 SPDX-License-Identifier: GPL-2.0

 Attempt to de-conflict with the selftests tree. */

 SPDX-License-Identifier: GPL-2.0

/*

 * selftest for sparc64's privileged ADI driver

 *

 * Author: Tom Hromatka <tom.hromatka@oracle.com>

 bit mask of enabled bits to print */

			/* Given a line like this:

			 * d0400000-10ffaffff : System RAM

			 * replace the "-" with a space

 somewhat arbitrarily chosen address */

 somewhat arbitrarily chosen address */

 somewhat arbitrarily chosen address */

 somewhat arbitrarily chosen address */

 seek to the current offset.  this should return EINVAL */

 somewhat arbitrarily chosen address */

 somewhat arbitrarily chosen address */

 somewhat arbitrarily chosen address */

	/* it's impossible to get here, but the compiler throws a warning

	 * about control reaching the end of non-void function.  bah.

 SPDX-License-Identifier: GPL-2.0

/*

 * video_device_test - Video Device Test

 *

 * Copyright (c) 2016 Shuah Khan <shuahkh@osg.samsung.com>

 * Copyright (c) 2016 Samsung Electronics Co., Ltd.

 *

/*

 * This file adds a test for Video Device. This test should not be included

 * in the Kselftest run. This test should be run when hardware and driver

 * that makes use of V4L2 API is present.

 *

 * This test opens user specified Video Device and calls video ioctls in a

 * loop once every 10 seconds.

 *

 * Usage:

 *	sudo ./video_device_test -d /dev/videoX

 *

 *	While test is running, remove the device or unbind the driver and

 *	ensure there are no use after free errors and other Oops in the

 *	dmesg.

 *	When possible, enable KaSan kernel config option for use-after-free

 *	error detection.

 Process arguments */

 Generate random number of interations */

 Open Video device and keep it open */

 SPDX-License-Identifier: GPL-2.0

/*

 * media_device_open.c - Media Controller Device Open Test

 *

 * Copyright (c) 2016 Shuah Khan <shuahkh@osg.samsung.com>

 * Copyright (c) 2016 Samsung Electronics Co., Ltd.

 *

/*

 * This file adds a test for Media Controller API.

 * This test should be run as root and should not be

 * included in the Kselftest run. This test should be

 * run when hardware and driver that makes use Media

 * Controller API are present in the system.

 *

 * This test opens user specified Media Device and calls

 * MEDIA_IOC_DEVICE_INFO ioctl, closes the file, and exits.

 *

 * Usage:

 *	sudo ./media_device_open -d /dev/mediaX

 *

 *	Run this test is a loop and run bind/unbind on the driver.

 Process arguments */

 Open Media device and keep it open */

 SPDX-License-Identifier: GPL-2.0

/*

 * media_device_test.c - Media Controller Device ioctl loop Test

 *

 * Copyright (c) 2016 Shuah Khan <shuahkh@osg.samsung.com>

 * Copyright (c) 2016 Samsung Electronics Co., Ltd.

 *

/*

 * This file adds a test for Media Controller API.

 * This test should be run as root and should not be

 * included in the Kselftest run. This test should be

 * run when hardware and driver that makes use Media

 * Controller API are present in the system.

 *

 * This test opens user specified Media Device and calls

 * MEDIA_IOC_DEVICE_INFO ioctl in a loop once every 10

 * seconds.

 *

 * Usage:

 *	sudo ./media_device_test -d /dev/mediaX

 *

 *	While test is running, remove the device and

 *	ensure there are no use after free errors and

 *	other Oops in the dmesg. Enable KaSan kernel

 *	config option for use-after-free error detection.

 Process arguments */

 Generate random number of interations */

 Open Media device and keep it open */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Exercise /dev/mem mmap cases that have been troublesome in the past

 *

 * (c) Copyright 2007 Hewlett-Packard Development Company, L.P.

 *	Bjorn Helgaas <bjorn.helgaas@hp.com>

	if (fnmatch("/proc/bus/pci/*", path, 0) == 0) {

		rc = ioctl(fd, PCIIOC_MMAP_IS_MEM);

		if (rc == -1)

			perror("PCIIOC_MMAP_IS_MEM ioctl");

	}



	addr = mmap(NULL, length, PROT_READ|PROT_WRITE, MAP_SHARED, fd, offset);

	if (addr == MAP_FAILED)

		return 1;



	if (touch) {

		c = (int *) addr;

		while (c < (int *) (addr + length))

			sum += *c++;

	}



	rc = munmap(addr, length);

	if (rc == -1) {

		perror("munmap");

		return -1;

	}



	close(fd);

	return 0;

}



static int scan_tree(char *path, char *file, off_t offset, size_t length, int touch)

{

	struct dirent **namelist;

	char *name, *path2;

	int i, n, r, rc = 0, result = 0;

	struct stat buf;



	n = scandir(path, &namelist, 0, alphasort);

	if (n < 0) {

		perror("scandir");

		return -1;

	}



	for (i = 0; i < n; i++) {

		name = namelist[i]->d_name;



		if (fnmatch(".", name, 0) == 0)

			goto skip;

		if (fnmatch("..", name, 0) == 0)

			goto skip;



		path2 = malloc(strlen(path) + strlen(name) + 3);

		strcpy(path2, path);

		strcat(path2, "/");

		strcat(path2, name);



		if (fnmatch(file, name, 0) == 0) {

			rc = map_mem(path2, offset, length, touch);

			if (rc == 0)

				fprintf(stderr, "PASS: %s 0x%lx-0x%lx is %s\n", path2, offset, offset + length, touch ? "readable" : "mappable");

			else if (rc > 0)

				fprintf(stderr, "PASS: %s 0x%lx-0x%lx not mappable\n", path2, offset, offset + length);

			else {

				fprintf(stderr, "FAIL: %s 0x%lx-0x%lx not accessible\n", path2, offset, offset + length);

				return rc;

			}

		} else {

			r = lstat(path2, &buf);

			if (r == 0 && S_ISDIR(buf.st_mode)) {

				rc = scan_tree(path2, file, offset, length, touch);

				if (rc < 0)

					return rc;

			}

		}



		result |= rc;

		free(path2);



skip:

		free(namelist[i]);

	}

	free(namelist);

	return result;

}



char buf[1024];



static int read_rom(char *path)

{

	int fd, rc;

	size_t size = 0;



	fd = open(path, O_RDWR);

	if (fd == -1) {

		perror(path);

		return -1;

	}



	rc = write(fd, "1", 2);

	if (rc <= 0) {

		close(fd);

		perror("write");

		return -1;

	}



	do {

		rc = read(fd, buf, sizeof(buf));

		if (rc > 0)

			size += rc;

	} while (rc > 0);



	close(fd);

	return size;

}



static int scan_rom(char *path, char *file)

{

	struct dirent **namelist;

	char *name, *path2;

	int i, n, r, rc = 0, result = 0;

	struct stat buf;



	n = scandir(path, &namelist, 0, alphasort);

	if (n < 0) {

		perror("scandir");

		return -1;

	}



	for (i = 0; i < n; i++) {

		name = namelist[i]->d_name;



		if (fnmatch(".", name, 0) == 0)

			goto skip;

		if (fnmatch("..", name, 0) == 0)

			goto skip;



		path2 = malloc(strlen(path) + strlen(name) + 3);

		strcpy(path2, path);

		strcat(path2, "/");

		strcat(path2, name);



		if (fnmatch(file, name, 0) == 0) {

			rc = read_rom(path2);





			 */

			if (rc > 0)

				fprintf(stderr, "PASS: %s read %d bytes\n", path2, rc);

			else {

				fprintf(stderr, "PASS: %s not readable\n", path2);

				return rc;

			}

		} else {

			r = lstat(path2, &buf);

			if (r == 0 && S_ISDIR(buf.st_mode)) {

				rc = scan_rom(path2, file);

				if (rc < 0)

					return rc;

			}

		}



		result |= rc;

		free(path2);



skip:

		free(namelist[i]);

	}

	free(namelist);

	return result;

}



int main(void)

{

	int rc;



	if (map_mem("/dev/mem", 0, 0xA0000, 1) == 0)

		fprintf(stderr, "PASS: /dev/mem 0x0-0xa0000 is readable\n");

	else

		fprintf(stderr, "FAIL: /dev/mem 0x0-0xa0000 not accessible\n");





	 */

	if (map_mem("/dev/mem", 0xA0000, 0x20000, 0) == 0)

		fprintf(stderr, "PASS: /dev/mem 0xa0000-0xc0000 is mappable\n");

	else

		fprintf(stderr, "FAIL: /dev/mem 0xa0000-0xc0000 not accessible\n");



	if (map_mem("/dev/mem", 0xC0000, 0x40000, 1) == 0)

		fprintf(stderr, "PASS: /dev/mem 0xc0000-0x100000 is readable\n");

	else

		fprintf(stderr, "FAIL: /dev/mem 0xc0000-0x100000 not accessible\n");





	 */

	rc = map_mem("/dev/mem", 0, 1024*1024, 0);

	if (rc == 0)

		fprintf(stderr, "PASS: /dev/mem 0x0-0x100000 is mappable\n");

	else if (rc > 0)

		fprintf(stderr, "PASS: /dev/mem 0x0-0x100000 not mappable\n");

	else

		fprintf(stderr, "FAIL: /dev/mem 0x0-0x100000 not accessible\n");



	scan_tree("/sys/class/pci_bus", "legacy_mem", 0, 0xA0000, 1);

	scan_tree("/sys/class/pci_bus", "legacy_mem", 0xA0000, 0x20000, 0);

	scan_tree("/sys/class/pci_bus", "legacy_mem", 0xC0000, 0x40000, 1);

	scan_tree("/sys/class/pci_bus", "legacy_mem", 0, 1024*1024, 0);



	scan_rom("/sys/devices", "rom");



	scan_tree("/proc/bus/pci", "??.?", 0, 0xA0000, 1);

	scan_tree("/proc/bus/pci", "??.?", 0xA0000, 0x20000, 0);

	scan_tree("/proc/bus/pci", "??.?", 0xC0000, 0x40000, 1);

	scan_tree("/proc/bus/pci", "??.?", 0, 1024*1024, 0);



	return rc;

}

 SPDX-License-Identifier: GPL-2.0

/*

 * Stas Sergeev <stsp@users.sourceforge.net>

 *

 * test sigaltstack(SS_ONSTACK | SS_AUTODISARM)

 * If that succeeds, then swapcontext() can be used inside sighandler safely.

 *

 put some data on stack. other sighandler will try to overwrite it */

 dont run valgrind on this */

 try to find the data stored by previous sighandler */

 corrupt the data */

 tell other sighandler that his data is corrupted */

 Make sure more than the required minimum. */

			/*

			 * If test cases for the !SS_AUTODISARM variant were

			 * added, we could still run them.  We don't have any

			 * test cases like that yet, so just exit and report

			 * success.

 SPDX-License-Identifier: GPL-2.0

 create a test variable */

 SPDX-License-Identifier: GPL-2.0

	/* attributes: EFI_VARIABLE_NON_VOLATILE |

	 *		EFI_VARIABLE_BOOTSERVICE_ACCESS |

	 *		EFI_VARIABLE_RUNTIME_ACCESS

 create a test variable */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0-or-later

/* Real Time Clock Driver Test

 *	by: Benjamin Gaignard (benjamin.gaignard@linaro.org)

 *

 * To build

 *	gcc rtctest_setdate.c -o rtctest_setdate

 FALLTHROUGH */

 Write the new date in RTC */

 Read back */

 SPDX-License-Identifier: GPL-2.0

/*

 * Real Time Clock Driver Test Program

 *

 * Copyright (c) 2018 Alexandre Belloni <alexandre.belloni@bootlin.com>

 Read the RTC time/date */

 Turn on update interrupts */

 This read will block */

 Turn on update interrupts */

 The select will wait until an RTC interrupt happens. */

 This read won't block */

 Enable alarm interrupts */

 Disable alarm interrupts */

 Enable alarm interrupts */

 Disable alarm interrupts */

 FALLTHROUGH */

 SPDX-License-Identifier: GPL-2.0+

/*

 * kselftest suite for mincore().

 *

 * Copyright (C) 2020 Collabora, Ltd.

 Default test file size: 4MB */

/*

 * Tests the user interface. This test triggers most of the documented

 * error conditions in mincore().

 Query a 0 byte sized range */

 Addresses in the specified range are invalid or unmapped */

 <addr> argument is not page-aligned */

 <length> argument is too large */

 <vec> argument points to an illegal address */

/*

 * Test mincore() behavior on a private anonymous page mapping.

 * Check that the page is not loaded into memory right after the mapping

 * but after accessing it (on-demand allocation).

 * Then free the page and check that it's not memory-resident.

 Map one page and check it's not memory-resident */

 Touch the page and check again. It should now be in memory */

	/*

	 * It shouldn't be memory-resident after unlocking it and

	 * marking it as unneeded.

/*

 * Check mincore() behavior on huge pages.

 * This test will be skipped if the mapping fails (ie. if there are no

 * huge pages available).

 *

 * Make sure the system has at least one free huge page, check

 * "HugePages_Free" in /proc/meminfo.

 * Increment /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages if

 * needed.

/*

 * Test mincore() behavior on a file-backed page.

 * No pages should be loaded into memory right after the mapping. Then,

 * accessing any address in the mapping range should load the page

 * containing the address and a number of subsequent pages (readahead).

 *

 * The actual readahead settings depend on the test environment, so we

 * can't make a lot of assumptions about that. This test covers the most

 * general cases.

	/*

	 * Map the whole file, the pages shouldn't be fetched yet.

	/*

	 * Touch a page in the middle of the mapping. We expect the next

	 * few pages (the readahead window) to be populated too.

	/*

	 * End of the readahead window. The rest of the pages shouldn't

	 * be in memory.

/*

 * Test mincore() behavior on a page backed by a tmpfs file.  This test

 * performs the same steps as the previous one. However, we don't expect

 * any readahead in this case.

	/*

	 * Map the whole file, the pages shouldn't be fetched yet.

	/*

	 * Touch a page in the middle of the mapping. We expect only

	 * that page to be fetched into memory.

 SPDX-License-Identifier: GPL-2.0

 kallsyms not loaded. return NULL */

 valid ksym */

 out of range. return _stext */

/* open kallsyms and read symbol addresses on the fly. Without caching all symbols,

 * this is faster than load + find.

	/*

	 * A PPC64 ABIv2 function may have a local and a global entry

	 * point. We need to use the local entry point when patching

	 * functions, so identify and step over the global entry point

	 * sequence.

	 *

	 * The global entry point sequence is always of the form:

	 *

	 * addis r2,r12,XXXX

	 * addi  r2,r2,XXXX

	 *

	 * A linker optimisation may convert the addis to lis:

	 *

	 * lis   r2,XXXX

	 * addi  r2,r2,XXXX

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2017-2018 Covalent IO, Inc. http:
 randomly selected ports for testing on lo */

 global sockets */

 Init sockets */

 Allow reuse */

 Non-blocking sockets */

 Bind server sockets */

 Listen server sockets */

 Initiate Connect */

 Accept Connecrtions */

 Special case test for skb ingress + ktls */

 advance index past PASS header */

		/* Account for pop bytes noting each iteration of apply will

		 * call msg_pop_data helper so we need to account for this

		 * by calculating the number of apply iterations. Note user

		 * of the tool can create cases where no data is sent by

		 * manipulating pop/push/pull/etc. For example txmsg_apply 1

		 * with txmsg_pop 1 will try to apply 1B at a time but each

		 * iteration will then pop 1B so no data will ever be sent.

		 * This is really only useful for testing edge cases in code

		 * paths.

 FD sets */

		/* Redirecting into non-TLS socket which sends into a TLS

		 * socket is not a valid test. So in this case lets not

		 * enable kTLS but still run the test.

 zero bytes sent case */

 Ping/Pong data from client to server */

 FD sets */

 If base test skip BPF setup */

 Attach programs to sockmap */

 Attach programs to TLS sockmap */

 Attach to cgroups */

 Attach txmsg program to sockmap */

 Detatch and zero all the maps */

 just zero byte could be written */

 strncat() adds + 1 for zero byte */

 Test small and large iov_count values with pass/redir/apply/cork */

	/* Using data verification so ensure iov layout is

	 * expected from test receiver side. e.g. has enough

	 * bytes to write test code.

 Tests that omit skb_parser */

/* Test cork with hung data. This tests poor usage patterns where

 * cork can leave data on the ring if user program is buggy and

 * doesn't flush them somehow. They do take some time however

 * because they wait for a timeout. Test pass, redir and cork with

 * apply logic. Use cork size of 4097 with send_large to avoid

 * aligning cork size with send size.

 Test basic start/end */

 Test >4k pull */

 Test pull + redirect */

 Test pull + cork */

 Test pull + cork + redirect */

 Test basic pop */

 Test pop with >4k */

 Test pop + redirect */

 Test pop + cork */

 Test pop + redirect + cork */

 Test basic push */

 Test push 4kB >4k */

 Test push + redirect */

 Test push + cork */

 Tests basic commands and APIs */

 catch SIGINT */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2019 Netronome Systems, Inc. */

 SPDX-License-Identifier: GPL-2.0

 Ignore */, BPF_FLOW_DISSECTOR, 0);

 To unpin, it is necessary and sufficient to just remove this dir */

 SPDX-License-Identifier: GPL-2.0-only

 On some systems 'ping' doesn't support IPv6, so use ping6 if it is present. */

 SPDX-License-Identifier: GPL-2.0

/*

 * To avoid relying on the system setup, when setup_cgroup_env is called

 * we create a new mount namespace, and cgroup namespace. The cgroupv2

 * root is mounted at CGROUP_MOUNT_PATH. Unfortunately, most people don't

 * have cgroupv2 enabled at this point in time. It's easier to create our

 * own mount namespace and manage it ourselves. We assume /mnt exists.

 *

 * Related cgroupv1 helpers are named *classid*(), since we only use the

 * net_cls controller for tagging net_cls.classid. We assume the default

 * mount under /sys/fs/cgroup/net_cls, which should be the case for the

 * vast majority of users.

/**

 * enable_all_controllers() - Enable all available cgroup v2 controllers

 *

 * Enable all available cgroup v2 controllers in order to increase

 * the code coverage.

 *

 * If successful, 0 is returned.

 No controllers available? We're probably on cgroup v1. */

/**

 * setup_cgroup_environment() - Setup the cgroup environment

 *

 * After calling this function, cleanup_cgroup_environment should be called

 * once testing is complete.

 *

 * This function will print an error to stderr and return 1 if it is unable

 * to setup the cgroup environment. If setup is successful, 0 is returned.

 Cleanup existing failed runs, now that the environment is setup */

/**

 * join_cgroup() - Join a cgroup

 * @path: The cgroup path, relative to the workdir, to join

 *

 * This function expects a cgroup to already be created, relative to the cgroup

 * work dir, and it joins it. For example, passing "/my-cgroup" as the path

 * would actually put the calling process into the cgroup

 * "/cgroup-test-work-dir/my-cgroup"

 *

 * On success, it returns 0, otherwise on failure it returns 1.

/**

 * cleanup_cgroup_environment() - Cleanup Cgroup Testing Environment

 *

 * This is an idempotent function to delete all temporary cgroups that

 * have been created during the test, including the cgroup testing work

 * directory.

 *

 * At call time, it moves the calling process to the root cgroup, and then

 * runs the deletion process. It is idempotent, and should not fail, unless

 * a process is lingering.

 *

 * On failure, it will print an error to stderr, and try to continue.

/**

 * create_and_get_cgroup() - Create a cgroup, relative to workdir, and get the FD

 * @path: The cgroup path, relative to the workdir, to join

 *

 * This function creates a cgroup under the top level workdir and returns the

 * file descriptor. It is idempotent.

 *

 * On success, it returns the file descriptor. On failure it returns -1.

 * If there is a failure, it prints the error to stderr.

/**

 * get_cgroup_id() - Get cgroup id for a particular cgroup path

 * @path: The cgroup path, relative to the workdir, to join

 *

 * On success, it returns the cgroup id. On failure it returns 0,

 * which is an invalid cgroup id.

 * If there is a failure, it prints the error to stderr.

/**

 * setup_classid_environment() - Setup the cgroupv1 net_cls environment

 *

 * After calling this function, cleanup_classid_environment should be called

 * once testing is complete.

 *

 * This function will print an error to stderr and return 1 if it is unable

 * to setup the cgroup environment. If setup is successful, 0 is returned.

/**

 * set_classid() - Set a cgroupv1 net_cls classid

 * @id: the numeric classid

 *

 * Writes the passed classid into the cgroup work dir's net_cls.classid

 * file in order to later on trigger socket tagging.

 *

 * On success, it returns 0, otherwise on failure it returns 1. If there

 * is a failure, it prints the error to stderr.

/**

 * join_classid() - Join a cgroupv1 net_cls classid

 *

 * This function expects the cgroup work dir to be already created, as we

 * join it here. This causes the process sockets to be tagged with the given

 * net_cls classid.

 *

 * On success, it returns 0, otherwise on failure it returns 1.

/**

 * cleanup_classid_environment() - Cleanup the cgroupv1 net_cls environment

 *

 * At call time, it moves the calling process to the root cgroup, and then

 * runs the deletion process.

 *

 * On failure, it will print an error to stderr, and try to continue.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Testsuite for eBPF verifier

 *

 * Copyright (c) 2014 PLUMgrid, http://plumgrid.com

 * Copyright (c) 2017 Facebook

 * Copyright (c) 2018 Covalent IO, Inc. http://covalent.io

	/* Expected verifier log output for result REJECT or VERBOSE_ACCEPT.

	 * Can be a tab-separated sequence of expected strings. An empty string

	 * means no log verification.

/* Note we want this to be 64 bit aligned so that the end of our array is

 * actually the end of the structure.

 test: {skb->data[0], vlan_push} x 51 + {skb->data[0], vlan_pop} x 51 */

 jump range is limited to 16 bit. PUSH_CNT of ld_abs needs room */

 jump to error label */

 error label */

	/* jump range is limited to 16 bit. every ld_abs is replaced by 6 insns,

	 * but on arches like arm, ppc etc, there will be one BPF_ZEXT inserted

	 * to extend the error value of the inlined ld_abs sequence which then

	 * contains 7 insns. so, set the dividend to 7 so the testcase could

	 * work on all arches.

 test the sequence of 8k jumps */

 test to check that the long sequence of jumps is acceptable */

	/* is_state_visited() doesn't allocate state for pruning for every jump.

	 * Hence multiply jmps by 4 to accommodate that heuristic

 test the sequence of 8k jumps in inner most function (function depth 8)*/

 test to check that the long sequence of jumps is acceptable */

 main */

 subprog 1 */

 subprog 2 */

 BPF_SK_LOOKUP contains 13 instructions, if you need to fix up maps */

 struct bpf_sock_tuple tuple = {} */				\

 sk = func(ctx, &tuple, sizeof tuple, 0, 0) */		\

/* BPF_DIRECT_PKT_R2 contains 7 instructions, it initializes default return

 * value into 0 and does necessary preparation for direct packet access

 * through r2. The allowed access range is 8 bytes.

/* BPF_RAND_UEXT_R7 contains 4 instructions, it initializes R7 into a random

 * positive u32, and zero-extend it into 64-bit.

/* BPF_RAND_SEXT_R7 contains 5 instructions, it initializes R7 into a random

 * negative u32, and sign-extend it into 64-bit.

/* struct bpf_spin_lock {

 *   int val;

 * };

 * struct val {

 *   int cnt;

 *   struct bpf_spin_lock l;

 * };

 * struct bpf_timer {

 *   __u64 :64;

 *   __u64 :64;

 * } __attribute__((aligned(8)));

 * struct timer {

 *   struct bpf_timer t;

 * };

 int */

 [1] */

 struct bpf_spin_lock */                      
 int val; */

 struct val */                                
 int cnt; */

 struct bpf_spin_lock l; */

 struct bpf_timer */                          
 struct timer */                              
 struct bpf_timer t; */

	/* Allocating HTs with 1 elem is fine here, since we only test

	 * for verifier and not do a runtime lookup, so the only thing

	 * that really matters is value size in this case.

 need CAP_BPF, CAP_NET_ADMIN, CAP_PERFMON to load progs */

	/* libcap is likely old and simply ignores CAP_BPF and CAP_PERFMON,

	 * so update effective bits manually

 CAP_PERFMON */ - 32);

 CAP_BPF */ - 32);

 fallthrough; */

/* Returns true if every part of exp (tab-separated) appears in log, in order.

 *

 * If exp is an empty string, returns true.

	/* If there were some map skips during fixup due to missing bpf

	 * features, skip this test.

	/* BPF_PROG_TYPE_TRACING requires more setup and

	 * bpf_probe_prog_type won't give correct answer

 CAP_BPF */ - 32));

 CAP_PERFMON */ - 32));

	/* Some architectures have strict alignment requirements. In

	 * that case, the BPF verifier detects if a program has

	 * unaligned accesses and rejects them. A user can pass

	 * BPF_F_ANY_ALIGNMENT to a program to override this

	 * check. That, however, will only work when a privileged user

	 * loads a program. An unprivileged user loading a program

	 * with this flag will be rejected prior entering the

	 * verifier.

		/* Program types that are not supported by non-root we

		 * skip right away.

 SPDX-License-Identifier: GPL-2.0

 test ir decoder



 Copyright (C) 2018 Sean Young <sean@mess.org>

 A lirc chardev is a device representing a consumer IR (cir) device which

 can receive infrared signals from remote control and/or transmit IR.



 IR is sent as a series of pulses and space somewhat like morse code. The

 BPF program can decode this into scancodes so that rc-core can translate

 this into input key codes using the rc keymap.



 This test works by sending IR over rc-loopback, so the IR is processed by

 BPF and then decoded into scancodes. The lirc chardev must be the one

 associated with rc-loopback, see the output of ir-keytable(1).



 The following CONFIG options must be enabled for the test to succeed:

 CONFIG_RC_CORE=y

 CONFIG_BPF_RAWIR_EVENT=y

 CONFIG_RC_LOOPBACK=y

 Steps:

 1. Open the /dev/lircN device for rc-loopback (given on command line)

 2. Attach bpf_lirc_mode2 program which decodes some IR.

 3. Send some IR to the same IR device; since it is loopback, this will

    end up in the bpf program

 4. bpf program should decode IR and report keycode

 5. We can read keycode from same /dev/lirc device

 Let's try detach it before it was ever attached */

 Write raw IR */

 Read decoded IR */

 Write raw IR */

 Read decoded IR */

 Let's try detaching it now it is actually attached */

 We need a few instructions to pass the min log length */

 Test incorrect attr */

 Test with log big enough */

 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)

 Copyright (C) 2020 Facebook, Inc. */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2018 Facebook

	/* attach to this pid so the all bpf invocations will be in the

	 * cgroup associated with this pid.

 trigger some syscalls */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved. */

 use server program */

 Only supports IPv4; see hints initiailization above. */

	/* Start xdping-ing from last regular ping reply, e.g. for a count

	 * of 10 ICMP requests, we start xdping-ing using reply with seq number

	 * 10.  The reason the last "real" ping RTT is much higher is that

	 * the ping program sees the ICMP reply associated with the last

	 * XDP-generated packet, so ping doesn't get a reply until XDP is done.

 We need to wait for XDP setup to complete. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2016 Facebook

/* Size of the LRU map is 2

 * Add key=1 (+1 key)

 * Add key=2 (+1 key)

 * Lookup Key=1

 * Add Key=3

 *   => Key=2 will be removed by LRU

 * Iterate map.  Only found key=1 and key=3

 insert key=1 element */

 BPF_NOEXIST means: add new element if it doesn't exist */

 key=1 already exists */

 insert key=2 element */

 check that key=2 is not found */

 BPF_EXIST means: update existing element */

 key=2 is not there */

 insert key=3 element */

 check that key=3 is not found */

	/* check that key=1 can be found and mark the ref bit to

	 * stop LRU from removing key=1

 key=2 has been removed from the LRU */

 lookup elem key=1 and delete it, then check it doesn't exist */

 remove the same element from the expected map */

/* Size of the LRU map is 1.5*tgt_free

 * Insert 1 to tgt_free (+tgt_free keys)

 * Lookup 1 to tgt_free/2

 * Insert 1+tgt_free to 2*tgt_free (+tgt_free keys)

 * => 1+tgt_free/2 to LOCALFREE_TARGET will be removed by LRU

 This test is only applicable to common LRU list */

 Insert 1 to tgt_free (+tgt_free keys) */

 Lookup 1 to tgt_free/2 */

	/* Insert 1+tgt_free to 2*tgt_free

	 * => 1+tgt_free/2 to LOCALFREE_TARGET will be

	 * removed by LRU

/* Size of the LRU map 1.5 * tgt_free

 * Insert 1 to tgt_free (+tgt_free keys)

 * Update 1 to tgt_free/2

 *   => The original 1 to tgt_free/2 will be removed due to

 *      the LRU shrink process

 * Re-insert 1 to tgt_free/2 again and do a lookup immeidately

 * Insert 1+tgt_free to tgt_free*3/2

 * Insert 1+tgt_free*3/2 to tgt_free*5/2

 *   => Key 1+tgt_free to tgt_free*3/2

 *      will be removed from LRU because it has never

 *      been lookup and ref bit is not set

 This test is only applicable to common LRU list */

 Insert 1 to tgt_free (+tgt_free keys) */

	/* Any bpf_map_update_elem will require to acquire a new node

	 * from LRU first.

	 *

	 * The local list is running out of free nodes.

	 * It gets from the global LRU list which tries to

	 * shrink the inactive list to get tgt_free

	 * number of free nodes.

	 *

	 * Hence, the oldest key 1 to tgt_free/2

	 * are removed from the LRU list.

	/* Re-insert 1 to tgt_free/2 again and do a lookup

	 * immeidately.

 Insert 1+tgt_free to tgt_free*3/2 */

		/* These newly added but not referenced keys will be

		 * gone during the next LRU shrink.

 Insert 1+tgt_free*3/2 to  tgt_free*5/2 */

/* Size of the LRU map is 2*tgt_free

 * It is to test the active/inactive list rotation

 * Insert 1 to 2*tgt_free (+2*tgt_free keys)

 * Lookup key 1 to tgt_free*3/2

 * Add 1+2*tgt_free to tgt_free*5/2 (+tgt_free/2 keys)

 *  => key 1+tgt_free*3/2 to 2*tgt_free are removed from LRU

 This test is only applicable to common LRU list */

 Insert 1 to 2*tgt_free (+2*tgt_free keys) */

 Lookup key 1 to tgt_free*3/2 */

	/* Add 1+2*tgt_free to tgt_free*5/2

	 * (+tgt_free/2 keys)

 Test deletion */

 Ensure the last key inserted by previous CPU can be found */

 Cannot find the last key because it was removed by LRU */

 Test map with only one element */

 At least one key should be tested */

 Test list rotation for BPF_F_NO_COMMON_LRU map */

 Make ref bit sticky for key: [1, tgt_free] */

 Mark the ref bit */

/* Size of the LRU map is 2

 * Add key=1 (+1 key)

 * Add key=2 (+1 key)

 * Lookup Key=1 (datapath)

 * Lookup Key=2 (syscall)

 * Add Key=3

 *   => Key=2 will be removed by LRU

 * Iterate map.  Only found key=1 and key=3

 insert key=1 element */

 BPF_NOEXIST means: add new element if it doesn't exist */

 key=1 already exists */

 insert key=2 element */

 check that key=2 is not found */

 BPF_EXIST means: update existing element */

 key=2 is not there */

 insert key=3 element */

 check that key=3 is not found */

	/* check that key=1 can be found and mark the ref bit to

	 * stop LRU from removing key=1

	/* check that key=2 can be found and do _not_ mark ref bit.

	 * this will be evicted on next update.

 key=2 has been removed from the LRU */

/* Size of the LRU map is 2

 * Add key=1 (+1 key)

 * Add key=2 (+1 key)

 * Lookup Key=1 (syscall)

 * Lookup Key=2 (datapath)

 * Add Key=3

 *   => Key=1 will be removed by LRU

 * Iterate map.  Only found key=2 and key=3

 insert key=1 element */

 BPF_NOEXIST means: add new element if it doesn't exist */

 key=1 already exists */

 insert key=2 element */

 check that key=2 is not found */

 BPF_EXIST means: update existing element */

 key=2 is not there */

 insert key=3 element */

 check that key=3 is not found */

	/* check that key=1 can be found and do _not_ mark ref bit.

	 * this will be evicted on next update.

	/* check that key=2 can be found and mark the ref bit to

	 * stop LRU from removing key=2

 key=1 has been removed from the LRU */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2018 Facebook

 Copyright (c) 2019 Cloudflare

 SYN packets do not get passed through generic XDP, skip the

 rest of the test.

 SPDX-License-Identifier: GPL-2.0-only

/* Copyright (c) 2017 Facebook

 backtrace */

 get_nprocs */

 Adapted from perf/util/string.c */

 Check wild card */

 Tail wild card matches all */

 defined in test_progs.h */

 store counts before subtest started */

/* Override C runtime library's usleep() implementation to ensure nanosleep()

 * is always called. Usleep is frequently used in selftests as a way to

 * trigger kprobe and tracepoints.

 worker always holds log */

 exports env.log_buf & env.log_cnt */

/* A bunch of tests set custom affinity per-thread and/or per-process. Reset

 * it after each test/sub-test.

/*

 * Trigger synchronize_rcu() in kernel.

 ensure previous instance of the module is unloaded */

 extern declarations for test funcs */

 nothing to do, output to stdout by default */

 stdout and stderr -> buffer */

/*

 * Determine if test_progs is running as a "flavored" test runner and switch

 * into corresponding sub-directory to load correct BPF objects.

 *

 * This is done by looking at executable name. If it contains "-flavor"

 * suffix, then we are running as a flavored test runner.

	/* General form of argv[0] passed here is:

	 * some/path/to/test_progs[-flavor], where -flavor part is optional.

	 * First cut out "test_progs[-flavor]" part, then extract "flavor"

	 * part, if it's there.

 ensure last sub-test is finalized properly */

 grab a test */

 run test through worker */

 wait for test done */

 collect all logs */

 output log */

 wait for test done */

 while (true) */

 print error logs again */

 wait for all dispatcher to finish */

 run serial tests */

 generate summary */

 reap all workers */

 receive command */

 send logs */

 case MSG_DO_TEST */

 Use libbpf 1.0 API mode */

 initializing tests */

 ignore workers if we are just listing */

 launch workers if requested */

 main process */

 main process */

 inside each worker process */

 The rest of the main process */

 on single mode */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Copyright(c) 2020 Intel Corporation. */

/*

 * Some functions in this program are taken from

 * Linux kernel samples/bpf/xdpsock* and modified

 * for use.

 *

 * See test_xsk.sh for detailed information on test topology

 * and prerequisite network setup.

 *

 * This test program contains two threads, each thread is single socket with

 * a unique UMEM. It validates in-order packet delivery and packet content

 * by sending packets to each other.

 *

 * Tests Information:

 * ------------------

 * These selftests test AF_XDP SKB and Native/DRV modes using veth

 * Virtual Ethernet interfaces.

 *

 * For each mode, the following tests are run:

 *    a. nopoll - soft-irq processing in run-to-completion mode

 *    b. poll - using poll() syscall

 *    c. Socket Teardown

 *       Create a Tx and a Rx socket, Tx from one socket, Rx on another. Destroy

 *       both sockets, then repeat multiple times. Only nopoll mode is used

 *    d. Bi-directional sockets

 *       Configure sockets as bi-directional tx/rx sockets, sets up fill and

 *       completion rings on each socket, tx/rx in both directions. Only nopoll

 *       mode is used

 *    e. Statistics

 *       Trigger some error conditions and ensure that the appropriate statistics

 *       are incremented. Within this test, the following statistics are tested:

 *       i.   rx dropped

 *            Increase the UMEM frame headroom to a value which results in

 *            insufficient space in the rx buffer for both the packet and the headroom.

 *       ii.  tx invalid

 *            Set the 'len' field of tx descriptors to an invalid value (umem frame

 *            size + 1).

 *       iii. rx ring full

 *            Reduce the size of the RX ring to a fraction of the fill ring size.

 *       iv.  fill queue empty

 *            Do not populate the fill queue and then try to receive pkts.

 *    f. bpf_link resource persistence

 *       Configure sockets at indexes 0 and 1, run a traffic on queue ids 0,

 *       then remove xsk sockets from queue 0 on both veth interfaces and

 *       finally run a traffic on queues ids 1

 *    g. unaligned mode

 *    h. tests for invalid and corner case Tx descriptors so that the correct ones

 *       are discarded and let through, respectively.

 *    i. 2K frame size tests

 *

 * Total tests: 12

 *

 * Flow:

 * -----

 * - Single process spawns two threads: Tx and Rx

 * - Each of these two threads attach to a veth interface within their assigned

 *   namespaces

 * - Each thread Creates one AF_XDP socket connected to a unique umem for each

 *   veth interface

 * - Tx thread Transmits 10k packets from veth<xxxx> to veth<yyyy>

 * - Rx thread verifies if all 10k packets were received and delivered in-order,

 *   and have the right content

 *

 * Enable/disable packet dump mode:

 * --------------------------

 * To enable L2 - L4 headers and payload dump of each packet on STDOUT, add

 * parameter -D to params array in test_xsk.sh, i.e. params=("-S" "-D")

/*

 * Fold a partial checksum

 * This function code has been taken from

 * Linux kernel include/asm-generic/checksum.h

/*

 * This function code has been taken from

 * Linux kernel lib/checksum.c

 add up 32-bit and 32-bit for 32+c bit */

 add up carry.. */

/*

 * This function code has been taken from

 * Linux kernel lib/checksum.c

/*

 * This function has been taken from

 * Linux kernel include/asm-generic/checksum.h

 udp hdr and data */

extract L2 frame */

extract L3 frame */

extract L4 frame */

extract L5 frame */

Do not try to verify packets that are smaller than minimum size. */

 Retry if it fails as xsk_socket__create() is asynchronous */

Spawn RX thread */

Spawn TX thread */

 No or few packets will be received so cannot pace packets */

 To only see the whole stat set being completed unless an individual test fails. */

 Simple test */

 Let half of the packets straddle a buffer boundrary */

 Zero packet length at address zero allowed */

 Zero packet length allowed */

 Straddling the start of umem */

 Packet too large */

 After umem ends */

 Straddle the end of umem */

 Straddle a page boundrary */

 Straddle a 2K boundrary */

 Valid packet for synch so that something is received */

 Crossing a page boundrary allowed */

 Crossing a 2K frame size boundrary not allowed */

 reset defaults after potential previous test */

 SPDX-License-Identifier: GPL-2.0

 default, set below */

 Find ingress/egress prog for 2nd xdp prog */

 Init forward multicast groups and exclude group */

 Add all the interfaces to group all */

 bind prog_fd to each interface */

 sleep some time for testing */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 set up periodic 1-second timer */

 find next available CPU */

	/* unless explicit producer CPU list is specified, continue after

	 * last consumer CPU

 skip first sample */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Testsuite for eBPF maps

 *

 * Copyright (c) 2014 PLUMgrid, http://plumgrid.com

 * Copyright (c) 2016 Facebook

 Insert key=1 element. */

 BPF_NOEXIST means add new element if it doesn't exist. */

 key=1 already exists. */

 -1 is an invalid flag. */

 Check that key=1 can be found. */

 Insert key=2 element. */

 Check that key=2 matches the value and delete it */

 Check that key=2 is not found. */

 BPF_EXIST means update existing element. */

 key=2 is not there. */

 Insert key=2 element. */

	/* key=1 and key=2 were inserted, check that key=0 cannot be

	 * inserted due to max_entries limit.

 Update existing element, though the map is full. */

 Check that key = 0 doesn't exist. */

 Iterate over two elements. */

 Delete both elements. */

 Check that map is empty. */

 give kernel time to destroy */

 Insert key=1 element. */

 Lookup and delete elem key=1 and check value. */

 Insert key=1 element which should not exist. */

 BPF_NOEXIST means add new element if it doesn't exist. */

 key=1 already exists. */

 -1 is an invalid flag. */

	/* Check that key=1 can be found. Value could be 0 if the lookup

	 * was run from a different CPU.

 Check that key=2 is not found. */

 BPF_EXIST means update existing element. */

 key=2 is not there. */

 Insert key=2 element. */

	/* key=1 and key=2 were inserted, check that key=0 cannot be

	 * inserted due to max_entries limit.

 Check that key = 0 doesn't exist. */

 Iterate over two elements. */

 Update with BPF_EXIST. */

 Delete both elements. */

 Check that map is empty. */

 Insert key=1 element. */

 Check that key=1 can be found. */

 Check that key=0 is also found and zero initialized. */

	/* key=0 and key=1 were inserted, check that key=2 cannot be inserted

	 * due to max_entries limit.

 Check that key = 2 doesn't exist. */

 Iterate over two elements. */

 Delete shouldn't succeed. */

 Insert key=1 element. */

 Check that key=1 can be found. */

 Check that key=0 is also found and zero initialized. */

 Check that key=2 cannot be inserted due to max_entries limit. */

 Check that key = 2 doesn't exist. */

 Iterate over two elements. */

 Delete shouldn't succeed. */

	/* nr_keys is not too large otherwise the test stresses percpu

	 * allocator more than anything else

 Fill test values to be used */

 Invalid key size */

 Queue map does not support BPF_F_NO_PREALLOC */

 Push MAP_SIZE elements */

 Check that element cannot be pushed due to max_entries limit */

 Peek element */

 Replace half elements */

 Pop all elements */

 Check that there are not elements left */

 Check that non supported functions set errno to EINVAL */

 Fill test values to be used */

 Invalid key size */

 Stack map does not support BPF_F_NO_PREALLOC */

 Push MAP_SIZE elements */

 Check that element cannot be pushed due to max_entries limit */

 Peek element */

 Replace half elements */

 Pop all elements */

 Check that there are not elements left */

 Check that non supported functions set errno to EINVAL */

 Create some sockets to use with sockmap */

 Test sockmap with connected sockets */

 Test update with unsupported UDP socket */

 Test update without programs */

 Test attaching/detaching bad fds */

 Load SK_SKB program and Attach */

 Test map update elem afterwards fd lives in fd and map_fd */

 Test map delete elem and remove send/recv sockets */

 Put sfd[2] (sending fd below) into msg map to test sendmsg bpf */

 Test map send/recv */

 Negative null entry lookup from datapath should be dropped */

 Push fd into same slot */

 Delete the elems without programs */

 Test having multiple maps open and set with programs on same fds */

 Test tasks number of forked operations */

 Test map close sockets and empty maps */

 Test that failing bpf_object__create_map() destroys the inner map */

	/* Iterate over all maps to check whether the internal map

	 * ("mim.internal") has been destroyed.

 Iterate through all elements. */

	/* Use the same fd in children to add elements to this map:

	 * child_0 adds key=0, key=1024, key=2048, ...

	 * child_1 adds key=1, key=1025, key=2049, ...

	 * child_1023 adds key=1023, ...

 Check that key=0 is already there. */

 Check that all elements were inserted. */

 Another check for all elements */

 Now let's delete all elemenets in parallel. */

 Nothing should be left. */

 Try to insert key=1 element. */

 Check that key=1 is not found. */

 Insert key=1 element. */

 Check that reading elements and keys from the map is not allowed. */

 Stack/Queue maps do not support BPF_F_NO_PREALLOC */

 Peek element should fail */

 Pop element should fail */

 reuseport_array does not allow unbound sk */

			/*

			 * reuseport_array does not allow

			 * non-listening tcp sk.

 Test lookup/update/delete with invalid index */

 Test lookup/delete non existence elem */

 Test BPF_* update flags */

 BPF_EXIST failure case */

 BPF_NOEXIST success case */

 BPF_EXIST success case. */

 BPF_NOEXIST failure case */

 BPF_ANY case (always succeed) */

 The same sk cannot be added to reuseport_array twice */

 Test delete elem */

 Add it back with BPF_NOEXIST */

 Test cookie */

 Test elem removed by close() */

 Test SOCK_RAW */

 Close the 64 bit value map */

 Test 32 bit fd */

 SPDX-License-Identifier: GPL-2.0

/*

 * Inject packets with all sorts of encapsulation into the kernel.

 *

 * IPv4/IPv6	outer layer 3

 * GRE/GUE/BARE outer layer 4, where bare is IPIP/SIT/IPv4-in-IPv6/..

 * IPv4/IPv6    inner layer 3

 Add some protocol definitions that do not exist in userspace */

 optional SIT prefix */

 halfwords: twice byte len */

 halfwords: twice byte len */

 calculate header offsets */

	/*

	 * Fill packet from inside out, to calculate correct checksums.

	 * But create ip before udp headers, as udp uses ip for pseudo-sum.

 add zero byte for udp csum padding */

 sender transmits encapsulated over RAW or unencap'd over UDP */

 connect to destination if not encapsulated */

 otherwise using loopback */

 receiver reads unencapsulated UDP */

 read straggler packets, if any */

	/*

	 * success (== 0) only if received all packets

	 * unless failure is expected, in which case none must arrive.

 == 0 */

	/* RFC 6040 4.2:

	 *   on decap, if outer encountered congestion (CE == 0x3),

	 *   but inner cannot encode ECN (NoECT == 0x0), then drop packet.

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2018 Facebook

 RFC 4291, Section 2.7.1 */

 root cgroup */

 non-existent cgroup */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2018 Facebook

 BPF prog properties */

 Socket properties */

 Endpoint to bind() to */

 Expected test result */

 if (ip == expected && port == expected) */

 return DENY; */

 else return ALLOW; */

 if (ip == expected && port == expected) */

 return ALLOW; */

 else return DENY; */

		/* sys_bind() may fail for different reasons, errno has to be

		 * checked to confirm that BPF program rejected it.

 Detaching w/o checking return code: best effort attempt. */

 SPDX-License-Identifier: GPL-2.0

/*

 * Randomized tests for eBPF longest-prefix-match maps

 *

 * This program runs randomized tests against the lpm-bpf-map. It implements a

 * "Trivial Longest Prefix Match" (tlpm) based on simple, linear, singly linked

 * lists. The implementation should be pretty straightforward.

 *

 * Based on tlpm, this inserts randomized data into bpf-lpm-maps and verifies

 * the trie-based bpf-map implementation behaves the same way as tlpm.

 'overwrite' an equivalent entry if one already exists */

 add new entry with @key/@n_bits to @list and return new head */

 free all entries in @list */

	/* Perform longest prefix-match on @key/@n_bits. That is, iterate all

	 * entries and match each prefix against @key. Remember the "best"

	 * entry we find (i.e., the longest prefix that matches) and return it

	 * to the caller when done.

 should never get here */

 very basic, static tests to verify tlpm works as expected */

	/* Verify the tlpm implementation works correctly regardless of the

	 * order of entries. Insert a random set of entries into @l1, and copy

	 * the same data in reverse order into @l2. Then verify a lookup of

	 * random keys will yield the same result in both sets.

	/* Compare behavior of tlpm vs. bpf-lpm. Create a randomized set of

	 * prefixes and insert it into both tlpm and bpf-lpm. Then run some

	 * randomized lookups and verify both maps return the same result.

	/* Remove the first half of the elements in the tlpm and the

	 * corresponding nodes from the bpf-lpm.  Then run the same

	 * large number of random lookups in both and make sure they match.

	 * Note: we need to count the number of nodes actually inserted

	 * since there may have been duplicates.

	/* With 255 random nodes in the map, we are pretty likely to match

	 * something on every lookup. For statistics, use this:

	 *

	 *     printf("          nodes: %zu\n"

	 *            "        lookups: %zu\n"

	 *            "        matches: %zu\n"

	 *            "matches(delete): %zu\n",

	 *            n_nodes, n_lookups, n_matches, n_matches_after_delete);

 Test the implementation with some 'real world' examples */

 Fill data some IPv4 and IPv6 address ranges */

 Set tprefixlen to maximum for lookups */

 Test some lookups that should come back with a value */

 Test some lookups that should not match any entry */

	/* Add nodes:

	 * 192.168.0.0/16   (1)

	 * 192.168.0.0/24   (2)

	 * 192.168.128.0/24 (3)

	 * 192.168.1.0/24   (4)

	 *

	 *         (1)

	 *        /   \

         *     (IM)    (3)

	 *    /   \

         *   (2)  (4)

 remove non-existent node */

 unused prefix so far

 same prefix as the root node

 assert initial lookup */

 remove leaf node */

 remove leaf (and intermediary) node */

 remove root node */

 remove last node */

 empty tree. get_next_key should return ENOENT */

 get and verify the first key, get the second one should fail. */

 no exact matching key should get the first one in post order. */

 add one more element (total two) */

 Add one more element (total three) */

 Add one more element (total four) */

 Add one more element (total five) */

 no exact matching key should return the first one in post order */

 0: update, 1: delete, 2: lookup, 3: get_next_key */

			/* first half of iterations in forward order,

			 * and second half in backward order.

 update must succeed */

 Pass successful exit info back to the main thread

 create a trie */

 create 4 threads to test update, delete, lookup and get_next_key */

 we want predictable, pseudo random tests */

 Test with 8, 16, 24, 32, ... 128 bit prefix length */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2018 Facebook

 BPF prog properties */

 Socket properties */

 IP:port pairs for BPF prog to override */

 Expected test result */

 bind */

 connect */

 sendmsg */

 recvmsg */

 return rc */

rc*/ 1);

rc*/ 0);

rc*/ 1);

rc*/ 0);

 if (sk.family == AF_INET && */

     sk.type == SOCK_DGRAM)  { */

      msg_src_ip4 = src4_rw_ip */

      user_ip4 = dst4_rw_addr.sin_addr */

      user_port = dst4_rw_addr.sin_port */

 } */

 return 1 */

 if (sk.family == AF_INET6) { */

      user_port = dst6_rw_addr.sin6_port */

 } */

 return 1 */

cmp_port*/ 0);

cmp_port*/ 1);

cmp_port*/ 1);

set_cmsg*/0,

 Try to connect to server just in case */

 Prepare server to connect to */

 Make sure src and dst addrs were overridden properly */

 Test TCP Fast Open scenario */

 Make sure src and dst addrs were overridden properly */

 Prepare server to sendmsg to */

flags*/0,

		/* Try to receive message on server instead of using

		 * getpeername(2) on client socket, to check that client's

		 * destination address was rewritten properly, since

		 * getpeername(2) doesn't work with unconnected datagram

		 * sockets.

		 *

		 * Get source address from recvmsg(2) as well to make sure

		 * source was rewritten properly: getsockname(2) can't be used

		 * since socket is unconnected and source defined for one

		 * specific packet may differ from the one used by default and

		 * returned by getsockname(2).

cmp_port*/0))

 error was expected, reset it */

 error was expected, reset it */

 error was expected, reset it */

 Detaching w/o checking return code: best effort attempt. */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

/* Print raw BTF type dump into a local buffer and return string pointer back.

 * Buffer *will* be overwritten by subsequent btf_type_raw_dump() calls

/* Print BTF-to-C dump into a local buffer and return string pointer back.

 * Buffer *will* be overwritten by subsequent btf_type_raw_dump() calls

 SPDX-License-Identifier: GPL-2.0

 percpu map fd */

 flags, not used */

 map fd */

 flags, not used */

 Attach the bpf program */

 Every second packet should be dropped */

 Check the counter in the cgroup local storage */

 Bump the counter in the cgroup local storage */

 Every second packet should be dropped */

 Check the final value of the counter in the cgroup local storage */

 Check the final value of the counter in the percpu local storage */

 SPDX-License-Identifier: GPL-2.0-only

/* Copyright (c) 2017 Facebook

 Attach bpf program */

	/* All operations with /dev/zero and and /dev/urandom are allowed,

	 * everything else is forbidden.

 /dev/zero is whitelisted */

 src is allowed, target is forbidden */

 src is forbidden, target is allowed */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook

 If (write) */

 return DENY; */

 else return ALLOW; */

 If (write) */

 return DENY; */

 else return ALLOW; */

 same as default, should fail anyway */

 u64 w = (u16)write & 1; */

 return 1 - w; */

 same as default, should fail anyway */

 write = X */

 If (file_pos == X) */

 return ALLOW; */

 else return DENY; */

 If (file_pos == X) */

 return ALLOW; */

 else return DENY; */

 file_pos = X */

 sysctl_get_name arg2 (buf) */

 sysctl_get_name arg3 (buf_len) */

 sysctl_get_name arg4 (flags) */

 sysctl_get_name(ctx, buf, buf_len, flags) */

 if (ret == expected && */

     buf == "tcp_mem\0") */

 return ALLOW; */

 else return DENY; */

 sysctl_get_name arg2 (buf) */

 sysctl_get_name arg3 (buf_len) too small */

 sysctl_get_name arg4 (flags) */

 sysctl_get_name(ctx, buf, buf_len, flags) */

 if (ret == expected && */

     buf[0:7] == "tcp_me\0") */

 return ALLOW; */

 else return DENY; */

 sysctl_get_name arg2 (buf) */

 sysctl_get_name arg3 (buf_len) */

 sysctl_get_name arg4 (flags) */

 sysctl_get_name(ctx, buf, buf_len, flags) */

 if (ret == expected && */

     buf[0:8] == "net/ipv4" && */

     buf[8:16] == "/tcp_mem" && */

     buf[16:24] == "\0") */

 return ALLOW; */

 else return DENY; */

 sysctl_get_name arg2 (buf) */

 sysctl_get_name arg3 (buf_len) */

 sysctl_get_name arg4 (flags) */

 sysctl_get_name(ctx, buf, buf_len, flags) */

 if (ret == expected && */

     buf[0:8] == "net/ipv4" && */

     buf[8:16] == "/tcp_me\0") */

 return ALLOW; */

 else return DENY; */

 sysctl_get_name arg2 (buf) */

 sysctl_get_name arg3 (buf_len) */

 sysctl_get_name arg4 (flags) */

 sysctl_get_name(ctx, buf, buf_len, flags) */

 if (ret == expected && */

     buf[0:8] == "net/ip\0") */

 return ALLOW; */

 else return DENY; */

 sysctl_get_current_value arg2 (buf) */

 sysctl_get_current_value arg3 (buf_len) */

 sysctl_get_current_value(ctx, buf, buf_len) */

 if (ret == expected && */

     buf[0:6] == "Linux\n\0") */

 return ALLOW; */

 else return DENY; */

 sysctl_get_current_value arg2 (buf) */

 sysctl_get_current_value arg3 (buf_len) */

 sysctl_get_current_value(ctx, buf, buf_len) */

 if (ret == expected && */

     buf[0:6] == "Linux\n\0") */

 return ALLOW; */

 else return DENY; */

 sysctl_get_current_value arg2 (buf) */

 sysctl_get_current_value arg3 (buf_len) */

 sysctl_get_current_value(ctx, buf, buf_len) */

 if (ret == expected && */

     buf[0:6] == "Linux\0") */

 return ALLOW; */

 else return DENY; */

 sysctl_get_current_value arg2 (buf) */

 sysctl_get_current_value arg3 (buf_len) */

 sysctl_get_current_value(ctx, buf, buf_len) */

 if (ret == expected && */

     buf[0:8] is NUL-filled) */

 return DENY; */

 else return ALLOW; */

 -EIO */

 sysctl_get_current_value arg2 (buf) */

 sysctl_get_current_value arg3 (buf_len) */

 sysctl_get_current_value(ctx, buf, buf_len) */

 if (ret == expected && */

     buf[0:4] == expected) */

 return DENY; */

 else return ALLOW; */

 same as default, should fail anyway */

 sysctl_get_new_value arg2 (buf) */

 sysctl_get_new_value arg3 (buf_len) */

 sysctl_get_new_value(ctx, buf, buf_len) */

 if (ret == expected) */

 return ALLOW; */

 else return DENY; */

 sysctl_get_new_value arg2 (buf) */

 sysctl_get_new_value arg3 (buf_len) */

 sysctl_get_new_value(ctx, buf, buf_len) */

 if (ret == expected && */

     buf[0:4] == "606\0") */

 return DENY; */

 else return ALLOW; */

 sysctl_get_new_value arg2 (buf) */

 sysctl_get_new_value arg3 (buf_len) */

 sysctl_get_new_value(ctx, buf, buf_len) */

 if (ret == expected && */

     buf[0:8] == "3000000 " && */

     buf[8:16] == "4000000 " && */

     buf[16:24] == "6000000\0") */

 return DENY; */

 else return ALLOW; */

 sysctl_get_new_value arg2 (buf) */

 sysctl_get_new_value arg3 (buf_len) */

 sysctl_get_new_value(ctx, buf, buf_len) */

 if (ret == expected && */

     buf[0:3] == "60\0") */

 return DENY; */

 else return ALLOW; */

 sysctl_set_new_value arg2 (buf) */

 sysctl_set_new_value arg3 (buf_len) */

 sysctl_set_new_value(ctx, buf, buf_len) */

 if (ret == expected) */

 return ALLOW; */

 else return DENY; */

 sysctl_set_new_value arg2 (buf) */

 sysctl_set_new_value arg3 (buf_len) */

 sysctl_set_new_value(ctx, buf, buf_len) */

 if (ret == expected) */

 return ALLOW; */

 else return DENY; */

 arg1 (buf) */

 arg2 (buf_len) */

 arg3 (flags) */

 arg4 (res) */

 if (ret == expected && */

     res == expected) */

 return ALLOW; */

 else return DENY; */

 arg1 (buf) */

 "600 602\0" */

 arg2 (buf_len) */

 arg3 (flags) */

 arg4 (res) */

 if (ret == expected && */

     res == expected) */

     arg1 (buf) */

     arg2 (buf_len) */

     arg3 (flags) */

     arg4 (res) */

     if (ret == expected && */

         res == expected) */

 return ALLOW; */

 else return DENY; */

 arg1 (buf) */

 arg2 (buf_len) */

 arg3 (flags) */

 arg4 (res) */

 arg1 (buf) */

 arg2 (buf_len) */

 arg3 (flags) */

 arg4 (res) */

 if (ret == expected && */

     res == expected) */

 return ALLOW; */

 else return DENY; */

 arg1 (buf) */

 arg2 (buf_len) */

 arg3 (flags) */

 arg4 (res) */

 if (ret == expected) */

 return ALLOW; */

 else return DENY; */

 arg1 (buf) */

 arg2 (buf_len) */

 arg3 (flags) */

 arg4 (res) */

 if (ret == expected) */

 return ALLOW; */

 else return DENY; */

 arg1 (buf) */

 " -6\0" */

 arg2 (buf_len) */

 arg3 (flags) */

 arg4 (res) */

 if (ret == expected) */

 return ALLOW; */

 else return DENY; */

 arg1 (buf) */

 " -6\0" */

 arg2 (buf_len) */

 arg3 (flags) */

 arg4 (res) */

 if (ret == expected && */

     res == expected) */

 return ALLOW; */

 else return DENY; */

 arg1 (buf) */

 "0xfe" */

 arg2 (buf_len) */

 arg3 (flags) */

 arg4 (res) */

 if (ret == expected && */

     res == expected) */

 return ALLOW; */

 else return DENY; */

 arg1 (buf) 9223372036854775807 */

 arg2 (buf_len) */

 arg3 (flags) */

 arg4 (res) */

 if (ret == expected && */

     res == expected) */

 return ALLOW; */

 else return DENY; */

 arg1 (buf) 9223372036854775808 */

 arg2 (buf_len) */

 arg3 (flags) */

 arg4 (res) */

 if (ret == expected) */

 return ALLOW; */

 else return DENY; */

 Detaching w/o checking return code: best effort attempt. */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 COUNT-GLOBAL benchmark */

 COUNT-local benchmark */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 BPF triggering benchmarks */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 per-ringbuf, in bytes */

 use slower output API */

 per-CPU size, in pages */

 exported into benchmark runner */

 RINGBUF-LIBBPF benchmark */

 initial batch to get everything started */

 record data + header take 16 bytes */

 RINGBUF-CUSTOM benchmark */

 Map writable consumer page */

 Map read-only producer page and data pages. */

 clear out top 2 bits */

 add length prefix */

 round up to 8 byte alignment */

 sample not committed yet, bail out for now */

 PERFBUF-LIBBPF benchmark */

 notify only every Nth sample */

 PERFBUF-CUSTOM benchmark */

 copies of internal libbpf definitions */

 mmap()'ed memory */

 for reconstructing segmented data */

 passed into callbacks */

 number of allocated CPU buffers */

 perf event FD */

 BPF_MAP_TYPE_PERF_EVENT_ARRAY BPF map FD */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 BPF triggering benchmarks */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 exported into benchmark runner */

		/* Populate hashmap, bloom filter map, and array map with the same

		 * random values

 Resize number of entries */

 Set value size */

 For the hashmap, we use the value as the key as well */

 Set number of hash functions */

 Load pointer to map. */

 Copy R10 to R9. */

 Pollute other registers with unaligned values. */

 Store both R9 and R10 with BPF_B and read back. */

 Should read back as same value. */

 val = 0x110; */

 atomic_xor(&val, 0x011); */

 if (val != 0x101) exit(2); */

 r1 should not be clobbered, no BPF_FETCH flag */

 val = 0x110; */

 old = atomic_fetch_xor(&val, 0x011); */

 if (old != 0x110) exit(3); */

 if (val != 0x101) exit(2); */

 Check R0 wasn't clobbered (fxor fear of x86 JIT bug) */

 exit(0); */

 r0 = (s64) -1 */

 val = 0x110; */

 old = atomic_fetch_xor(&val, 0x011); */

 if (old != 0x110) exit(3); */

 if (val != 0x101) exit(2); */

		/* Check R0 wasn't clobbered (fxor fear of x86 JIT bug)

		 * It should be -1 so add 1 to get exit code.

 struct bpf_sock *sock = bpf_sock_lookup(...); */

 u64 foo; */

 void *target = &foo; */

 if (skb == NULL) *target = sock; */

 else *target = skb; */

 struct __sk_buff *skb = *target; */

 skb->mark = 42; */

 if (sk) bpf_sk_release(sk) */

 struct bpf_sock *sock = bpf_sock_lookup(...); */

 u64 foo; */

 void *target = &foo; */

 if (skb == NULL) *target = sock; */

 else *target = skb; */

 struct __sk_buff *skb = *target; */

 skb->mark = 42; */

.errstr = "same insn cannot be used with different pointers",

 struct bpf_sock *sock = bpf_sock_lookup(...); */

 u64 foo; */

 void *target = &foo; */

 if (skb) *target = skb */

 else *target = sock */

 struct bpf_sock *sk = *target; */

 if (sk) u32 foo = sk->mark; bpf_sk_release(sk); */

 struct bpf_sock *sock = bpf_sock_lookup(...); */

 u64 foo; */

 void *target = &foo; */

 if (skb) *target = skb */

 else *target = sock */

 struct bpf_sock *sk = *target; */

 if (sk) sk->mark = 42; bpf_sk_release(sk); */

.errstr = "same insn cannot be used with different pointers",

 Write 3 to stack */

 Put a 1 in R1, add it to the 3 on the stack, and load the value back into R1 */

 Check the value we loaded back was 3 */

 Load value from stack */

 Check value loaded from stack was 4 */

 Write 3 to stack */

 Put a 1 in R1, add it to the 3 on the stack, and load the value back into R1 */

 Check the value we loaded back was 3 */

 Load value from stack */

 Check value loaded from stack was 4 */

	/* It happens that the address leak check is first, but it would also be

	 * complain about the fact that we're trying to modify R10.

	/* It happens that the address leak check is first, but it would also be

	 * complain about the fact that we're trying to modify R10.

		/* This is an fentry prog, context is array of the args of the

		 * kernel function being called. Load first arg into R2.

		/* First arg of bpf_fentry_test7 is a pointer to a struct.

		 * Attempt to modify that struct. Verifier shouldn't let us

		 * because it's kernel memory.

 Done */

 main prog */

 subprog 1 */

 subprog 2 */

 main prog */

 subprog 1 */

 subprog 2 */

 val = 0x110; */

 atomic_or(&val, 0x011); */

 if (val != 0x111) exit(2); */

 r1 should not be clobbered, no BPF_FETCH flag */

 val = 0x110; */

 old = atomic_fetch_or(&val, 0x011); */

 if (old != 0x110) exit(3); */

 if (val != 0x111) exit(2); */

 Check R0 wasn't clobbered (for fear of x86 JIT bug) */

 exit(0); */

 r0 = (s64) -1 */

 val = 0x110; */

 old = atomic_fetch_or(&val, 0x011); */

 if (old != 0x110) exit(3); */

 if (val != 0x111) exit(2); */

		/* Check R0 wasn't clobbered (for fear of x86 JIT bug)

		 * It should be -1 so add 1 to get exit code.

 r1 = U64_MAX; */

 u64 val = r1; */

 r1 = (u32)atomic_fetch_or((u32 *)&val, 2); */

 r2 = 0x00000000FFFFFFFF; */

 if (r2 != r1) exit(1); */

 exit(0); */

 If this gets ever changed, make sure JITs can deal with it. */

 spill R1(ctx) into stack */

 fill it back into R2 */

 should be able to access R0 = *(R2 + 8) */

 BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_2, 8), */

 reserve 8 byte ringbuf memory */

 store a pointer to the reserved memory in R6 */

 check whether the reservation was successful */

 spill R6(mem) into the stack */

 fill it back in R7 */

 should be able to access *(R7) = 0 */

 submit the reserved ringbuf memory */

 spill R1(ctx) into stack */

 mess up with R1 pointer on stack */

	/* fill back into R0 is fine for priv.

	 * R0 now becomes SCALAR_VALUE.

 Load from R0 should fail. */

 r4 = 20 */

 *(u32 *)(r10 -8) = r4 */

 r4 = *(u32 *)(r10 -8) */

 r0 = r2 */

 r0 += r4 R0=pkt R2=pkt R3=pkt_end R4=inv20 */

 if (r0 > r3) R0=pkt,off=20 R2=pkt R3=pkt_end R4=inv20 */

 r0 = *(u32 *)r2 R0=pkt,off=20,r=20 R2=pkt,r=20 R3=pkt_end R4=inv20 */

 r4 = 20 */

 *(u32 *)(r10 -8) = r4 */

 r4 = *(u32 *)(r10 -4) fp-8=????rrrr*/

 r4 = 20 */

 *(u32 *)(r10 -8) = r4 */

 r4 = *(u16 *)(r10 -8) */

 r0 = r2 */

 r0 += r4 R0=pkt R2=pkt R3=pkt_end R4=inv,umax=65535 */

 if (r0 > r3) R0=pkt,umax=65535 R2=pkt R3=pkt_end R4=inv,umax=65535 */

 r0 = *(u32 *)r2 R0=pkt,umax=65535 R2=pkt R3=pkt_end R4=inv20 */

 r4 = 20 */

 *(u32 *)(r10 -8) = r4 */

 r4 = *(u16 *)(r10 -6) */

 r0 = r2 */

 r0 += r4 R0=pkt R2=pkt R3=pkt_end R4=inv,umax=65535 */

 if (r0 > r3) R0=pkt,umax=65535 R2=pkt R3=pkt_end R4=inv,umax=65535 */

 r0 = *(u32 *)r2 R0=pkt,umax=65535 R2=pkt R3=pkt_end R4=inv20 */

 r4 = 20 */

 *(u32 *)(r10 -8) = r4 */

 *(u32 *)(r10 -4) = r4 */

 r4 = *(u32 *)(r10 -4),  */

 r0 = r2 */

 r0 += r4 R0=pkt R2=pkt R3=pkt_end R4=inv,umax=U32_MAX */

 if (r0 > r3) R0=pkt,umax=U32_MAX R2=pkt R3=pkt_end R4=inv */

 r0 = *(u32 *)r2 R0=pkt,umax=U32_MAX R2=pkt R3=pkt_end R4=inv */

 *(u32 *)(r10 -8) = r4 R4=inv,umax=40 */

 r4 = (*u32 *)(r10 - 8) */

 r2 += r4 R2=pkt R4=inv,umax=40 */

 r0 = r2 R2=pkt,umax=40 R4=inv,umax=40 */

 r2 += 20 R0=pkt,umax=40 R2=pkt,umax=40 */

 if (r2 > r3) R0=pkt,umax=40 R2=pkt,off=20,umax=40 */

 r0 = *(u32 *)r0 R0=pkt,r=20,umax=40 R2=pkt,off=20,r=20,umax=40 */

 r4 = 4321 */

 *(u32 *)(r10 -4) = r4 */

 *(u32 *)(r10 -8) = r4 */

 r4 = *(u64 *)(r10 -8) */

 a = 0; */

		/*

		 * Note this is implemented with two separate instructions,

		 * where you might think one would suffice:

		 *

		 * BPF_ST_MEM(BPF_DW, BPF_REG_10, -8, 0),

		 *

		 * This is because BPF_ST_MEM doesn't seem to set the stack slot

		 * type to 0 when storing an immediate.

 b = atomic_fetch_add(&a, 1); */

 Verifier should be able to tell that this infinite loop isn't reachable. */

 if (b) while (true) continue; */

 ultimate return value */,

 Check bounds are OK

 Check bounds are OK

 bpf_strtoul arg1 (buf) */

 bpf_strtoul arg2 (buf_len) */

 bpf_strtoul arg3 (flags) */

 bpf_strtoul arg4 (res) */

 bpf_strtoul() */

 bpf_strtoul arg1 (buf) */

 bpf_strtoul arg2 (buf_len) */

 bpf_strtoul arg3 (flags) */

 bpf_strtoul arg4 (res) */

 bpf_strtoul() */

 bpf_strtoul arg1 (buf) */

 bpf_strtoul arg2 (buf_len) */

 bpf_strtoul arg3 (flags) */

 bpf_strtoul arg4 (res) */

 bpf_strtoul() */

 bpf_strtoul arg1 (buf) */

 bpf_strtoul arg2 (buf_len) */

 bpf_strtoul arg3 (flags) */

 bpf_strtoul arg4 (res) */

 bpf_strtoul() */

 bpf_strtoul arg1 (buf) */

 bpf_strtoul arg2 (buf_len) */

 bpf_strtoul arg3 (flags) */

 bpf_strtoul arg4 (res) */

 bpf_strtoul() */

	/* clear_all_pkt_pointers() has to walk all frames

	 * to make sure that pkt pointers in the caller

	 * are cleared when callee is calling a helper that

	 * adjusts packet size

 main prog */

 subprog 1 */

 write into stack frame of main prog */

 subprog 2 */

 read from stack frame of main prog */

 prog 1 */

 prog 2 */

 prog 1 */

 prog 2 */

 main */

 call A */

 call B */

 A */

 B */

 call A */

	/* stack_main=32, stack_A=256, stack_B=64

	 * and max(main+A, main+A+B) < 512

 main */

 call A */

 call B */

 A */

 B */

 call A */

	/* stack_main=32, stack_A=64, stack_B=256

	 * and max(main+A, main+A+B) < 512

 main */

 call A */

 call B */

 A */

 B */

 call A */

	/* stack_main=64, stack_A=224, stack_B=256

	 * and max(main+A, main+A+B) > 512

	/* void main(void) {

	 *   func1(0);

	 *   func1(1);

	 *   func2(1);

	 * }

	 * void func1(int alloc_or_recurse) {

	 *   if (alloc_or_recurse) {

	 *     frame_pointer[-300] = 1;

	 *   } else {

	 *     func2(alloc_or_recurse);

	 *   }

	 * }

	 * void func2(int alloc_or_recurse) {

	 *   if (alloc_or_recurse) {

	 *     frame_pointer[-300] = 1;

	 *   }

	 * }

 main */

 call A */

 call A */

 call B */

 A */

 call B */

 B */

 main */

 call A */

 A */

 call B */

 B */

 call C */

 C */

 call D */

 D */

 call E */

 E */

 call F */

 F */

 call G */

 G */

 call H */

 H */

 main */

 call A */

 A */

 call B */

 B */

 call C */

 C */

 call D */

 D */

 call E */

 E */

 call F */

 F */

 call G */

 G */

 call H */

 H */

 main prog */

 subprog 1 */

 subprog 2 */

 write into stack frame of main prog */

 void return */

 main prog */

 pass fp-16, fp-8 into a function */

 fetch map_value_ptr from the stack of this function */

 write into map value */

 fetch secound map_value_ptr from the stack */

 write into map value */

 subprog 1 */

 call 3rd function twice */

 first time with fp-8 */

 second time with fp-16 */

 subprog 2 */

 lookup from map */

 write map_value_ptr into stack frame of main prog */

 return 0 */

 main prog */

 pass fp-16, fp-8 into a function */

 subprog 1 */

 call 3rd function twice */

 first time with fp-8 */

 fetch map_value_ptr from the stack of this function */

 write into map value */

 second time with fp-16 */

 fetch secound map_value_ptr from the stack */

 write into map value */

 subprog 2 */

 lookup from map */

 return 0 */

 write map_value_ptr into stack frame of main prog */

 return 1 */

 main prog */

 pass fp-16, fp-8 into a function */

 subprog 1 */

 call 3rd function twice */

 first time with fp-8 */

 fetch map_value_ptr from the stack of this function */

 write into map value */

 second time with fp-16 */

 fetch secound map_value_ptr from the stack */

 write into map value */

 subprog 2 */

 lookup from map */

 return 0 */

 write map_value_ptr into stack frame of main prog */

 return 1 */

 main prog */

 pass fp-16, fp-8 into a function */

 subprog 1 */

 1st lookup from map */

 write map_value_ptr into stack frame of main prog at fp-8 */

 2nd lookup from map */

 20 */

 24 */

 write map_value_ptr into stack frame of main prog at fp-16 */

 call 3rd func with fp-8, 0|1, fp-16, 0|1 */

 30 */

 34 */

 subprog 2 */

 if arg2 == 1 do *arg1 = 0 */

 fetch map_value_ptr from the stack of this function */

 write into map value */

 if arg4 == 1 do *arg3 = 0 */

 fetch map_value_ptr from the stack of this function */

 write into map value */

 main prog */

 pass fp-16, fp-8 into a function */

 subprog 1 */

 1st lookup from map */

 write map_value_ptr into stack frame of main prog at fp-8 */

 2nd lookup from map */

 20 */

 24 */

 write map_value_ptr into stack frame of main prog at fp-16 */

 call 3rd func with fp-8, 0|1, fp-16, 0|1 */

 30 */

 34 */

 subprog 2 */

 if arg2 == 1 do *arg1 = 0 */

 fetch map_value_ptr from the stack of this function */

 write into map value */

 if arg4 == 1 do *arg3 = 0 */

 fetch map_value_ptr from the stack of this function */

 write into map value */

 main prog */

 pass fp-16, fp-8 into a function */

 subprog 1 */

 1st lookup from map */

 write map_value_ptr into stack frame of main prog at fp-8 */

 2nd lookup from map */

 26

 write map_value_ptr into stack frame of main prog at fp-16 */

 call 3rd func with fp-8, 0|1, fp-16, 0|1 */

 30

 34

 subprog 2 */

 if arg2 == 1 do *arg1 = 0 */

 fetch map_value_ptr from the stack of this function */

 write into map value */

 if arg4 == 1 do *arg3 = 0 */

 fetch map_value_ptr from the stack of this function */

 write into map value */

 main prog */

 pass fp-16, fp-8 into a function */

 subprog 1 */

 1st lookup from map */

 write map_value_ptr_or_null into stack frame of main prog at fp-8 */

 2nd lookup from map */

 write map_value_ptr_or_null into stack frame of main prog at fp-16 */

 call 3rd func with fp-8, 0|1, fp-16, 0|1 */

 subprog 2 */

 if arg2 == 1 do *arg1 = 0 */

 fetch map_value_ptr from the stack of this function */

 write into map value */

 if arg4 == 1 do *arg3 = 0 */

 fetch map_value_ptr from the stack of this function */

 write into map value */

 main prog */

 pass fp-16, fp-8 into a function */

 subprog 1 */

 1st lookup from map */

 write map_value_ptr_or_null into stack frame of main prog at fp-8 */

 2nd lookup from map */

 write map_value_ptr_or_null into stack frame of main prog at fp-16 */

 call 3rd func with fp-8, 0|1, fp-16, 0|1 */

 subprog 2 */

 if arg2 == 1 do *arg1 = 0 */

 fetch map_value_ptr from the stack of this function */

 write into map value */

 if arg4 == 0 do *arg3 = 0 */

 fetch map_value_ptr from the stack of this function */

 write into map value */

 subprog 1 */

 spill unchecked pkt_ptr into stack of caller */

 now the pkt range is verified, read pkt_ptr from stack */

 write 4 bytes into packet */

 Marking is still kept, but not in all cases safe. */

 subprog 1 */

 spill unchecked pkt_ptr into stack of caller */

 now the pkt range is verified, read pkt_ptr from stack */

 write 4 bytes into packet */

 Marking is still kept and safe here. */

 subprog 1 */

 spill unchecked pkt_ptr into stack of caller */

 now the pkt range is verified, read pkt_ptr from stack */

 write 4 bytes into packet */

 Check marking propagated. */

 subprog 1 */

 spill unchecked pkt_ptr into stack of caller */

 don't read back pkt_ptr from stack here */

 write 4 bytes into packet */

 subprog 1 */

 spill checked pkt_ptr into stack of caller */

 don't read back pkt_ptr from stack here */

 write 4 bytes into packet */

 subprog 1 */

 spill checked pkt_ptr into stack of caller */

 don't read back pkt_ptr from stack here */

 write 4 bytes into packet */

 subprog 1 */

 spill checked pkt_ptr into stack of caller */

 don't read back pkt_ptr from stack here */

 write 4 bytes into packet */

 subprog 1 */

 spill checked pkt_ptr into stack of caller */

 don't read back pkt_ptr from stack here */

 write 4 bytes into packet */

 subprog 1 */

 spill unchecked pkt_ptr into stack of caller */

 don't read back pkt_ptr from stack here */

 write 4 bytes into packet */

 fetch map_value_or_null or const_zero from stack */

 store into map_value */

 subprog 1 */

 if (ctx == 0) return; */

 else bpf_map_lookup() and *(fp - 8) = r0 */

 write map_value_ptr_or_null into stack frame of main prog at fp-8 */

 first make allocated_stack 16 byte */

	/* now fork the execution such that the false branch

	 * of JGT insn will be verified second and it skisp zero

	 * init of fp-8 stack slot. If stack liveness marking

	 * is missing live_read marks from call map_lookup

	 * processing then pruning will incorrectly assume

	 * that fp-8 stack slot was unused in the fall-through

	 * branch and will accept the program incorrectly

	/* r8 = !!random();

	 * call pruner()

	 * if (r8)

	 *     do something bad;

 because max wasn't checked, signed min is negative */

 csum_diff of 64-byte packet */,

/* Just make sure that JITs used udiv/umod as otherwise we get

 * an exception from INT_MIN/-1 overflow similarly as with div

 * by zero.

 Get an unknown value */

 Make it small and 4-byte aligned */

	/* add it to skb.  We now have either &skb->len or

	 * &skb->pkt_type, but we don't know which

 dereference it */

 Fill the top 8 bytes of the stack */

 Get an unknown value */

 Make it small and 4-byte aligned */

	/* add it to fp.  We now have either fp-4 or fp-8, but

	 * we don't know which

 dereference it for a stack read */

 Get an unknown value */

 Make it small and 4-byte aligned */

	/* add it to fp.  We now have either fp-4 or fp-8, but

	 * we don't know which

 dereference it for a stack read */

 Get an unknown value */

 Make it small and 8-byte aligned */

	/* Add it to fp.  We now have either fp-8 or fp-16, but

	 * we don't know which

 Dereference it for a stack write */

	/* Now read from the address we just wrote. This shows

	 * that, after a variable-offset write, a priviledged

	 * program can read the slots that were in the range of

	 * that write (even if the verifier doesn't actually know

	 * if the slot being read was really written to or not.

	/* Variable stack access is rejected for unprivileged.

	/* Dummy instruction; needed because we need to patch the next one

	 * and we can't patch the first instruction.

 Make R0 a map ptr */

 Get an unknown value */

 Make it small and 8-byte aligned */

	/* Add it to fp. We now have either fp-8 or fp-16, but

	 * we don't know which.

 Spill R0(map ptr) into stack */

 Dereference the unknown value for a stack write */

 Fill the register back into R2 */

 Try to dereference R2 for a memory load */

	/* The unpriviledged case is not too interesting; variable

	 * stack access is rejected.

	/* In the priviledged case, dereferencing a spilled-and-then-filled

	 * register is rejected because the previous variable offset stack

	 * write might have overwritten the spilled pointer (i.e. we lose track

	 * of the spilled register when we analyze the write).

 Fill the top 16 bytes of the stack. */

 Get an unknown value. */

 Check the lower bound but don't check the upper one. */

	/* Point the lower bound to initialized stack. Offset is now in range

	 * from fp-16 to fp+0x7fffffffffffffef, i.e. max value is unbounded.

 Dereference it indirectly. */

 Fill the top 8 bytes of the stack */

 Get an unknown value */

 Make it small and 4-byte aligned */

	/* add it to fp.  We now have either fp-4 or fp-8, but

	 * we don't know which

 dereference it indirectly */

 Fill the top 8 bytes of the stack */

 Get an unknown value */

 Make it small and 4-byte aligned */

	/* add it to fp.  We now have either fp-516 or fp-512, but

	 * we don't know which

 dereference it indirectly */

 Fill only the second from top 8 bytes of the stack. */

 Get an unknown value. */

 Make it small and 4-byte aligned. */

	/* Add it to fp.  We now have either fp-12 or fp-16, but we don't know

	 * which. fp-12 size 8 is partially uninitialized stack.

 Dereference it indirectly. */

 Fill only the top 8 bytes of the stack. */

 Get an unknown value */

 Make it small and 4-byte aligned. */

	/* Add it to fp.  We now have either fp-12 or fp-16, but we don't know

	 * which. fp-16 size 8 is partially uninitialized stack.

 Dereference it indirectly. */

 Fill the top 16 bytes of the stack. */

 Get an unknown value. */

 Make it small and 4-byte aligned. */

	/* Add it to fp.  We now have either fp-12 or fp-16, we don't know

	 * which, but either way it points to initialized stack.

 Dereference it indirectly. */

 Fill the top 16 bytes of the stack. */

 Get an unknown value. */

 Make it small and 4-byte aligned. */

	/* Add it to fp.  We now have either fp-12 or fp-16, we don't know

	 * which, but either way it points to initialized stack.

 Dereference it indirectly. */

 Fill the top 16 bytes of the stack. */

 Get an unknown value. */

 Make it small and 4-byte aligned. */

	/* Add it to fp.  We now have either fp-12 or fp-16, we don't know

	 * which, but either way it points to initialized stack.

 Dereference it indirectly. */

 r0 has upper bound that should propagate into r2 */

 spill r2 */

 clear r0 and r2 */

 fill r3 */

 r3 has lower and upper bounds */

 r0 has upper bound that should propagate into r2 */

 spill r2 */

 clear r0 and r2 */

 fill r3 */

 r3 has lower and upper bounds */

 spill r0 */

 The verifier will walk the rest twice with r0 == 0 and r0 == map_value */

 The verifier will walk the rest two more times with r0 == 20 and r0 == unknown */

 fill r3 with map_value */

 skip ldx if map_value == NULL */

 Buggy verifier will think that r3 == 20 here */

 read from map_value */

 val = 3; */

 old = atomic_xchg(&val, 4); */

 if (old != 3) exit(1); */

 if (val != 4) exit(2); */

 exit(0); */

 val = 3; */

 old = atomic_xchg(&val, 4); */

 if (old != 3) exit(1); */

 if (val != 4) exit(2); */

 exit(0); */

 map_value_ptr -= map_value_ptr */

 R2=inv(umin=1, umax=8) */

 map_value_ptr -= map_value_ptr */

 R2=inv(umin=1, umax=8) */

 Get an unknown value */

 branch conditions teach us nothing about R2 */

  0. r2 = *(u32 *)(r1 + data_end)

  1. r4 = *(u32 *)(r1 + data)

  2. r3 = r4

  3. r3 += 42

  4. r1 = 0

  5. if r3 > r2 goto 8

  6. r4 += 14

  7. r1 = r4

  8. if r3 > r2 goto 10

  9. r2 = *(u8 *)(r1 + 9)

 10. r0 = 0

 11. exit

  0. r2 = *(u32 *)(r1 + data_end)

  1. r4 = *(u32 *)(r1 + data)

  2. r3 = r4

  3. r3 += 42

  4. r1 = 0

  5. if r3 > r2 goto 8

  6. r4 += 14

  7. r1 = r4

  8. if r2 < r3 goto 10

  9. r2 = *(u8 *)(r1 + 9)

 10. r0 = 0

 11. exit

 Dead branch. */

 user_ip6[0] is u64 aligned */

 msg_src_ip6[0] is _not_ u64 aligned */

 user_ip6[0] is u64 aligned */

 msg_src_ip6[0] is _not_ u64 aligned */

 Call to skb_load_bytes() omitted. */

 reg, bit 63 or bit 0 set, taken */

 reg, bit 62, not taken */

 imm, any bit set, taken */

 imm, bit 31 set, taken */

 all good - return r0 == 2 */

 r2 = 0x0000'0000'ffff'ffff */

 r2 = 0 */

 no-op */

 access at offset 0 */

 exit */

 r2 = 0xffff'ffff'ffff'ffff */

 r2 = 0xffff'ffff */

 r0 = <oob pointer> */

 access to OOB pointer */

 exit */

 r2 = 0xffff'ffff'ffff'ffff */

 r2 = 0xfff'ffff */

 r0 = <oob pointer> */

 access to OOB pointer */

 exit */

 r1 = [0x00, 0xff] */

 r2 = 0x10'0000'0000 */

 r1 = [0x10'0000'0000, 0x10'0000'00ff] */

 r1 = [0x10'7fff'ffff, 0x10'8000'00fe] */

 r1 = [0x00, 0xff] */

 r1 = 0 */

 no-op */

 access at offset 0 */

 exit */

 r1 = [0x00, 0xff] */

 r1 = [0xffff'ff80, 0x1'0000'007f] */

	/* r1 = [0xffff'ff80, 0xffff'ffff] or

	 *      [0x0000'0000, 0x0000'007f]

	/* r1 = [0x00, 0xff] or

	 *      [0xffff'ffff'0000'0080, 0xffff'ffff'ffff'ffff]

 error on OOB pointer computation */

 exit */

 not actually fully unbounded, but the bound is very high */

 r1 = [0x00, 0xff] */

 r1 = [0xffff'ff80, 0x1'0000'007f] */

	/* r1 = [0xffff'ff80, 0xffff'ffff] or

	 *      [0x0000'0000, 0x0000'007f]

	 * difference to previous test: truncation via MOV32

	 * instead of ALU32.

	/* r1 = [0x00, 0xff] or

	 *      [0xffff'ffff'0000'0080, 0xffff'ffff'ffff'ffff]

 error on OOB pointer computation */

 exit */

 r1 = 0x7fff'ffff */

 r1 = 0xffff'fffe */

 r1 = 0 */

 no-op */

 access at offset 0 */

 exit */

 r1 = (u32)1 << (u32)32 = ? */

 r1 = [0x0000, 0xffff] */

 computes unknown pointer, potentially OOB */

 potentially OOB access */

 exit */

 r1 = [0x00, 0xff] */

 r1 = [-0x01, 0xfe] */

 r1 = 0 or 0xff'ffff'ffff'ffff */

 r1 = 0 or 0xffff'ffff'ffff */

 computes unknown pointer, potentially OOB */

 potentially OOB access */

 exit */

 r1 = 2 */

 r1 = 1<<32 */

 r1 = 0 (NOT 2!) */

 r1 = 0xffff'fffe (NOT 0!) */

 error on computing OOB pointer */

 exit */

 r1 = 0xffffFFFF00000001 */

 check ALU64 op keeps 32bit bounds */

 invalid ldx if bounds are lost above */

 r1 = 0xffffFFFF00000001 */

 r1 = 0x2 */

 check ALU32 op zero extends 64bit bounds */

 invalid ldx if bounds are lost above */

 This used to reduce the max bound to 0x7fffffff */

 Verifier rewrite for unpriv skips tail call here. */

 split for s390 to succeed */

 load map value pointer into r0 and r2

 load some number from the map into r1

 depending on r1, branch:

 branch A

 branch B

 common instruction

 depending on r1, branch:

 branch A

 branch B

 verifier follows fall-through

 fake-dead code; targeted from branch A to

 prevent dead code sanitization

 load map value pointer into r0 and r2

 load some number from the map into r1

 depending on r1, branch:

 branch A

 branch B

 common instruction

 depending on r1, branch:

 branch A

 branch B

 verifier follows fall-through

 fake-dead code; targeted from branch A to

 prevent dead code sanitization, rejected

 via branch B however

 Marks reg as unknown. */

 val = 3; */

 old = atomic_cmpxchg(&val, 2, 4); */

 if (old != 3) exit(2); */

 if (val != 3) exit(3); */

 old = atomic_cmpxchg(&val, 3, 4); */

 if (old != 3) exit(4); */

 if (val != 4) exit(5); */

 exit(0); */

 val = 3; */

 old = atomic_cmpxchg(&val, 2, 4); */

 if (old != 3) exit(2); */

 if (val != 3) exit(3); */

 old = atomic_cmpxchg(&val, 3, 4); */

 if (old != 3) exit(4); */

 if (val != 4) exit(5); */

 exit(0); */

 r0 = U64_MAX; */

 u64 val = r0; */

 r0 = (u32)atomic_cmpxchg((u32 *)&val, r0, 1); */

 r1 = 0x00000000FFFFFFFFull; */

 if (r0 != r1) exit(1); */

 exit(0); */

 val = 0; */

 r0 = &val */

 r0 = atomic_cmpxchg(&val, r0, 1); */

 if (r0 != 0) exit(1); */

 exit(0); */

 r0 = &val */

 val = r0; */

 r0 = atomic_cmpxchg(&val, r0, 0); */

 r1 = *r0 */

 exit(0); */

 r6 is our tp buffer */

 move the key (== 0) to r10-8 */

 lookup in the map */

 exit clean if null */

 shift the buffer pointer to a variable location */

 clobber whatever's there */

/* This file contains sub-register zero extension checks for insns defining

 * sub-registers, meaning:

 *   - All insns under BPF_ALU class. Their BPF_ALU32 variants or narrow width

 *     forms (BPF_END) could define sub-registers.

 *   - Narrow direct loads, BPF_B/H/W | BPF_LDX.

 *   - BPF_LD is not exposed to JIT back-ends, so no need for testing.

 *

 * "get_prandom_u32" is used to initialize low 32-bit of some registers to

 * prevent potential optimizations done by verifier or JIT back-ends which could

 * optimize register back into constant when range info shows one register is a

 * constant.

	/* An insn could have no effect on the low 32-bit, for example:

	 *   a = a + 0

	 *   a = a | 0

	 *   a = a & -1

	 * But, they should still zero high 32-bit.

 Upper bits are unknown but AND above masks out 1 zero'ing lower bits */

 val = 0x110; */

 atomic_and(&val, 0x011); */

 if (val != 0x010) exit(2); */

 r1 should not be clobbered, no BPF_FETCH flag */

 val = 0x110; */

 old = atomic_fetch_and(&val, 0x011); */

 if (old != 0x110) exit(3); */

 if (val != 0x010) exit(2); */

 Check R0 wasn't clobbered (for fear of x86 JIT bug) */

 exit(0); */

 r0 = (s64) -1 */

 val = 0x110; */

 old = atomic_fetch_and(&val, 0x011); */

 if (old != 0x110) exit(3); */

 if (val != 0x010) exit(2); */

		/* Check R0 wasn't clobbered (for fear of x86 JIT bug)

		 * It should be -1 so add 1 to get exit code.

 val = 0x110; */

 old = atomic_fetch_and(&val, 0x011); */

 if (old != 0x110) exit(3); */

 if (val != 0x010) exit(2); */

 exit(0); */

 leak reference */

 leak reference */

 leak reference */

 leak reference */

 leak reference */

 reference in r0 may be NULL */

 reference in r0 may be NULL */

 goto end */

 if (offsetof(skb, mark) > data_len) exit; */

 mark == 0? */

 Leak reference in R0 */

 sk NULL? */

 if (offsetof(skb, mark) > data_len) exit; */

 mark == 0? */

 sk NULL? */

 sk NULL? */

 unchecked reference */

 subprog 1 */

 unchecked reference */

 subprog 1 */

 subprog 1 */

 spill unchecked sk_ptr into stack of caller */

 subprog 1 */

 return sk */

 subprog 1 */

 spill unchecked sk_ptr into stack of caller */

 subprog 2 */

 subprog 1 */

 spill unchecked sk_ptr into stack of caller */

 now the sk_ptr is verified, free the reference */

 subprog 2 */

 if (sk) bpf_sk_release() */

 bpf_tail_call() */

 if (sk) bpf_sk_release() */

 bpf_tail_call() */

 Look up socket and store in REG_6 */

 bpf_tail_call() */

 if (sk) bpf_sk_release() */

 Look up socket and store in REG_6 */

 if (!sk) goto end */

 bpf_tail_call() */

 Check that the packet is at least 64B long */

 sk = sk_lookup_tcp(ctx, skb->data, ...) */

 !bpf_sk_fullsock(sk) is checked but !bpf_tcp_sock(sk) is not checked */

 u64 val = operan1; */			\

 u64 old = atomic_fetch_add(&val, operand2); */ \

 if (old != operand1) exit(1); */		\

 if (val != result) exit (2); */		\

 exit(0); */					\

 1-byte read from family field */

 2-byte read from family field */

 4-byte read from family field */

 1-byte read from protocol field */

 2-byte read from protocol field */

 4-byte read from protocol field */

 1-byte read from remote_ip4 field */

 2-byte read from remote_ip4 field */

 4-byte read from remote_ip4 field */

 1-byte read from remote_ip6 field */

 2-byte read from remote_ip6 field */

 4-byte read from remote_ip6 field */

 1-byte read from remote_port field */

 2-byte read from remote_port field */

 4-byte read from remote_port field */

 1-byte read from local_ip4 field */

 2-byte read from local_ip4 field */

 4-byte read from local_ip4 field */

 1-byte read from local_ip6 field */

 2-byte read from local_ip6 field */

 4-byte read from local_ip6 field */

 1-byte read from local_port field */

 2-byte read from local_port field */

 4-byte read from local_port field */

 8-byte read from sk field */

 invalid 8-byte reads from a 4-byte fields in bpf_sk_lookup */

 invalid 1,2,4-byte reads from 8-byte fields in bpf_sk_lookup */

 out of bounds and unaligned reads from bpf_sk_lookup */

 in-bound and out-of-bound writes to bpf_sk_lookup */

 reg, high bits shouldn't be tested */

/* instructions used to output a skb based software event, produced

 * from code snippet:

 * struct TMP {

 *  uint64_t tmp;

 * } tt;

 * tt.tmp = 5;

 * bpf_perf_event_output(skb, &connection_tracking_event_map, 0,

 *			 &tt, sizeof(tt));

 * return 1;

 *

 * the bpf assembly from llvm is:

 *        0:       b7 02 00 00 05 00 00 00         r2 = 5

 *        1:       7b 2a f8 ff 00 00 00 00         *(u64 *)(r10 - 8) = r2

 *        2:       bf a4 00 00 00 00 00 00         r4 = r10

 *        3:       07 04 00 00 f8 ff ff ff         r4 += -8

 *        4:       18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00    r2 = 0ll

 *        6:       b7 03 00 00 00 00 00 00         r3 = 0

 *        7:       b7 05 00 00 08 00 00 00         r5 = 8

 *        8:       85 00 00 00 19 00 00 00         call 25

 *        9:       b7 00 00 00 01 00 00 00         r0 = 1

 *       10:       95 00 00 00 00 00 00 00         exit

 *

 *     The reason I put the code here instead of fill_helpers is that map fixup

 *     is against the insns, instead of filled prog.

 ctx->meta->seq

 ctx->task

 fixup_map_array_48b

 keep buf for seq_write

 Don't run, just load

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2018 Politecnico di Torino

 SPDX-License-Identifier: GPL-2.0 */

 Copyright (c) 2018 Facebook */

 just to validate we can handle maps in multiple sections */

 just verify we can reference both maps */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2018 Facebook

 Verify that new destination is available. */

 Bind to device and unbind it. */

 Rewrite congestion control. */

 Rewrite destination. */

 SPDX-License-Identifier: GPL-2.0-only

 Copyright (c) 2020 Facebook */

 SPDX-License-Identifier: GPL-2.0-only

/* Copyright (c) 2017 Facebook

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 8-byte aligned .data */

 4-byte aligned .rodata */

 same "subprog" name in both files */

 but different formula */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 long */

 [1] */

 unsigned long */

 [2] */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2018 Facebook

 Verify that new destination is available. */

 Rewrite destination. */

 Rewrite source. */

 SPDX-License-Identifier: GPL-2.0

 Force local address to [::1]:22223. */

 Rewire service [fc00::1]:60000 to backend [::1]:60124. */

 Expose local server as [fc00::1]:60000 to client. */

 Expose service [fc00::1]:60000 as peer instead of backend. */

/* Copyright (c) 2017 VMware

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of version 2 of the GNU General Public

 * License as published by the Free Software Foundation.

 *

 * This program is distributed in the hope that it will be useful, but

 * WITHOUT ANY WARRANTY; without even the implied warranty of

 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU

 * General Public License for more details.

 SPDX-License-Identifier: GPL-2.0

/* These are the identifiers of the BPF programs that will be used in tail

 * calls. Name is limited to 16 characters, with the terminating character and

 * bpf_func_ above, we have only 6 to work with, anything after will be cropped.

 Destination/Hop-by-Hop Options IPv6 Ext. Header */

 Fragmentation IPv6 Extension Header */

 Verifies this variable offset does not overflow */

 Dispatches on ETHERTYPE */

 Protocol not supported */

 Parses on IPPROTO_* */

 Only inspect standard GRE packets with version 0 */

 Step over GRE Flags and Proto */

 Step over chksum and Padding */

 Step over key */

 Step over sequence number */

 IP header cannot be smaller than 20 bytes */

			/* From second fragment on, packets do not have headers

			 * we can parse.

			/* No need to parse fragmented packet unless

			 * explicitly asked for.

	/* hlen is in 8-octets and does not include the first 8 bytes

	 * of the header

		/* No need to parse fragmented packet unless

		 * explicitly asked for.

 Account for double-tagging */

 Only allow 8021AD + 8021Q double tagging and no triple tagging.*/

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2017 Facebook

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright 2020 Google LLC.

 This is the first fmod_ret program, the ret passed should be 0 */

	/* If the input_reval is non-zero a successful modification should have

	 * occurred.

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook

 spin_lock in hash map */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 4-byte aligned .data */

 8-byte aligned .rodata */

 same "subprog" name in both files */

 but different formula */

 different name and/or type of the variable doesn't matter */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 weak and shared between both files */

 should stay zero */

 same "subprog" name in all files, but it's ok because they all are static */

 but different formula */

 Global functions can't be void */

/* This function can't be verified as global, as it assumes raw_tp/sys_enter

 * context and accesses syscall id (second argument). So we mark it as

 * __hidden, so that libbpf will mark it as static in the final object file,

 * right before verifying it in the kernel.

 *

 * But we don't mark it as __hidden here, rather at extern site. __hidden is

 * "contaminating" visibility, so it will get propagated from either extern or

 * actual definition (including from the losing __weak definition).

 long id, same as in BPF_PROG below */

 this weak instance should lose, because it will be processed second */

 here we'll force set_output_ctx1() to be __hidden in the final obj file */

 ctx definition is hidden in BPF_PROG macro */

	/* keep input value the same across both files to avoid dependency on

	 * handler call order; differentiate by output_weak1 vs output_weak2.

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Jesper Dangaard Brouer */

 Userspace will update with MTU it can see on device */

 BPF-prog will update these with MTU values it can see */

 Expected retval on successful test */

 When ifindex is zero, save net_device lookup and use ctx netdev */

 mtu_len is also valid when check fail */

 Fail */

 Exceed MTU with 1 via delta adjust */

 Success in exceeding MTU check */

 Expected retval on successful test */

 Borderline test case: Minus delta exceeding packet length allowed */

	/* Minus length (adjusted via delta) still pass MTU check, other helpers

	 * are responsible for catching this, when doing actual size adjust

 Expected retval on successful test */

	/* API allow user give length to check as input via mtu_len param,

	 * resulting MTU value is still output in mtu_len param after call.

	 *

	 * Input len is L3, like MTU and iph->tot_len.

	 * Remember XDP data_len is L2.

 Fail */

	/* API allow user give length to check as input via mtu_len param,

	 * resulting MTU value is still output in mtu_len param after call.

	 *

	 * Input length value is L3 size like MTU.

 Exceed with 1 */

 Success in exceeding MTU check */

 Expected retval on successful test */

 Fail */

 Exceed MTU with 1 via delta adjust */

 Success in exceeding MTU check */

 SKB Direct-Access variant */

 Fail */

 Exceed MTU with 1 via delta adjust */

 Success in exceeding MTU check */

 Expected retval on successful test */

 Borderline test case: Minus delta exceeding packet length allowed */

	/* Minus length (adjusted via delta) still pass MTU check, other helpers

	 * are responsible for catching this, when doing actual size adjust

 Expected retval on successful test */

	/* API allow user give length to check as input via mtu_len param,

	 * resulting MTU value is still output in mtu_len param after call.

	 *

	 * Input length value is L3 size.

 Fail */

	/* API allow user give length to check as input via mtu_len param,

	 * resulting MTU value is still output in mtu_len param after call.

	 *

	 * Input length value is L3 size like MTU.

 Exceed with 1 */

 Success in exceeding MTU check */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 Copied from mm.h */

 Copied from kdev_t.h */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 will set before prog run */

 will collect results during prog run */

		/* test mode is used by selftests to

		 * test functionality of bpf_hash_map iter.

		 *

		 * the above hashmap1 will have correct size

		 * and will be accepted, hashmap2 and hashmap3

		 * should be rejected due to smaller key/value

		 * size.

		/* update the value and then delete the <key, value> pair.

		 * it should not impact the existing 'val' which is still

		 * accessible under rcu.

	/* non-test mode, the map is prepared with the

	 * below bpftool command sequence:

	 *   bpftool map create /sys/fs/bpf/m1 type hash \

	 *   	key 12 value 8 entries 3 name map1

	 *   bpftool map update id 77 key 0 0 0 1 0 0 0 0 0 0 0 1 \

	 *   	value 0 0 0 1 0 0 0 1

	 *   bpftool map update id 77 key 0 0 0 1 0 0 0 0 0 0 0 2 \

	 *   	value 0 0 0 1 0 0 0 2

	 * The bpftool iter command line:

	 *   bpftool iter pin ./bpf_iter_bpf_hash_map.o /sys/fs/bpf/p1 \

	 *   	map id 77

	 * The below output will be:

	 *   map dump starts

	 *   77: (1000000 0 2000000) (200000001000000)

	 *   77: (1000000 0 1000000) (100000001000000)

	 *   map dump ends

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Carlos Neira cneirabustos@gmail.com */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

	/* If the verifier doesn't refine bpf_get_task_stack res, and instead

	 * assumes res is entirely unknown, this program will fail to load as

	 * the verifier will believe that max buf_sz value allows reading

	 * past the end of entries in bpf_seq_write call

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook

 SPDX-License-Identifier: GPL-2.0

	/* Return 1 OR'ed with the first bit set to indicate

	 * that CAP_NET_BIND_SERVICE should be bypassed.

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 EPERM, bounds check */

 SPDX-License-Identifier: GPL-2.0

/* Copyright (c) 2016 VMware

 * Copyright (c) 2016 Facebook

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of version 2 of the GNU General Public

 * License as published by the Free Software Foundation.

 hard-coded to 8 byte */

 172.16.1.100 */

 ::11 */

 172.16.1.100 */

 172.16.1.100 */

 Set VXLAN Group Policy extension */

 ::11 */

 172.16.1.100 */

 Open Virtual Networking (OVN) */

 4-byte multiple */

 ::11 */

 Open Virtual Networking (OVN) */

 4-byte multiple */

 single length check */

 172.16.1.100 */

 single length check */

 ::11 */

 single length check */

 NEXTHDR_ICMP */) {

 ::11 */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook

	/*

	 * if the struct's size is multiple of 16, compiler will put it into

	 * .rodata.cst16 section, which is not recognized by libbpf; work

	 * around this by ensuring we don't have 16-aligned struct

 prevent compiler to optimize everything out */

 we should never enter this loop */

 prevent compiler to optimize everything out */

 validate verifier can derive loop termination */

 prevent compiler to optimize everything out */

 validate verifier can allow full loop as well */

 SPDX-License-Identifier: GPL-2.0

 One map use devmap, another one use devmap_hash for testing */

 map to store egress interfaces mac addresses */

 Using IPv4 for (BPF_F_BROADCAST | BPF_F_EXCLUDE_INGRESS) testing */

 Using IPv6 for none flag testing */

 All others for BPF_F_BROADCAST testing */

 The following 2 progs are for 2nd devmap prog testing */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook

 tcp_mem sysctl has only 3 ints, but this test is doing TCP_MEM_LOOPS */

 because 30 doesn't fit into 512 bytes of stack */

	/* a workaround to prevent compiler from generating

	 * codes verifier cannot handle yet.

 SPDX-License-Identifier: GPL-2.0

/* these are identical, but keep them separate for compatibility with the

 * section names expected by test_tc_redirect.sh

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

/* bpf_prog_array, used by kernel internally to keep track of attached BPF

 * programs to a given BPF hook (e.g., for tracepoints) doesn't allow the same

 * BPF program to be attached multiple times. So have three identical copies

 * ready to attach to the same tracepoint.

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook

 userspace should set it */

 to test bpf_htab.count */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 modifiers and typedefs are ignored when comparing key/value types */

 this definition will lose, but it has to exactly match the winner */

 update values with key = 2 */

 lookup values with key = 1, set in another file */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Isovalent, Inc.

 Relocation tests for __u64s. */

 Relocation tests for strings. */

 Relocation tests for structs. */

 SPDX-License-Identifier: GPL-2.0-only

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook

	/* For SYN packets coming to listening socket skb->remote_port will be

	 * zero, so IPv6/TCP headers are loaded to identify remote peer

	 * instead.

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 field order is mixed up */

 we have test_progs[-flavor], so cut flavor part */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

/*

 * load is successful

 * #define TWFW_MAX_TIERS (64u)$

 rule->seqnum / 64 should always be 0 */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook

/* clang will not unroll at all.

 * Total program size is around 2k insns

 SPDX-License-Identifier: GPL-2.0-only

/* Copyright (c) 2017 Facebook

/* llvm will optimize both subprograms into exactly the same BPF assembly

 *

 * Disassembly of section .text:

 *

 * 0000000000000000 test_pkt_access_subprog1:

 * ; 	return skb->len * 2;

 *        0:	61 10 00 00 00 00 00 00	r0 = *(u32 *)(r1 + 0)

 *        1:	64 00 00 00 01 00 00 00	w0 <<= 1

 *        2:	95 00 00 00 00 00 00 00	exit

 *

 * 0000000000000018 test_pkt_access_subprog2:

 * ; 	return skb->len * val;

 *        3:	61 10 00 00 00 00 00 00	r0 = *(u32 *)(r1 + 0)

 *        4:	64 00 00 00 01 00 00 00	w0 <<= 1

 *        5:	95 00 00 00 00 00 00 00	exit

 *

 * Which makes it an interesting test for BTF-enabled verifier.

 make modification to the packet data */

 to force ordering of checks */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Cloudflare */

	/* We need a temporary buffer on the stack, since the verifier doesn't

	 * let us use the pointer from the context as an argument to the helper.

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook */

/* WARNING: This implemenation is not necessarily the same

 * as the tcp_dctcp.c.  The purpose is mainly for testing

 * the kernel BPF logic.

 g = 1/2^4 */

 Switch to fallback */

		/* Switch back to myself which the bpf trampoline

		 * stopped calling dctcp_init recursively.

 Switch back to fallback */

 Expecting -ENOTSUPP for tcp_cdg_res */

 Expired RTT */

 alpha = (1 - g) * alpha + g * F */

			/* If dctcp_shift_g == 1, a 32bit value would overflow

			 * after 8 M packets.

	/* We handle RTO in dctcp_cwnd_event to ensure that we perform only

	 * one loss-adjustment per RTT.

/* Minimal DCTP CE state machine:

 *

 * S:	0 <- last pkt was non-CE

 *	1 <- last pkt was CE

		/* CE state has changed, force an immediate ACK to

		 * reflect the new CE state. If an ACK was delayed,

		 * send that first to reflect the prior CE state.

 Don't care for the rest. */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2018 Covalent IO, Inc. http:
 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2017 Facebook

/* copy paste of jhash from kernel sources to make sure llvm

 * can compile it into valid sequence of bpf instructions

 Nothing left to add */

	/* don't update iph->daddr, since it will overwrite old eth_proto

	 * and multiple iterations of bpf_prog_run() will fail

 jhash of ipv4 packet */  &&

 jhash of ipv6 packet */)

/* don't believe your eyes!

 * below function has 6 arguments whereas bpf and llvm allow maximum of 5

 * but since it's _static_ llvm can optimize one argument away

 SPDX-License-Identifier: GPL-2.0-only

 Copyright (c) 2020 Facebook */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 this weak extern will be strict due to the other file's strong extern */

 these two definitions should win */

 just make sure all the relocations work against .text as well */

	/* make sure we actually use above special externs, otherwise compiler

	 * will optimize them out

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook

 SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause

 Copyright (c) 2019, 2020 Cloudflare

/**

 * Destination port and IP used for UDP encapsulation.

/* This is a bit of a hack. We need a return value which allows us to

 * indicate that the regular flow of the program should continue,

 * while allowing functions to use XDP_PASS and XDP_DROP, etc.

/* Convenience macro to call functions which return ret_t.

/* Linux packet pointers are either aligned to NET_IP_ALIGN (aka 2 bytes),

 * or not aligned if the arch supports efficient unaligned access.

 *

 * Since the verifier ensures that eBPF packet accesses follow these rules,

 * we can tell LLVM to emit code as if we always had a larger alignment.

 * It will yell at us if we end up on a platform where this is not valid.

	/* NB: tail musn't have alignment other than 1, otherwise

	* LLVM will go and eliminate code, e.g. when checking packet lengths.

	/* Clang seems to optimize constructs like

	 *    a - b + c

	 * if c is known:

	 *    r? = c

	 *    r? -= b

	 *    r? += a

	 *

	 * This is a problem if a and b are packet pointers,

	 * since the verifier allows subtracting two pointers to

	 * get a scalar, but not a scalar and a pointer.

	 *

	 * Use inline asm to break this optimization.

 Check whether off + len is valid in the non-linear part. */

/* Returns a pointer to the start of buf, or NULL if len is

 * larger than the remaining data. Consumes len bytes on a successful

 * call.

 *

 * If scratch is not NULL, the function will attempt to load non-linear

 * data via bpf_skb_load_bytes. On success, scratch is returned.

 Parse the L4 ports from a packet, assuming a layout like TCP or UDP. */

	/* Ports in the L4 headers are reversed, since we are parsing an ICMP

	 * payload which is going towards the eyeball.

	/* The highest reasonable value for an IPv4 header

	 * checksum requires two folds, so we just do that always.

	/* An IP header without options is 20 bytes. Two of those

	 * are the checksum, which we always set to zero. Hence,

	 * the maximum accumulated value is 18 / 2 * 0xffff = 0x8fff7,

	 * which fits in 32 bit.

	/* We understand five extension headers.

	 * https://tools.ietf.org/html/rfc8200#section-4.1 states that all

	 * headers should occur once, except Destination Options, which may

	 * occur twice. Hence we give up after 6 headers.

 NB: We don't check that hdrlen == 0 as per spec. */

 fallthrough; */

 hdrlen is in 8-octet units, and excludes the first 8 octets. */

 Decode next header */

			/* The next header is not one of the known extension

			 * headers, treat it as the upper layer header.

			 *

			 * This handles IPPROTO_NONE.

			 *

			 * Encapsulating Security Payload (50) and Authentication

			 * Header (51) also end up here (and will trigger an

			 * unknown proto error later). They have a custom header

			 * format and seem too esoteric to care about.

 We never found an upper layer header. */

/* This function has to be inlined, because the verifier otherwise rejects it

 * due to returning a pointer to the stack. This is technically correct, since

 * scratch is allocated on the stack. However, this usage should be safe since

 * it's the callers stack after all.

/* Global metrics, per CPU

 Changing the ethertype if the encapsulated packet is ipv6

	/* Loop protection: the inner packet's TTL is decremented as a safeguard

	 * against any forwarding loop. As the only interesting field is the TTL

	 * hop limit for IPv6, it is easier to use bpf_skb_load_bytes/bpf_skb_store_bytes

	 * as they handle the split packets if needed (no need for the data to be

	 * in the linear section).

		/* IPv4 also has a checksum to patch. While the TTL is only one byte,

		 * this function only works for 2 and 4 bytes arguments (the result is

		 * the same).

 swap L2 addresses */

	/* This assumes that packets are received from a router.

	 * So just swapping the MAC addresses here will make the packet go back to

	 * the router, which will send it to the appropriate machine.

 Remove ip->saddr, add next_hop->s_addr */

/* Get the next hop from the GLB header.

 *

 * Sets next_hop->s_addr to 0 if there are no more hops left.

 * pkt is positioned just after the variable length GLB header

 * iff the call is successful.

 Skip "used" next hops. */

 No more next hops, we are at the end of the GLB header. */

 Skip the remainig next hops (may be zero). */

/* Fill a bpf_sock_tuple to be used with the socket lookup functions.

 * This is a kludge that let's us work around verifier limitations:

 *

 *    fill_tuple(&t, foo, sizeof(struct iphdr), 123, 321)

 *

 * clang will substitue a costant for sizeof, which allows the verifier

 * to track it's value. Based on this, it can figure out the constant

 * return value, and calling code works while still being "generic" to

 * IPv4 and IPv6.

 Kludge: we've run out of arguments, but need the length of the ip header. */

 We should never receive encapsulated echo replies. */

	/* The source address in the outer IP header is from the entity that

	 * originated the ICMP message. Use the original IP header to restore

	 * the correct flow tuple.

 We should never receive encapsulated echo replies. */

 Swap source and dest addresses. */

	/* Pass bogus packets as long as we're not sure they're

	 * destined for us.

	/* Make sure that all encapsulation headers are available in

	 * the linear portion of the skb. This makes it easy to manipulate them.

 We never have any options. */

 TODO Check UDP length? */

	/* We now know that the packet is destined to us, we can

	 * drop bogus ones.

 metrics have already been bumped */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2018 Facebook */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 when an extern is defined as both strong and weak, resulting symbol will be strong */

 these two weak variables should lose */

 just make sure all the relocations work against .text as well */

	/* make sure we actually use above special externs, otherwise compiler

	 * will optimize them out

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2020 Google LLC.

/* Copyright (c) 2016,2017 Facebook

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of version 2 of the GNU General Public

 * License as published by the Free Software Foundation.

 It only does v4-in-v4 */

 It only does v6-in-v6 */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 unused */

 callback for inner hash map */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved. */

 Record time reply received. */

 verifier is fussy here... */

 No more space for values? */

 Now convert reply back into echo request. */

 Now convert request into echo reply. */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 negative offset, verifier failure. */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Google LLC. */

 The format string is filled from the userspace such that loading fails */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook

 It only does v4-in-v4 */

 It only does v6-in-v6 */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Cloudflare

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 Packet parsing state machine helpers. */

 cur_off = end of segments, start of possible TLVs

 we can only go as far as ~10 TLVs due to the BPF max stack size

 workaround: define induction variable "i" as "long" instead

 of "int" to prevent alu32 sub-register spilling.

 we reached the padding or HMAC TLVs, or the end of the SRH

 the following can't be moved inside update_tlv_pad because the

 bpf verifier has some issues with it

 cannot pad for 1 byte only

 Add an Egress TLV fc00::4, add the flag A,

 and apply End.X action to fc42::1

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook

 we have test_progs[-flavor], so cut flavor part */

 validate pid + tgid matches */

 test variadic BPF_CORE_READ macros */

 test BPF_CORE_READ_STR_INTO() returns correct code and contents */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook */

 non-existing BPF helper, to test dead code elimination */

 strong */

 invalid, but dead code - never executed */

 SPDX-License-Identifier: GPL-2.0-only

 Copyright (c) 2020 Facebook */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 original get_constant() returns val - 122 */

 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)

/*

 * BTF-to-C dumper tests for implicit and explicit padding between fields and

 * at the end of a struct.

 *

 * Copyright (c) 2019 Facebook

 ----- START-EXPECTED-OUTPUT ----- */

 ------ END-EXPECTED-OUTPUT ------ */

 ----- START-EXPECTED-OUTPUT ----- */

/*

 *struct padded_explicitly {

 *	int a;

 *	int: 32;

 *	int b;

 *};

 *

 ------ END-EXPECTED-OUTPUT ------ */

 algo will explicitly pad with full 32 bits here */

 ----- START-EXPECTED-OUTPUT ----- */

/*

 *struct padded_a_lot {

 *	int a;

 *	long: 32;

 *	long: 64;

 *	long: 64;

 *	int b;

 *};

 *

 ------ END-EXPECTED-OUTPUT ------ */

 32 bit of implicit padding here, which algo will make explicit */

 ----- START-EXPECTED-OUTPUT ----- */

/*

 *struct padded_cache_line {

 *	int a;

 *	long: 32;

 *	long: 64;

 *	long: 64;

 *	long: 64;

 *	int b;

 *	long: 32;

 *	long: 64;

 *	long: 64;

 *	long: 64;

 *};

 *

 ------ END-EXPECTED-OUTPUT ------ */

 ----- START-EXPECTED-OUTPUT ----- */

/*

 *struct zone_padding {

 *	char x[0];

 *};

 *

 *struct zone {

 *	int a;

 *	short b;

 *	short: 16;

 *	struct zone_padding __pad__;

 *};

 *

 ------ END-EXPECTED-OUTPUT ------ */

 SPDX-License-Identifier: GPL-2.0

 typically virtio scsi has max SGs of 6 */

/* Verifier will fail with SG_MAX = 128. The failure can be

 * workarounded with a smaller SG_MAX, e.g. 10.

 typically virtio blk has max SEG of 128 */

/* Copyright (c) 2017 Facebook

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of version 2 of the GNU General Public

 * License as published by the Free Software Foundation.

/* copy paste of jhash from kernel sources to make sure llvm

 * can compile it into valid sequence of bpf instructions

 Nothing left to add */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

	/* This will be kept by clang, but removed by verifier. Since it is

	 * marked as __weak, libbpf and gen_loader don't error out if BTF ID

	 * is not found for it, instead imm and off is set to 0 for it.

 this will fail if kfunc doesn't reuse its own btf fd index */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright 2020 Google LLC.

 Don't let an executable delete itself */

	/* new_dentry->d_inode can be NULL when the inode is renamed to a file

	 * that did not exist before. The helper should be able to handle this

	 * NULL pointer.

/* This uses the local storage to remember the inode of the binary that a

 * process was originally executing.

 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)

 Copyright (c) 2019 Facebook

 SPDX-License-Identifier: GPL-2.0-only

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook */

 .data section */

 .bss section */

 .rodata section */

 .data section */

 .bss section */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 userspace should set it */

	/* Make sure bpf_get_netns_cookie is callable.

		/* Not interested in SOL_IP:IP_TOS;

		 * let next BPF program in the cgroup chain or kernel

		 * handle it.

 bypass optval>PAGE_SIZE */

		/* Not interested in SOL_SOCKET:SO_SNDBUF;

		 * let next BPF program in the cgroup chain or kernel

		 * handle it.

		/* Not interested in SOL_TCP:TCP_CONGESTION;

		 * let next BPF program in the cgroup chain or kernel

		 * handle it.

		/* Verify that TCP_ZEROCOPY_RECEIVE triggers.

		 * It has a custom implementation for performance

		 * reasons.

 EPERM, bounds check */

 EPERM, unexpected data */

 EPERM, bounds check */

 Reset system call return value to zero */

 Always export 0x55 */

		/* Userspace buffer is PAGE_SIZE * 2, but BPF

		 * program can only see the first PAGE_SIZE

		 * bytes of data.

 EPERM, unexpected data size */

 EPERM, deny everything except custom level */

 EPERM, bounds check */

 EPERM, couldn't get sk storage */

		return 0; /* EPERM, kernel should not have handled

			   * SOL_CUSTOM, something is wrong!

 Reset system call return value to zero */

	/* Make sure bpf_get_netns_cookie is callable.

		/* Not interested in SOL_IP:IP_TOS;

		 * let next BPF program in the cgroup chain or kernel

		 * handle it.

 bypass optval>PAGE_SIZE */

 Overwrite SO_SNDBUF value */

 EPERM, bounds check */

 Always use cubic */

 EPERM, bounds check */

 Original optlen is larger than PAGE_SIZE. */

 EPERM, unexpected data size */

 EPERM, bounds check */

 Make sure we can trim the buffer. */

		/* Usepace buffer is PAGE_SIZE * 2, but BPF

		 * program can only see the first PAGE_SIZE

		 * bytes of data.

 EPERM, unexpected data size */

 EPERM, deny everything except custom level */

 EPERM, bounds check */

 EPERM, couldn't get sk storage */

	ctx->optlen = -1; /* BPF has consumed this option, don't call kernel

			   * setsockopt handler.

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2018 Facebook

 Rewrite source. */

 Unexpected source. Reject sendmsg. */

 Rewrite destination. */

 Unexpected destination. Reject sendmsg. */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2017 Facebook

/* copy paste of jhash from kernel sources to make sure llvm

 * can compile it into valid sequence of bpf instructions

 Nothing left to add */

 jhash of ipv4 packet */  &&

 jhash of ipv6 packet */)

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook

 local flavor with reversed layout */

 local flavor with nested/overlapping layout */

	/* a and c overlap in local flavor, but this should still work

	 * correctly with target original flavor

 read a using weird layout */

 read b using reversed layout */

 read c using original layout */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 FIXME: nexthop_is_multipath is not handled here. */

 SPDX-License-Identifier: GPL-2.0-only

 SPDX-License-Identifier: GPL-2.0

	/* Structure does not need to contain all entries,

	 * as "preserve_access_index" will use BTF to fix this...

	/* Structure does not need to contain all entries,

	 * as "preserve_access_index" will use BTF to fix this...

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0-only

/* WARNING: This implemenation is not necessarily the same

 * as the tcp_cubic.c.  The purpose is mainly for testing

 * the kernel BPF logic.

 *

 * Highlights:

 * 1. CONFIG_HZ .kconfig map is used.

 * 2. In bictcp_update(), calculation is changed to use usec

 *    resolution (i.e. USEC_PER_JIFFY) instead of using jiffies.

 *    Thus, usecs_to_jiffies() is not used in the bpf_cubic.c.

 * 3. In bitctcp_update() [under tcp_friendliness], the original

 *    "while (ca->ack_cnt > delta)" loop is changed to the equivalent

 *    "ca->ack_cnt / delta" operation.

#define BICTCP_BETA_SCALE    1024	/* Scale factor beta calculation

					 * max_cwnd = snd_cwnd * beta

 BIC HZ 2^10 = 1024 */

 Two methods of hybrid slow start */

 Number of delay samples for detecting the increase of delay */

 4ms */

 16 ms */

 = 717/1024 (BICTCP_BETA_SCALE) */

 1024*c/rtt */

/* calculate the "K" for (wmax-cwnd) = c/rtt * K^3

 *  so K = cubic_root( (wmax-cwnd)*rtt/c )

 * the unit of K is bictcp_HZ=2^10, not HZ

 *

 *  c = bic_scale >> 10

 *  rtt = 100ms

 *

 * the following code has been designed and tested for

 * cwnd < 1 million packets

 * RTT < 100 seconds

 * HZ < 1,000,00  (corresponding to 10 nano-second)

 1/c * 2^2*bictcp_HZ * srtt, 2^40 */

 BIC TCP Parameters */

 increase cwnd by 1 after ACKs */

 last maximum snd_cwnd */

 the last snd_cwnd */

 time when updated last_cwnd */

 origin point of bic function */

	__u32	bic_K;		/* time to origin point

 min delay (usec) */

 beginning of an epoch */

 number of acks */

 estimated tcp cwnd */

 number of samples to decide curr_rtt */

 the exit point is found? */

 beginning of each round */

 end_seq of the round */

 last time when the ACK spacing is close */

 the minimum rtt of current round */

 "struct_ops/" prefix is a requirement */

 "struct_ops" prefix is a requirement */

		/* We were application limited (idle) for a while.

		 * Shift epoch_start to keep cwnd growth to cubic curve.

/*

 * cbrt(x) MSB values for x MSB values in [0..63].

 * Precomputed then refined by hand - Willy Tarreau

 *

 * For x in [0..63],

 *   v = cbrt(x << 18) - 1

 *   cbrt(x) = (v[x] + 10) >> 6

 0x00 */    0,   54,   54,   54,  118,  118,  118,  118,

 0x08 */  123,  129,  134,  138,  143,  147,  151,  156,

 0x10 */  157,  161,  164,  168,  170,  173,  176,  179,

 0x18 */  181,  185,  187,  190,  192,  194,  197,  199,

 0x20 */  200,  202,  204,  206,  209,  211,  213,  215,

 0x28 */  217,  219,  221,  222,  224,  225,  227,  229,

 0x30 */  231,  232,  234,  236,  237,  239,  240,  242,

 0x38 */  244,  245,  246,  248,  250,  251,  252,  254,

/* calculate the cubic root of x using a table lookup followed by one

 * Newton-Raphson iteration.

 * Avg err ~= 0.195%

 a in [0..63] */

 it is needed for verifier's bound check on v */

	/*

	 * Newton-Raphson iteration

	 *                         2

	 * x    = ( 2 * x  +  a / x  ) / 3

	 *  k+1          k         k

/*

 * Compute congestion window to use.

 count the number of ACKed packets */

	/* The CUBIC function can update ca->cnt at most once per jiffy.

	 * On all cwnd reduction events, ca->epoch_start is set to 0,

	 * which will force a recalculation of ca->cnt.

 record beginning */

 start counting */

 syn with cubic */

			/* Compute new K based on

			 * (wmax-cwnd) * (srtt>>3 / HZ) / c * 2^(3*bictcp_HZ)

 cubic function - calc*/

	/* calculate c * time^3 / rtt,

	 *  while considering overflow in calculation of time^3

	 * (so time^3 is done by using 64 bit)

	 * and without the support of division of 64bit numbers

	 * (so all divisions are done by using 32 bit)

	 *  also NOTE the unit of those veriables

	 *	  time  = (t - K) / 2^bictcp_HZ

	 *	  c = bic_scale >> 10

	 * rtt  = (srtt >> 3) / HZ

	 * !!! The following code does not have overflow problems,

	 * if the cwnd < 1 million packets !!!

 change the unit from usec to bictcp_HZ */

 t - K */

 c/rtt * (t-K)^3 */

 below origin*/

 above origin*/

 cubic function - calc bictcp_cnt*/

 very small increment*/

	/*

	 * The initial growth of cubic function may be too conservative

	 * when the available bandwidth is still unknown.

 increase cwnd 5% per RTT */

 TCP Friendly */

 update tcp cwnd */

 if bic is slower than tcp */

	/* The maximum rate of cwnd increase CUBIC allows is 1 packet per

	 * 2 packets ACKed, meaning cwnd grows at 1.5x per RTT.

 Or simply use the BPF_STRUCT_OPS to avoid the SEC boiler plate. */

 end of epoch */

 Wmax and fast convergence */

/* Account for TSO/GRO delays.

 * Otherwise short RTT flows could get too small ssthresh, since during

 * slow start we begin with small TSO packets and ca->delay_min would

 * not account for long aggregation delay when TSO packets get bigger.

 * Ideally even with a very small RTT we would like to have at least one

 * TSO packet being sent and received by GRO, and another one in qdisc layer.

 * We apply another 100% factor because @rate is doubled at this point.

 * We cap the cushion to 1ms.

 first detection parameter - ack-train detection */

			/* Hystart ack train triggers if we get ack past

			 * ca->delay_min/2.

			 * Pacing might have delayed packets up to RTT/2

			 * during slow start.

 obtain the minimum delay of more than sampling packets */

 Some calls are for duplicates without timetamps */

 Discard delay samples right after fast recovery */

 first time call or link delay decreases */

 hystart triggers when cwnd is larger than some threshold */

 SPDX-License-Identifier: GPL-2.0

 In-place tunneling */

 MPLS label 1000 with S bit (last label) set and ttl of 255. */

 space for L2 header / vxlan header ... */

 space for L2 header / vxlan header ... */

	/* Most tests encapsulate a packet into a tunnel with the same

	 * network protocol, and derive the outer header fields from

	 * the inner header.

	 *

	 * The 6in4 case tests different inner and outer protocols. As

	 * the inner is ipv6, but the outer expects an ipv4 header as

	 * input, manually build a struct iphdr based on the ipv6hdr.

 Read the IPv6 header */

 Derive the IPv4 header fields from the IPv6 header */

 filter only packets we want */

 add L2 encap (if specified) */

 add room between mac and network header */

 prepare new outer network header */

 store new outer network header */

 if changing outer proto type, update eth->h_proto */

 filter only packets we want */

 add L2 encap (if specified) */

 add room between mac and network header */

 prepare new outer network header */

 store new outer network header */

 does not match, ignore */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook

/* Copyright (c) 2017 Facebook

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of version 2 of the GNU General Public

 * License as published by the Free Software Foundation.

	/* Allow access to /dev/zero and /dev/random.

	 * Forbid everything else.

 1:5 /dev/zero */

 1:9 /dev/urandom */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

/*

 * Test weak ksyms.

 *

 * Copyright (c) 2021 Google

 existing weak symbols */

 test existing weak symbols can be resolved. */

 typed */

 typeless */

 non-existent weak symbols. */

 typeless symbols, default to zero. */

 typed symbols, default to zero. */

 tests existing symbols. */

 tests non-existent symbols. */

 tests non-existent symbols. */

 can't happen */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2018 Facebook

 Copyright (c) 2019 Cloudflare

 packet should only have an MSS option

 SPDX-License-Identifier: GPL-2.0

 Check multi-prog update. */

 Check tail call limit. */

 SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause) */

 Sample program which should always load for testing control paths. */

 SPDX-License-Identifier: GPL-2.0

 b is certainly 0 here. Can the verifier tell? */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

/* sub5() is an identitify function, just to test weirder functions layout and

 * call patterns

 compensates sub1()'s + 1 */

/* unfortunately verifier rejects `struct task_struct *t` as an unkown pointer

 * type, so we need to accept pointer as integer and then cast it inside the

 * function

 this ensures that CO-RE relocs work in multi-subprogs .text */

	/* perform some CO-RE relocations to ensure they work with multi-prog

	 * sections correctly

 (1 + 1) + (2 + 3 + (4 + 1)) = 12 */

 (3 + 2) + (4 + 3 + (4 + 1)) = 17 */

 prog3 has the same section name as prog1 */

 (5 + 3 + (4 + 1)) + 6 = 19 */

 prog4 has the same section name as prog2 */

 (7 + (5 + 3 + (4 + 1)) + (6 + 1)) + (8 + 1) = 36 */

 SPDX-License-Identifier: GPL-2.0-only

		/* BPF_CGROUP_INET_SOCK_RELEASE is _not_ called

		 * when we return an error from the BPF

		 * program!

 SPDX-License-Identifier: GPL-2.0

	/* Multiple locations to make sure we patch

	 * all of them.

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 will set before prog run */

 will collect results during prog run */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook

 SPDX-License-Identifier: GPL-2.0

www.tessares.net> */

	/* Just do it for once, when called from our own test prog. This

	 * ensures the map value is only updated for a single CPU.

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2018 Facebook

 172.16.0.1 */

 192.168.1.254 */

 Rewrite source. */

 Unexpected source. Reject sendmsg. */

 Rewrite destination. */

 Unexpected source. Reject sendmsg. */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 SPDX-License-Identifier: GPL-2.0

	/* This BPF program performs variable-offset reads and writes on a

	 * stack-allocated buffer.

 Copy the input to the stack. */

 The first byte in the buffer indicates the length. */

	/* Append something to the buffer. The offset where we write is not

	 * statically known; this is a variable-offset stack write.

	/* Index into the buffer at an unknown offset. This is a

	 * variable-offset stack read.

	 *

	 * Note that if it wasn't for the preceding variable-offset write, this

	 * read would be rejected because the stack slot cannot be verified as

	 * being initialized. With the preceding variable-offset write, the

	 * stack slot still cannot be verified, but the write inhibits the

	 * respective check on the reasoning that, if there was a

	 * variable-offset to a higher-or-equal spot, we're probably reading

	 * what we just wrote.

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Cloudflare

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 struct type global var. */

 int type global var. */

 READ_ONCE */

 !rq has not been tested, so verifier should reject. */

 SPDX-License-Identifier: GPL-2.0

/*

 * The kernel struct pt_regs isn't exported in its entirety to userspace.

 * Pass it as an array to task_pt_regs.c

 Prove that uprobe was run */

 SPDX-License-Identifier: GPL-2.0

 face:b00c:1234:5678::abcd */

 Socket in test case has guarantee that old never equals to new. */

 u8 narrow loads:

 u16 narrow loads:

 Bind to device and unbind it. */

 Test for misc socket options. */

 Set reuseport and unset */

 SPDX-License-Identifier: GPL-2.0 */

 Copyright (c) 2020 Facebook */

 it's possible to use anonymous struct as inner map definition here */

		/* changing max_entries to 2 will fail during load

	/* (void *) cast is necessary because we didn't use `struct inner_map`

	 * in __inner(values, ...)

	 * Actually, a conscious effort is required to screw up initialization

	 * of inner map slots, which is a great thing!

	/* Here everything works flawlessly due to reuse of struct inner_map

	 * and compiler will complain at the attempt to use non-inner_map

	 * references below. This is great experience.

 SPDX-License-Identifier: GPL-2.0

 Copyright (C) 2021. Huawei Technologies Co., Ltd */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook

 SPDX-License-Identifier: GPL-2.0-only

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0-only

 Copyright (c) 2020 Facebook */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Google LLC. */

 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)

/*

 * BTF-to-C dumper test validating no name versioning happens between

 * independent C namespaces (struct/union/enum vs typedef/enum values).

 *

 * Copyright (c) 2019 Facebook

 ----- START-EXPECTED-OUTPUT ----- */

------ END-EXPECTED-OUTPUT ------ */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 unused */

 callback for array and lru timers */

	/* increment bss variable twice.

	 * Once via array timer callback and once via lru timer callback

	/* *key == 0 - the callback was called for array timer.

	 * *key == 4 - the callback was called from lru timer.

 rearm array timer to be called again in ~35 seconds */

		     i <= 100  /* for current LRU eviction algorithm this number

				* should be larger than ~ lru->max_entries * 2

			/* lru_key cannot be used as loop induction variable

			 * otherwise the loop will be unbounded.

			/* add more elements into lru map to push out current

			 * element and force deletion of this timer

 look it up to bump it into active list */

			/* keep adding until *key changes underneath,

			 * which means that key/timer memory was reused

 check that the timer was removed */

 call timer_cb1 asap */, 0);

	/* init more timers to check that array destruction

	 * doesn't leak timer memory.

 callback for prealloc and non-prealloca hashtab timers */

 re-arm the timer again to execute after 1 usec */

		/* cancel arr_timer otherwise bpf_fentry_test1 prog

		 * will stay alive forever.

			/* bpf_timer_cancel should return 1 to indicate

			 * that arr_timer was active at this time

 try to cancel ourself. It shouldn't deadlock. */

		/* delete this key and this timer anyway.

		 * It shouldn't deadlock either.

		/* in preallocated hashmap both 'key' and 'val' could have been

		 * reused to store another map element (like in LRU above),

		 * but in controlled test environment the below test works.

		 * It's not a use-after-free. The memory is owned by the map.

 try to cancel ourself. It shouldn't deadlock. */

		/* delete this key and this timer anyway.

		 * It shouldn't deadlock either.

		/* in non-preallocated hashmap both 'key' and 'val' are RCU

		 * protected and still valid though this element was deleted

		 * from the map. Arm this timer for ~35 seconds. When callback

		 * finishes the call_rcu will invoke:

		 * htab_elem_free_rcu

		 *   check_and_free_timer

		 *     bpf_timer_cancel_and_free

		 * to cancel this 35 second sleep and delete the timer for real.

 number of times to trigger timer_cb2 */

 update the same key to free the timer */

 update the same key to free the timer */

	/* init more timers to check that htab operations

	 * don't leak timer memory.

 and with non-prealloc htab */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)

 Copyright (c) 2019 Facebook

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 SPDX-License-Identifier: GPL-2.0 */

 Copyright (c) 2021 Hengqi Chen */

 SPDX-License-Identifier: GPL-2.0

 Update results */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020, Oracle and/or its affiliates.

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook

 inputs */

 outputs */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook */

/* Though test_pkt_access_subprog2() is defined in C as:

 * static __attribute__ ((noinline))

 * int test_pkt_access_subprog2(int val, volatile struct __sk_buff *skb)

 * {

 *     return skb->len * val;

 * }

 * llvm optimizations remove 'int val' argument and generate BPF assembly:

 *   r0 = *(u32 *)(r1 + 0)

 *   w0 <<= 1

 *   exit

 * In such case the verifier falls back to conservative and

 * tracing program can access arguments and return value as u64

 * instead of accurate types.

	/* bpf_prog_load() loads "test_pkt_access.o" with BPF_F_TEST_RND_HI32

	 * which randomizes upper 32 bits after BPF_ALU32 insns.

	 * Hence after 'w0 <<= 1' upper bits of $rax are random.

	 * That is expected and correct. Trim them.

 original get_skb_len() returns skb->len */

 check that BPF extension can read packet via direct packet access */

 check that legacy packet access helper works too */

 original get_skb_ifindex() returns val * ifindex * var */

 original get_constant() returns val - 122 */

 make modifications to the packet data */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 stop the iteration */

 SPDX-License-Identifier: GPL-2.0

/* Copyright (c) 2017 Facebook

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of version 2 of the GNU General Public

 * License as published by the Free Software Foundation.

/* This program shows clang/llvm is able to generate code pattern

 * like:

 *   _tcp_send_active_reset:

 *      0:       bf 16 00 00 00 00 00 00         r6 = r1

 *    ......

 *    335:       b7 01 00 00 0f 00 00 00         r1 = 15

 *    336:       05 00 48 00 00 00 00 00         goto 72

 *

 *   LBB0_3:

 *    337:       b7 01 00 00 01 00 00 00         r1 = 1

 *    338:       63 1a d0 ff 00 00 00 00         *(u32 *)(r10 - 48) = r1

 *    408:       b7 01 00 00 03 00 00 00         r1 = 3

 *

 *   LBB0_4:

 *    409:       71 a2 fe ff 00 00 00 00         r2 = *(u8 *)(r10 - 2)

 *    410:       bf a7 00 00 00 00 00 00         r7 = r10

 *    411:       07 07 00 00 b8 ff ff ff         r7 += -72

 *    412:       bf 73 00 00 00 00 00 00         r3 = r7

 *    413:       0f 13 00 00 00 00 00 00         r3 += r1

 *    414:       73 23 2d 00 00 00 00 00         *(u8 *)(r3 + 45) = r2

 *

 * From the above code snippet, the code generated by the compiler

 * is reasonable. The "r1" is assigned to different values in basic

 * blocks "_tcp_send_active_reset" and "LBB0_3", and used in "LBB0_4".

 * The verifier should be able to handle such code patterns.

/* This test case needs "sock" and "pt_regs" data structure.

 * Recursively, "sock" needs "sock_common" and "inet_sock".

 * However, this is a unit test case only for

 * verifier purpose without bpf program execution.

 * We can safely mock much simpler data structures, basically

 * only taking the necessary fields from kernel headers.

/* Define various data structures for state recording.

 * Some fields are not used due to test simplification.

/* The below data structure is packed in order for

 * llvm compiler to generate expected code.

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 runner doesn't search for \t, just ensure it compiles */

 non-NULL fmt w/ NULL data should result in error */

 SPDX-License-Identifier: GPL-2.0-only

 SPDX-License-Identifier: GPL-2.0-only

 Copyright (c) 2020 Facebook */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 unused */

 callback for inner hash map */

 Do a lookup to make sure 'map' and 'key' pointers are correct */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2020 Google LLC.

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 /* Matches map2 definition in linked_maps2.c. Order of the attributes doesn't

  * matter.

/* This should be the winning map definition, but we have no way of verifying,

 * so we just make sure that it links and works without errors

 update values with key = 1 */

 lookup values with key = 2, set in another file */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Isovalent, Inc.

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook

 inputs */

 outputs */

 inner state */

 copy from reserved sample to a new one... */

 ...and then discard reserved sample */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 face:b00c:1234:5678::abcd */

	/* This write/read is a bit pointless but tests the verifier and

	 * strparser handler for read/write pkt data and access into sk

	 * fields.

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2018 Politecnico di Torino

 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 don't override the exit code */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Google LLC. */

 Convenient values to pretty-print */

 Integer types */

 IP addresses */

 Symbol lookup formatting */

 Kernel pointers */

 Strings and single-byte character embedding */

 Overflow */

 Padding of fixed width numbers */

 No args */

 No buffer */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

*/

 undef #define UNROLL */

*/

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 Testing delete */

 SPDX-License-Identifier: GPL-2.0

/* fails to load without expected_attach_type = BPF_XDP_DEVMAP

 * because of access to egress_ifindex

 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)

/*

 * BTF-to-C dumper test for multi-dimensional array output.

 *

 * Copyright (c) 2019 Facebook

 ----- START-EXPECTED-OUTPUT ----- */

 ------ END-EXPECTED-OUTPUT ------ */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook

 write to stack */

 ignore spurious events */

 get required size */

 ignore spurious events */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook */

 Always return CG_OK so that no pkt will be filtered out */

	/* Not the testing egress traffic or

	 * TCP_LISTEN (10) socket will be copied at the ingress side.

 Server socket */

 Client socket */

 Not the testing egress traffic */

 It must be a fullsock for cgroup_skb/egress prog */

 Not the testing egress traffic */

 The userspace has created it for srv sk */

	/* Even both cnt and cnt10 have lock defined in their BTF,

	 * intentionally one cnt takes lock while one does not

	 * as a test for the spinlock support in BPF_MAP_TYPE_SK_STORAGE.

 Not the testing ingress traffic to the server */

 Only interested in TCP_LISTEN */

 It must be a fullsock for cgroup_skb/ingress prog */

 SPDX-License-Identifier: GPL-2.0

 EPERM, bounds check */

 EPERM, unexpected optval from the kernel */

 Reset system call return value to zero */

 EPERM, bounds check */

 EPERM, unexpected optval from the kernel */

 Reset system call return value to zero */

 EPERM, bounds check */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook

 tcp_mem sysctl has only 3 ints, but this test is doing TCP_MEM_LOOPS */

 because 30 doesn't fit into 512 bytes of stack */

 SPDX-License-Identifier: GPL-2.0

/**

 * SOL_TCP is defined in <netinet/tcp.h> while

 * TCP_SAVED_SYN is defined in already included <linux/tcp.h>

 Test reading fields in bpf_sock_ops using single register */

 Test failure to set largest cb flag (assumes not defined) */

 Set callback */

 Update global map w/ result of setsock opt */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook

 return value thats in invalid range

 SPDX-License-Identifier: GPL-2.0-only

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook

 pragma unroll doesn't work on large loops */

 90 calls */

 SPDX-License-Identifier: GPL-2.0-only

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2018 Facebook

 taken from /sys/kernel/debug/tracing/events/random/urandom_read/format */

 skip if non-zero *value_p */

 The size of stackmap and stackid_hmap should be the same */

 SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause

 Copyright (c) 2020 Cloudflare

 Macros for least-significant byte and word accesses. */

 Addressable key/value constants for convenience */

 Host byte order */

 Redirect packets destined for port DST_PORT to socket at redir_map[0]. */

 Redirect packets destined for DST_IP4 address to socket at redir_map[0]. */

 Redirect packets destined for DST_IP6 address to socket at redir_map[0]. */

 Check that bpf_sk_assign() returns -EEXIST if socket already selected. */

 Success, redirect to KEY_SERVER_B */

 Check that bpf_sk_assign(BPF_SK_LOOKUP_F_REPLACE) can override selection. */

 Success, redirect to KEY_SERVER_B */

 Check that bpf_sk_assign(sk=NULL) is accepted. */

 Success, redirect to KEY_SERVER_B */

 Check that selected sk is accessible through context. */

 Try accessing unassigned (NULL) ctx->sk field */

 Assign a value to ctx->sk */

 Access ctx->sk fields */

 Reset selection */

 Assign another socket */

 Access reassigned ctx->sk fields */

 Success, redirect to KEY_SERVER_B */

/* Check narrow loads from ctx fields that support them.

 *

 * Narrow loads of size >= target field size from a non-zero offset

 * are not covered because they give bogus results, that is the

 * verifier ignores the offset.

 Narrow loads from family field */

 Narrow loads from protocol field */

 Narrow loads from remote_port field. Expect SRC_PORT. */

 Narrow loads from local_port field. Expect DST_PORT. */

 Narrow loads from IPv4 fields */

 Expect SRC_IP4 in remote_ip4 */

 Expect DST_IP4 in local_ip4 */

 Expect 0.0.0.0 IPs when family != AF_INET */

 Narrow loads from IPv6 fields */

 Expect SRC_IP6 in remote_ip6 */

 Expect DST_IP6 in local_ip6 */

 Expect :: IPs when family != AF_INET6 */

 Success, redirect to KEY_SERVER_B */

 Check that sk_assign rejects SERVER_A socket with -ESOCKNOSUPPORT */

 Success, pass to regular lookup */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0-only

/* Copyright (c) 2017 Facebook

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2020 Google LLC.

 MAC header is not set by the time cgroup_skb/egress triggers */

 SPDX-License-Identifier: GPL-2.0

 Copyright Amazon.com Inc. or its affiliates. */

			/* The name of the abstract UNIX domain socket starts

			 * with '\0' and can contain '\0'.  The null bytes

			 * should be escaped as done in unix_seq_show().

 unix_mkname() tests this upper bound. */

 SPDX-License-Identifier: GPL-2.0

 Force local address to 127.0.0.1:22222. */

 Rewire service 1.2.3.4:60000 to backend 127.0.0.1:60123. */

 Expose local server as 1.2.3.4:60000 to client. */

 Expose service 1.2.3.4:60000 as peer instead of backend. */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause) */

 Sample program which should always load for testing control paths. */

 SPDX-License-Identifier: GPL-2.0

 172.16.1.100 */

 172.16.2.100 */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook */

 non-existing symbol, weak, default to zero */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020, Oracle and/or its affiliates. */

 NULL task or task->fs, don't count it as an error. */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020, Oracle and/or its affiliates. */

 NULL points to a readable struct lowcore on s390, so take the last page */

 Use where expected data string matches its stringified declaration */

/* TRACE_EVENT(netif_receive_skb,

 *	TP_PROTO(struct sk_buff *skb),

 Ensure we can write skb string representation */

 Check invalid ptr value */

 Verify type display for various types. */

 simple int */

 zero value should be printed at toplevel */

 simple char */

 zero value should be printed at toplevel */

 simple typedef */

 zero value should be printed at toplevel */

 typedef struct */

 typedef with 0 value should be printed at toplevel */

 enum where enum value does (and does not) exist */

 simple struct */

 empty struct should be printed */

 struct with pointers */

 NULL pointer should not be displayed */

 struct with char array */

 leading null char means do not display string */

 handle non-printable characters */

 struct with non-char array */

 For non-char, arrays, show non-zero values only */

 struct with bitfields */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook

 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)

/*

 * BTF-to-C dumper tests for struct packing determination.

 *

 * Copyright (c) 2019 Facebook

 ----- START-EXPECTED-OUTPUT ----- */

------ END-EXPECTED-OUTPUT ------ */

 SPDX-License-Identifier: GPL-2.0

 only interested in SOL_CUSTOM */

 EPERM, bounds check */

 EPERM, couldn't get sk storage */

 Reset system call return value to zero */

 only interested in SOL_CUSTOM */

 EPERM, bounds check */

 EPERM, couldn't get sk storage */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook

/* clang will not unroll the loop 600 times.

 * Instead it will unroll it to the amount it deemed

 * appropriate, but the loop will still execute 600 times.

 * Total program size is around 90k insns

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 SPDX-License-Identifier: GPL-2.0-only

 Copyright (c) 2020 Facebook */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 will set before prog run */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 only dump map1_id and map2_id */

 fill seq_file buffer */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2020 Google LLC.

 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)

 Copyright (c) 2019 Facebook

 full unroll by llvm #undef NO_UNROLL */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 ret should be 2 */

 ret should be 12 */

 SPDX-License-Identifier: GPL-2.0

 Data length determine test case */

 sizeof(pkt_v4) */

 test too large offset */

 sizeof(pkt_v6) */

 Max tail grow 3520 */

 No matching test */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook

 fixed two first members, can be extended with new fields */

 record two different relocations with the same accessor string */

 accessor: 0:0 */

 accessor: 0:0 */

	/* Validate relocations capture array-only accesses for structs with

	 * fixed header, but with potentially extendable tail. This will read

	 * first 4 bytes of 2nd element of in_ext array of potentially

 accessor: 2 */

 SPDX-License-Identifier: GPL-2.0

 invalid */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)

/*

 * BTF-to-C dumper test for majority of C syntax quirks.

 *

 * Copyright (c) 2019 Facebook

 ----- START-EXPECTED-OUTPUT ----- */

 ------ END-EXPECTED-OUTPUT ------ */

/*

 * While previous function pointers are pretty trivial (C-syntax-level

 * trivial), the following are deciphered here for future generations:

 *

 * - `fn_ptr2_t`: function, taking anonymous struct as a first arg and pointer

 *   to a function, that takes int and returns int, as a second arg; returning

 *   a pointer to a const pointer to a char. Equivalent to:

 *	typedef struct { int a; } s_t;

 *	typedef int (*fn_t)(int);

 *	typedef char * const * (*fn_ptr2_t)(s_t, fn_t);

 *

 * - `fn_complext_t`: pointer to a function returning struct and accepting

 *   union and struct. All structs and enum are anonymous and defined inline.

 *

 * - `signal_t: pointer to a function accepting a pointer to a function as an

 *   argument and returning pointer to a function as a result. Sane equivalent:

 *	typedef void (*signal_handler_t)(int);

 *	typedef signal_handler_t (*signal_ptr_t)(int, signal_handler_t);

 *

 * - fn_ptr_arr1_t: array of pointers to a function accepting pointer to

 *   a pointer to an int and returning pointer to a char. Easy.

 *

 * - fn_ptr_arr2_t: array of const pointers to a function taking no arguments

 *   and returning a const pointer to a function, that takes pointer to a

 *   `int -> char *` function and returns pointer to a char. Equivalent:

 *   typedef char * (*fn_input_t)(int);

 *   typedef char * (*fn_output_outer_t)(fn_input_t);

 *   typedef const fn_output_outer_t (* fn_output_inner_t)();

 *   typedef const fn_output_inner_t fn_ptr_arr2_t[5];

 ----- START-EXPECTED-OUTPUT ----- */

 ------ END-EXPECTED-OUTPUT ------ */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook

 define few struct-s that bpf program needs to access */

 same as kernel's struct net_device */ {

 field names and sizes should match to those in the kernel */

 order of the fields doesn't matter */

/* TRACE_EVENT(kfree_skb,

 *         TP_PROTO(struct sk_buff *skb, void *location),

 read eth proto */

 raw tp ignores return value */

 send first 72 byte of the packet to user space */

 fentry sees full packet including L2 header */

	/* fexit sees packet without L2 header that eth_type_trans should have

	 * consumed.

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook

 NAMED_ENUM_VAL3 value is optional */

 ANON_ENUM_VAL3 value is optional */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook

 unsigned bitfields */

 signed bitfields */

 non-bitfields */

 bitfield read results, all as plain integers */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 SPDX-License-Identifier: GPL-2.0

 192.168.1.254 */

 127.0.0.1 */

 Socket in test case has guarantee that old never equals to new. */

 u8 narrow loads:

 u16 narrow loads:

 Bind to device and unbind it. */

 Test for misc socket options. */

 Set reuseport and unset */

 SPDX-License-Identifier: GPL-2.0

 Dummy prog to test TC-BPF API */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0-only

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2018 Facebook

/*

 * These three programs get executed in a row on connect() syscalls. The

 * userspace side of the test creates a client socket, issues a connect() on it

 * and then checks that the local storage associated with this socket has:

 * cookie_value == local_port << 8 | 0xFF

 * The different parts of this cookie_value are appended by those hooks if they

 * all agree on the output of bpf_get_socket_cookie().

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2018 Facebook

 taken from /sys/kernel/debug/tracing/events/sched/sched_switch/format */

 skip if non-zero *value_p */

 The size of stackmap and stackid_hmap should be the same */

 SPDX-License-Identifier: GPL-2.0-only

 Copyright (c) 2020 Facebook */

 type mismatch */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 .bss */

 .data */

 ignore irrelevant invocations */

 ignore irrelevant invocations */

 ignore irrelevant invocations */

 ignore irrelevant invocations */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 weak and shared between two files */

 same "subprog" name in all files, but it's ok because they all are static */

 but different formula */

 Global functions can't be void */

/* This function can't be verified as global, as it assumes raw_tp/sys_enter

 * context and accesses syscall id (second argument). So we mark it as

 * __hidden, so that libbpf will mark it as static in the final object file,

 * right before verifying it in the kernel.

 *

 * But we don't mark it as __hidden here, rather at extern site. __hidden is

 * "contaminating" visibility, so it will get propagated from either extern or

 * actual definition (including from the losing __weak definition).

 long id, same as in BPF_PROG below */

 this weak instance should win because it's the first one */

 here we'll force set_output_ctx2() to be __hidden in the final obj file */

 ctx definition is hidden in BPF_PROG macro */

	/* keep input value the same across both files to avoid dependency on

	 * handler call order; differentiate by output_weak1 vs output_weak2.

 SPDX-License-Identifier: GPL-2.0

/* Copyright (c) 2018 Facebook

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of version 2 of the GNU General Public

 * License as published by the Free Software Foundation.

 sizeof(pkt_v4) */

 shrink too much */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright 2020 Google LLC.

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2018 Facebook

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 stop the iteration */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 out of bound access w.r.t. hashmap1 */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 impossible path */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 It was in cookie mode */

 Is it the testing traffic? */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright 2020 Google LLC.

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Isovalent, Inc. */

 This will make map creation to fail */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook

 pragma unroll doesn't work on large loops */

 90 calls */

 SPDX-License-Identifier: GPL-2.0 */

 Copyright (c) 2018 Facebook */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook

 only pass through sys_enters from test process */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 filter out udp6 sockets */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook

 spin_lock in hash map */

 spin_lock in array */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Cloudflare

 toggled by user-space */

 toggled by user-space */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0-only

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

*/

 SPDX-License-Identifier: GPL-2.0-only

 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)

 Copyright (c) 2019 Facebook

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook */

 SPDX-License-Identifier: GPL-2.0 */

 Copyright (c) 2018 Covalent IO, Inc. http:
 Fill 'tuple' with L3 info, and attempt to find L4. On fail, return NULL. */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2018 Facebook */

	/*

	 * The ip_protocol could be a compile time decision

	 * if the bpf_prog.o is dedicated to either TCP or

	 * UDP.

	 *

	 * Otherwise, reuse_md->ip_protocol or

	 * the protocol field in the iphdr can be used.

			/* The connection is being torn down at the end of a

			 * test. It can't contain a cmd, so return early.

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook

 data_map[2] = in_val; */

 data_map[1] = data_map[0] * 2; */

 data_map[far] = in_val * 3; */

 Packet parsing state machine helpers. */

 cur_off = end of segments, start of possible TLVs

 we can only go as far as ~10 TLVs due to the BPF max stack size

 we reached the padding or HMAC TLVs, or the end of the SRH

 the following can't be moved inside update_tlv_pad because the

 bpf verifier has some issues with it

 cannot pad for 1 byte only

 cannot pad for 1 byte only

 check if egress TLV value is correct

 This function will push a SRH with segments fd00::1, fd00::2, fd00::3,

 fd00::4

 room for 4 segments

 Add an Egress TLV fc00::4, add the flag A,

 and apply End.X action to fc42::1

 Pop the Egress TLV, reset the flags, change the tag 2442 and finally do a

 simple End action

 4 segments + Egress TLV + Padding TLV

 Inspect if the Egress TLV and flag have been removed, if the tag is correct,

 then apply a End.T action to reach the last segment

 4 segments

 SPDX-License-Identifier: GPL-2.0

 set all the flags which should return -EINVAL */

 SPDX-License-Identifier: GPL-2.0-only

 Copyright (c) 2020 Facebook */

 type mismatch */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook

 unsigned bitfields */

 signed bitfields */

 non-bitfields */

 bitfield read results, all as plain integers */

 SPDX-License-Identifier: GPL-2.0-only

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook

 SPDX-License-Identifier: GPL-2.0

 the maximum delay we are willing to add (drop packets beyond that) */

 flow_key => last_tstamp timestamp used */

 should we throttle? */

 do not queue past the time horizon */

 set ecn bit, if needed */

 drop malformed packets */

 drop malformed packets */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2018 Facebook

	/* [1] &level passed to external function that may change it, it's

	 *     incompatible with loop unroll.

	/* Loop unroll can't be used here due to [1]. Unrolling manually.

	 * Number of calls should be in sync with NUM_CGROUP_LEVELS.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright 2020 Google LLC.

 lsm/ is ok, lsm.s/ fails */

 SPDX-License-Identifier: GPL-2.0

 192.168.1.254 */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

		/* FIXME: temporary use bpf_probe_read_kernel here, needs

		 * verifier support to do direct access.

		/* FIXME: container_of inside SOCK_INODE has a forced

		 * type conversion, and direct access cannot be used

		 * with current verifier.

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

	/* max entries and value_size will be set programmatically.

	 * They are configurable from the userspace bench program.

	/* max entries,  value_size, and # of hash functions will be set

	 * programmatically. They are configurable from the userspace

	 * bench program.

	/* max entries, key_size, and value_size, will be set

	 * programmatically. They are configurable from the userspace

	 * bench program.

 Tracks the number of hits, drops, and false hits */

 stop the iteration */

 SPDX-License-Identifier: GPL-2.0 */

 Copyright (c) 2018 Facebook */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Cloudflare Ltd.

 Copyright (c) 2020 Isovalent, Inc.

 Pin map under /sys/fs/bpf/tc/globals/<map name> */

 Must match struct bpf_elf_map layout from iproute2 */

 Fill 'tuple' with L3 info, and attempt to find L4. On fail, return NULL. */

 Options are not supported */

	/* Note that the verifier socket return type for bpf_skc_lookup_tcp()

	 * differs from bpf_sk_lookup_udp(), so even though the C-level type is

	 * the same here, if we try to share the implementations they will

	 * fail to verify because we're crossing pointer types.

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

	/* The implementation here tailored to a particular

	 * setting of USER_HZ.

 SPDX-License-Identifier: GPL-2.0

 test ir decoder



 Copyright (C) 2018 Sean Young <sean@mess.org>

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2017 Facebook

 taken from /sys/kernel/debug/tracing/events/sched/sched_switch/format */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

	/* The implementation here tailored to a particular

	 * setting of USER_HZ.

 SPDX-License-Identifier: GPL-2.0

/*

 * Check if we can migrate child sockets.

 *

 *   1. If reuse_md->migrating_sk is NULL (SYN packet),

 *        return SK_PASS without selecting a listener.

 *   2. If reuse_md->migrating_sk is not NULL (socket migration),

 *        select a listener (reuseport_map[migrate_map[cookie]])

 *

 * Author: Kuniyuki Iwashima <kuniyu@amazon.co.jp>

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 +1 for flags */

 RESEND bit does not use a byte */

 +1 kind, +1 kind-len */

 bpf_test_option is not found */

		/* We should not even be called since no header

		 * space has been reserved.

	/* Same as the nodata version.  Mostly to show

	 * an example usage on skops->skb_len.

 Reserve maximum that may be needed */

 The kernel is calculating the MSS */

		/* Don't clear the write_hdr cb now because

		 * the ACK may get lost and retransmit may

		 * be needed.

		 *

		 * PARSE_ALL_HDR cb flag is set to learn if this

		 * resend_syn option has received by the peer.

		 *

		 * The header option will be resent until a valid

		 * packet is received at handle_parse_hdr()

		 * and all hdr cb flags will be cleared in

		 * handle_parse_hdr().

 No options will be written from now */

		/* saved_syn is not found. It was in syncookie mode.

		 * We have asked the active side to resend the options

		 * in ACK, so try to find the bpf_test_option from ACK now.

	/* ENOMSG: The bpf_test_option is not found which is fine.

	 * Bail out now for all other errors.

 Fastopen */

		/* Cannot clear cb_flags to stop write_hdr cb.

		 * synack is not sent yet for fast open.

		 * Even it was, the synack may need to be retransmitted.

		 *

		 * PARSE_ALL_HDR cb flag is set to learn

		 * if synack has reached the peer.

		 * All cb_flags will be cleared in handle_parse_hdr().

 No options will be written from now */

		/* The PARSE_ALL_HDR cb flag was turned on

		 * to ensure that the previously written

		 * options have reached the peer.

		 * Those previously written option includes:

		 *     - Active side: resend_syn in ACK during syncookie

		 *      or

		 *     - Passive side: SYNACK during fastopen

		 *

		 * A valid packet has been received here after

		 * the 3WHS, so the PARSE_ALL_HDR cb flag

		 * can be cleared now.

		/* Active side resent the syn option in ACK

		 * because the server was in syncookie mode.

		 * A valid packet has been received, so

		 * clear header cb flags if there is no

		 * more option to send.

		/* Passive side was in fastopen.

		 * A valid packet has been received, so

		 * the SYNACK has reached the peer.

		 * Clear header cb flags if there is no more

		 * option to send.

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook

 some types are shared with test_core_reloc_type_based.c */

 preserve types even if Clang doesn't support built-in */

	/* We use __builtin_btf_type_id() in this tests, but up until the time

	 * __builtin_preserve_type_info() was added it contained a bug that

	 * would make this test fail. The bug was fixed ([0]) with addition of

	 * __builtin_preserve_type_info(), though, so that's what we are using

	 * to detect whether this test has to be executed, however strange

	 * that might look like.

	 *

	 *   [0] https://reviews.llvm.org/D85174

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook

 pragma unroll doesn't work on large loops */

 90 calls */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook

 shuffled layout for relocatable (CO-RE) reads */

	/* next pointers for kernel address space have to be initialized from

	 * BPF side, user-space mmaped addresses are stil user-space addresses

 SPDX-License-Identifier: GPL-2.0

 Permit pretty deep stack traces */

/* Allocate per-cpu space twice the needed. For the code below

 *   usize = bpf_get_stack(ctx, raw_data, max_len, BPF_F_USER_STACK);

 *   if (usize < 0)

 *     return 0;

 *   ksize = bpf_get_stack(ctx, raw_data + usize, max_len - usize, 0);

 *

 * If we have value_size = MAX_STACK_RAWTP * sizeof(__u64),

 * verifier will complain that access "raw_data + usize"

 * with size "max_len - usize" may be out of bound.

 * The maximum "raw_data + usize" is "raw_data + max_len"

 * and the maximum "max_len - usize" is "max_len", verifier

 * concludes that the maximum buffer access range is

 * "raw_data[0...max_len * 2 - 1]" and hence reject the program.

 *

 * Doubling the to-be-used max buffer size can fix this verifier

 * issue and avoid complicated C programming massaging.

 * This is an acceptable workaround since there is one entry here.

 write both kernel and user stacks to the same buffer */

 SPDX-License-Identifier: GPL-2.0

 IPPROTO_GRE */

 172.16.1.100 */

 172.16.16.100 */

 172.16.1.100 */

 172.16.16.100 */

 IPPROTO_GRE */

 fb01::1 */

 fb10::1 */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 options received at passive side */

 Check the header received from the active side */

 IPv6 (40) + Max TCP hdr (60) */

 The option is 4 bytes long instead of 2 bytes */

 Test searching magic with regular kind */

 Test searching experimental option with invalid kind length */

 Test searching experimental option with 0 magic value */

	/* Test loading from skops->syn_skb if sk_state == TCP_NEW_SYN_RECV

	 *

	 * Test loading from tp->saved_syn for other sk_state.

	/* Reserve more than enough to allow the -EEXIST test in

	 * the write_active_opt().

 Store the same exprm option */

 Check the option has been written and can be searched */

		/* Search the win scale option written by kernel

		 * in the SYN packet.

		/* Write the win scale option that kernel

		 * has already written.

 Check the SYN from bpf_sock_ops_kern->syn_skb */

 Passive side should have cleared the write hdr cb by now */

	/* Passive side is not writing any non-standard/unknown

	 * option, so the active side should never be called.

 No more write hdr cb */

 Recheck the SYN but check the tp->saved_syn this time */

 The ack has header option written by the active side also */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook

 Max supported length of a string with unsigned long in base 10 (pow2 - 1). */

 Max supported length of sysctl value string (pow2). */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2018 Covalent IO, Inc. http:
 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook

 int a.a.a and b.b.b accesses */

 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)

/*

 * BTF-to-C dumper test for topological sorting of dependent structs.

 *

 * Copyright (c) 2019 Facebook

 ----- START-EXPECTED-OUTPUT ----- */

------ END-EXPECTED-OUTPUT ------ */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 fields of exactly the same size */

 unsigned fields that have to be downsized by libbpf */

 total sz: 40 */

 fields with signed integers of wrong size, should be rejected */

 real layout and sizes according to test's (32-bit) BTF */

 can't use `void *`, it is always 8 byte in BPF target */

 total sz: 20 */

 make sure no accidental zeros are present */

 Prevent "subtraction from stack pointer prohibited" */ \

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Google */

 percpu struct fields */

 percpu int */

 cpu_rq(0)->cpu */

 struct type global var. */

 int type global var. */

 test bpf_per_cpu_ptr() */

 should always be valid, but we can't spare the check. */

 test bpf_this_cpu_ptr */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

/* SPDX-License-Identifier: GPL-2.0

 *  Copyright(c) 2018 Jesper Dangaard Brouer.

 *

 * XDP/TC VLAN manipulation example

 *

 * GOTCHA: Remember to disable NIC hardware offloading of VLANs,

 * else the VLAN tags are NOT inlined in the packet payload:

 *

 *  # ethtool -K ixgbe2 rxvlan off

 *

 * Verify setting:

 *  # ethtool -k ixgbe2 | grep rx-vlan-offload

 *  rx-vlan-offload: off

 *

/* linux/if_vlan.h have not exposed this as UAPI, thus mirror some here

 *

 *	struct vlan_hdr - vlan header

 *	@h_vlan_TCI: priority and VLAN ID

 *	@h_vlan_encapsulated_proto: packet type ID or len

 Priority Code Point */

 Canonical Format Indicator */

 VLAN Identifier */

 Make sure packet is large enough for parsing eth + 2 VLAN headers */

 Handle outer VLAN tag */

 Handle inner (double) VLAN tag */

 Convert to host-byte-order */

 Hint, VLANs are choosen to hit network-byte-order issues */

 0xFAB */

 #define TO_VLAN  4000 /* 0xFA0 (hint 0xOA0 = 160) */

 Drop specific VLAN ID example */

	/*

	 * Using XDP_ABORTED makes it possible to record this event,

	 * via tracepoint xdp:xdp_exception like:

	 *  # perf record -a -e xdp:xdp_exception

	 *  # perf script

/*

Commands to setup VLAN on Linux to test packets gets dropped:



 export ROOTDEV=ixgbe2

 export VLANID=4011

 ip link add link $ROOTDEV name $ROOTDEV.$VLANID type vlan id $VLANID

 ip link set dev  $ROOTDEV.$VLANID up



 ip link set dev $ROOTDEV mtu 1508

 ip addr add 100.64.40.11/24 dev $ROOTDEV.$VLANID



Load prog with ip tool:



 ip link set $ROOTDEV xdp off

 ip link set $ROOTDEV xdp object xdp_vlan01_kern.o section xdp_drop_vlan_4011



 Changing VLAN to zero, have same practical effect as removing the VLAN. */

 Change specific VLAN ID */

 Modifying VLAN, preserve top 4 bits */

/*

 * Show XDP+TC can cooperate, on creating a VLAN rewriter.

 * 1. Create a XDP prog that can "pop"/remove a VLAN header.

 * 2. Create a TC-bpf prog that egress can add a VLAN header.

 Ethernet MAC address length */

 bytes */

 bytes */

 Skip packet if no outer VLAN was detected */

 Moving Ethernet header, dest overlap with src, memmove handle this */

	/*

	 * Notice: Taking over vlan_hdr->h_vlan_encapsulated_proto, by

	 * only moving two MAC addrs (12 bytes), not overwriting last 2 bytes

 Note: LLVM built-in memmove inlining require size to be constant */

 Move start of packet header seen by Linux kernel stack */

 delete p[7] was vlan_hdr->h_vlan_TCI */

 delete p[6] was ethhdr->h_proto */

	/* Assuming VLAN hdr present. The 4 bytes in p[3] that gets

	 * overwritten, is ethhdr->h_proto and vlan_hdr->h_vlan_TCI.

	 * The vlan_hdr->h_vlan_encapsulated_proto take over role as

	 * ethhdr->h_proto.

 Skip packet if no outer VLAN was detected */

 Simply shift down MAC addrs 4 bytes, overwrite h_proto + TCI */

 Move start of packet header seen by Linux kernel stack */

/*=====================================

 *  BELOW: TC-hook based ebpf programs

 * ====================================

 * The TC-clsact eBPF programs (currently) need to be attach via TC commands

/*

Commands to setup TC to use above bpf prog:



export ROOTDEV=ixgbe2

export FILE=xdp_vlan01_kern.o



# Re-attach clsact to clear/flush existing role

tc qdisc del dev $ROOTDEV clsact 2> /dev/null ;\

tc qdisc add dev $ROOTDEV clsact



# Attach BPF prog EGRESS

tc filter add dev $ROOTDEV egress \

  prio 1 handle 1 bpf da obj $FILE sec tc_vlan_push



tc filter show dev $ROOTDEV egress

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)

/*

 * BTF-to-C dumper tests for bitfield.

 *

 * Copyright (c) 2019 Facebook

 ----- START-EXPECTED-OUTPUT ----- */

/*

 *struct bitfields_only_mixed_types {

 *	int a: 3;

 *	long b: 2;

 *	_Bool c: 1;

 *	enum {

 *		A = 0,

 *		B = 1,

 *	} d: 1;

 *	short e: 5;

 *	int: 20;

 *	unsigned int f: 30;

 *};

 *

 ------ END-EXPECTED-OUTPUT ------ */

 it's really a _Bool type */

 A = 0, dumper is very explicit */

 B = 1, same */

 20-bit padding here */

 this gets aligned on 4-byte boundary */

 ----- START-EXPECTED-OUTPUT ----- */

/*

 *struct bitfield_mixed_with_others {

 *	char: 4;

 *	int a: 4;

 *	short b;

 *	long c;

 *	long d: 8;

 *	int e;

 *	int f;

 *};

 *

 ------ END-EXPECTED-OUTPUT ------ */

 char is enough as a backing field */

 8-bit implicit padding */

 combined with previous bitfield */

 4 more bytes of implicit padding */

 24 bits implicit padding */

 combined with previous bitfield */

 4 bytes of padding */

 ----- START-EXPECTED-OUTPUT ----- */

/*

 *struct bitfield_flushed {

 *	int a: 4;

 *	long: 60;

 *	long b: 16;

 *};

 *

 ------ END-EXPECTED-OUTPUT ------ */

 flush until next natural alignment boundary */

 SPDX-License-Identifier: GPL-2.0

/* invalid program on DEVMAP entry;

 * SEC name means expected attach type not set

/* valid program on DEVMAP entry via SEC name;

 * has access to egress and ingress ifindex

 SPDX-License-Identifier: GPL-2.0-only

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook

 4 byte hole */

 spin_lock in hash map run time test */

 spin_lock in array. virtual queue demo */

 spin_lock in cgroup local storage */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook */

 SPDX-License-Identifier: GPL-2.0 */

 Copyright (c) 2021 Hengqi Chen */

 trigger unix_listen */

 SPDX-License-Identifier: GPL-2.0

 pid */,

 cpu 0 */, -1 
 flags */);

 query (getpid(), pmu_fd) */

 SPDX-License-Identifier: GPL-2.0

 find map fds */

 give some time for bpf program run */

 disable stack trace collection */

	/* for every element in stackid_hmap, we can find a corresponding one

	 * in stackmap, and vise versa.

 SPDX-License-Identifier: GPL-2.0

/*

 * Tests for attaching, detaching, and replacing flow_dissector BPF program.

 Expect success when attaching a different program */

 Expect failure when attaching the same program twice */

 Expect failure creating link when another link exists */

 Expect failure creating link when prog attached */

 Expect failure attaching prog when link exists */

 Expect failure detaching prog when link exists */

 Expect no prog attached after successful detach */

 Expect no prog attached after closing last link FD */

 Expect success replacing the prog when old prog not specified */

 Expect success F_REPLACE and old prog specified to succeed */

 Expect success updating the prog with the same one */

 Expect update to fail w/ old prog FD but w/o F_REPLACE*/

 Expect update to fail on old prog FD mismatch */

 Expect update to fail for invalid old prog FD */

 Expect update to fail with invalid flags */

 Expect failure when new prog FD is not valid */

 Expect failure when new prog FD type doesn't match */

 Expect failure when netns destroyed */

 Expect link info to be sane and match prog and netns details */

 Expect no info change after update except in prog id */

 Leave netns link is attached to and close last FD to it */

 Expect netns_ino to change to 0 */

 First run tests in root network namespace */

 Then repeat tests in a non-root namespace */

 Move back to netns we started in. */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook */

 trigger tracepoint */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 trigger */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 not check contents, but ensure read() ends without error */

 The expected string is less than 16 bytes */

 unlink this path if it exists. */

	/* file based iterator seems working fine. Let us a link update

	 * of the underlying link and `cat` the iterator again, its content

	 * should change.

	/* create two maps: bpf program will only do bpf_seq_write

	 * for these two maps. The goal is one map output almost

	 * fills seq_file buffer and then the other will trigger

	 * overflow and needs restart.

	/* bpf_seq_printf kernel buffer is 8 pages, so one map

	 * bpf_seq_write will mostly fill it, and the other map

	 * will partially fill and then trigger overflow and need

	 * bpf_seq_read restart.

 setup filtering map_id in bpf program */

 do read */

 iterator with hashmap2 and hashmap3 should fail */

 hashmap1 should be good, update map values here */

 do some tests */

 test results */

 update map values here */

 do some tests */

 test results */

 do some tests */

 test results */

 update map values here */

 do some tests */

 test results */

 An iterator program deletes all local storage in a map. */

 do some tests */

 test results */

/* This creates a socket and its local storage. It then runs a task_iter BPF

 * program that replaces the existing socket local storage with the tgid of the

 * only task owning a file descriptor to this socket, this process, prog_tests.

 * It then runs a tcp socket iterator that negates the value in the existing

 * socket local storage, the test verifies that the resulting value is -pid.

 do some tests */

 test results */

 remove \0 and \t from str, and only keep the first line */

	/* Read CMP_BUFFER_SIZE (1kB) from bpf_iter. Read in small chunks

	 * to trigger seq_file corner cases. The expected output is much

	 * longer than 1kB, so the while loop will terminate.

 read CMP_BUFFER_SIZE (1kB) from /proc/pid/maps */

 strip and compare the first line of the two files */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2020 Google LLC.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright 2020 Google LLC.

 TODO: conflict with get_func_ip_test */

 input_retval */,

 want_side_effect */,

 want_ret */);

 input_retval */,

 want_side_effect */,

 want_ret */);

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Data past the end of the kernel's struct xdp_md must be 0 */

 Meta data's size must be a multiple of 4 */

 data_meta must reference the start of data */

 Meta data must be 32 bytes or smaller */

 Total size of data must match data_end - data_meta */

 RX queue cannot be specified without specifying an ingress */

	/* Interface 1 is always the loopback interface which always has only

	 * one RX queue (index 0). This makes index 1 an invalid rx queue index

	 * for interface 1.

 The egress cannot be specified */

 SPDX-License-Identifier: GPL-2.0

 only trigger BPF program for current process */

 trigger few samples, some will be skipped */

 skipped, no ringbuf in slot 1 */

 poll for samples, should get 2 ringbufs back */

 expect extra polling to return nothing */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 Allow fastopen without fastopen cookie */

	/* Clear the RESEND to ensure the bpf prog can learn

	 * want_cookie and set the RESEND by itself.

 Enforce syncookie mode */

 MSG_EOR to ensure skb will not be combined */

 The last ACK may have been delayed, so it is either 1 or 2. */

 SPDX-License-Identifier: GPL-2.0

 BPF_REG_1 - 1st argument: context

 BPF_REG_2 - 2nd argument: offset, start at first byte

 BPF_REG_3 - 3rd argument: destination, reserve byte on stack

 BPF_REG_4 - 4th argument: copy one byte

 bpf_skb_load_bytes(ctx, sizeof(pkt_v4), ptr, 1)

 if (ret == 0) return BPF_DROP (2)

 if (ret != 0) return BPF_OK (0)

	/* make sure bpf_skb_load_bytes is not allowed from skb-less context

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 Load BTF in native endianness */

 Get raw BTF data in non-native endianness... */

 ...and open it as a new BTF instance */

 both raw data should be identical (with non-native endianness) */

 make sure that at least BTF header data is really swapped */

 swap it back to native endianness */

 now header should have native BTF_MAGIC */

 now modify original BTF */

 and re-open swapped raw data again */

 the type should appear as if it was stored in native endianness */

 SPDX-License-Identifier: GPL-2.0

 check that opening fails with invalid pinning value in map def */

 open the valid object file  */

 check that pinmap was pinned */

 check that nopinmap was *not* pinned */

 check that nopinmap2 was *not* pinned */

 check that same map ID was reused for second load */

 should be no-op to re-pin same map */

 but error to pin at different location */

 unpin maps with a pin_path set */

 and re-pin them... */

 get pinning path */

 set pinning path of other map and re-pin all */

 get pinning path after set */

 should only pin the one unpinned map */

 check that nopinmap was pinned at the custom path */

 remove the custom pin path to re-test it with auto-pinning below */

 open the valid object file again */

	/* set pin paths so that nopinmap2 will attempt to reuse the map at

	 * pinpath (which will fail), but not before pinmap has already been

	 * reused

 should fail because of map parameter mismatch */

 nopinmap2 should have been pinned and cleaned up again */

 pinmap should still be there */

 test auto-pinning at custom path with open opt */

 check that pinmap was pinned at the custom path */

 remove the custom pin path to re-test it with reuse fd below */

 test pinning at custom path with reuse fd */

 check that pinmap was pinned at the custom path */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2018 Facebook

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 enforce 64-bit arch */

 [1] int */

 [2] ptr to int */

 [3] struct s1 { */

      int f1; */

 } */

 pointer size should be "inherited" from main BTF */

 [4] struct s2 {	*/

      struct s1 f1;	*/

      int f2;		*/

      int *f3;	*/

 } */

 BTF-to-C dump of split BTF */

 some libc implementations don't do this */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 TCP_CA_NAME_MAX */

 Verify the setsockopt cc change */

 TCP_CA_NAME_MAX */

 destroy can take null and error pointer */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 trigger everything */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 SPDX-License-Identifier: GPL-2.0

 install signal handler and notify parent */

 close read */

 close write */

		/* boost with a high priority so we got a higher chance

		 * that if an interrupt happens, the underlying task

		 * is this process.

 notify parent signal handler is installed */

 make sure parent enabled bpf program to send_signal */

 wait a little for signal handler */

 wait for parent notification and exit */

 restore the old priority */

 close write */

 close read */

 group id */, 0 
 wait until child signal handler installed */

 trigger the bpf send_signal */

 notify child that bpf program can send_signal now */

 wait for result */

 notify child safe to exit */

	/* Some setups (e.g. virtual machines) might run with hardware

	 * perf events disabled. If this is the case, skip this test.

 pid */,

 cpu */, -1  flags */);

 Let the test fail with a more informative message */

 SPDX-License-Identifier: GPL-2.0

 failure cases */

 SPDX-License-Identifier: GPL-2.0

 query the number of effective progs and attach flags in root cg */

 query the number of effective progs in last cg */

 query the effective prog IDs in last cg */

 detach bottom program and ping again */

 mix in with non link-based multi-attachments */

 detach link */

 detach legacy */

 attach legacy exclusive prog attachment */

 attempt to mix in with multi-attach bpf_link */

 detach */

 attach back link-based one */

 check legacy exclusive prog can't be attached */

 replace BPF programs inside their links for all but first link */

 Attempt program update with wrong expected BPF program */

 Compare-exchange single link program from egress to egress_alt */

 ping */

 close cgroup FDs before detaching links */

 BPF programs should still get called */

 cgroup_id should be zero in link_info */

 First BPF program shouldn't be called anymore */

 leave cgroup and remove them, don't detach programs */

 BPF programs should have been auto-detached */

 SPDX-License-Identifier: GPL-2.0

TC_ACT_REDIRECT*/ || size != 54 ||

TC_ACT_REDIRECT*/ || size != 74 ||

 SPDX-License-Identifier: GPL-2.0-only

 Triggers BPF program that updates map with given key and value */

 Setup program and fill the map. */

 Lookup and delete element. */

 Fetched value should match the initially set value. */

 Check that the entry is non existent. */

 Setup program and fill the map. */

 Lookup and delete element. */

 Fetched value should match the initially set value. */

 Check that the entry is non existent. */

 Setup program and fill the LRU map. */

 Insert new element at key=3, should reuse LRU element. */

 Lookup and delete element 3. */

 Value should match the new value. */

 Check that entries 3 and 1 are non existent. */

 Setup program and fill the LRU map. */

 Insert new element at key=3, should reuse LRU element 1. */

 Clean value. */

 Lookup and delete element 3. */

 Check if only one CPU has set the value. */

 Check that entries 3 and 1 are non existent. */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook

 .type = PERF_TYPE_SOFTWARE, */

 pid */,

 cpu 0 */, -1 
 flags */);

 create kernel and user stack traces for testing */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 trigger tracepoint */

 attach fentry/fexit and make sure it get's module reference */

 SPDX-License-Identifier: GPL-2.0-only

 Copyright (c) 2019 Facebook */

 invalid cpu ID should fail with ENXIO */

 non-zero cpu w/o BPF_F_TEST_RUN_ON_CPU should fail with EINVAL */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

		/* If jit is enabled, we do not have a good way to

		 * verify the sanity of the kernel stack. So we

		 * just assume it is good if the stack is not empty.

		 * This could be improved in the future.

 trigger some syscall action */

 SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause

 Copyright (c) 2020 Cloudflare

	/* We want to simulate packets arriving at conn, so we have to

	 * swap src and dst.

 SPDX-License-Identifier: GPL-2.0

 ensure we can lookup internal maps by their ELF names */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook

 load program */

 attach probe */

 trigger */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 trigger everything */

 SPDX-License-Identifier: GPL-2.0

/* Demonstrate that bpf_snprintf_btf succeeds and that various data types

 * are formatted correctly.

 generate receive event */

	/*

	 * Make sure netif_receive_skb program was triggered

	 * and it set expected return values from bpf_trace_printk()s

	 * and all tests ran.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2020 Google LLC.

 Check that already linked program can't be attached again. */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 SPDX-License-Identifier: GPL-2.0

 retprobe */,

 self pid */,

 trigger & validate uprobe */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 enforce 64-bit arch */

 [1] int */

 [2] ptr to int */

 [3] struct s1 { */

      int f1; */

 } */

 pointer size should be "inherited" from main BTF */

 [4] struct s2 {	*/

      struct s1 f1;	*/

      int f2;		*/

      int *f3;	*/

 } */

 duplicated int */

 [5] int */

 duplicated struct s1 */

 [6] struct s1 { */

      int f1; */

 } */

 enforce 64-bit arch */

 [1] int */

 [2] ptr to struct s1 */

 [3] ptr to struct s2 */

 [4] struct s1 { */

      struct s1 *f1; */

      struct s2 *f2; */

 } */

 [5] struct s2 { */

      int f1; */

 } */

 [6] int */

 [7] ptr to struct s1 */

 [8] fwd for struct s2 */

 [9] ptr to fwd struct s2 */

 [10] struct s1 { */

      struct s1 *f1; */

      struct s2 *f2; */

 } */

 enforce 64-bit arch */

 [1] int */

 [2] ptr to struct s1 */

 [3] fwd for struct s2 */

 [4] ptr to fwd struct s2 */

 [5] struct s1 { */

      struct s1 *f1; */

      struct s2 *f2; */

 } */

 [6] int */

 [7] ptr to struct s1 */

 [8] fwd for struct s2 */

 [9] ptr to struct s2 */

 [10] struct s1 { */

      struct s1 *f1; */

      struct s2 *f2; */

 } */

 [11] struct s2 {	*/

      struct s1 *f1;	*/

      struct s2 *f2;	*/

      int f3;		*/

      struct s1 f4;	*/

 } */

 [12] ptr to fwd struct s2 */

 [13] struct s3 { */

      struct s2 *f1; (fwd) */

 } */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Keep in sync with 'flags' from eth_get_headlen. */

		/* For skb-less case we can't pass input flags; run

		 * only the tests that have a matching set of flags.

	/* Do the same tests but for skb-less flow dissector.

	 * We use a known path in the net/tun driver that calls

	 * eth_get_headlen and we manually export bpf_flow_keys

	 * via BPF map in this case.

 Test direct prog attachment */

 Test indirect prog attachment via link */

 SPDX-License-Identifier: GPL-2.0 */

 Copyright (c) 2021 Hengqi Chen */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook

 full unroll by llvm */

 full unroll by llvm */

 full unroll by llvm */

	/* partial unroll. llvm will unroll loop ~150 times.

	 * C loop count -> 600.

	 * Asm loop count -> 4.

	 * 16k insns in loop body.

	 * Total of 5 such loops. Total program size ~82k insns.

	/* no unroll at all.

	 * C loop count -> 600.

	 * ASM loop count -> 600.

	 * ~110 insns in loop body.

	 * Total of 5 such loops. Total program size ~1500 insns.

 fails */);

	/* partial unroll. 19k insn in a loop.

	 * Total program size 20.8k insn.

	 * ~350k processed_insns

 no unroll, tiny loops */

 no unroll, tiny loops */

 non-inlined subprogs */

 SPDX-License-Identifier: GPL-2.0

 NOTE: cause events loss */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2020 Google LLC.

	/* Assert that we can access the metadata in skel and the values are

	 * what we expect.

 Assert that binding metadata map to prog again succeeds. */

	/* Assert that we can access the metadata in skel and the values are

	 * what we expect.

 Assert that binding metadata map to prog again succeeds. */

 SPDX-License-Identifier: GPL-2.0

 Step 1: Check base connectivity works without any BPF. */

 Step 2: Check BPF policy prog attached to cgroups drops connectivity. */

 SPDX-License-Identifier: GPL-2.0-only

 Copyright (c) 2019 Facebook */

 pid */,

 cpu 0 */, -1  flags */);

 closing mfd, prog still holds a reference on map */

 SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause

/*

 * This test sets up 3 netns (src <-> fwd <-> dst). There is no direct veth link

 * between src and dst. The netns fwd has veth links to each src and dst. The

 * client is in src and server in dst. The test installs a TC BPF program to each

 * host facing veth in fwd which calls into i) bpf_redirect_neigh() to perform the

 * neigh addr population and redirect or ii) bpf_redirect_peer() for namespace

 * switch from ingress side; it also installs a checker prog on the egress side

 * to drop unexpected traffic.

	/* Switch /sys to the new namespace so that e.g. /sys/class/net

	 * reflects the devices in the new namespace.

/**

 * open_netns() - Switch to specified network namespace by name.

 *

 * Returns token with which to restore the original namespace

 * using close_netns().

* setup in 'src' namespace */

* setup in 'fwd' namespace */

	/* The fwd netns automatically gets a v6 LL address / routes, but also

	 * needs v4 one in order to start ARP probing. IP4_NET route is added

	 * to the endpoints so that the ARP processing will reply.

* setup in 'dst' namespace */

 bpf_fib_lookup() checks if forwarding is enabled */

	/* Start a L3 TUN/TAP tunnel between the src and dst namespaces.

	 * This test is using TUN/TAP instead of e.g. IPIP or GRE tunnel as those

	 * expose the L2 headers encapsulating the IP packet to BPF and hence

	 * don't have skb in suitable state for this test. Alternative to TUN/TAP

	 * would be e.g. Wireguard which would appear as a pure L3 device to BPF,

	 * but that requires much more complicated setup.

	/* Load "tc_src_l3" to the tun_fwd interface to redirect packets

	 * towards dst, and "tc_dst" to redirect packets

	 * and "tc_chk" on veth_dst_fwd to drop non-redirected packets.

 Setup route and neigh tables */

	/* Run the tests in their own thread to isolate the namespace changes

	 * so they do not affect the environment of other tests.

	 * (specifically needed because of unshare(CLONE_NEWNS) in open_netns())

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 BTF_KIND_INT */

 should re-use previously added "int" string */

 invalid int size */

 invalid encoding */

 NULL name */

 empty name */

 PTR/CONST/VOLATILE/RESTRICT */

 points forward to restrict */

 ARRAY */

 int *[10] */

 STRUCT */

 UNION */

 invalid, non-zero offset */

 ENUM */

 FWDs */

 TYPEDEF */

 FUNC & FUNC_PROTO */

 VAR */

 DATASECT */

 DECL_TAG */

 types appended from the second BTF */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 we don't care about the rest */

 trigger exactly two samples */

 good read/write cons_pos */

 bad writeable prod_pos */

 bad writeable data pages */

 good read-only pages */

 good read-only pages with initial offset */

 only trigger BPF program for current process */

 2 submitted + 1 discarded records */

 poll for samples */

 -EDONE is used as an indicator that we are done */

 we expect extra polling to return nothing */

 now validate consumer position is updated and returned */

 start poll in background w/ long timeout */

 turn off notifications now */

 give background thread a bit of a time */

	/* sleeping arbitrarily is bad, but no better way to know that

	 * epoll_wait() **DID NOT** unblock in background thread

 background poll should still be blocked */

 BPF side did everything right */

 clear flags to return to "adaptive" notification mode */

	/* produce new samples, no notification should be triggered, because

	 * consumer is now behind

 background poll should still be blocked */

 still no samples, because consumer is behind */

 now force notifications */

 now we should get a pending notification */

	/* due to timing variations, there could still be non-notified

	 * samples, so consume them here to collect all the samples

 3 rounds, 2 samples each */

 BPF side did everything right */

 SPDX-License-Identifier: GPL-2.0

 TCP_CA_NAME_MAX */

 IP_TOS - BPF bypass */

 IP_TTL - EPERM */

 SOL_CUSTOM - handled by BPF */

 IP_FREEBIND - BPF can't access optval past PAGE_SIZE */

 SO_SNDBUF is overwritten */

 TCP_CONGESTION can extend the string */

 TCP_ZEROCOPY_RECEIVE triggers */

 rejected by BPF */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook */

 Check that already linked program can't be attached again. */

 zero results for re-attach test */

 SPDX-License-Identifier: GPL-2.0

 r6 is our tp buffer */

 one byte beyond the end of the nbd_request struct */

 SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause

 Copyright (c) 2020 Cloudflare

/*

 * Test BPF attach point for INET socket lookup (BPF_SK_LOOKUP).

 *

 * Tests exercise:

 *  - attaching/detaching/querying programs to BPF_SK_LOOKUP hook,

 *  - redirecting socket lookup to a socket selected by BPF program,

 *  - failing a socket lookup on BPF program's request,

 *  - error scenarios for selecting a socket from BPF program,

 *  - accessing BPF program context,

 *  - attaching and running multiple BPF programs.

 *

 * Tests run in a dedicated network namespace.

 External (address, port) pairs the client sends packets to. */

 Internal (address, port) pairs the server listens/receives at. */

 Add a connected socket to reuseport group */

 for CHECK macro */

 Enabled for UDPv6 sockets for IPv4-mapped IPv6 to work. */

 Late attach reuseport prog so we can have one init path */

 Server socket bound to IPv4-mapped IPv6 address */

 Reply from original destination address. */

 query flags */,

 prog id is still there, but netns_ino is zeroed out */

 want just one server for non-reuseport test */

	/* Regular UDP socket lookup with reuseport behaves

	 * differently when reuseport group contains connected

	 * sockets. Check that adding a connected UDP socket to the

	 * reuseport group does not affect how reuseport works with

	 * BPF socket lookup.

 Add an extra socket to reuseport group */

 Connect the extra socket to itself */

 Read out asynchronous error */

 second server on destination address we should never reach */

 reuseport prog */);

 Read out asynchronous error */

 Put a connected socket in redirect map */

 Try to redirect TCP SYN / UDP packet to a connected socket */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)

/*

 * Tests for libbpf's hashmap.

 *

 * Copyright (c) 2019 Facebook

 force collisions */

	/* set up multimap:

	 * [0] -> 1, 2, 4;

	 * [1] -> 8, 16, 32;

 verify global iteration still works and sees all values */

 iterate values for key 1 */

 iterate values for key 2 */

 force collisions */

 SPDX-License-Identifier: GPL-2.0

	/* BPF program enforces a single UDP socket per cgroup,

	 * verify that.

 We can reopen again after close. */

	/* Make sure the program was invoked the expected

	 * number of times:

	 * - open fd1           - BPF_CGROUP_INET_SOCK_CREATE

	 * - attempt to openfd2 - BPF_CGROUP_INET_SOCK_CREATE

	 * - close fd1          - BPF_CGROUP_INET_SOCK_RELEASE

	 * - open fd1 again     - BPF_CGROUP_INET_SOCK_CREATE

 We should still have a single socket in use */

 SPDX-License-Identifier: GPL-2.0

 can not attach BPF_XDP_DEVMAP program to a device */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 trigger */

 output_weak2 should never be updated */

 SPDX-License-Identifier: GPL-2.0

	/* tests with t->known_ptr_sz have no "long" or "unsigned long" type,

	 * so it's impossible to determine correct pointer size; but if they

	 * do, it should be 8 regardless of host architecture, becaues BPF

	 * target is always 64-bit

		/*

		 * When the test is run with O=, kselftest copies TEST_FILES

		 * without preserving the directory structure.

	/*

	 * Diff test output and expected test output, contained between

	 * START-EXPECTED-OUTPUT and END-EXPECTED-OUTPUT lines in test case.

	 * For expected output lines, everything before '*' is stripped out.

	 * Also lines containing comment start and comment end markers are

	 * ignored. 

{next} " /* ignore comment start/end lines */

		 "out {sub(/^[ \\t]*\\*/, \"\"); print}' '%s' | diff -u - '%s'",

		 test_file, out_file);

	err = system(diff_cmd);

	if (CHECK(err, "diff",

		  "differing test output, output=%s, err=%d, diff cmd:\n%s\n",

		  out_file, err, diff_cmd))

		goto done;



	remove(out_file);



done:

	btf__free(btf);

	return err;

}



static char *dump_buf;

static size_t dump_buf_sz;

static FILE *dump_buf_file;



static void test_btf_dump_incremental(void)

{

	struct btf *btf = NULL;

	struct btf_dump *d = NULL;

	struct btf_dump_opts opts;

	int id, err, i;



	dump_buf_file = open_memstream(&dump_buf, &dump_buf_sz);

	if (!ASSERT_OK_PTR(dump_buf_file, "dump_memstream"))

		return;

	btf = btf__new_empty();

	if (!ASSERT_OK_PTR(btf, "new_empty"))

		goto err_out;

	opts.ctx = dump_buf_file;

	d = btf_dump__new(btf, NULL, &opts, btf_dump_printf);

	if (!ASSERT_OK(libbpf_get_error(d), "btf_dump__new"))

		goto err_out;



 First, generate BTF corresponding to the following C code:

	 */

	id = btf__add_enum(btf, NULL, 4);

	ASSERT_EQ(id, 1, "enum_id");

	err = btf__add_enum_value(btf, "VAL", 1);

	ASSERT_OK(err, "enum_val_ok");



	id = btf__add_int(btf, "int", 4, BTF_INT_SIGNED);

	ASSERT_EQ(id, 2, "int_id");



	id = btf__add_struct(btf, "s", 4);

	ASSERT_EQ(id, 3, "struct_id");

	err = btf__add_field(btf, "x", 2, 0, 0);

	ASSERT_OK(err, "field_ok");



	for (i = 1; i < btf__type_cnt(btf); i++) {

		err = btf_dump__dump_type(d, i);

		ASSERT_OK(err, "dump_type_ok");

	}



	fflush(dump_buf_file);

	dump_buf[dump_buf_sz] = 0; /* some libc implementations don't do this */

	ASSERT_STREQ(dump_buf,

"enum {\n"

"	VAL = 1,\n"

"};\n"

"\n"

"struct s {\n"

"	int x;\n"

"};\n\n", "c_dump1");



 Now, after dumping original BTF, append another struct that embeds

	 */

	fseek(dump_buf_file, 0, SEEK_SET);



	id = btf__add_struct(btf, "s", 4);

	ASSERT_EQ(id, 4, "struct_id");

	err = btf__add_field(btf, "x", 1, 0, 0);

	ASSERT_OK(err, "field_ok");

	err = btf__add_field(btf, "s", 3, 32, 0);

	ASSERT_OK(err, "field_ok");



	for (i = 1; i < btf__type_cnt(btf); i++) {

		err = btf_dump__dump_type(d, i);

		ASSERT_OK(err, "dump_type_ok");

	}



	fflush(dump_buf_file);

	dump_buf[dump_buf_sz] = 0; /* some libc implementations don't do this */

	ASSERT_STREQ(dump_buf,

"struct s___2 {\n"

"	enum {\n"

"		VAL___2 = 1,\n"

"	} x;\n"

"	struct s s;\n"

"};\n\n" , "c_dump1");



err_out:

	fclose(dump_buf_file);

	free(dump_buf);

	btf_dump__free(d);

	btf__free(btf);

}



#define STRSIZE				4096



static void btf_dump_snprintf(void *ctx, const char *fmt, va_list args)

{

	char *s = ctx, new[STRSIZE];



	vsnprintf(new, STRSIZE, fmt, args);

	if (strlen(s) < STRSIZE)

		strncat(s, new, STRSIZE - strlen(s) - 1);

}



static int btf_dump_data(struct btf *btf, struct btf_dump *d,

			 char *name, char *prefix, __u64 flags, void *ptr,

			 size_t ptr_sz, char *str, const char *expected_val)

{

	DECLARE_LIBBPF_OPTS(btf_dump_type_data_opts, opts);

	size_t type_sz;

	__s32 type_id;

	int ret = 0;



	if (flags & BTF_F_COMPACT)

		opts.compact = true;

	if (flags & BTF_F_NONAME)

		opts.skip_names = true;

	if (flags & BTF_F_ZERO)

		opts.emit_zeroes = true;

	if (prefix) {

		ASSERT_STRNEQ(name, prefix, strlen(prefix),

			      "verify prefix match");

		name += strlen(prefix) + 1;

	}

	type_id = btf__find_by_name(btf, name);

	if (!ASSERT_GE(type_id, 0, "find type id"))

		return -ENOENT;

	type_sz = btf__resolve_size(btf, type_id);

	str[0] = '\0';

	ret = btf_dump__dump_type_data(d, type_id, ptr, ptr_sz, &opts);

	if (type_sz <= ptr_sz) {

		if (!ASSERT_EQ(ret, type_sz, "failed/unexpected type_sz"))

			return -EINVAL;

	} else {

		if (!ASSERT_EQ(ret, -E2BIG, "failed to return -E2BIG"))

			return -EINVAL;

	}

	if (!ASSERT_STREQ(str, expected_val, "ensure expected/actual match"))

		return -EFAULT;

	return 0;

}



#define TEST_BTF_DUMP_DATA(_b, _d, _prefix, _str, _type, _flags,	\

			   _expected, ...)				\

	do {								\

		char __ptrtype[64] = #_type;				\

		char *_ptrtype = (char *)__ptrtype;			\

		_type _ptrdata = __VA_ARGS__;				\

		void *_ptr = &_ptrdata;					\

									\

		(void) btf_dump_data(_b, _d, _ptrtype, _prefix, _flags,	\

				     _ptr, sizeof(_type), _str,		\

				     _expected);			\

	} while (0)



/* Use where expected data string matches its stringified declaration */

#define TEST_BTF_DUMP_DATA_C(_b, _d, _prefix,  _str, _type, _flags,	\

			     ...)					\

	TEST_BTF_DUMP_DATA(_b, _d, _prefix, _str, _type, _flags,	\

			   "(" #_type ")" #__VA_ARGS__,	__VA_ARGS__)



/* overflow test; pass typesize < expected type size, ensure E2BIG returned */

#define TEST_BTF_DUMP_DATA_OVER(_b, _d, _prefix, _str, _type, _type_sz,	\

				_expected, ...)				\

	do {								\

		char __ptrtype[64] = #_type;				\

		char *_ptrtype = (char *)__ptrtype;			\

		_type _ptrdata = __VA_ARGS__;				\

		void *_ptr = &_ptrdata;					\

									\

		(void) btf_dump_data(_b, _d, _ptrtype, _prefix, 0,	\

				     _ptr, _type_sz, _str, _expected);	\

	} while (0)



#define TEST_BTF_DUMP_VAR(_b, _d, _prefix, _str, _var, _type, _flags,	\

			  _expected, ...)				\

	do {								\

		_type _ptrdata = __VA_ARGS__;				\

		void *_ptr = &_ptrdata;					\

									\

		(void) btf_dump_data(_b, _d, _var, _prefix, _flags,	\

				     _ptr, sizeof(_type), _str,		\

				     _expected);			\

	} while (0)



static void test_btf_dump_int_data(struct btf *btf, struct btf_dump *d,

				   char *str)

{

#ifdef __SIZEOF_INT128__

	__int128 i = 0xffffffffffffffff;



 this dance is required because we cannot directly initialize

	 */

	i = (i << 64) | (i - 1);

#endif

	/* simple int */

	TEST_BTF_DUMP_DATA_C(btf, d, NULL, str, int, BTF_F_COMPACT, 1234);

	TEST_BTF_DUMP_DATA(btf, d, NULL, str, int, BTF_F_COMPACT | BTF_F_NONAME,

			   "1234", 1234);

	TEST_BTF_DUMP_DATA(btf, d, NULL, str, int, 0, "(int)1234", 1234);



	/* zero value should be printed at toplevel */

	TEST_BTF_DUMP_DATA(btf, d, NULL, str, int, BTF_F_COMPACT, "(int)0", 0);

	TEST_BTF_DUMP_DATA(btf, d, NULL, str, int, BTF_F_COMPACT | BTF_F_NONAME,

			   "0", 0);

	TEST_BTF_DUMP_DATA(btf, d, NULL, str, int, BTF_F_COMPACT | BTF_F_ZERO,

			   "(int)0", 0);

	TEST_BTF_DUMP_DATA(btf, d, NULL, str, int,

			   BTF_F_COMPACT | BTF_F_NONAME | BTF_F_ZERO,

			   "0", 0);

	TEST_BTF_DUMP_DATA_C(btf, d, NULL, str, int, BTF_F_COMPACT, -4567);

	TEST_BTF_DUMP_DATA(btf, d, NULL, str, int, BTF_F_COMPACT | BTF_F_NONAME,

			   "-4567", -4567);

	TEST_BTF_DUMP_DATA(btf, d, NULL, str, int, 0, "(int)-4567", -4567);



	TEST_BTF_DUMP_DATA_OVER(btf, d, NULL, str, int, sizeof(int)-1, "", 1);



#ifdef __SIZEOF_INT128__

 gcc encode unsigned __int128 type with name "__int128 unsigned" in dwarf,

	 */

	if (btf__find_by_name(btf, "unsigned __int128") > 0) {

		TEST_BTF_DUMP_DATA(btf, d, NULL, str, unsigned __int128, BTF_F_COMPACT,

				   "(unsigned __int128)0xffffffffffffffff",

				   0xffffffffffffffff);

		ASSERT_OK(btf_dump_data(btf, d, "unsigned __int128", NULL, 0, &i, 16, str,

					"(unsigned __int128)0xfffffffffffffffffffffffffffffffe"),

			  "dump unsigned __int128");

	} else if (btf__find_by_name(btf, "__int128 unsigned") > 0) {

		TEST_BTF_DUMP_DATA(btf, d, NULL, str, __int128 unsigned, BTF_F_COMPACT,

				   "(__int128 unsigned)0xffffffffffffffff",

				   0xffffffffffffffff);

		ASSERT_OK(btf_dump_data(btf, d, "__int128 unsigned", NULL, 0, &i, 16, str,

					"(__int128 unsigned)0xfffffffffffffffffffffffffffffffe"),

			  "dump unsigned __int128");

	} else {

		ASSERT_TRUE(false, "unsigned_int128_not_found");

	}

#endif

}



static void test_btf_dump_float_data(struct btf *btf, struct btf_dump *d,

				     char *str)

{

	float t1 = 1.234567;

	float t2 = -1.234567;

	float t3 = 0.0;

	double t4 = 5.678912;

	double t5 = -5.678912;

	double t6 = 0.0;

	long double t7 = 9.876543;

	long double t8 = -9.876543;

	long double t9 = 0.0;



 since the kernel does not likely have any float types in its BTF, we

	 */



	ASSERT_GT(btf__add_float(btf, "test_float", 4), 0, "add float");

	ASSERT_OK(btf_dump_data(btf, d, "test_float", NULL, 0, &t1, 4, str,

				"(test_float)1.234567"), "dump float");

	ASSERT_OK(btf_dump_data(btf, d, "test_float", NULL, 0, &t2, 4, str,

				"(test_float)-1.234567"), "dump float");

	ASSERT_OK(btf_dump_data(btf, d, "test_float", NULL, 0, &t3, 4, str,

				"(test_float)0.000000"), "dump float");



	ASSERT_GT(btf__add_float(btf, "test_double", 8), 0, "add_double");

	ASSERT_OK(btf_dump_data(btf, d, "test_double", NULL, 0, &t4, 8, str,

		  "(test_double)5.678912"), "dump double");

	ASSERT_OK(btf_dump_data(btf, d, "test_double", NULL, 0, &t5, 8, str,

		  "(test_double)-5.678912"), "dump double");

	ASSERT_OK(btf_dump_data(btf, d, "test_double", NULL, 0, &t6, 8, str,

				"(test_double)0.000000"), "dump double");



	ASSERT_GT(btf__add_float(btf, "test_long_double", 16), 0, "add long double");

	ASSERT_OK(btf_dump_data(btf, d, "test_long_double", NULL, 0, &t7, 16,

				str, "(test_long_double)9.876543"),

				"dump long_double");

	ASSERT_OK(btf_dump_data(btf, d, "test_long_double", NULL, 0, &t8, 16,

				str, "(test_long_double)-9.876543"),

				"dump long_double");

	ASSERT_OK(btf_dump_data(btf, d, "test_long_double", NULL, 0, &t9, 16,

				str, "(test_long_double)0.000000"),

				"dump long_double");

}



static void test_btf_dump_char_data(struct btf *btf, struct btf_dump *d,

				    char *str)

{

	/* simple char */

	TEST_BTF_DUMP_DATA_C(btf, d, NULL, str, char, BTF_F_COMPACT, 100);

	TEST_BTF_DUMP_DATA(btf, d, NULL, str, char, BTF_F_COMPACT | BTF_F_NONAME,

			   "100", 100);

	TEST_BTF_DUMP_DATA(btf, d, NULL, str, char, 0, "(char)100", 100);

	/* zero value should be printed at toplevel */

	TEST_BTF_DUMP_DATA(btf, d, NULL, str, char, BTF_F_COMPACT,

			   "(char)0", 0);

	TEST_BTF_DUMP_DATA(btf, d, NULL, str, char, BTF_F_COMPACT | BTF_F_NONAME,

			   "0", 0);

	TEST_BTF_DUMP_DATA(btf, d, NULL, str, char, BTF_F_COMPACT | BTF_F_ZERO,

			   "(char)0", 0);

	TEST_BTF_DUMP_DATA(btf, d, NULL, str, char, BTF_F_COMPACT | BTF_F_NONAME | BTF_F_ZERO,

			   "0", 0);

	TEST_BTF_DUMP_DATA(btf, d, NULL, str, char, 0, "(char)0", 0);



	TEST_BTF_DUMP_DATA_OVER(btf, d, NULL, str, char, sizeof(char)-1, "", 100);

}



static void test_btf_dump_typedef_data(struct btf *btf, struct btf_dump *d,

				       char *str)

{

	/* simple typedef */

	TEST_BTF_DUMP_DATA_C(btf, d, NULL, str, uint64_t, BTF_F_COMPACT, 100);

	TEST_BTF_DUMP_DATA(btf, d, NULL, str, u64, BTF_F_COMPACT | BTF_F_NONAME,

			   "1", 1);

	TEST_BTF_DUMP_DATA(btf, d, NULL, str, u64, 0, "(u64)1", 1);

	/* zero value should be printed at toplevel */

	TEST_BTF_DUMP_DATA(btf, d, NULL, str, u64, BTF_F_COMPACT, "(u64)0", 0);

	TEST_BTF_DUMP_DATA(btf, d, NULL, str, u64, BTF_F_COMPACT | BTF_F_NONAME,

			   "0", 0);

	TEST_BTF_DUMP_DATA(btf, d, NULL, str, u64, BTF_F_COMPACT | BTF_F_ZERO,

			   "(u64)0", 0);

	TEST_BTF_DUMP_DATA(btf, d, NULL, str, u64,

			   BTF_F_COMPACT | BTF_F_NONAME | BTF_F_ZERO,

			   "0", 0);

	TEST_BTF_DUMP_DATA(btf, d, NULL, str, u64, 0, "(u64)0", 0);



	/* typedef struct */

	TEST_BTF_DUMP_DATA_C(btf, d, NULL, str, atomic_t, BTF_F_COMPACT,

			     {.counter = (int)1,});

	TEST_BTF_DUMP_DATA(btf, d, NULL, str, atomic_t, BTF_F_COMPACT | BTF_F_NONAME,

			   "{1,}", { .counter = 1 });

	TEST_BTF_DUMP_DATA(btf, d, NULL, str, atomic_t, 0,

"(atomic_t){\n"

"	.counter = (int)1,\n"

"}",

			   {.counter = 1,});

	/* typedef with 0 value should be printed at toplevel */

	TEST_BTF_DUMP_DATA(btf, d, NULL, str, atomic_t, BTF_F_COMPACT, "(atomic_t){}",

			   {.counter = 0,});

	TEST_BTF_DUMP_DATA(btf, d, NULL, str, atomic_t, BTF_F_COMPACT | BTF_F_NONAME,

			   "{}", {.counter = 0,});

	TEST_BTF_DUMP_DATA(btf, d, NULL, str, atomic_t, 0,

"(atomic_t){\n"

"}",

			   {.counter = 0,});

	TEST_BTF_DUMP_DATA(btf, d, NULL, str, atomic_t, BTF_F_COMPACT | BTF_F_ZERO,

			   "(atomic_t){.counter = (int)0,}",

			   {.counter = 0,});

	TEST_BTF_DUMP_DATA(btf, d, NULL, str, atomic_t,

			   BTF_F_COMPACT | BTF_F_NONAME | BTF_F_ZERO,

			   "{0,}", {.counter = 0,});

	TEST_BTF_DUMP_DATA(btf, d, NULL, str, atomic_t, BTF_F_ZERO,

"(atomic_t){\n"

"	.counter = (int)0,\n"

"}",

			   { .counter = 0,});



	/* overflow should show type but not value since it overflows */

	TEST_BTF_DUMP_DATA_OVER(btf, d, NULL, str, atomic_t, sizeof(atomic_t)-1,

				"(atomic_t){\n", { .counter = 1});

}



static void test_btf_dump_enum_data(struct btf *btf, struct btf_dump *d,

				    char *str)

{

	/* enum where enum value does (and does not) exist */

	TEST_BTF_DUMP_DATA_C(btf, d, "enum", str, enum bpf_cmd, BTF_F_COMPACT,

			     BPF_MAP_CREATE);

	TEST_BTF_DUMP_DATA(btf, d, "enum", str, enum bpf_cmd, BTF_F_COMPACT,

			   "(enum bpf_cmd)BPF_MAP_CREATE", 0);

	TEST_BTF_DUMP_DATA(btf, d, "enum", str, enum bpf_cmd,

			   BTF_F_COMPACT | BTF_F_NONAME,

			   "BPF_MAP_CREATE",

			   BPF_MAP_CREATE);

	TEST_BTF_DUMP_DATA(btf, d, "enum", str, enum bpf_cmd, 0,

			   "(enum bpf_cmd)BPF_MAP_CREATE",

			   BPF_MAP_CREATE);

	TEST_BTF_DUMP_DATA(btf, d, "enum", str, enum bpf_cmd,

			   BTF_F_COMPACT | BTF_F_NONAME | BTF_F_ZERO,

			   "BPF_MAP_CREATE", 0);

	TEST_BTF_DUMP_DATA(btf, d, "enum", str, enum bpf_cmd,

			   BTF_F_COMPACT | BTF_F_ZERO,

			   "(enum bpf_cmd)BPF_MAP_CREATE",

			   BPF_MAP_CREATE);

	TEST_BTF_DUMP_DATA(btf, d, "enum", str, enum bpf_cmd,

			   BTF_F_COMPACT | BTF_F_NONAME | BTF_F_ZERO,

			   "BPF_MAP_CREATE", BPF_MAP_CREATE);

	TEST_BTF_DUMP_DATA_C(btf, d, "enum", str, enum bpf_cmd, BTF_F_COMPACT, 2000);

	TEST_BTF_DUMP_DATA(btf, d, "enum", str, enum bpf_cmd,

			   BTF_F_COMPACT | BTF_F_NONAME,

			   "2000", 2000);

	TEST_BTF_DUMP_DATA(btf, d, "enum", str, enum bpf_cmd, 0,

			   "(enum bpf_cmd)2000", 2000);



	TEST_BTF_DUMP_DATA_OVER(btf, d, "enum", str, enum bpf_cmd,

				sizeof(enum bpf_cmd) - 1, "", BPF_MAP_CREATE);

}



static void test_btf_dump_struct_data(struct btf *btf, struct btf_dump *d,

				      char *str)

{

	DECLARE_LIBBPF_OPTS(btf_dump_type_data_opts, opts);

	char zero_data[512] = { };

	char type_data[512];

	void *fops = type_data;

	void *skb = type_data;

	size_t type_sz;

	__s32 type_id;

	char *cmpstr;

	int ret;



	memset(type_data, 255, sizeof(type_data));



	/* simple struct */

	TEST_BTF_DUMP_DATA_C(btf, d, "struct", str, struct btf_enum, BTF_F_COMPACT,

			     {.name_off = (__u32)3,.val = (__s32)-1,});

	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct btf_enum,

			   BTF_F_COMPACT | BTF_F_NONAME,

			   "{3,-1,}",

			   { .name_off = 3, .val = -1,});

	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct btf_enum, 0,

"(struct btf_enum){\n"

"	.name_off = (__u32)3,\n"

"	.val = (__s32)-1,\n"

"}",

			   { .name_off = 3, .val = -1,});

	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct btf_enum,

			   BTF_F_COMPACT | BTF_F_NONAME,

			   "{-1,}",

			   { .name_off = 0, .val = -1,});

	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct btf_enum,

			   BTF_F_COMPACT | BTF_F_NONAME | BTF_F_ZERO,

			   "{0,-1,}",

			   { .name_off = 0, .val = -1,});

	/* empty struct should be printed */

	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct btf_enum, BTF_F_COMPACT,

			   "(struct btf_enum){}",

			   { .name_off = 0, .val = 0,});

	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct btf_enum,

			   BTF_F_COMPACT | BTF_F_NONAME,

			   "{}",

			   { .name_off = 0, .val = 0,});

	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct btf_enum, 0,

"(struct btf_enum){\n"

"}",

			   { .name_off = 0, .val = 0,});

	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct btf_enum,

			   BTF_F_COMPACT | BTF_F_ZERO,

			   "(struct btf_enum){.name_off = (__u32)0,.val = (__s32)0,}",

			   { .name_off = 0, .val = 0,});

	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct btf_enum,

			   BTF_F_ZERO,

"(struct btf_enum){\n"

"	.name_off = (__u32)0,\n"

"	.val = (__s32)0,\n"

"}",

			   { .name_off = 0, .val = 0,});



	/* struct with pointers */

	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct list_head, BTF_F_COMPACT,

			   "(struct list_head){.next = (struct list_head *)0x1,}",

			   { .next = (struct list_head *)1 });

	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct list_head, 0,

"(struct list_head){\n"

"	.next = (struct list_head *)0x1,\n"

"}",

			   { .next = (struct list_head *)1 });

	/* NULL pointer should not be displayed */

	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct list_head, BTF_F_COMPACT,

			   "(struct list_head){}",

			   { .next = (struct list_head *)0 });

	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct list_head, 0,

"(struct list_head){\n"

"}",

			   { .next = (struct list_head *)0 });



	/* struct with function pointers */

	type_id = btf__find_by_name(btf, "file_operations");

	if (ASSERT_GT(type_id, 0, "find type id")) {

		type_sz = btf__resolve_size(btf, type_id);

		str[0] = '\0';



		ret = btf_dump__dump_type_data(d, type_id, fops, type_sz, &opts);

		ASSERT_EQ(ret, type_sz,

			  "unexpected return value dumping file_operations");

		cmpstr =

"(struct file_operations){\n"

"	.owner = (struct module *)0xffffffffffffffff,\n"

"	.llseek = (loff_t (*)(struct file *, loff_t, int))0xffffffffffffffff,";



		ASSERT_STRNEQ(str, cmpstr, strlen(cmpstr), "file_operations");

	}



	/* struct with char array */

	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct bpf_prog_info, BTF_F_COMPACT,

			   "(struct bpf_prog_info){.name = (char[16])['f','o','o',],}",

			   { .name = "foo",});

	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct bpf_prog_info,

			   BTF_F_COMPACT | BTF_F_NONAME,

			   "{['f','o','o',],}",

			   {.name = "foo",});

	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct bpf_prog_info, 0,

"(struct bpf_prog_info){\n"

"	.name = (char[16])[\n"

"		'f',\n"

"		'o',\n"

"		'o',\n"

"	],\n"

"}",

			   {.name = "foo",});

	/* leading null char means do not display string */

	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct bpf_prog_info, BTF_F_COMPACT,

			   "(struct bpf_prog_info){}",

			   {.name = {'\0', 'f', 'o', 'o'}});

	/* handle non-printable characters */

	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct bpf_prog_info, BTF_F_COMPACT,

			   "(struct bpf_prog_info){.name = (char[16])[1,2,3,],}",

			   { .name = {1, 2, 3, 0}});



	/* struct with non-char array */

	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct __sk_buff, BTF_F_COMPACT,

			   "(struct __sk_buff){.cb = (__u32[5])[1,2,3,4,5,],}",

			   { .cb = {1, 2, 3, 4, 5,},});

	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct __sk_buff,

			   BTF_F_COMPACT | BTF_F_NONAME,

			   "{[1,2,3,4,5,],}",

			   { .cb = { 1, 2, 3, 4, 5},});

	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct __sk_buff, 0,

"(struct __sk_buff){\n"

"	.cb = (__u32[5])[\n"

"		1,\n"

"		2,\n"

"		3,\n"

"		4,\n"

"		5,\n"

"	],\n"

"}",

			   { .cb = { 1, 2, 3, 4, 5},});

	/* For non-char, arrays, show non-zero values only */

	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct __sk_buff, BTF_F_COMPACT,

			   "(struct __sk_buff){.cb = (__u32[5])[0,0,1,0,0,],}",

			   { .cb = { 0, 0, 1, 0, 0},});

	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct __sk_buff, 0,

"(struct __sk_buff){\n"

"	.cb = (__u32[5])[\n"

"		0,\n"

"		0,\n"

"		1,\n"

"		0,\n"

"		0,\n"

"	],\n"

"}",

			   { .cb = { 0, 0, 1, 0, 0},});



	/* struct with bitfields */

	TEST_BTF_DUMP_DATA_C(btf, d, "struct", str, struct bpf_insn, BTF_F_COMPACT,

		{.code = (__u8)1,.dst_reg = (__u8)0x2,.src_reg = (__u8)0x3,.off = (__s16)4,.imm = (__s32)5,});

	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct bpf_insn,

			   BTF_F_COMPACT | BTF_F_NONAME,

			   "{1,0x2,0x3,4,5,}",

			   { .code = 1, .dst_reg = 0x2, .src_reg = 0x3, .off = 4,

			     .imm = 5,});

	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct bpf_insn, 0,

"(struct bpf_insn){\n"

"	.code = (__u8)1,\n"

"	.dst_reg = (__u8)0x2,\n"

"	.src_reg = (__u8)0x3,\n"

"	.off = (__s16)4,\n"

"	.imm = (__s32)5,\n"

"}",

			   {.code = 1, .dst_reg = 2, .src_reg = 3, .off = 4, .imm = 5});



	/* zeroed bitfields should not be displayed */

	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct bpf_insn, BTF_F_COMPACT,

			   "(struct bpf_insn){.dst_reg = (__u8)0x1,}",

			   { .code = 0, .dst_reg = 1});



	/* struct with enum bitfield */

	type_id = btf__find_by_name(btf, "fs_context");

	if (ASSERT_GT(type_id,  0, "find fs_context")) {

		type_sz = btf__resolve_size(btf, type_id);

		str[0] = '\0';



		opts.emit_zeroes = true;

		ret = btf_dump__dump_type_data(d, type_id, zero_data, type_sz, &opts);

		ASSERT_EQ(ret, type_sz,

			  "unexpected return value dumping fs_context");



		ASSERT_NEQ(strstr(str, "FS_CONTEXT_FOR_MOUNT"), NULL,

				  "bitfield value not present");

	}



	/* struct with nested anon union */

	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct bpf_sock_ops, BTF_F_COMPACT,

			   "(struct bpf_sock_ops){.op = (__u32)1,(union){.args = (__u32[4])[1,2,3,4,],.reply = (__u32)1,.replylong = (__u32[4])[1,2,3,4,],},}",

			   { .op = 1, .args = { 1, 2, 3, 4}});



	/* union with nested struct */

	TEST_BTF_DUMP_DATA(btf, d, "union", str, union bpf_iter_link_info, BTF_F_COMPACT,

			   "(union bpf_iter_link_info){.map = (struct){.map_fd = (__u32)1,},}",

			   { .map = { .map_fd = 1 }});



 struct skb with nested structs/unions; because type output is so

	 */

	type_id = btf__find_by_name(btf, "sk_buff");

	if (ASSERT_GT(type_id, 0, "find struct sk_buff")) {

		type_sz = btf__resolve_size(btf, type_id);

		str[0] = '\0';



		ret = btf_dump__dump_type_data(d, type_id, skb, type_sz, &opts);

		ASSERT_EQ(ret, type_sz,

			  "unexpected return value dumping sk_buff");

	}



 overflow bpf_sock_ops struct with final element nonzero/zero.

	 */

	TEST_BTF_DUMP_DATA_OVER(btf, d, "struct", str, struct bpf_sock_ops,

				sizeof(struct bpf_sock_ops) - 1,

				"(struct bpf_sock_ops){\n\t.op = (__u32)1,\n",

				{ .op = 1, .skb_tcp_flags = 2});

	TEST_BTF_DUMP_DATA_OVER(btf, d, "struct", str, struct bpf_sock_ops,

				sizeof(struct bpf_sock_ops) - 1,

				"(struct bpf_sock_ops){\n\t.op = (__u32)1,\n",

				{ .op = 1, .skb_tcp_flags = 0});

}



static void test_btf_dump_var_data(struct btf *btf, struct btf_dump *d,

				   char *str)

{

#if defined(__i386__) || defined(__x86_64__) || defined(__aarch64__)

	TEST_BTF_DUMP_VAR(btf, d, NULL, str, "cpu_number", int, BTF_F_COMPACT,

			  "int cpu_number = (int)100", 100);

#endif

	TEST_BTF_DUMP_VAR(btf, d, NULL, str, "cpu_profile_flip", int, BTF_F_COMPACT,

			  "static int cpu_profile_flip = (int)2", 2);

}



static void test_btf_datasec(struct btf *btf, struct btf_dump *d, char *str,

			     const char *name, const char *expected_val,

			     void *data, size_t data_sz)

{

	DECLARE_LIBBPF_OPTS(btf_dump_type_data_opts, opts);

	int ret = 0, cmp;

	size_t secsize;

	__s32 type_id;



	opts.compact = true;



	type_id = btf__find_by_name(btf, name);

	if (!ASSERT_GT(type_id, 0, "find type id"))

		return;



	secsize = btf__resolve_size(btf, type_id);

	ASSERT_EQ(secsize,  0, "verify section size");



	str[0] = '\0';

	ret = btf_dump__dump_type_data(d, type_id, data, data_sz, &opts);

	ASSERT_EQ(ret, 0, "unexpected return value");



	cmp = strcmp(str, expected_val);

	ASSERT_EQ(cmp, 0, "ensure expected/actual match");

}



static void test_btf_dump_datasec_data(char *str)

{

	struct btf *btf = btf__parse("xdping_kern.o", NULL);

	struct btf_dump_opts opts = { .ctx = str };

	char license[4] = "GPL";

	struct btf_dump *d;



	if (!ASSERT_OK_PTR(btf, "xdping_kern.o BTF not found"))

		return;



	d = btf_dump__new(btf, NULL, &opts, btf_dump_snprintf);

	if (!ASSERT_OK_PTR(d, "could not create BTF dump"))

		return;



	test_btf_datasec(btf, d, str, "license",

			 "SEC(\"license\") char[4] _license = (char[4])['G','P','L',];",

			 license, sizeof(license));

}



void test_btf_dump() {

	char str[STRSIZE];

	struct btf_dump_opts opts = { .ctx = str };

	struct btf_dump *d;

	struct btf *btf;

	int i;



	for (i = 0; i < ARRAY_SIZE(btf_dump_test_cases); i++) {

		struct btf_dump_test_case *t = &btf_dump_test_cases[i];



		if (!test__start_subtest(t->name))

			continue;



		test_btf_dump_case(i, &btf_dump_test_cases[i]);

	}

	if (test__start_subtest("btf_dump: incremental"))

		test_btf_dump_incremental();



	btf = libbpf_find_kernel_btf();

	if (!ASSERT_OK_PTR(btf, "no kernel BTF found"))

		return;



	d = btf_dump__new(btf, NULL, &opts, btf_dump_snprintf);

	if (!ASSERT_OK_PTR(d, "could not create BTF dump"))

		return;



	/* Verify type display for various types. */

	if (test__start_subtest("btf_dump: int_data"))

		test_btf_dump_int_data(btf, d, str);

	if (test__start_subtest("btf_dump: float_data"))

		test_btf_dump_float_data(btf, d, str);

	if (test__start_subtest("btf_dump: char_data"))

		test_btf_dump_char_data(btf, d, str);

	if (test__start_subtest("btf_dump: typedef_data"))

		test_btf_dump_typedef_data(btf, d, str);

	if (test__start_subtest("btf_dump: enum_data"))

		test_btf_dump_enum_data(btf, d, str);

	if (test__start_subtest("btf_dump: struct_data"))

		test_btf_dump_struct_data(btf, d, str);

	if (test__start_subtest("btf_dump: var_data"))

		test_btf_dump_var_data(btf, d, str);

	btf_dump__free(d);

	btf__free(btf);



	if (test__start_subtest("btf_dump: datasec_data"))

		test_btf_dump_datasec_data(str);

}

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Google LLC. */

 The third specifier, %pB, depends on compiler inlining so don't check it */

 The third specifier, %p, is a hashed pointer which changes on every reboot */

 trigger tracepoint */

 Loads an eBPF object calling bpf_snprintf with up to 10 characters of fmt */

 SPDX-License-Identifier: GPL-2.0

 fallback to 5000 on error */

 override program type */

 pid */,

 cpu 0 */, -1 
 flags */);

 find map fds */

 disable stack trace collection */

	/* for every element in stackid_hmap, we can find a corresponding one

	 * in stackmap, and vise versa.

	/* stack_map_get_build_id_offset() is racy and sometimes can return

	 * BPF_STACK_BUILD_ID_IP instead of BPF_STACK_BUILD_ID_VALID;

	 * try it one more time.

	/*

	 * We intentionally skip compare_stack_ips(). This is because we

	 * only support one in_nmi() ips-to-build_id translation per cpu

	 * at any time, thus stack_amap here will always fallback to

	 * BPF_STACK_BUILD_ID_IP;

 SPDX-License-Identifier: GPL-2.0

 at least 4 pages of data */

 now double-check if it's mmap()'able at all */

 get map's ID */

 mmap BSS map */

 map as R/W first */

 data_map freeze should fail due to R/W mmap() */

 unmap R/W mapping */

 re-map as R/O now */

 map/unmap in a loop to test ref counting */

 data_map freeze should now succeed due to no R/W mapping */

 mapping as R/W now should fail */

 check some more advanced mmap() manipulations */

 map all but last page: pages 1-3 mapped */

 unmap second page: pages 1, 3 mapped */

 map page 2 back */

 re-map all 4 pages */

 unmap page 1 */

 map all 4 pages, but with pg_off=1 page, should fail */

 initial page shift */);

 map should be still held by active mmap */

 this should release data map finally */

 we need to wait for RCU grace period */

 should fail to get map FD by non-existing ID */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 trigger */

 10 comes from "winner" input_data_weak in first obj file */

 100 comes from "winner" input_rodata_weak in first obj file */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 set initial prog attachment */

 validate prog ID */

 BPF link is not allowed to replace prog attachment */

 best-effort detach prog */

 detach BPF program */

 now BPF link should attach successfully */

 validate prog ID */

 BPF prog attach is not allowed to replace BPF link */

 Can't force-update when BPF link is active */

 Can't force-detach when BPF link is active */

 BPF link is not allowed to replace another BPF link */

 new link attach should succeed */

 updating program under active BPF link works as expected */

 ifindex should be zeroed out */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Google */

 trigger tracepoint */

 trigger tracepoint */

 trigger tracepoint */

 SPDX-License-Identifier: GPL-2.0

 Expect verifier failure if test name has 'err' */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 SPDX-License-Identifier: GPL-2.0

 unmountable pseudo-filesystems */

 unmountable pseudo-filesystems */

 mountable pseudo-filesystems */

 bpf_d_path will return path with (deleted) */

 triggers vfs_getattr */

 triggers filp_close */

 The d_path helper returns size plus NUL char, hence + 1 */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 100ms */

 500ms */

 SPDX-License-Identifier: GPL-2.0

 find in kernel module BTFs */		\

 always 8-byte pointer for BPF */	\

 we are interested only in anonymous types */

 ptr -> func_proto -> _Bool */

 ptr -> void */

 _Bool[] */

 validate we can find kernel image and use its BTF for relocs */

 load from /lib/modules/$(uname -r) */

 validate we can find kernel module BTF types for relocs/attach */

	/* validate BPF program can use multiple flavors to match against

	 * single target BTF type

 various struct/enum nesting and resolution scenarios */

 various array access relocation scenarios */

 enum/ptr/int handling scenarios */

 const/volatile/restrict and typedefs scenarios */

 handling "ptr is an array" semantics */

 int signedness/sizing/bitfield handling */

 validate edge cases of capturing relocations */

 not read */

 BUG in clang, should be 3 */

 validate field existence checks */

 bitfield relocation checks */

 size relocation checks */

 validate type existence and size relocations */

 all zeros */

 BTF_TYPE_ID_LOCAL/BTF_TYPE_ID_TARGET tests */

 Enumerator value existence and value relocations */

 NULL for tp_btf */

 trigger test run */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook */

 TRISTATE */

 BOOL */

 CHAR */

 STRING */

 INTEGERS */

 SPDX-License-Identifier: GPL-2.0

 Copyright (C) 2021. Huawei Technologies Co., Ltd */

 Need to keep consistent with definition in include/linux/bpf.h */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 1024 should be enough to get contiguous 4 "iter" letters at some point */

 Check that RENAME_EXCHANGE works for directories. */

 Check that RENAME_EXCHANGE works for mixed file types. */

 Check that RENAME_NOREPLACE works. */

 SPDX-License-Identifier: GPL-2.0

 find map fds */

 disable stack trace collection */

	/* for every element in stackid_hmap, we can find a corresponding one

	 * in stackmap, and vise versa.

	/* stack_map_get_build_id_offset() is racy and sometimes can return

	 * BPF_STACK_BUILD_ID_IP instead of BPF_STACK_BUILD_ID_VALID;

	 * try it one more time.

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 prog3 should be broken */

 don't load prog3 */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2020 Google LLC.

		/* Ensure that all executions from hereon are

		 * secure by setting a local storage which is read by

		 * the bprm_creds_for_exec hook and sets bprm->secureexec.

		/* If the binary is executed with securexec=1, the dynamic

		 * loader ingores and unsets certain variables like LD_PRELOAD,

		 * TMPDIR etc. TMPDIR is used here to simplify the example, as

		 * LD_PRELOAD requires a real .so file.

		 *

		 * If the value of TMPDIR is set, the bash command returns 10

		 * and if the value is unset, it returns 20.

 If a secureexec occurred, the exit status should be 20 */

 If normal execution happened, the exit code should be 10 */

 Run the test with the secureexec bit unset */

 secureexec */);

 Run the test with the secureexec bit set */

 secureexec */);

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 10 usecs should be enough, but give it extra */

 check that timer_cb1() was executed 10+10 times */

 check that timer_cb2() was executed twice */

 check that there were no errors in timer execution */

 check that code paths completed */

 TODO: use pid filtering */

 SPDX-License-Identifier: GPL-2.0

 test different attr.prog_name during BPF_PROG_LOAD */

 test different attr.map_name during BPF_MAP_CREATE */

 SPDX-License-Identifier: GPL-2.0

 r0 = verdict */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 create perf event */

 Skip the test before we fix LBR snapshot for hypervisor. */

 system doesn't support LBR */

	/* Just a guess for the end of this function, as module functions

	 * in /proc/kallsyms could come in any order.

 too few entries for the hit/waste test */

	/* Given we stop LBR in software, we will waste a few entries.

	 * But we should try to waste as few as possible entries. We are at

	 * about 7 on x86_64 systems.

	 * Add a check for < 10 so that we get heads-up when something

	 * changes and wastes too many entries.

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020, Oracle and/or its affiliates. */

 We do not want to wait forever if this test fails... */

 wait for tracepoint to trigger */

 verify our search string is in the trace buffer */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook

 Client outside of test cgroup should fail to connect by timeout. */

 Client inside test cgroup should connect just fine. */

	/* Create a socket before joining testing cgroup so that its cgroup id

	 * differs from that of testing cgroup. Moving selftests process to

	 * testing cgroup won't change cgroup id of an already created socket.

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 attach two kprobes */

 attach two kretprobes */

 trigger kprobe && kretprobe */

 attach two uprobes */

 self pid */,

 any pid */,

 attach two uretprobes */

 any pid */,

 self pid */,

 trigger uprobe && uretprobe */

 attach first tp prog */

 attach second tp prog */

 trigger tracepoints */

	/* now we detach first prog and will attach third one, which causes

	 * two internal calls to bpf_prog_array_copy(), shuffling

	 * bpf_prog_array_items around. We test here that we don't lose track

	 * of associated bpf_cookies.

 attach third tp prog */

 trigger tracepoints */

 generate some branches on cpu 0 */

 spin the loop for a while (random high number) */

 create perf event */

 trigger BPF prog */

 prevent bpf_link__destroy() closing pfd itself */

 close BPF link's FD explicitly */

 free up memory used by struct bpf_link */

 trigger BPF prog */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook */

 spare */) * sizeof(__u64));

 cut off freplace/ */

 the target prog should load fine */

	/*

	 * standalone test that asserts failure to load freplace prog

	 * because of invalid return code.

 the target prog should load fine */

 It should fail to load the program */

 test invalid return code in the replaced program */

 test with spin lock map value in the replaced program */

 NOTE: affect other tests, must run in serial mode */

 SPDX-License-Identifier: GPL-2.0 */

 Copyright (c) 2018 Facebook */

 several different mapv kinds(types) supported by pprint */

/* enum E {

 *     E0,

 *     E1,

 * };

 *

 * struct A {

 *	unsigned long long m;

 *	int n;

 *	char o;

 *	[3 bytes hole]

 *	int p[8];

 *	int q[4][8];

 *	enum E r;

 * };

 int */

 [1] */

 unsigned long long */

 [2] */

 char */

 [3] */

 int[8] */

 [4] */

 struct A { */				
 unsigned long long m;*/

 int n;		*/

 char o;		*/

 int p[8]		*/

 int q[4][8]		*/

 enum E r		*/

 } */

 int[4][8] */

 [6] */

 enum E */					
/* typedef struct b Struct_B;

 *

 * struct A {

 *     int m;

 *     struct b n[4];

 *     const Struct_B o[4];

 * };

 *

 * struct B {

 *     int m;

 *     int n;

 * };

 int */					
 struct b [4] */				
 struct A { */				
 int m;		*/

 struct B n[4]	*/

 const Struct_B o[4];*/

 } */

 struct B { */				
 int m; */

 int n; */

 } */

 const int */					
 typedef struct b Struct_B */	
 const Struct_B */				
 const Struct_B [4] */			
 int */					
 int64 */					
 struct A { */				
 int m;		*/

 int64 n; */

 } */

/*

 * struct A {

 *	unsigned long long m;

 *	int n;

 *	char o;

 *	[3 bytes hole]

 *	int p[8];

 * };

 int */

 [1] */

 unsigned long long */

 [2] */

 char */

 [3] */

 int[8] */

 [4] */

 struct A { */				
 unsigned long long m;*/

 int n;		*/

 char o;		*/

 int p[8]		*/

 } */

/*

 * struct A {

 *	unsigned long long m;

 *	int n;

 *	char o;

 *	[3 bytes hole]

 *	int p[8];

 * };

 * static struct A t; <- in .bss

 int */

 [1] */

 unsigned long long */

 [2] */

 char */

 [3] */

 int[8] */

 [4] */

 struct A { */				
 unsigned long long m;*/

 int n;		*/

 char o;		*/

 int p[8]		*/

 } */

 static struct A t */

 [6] */

 .bss section */				
 int */

 [1] */

 static int t */

 [2] */

 .bss section */				
 int */

 [1] */

 static int t */

 [2] */

 .bss section */				
 static void t */

 [1] */

 .bss section */				
 union A */

 [1] */

 static union A t */

 [2] */

 .bss section */				
 union A */

 [1] */

 static union A t */

 [2] */

 .bss section */				
 int */

 [1] */

 unsigned long long */

 [2] */

 char */

 [3] */

 int[8] */

 [4] */

 struct A { */				
 unsigned long long m;*/

 int n;		*/

 char o;		*/

 int p[8]		*/

 } */

 static struct A t */

 [6] */

 .bss section */				
 int */

 [1] */

 unsigned long long */

 [2] */

 char */

 [3] */

 int[8] */

 [4] */

 struct A { */				
 unsigned long long m;*/

 int n;		*/

 char o;		*/

 int p[8]		*/

 } */

 static struct A t */

 [6] */

 .bss section */				
 int */

 [1] */

 unsigned long long */

 [2] */

 char */

 [3] */

 int[8] */

 [4] */

 struct A { */				
 unsigned long long m;*/

 int n;		*/

 char o;		*/

 int p[8]		*/

 } */

 static struct A t */

 [6] */

 .bss section */				
 int */

 [1] */

 unsigned long long */

 [2] */

 char */

 [3] */

 int[8] */

 [4] */

 struct A { */				
 unsigned long long m;*/

 int n;		*/

 char o;		*/

 int p[8]		*/

 } */

 static struct A t */

 [6] */

 static int u */

 [7] */

 .bss section */				
 int */

 [1] */

 unsigned long long */

 [2] */

 char */

 [3] */

 int[8] */

 [4] */

 struct A { */				
 unsigned long long m;*/

 int n;		*/

 char o;		*/

 int p[8]		*/

 } */

 static struct A t */

 [6] */

 static int u */

 [7] */

 .bss section */				
 int */

 [1] */

 unsigned long long */

 [2] */

 char */

 [3] */

 int[8] */

 [4] */

 struct A { */				
 unsigned long long m;*/

 int n;		*/

 char o;		*/

 int p[8]		*/

 } */

 static struct A t */

 [6] */

 static int u */

 [7] */

 .bss section */				
 int */

 [1] */

 unsigned long long */

 [2] */

 char */

 [3] */

 int[8] */

 [4] */

 struct A { */				
 unsigned long long m;*/

 int n;		*/

 char o;		*/

 int p[8]		*/

 } */

 static struct A t */

 [6] */

 static int u */

 [7] */

 .bss section */				
 int */

 [1] */

 [2] */

 .bss section */				
 int */

 [1] */

 [2] */

 [3] */

 a section */					
 a section */					
 [6] */

 int */

 [1] */

 [2] */

 [3] */

 a section */					
 int */

 [1] */

 [2] */

 .bss section */				
 int */

 [1] */

 [2] */

 [3] */

 int */

 [1] */

 PTR type_id=3	*/			
 [3] */

 int */

 [1] */

 struct A { */				
 int m; */

 VAR type_id=3; */

 } */

 [3] */

 int */

 [1] */

 [2] */

 [3] */

/* Test member exceeds the size of struct.

 *

 * struct A {

 *     int m;

 *     int n;

 * };

 int */					
 struct A { */				
 int m; */

 int n; */

 } */

/* Test member exceeds the size of struct

 *

 * struct A {

 *     int m;

 *     int n[2];

 * };

 int */					
 int[2] */					
 struct A { */				
 int m; */

 int n[2]; */

 } */

/* Test member exceeds the size of struct

 *

 * struct A {

 *     int m;

 *     void *n;

 * };

 int */					
 void* */					
 struct A { */				
 int m; */

 void *n; */

 } */

/* Test member exceeds the size of struct

 *

 * enum E {

 *     E0,

 *     E1,

 * };

 *

 * struct A {

 *     int m;

 *     enum E n;

 * };

 int */			
 enum E { */			
 } */

 struct A { */		
 int m; */

 enum E n; */

 } */

/* Test member unexceeds the size of struct

 *

 * enum E {

 *     E0,

 *     E1,

 * };

 *

 * struct A {

 *     char m;

 *     enum E __attribute__((packed)) n;

 * };

 int */			
 char */			
 enum E { */			
 } */

 struct A { */		
 char m; */

 enum E __attribute__((packed)) n; */

 } */

/* typedef const void * const_void_ptr;

 * struct A {

 *	const_void_ptr m;

 * };

 int */		
 const void */	
 const void* */	
 typedef const void * const_void_ptr */

 [4] */

 struct A { */	
 const_void_ptr m; */

 } */

/* struct A {

 *     const void m;

 * };

 int */		
 const void */	
 struct A { */	
 const void m; */

 } */

/* typedef const void * const_void_ptr;

 * const_void_ptr[4]

 int */		
 const void */	
 const void* */	
 typedef const void * const_void_ptr */

 [4] */

 const_void_ptr[4] */

 [5] */

 const void[4]  */

 int */		
 const void */	
 const void[4] */	
/* Array_A  <------------------+

 *     elem_type == Array_B    |

 *                    |        |

 *                    |        |

 * Array_B  <-------- +        |

 *      elem_type == Array A --+

 int */			
 Array_A */			
 Array_B */			
/* typedef is _before_ the BTF type of Array_A and Array_B

 *

 * typedef Array_B int_array;

 *

 * Array_A  <------------------+

 *     elem_type == int_array  |

 *                    |        |

 *                    |        |

 * Array_B  <-------- +        |

 *      elem_type == Array_A --+

 int */

 [1] */

 typedef Array_B int_array */

 [2] */

 Array_A */

 [3] */

 Array_B */

 [4] */

/* Array_A  <------------------+

 *     elem_type == Array_B    |

 *                    |        |

 *                    |        |

 * Array_B  <-------- +        |

 *      elem_type == Array_A --+

 int */				
 Array_A */				
 Array_B */				
/* typedef is _between_ the BTF type of Array_A and Array_B

 *

 * typedef Array_B int_array;

 *

 * Array_A  <------------------+

 *     elem_type == int_array  |

 *                    |        |

 *                    |        |

 * Array_B  <-------- +        |

 *      elem_type == Array_A --+

 int */				
 Array_A */				
 typedef Array_B int_array */		
 Array_B */				
/* typedef struct B Struct_B

 *

 * struct A {

 *     int x;

 *     Struct_B y;

 * };

 *

 * struct B {

 *     int x;

 *     struct A y;

 * };

 int */

 [1] */

 struct A */					
 int x;	*/

 Struct_B y;	*/

 typedef struct B Struct_B */

 [3] */

 struct B */					
 int x;	*/

 struct A y;	*/

/* struct A {

 *     int x;

 *     struct A array_a[4];

 * };

 int */

 [1] */

 [2] */

 struct A */					
 int x;		*/

 struct A array_a[4];	*/

 int */				
 struct A { */			
     const void *m;	*/

 CONST type_id=3	*/		
 PTR type_id=2	*/		
 int */				
 struct A { */			
     const void *m;	*/

 struct B { */			
     const void *n;	*/

 CONST type_id=5	*/		
 PTR type_id=6	*/		
 CONST type_id=7	*/		
 PTR type_id=4	*/		
 int */				
 int */				
 int */				
 int */				
 int */				
 int */				
 int */				
 int */				
 int */				
 int[16] */				
 int */				
 int[16] */				
 CONST type_id=1 */			
 int */				
 int:31 */				
 int[16] */				
 CONST type_id=2 */			
 int */				
 int:31 */				
 int[16] */				
 CONST type_id=2 */			
 int */				
 int[16] */				
 int */				
 int[16] */				
 CONST type_id=0 (void) */		
 int */				
 int[16] */				
 CONST type_id=0 (void) */		
 int */				
 const void *[16] */			
 CONST type_id=4 */			
 void* */				
 int */				
 const void *[16] */			
 CONST type_id=4 */			
 void* */				
 int */				
 int[16] */				
 int */				
 int */				
 fwd type */				
 [1] */

 [2] */

 [1] */

 [2] */

 [1] */

 [2] */

 [1] */

 [2] */

 [1] */

 [2] */

 [1] */

 [2] */

 [3] */

 [1] */

 [2] */

 [1] */

 [2] */

 [1] */

 [2] */

 [1] */

 [2] */

 [1] */

 [2] */

 [1] */

 [2] */

 [1] */

 [2] */

 [1] */

 [2] */

 [1] */

 [2] */

 [1] */

 [2] */

 [1] */

 [2] */

 int */				
 32 bit int with 32 bit offset */	
 int */				
 16 bit int with 0 bit offset */	
 int */				
 btf_value_size < map->value_size */

 int */				
 btf_value_size > map->value_size */

 [1] */

 [2] */

 int (*)(int, unsigned int) */

 [3] */

 [1] */

 [2] */

 void (*)(int, unsigned int, ...) */

 [3] */

 [1] */

 [2] */

 void (*)(int a, unsigned int b, ... c) */

 [3] */

 [1] */

 [2] */

 void (*)(int a, ..., unsigned int b) */

 [3] */

 [1] */

 [2] */

 typedef void (*func_ptr)(int, unsigned int) */

 [3] */

 const func_ptr */

 [4] */

 [5] */

 [6] */

 [1] */

 [2] */

 [3] */

 [4] */

 [1] */

 void (*)(const void *) */

 [2] */

 [3] */

 [4] */

 [1] */

 [2] */

 void (*)(int, unsigned int b) */

 [3] */

 [1] */

 [2] */

 void (*)(int a, unsigned int <bad_name_off>) */

 [3] */

 [1] */

 [2] */

 void (*)(int a, unsigned int !!!) */

 [3] */

 [1] */

 [2] */

 <bad_ret_type> (*)(int, unsigned int) */

 [3] */

 [1] */

 [2] */

 void func_proto(int, unsigned int) */

 [3] */

 [1] */

 [2] */

 void (*)(const void) */

 [3] */

 [4] */

 [1] */

 [2] */

 void (*)(int a, unsigned int b) */

 [3] */

 void func(int a, unsigned int b) */

 [4] */

 [1] */

 [2] */

 void (*)(int a, unsigned int b) */

 [3] */

 void <no_name>(int a, unsigned int b) */

 [4] */

 [1] */

 [2] */

 void (*)(int a, unsigned int b) */

 [3] */

 void !!!(int a, unsigned int b) */

 [4] */

 [1] */

 [2] */

 void (*)(int a, unsigned int) */

 [3] */

 void func(int a, unsigned int) */

 [4] */

 [1] */

 [2] */

 void (*)(int a, unsigned int b) */

 [3] */

 void func(int a, unsigned int b) */

 [4] */

 [1] */

 [2] */

 [1] */

 [2] */

 [1] */

 [2] */

 [1] */

 [2] */

 [1] */

 [2] */

 [1] */

 [2] */

 [1] */

 [2] */

 [1] */

 [2] */

 [1] */

 [2] */

 [1] */

 [2] */

 [1] */

 [2] */

 [3] */

 [1] */

 [2] */

 [1] */

 [2] */

 [1] */

 [2] */

 [1] */

 [2] */

 [1] */

 [2] */

 [3] */

 [1] */

 [2] */

 [3] */

 [1] */

 [2] */

 [3] */

 [4] */

 [5] */

 [1] */

 [2] */

 [3] */

 [4] */

 [5] */

 [1] */

 [2] */

 [1] */

 [2] */

 [3] */

 [1] */

 [2] */

 [3] */

 [1] */

 [2] */

 [1] */

 [2] */

 [3] */

 [1] */

 [2] */

 [2] */

 [3] */

 [1] */

 [2] */

 [1] */

 [2] */

 [3] */

 [1] */

 [2] */

 [3] */

 [1] */

 [2] */

 [3] */

 [1] */

 [2] */

 [3] */

/*

 * typedef int arr_t[16];

 * struct s {

 *	arr_t *a;

 * };

 [1] */

 [2] */

 [3] */

 [4] */

 [5] */

 int */,

 arr_t */,

/*

 * typedef int arr_t[16][8][4];

 * struct s {

 *	arr_t *a;

 * };

 [1] */

 [2] */

 [3] */

 [4] */

 [5] */

 [6] */

 [7] */

 int */,

 arr_t */,

/*

 * typedef int int_t;

 * typedef int_t arr3_t[4];

 * typedef arr3_t arr2_t[8];

 * typedef arr2_t arr1_t[16];

 * struct s {

 *	arr1_t *a;

 * };

 [1] */

 [2] */

 [3] */

 [4] */

 [5] */

 [6] */

 [7] */

 [8] */

 [9] */

 [10] */

 int */,

 arr_t */,

/*

 * elf .rodata section size 4 and btf .rodata section vlen 0.

 int */

 [1] */

 .rodata section */

 [2] */

 [1] */

 [2] */

 [3] */

 [4] */

 [5] */

 [6] */

 [7] */

 [1] */

 [2] */

 [1] */

 [2] */

 [1] */

 [2] */

 [3] */

 [1] */

 [2] */

 [3] */

 [1] */

 [2] */

 [1] */

 [2] */

 [1] */

 [2] */

 [1] */

 [2] */

 [3] */

 [1] */

 [2] */

 [3] */

 [1] */

 [2] */

 [1] */

 [1] */

 [2] */

 [1] */

 [2] */

 [1] */

 [2] */

 [1] */

 [2] */

 [1] */

 [2] */

 [3] */

 [1] */

 [2] */

 [3] */

 [1] */

 [2] */

 [1] */

 [2] */

 struct btf_raw_test raw_tests[] */

 Copy header */

 Index strings */

 Copy type section */

 Copy string section */

 int */				
 int */				
 int */				
 int */				
 unsigned int */			
	/*

	 * GET_INFO should error out if the userspace info

	 * has non zero tailing bytes.

	/*

	 * GET_INFO should succeed even info_len is larger than

	 * the kernel supported as long as tailing bytes are zero.

	 * The kernel supported info len should also be returned

	 * to userspace.

 Test BPF_OBJ_GET_INFO_BY_ID on btf_id */

 Test btf members in struct bpf_map_info */

 Test BTF ID is removed from the kernel */

 The map holds the last ref to BTF and its btf_id */

 get necessary program info */

 reset info to only retrieve func_info related data */

 check three functions */

		/* for the second and third functions in .text section,

		 * the compiler may order them either way.

 2 bytes hole */

 unsighed char */			
 unsigned short */			
 unsigned int */			
 int */				
 unsigned long long */		
 2 bits */				
 28 bits */				
 uint8_t[8] */			
 typedef unsigned char uint8_t */	
 typedef unsigned short uint16_t */	
 typedef unsigned int uint32_t */	
 typedef int int32_t */		
* [13] */
 [13] */

 union (anon) */			
 uint64_t ui64; */

 uint8_t ui8a[8]; */

 enum (anon) */			
 struct pprint_mapv */		
 uint32_t ui32 */

 uint16_t ui16 */

 int32_t si32 */

 unused_bits2a */

 bits28 */

 unused_bits2b */

 union (anon) */

 aenum */

 uint32_t ui32b */

 bits2c */

 si8_4 */

 [17] */

 [18] */

 unsigned int */

 struct pprint_mapv */

	/* this type will have the same type as the

	 * first .raw_types definition, but struct type will

	 * be encoded with kind_flag set.

 unsighed char */			
 unsigned short */			
 unsigned int */			
 int */				
 unsigned long long */		
 [6] */

 [7] */

 uint8_t[8] */			
 typedef unsigned char uint8_t */	
 typedef unsigned short uint16_t */	
 typedef unsigned int uint32_t */	
 typedef int int32_t */		
* [13] */
 [13] */

 union (anon) */			
 uint64_t ui64; */

 uint8_t ui8a[8]; */

 enum (anon) */			
 struct pprint_mapv */		
 uint32_t ui32 */

 uint16_t ui16 */

 int32_t si32 */

 unused_bits2a */

 bits28 */

 unused_bits2b */

 union (anon) */

 aenum */

 uint32_t ui32b */

 bits2c */

 si8_4 */

 [17] */

 [18] */

 unsigned int */

 struct pprint_mapv */

	/* this type will have the same layout as the

	 * first .raw_types definition. The struct type will

	 * be encoded with kind_flag set, bitfield members

	 * are added typedef/const/volatile, and bitfield members

	 * will have both int and enum types.

 unsighed char */			
 unsigned short */			
 unsigned int */			
 int */				
 unsigned long long */		
 [6] */

 [7] */

 uint8_t[8] */			
 typedef unsigned char uint8_t */	
 typedef unsigned short uint16_t */	
 typedef unsigned int uint32_t */	
 typedef int int32_t */		
* [13] */
 [13] */

 union (anon) */			
 uint64_t ui64; */

 uint8_t ui8a[8]; */

 enum (anon) */			
 struct pprint_mapv */		
 uint32_t ui32 */

 uint16_t ui16 */

 int32_t si32 */

 unused_bits2a */

 bits28 */

 unused_bits2b */

 union (anon) */

 aenum */

 uint32_t ui32b */

 bits2c */

 si8_4 */

 typedef unsigned int ___int */	
 [18] */

 [19] */

 [20] */

 [21] */

 unsigned int */

 struct pprint_mapv */

 test int128 */

 unsigned int */				
 __int128 */					
 unsigned __int128 */				
 struct pprint_mapv_int128 */			
 si128a */

 si128b */

 bits3 */

 bits80 */

 ui128 */

 Skip lines start with '#' */

				/* for percpu map, the format looks like:

				 * <key>: {

				 *	cpu0: <value_on_cpu0>

				 *	cpu1: <value_on_cpu1>

				 *	...

				 *	cpun: <value_on_cpun>

				 * }

				 *

				 * let us verify the line containing the key here.

 read value@cpu */

 skip the last bracket for the percpu map */

 test various maps with the first test template */

 test rest test templates with the first map */

 [1] */

 [2] */

 [3] */

 [4] */

 [5] */

 [6] */

 [1] */

 [2] */

 [3] */

 [4] */

 [5] */

 [6] */

 [1] */

 [2] */

 [3] */

 [4] */

 [5] */

 [6] */

 [1] */

 [2] */

 [3] */

 [4] */

 [5] */

 [6] */

 [1] */

 [1] */

 [1] */

 [2] */

 [3] */

 [1] */

 [1] */

 [1] */

 [1] */

 [2] */

 [3] */

 [4] */

 [1] */

 [1] */

 [1] */

 [1] */

 dead jmp */\0int a=1;\0int b=2;\0return a + b;\0return a + b;"),

 [1] */

 dead jmp */\0return a + b;\0
 [1] */

 [2] */

 [3] */

 [4] */

 dead jmp */"

 dead */\0 dead */\0
 dead */\0 dead */\0
 [1] */

 [2] */

 [3] */

 [4] */

 [5] */

 live call */"

 dead */\0
 dead */\0return bla + 1;\0return bla + 1;"

 [1] */

 [2] */

 [3] */

 [5] */

 live call */"

 dead */\0
 [1] */

 [2] */

 [3] */

 [4] */

 [5] */

 dead */"

 dead */\0 dead */\0
 [1] */

 [2] */

 [3] */

 [4] */

 [5] */

 live call */"

 dead */\0
 dead */\0return bla + 1;\0return bla + 1;"

 [1] */

 [2] */

 [3] */

 [4] */

 main linfo */\0
 get necessary lens */

 reset info to only retrieve func_info related data */

 prog is not jited */

	/*

	 * Only recheck the info.*line_info* fields.

	 * Other fields are not the concern of this test.

	/*

	 * struct s {

	 *	struct s *next;

	 *	const int *a;

	 *	int b[16];

	 *	int c;

	 * }

 int */

 [1] */

 int[16] */

 [2] */

 struct s { */

 [3] */

 struct s *next;	*/

 const int *a;	*/

 int b[16];		*/

 int c;		*/

 float d;		*/

 ptr -> [3] struct s */

 [4] */

 ptr -> [6] const int */

 [5] */

 const -> [1] int */

 [6] */

 tag -> [3] struct s */

 [7] */

 tag -> [3] struct s, member 1 */

 [8] */

 full copy of the above */

 [9] */

 [10] */

 [11] */

 [12] */

 [13] */

 [14] */

 [15] */

 [16] */

 [17] */

 int */

 [1] */

 int[16] */

 [2] */

 struct s { */

 [3] */

 struct s *next;	*/

 const int *a;	*/

 int b[16];		*/

 int c;		*/

 float d;		*/

 ptr -> [3] struct s */

 [4] */

 ptr -> [6] const int */

 [5] */

 const -> [1] int */

 [6] */

 [7] */

 [8] */

 [9] */

	/*

	 * // CU 1:

	 * struct x;

	 * struct s {

	 *	struct x *x;

	 * };

	 * // CU 2:

	 * struct x {};

	 * struct s {

	 *	struct x *x;

	 * };

 CU 1 */

 struct fwd */),	
 [2] ptr -> [1] */

 [3] struct s   */

 CU 2 */

 [4] struct x   */

 [5] ptr -> [4] */

 [6] struct s   */

 [1] ptr -> [3] */

 [2] struct s   */

 [3] struct x   */

 force hash collisions */

	/*

	 * // CU 1:

	 * struct s {

	 *	struct {} *x;

	 * };

	 * // CU 2:

	 * struct s {

	 *	int *x;

	 * };

 CU 1 */

 [1] struct {}  */

 [2] ptr -> [1] */

 [3] struct s   */

 CU 2 */

 [4] ptr -> void */

 [5] struct s   */

 CU 1 */

 [1] struct {}  */

 [2] ptr -> [1] */

 [3] struct s   */

 CU 2 */

 [4] ptr -> void */

 [5] struct s   */

 force hash collisions */

 [1] int */

 [2] enum */

 union kind_flag */),			
 [4] array */

 [5] struct */

 [6] union */

 [7] typedef */

 [8] ptr */

 [9] const */

 [10] volatile */

 [11] restrict */

 [12] func_proto */

 [13] func */

 [14] float */

 [15] decl_tag */

 [16] decl_tag */

 [17] decl_tag */

 [1] int */

 [2] enum */

 union kind_flag */),			
 [4] array */

 [5] struct */

 [6] union */

 [7] typedef */

 [8] ptr */

 [9] const */

 [10] volatile */

 [11] restrict */

 [12] func_proto */

 [13] func */

 [14] float */

 [15] decl_tag */

 [16] decl_tag */

 [17] decl_tag */

 different name */

 different encoding */

 different bit offset */

 different bit size */

 different byte size */

 all allowed sizes */

 different name */

 different encoding */

 different bit offset */

 different bit size */

 different byte size */

 all allowed sizes */

 [1] fwd enum 'e1' before full enum */

 [2] full enum 'e1' after fwd */

 [3] full enum 'e2' before fwd */

 [4] fwd enum 'e2' after full enum */

 [5] incompatible fwd enum with different size */

 [6] incompatible full enum with different value */

 [1] full enum 'e1' */

 [2] full enum 'e2' */

 [3] incompatible fwd enum with different size */

 [4] incompatible full enum with different value */

 int */

 [1] */

 static int t */

 [2] */

 .bss section */				
 int, referenced from [5] */

 [4] */

 another static int t */

 [5] */

 another .bss section */			
 int */

 [1] */

 static int t */

 [2] */

 .bss section */				
 another static int t */

 [4] */

 another .bss section */			
 int */

 [1] */

 static int t */

 [2] */

 void f(int a1, int a2) */

 [3] */

 [4] */

 tag -> t */

 [5] */

 [6] */

 tag -> func */

 [7] */

 [8] */

 tag -> func arg a1 */

 [9] */

 [10] */

 [1] */

 [2] */

 [3] */

 [4] */

 [5] */

 [6] */

 [7] */

 int */

 [1] */

 void f(int a1, int a2) */

 [2] */

 [3] */

 void f(int a1, int a2) */

 [4] */

 [5] */

 tag -> f: tag1, tag2 */

 [6] */

 [7] */

 tag -> f/a2: tag1, tag2 */

 [8] */

 [9] */

 tag -> f: tag1, tag3 */

 [10] */

 [11] */

 tag -> f/a2: tag1, tag3 */

 [12] */

 [13] */

 [1] */

 [2] */

 [3] */

 [4] */

 [5] */

 [6] */

 [7] */

 [8] */

 [9] */

 int */

 [1] */

 [2] */

 [3] */

 tag -> t: tag1, tag2 */

 [4] */

 [5] */

 tag -> t/m2: tag1, tag2 */

 [6] */

 [7] */

 tag -> t: tag1, tag3 */

 [8] */

 [9] */

 tag -> t/m2: tag1, tag3 */

 [10] */

 [11] */

 [1] */

 [2] */

 [3] */

 [4] */

 [5] */

 [6] */

 [7] */

 [8] */

 int */

 [1] */

 [2] */

 [3] */

 tag -> t: tag1, tag2 */

 [4] */

 [5] */

 tag -> t: tag1, tag3 */

 [6] */

 [7] */

 [1] */

 [2] */

 [3] */

 [4] */

 [5] */

 SPDX-License-Identifier: GPL-2.0

 Ensure bytes after string are ones */

 Give prog our userspace pointer */

 Trigger tracepoint */

 Did helper fail? */

 Check that string was copied correctly */

 Now check that no extra trailing bytes were copied */

 Give pid to bpf prog so it doesn't read from anyone else */

 SPDX-License-Identifier: GPL-2.0

 Test shrink with 20 bytes */

 avoid segfault: large buf to hold grow results */

 Test grow with 40 bytes */

 74 */,

 avoid segfault: large buf to hold grow results */

 SKB_DATA_ALIGN(sizeof(struct skb_shared_info))*/;

 Per test */

 Per test */

 Test case-64 */

 Determine test case via pkt size */

 Limit copy_size */

 Kernel side alloc packet memory area that is zero init */

 Due limit copy_size in bpf_test_finish */

 Expected grow size */

 Extra checks for data contents */

  0-63  memset to 1 */

 64-127 memset to 0 */

128-191 memset to 1 */

 Test case-128 */

 Determine test case via pkt size */

 Copy everything */

 3520 */

 Expect max grow size */

 Extra checks for data content: Count grow size, will contain zeros */

 Grow increase */

 Total grow size */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 We do not want to wait forever if this test fails... */

 wait for tracepoint to trigger */

 verify our search string is in the trace buffer */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 check that timer_cb[12] are incrementing 'cnt' */

 100 times more than interval */

 check that code paths completed */

 check that timer_cb[12] are no longer running */

 100 times more than interval */

 SPDX-License-Identifier: GPL-2.0

 ==================== getsockopt ====================  */

 return 1 */

 return 1 */

 return 1 */

 r6 = ctx->optval */

 ctx->optval[0] = 0x80 */

 return 1 */

 r6 = ctx->level */

 if (ctx->level == 123) { */

 ctx->retval = 0 */

 return 1 */

 } else { */

 return 0 */

 } */

 ctx->level = 1 */

 r6 = ctx->optname */

 if (ctx->optname == 123) { */

 ctx->retval = 0 */

 return 1 */

 } else { */

 return 0 */

 } */

 r6 = ctx->retval */

 return 1 */

 ctx->optname = 1 */

 r6 = ctx->optlen */

 if (ctx->optlen == 64) { */

 ctx->retval = 0 */

 return 1 */

 } else { */

 return 0 */

 } */

 ctx->optlen = 65 */

 ctx->retval = 0 */

 return 1 */

 ctx->retval = 123 */

 return 1 */

 ctx->optlen = 32 */

 ctx->retval = 0 */

 return 1 */

 ctx->optval = 1 */

 ctx->optval_end = 1 */

 r6 = ctx->optval */

 r2 = ctx->optval */

 r6 = ctx->optval + 1 */

 r7 = ctx->optval_end */

 if (ctx->optval + 1 <= ctx->optval_end) { */

 ctx->optval[0] = 0xF0 */

 } */

 ctx->retval = 0 */

 return 1*/

 ==================== setsockopt ====================  */

 return 1 */

 return 1 */

 return 1 */

 return 0 */

 r6 = ctx->optval */

 r0 = ctx->optval[0] */

 return 1 */

 r6 = ctx->level */

 if (ctx->level == 123) { */

 ctx->optlen = -1 */

 return 1 */

 } else { */

 return 0 */

 } */

 ctx->level = SOL_IP */

 return 1 */

 should be rewritten to SOL_IP */

 r6 = ctx->optname */

 if (ctx->optname == 123) { */

 ctx->optlen = -1 */

 return 1 */

 } else { */

 return 0 */

 } */

 ctx->optname = IP_TOS */

 return 1 */

 should be rewritten to IP_TOS */

 r6 = ctx->optlen */

 if (ctx->optlen == 64) { */

 ctx->optlen = -1 */

 return 1 */

 } else { */

 return 0 */

 } */

 ctx->optlen = -1 */

 return 1 */

 ctx->optlen = -2 */

 return 1 */

 ctx->optlen = 65 */

 r6 = ctx->optval */

 r2 = ctx->optval */

 r6 = ctx->optval + 1 */

 r7 = ctx->optval_end */

 if (ctx->optval + 1 <= ctx->optval_end) { */

 ctx->optval[0] = 1 << 3 */

 } */

 ctx->optlen = 1 */

 return 1*/

 ctx->retval = 0 */

 return 1 */

 r6 = ctx->retval */

 return 1 */

 ctx->optval = 1 */

 ctx->optval_end = 1 */

 r6 = ctx->optval */

 r7 = ctx->optval + 1 */

 r8 = ctx->optval_end */

 if (ctx->optval + 1 <= ctx->optval_end) { */

 r9 = ctx->optval[0] */

 if (ctx->optval[0] < 128) */

 } */

 } else { */

 } */

 r6 = ctx->optval */

 r7 = ctx->optval + 1 */

 r8 = ctx->optval_end */

 if (ctx->optval + 1 <= ctx->optval_end) { */

 r9 = ctx->optval[0] */

 if (ctx->optval[0] < 128) */

 } */

 } else { */

 } */

 SPDX-License-Identifier: GPL-2.0

 this is how USDT semaphore is actually defined, except volatile modifier */

 attach point */

	/* Check if new-style kprobe/uprobe API is supported.

	 * Kernels that support new FD-based kprobe and uprobe BPF attachment

	 * through perf_event_open() syscall expose

	 * /sys/bus/event_source/devices/kprobe/type and

	 * /sys/bus/event_source/devices/uprobe/type files, respectively. They

	 * contain magic numbers that are passed as "type" field of

	 * perf_event_attr. Lack of such file in the system indicates legacy

	 * kernel with old-style kprobe/uprobe attach interface through

	 * creating per-probe event through tracefs. For such cases

	 * ref_ctr_offset feature is not supported, so we don't test it.

 retprobe */,

 retprobe */,

 self pid */,

 if uprobe uses ref_ctr, uretprobe has to use ref_ctr as well */

 any pid */,

 trigger & validate kprobe && kretprobe */

 trigger & validate uprobe & uretprobe */

 SPDX-License-Identifier: GPL-2.0

 Get prog_id for XDP_ATTACHED_NONE mode */

 Setup prog */

 Get prog_id for single prog mode */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook */

 Check that already linked program can't be attached again. */

 zero results for re-attach test */

 SPDX-License-Identifier: GPL-2.0

 *(u32 *)(fp - 4) = r0 */

 r2 = fp - 4 */

 r1 = 1 */

 r0 = verdict */

 query the number of effective progs in cg5 */

 retrieve prog_ids of effective progs in cg5 */

 check enospc handling */

 check that prog_ids are returned even when buffer is too small */

 retrieve prog_id of single attached prog in cg5 */

 detach bottom program and ping again */

 test replace */

 replacing a program that is not attached to cgroup should fail  */

 replace 1st from the top program */

 replace program with itself */

 detach 3rd from bottom program and ping again */

 detach 2nd from bottom program and ping again */

 SPDX-License-Identifier: GPL-2.0

 hook ifindex = 0 */

 hook ifindex < 0 */

 hook.attach_point invalid */

 hook.attach_point valid, but parent invalid */

	/* These return EOPNOTSUPP instead of EINVAL as parent is checked after

	 * attach_point of the hook.

 detach */

 query */

 when chain is not present, kernel returns -EINVAL */

 attach */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 query (getpid(), efd) */

 test zero len */

 test empty buffer */

 test smaller buffer */

 SPDX-License-Identifier: GPL-2.0

/*

 * Check if we can migrate child sockets.

 *

 *   1. call listen() for 4 server sockets.

 *   2. call connect() for 25 client sockets.

 *   3. call listen() for 1 server socket. (migration target)

 *   4. update a map to migrate all child sockets

 *        to the last server socket (migrate_map[cookie] = 4)

 *   5. call shutdown() for first 4 server sockets

 *        and migrate the requests in the accept queue

 *        to the last server socket.

 *   6. call listen() for the second server socket.

 *   7. call shutdown() for the last server

 *        and migrate the requests in the accept queue

 *        to the second server socket.

 *   8. call listen() for the last server.

 *   9. call shutdown() for the second server

 *        and migrate the requests in the accept queue

 *        to the last server socket.

 *  10. call accept() for the last server socket.

 *

 * Author: Kuniyuki Iwashima <kuniyu@amazon.co.jp>

 fastopenq->max_qlen and sk->sk_max_ack_backlog */

		/* (TFO_CLIENT_ENABLE | TFO_SERVER_ENABLE |

		 *  TFO_CLIENT_NO_COOKIE | TFO_SERVER_COOKIE_NOT_REQD)

 All requests will be tied to the first four listeners */

		/* The attached XDP program drops only the final ACK, so

		 * clients will transition to TCP_ESTABLISHED immediately.

	/* Migrate TCP_ESTABLISHED and TCP_SYN_RECV requests

	 * to the last listener based on eBPF.

 No dance for TCP_NEW_SYN_RECV to migrate based on eBPF */

	/* Note that we use the second listener instead of the

	 * first one here.

	 *

	 * The fist listener is bind()ed with port 0 and,

	 * SOCK_BINDPORT_LOCK is not set to sk_userlocks, so

	 * calling listen() again will bind() the first listener

	 * on a new ephemeral port and detach it from the existing

	 * reuseport group.  (See: __inet_bind(), tcp_set_state())

	 *

	 * OTOH, the second one is bind()ed with a specific port,

	 * and SOCK_BINDPORT_LOCK is set. Thus, re-listen() will

	 * resurrect the listener on the existing reuseport group.

	/* Migrate from the last listener to the second one.

	 *

	 * All listeners were detached out of the reuseport_map,

	 * so migration will be done by kernel random pick from here.

 Back to the existing reuseport group */

 Migrate back to the last one from the second one */

		/* Drop the final ACK of the 3-way handshake and stick the

		 * in-flight requests on TCP_SYN_RECV or TCP_NEW_SYN_RECV.

 Tie requests to the first four listners */

	/* Migrate the requests in the accept queue only.

	 * TCP_NEW_SYN_RECV requests are not migrated at this point.

		/* Wait for SYN+ACK timers to expire so that

		 * reqsk_timer_handler() migrates TCP_NEW_SYN_RECV requests.

 Resume 3WHS and migrate TCP_NEW_SYN_RECV requests */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Google LLC.

 Copyright (c) 2018 Facebook

 SPDX-License-Identifier: GPL-2.0-only

www.tessares.net> */

 padding */

 executes bpf program that updates map with key, value */

 Let tracepoint trigger */

/* Add key=1 elem with values set for all CPUs

 * Delete elem key=1

 * Run bpf prog that inserts new key=1 elem with value=0x1234

 *   (bpf prog can only set value for current CPU)

 * Lookup Key=1 and check value is as expected for all CPUs:

 *   value set by bpf prog for one CPU, 0 for all others

 max 1 elem in map so insertion is forced to reuse freed entry */

 delete element so the entry can be re-used*/

 run bpf prog that inserts new elem, re-using the slot just freed */

 check that key=1 was re-created by bpf prog */

 and has expected values */

/* Add key=1 and key=2 elems with values set for all CPUs

 * Run bpf prog that inserts new key=3 elem

 *   (only for current cpu; other cpus should have initial value = 0)

 * Lookup Key=1 and check value is as expected for all CPUs

	/* Set up LRU map with 2 elements, values filled for all CPUs.

	 * With these 2 elements, the LRU map is full

 run bpf prog that inserts new key=3 element, re-using LRU slot */

 check that key=3 replaced one of earlier elements */

 and has expected values */

 SPDX-License-Identifier: GPL-2.0

 Set IP_TOS to the expected value (0x80). */

	/* Attach child program and make sure it returns new value:

	 * - kernel:      -> 0x80

	 * - child:  0x80 -> 0x90

	/* Attach parent program and make sure it returns new value:

	 * - kernel:      -> 0x80

	 * - child:  0x80 -> 0x90

	 * - parent: 0x90 -> 0xA0

	/* Setting unexpected initial sockopt should return EPERM:

	 * - kernel: -> 0x40

	 * - child:  unexpected 0x40, EPERM

	 * - parent: unexpected 0x40, EPERM

	/* Detach child program and make sure we still get EPERM:

	 * - kernel: -> 0x40

	 * - parent: unexpected 0x40, EPERM

	/* Set initial value to the one the parent program expects:

	 * - kernel:      -> 0x90

	 * - parent: 0x90 -> 0xA0

 Set IP_TOS to the expected value (0x80). */

 Attach child program and make sure it adds 0x10. */

 Attach parent program and make sure it adds another 0x10. */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Cloudflare

 TCP sock is under repair right now */

 Turn off without window probes */

 Create a map, populate it with one socket, and free the map. */

 do some tests */

 test results */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 generate some branches on cpu 0 */

 spin the loop for a while (random high number) */

 TODO: often fails in concurrent mode */

 create perf event */

 ensure we get at least one perf_event prog execution */

	/* perf_event is still active, but we close link and BPF program

	 * shouldn't be executed anymore

 make sure there are no stragglers */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook */

 trigger */

 SPDX-License-Identifier: GPL-2.0

/* Test read and writes to the stack performed with offsets that are not

 * statically known.

 Give pid to bpf prog so it doesn't trigger for anyone else. */

 Initialize the probe's input. */

 This will be returned in probe_res. */

 Trigger probe. */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 skip the last iteration for expected total */

 SPDX-License-Identifier: GPL-2.0

 Align the .BTF_ids section to 4 bytes */

	/* Check BTF_ID_LIST(test_list_local) and

	 * BTF_ID_LIST_GLOBAL(test_list_global) IDs

 Check BTF_SET_START(test_set) IDs */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 inner1 = input, inner2 = input + 1, inner3 = input + 2 */

 inner2 = input, inner1 = input + 1, inner4 = input + 2 */

 inner5 = input + 2 */

	/* we need to either wait for or force synchronize_rcu(), before

	 * checking for "still exists" condition, otherwise map could still be

	 * resolvable by ID, causing false positives.

	 *

	 * Older kernels (5.8 and earlier) freed map only after two

	 * synchronize_rcu()s, so trigger two, to be entirely sure.

 SPDX-License-Identifier: GPL-2.0

 pid */,

 cpu 0 */, -1 
 flags */);

 check NULL prog array query */

 try to get # of programs only */

 try a few negative tests */

 invalid query pointer */

 no enough space */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook */

 validate values are pre-initialized correctly */

 validate we can pre-setup global variables, even in .bss */

 validate pre-setup values are still there */

 now set new values and attach to get them into outX variables */

 trigger tracepoint */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook */

	/* The bpf prog only counts for fullsock and

	 * passive connection did not become fullsock until 3WHS

	 * had been finished, so the bpf prog only counted two data

	 * packet out.

	/* Active connection is fullsock from the beginning.

	 * 1 SYN and 1 ACK during 3WHS

	 * 2 Acks on data packet.

	 *

	 * The bpf_prog initialized it to 0xeB9F.

 Prepare listen_fd */

 start_server() has logged the error details */

		/* Send some data from accept_fd to cli_fd.

		 * MSG_EOR to stop kernel from coalescing two pkts.

 Create a cgroup, get fd, and join it */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook

 .type = PERF_TYPE_SOFTWARE, */

 override program type */

 pid */,

 cpu 0 */, -1 
 flags */);

 add PERF_SAMPLE_CALLCHAIN, attach should succeed */

 pid */,

 cpu 0 */, -1 
 flags */);

 add exclude_callchain_kernel, attach should fail */

 pid */,

 cpu 0 */, -1 
 flags */);

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2018 Facebook

 Copyright (c) 2019 Cloudflare

 Copyright (c) 2020 Isovalent, Inc.

/*

 * Test that the socket assign program is able to redirect traffic towards a

 * socket, regardless of whether the port or address destination of the traffic

 * matches the port.

 Move to a new networking namespace */

 Configure necessary links, routes */

 Load qdisc, BPF program */

	/* SOCK_STREAM is connected via accept(), so the server's local address

	 * will be the CONNECT_PORT rather than the BIND port that corresponds

	 * to the listen socket. SOCK_DGRAM on the other hand is connectionless

	 * so we can't really do the same check there; the server doesn't ever

	 * create a socket with CONNECT_PORT.

 connect to unbound ports */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2020 Google LLC.

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 Prepare non-reuseport listen_fd */

 Connect to non-reuseport listen_fd */

 Prepare reuseport listen fds */

 Run bpf tcp iter to switch from bpf_cubic to bpf_dctcp */

 Check reuseport listen fds for dctcp */

 Check non reuseport listen fd for dctcp */

 Check established fds for dctcp */

 Check accepted fds for dctcp */

 Load iter_skel */

 Load bpf_cubic */

 Load bpf_dctcp */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 wait until first sys_nanosleep ends and second sys_nanosleep starts */

	/* close progs and detach them. That will trigger two nop5->jmp5 rewrites

	 * in the trampolines to skip nanosleep_fexit prog.

	 * The nanosleep_fentry prog will get detached first.

	 * The nanosleep_fexit prog will get detached second.

	 * Detaching will trigger freeing of both progs JITed images.

	 * There will be two dying bpf_tramp_image-s, but only the initial

	 * bpf_tramp_image (with both _fentry and _fexit progs will be stuck

	 * waiting for percpu_ref_kill to confirm). The other one

	 * will be freed quickly.

 kill the thread to unwind sys_nanosleep stack through the trampoline */

	/* The bypassed nanosleep_fexit prog shouldn't have executed.

	 * Unlike progs the maps were not freed and directly accessible.

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook */

 that's kernel internal BPF_MAX_TRAMP_PROGS define */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2018 Facebook */

 Creating reuseport_array */

 Creating outer_map */

	/*

	 * +1 for TCP-SYN and

	 * +1 for the TCP-ACK (ack the syncookie)

	/*

	 * Simulate TCP-SYN and TCP-ACK are handled by two different sk:

	 * TCP-SYN: select sk_fds[tmp_index = 1] tmp_index is from the

	 *          tmp_index_ovr_map

	 * TCP-ACK: select sk_fds[reuseport_index = 0] reuseport_index

	 *          is from the cmd.reuseport_index

	/*

	 * The sk_fds[] is filled from the back such that the order

	 * is exactly opposite to the (struct sock_reuseport *)reuse->socks[].

 Install reuseport_array to outer_map? */

 Delete reuseport_array from outer_map? */

 test not compatible with socket type */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 SPDX-License-Identifier: GPL-2.0

 trigger probe */

 SPDX-License-Identifier: GPL-2.0

 find map fds */

 give some time for bpf program run */

 disable stack trace collection */

	/* for every element in stackid_hmap, we can find a corresponding one

	 * in stackmap, and vise versa.

 SPDX-License-Identifier: GPL-2.0

 spurious kfree_skb not on loopback device */

 TODO: fix kernel panic caused by this test in parallel mode */

 set up perf buffer */

 read perf buffer */

	/* make sure kfree_skb program was triggered

	 * and it sent expected skb into ring buffer

 SPDX-License-Identifier: GPL-2.0

/* test_tailcall_1 checks basic functionality by patching multiple locations

 * in a single program for a single tail call slot with nop->jmp, jmp->nop

 * and jmp->jmp rewrites. Also checks for nop->nop.

/* test_tailcall_2 checks that patching multiple programs for a single

 * tail call slot works. It also jumps through several programs and tests

 * the tail call limit counter.

/* test_tailcall_3 checks that the count value of the tail call limit

 * enforcement matches with expectations. JIT uses direct jump.

/* test_tailcall_6 checks that the count value of the tail call limit

 * enforcement matches with expectations. JIT uses indirect jump.

/* test_tailcall_4 checks that the kernel properly selects indirect jump

 * for the case where the key is not known. Latter is passed via global

 * data to select different targets we can compare return value of.

/* test_tailcall_5 probes similarly to test_tailcall_4 that the kernel generates

 * an indirect jump when the keys are const but different from different branches.

/* test_tailcall_bpf2bpf_1 purpose is to make sure that tailcalls are working

 * correctly in correlation with BPF subprograms

 nop -> jmp */

 jmp -> nop, call subprog that will do tailcall */

	/* make sure that subprog can access ctx and entry prog that

	 * called this subprog can properly return

/* test_tailcall_bpf2bpf_2 checks that the count value of the tail call limit

 * enforcement matches with expectations when tailcall is preceded with

 * bpf2bpf call.

/* test_tailcall_bpf2bpf_3 checks that non-trivial amount of stack (up to

 * 256 bytes) can be used within bpf subprograms that have the tailcalls

 * in them

/* test_tailcall_bpf2bpf_4 checks that tailcall counter is correctly preserved

 * across tailcalls combined with bpf2bpf calls. for making sure that tailcall

 * counter behaves correctly, bpf program will go through following flow:

 *

 * entry -> entry_subprog -> tailcall0 -> bpf_func0 -> subprog0 ->

 * -> tailcall1 -> bpf_func1 -> subprog1 -> tailcall2 -> bpf_func2 ->

 * subprog2 [here bump global counter] --------^

 *

 * We go through first two tailcalls and start counting from the subprog2 where

 * the loop begins. At the end of the test make sure that the global counter is

 * equal to 31, because tailcall counter includes the first two tailcalls

 * whereas global counter is incremented only on loop presented on flow above.

 *

 * The noise parameter is used to insert bpf_map_update calls into the logic

 * to force verifier to patch instructions. This allows us to ensure jump

 * logic remains correct with instruction movement.

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

/* real layout and sizes according to test's (32-bit) BTF

 can't use `void *`, it is always 8 byte in BPF target */

	/* Emit the following struct with 32-bit pointer size:

	 *

	 * struct test_struct {

	 *     void *ptr;

	 *     unsigned long val2;

	 *     unsigned long long val1;

	 *     unsigned short val3;

	 *     unsigned char val4;

	 *     char: 8;

	 * };

	 *

	 * This struct is going to be used as the "kernel BTF" for this test.

	 * It's equivalent memory-layout-wise to test_struct__real above.

 force 32-bit pointer size */

 "long unsigned int" of 4 byte size tells BTF that sizeof(void *) == 4 */

 bytes */);

 open and load BPF program with custom BTF as the kernel BTF */

 disable handle_signed() for now */

 now re-load with handle_signed() enabled, it should fail loading */

 SPDX-License-Identifier: GPL-2.0

 Matches must be in order of increasing line */

	/* Four tests of known constants.  These aren't staggeringly

	 * interesting since we track exact values now.

 Tests using unknown values */

 Skip over ethernet header.  */

			/* First, add a constant to the R5 packet pointer,

			 * then a variable with a known alignment.

			/* Now, test in the other direction.  Adding first

			 * the variable offset to R5, then the constant.

			/* Test multiple accumulations of unknown values

			 * into a packet pointer.

			/* Calculated offset in R6 has unknown value, but known

			 * alignment of 4.

			/* Offset is added to packet pointer R5, resulting in

			 * known fixed offset, and variable offset from R6.

			/* At the time the word size load is performed from R5,

			 * it's total offset is NET_IP_ALIGN + reg->off (0) +

			 * reg->aux_off (14) which is 16.  Then the variable

			 * offset is considered using reg->aux_off_align which

			 * is 4 and meets the load's requirements.

			/* Variable offset is added to R5 packet pointer,

			 * resulting in auxiliary alignment of 4.

			/* Constant offset is added to R5, resulting in

			 * reg->off of 14.

			/* At the time the word size load is performed from R5,

			 * its total fixed offset is NET_IP_ALIGN + reg->off

			 * (14) which is 16.  Then the variable offset is 4-byte

			 * aligned, so the total offset is 4-byte aligned and

			 * meets the load's requirements.

			/* Constant offset is added to R5 packet pointer,

			 * resulting in reg->off value of 14.

			/* Variable offset is added to R5, resulting in a

			 * variable offset of (4n).

 Constant is added to R5 again, setting reg->off to 18. */

			/* And once more we add a variable; resulting var_off

			 * is still (4n), fixed offset is not changed.

			 * Also, we create a new reg->id.

			/* At the time the word size load is performed from R5,

			 * its total fixed offset is NET_IP_ALIGN + reg->off (18)

			 * which is 20.  Then the variable offset is (4n), so

			 * the total offset is 4-byte aligned and meets the

			 * load's requirements.

 Create an unknown offset, (4n+2)-aligned */

 Add it to the packet pointer */

 Check bounds and perform a read */

 Make a (4n) offset from the value we just read */

 Add it to the packet pointer */

 Check bounds and perform a read */

			/* Calculated offset in R6 has unknown value, but known

			 * alignment of 4.

 Adding 14 makes R6 be (4n+2) */

 Packet pointer has (4n+2) offset */

			/* At the time the word size load is performed from R5,

			 * its total fixed offset is NET_IP_ALIGN + reg->off (0)

			 * which is 2.  Then the variable offset is (4n+2), so

			 * the total offset is 4-byte aligned and meets the

			 * load's requirements.

			/* Newly read value in R6 was shifted left by 2, so has

			 * known alignment of 4.

			/* Added (4n) to packet pointer's (4n+2) var_off, giving

			 * another (4n+2).

			/* At the time the word size load is performed from R5,

			 * its total fixed offset is NET_IP_ALIGN + reg->off (0)

			 * which is 2.  Then the variable offset is (4n+2), so

			 * the total offset is 4-byte aligned and meets the

			 * load's requirements.

 (ptr - ptr) << 2 */

			/* We have a (4n) value.  Let's make a packet offset

			 * out of it.  First add 14, to make it a (4n+2)

 Then make sure it's nonnegative */

 Add it to packet pointer */

 Check bounds and perform a read */

 (ptr - ptr) << 2 == unknown, (4n) */

			/* (4n) + 14 == (4n+2).  We blow our bounds, because

			 * the add could overflow.

 Checked s>=0 */

 packet pointer + nonnegative (4n+2) */

			/* NET_IP_ALIGN + (4n+2) == (4n), alignment is fine.

			 * We checked the bounds, but it might have been able

			 * to overflow if the packet pointer started in the

			 * upper half of the address space.

			 * So we did not get a 'range' on R6, and the access

			 * attempt will fail.

 Create an unknown offset, (4n+2)-aligned */

			/* Create another unknown, (4n)-aligned, and subtract

			 * it from the first one

 Bounds-check the result */

 Add it to the packet pointer */

 Check bounds and perform a read */

			/* Calculated offset in R6 has unknown value, but known

			 * alignment of 4.

 Adding 14 makes R6 be (4n+2) */

 New unknown value in R7 is (4n) */

 Subtracting it from R6 blows our unsigned bounds */

 Checked s>= 0 */

			/* At the time the word size load is performed from R5,

			 * its total fixed offset is NET_IP_ALIGN + reg->off (0)

			 * which is 2.  Then the variable offset is (4n+2), so

			 * the total offset is 4-byte aligned and meets the

			 * load's requirements.

			/* Create an unknown offset, (4n+2)-aligned and bounded

			 * to [14,74]

 Subtract it from the packet pointer */

			/* Create another unknown, (4n)-aligned and >= 74.

			 * That in fact means >= 76, since 74 % 4 == 2

 Add it to the packet pointer */

 Check bounds and perform a read */

			/* Calculated offset in R6 has unknown value, but known

			 * alignment of 4.

 Adding 14 makes R6 be (4n+2) */

 Subtracting from packet pointer overflows ubounds */

 New unknown value in R7 is (4n), >= 76 */

 Adding it to packet pointer gives nice bounds again */

			/* At the time the word size load is performed from R5,

			 * its total fixed offset is NET_IP_ALIGN + reg->off (0)

			 * which is 2.  Then the variable offset is (4n+2), so

			 * the total offset is 4-byte aligned and meets the

			 * load's requirements.

 We make a local copy so that we can strtok() it */

 SPDX-License-Identifier: GPL-2.0

 check global map */

 3 comes from one listening socket + both ends of the connection */

 check setsockopt for SAVE_SYN */

 check getsockopt for SAVED_SYN */

 check getsockopt for window_clamp */

 Send 1000B of '+'s from cli_fd -> accept_fd */

 Send 500B of '.'s from accept_fd ->cli_fd */

	/*

	 * shutdown accept first to guarantee correct ordering for

	 * bytes_received and bytes_acked when we go to verify the results.

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Cloudflare

/*

 * Tests for sockmap/sockhash holding kTLS sockets.

 Disconnect (unhash) a kTLS socket after removing it from sockmap. */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 Invalid key size */

 Invalid value size */

 Invalid max entries size */

 Bloom filter maps do not support BPF_F_NO_PREALLOC */

 Test invalid flags */

 Create a map */

 Add a value to the bloom filter */

 Lookup a value in the bloom filter */

 Create a bloom filter map that will be used as the inner map */

 Add the bloom filter map to the outer map */

 Attach the bloom_filter_inner_map prog */

 Ensure the inner bloom filter map can be deleted */

 Set up a bloom filter map skeleton */

 Set up rand_vals */

 Generate random values and populate both skeletons */

 SPDX-License-Identifier: GPL-2.0

 can not attach BPF_XDP_CPUMAP program to a device */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 Fill test values to be used */

 Push 32 elements to the input map */

	/* The eBPF program pushes iph.saddr in the output map,

	 * pops the input map and saves this value in iph.daddr

 Queue is empty, program should return TC_ACT_SHOT */

 TC_ACT_SHOT */|| size != sizeof(pkt_v4),

 Check that the program pushed elements correctly */

 SPDX-License-Identifier: GPL-2.0

	/*

	 * It's hard to validate the contents of the branch entries b/c it

	 * would require some kind of disassembler and also encoding the

	 * valid jump instructions for supported architectures. So just check

	 * the easy stuff for now.

 attach perf_event */

 generate some branches on cpu 0 */

 spin the loop for a while (random high number) */

 create perf event */

	/*

	 * Some setups don't support branch records (virtual machines, !x86),

	 * so skip test in this case.

/*

 * Tests negative case -- run bpf_read_branch_records() on improperly configured

 * perf event.

 create perf event */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2020 Google LLC.

	/* Lock ensures that spin locked versions of local stoage operations

	 * also work, most operations in this tests are still single threaded

/* Fork and exec the provided rm binary and return the exit code of the

 * forked process and its pid.

		/* Use the copied /usr/bin/rm to delete itself

		 * /tmp/copy_of_rm /tmp/copy_of_rm.

 Looking up an existing element should fail initially */

 Create a new element */

 Lookup the newly created element */

 Check the value of the newly created element */

 The lookup should fail, now that the element has been deleted */

	/* Sets skel->bss->monitored_pid to the pid of the forked child

	 * forks a child process that executes tmp_exec_path and tries to

	 * unlink its executable. This operation should be denied by the loaded

	 * LSM program.

 Set the process being monitored to be the current process */

	/* Move copy_of_rm to a new location so that it triggers the

	 * inode_rename LSM hook with a new_dentry that has a NULL inode ptr.

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

reviews.llvm.org/D109073?");

 SPDX-License-Identifier: GPL-2.0-only

 TODO: use different target function to run in concurrent mode */

 attach 'allowed' trampoline programs */

 and try 1 extra.. */

 ..that needs to fail */

 with E2BIG error */

 and finaly execute the probe */

 SPDX-License-Identifier: GPL-2.0

/* AddressSanitizer sometimes crashes due to data dereference below, due to

 * this being mmap()'ed memory. Disable instrumentation with

 * no_sanitize_address attribute

 load program */

 attach probe */

 set up perf buffer */

 trigger kprobe on every CPU */

 read perf buffer */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 ctx_in != NULL, ctx_size_in == 0 */

 ctx_out != NULL, ctx_size_out == 0 */

 non-zero [len, tc_index] fields should be rejected*/

 non-zero [hash, sk] fields should be rejected */

 SPDX-License-Identifier: GPL-2.0

 NOTE: conflict with other tests. */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook */

 bind, listen and start server thread to accept */

 connect to server */

 recv total_bytes */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Carlos Neira cneirabustos@gmail.com */

 trigger tracepoint */

	/* Create a process in a new namespace, this process

	 * will be the init process of this new namespace hence will be pid 1.

 TODO: use a different tracepoint */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

	/* Ensure 20 bytes options (i.e. in total 40 bytes tcp header) for the

	 * bpf_tcp_gen_syncookie() helper.

 Enforce syncookie mode */

 SPDX-License-Identifier: GPL-2.0-only

 Copyright (c) 2019 Facebook */

 base line run */

 attach kprobe */

 retprobe */,

 attach kretprobe */

 retprobe */,

 attach raw_tp */

 attach fentry */

 attach fexit */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 pin link */

 check that link was pinned */

 destroy link, pinned link should keep program attached */

 re-open link from BPFFS */

 unpin link from BPFFS, program still attached */

 still active, as we have FD open now */

	/* Validate it's finally detached.

	 * Actual detachment might get delayed a bit, so there is no reliable

	 * way to validate it immediately here, let's count up for long enough

	 * and see if eventually output stops being updated

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 SPDX-License-Identifier: GPL-2.0

 TODO: corrupts other tests uses connect() */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

/* ___shuffled flavor is just an illusion for BPF code, it doesn't really

 * exist and user-space needs to provide data in the memory layout that

 * matches callback_head. We just defined ___shuffled flavor to make it easier

 * to work with the skeleton

 next pointers have to be set from the kernel side */

 trigger tracepoint */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2020 Google LLC.

	/* Attach to parent cgroup, trigger packet from child.

	 * Assert that there is only one run and in that run the storage is

	 * parent cgroup's storage.

	 * Also assert that child cgroup's storage does not exist

	/* Attach to parent and child cgroup, trigger packet from child.

	 * Assert that there are two additional runs, one that run with parent

	 * cgroup's storage and one with child cgroup's storage.

	/* Attach to parent cgroup, trigger packet from child.

	 * Assert that there is three runs, two with parent cgroup egress and

	 * one with parent cgroup ingress, stored in separate parent storages.

	 * Also assert that child cgroup's storages does not exist

	/* Attach to parent and child cgroup, trigger packet from child.

	 * Assert that there is six additional runs, parent cgroup egresses and

	 * ingress, child cgroup egresses and ingress.

	 * Assert that egree and ingress storages are separate.

	/* Attach to parent cgroup, trigger packet from child.

	 * Assert that there is three runs, two with parent cgroup egress and

	 * one with parent cgroup ingress.

	 * Also assert that child cgroup's storage does not exist

	/* Attach to parent and child cgroup, trigger packet from child.

	 * Assert that there is six additional runs, parent cgroup egresses and

	 * ingress, child cgroup egresses and ingress.

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Cloudflare

/*

 * Test suite for SOCKMAP/SOCKHASH holding listening sockets.

 * Covers:

 *  1. BPF map operations - bpf_map_{update,lookup delete}_elem

 *  2. BPF redirect helpers - bpf_{sk,msg}_redirect_map

 *  3. BPF reuseport helper - bpf_sk_select_reuseport

 Wrappers that fail the test on error and report it. */

 SOCKMAP and SOCKHASH return different error codes */

/* Exercise the code path where we destroy child sockets that never

 * got accept()'ed, aka orphans, when parent socket gets closed.

/* Perform a passive open after removing listening socket from SOCKMAP

 * to ensure that callbacks get restored properly.

/* Check that child socket that got created while parent was in a

 * SOCKMAP, but got accept()'ed only after the parent has been removed

 * from SOCKMAP, gets cloned without parent psock state or callbacks.

 Create child while parent is in sockmap */

 Remove parent from sockmap */

 Check that child sk_user_data is not set */

/* Check that child socket that got created and accepted while parent

 * was in a SOCKMAP is cloned without parent psock state or callbacks.

 Create & accept child while parent is in sockmap */

 Check that child sk_user_data is not set */

 Expecting EOPNOTSUPP before listen() */

 Expecting no entry after unhash on connect(AF_UNSPEC) */

 Populate sock_map[0] to avoid ENOENT on first connection */

 Update sock_map[0] to redirect to a connected socket */

 Check that redirecting across reuseport groups is not allowed. */

 Create two listeners, each in its own reuseport group */

 Connect to s2, reuseport BPF selects s1 via sock_map[0] */

 Expect drop, can't redirect outside of reuseport group */

 insert */

 delete */

 lookup */

 update */

 races with insert/delete */

 child clone */

 SPDX-License-Identifier: GPL-2.0

 wrong size, should fail */

 object loaded - should fail */

 SPDX-License-Identifier: GPL-2.0

/**

 * Test XDP bonding support

 *

 * Sets up two bonded veth pairs between two fresh namespaces

 * and verifies that XDP_TX program loaded on a bond device

 * are correctly loaded onto the slave devices and XDP_TX'd

 * packets are balanced using bonding.

 skip whitespace */

 skip whitespace */

 skip rx bytes */

 skip whitespace */

	/* Load a dummy program on sending side as with veth peer needs to have a

	 * XDP program loaded as well.

 vary the UDP destination port for even distribution with roundrobin/xor modes */

/* Test the broadcast redirection using xdp_redirect_map_multi_prog and adding

 * all the interfaces to it and checking that broadcasting won't send the packet

 * to neither the ingress bond device (bond2) or its slave (veth2_1).

 populate the devmap with the relevant interfaces */

 Test that XDP programs cannot be attached to both the bond master and slaves simultaneously */

 enslaving with a XDP program loaded is allowed */

 attaching to slave when master has no program is allowed */

 attaching to master not allowed when slave has program loaded */

 attaching XDP program to master allowed when slave has no program */

 attaching to slave not allowed when master has program loaded */

 test program unwinding with a non-XDP slave */

 attaching not allowed when one slave does not support XDP */

 Test with nested bonding devices to catch issue with negative jump label count */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Jesper Dangaard Brouer */

 before test_progs.h, avoid bpf_util.h redefines */

 Hint: needed for CHECK macro */

 Exit if e.g. helper unknown to kernel */

 Extract MTU that BPF-prog got */

 Update "constants" in BPF-prog *BEFORE* libbpf load */

 Extract MTU that BPF-prog got */

 Update "constants" in BPF-prog *BEFORE* libbpf load */

 SPDX-License-Identifier: GPL-2.0

 +1 to test for the info_len returned by kernel */

	/* Each prog only uses one map. +1 to test nr_map_ids

	 * returned by kernel.

 Check bpf_obj_get_info_by_fd() */

		/* test_obj_id.o is a dumb prog. It should never fail

		 * to load.

 Insert a magic value to the map */

 Check getting map info */

 Check getting prog info */

 Check getting link info */

 Check bpf_prog_get_next_id() */

 The bpf_prog is in the dead row */

		/* Negative test:

		 * prog_info.nr_map_ids = 1

		 * prog_info.map_ids = NULL

 Check bpf_map_get_next_id() */

 The bpf_map is in the dead row */

 Check bpf_link_get_next_id() */

 The bpf_link is in the dead row */

 SPDX-License-Identifier: GPL-2.0

	/* Some packets can be still in per-cpu cache, but not more than

	 * MAX_PERCPU_PACKETS.

 No packets should be lost */

	/* Let's check that bytes counter matches the number of packets

	 * multiplied by the size of ipv6 ICMP packet.

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

invoked=*/1,

dsack_dups=*/0,

delivered=*/1,

delivered_ce=*/0,

icsk_retransmits=*/0);

invoked=*/2,

dsack_dups=*/0,

delivered=*/2,

delivered_ce=*/0,

icsk_retransmits=*/0);

 SPDX-License-Identifier: GPL-2.0

 r0 = 1 */

 create a cgroup, attach two programs and remember their ids */

 make sure that programs are attached and run some traffic */

 allocate some memory (4Mb) to pin the original cgroup */

 close programs and cgroup fd */

 leave the cgroup and remove it. don't detach programs */

	/* wait for the asynchronous auto-detachment.

	 * wait for no more than 5 sec and give up.

 don't leave the fd open */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 open/load/attach test_pkt_md_access */

 open extension */

 set extension's attach target - test_pkt_md_access  */

 load/attach extension */

 open tracing  */

 set tracing's attach target - fentry */

 set tracing's attach target - fexit */

 load/attach tracing */

 trigger the test */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021 Facebook */

 See feature_test_macros(7) */

 For SYS_xxx definitions */

 3x syscalls: 1x attach and 2x gettid */

 trigger at least one exit_creds() */

 sync rcu to make sure exit_creds() is called for "ls" */

 trigger sys_enter, make sure it does not cause deadlock */

 SPDX-License-Identifier: GPL-2.0

 Load XDP program to introspect */

 Load trace program */

	/* Demonstrate the bpf_program__set_attach_target() API rather than

	 * the load with options, i.e. opts.attach_prog_fd.

 Set up perf buffer */

 Run test program */

	/* Make sure bpf_xdp_output() was triggered and it sent the expected

	 * data to the perf ring buffer.

 Verify test results */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

	/* test6 is x86_64 specifc because of the instruction

	 * offset, disabling it for all other archs

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2020 Facebook */

	/* the primary goal of this test is to test LBR. Create a lot of

	 * branches in the function, so we can catch it easily.

	/* This is always true. Use the check to make sure the compiler

	 * doesn't remove bpf_testmod_loop_test.

 Magic number to enable writable tp */

 always fail */

 always fail */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook  */

 test 1: lookup/delete an empty hash table, -ENOENT */

 populate elements to the map */

 test 2: lookup/delete with count = 0, success */

 test 3: lookup/delete with count = max_entries, success */

 bpf_map_get_next_key() should return -ENOENT for an empty map. */

 test 4: lookup/delete in a loop with various steps. */

		/* iteratively lookup/delete elements with 'step'

		 * elements each

			/* It is possible that we are failing due to buffer size

			 * not big enough. In such cases, let us just exit and

			 * go with large steps. Not that a buffer size with

			 * max_entries should always work.

 check map is empty, errono == ENOENT */

		/* iteratively lookup/delete elements with 'step'

		 * elements each

			/* It is possible that we are failing due to buffer size

			 * not big enough. In such cases, let us just exit and

			 * go with large steps. Not that a buffer size with

			 * max_entries should always work.

 SPDX-License-Identifier: GPL-2.0

 test 1: lookup in a loop with various steps. */

		/* iteratively lookup/delete elements with 'step'

		 * elements each.

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Facebook  */

 int */

 [1] */

 struct bpf_spin_lock */                      
 int val; */

 struct val */                                
 int cnt; */

 struct bpf_spin_lock l; */

 Suppress compiler false alarm */

 Suppress compiler false alarm */

 Add new elem */

 Bump the cnt and update with BPF_EXIST | BPF_F_LOCK */

 Bump the cnt and update with BPF_EXIST */

 Update with BPF_NOEXIST */

 Bump the cnt again and update with map_flags == 0 */

 Test delete elem */

 SPDX-License-Identifier: GPL-2.0

		/* iteratively lookup/delete elements with 'step'

		 * elements each.

 check map is empty, errono == ENOENT */

 SPDX-License-Identifier: GPL-2.0

 Copyright Intel Corp. 2018 */

	/*

	 * For the test version we need to poll the "hardware" in order

	 * to get the updated status for unlock testing.

 SPDX-License-Identifier: GPL-2.0

 Copyright(c) 2019 Intel Corporation. All rights reserved.

 SPDX-License-Identifier: GPL-2.0

 Copyright(c) 2018 Intel Corporation. All rights reserved.

 SPDX-License-Identifier: GPL-2.0

 Copyright(c) 2019 Intel Corporation. All rights reserved.

 SPDX-License-Identifier: GPL-2.0

 Copyright(c) 2018 Intel Corporation. All rights reserved.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2014-2016, Intel Corporation.

	/*

	 * Limit dax to a single page at a time given vmalloc()-backed

	 * in the nfit_test case.

	/*

	 * If badblocks are present, limit known good range to the

	 * requested range.

 SPDX-License-Identifier: GPL-2.0

 Copyright(c) 2018 Intel Corporation. All rights reserved.

 strong / override definition of nfit_intel_shutdown_status */

 SPDX-License-Identifier: GPL-2.0

 Copyright(c) 2019 Intel Corporation. All rights reserved.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2016, Intel Corporation.

 SPDX-License-Identifier: GPL-2.0

 Copyright(c) 2018 Intel Corporation. All rights reserved.

 SPDX-License-Identifier: GPL-2.0

	/*

	 * These kconfig symbols must be set to "m" for nfit_test to

	 * load and operate.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright(c) 2013-2015 Intel Corporation. All rights reserved.

/*

 * Generate an NFIT table to describe the following topology:

 *

 * BUS0: Interleaved PMEM regions, and aliasing with BLK regions

 *

 *                     (a)                       (b)            DIMM   BLK-REGION

 *           +----------+--------------+----------+---------+

 * +------+  |  blk2.0  |     pm0.0    |  blk2.1  |  pm1.0  |    0      region2

 * | imc0 +--+- - - - - region0 - - - -+----------+         +

 * +--+---+  |  blk3.0  |     pm0.0    |  blk3.1  |  pm1.0  |    1      region3

 *    |      +----------+--------------v----------v         v

 * +--+---+                            |                    |

 * | cpu0 |                                    region1

 * +--+---+                            |                    |

 *    |      +-------------------------^----------^         ^

 * +--+---+  |                 blk4.0             |  pm1.0  |    2      region4

 * | imc1 +--+-------------------------+----------+         +

 * +------+  |                 blk5.0             |  pm1.0  |    3      region5

 *           +-------------------------+----------+-+-------+

 *

 * +--+---+

 * | cpu1 |

 * +--+---+                   (Hotplug DIMM)

 *    |      +----------------------------------------------+

 * +--+---+  |                 blk6.0/pm7.0                 |    4      region6/7

 * | imc0 +--+----------------------------------------------+

 * +------+

 *

 *

 * *) In this layout we have four dimms and two memory controllers in one

 *    socket.  Each unique interface (BLK or PMEM) to DPA space

 *    is identified by a region device with a dynamically assigned id.

 *

 * *) The first portion of dimm0 and dimm1 are interleaved as REGION0.

 *    A single PMEM namespace "pm0.0" is created using half of the

 *    REGION0 SPA-range.  REGION0 spans dimm0 and dimm1.  PMEM namespace

 *    allocate from from the bottom of a region.  The unallocated

 *    portion of REGION0 aliases with REGION2 and REGION3.  That

 *    unallacted capacity is reclaimed as BLK namespaces ("blk2.0" and

 *    "blk3.0") starting at the base of each DIMM to offset (a) in those

 *    DIMMs.  "pm0.0", "blk2.0" and "blk3.0" are free-form readable

 *    names that can be assigned to a namespace.

 *

 * *) In the last portion of dimm0 and dimm1 we have an interleaved

 *    SPA range, REGION1, that spans those two dimms as well as dimm2

 *    and dimm3.  Some of REGION1 allocated to a PMEM namespace named

 *    "pm1.0" the rest is reclaimed in 4 BLK namespaces (for each

 *    dimm in the interleave set), "blk2.1", "blk3.1", "blk4.0", and

 *    "blk5.0".

 *

 * *) The portion of dimm2 and dimm3 that do not participate in the

 *    REGION1 interleaved SPA range (i.e. the DPA address below offset

 *    (b) are also included in the "blk4.0" and "blk5.0" namespaces.

 *    Note, that BLK namespaces need not be contiguous in DPA-space, and

 *    can consume aliased capacity from multiple interleave sets.

 *

 * BUS1: Legacy NVDIMM (single contiguous range)

 *

 *  region2

 * +---------------------+

 * |---------------------|

 * ||       pm2.0       ||

 * |---------------------|

 * +---------------------+

 *

 * *) A NFIT-table may describe a simple system-physical-address range

 *    with no BLK aliasing.  This type of region may optionally

 *    reference an NVDIMM.

 spa0 iset */

 spa1 iset */ + 1 
 permit testing multiple NFITs per system */

 extended status, FW update in progress */

	/*

	 * check offset + len > size of fw storage

	 * check length is > max send length

 update already done, need activation */

 finish */

 set 1 second of time for firmware "update" */

 abort */

 successfully aborted status */

 bad control flag */

 sequencing error */

 bogus test version */

 we should never get here */

 for testing, only store up to n records that fit within 4k */

 skip entries outside the range */

	/*

	 * last dimm is selected for test

 we do not erase master state passphrase ever */

	/*

	 * Emulate 3 second activation max, and 1 second incremental

	 * quiesce time per dimm requiring multiple activates to get all

	 * DIMMs updated.

 lookup per-dimm data */

 for testing, only store up to n records that fit within 4k */

 until spa location cookie support is added... */

	/*

	 * spa0 (interleave first half of dimm0 and dimm1, note storage

	 * does not actually alias the related block-data-window

	 * regions)

	/*

	 * spa1 (interleave last half of the 4 DIMMS, note storage

	 * does not actually alias the related block-data-window

	 * regions)

 spa2 (dcr0) dimm0 */

 spa3 (dcr1) dimm1 */

 spa4 (dcr2) dimm2 */

 spa5 (dcr3) dimm3 */

 spa6 (bdw for dcr0) dimm0 */

 spa7 (bdw for dcr1) dimm1 */

 spa8 (bdw for dcr2) dimm2 */

 spa9 (bdw for dcr3) dimm3 */

 mem-region0 (spa0, dimm0) */

 mem-region1 (spa0, dimm1) */

 mem-region2 (spa1, dimm0) */

 mem-region3 (spa1, dimm1) */

 mem-region4 (spa1, dimm2) */

 mem-region5 (spa1, dimm3) */

 mem-region6 (spa/dcr0, dimm0) */

 mem-region7 (spa/dcr1, dimm1) */

 mem-region8 (spa/dcr2, dimm2) */

 mem-region9 (spa/dcr3, dimm3) */

 mem-region10 (spa/bdw0, dimm0) */

 mem-region11 (spa/bdw1, dimm1) */

 mem-region12 (spa/bdw2, dimm2) */

 mem-region13 (spa/dcr3, dimm3) */

 dcr-descriptor0: blk */

 dcr-descriptor1: blk */

 dcr-descriptor2: blk */

 dcr-descriptor3: blk */

 dcr-descriptor0: pmem */

 dcr-descriptor1: pmem */

 dcr-descriptor2: pmem */

 dcr-descriptor3: pmem */

 bdw0 (spa/dcr0, dimm0) */

 bdw1 (spa/dcr1, dimm1) */

 bdw2 (spa/dcr2, dimm2) */

 bdw3 (spa/dcr3, dimm3) */

 flush0 (dimm0) */

 flush1 (dimm1) */

 flush2 (dimm2) */

 flush3 (dimm3) */

 platform capabilities */

 dcr-descriptor4: blk */

 dcr-descriptor4: pmem */

 bdw4 (spa/dcr4, dimm4) */

 spa10 (dcr4) dimm4 */

		/*

		 * spa11 (single-dimm interleave for hotplug, note storage

		 * does not actually alias the related block-data-window

		 * regions)

 spa12 (bdw for dcr4) dimm4 */

 mem-region14 (spa/dcr4, dimm4) */

 mem-region15 (spa11, dimm4) */

 mem-region16 (spa/bdw4, dimm4) */

 flush3 (dimm4) */

 sanity check to make sure we've filled the buffer */

 spa0 (flat range with no bdw aliasing) */

 virtual cd region */

 mem-region0 (spa0, dimm0) */

 dcr-descriptor0 */

 dcr-descriptor1 */

 sanity check to make sure we've filled the buffer */

 give us some some coverage of the arch_invalidate_pmem() API */

 basic checkout of a typical 'get config size' command */

 test ars_status with zero output */

 test ars_cap with benign extended status */

 test ars_status with 'status' trimmed from 'out_length' */

 test ars_status with 'Output (Size)' including 'status' */

 test extended status for get_config_size results in failure */

 test clear error */

 test firmware activate bus info */

 common alloc */

 pass */;

 pass */;

 per-nfit specific alloc */

 associate dimm devices with nfit_mem data for notification testing */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright(c) 2013-2015 Intel Corporation. All rights reserved.

 SPDX-License-Identifier: GPL-2.0-only

 bus 1 */

 bus 2 */

	/* Failures for a DIMM can be injected using fail_cmd and

	 * fail_cmd_code, see the device attributes below

 Each instance can be taken as a bus, which can have multiple dimms */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * vsock_test - vsock.ko test suite

 *

 * Copyright (C) 2017 Red Hat, Inc.

 *

 * Author: Stefan Hajnoczi <stefanha@redhat.com>

 Wait for the server to be ready */

 Notify the server that the client has finished */

 Notify the client that the server is ready */

 Wait for the client to finish */

	/* Wait for the remote to close the connection, before check

	 * -EPIPE error on send.

	/* Wait for the remote to close the connection, before check

	 * -EPIPE error on send.

/* With the standard socket sizes, VMCI is able to support about 100

 * concurrent stream connections.

 Send several messages, one with MSG_EOR flag */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * vsock_diag_test - vsock_diag.ko test suite

 *

 * Copyright (C) 2017 Red Hat, Inc.

 *

 * Author: Stefan Hajnoczi <stefanha@redhat.com>

 Per-socket status */

/*

 * Read vsock stats into a list.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * vsock test utilities

 *

 * Copyright (C) 2017 Red Hat, Inc.

 *

 * Author: Stefan Hajnoczi <stefanha@redhat.com>

 Install signal handlers */

 Parse a CID in string representation */

 Wait for the remote to close the connection */

 Connect to <cid, port> and return the file descriptor. */

/* Listen on <cid, port> and return the first incoming connection.  The remote

 * address is stored to clientaddrp.  clientaddrp may be NULL.

/* Transmit one byte and check the return value.

 *

 * expected_ret:

 *  <0 Negative errno (for testing errors)

 *   0 End-of-file

 *   1 Success

/* Receive one byte and check the return value.

 *

 * expected_ret:

 *  <0 Negative errno (for testing errors)

 *   0 End-of-file

 *   1 Success

 Run test cases.  The program terminates if a failure occurs. */

		/* Full barrier before executing the next test.  This

		 * ensures that client and server are executing the

		 * same test case.  In particular, it means whoever is

		 * faster will not see the peer still executing the

		 * last test.  This is important because port numbers

		 * can be used by multiple test cases.

 SPDX-License-Identifier: GPL-2.0-only

/* Timeout API for single-threaded programs that use blocking

 * syscalls (read/write/send/recv/connect/accept).

 *

 * Copyright (C) 2017 Red Hat, Inc.

 *

 * Author: Stefan Hajnoczi <stefanha@redhat.com>

/* Use the following pattern:

 *

 *   timeout_begin(TIMEOUT);

 *   do {

 *       ret = accept(...);

 *       timeout_check("accept");

 *   } while (ret < 0 && ret == EINTR);

 *   timeout_end();

/* SIGALRM handler function.  Do not use sleep(2), alarm(2), or

 * setitimer(2) while using this API - they may interfere with each

 * other.

/* Start a timeout.  Call timeout_check() to verify that the timeout hasn't

 * expired.  timeout_end() must be called to stop the timeout.  Timeouts cannot

 * be nested.

 Exit with an error message if the timeout has expired */

 Stop a timeout */

 SPDX-License-Identifier: GPL-2.0-only

/* Control socket for client/server test execution

 *

 * Copyright (C) 2017 Red Hat, Inc.

 *

 * Author: Stefan Hajnoczi <stefanha@redhat.com>

/* The client and server may need to coordinate to avoid race conditions like

 * the client attempting to connect to a socket that the server is not

 * listening on yet.  The control socket offers a communications channel for

 * such coordination tasks.

 *

 * If the client calls control_expectln("LISTENING"), then it will block until

 * the server calls control_writeln("LISTENING").  This provides a simple

 * mechanism for coordinating between the client and the server.

 Open the control socket, either in server or client mode */

 Free resources */

 Write a line to the control socket */

/* Return the next line from the control socket (without the trailing newline).

 *

 * The program terminates if a timeout occurs.

 *

 * The caller must free() the returned string.

 Wait until a given line is received or a timeout occurs */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * tmon.c Thermal Monitor (TMON) main function and entry point

 *

 * Copyright (C) 2012 Intel Corporation. All rights reserved.

 *

 * Author: Jacob Pan <jacob.jun.pan@linux.intel.com>

 seconds */

unsigned long no_control = 1; /* monitoring only or use cooling device for

			       * temperature control.

 can be select by tui later */

 for recording thermal data to a file */

cooling device used for the PID controller */

 user selected target zone instance */

 relax control knobs, undo throttling */

 open local data log file */

 The log file must be a regular file owned by us */

 size of long + 1 */

 controller output */

	/* validate range of user selected target zone, default to the first

	 * instance if out of range

 fork */

 kill parent */

 disable TUI, it may not be necessary, but saves some resource */

 change the file mode mask */

 new SID for the daemon process */

 change working directory */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * tui.c ncurses text user interface for TMON program

 *

 * Copyright (C) 2013 Intel Corporation. All rights reserved.

 *

 * Author: Jacob Pan <jacob.jun.pan@linux.intel.com>

 one row for tz name, one for trip points */

 daemon mode flag (set by startup parameter -d) */

 must delete panels before their attached windows */

 wrap at 5 */

/*

 * list cooling devices + "set temp" entry; wraps after 5 rows, if they fit

 2 lines for border */

	/* two lines to show borders, one line per tz show trip point position

	 * and value.

	 * dialogue window is a pop-up, when needed it lays on top of cdev win

	/* prepare panels for dialogue, if panel already created then we must

	 * be doing resizing, so just replace windows with new ones, old ones

	 * should have been deleted by close_window

 Set up the user pointer to the next panel*/

 start over when term gets resized, but first we clean up */

 get the new screen size */

 rate limit */

		/* draw cooling device list on the left in the order of

		 * cooling device instances. skip unused idr.

 show cdev binding, y is the global cooling device instance */

 draw a column of spaces to separate thermal zones */

				int k = 0; /* per zone trip point id that

					    * binded to this cdev, one to

					    * many possible based on the

					    * binding bitmask.

 draw each trip binding for the cdev */

 draw '*' to show binding */

	/* draw border after data so that border will not be messed up

	 * even there is not enough space for all the data to be shown

 Silence compiler 'unused' warnings */

 list all the available tunables */

 save last choice for target temp */

 print legend at the bottom line */

 draw border last such that everything is within boundary */

 enable keyboard mapping */

 tell curses not to do NL->CR/NL on output */

 take input chars one at a time */

 dont echo input */

 turn off cursor */

		/* when term size is too small, no dialogue panels are set.

		 * we need to filter out such cases.

 top panel filter */

 TAB */

 force refresh */

 make gcc happy */

 draw a horizontal bar in given pattern */

/* fill a string with trip point type and value in one line

 * e.g.      P(56)    C(106)

 * maintain the distance one degree per char

 draw a line as ruler */

 y at tz temp data line */

 fill trip points for each tzone */

 draw trip point from low to high for each tz */

 loop through all trip points */

			/* reverse the order here since trips are sorted

			 * in ascending order in terms of temperature.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * pid.c PID controller for testing cooling devices

 *

 * Copyright (C) 2012 Intel Corporation. All rights reserved.

 *

 * Author Name Jacob Pan <jacob.jun.pan@linux.intel.com>

/**************************************************************************

 * PID (Proportional-Integral-Derivative) controller is commonly used in

 * linear control system, consider the the process.

 * G(s) = U(s)/E(s)

 * kp = proportional gain

 * ki = integral gain

 * kd = derivative gain

 * Ts

 * We use type C Alan Bradley equation which takes set point off the

 * output dependency in P and D term.

 *

 *   y[k] = y[k-1] - kp*(x[k] - x[k-1]) + Ki*Ts*e[k] - Kd*(x[k]

 *          - 2*x[k-1]+x[k-2])/Ts

 *

 *

 cached data from previous loop */

 input temperature x[k-#] */

/*

 * TODO: make PID parameters tuned automatically,

 * 1. use CPU burn to produce open loop unit step response

 * 2. calculate PID based on Ziegler-Nichols rule

 *

 * add a flag for tuning PID

 init pid params */

 TODO: get it from TUI tuning tab */

 TODO: relax control data when not over thermal limit */

/* To be called at time interval Ts. Type C PID controller.

 *    y[k] = y[k-1] - kp*(x[k] - x[k-1]) + Ki*Ts*e[k] - Kd*(x[k]

 *          - 2*x[k-1]+x[k-2])/Ts

 * TODO: add low pass filter for D term

 error */

 compute intermediate PID terms */

 compute output */

 update sample data */

 clamp output adjustment range */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * sysfs.c sysfs ABI access functions for TMON program

 *

 * Copyright (C) 2013 Intel Corporation. All rights reserved.

 *

 * Author: Jacob Pan <jacob.jun.pan@linux.intel.com>

 history of thermal data, used for control algo */

 index to the trec array */

 get states of the cooling device instance */

 scan and fill in trip point info for a thermal zone and trip point id */

 check trip point type */

 TODO: check attribute */

 return instance id for file format such as trip_point_4_temp */

 Find trip point info of a thermal zone */

		/* check if trip point temp is non-zero

		 * ignore 0/invalid trip points

 found a valid trip point */

 check cooling devices for binding info. */

 find the link to real cooling device record binding */

			/* find the trip point in which the cdev is binded to

			 * in this tzone

			/* validate trip point range, e.g. trip could return -1

			 * when passive is enabled

/*****************************************************************************

 * Before calling scan_tzones, thermal sysfs must be probed to determine

 * the number of thermal zones and cooling devices.

 * We loop through each thermal zone and fill in tz_info struct, i.e.

 * ptdata.tzi[]

root@jacob-chiefriver:~# tree -d /sys/class/thermal/thermal_zone0

/sys/class/thermal/thermal_zone0

|-- cdev0 -> ../cooling_device4

|-- cdev1 -> ../cooling_device3

|-- cdev10 -> ../cooling_device7

|-- cdev11 -> ../cooling_device6

|-- cdev12 -> ../cooling_device5

|-- cdev2 -> ../cooling_device2

|-- cdev3 -> ../cooling_device1

|-- cdev4 -> ../cooling_device0

|-- cdev5 -> ../cooling_device12

|-- cdev6 -> ../cooling_device11

|-- cdev7 -> ../cooling_device10

|-- cdev8 -> ../cooling_device9

|-- cdev9 -> ../cooling_device8

|-- device -> ../../../LNXSYSTM:00/device:62/LNXTHERM:00

|-- power

`-- subsystem -> ../../../../class/thermal

 keep track of valid tzones */

 detect trip points and cdev attached to this tzone */

 index for cdev */

 increment cdev index */

TODO: reverse trip points */

			/* there is a gap in cooling device id, check again

			 * for the same index.

 detect number of thermal zones and cooling devices */

				/* keep track of the max cooling device since

				 * there may be gaps.

 we still show thermal zone information if there is no cdev */

 now probe tzones */

 convert sysfs zone instance to zone array index */

 read temperature of all thermal zones */

 circular buffer for keeping historic data */

 set all ctrl cdev to the same state */

 scale to percentage of max_state */

	/* TODO: take average of all ctrl types. also consider change based on

	 * uevent. Take the first reading for now.

/*

 * perf.c

 *

 * Performance analysis utility.

 *

 * This is the main hub from which the sub-commands (perf stat,

 * perf top, perf record, perf report, etc.) are started.

 page_size

 usage()

 returns 0 for "no pager", 1 for "use pager", and -1 for "not specified" */

/*

 * returns 0 for "no tui", 1 for "use tui", 2 for "use gtk",

 * and -1 for "not specified"

 setup_pager(); */

		/*

		 * For legacy reasons, the "version" and "help"

		 * commands can be written with "--" prepended

		 * to make them look like flags.

		/*

		 * Shortcut for '-h' and '-v' options to invoke help

		 * and version command.

		/*

		 * Check remaining flags.

 Somebody closed stdout? */

 Ignore write errors for pipes and sockets.. */

 Check for ENOSPC and EIO errors.. */

 Turn "perf cmd --help" into "perf help cmd" */

	/*

	 * argv[0] must be the perf command, but the argv array

	 * belongs to the caller, and may be reused in

	 * subsequent loop iterations. Save argv[0] and

	 * restore it on error.

	/*

	 * if we fail because the command is not found, it is

	 * OK to return. Otherwise, we just pass along the status code.

 as if we called execvp */

 See if it's an internal command */

 .. then try the external ones */

 libsubcmd init */

 Setting $PERF_CONFIG makes perf read _only_ the given config file. */

	/*

	 * "perf-xxxx" is the same as "perf xxxx", but we obviously:

	 *

	 *  - cannot take flags in between the "perf" and the "xxxx".

	 *  - cannot execute it externally (since it would just do

	 *    the same thing over again)

	 *

	 * So we just directly call the internal command handler. If that one

	 * fails to handle this, then maybe we just run a renamed perf binary

	 * that contains a dash in its name. To handle this scenario, we just

	 * fall through and ignore the "xxxx" part of the command string.

		/*

		 * If the command is handled, the above function does not

		 * return undo changes and fall through in such a case.

 Look for flags.. */

 The user didn't specify a command; give them help */

	/*

	 * We use PATH to find perf commands, but we prepend some higher

	 * precedence paths: the "--exec-path" option, the PERF_EXEC_PATH

	 * environment, and the $(perfexecdir) from the Makefile at build

	 * time.

	/*

	 * Block SIGWINCH notifications so that the thread that wants it can

	 * unblock and get syscalls like select interrupted instead of waiting

	 * forever while the signal goes to some other non interested thread.

 SPDX-License-Identifier: GPL-2.0

/*

 * builtin-buildid-cache.c

 *

 * Builtin buildid-cache command: Manages build-id cache

 *

 * Copyright (C) 2010, Red Hat Inc.

 * Copyright (C) 2010, Arnaldo Carvalho de Melo <acme@redhat.com>

 Remove YYYYmmddHHMMSShh directory */

 Try to remove buildid directory */

 Try to remove [kernel.kcore] directory */

 -l is exclusive. It can not be used with other options. */

/*

 * builtin-trace.c

 *

 * Builtin 'trace' command:

 *

 * Display a continuously updated trace of any workload, CPU, specific PID,

 * system wide, etc.  Default format is loosely strace like, but any other

 * event may be specified using --event.

 *

 * Copyright (C) 2012, 2013, 2014, 2015 Red Hat Inc, Arnaldo Carvalho de Melo <acme@redhat.com>

 *

 * Initially based on the 'trace' prototype by Thomas Gleixner:

 *

 * http://lwn.net/Articles/415728/ ("Announcing a new utility: 'trace'")

/*

 * strtoul: Go from a string to a value, i.e. for msr: MSR_FS_BASE to 0xc0000100

 for arrays

 per syscall BPF_MAP_TYPE_PROG_ARRAY

/*

 * The evsel->priv as used by 'perf trace'

 * sc:	for raw_syscalls:sys_{enter,exit} and syscalls:sys_{enter,exit}_SYSCALLNAME

 * fmt: for all the other tracepoints

/*

 * Used with raw_syscalls:sys_{enter,exit} and with the

 * syscalls:sys_{enter,exit}_SYSCALL tracepoints

/*

 * Used with all the other tracepoints.

 older kernel (e.g., RHEL6) use syscalls:{enter,exit} */

 %s??? */", sa->prefix);

 %s??? */", sa->prefix);

 %s??? */", sas->entries[0]->prefix);

 XXX Hey, maybe for sched:sched_switch prev/next comm fields we can

     fill missing comms using thread__set_comm()...

     here or in a special syscall_arg__scnprintf_pid_sched_tp...

 0 */

 mode */ }, }, },

 code */ },

 arg2 */ }, }, },

 fd */ },

 umyaddr */ },

 addrlen */ }, }, },

 brk */ }, }, },

 fd */ }, }, },

 fd */ },

 servaddr */ },

 addrlen */ }, }, },

 flags */ }, }, },

 fd */ }, }, },

 fd */ }, }, },

 cmd */

 arg */ }, }, },

 cmd */ }, }, },

 attr_flags */ }, }, },

 dfd */ },

 path */ },

 flags */ }, }, },

 op */ },

 val3 */ }, }, },

 fd */ }, }, },

 flags */ }, }, },

/*

 * FIXME: Make this available to all arches.

 cmd */ },

 arg */ }, }, },

 arg */ }, }, },

 sig */ }, }, },

 fd */ }, }, },

 start */ },

 behavior */ }, }, },

 fd */ }, }, },

 fd */ }, }, },

 The standard mmap maps to old_mmap on s390x */

 prot */ },

 flags */

 offset */ }, }, },

 dev_name */ },

 flags */

 flags */ }, }, },

 from_dfd */ },

 from_pathname */ },

 to_dfd */ },

 to_pathname */ },

 flags */ }, }, },

 start */ },

 prot */ }, }, },

 u_name */ }, }, },

 flags */ }, }, },

 dfd */ }, }, },

 dfd */ }, }, },

 flags */ }, }, },

 dfd */ },

 flags */ }, }, },

 dfd */ },

 flags */ }, }, },

 cpu */ },

 group_fd */ },

 flags */ }, }, },

 flags */ }, }, },

 access_rights */ }, }, },

 key */ }, }, },

 start */ },

 prot */ },

 pkey */ }, }, },

 option */

 arg2 */ },

 arg3 */ }, }, },

 dfd */ }, }, },

 flags */ }, }, },

 flags */ }, }, },

 flags */ }, }, },

 olddirfd */ },

 newdirfd */ }, }, },

 olddirfd */ },

 newdirfd */ },

 flags */ }, }, },

 sig */ }, }, },

 sig */ }, }, },

 sig */ }, }, },

 policy */ }, }, },

 op */ },

 flags */ }, }, },

 flags */ }, }, },

 flags */ }, }, },

 flags */ },

 addr */ }, }, },

 type */ },

 protocol */ }, }, },

 type */ },

 protocol */ }, }, },

 fdat */ },

 flags */ } ,

 mask */ }, }, },

 specialfile */ }, }, },

 specialfile */ }, }, },

 dfd */ }, }, },

 flags */ }, }, },

 sig */ }, }, },

 sig */ }, }, },

 name */ }, }, },

 dfd */ }, }, },

 dirfd */ }, }, },

 options */ }, }, },

 options */ }, }, },

/*

 * is_exit: is this "exit" or "exit_group"?

 * is_open: is this "open" or "openat"? To associate the fd returned in sys_exit with the pathname in sys_enter.

 * args_size: sum of the sizes of the syscall arguments, anything after that is augmented stuff: pathname for openat, etc.

 * nonexistent: Just a hole in the syscall table, syscall id not allocated

/*

 * Must match what is in the BPF program:

 *

 * tools/perf/examples/bpf/augmented_raw_syscalls.c

/*

 * We need to have this 'calculated' boolean because in some cases we really

 * don't know what is the duration of a syscall, for instance, when we start

 * a session and some threads are waiting for a syscall to finish, say 'poll',

 * in which case all we can do is to print "( ? ) for duration and for the

 * start timestamp.

/**

 * filename.ptr: The filename char pointer that will be vfs_getname'd

 * filename.entry_str_pos: Where to insert the string translated from

 *                         filename.ptr by the vfs_getname tracepoint/kprobe.

 * ret_scnprintf: syscall args may set this to a different syscall return

 *                formatter, for instance, fcntl may return fds, file flags, etc.

	/*

	 * So that the next arg with a payload can consume its augmented arg, i.e. for rename* syscalls

	 * we would have two strings, each prefixed by its size.

/*

 * We're handling tstamp=0 as an undefined tstamp, i.e. like when we are

 * using ttrace->entry_time for a thread that receives a sys_exit without

 * first having received a sys_enter ("poll" issued before tracing session

 * starts, lost sys_enter exit due to ring buffer overflow).

			/*

			 * /sys/kernel/tracing/events/syscalls/sys_enter*

			 * egrep 'field:.*fd;' .../format|sed -r 's/.*field:([a-z ]+) [a-z_]*fd.+/\1/g'|sort|uniq -c

			 * 65 int

			 * 23 unsigned int

			 * 7 unsigned long

 When using libaudit we don't know beforehand what is the max syscall id

 Need to memset from offset 0 and +1 members if brand new

	/*

	 * We need to check and discard the first variable '__syscall_nr'

	 * or 'nr' that mean the syscall number. It is needless here.

	 * So drop '__syscall_nr' or 'nr' field but does not exist on older kernels.

/*

 * args is to be interpreted as a series of longs but we need to handle

 * 8-byte unaligned accesses. args points to raw_data within the event

 * and raw_data is guaranteed to be 8-byte unaligned because it is

 * preceded by raw_size which is a u32. So we need to copy args to a temp

 * variable to read it. Most notably this avoids extended load instructions

 * on unaligned addresses

/*

 * Check if the value is in fact zero, i.e. mask whatever needs masking, such

 * as mount 'flags' argument that needs ignoring some magic flag, see comment

 * in tools/perf/trace/beauty/mount_flags.c

	/*

	 * Things like fcntl will set this in its 'cmd' formatter to pick the

	 * right formatter for the return value (an fd? file flags?), which is

	 * not needed for syscalls that always return a given type, say an fd.

			/*

			 * Some syscall args need some mask, most don't and

			 * return val untouched.

			/*

 			 * Suppress this argument if its value is zero and

 			 * and we don't have a string associated in an

 			 * strarray for it.

		/*

		 * If we managed to read the tracepoint /format file, then we

		 * may end up not having any args, like with gettid(), so only

		 * print the raw args when we didn't manage to read it.

		/*

		 * XXX: Noticed on x86_64, reproduced as far back as 3.0.36, haven't tried

		 * before that, leaving at a higher verbosity level till that is

		 * explained. Reproduced with plain ftrace with:

		 *

		 * echo 1 > /t/events/raw_syscalls/sys_exit/enable

		 * grep "NR -1 " /t/trace_pipe

		 *

		 * After generating some load on the machine.

		/*

		 * With libaudit we don't know beforehand what is the max_id,

		 * so we let trace__read_syscall_info() figure that out as we

		 * go on reading syscalls.

	/*

	 * For now with BPF raw_augmented we hook into raw_syscalls:sys_enter

	 * and there we get all 6 syscall args plus the tracepoint common fields

	 * that gets calculated at the start and the syscall_nr (another long).

	 * So we check if that is the case and if so don't look after the

	 * sc->args_size but always after the full raw_syscalls:sys_enter payload,

	 * which is fixed.

	 *

	 * We'll revisit this later to pass s->args_size to the BPF augmenter

	 * (now tools/perf/examples/bpf/augmented_raw_syscalls.c, so that it

	 * copies only what we need for each syscall, like what happens when we

	 * use syscalls:sys_enter_NAME, so that we reduce the kernel/userspace

	 * traffic to just what is needed for each syscall.

	/*

	 * If this is raw_syscalls.sys_enter, then it always comes with the 6 possible

	 * arguments, even if the syscall being handled, say "openat", uses only 4 arguments

	 * this breaks syscall__augmented_args() check for augmented args, as we calculate

	 * syscall->args_size using each syscalls:sys_enter_NAME tracefs format file,

	 * so when handling, say the openat syscall, we end up getting 6 args for the

	 * raw_syscalls:sys_enter event, when we expected just 4, we end up mistakenly

	 * thinking that the extra 2 u64 args are the augmented filename, so just check

	 * here and avoid using augmented syscalls when the evsel is the raw_syscalls one.

 See trace__vfs_getname & trace__sys_exit */

	/*

	 * We need to get ttrace just to make sure it is there when syscall__scnprintf_args()

	 * and the rest of the beautifiers accessing it via struct syscall_arg touches it.

 TODO: user-configurable print_opts */

 the closing ')' */

	/*

	 * We only consider an 'event' for the sake of --max-events a non-filtered

	 * sys_enter + sys_exit and other tracepoint events.

 \0 */

 \0 */

		/*

		 * Some syscall args need some mask, most don't and

		 * return val untouched.

		/*

		 * Suppress this argument if its value is zero and

		 * and we don't have a string associated in an

		 * strarray for it.

		/*

		 * XXX Perhaps we should have a show_tp_arg_names,

		 * leaving show_arg_names just for syscalls?

	/*

	 * Check if we called perf_evsel__disable(evsel) due to, for instance,

	 * this event's max_events having been hit and this is an entry coming

	 * from the ring buffer that we should discard, since the max events

	 * have already been considered/printed.

		/*

		 * XXX: Not having the associated syscall info or not finding/adding

		 * 	the thread should never happen, but if it does...

		 * 	fall thru and print it as a bpf_output event.

	/*

	 * BPF events were not setting PERF_SAMPLE_TIME, so be more robust

	 * and don't use sample->time unconditionally, we may end up having

	 * some other event in the future without PERF_SAMPLE_TIME for good

	 * reason, i.e. we may not be interested in its timestamps, just in

	 * it taking place, picking some piece of information when it

	 * appears in our event stream (vfs_getname comes to mind).

 +3 is for the event string below and the pid filter */

 event string may be different for older kernels - e.g., RHEL6 */

		/*

		 * We're interested only in the user space callchain

		 * leading to the syscall, allow overriding that for

		 * debugging reasons using --kernel_syscall_callchains

 Should be set like strace -s strsize */

	/*

	 * We're only interested in syscalls that have a pointer:

 The candidate just doesn't copies our pointer arg, might copy other pointers we want.

 The candidate might copy a pointer we don't have, skip it.

		/*

		 * Check if the tentative pair syscall augmenter has more pointers, if it has,

		 * then it may be collecting that and we then can't use it, as it would collect

		 * more than what is common to the two syscalls.

		/*

		 * If the pair isn't enabled, then its bpf_prog.sys_enter will not

		 * have been searched for, so search it here and if it returns the

		 * unaugmented one, then ignore it, otherwise we'll reuse that BPF

		 * program for a filtered syscall on a non-filtered one.

		 *

		 * For instance, we have "!syscalls:sys_enter_renameat" and that is

		 * useful for "renameat2".

 It'll get at least the "!raw_syscalls:unaugmented"

	/*

	 * Now lets do a second pass looking for enabled syscalls without

	 * an augmenter that have a signature that is a superset of another

	 * syscall with an augmenter so that we can auto-reuse it.

	 *

	 * I.e. if we have an augmenter for the "open" syscall that has

	 * this signature:

	 *

	 *   int open(const char *pathname, int flags, mode_t mode);

	 *

	 * I.e. that will collect just the first string argument, then we

	 * can reuse it for the 'creat' syscall, that has this signature:

	 *

	 *   int creat(const char *pathname, mode_t mode);

	 *

	 * and for:

	 *

	 *   int stat(const char *pathname, struct stat *statbuf);

	 *   int lstat(const char *pathname, struct stat *statbuf);

	 *

	 * Because the 'open' augmenter will collect the first arg as a string,

	 * and leave alone all the other args, which already helps with

	 * beautifying 'stat' and 'lstat''s pathname arg.

	 *

	 * Then, in time, when 'stat' gets an augmenter that collects both

	 * first and second arg (this one on the raw_syscalls:sys_exit prog

	 * array tail call, then that one will be used.

		/*

		 * For now we're just reusing the sys_enter prog, and if it

		 * already has an augmenter, we don't need to find one.

		/*

		 * Look at all the other syscalls for one that has a signature

		 * that is close enough that we can share:

		/*

		 * Update the BPF_MAP_TYPE_PROG_SHARED for raw_syscalls:sys_enter

		 * with the fd for the program we're reusing:

 HAVE_LIBBPF_SUPPORT

 HAVE_LIBBPF_SUPPORT

	/*

	 * Better not use !target__has_task() here because we need to cover the

	 * case where no threads were specified in the command line, but a

	 * workload was, and in that case we will fill in the thread_map when

	 * we fork the workload in evlist__prepare_workload.

 Is there some thing to flush.. */

				/*

				 * Bail out, can't find the name of the argument that is being

				 * used in the filter, let it try to set this filter, will fail later.

	/*

	 * If a global cgroup was set, apply it to all the events without an

	 * explicit cgroup. I.e.:

	 *

	 * 	trace -G A -e sched:*switch

	 *

	 * Will set all raw_syscalls:sys_{enter,exit}, pgfault, vfs_getname, etc

	 * _and_ sched:sched_switch to the 'A' cgroup, while:

	 *

	 * trace -e sched:*switch -G A

	 *

	 * will only set the sched:sched_switch event to the 'A' cgroup, all the

	 * other events (raw_syscalls:sys_{enter,exit}, etc are left "without"

	 * a cgroup (on the root cgroup, sys wide, etc).

	 *

	 * Multiple cgroups:

	 *

	 * trace -G A -e sched:*switch -G B

	 *

	 * the syscall ones go to the 'A' cgroup, the sched:sched_switch goes

	 * to the 'B' cgroup.

	 *

	 * evlist__set_default_cgroup() grabs a reference of the passed cgroup

	 * only for the evsels still without a cgroup, i.e. evsel->cgroup == NULL.

	/*

	 * If the "close" syscall is not traced, then we will not have the

	 * opportunity to, in syscall_arg__scnprintf_close_fd() invalidate the

	 * fd->pathname table and were ending up showing the last value set by

	 * syscalls opening a pathname and associating it with a descriptor or

	 * reading it from /proc/pid/fd/ in cases where that doesn't make

	 * sense.

	 *

	 *  So just disable this beautifier (SCA_FD, SCA_FDAT) when 'close' is

	 *  not in use.

	/*

	 * Now that we already used evsel->core.attr to ask the kernel to setup the

	 * events, lets reuse evsel->core.attr.sample_max_stack as the limit in

	 * trace__resolve_callchain(), allowing per-event max-stack settings

	 * to override an explicitly set --max-stack global setting.

 add tid to output */

 older kernels have syscalls tp versus raw_syscalls */

	/*

	 * FIXME: introduce a intarray class, plain parse csv and create a

	 * { int nr, int entries[] } struct...

/*

 * XXX: Hackish, just splitting the combined -e+--event (syscalls

 * (raw_syscalls:{sys_{enter,exit}} + events (tracepoints, HW, SW, etc) to use

 * existing facilities unchanged (trace->ev_qualifier + parse_options()).

 *

 * It'd be better to introduce a parse_options() variant that would return a

 * list with the terms it didn't match to an event...

	/*

	 * Parsing .perfconfig may entail creating a BPF event, that may need

	 * to create BPF maps, so bump RLIM_MEMLOCK as the default 64K setting

	 * is too small. This affects just this process, not touching the

	 * global setting. If it fails we'll get something in 'perf trace -v'

	 * to help diagnose the problem.

	/*

	 * Here we already passed thru trace__parse_events_option() and it has

	 * already figured out if -e syscall_name, if not but if --event

	 * foo:bar was used, the user is interested _just_ in those, say,

	 * tracepoint events, not in the strace-like syscall-name-based mode.

	 *

	 * This is important because we need to check if strace-like mode is

	 * needed to decided if we should filter out the eBPF

	 * __augmented_syscalls__ code, if it is in the mix, say, via

	 * .perfconfig trace.add_events, and filter those out.

 Was --events used? */) {

	/*

	 * Now that we have --verbose figured out, lets see if we need to parse

	 * events from .perfconfig, so that if those events fail parsing, say some

	 * BPF program fails, then we'll be able to use --verbose to see what went

	 * wrong in more detail.

		/*

		 * If we have _just_ the augmenter event but don't have a

		 * explicit --syscalls, then assume we want all strace-like

		 * syscalls:

		/*

		 * So, if we have a syscall augmenter, but trace_syscalls, aka

		 * strace-like syscall tracing is not set, then we need to trow

		 * away the augmenter, i.e. all the events that were created

		 * from that BPF object file.

		 *

		 * This is more to fix the current .perfconfig trace.add_events

		 * style of setting up the strace-like eBPF based syscall point

		 * payload augmenter.

		 *

		 * All this complexity will be avoided by adding an alternative

		 * to trace.add_events in the form of

		 * trace.bpf_augmented_syscalls, that will be only parsed if we

		 * need it.

		 *

		 * .perfconfig trace.add_events is still useful if we want, for

		 * instance, have msr_write.msr in some .perfconfig profile based

		 * 'perf trace --config determinism.profile' mode, where for some

		 * particular goal/workload type we want a set of events and

		 * output mode (with timings, etc) instead of having to add

		 * all via the command line.

		 *

		 * Also --config to specify an alternate .perfconfig file needs

		 * to be implemented.

	/*

	 * If we are augmenting syscalls, then combine what we put in the

	 * __augmented_syscalls__ BPF map with what is in the

	 * syscalls:sys_exit_FOO tracepoints, i.e. just like we do without BPF,

	 * combining raw_syscalls:sys_enter with raw_syscalls:sys_exit.

	 *

	 * We'll switch to look at two BPF maps, one for sys_enter and the

	 * other for sys_exit when we start augmenting the sys_exit paths with

	 * buffers that are being copied from kernel to userspace, think 'read'

	 * syscall.

				/*

				 * Augmented is __augmented_syscalls__ BPF_OUTPUT event

				 * Above we made sure we can get from the payload the tp fields

				 * that we get from syscalls:sys_enter tracefs format file.

				/*

				 * Now we do the same for the *syscalls:sys_enter event so that

				 * if we handle it directly, i.e. if the BPF prog returns 0 so

				 * as not to filter it, then we'll handle it just like we would

				 * for the BPF_OUTPUT one:

				/*

				 * For now with BPF raw_augmented we hook into

				 * raw_syscalls:sys_enter and there we get all

				 * 6 syscall args plus the tracepoint common

				 * fields and the syscall_nr (another long).

				 * So we check if that is the case and if so

				 * don't look after the sc->args_size but

				 * always after the full raw_syscalls:sys_enter

				 * payload, which is fixed.

				 *

				 * We'll revisit this later to pass

				 * s->args_size to the BPF augmenter (now

				 * tools/perf/examples/bpf/augmented_raw_syscalls.c,

				 * so that it copies only what we need for each

				 * syscall, like what happens when we use

				 * syscalls:sys_enter_NAME, so that we reduce

				 * the kernel/userspace traffic to just what is

				 * needed for each syscall.

 Using just --errno-summary will trigger --summary */

 summary_only implies summary option, but don't overwrite summary if set */

 SPDX-License-Identifier: GPL-2.0

 max number of arguments */

	/*

	 * Save the allocated event name strings.

	/*

	 * The load and store operations are required, use the event

	 * PERF_MEM_EVENTS__LOAD_STORE if it is supported.

 Only enable memory event */

	/*

	 * there is no weight (cost) associated with stores, so don't print

	 * the column

 display number of samples */

 str may be NULL in case no arg is passed to -t */

 because str is read-only */

 reset mode */

		/*

		 * default to both load an store sampling

 SPDX-License-Identifier: GPL-2.0

 for struct evsel_str_handler

 based on kernel/lockdep.c */

 used for sorting */

	/*

	 * FIXME: evsel__intval() returns u64,

	 * so address of lockdep_map should be treated as 64bit.

	 * Is there more better solution?

 address of lockdep_map, used as ID */

 for strcpy(), we cannot use const */

 these times are in nano sec. */

 flag of blacklist */

/*

 * States of lock_seq_stat

 *

 * UNINITIALIZED is required for detecting first event of acquire.

 * As the nature of lock events, there is no guarantee

 * that the first event for the locks are acquire,

 * it can be acquired, contended or release.

 initial state */

/*

 * MAX_LOCK_DEPTH

 * Imported from include/linux/sched.h.

 * Should this be synchronized?

/*

 * struct lock_seq_stat:

 * Place to put on state of one lock sequence

 * 1) acquire -> acquired -> release

 * 2) acquire -> contended -> acquired -> release

 * 3) acquire (with read or try) -> release

 * 4) Are there other patterns?

 build simple key function one is bigger than two */

	/*

	 * name: the value for specify by user

	 * this should be simpler than raw name of member

	 * e.g. nr_acquired -> acquired, wait_time_total -> wait_total

 place to store sorted data */

 extra comparisons much complicated should be here */

 returns left most element of result, and erase it */

 broken lock sequence, discard it */

 orphan event, do nothing */

 broken lock sequence, discard it */

 orphan event, do nothing */

 broken lock sequence, discard it */

 broken lock sequence, discard it */

 lock oriented handlers */

 TODO: handlers for CPU oriented, thread oriented */

 Output for debug, this have to be removed */

 TODO: various way to print, coloring, nano or milli sec */

 output raw name */

 cut off name for saving output style */

 CONFIG_LOCKDEP */

 CONFIG_LOCKDEP, CONFIG_LOCK_STAT */

 CONFIG_LOCKDEP, CONFIG_LOCK_STAT */

 CONFIG_LOCKDEP */

 used for info subcommand */

 factor of 2 is for -e in front of each tracepoint */

 TODO: type */

 Aliased to 'perf script' */

 recycling report_lock_ops */

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

 for backward compatibility */

 filters for controlling start and stop of time of analysis */

/*

 * Find first non-memory allocation function from callchain.

 * The allocation functions are in the 'alloc_func_list'.

 found */

 see include/trace/events/mmflags.h */

	/*

	 * This is to find the current page (with correct gfp flags and

	 * migrate type) at free event.

 skip sample based on time? */

 slab allocator */

 page allocator */

 slab sort keys */

 page sort keys */

 for internal use to find free'd page */

 for internal use to find free'd page */

 for -g */

 SPDX-License-Identifier: GPL-2.0

/*

 * This is rewrite of original c2c tool introduced in here:

 *   http://lwn.net/Articles/588866/

 *

 * The original tool was changed to fit in current perf state.

 *

 * Original authors:

 *   Don Zickus <dzickus@redhat.com>

 *   Dick Fowles <fowles@inreach.com>

 *   Joe Mario <jmario@redhat.com>

	/*

	 * must be at the end,

	 * because of its callchain dynamic entry

 Shared cache line stats */

	/*

	 * The mi object is released in hists__add_entry_ops,

	 * if it gets sorted out into existing data, so we need

	 * to take the copy now.

		/*

		 * There's already been warning about missing

		 * sample's cpu value. Let's account all to

		 * node 0 in this case, without any further

		 * warning.

		 *

		 * Doing node stats only for single callchain data.

 Use the last line from sort_entry if not defined. */

 copy sort keys to output fields */

	/*

	 * We dont need other sorting keys other than those

	 * we already specified. It also really slows down

	 * the processing a lot with big number of output

	 * fields, so switching this off for c2c.

 and then copy output fields to sort keys */

	/*

	 * Initialize only with sort fields, we need to resort

	 * later anyway, and that's where we add output fields

	 * as well.

 Overload number of header lines.*/

 It's a valid entry if contains stores */

 empty node, skip */

 Display compact version first. */

 reset abort key so that it can get Ctrl-C as a key */

 reset abort key so that it can get Ctrl-C as a key */

 HAVE_SLANG_SUPPORT */

 Fix the zero line for dcacheline column. */

 Fix the zero line for offset column. */

	/*

	 * --no-call-graph

 Only enable memory event */

 No pipe support at the moment. */

 max number of arguments */

		/*

		 * The load and store operations are required, use the event

		 * PERF_MEM_EVENTS__LOAD_STORE if it is supported.

 SPDX-License-Identifier: GPL-2.0

/*

 * builtin-record.c

 *

 * Builtin record command: Record the profile of a workload

 * (or a CPU, or a PID) into the perf.data output file - for

 * later analysis via perf report.

 = 0: unlimited */

		/*

		 * md->refcount is incremented in record__aio_pushfn() for

		 * every aio write request started in record__aio_push() so

		 * decrement it because the request is now complete.

		/*

		 * aio write request may require restart with the

		 * reminder if the kernel didn't write whole

		 * chunk at once.

 1ms */

				/*

				 * Started aio write is not complete yet

				 * so it has to be waited before the

				 * next allocation.

	/*

	 * map->core.base data pointed by buf is copied into free map->aio.data[] buffer

	 * to release space in the kernel buffer as fast as possible, calling

	 * perf_mmap__consume() from perf_mmap__push() function.

	 *

	 * That lets the kernel to proceed with storing more profiling data into

	 * the kernel buffer earlier than other per-cpu kernel buffers are handled.

	 *

	 * Coping can be done in two steps in case the chunk of profiling data

	 * crosses the upper bound of the kernel buffer. In this case we first move

	 * part of data from map->start till the upper bound and then the reminder

	 * from the beginning of the kernel buffer till the end of the data chunk.

		/*

		 * Increment map->refcount to guard map->aio.data[] buffer

		 * from premature deallocation because map object can be

		 * released earlier than aio write request started on

		 * map->aio.data[] buffer is complete.

		 *

		 * perf_mmap__put() is done at record__aio_complete()

		 * after started aio request completion or at record__aio_push()

		 * if the request failed to start.

	/*

	 * Call record__aio_sync() to wait till map->aio.data[] buffer

	 * becomes available after previous aio write operation.

 ret > 0 - no data, ret < 0 - error */

		/*

		 * Decrement map->refcount incremented in record__aio_pushfn()

		 * back if record__aio_write() operation failed to start, otherwise

		 * map->refcount is decremented in record__aio_complete() after

		 * aio write operation finishes successfully.

 HAVE_AIO_SUPPORT */

	/*

	 * It is possible for this signal handler to run after done is checked

	 * in the main loop, but before the perf counter fds are polled. If this

	 * happens, the poll() will continue to wait even though done is set,

	 * and will only break out if either another signal is received, or the

	 * counters are ready for read. To ensure the poll() doesn't sleep when

	 * done is set, use an eventfd (done_fd) to wake up the poll().

 HAVE_EVENTFD_SUPPORT

 event.auxtrace.size includes padding, see __auxtrace_mmap__read() */

 Nothing to do if text poke is already configured */

 Text poke must be collected on all CPUs */

	/*

	 * For initial_delay, system wide or a hybrid system, we need to add a

	 * dummy event so that we can track PERF_RECORD_MMAP to cover the delay

	 * of waiting or event synthesis.

 Set up dummy event. */

		/*

		 * Enable the dummy event when the process is forked for

		 * initial_delay, immediately for system wide.

	/*

	 * During this process, it'll load kernel map and replace the

	 * dso->long_name to a real pathname it found.  In this case

	 * we prefer the vmlinux path like

	 *   /lib/modules/3.16.4/build/vmlinux

	 *

	 * rather than build-id path (in debug directory).

	 *   $HOME/.debug/.build-id/f0/6e17aa50adf4d00b88925e03775de107611551

	/*

	 * If --buildid-all is given, it marks all DSO regardless of hits,

	 * so no need to process samples. But if timestamp_boundary is enabled,

	 * it still needs to walk on all samples to get the timestamps of

	 * first/last samples.

	/*

	 *As for guest kernel when processing subcommand record&report,

	 *we arrange module mmap prior to guest kernel mmap and trigger

	 *a preload dso because default guest module symbols are loaded

	 *from guest kallsyms instead of /lib/modules/XXX/XXX. This

	 *method is used to avoid symbol missing when the first addr is

	 *in module instead of in guest kernel.

	/*

	 * We use _stext for guest kernel because guest kernel's /proc/kallsyms

	 * have no _text sometimes.

	/*

	 * Mark the round finished in case we wrote

	 * at least one event.

 Same Size:      "2015122520103046"*/

 Output tracking events */

		/*

		 * In 'perf record --switch-output' without -a,

		 * record__synthesize() in record__switch_output() won't

		 * generate tracking events because there's no thread_map

		 * in evlist. Which causes newly created perf.data doesn't

		 * contain map and comm information.

		 * Create a fake thread_map and directly call

		 * perf_event__synthesize_thread_map() for those events.

/*

 * evlist__prepare_workload will send a SIGUSR1

 * if the fork fails, since we asked by setting its

 * want_signal to true.

 Synthesize id_index before auxtrace_info */

		/*

		 * We get here if --switch-output-event populated the

		 * sb_evlist, so associate a callback that will send a SIGUSR2

		 * to the main thread.

 HAVE_EVENTFD_SUPPORT

	/*

	 * If we have just single event and are sending data

	 * through pipe, we need to force the ids allocation,

	 * because we synthesize event name through the pipe

	 * and need the id for that.

	/*

	 * Normally perf_session__new would do this, but it doesn't have the

	 * evlist.

	/*

	 * When perf is starting the traced process, all the events

	 * (apart from group members) have enable_on_exec=1 set,

	 * so don't spoil it by prematurely enabling them.

	/*

	 * Let the child rip

		/*

		 * Some H/W events are generated before COMM event

		 * which is emitted during exec(), so perf script

		 * cannot see a correct process name for those events.

		 * Synthesize COMM event to prevent it.

		/*

		 * Synthesize NAMESPACES event for the command specified.

		/*

		 * rec->evlist->bkw_mmap_state is possible to be

		 * BKW_MMAP_EMPTY here: when done == true and

		 * hits != rec->samples in previous round.

		 *

		 * evlist__toggle_bkw_mmap ensure we never

		 * convert BKW_MMAP_EMPTY to BKW_MMAP_DATA_PENDING.

			/*

			 * If switch_output_trigger is hit, the data in

			 * overwritable ring buffer should have been collected,

			 * so bkw_mmap_state should be set to BKW_MMAP_EMPTY.

			 *

			 * If SIGUSR2 raise after or during record__mmap_read_all(),

			 * record__mmap_read_all() didn't collect data from

			 * overwritable ring buffer. Read again.

			/*

			 * Reenable events in overwrite ring buffer after

			 * record__mmap_read_all(): we should have collected

			 * data from it.

 re-arm the alarm */

			/*

			 * Propagate error, only if there's any. Ignore positive

			 * number of returned events and interrupt error.

		/*

		 * When perf is starting the traced process, at the end events

		 * die with the process and we wait for that. Thus no need to

		 * disable events in this case.

 this will be recalculated during process_buildids() */

 --no-call-graph */

 Enable data address sampling for DWARF unwind. */

	/*

	 * If we're using --switch-output-events, then we imply its 

	 * --switch-output=signal, as we'll send a SIGUSR2 from the side band

	 *  thread to its parent.

	/*

	 * We already have the kernel maps, put in place via perf_session__create_kernel_maps()

	 * no need to add them twice.

	/*

	 * We already have the kernel maps, put in place via perf_session__create_kernel_maps()

	 * no need to add them twice.

/*

 * XXX Ideally would be local to cmd_record() and passed to a record__new

 * because we need to have access to it in record__exit, that is called

 * after cmd_record() exits, but since record_options need to be accessible to

 * builtin-script, leave it here.

 *

 * At least we don't ouch it in all the other functions here directly.

 *

 * Just say no to tons of global variables, sigh.

/*

 * XXX Will stay a global variable till we fix builtin-script.c to stop messing

 * with it and switch to use the library functions in perf_evlist that came

 * from builtin-record.c, i.e. use record_opts,

 * evlist__prepare_workload, etc instead of fork+exec'in 'perf record',

 * using pipes, etc.

 Make system wide (-a) the default target. */

 Enable mmap build id synthesizing. */

 Enable perf_event_attr::build_id bit. */

 Disable build id cache. */

	/*

	 * Allow aliases to facilitate the lookup of symbols for address

	 * filters. Refer to auxtrace_parse_filters().

		/*

		 * In 'perf record --switch-output', disable buildid

		 * generation by default to reduce data file switching

		 * overhead. Still generate buildid if they are required

		 * explicitly using

		 *

		 *  perf record --switch-output --no-no-buildid \

		 *              --no-no-buildid-cache

		 *

		 * Following code equals to:

		 *

		 * if ((rec->no_buildid || !rec->no_buildid_set) &&

		 *     (rec->no_buildid_cache || !rec->no_buildid_cache_set))

		 *         disable_buildid_cache();

 Enable ignoring missing threads when -u/-p option is defined. */

	/*

	 * We take all buildids when the file contains

	 * AUX area tracing data because we do not decode the

	 * trace because it would take too long.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * builtin-stat.c

 *

 * Builtin stat command: Give a precise performance counters summary

 * overview about any workload, CPU or specific PID.

 *

 * Sample output:



   $ perf stat ./hackbench 10



  Time: 0.118



  Performance counter stats for './hackbench 10':



       1708.761321 task-clock                #   11.037 CPUs utilized

            41,190 context-switches          #    0.024 M/sec

             6,735 CPU-migrations            #    0.004 M/sec

            17,318 page-faults               #    0.010 M/sec

     5,205,202,243 cycles                    #    3.046 GHz

     3,856,436,920 stalled-cycles-frontend   #   74.09% frontend cycles idle

     1,600,790,871 stalled-cycles-backend    #   30.75% backend  cycles idle

     2,603,501,247 instructions              #    0.50  insns per cycle

                                             #    1.48  stalled cycles per insn

       484,357,498 branches                  #  283.455 M/sec

         6,388,934 branch-misses             #    1.32% of all branches



        0.154822978  seconds time elapsed



 *

 * Copyright (C) 2008-2011, Red Hat Inc, Ingo Molnar <mingo@redhat.com>

 *

 * Improvements and fixes by:

 *

 *   Arjan van de Ven <arjan@linux.intel.com>

 *   Yanmin Zhang <yanmin.zhang@intel.com>

 *   Wu Fengguang <fengguang.wu@intel.com>

 *   Mike Galbraith <efault@gmx.de>

 *   Paul Mackerras <paulus@samba.org>

 *   Jaswinder Singh Rajput <jaswinder@kernel.org>

 Default events used for perf stat -T */

 More limited version when the CPU does not have all events. */

 strlen("unit") */

 Check that leader matches cpus with each member. */

 If there's mismatch disable the group and warn user. */

/*

 * Read out the results of a single counter:

 * do not aggregate counts across CPUs in system-wide mode

		/*

		 * The leader's group read loads data into its group members

		 * (via evsel__read_counter()) and sets their count->loaded.

	/*

	 * We need to enable counters only if:

	 * - we don't have tracee (attaching to task or cpu)

	 * - we have initial delay configured

	/*

	 * If we don't have tracee (attaching to task or cpu), counters may

	 * still be running. To get accurate group ratios, we must stop groups

	 * from counting before reading their constituent counters.

/*

 * evlist__prepare_workload will send a SIGUSR1

 * if the fork fails, since we asked by setting its

 * want_signal to true.

 poll timeout or EINTR */

 fd revent */

	/*

	 * PPC returns ENXIO for HW counters until 2.6.37

	 * (behavior changed with commit b0a873e).

		/*

		 * errored is a sticky flag that means one of the counter's

		 * cpu event had a problem and needs to be reexamined.

		/*

		 * For global --per-thread case, skip current

		 * error thread.

		/*

		 * bperf calls evsel__open_per_cpu() in bperf__load(), so

		 * no need to call it again here.

				/*

				 * Weak group failed. We cannot just undo this here

				 * because earlier CPUs might be in group mode, and the kernel

				 * doesn't support mixing group and non group reads. Defer

				 * it to later.

				 * Don't close here because we're in the wrong affinity.

		/*

		 * Now redo all the weak group after closing them,

		 * and also close errored counters.

 First close errored or weak retry */

 Now reopen weak */

	/*

	 * Enable counters and exec the command:

	/*

	 * Closing a group leader splits the group, and as we only disable

	 * group leaders, results in remaining events becoming enabled. To

	 * avoid arbitrary skew, we must read all counters before closing any

	 * group leaders.

	/*

	 * We need to keep evsel_list alive, because it's processed

	 * later the evsel_list will be closed after.

 Do not print anything if we record to the pipe. */

	/*

	 * render child_pid harmless

	 * won't send SIGTERM to a random

	 * process in case of race condition

	 * and fast PID recycling

	/*

	 * avoid race condition with SIGCHLD handler

	 * in skip_signal() which is modifying child_pid

	 * goal is to avoid send SIGTERM to a random

	 * process

	/*

	 * The evsel_list->cpus is the base we operate on,

	 * taking the highest cpu number to be the size of

	 * the aggregation translate cpumap.

		/*

		 * die_id is relative to socket, so start

		 * with the socket ID and then add die to

		 * make a unique ID.

		/*

		 * core_id is relative to socket and die,

		 * we need a global id. So we set

		 * socket, die id and core id

/*

 * Add default attributes, if there were no attributes specified or

 * if -d/--detailed, -d -d or -d -d -d is used:

/*

 * Detailed stats (-d), covering the L1 and last level data caches:

/*

 * Very detailed stats (-d -d), covering the instruction cache and the TLB caches:

/*

 * Very, very detailed stats (-d -d -d), adding prefetch events:

 Set attrs if no event is selected and !null_run: */

		/* Handle -T as -M transaction. Once platform specific metrics

		 * support has been added to the json files, all architectures

		 * will use this approach. To determine transaction support

		 * on an architecture test for such a metric name.

 Detailed events get appended to the event list: */

 Append detailed run extra attributes: */

 Append very detailed run extra attributes: */

 Append very, very detailed run extra attributes: */

	/*

	 * Make system wide (-a) the default target if

	 * no target was specified and one of following

	 * conditions is met:

	 *

	 *   - there's no workload specified

	 *   - there is workload specified but all requested

	 *     events are system wide events

 String-parsing callback-based options would segfault when negated */

	/*

	 * For record command the -o is already taken care of.

	/*

	 * let the spreadsheet do the pretty-printing

 User explicitly passed -B? */

 Nope, so disable big number formatting */

 User passed --no-big-num */

	/*

	 * Display user/system times only for single

	 * run and when there's specified tracee.

	/*

	 * no_aggr, cgroup are for system-wide only

	 * --per-thread is aggregated per thread, we dont mix it with cpu mode

	/*

	 * Initialize thread_map with comm names,

	 * so we could print it out on output.

	/*

	 * Set sample_type to PERF_SAMPLE_IDENTIFIER, which should be harmless

	 * while avoiding that older tools show confusing messages.

	 *

	 * However for pipe sessions we need to keep it zero,

	 * because script's perf_evsel__check_attr is triggered

	 * by attr->sample_type != 0, and we can't run it on

	 * stat sessions.

	/*

	 * We dont want to block the signals - that would cause

	 * child tasks to inherit that and Ctrl-C would not work.

	 * What we want is for Ctrl-C to work in the exec()-ed

	 * task, but being ignored by perf stat itself:

		/*

		 * We synthesize the kernel mmap record just so that older tools

		 * don't emit warnings about not being able to resolve symbols

		 * due to /proc/sys/kernel/kptr_restrict settings and instead provide

		 * a saner message about no samples being in the perf.data file.

		 *

		 * This also serves to suppress a warning about f_header.data.size == 0

		 * in header.c at the moment 'perf stat record' gets introduced, which

		 * is not really needed once we start adding the stat specific PERF_RECORD_

		 * records, but the need to suppress the kptr_restrict messages in older

		 * tools remain  -acme

 SPDX-License-Identifier: GPL-2.0-only

/*

 * builtin-top.c

 *

 * Builtin top command: Display a continuously updated profile of

 * any workload, CPU or specific PID.

 *

 * Copyright (C) 2008, Red Hat Inc, Ingo Molnar <mingo@redhat.com>

 *		 2011, Red Hat Inc, Arnaldo Carvalho de Melo <acme@redhat.com>

 *

 * Improvements and fixes by:

 *

 *   Arjan van de Ven <arjan@linux.intel.com>

 *   Yanmin Zhang <yanmin.zhang@intel.com>

 *   Wu Fengguang <fengguang.wu@intel.com>

 *   Mike Galbraith <efault@gmx.de>

 *   Paul Mackerras <paulus@samba.org>

	/*

	 * We can't annotate with just /proc/kallsyms

		/*

		 * This function is now called with he->hists->lock held.

		 * Release it before going to sleep.

		/*

		 * unlink existing entries so that they can be linked

		 * in a correct order in hists__match() below.

 Non-group events are considered as leader */

 zero counters of active symbol */

 Select 0 as the default event: */

	/* In order to read symbols from other namespaces perf to  needs to call

	 * setns(2).  This isn't permitted if the struct_fs has multiple users.

	 * unshare(2) the fs so that we may continue to setns into namespaces

	 * that we're observing.

	/*

	 * Initialize the uid_filter_str, in the future the TUI will allow

	 * Zooming in/out UIDs. For now just use whatever the user passed

	 * via --uid.

	/* In order to read symbols from other namespaces perf to  needs to call

	 * setns(2).  This isn't permitted if the struct_fs has multiple users.

	 * unshare(2) the fs so that we may continue to setns into namespaces

	 * that we're observing.

 trash return*/

		/*

		 * Either timeout expired or we got an EINTR due to SIGWINCH,

		 * refresh screen in both cases.

		/*

		 * As we do lazy loading of symtabs we only will know if the

		 * specified vmlinux file is invalid when we actually have a

		 * hit in kernel space and then try to load it. So if we get

		 * here and there are _no_ symbols in the DSO backing the

		 * kernel map, bail out.

		 *

		 * We may never get here, for instance, if we use -K/

		 * --hide-kernel-symbols, even if the user specifies an

		 * invalid --vmlinux ;-)

/*

 * Check per-event overwrite term.

 * perf top should support consistent term for all events.

 * - All events don't have per-event term

 *   E.g. "cpu/cpu-cycles/,cpu/instructions/"

 *   Nothing change, return 0.

 * - All events have same per-event term

 *   E.g. "cpu/cpu-cycles,no-overwrite/,cpu/instructions,no-overwrite/

 *   Using the per-event setting to replace the opts->overwrite if

 *   they are different, then return 0.

 * - Events have different per-event term

 *   E.g. "cpu/cpu-cycles,overwrite/,cpu/instructions,no-overwrite/"

 *   Return -1

 * - Some of the event set per-event term, but some not.

 *   E.g. "cpu/cpu-cycles/,cpu/instructions,no-overwrite/"

 *   Return -1

 no term for current and previous event (likely) */

 has term for both current and previous event, compare */

 no term for current event but has term for previous one */

 has term for current event */

 if it's first event, set overwrite */

 only fall back when first event fails */

			/*

			 * Specially handle overwrite fall back.

			 * Because perf top is the only tool which has

			 * overwrite mode by default, support

			 * both overwrite and non-overwrite mode, and

			 * require consistent mode for all events.

			 *

			 * May move it to generic code with more tools

			 * have similar attribute.

/*

 * Allow only 'top->delay_secs' seconds behind samples.

		/*

		 * TODO: we don't process guest user from host side

		 * except simple counting.

	/*

	 * When perf is starting the traced process, all the events (apart from

	 * group members) have enable_on_exec=1 set, so don't spoil it by

	 * prematurely enabling them.

	 *

	 * XXX 'top' still doesn't start workloads like record, trace, but should,

	 * so leave the check here.

 Wait for a minimal set of events before starting the snapshot */

	/*

	 * --no-call-graph

 4 KHz */

			/*

			 * FIXME: This will lose PERF_RECORD_MMAP and other metadata

			 * when we pause, fix that and reenable. Probably using a

			 * separate evlist with a dummy event, i.e. a non-overwrite

			 * ring buffer just for metadata events, while PERF_RECORD_SAMPLE

			 * stays in overwrite mode. -acme

	/*

	 * Since the per arch annotation init routine may need the cpuid, read

	 * it here, since we are not getting this from the perf.data header.

		/*

		 * Some arches do not provide a get_cpuid(), so just use pr_debug, otherwise

		 * warn the user explicitly.

 disable incompatible options */

 display thread wants entries to be collapsed in a different tree */

 SPDX-License-Identifier: GPL-2.0

 Set process name */

 task state bitmask, copied from include/linux/sched.h */

 in tsk->exit_state */

 in tsk->state again */

 PERF_RECORD_FORK event, not sched_process_fork tracepoint */

/*

 * Track the current task - that way we can know whether there's any

 * weird events, such as a task being switched away that is not current.

 options for timehist command */

 per thread run time data */

 time of previous sched in/out event */

 run time */

 time between CPU access by sleep (off cpu) */

 time between CPU access by iowait (off cpu) */

 time between CPU access by preempt (off cpu) */

 time between wakeup and sched-in */

 time of wakeup */

 per event run time data */

 time this event was last seen per cpu */

 highest cpu slot allocated */

 per cpu idle time data */

 track idle times per cpu */

	/*

	 * optimize an existing RUN event by merging this one

	 * to it:

	/*

	 * every task starts in sleeping state - this gets ignored

	 * if there's no wakeup pointing to this sleep state:

	/*

	 * rusage statistics done by the parent, these are less

	 * accurate than the sched->sum_exec_runtime based statistics:

/*

 * handle runtime stats saved per thread

		/*

		 * Take came in we have not heard about yet,

		 * add in an initial atom in runnable state:

	/*

	 * As we do not guarantee the wakeup event happens when

	 * task is out of run queue, also may happen when task is

	 * on run queue and wakeup only change ->state to TASK_RUNNING,

	 * then we should not set the ->wake_up_time when wake up a

	 * task which is on run queue.

	 *

	 * You WILL be missing events if you've recorded only

	 * one CPU, or are only looking at only one, so don't

	 * skip in this case.

	/*

	 * Only need to worry about migration when profiling one CPU.

	/*

	 * Ignore idle threads:

			/*

			 * Don't allocate a letter-number for swapper:0

			 * as a shortname. Instead, we use '.' for it.

		/*

		 * Are we trying to switch away a PID that is

		 * not current?

 run the fork event through the perf machinery */

 and then run additional processing needed for this command */

/*

 * scheduling times are printed as msec.usec

/*

 * returns runtime data for event, allocating memory for it the

 * first time it is used.

/*

 * save last time event was seen per cpu

 returns last time this event was seen on the given cpu */

	/*

	 * units row

	/*

	 * separator

 'I' for idle */

 flag idle times with 'i'; others are sched events */

/*

 * Explanation of delta-time stats:

 *

 *            t = time of current schedule out event

 *        tprev = time of previous sched out event

 *                also time of schedule-in event for current task

 *    last_time = time of last sched change event for current task

 *                (i.e, time process was last scheduled out)

 * ready_to_run = time of wakeup for current task

 *

 * -----|------------|------------|------------|------

 *    last         ready        tprev          t

 *    time         to run

 *

 *      |-------- dt_wait --------|

 *                   |- dt_delay -|-- dt_run --|

 *

 *   dt_run = run time of current task

 *  dt_wait = time between last schedule out event for task and tprev

 *            represents time spent off the cpu

 * dt_delay = time between wakeup and schedule-in of task

 pid 0 == swapper == idle task */

 want main thread for process - has maps */

/*

 * Track idle stats per cpu by maintaining a local thread

 * struct for the idle task on each cpu.

 allocate the actual thread struct if needed */

	/*

	 * expand/allocate array of pointers to local thread

	 * structs if needed

 allocate a new thread struct if needed */

 there were samples with tid 0 but non-zero pid */

 copy task callchain when entering to idle */

 show wakeup unless both awakee and awaker are filtered */

 dt spacer */

 want pid of awakened task not pid in sample */

 show wakeups if requested */

 dt spacer */

 want pid of migrated task not pid in sample */

 show migrations if requested */

	/*

	 * If start time given:

	 * - sample time is under window user cares about - skip sample

	 * - tprev is under window user cares about  - reset to start of window

	/*

	 * If end time given:

	 * - previous sched event is out of window - we are done

	 * - sample time is beyond window user cares about - reset it

	 *   to close out stats for time window interest

 add current idle time as last thread's runtime */

			/*

			 * remove delta time of last thread as it's not updated

			 * and otherwise it will show an invalid value next

			 * time.  we only care total run time and run stat.

 time of this sched_switch event becomes last time task seen */

 last state is used to determine where to account wait time */

 sched out event for task so reset ready to run time */

 print_sched_time returns 2nd arg + 4 */

 CPU idle stats not tracked when samples were skipped */

	/*

	 * event handlers for timehist option

 prefer sched_waking if it is captured */

 setup per-evsel handlers */

 sched_switch event at a minimum needs to exist */

 pre-allocate struct for per-CPU idle stats */

 summary_only implies summary option, but don't overwrite summary if set */

	/*

	 * Select "sched:sched_stat_wait" event to check

	 * whether schedstat tracepoints are exposed.

	/*

	 * The tracepoints trace_sched_stat_{wait, sleep, iowait}

	 * are not exposed to user if CONFIG_SCHEDSTATS is not set,

	 * to prevent "perf sched record" execution failure, determine

	 * whether to record schedstat events according to actual situation.

	/*

	 * +2 for either "-e", "sched:sched_wakeup" or

	 * "-e", "sched:sched_waking"

	/*

	 * Aliased to 'perf script' for now:

 SPDX-License-Identifier: GPL-2.0

 default set to maintain compatibility with current format */

 For metric output */

 user did not ask for it explicitly so remove from the default list */

/*

 * verify all user requested events exist and the samples

 * have the expected data

		/*

		 * even if fields is set to 0 (ie., show nothing) event must

		 * exist if user explicitly includes it on the command line

	/*

	 * set default for tracepoints to print symbols only

	 * if callchains are present

	/*

	 * Block overlaps between kernel and user.

	 * This can happen due to ring filtering

	 * On Intel CPUs the entry into the kernel is filtered,

	 * but the exit is not. Let the caller patch it up.

 Load maps to ensure dso->is_64_bit has been updated */

 Avoid redundant printing */

 Handle first from jump, of which we don't know the entry. */

 Print all blocks */

 Patch up missing kernel transfers due to ring filters */

	/*

	 * Hit the branch? In this case we are already done, and the target

	 * has not been executed yet.

	/*

	 * Print final block upto sample

	 *

	 * Due to pipeline delays the LBRs might be missing a branch

	 * or two, which can result in very large or negative blocks

	 * between final branch and sample. When this happens just

	 * continue walking after the last TO until we hit a branch.

 Missing jump. Scan 128 bytes for the next branch */

 Print at least last IP if basic block did not work */

			/*

			 * Hit a missing branch. Just stop.

	/*

	 * The 'return' has already been popped off the stack so the depth has

	 * to be adjusted to match the 'call'.

	/*

	 * Try to keep the output length from changing frequently so that the

	 * output lines up more nicely.

 print branch_from information */

 print branch_to information */

 Set thread to NULL to indicate addr_al and al are not initialized */

	/*

	 * Check if we need to enable callchains based

	 * on events sample_type.

 Enable fields for callchain entries */

 Print before 'exit' deletes anything */

		/*

		 * Already setup? I.e. we may be called twice in cases like

		 * Intel PT, one for the intel_pt// and dummy events, then

		 * for the evsels synthesized from the auxtrace info.

		 *

		 * Ses perf_script__process_auxtrace_info.

 override event processing functions */

 Find script file relative to current directory or exec path */

	/* first word can state for which event type the user is specifying

	 * the fields. If no type exists, the specified fields apply to all

	 * event types found in the file minus the invalid fields for a type.

 Don't override defaults for +- */

 Don't override defaults for +- */

			/* add user option to all events types for

			 * which it is valid

/*

 * Some scripts specify the required events in their "xxx-record" file,

 * this function will check if the events in perf.data match those

 * mentioned in the "xxx-record".

 *

 * Fixme: All existing "xxx-record" are all in good formats "-e event ",

 * which is covered well now. And new parsing code should be added to

 * cover the future complex formats like event groups etc.

/*

 * Return -1 if none is found, otherwise the actual scripts number.

 *

 * Currently the only user of this function is the script browser, which

 * will list all statically runnable scripts, select one, execute it and

 * show the output in a perf browser.

 Skip those real time scripts: xxxtop.p[yl] */

		/*

		 * Enable guest sample processing.

 make sure PERF_EXEC_PATH is set for scripts */

 Assume pipe_mode indicates native_arch */

 input_name */

 SPDX-License-Identifier: GPL-2.0

/*

 * Builtin evlist command: Show the list of event selectors present

 * in a perf.data file.

 only needed for pipe mode */

/*

 * builtin-buildid-list.c

 *

 * Builtin buildid-list command: list buildids in perf.data, in the running

 * kernel and in ELF files.

 *

 * Copyright (C) 2009, Red Hat Inc.

 * Copyright (C) 2009, Arnaldo Carvalho de Melo <acme@redhat.com>

	/*

	 * See if this is an ELF file first:

	/*

	 * We take all buildids when the file contains AUX area tracing data

	 * because we do not decode the trace because it would take too long.

	/*

	 * in pipe-mode, the only way to get the buildids is to parse

	 * the record stream. Buildids are stored as RECORD_HEADER_BUILD_ID

 SPDX-License-Identifier: GPL-2.0

/*

 * Session states:

 *

 *   OK       - session is up and running

 *   RECONFIG - session is pending for reconfiguration,

 *              new values are already loaded in session object

 *   KILL     - session is pending to be killed

 *

 * Session object life and its state is maintained by

 * following functions:

 *

 *  setup_server_config

 *    - reads config file and setup session objects

 *      with following states:

 *

 *      OK       - no change needed

 *      RECONFIG - session needs to be changed

 *                 (run variable changed)

 *      KILL     - session needs to be killed

 *                 (session is no longer in config file)

 *

 *  daemon__reconfig

 *    - scans session objects and does following actions

 *      for states:

 *

 *      OK       - skip

 *      RECONFIG - session is killed and re-run with new config

 *      KILL     - session is killed

 *

 *    - all sessions have OK state on the function exit

 New session is defined. */

 Trigger reconfig to start it. */

 Current session is defined, no action needed. */

			/*

			 * Either new or changed run value is defined,

			 * trigger reconfig for the session.

	/*

	 * Mark all sessions for kill, the server config

	 * will set following states, see explanation at

	 * enum daemon_session_state declaration.

	/*

	 * Take signal fd data as pure signal notification and check all

	 * the sessions state. The reason is that multiple signals can get

	 * coalesced in kernel and we can receive only single signal even

	 * if multiple SIGCHLD were generated.

 open the control file */

 open the ack file */

 write the command */

 wait for an ack */

 CMD_LIST */

 CMD_SIGNAL */

 CMD_PING */

 pid daemon  */

 base */

 output */

 lock */

 session up time */

 pid */

 name */

 base */

 session dir */

 session output */

 session control */

 session ack */

 session up time */

 If out is defined, then fd is closed via fclose. */

 No change. */

 Remove session. */

 Reconfig session. */

		/*

		 * We monitor config directory, check if our

		 * config file was changes.

 F_TLOCK

/*

 * Each daemon tries to create and lock BASE/lock file,

 * if it's successful we are sure we're the only daemon

 * running over the BASE.

 *

 * Once daemon is finished, file descriptor to lock file

 * is closed and lock is released.

 original process, exit normally */

 If in is defined, then fd is closed via fclose. */

 SPDX-License-Identifier: GPL-2.0

/*

 * builtin-inject.c

 *

 * Builtin inject command: Examine the live mode (stdin) event stream

 * and repipe it to stdout while optionally injecting additional

 * events into it.

 To get things like MAP_HUGETLB even on older libc headers */

	/*

	 * if jit marker, then inject jit mmaps and generate ELF images

		/* The vdso maps are always on the host and not the

		 * container.  Ensure that we don't use setns to look

		 * them up.

 mark it not to inject build-id */

	/*

	 * if jit marker, then inject jit mmaps and generate ELF images

 cannot use dso_id since it'd have invalid info */

 mark it not to inject build-id */

 Allow space in the header for new attributes */

		/*

		 * Keep all buildids when there is unprocessed AUX data because

		 * it is not known which ones the AUX trace hits.

		/*

		 * The AUX areas have been removed and replaced with

		 * synthesized hardware events, so clear the feature flag.

	/*

	 * Any (unrecognized) arguments left?

		/*

		 * Do not repipe header when input is a regular file

		 * since either it can rewrite the header at the end

		 * or write a new pipe header.

		/*

		 * to make sure the mmap records are ordered correctly

		 * and so that the correct especially due to jitted code

		 * mmaps. We cannot generate the buildid hit list and

		 * inject the jit mmaps at the same time for now.

		/*

		 * JIT MMAP injection injects all MMAP events in one go, so it

		 * does not obey finished_round semantics.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * builtin-probe.c

 *

 * Builtin probe command: Set up probe events by C expression

 *

 * Written by Masami Hiramatsu <mhiramat@redhat.com>

 Session management structure */

 Command short_name */

 Parse an event definition. Note that any error must die. */

 Parse a perf-probe command into event */

	/*

	 * The first argument after options can be an absolute path

	 * to an executable / library or kernel module.

	 *

	 * TODO: Support relative path, and $PATH, $LD_LIBRARY_PATH,

	 * short module name.

 Bind up rest arguments */

 Expand given path to absolute path, except for modulename */

 Command option callbacks */

 it shows definition */

 Skipped events have no event name */

 We use tev's name for showing new events */

 Save the last valid name */

 Note that it is possible to skip all events because of blacklist */

 Show how to use the event. */

 Get current event names */

	/*

	 * Only consider the user's kernel image path if given.

	/*

	 * Except for --list, --del and --add, other command doesn't depend

	 * nor change running kernel. So if user gives offline vmlinux,

	 * ignore its buildid.

 Ensure the last given target is used */

			/*

			 * When perf_add_probe_events() fails it calls

			 * cleanup_perf_probe_events(pevs, npevs), i.e.

			 * cleanup_perf_probe_events(params.events, params.nevents), which

			 * will call clear_perf_probe_event(), so set nevents to zero

			 * to avoid cleanup_params() to call clear_perf_probe_event() again

			 * on the same pevs.

 SPDX-License-Identifier: GPL-2.0

/*

 * builtin-annotate.c

 *

 * Builtin annotate command: Analyze the perf.data input file,

 * look up and read DSOs and symbol information and display

 * a histogram of results, along various sorting keys.

/*

 * Given one basic block:

 *

 *	from	to		branch_i

 *	* ----> *

 *		|

 *		| block

 *		v

 *		* ----> *

 *		from	to	branch_i+1

 *

 * where the horizontal are the branches and the vertical is the executed

 * block of instructions.

 *

 * We count, for each 'instruction', the number of blocks that covered it as

 * well as count the ratio each branch is taken.

 *

 * We can do this without knowing the actual instruction stream by keeping

 * track of the address ranges. We break down ranges such that there is no

 * overlap and iterate from the start until the end.

 *

 * @acme: once we parse the objdump output _before_ processing the samples,

 * we can easily fold the branch.cycles IPC bits in.

	/*

	 * Sanity; NULL isn't executable and the CPU cannot execute backwards

	/*

	 * First block in range is a branch target.

	/*

	 * Last block in rage is a branch.

		/*

		 * XXX filter against symbol

 We're only interested in a symbol named sym_hist_filter */

		/*

		 * FIXME: why isn't this done in the symbol_filter when loading

		 * the DSO?

	/*

	 * XXX filtered samples can still have branch entries pointing into our

	 * symbol and are missed.

 skip missing symbols */

 fall through */

 Don't sort callchain */

		/*

		 * Special case: if there's an argument left then assume that

		 * it's a symbol filter:

	/*

	 * Events of different processes may correspond to the same

	 * symbol, we do not care about the processes in annotate,

	 * set sort order to avoid repeated output.

	/*

	 * Set SORT_MODE__BRANCH so that annotate display IPC/Cycle

	 * if branch info is in perf data in TUI mode.

	/*

	 * Speed up the exit process, for large files this can

	 * take quite a while.

	 *

	 * XXX Enable this when using valgrind or if we ever

	 * librarize this command.

	 *

	 * Also experiment with obstacks to see how much speed

	 * up we'll get here.

	 *

	 * perf_session__delete(session);

 SPDX-License-Identifier: GPL-2.0

/*

 * Include definition of find_map() also used in util/vdso.c for

 * building perf.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * builtin-kallsyms.c

 *

 * Builtin command: Look for a symbol in the running kernel and its modules

 *

 * Copyright (C) 2017, Red Hat Inc, Arnaldo Carvalho de Melo <acme@redhat.com>

 SPDX-License-Identifier: GPL-2.0

/*

 * builtin-bench.c

 *

 * General benchmarking collections provided by perf

 *

 * Copyright (C) 2009, Hitoshi Mitake <mitake@dcl.info.waseda.ac.jp>

/*

 * Available benchmark collection list:

 *

 *  sched ... scheduler and IPC performance

 *  syscall ... System call performance

 *  mem   ... memory access performance

 *  numa  ... NUMA scheduling and MM performance

 *  futex ... Futex performance

 *  epoll ... Event poll performance

 pi-futexes */

 HAVE_EVENTFD_SUPPORT

 Iterate over all benchmark collections: */

 Iterate over all benchmarks within a collection: */

 Output/formatting style, exported to benchmark modules: */

 default number of times to repeat the run */

/*

 * Run a specific benchmark but first rename the running task's ->comm[]

 * to something meaningful:

	/*

	 * TODO:

	 *

	 * Preparing preset parameters for

	 * embedded, ordinary PC, HPC, etc...

	 * would be helpful.

 No collection specified. */

 No bench specified. */

 SPDX-License-Identifier: GPL-2.0

/*

 * builtin-report.c

 *

 * Builtin report command: Analyze the perf.data input file,

 * look up and read DSOs and symbol information and display

 * a histogram of results, along various sorting keys.

 perf_tip()

	/*

	 * (feat_id = HEADER_LAST_FEATURE) is the end marker which

	 * means all features are received, now we can force the

	 * group if needed.

		/*

		 * A non-synthesized event might not have a branch stack if

		 * branch stacks have been synthesized (using itrace options).

 For pipe mode, sample_type is not currently set */

 Silently ignore if callchain is missing */

 ??? handle more cases than just ANY? */

 fallback for people who don't install perf ;-) */

		/*

		 * Usually "ret" is the last pressed key, and we only

		 * care if the key notifies us to switch data file.

 Non-group events are considered as leader */

 Already listed. */

 Last one in the chain. */

	/*

	 * No locking needed while accessing machine->threads,

	 * because --tasks is single threaded command.

 Count all the threads. */

	/*

	 * Iterate every task down to the unprocessed parent

	 * and link all in task children list. Task with no

	 * parent is added into 'list'.

 report__setup_sample_type() already showed error message */

	/*

	 * recalculate number of entries after collapsing since it

	 * might be changed during the collapse phase.

	/*

	 * --no-call-graph

	/*

	 * Check if we need to enable callchains based

	 * on events sample_type.

		/*

		 * Special case: if there's an argument left then assume that

		 * it's a symbol filter:

	/*

	 * Branch mode is a tristate:

	 * -1 means default, so decide based on the file having branch data.

	 * 0/1 means the user chose a mode.

 disable incompatible options */

 Force tty output for header output and per-thread stat. */

				/*

				 * we need to process first few records

				 * which contains PERF_RECORD_HEADER_FEATURE.

	/*

	 * Only in the TUI browser we are doing integrated annotation,

	 * so don't allocate extra space that won't be used in the stdio

	 * implementation.

		/*

 		 * For searching by name on the "Browse map details".

 		 * providing it only in verbose mode not to bloat too

 		 * much struct symbol.

			/*

			 * XXX: Need to provide a less kludgy way to ask for

			 * more space per symbol, the u32 is for the index on

			 * the ui browser.

			 * See symbol__browser_index.

 SPDX-License-Identifier: GPL-2.0

 SPDX-License-Identifier: GPL-2.0

/*

 * builtin-help.c

 *

 * Builtin help command

 emacsclient prints its version number on stderr */

	/*

	 * Don't bother checking return value, because "emacsclient --version"

	 * seems to always exits with code 1.

 This works only with emacsclient version >= 22. */

 It's simpler to launch konqueror using kfmclient. */

 strlen("konqueror") == strlen("kfmclient") */

	/* We should always put ':' after our path. If there is no

	 * old_path, the ':' at the end will let 'man' to try

	 * system-wide paths after ours to find the manual page. If

 will return when unable */

 Check that we have a perf documentation directory. */

/*

 * If open_html is not defined in a platform-specific way (see for

 * example compat/mingw.h), we use the script web--browse to display

 * HTML.

 it leaks but we exec bellow */

 fall-through */

 SPDX-License-Identifier: GPL-2.0

/*

 * builtin-diff.c

 *

 * Builtin diff command: Analyze two perf.data input files, look up and read

 * DSOs and symbol information, sort them and produce a diff.

 Diff command specific HPP columns. */

 After COMPUTE_MAX to avoid use current compute arrays */

		/*

		 * The str data are not writeable, so we need

		 * to use another buffer.

 No option value is longer. */

	/*

	 * The total_period is updated here before going to the output

	 * tree since normally only the baseline hists will call

	 * hists__output_resort() and precompute needs the total

	 * period in order to sort entries by percentage delta.

	/*

	 * We have 2 entries of same kind, let's

	 * make the data comparison.

		/*

		 * The delta can be computed without the baseline, but

		 * others are not.  Put those entries which have no

		 * values below.

 Don't sort callchain for perf diff */

	/*

	 * Stream comparison only supports two data files.

	 * perf.data.old and perf.data. data__files[0] is perf.data.old,

	 * data__files[1] is perf.data.

	/*

	 * Absolute timestamp for one file has the format: a.b,c.d

	 * For multiple files, the format is: a.b,c.d:a.b,c.d

 Set only all files having branch stacks */

	/*

	 * Avoid printing the warning "addr2line_init failed for ..."

		/*

		 * Padding spaces if number of sparks less than NUM_SPARKS

		 * otherwise the output is not aligned.

 No point for ratio number if we are dummy.. */

 No point for wdiff number if we are dummy.. */

 baseline is special */

 Only our defined HPP fmts should appear here. */

 TODO more colors */

		/*

		 * Baseline or compute related columns:

		 *

		 *   PERF_HPP_DIFF__BASELINE

		 *   PERF_HPP_DIFF__DELTA

		 *   PERF_HPP_DIFF__RATIO

		 *   PERF_HPP_DIFF__WEIGHTED_DIFF

		 *   PERF_HPP_DIFF__CYCLES

		/*

		 * And the rest:

		 *

		 * PERF_HPP_DIFF__FORMULA

		 * PERF_HPP_DIFF__PERIOD

		 * PERF_HPP_DIFF__PERIOD_BASELINE

	/*

	 * Prepend an fmt to sort on columns at 'sort_compute' first.

	 * This fmt is added only to the sort list but not to the

	 * output fields list.

	 *

	 * Note that this column (data) can be compared twice - one

	 * for this 'sort_compute' fmt and another for the normal

	 * diff_hpp_fmt.  But it shouldn't a problem as most entries

	 * will be sorted out by first try or baseline and comparing

	 * is not a costly operation.

		/*

		 * Should set since 'fmt->sort' is called without

		 * checking valid during sorting

 SPDX-License-Identifier: GPL-2.0-only

/*

 * builtin-ftrace.c

 *

 * Copyright (c) 2013  LG Electronics,  Namhyung Kim <namhyung@kernel.org>

 * Copyright (c) 2020  Changbin Du <changbin.du@gmail.com>, significant enhancement.

/*

 * evlist__prepare_workload will send a SIGUSR1 if the fork fails, since

 * we asked by setting its exec_error to the function below,

 * ftrace__workload_exec_failed_signal.

 *

 * XXX We need to handle this more appropriately, emitting an error, etc.

	/*

	 * Copy the original value and append a '\n'. Without this,

	 * the kernel can hide possible errors.

 read contents to stdout */

 one more byte for EOS */

 ',' is needed for every 32th cpus */

 old kernels do not have this filter */

 reset ftrace buffer */

 display column headers */

 flush stdout first so below error msg appears at the end. */

 read remaining buffer contents */

 The function_graph has priority over function tracer. */

 Otherwise, the default tracer is used. */

 TODO: Add short option -t after -t/--tracer can be removed. */

 SPDX-License-Identifier: GPL-2.0

/*

 * builtin-list.c

 *

 * Builtin list command: list all event types

 *

 * Copyright (C) 2009, Thomas Gleixner <tglx@linutronix.de>

 * Copyright (C) 2008-2009, Red Hat Inc, Ingo Molnar <mingo@redhat.com>

 * Copyright (C) 2011, Red Hat Inc, Arnaldo Carvalho de Melo <acme@redhat.com>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * builtin-timechart.c - make an svg timechart of system activity

 *

 * (C) Copyright 2009 Intel Corporation

 *

 * Authors:

 *     Arjan van de Ven <arjan@linux.intel.com>

 for struct evsel_str_handler

 Lowest CPU frequency seen */

 Highest CPU frequency seen */

 IO related settings */

/*

 * Datastructure layout:

 * We keep an list of "pid"s, matching the kernels notion of a task struct.

 * Each "pid" entry, has a list of "comm"s.

 *	this is because we want to track different programs different, while

 *	exec will reuse the original pid (by design).

 * Each comm has a list of samples that will be used to draw

 * final graph.

 detect invalid data */

				/*

				 * It seems the callchain is corrupted.

				 * Discard all.

 SUPPORT_OLD_POWER_EVENTS */

/*

 * After the last sample we need to wrap up the current C/P state

 * and close out each CPU for these.

 C state */

 P state */

		/* remove previous event that has been started,

 skip partially captured events */

	/* we want to be able to see small and fast transfers, so make them

 try to make errors more visible */

 merge two requests to make svg smaller and render-friendly */

/*

 * Sort the pid datastructure

 sort by ppid first, then by pid, lowest to highest */

 must insert before */

	/*

	 * two pass drawing so that the P state bars are on top of the C state blocks

 locate the column of the waker and wakee */

 5 seconds */

 no exit marker, task kept running to the end */

 no exit marker, task kept running to the end */

 no exit marker, task kept running to the end */

	/* We'd like to show at least proc_num tasks;

