 SPDX-License-Identifier: GPL-2.0

/*

 *  thermal.c - sysfs interface of thermal devices

 *

 *  Copyright (C) 2016 Eduardo Valentin <edubezval@gmail.com>

 *

 *  Highly based on original thermal_core.c

 *  Copyright (C) 2008 Intel Corp

 *  Copyright (C) 2008 Zhang Rui <rui.zhang@intel.com>

 *  Copyright (C) 2008 Sujith Thomas <sujith.thomas@intel.com>

 sys I/F for thermal zone */

	/*

	 * We are not doing any check on the 'temperature' value

	 * here. The driver implementing 'set_trip_hyst' has to

	 * take care of this.

/*

 * These are thermal zone device attributes that will always be present.

 * All the attributes created for tzp (create_s32_tzp_attr) also are always

 * present on the sysfs interface.

 These thermal zone device attributes are created based on conditions */

 These attributes are unconditionally added to a thermal zone */

 This is not NULL terminated as we create the group dynamically */

/**

 * create_trip_attrs() - create attributes for trip points

 * @tz:		the thermal zone device

 * @mask:	Writeable trip point bitmap.

 *

 * helper function to instantiate sysfs entries for every trip

 * point and its properties of a struct thermal_zone_device.

 *

 * Return: 0 on success, the proper error value otherwise.

 This function works only for zones with at least one trip */

 create trip type attribute */

 create trip temp attribute */

 create Optional trip hyst attribute */

/**

 * destroy_trip_attrs() - destroy attributes for trip points

 * @tz:		the thermal zone device

 *

 * helper function to free resources allocated by create_trip_attrs()

 we need one extra for trips and the NULL to terminate the array */

 This also takes care of API requirement to be NULL terminated */

 sys I/F for cooling device */

 Space allocated for cooling_device_stats_attr_group */

 Total number of states is highest state + 1 */

 Fill the empty slot left in cooling_device_attr_groups */

 CONFIG_THERMAL_STATISTICS */

 these helper will be used only at the time of bindig */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Thermal device driver for DA9062 and DA9061

 * Copyright (C) 2017  Dialog Semiconductor

/* When over-temperature is reached, an interrupt from the device will be

 * triggered. Following this event the interrupt will be disabled and

 * periodic transmission of uevents (HOT trip point) should define the

 * first level of temperature supervision. It is expected that any final

 * implementation of the thermal driver will include a .notify() function

 * to implement these uevents to userspace.

 *

 * These uevents are intended to indicate non-invasive temperature control

 * of the system, where the necessary measures for cooling are the

 * responsibility of the host software. Once the temperature falls again,

 * the IRQ is re-enabled so the start of a new over-temperature event can

 * be detected without constant software monitoring.

/* Minimum, maximum and default polling millisecond periods are provided

 * here as an example. It is expected that any final implementation to also

 * include a modification of these settings to match the required

 * application.

 protection for da9062_thermal temperature */

 clear E_TEMP */

	/* Now read E_TEMP again: it is acting like a status bit.

	 * If over-temperature, then this status will be true.

	 * If not over-temperature, this status will be false.

 SPDX-License-Identifier: GPL-2.0

/*

 *  thermal_hwmon.c - Generic Thermal Management hwmon support.

 *

 *  Code based on Intel thermal_core.c. Copyrights of the original code:

 *  Copyright (C) 2008 Intel Corp

 *  Copyright (C) 2008 Zhang Rui <rui.zhang@intel.com>

 *  Copyright (C) 2008 Sujith Thomas <sujith.thomas@intel.com>

 *

 *  Copyright (C) 2013 Texas Instruments

 *  Copyright (C) 2013 Eduardo Valentin <eduardo.valentin@ti.com>

 hwmon sys I/F */

 thermal zone devices with the same type share one hwmon device */

 one temperature input for each thermal zone */

 hwmon sys attr */

 hwmon sys attr */

 Find the temperature input matching a given thermal zone */

 Should never happen... */

 Should never happen... */

 SPDX-License-Identifier: GPL-2.0

/*

 *  R-Car THS/TSC thermal sensor driver

 *

 * Copyright (C) 2012 Renesas Solutions Corp.

 * Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>

 THSCR */

 THSSR */

	/*

	 * The Gen3 chip has 3 interrupts, but this driver uses only 2

	 * interrupts to detect a temperature change, rise or fall.

/*

 *		basic functions

/*

 *		zone device functions

	/*

	 * TSC decides a value of CPTAP automatically,

	 * and this is the conditions which validate interrupt.

		/*

		 * we need to wait 300us after changing comparator offset

		 * to get stable temperature.

		 * see "Usage Notes" on datasheet

	/*

	 * enable IRQ

 enable Rising/Falling edge interrupt */

 Guaranteed operating range is -45C to 125C. */

 see rcar_thermal_get_temp() */

 +90 <= temp */

 see rcar_thermal_get_temp() */

 +90 <= temp */

/*

 *		interrupt

 enable Rising/Falling */

	/*

	 * check the status

/*

 *		platform functions

			/*

			 * platform has IRQ support.

			 * Then, driver uses common registers

			 * rcar_has_irq_support() will be enabled

 polling delay is not needed */

 update ENR bits */

			/*

			 * thermal_zone doesn't enable hwmon as default,

			 * but, enable it here to keep compatible

 update ENR bits */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  gov_bang_bang.c - A simple thermal throttling governor using hysteresis

 *

 *  Copyright (C) 2014 Peter Kaestle <peter@piie.net>

 *

 *  Based on step_wise.c with following Copyrights:

 *  Copyright (C) 2012 Intel Corp

 *  Copyright (C) 2012 Durgadoss R <durgadoss.r@intel.com>

 in case fan is in initial state, switch the fan off */

 in case fan is neither on nor off set the fan to active */

		/*

		 * enable fan when temperature exceeds trip_temp and disable

		 * the fan in case it falls below trip_temp minus hysteresis

 cdev needs update */

/**

 * bang_bang_control - controls devices associated with the given zone

 * @tz: thermal_zone_device

 * @trip: the trip point

 *

 * Regulation Logic: a two point regulation, deliver cooling state depending

 * on the previous state shown in this diagram:

 *

 *                Fan:   OFF    ON

 *

 *                              |

 *                              |

 *          trip_temp:    +---->+

 *                        |     |        ^

 *                        |     |        |

 *                        |     |   Temperature

 * (trip_temp - hyst):    +<----+

 *                        |

 *                        |

 *                        |

 *

 *   * If the fan is not running and temperature exceeds trip_temp, the fan

 *     gets turned on.

 *   * In case the fan is running, temperature must fall below

 *     (trip_temp - hyst) so that the fan gets turned off again.

 *

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Marvell EBU Armada SoCs thermal sensor driver

 *

 * Copyright (C) 2013 Marvell

 Thermal Manager Control and Status Register */

 Errata fields */

 Marvell EBU Thermal Sensor Dev Structure */

 serialize temperature reads/updates */

 Initialize the thermal IC */

 Formula coeficients: temp = (b - m * reg) / div */

 Register shift and mask to access the sensor temperature */

 Syscon access */

 One sensor is in the thermal IC, the others are in the CPUs if any */

/*

 * struct armada_thermal_sensor - hold the information of one thermal sensor

 * @thermal: pointer to the local private structure

 * @tzd: pointer to the thermal zone device

 * @id: identifier of the thermal sensor

 Reference calibration value */

 Reset the sensor */

 Enable the sensor */

 Reference calibration value */

 Reset the sensor */

 Disable the HW/SW reset */

 Set Tsen Tc Trim to correct default value (errata #132698) */

 Sample every ~2ms */

 Enable average (2 samples by default) */

 Sample every ~2ms */

 Average the output value over 2^1 = 2 samples */

 Clear DFX temperature IRQ cause */

 Enable DFX Temperature IRQ */

 Enable DFX server IRQ */

 Enable overheat interrupt */

 There is currently no board with more than one sensor per channel */

 Stop the measurements */

 Reset the mode, internal sensor will be automatically selected */

 Other channels are external and should be selected accordingly */

 Change the mode to external */

 Select the sensor */

 Actually set the mode/channel */

 Re-start the measurements */

	/*

	 * The IP has a latency of ~15ms, so after updating the selected source,

	 * we must absolutely wait for the sensor validity bit to ensure we read

	 * actual data.

 The most significant bit is the sign bit */

 Get formula coeficients */

 Valid check */

 Do the actual reading */

 Select the desired channel */

 Do the actual reading */

	/*

	 * Select back the interrupt source channel from which a potential

	 * critical trip point has been set.

/*

 * The documentation states:

 * high/low watermark = threshold +/- 0.4761 * 2^(hysteresis + 2)

 * which is the mathematical derivation for:

 * 0x0 <=> 1.9°C, 0x1 <=> 3.8°C, 0x2 <=> 7.6°C, 0x3 <=> 15.2°C

	/*

	 * We will always take the smallest possible hysteresis to avoid risking

	 * the hardware integrity by enlarging the threshold by +8°C in the

	 * worst case.

 Set Threshold */

 Set Hysteresis */

	/*

	 * Disable the IRQ and continue in thread context (thermal core

	 * notification and temperature monitoring).

 Notify the core in thread context */

	/*

	 * The overheat interrupt must be cleared by reading the DFX interrupt

	 * cause _after_ the temperature has fallen down to the low threshold.

	 * Otherwise future interrupts might not be served.

 Notify the thermal core that the temperature is acceptable again */

 sentinel */

 First memory region points towards the status register */

	/*

	 * Fix up from the old individual DT register specification to

	 * cover all the registers.  We do this by adjusting the ioremap()

	 * result, which should be fine as ioremap() deals with pages.

	 * However, validate that we do not cross a page boundary while

	 * making this adjustment.

		/*

		 * When inside a system controller, the device name has the

		 * form: f06f8000.system-controller:ap-thermal so stripping

		 * after the ':' should give us a shorter but meaningful name.

 Save the name locally */

 Then check there are no '-' or hwmon core will complain */

/*

 * The IP can manage to trigger interrupts on overheat situation from all the

 * sensors. However, the interrupt source changes along with the last selected

 * source (ie. the last read sensor), which is an inconsistent behavior. Avoid

 * possible glitches by always selecting back only one channel (arbitrarily: the

 * first in the DT which has a critical trip point). We also disable sensor

 * switch during overheat situations.

 Retrieve the critical trip point to enable the overheat interrupt */

	/*

	 * Legacy DT bindings only described "control1" register (also referred

	 * as "control MSB" on old documentation). Then, bindings moved to cover

	 * "control0/control LSB" and "control1/control MSB" registers within

	 * the same resource, which was then of size 8 instead of 4.

	 *

	 * The logic of defining sporadic registers is broken. For instance, it

	 * blocked the addition of the overheat interrupt feature that needed

	 * another resource somewhere else in the same memory area. One solution

	 * is to define an overall system controller and put the thermal node

	 * into it, which requires the use of regmaps across all the driver.

 Ensure device name is correct for the thermal core */

 Wait the sensors to be valid */

 The overheat interrupt feature is not mandatory */

	/*

	 * There is one channel for the IC and one per CPU (if any), each

	 * channel has one sensor.

 Register the sensor */

		/*

		 * The first channel that has a critical trip point registered

		 * in the DT will serve as interrupt source. Others possible

		 * critical trip points will simply be ignored by the driver.

 Just complain if no overheat interrupt was set up */

 SPDX-License-Identifier: GPL-2.0



 Copyright 2013 Freescale Semiconductor, Inc.

 i.MX6 specific */

 Below LOW and PANIC bits are only for TEMPMON_IMX6SX */

 Below TEMPSENSE2 is only for TEMPMON_IMX6SX */

 i.MX7 specific */

 The driver supports 1 passive trip point and 1 critical trip point */

 millisecond */

 See formula in imx_init_calib() */

 Check if a measurement is currently in progress */

		/*

		 * Every time we measure the temperature, we will power on the

		 * temperature sensor, enable measurements, take a reading,

		 * disable measurements, power off the temperature sensor.

	/*

	 * According to the temp sensor designers, it may require up to ~17us

	 * to complete a measurement.

 See imx_init_calib() for formula derivation */

 Update alarm value to next higher trip point for TEMPMON_IMX6Q */

 Reenable alarm IRQ if temperature below alarm temperature */

 do not allow changing critical threshold */

 do not allow passive to be set higher than critical */

	/*

	 * On i.MX7D, we only use the calibration data at 25C to get the temp,

	 * Tmeas = ( Nmeas - n1) + 25; n1 is the fuse value for 25C.

	/*

	 * The sensor is calibrated at 25 °C (aka T1) and the value measured

	 * (aka N1) at this temperature is provided in bits [31:20] in the

	 * i.MX's OCOTP value ANA1.

	 * To find the actual temperature T, the following formula has to be used

	 * when reading value n from the sensor:

	 *

	 * T = T1 + (N - N1) / (0.4148468 - 0.0015423 * N1) °C + 3.580661 °C

	 *   = [T1' - N1 / (0.4148468 - 0.0015423 * N1) °C] + N / (0.4148468 - 0.0015423 * N1) °C

	 *   = [T1' + N1 / (0.0015423 * N1 - 0.4148468) °C] - N / (0.0015423 * N1 - 0.4148468) °C

	 *   = c2 - c1 * N

	 *

	 * with

	 *

	 *  T1' = 28.580661 °C

	 *   c1 = 1 / (0.0015423 * N1 - 0.4297157) °C

	 *   c2 = T1' + N1 / (0.0015423 * N1 - 0.4148468) °C

	 *      = T1' + N1 * c1

 use 10^7 as fixed point constant for values in formula */

 to get result in °mC */

 The maximum die temp is specified by the Temperature Grade */

 Commercial (0 to 95 °C) */

 Extended Commercial (-20 °C to 105 °C) */

 Industrial (-40 °C to 105 °C) */

 Automotive (-40 °C to 125 °C) */

	/*

	 * Set the critical trip point at 5 °C under max

	 * Set the passive trip point at 10 °C under max (changeable via sysfs)

 end */ }

/*

 * Create cooling device in case no #cooling-cells property is available in

 * CPU node

 make sure the IRQ flag is clear before enabling irq on i.MX6SX */

		/*

		 * reset value of LOW ALARM is incorrect, set it to lowest

		 * value to avoid false trigger of low alarm.

 Make sure sensor is in known good state for measurements */

	/*

	 * Thermal sensor needs clk on to get correct value, normally

	 * we should enable its clk before taking measurement and disable

	 * clk after measurement is done, but if alarm function is enabled,

	 * hardware will auto measure the temperature periodically, so we

	 * need to keep the clk always on for alarm function.

 Enable measurements at ~ 10 Hz */

 10 Hz */

 Disable measurements */

	/*

	 * Need to disable thermal sensor, otherwise, when thermal core

	 * try to get temperature before thermal sensor resume, a wrong

	 * temperature will be read as the thermal sensor is powered

	 * down. This is done in change_mode() operation called from

	 * thermal_zone_device_disable()

 Enabled thermal sensor after resume */

 SPDX-License-Identifier: GPL-2.0

/*

 *  R-Car Gen3 THS thermal sensor driver

 *  Based on rcar_thermal.c and work from Hien Dang and Khiem Nguyen.

 *

 * Copyright (C) 2016 Renesas Electronics Corporation.

 * Copyright (C) 2016 Sang Engineering

 Register offsets */

 IRQ{STR,MSK,EN} bits */

 CTSR bits */

 THCTR bits */

 THSCP bits */

 Structure for thermal temperature calculation */

/*

 * Linear approximation for temperature

 *

 * [reg] = [temp] * a + b => [temp] = ([reg] - b) / a

 *

 * The constants a and b are calculated using two triplets of int values PTAT

 * and THCODE. PTAT and THCODE can either be read from hardware or use hard

 * coded values from driver. The formula to calculate a and b are taken from

 * BSP and sparsely documented and understood.

 *

 * Examining the linear formula and the formula used to calculate constants a

 * and b while knowing that the span for PTAT and THCODE values are between

 * 0x000 and 0xfff the largest integer possible is 0xfff * 0xfff == 0xffe001.

 * Integer also needs to be signed so that leaves 7 bits for binary

 * fixed point scaling.

 mili Celsius */

 no idea where these constants come from */

 TODO: Find documentation and document constant calculation formula */

	/*

	 * Division is not scaled in BSP and if scaled it might overflow

	 * the dividend (4095 * 4095 << 14 > INT_MAX) so keep it unscaled

 Read register and convert to mili Celsius */

 Guaranteed operating range is -40C to 125C. */

 Round value to device granularity setting */

 sentinel */ }

 If fuses are not set, fallback to pseudo values. */

 Default THCODE values in case FUSEs are not set. */

	/*

	 * Set the pseudo calibration points with fused values.

	 * PTAT is shared between all TSCs but only fused for the first

	 * TSC while THCODEs are fused for each TSC.

 SPDX-License-Identifier: GPL-2.0

 Copyright (C) 2020 Spreadtrum Communications Inc.

 bits definitions for register THM_CTL */

 bits definitions for register THM_INT_CTL */

 bits definitions for register SPRD_THM_INTERNAL_STS1 */

 thermal sensor calibration parameters */

/*

 * The conversion between ADC and temperature is based on linear relationship,

 * and use idea_k to specify the slope and ideal_b to specify the offset.

 *

 * Since different Spreadtrum SoCs have different ideal_k and ideal_b,

 * we should save ideal_k and ideal_b in the device data structure.

	/*

	 * According to thermal datasheet, the default calibration offset is 64,

	 * and the default ratio is 1000.

	/*

	 * According to the ideal slope K and ideal offset B, combined with

	 * calibration value of thermal from efuse, then calibrate the real

	 * slope k and offset b:

	 * k_cal = (k * ratio) / 1000.

	 * b_cal = b + (dt_offset - 64) * 500.

	/*

	 * According to the thermal datasheet, the formula of converting

	 * adc value to the temperature value should be:

	 * T_final = k_cal * x - b_cal.

	/*

	 * According to the thermal datasheet, the formula of converting

	 * adc value to the temperature value should be:

	 * T_final = k_cal * x - b_cal.

	/*

	 * Wait for thermal ready status before configuring thermal parameters.

 Wait for first temperature data ready before reading temperature */

	/*

	 * Clear interrupt status, enable thermal interrupt and enable thermal.

	 *

	 * The SPRD thermal controller integrates a hardware interrupt signal,

	 * which means if the temperature is overheat, it will generate an

	 * interrupt and notify the event to PMIC automatically to shutdown the

	 * system. So here we should enable the interrupt bits, though we have

	 * not registered an irq handler.

 Enable the sensor' overheat temperature protection interrupt */

 Set the sensor' overheat and hot threshold temperature */

 Enable the corresponding sensor */

 Set the period of two valid temperature detection action */

 Set the sensors' monitor mode */

 Set the sensors' monitor period */

 sen_child set to NULL at this point */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * SPEAr thermal driver.

 *

 * Copyright (C) 2011-2012 ST Microelectronics

 * Author: Vincenzo Frascino <vincenzo.frascino@st.com>

 SPEAr Thermal Sensor Dev Structure */

 pointer to base address of the thermal sensor */

 clk structure */

 pointer to thermal flags */

	/*

	 * Data are ready to be read after 628 usec from POWERDOWN signal

	 * (PDN) = 1

 Disable SPEAr Thermal Sensor */

 Enable SPEAr Thermal Sensor */

 Enable thermal sensor */

 Disable SPEAr Thermal Sensor */

 SPDX-License-Identifier: GPL-2.0

/*

 * A power allocator to manage temperature

 *

 * Copyright (C) 2014 ARM Ltd.

 *

/**

 * mul_frac() - multiply two fixed-point numbers

 * @x:	first multiplicand

 * @y:	second multiplicand

 *

 * Return: the result of multiplying two fixed-point numbers.  The

 * result is also a fixed-point number.

/**

 * div_frac() - divide two fixed-point numbers

 * @x:	the dividend

 * @y:	the divisor

 *

 * Return: the result of dividing two fixed-point numbers.  The

 * result is also a fixed-point number.

/**

 * struct power_allocator_params - parameters for the power allocator governor

 * @allocated_tzp:	whether we have allocated tzp for this thermal zone and

 *			it needs to be freed on unbind

 * @err_integral:	accumulated error in the PID controller.

 * @prev_err:	error in the previous iteration of the PID controller.

 *		Used to calculate the derivative term.

 * @trip_switch_on:	first passive trip point of the thermal zone.  The

 *			governor switches on when this trip point is crossed.

 *			If the thermal zone only has one passive trip point,

 *			@trip_switch_on should be INVALID_TRIP.

 * @trip_max_desired_temperature:	last passive trip point of the thermal

 *					zone.  The temperature we are

 *					controlling for.

 * @sustainable_power:	Sustainable power (heat) that this thermal zone can

 *			dissipate

/**

 * estimate_sustainable_power() - Estimate the sustainable power of a thermal zone

 * @tz: thermal zone we are operating in

 *

 * For thermal zones that don't provide a sustainable_power in their

 * thermal_zone_params, estimate one.  Calculate it using the minimum

 * power of all the cooling devices as that gives a valid value that

 * can give some degree of functionality.  For optimal performance of

 * this governor, provide a sustainable_power in the thermal zone's

 * thermal_zone_params.

/**

 * estimate_pid_constants() - Estimate the constants for the PID controller

 * @tz:		thermal zone for which to estimate the constants

 * @sustainable_power:	sustainable power for the thermal zone

 * @trip_switch_on:	trip point number for the switch on temperature

 * @control_temp:	target temperature for the power allocator governor

 *

 * This function is used to update the estimation of the PID

 * controller constants in struct thermal_zone_parameters.

	/*

	 * estimate_pid_constants() tries to find appropriate default

	 * values for thermal zones that don't provide them. If a

	 * system integrator has configured a thermal zone with two

	 * passive trip points at the same temperature, that person

	 * hasn't put any effort to set up the thermal zone properly

	 * so just give up.

	/*

	 * The default for k_d and integral_cutoff is 0, so we can

	 * leave them as they are.

/**

 * get_sustainable_power() - Get the right sustainable power

 * @tz:		thermal zone for which to estimate the constants

 * @params:	parameters for the power allocator governor

 * @control_temp:	target temperature for the power allocator governor

 *

 * This function is used for getting the proper sustainable power value based

 * on variables which might be updated by the user sysfs interface. If that

 * happen the new value is going to be estimated and updated. It is also used

 * after thermal zone binding, where the initial values where set to 0.

 Check if it's init value 0 or there was update via sysfs */

 Do the estimation only once and make available in sysfs */

/**

 * pid_controller() - PID controller

 * @tz:	thermal zone we are operating in

 * @control_temp:	the target temperature in millicelsius

 * @max_allocatable_power:	maximum allocatable power for this thermal zone

 *

 * This PID controller increases the available power budget so that the

 * temperature of the thermal zone gets as close as possible to

 * @control_temp and limits the power if it exceeds it.  k_po is the

 * proportional term when we are overshooting, k_pu is the

 * proportional term when we are undershooting.  integral_cutoff is a

 * threshold below which we stop accumulating the error.  The

 * accumulated error is only valid if the requested power will make

 * the system warmer.  If the system is mostly idle, there's no point

 * in accumulating positive error.

 *

 * Return: The power budget for the next period.

 Calculate the proportional term */

	/*

	 * Calculate the integral term

	 *

	 * if the error is less than cut off allow integration (but

	 * the integral is limited to max power)

	/*

	 * Calculate the derivative term

	 *

	 * We do err - prev_err, so with a positive k_d, a decreasing

	 * error (i.e. driving closer to the line) results in less

	 * power being applied, slowing down the controller)

 feed-forward the known sustainable dissipatable power */

/**

 * power_actor_set_power() - limit the maximum power a cooling device consumes

 * @cdev:	pointer to &thermal_cooling_device

 * @instance:	thermal instance to update

 * @power:	the power in milliwatts

 *

 * Set the cooling device to consume at most @power milliwatts. The limit is

 * expected to be a cap at the maximum power consumption.

 *

 * Return: 0 on success, -EINVAL if the cooling device does not

 * implement the power actor API or -E* for other failures.

/**

 * divvy_up_power() - divvy the allocated power between the actors

 * @req_power:	each actor's requested power

 * @max_power:	each actor's maximum available power

 * @num_actors:	size of the @req_power, @max_power and @granted_power's array

 * @total_req_power: sum of @req_power

 * @power_range:	total allocated power

 * @granted_power:	output array: each actor's granted power

 * @extra_actor_power:	an appropriately sized array to be used in the

 *			function as temporary storage of the extra power given

 *			to the actors

 *

 * This function divides the total allocated power (@power_range)

 * fairly between the actors.  It first tries to give each actor a

 * share of the @power_range according to how much power it requested

 * compared to the rest of the actors.  For example, if only one actor

 * requests power, then it receives all the @power_range.  If

 * three actors each requests 1mW, each receives a third of the

 * @power_range.

 *

 * If any actor received more than their maximum power, then that

 * surplus is re-divvied among the actors based on how far they are

 * from their respective maximums.

 *

 * Granted power for each actor is written to @granted_power, which

 * should've been allocated by the calling function.

	/*

	 * Prevent division by 0 if none of the actors request power.

	/*

	 * Re-divvy the reclaimed extra among actors based on

	 * how far they are from the max

	/*

	 * We need to allocate five arrays of the same size:

	 * req_power, max_power, granted_power, extra_actor_power and

	 * weighted_req_power.  They are going to be needed until this

	 * function returns.  Allocate them all in one go to simplify

	 * the allocation and deallocation logic.

/**

 * get_governor_trips() - get the number of the two trip points that are key for this governor

 * @tz:	thermal zone to operate on

 * @params:	pointer to private data for this governor

 *

 * The power allocator governor works optimally with two trips points:

 * a "switch on" trip point and a "maximum desired temperature".  These

 * are defined as the first and last passive trip points.

 *

 * If there is only one trip point, then that's considered to be the

 * "maximum desired temperature" trip point and the governor is always

 * on.  If there are no passive or active trip points, then the

 * governor won't do anything.  In fact, its throttle function

 * won't be called at all.

		/*

		 * Call for updating the cooling devices local stats and avoid

		 * periods of dozen of seconds when those have not been

		 * maintained.

/**

 * check_power_actors() - Check all cooling devices and warn when they are

 *			not power actors

 * @tz:		thermal zone to operate on

 *

 * Check all cooling devices in the @tz and warn every time they are missing

 * power actor API. The warning should help to investigate the issue, which

 * could be e.g. lack of Energy Model for a given device.

 *

 * Return: 0 on success, -EINVAL if any cooling device does not implement

 * the power actor API.

/**

 * power_allocator_bind() - bind the power_allocator governor to a thermal zone

 * @tz:	thermal zone to bind it to

 *

 * Initialize the PID controller parameters and bind it to the thermal

 * zone.

 *

 * Return: 0 on success, or -ENOMEM if we ran out of memory, or -EINVAL

 * when there are unsupported cooling devices in the @tz.

	/*

	 * We get called for every trip point but we only need to do

	 * our calculations once

 SPDX-License-Identifier: GPL-2.0

/*

 *  Copyright (C) 2019 Linaro Limited.

 *

 *  Author: Daniel Lezcano <daniel.lezcano@linaro.org>

 *

/**

 * struct cpuidle_cooling_device - data for the idle cooling device

 * @ii_dev: an atomic to keep track of the last task exiting the idle cycle

 * @state: a normalized integer giving the state of the cooling device

/**

 * cpuidle_cooling_runtime - Running time computation

 * @idle_duration_us: CPU idle time to inject in microseconds

 * @state: a percentile based number

 *

 * The running duration is computed from the idle injection duration

 * which is fixed. If we reach 100% of idle injection ratio, that

 * means the running duration is zero. If we have a 50% ratio

 * injection, that means we have equal duration for idle and for

 * running duration.

 *

 * The formula is deduced as follows:

 *

 *  running = idle x ((100 / ratio) - 1)

 *

 * For precision purpose for integer math, we use the following:

 *

 *  running = (idle x 100) / ratio - idle

 *

 * For example, if we have an injected duration of 50%, then we end up

 * with 10ms of idle injection and 10ms of running duration.

 *

 * Return: An unsigned int for a usec based runtime duration.

/**

 * cpuidle_cooling_get_max_state - Get the maximum state

 * @cdev  : the thermal cooling device

 * @state : a pointer to the state variable to be filled

 *

 * The function always returns 100 as the injection ratio. It is

 * percentile based for consistency accross different platforms.

 *

 * Return: The function can not fail, it is always zero

	/*

	 * Depending on the configuration or the hardware, the running

	 * cycle and the idle cycle could be different. We want to

	 * unify that to an 0..100 interval, so the set state

	 * interface will be the same whatever the platform is.

	 *

	 * The state 100% will make the cluster 100% ... idle. A 0%

	 * injection ratio means no idle injection at all and 50%

	 * means for 10ms of idle injection, we have 10ms of running

	 * time.

/**

 * cpuidle_cooling_get_cur_state - Get the current cooling state

 * @cdev: the thermal cooling device

 * @state: a pointer to the state

 *

 * The function just copies  the state value from the private thermal

 * cooling device structure, the mapping is 1 <-> 1.

 *

 * Return: The function can not fail, it is always zero

/**

 * cpuidle_cooling_set_cur_state - Set the current cooling state

 * @cdev: the thermal cooling device

 * @state: the target state

 *

 * The function checks first if we are initiating the mitigation which

 * in turn wakes up all the idle injection tasks belonging to the idle

 * cooling device. In any case, it updates the internal state for the

 * cooling device.

 *

 * Return: The function can not fail, it is always zero

/**

 * cpuidle_cooling_ops - thermal cooling device ops

/**

 * __cpuidle_cooling_register: register the cooling device

 * @drv: a cpuidle driver structure pointer

 * @np: a device node structure pointer used for the thermal binding

 *

 * This function is in charge of allocating the cpuidle cooling device

 * structure, the idle injection, initialize them and register the

 * cooling device to the thermal framework.

 *

 * Return: zero on success, a negative value returned by one of the

 * underlying subsystem in case of error

/**

 * cpuidle_cooling_register - Idle cooling device initialization function

 * @drv: a cpuidle driver structure pointer

 *

 * This function is in charge of creating a cooling device per cpuidle

 * driver and register it to the thermal framework.

 *

 * Return: zero on success, or negative value corresponding to the

 * error detected in the underlying subsystems.

 SPDX-License-Identifier: GPL-2.0

/*

 * Thermal sensor driver for Allwinner SOC

 * Copyright (C) 2019 Yangtao Li

 *

 * Based on the work of Icenowy Zheng <icenowy@aosc.io>

 * Based on the work of Ondrej Jirman <megous@megous.com>

 * Based on the work of Josef Gajdusek <atx@atx.name>

 millidegree celsius */

 Temp Unit: millidegree Celsius */

 ths have no data yet */

	/*

	 * According to the original sdk, there are some platforms(rarely)

	 * that add a fixed offset value after calculating the temperature

	 * value. We can't simply put it on the formula for calculating the

	 * temperature above, because the formula for calculating the

	 * temperature above is also used when the sensor is calibrated. If

	 * do this, the correct calibration formula is hard to know.

	/*

	 * efuse layout:

	 *

	 *	0   11  16	 32

	 *	+-------+-------+-------+

	 *	|temp|  |sensor0|sensor1|

	 *	+-------+-------+-------+

	 *

	 * The calibration data on the H6 is the ambient temperature and

	 * sensor values that are filled during the factory test stage.

	 *

	 * The unit of stored FT temperature is 0.1 degreee celusis.

	 *

	 * We need to calculate a delta between measured and caluclated

	 * register values and this will become a calibration offset.

		/*

		 * Calibration data is CALIBRATE_DEFAULT - (calculated

		 * temperature from sensor reading at factory temperature

		 * minus actual factory temperature) * 14.88 (scale from

		 * temperature to register values)

			/*

			 * Calibration value more than 12-bit, but calibration

			 * register is 12-bit. In this case, ths hardware can

			 * still work without calibration, although the data

			 * won't be so accurate.

		/*

		 * Even if the external calibration data stored in sid is

		 * not accessible, the THS hardware can still work, although

		 * the data won't be so accurate.

		 *

		 * The default value of calibration register is 0x800 for

		 * every sensor, and the calibration value is usually 0x7xx

		 * or 0x8xx, so they won't be away from the default value

		 * for a lot.

		 *

		 * So here we do not return error if the calibration data is

		 * not available, except the probe needs deferring.

 average over 4 samples */

	/*

	 * clkin = 24MHz

	 * filter_samples = 4

	 * period = 0.25s

	 *

	 * x = period * clkin / 4096 / filter_samples - 1

	 *   = 365

	/*

	 * T_acq = 20us

	 * clkin = 24MHz

	 *

	 * x = T_acq * clkin - 1

	 *   = 479

/*

 * Without this undocumented value, the returned temperatures would

 * be higher than real ones by about 20C.

	/*

	 * T_acq = 20us

	 * clkin = 24MHz

	 *

	 * x = T_acq * clkin - 1

	 *   = 479

 average over 4 samples */

	/*

	 * clkin = 24MHz

	 * filter_samples = 4

	 * period = 0.25s

	 *

	 * x = period * clkin / 4096 / filter_samples - 1

	 *   = 365

 enable sensor */

 thermal data interrupt enable */

	/*

	 * Avoid entering the interrupt handler, the thermal device is not

	 * registered yet, we deffer the registration of the interrupt to

	 * the end.

 sentinel */ },

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2015 MediaTek Inc.

 * Author: Hanyi Wu <hanyi.wu@mediatek.com>

 *         Sascha Hauer <s.hauer@pengutronix.de>

 *         Dawei Chien <dawei.chien@mediatek.com>

 *         Louis Yu <louis.yu@mediatek.com>

 AUXADC Registers */

 Thermal Controller Registers */

 MT8173 thermal sensors */

 AUXADC channel 11 is used for the temperature sensors */

 The total number of temperature sensors in the MT8173 */

 The number of banks in the MT8173 */

 The number of sensing points per bank */

 The number of controller in the MT8173 */

 The calibration coefficient of sensor  */

/*

 * Layout of the fuses providing the calibration data

 * These macros could be used for MT8183, MT8173, MT2701, and MT2712.

 * MT8183 has 6 sensors and needs 6 VTS calibration data.

 * MT8173 has 5 sensors and needs 5 VTS calibration data.

 * MT2701 has 3 sensors and needs 3 VTS calibration data.

 * MT2712 has 4 sensors and needs 4 VTS calibration data.

/*

 * Layout of the fuses providing the calibration data

 * These macros could be used for MT7622.

 MT2701 thermal sensors */

 AUXADC channel 11 is used for the temperature sensors */

 The total number of temperature sensors in the MT2701 */

 The number of sensing points per bank */

 The number of controller in the MT2701 */

 The calibration coefficient of sensor  */

 MT2712 thermal sensors */

 AUXADC channel 11 is used for the temperature sensors */

 The total number of temperature sensors in the MT2712 */

 The number of sensing points per bank */

 The number of controller in the MT2712 */

 The calibration coefficient of sensor  */

 The maximum number of banks */

 The calibration coefficient of sensor  */

 MT8183 thermal sensors */

 AUXADC channel  is used for the temperature sensors */

 The total number of temperature sensors in the MT8183 */

 The number of banks in the MT8183 */

 The number of sensing points per bank */

 The number of controller in the MT8183 */

 The calibration coefficient of sensor  */

 lock: for getting and putting banks */

 Calibration values */

 MT8183 thermal sensor data */

 MT8173 thermal sensor data */

 MT2701 thermal sensor data */

 MT2712 thermal sensor data */

 MT7622 thermal sensor data */

/*

 * The MT8173 thermal controller has four banks. Each bank can read up to

 * four temperature sensors simultaneously. The MT8173 has a total of 5

 * temperature sensors. We use each bank to measure a certain area of the

 * SoC. Since TS2 is located centrally in the SoC it is influenced by multiple

 * areas, hence is used in different banks.

 *

 * The thermal core only gets the maximum temperature of all banks, so

 * the bank concept wouldn't be necessary here. However, the SVS (Smart

 * Voltage Scaling) unit makes its decisions based on the same bank

 * data, and this indeed needs the temperatures of the individual banks

 * for making better decisions.

/*

 * The MT2701 thermal controller has one bank, which can read up to

 * three temperature sensors simultaneously. The MT2701 has a total of 3

 * temperature sensors.

 *

 * The thermal core only gets the maximum temperature of this one bank,

 * so the bank concept wouldn't be necessary here. However, the SVS (Smart

 * Voltage Scaling) unit makes its decisions based on the same bank

 * data.

/*

 * The MT2712 thermal controller has one bank, which can read up to

 * four temperature sensors simultaneously. The MT2712 has a total of 4

 * temperature sensors.

 *

 * The thermal core only gets the maximum temperature of this one bank,

 * so the bank concept wouldn't be necessary here. However, the SVS (Smart

 * Voltage Scaling) unit makes its decisions based on the same bank

 * data.

/*

 * MT7622 have only one sensing point which uses AUXADC Channel 11 for raw data

 * access.

/*

 * The MT8183 thermal controller has one bank for the current SW framework.

 * The MT8183 has a total of 6 temperature sensors.

 * There are two thermal controller to control the six sensor.

 * The first one bind 2 sensor, and the other bind 4 sensors.

 * The thermal core only gets the maximum temperature of all sensor, so

 * the bank concept wouldn't be necessary here. However, the SVS (Smart

 * Voltage Scaling) unit makes its decisions based on the same bank

 * data, and this indeed needs the temperatures of the individual banks

 * for making better decisions.

/**

 * raw_to_mcelsius - convert a raw ADC value to mcelsius

 * @mt:	The thermal controller

 * @sensno:	sensor number

 * @raw:	raw ADC value

 *

 * This converts the raw ADC value to mcelsius using the SoC specific

 * calibration constants

/**

 * mtk_thermal_get_bank - get bank

 * @bank:	The bank

 *

 * The bank registers are banked, we have to select a bank in the

 * PTPCORESEL register to access it.

/**

 * mtk_thermal_put_bank - release bank

 * @bank:	The bank

 *

 * release a bank previously taken with mtk_thermal_get_bank,

/**

 * mtk_thermal_bank_temperature - get the temperature of a bank

 * @bank:	The bank

 *

 * The temperature of a bank is considered the maximum temperature of

 * the sensors associated to the bank.

		/*

		 * The first read of a sensor often contains very high bogus

		 * temperature value. Filter these out so that the system does

		 * not immediately shut down.

 bus clock 66M counting unit is 12 * 15.15ns * 256 = 46.540us */

	/*

	 * filt interval is 1 * 46.540us = 46.54us,

	 * sen interval is 429 * 46.540us = 19.96ms

 poll is set to 10u */

 temperature sampling control, 1 sample */

 exceed this polling time, IRQ would be inserted */

 number of interrupts per event, 1 is enough */

	/*

	 * The MT8173 thermal controller does not have its own ADC. Instead it

	 * uses AHB bus accesses to control the AUXADC. To do this the thermal

	 * controller has to be programmed with the physical addresses of the

	 * AUXADC registers and with the various bit positions in the AUXADC.

	 * Also the thermal controller controls a mux in the APMIXEDSYS register

	 * space.

	/*

	 * this value will be stored to TEMP_PNPMUXADDR (TEMP_SPARE0)

	 * automatically by hw

 AHB address for auxadc mux selection */

 AHB address for pnp sensor mux selection */

 AHB value for auxadc enable */

 AHB address for auxadc enable (channel 0 immediate mode selected) */

 AHB address for auxadc valid bit */

 AHB address for auxadc voltage output */

 read valid & voltage are at the same register */

 indicate where the valid bit is */

 no shift */

 enable auxadc mux write transaction */

 Start with default values */

 SPDX-License-Identifier: GPL-2.0+

/*

 * Amlogic Thermal Sensor Driver

 *

 * Copyright (C) 2017 Huan Biao <huan.biao@amlogic.com>

 * Copyright (C) 2019 Guillaume La Roque <glaroque@baylibre.com>

 *

 * Register value to celsius temperature formulas:

 *	Read_Val	    m * U

 * U = ---------, Uptat = ---------

 *	2^16		  1 + n * U

 *

 * Temperature = A * ( Uptat + u_efuse / 2^16 )- B

 *

 *  A B m n : calibration parameters

 *  u_efuse : fused calibration value, it's a signed 16 bits value

/**

 * struct amlogic_thermal_soc_calib_data

 * @A: calibration parameters

 * @B: calibration parameters

 * @m: calibration parameters

 * @n: calibration parameters

 *

 * This structure is required for configuration of amlogic thermal driver.

/**

 * struct amlogic_thermal_data

 * @u_efuse_off: register offset to read fused calibration value

 * @calibration_parameters: calibration parameters structure pointer

 * @regmap_config: regmap config for the device

 * This structure is required for configuration of amlogic thermal driver.

/*

 * Calculate a temperature value from a temperature code.

 * The unit of the temperature is degree milliCelsius.

 sentinel */ }

/*

 * HiSilicon thermal sensor driver

 *

 * Copyright (c) 2014-2015 HiSilicon Limited.

 * Copyright (c) 2014-2015 Linaro Limited.

 *

 * Xinwei Kong <kong.kongxinwei@hisilicon.com>

 * Leo Yan <leo.yan@linaro.org>

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License version 2 as

 * published by the Free Software Foundation.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the

 * GNU General Public License for more details.

/*

 * The temperature computation on the tsensor is as follow:

 *	Unit: millidegree Celsius

 *	Step: 200/255 (0.7843)

 *	Temperature base: -60°C

 *

 * The register is programmed in temperature steps, every step is 785

 * millidegree and begins at -60 000 m°C

 *

 * The temperature from the steps:

 *

 *	Temp = TempBase + (steps x 785)

 *

 * and the steps from the temperature:

 *

 *	steps = (Temp - TempBase) / 785

 *

/*

 * for Hi3660,

 *	Step: 189/922 (0.205)

 *	Temperature base: -63.780°C

 *

 * The register is programmed in temperature steps, every step is 205

 * millidegree and begins at -63 780 m°C

/*

 * The lag register contains 5 bits encoding the temperature in steps.

 *

 * Each time the temperature crosses the threshold boundary, an

 * interrupt is raised. It could be when the temperature is going

 * above the threshold or below. However, if the temperature is

 * fluctuating around this value due to the load, we can receive

 * several interrupts which may not desired.

 *

 * We can setup a temperature representing the delta between the

 * threshold and the current temperature when the temperature is

 * decreasing.

 *

 * For instance: the lag register is 5°C, the threshold is 65°C, when

 * the temperature reaches 65°C an interrupt is raised and when the

 * temperature decrease to 65°C - 5°C another interrupt is raised.

 *

 * A very short lag can lead to an interrupt storm, a long lag

 * increase the latency to react to the temperature changes.  In our

 * case, that is not really a problem as we are polling the

 * temperature.

 *

 * [0:4] : lag register

 *

 * The temperature is coded in steps, cf. HI6220_TEMP_STEP.

 *

 * Min : 0x00 :  0.0 °C

 * Max : 0x1F : 24.3 °C

 *

 * The 'value' parameter is in milliCelsius.

/*

 * [0:6] lag register

 *

 * The temperature is coded in steps, cf. HI3660_TEMP_STEP.

 *

 * Min : 0x00 :  0.0 °C

 * Max : 0x7F : 26.0 °C

 *

/*

 * Temperature configuration register - Sensor selection

 *

 * Bits [19:12]

 *

 * 0x0: local sensor (default)

 * 0x1: remote sensor 1 (ACPU cluster 1)

 * 0x2: remote sensor 2 (ACPU cluster 0)

 * 0x3: remote sensor 3 (G3D)

/*

 * Temperature configuration register - Hdak conversion polling interval

 *

 * Bits [5:4]

 *

 * 0x0 :   0.768 ms

 * 0x1 :   6.144 ms

 * 0x2 :  49.152 ms

 * 0x3 : 393.216 ms

 disable sensor module */

 disable sensor module */

 enable clock for tsensor */

 disable module firstly */

 select sensor id */

 setting the hdak time */

 setting lag value between current temp and the threshold */

 enable for interrupt */

 enable module */

 disable interrupt */

 setting lag value between current temp and the threshold */

 set interrupt threshold */

 enable interrupt */

 end */ }

 SPDX-License-Identifier: GPL-2.0



 Copyright 2016 Freescale Semiconductor, Inc.

 Mode Register */

 Temperature measurement interval Register */

 monitor site register */

 Temperature measurement interval Register */

 Interrupt Enable Register */

 Temperature Configuration Register */

 Sensor Configuration Register */

#define REGS_TRITSR(n)	(0x100 + 16 * (n)) /* Immediate Temperature

					    * Site Register

#define REGS_V2_TMSAR(n)	(0x304 + 16 * (n))	/* TMU monitoring

						* site adjustment register

#define REGS_TTRnCR(n)	(0xf10 + 4 * (n)) /* Temperature Range n

					   * Control Register

#define REGS_IPBRR(n)		(0xbf8 + 4 * (n)) /* IP Block Revision

						   * Register n

/*

 * Thermal zone data

	/*

	 * REGS_TRITSR(id) has the following layout:

	 *

	 * For TMU Rev1:

	 * 31  ... 7 6 5 4 3 2 1 0

	 *  V          TEMP

	 *

	 * Where V bit signifies if the measurement is ready and is

	 * within sensor range. TEMP is an 8 bit value representing

	 * temperature in Celsius.



	 * For TMU Rev2:

	 * 31  ... 8 7 6 5 4 3 2 1 0

	 *  V          TEMP

	 *

	 * Where V bit signifies if the measurement is ready and is

	 * within sensor range. TEMP is an 9 bit value representing

	 * temperature in KelVin.

 Init temperature range registers */

 Disable interrupt, using polling instead */

 Set update_interval */

 Disable monitoring */

 Read only registers below */

 version register offset at: 0xbf8 on both v1 and v2 */

 TMU initialization */

 TMU calibration */

 Enable monitoring */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2014-2016, Fuzhou Rockchip Electronics Co., Ltd

 * Caesar Wang <wxt@rock-chips.com>

/*

 * If the temperature over a period of time High,

 * the resulting TSHUT gave CRU module,let it reset the entire chip,

 * or via GPIO give PMIC.

/*

 * The system Temperature Sensors tshut(tshut) polarity

 * the bit 8 is tshut polarity.

 * 0: low active, 1: high active

/*

 * The system has two Temperature Sensors.

 * sensor0 is for CPU, and sensor1 is for GPU.

/*

 * The conversion table has the adc value and temperature.

 * ADC_DECREMENT: the adc value is of diminishing.(e.g. rk3288_code_table)

 * ADC_INCREMENT: the adc value is incremental.(e.g. rk3368_code_table)

/**

 * The max sensors is two in rockchip SoCs.

 * Two sensors: CPU and GPU sensor.

/**

 * struct chip_tsadc_table - hold information about chip-specific differences

 * @id: conversion table

 * @length: size of conversion table

 * @data_mask: mask to apply on data inputs

 * @mode: sort mode of this adc variant (incrementing or decrementing)

/**

 * struct rockchip_tsadc_chip - hold the private data of tsadc chip

 * @chn_id: array of sensor ids of chip corresponding to the channel

 * @chn_num: the channel number of tsadc chip

 * @tshut_temp: the hardware-controlled shutdown temperature value

 * @tshut_mode: the hardware-controlled shutdown mode (0:CRU 1:GPIO)

 * @tshut_polarity: the hardware-controlled active polarity (0:LOW 1:HIGH)

 * @initialize: SoC special initialize tsadc controller method

 * @irq_ack: clear the interrupt

 * @control: enable/disable method for the tsadc controller

 * @get_temp: get the temperature

 * @set_alarm_temp: set the high temperature interrupt

 * @set_tshut_temp: set the hardware-controlled shutdown temperature

 * @set_tshut_mode: set the hardware-controlled shutdown mode

 * @table: the chip-specific conversion table

 The sensor id of chip correspond to the ADC channel */

 The hardware-controlled tshut property */

 Chip-wide methods */

 Per-sensor methods */

 Per-table methods */

/**

 * struct rockchip_thermal_sensor - hold the information of thermal sensor

 * @thermal:  pointer to the platform/configuration data

 * @tzd: pointer to a thermal zone

 * @id: identifier of the thermal sensor

/**

 * struct rockchip_thermal_data - hold the private data of thermal driver

 * @chip: pointer to the platform/configuration data

 * @pdev: platform device of thermal

 * @reset: the reset controller of tsadc

 * @sensors: array of thermal sensors

 * @clk: the controller clock is divided by the exteral 24MHz

 * @pclk: the advanced peripherals bus clock

 * @grf: the general register file will be used to do static set by software

 * @regs: the base address of tsadc controller

 * @tshut_temp: the hardware-controlled shutdown temperature value

 * @tshut_mode: the hardware-controlled shutdown mode (0:CRU 1:GPIO)

 * @tshut_polarity: the hardware-controlled active polarity (0:LOW 1:HIGH)

/**

 * TSADC Sensor Register description:

 *

 * TSADCV2_* are used for RK3288 SoCs, the other chips can reuse it.

 * TSADCV3_* are used for newer SoCs than RK3288. (e.g: RK3228, RK3399)

 *

 250ms */

 50ms */

 2.5ms */

 2.5ms */

 2.5ms */

 2.5ms */

 13 clocks */

 97us, at least 90us */

/**

 * struct tsadc_table - code to temperature conversion table

 * @code: the value of adc channel

 * @temp: the temperature

 * Note:

 * code to temperature mapping of the temperature sensor is a piece wise linear

 * curve.Any temperature, code faling between to 2 give temperatures can be

 * linearly interpolated.

 * Code to Temperature mapping should be updated based on manufacturer results.

 ignore the last check for table */

 Return mask code data when the temp is over table range */

	/*

	 * The conversion code granularity provided by the table. Let's

	 * assume that the relationship between temperature and

	 * analog value between 2 table entries is linear and interpolate

	 * to produce less granular result.

 Incorrect reading */

 Incorrect reading */

	/*

	 * The 5C granularity provided by the table is too much. Let's

	 * assume that the relationship between sensor readings and

	 * temperature between 2 table entries is linear and interpolate

	 * to produce less granular result.

/**

 * rk_tsadcv2_initialize - initialize TASDC Controller.

 * @grf: the general register file will be used to do static set by software

 * @regs: the base address of tsadc controller

 * @tshut_polarity: the hardware-controlled active polarity (0:LOW 1:HIGH)

 *

 * (1) Set TSADC_V2_AUTO_PERIOD:

 *     Configure the interleave between every two accessing of

 *     TSADC in normal operation.

 *

 * (2) Set TSADCV2_AUTO_PERIOD_HT:

 *     Configure the interleave between every two accessing of

 *     TSADC after the temperature is higher than COM_SHUT or COM_INT.

 *

 * (3) Set TSADCV2_HIGH_INT_DEBOUNCE and TSADC_HIGHT_TSHUT_DEBOUNCE:

 *     If the temperature is higher than COMP_INT or COMP_SHUT for

 *     "debounce" times, TSADC controller will generate interrupt or TSHUT.

/**

 * rk_tsadcv3_initialize - initialize TASDC Controller.

 * @grf: the general register file will be used to do static set by software

 * @regs: the base address of tsadc controller

 * @tshut_polarity: the hardware-controlled active polarity (0:LOW 1:HIGH)

 *

 * (1) The tsadc control power sequence.

 *

 * (2) Set TSADC_V2_AUTO_PERIOD:

 *     Configure the interleave between every two accessing of

 *     TSADC in normal operation.

 *

 * (2) Set TSADCV2_AUTO_PERIOD_HT:

 *     Configure the interleave between every two accessing of

 *     TSADC after the temperature is higher than COM_SHUT or COM_INT.

 *

 * (3) Set TSADCV2_HIGH_INT_DEBOUNCE and TSADC_HIGHT_TSHUT_DEBOUNCE:

 *     If the temperature is higher than COMP_INT or COMP_SHUT for

 *     "debounce" times, TSADC controller will generate interrupt or TSHUT.

 The tsadc control power sequence */

 Set interleave value to workround ic time sync issue */

 Enable the voltage common mode feature */

 The spec note says at least 15 us */

 The spec note says at least 90 us */

	/*

	 * The general register file will is optional

	 * and might not be available.

		/*

		 * RK3568 TRM, section 18.5. requires a delay no less

		 * than 10us between the rising edge of tsadc_tsen_en

		 * and the rising edge of tsadc_ana_reg_0/1/2.

		/*

		 * RK3568 TRM, section 18.5. requires a delay no less

		 * than 90us after the rising edge of tsadc_ana_reg_0/1/2.

/**

 * rk_tsadcv3_control - the tsadc controller is enabled or disabled.

 * @regs: the base address of tsadc controller

 * @enable: boolean flag to enable the controller

 *

 * NOTE: TSADC controller works at auto mode, and some SoCs need set the

 * tsadc_q_sel bit on TSADCV2_AUTO_CON[1]. The (1024 - tsadc_q) as output

 * adc value if setting this bit to enable.

	/*

	 * In some cases, some sensors didn't need the trip points, the

	 * set_trips will pass {-INT_MAX, INT_MAX} to trigger tsadc alarm

	 * in the end, ignore this case and disable the high temperature

	 * interrupt.

 Make sure the value is valid */

 Make sure the value is valid */

 TSHUT will be valid */

 cpu sensor is channel 0 */

 gpu sensor is channel 1 */

 2 channels for tsadc */

 default TSHUT via CRU */

 cpu sensor is channel 0 */

 one channel for tsadc */

 default TSHUT via GPIO give PMIC */

 default TSHUT LOW ACTIVE */

 cpu sensor is channel 0 */

 one channel for tsadc */

 default TSHUT via GPIO give PMIC */

 default TSHUT LOW ACTIVE */

 cpu sensor is channel 1 */

 gpu sensor is channel 2 */

 two channels for tsadc */

 default TSHUT via GPIO give PMIC */

 default TSHUT LOW ACTIVE */

 cpu sensor is channel 0 */

 one channels for tsadc */

 default TSHUT via CRU */

 cpu sensor is channel 0 */

 gpu sensor is channel 1 */

 two channels for tsadc */

 default TSHUT via GPIO give PMIC */

 default TSHUT LOW ACTIVE */

 cpu sensor is channel 0 */

 gpu sensor is channel 1 */

 two channels for tsadc */

 default TSHUT via GPIO give PMIC */

 default TSHUT LOW ACTIVE */

 cpu sensor is channel 0 */

 gpu sensor is channel 1 */

 two channels for tsadc */

 default TSHUT via GPIO give PMIC */

 default TSHUT LOW ACTIVE */

 cpu sensor is channel 0 */

 gpu sensor is channel 1 */

 two channels for tsadc */

 default TSHUT via GPIO give PMIC */

 default TSHUT LOW ACTIVE */

 end */ },

	/* The tsadc wont to handle the error in here since some SoCs didn't

	 * need this property.

/**

 * Reset TSADC Controller, reset all tsadc registers.

 * @reset: the reset controller of tsadc

 SPDX-License-Identifier: GPL-2.0

/**

 * uniphier_thermal.c - Socionext UniPhier thermal driver

 * Copyright 2014      Panasonic Corporation

 * Copyright 2016-2017 Socionext Inc.

 * Author:

 *	Kunihiko Hayashi <hayashi.kunihiko@socionext.com>

/*

 * block registers

 * addresses are the offset from .block_base

/*

 * common registers

 * addresses are the offset from .map_base

 SoC critical temperature */

 Max # of alert channels */

 SoC specific thermal sensor data */

 stop PVT */

	/*

	 * Since SoC has a calibrated value that was set in advance,

	 * TMODCOEF shows non-zero and PVT refers the value internally.

	 *

	 * If TMODCOEF shows zero, the boards don't have the calibrated

	 * value, and the driver has to set default value from DT.

 look for the default values in DT */

 select temperature mode */

 set monitoring period */

 set monitor mode */

 set alert temperature */

 enable alert interrupt */

 start PVT */

 The spec note says at least 700us */

 disable alert interrupt */

 stop PVT */

 The spec note says at least 1ms */

 MSB of the TMOD field is a sign bit */

 clear alert interrupt */

 get regmap from syscon node */

 parent should be syscon node */

 get trip points */

 set alert temperatures */

 disable sensor */

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Junction temperature thermal driver for Maxim Max77620.

 *

 * Copyright (c) 2016, NVIDIA CORPORATION.  All rights reserved.

 *

 * Author: Laxman Dewangan <ldewangan@nvidia.com>

 *	   Mallikarjun Kasoju <mkasoju@nvidia.com>

/**

 * max77620_thermal_read_temp: Read PMIC die temperatue.

 * @data:	Device specific data.

 * @temp:	Temperature in millidegrees Celsius

 *

 * The actual temperature of PMIC die is not available from PMIC.

 * PMIC only tells the status if it has crossed or not the threshold level

 * of 120degC or 140degC.

 * If threshold has not been crossed then assume die temperature as 100degC

 * else 120degC or 140deG based on the PMIC die temp threshold status.

 *

 * Return 0 on success otherwise error number to show reason of failure.

	/*

	 * The reference taken to the parent's node which will be balanced on

	 * reprobe or on platform-device release.

 SPDX-License-Identifier: GPL-2.0

/*

 * TI Bandgap temperature sensor driver for K3 SoC Family

 *

 * Copyright (C) 2020 Texas Instruments Incorporated - http://www.ti.com/

 common data structures */

	/*

	 * Errata is applicable for am654 pg 1.0 silicon. There

	 * is a variation of the order for 8-10 degree centigrade.

	 * Work around that by getting the average of two closest

	 * readings out of three readings everytime we want to

	 * report temperatures.

	 *

	 * Errata workaround.

 Get the sensor count in the VTM */

 Register the thermal sensors */

 sentinel */ },

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Dove thermal sensor driver

 *

 * Copyright (C) 2013 Andrew Lunn <andrew@lunn.ch>

 Dove Thermal Manager Control and Status Register */

 Dove Theraml Diode Control 0 Register */

 Dove Thermal Diode Control 1 Register */

 Dove Thermal Sensor Dev Structure */

 Configure the Diode Control Register #0 */

 Use average of 2 */

 Reference calibration value */

 Set the high level reference for calibration */

 Reset the sensor */

 Enable the sensor */

 Poll the sensor for the first reading */

 Valid check */

	/*

	 * Calculate temperature. According to Marvell internal

	 * documentation the formula for this is:

	 * Celsius = (322-reg)/1.3625

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  user_space.c - A simple user space Thermal events notifier

 *

 *  Copyright (C) 2012 Intel Corp

 *  Copyright (C) 2012 Durgadoss R <durgadoss.r@intel.com>

 *

 *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 *

 * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

/**

 * notify_user_space - Notifies user space about thermal events

 * @tz: thermal_zone_device

 * @trip: trip point index

 *

 * This function notifies the user space through UEvents.

 SPDX-License-Identifier: GPL-2.0

/*

 *  linux/drivers/thermal/cpufreq_cooling.c

 *

 *  Copyright (C) 2012	Samsung Electronics Co., Ltd(http://www.samsung.com)

 *

 *  Copyright (C) 2012-2018 Linaro Limited.

 *

 *  Authors:	Amit Daniel <amit.kachhap@linaro.org>

 *		Viresh Kumar <viresh.kumar@linaro.org>

 *

/*

 * Cooling state <-> CPUFreq frequency

 *

 * Cooling states are translated to frequencies throughout this driver and this

 * is the relation between them.

 *

 * Highest cooling state corresponds to lowest possible frequency.

 *

 * i.e.

 *	level 0 --> 1st Max Freq

 *	level 1 --> 2nd Max Freq

 *	...

/**

 * struct time_in_idle - Idle time stats

 * @time: previous reading of the absolute time that this cpu was idle

 * @timestamp: wall time of the last invocation of get_cpu_idle_time_us()

/**

 * struct cpufreq_cooling_device - data for cooling device with cpufreq

 * @last_load: load measured by the latest call to cpufreq_get_requested_power()

 * @cpufreq_state: integer value representing the current state of cpufreq

 *	cooling	devices.

 * @max_level: maximum cooling level. One less than total number of valid

 *	cpufreq frequencies.

 * @em: Reference on the Energy Model of the device

 * @cdev: thermal_cooling_device pointer to keep track of the

 *	registered cooling device.

 * @policy: cpufreq policy.

 * @idle_time: idle time stats

 * @qos_req: PM QoS contraint to apply

 *

 * This structure is required for keeping information of each registered

 * cpufreq_cooling_device.

/**

 * get_level: Find the level for a particular frequency

 * @cpufreq_cdev: cpufreq_cdev for which the property is required

 * @freq: Frequency

 *

 * Return: level corresponding to the frequency.

/**

 * get_load() - get load for a cpu

 * @cpufreq_cdev: struct cpufreq_cooling_device for the cpu

 * @cpu: cpu number

 * @cpu_idx: index of the cpu in time_in_idle array

 *

 * Return: The average load of cpu @cpu in percentage since this

 * function was last called.

 !CONFIG_SMP */

 CONFIG_SMP */

/**

 * get_dynamic_power() - calculate the dynamic power

 * @cpufreq_cdev:	&cpufreq_cooling_device for this cdev

 * @freq:	current frequency

 *

 * Return: the dynamic power consumed by the cpus described by

 * @cpufreq_cdev.

/**

 * cpufreq_get_requested_power() - get the current power

 * @cdev:	&thermal_cooling_device pointer

 * @power:	pointer in which to store the resulting power

 *

 * Calculate the current power consumption of the cpus in milliwatts

 * and store it in @power.  This function should actually calculate

 * the requested power, but it's hard to get the frequency that

 * cpufreq would have assigned if there were no thermal limits.

 * Instead, we calculate the current power on the assumption that the

 * immediate future will look like the immediate past.

 *

 * We use the current frequency and the average load since this

 * function was last called.  In reality, there could have been

 * multiple opps since this function was last called and that affects

 * the load calculation.  While it's not perfectly accurate, this

 * simplification is good enough and works.  REVISIT this, as more

 * complex code may be needed if experiments show that it's not

 * accurate enough.

 *

 * Return: 0 on success, -E* if getting the static power failed.

/**

 * cpufreq_state2power() - convert a cpu cdev state to power consumed

 * @cdev:	&thermal_cooling_device pointer

 * @state:	cooling device state to be converted

 * @power:	pointer in which to store the resulting power

 *

 * Convert cooling device state @state into power consumption in

 * milliwatts assuming 100% load.  Store the calculated power in

 * @power.

 *

 * Return: 0 on success, -EINVAL if the cooling device state could not

 * be converted into a frequency or other -E* if there was an error

 * when calculating the static power.

 Request state should be less than max_level */

/**

 * cpufreq_power2state() - convert power to a cooling device state

 * @cdev:	&thermal_cooling_device pointer

 * @power:	power in milliwatts to be converted

 * @state:	pointer in which to store the resulting state

 *

 * Calculate a cooling device state for the cpus described by @cdev

 * that would allow them to consume at most @power mW and store it in

 * @state.  Note that this calculation depends on external factors

 * such as the cpu load or the current static power.  Calling this

 * function with the same power as input can yield different cooling

 * device states depending on those external factors.

 *

 * Return: 0 on success, -ENODEV if no cpus are online or -EINVAL if

 * the calculated frequency could not be converted to a valid state.

 * The latter should not happen unless the frequencies available to

 * cpufreq have changed since the initialization of the cpu cooling

 * device.

 CONFIG_THERMAL_GOV_POWER_ALLOCATOR */

 CONFIG_SMP */

 Use the Energy Model table if available */

 Otherwise, fallback on the CPUFreq table */

 cpufreq cooling device callback functions are defined below */

/**

 * cpufreq_get_max_state - callback function to get the max cooling state.

 * @cdev: thermal cooling device pointer.

 * @state: fill this variable with the max cooling state.

 *

 * Callback for the thermal cooling device to return the cpufreq

 * max cooling state.

 *

 * Return: 0 on success, an error code otherwise.

/**

 * cpufreq_get_cur_state - callback function to get the current cooling state.

 * @cdev: thermal cooling device pointer.

 * @state: fill this variable with the current cooling state.

 *

 * Callback for the thermal cooling device to return the cpufreq

 * current cooling state.

 *

 * Return: 0 on success, an error code otherwise.

/**

 * cpufreq_set_cur_state - callback function to set the current cooling state.

 * @cdev: thermal cooling device pointer.

 * @state: set this variable to the current cooling state.

 *

 * Callback for the thermal cooling device to change the cpufreq

 * current cooling state.

 *

 * Return: 0 on success, an error code otherwise.

 Request state should be less than max_level */

 Check if the old cooling action is same as new cooling action */

 Bind cpufreq callbacks to thermal cooling device ops */

/**

 * __cpufreq_cooling_register - helper function to create cpufreq cooling device

 * @np: a valid struct device_node to the cooling device device tree node

 * @policy: cpufreq policy

 * Normally this should be same as cpufreq policy->related_cpus.

 * @em: Energy Model of the cpufreq policy

 *

 * This interface function registers the cpufreq cooling device with the name

 * "thermal-cpufreq-%x". This api can support multiple instances of cpufreq

 * cooling devices. It also gives the opportunity to link the cooling device

 * with a device tree node, in order to bind it via the thermal DT code.

 *

 * Return: a valid struct thermal_cooling_device pointer on success,

 * on failure, it returns a corresponding ERR_PTR().

 max_level is an index, not a counter */

/**

 * cpufreq_cooling_register - function to create cpufreq cooling device.

 * @policy: cpufreq policy

 *

 * This interface function registers the cpufreq cooling device with the name

 * "thermal-cpufreq-%x". This api can support multiple instances of cpufreq

 * cooling devices.

 *

 * Return: a valid struct thermal_cooling_device pointer on success,

 * on failure, it returns a corresponding ERR_PTR().

/**

 * of_cpufreq_cooling_register - function to create cpufreq cooling device.

 * @policy: cpufreq policy

 *

 * This interface function registers the cpufreq cooling device with the name

 * "thermal-cpufreq-%x". This api can support multiple instances of cpufreq

 * cooling devices. Using this API, the cpufreq cooling device will be

 * linked to the device tree node provided.

 *

 * Using this function, the cooling device will implement the power

 * extensions by using a simple cpu power model.  The cpus must have

 * registered their OPPs using the OPP library.

 *

 * It also takes into account, if property present in policy CPU node, the

 * static power consumed by the cpu.

 *

 * Return: a valid struct thermal_cooling_device pointer on success,

 * and NULL on failure.

/**

 * cpufreq_cooling_unregister - function to remove cpufreq cooling device.

 * @cdev: thermal cooling device pointer.

 *

 * This interface function unregisters the "thermal-cpufreq-%x" cooling device.

 SPDX-License-Identifier: GPL-2.0

/*

 *  thermal_helpers.c - helper functions to handle thermal devices

 *

 *  Copyright (C) 2016 Eduardo Valentin <edubezval@gmail.com>

 *

 *  Highly based on original thermal_core.c

 *  Copyright (C) 2008 Intel Corp

 *  Copyright (C) 2008 Zhang Rui <rui.zhang@intel.com>

 *  Copyright (C) 2008 Sujith Thomas <sujith.thomas@intel.com>

/**

 * thermal_zone_get_temp() - returns the temperature of a thermal zone

 * @tz: a valid pointer to a struct thermal_zone_device

 * @temp: a valid pointer to where to store the resulting temperature.

 *

 * When a valid thermal zone reference is passed, it will fetch its

 * temperature and fill @temp.

 *

 * Return: On success returns 0, an error code otherwise

		/*

		 * Only allow emulating a temperature when the real temperature

		 * is below the critical temperature so that the emulation code

		 * cannot hide critical conditions.

/**

 * thermal_zone_set_trips - Computes the next trip points for the driver

 * @tz: a pointer to a thermal zone device structure

 *

 * The function computes the next temperature boundaries by browsing

 * the trip points. The result is the closer low and high trip points

 * to the current temperature. These values are passed to the backend

 * driver to let it set its own notification mechanism (usually an

 * interrupt).

 *

 * It does not return a value

 No need to change trip points */

	/*

	 * Set a temperature window. When this window is left the driver

	 * must inform the thermal core via thermal_zone_device_update.

 Make sure cdev enters the deepest cooling state */

/**

 * thermal_cdev_update - update cooling device state if needed

 * @cdev:	pointer to struct thermal_cooling_device

 *

 * Update the cooling device state if there is a need.

/**

 * thermal_zone_get_slope - return the slope attribute of the thermal zone

 * @tz: thermal zone device with the slope attribute

 *

 * Return: If the thermal zone device has a slope attribute, return it, else

 * return 1.

/**

 * thermal_zone_get_offset - return the offset attribute of the thermal zone

 * @tz: thermal zone device with the offset attribute

 *

 * Return: If the thermal zone device has a offset attribute, return it, else

 * return 0.

 SPDX-License-Identifier: GPL-2.0

/*

 *  of-thermal.c - Generic Thermal Management device tree support.

 *

 *  Copyright (C) 2013 Texas Instruments

 *  Copyright (C) 2013 Eduardo Valentin <eduardo.valentin@ti.com>

**   Private data structures to represent thermal device tree data ***/

/**

 * struct __thermal_cooling_bind_param - a cooling device for a trip point

 * @cooling_device: a pointer to identify the referred cooling device

 * @min: minimum cooling state used at this trip point

 * @max: maximum cooling state used at this trip point

/**

 * struct __thermal_bind_param - a match between trip and cooling device

 * @tcbp: a pointer to an array of cooling devices

 * @count: number of elements in array

 * @trip_id: the trip point index

 * @usage: the percentage (from 0 to 100) of cooling contribution

/**

 * struct __thermal_zone - internal representation of a thermal zone

 * @passive_delay: polling interval while passive cooling is activated

 * @polling_delay: zone polling interval

 * @slope: slope of the temperature adjustment curve

 * @offset: offset of the temperature adjustment curve

 * @ntrips: number of trip points

 * @trips: an array of trip points (0..ntrips - 1)

 * @num_tbps: number of thermal bind params

 * @tbps: an array of thermal bind params (0..num_tbps - 1)

 * @sensor_data: sensor private data used while reading temperature and trend

 * @ops: set of callbacks to handle the thermal zone based on DT

 trip data */

 cooling binding data */

 sensor interface */

**   DT thermal zone device callbacks   ***/

/**

 * of_thermal_get_ntrips - function to export number of available trip

 *			   points.

 * @tz: pointer to a thermal zone

 *

 * This function is a globally visible wrapper to get number of trip points

 * stored in the local struct __thermal_zone

 *

 * Return: number of available trip points, -ENODEV when data not available

/**

 * of_thermal_is_trip_valid - function to check if trip point is valid

 *

 * @tz:	pointer to a thermal zone

 * @trip:	trip point to evaluate

 *

 * This function is responsible for checking if passed trip point is valid

 *

 * Return: true if trip point is valid, false otherwise

/**

 * of_thermal_get_trip_points - function to get access to a globally exported

 *				trip points

 *

 * @tz:	pointer to a thermal zone

 *

 * This function provides a pointer to trip points table

 *

 * Return: pointer to trip points table, NULL otherwise

/**

 * of_thermal_set_emul_temp - function to set emulated temperature

 *

 * @tz:	pointer to a thermal zone

 * @temp:	temperature to set

 *

 * This function gives the ability to set emulated value of temperature,

 * which is handy for debugging

 *

 * Return: zero on success, error code otherwise

 find where to bind */

 find where to unbind */

 thermal framework should take care of data->mask & (1 << trip) */

 thermal framework should take care of data->mask & (1 << trip) */

**   sensor API   ***/

	/*

	 * The thermal zone core will calculate the window if they have set the

	 * optional set_trips pointer.

/**

 * thermal_zone_of_get_sensor_id - get sensor ID from a DT thermal zone

 * @tz_np: a valid thermal zone device node.

 * @sensor_np: a sensor node of a valid sensor device.

 * @id: the sensor ID returned if success.

 *

 * This function will get sensor ID from a given thermal zone node and

 * the sensor node must match the temperature provider @sensor_np.

 *

 * Return: 0 on success, proper error code otherwise.

/**

 * thermal_zone_of_sensor_register - registers a sensor to a DT thermal zone

 * @dev: a valid struct device pointer of a sensor device. Must contain

 *       a valid .of_node, for the sensor node.

 * @sensor_id: a sensor identifier, in case the sensor IP has more

 *             than one sensors

 * @data: a private pointer (owned by the caller) that will be passed

 *        back, when a temperature reading is needed.

 * @ops: struct thermal_zone_of_device_ops *. Must contain at least .get_temp.

 *

 * This function will search the list of thermal zones described in device

 * tree and look for the zone that refer to the sensor device pointed by

 * @dev->of_node as temperature providers. For the zone pointing to the

 * sensor node, the sensor will be added to the DT thermal zone device.

 *

 * The thermal zone temperature is provided by the @get_temp function

 * pointer. When called, it will have the private pointer @data back.

 *

 * The thermal zone temperature trend is provided by the @get_trend function

 * pointer. When called, it will have the private pointer @data back.

 *

 * TODO:

 * 01 - This function must enqueue the new sensor instead of using

 * it as the only source of temperature values.

 *

 * 02 - There must be a way to match the sensor with all thermal zones

 * that refer to it.

 *

 * Return: On success returns a valid struct thermal_zone_device,

 * otherwise, it returns a corresponding ERR_PTR(). Caller must

 * check the return value with help of IS_ERR() helper.

 For now, thermal framework supports only 1 sensor per zone */

/**

 * thermal_zone_of_sensor_unregister - unregisters a sensor from a DT thermal zone

 * @dev: a valid struct device pointer of a sensor device. Must contain

 *       a valid .of_node, for the sensor node.

 * @tzd: a pointer to struct thermal_zone_device where the sensor is registered.

 *

 * This function removes the sensor callbacks and private data from the

 * thermal zone device registered with thermal_zone_of_sensor_register()

 * API. It will also silent the zone by remove the .get_temp() and .get_trend()

 * thermal zone device callbacks.

 *

 * TODO: When the support to several sensors per zone is added, this

 * function must search the sensor list based on @dev parameter.

 *

 no __thermal_zone, nothing to be done */

 stop temperature polling */

/**

 * devm_thermal_zone_of_sensor_register - Resource managed version of

 *				thermal_zone_of_sensor_register()

 * @dev: a valid struct device pointer of a sensor device. Must contain

 *       a valid .of_node, for the sensor node.

 * @sensor_id: a sensor identifier, in case the sensor IP has more

 *	       than one sensors

 * @data: a private pointer (owned by the caller) that will be passed

 *	  back, when a temperature reading is needed.

 * @ops: struct thermal_zone_of_device_ops *. Must contain at least .get_temp.

 *

 * Refer thermal_zone_of_sensor_register() for more details.

 *

 * Return: On success returns a valid struct thermal_zone_device,

 * otherwise, it returns a corresponding ERR_PTR(). Caller must

 * check the return value with help of IS_ERR() helper.

 * Registered thermal_zone_device device will automatically be

 * released when device is unbounded.

/**

 * devm_thermal_zone_of_sensor_unregister - Resource managed version of

 *				thermal_zone_of_sensor_unregister().

 * @dev: Device for which which resource was allocated.

 * @tzd: a pointer to struct thermal_zone_device where the sensor is registered.

 *

 * This function removes the sensor callbacks and private data from the

 * thermal zone device registered with devm_thermal_zone_of_sensor_register()

 * API. It will also silent the zone by remove the .get_temp() and .get_trend()

 * thermal zone device callbacks.

 * Normally this function will not need to be called and the resource

 * management code will ensure that the resource is freed.

**   functions parsing device tree nodes   ***/

/**

 * thermal_of_populate_bind_params - parse and fill cooling map data

 * @np: DT node containing a cooling-map node

 * @__tbp: data structure to be filled with cooling map info

 * @trips: array of thermal zone trip points

 * @ntrips: number of trip points inside trips.

 *

 * This function parses a cooling-map type of node represented by

 * @np parameter and fills the read data into @__tbp data structure.

 * It needs the already parsed array of trip points of the thermal zone

 * in consideration.

 *

 * Return: 0 on success, proper error code otherwise

 Default weight. Usage is optional */

 match using device_node */

 at least min and max */

/*

 * It maps 'enum thermal_trip_type' found in include/linux/thermal.h

 * into the device tree binding of 'trip', property type.

/**

 * thermal_of_get_trip_type - Get phy mode for given device_node

 * @np:	Pointer to the given device_node

 * @type: Pointer to resulting trip type

 *

 * The function gets trip type string from property 'type',

 * and store its index in trip_types table in @type,

 *

 * Return: 0 on success, or errno in error case.

/**

 * thermal_of_populate_trip - parse and fill one trip point data

 * @np: DT node containing a trip point node

 * @trip: trip point data structure to be filled up

 *

 * This function parses a trip point type of node represented by

 * @np parameter and fills the read data into @trip data structure.

 *

 * Return: 0 on success, proper error code otherwise

 Required for cooling map matching */

/**

 * thermal_of_build_thermal_zone - parse and fill one thermal zone data

 * @np: DT node containing a thermal zone node

 *

 * This function parses a thermal zone type of node represented by

 * @np parameter and fills the read data into a __thermal_zone data structure

 * and return this pointer.

 *

 * TODO: Missing properties to parse: thermal-sensor-names

 *

 * Return: On success returns a valid struct __thermal_zone,

 * otherwise, it returns a corresponding ERR_PTR(). Caller must

 * check the return value with help of IS_ERR() helper.

	/*

	 * REVIST: for now, the thermal framework supports only

	 * one sensor per thermal zone. Thus, we are considering

	 * only the first two values as slope and offset.

 trips */

 No trips provided */

 must have at least one child */

 cooling-maps */

 cooling-maps not provided */

/**

 * of_thermal_destroy_zones - remove all zones parsed and allocated resources

 *

 * Finds all zones parsed and added to the thermal framework and remove them

 * from the system, together with their resources.

 *

/**

 * of_parse_thermal_zones - parse device tree thermal data

 *

 * Initialization function that can be called by machine initialization

 * code to parse thermal data and populate the thermal framework

 * with hardware thermal zones info. This function only parses thermal zones.

 * Cooling devices and sensor devices nodes are supposed to be parsed

 * by their respective drivers.

 *

 * Return: 0 on success, proper error code otherwise

 *

 Run successfully on systems without thermal DT */

 No hwmon because there might be hwmon drivers registering */

 these two are left for temperature drivers to use */

 attempting to build remaining zones still */

 no memory available, so free what we have built */

 SPDX-License-Identifier: GPL-2.0+

/*

 * Copyright 2018-2020 NXP.

 SPDX-License-Identifier: GPL-2.0+

/*

 * Broadcom AVS RO thermal sensor driver

 *

 * based on brcmstb_thermal

 *

 * Copyright (C) 2020 Stefan Wahren

 Convert a HW code to a temperature reading (millidegree celsius) */

 get regmap from syscon node */

 parent should be syscon node */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Broadcom STB AVS TMON thermal sensor driver

 *

 * Copyright (c) 2015-2017 Broadcom

 Default coefficients */

 HW related temperature constants */

 HW bit to enable the trip */

 HW field to read the trip temperature */

 Trips when temperature is below threshold */

 Trips when temperature is above threshold */

 Automatically resets chip when above threshold */

 Process specific thermal parameters used for calculations */

 Convert a HW code to a temperature reading (millidegree celsius) */

/*

 * Convert a temperature value (millidegree celsius) to a HW code

 *

 * @temp: temperature to convert

 * @low: if true, round toward the low side

 Maximum code value */

 Minimum code value */

 round toward low temp for the low interrupt */

 Disable high-temp until next threshold shift */

 Disable low-temp until next threshold shift */

	/*

	 * Notify using the interrupt temperature, in case the temperature

	 * changes before it can next be read out

	/*

	 * Disable low-temp if "low" is too small. As per thermal framework

	 * API, we use -INT_MAX rather than INT_MIN.

 Disable high-temp if "high" is too big. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2017 Rafał Miłecki <rafal@milecki.pl>

 Clear current mode selection */

 Set temp monitor mode (it's the default actually) */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2018 Broadcom

/*

 * In stingray thermal IO memory,

 * Total Number of available TMONs MASK is at offset 0

 * temperature registers BASE is at 4 byte offset.

 * Each TMON temperature register size is 4.

 Flush temperature registers */

 SPDX-License-Identifier: GPL-2.0+

/*

 * Driver for Broadcom BCM2835 SoC temperature sensor

 *

 * Copyright (C) 2016 Martin Sperl

/*

 * bandgap reference voltage in 6 mV increments

 * 000b = 1178 mV, 001b = 1184 mV, ... 111b = 1220 mV

/*

 * time how long the block to be asserted in reset

 * which based on a clock counter (TSENS clock assumed)

/*

 * Note: as per Raspberry Foundation FAQ

 * (https://www.raspberrypi.org/help/faqs/#performanceOperatingTemperature)

 * the recommended temperature range for the SoC -40C to +85C

 * so the trip limit is set to 80C.

 * this applies to all the BCM283X SoC

 register of thermal sensor and get info from DT */

	/*

	 * right now the FW does set up the HW-block, so we are not

	 * touching the configuration registers.

	 * But if the HW is not enabled, then set it up

	 * using "sane" values used by the firmware right now.

		/*

		 * For now we deal only with critical, otherwise

		 * would need to iterate

 set bandgap reference voltage and enable voltage regulator */

 use the recommended reset duration */

  trip_adc value from info */

 write the value back to the register as 2 steps */

	/*

	 * Thermal_zone doesn't enable hwmon as default,

	 * enable it here

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2015, The Linux Foundation. All rights reserved.

 * Copyright (c) 2018, Linaro Limited

 ----- SROT ------ */

 ----- TM ------ */

 v2.x: 8996, 8998, sdm845 */

 ----- SROT ------ */

 VERSION */

 CTRL_OFF */

 ----- TM ------ */

 INTERRUPT ENABLE */

 v2 has separate enables for UPPER/LOWER/CRITICAL interrupts */

 TEMPERATURE THRESHOLDS */

 INTERRUPTS [CLEAR/STATUS/MASK] */

 WATCHDOG on v2.3 or later */

 Sn_STATUS */

 xxx_STATUS bits: 1 == threshold violated */

 TRDY: 1=ready, 0=in progress */

 Kept around for backward compatibility with old msm8996.dtsi */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2015, The Linux Foundation. All rights reserved.

 ----- SROT ------ */

 ----- TM ------ */

 eeprom layout data for 8916 */

 eeprom layout data for 8939 */

 eeprom layout data for 8974 */

 eeprom layout data for mdm9607 */

 Mapping between qfprom nvmem and calibration data */

 v0.1: 8916, 8939, 8974, 9607 */

 ----- SROT ------ */

 No VERSION information */

 CTRL_OFFSET */

 ----- TM ------ */

 INTERRUPT ENABLE */

 UPPER/LOWER TEMPERATURE THRESHOLDS */

 UPPER/LOWER INTERRUPTS [CLEAR/STATUS] */

 NO CRITICAL INTERRUPT SUPPORT on v0.1 */

 Sn_STATUS */

 No VALID field on v0.1 */

 xxx_STATUS bits: 1 == threshold violated */

 No CRITICAL field on v0.1 */

 TRDY: 1=ready, 0=in progress */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2015, The Linux Foundation. All rights reserved.

 * Copyright (c) 2019, 2020, Linaro Ltd.

/**

 * struct tsens_irq_data - IRQ status and temperature violations

 * @up_viol:        upper threshold violated

 * @up_thresh:      upper threshold temperature value

 * @up_irq_mask:    mask register for upper threshold irqs

 * @up_irq_clear:   clear register for uppper threshold irqs

 * @low_viol:       lower threshold violated

 * @low_thresh:     lower threshold temperature value

 * @low_irq_mask:   mask register for lower threshold irqs

 * @low_irq_clear:  clear register for lower threshold irqs

 * @crit_viol:      critical threshold violated

 * @crit_thresh:    critical threshold temperature value

 * @crit_irq_mask:  mask register for critical threshold irqs

 * @crit_irq_clear: clear register for critical threshold irqs

 *

 * Structure containing data about temperature threshold settings and

 * irq status if they were violated.

/*

 * Use this function on devices where slope and offset calculations

 * depend on calibration data read from qfprom. On others the slope

 * and offset values are derived from tz->tzp->slope and tz->tzp->offset

 * resp.

			/*

			 * slope (m) = adc_code2 - adc_code1 (y2 - y1)/

			 *	temp_120_degc - temp_30_degc (x2 - x1)

/**

 * tsens_hw_to_mC - Return sign-extended temperature in mCelsius.

 * @s:     Pointer to sensor struct

 * @field: Index into regmap_field array pointing to temperature data

 *

 * This function handles temperature returned in ADC code or deciCelsius

 * depending on IP version.

 *

 * Return: Temperature in milliCelsius on success, a negative errno will

 * be returned in error cases

 Convert temperature from ADC code to milliCelsius */

 deciCelsius -> milliCelsius along with sign extension */

/**

 * tsens_mC_to_hw - Convert temperature to hardware register value

 * @s: Pointer to sensor struct

 * @temp: temperature in milliCelsius to be programmed to hardware

 *

 * This function outputs the value to be written to hardware in ADC code

 * or deciCelsius depending on IP version.

 *

 * Return: ADC code or temperature in deciCelsius.

 milliC to adc code */

 milliC to deciC */

 No critical interrupts before v2 */

	/*

	 * To enable the interrupt flag for a sensor:

	 *    - clear the mask bit

	 * To disable the interrupt flag for a sensor:

	 *    - Mask further interrupts for this sensor

	 *    - Write 1 followed by 0 to clear the interrupt

/**

 * tsens_set_interrupt - Set state of an interrupt

 * @priv: Pointer to tsens controller private data

 * @hw_id: Hardware ID aka. sensor number

 * @irq_type: irq_type from enum tsens_irq_type

 * @enable: false = disable, true = enable

 *

 * Call IP-specific function to set state of an interrupt

 *

 * Return: void

/**

 * tsens_threshold_violated - Check if a sensor temperature violated a preset threshold

 * @priv: Pointer to tsens controller private data

 * @hw_id: Hardware ID aka. sensor number

 * @d: Pointer to irq state data

 *

 * Return: 0 if threshold was not violated, 1 if it was violated and negative

 * errno in case of errors

 No mask register on older TSENS */

 v1, v0.1 don't have a irq mask register */

/**

 * tsens_critical_irq_thread() - Threaded handler for critical interrupts

 * @irq: irq number

 * @data: tsens controller private data

 *

 * Check FSM watchdog bark status and clear if needed.

 * Check all sensors to find ones that violated their critical threshold limits.

 * Clear and then re-enable the interrupt.

 *

 * The level-triggered interrupt might deassert if the temperature returned to

 * within the threshold limits by the time the handler got scheduled. We

 * consider the irq to have been handled in that case.

 *

 * Return: IRQ_HANDLED

 Clear WDOG interrupt */

 Fall through to handle critical interrupts if any */

 Mask critical interrupts, unused on Linux */

/**

 * tsens_irq_thread - Threaded interrupt handler for uplow interrupts

 * @irq: irq number

 * @data: tsens controller private data

 *

 * Check all sensors to find ones that violated their threshold limits. If the

 * temperature is still outside the limits, call thermal_zone_device_update() to

 * update the thresholds, else re-enable the interrupts.

 *

 * The level-triggered interrupt might deassert if the temperature returned to

 * within the threshold limits by the time the handler got scheduled. We

 * consider the irq to have been handled in that case.

 *

 * Return: IRQ_HANDLED

 Keep irq masked */

 Keep irq masked */

			/* Constraint: There is only 1 interrupt control register for all

			 * 11 temperature sensor. So monitoring more than 1 sensor based

			 * on interrupts will yield inconsistent result. To overcome this

			 * issue we will monitor only sensor 0 which is the master sensor.

		/* Pre v0.1 IP had a single register for each type of interrupt

		 * and thresholds

 Write the new thresholds and clear the status */

 VER_0 doesn't have VALID bit */

	/* Valid bit is 0 for 6 AHB clock cycles.

	 * At 19.2MHz, 1 AHB clock is ~60ns.

	 * We should enter this loop very, very rarely.

	 * Wait 1 us since it's the min of poll_timeout macro.

	 * Old value was 400 ns.

 Valid bit is set, OK to read the temperature */

 A directory for each instance of the TSENS IP */

 DT with separate SROT and TM address space */

 old DTs where SROT and TM were in a contiguous 2K block */

 VER_0 share the same gcc regs using a syscon */

 VER_0 have only tm_map */

 in VER_0 TSENS need to be explicitly enabled */

 This loop might need changes if enum regfield_ids is reordered */

 Loop might need changes if enum regfield_ids is reordered */

 Watchdog is present only on v2.3+ */

		/*

		 * Watchdog is already enabled, unmask the bark.

		 * Disable cycle completion monitoring

 VER_0 interrupt doesn't need to be enabled */

 For old DTs with no IRQ defined */

 VER_0 interrupt is TRIGGER_RISING, VER_0_1 and up is ONESHOT */

	/* VER_0 require to set MIN and MAX THRESH

	 * These 2 regs are set using the:

	 * - CRIT_THRESH_0 for MAX THRESH hardcoded to 120°C

	 * - CRIT_THRESH_1 for MIN THRESH hardcoded to   0°C

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2019, Linaro Limited

 ----- SROT ------ */

 ----- TM ------ */

 eeprom layout data for msm8956/76 (v1) */

 eeprom layout data for qcs404/405 (v1) */

 This value is split over two registers, 2 bits and 4 bits */

 This value is split over two registers, 2 bits and 4 bits */

 v1.x: msm8956,8976,qcs404,405 */

 ----- SROT ------ */

 VERSION */

 CTRL_OFFSET */

 ----- TM ------ */

 INTERRUPT ENABLE */

 UPPER/LOWER TEMPERATURE THRESHOLDS */

 UPPER/LOWER INTERRUPTS [CLEAR/STATUS] */

 NO CRITICAL INTERRUPT SUPPORT on v1 */

 Sn_STATUS */

 xxx_STATUS bits: 1 == threshold violated */

 No CRITICAL field on v1.x */

 TRDY: 1=ready, 0=in progress */

 Valid for both MSM8956 and MSM8976. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2020 Linaro Limited

 *

 * Based on original driver:

 * Copyright (c) 2012-2020, The Linux Foundation. All rights reserved.

/*

 * Thermal monitoring block consists of 8 (ADC_TM5_NUM_CHANNELS) channels. Each

 * channel is programmed to use one of ADC channels for voltage comparison.

 * Voltages are programmed using ADC codes, so we have to convert temp to

 * voltage and then to ADC code value.

 *

 * Configuration of TM channels must match configuration of corresponding ADC

 * channels.

 3.9ms */

 1 second */

 4 second */

/**

 * struct adc_tm5_channel - ADC Thermal Monitoring channel data.

 * @channel: channel number.

 * @adc_channel: corresponding ADC channel number.

 * @cal_method: calibration method.

 * @prescale: channel scaling performed on the input signal.

 * @hw_settle_time: the time between AMUX being configured and the

 *	start of conversion.

 * @iio: IIO channel instance used by this channel.

 * @chip: ADC TM chip instance.

 * @tzd: thermal zone device used by this channel.

/**

 * struct adc_tm5_chip - ADC Thermal Monitoring properties

 * @regmap: SPMI ADC5 Thermal Monitoring  peripheral register map field.

 * @dev: SPMI ADC5 device.

 * @data: software configuration data.

 * @channels: array of ADC TM channel data.

 * @nchannels: amount of channels defined/allocated

 * @decimation: sampling rate supported for the channel.

 * @avg_samples: ability to provide single result from the ADC

 *	that is an average of multiple measurements.

 * @base: base address of TM registers.

 No TZD, we warned at the boot time */

 High temperature corresponds to low voltage threshold */

 Low temperature corresponds to high voltage threshold */

 Set calibration select, hw_settle delay */

	/*

	 * We are tied to PMIC's ADC controller, which always use single

	 * argument for channel number.  So don't bother parsing

	 * #io-channel-cells, just enforce cell_count = 1.

 1:1 prescale is index 0 */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2015, The Linux Foundation. All rights reserved.

 CONFIG_ADDR bitmasks */

 CNTL_ADDR bitmasks */

 Sensors 5-10 found on apq8064/msm8960 */

 Original slope - 350 to compensate mC to C inaccuracy */

	/*

	 * Separate CONFIG restore is not needed only for 8660 as

	 * config is part of CTRL Addr and its restored as such

	/* HARDWARE BUG:

	 * On platforms with more than 6 sensors, all remaining sensors

	 * must be enabled together, otherwise undefined results are expected.

	 * (Sensor 6-7 disabled, Sensor 3 disabled...) In the original driver,

	 * all the sensors are enabled in one step hence this bug is not

	 * triggered.

 Sensors already enabled. Skip. */

 ----- SROT ------ */

 No VERSION information */

 CNTL */

 8960 has 5 sensors, 8660 has 11, we only handle 5 */

 ----- TM ------ */

 INTERRUPT ENABLE */

 NO INTERRUPT ENABLE */

 Single UPPER/LOWER TEMPERATURE THRESHOLD for all sensors */

	/* MIN_THRESH_0 and MAX_THRESH_0 are not present in the regfield

	 * Recycle CRIT_THRESH_0 and 1 to set the required regs to hardcoded temp

	 * MIN_THRESH_0 -> CRIT_THRESH_1

	 * MAX_THRESH_0 -> CRIT_THRESH_0

 UPPER/LOWER INTERRUPT [CLEAR/STATUS] */

 1 == clear, 0 == normal operation */

 NO CRITICAL INTERRUPT SUPPORT on 8960 */

 Sn_STATUS */

 No VALID field on 8960 */

 TSENS_INT_STATUS bits: 1 == threshold violated */

 No CRITICAL field on 8960 */

 TRDY: 1=ready, 0=in progress */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2021, Linaro Limited. All rights reserved.

 Call the cpufreq driver to handle the interrupt */

 Clear the existing interrupt */

	/*

	 * Only sdm845 has lmh hardware currently enabled from hlos. If this is needed

	 * for other platforms, revisit this to check if the <cpu-id, node-id> should be part

	 * of a dt match table.

 Set default thermal trips */

 Disable the irq and let cpufreq enable it when ready to handle the interrupt */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2011-2015, 2017, 2020, The Linux Foundation. All rights reserved.

 Over-temperature trip point values in mC */

 Threshold step: 5 C */

 Temperature in Milli Celsius reported during stage 0 if no ADC is present */

 protects .thresh, .stage and chip registers */

 This array maps from GEN2 alarm state to GEN1 alarm stage */

/**

 * qpnp_tm_decode_temp() - return temperature in mC corresponding to the

 *		specified over-temperature stage

 * @chip:		Pointer to the qpnp_tm chip

 * @stage:		Over-temperature stage

 *

 * Return: temperature in mC

/**

 * qpnp_tm_get_temp_stage() - return over-temperature stage

 * @chip:		Pointer to the qpnp_tm chip

 *

 * Return: stage (GEN1) or state (GEN2) on success, or errno on failure.

/*

 * This function updates the internal temp value based on the

 * current thermal stage and threshold as well as the previous stage

 increasing stage, use lower bound */

 decreasing stage, use upper bound */

	/*

	 * Default: S2 and S3 shutdown enabled, thresholds at

	 * lowest threshold set, monitoring at 25Hz

/*

 * This function initializes the internal temp value based on only the

 * current thermal stage and threshold. Setup threshold control and

 * disable shutdown override.

 Enable the thermal alarm PMIC module in always-on mode. */

 ADC based measurements are optional */

	/*

	 * Register the sensor before initializing the hardware to be able to

	 * read the trip points. get_temp() returns the default temperature

	 * before the hardware initialization is completed.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * exynos_tmu.c - Samsung Exynos TMU (Thermal Management Unit)

 *

 *  Copyright (C) 2014 Samsung Electronics

 *  Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>

 *  Lukasz Majewski <l.majewski@samsung.com>

 *

 *  Copyright (C) 2011 Samsung Electronics

 *  Donggeun Kim <dg77.kim@samsung.com>

 *  Amit Daniel Kachhap <amit.kachhap@linaro.org>

 Exynos generic registers */

 Exynos3250 specific registers */

 Exynos4210 specific registers */

 Exynos5250, Exynos4412, Exynos3250 specific registers */

 Exynos5260 specific */

 Exynos4412 specific */

 Exynos5433 specific registers */

 Exynos7 specific registers */

/**

 * struct exynos_tmu_data : A structure to hold the private data of the TMU

 *			    driver

 * @id: identifier of the one instance of the TMU controller.

 * @base: base address of the single instance of the TMU controller.

 * @base_second: base address of the common registers of the TMU controller.

 * @irq: irq number of the TMU controller.

 * @soc: id of the SOC type.

 * @irq_work: pointer to the irq work structure.

 * @lock: lock to implement synchronization.

 * @clk: pointer to the clock structure.

 * @clk_sec: pointer to the clock structure for accessing the base_second.

 * @sclk: pointer to the clock structure for accessing the tmu special clk.

 * @cal_type: calibration type for temperature

 * @efuse_value: SoC defined fuse value

 * @min_efuse_value: minimum valid trimming data

 * @max_efuse_value: maximum valid trimming data

 * @temp_error1: fused value of the first point trim.

 * @temp_error2: fused value of the second point trim.

 * @gain: gain of amplifier in the positive-TC generator block

 *	0 < gain <= 15

 * @reference_voltage: reference voltage of amplifier

 *	in the positive-TC generator block

 *	0 < reference_voltage <= 31

 * @regulator: pointer to the TMU regulator structure.

 * @reg_conf: pointer to structure to register with core thermal.

 * @tzd: pointer to thermal_zone_device structure

 * @ntrip: number of supported trip points.

 * @enabled: current status of TMU device

 * @tmu_set_trip_temp: SoC specific method to set trip (rising threshold)

 * @tmu_set_trip_hyst: SoC specific to set hysteresis (falling threshold)

 * @tmu_initialize: SoC specific TMU initialization method

 * @tmu_control: SoC specific TMU control method

 * @tmu_read: SoC specific TMU temperature read method

 * @tmu_set_emulation: SoC specific TMU emulation setting method

 * @tmu_clear_irqs: SoC specific TMU interrupts clearing method

/*

 * TMU treats temperature as a mapped temperature code.

 * The temperature is converted differently depending on the calibration type.

/*

 * Calculate a temperature value from a temperature code.

 * The unit of the temperature is degree Celsius.

 FIXME */

 Write temperature code for rising and falling threshold */

 Write temperature code for rising threshold */

 Write temperature code for falling threshold */

 failing thresholds are not supported on Exynos4210 */

 On exynos5420 the triminfo register is in the shared space */

 Read the temperature sensor id */

 Read the calibration mode */

		/*

		 * Called too early, probably

		 * from thermal_zone_of_sensor_register().

 CONFIG_THERMAL_EMULATION */

 "temp_code" should range between 75 and 175 */

 TODO: take action based on particular interrupt */

	/*

	 * Clear the interrupts.  Please note that the documentation for

	 * Exynos3250, Exynos4412, Exynos5250 and Exynos5260 incorrectly

	 * states that INTCLEAR register has a different placing of bits

	 * responsible for FALL IRQs than INTSTAT register.  Exynos5420

	 * and Exynos5440 documentation is correct (Exynos4210 doesn't

	 * support FALL IRQs at all).

	/*

	 * Check if the TMU shares some registers and then try to map the

	 * memory of common registers.

	/*

	 * Try enabling the regulator if found

	 * TODO: Add regulator as an SOC feature, so that regulator enable

	 * is a compulsory call.

	/*

	 * data->tzd must be registered before calling exynos_tmu_initialize(),

	 * requesting irq and calling exynos_tmu_control().

 SPDX-License-Identifier: GPL-2.0-only

/*

 * OMAP4 thermal driver.

 *

 * Copyright (C) 2011-2012 Texas Instruments Inc.

 * Contact:

 *	Eduardo Valentin <eduardo.valentin@ti.com>

/*

 * OMAP4430 has one instance of thermal sensor for MPU

 * need to describe the individual bit fields

 Thresholds and limits for OMAP4430 MPU temperature sensor */

/*

 * Temperature values in milli degree celsius

 * ADC code values from 13 to 107, see TRM

 * "18.4.10.2.3 ADC Codes Versus Temperature".

 OMAP4430 data */

/*

 * OMAP4460 has one instance of thermal sensor for MPU

 * need to describe the individual bit fields

 Thresholds and limits for OMAP4460 MPU temperature sensor */

/*

 * Temperature values in milli degree celsius

 * ADC code values from 530 to 923

 OMAP4460 data */

 OMAP4470 data */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * DRA752 thermal data.

 *

 * Copyright (C) 2013 Texas Instruments Inc.

 * Contact:

 *	Eduardo Valentin <eduardo.valentin@ti.com>

 *	Tero Kristo <t-kristo@ti.com>

 *

 * This file is partially autogenerated.

/*

 * DRA752 has five instances of thermal sensor: MPU, GPU, CORE,

 * IVA and DSPEVE need to describe the individual registers and

 * bit fields.

/*

 * DRA752 CORE thermal sensor register offsets and bit-fields

/*

 * DRA752 IVA thermal sensor register offsets and bit-fields

/*

 * DRA752 MPU thermal sensor register offsets and bit-fields

/*

 * DRA752 DSPEVE thermal sensor register offsets and bit-fields

/*

 * DRA752 GPU thermal sensor register offsets and bit-fields

 Thresholds and limits for DRA752 MPU temperature sensor */

 Thresholds and limits for DRA752 GPU temperature sensor */

 Thresholds and limits for DRA752 CORE temperature sensor */

 Thresholds and limits for DRA752 DSPEVE temperature sensor */

 Thresholds and limits for DRA752 IVA temperature sensor */

/*

 * DRA752 : Temperature values in milli degree celsius

 * ADC code values from 540 to 945

 Index 540 - 549 */

 Index 550 - 559 */

 Index 560 - 569 */

 Index 570 - 579 */

 Index 580 - 589 */

 Index 590 - 599 */

 Index 600 - 609 */

 Index 610 - 619 */

 Index 620 - 629 */

 Index 630 - 639 */

 Index 640 - 649 */

 Index 650 - 659 */

 Index 660 - 669 */

 Index 670 - 679 */

 Index 680 - 689 */

 Index 690 - 699 */

 Index 700 - 709 */

 Index 710 - 719 */

 Index 720 - 729 */

 Index 730 - 739 */

 Index 740 - 749 */

 Index 750 - 759 */

 Index 760 - 769 */

 Index 770 - 779 */

 Index 780 - 789 */

 Index 790 - 799 */

 Index 800 - 809 */

 Index 810 - 819 */

 Index 820 - 829 */

 Index 830 - 839 */

 Index 840 - 849 */

 Index 850 - 859 */

 Index 860 - 869 */

 Index 870 - 879 */

 Index 880 - 889 */

 Index 890 - 899 */

 Index 900 - 909 */

 Index 910 - 919 */

 Index 920 - 929 */

 Index 930 - 939 */

 Index 940 - 945 */

 DRA752 data */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * OMAP3 thermal driver.

 *

 * Copyright (C) 2011-2012 Texas Instruments Inc.

 * Copyright (C) 2014 Pavel Machek <pavel@ucw.cz>

 *

 * Note

 * http://www.ti.com/lit/er/sprz278f/sprz278f.pdf "Advisory

 * 3.1.1.186 MMC OCP Clock Not Gated When Thermal Sensor Is Used"

 *

 * Also TI says:

 * Just be careful when you try to make thermal policy like decisions

 * based on this sensor. Placement of the sensor w.r.t the actual logic

 * generating heat has to be a factor as well. If you are just looking

 * for an approximation temperature (thermometerish kind), you might be

 * ok with this. I am not sure we'd find any TI data around this.. just a

 * heads up.

/*

 * OMAP34XX has one instance of thermal sensor for MPU

 * need to describe the individual bit fields

 Thresholds and limits for OMAP34XX MPU temperature sensor */

/*

 * Temperature values in milli degree celsius

 OMAP34XX data */

/*

 * OMAP36XX has one instance of thermal sensor for MPU

 * need to describe the individual bit fields

 Thresholds and limits for OMAP36XX MPU temperature sensor */

/*

 * Temperature values in milli degree celsius

 OMAP36XX data */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * TI Bandgap temperature sensor driver

 *

 * Copyright (C) 2011-2012 Texas Instruments Incorporated - http://www.ti.com/

 * Author: J Keerthy <j-keerthy@ti.com>

 * Author: Moiz Sonasath <m-sonasath@ti.com>

 * Couple of fixes, DT and MFD adaptation:

 *   Eduardo Valentin <eduardo.valentin@ti.com>

**   Helper functions to access registers and their bitfields   ***/

/**

 * ti_bandgap_readl() - simple read helper function

 * @bgp: pointer to ti_bandgap structure

 * @reg: desired register (offset) to be read

 *

 * Helper function to read bandgap registers. It uses the io remapped area.

 * Return: the register value.

/**

 * ti_bandgap_writel() - simple write helper function

 * @bgp: pointer to ti_bandgap structure

 * @val: desired register value to be written

 * @reg: desired register (offset) to be written

 *

 * Helper function to write bandgap registers. It uses the io remapped area.

/**

 * DOC: macro to update bits.

 *

 * RMW_BITS() - used to read, modify and update bandgap bitfields.

 *            The value passed will be shifted.

**   Basic helper functions   ***/

/**

 * ti_bandgap_power() - controls the power state of a bandgap device

 * @bgp: pointer to ti_bandgap structure

 * @on: desired power state (1 - on, 0 - off)

 *

 * Used to power on/off a bandgap device instance. Only used on those

 * that features tempsoff bit.

 *

 * Return: 0 on success, -ENOTSUPP if tempsoff is not supported.

 active on 0 */

/**

 * ti_errata814_bandgap_read_temp() - helper function to read dra7 sensor temperature

 * @bgp: pointer to ti_bandgap structure

 * @reg: desired register (offset) to be read

 *

 * Function to read dra7 bandgap sensor temperature. This is done separately

 * so as to workaround the errata "Bandgap Temperature read Dtemp can be

 * corrupted" - Errata ID: i814".

 * Read accesses to registers listed below can be corrupted due to incorrect

 * resynchronization between clock domains.

 * Read access to registers below can be corrupted :

 * CTRL_CORE_DTEMP_MPU/GPU/CORE/DSPEVE/IVA_n (n = 0 to 4)

 * CTRL_CORE_TEMP_SENSOR_MPU/GPU/CORE/DSPEVE/IVA_n

 *

 * Return: the register value.

 If both times we read the same value then that is right */

 if val1 and val2 are different read it third time */

/**

 * ti_bandgap_read_temp() - helper function to read sensor temperature

 * @bgp: pointer to ti_bandgap structure

 * @id: bandgap sensor id

 *

 * Function to concentrate the steps to read sensor temperature register.

 * This function is desired because, depending on bandgap device version,

 * it might be needed to freeze the bandgap state machine, before fetching

 * the register value.

 *

 * Return: temperature in ADC values.

		/*

		 * In case we cannot read from cur_dtemp / dtemp_0,

		 * then we read from the last valid temp read

 read temperature */

**   IRQ handlers   ***/

/**

 * ti_bandgap_talert_irq_handler() - handles Temperature alert IRQs

 * @irq: IRQ number

 * @data: private data (struct ti_bandgap *)

 *

 * This is the Talert handler. Use it only if bandgap device features

 * HAS(TALERT). This handler goes over all sensors and checks their

 * conditions and acts accordingly. In case there are events pending,

 * it will reset the event mask to wait for the opposite event (next event).

 * Every time there is a new event, it will be reported to thermal layer.

 *

 * Return: IRQ_HANDLED

 Read the status of t_hot */

 Read the status of t_cold */

		/*

		 * One TALERT interrupt: Two sources

		 * If the interrupt is due to t_hot then mask t_hot and

		 * and unmask t_cold else mask t_cold and unmask t_hot

 report temperature to whom may concern */

/**

 * ti_bandgap_tshut_irq_handler() - handles Temperature shutdown signal

 * @irq: IRQ number

 * @data: private data (unused)

 *

 * This is the Tshut handler. Use it only if bandgap device features

 * HAS(TSHUT). If any sensor fires the Tshut signal, we simply shutdown

 * the system.

 *

 * Return: IRQ_HANDLED

**   Helper functions which manipulate conversion ADC <-> mi Celsius   ***/

/**

 * ti_bandgap_adc_to_mcelsius() - converts an ADC value to mCelsius scale

 * @bgp: struct ti_bandgap pointer

 * @adc_val: value in ADC representation

 * @t: address where to write the resulting temperature in mCelsius

 *

 * Simple conversion from ADC representation to mCelsius. In case the ADC value

 * is out of the ADC conv table range, it returns -ERANGE, 0 on success.

 * The conversion table is indexed by the ADC values.

 *

 * Return: 0 if conversion was successful, else -ERANGE in case the @adc_val

 * argument is out of the ADC conv table range.

 look up for temperature in the table and return the temperature */

/**

 * ti_bandgap_validate() - helper to check the sanity of a struct ti_bandgap

 * @bgp: struct ti_bandgap pointer

 * @id: bandgap sensor id

 *

 * Checks if the bandgap pointer is valid and if the sensor id is also

 * applicable.

 *

 * Return: 0 if no errors, -EINVAL for invalid @bgp pointer or -ERANGE if

 * @id cannot index @bgp sensors.

/**

 * ti_bandgap_read_counter() - read the sensor counter

 * @bgp: pointer to bandgap instance

 * @id: sensor id

 * @interval: resulting update interval in miliseconds

/**

 * ti_bandgap_read_counter_delay() - read the sensor counter delay

 * @bgp: pointer to bandgap instance

 * @id: sensor id

 * @interval: resulting update interval in miliseconds

/**

 * ti_bandgap_read_update_interval() - read the sensor update interval

 * @bgp: pointer to bandgap instance

 * @id: sensor id

 * @interval: resulting update interval in miliseconds

 *

 * Return: 0 on success or the proper error code

/**

 * ti_bandgap_write_counter_delay() - set the counter_delay

 * @bgp: pointer to bandgap instance

 * @id: sensor id

 * @interval: desired update interval in miliseconds

 *

 * Return: 0 on success or the proper error code

 Immediate conversion */

 Conversion after ever 1ms */

 Conversion after ever 10ms */

 Conversion after ever 100ms */

 Conversion after ever 250ms */

 Conversion after ever 500ms */

/**

 * ti_bandgap_write_counter() - set the bandgap sensor counter

 * @bgp: pointer to bandgap instance

 * @id: sensor id

 * @interval: desired update interval in miliseconds

/**

 * ti_bandgap_write_update_interval() - set the update interval

 * @bgp: pointer to bandgap instance

 * @id: sensor id

 * @interval: desired update interval in miliseconds

 *

 * Return: 0 on success or the proper error code

/**

 * ti_bandgap_read_temperature() - report current temperature

 * @bgp: pointer to bandgap instance

 * @id: sensor id

 * @temperature: resulting temperature

 *

 * Return: 0 on success or the proper error code

/**

 * ti_bandgap_set_sensor_data() - helper function to store thermal

 * framework related data.

 * @bgp: pointer to bandgap instance

 * @id: sensor id

 * @data: thermal framework related data to be stored

 *

 * Return: 0 on success or the proper error code

/**

 * ti_bandgap_get_sensor_data() - helper function to get thermal

 * framework related data.

 * @bgp: pointer to bandgap instance

 * @id: sensor id

 *

 * Return: data stored by set function with sensor id on success or NULL

**   Helper functions used during device initialization   ***/

/**

 * ti_bandgap_force_single_read() - executes 1 single ADC conversion

 * @bgp: pointer to struct ti_bandgap

 * @id: sensor id which it is desired to read 1 temperature

 *

 * Used to initialize the conversion state machine and set it to a valid

 * state. Called during device initialization and context restore events.

 *

 * Return: 0

 Select continuous or single conversion mode */

 Set Start of Conversion if available */

 Wait for EOCZ going up */

 Clear Start of Conversion if available */

 Wait for EOCZ going down, always needed even if no bgap_soc_mask */

/**

 * ti_bandgap_set_continuous_mode() - One time enabling of continuous mode

 * @bgp: pointer to struct ti_bandgap

 *

 * Call this function only if HAS(MODE_CONFIG) is set. As this driver may

 * be used for junction temperature monitoring, it is desirable that the

 * sensors are operational all the time, so that alerts are generated

 * properly.

 *

 * Return: 0

 Perform a single read just before enabling continuous */

/**

 * ti_bandgap_get_trend() - To fetch the temperature trend of a sensor

 * @bgp: pointer to struct ti_bandgap

 * @id: id of the individual sensor

 * @trend: Pointer to trend.

 *

 * This function needs to be called to fetch the temperature trend of a

 * Particular sensor. The function computes the difference in temperature

 * w.r.t time. For the bandgaps with built in history buffer the temperatures

 * are read from the buffer and for those without the Buffer -ENOTSUPP is

 * returned.

 *

 * Return: 0 if no error, else return corresponding error. If no

 *		error then the trend value is passed on to trend parameter

 Freeze and read the last 2 valid readings */

 read temperature from history buffer */

 Convert from adc values to mCelsius temperature */

 Fetch the update interval */

 Set the interval to 1 ms if bandgap counter delay is not set */

/**

 * ti_bandgap_tshut_init() - setup and initialize tshut handling

 * @bgp: pointer to struct ti_bandgap

 * @pdev: pointer to device struct platform_device

 *

 * Call this function only in case the bandgap features HAS(TSHUT).

 * In this case, the driver needs to handle the TSHUT signal as an IRQ.

 * The IRQ is wired as a GPIO, and for this purpose, it is required

 * to specify which GPIO line is used. TSHUT IRQ is fired anytime

 * one of the bandgap sensors violates the TSHUT high/hot threshold.

 * And in that case, the system must go off.

 *

 * Return: 0 if no error, else error status

/**

 * ti_bandgap_talert_init() - setup and initialize talert handling

 * @bgp: pointer to struct ti_bandgap

 * @pdev: pointer to device struct platform_device

 *

 * Call this function only in case the bandgap features HAS(TALERT).

 * In this case, the driver needs to handle the TALERT signals as an IRQs.

 * TALERT is a normal IRQ and it is fired any time thresholds (hot or cold)

 * are violated. In these situation, the driver must reprogram the thresholds,

 * accordingly to specified policy.

 *

 * Return: 0 if no error, else return corresponding error.

/**

 * ti_bandgap_build() - parse DT and setup a struct ti_bandgap

 * @pdev: pointer to device struct platform_device

 *

 * Used to read the device tree properties accordingly to the bandgap

 * matching version. Based on bandgap version and its capabilities it

 * will build a struct ti_bandgap out of the required DT entries.

 *

 * Return: valid bandgap structure if successful, else returns ERR_PTR

 * return value must be verified with IS_ERR.

 just for the sake */

 register shadow for context save and restore */

/*

 * List of SoCs on which the CPU PM notifier can cause erros on the DTEMP

 * readout.

 * Enabled notifier on these machines results in erroneous, random values which

 * could trigger unexpected thermal shutdown.

 sentinel */ },

**   Device driver call backs   ***/

		/*

		 * check if the efuse has a non-zero value if not

		 * it is an untrimmed sample and the temperatures

		 * may not be accurate

 Set default counter to 1 for now */

 Set default thresholds for alert and shutdown */

 Set initial Talert thresholds */

 Enable the alert events */

 Set initial Tshut thresholds */

 Set .250 seconds time as default counter */

 Every thing is good? Then expose the sensors */

	/*

	 * Enable the Interrupts once everything is set. Otherwise irq handler

	 * might be called as soon as it is enabled where as rest of framework

	 * is still getting initialised.

 Remove sensor interfaces */

		/* Force immediate temperature measurement and update

		 * of the DTEMP field

 Sentinel */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * OMAP5 thermal driver.

 *

 * Copyright (C) 2011-2012 Texas Instruments Inc.

 * Contact:

 *	Eduardo Valentin <eduardo.valentin@ti.com>

/*

 * OMAP5430 has three instances of thermal sensor for MPU, GPU & CORE,

 * need to describe the individual registers and bit fields.

/*

 * OMAP5430 MPU thermal sensor register offset and bit-fields

/*

 * OMAP5430 GPU thermal sensor register offset and bit-fields

/*

 * OMAP5430 CORE thermal sensor register offset and bit-fields

 Thresholds and limits for OMAP5430 MPU temperature sensor */

 Thresholds and limits for OMAP5430 GPU temperature sensor */

 Thresholds and limits for OMAP5430 CORE temperature sensor */

/*

 * OMAP54xx ES2.0 : Temperature values in milli degree celsius

 * ADC code values from 540 to 945

 Index 540 - 549 */

 Index 550 - 559 */

 Index 560 - 569 */

 Index 570 - 579 */

 Index 580 - 589 */

 Index 590 - 599 */

 Index 600 - 609 */

 Index 610 - 619 */

 Index 620 - 629 */

 Index 630 - 639 */

 Index 640 - 649 */

 Index 650 - 659 */

 Index 660 - 669 */

 Index 670 - 679 */

 Index 680 - 689 */

 Index 690 - 699 */

 Index 700 - 709 */

 Index 710 - 719 */

 Index 720 - 729 */

 Index 730 - 739 */

 Index 740 - 749 */

 Index 750 - 759 */

 Index 760 - 769 */

 Index 770 - 779 */

 Index 780 - 789 */

 Index 790 - 799 */

 Index 800 - 809 */

 Index 810 - 819 */

 Index 820 - 829 */

 Index 830 - 839 */

 Index 840 - 849 */

 Index 850 - 859 */

 Index 860 - 869 */

 Index 870 - 879 */

 Index 880 - 889 */

 Index 890 - 899 */

 Index 900 - 909 */

 Index 910 - 919 */

 Index 920 - 929 */

 Index 930 - 939 */

 Index 940 - 945 */

 OMAP54xx ES2.0 data */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * OMAP thermal driver interface

 *

 * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/

 * Contact:

 *   Eduardo Valentin <eduardo.valentin@ti.com>

 common data structures */

/**

 * ti_thermal_hotspot_temperature - returns sensor extrapolated temperature

 * @t:	omap sensor temperature

 * @s:	omap sensor slope value

 * @c:	omap sensor const value

 thermal zone ops */

 Get temperature callback function for thermal zone */

 Default constants */

 In case pcb zone is available, use the extrapolation rule with it */

 got a valid PCB temp */

 pcb_tz will be either valid or PTR_ERR() */

 in case this is specified by DT */

	/*

	 * We are assuming here that if one deploys the zone

	 * using DT, then it must be aware that the cooling device

	 * loading has to happen via cpufreq driver.

 Register cooling device */

 SPDX-License-Identifier: GPL-2.0

/*

 *  Intel menlow Driver for thermal management extension

 *

 *  Copyright (C) 2008 Intel Corp

 *  Copyright (C) 2008 Sujith Thomas <sujith.thomas@intel.com>

 *  Copyright (C) 2008 Zhang Rui <rui.zhang@intel.com>

 *

 *  This driver creates the sys I/F for programming the sensors.

 *  It also implements the driver for intel menlow memory controller (hardware

 *  id is INT0002) which makes use of the platform specific ACPI methods

 *  to get/set bandwidth.

/*

 * Memory controller device control

/*

 * GTHS returning 'n' would mean that [0,n-1] states are supported

 * In that case max_cstate would be n-1

 * GTHS returning '0' would mean that no bandwidth control states are supported

/*

 * Memory Device Management

/*

 * Sensor control on menlow platform

/*

 * sensor_get_auxtrip - get the current auxtrip value from sensor

 * @name: Thermalzone name

 * @auxtype : AUX0/AUX1

 * @buf: syfs buffer

/*

 * sensor_set_auxtrip - set the new auxtrip value to sensor

 * @name: Thermalzone name

 * @auxtype : AUX0/AUX1

 * @buf: syfs buffer

 do we need to check the return value of SAX0/SAX1 ? */

Sanity check; should be a positive integer */

 BIOS can enable/disable the thermal user application in dabney platform */

 That is consistent naming :D */

 _TZ must have the AUX0/1 methods */

	/*

	 * create the "dabney_enabled" attribute which means the user app

	 * should be loaded or not

 Looking for the \_TZ.GSTS method */

 Looking for ACPI device MEM0 with hardware id INT0002 */

 Looking for sensors in each ACPI thermal zone */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * x86_pkg_temp_thermal driver

 * Copyright (c) 2013, Intel Corporation.

/*

* Rate control delay: Idea is to introduce denounce effect

* This should be long enough to avoid reduce events, when

* threshold is set to a temperature, which is constantly

* violated, but at the short enough to take any action.

* The action can be remove threshold or change it to next

* interesting setting. Based on experiments, in around

* every 5 seconds under load will give us a significant

* temperature change.

/* Number of trip points in thermal zone. Currently it can't

* be more than 2. MSR can allow setting and getting notifications

* for only 2 thresholds. This define enforces this, if there

* is some wrong values returned by cpuid for number of thresholds.

 Keep track of how many zone pointers we allocated in init() */

 Array of zone pointers */

 Serializes interrupt notification, work and hotplug */

 Protects zone operation in the work function against hotplug removal */

 The dynamically assigned cpu hotplug state for module_exit() */

 Debug counters to show using debugfs */

/*

 * Protection:

 *

 * - cpu hotplug: Read serialized by cpu hotplug lock

 *		  Write must hold pkg_temp_lock

 *

 * - Other callsites: Must hold pkg_temp_lock

/*

* tj-max is is interesting because threshold is set relative to this

* temperature.

	/*

	* When users space sets a trip temperature == 0, which is indication

	* that, it is no longer interested in receiving notifications.

 Thermal zone callback registry */

 Enable threshold interrupt on local package/cpu */

 only enable/disable if it had valid threshold value */

 Disable threshold interrupt on local package/cpu */

	/*

	 * If tzone is not NULL, then thermal_zone_mutex will prevent the

	 * concurrent removal in the cpu offline callback.

 Work is per package, so scheduling it once is enough. */

 Store MSR value for package thermal interrupt, to restore at exit */

	/*

	 * Remove the sysfs files, if this is the last cpu in the package

	 * before doing further cleanups.

		/*

		 * We must protect against a work function calling

		 * thermal_zone_update, after/while unregister. We null out

		 * the pointer under the zone mutex, so the worker function

		 * won't try to call.

 Protect against work and interrupts */

	/*

	 * Check whether this cpu was the current target and store the new

	 * one. When we drop the lock, then the interrupt notify function

	 * will see the new target.

	/*

	 * If this is the last CPU in the package remove the package

	 * reference from the array and restore the interrupt MSR. When we

	 * drop the lock neither the interrupt notify function nor the

	 * worker will see the package anymore.

 After this point nothing touches the MSR anymore. */

	/*

	 * Check whether there is work scheduled and whether the work is

	 * targeted at the outgoing CPU.

		/*

		 * To cancel the work we need to drop the lock, otherwise

		 * we might deadlock if the work needs to be flushed.

		/*

		 * If this is not the last cpu in the package and the work

		 * did not run after we dropped the lock above, then we

		 * need to reschedule the work, otherwise the interrupt

		 * stays disabled forever.

 Final cleanup if this is the last cpu */

 Paranoia check */

 If the package exists, nothing to do */

 Store the state for module exit */

 Don't care if it fails */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * cooling device driver that activates the processor throttling by

 * programming the TCC Offset register.

 * Copyright (c) 2021, Intel Corporation.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * intel_soc_dts_iosf.c

 * Copyright (c) 2015, Intel Corporation.

 DTS encoding for TJ MAX temperature */

 Only 2 out of 4 is allowed for OSPM */

 Mask for two trips in status bits */

 DTS0 and DTS 1 */

 Enable for CPU module 0 and module 1 */

 Nothing we can do if restore fails */

 Store status to restor on exit */

 Check if the writable trip we provide is not used by BIOS */

 reset sticky bit */

 SPDX-License-Identifier: GPL-2.0-only

/* intel_pch_thermal.c - Intel PCH Thermal driver

 *

 * Copyright (c) 2015, Intel Corporation.

 *

 * Authors:

 *     Tushar Dave <tushar.n.dave@intel.com>

 Intel PCH thermal Device IDs */

 Haswell PCH */

 Haswell PCH */

 Wildcat Point */

 Skylake PCH */

 Skylake PCH 100 series */

 CNL PCH */

 CNL-H PCH */

 CNL-LP PCH */

 CML-H PCH */

 Lewisburg PCH */

 Wildcat Point-LP  PCH Thermal registers */

 Temperature */

 Thermal Sensor Control */

 Thermal Sensor Status */

 Thermal Sensor Enable and Lock */

 Thermal Sensor Report Enable and Lock */

 Thermal Sensor SMI Control */

 Catastrophic Trip Point */

 Thermal Sensor Power Management */

 Thermal Alert High Value */

 Thermal Alert Low Value */

 Throttle Value */

 PCH Hot Level */

 PHL Control */

 Thermal Alert Status */

 PCI Interrupt Event Enables */

 General Purpose Event Enables */

  Wildcat Point-LP  PCH Thermal Register bit definitions */

 Temp TS Reading */

 Catastrophic Power-Down Enable */

 Thermal Sensor Dynamic Shutdown Status */

 GPE status */

 Enable TS */

 TSEL Policy Lock-Down Bit */

 T0 Level */

 T1 Level */

 TT Enable */

 Resolution of 1/2 degree C and an offset of -50C */

 Amount of time for each cooling delay, 100ms by default for now */

 Number of iterations for cooling delay, 10 counts by default for now */

/*

 * On some platforms, there is a companion ACPI device, which adds

 * passive trip temperature using _PSV method. There is no specific

 * passive temperature setting in MMIO interface of this PCI device.

 Check if BIOS has already enabled thermal sensor */

	/*

	 * When TSEL's Policy Lock-Down bit is 1, TSEL become RO.

	 * If so, thermal sensor cannot enable. Bail out.

 Shutdown the thermal sensor if it is not enabled by BIOS */

 Do not check temperature if it is not a S0ix capable platform */

 Do not check temperature if it is not s2idle */

 Get the PCH temperature threshold value */

 Get the PCH current temperature value */

	/*

	 * If current PCH temperature is higher than configured PCH threshold

	 * value, run some delay loop with sleep to let the current temperature

	 * go down below the threshold value which helps to allow system enter

	 * lower power S0ix suspend state. Even after delay loop if PCH current

	 * temperature stays above threshold, notify the warning message

	 * which helps to indentify the reason why S0ix entry was rejected.

 Read the PCH current temperature for next cycle. */

 dev ops for Wildcat Point */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * intel_soc_dts_thermal.c

 * Copyright (c) 2014, Intel Corporation.

 IRQ 86 is a fixed APIC interrupt for BYT DTS Aux threshold notifications */

 Create a zone with 2 trips with marked as read only */

		/*

		 * Note the flags here MUST match the firmware defaults, rather

		 * then the request_irq flags, otherwise we get an EBUSY error.

			/*

			 * Do not just error out because the user space thermal

			 * daemon such as DPTF may use polling instead of being

			 * interrupt driven.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Thermal throttle event support code (such as syslog messaging and rate

 * limiting) that was factored out from x86_64 (mce_intel.c) and i386 (p4.c).

 *

 * This allows consistent reporting of CPU thermal throttle events.

 *

 * Maintains a counter in /sys that keeps track of the number of thermal

 * events, such that the user knows how bad the thermal problem might be

 * (since the logging to syslog is rate limited).

 *

 * Author: Dmitriy Zavin (dmitriyz@google.com)

 *

 * Credits: Adapted from Zwane Mwaikambo's original code in mce_intel.c.

 *          Inspired by Ross Biro's and Al Borchers' counter code.

 How long to wait between reporting thermal events */

/**

 * struct _thermal_state - Represent the current thermal event state

 * @next_check:			Stores the next timestamp, when it is allowed

 *				to log the next warning message.

 * @last_interrupt_time:	Stores the timestamp for the last threshold

 *				high event.

 * @therm_work:			Delayed workqueue structure

 * @count:			Stores the current running count for thermal

 *				or power threshold interrupts.

 * @last_count:			Stores the previous running count for thermal

 *				or power threshold interrupts.

 * @max_time_ms:		This shows the maximum amount of time CPU was

 *				in throttled state for a single thermal

 *				threshold high to low state.

 * @total_time_ms:		This is a cumulative time during which CPU was

 *				in the throttled state.

 * @rate_control_active:	Set when a throttling message is logged.

 *				This is used for the purpose of rate-control.

 * @new_event:			Stores the last high/low status of the

 *				THERM_STATUS_PROCHOT or

 *				THERM_STATUS_POWER_LIMIT.

 * @level:			Stores whether this _thermal_state instance is

 *				for a CORE level or for PACKAGE level.

 * @sample_index:		Index for storing the next sample in the buffer

 *				temp_samples[].

 * @sample_count:		Total number of samples collected in the buffer

 *				temp_samples[].

 * @average:			The last moving average of temperature samples

 * @baseline_temp:		Temperature at which thermal threshold high

 *				interrupt was generated.

 * @temp_samples:		Storage for temperature samples to calculate

 *				moving average.

 *

 * This structure is used to represent data related to thermal state for a CPU.

 * There is a separate storage for core and package level for each CPU.

 Callback to handle core threshold interrupts */

 Callback to handle core package threshold_interrupts */

/* Callback support of rate control, return true, if

 CPU hotplug */			\

 CONFIG_SYSFS */

 temperature value is offset from the max so lesser means hotter */

 There was one new thermal interrupt */

/***

 * therm_throt_process - Process thermal throttling event from interrupt

 * @curr: Whether the condition is current or not (boolean), since the

 *        thermal interrupt normally gets called both when the thermal

 *        event begins and once the event has ended.

 *

 * This function is called by the thermal interrupt after the

 * IRQ has been acknowledged.

 *

 * It will take care of rate limiting and printing messages to the syslog.

		/*

		 * Ignore short temperature spike as the system is not close

		 * to PROCHOT. 10C offset is large enough to ignore. It is

		 * already dropped from the high threshold temperature.

 Add/Remove thermal_throttle interface for CPU device: */

 Get notified when a cpu comes on/off. Be hotplug friendly. */

 Unmask the thermal vector after the above workqueues are initialized. */

 Mask the thermal vector before draining evtl. pending work */

 CONFIG_SYSFS */

 lower threshold check */

 higher threshold check */

 Rate control is implemented in callback */

 lower threshold reached */

 higher threshold reached */

	/* check whether the interrupt handler is defined;

	 * otherwise simply return

 lower threshold reached */

 higher threshold reached */

 Thermal transition interrupt handler */

 Check for violation of core thermal thresholds*/

 check violations of package thermal thresholds */

 Thermal monitoring depends on APIC, ACPI and clock modulation */

	/*

	 * This function is only called on boot CPU. Save the init thermal

	 * LVT value on BSP and use that value to restore APs' thermal LVT

	 * entry BIOS programmed later

	/*

	 * First check if its enabled already, in which case there might

	 * be some SMM goo which handles it, so we can't even put a handler

	 * since it might be delivered via SMI already:

	/*

	 * The initial value of thermal LVT entries on all APs always reads

	 * 0x10000 because APs are woken up by BSP issuing INIT-SIPI-SIPI

	 * sequence to them and LVT registers are reset to 0s except for

	 * the mask bits which are set to 1s when APs receive INIT IPI.

	 * If BIOS takes over the thermal interrupt and sets its interrupt

	 * delivery mode to SMI (not fixed), it restores the value that the

	 * BIOS has programmed on AP based on BSP's info we saved since BIOS

	 * is always setting the same value for all threads/cores.

 early Pentium M models use different method for enabling TM2 */

 We'll mask the thermal vector in the lapic till we're ready: */

 enable thermal throttle processing */

/*

 * intel_quark_dts_thermal.c

 *

 * This file is provided under a dual BSD/GPLv2 license.  When using or

 * redistributing this file, you may do so under either license.

 *

 * GPL LICENSE SUMMARY

 *

 * Copyright(c) 2015 Intel Corporation.

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of version 2 of the GNU General Public License as

 * published by the Free Software Foundation.

 *

 * This program is distributed in the hope that it will be useful, but

 *  WITHOUT ANY WARRANTY; without even the implied warranty of

 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU

 * General Public License for more details.

 *

 * Contact Information:

 *  Ong Boon Leong <boon.leong.ong@intel.com>

 *  Intel Malaysia, Penang

 *

 * BSD LICENSE

 *

 * Copyright(c) 2015 Intel Corporation.

 *

 * Redistribution and use in source and binary forms, with or without

 * modification, are permitted provided that the following conditions

 * are met:

 *

 *   * Redistributions of source code must retain the above copyright

 *     notice, this list of conditions and the following disclaimer.

 *   * Redistributions in binary form must reproduce the above copyright

 *     notice, this list of conditions and the following disclaimer in

 *     the documentation and/or other materials provided with the

 *     distribution.

 *   * Neither the name of Intel Corporation nor the names of its

 *     contributors may be used to endorse or promote products derived

 *     from this software without specific prior written permission.

 *

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS

 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT

 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR

 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT

 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,

 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT

 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,

 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY

 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT

 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE

 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 *

 * Quark DTS thermal driver is implemented by referencing

 * intel_soc_dts_thermal.c.

 DTS reset is programmed via QRK_MBI_UNIT_SOC */

 DTS enable is programmed via QRK_MBI_UNIT_RMU */

 Temperature Register is read via QRK_MBI_UNIT_RMU */

 Programmable Trip Point Register is configured via QRK_MBI_UNIT_RMU */

 Thermal Sensor Register Lock */

 Quark DTS has 2 trip points: hot & catastrophic */

 If DTS not locked, all trip points are configurable */

 If DTS locked, all trip points are not configurable */

	/*

	 * Thermal Sensor Programmable Trip Point Register has 8-bit

	 * fields for critical (catastrophic) and hot set trip point

	 * thresholds. The threshold value is always offset by its

	 * temperature base (50 degree Celsius).

	/*

	 * Protection against unsafe trip point thresdhold value.

	 * As Quark X1000 data-sheet does not provide any recommendation

	 * regarding the safe trip point threshold value to use, we choose

	 * the safe value according to the threshold value set by UEFI BIOS.

	/*

	 * Thermal Sensor Programmable Trip Point Register has 8-bit

	 * fields for critical (catastrophic) and hot set trip point

	 * thresholds. The threshold value is always offset by its

	 * temperature base (50 degree Celsius).

	/*

	 * Thermal Sensor Temperature Register has 8-bit field

	 * for temperature value (offset by temperature base

	 * 50 degree Celsius).

 Check if DTS register is locked */

 Store DTS default state if DTS registers are not locked */

 Store DTS default enable for restore on exit */

 Store DTS default PTPS register for restore on exit */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * intel_powerclamp.c - package c-state idle injection

 *

 * Copyright (c) 2012, Intel Corporation.

 *

 * Authors:

 *     Arjan van de Ven <arjan@linux.intel.com>

 *     Jacob Pan <jacob.jun.pan@linux.intel.com>

 *

 *	TODO:

 *           1. better handle wakeup from external interrupts, currently a fixed

 *              compensation is added to clamping duration when excessive amount

 *              of wakeups are observed during idle time. the reason is that in

 *              case of external interrupts without need for ack, clamping down

 *              cpu in non-irq context does not reduce irq. for majority of the

 *              cases, clamping down cpu does help reduce irq as well, we should

 *              be able to differentiate the two cases and give a quantitative

 *              solution for the irqs that we can control. perhaps based on

 *              get_cpu_iowait_time_us()

 *

 *	     2. synchronization with other hw blocks

/* For each undisturbed clamping period (no extra wake ups during idle time),

 * we increment the confidence counter for the given target ratio.

 * CONFIDENCE_OK defines the level where runtime calibration results are

 * valid.

/* Default idle injection duration, driver adjust sleep time to meet target

 * idle ratio. Similar to frequency modulation.

 user selected target */

static unsigned int control_cpu; /* The cpu assigned to collect stat and update

				  * control parameters. default to BSP but BSP

				  * can be offlined.

static unsigned long *cpu_clamping_mask;  /* bit map for tracking per cpu

					   * clamping kthread worker

	unsigned long confidence;  /* used for calibration, basically a counter

				    * gets incremented each time a clamping

				    * period is completed without extra wakeups

				    * once that counter is reached given level,

				    * compensation is deemed usable.

	unsigned long steady_comp; /* steady state compensation used when

				    * no extra wakeups occurred.

	unsigned long dynamic_comp; /* compensate excessive wakeup from idle

				     * mostly from external interrupts.

 check if any one of the counter msrs exists */

 we only use compensation if all adjacent ones are good */

 REVISIT: simple penalty of double idle injection */

 do not exceed limit */

	/*

	 * adjust compensations if confidence level has not been reached or

	 * there are too many wakeups during the last idle injection period, we

	 * cannot trust the data for compensation.

 filter out bad data */

 check result for the last window */

 calculate pkg cstate vs tsc ratio */

 update record */

	/*

	 * too many external interrupts, set flag such

	 * that we can take measure later.

 if we are above target+guard, skip */

 jiffies to sleep for each attempt */

	/*

	 * make sure user selected ratio does not take effect until

	 * the next round. adjust target_ratio if user has changed

	 * target such that we can converge quickly.

	/*

	 * systems may have different ability to enter package level

	 * c-states, thus we need to compensate the injected idle ratio

	 * to achieve the actual target reported by the HW.

 align idle time */

	/*

	 * only elected controlling cpu can collect stats and update

	 * control parameters.

/*

 * 1 HZ polling while clamping is active, useful for userspace

 * to monitor actual idle ratio.

 calculate pkg cstate vs tsc ratio */

 update record */

	/*

	 * Make sure that all works that get queued after this point see

	 * the clamping disabled. The counter part is not needed because

	 * there is an implicit memory barrier when the queued work

	 * is proceed.

	/*

	 * The balancing work still might be queued here because

	 * the handling of the "clapming" variable, cancel, and queue

	 * operations are not synchronized via a lock. But it is not

	 * a big deal. The balancing work is fast and destroy kthread

	 * will wait for it.

 prevent cpu hotplug */

 prefer BSP */

 start one kthread worker per online cpu */

	/*

	 * Block requeuing in all the kthread workers. They will flush and

	 * stop faster.

 prefer BSP as controlling CPU */

 to save power, do not poll idle ratio while not clamping */

 indicates invalid state */

 adjust currently running */ {

 make new set_target_ratio visible to other cpus */

 bind to generic thermal layer as cooling device*/

 The goal for idle time alignment is to achieve package cstate. */

 find the deepest mwait value */

 probe cpu features and ids here */

 set default limit, maybe adjusted during runtime based on feedback */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Intel Broxton PMIC thermal driver

 *

 * Copyright (C) 2016 Intel Corporation. All rights reserved.

 Resolve thermal irqs */

			/*

			 * Read the irq register to resolve whether the

			 * interrupt was triggered for this sensor

			/*

			 * Read the status register to find out what

			 * event occurred i.e a high or a low

 Clear the appropriate irq */

 Enable thermal interrupts */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * processor thermal device mailbox driver for Workload type hints

 * Copyright (c) 2020, Intel Corporation.

 Poll for rb bit == 0 */

 Write command register */

 Poll for rb bit == 0 */

 List of workload types */

 Check if there is a mailbox support, if fails return success */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ACPI INT3403 thermal driver

 * Copyright (c) 2013, Intel Corporation.

 Preserved structure for future expandbility */

 INT3403 Cooling devices */

 TODO: add ACPI notification support */

 SPDX-License-Identifier: GPL-2.0-only

/* acpi_thermal_rel.c driver for exporting ACPI thermal relationship

 *

 * Copyright (c) 2014 Intel Corp

/*

 * Two functionalities included:

 * 1. Export _TRT, _ART, via misc device interface to the userspace.

 * 2. Provide parsing result to kernel drivers

 *

 #times opened */

 already open exclusive? */

/**

 * acpi_parse_trt - Thermal Relationship Table _TRT for passive cooling

 *

 * @handle: ACPI handle of the device contains _TRT

 * @trt_count: the number of valid entries resulted from parsing _TRT

 * @trtp: pointer to pointer of array of _TRT entries in parsing result

 * @create_dev: whether to create platform devices for target and source

 *

 don't count bad entries */

/**

 * acpi_parse_art - Parse Active Relationship Table _ART

 *

 * @handle: ACPI handle of the device contains _ART

 * @art_count: the number of valid entries resulted from parsing _ART

 * @artp: pointer to pointer of array of art entries in parsing result

 * @create_dev: whether to create platform devices for target and source

 *

 ignore p->package.elements[0], as this is _ART Revision field */

 don't count bad entries */

 get device name from acpi handle */

 now fill in user art data */

 userspace art needs device name instead of acpi reference */

 copy the rest int data in addition to source and target */

 now fill in user trt data */

 userspace trt needs device name instead of acpi reference */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * INT3402 thermal driver for memory temperature reporting

 *

 * Copyright (C) 2014, Intel Corporation

 * Authors: Aaron Lu <aaron.lu@intel.com>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * processor thermal device RFIM control

 * Copyright (c) 2020, Intel Corporation.

 These will represent sysfs attribute names */

 vco_ref_code_lo */

 vco_ref_code_hi */

 spread_spectrum_pct */

 spread_spectrum_clk_enable */

 rfi_vco_ref_code */

 fivr_fffc_rev */

 These will represent sysfs attribute names */

 rfi_restriction_run_busy */

 rfi_restriction_err_code */

 rfi_restriction_data_rate */

 rfi_restriction_data_rate_base */

 ddr_data_rate_point_0 */

 ddr_data_rate_point_1 */

 ddr_data_rate_point_2 */

 ddr_data_rate_point_3 */

 rfi_disable */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Processor thermal device for newer processors

 * Copyright (c) 2020, Intel Corporation.

/*

 * To avoid sending two many messages to user space, we have 1 second delay.

 * On interrupt we are disabling interrupt and enabling after 1 second.

 * This workload function is delayed by 1 second.

 Enable interrupt flag */

 Disable enable interrupt flag */

 request and enable interrupt */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * processor_thermal_device.c

 * Copyright (c) 2014, Intel Corporation.

 since it is fixed, we can have local storage */

 there is no _TMP method, add local method */

 Do not update if saving failed */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * INT3401 processor thermal device

 * Copyright (c) 2020, Intel Corporation.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * B0D4 processor thermal device

 * Copyright (c) 2020, Intel Corporation.

		/*

		 * Enumerate additional DTS sensors available via IOSF.

		 * But we are not treating as a failure condition, if

		 * there are no aux DTSs enabled or fails. This driver

		 * already exposes sensors, which can be accessed via

		 * ACPI/MSR. So we don't want to fail for auxiliary DTSs.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * int340x_thermal_zone.c

 * Copyright (c) 2015, Intel Corporation.

 _TMP returns the temperature in tenths of degrees Kelvin */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * INT3400 thermal driver

 *

 * Copyright (C) 2014, Intel Corporation

 * Authors: Zhang Rui <rui.zhang@intel.com>

			/*

			 * If we have a list of supported UUIDs, make sure

			 * this one is supported.

 UUID must be 16 bytes */

 Ignore unknown notification codes sent to INT3400 device */

 faked temp sensor with 20C */

 Missing IDSP isn't fatal */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * INT3406 thermal driver for display participant device

 *

 * Copyright (C) 2016, Intel Corporation

 * Authors: Aaron Lu <aaron.lu@intel.com>

/*

 * According to the ACPI spec,

 * "Each brightness level is represented by a number between 0 and 100,

 * and can be thought of as a percentage. For example, 50 can be 50%

 * power consumption or 50% brightness, as defined by the OEM."

 *

 * As int3406 device uses this value to communicate with the native

 * graphics driver, we make the assumption that it represents

 * the percentage of brightness only

	/*

	 * There is no 1:1 mapping between the firmware interface level

	 * with the raw interface level, we will have to find one that is

	 * right above it.

 lower_limit and upper_limit should be always set */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * processor thermal device RFIM control

 * Copyright (c) 2020, Intel Corporation.

 mmio rapl supports package 0 only for now */

 SPDX-License-Identifier: GPL-2.0

/*

 * Tegra30 SoC Thermal Sensor driver

 *

 * Based on downstream HWMON driver from NVIDIA.

 * Copyright (C) 2011 NVIDIA Corporation

 *

 * Author: Dmitry Osipenko <digetx@gmail.com>

 * Copyright (C) 2021 GRATE-DRIVER project

	/*

	 * Sensors are enabled after reset by default, but not gauging

	 * until clock counter is programmed.

	 *

	 * M: number of reference clock pulses after which every

	 *    temperature / voltage measurement is made

	 *

	 * N: number of reference clock counts for which the counter runs

 apply the same configuration to both channels */

	/*

	 * Counter will be invalid if hardware is misprogrammed or not enough

	 * time passed since the time when sensor was enabled.

	/*

	 * This shouldn't happen with a valid counter status, nevertheless

	 * lets verify the value since it's in a separate (from status)

	 * register.

	/*

	 * temperature = a * counter + b

	 * temperature = m * (temperature ^ 2) + n * temperature + p

	/*

	 * TSENSOR doesn't trigger interrupt on the "low" temperature breach,

	 * hence bail out if high temperature is unspecified.

 stop channel gracefully */

	/*

	 * 90C is the maximal critical temperature of all Tegra30 SoC variants,

	 * use it for the default trip if unspecified in a device-tree.

 clamp hardware trips to the calibration limits */

	/*

	 * Kernel will perform a normal system shut down if it will

	 * see that critical temperature is breached, hence set the

	 * hardware limit by 5C higher in order to allow system to

	 * shut down gracefully before sending signal to the Power

	 * Management controller.

 prevent potential racing with tegra_tsensor_set_trips() */

 program LEVEL2 counter threshold */

 program LEVEL3 counter threshold */

	/*

	 * Enable sensor, emergency shutdown, interrupts for level 1/2/3

	 * breaches and counter overflow condition.

	 *

	 * Disable DIV2 throttle for now since we need to figure out how

	 * to integrate it properly with the thermal framework.

	 *

	 * Thermal levels supported by hardware:

	 *

	 *     Level 0 = cold

	 *     Level 1 = passive cooling (cpufreq DVFS)

	 *     Level 2 = passive cooling assisted by hardware (DIV2)

	 *     Level 3 = emergency shutdown assisted by hardware (PMC)

	/*

	 * We have two TSENSOR channels in a two different spots on SoC.

	 * Second channel provides more accurate data on older SoC versions,

	 * use it as a primary channel.

 get calibrated counter values for 25C/90C thresholds */

 and calibrated temperatures corresponding to the counter values */

 all calibration coefficients are premultiplied by 1000000 */

 except the coefficient of a reduced quadratic equation */

		/*

		 * It's okay if sensor isn't assigned to any thermal zone

		 * in a device-tree.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2014-2018, NVIDIA CORPORATION.  All rights reserved.

 *

 * This software is licensed under the terms of the GNU General Public

 * License version 2, as published by the Free Software Foundation, and

 * may be copied, distributed, and modified under those terms.

 *

 * This program is distributed in the hope that it will be useful,

 * but WITHOUT ANY WARRANTY; without even the implied warranty of

 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

 *

/*

 * Mask/shift bits in FUSE_TSENSOR_COMMON and

 * FUSE_TSENSOR_COMMON, which are described in

 * tegra_soctherm_fuse.c

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2014-2018, NVIDIA CORPORATION.  All rights reserved.

 *

 * This software is licensed under the terms of the GNU General Public

 * License version 2, as published by the Free Software Foundation, and

 * may be copied, distributed, and modified under those terms.

 *

 * This program is distributed in the hope that it will be useful,

 * but WITHOUT ANY WARRANTY; without even the implied warranty of

 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

 *

/*

 * Mask/shift bits in FUSE_TSENSOR_COMMON and

 * FUSE_TSENSOR_COMMON, which are described in

 * tegra_soctherm_fuse.c

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2015-2017, NVIDIA CORPORATION.  All rights reserved.

 *

 * Author:

 *	Mikko Perttunen <mperttunen@nvidia.com>

 *	Aapo Vienamo	<avienamo@nvidia.com>

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2014 - 2018, NVIDIA CORPORATION.  All rights reserved.

 *

 * Author:

 *	Mikko Perttunen <mperttunen@nvidia.com>

 *

 * This software is licensed under the terms of the GNU General Public

 * License version 2, as published by the Free Software Foundation, and

 * may be copied, distributed, and modified under those terms.

 *

 * This program is distributed in the hope that it will be useful,

 * but WITHOUT ANY WARRANTY; without even the implied warranty of

 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

 *

/*

 * SENSOR_CONFIG2 is defined in soctherm.h

 * because, it will be used by tegra_soctherm_fuse.c

/*

 * THERMCTL_LEVEL0_GROUP_CPU is defined in soctherm.h

 * because it will be used by tegraxxx_soctherm.c

 3'b000 */

 3'b001 */

 3'b011 */

 3'b111 */

 car register offsets needed for enabling HW throttling */

 ccroc register offsets needed for enabling HW throttling for Tegra132 */

 get val from register(r) mask bits(m) */

 set val(v) to mask bits(m) of register(r) */

 get dividend from the depth */

/* gk20a nv_therm interface N:3 Mapping. Levels defined in tegra124-soctherm.h

 * level	vector

 * NONE		3'b000

 * LOW		3'b001

 * MED		3'b011

 * HIGH		3'b111

 get THROT_PSKIP_xxx offset per LIGHT/HEAVY throt and CPU/GPU dev */

 get THROT_xxx_CTRL offset per LIGHT/HEAVY throt */

 get CCROC_THROT_PSKIP_xxx offset per HIGH/MED/LOW vect*/

 get THERMCTL_LEVELx offset per CPU/GPU/MEM/TSENSE rg and LEVEL0~3 lv */

 OC5 is reserved */

 serialize OC IRQs */

/**

 * ccroc_writel() - writes a value to a CCROC register

 * @ts: pointer to a struct tegra_soctherm

 * @value: the value to write

 * @reg: the register offset

 *

 * Writes @v to @reg.  No return value.

/**

 * ccroc_readl() - reads specified register from CCROC IP block

 * @ts: pointer to a struct tegra_soctherm

 * @reg: register address to be read

 *

 * Return: the value of the register

/*

 * Translate from soctherm readback format to millicelsius.

 * The soctherm readback format in bits is as follows:

 *   TTTTTTTT H______N

 * where T's contain the temperature in Celsius,

 * H denotes an addition of 0.5 Celsius and N denotes negation

 * of the final value.

/**

 * enforce_temp_range() - check and enforce temperature range [min, max]

 * @dev: struct device * of the SOC_THERM instance

 * @trip_temp: the trip temperature to check

 *

 * Checks and enforces the permitted temperature range that SOC_THERM

 * HW can support This is

 * done while taking care of precision.

 *

 * Return: The precision adjusted capped temperature in millicelsius.

/**

 * thermtrip_program() - Configures the hardware to shut down the

 * system if a given sensor group reaches a given temperature

 * @dev: ptr to the struct device for the SOC_THERM IP block

 * @sg: pointer to the sensor group to set the thermtrip temperature for

 * @trip_temp: the temperature in millicelsius to trigger the thermal trip at

 *

 * Sets the thermal trip threshold of the given sensor group to be the

 * @trip_temp.  If this threshold is crossed, the hardware will shut

 * down.

 *

 * Note that, although @trip_temp is specified in millicelsius, the

 * hardware is programmed in degrees Celsius.

 *

 * Return: 0 upon success, or %-EINVAL upon failure.

/**

 * throttrip_program() - Configures the hardware to throttle the

 * pulse if a given sensor group reaches a given temperature

 * @dev: ptr to the struct device for the SOC_THERM IP block

 * @sg: pointer to the sensor group to set the thermtrip temperature for

 * @stc: pointer to the throttle need to be triggered

 * @trip_temp: the temperature in millicelsius to trigger the thermal trip at

 *

 * Sets the thermal trip threshold and throttle event of the given sensor

 * group. If this threshold is crossed, the hardware will trigger the

 * throttle.

 *

 * Note that, although @trip_temp is specified in millicelsius, the

 * hardware is programmed in degrees Celsius.

 *

 * Return: 0 upon success, or %-EINVAL upon failure.

 Hardcode LIGHT on LEVEL1 and HEAVY on LEVEL2 */

		/*

		 * If thermtrips property is set in DT,

		 * doesn't need to program critical type trip to HW,

		 * if not, program critical trip to HW.

 multiple zones could be handling and setting trips at once */

 multiple zones could be handling and setting trips at once */

/**

 * tegra_soctherm_set_hwtrips() - set HW trip point from DT data

 * @dev: struct device * of the SOC_THERM instance

 * @sg: pointer to the sensor group to set the thermtrip temperature for

 * @tz: struct thermal_zone_device *

 *

 * Configure the SOC_THERM HW trip points, setting "THERMTRIP"

 * "THROTTLE" trip points , using "thermtrips", "critical" or "hot"

 * type trip_temp

 * from thermal zone.

 * After they have been configured, THERMTRIP or THROTTLE will take

 * action when the configured SoC thermal sensor group reaches a

 * certain temperature.

 *

 * Return: 0 upon success, or a negative error code on failure.

 * "Success" does not mean that trips was enabled; it could also

 * mean that no node was found in DT.

 * THERMTRIP has been enabled successfully when a message similar to

 * this one appears on the serial console:

 * "thermtrip: will shut down when sensor group XXX reaches YYYYYY mC"

 * THROTTLE has been enabled successfully when a message similar to

 * this one appears on the serial console:

 * ""throttrip: will throttle when sensor group XXX reaches YYYYYY mC"

 Get thermtrips. If missing, try to get critical trips. */

	/* Case for no lock:

	 * Although interrupts are enabled in set_trips, there is still no need

	 * to lock here because the interrupts are disabled before programming

	 * new trip points. Hence there cant be a interrupt on the same sensor.

	 * An interrupt can however occur on a sensor while trips are being

	 * programmed on a different one. This beign a LEVEL interrupt won't

	 * cause a new interrupt but this is taken care of by the re-reading of

	 * the STATUS register in the thread function.

/**

 * soctherm_thermal_isr_thread() - Handles a thermal interrupt request

 * @irq:       The interrupt number being requested; not used

 * @dev_id:    Opaque pointer to tegra_soctherm;

 *

 * Clears the interrupt status register if there are expected

 * interrupt bits set.

 * The interrupt(s) are then handled by updating the corresponding

 * thermal zones.

 *

 * An error is logged if any unexpected interrupt bits are set.

 *

 * Disabled interrupts are re-enabled.

 *

 * Return: %IRQ_HANDLED. Interrupt was handled and no further processing

 * is needed.

 deliberately clear expected interrupts handled in SW */

 deliberately ignore expected interrupts NOT handled in SW */

 Whine about any other unexpected INTR bits still set */

/**

 * soctherm_oc_intr_enable() - Enables the soctherm over-current interrupt

 * @ts:		pointer to a struct tegra_soctherm

 * @alarm:		The soctherm throttle id

 * @enable:		Flag indicating enable the soctherm over-current

 *			interrupt or disable it

 *

 * Enables a specific over-current pins @alarm to raise an interrupt if the flag

 * is set and the alarm corresponds to OC1, OC2, OC3, or OC4.

/**

 * soctherm_handle_alarm() - Handles soctherm alarms

 * @alarm:		The soctherm throttle id

 *

 * "Handles" over-current alarms (OC1, OC2, OC3, and OC4) by printing

 * a warning or informative message.

 *

 * Return: -EINVAL for @alarm = THROTTLE_OC3, otherwise 0 (success).

/**

 * soctherm_edp_isr_thread() - log an over-current interrupt request

 * @irq:	OC irq number. Currently not being used. See description

 * @arg:	a void pointer for callback, currently not being used

 *

 * Over-current events are handled in hardware. This function is called to log

 * and handle any OC events that happened. Additionally, it checks every

 * over-current interrupt registers for registers are set but

 * was not expected (i.e. any discrepancy in interrupt status) by the function,

 * the discrepancy will logged.

 *

 * Return: %IRQ_HANDLED

 deliberately clear expected interrupts handled in SW */

/**

 * soctherm_edp_isr() - Disables any active interrupts

 * @irq:	The interrupt request number

 * @arg:	Opaque pointer to an argument

 *

 * Writes to the OC_INTR_DISABLE register the over current interrupt status,

 * masking any asserted interrupts. Doing this prevents the same interrupts

 * from triggering this isr repeatedly. The thread woken by this isr will

 * handle asserted interrupts and subsequently unmask/re-enable them.

 *

 * The OC_INTR_DISABLE register indicates which OC interrupts

 * have been disabled.

 *

 * Return: %IRQ_WAKE_THREAD, handler requests to wake the handler thread

/**

 * soctherm_oc_irq_lock() - locks the over-current interrupt request

 * @data:	Interrupt request data

 *

 * Looks up the chip data from @data and locks the mutex associated with

 * a particular over-current interrupt request.

/**

 * soctherm_oc_irq_sync_unlock() - Unlocks the OC interrupt request

 * @data:		Interrupt request data

 *

 * Looks up the interrupt request data @data and unlocks the mutex associated

 * with a particular over-current interrupt request.

/**

 * soctherm_oc_irq_enable() - Enables the SOC_THERM over-current interrupt queue

 * @data:       irq_data structure of the chip

 *

 * Sets the irq_enable bit of SOC_THERM allowing SOC_THERM

 * to respond to over-current interrupts.

 *

/**

 * soctherm_oc_irq_disable() - Disables overcurrent interrupt requests

 * @data:	The interrupt request information

 *

 * Clears the interrupt request enable bit of the overcurrent

 * interrupt request chip data.

 *

 * Return: Nothing is returned (void)

/**

 * soctherm_oc_irq_map() - SOC_THERM interrupt request domain mapper

 * @h:		Interrupt request domain

 * @virq:	Virtual interrupt request number

 * @hw:		Hardware interrupt request number

 *

 * Mapping callback function for SOC_THERM's irq_domain. When a SOC_THERM

 * interrupt request is called, the irq_domain takes the request's virtual

 * request number (much like a virtual memory address) and maps it to a

 * physical hardware request number.

 *

 * When a mapping doesn't already exist for a virtual request number, the

 * irq_domain calls this function to associate the virtual request number with

 * a hardware request number.

 *

 * Return: 0

/**

 * soctherm_irq_domain_xlate_twocell() - xlate for soctherm interrupts

 * @d:      Interrupt request domain

 * @ctrlr:      Controller device tree node

 * @intspec:    Array of u32s from DTs "interrupt" property

 * @intsize:    Number of values inside the intspec array

 * @out_hwirq:  HW IRQ value associated with this interrupt

 * @out_type:   The IRQ SENSE type for this interrupt.

 *

 * This Device Tree IRQ specifier translation function will translate a

 * specific "interrupt" as defined by 2 DT values where the cell values map

 * the hwirq number + 1 and linux irq flags. Since the output is the hwirq

 * number, this function will subtract 1 from the value listed in DT.

 *

 * Return: 0

	/*

	 * The HW value is 1 index less than the DT IRQ values.

	 * i.e. OC4 goes to HW index 3.

/**

 * soctherm_oc_int_init() - Initial enabling of the over

 * current interrupts

 * @np:	The devicetree node for soctherm

 * @num_irqs:	The number of new interrupt requests

 *

 * Sets the over current interrupt request chip data

 *

 * Return: 0 on success or if overcurrent interrupts are not enabled,

 * -ENOMEM (out of memory), or irq_base if the function failed to

 * allocate the irqs

 BRIEF throttling by default, do not support STICKY */

/**

 * soctherm_init_hw_throt_cdev() - Parse the HW throttle configurations

 * and register them as cooling devices.

 * @pdev: Pointer to platform_device struct

/**

 * throttlectl_cpu_level_cfg() - programs CCROC NV_THERM level config

 * @ts: pointer to a struct tegra_soctherm

 * @level: describing the level LOW/MED/HIGH of throttling

 *

 * It's necessary to set up the CPU-local CCROC NV_THERM instance with

 * the M/N values desired for each level. This function does this.

 *

 * This function pre-programs the CCROC NV_THERM levels in terms of

 * pre-configured "Low", "Medium" or "Heavy" throttle levels which are

 * mapped to THROT_LEVEL_LOW, THROT_LEVEL_MED and THROT_LEVEL_HVY.

 setup PSKIP in ccroc nv_therm registers */

/**

 * throttlectl_cpu_level_select() - program CPU pulse skipper config

 * @ts: pointer to a struct tegra_soctherm

 * @throt: the LIGHT/HEAVY of throttle event id

 *

 * Pulse skippers are used to throttle clock frequencies.  This

 * function programs the pulse skippers based on @throt and platform

 * data.  This function is used on SoCs which have CPU-local pulse

 * skipper control, such as T13x. It programs soctherm's interface to

 * Denver:CCROC NV_THERM in terms of Low, Medium and HIGH throttling

 * vectors. PSKIP_BYPASS mode is set as required per HW spec.

 Denver:CCROC NV_THERM interface N:3 Mapping */

 bypass sequencer in soc_therm as it is programmed in ccroc */

/**

 * throttlectl_cpu_mn() - program CPU pulse skipper configuration

 * @ts: pointer to a struct tegra_soctherm

 * @throt: the LIGHT/HEAVY of throttle event id

 *

 * Pulse skippers are used to throttle clock frequencies.  This

 * function programs the pulse skippers based on @throt and platform

 * data.  This function is used for CPUs that have "remote" pulse

 * skipper control, e.g., the CPU pulse skipper is controlled by the

 * SOC_THERM IP block.  (SOC_THERM is located outside the CPU

 * complex.)

/**

 * throttlectl_gpu_level_select() - selects throttling level for GPU

 * @ts: pointer to a struct tegra_soctherm

 * @throt: the LIGHT/HEAVY of throttle event id

 *

 * This function programs soctherm's interface to GK20a NV_THERM to select

 * pre-configured "Low", "Medium" or "Heavy" throttle levels.

 *

 * Return: boolean true if HW was programmed

/**

 * soctherm_throttle_program() - programs pulse skippers' configuration

 * @ts: pointer to a struct tegra_soctherm

 * @throt: the LIGHT/HEAVY of the throttle event id.

 *

 * Pulse skippers are used to throttle clock frequencies.

 * This function programs the pulse skippers.

 Setup PSKIP parameters */

 configure LOW, MED and HIGH levels for CCROC NV_THERM */

 Thermal HW throttle programming */

 initialize stats collection */

 Initialize raw sensors */

 program pdiv and hotspot offsets per THERM */

 hotspot offset from PLLX, doesn't need to configure PLLX */

 Configure hw throttle */

 calculate shared calibration data */

 calculate tsensor calibration data */

 Configure hw trip points */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2014-2016, NVIDIA CORPORATION.  All rights reserved.

/*

 * Tegra210: Layout of bits in FUSE_TSENSOR_COMMON:

 *    3                   2                   1                   0

 *  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0

 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

 * |       BASE_FT       |      BASE_CP      | SHFT_FT | SHIFT_CP  |

 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

 *

 * Tegra12x, etc:

 * In chips prior to Tegra210, this fuse was incorrectly sized as 26 bits,

 * and didn't hold SHIFT_CP in [31:26]. Therefore these missing six bits

 * were obtained via the FUSE_SPARE_REALIGNMENT_REG register [5:0].

 *

 * FUSE_TSENSOR_COMMON:

 *    3                   2                   1                   0

 *  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0

 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

 * |-----------| SHFT_FT |       BASE_FT       |      BASE_CP      |

 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

 *

 * FUSE_SPARE_REALIGNMENT_REG:

 *    3                   2                   1                   0

 *  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0

 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

 * |---------------------------------------------------| SHIFT_CP  |

 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

/**

 * div64_s64_precise() - wrapper for div64_s64()

 * @a:  the dividend

 * @b:  the divisor

 *

 * Implements division with fairly accurate rounding instead of truncation by

 * shifting the dividend to the left by 16 so that the quotient has a

 * much higher precision.

 *

 * Return: the quotient of a / b.

 Scale up for increased precision division */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2014-2018, NVIDIA CORPORATION.  All rights reserved.

 *

 * This software is licensed under the terms of the GNU General Public

 * License version 2, as published by the Free Software Foundation, and

 * may be copied, distributed, and modified under those terms.

 *

 * This program is distributed in the hope that it will be useful,

 * but WITHOUT ANY WARRANTY; without even the implied warranty of

 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

 *

/*

 * Mask/shift bits in FUSE_TSENSOR_COMMON and

 * FUSE_TSENSOR_COMMON, which are described in

 * tegra_soctherm_fuse.c

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * ST Thermal Sensor Driver for syscfg based sensors.

 * Author: Ajit Pal Singh <ajitpal.singh@st.com>

 *

 * Copyright (C) 2003-2014 STMicroelectronics (R&D) Limited

 STiH415 */

 STiH416 */

 STiD127 */

 Private OPs for System Configuration Register based thermal sensors */

 Compatible device data for stih415 sas thermal sensor */

 Compatible device data for stih415 mpe thermal sensor */

 Compatible device data for stih416 sas thermal sensor */

 Compatible device data for stid127 thermal sensor */

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) STMicroelectronics 2018 - All Rights Reserved

 * Author: David Hernandez Sanchez <david.hernandezsanchez@st.com> for

 * STMicroelectronics.

 DTS register offsets */

 DTS_CFGR1 register mask definitions */

 DTS_T0VALR1 register mask definitions */

 DTS_RAMPVALR register mask definitions */

 DTS_ITR1 register mask definitions */

 DTS_DR register mask definitions */

 DTS_ITENR register mask definitions */

 DTS_ICIFR register mask definitions */

 Less significant bit position definitions */

 DTS_CFGR1 bit definitions */

 DTS_SR bit definitions */

 Bit definitions below are common for DTS_SR, DTS_ITENR and DTS_CIFR */

 Constants */

 30 celsius */

 130 celsius */

 Disable IT generation for low and high thresholds */

 Enable interrupts */

 Acknoledge all DTS irqs */

 Enable sensor */

	/*

	 * The DTS block can be enabled by setting TSx_EN bit in

	 * DTS_CFGRx register. It requires a startup time of

	 * 40μs. Use 5 ms as arbitrary timeout.

 Start continuous measuring */

 Stop measuring */

 Ensure stop is taken into account */

 Disable sensor */

 Ensure disable is taken into account */

 Figure out prescaler value for PCLK during calibration */

 Clear prescaler */

 Set prescaler. pclk_freq/prescaler < 1MHz */

 Select PCLK as reference clock */

 Set maximal sampling time for better precision */

 Measure with calibration */

 select trigger */

 Fill in DTS structure with factory sensor values */

 Retrieve engineering calibration temperature */

 Retrieve fmt0 and put it on Hz */

 Retrieve ramp coefficient */

 Figure out the CLK_PTAT frequency for a given temperature */

 Figure out the threshold sample number */

 Disable temperature interrupt */

 Disable IT generation */

 Erase threshold content */

	/*

	 * Disable low-temp if "low" is too small. As per thermal framework

	 * API, we use -INT_MAX rather than INT_MIN.

 add 0.5 of hysteresis due to measurement error */

 Disable high-temp if "high" is too big. */

 Write new threshod values*/

 Callback to get temperature from HW */

 Retrieve the number of periods sampled */

 Figure out the CLK_PTAT frequency */

 Figure out the temperature in mili celsius */

 Registers DTS irq to be visible by GIC */

 CONFIG_PM_SLEEP */

 sentinel */ }

 Populate sensor */

 Clear irq flags */

 Configure and enable HW sensor */

 Register IRQ into GIC */

	/*

	 * Thermal_zone doesn't enable hwmon as default,

	 * enable it here

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * ST Thermal Sensor Driver core routines

 * Author: Ajit Pal Singh <ajitpal.singh@st.com>

 *

 * Copyright (C) 2003-2014 STMicroelectronics (R&D) Limited

 The Thermal Framework expects millidegrees */

/*

 * Function to allocate regfields which are common

 * between syscfg and memory mapped based sensors

 Check if sensor calibration data is already written */

		/*

		 * Sensor calibration value not set by bootloader,

		 * default calibration data to be used

 Callback to get temperature from HW*/

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * ST Thermal Sensor Driver for memory mapped sensors.

 * Author: Ajit Pal Singh <ajitpal.singh@st.com>

 *

 * Copyright (C) 2003-2014 STMicroelectronics (R&D) Limited

 Power control bits for the memory mapped thermal sensor */

	/*

	 * According to the STIH416 MPE temp sensor data sheet -

	 * the PDN (Power Down Bit) and SRSTN (Soft Reset Bit) need to be

	 * written simultaneously for powering on and off the temperature

	 * sensor. regmap_update_bits() will be used to update the register.

 Private ops for the Memory Mapped based thermal sensors */

 Set upper critical threshold */

 Compatible device data stih416 mpe thermal sensor */

 Compatible device data stih407 thermal sensor */

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0

/*

 * Configfs interface for the NVMe target.

 * Copyright (c) 2015-2016 HGST, a Western Digital Company.

/*

 * nvmet_port Generic ConfigFS definitions.

 * Used in any place in the ConfigFS tree that refers to an address.

/*

 * Namespace structures & file operation functions below

 CONFIG_PCI_P2PDMA */

 CONFIG_NVME_TARGET_PASSTHRU */

 CONFIG_NVME_TARGET_PASSTHRU */

 passthru subsystems use the underlying controller's version */

 See Section 1.5 of NVMe 1.4 */

	/*

	 * The discovery NQN must be different from subsystem NQN.

/*

 * Subsystem structures & folder operation functions below

/*

 * Discovery Service subsystem definitions

/*

 * Ports definitions.

 Let inflight controllers teardown complete */

 < 0 == let the transport choose */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2016 Avago Technologies.  All rights reserved.

 *************************** Data Structures/Defines ****************** */

 for an LS RQST RCV */

 only if RS */

 tgtport->ls_rcv_list */

 for an LS RQST XMT */

 tgtport->ls_req_list */

 desired maximum for a single sequence - if sg list allows it */

 tgtport->fcp_list */

 nvmet_fc_target_list */

 dev for dma mapping */

 array of fcp_iods */

/*

 * Association and Connection IDs:

 *

 * Association ID will have random number in upper 6 bytes and zero

 *   in lower 2 bytes

 *

 * Connection IDs will be Association ID with QID or'd in lower 2 bytes

 *

 * note: Association ID = Connection ID for queue 0

 *************************** Globals **************************** */

 *********************** FC-NVME DMA Handling **************************** */

/*

 * The fcloop device passes in a NULL device pointer. Real LLD's will

 * pass in a valid device pointer. If NULL is passed to the dma mapping

 * routines, depending on the platform, it may or may not succeed, and

 * may crash.

 *

 * As such:

 * Wrapper all the dma routines and check the dev pointer.

 *

 * If simple mappings (return just a dma address, we'll noop them,

 * returning a dma address of 0.

 *

 * On more complex mappings (dma_map_sg), a pseudo routine fills

 * in the scatter list, setting all dma addresses to 0.

 pseudo dma_map_sg call */

 ********************** FC-NVME LS XMT Handling ************************* */

 don't wait for completion */

 fc-nvme target doesn't care about success or failure of cmd */

/*

 * This routine sends a FC-NVME LS to disconnect (aka terminate)

 * the FC-NVME Association.  Terminating the association also

 * terminates the FC-NVME connections (per queue, both admin and io

 * queues) that are part of the association. E.g. things are torn

 * down, and the related FC-NVME Association ID and Connection IDs

 * become invalid.

 *

 * The behavior of the fc-nvme target is such that it's

 * understanding of the association and connections will implicitly

 * be torn down. The action is implicit as it may be due to a loss of

 * connectivity with the fc-nvme host, so the target may never get a

 * response even if it tried.  As such, the action of this routine

 * is to asynchronously send the LS, ignore any results of the LS, and

 * continue on with terminating the association. If the fc-nvme host

 * is present and receives the LS, it too can tear down.

	/*

	 * If ls_req is NULL or no hosthandle, it's an older lldd and no

	 * message is normal. Otherwise, send unless the hostport has

	 * already been invalidated by the lldd.

 *********************** FC-NVME Port Management ************************ */

		/*

		 * no queue reference is taken, as it was taken by the

		 * queue lookup just prior to the allocation. The iod

		 * will "inherit" that reference.

	/*

	 * put all admin cmds on hw queue id 0. All io commands go to

	 * the respective hw queue based on a modulo basis

 Submit deferred IO for processing */

 release the queue lookup reference on the completed IO */

 Re-use the fod for the next pending cmd that was deferred */

 deferfcp can be reused for another IO at a later date */

 Save NVME CMD IO in fod */

 Setup new fcpreq to be processed */

 inform LLDD IO is now being processed */

	/*

	 * Leave the queue lookup get reference taken when

	 * fod was originally allocated.

 if not connected, nothing to do */

 abort outstanding io's */

			/*

			 * only call lldd abort routine if waiting for

			 * writedata. other outstanding ops should finish

			 * on their own.

 Cleanup defer'ed IOs in queue */

 release the queue lookup reference */

 if LLDD not implemented, leave as NULL */

 if LLDD not implemented, leave as NULL */

	/*

	 * take reference for what will be the newly allocated hostport if

	 * we end up using a new allocation

 no new allocation - release reference */

 no new allocation - release reference */

 new allocation not needed */

 no new allocation - release reference */

 Send Disconnect now that all i/o has completed */

 if pending Rcv Disconnect Association LS, send rsp now */

 if already terminating, do nothing */

/*

 * called when a targetport deregisters. Breaks the relationship

 * with the nvmet port, but leaves the port_entry in place so that

 * re-registration can resume operation.

/*

 * called when a new targetport is registered. Looks in the

 * existing nvmet port_entries to see if the nvmet layer is

 * configured for the targetport's wwn's. (the targetport existed,

 * nvmet configured, the lldd unregistered the tgtport, and is now

 * reregistering the same targetport).  If so, set the nvmet port

 * port entry on the targetport.

/**

 * nvme_fc_register_targetport - transport entry point called by an

 *                              LLDD to register the existence of a local

 *                              NVME subystem FC port.

 * @pinfo:     pointer to information about the port to be registered

 * @template:  LLDD entrypoints and operational parameters for the port

 * @dev:       physical hardware device node port corresponds to. Will be

 *             used for DMA mappings

 * @portptr:   pointer to a local port pointer. Upon success, the routine

 *             will allocate a nvme_fc_local_port structure and place its

 *             address in the local port pointer. Upon failure, local port

 *             pointer will be set to NULL.

 *

 * Returns:

 * a completion status. Must be 0 upon success; a negative errno

 * (ex: -ENXIO) upon failure.

 let the LLDD know we've finished tearing it down */

 already deleting - release local reference */

/**

 * nvmet_fc_invalidate_host - transport entry point called by an LLDD

 *                       to remove references to a hosthandle for LS's.

 *

 * The nvmet-fc layer ensures that any references to the hosthandle

 * on the targetport are forgotten (set to NULL).  The LLDD will

 * typically call this when a login with a remote host port has been

 * lost, thus LS's for the remote host port are no longer possible.

 *

 * If an LS request is outstanding to the targetport/hosthandle (or

 * issued concurrently with the call to invalidate the host), the

 * LLDD is responsible for terminating/aborting the LS and completing

 * the LS request. It is recommended that these terminations/aborts

 * occur after calling to invalidate the host handle to avoid additional

 * retries by the nvmet-fc transport. The nvmet-fc transport may

 * continue to reference host handle while it cleans up outstanding

 * NVME associations. The nvmet-fc transport will call the

 * ops->host_release() callback to notify the LLDD that all references

 * are complete and the related host handle can be recovered.

 * Note: if there are no references, the callback may be called before

 * the invalidate host call returns.

 *

 * @target_port: pointer to the (registered) target port that a prior

 *              LS was received on and which supplied the transport the

 *              hosthandle.

 * @hosthandle: the handle (pointer) that represents the host port

 *              that no longer has connectivity and that LS's should

 *              no longer be directed to.

 already deleting - release local reference */

 if there's nothing to wait for - call the callback */

/*

 * nvmet layer has called to terminate an association

 this is a bit ugly, but don't want to make locks layered */

 already deleting - release local reference */

/**

 * nvme_fc_unregister_targetport - transport entry point called by an

 *                              LLDD to deregister/remove a previously

 *                              registered a local NVME subsystem FC port.

 * @target_port: pointer to the (registered) target port that is to be

 *               deregistered.

 *

 * Returns:

 * a completion status. Must be 0 upon success; a negative errno

 * (ex: -ENXIO) upon failure.

 terminate any outstanding associations */

	/*

	 * should terminate LS's as well. However, LS's will be generated

	 * at the tail end of association termination, so they likely don't

	 * exist yet. And even if they did, it's worthwhile to just let

	 * them finish and targetport ref counting will clean things up.

 ********************** FC-NVME LS RCV Handling ************************* */

	/*

	 * FC-NVME spec changes. There are initiators sending different

	 * lengths as padding sizes for Create Association Cmd descriptor

	 * was incorrect.

	 * Accept anything of "minimum" length. Assume format per 1.15

	 * spec (with HOSTID reduced to 16 bytes), ignore how long the

	 * trailing pad length is.

 new association w/ admin queue */

 best place to init value */

 format a response */

 new io queue */

 release get taken in nvmet_fc_find_target_assoc */

 best place to init value */

 format a response */

/*

 * Returns true if the LS response is to be transmit

 * Returns false if the LS response is to be delayed

 match an active association - takes an assoc ref if !NULL */

 format a response */

 release get taken in nvmet_fc_find_target_assoc */

	/*

	 * The rules for LS response says the response cannot

	 * go back until ABTS's have been sent for all outstanding

	 * I/O and a Disconnect Association LS has been sent.

	 * So... save off the Disconnect LS to send the response

	 * later. If there was a prior LS already saved, replace

	 * it with the newer one and send a can't perform reject

	 * on the older one.

 overwrite good response with bogus failure */

 ok to use rqst, LS is same */

 *********************** NVME Ctrl Routines **************************** */

/*

 * Actual processing routine for received FC-NVME LS Requests from the LLD

 Be preventative. handlers will later set to valid length */

	/*

	 * handlers:

	 *   parse request input, execute the request, and format the

	 *   LS response

 Creates Association and initial Admin Queue/Connection */

 Creates an IO Queue/Connection */

 Terminate a Queue/Connection or the Association */

/*

 * Actual processing routine for received FC-NVME LS Requests from the LLD

/**

 * nvmet_fc_rcv_ls_req - transport entry point called by an LLDD

 *                       upon the reception of a NVME LS request.

 *

 * The nvmet-fc layer will copy payload to an internal structure for

 * processing.  As such, upon completion of the routine, the LLDD may

 * immediately free/reuse the LS request buffer passed in the call.

 *

 * If this routine returns error, the LLDD should abort the exchange.

 *

 * @target_port: pointer to the (registered) target port the LS was

 *              received on.

 * @hosthandle: pointer to the host specific data, gets stored in iod.

 * @lsrsp:      pointer to a lsrsp structure to be used to reference

 *              the exchange corresponding to the LS.

 * @lsreqbuf:   pointer to the buffer containing the LS Request

 * @lsreqbuf_len: length, in bytes, of the received LS request

/*

 * **********************

 * Start of FCP handling

 * **********************

 note: write from initiator perspective */

 egad, this is ugly. And sqtail is just a best guess */

/*

 * Prep RSP payload.

 * May be a NVMET_FCOP_RSP or NVMET_FCOP_READDATA_RSP op

	/*

	 * check to see if we can send a 0's rsp.

	 *   Note: to send a 0's response, the NVME-FC host transport will

	 *   recreate the CQE. The host transport knows: sq id, SQHD (last

	 *   seen in an ersp), and command_id. Thus it will create a

	 *   zero-filled CQE with those known fields filled in. Transport

	 *   must send an ersp for any condition where the cqe won't match

	 *   this.

	 *

	 * Here are the FC-NVME mandated cases where we must send an ersp:

	 *  every N responses, where N=ersp_ratio

	 *  force fabric commands to send ersp's (not in FC-NVME but good

	 *    practice)

	 *  normal cmds: any time status is non-zero, or status is zero

	 *     but words 0 or 1 are non-zero.

	 *  the SQ is 90% or more full

	 *  the cmd is a fused command

	 *  transferred data length not equal to cmd iu length

 re-set the fields */

 data no longer needed */

	/*

	 * if an ABTS was received or we issued the fcp_abort early

	 * don't call abort routine again.

 no need to take lock - lock was taken earlier to get here */

	/*

	 * for next sequence:

	 *  break at a sg element boundary

	 *  attempt to keep sequence length capped at

	 *    NVMET_FC_MAX_SEQ_LENGTH but allow sequence to

	 *    be longer if a single sg element is larger

	 *    than that amount. This is done to avoid creating

	 *    a new sg list to use for the tgtport api.

	/*

	 * If the last READDATA request: check if LLDD supports

	 * combined xfr with response.

		/*

		 * should be ok to set w/o lock as its in the thread of

		 * execution (not an async timer routine) and doesn't

		 * contend with any clearing action

 NVMET_FCOP_READDATA or NVMET_FCOP_READDATA_RSP */ {

 if in the middle of an io and we need to tear down */

/*

 * actual done handler for FCP operations when completed by the lldd

 transfer the next chunk */

 data transfer complete, resume with nvmet layer */

 success */

 data no longer needed */

 transfer the next chunk */

 data transfer complete, send response */

 data no longer needed */

/*

 * actual completion handler after execution by the nvmet layer

 if we have a CQE, snoop the last sq_head value */

 if an error handling the cmd post initial parsing */

 fudge up a failed CQE status for our transport error */

 echo last cqe sqhd */

		/*

		 * try to push the data even if the SQE status is non-zero.

		 * There may be a status where data still was intended to

		 * be moved

 push the data over before sending rsp */

 writes & no data - fall thru */

 data no longer needed */

/*

 * Actual processing routine for received FC-NVME I/O Requests from the LLD

	/*

	 * Fused commands are currently not supported in the linux

	 * implementation.

	 *

	 * As such, the implementation of the FC transport does not

	 * look at the fused commands and order delivery to the upper

	 * layer until we have both based on csn.

 clear any response payload */

 bad SQE content or invalid ctrl state */

 nvmet layer has already called op done to send rsp. */

 keep a running counter of tail position */

 pull the data over before invoking nvmet layer */

	/*

	 * Reads or no data:

	 *

	 * can invoke the nvmet_layer now. If read data, cmd completion will

	 * push the data

/**

 * nvmet_fc_rcv_fcp_req - transport entry point called by an LLDD

 *                       upon the reception of a NVME FCP CMD IU.

 *

 * Pass a FC-NVME FCP CMD IU received from the FC link to the nvmet-fc

 * layer for processing.

 *

 * The nvmet_fc layer allocates a local job structure (struct

 * nvmet_fc_fcp_iod) from the queue for the io and copies the

 * CMD IU buffer to the job structure. As such, on a successful

 * completion (returns 0), the LLDD may immediately free/reuse

 * the CMD IU buffer passed in the call.

 *

 * However, in some circumstances, due to the packetized nature of FC

 * and the api of the FC LLDD which may issue a hw command to send the

 * response, but the LLDD may not get the hw completion for that command

 * and upcall the nvmet_fc layer before a new command may be

 * asynchronously received - its possible for a command to be received

 * before the LLDD and nvmet_fc have recycled the job structure. It gives

 * the appearance of more commands received than fits in the sq.

 * To alleviate this scenario, a temporary queue is maintained in the

 * transport for pending LLDD requests waiting for a queue job structure.

 * In these "overrun" cases, a temporary queue element is allocated

 * the LLDD request and CMD iu buffer information remembered, and the

 * routine returns a -EOVERFLOW status. Subsequently, when a queue job

 * structure is freed, it is immediately reallocated for anything on the

 * pending request list. The LLDDs defer_rcv() callback is called,

 * informing the LLDD that it may reuse the CMD IU buffer, and the io

 * is then started normally with the transport.

 *

 * The LLDD, when receiving an -EOVERFLOW completion status, is to treat

 * the completion as successful but must not reuse the CMD IU buffer

 * until the LLDD's defer_rcv() callback has been called for the

 * corresponding struct nvmefc_tgt_fcp_req pointer.

 *

 * If there is any other condition in which an error occurs, the

 * transport will return a non-zero status indicating the error.

 * In all cases other than -EOVERFLOW, the transport has not accepted the

 * request and the LLDD should abort the exchange.

 *

 * @target_port: pointer to the (registered) target port the FCP CMD IU

 *              was received on.

 * @fcpreq:     pointer to a fcpreq request structure to be used to reference

 *              the exchange corresponding to the FCP Exchange.

 * @cmdiubuf:   pointer to the buffer containing the FCP CMD IU

 * @cmdiubuf_len: length, in bytes, of the received FCP CMD IU

 validate iu, so the connection id can be used to find the queue */

	/*

	 * note: reference taken by find_target_queue

	 * After successful fod allocation, the fod will inherit the

	 * ownership of that reference and will remove the reference

	 * when the fod is freed.

 release the queue lookup reference */

 Just re-use one that was previously allocated */

 Now we need to dynamically allocate one */

 release the queue lookup reference */

 For now, use rspaddr / rsplen to save payload information */

 defer processing till a fod becomes available */

 NOTE: the queue lookup reference is still valid */

/**

 * nvmet_fc_rcv_fcp_abort - transport entry point called by an LLDD

 *                       upon the reception of an ABTS for a FCP command

 *

 * Notify the transport that an ABTS has been received for a FCP command

 * that had been given to the transport via nvmet_fc_rcv_fcp_req(). The

 * LLDD believes the command is still being worked on

 * (template_ops->fcp_req_release() has not been called).

 *

 * The transport will wait for any outstanding work (an op to the LLDD,

 * which the lldd should complete with error due to the ABTS; or the

 * completion from the nvmet layer of the nvme command), then will

 * stop processing and call the nvmet_fc_rcv_fcp_req() callback to

 * return the i/o context to the LLDD.  The LLDD may send the BA_ACC

 * to the ABTS either after return from this function (assuming any

 * outstanding op work has been terminated) or upon the callback being

 * called.

 *

 * @target_port: pointer to the (registered) target port the FCP CMD IU

 *              was received on.

 * @fcpreq:     pointer to the fcpreq request structure that corresponds

 *              to the exchange that received the ABTS.

 job appears to have already completed, ignore abort */

		/*

		 * mark as abort. The abort handler, invoked upon completion

		 * of any work, will detect the aborted status and do the

		 * callback.

/*

 * This routine validates and extracts the WWN's from the TRADDR string.

 * As kernel parsers need the 0x to determine number base, universally

 * build string to parse with 0x prefix before parsing name strings.

 validate if string is one of the 2 allowed formats */

 validate the address info */

 map the traddr address info to a target port */

 a FC port can only be 1 nvmet port id */

 sanity check - all lports should be removed */

 SPDX-License-Identifier: GPL-2.0

/*

 * NVMe over Fabrics RDMA target.

 * Copyright (c) 2015-2016 HGST, a Western Digital Company.

/*

 * We allow at least 1 page, up to 4 SGEs, and up to 16KB of inline data

 Assume mpsmin == device_page_size == 4KB */

 NVMe command / RDMA RECV */

 NVMe CQE / RDMA SEND */

 Data In / RDMA READ */

 Data Out / RDMA WRITE */

 for WRITE_INSERT/READ_STRIP no wire domain */

 Clear the PRACT bit since HCA will generate/verify the PI */

 PI is added by the HW */

 for WRITE_PASS/READ_PASS both wire/memory domains exist */

		/*

		 * we didn't setup the controller yet in case

		 * of admin connect error, just disconnect and

		 * cleanup the queue

	/*

	 * Upon RDMA completion check the signature status

	 * - if succeeded send good NVMe response

	 * - if failed send bad NVMe response with appropriate error

 no data command? */

 no data command? */

		/*

		 * we get here only under memory pressure,

		 * silently drop and have the host retry

		 * as we can't even fail it.

		/*

		 * If SRQs aren't supported we just go ahead and use normal

		 * non-shared receive queues.

	/*

	 * Reserve CQ slots for RECV + RDMA_READ/RDMA_WRITE + RDMA_SEND.

 +1 for drain */

 +1 for drain */

	/*

	 * req->hsqsize corresponds to our recv queue size plus 1

	 * req->hrqsize corresponds to our send queue size

 XXX: Should we enforce some kind of max for IO queues? */

	/*

	 * Schedules the actual release because calling rdma_destroy_id from

	 * inside a CM callback would trigger a deadlock. (great API design..)

	/*

	 * Spread the io queues across completion vectors,

	 * but still keep all admin queues on vector 0.

 Let inflight controller teardown complete */

		/*

		 * Don't destroy the cm_id in free path, as we implicitly

		 * destroy the cm_id here with non-zero ret code.

/**

 * nvme_rdma_device_removal() - Handle RDMA device removal

 * @cm_id:	rdma_cm id, used for nvmet port

 * @queue:      nvmet rdma queue (cm id qp_context)

 *

 * DEVICE_REMOVAL event notifies us that the RDMA device is about

 * to unplug. Note that this event can be generated on a normal

 * queue cm_id and/or a device bound listener cm_id (where in this

 * case queue will be null).

 *

 * We registered an ib_client to handle device removal for queues,

 * so we only need to handle the listening port cm_ids. In this case

 * we nullify the priv to prevent double cm_id destruction and destroying

 * the cm_id implicitely by returning a non-zero rc to the callout.

		/*

		 * This is a queue cm_id. we have registered

		 * an ib_client to handle queues removal

		 * so don't interfear and just return.

	/*

	 * This is a listener cm_id. Make sure that

	 * future remove_port won't invoke a double

	 * cm_id destroy. use atomic xchg to make sure

	 * we don't compete with remove_port.

	/*

	 * We need to return 1 so that the core will destroy

	 * it's own ID.  What a great API design..

	/*

	 * Destroy the remaining queues, which are not belong to any

	 * controller yet. Do it here after the RDMA-CM was destroyed

	 * guarantees that no new queue will be created.

	/*

	 * Allow both IPv4 and IPv6 sockets to bind a single port

	 * at the same time.

	/*

	 * IB Device that is used by nvmet controllers is being removed,

	 * delete all queues using this device.

 1 == NVMF_TRTYPE_RDMA */

 SPDX-License-Identifier: GPL-2.0

/*

 * NVMe admin command implementation.

 * Copyright (c) 2015-2016 HGST, a Western Digital Company.

 NUMD is a 0's based value */

 we don't have the right data for file backed ns */

 we don't have the right data for file backed ns */

 start beyond hdr */

 copy the header last once we know the number of groups */

		/*

		 * We only support a single firmware slot which always is

		 * active, so we can zero out the whole firmware slot log and

		 * still claim to fully implement this mandatory log page.

 XXX: figure out how to assign real vendors IDs. */

	/*

	 * XXX: figure out how we can assign a IEEE OUI, but until then

	 * the safest is to leave it as zeroes.

 we support multiple ports, multiples hosts and ANA: */

 Limit MDTS according to transport capability */

 XXX: figure out what to do about RTD3R/RTD3 */

	/*

	 * We don't really have a practical limit on the number of abort

	 * comands.  But we don't do anything useful for abort either, so

	 * no point in allowing more abort commands than the spec requires.

 first slot is read-only, only one slot supported */

 We support keep-alive timeout in granularity of seconds */

 no enforcement soft-limit for maxcmd - pick arbitrary high value */

 XXX: don't report vwc if the underlying device is write through */

	/*

	 * We can't support atomic writes bigger than a LBA without support

	 * from the backend device.

 we always support SGLs */

	/*

	 * Max command capsule size is sqe + in-capsule data size.

	 * Disable in-capsule data for Metadata capable controllers.

 Max response capsule size is cqe */

 random value */

	/*

	 * Meh, we don't really support any power state.  Fake up the same

	 * values that qemu does.

 write protect and no write protect */

 return an all zeroed buffer if we can't find an active namespace */

	/*

	 * nuse = ncap = nsze isn't always true, but we have no way to find

	 * that out from the underlying device.

	/*

	 * We just provide a single LBA format that matches what the

	 * underlying device reports.

	/*

	 * Our namespace might always be shared.  Not just with other

	 * controllers, but also with any other user of the block device.

/*

 * A "minimum viable" abort implementation: the command is mandatory in the

 * spec, but we are not required to do any useful work.  We couldn't really

 * do a useful abort, so don't bother even with waiting for the command

 * to be exectuted and return immediately telling the command to abort

 * wasn't found.

	/*

	 * These features are mandatory in the spec, but we don't

	 * have a useful way to implement them.  We'll eventually

	 * need to come up with some fake values for these.

 need 128-bit host identifier flag */

 SPDX-License-Identifier: GPL-2.0

/*

 * NVMe over Fabrics TCP target.

 * Copyright (c) 2018 Lightbits Labs. All rights reserved.

/* Define the socket priority to use for connections were it is desirable

 * that the NIC consider performing optimized packet processing or filtering.

 * A non-zero value being sufficient to indicate general consideration of any

 * possible optimization.  Making it a module param allows for alternative

 * values that may be unique for some NIC implementations.

/* Define a time period (in usecs) that io_work() shall sample an activated

 * queue before determining it to be idle.  This optional module behavior

 * can enable NIC solutions that support socket optimized packet processing

 * using advanced interrupt moderation techniques.

 send state */

 send state */

 recv state */

 digest state */

 We didn't allocate cmds yet, send 0xffff */

		/*

		 * Wait for inline data before processing the response.

		 * Avoid using helpers, this might happen before

		 * nvmet_req_init is completed.

 Done with sg?*/

 16M arbitrary limit */

 FIXME: use path and transport errors */

 This should never happen */

 send back R2T */

 fallthru */

 fatal */

 fatal */

	/*

	 * Requeue the worker if idle deadline period is in progress or any

	 * ops activity was recorded during the do-while loop above.

 failed in connect */

 FALLTHRU */

	/*

	 * Cleanup whatever is sitting in the TCP transmit queue on socket

	 * close. This is done to prevent stale data from being sent should

	 * the network connection be restored before TCP times out.

 Set socket type of service */

		/*

		 * If the socket is already closing, don't even start

		 * consuming it

	/*

	 * Destroy the remaining queues, which are not belong to any

	 * controller yet.

 Let inflight controller teardown complete */

 3 == NVMF_TRTYPE_TCP */

 SPDX-License-Identifier: GPL-2.0

/*

 * NVMe ZNS-ZBD command implementation.

 * Copyright (C) 2021 Western Digital Corporation or its affiliates.

/*

 * We set the Memory Page Size Minimum (MPSMIN) for target controller to 0

 * which gets added by 12 in the nvme_enable_ctrl() which results in 2^12 = 4k

 * as page_shift value. When calculating the ZASL use shift by 12.

	/*

	 * Zone Append Size Limit (zasl) is expressed as a power of 2 value

	 * with the minimum memory page size (i.e. 12) as unit.

	/*

	 * Generic zoned block devices may have a smaller last zone which is

	 * not supported by ZNS. Exclude zoned drives that have such smaller

	 * last zone.

	/*

	 * ZNS does not define a conventional zone type. If the underlying

	 * device has a bitmap set indicating the existence of conventional

	 * zones, reject the device. Otherwise, use report zones to detect if

	 * the device has conventional zones.

 leave the place for report zone header */

	/*

	 * When partial bit is set nr_zones must indicate the number of zone

	 * descriptors actually transferred.

 Scan and build bitmap of the eligible zones */

 We scanned all the zones */

 This may take a while, so be nice to others */

 this is needed to quiet compiler warning */

 when select all bit is set slba field is ignored */

 Request is completed on len mismatch in nvmet_check_transter_len() */

 SPDX-License-Identifier: GPL-2.0

/*

 * NVMe Over Fabrics Target Passthrough command implementation.

 *

 * Copyright (c) 2017-2018 Western Digital Corporation or its

 * affiliates.

 * Copyright (c) 2019-2020, Eideticom Inc.

 *

/*

 * xarray to maintain one passthru subsystem per nvme controller.

	/*

	 * Multiple command set support can only be declared if the underlying

	 * controller actually supports it.

	/*

	 * The passthru NVMe driver may have a limit on the number of segments

	 * which depends on the host's memory fragementation. To solve this,

	 * ensure mdts is limited to the pages equal to the number of segments.

	/*

	 * nvmet_passthru_map_sg is limitted to using a single bio so limit

	 * the mdts based on BIO_MAX_VECS as well

	/*

	 * We export aerl limit for the fabrics controller, update this when

	 * passthru based aerl support is added.

 emulate kas as most of the PCIe ctrl don't have a support for kas */

 don't support host memory buffer */

 don't support fuse commands */

 we always support SGLs */

	/*

	 * When passsthru controller is setup using nvme-loop transport it will

	 * export the passthru ctrl subsysnqn (PCIe NVMe ctrl) and will fail in

	 * the nvme/host/core.c in the nvme_init_subsystem()->nvme_active_ctrl()

	 * code path with duplicate ctr subsynqn. In order to prevent that we

	 * mask the passthru-ctrl subsysnqn with the target ctrl subsysnqn.

 use fabric id-ctrl values */

 Support multipath connections with fabrics */

 Disable reservations, see nvmet_parse_passthru_io_cmd() */

	/*

	 * Presently the NVMEof target code does not support sending

	 * metadata, so we must disable it here. This should be updated

	 * once target starts supporting metadata.

	/*

	 * If there are effects for the command we are about to execute, or

	 * an end_req function we need to use nvme_execute_passthru_rq()

	 * synchronously in a work item seeing the end_req function and

	 * nvme_passthru_end() can't be called in the request done callback

	 * which is typically in interrupt context.

/*

 * We need to emulate set host behaviour to ensure that any requested

 * behaviour of the target's host matches the requested behaviour

 * of the device's host and fail otherwise.

 Reject any commands with non-sgl flags set (ie. fused commands) */

		/*

		 * Reservations cannot be supported properly because the

		 * underlying device has no way of differentiating different

		 * hosts that connect via fabrics. This could potentially be

		 * emulated in the future if regular targets grow support for

		 * this feature.

/*

 * Only features that are emulated or specifically allowed in the list  are

 * passed down to the controller. This function implements the allow list for

 * both get and set features.

 There is no support for forwarding ASYNC events */

 The IRQ settings will not apply to the target controller */

		/*

		 * Any HMB that's set will not be passed through and will

		 * not work as expected

		/*

		 * The Pre-Boot Software Load Count doesn't make much

		 * sense for a target to export

 No reservations, see nvmet_parse_passthru_io_cmd() */

 Reject any commands with non-sgl flags set (ie. fused commands) */

	/*

	 * Passthru all vendor specific commands

		/*

		 * Most PCIe ctrls don't support keep alive cmd, we route keep

		 * alive to the non-passthru mode. In future please change this

		 * code when PCIe ctrls with keep alive support available.

 Reject commands not in the allowlist above */

 SPDX-License-Identifier: GPL-2.0

/*

 * NVMe Fabrics command implementation.

 * Copyright (c) 2015-2016 HGST, a Western Digital Company.

 note: convert queue size from 0's-based value to 1's-based value */

 zero out initial completion result, assign values as needed */

 zero out initial completion result, assign values as needed */

 pass back cntlid for successful completion */

 SPDX-License-Identifier: GPL-2.0

/*

 * Common code for the NVMe target.

 * Copyright (c) 2015-2016 HGST, a Western Digital Company.

/*

 * This read/write semaphore is used to synchronize access to configuration

 * information on a target system that will result in discovery log page

 * information change for at least one host.

 * The full list of resources to protected by this semaphore is:

 *

 *  - subsystems list

 *  - per-subsystem allowed hosts list

 *  - allow_any_host subsystem attribute

 *  - nvmet_genctr

 *  - the nvmet_transports array

 *

 * When updating any of those lists/structures write lock should be obtained,

 * while when reading (popolating discovery log page or checking host-subsystem

 * link) read lock is obtained to allow concurrent reads.

	/*

	 * If the user requested PI support and the transport isn't pi capable,

	 * don't enable the port.

 If the transport didn't set inline_data_size, then disable it. */

		/*

		 * Right now we just check that there is p2pmem available so

		 * we can report an error to the user right away if there

		 * is not. We'll find the actual device to use once we

		 * setup the controller when the port's device is available.

/*

 * Note: ctrl->subsys->lock should be held when calling this function

	/*

	 * Now that we removed the namespaces from the lookup list, we

	 * can kill the per_cpu ref and wait for any remaining references

	 * to be dropped, as well as a RCU grace period for anyone only

	 * using the namepace under rcu_read_lock().  Note that we can't

	 * use call_rcu here as we need to ensure the namespaces have

	 * been fully destroyed before unloading the module.

 set the more bit for this request */

	/*

	 * If this is the admin queue, complete all AERs so that our

	 * queue doesn't have outstanding requests on it.

		/*

		 * The teardown flow may take some time, and the host may not

		 * send us keep-alive during this period, hence reset the

		 * traffic based keep-alive timer so we don't trigger a

		 * controller teardown as a result of a keep-alive expiration.

 allows reusing the queue later */

 no support for fused commands yet */

	/*

	 * For fabrics, PSDT field shall describe metadata pointer (MPTR) that

	 * contains an address of a single contiguous physical buffer that is

	 * byte aligned.

 will return an error for any non-connect command: */

	/*

	 * Only I/O controllers should verify iosqes,iocqes.

	 * Strictly speaking, the spec says a discovery controller

	 * should verify iosqes,iocqes are zeroed, however that

	 * would break backwards compatibility, so don't enforce it.

	/*

	 * Controllers that are not yet enabled should not really enforce the

	 * keep alive timeout, but we still want to track a timeout and cleanup

	 * in case a host died before it enabled the controller.  Hence, simply

	 * reset the keep alive timer when the controller is enabled.

 XXX: tear down queues? */

 command sets supported: NVMe command set: */

 Controller supports one or more I/O Command Sets */

 CC.EN timeout in 500msec units: */

 maximum queue entries supported: */

 ctrl found */

 ctrl not found */

 allow all access to disc subsys */

/*

 * Note: ctrl->subsys->lock should be held when calling this function

/*

 * Note: ctrl->subsys->lock should be held when calling this function

	/*

	 * Discovery controllers may use some arbitrary high value

	 * in order to cleanup stale discovery sessions

 keep-alive timeout in seconds */

 generate a random serial number as our controllers are ephemeral: */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2016 Avago Technologies.  All rights reserved.

 H2T or T2H */

 fcloop_rport->ls_list */

		/*

		 * callee may free memory containing tls_req.

		 * do not reference lsreq after this.

		/*

		 * callee may free memory containing tls_req.

		 * do not reference lsreq after this.

	/*

	 * hosthandle should be the dst.rport value.

	 * hosthandle ignored as fcloop currently is

	 * 1:1 tgtport vs remoteport

 host handle ignored for now */

/*

 * Simulate reception of RSCN and converting it to a initiator transport

 * call to rescan a remote port.

 release original io reference on tgt struct */

 fabrics opcode will have a bit set above 1st byte */

/*

 * Routine to parse io and determine if the io is to be dropped.

 * Returns:

 *  0 if io is not obstructed

 *  1 if io was dropped

 remove reference taken in original abort downcall */

 call_host_done releases reference for abort downcall */

/*

 * FCP IO operation done by target completion.

 * call back up initiator "done" flows.

 illegal - call while i/o active */

 target transport has aborted i/o prior */

	/*

	 * if fcpreq is NULL, the I/O has been aborted (from

	 * initiator side). For the target side, act as if all is well

	 * but don't actually move data.

 Fall-Thru to RSP handling */

	/*

	 * mark aborted only in case there were 2 threads in transport

	 * (one doing io, other doing abort) and only kills ops posted

	 * after the abort request

	/*

	 * nothing more to do. If io wasn't active, the transport should

	 * immediately call the req_release. If it was active, the op

	 * will complete, and the lldd should call req_release.

 abort has already been called */

 break initiator/target relationship for io */

 leave the reference while the work item is scheduled */

		/*

		 * as the io has already had the done callback made,

		 * nothing more to do. So release the reference taken above

 release any threads waiting for the unreg to complete */

 sizes of additional private data for data structures */

 optional features */

 sizes of additional private data for data structures */

 everything there ? */

 success */

 free only if we're going to fail */

 everything there ? */

 success */

 success */

	/* the check to drop routine uses instance + count to know when

	 * to end. Thus, if dropping 1 instance, count should be 0.

	 * so subtract 1 from the count.

 SPDX-License-Identifier: GPL-2.0

/*

 * Discovery service for the NVMe over Fabrics target.

 * Copyright (C) 2016 Intel Corporation. All rights reserved.

 If transport can signal change, notify transport */

 we support only dynamic controllers */

/*

 * nvmet_set_disc_traddr - set a correct discovery log entry traddr

 *

 * IP based transports (e.g RDMA) can listen on "any" ipv4/ipv6 addresses

 * (INADDR_ANY or IN6ADDR_ANY_INIT). The discovery log page traddr reply

 * must not contain that "any" IP address. If the transport implements

 * .disc_traddr, use it. this callback will set the discovery traddr

 * from the req->port address in case the port in question listens

 * "any" IP address.

 Spec requires dword aligned offsets */

	/*

	 * Make sure we're passing at least a buffer of response header size.

	 * If host provided data len is less than the header size, only the

	 * number of bytes requested by host will be sent to host.

 no limit on data transfer sizes for now */

 no enforcement soft-limit for maxcmd - pick arbitrary high value */

 we always support SGLs */

 SPDX-License-Identifier: GPL-2.0

/*

 * NVMe I/O command implementation.

 * Copyright (c) 2015-2016 HGST, a Western Digital Company.

 Number of logical blocks per physical block. */

 Logical blocks per physical block, 0's based. */

	/*

	 * For NVMe 1.2 and later, bit 1 indicates that the fields NAWUN,

	 * NAWUPF, and NACWU are defined for this namespace and should be

	 * used by the host for this namespace instead of the AWUN, AWUPF,

	 * and ACWU fields in the Identify Controller data structure. If

	 * any of these fields are zero that means that the corresponding

	 * field from the identify controller data structure should be used.

	/*

	 * Bit 4 indicates that the fields NPWG, NPWA, NPDG, NPDA, and

	 * NOWS are defined for this namespace and should be used by

	 * the host for I/O optimization.

 NPWG = Namespace Preferred Write Granularity. 0's based */

 NPWA = Namespace Preferred Write Alignment. 0's based */

 NPDG = Namespace Preferred Deallocate Granularity. 0's based */

 NPDG = Namespace Preferred Deallocate Alignment */

 NOWS = Namespace Optimal Write Size */

 Unsupported metadata type */

	/*

	 * Right now there exists M : 1 mapping between block layer error

	 * to the NVMe status code (see nvme_error_status()). For consistency,

	 * when we reverse map we use most appropriate NVMe Status code from

	 * the group of the NVMe staus codes used in the nvme_error_status().

 virtual start sector must be in integrity interval units */

 CONFIG_BLK_DEV_INTEGRITY */

 Not supported yet */

 SPDX-License-Identifier: GPL-2.0

/*

 * NVMe over Fabrics loopback device.

 * Copyright (c) 2015-2016 HGST, a Western Digital Company.

	/*

	 * AEN requests are special as they don't time out and can

	 * survive any kind of queue freeze and often don't respond to

	 * aborts.  We don't even bother to allocate a struct request

	 * for them but rather special case them here.

	/*

	 * flush_end_io() can be called recursively for us, so use our own

	 * lock class key for avoiding lockdep possible recursive locking,

	 * then we can remove the dynamically allocated lock class for each

	 * flush queue, that way may cause horrible boot delay.

 reset stopped state for the fresh admin queue */

 state change failure for non-deleted ctrl? */

 if no transport address is specified use the first port */

 no quirks, we're perfect! */);

 warn if maxcmd is lower than queue_size */

	/*

	 * Ensure any ctrls that are in the process of being

	 * deleted are in fact deleted before we return

	 * and free the port. This is to prevent active

	 * ctrls from using a port after it's freed.

 254 == NVMF_TRTYPE_LOOP */

 SPDX-License-Identifier: GPL-2.0

/*

 * NVM Express target device driver tracepoints

 * Copyright (c) 2018 Johannes Thumshirn, SUSE Linux GmbH

	/*

	 * XXX: We don't know the controller instance before executing the

	 * connect command itself because the connect command for the admin

	 * queue will not provide the cntlid which will be allocated in this

	 * command.  In case of io queues, the controller instance will be

	 * mapped by the extra data of the connect command.

	 * If we can know the extra data of the connect command in this stage,

	 * we can update this print statement later.

 SPDX-License-Identifier: GPL-2.0

/*

 * NVMe Over Fabrics Target File I/O commands implementation.

 * Copyright (c) 2017-2018 Western Digital Corporation or its

 * affiliates.

	/*

	 * i_blkbits can be greater than the universally accepted upper bound,

	 * so make sure we export a sane namespace lba_shift.

	/*

	 * A NULL ki_complete ask for synchronous execution, which we want

	 * for the IOCB_NOWAIT case.

		/*

		 * For file systems returning error -EOPNOTSUPP, handle

		 * IOCB_NOWAIT error case separately and retry without

		 * IOCB_NOWAIT.

 fallback under memory pressure */

 Not supported yet */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2011-2014, Intel Corporation.

 * Copyright (c) 2017-2021 Christoph Hellwig.

 for force_successful_syscall_return */

/*

 * Convert integer values from ioctl structures to user pointers, silently

 * ignoring the upper bits in the compat case to match behaviour of 32-bit

 * kernels.

		/*

		 * Protection information is stripped/inserted by the

		 * controller.

 COMPAT_FOR_U64_ALIGNMENT */

	/*

	 * struct nvme_user_io can have different padding on some 32-bit ABIs.

	 * Just accept the compat version as all fields that are used are the

	 * same size and at the same offset.

	/*

	 * Handle ioctls that apply to the controller instead of the namespace

	 * seperately and drop the ns SRCU reference early.  This avoids a

	 * deadlock when deleting namespaces using the passthrough interface.

 CONFIG_NVME_MULTIPATH */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2016 Avago Technologies.  All rights reserved.

 *************************** Data Structures/Defines ****************** */

 seconds */

#define NVME_FC_DEFAULT_RECONNECT_TMO	2	/* delay between reconnects

						 * when connected and a

						 * connection failure.

 alignment for other things alloc'd with */

 rport->ls_req_list */

 rport->ls_rcv_list */

 alignment for other things alloc'd with */

	struct nvme_request	nreq;		/*

						 * nvme/host/core.c

						 * requires this to be

						 * the 1st element in the

						 * private structure

						 * associated with the

						 * request.

 nvme_fc_port_list */

 physical device for dma */

 alignment for other things alloc'd with */

 for lport->endp_list */

 physical device for dma */

 alignment for other things alloc'd with */

 fc_ctrl flags values - specified as bit positions */

 rport->ctrl_list */

 *************************** Globals **************************** */

/*

 * These items are short-term. They will eventually be moved into

 * a generic FC class. See comments in module init.

 *********************** FC-NVME Port Management ************************ */

 remove from transport list */

			/*

			 * fails if ref cnt already 0. If so,

			 * act as if lport already deleted

 resume the lport */

/**

 * nvme_fc_register_localport - transport entry point called by an

 *                              LLDD to register the existence of a NVME

 *                              host FC port.

 * @pinfo:     pointer to information about the port to be registered

 * @template:  LLDD entrypoints and operational parameters for the port

 * @dev:       physical hardware device node port corresponds to. Will be

 *             used for DMA mappings

 * @portptr:   pointer to a local port pointer. Upon success, the routine

 *             will allocate a nvme_fc_local_port structure and place its

 *             address in the local port pointer. Upon failure, local port

 *             pointer will be set to 0.

 *

 * Returns:

 * a completion status. Must be 0 upon success; a negative errno

 * (ex: -ENXIO) upon failure.

	/*

	 * look to see if there is already a localport that had been

	 * deregistered and in the process of waiting for all the

	 * references to fully be removed.  If the references haven't

	 * expired, we can simply re-enable the localport. Remoteports

	 * and controller reconnections should resume naturally.

 found an lport, but something about its state is bad */

 found existing lport, which was resumed */

 nothing found - allocate a new localport struct */

/**

 * nvme_fc_unregister_localport - transport entry point called by an

 *                              LLDD to deregister/remove a previously

 *                              registered a NVME host FC port.

 * @portptr: pointer to the (registered) local port that is to be deregistered.

 *

 * Returns:

 * a completion status. Must be 0 upon success; a negative errno

 * (ex: -ENXIO) upon failure.

/*

 * TRADDR strings, per FC-NVME are fixed format:

 *   "nn-0x<16hexdigits>:pn-0x<16hexdigits>" - 43 characters

 * udev event will only differ by prefix of what field is

 * being specified:

 *    "NVMEFC_HOST_TRADDR=" or "NVMEFC_TRADDR=" - 19 max characters

 *  19 + 43 + null_fudge = 64 characters

 NVMEFC_HOST_TRADDR=...*/

 NVMEFC_TRADDR=...*/

 remove from lport list */

		/*

		 * As all reconnects were suppressed, schedule a

		 * connect.

		/*

		 * Controller is already in the process of terminating the

		 * association. No need to do anything further. The reconnect

		 * step will naturally occur after the reset completes.

 no action to take - let it delete */

 has it been unregistered */

 means lldd called us twice */

		/*

		 * kick off a reconnect attempt on all associations to the

		 * remote port. A successful reconnects will resume i/o.

/**

 * nvme_fc_register_remoteport - transport entry point called by an

 *                              LLDD to register the existence of a NVME

 *                              subsystem FC port on its fabric.

 * @localport: pointer to the (registered) local port that the remote

 *             subsystem port is connected to.

 * @pinfo:     pointer to information about the port to be registered

 * @portptr:   pointer to a remote port pointer. Upon success, the routine

 *             will allocate a nvme_fc_remote_port structure and place its

 *             address in the remote port pointer. Upon failure, remote port

 *             pointer will be set to 0.

 *

 * Returns:

 * a completion status. Must be 0 upon success; a negative errno

 * (ex: -ENXIO) upon failure.

	/*

	 * look to see if there is already a remoteport that is waiting

	 * for a reconnect (within dev_loss_tmo) with the same WWN's.

	 * If so, transition to it and reconnect.

 found an rport, but something about its state is bad */

 found existing rport, which was resumed */

 nothing found - allocate a new remoteport struct */

		/*

		 * Schedule a controller reset. The reset will terminate the

		 * association and schedule the reconnect timer.  Reconnects

		 * will be attempted until either the ctlr_loss_tmo

		 * (max_retries * connect_delay) expires or the remoteport's

		 * dev_loss_tmo expires.

		/*

		 * The association has already been terminated and the

		 * controller is attempting reconnects.  No need to do anything

		 * futher.  Reconnects will be attempted until either the

		 * ctlr_loss_tmo (max_retries * connect_delay) expires or the

		 * remoteport's dev_loss_tmo expires.

		/*

		 * Controller is already in the process of terminating the

		 * association.  No need to do anything further. The reconnect

		 * step will kick in naturally after the association is

		 * terminated.

 no action to take - let it delete */

/**

 * nvme_fc_unregister_remoteport - transport entry point called by an

 *                              LLDD to deregister/remove a previously

 *                              registered a NVME subsystem FC port.

 * @portptr: pointer to the (registered) remote port that is to be

 *           deregistered.

 *

 * Returns:

 * a completion status. Must be 0 upon success; a negative errno

 * (ex: -ENXIO) upon failure.

 if dev_loss_tmo==0, dev loss is immediate */

	/*

	 * release the reference, which will allow, if all controllers

	 * go away, which should only occur after dev_loss_tmo occurs,

	 * for the rport to be torn down.

/**

 * nvme_fc_rescan_remoteport - transport entry point called by an

 *                              LLDD to request a nvme device rescan.

 * @remoteport: pointer to the (registered) remote port that is to be

 *              rescanned.

 *

 * Returns: N/A

 a dev_loss_tmo of 0 (immediate) is allowed to be set */

 *********************** FC-NVME DMA Handling **************************** */

/*

 * The fcloop device passes in a NULL device pointer. Real LLD's will

 * pass in a valid device pointer. If NULL is passed to the dma mapping

 * routines, depending on the platform, it may or may not succeed, and

 * may crash.

 *

 * As such:

 * Wrapper all the dma routines and check the dev pointer.

 *

 * If simple mappings (return just a dma address, we'll noop them,

 * returning a dma address of 0.

 *

 * On more complex mappings (dma_map_sg), a pseudo routine fills

 * in the scatter list, setting all dma addresses to 0.

 pseudo dma_map_sg call */

 *********************** FC-NVME LS Handling **************************** */

		/*

		 * No timeout/not interruptible as we need the struct

		 * to exist until the lldd calls us back. Thus mandate

		 * wait until driver calls back. lldd responsible for

		 * the timeout action

 ACC or RJT payload ? */

 don't wait for completion */

 Linux supports only Dynamic controllers */

 process connect LS completion */

 validate the ACC response */

 process connect LS completion */

 validate the ACC response */

 fc-nvme initiator doesn't care about success or failure of cmd */

/*

 * This routine sends a FC-NVME LS to disconnect (aka terminate)

 * the FC-NVME Association.  Terminating the association also

 * terminates the FC-NVME connections (per queue, both admin and io

 * queues) that are part of the association. E.g. things are torn

 * down, and the related FC-NVME Association ID and Connection IDs

 * become invalid.

 *

 * The behavior of the fc-nvme initiator is such that it's

 * understanding of the association and connections will implicitly

 * be torn down. The action is implicit as it may be due to a loss of

 * connectivity with the fc-nvme target, so you may never get a

 * response even if you tried.  As such, the action of this routine

 * is to asynchronously send the LS, ignore any results of the LS, and

 * continue on with terminating the association. If the fc-nvme target

 * is present and receives the LS, it too can tear down.

 leave the ctrl get reference */

 transmit a response for anything that was pending */

 overwrite good response with bogus failure */

/*

 * returns true to mean LS handled and ls_rsp can be sent

 * returns false to defer ls_rsp xmt (will be done as part of

 *     association termination)

 match an active association */

 format an ACCept response */

	/*

	 * the transmit of the response will occur after the exchanges

	 * for the association have been ABTS'd by

	 * nvme_fc_delete_association().

 fail the association */

 release the reference taken by nvme_fc_match_disconn_ls() */

/*

 * Actual Processing routine for received FC-NVME LS Requests from the LLD

 * returns true if a response should be sent afterward, false if rsp will

 * be sent asynchronously.

 Be preventative. handlers will later set to valid length */

	/*

	 * handlers:

	 *   parse request input, execute the request, and format the

	 *   LS response

/**

 * nvme_fc_rcv_ls_req - transport entry point called by an LLDD

 *                       upon the reception of a NVME LS request.

 *

 * The nvme-fc layer will copy payload to an internal structure for

 * processing.  As such, upon completion of the routine, the LLDD may

 * immediately free/reuse the LS request buffer passed in the call.

 *

 * If this routine returns error, the LLDD should abort the exchange.

 *

 * @portptr:    pointer to the (registered) remote port that the LS

 *              was received from. The remoteport is associated with

 *              a specific localport.

 * @lsrsp:      pointer to a nvmefc_ls_rsp response structure to be

 *              used to reference the exchange corresponding to the LS

 *              when issuing an ls response.

 * @lsreqbuf:   pointer to the buffer containing the LS Request

 * @lsreqbuf_len: length, in bytes, of the received LS request

 validate there's a routine to transmit a response */

 *********************** NVME Ctrl Routines **************************** */

 ensure we've initialized the ops once */

	/*

	 * WARNING:

	 * The current linux implementation of a nvme controller

	 * allocates a single tag set for all io queues and sizes

	 * the io queues to fully hold all possible tags. Thus, the

	 * implementation does not reference or care about the sqhd

	 * value as it never needs to use the sqhd/sqtail pointers

	 * for submission pacing.

	 *

	 * This affects the FC-NVME implementation in two ways:

	 * 1) As the value doesn't matter, we don't need to waste

	 *    cycles extracting it from ERSPs and stamping it in the

	 *    cases where the transport fabricates CQEs on successful

	 *    completions.

	 * 2) The FC-NVME implementation requires that delivery of

	 *    ERSP completions are to go back to the nvme layer in order

	 *    relative to the rsn, such that the sqhd value will always

	 *    be "in order" for the nvme layer. As the nvme layer in

	 *    linux doesn't care about sqhd, there's no need to return

	 *    them in order.

	 *

	 * Additionally:

	 * As the core nvme layer in linux currently does not look at

	 * every field in the cqe - in cases where the FC transport must

	 * fabricate a CQE, the following fields will not be set as they

	 * are not referenced:

	 *      cqe.sqid,  cqe.sqhd,  cqe.command_id

	 *

	 * Failure or error of an individual i/o, in a transport

	 * detected fashion unrelated to the nvme completion status,

	 * potentially cause the initiator and target sides to get out

	 * of sync on SQ head/tail (aka outstanding io count allowed).

	 * Per FC-NVME spec, failure of an individual command requires

	 * the connection to be terminated, which in turn requires the

	 * association to be terminated.

	/*

	 * For the linux implementation, if we have an unsuccesful

	 * status, they blk-mq layer can typically be called with the

	 * non-zero status and the content of the cqe isn't important.

	/*

	 * command completed successfully relative to the wire

	 * protocol. However, validate anything received and

	 * extract the status and result from the cqe (create it

	 * where necessary).

		/*

		 * No response payload or 12 bytes of payload (which

		 * should all be zeros) are considered successful and

		 * no payload in the CQE by the transport.

		/*

		 * The ERSP IU contains a full completion with CQE.

		 * Validate ERSP IU and look at cqe.

 clear other flags */

 Note: core layer may overwrite the sqe.command_id value */

	/*

	 * Considered whether we should allocate buffers for all SQEs

	 * and CQEs and dma map them - mapping their respective entries

	 * into the request structures (kernel vm addr and dma address)

	 * thus the driver could use the buffers/mappings directly.

	 * It only makes sense if the LLDD would use them for its

	 * messaging api. It's very unlikely most adapter api's would use

	 * a native NVME sqe/cqe. More reasonable if FC-NVME IU payload

	 * structures were used instead.

/*

 * This routine terminates a queue at the transport level.

 * The transport has already ensured that all outstanding ios on

 * the queue have been terminated.

 * The transport will send a Disconnect LS request to terminate

 * the queue's connection. Termination of the admin queue will also

 * terminate the association at the target.

	/*

	 * Current implementation never disconnects a single queue.

	 * It always terminates a whole association. So there is never

	 * a disconnect(queue) LS sent to the target.

 remove from rport list */

/*

 * All accesses from nvme core layer done - can now free the

 * controller. Called after last nvme_put_ctrl() call

/*

 * This routine is used by the transport when it needs to find active

 * io on a queue that is to be terminated. The transport uses

 * blk_mq_tagset_busy_itr() to find the busy requests, which then invoke

 * this routine to kill them on a 1 by 1 basis.

 *

 * As FC allocates FC exchange for each io, the transport must contact

 * the LLDD to terminate the exchange, thus releasing the FC exchange.

 * After terminating the exchange the LLDD will call the transport's

 * normal io done path for the request, but it will have an aborted

 * status. The done path will return the io request back to the block

 * layer with an error status.

/*

 * This routine runs through all outstanding commands on the association

 * and aborts them.  This routine is typically be called by the

 * delete_association routine. It is also called due to an error during

 * reconnect. In that scenario, it is most likely a command that initializes

 * the controller, including fabric Connect commands on io queues, that

 * may have timed out or failed thus the io must be killed for the connect

 * thread to see the error.

	/*

	 * if aborting io, the queues are no longer good, mark them

	 * all as not live.

	/*

	 * If io queues are present, stop them and terminate all outstanding

	 * ios on them. As FC allocates FC exchange for each io, the

	 * transport must contact the LLDD to terminate the exchange,

	 * thus releasing the FC exchange. We use blk_mq_tagset_busy_itr()

	 * to tell us what io's are busy and invoke a transport routine

	 * to kill them with the LLDD.  After terminating the exchange

	 * the LLDD will call the transport's normal io done path, but it

	 * will have an aborted status. The done path will return the

	 * io requests back to the block layer as part of normal completions

	 * (but with error status).

	/*

	 * Other transports, which don't have link-level contexts bound

	 * to sqe's, would try to gracefully shutdown the controller by

	 * writing the registers for shutdown and polling (call

	 * nvme_shutdown_ctrl()). Given a bunch of i/o was potentially

	 * just aborted and we will wait on those contexts, and given

	 * there was no indication of how live the controlelr is on the

	 * link, don't send more io to create more contexts for the

	 * shutdown. Let the controller fail via keepalive failure if

	 * its still present.

	/*

	 * clean up the admin queue. Same thing as above.

	/*

	 * if an error (io timeout, etc) while (re)connecting, the remote

	 * port requested terminating of the association (disconnect_ls)

	 * or an error (timeout or abort) occurred on an io while creating

	 * the controller.  Abort any ios on the association and let the

	 * create_association error path resolve things.

 Otherwise, only proceed if in LIVE state - e.g. on first error */

	/*

	 * Attempt to abort the offending command. Command completion

	 * will detect the aborted io and will fail the connection.

	/*

	 * the io abort has been initiated. Have the reset timer

	 * restarted and the abort completion will complete the io

	 * shortly. Avoids a synchronous wait while the abort finishes.

	/*

	 * TODO: blk_integrity_rq(rq)  for DIF

/*

 * In FC, the queue is a logical thing. At transport connect, the target

 * creates its "queue" and returns a handle that is to be given to the

 * target whenever it posts something to the corresponding SQ.  When an

 * SQE is sent on a SQ, FC effectively considers the SQE, or rather the

 * command contained within the SQE, an io, and assigns a FC exchange

 * to it. The SQE and the associated SQ handle are sent in the initial

 * CMD IU sents on the exchange. All transfers relative to the io occur

 * as part of the exchange.  The CQE is the last thing for the io,

 * which is transferred (explicitly or implicitly) with the RSP IU

 * sent on the exchange. After the CQE is received, the FC exchange is

 * terminaed and the Exchange may be used on a different io.

 *

 * The transport to LLDD api has the transport making a request for a

 * new fcp io request to the LLDD. The LLDD then allocates a FC exchange

 * resource and transfers the command. The LLDD will then process all

 * steps to complete the io. Upon completion, the transport done routine

 * is called.

 *

 * So - while the operation is outstanding to the LLDD, there is a link

 * level FC exchange resource that is also outstanding. This must be

 * considered in all cleanup operations.

	/*

	 * before attempting to send the io, check to see if we believe

	 * the target device is present

 format the FC-NVME CMD IU and fcp_req */

	/*

	 * validate per fabric rules, set fields mandated by fabric spec

	 * as well as those by FC-NVME spec.

	/*

	 * format SQE DPTR field per FC-NVME rules:

	 *    type=0x5     Transport SGL Data Block Descriptor

	 *    subtype=0xA  Transport-specific value

	 *    address=0

	 *    length=length of the data series

		/*

		 * If the lld fails to send the command is there an issue with

		 * the csn value?  If the command that fails is the Connect,

		 * no - as the connection won't be live.  If it is a command

		 * post-connect, it's possible a gap in csn may be created.

		 * Does this matter?  As Linux initiators don't send fused

		 * commands, no.  The gap would exist, but as there's nothing

		 * that depends on csn order to be delivered on the target

		 * side, it shouldn't hurt.  It would be difficult for a

		 * target to even detect the csn gap as it has no idea when the

		 * cmd with the csn was supposed to arrive.

	/*

	 * nvme core doesn't quite treat the rq opaquely. Commands such

	 * as WRITE ZEROES will return a non-zero rq payload_bytes yet

	 * there is no actual payload to be transferred.

	 * To get it right, key data transmission on there being 1 or

	 * more physical segments in the sg list. If there is no

	 * physical segments, there is no payload.

 Call LLDD map queue functionality if defined */

 force put free routine to ignore io queues */

 check for io queues existing */

 clearing of ctrl->flags ASSOC_ACTIVE bit is in association delete */

/*

 * This routine restarts the controller on the host side, and

 * on the link side, recreates the controller association.

	/*

	 * Create the admin queue

	/*

	 * Check controller capabilities

	 *

	 * todo:- add code to check if ctrl attributes changed from

	 * prior connection values

 sanity checks */

 FC-NVME does not have other data in the capsule */

 FC-NVME supports normal SGL Data Block Descriptors */

 warn if maxcmd is lower than queue_size */

 warn if sqsize is lower than queue_size */

	/*

	 * Create the io queues

 Success */

 send a Disconnect(association) LS to fc-nvme target */

/*

 * This routine stops operation of the controller on the host side.

 * On the host os stack side: Admin and IO queues are stopped,

 *   outstanding ios on them terminated via FC ABTS.

 * On the link side: the association is terminated.

 kill the aens as they are a separate path */

 wait for all io that had to be aborted */

	/*

	 * send a Disconnect(association) LS to fc-nvme target

	 * Note: could have been sent at top of process, but

	 * cleaner on link traffic if after the aborts complete.

	 * Note: if association doesn't exist, association_id will be 0

		/*

		 * if a Disconnect Request was waiting for a response, send

		 * now that all ABTS's have been issued (and are complete).

 re-enable the admin_q so anything new can fast fail */

 resume the io queues so that things will fast fail */

	/*

	 * kill the association on the link side.  this will block

	 * waiting for io to terminate

 will block will waiting for io to terminate */

/*

 * Fails a controller request if it matches an existing controller

 * (association) with the same tuple:

 * <Host NQN, Host ID, local FC port, remote FC port, SUBSYS NQN>

 *

 * The ports don't need to be compared as they are intrinsically

 * already matched by the port pointers supplied.

	/*

	 * if ctrl_loss_tmo is being enforced and the default reconnect delay

	 * is being used, change to a shorter reconnect delay for FC.

 io queue count */

 +1 for admin queue */

	/*

	 * Would have been nice to init io queues tag set as well.

	 * However, we require interaction from the controller

	 * for max io queue count before we can do so.

	 * Defer this to the connect path.

 at this point, teardown path changes to ref counting on nvme ctrl */

 initiate nvme ctrl ref counting teardown */

 Remove core ctrl ref. */

	/* as we're past the point where we transition to the ref

	 * counting teardown path, if we return a bad pointer here,

	 * the calling routine, thinking it's prior to the

	 * transition, will do an rport put. Since the teardown

	 * path also does a rport put, we do an extra get here to

	 * so proper order/teardown happens.

 exit via here doesn't follow ctlr ref points */

/*

 * This routine validates and extracts the WWN's from the TRADDR string.

 * As kernel parsers need the 0x to determine number base, universally

 * build string to parse with 0x prefix before parsing name strings.

 validate if string is one of the 2 allowed formats */

 find the host and remote ports to connect together */

 if fail to get reference fall through. Will error */

 Arbitrary successive failures max. With lots of subsystems could be high */

				/*

				 * This is a temporary condition. Upon restart

				 * this rport will be gone from the list.

				 *

				 * Revert the lport put and retry.  Anything

				 * added to the list already will be skipped (as

				 * they are no longer list_empty).  Loops should

				 * resume at rports that were not yet seen.

 signal discovery. Won't hurt if it repeats */

 Parse the cgroup id from a buf and return the length of cgrpid */

/*

 * fc_update_appid: Parse and update the appid in the blkcg associated with

 * cgroupid.

 * @buf: buf contains both cgrpid and appid info

 * @count: size of the buffer

	/*

	 * NOTE:

	 * It is expected that in the future the kernel will combine

	 * the FC-isms that are currently under scsi and now being

	 * added to by NVME into a new standalone FC class. The SCSI

	 * and NVME protocols and their devices would be under this

	 * new FC class.

	 *

	 * As we need something to post FC-specific udev events to,

	 * specifically for nvme probe events, start by creating the

	 * new device class.  When the new standalone FC class is

	 * put in place, this code will move to a more generic

	 * location for the class.

	/*

	 * Create a device for the FC-centric udev events

 SPDX-License-Identifier: GPL-2.0

/*

 * NVMe over Fabrics RDMA host code.

 * Copyright (c) 2015-2016 HGST, a Western Digital Company.

 3 second */

 read only in the hot path */

 other member variables */

/*

 * Disabling this option makes small I/O goes faster, but is fundamentally

 * unsafe.  With it turned off we will have to register a global rkey that

 * allows read and write access to all physical memory.

	/*

	 * Bind the CQEs (post recv buffers) DMA mapping to the RDMA queue

	 * lifetime. It's safe, since any chage in the underlying RDMA device

	 * will issue error recovery and queue re-creation.

 +1 for drain */

 +1 for drain */

 metadata nvme_rdma_sgl struct is located after command's data SGL */

	/*

	 * The cm_id object might have been destroyed during RDMA connection

	 * establishment error flow to avoid getting other cma events, thus

	 * the destruction of the QP shouldn't use rdma_cm API.

	/*

	 * Spread I/O queues completion vectors according their queue index.

	 * Admin queues can always go on completion vector 0.

 Polling queues need direct cq polling context */

 MR, SEND, INV */

 + RECV */

 +1 for ib_stop_cq */

	/*

	 * Currently we don't use SG_GAPS MR's so if the first entry is

	 * misaligned we'll end up using two entries for a single data page,

	 * so one additional entry is required.

		/*

		 * separate read/write queues

		 * hand out dedicated default queues only after we have

		 * sufficient read queues.

		/*

		 * shared read/write queues

		 * either no write queues were requested, or we don't have

		 * sufficient queue count to have dedicated default queues.

 map dedicated poll queues only if we have queues left */

 T10-PI support */

	/*

	 * Bind the async event SQE DMA mapping to the admin queue lifetime.

	 * It's safe, since any chage in the underlying RDMA device will issue

	 * error recovery and queue re-creation.

			/*

			 * If we timed out waiting for freeze we are likely to

			 * be stuck.  Fail the controller initialization just

			 * to be safe.

 If we are resetting/deleting then do nothing */

		/*

		 * state change failure is ok if we started ctrl delete,

		 * unless we're during creation of a new controller to

		 * avoid races with teardown flow.

 state change failure is ok if we started ctrl delete */

	/*

	 * Align the MR to a 4K page size to match the ctrl page size and

	 * the block virtual boundary.

 for WRITE_INSERT/READ_STRIP no memory domain */

 Clear the PRACT bit since HCA will generate/verify the PI */

 for WRITE_PASS/READ_PASS both wire/memory domains exist */

 send and recv completions */

 the local invalidation completion will end the request */

 sanity checking for received data length */

	/*

	 * AEN requests are special as they don't time out and can

	 * survive any kind of queue freeze and often don't respond to

	 * aborts.  We don't even bother to allocate a struct request

	 * for them but rather special case them here.

 maximum retry count */

	/*

	 * set the admin queue depth to the minimum size

	 * specified by the Fabrics standard.

		/*

		 * current interpretation of the fabrics spec

		 * is at minimum you make hrqsize sqsize+1, or a

		 * 1's based representation of sqsize.

 complete cm_done regardless of success/failure */

 device removal is handled via the ib_client API */

		/*

		 * If we are resetting, connecting or deleting we should

		 * complete immediately because we may block controller

		 * teardown or setup sequence

		 * - ctrl disable/shutdown fabrics requests

		 * - connect requests

		 * - initialization admin requests

		 * - I/O requests that entered after unquiescing and

		 *   the controller stopped responding

		 *

		 * All other requests should be cancelled by the error

		 * recovery work, so it's fine that we fail it here.

	/*

	 * LIVE state should trigger the normal error recovery which will

	 * handle completing this request.

 separate read/write queues */

 shared read/write queues */

 map dedicated poll queues only if we have queues left */

 state change failure should never happen */

/*

 * Fails a connection request if it matches an existing controller

 * (association) with the same tuple:

 * <Host NQN, Host ID, local address, remote address, remote port, SUBSYS NQN>

 *

 * if local address is not specified in the request, it will match an

 * existing controller with all the other parameters the same and no

 * local port address specified as well.

 *

 * The ports don't need to be compared as they are intrinsically

 * already matched by the port pointers supplied.

 no quirks, we're perfect! */);

 Delete all controllers using this device */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2017-2018 Christoph Hellwig.

/*

 * If multipathing is enabled we need to always use the subsystem instance

 * number for numbering our devices to avoid conflicts between subsystems that

 * have multiple controllers and thus use the multipath-aware subsystem node

 * and those that have a single controller and use the controller node

 * directly.

	/*

	 * If we got back an ANA error, we know the controller is alive but not

	 * ready to serve this namespace.  Kick of a re-read of the ANA

	 * information page, and just try any other available path for now.

	/*

	 * We don't treat NVME_CTRL_DELETING as a disabled path as I/O should

	 * still be able to complete assuming that the controller is connected.

	 * Otherwise it will fail immediately and return to the requeue list.

	/*

	 * The loop above skips the current path for round-robin semantics.

	 * Fall back to the current path if either:

	 *  - no other optimized path found and current is optimized,

	 *  - no other usable path found and current is usable.

 fallthru */

	/*

	 * The namespace might be going away and the bio might be moved to a

	 * different queue via blk_steal_bios(), so we need to use the bio_split

	 * pool from the original queue to allocate the bvecs from.

 CONFIG_BLK_DEV_ZONED */

	/*

	 * Add a multipath node if the subsystems supports multiple controllers.

	 * We also do this for private namespaces as the namespace sharing data could

	 * change after a rescan.

	/*

	 * This assumes all controllers that refer to a namespace either

	 * support poll queues or not.  That is not a strict guarantee,

	 * but if the assumption is wrong the effect is only suboptimal

	 * performance but not correctness problem.

 set to a default value of 512 until the disk is validated */

 we need to propagate up the VMC settings */

	/*

	 * test_and_set_bit() is used because it is protecting against two nvme

	 * paths simultaneously calling device_add_disk() on the same namespace

	 * head.

	/*

	 * In theory we should have an ANATT timer per group as they might enter

	 * the change state at different times.  But that is a lot of overhead

	 * just to protect against a target that keeps entering new changes

	 * states while never finishing previous ones.  But we'll still

	 * eventually time out once all groups are in change state, so this

	 * isn't a big deal.

	 *

	 * We also double the ANATT value to provide some slack for transports

	 * or AEN processing overhead.

 just break out of the loop */

 found the group desc: update */

 group desc not found: trigger a re-read */

 make sure all pending bios are cleaned up */

 check if multipath is enabled and we have the capability */

 SPDX-License-Identifier: GPL-2.0

/*

 * NVM Express hardware monitoring support

 * Copyright (c) 2019, Guenter Roeck

	/*

	 * First handle attributes which don't require us to read

	 * the smart log.

 SPDX-License-Identifier: GPL-2.0

/*

 * NVMe over Fabrics TCP host.

 * Copyright (c) 2018 Lightbits Labs. All rights reserved.

/* Define the socket priority to use for connections were it is desirable

 * that the NIC consider performing optimized packet processing or filtering.

 * A non-zero value being sufficient to indicate general consideration of any

 * possible optimization.  Making it a module param allows for alternative

 * values that may be unique for some NIC implementations.

 send state */

 recv state */

 send state */

 read only in the hot path */

 other member variables */

 async events don't have a request */

 drain the send queue as much as we can... */

	/*

	 * if we're the first on the send_list and we can try to send

	 * directly, otherwise queue io_work. Also, only do that if we

	 * are on the same cpu, so we don't introduce contention.

	/*

	 * AEN requests are special as they don't time out and can

	 * survive any kind of queue freeze and often don't respond to

	 * aborts.  We don't even bother to allocate a struct request

	 * for them but rather special case them here.

			/*

			 * If we don`t have any bios it means that controller

			 * sent more data than we requested, hence error

 we can read only from what is left in this bio */

		/*

		 * update the request iterator except for the last payload send

		 * in the request where we don't want to modify it as we may

		 * compete with the RX path completing the request.

 fully successful last send in current PDU */

 quota is exhausted */

 single inflight r2t supported */

 no alignment constraint */

 Single syn retry */

 Set TCP no delay */

	/*

	 * Cleanup whatever is sitting in the TCP transmit queue on socket

	 * close. This is done to prevent stale data from being sent should

	 * the network connection be restored before TCP times out.

 Set socket type of service */

 Set 10 seconds timeout for icresp recvmsg */

		/*

		 * separate read/write queues

		 * hand out dedicated default queues only after we have

		 * sufficient read queues.

		/*

		 * shared read/write queues

		 * either no write queues were requested, or we don't have

		 * sufficient queue count to have dedicated default queues.

 map dedicated poll queues only if we have queues left */

			/*

			 * If we timed out waiting for freeze we are likely to

			 * be stuck.  Fail the controller initialization just

			 * to be safe.

 If we are resetting/deleting then do nothing */

		/*

		 * state change failure is ok if we started ctrl delete,

		 * unless we're during creation of a new controller to

		 * avoid races with teardown flow.

 unquiesce to fail fast pending requests */

 state change failure is ok if we started ctrl delete */

 state change failure is ok if we started ctrl delete */

		/*

		 * If we are resetting, connecting or deleting we should

		 * complete immediately because we may block controller

		 * teardown or setup sequence

		 * - ctrl disable/shutdown fabrics requests

		 * - connect requests

		 * - initialization admin requests

		 * - I/O requests that entered after unquiescing and

		 *   the controller stopped responding

		 *

		 * All other requests should be cancelled by the error

		 * recovery work, so it's fine that we fail it here.

	/*

	 * LIVE state should trigger the normal error recovery which will

	 * handle completing this request.

 separate read/write queues */

 shared read/write queues */

 map dedicated poll queues only if we have queues left */

 SPDX-License-Identifier: GPL-2.0

/*

 * NVM Express device driver

 * Copyright (c) 2011-2014, Intel Corporation.

/*

 * These can be higher, but we need to ensure that any command doesn't

 * require an sg allocation that needs more than a page of data.

/*

 * Represents an NVM Express device.  Each nvme_dev is a PCI function.

 shadow doorbell buffer support: */

 host memory buffer support: */

/*

 * An NVM Express queue.  Each device has at least two (one for admin

 * commands and one for I/O commands).

 only used for poll queues: */

/*

 * The nvme_iod describes the data in an I/O.

 *

 * The sg pointer contains the list of PRP/SGL chunk allocations in addition

 * to the actual struct scatterlist.

 In the PRP list. 0 means small pool in use */

 Used in scatterlist */

 length of single DMA segment mapping */

		/*

		 * Clear the dbbuf memory so the driver doesn't observe stale

		 * values from the previous instantiation.

 Free memory and continue on */

 Update dbbuf and return true if an MMIO is required */

		/*

		 * Ensure that the queue is written before updating

		 * the doorbell in memory

		/*

		 * Ensure that the doorbell is updated before reading the event

		 * index from memory.  The controller needs to provide similar

		 * ordering to ensure the envent index is updated before reading

		 * the doorbell.

/*

 * Will slightly overestimate the number of pages needed.  This is OK

 * as it only leads to a small amount of wasted memory for the lifetime of

 * the I/O.

/*

 * Calculates the number of pages needed for the SGL segments. For example a 4k

 * page can accommodate 256 SGL descriptors.

 if we have more than 1 vec, admin queue offsets us by 1 */

		/*

		 * The poll queue(s) doesn't have an IRQ (and hence IRQ

		 * affinity), so use the regular blk-mq cpu mapping

/*

 * Write sq tail if we are asked to, or if the next command would wrap.

/**

 * nvme_submit_cmd() - Copy a command into a queue and ring the doorbell

 * @nvmeq: The queue to use

 * @cmd: The command to send

 * @write_sq: whether to write to the SQ doorbell

 setting the transfer type as SGL */

/*

 * NOTE: ns is NULL when called on the admin queue.

	/*

	 * We should not need to do this, but we're still using this to

	 * ensure we can drain requests on a dying queue.

 We read the CQE phase first to check if the rest of the entry is valid */

	/*

	 * AEN requests are special as they don't time out and can

	 * survive any kind of queue freeze and often don't respond to

	 * aborts.  We don't even bother to allocate a struct request

	 * for them but rather special case them here.

		/*

		 * load-load control dependency between phase and the rest of

		 * the cqe requires a full read memory barrier

/*

 * Poll for completions for any interrupt driven queue

 * Can be called from any context.

	/*

	 * Note: we (ab)use the fact that the prp fields survive if no data

	 * is attached to the request.

	/*

	 * Some drives have a bug that auto-enables WRRU if MEDIUM isn't

	 * set. Since URGENT priority is zeroes, it makes all queues

	 * URGENT.

	/*

	 * Note: we (ab)use the fact that the prp fields survive if no data

	 * is attached to the request.

	/* If true, indicates loss of adapter communication, possibly by a

	 * NVMe Subsystem reset.

 If there is a reset/reinit ongoing, we shouldn't reset again. */

	/* We shouldn't reset unless the controller is on fatal error state

	 * _or_ if we lost the communication with it.

 Read a config register to help see what died. */

	/* If PCI error recovery process is happening, we cannot reset or

	 * the recovery mechanism will surely fail.

	/*

	 * Reset immediately if the controller is failed

	/*

	 * Did we miss an interrupt?

	/*

	 * Shutdown immediately if controller times out while starting. The

	 * reset work will see the pci device disabled when it gets the forced

	 * cancellation error. All outstanding requests are completed on

	 * shutdown, so we return BLK_EH_DONE.

	/*

	 * Shutdown the controller immediately and schedule a reset if the

	 * command was already aborted once before and still hasn't been

	 * returned to the driver, or if this is the admin queue.

	/*

	 * The aborted req will be completed on receiving the abort req.

	 * We enable the timer again. If hit twice, it'll cause a device reset,

	 * as the device then is in a faulty state.

/**

 * nvme_suspend_queue - put queue into suspended state

 * @nvmeq: queue to suspend

 ensure that nvme_queue_rq() sees NVMEQ_ENABLED cleared */

/*

 * Called only on a device that has been disabled and after all other threads

 * that can check this device's completion queues have synced, except

 * nvme_poll(). This is the last chance for the driver to see a natural

 * completion before nvme_cancel_request() terminates all incomplete requests.

		/*

		 * Ensure the reduced q_depth is above some threshold where it

		 * would be better to map queues in system memory with the

		 * original depth

 ensure the first interrupt sees the initialization */

/*

 * Try getting shutdown_lock while setting up IO queues.

	/*

	 * Give up if the lock is being held by nvme_dev_disable.

	/*

	 * Controller is in wrong state, fail early.

	/*

	 * A queue's vector matches the queue identifier unless the controller

	 * has only one vector available.

		/*

		 * If the controller was reset during removal, it's possible

		 * user requests may be waiting on a stopped queue. Start the

		 * queue to flush these to completion.

	/*

	 * Ignore failing Create SQ/CQ commands, we can continue with less

	 * than the desired amount of queues, and even a controller without

	 * I/O queues can still be used to issue admin commands.  This might

	 * be useful to upgrade a buggy firmware for example.

	/*

	 * Tell the controller about the host side address mapping the CMB,

	 * and enable CMB decoding for the NVMe 1.4+ scheme:

	/*

	 * Controllers may support a CMB size larger than their BAR,

	 * for example, due to being behind a bridge. Reduce the CMB to

	 * the reported size of the BAR

 start big and work our way down */

	/*

	 * If we already have a buffer allocated check if we can reuse it.

 controller must work without HMB */

/*

 * nirqs is the number of interrupts available for write and read

 * queues. The core already reserved an interrupt for the admin queue.

	/*

	 * If there is no interrupt available for queues, ensure that

	 * the default queue is set to 1. The affinity set size is

	 * also set to one, but the irq core ignores it for this case.

	 *

	 * If only one interrupt is available or 'write_queue' == 0, combine

	 * write and read queues.

	 *

	 * If 'write_queues' > 0, ensure it leaves room for at least one read

	 * queue.

	/*

	 * Poll queues don't need interrupts, but we need at least one I/O queue

	 * left over for non-polled I/O.

	/*

	 * Initialize for the single interrupt case, will be updated in

	 * nvme_calc_irq_sets().

	/*

	 * We need interrupts for the admin queue and each non-polled I/O queue,

	 * but some Apple controllers require all queues to use the first

	 * vector.

	/*

	 * If tags are shared with admin queue (Apple bug), then

	 * make sure we only use one IO queue.

	/*

	 * Sample the module parameters once at reset time so that we have

	 * stable values to work with.

	/*

	 * Free IRQ resources as soon as NVMEQ_ENABLED bit transitions

	 * from set to unset. If there is a window to it is truely freed,

	 * pci_free_irq_vectors() jumping into this window will crash.

	 * And take lock to avoid racing with pci_free_irq_vectors() in

	 * nvme_dev_disable() path.

 Deregister the admin queue's interrupt */

	/*

	 * If we enable msix early due to not intx, disable it again before

	 * setting up the full range we need.

	/*

	 * Should investigate if there's a performance win from allocating

	 * more queues than interrupt vectors; it might allow the submission

	 * path to scale better, even if the receive path is limited by the

	 * number of interrupts.

 default + read */

		/*

		 * Some Apple controllers requires tags to be unique

		 * across admin and IO queue, so reserve the first 32

		 * tags of the IO queue.

 Free previously allocated queues that are no longer usable */

	/*

	 * Some devices and/or platforms don't advertise or work with INTx

	 * interrupts. Pre-enable a single MSIX or MSI vec for setup. We'll

	 * adjust this later.

 0's based queue depth */

	/*

	 * Some Apple controllers require a non-standard SQE size.

	 * Interestingly they also seem to ignore the CC:IOSQES register

	 * so we don't bother updating it here.

	/*

	 * Temporary fix for the Apple controller found in the MacBook8,1 and

	 * some MacBook7,1 to avoid controller resets and data loss.

	/*

	 * Controllers with the shared tags quirk need the IO queue to be

	 * big enough so that we get 32 tags for the admin queue

	/*

	 * Give the controller a chance to complete all entered requests if

	 * doing a safe shutdown.

	/*

	 * The driver will not be starting up queues again if shutting down so

	 * must flush all entered requests to their failed completion to avoid

	 * deadlocking blk-mq hot-cpu notifier.

 Optimisation for I/Os between 4k and 128k */

	/*

	 * Set state to deleting now to avoid blocking nvme_wait_reset(), which

	 * may be holding this pci_dev's device lock.

	/*

	 * If we're called to reset a live controller first shut it down before

	 * moving on.

	/*

	 * Limit the max command size to prevent iod->sg allocations going

	 * over a single page.

	/*

	 * Don't limit the IOMMU merged segment size.

	/*

	 * Introduce CONNECTING state from nvme-fc/rdma transports to mark the

	 * initializing procedure here.

	/*

	 * We do not support an SGL for metadata (yet), so we are limited to a

	 * single integrity segment for the separate metadata pointer.

	/*

	 * Keep the controller around but remove all namespaces if we don't have

	 * any working I/O queue.

	/*

	 * If only admin queue live, keep it to do further investigation or

	 * recovery.

		/*

		 * Several Samsung devices seem to drop off the PCIe bus

		 * randomly when APST is on and uses the deepest sleep state.

		 * This has been observed on a Samsung "SM951 NVMe SAMSUNG

		 * 256GB", a "PM951 NVMe SAMSUNG 512GB", and a "Samsung SSD

		 * 950 PRO 256GB", but it seems to be restricted to two Dell

		 * laptops.

		/*

		 * Samsung SSD 960 EVO drops off the PCIe bus after system

		 * suspend on a Ryzen board, ASUS PRIME B350M-A, as well as

		 * within few minutes after bootup on a Coffee Lake board -

		 * ASUS PRIME Z370-A

		/*

		 * Forcing to use host managed nvme power settings for

		 * lowest idle power with quick resume latency on

		 * Samsung and Toshiba SSDs based on suspend behavior

		 * on Coffee Lake board for LENOVO C640

		/*

		 * Some systems use a bios work around to ask for D3 on

		 * platforms that support kernel managed suspend.

	/*

	 * Double check that our mempool alloc size will cover the biggest

	 * command we support.

	/*

	 * We don't need to check the return value from waiting for the reset

	 * state as pci_dev device lock is held, making it impossible to race

	 * with ->remove().

/*

 * The driver's remove may be called on a device in a partially initialized

 * state. This function must not have any dependencies on the device state in

 * order to proceed.

	/*

	 * The platform does not remove power for a kernel managed suspend so

	 * use host managed nvme power settings for lowest idle power if

	 * possible. This should have quicker resume latency than a full device

	 * shutdown.  But if the firmware is involved after the suspend or the

	 * device does not support any non-default power states, shut down the

	 * device fully.

	 *

	 * If ASPM is not enabled for the device, shut down the device and allow

	 * the PCI bus layer to put it into D3 in order to take the PCIe link

	 * down, so as to allow the platform to achieve its minimum low-power

	 * state (which may not be possible if the link is up).

	/*

	 * Host memory access may not be successful in a system suspend state,

	 * but the specification allows the controller to access memory in a

	 * non-operational power state.

	/*

	 * A saved state prevents pci pm from generically controlling the

	 * device's power. If we're using protocol specific settings, we don't

	 * want pci interfering.

 discard the saved state */

		/*

		 * Clearing npss forces a controller reset on resume. The

		 * correct value will be rediscovered then.

 CONFIG_PM_SLEEP */

	/*

	 * A frozen channel requires a reset. When detected, this method will

	 * shutdown the controller to quiesce. The controller will be restarted

	 * after the slot reset through driver's slot_reset callback.

 Intel 750/P3500/P3600/P3700 */

 Intel P3520 */

 Intel P4500/P4600 */

 Dell Express Flash P4600 */

 Intel 600P/P3100 */

 Intel 760p/Pro 7600p */

 Qemu emulated controller */

 Silicon Motion unidentified */

 Seagate Nytro Flash Storage */

 HGST adapter */

 WDC SN200 adapter */

 Memblaze Pblaze4 adapter */

 Samsung PM1725 */

 Samsung PM1725a */

 Phison E16 */

 Lexar 256 GB SSD */

 ADATA SX6000LNP */

 ADATA SX8200PNP 512GB */

 SK Hynix PC400 */

  Sandisk Skyhawk */

 SPCC */

 KINGSTON SKC2000 NVMe SSD */

 KINGSTON A2000 NVMe SSD  */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2020 Western Digital Corporation or its affiliates.

 Driver requires zone append support */

 Lazily query controller append limit for the first zoned namespace */

	/*

	 * We currently do not handle devices requiring any of the zoned

	 * operation characteristics.

 SPDX-License-Identifier: GPL-2.0

/*

 * fault injection support for nvme.

 *

 * Copyright (c) 2018, Oracle and/or its affiliates

/* optional fault injection attributes boot time option:

 * nvme_core.fail_request=<interval>,<probability>,<space>,<times>

 set default fault injection attribute */

 create debugfs directory and attribute */

 create debugfs for status code and dont_retry */

 remove debugfs directories */

 inject status code and DNR bit */

 SPDX-License-Identifier: GPL-2.0

/*

 * NVMe over Fabrics common host code.

 * Copyright (c) 2015-2016 HGST, a Western Digital Company.

/**

 * nvmf_get_address() -  Get address/port

 * @ctrl:	Host NVMe controller instance which we got the address

 * @buf:	OUTPUT parameter that will contain the address/port

 * @size:	buffer size

/**

 * nvmf_reg_read32() -  NVMe Fabrics "Property Get" API function.

 * @ctrl:	Host NVMe controller instance maintaining the admin

 *		queue used to submit the property read command to

 *		the allocated NVMe controller resource on the target system.

 * @off:	Starting offset value of the targeted property

 *		register (see the fabrics section of the NVMe standard).

 * @val:	OUTPUT parameter that will contain the value of

 *		the property after a successful read.

 *

 * Used by the host system to retrieve a 32-bit capsule property value

 * from an NVMe controller on the target system.

 *

 * ("Capsule property" is an "PCIe register concept" applied to the

 * NVMe fabrics space.)

 *

 * Return:

 *	0: successful read

 *	> 0: NVMe error status code

 *	< 0: Linux errno error code

/**

 * nvmf_reg_read64() -  NVMe Fabrics "Property Get" API function.

 * @ctrl:	Host NVMe controller instance maintaining the admin

 *		queue used to submit the property read command to

 *		the allocated controller resource on the target system.

 * @off:	Starting offset value of the targeted property

 *		register (see the fabrics section of the NVMe standard).

 * @val:	OUTPUT parameter that will contain the value of

 *		the property after a successful read.

 *

 * Used by the host system to retrieve a 64-bit capsule property value

 * from an NVMe controller on the target system.

 *

 * ("Capsule property" is an "PCIe register concept" applied to the

 * NVMe fabrics space.)

 *

 * Return:

 *	0: successful read

 *	> 0: NVMe error status code

 *	< 0: Linux errno error code

/**

 * nvmf_reg_write32() -  NVMe Fabrics "Property Write" API function.

 * @ctrl:	Host NVMe controller instance maintaining the admin

 *		queue used to submit the property read command to

 *		the allocated NVMe controller resource on the target system.

 * @off:	Starting offset value of the targeted property

 *		register (see the fabrics section of the NVMe standard).

 * @val:	Input parameter that contains the value to be

 *		written to the property.

 *

 * Used by the NVMe host system to write a 32-bit capsule property value

 * to an NVMe controller on the target system.

 *

 * ("Capsule property" is an "PCIe register concept" applied to the

 * NVMe fabrics space.)

 *

 * Return:

 *	0: successful write

 *	> 0: NVMe error status code

 *	< 0: Linux errno error code

/**

 * nvmf_log_connect_error() - Error-parsing-diagnostic print out function for

 * 				connect() errors.

 * @ctrl:	The specific /dev/nvmeX device that had the error.

 * @errval:	Error code to be decoded in a more human-friendly

 * 		printout.

 * @offset:	For use with the NVMe error code

 * 		NVME_SC_CONNECT_INVALID_PARAM.

 * @cmd:	This is the SQE portion of a submission capsule.

 * @data:	This is the "Data" portion of a submission capsule.

/**

 * nvmf_connect_admin_queue() - NVMe Fabrics Admin Queue "Connect"

 *				API function.

 * @ctrl:	Host nvme controller instance used to request

 *              a new NVMe controller allocation on the target

 *              system and  establish an NVMe Admin connection to

 *              that controller.

 *

 * This function enables an NVMe host device to request a new allocation of

 * an NVMe controller resource on a target system as well establish a

 * fabrics-protocol connection of the NVMe Admin queue between the

 * host system device and the allocated NVMe controller on the

 * target system via a NVMe Fabrics "Connect" command.

 *

 * Return:

 *	0: success

 *	> 0: NVMe error status code

 *	< 0: Linux errno error code

 *

	/*

	 * Set keep-alive timeout in seconds granularity (ms * 1000)

/**

 * nvmf_connect_io_queue() - NVMe Fabrics I/O Queue "Connect"

 *			     API function.

 * @ctrl:	Host nvme controller instance used to establish an

 *		NVMe I/O queue connection to the already allocated NVMe

 *		controller on the target system.

 * @qid:	NVMe I/O queue number for the new I/O connection between

 *		host and target (note qid == 0 is illegal as this is

 *		the Admin queue, per NVMe standard).

 *

 * This function issues a fabrics-protocol connection

 * of a NVMe I/O queue (via NVMe Fabrics "Connect" command)

 * between the host system device and the allocated NVMe controller

 * on the target system.

 *

 * Return:

 *	0: success

 *	> 0: NVMe error status code

 *	< 0: Linux errno error code

/**

 * nvmf_register_transport() - NVMe Fabrics Library registration function.

 * @ops:	Transport ops instance to be registered to the

 *		common fabrics library.

 *

 * API function that registers the type of specific transport fabric

 * being implemented to the common NVMe fabrics library. Part of

 * the overall init sequence of starting up a fabrics driver.

/**

 * nvmf_unregister_transport() - NVMe Fabrics Library unregistration function.

 * @ops:	Transport ops instance to be unregistered from the

 *		common fabrics library.

 *

 * Fabrics API function that unregisters the type of specific transport

 * fabric being implemented from the common NVMe fabrics library.

 * Part of the overall exit sequence of unloading the implemented driver.

 Set defaults */

 < 0 == use transport default */

 Allowed for debug */

	/*

	 * Checking the local address is rough. In most cases, none is specified

	 * and the host port is selected by the stack.

	 *

	 * Assume no match if:

	 * -  local address is specified and address is not the same

	 * -  local address is not specified but remote is, or vice versa

	 *    (admin using specific host_traddr when it matters).

	/*

	 * Check the generic options first as we need a valid transport for

	 * the lookup below.  Then clear the generic flags so that transport

	 * drivers don't have to care about them.

	/*

	 * The miscdevice code initializes file->private_data, but doesn't

	 * make use of it later.

 SPDX-License-Identifier: GPL-2.0

/*

 * NVM Express device driver

 * Copyright (c) 2011-2014, Intel Corporation.

/*

 * nvme_wq - hosts nvme related works that are not reset or delete

 * nvme_reset_wq - hosts nvme reset works

 * nvme_delete_wq - hosts nvme delete works

 *

 * nvme_wq will host works such as scan, aen handling, fw activation,

 * keep-alive, periodic reconnects etc. nvme_reset_wq

 * runs reset works which also flush works hosted on nvme_wq for

 * serialization purposes. nvme_delete_wq host controller deletion

 * works which flush reset works for serialization.

	/*

	 * Only new queue scan work when admin and IO queues are both alive

/*

 * Use this function to proceed with scheduling reset_work for a controller

 * that had previously been set to the resetting state. This is intended for

 * code paths that can't be interrupted by other reset attempts. A hot removal

 * may prevent this from succeeding.

	/*

	 * Keep a reference until nvme_do_delete_ctrl() complete,

	 * since ->delete_ctrl can free the controller.

 The mask and shift result must be <= 3 */

/*

 * Called to unwind from ->queue_rq on a failed command submission so that the

 * multipathing code gets called to potentially failover to another path.

 * The caller needs to unwind all transport specific resource allocations and

 * must return propagate the return value.

 don't abort one completed request */

/*

 * Returns true for sink states that can't ever transition back to live.

/*

 * Waits for the controller state to be resetting, or returns false if it is

 * not possible to ever transition to that state.

 no queuedata implies admin queue */

 passthru commands should let the driver set the SGL flags */

/*

 * For something we're not in a state to send to the device the default action

 * is to busy it and retry it after the controller state is recovered.  However,

 * if the controller is deleting or if anything is marked for failfast or

 * nvme multipath it is immediately failed.

 *

 * Note: commands used to initialize the controller will be marked for failfast.

 * Note: nvme cli/ioctl commands are marked for failfast.

	/*

	 * currently we have a problem sending passthru commands

	 * on the admin_q if the controller is not LIVE because we can't

	 * make sure that they are going out after the admin connect,

	 * controller enable and/or other commands in the initialization

	 * sequence. until the controller will be LIVE, fail with

	 * BLK_STS_RESOURCE so that they will be rescheduled.

		/*

		 * Only allow commands on a live queue, except for the connect

		 * command, which is require to set the queue live in the

		 * appropinquate states.

/*

 * Check if 'req' has a write hint associated with it. If it does, assign

 * a valid namespace stream to the write.

	/*

	 * Some devices do not consider the DSM 'Number of Ranges' field when

	 * determining how much data to DMA. Always allocate memory for maximum

	 * number of segments to prevent device reading beyond end of buffer.

		/*

		 * If we fail allocation our range, fallback to the controller

		 * discard page. If that's also busy, it's safe to return

		 * busy, as we know we can make progress once that's freed.

		/*

		 * If formated with metadata, the block layer always provides a

		 * metadata buffer if CONFIG_BLK_DEV_INTEGRITY is enabled.  Else

		 * we enable the PRACT bit for protection information or set the

		 * namespace capacity to zero to prevent any I/O.

 these are setup prior to execution in nvme_init_request() */

/*

 * Return values:

 * 0:  success

 * >0: nvme controller's cqe status response

 * <0: kernel error in lieu of controller response

/*

 * Returns 0 on success.  If the result is negative, it's a Linux error code;

 * if the result is positive, it's an NVM Express status code

	/*

	 * For simplicity, IO to all namespaces is quiesced even if the command

	 * effects say only one namespace is affected.

			/*

			 * Keep alive commands interval on the host should be

			 * updated when KATO is modified by Set Features

			 * commands.

 nothing to be done for zero cmd effects */

/*

 * Recommended frequency for KATO commands per NVMe 1.4 section 7.12.1:

 * 

 *   The host should send Keep Alive commands at half of the Keep Alive Timeout

 *   accounting for transport roundtrip times [..].

 allocation failure, reset the controller */

/*

 * In NVMe 1.0 the CNS field was just a binary controller or namespace

 * flag, thus sending any new CNS opcodes has a big chance of not working.

 * Qemu unfortunately had that bug after reporting a 1.1 version compliance

 * (but not for any later version).

 gcc-4.4.4 (at least) has issues with initializers and anon unions */

 Skip unknown types */

 gcc-4.4.4 (at least) has issues with initializers and anon unions */

 namespace not allocated or attached */

	/*

	 * Degraded controllers might return an error when setting the queue

	 * count.  We still want to be able to bring them online and offer

	 * access to the admin queue, as that might be only way to fix them up.

 should never be called due to GENHD_FL_HIDDEN */

 some standard values */

 CONFIG_BLK_DEV_INTEGRITY */

 If discard is already enabled, don't reset queue limits */

	/*

	 * The PI implementation requires the metadata size to be equal to the

	 * t10 pi tuple size.

		/*

		 * The NVMe over Fabrics specification only supports metadata as

		 * part of the extended data LBA.  We rely on HCA/HBA support to

		 * remap the separate metadata buffer from the block layer.

		/*

		 * For PCIe controllers, we can't easily remap the separate

		 * metadata buffer from the block layer and thus require a

		 * separate metadata buffer for block layer metadata/PI support.

		 * We allow extended LBAs for the passthrough interface, though.

	/*

	 * The block layer can't support LBA sizes larger than the page size

	 * yet, so catch this early and don't allow block I/O.

		/*

		 * Bit 1 indicates whether NAWUPF is defined for this namespace

		 * and whether it should be used instead of AWUPF. If NAWUPF ==

		 * 0 then AWUPF must be used instead.

 NPWG = Namespace Preferred Write Granularity */

 NOWS = Namespace Optimal Write Size */

	/*

	 * Linux filesystems assume writing a single physical block is

	 * an atomic operation. Hence limit the physical block size to the

	 * value of the Atomic Write Unit Power Fail parameter.

	/*

	 * Register a metadata profile for PI, or the plain non-integrity NVMe

	 * metadata masquerading as Type 0 if supported, otherwise reject block

	 * I/O to namespaces with metadata except when the namespace supports

	 * PI, as it can strip/insert in that case.

 nvme_alloc_ns() scans the disk prior to adding it */

	/*

	 * If probing fails due an unsupported feature, hide the block device,

	 * but still allow other access.

 PTPL=1 */

 CONFIG_BLK_SED_OPAL */

 CONFIG_BLK_DEV_ZONED */

/*

 * If the device has been passed off to us in an enabled state, just clear

 * the enabled bit.  The spec says we should set the 'shutdown notification

 * bits', but doing so may cause the device to complete commands to the

 * admin queue ... and we don't know what memory that might be pointing at!

 Don't bother enabling the feature if retry delay is not reported */

/*

 * The function checks whether the given total (exlat + enlat) latency of

 * a power state allows the latter to be used as an APST transition target.

 * It does so by comparing the latency to the primary and secondary latency

 * tolerances defined by module params. If there's a match, the corresponding

 * timeout value is returned and the matching tolerance index (1 or 2) is

 * reported.

/*

 * APST (Autonomous Power State Transition) lets us program a table of power

 * state transitions that the controller will perform automatically.

 *

 * Depending on module params, one of the two supported techniques will be used:

 *

 * - If the parameters provide explicit timeouts and tolerances, they will be

 *   used to build a table with up to 2 non-operational states to transition to.

 *   The default parameter values were selected based on the values used by

 *   Microsoft's and Intel's NVMe drivers. Yet, since we don't implement dynamic

 *   regeneration of the APST table in the event of switching between external

 *   and battery power, the timeouts and tolerances reflect a compromise

 *   between values used by Microsoft for AC and battery scenarios.

 * - If not, we'll configure the table with a simple heuristic: we are willing

 *   to spend at most 2% of the time transitioning between power states.

 *   Therefore, when running in any given state, we will enter the next

 *   lower-power non-operational state after waiting 50 * (enlat + exlat)

 *   microseconds, as long as that state's exit latency is under the requested

 *   maximum latency.

 *

 * We will not autonomously enter any non-operational state for which the total

 * latency exceeds ps_max_latency_us.

 *

 * Users can set ps_max_latency_us to zero to turn off APST.

	/*

	 * If APST isn't supported or if we haven't been initialized yet,

	 * then don't do anything.

 Turn off APST. */

	/*

	 * Walk through all states from lowest- to highest-power.

	 * According to the spec, lower-numbered states use more power.  NPSS,

	 * despite the name, is the index of the lowest-power state, not the

	 * number of states.

		/*

		 * Don't allow transitions to the deepest state if it's quirked

		 * off.

		/*

		 * Is this state a useful non-operational state for higher-power

		 * states to autonomously transition to?

		/*

		 * This state is good. It can be used as the APST idle target

		 * for higher power states.

	/*

	 * NVMe model and firmware strings are padded with spaces.  For

	 * simplicity, strings in the quirk table are padded with NULLs

	 * instead.

		/*

		 * This Toshiba device seems to die using any APST states.  See:

		 * https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1678184/comments/11

		/*

		 * This LiteON CL1-3D*-Q11 firmware version has a race

		 * condition associated with actions related to suspend to idle

		 * LiteON has resolved the problem in future firmware

 match is null-terminated but idstr is space-padded. */

 Generate a "fake" NQN per Figure 254 in NVMe 1.3 + ECN 001 */

	/*

	 * Fail matches for discovery subsystems. This results

	 * in each discovery controller bound to a unique subsystem.

	 * This avoids issues with validating controller values

	 * that can only be true when there is a single unique subsystem.

	 * There may be multiple and completely independent entities

	 * that provide discovery controllers.

 Versions prior to 1.4 don't necessarily report a valid type */

	/*

	 * Even though NVMe spec explicitly states that MDTS is not applicable

	 * to the write-zeroes, we are cautious and limit the size to the

	 * controllers max_hw_sectors value, which is based on the MDTS field

	 * and possibly other limiting factors.

		/*

		 * Check for quirks.  Quirk can depend on firmware version,

		 * so, in principle, the set of quirks present can change

		 * across a reset.  As a possible future enhancement, we

		 * could re-scan for quirks every time we reinitialize

		 * the device, but we'd have to make sure that the driver

		 * behaves intelligently if the quirks change.

 us -> s */

		/*

		 * In fabrics we need to verify the cntlid matches the

		 * admin connect

/*

 * Initialize the cached copies of the Identify data and various controller

 * register in our nvme_ctrl structure.  This should be called as soon as

 * the admin queue is fully up and running.

	/* For backward compatibility expose the NGUID to userspace if

	 * we have no UUID set

 per-path attr */

/*

 * Add the namespace to the controller list while keeping the list ordered.

	/*

	 * Without the multipath code enabled, multiple controller per

	 * subsystems are visible as devices and thus we cannot use the

	 * subsystem instance.

 guarantee not available in head->list */

 wait for concurrent submissions */

	/*

	 * Only remove the namespace if we got a fatal error back from the

	 * device, otherwise ignore the error and just move on.

	 *

	 * TODO: we should probably schedule a delayed retry here.

 end of the list? */

	/*

	 * We need to read the log to clear the AEN, but we don't want to rely

	 * on it for the changed namespace information as userspace could have

	 * raced with us in reading the log page, which could cause us to miss

	 * updates.

 No tagset on a live ctrl means IO queues could not created */

/*

 * This function iterates the namespace list unlocked to allow recovery from

 * controller failure. It is up to the caller to ensure the namespace list is

 * not modified by scan work while this function is executing.

	/*

	 * make sure to requeue I/O to all namespaces as these

	 * might result from the scan itself and must complete

	 * for the scan_work to make progress

 prevent racing with ns scanning */

	/*

	 * The dead states indicates the controller was not gracefully

	 * disconnected. In that case, we won't be able to flush any data while

	 * removing the namespaces' disks; fail all the queues now to avoid

	 * potentially having to clean up the failed sync later.

 this is a no-op when called from the controller reset handler */

 read FW slot information to clear the AER */

		/*

		 * We are (ab)using the RESETTING state to prevent subsequent

		 * recovery actions from interfering with the controller's

		 * firmware activation.

/*

 * Initialize a NVMe controller structures.  This needs to be called during

 * earliest initialization so that we have the initialized structured around

 * during probing.

	/*

	 * Initialize latency tolerance controls.  The sysfs files won't

	 * be visible to userspace unless the device actually supports APST.

/*

 * Prepare a queue for teardown.

 *

 * This must forcibly unquiesce queues to avoid blocking dispatch, and only set

 * the capacity to 0 after that to avoid blocking dispatchers that may be

 * holding bd_butex.  This will end buffered writers dirtying pages that can't

 * be synced.

/**

 * nvme_kill_queues(): Ends all namespace queues

 * @ctrl: the dead controller that needs to end

 *

 * Call this function when the driver determines it is unable to get the

 * controller in a state capable of servicing IO.

 Forcibly unquiesce queues to avoid blocking dispatch */

/*

 * Check we didn't inadvertently grow the command structure sizes:

 SPDX-License-Identifier: GPL-2.0

/*

 * NVM Express device driver tracepoints

 * Copyright (c) 2018 Johannes Thumshirn, SUSE Linux GmbH

 SPDX-License-Identifier: GPL-2.0+



 Copyright (c) 2013-2014 Freescale Semiconductor, Inc

 Copyright (c) 2017 Sysam, Angelo Dureghello  <angelo@sysam.it>

		/* ColdFire is big endian, and accesses natively

		 * big endian I/O peripherals

		/* ColdFire is big endian, and accesses natively

		 * big endian I/O peripherals

 Already mapped for this config? */

 calculate the total size in this desc */

 figure out the finished and calculate the residue */

	/*

	 * TCD parameters are stored in struct fsl_edma_hw_tcd in little

	 * endian format. However, we need to load the TCD registers in

	 * big- or little-endian obeying the eDMA engine model endian,

	 * and this is performed from specific edma_write functions

	/*

	 * eDMA hardware SGs require the TCDs to be stored in little

	 * endian format irrespective of the register endian model.

	 * So we put the value in little endian in memory, waiting

	 * for fsl_edma_set_tcd_regs doing the swap.

 get next sg's physical address */

 get next sg's physical address */

 To match with copy_align and max_seg_size so 1 tcd is enough */

 cannot submit due to suspend */

/*

 * On the 32 channels Vybrid/mpc577x edma version (here called "v1"),

 * register offsets are different compared to ColdFire mcf5441x 64 channels

 * edma (here called "v2").

 *

 * This function sets up register offsets as per proper declared version

 * so must be called in xxx_edma_probe() just after setting the

 * edma "version" and "membase" appropriately.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Topcliff PCH DMA controller driver

 * Copyright (c) 2010 Intel Corporation

 * Copyright (C) 2011 LAPIS Semiconductor Co., Ltd.

 ch8-->0 ch9-->1 ... ch11->3 */

 ch8-->0 ch9-->1 ... ch11->3 */

 clear interrupt bits in status register */

 PCI Device ID of DMA device */

 UART Video */

 PCMIF SPI */

 FPGA */

 I2S */

 UART */

 Video SPI */

 Security */

 FPGA */

 UART */

 SPI */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright(c) 2004 - 2006 Intel Corporation. All rights reserved.

/*

 * This code implements the DMA subsystem. It provides a HW-neutral interface

 * for other kernel code to use asynchronous memory copy capabilities,

 * if present, and allows different HW DMA drivers to register as providing

 * this capability.

 *

 * Due to the fact we are accelerating what is already a relatively fast

 * operation, the code goes to great lengths to avoid additional overhead,

 * such as locking.

 *

 * LOCKING:

 *

 * The subsystem keeps a global list of dma_device structs it is protected by a

 * mutex, dma_list_mutex.

 *

 * A subsystem can get access to a channel by calling dmaengine_get() followed

 * by dma_find_channel(), or if it has need for an exclusive channel it can call

 * dma_request_channel().  Once a channel is allocated a reference is taken

 * against its corresponding driver to disable removal.

 *

 * Each device has a channels list, which runs unlocked but is never modified

 * once the device is registered, it's just setup by the driver.

 *

 * See Documentation/driver-api/dmaengine for more details

 --- debugfs implementation --- */

 /sys/kernel/debug/dmaengine/summary */

 DEBUG_FS */

 --- sysfs implementation --- */

/**

 * dev_to_dma_chan - convert a device pointer to its sysfs container object

 * @dev:	device node

 *

 * Must be called under dma_list_mutex.

 --- client and device registration --- */

 enable iteration over all operation types */

/**

 * struct dma_chan_tbl_ent - tracks channel allocations per core/operation

 * @chan:	associated channel for this entry

 percpu lookup table for memory-to-memory offload providers */

	/* 'interrupt', 'private', and 'slave' are channel capabilities,

	 * but are not associated with an operation so they do not need

	 * an entry in the channel_table

/**

 * dma_chan_is_local - checks if the channel is in the same NUMA-node as the CPU

 * @chan:	DMA channel to test

 * @cpu:	CPU index which the channel should be close to

 *

 * Returns true if the channel is in the same NUMA-node as the CPU.

/**

 * min_chan - finds the channel with min count and in the same NUMA-node as the CPU

 * @cap:	capability to match

 * @cpu:	CPU index which the channel should be close to

 *

 * If some channels are close to the given CPU, the one with the lowest

 * reference count is returned. Otherwise, CPU is ignored and only the

 * reference count is taken into account.

 *

 * Must be called under dma_list_mutex.

/**

 * dma_channel_rebalance - redistribute the available channels

 *

 * Optimize for CPU isolation (each CPU gets a dedicated channel for an

 * operation type) in the SMP case, and operation isolation (avoid

 * multi-tasking channels) in the non-SMP case.

 *

 * Must be called under dma_list_mutex.

 undo the last distribution */

 don't populate the channel_table if no clients are available */

 redistribute available channels */

/**

 * balance_ref_count - catch up the channel reference count

 * @chan:	channel to balance ->client_count versus dmaengine_ref_count

 *

 * Must be called under dma_list_mutex.

/**

 * dma_chan_get - try to grab a DMA channel's parent driver module

 * @chan:	channel to grab

 *

 * Must be called under dma_list_mutex.

 The channel is already in use, update client count */

 allocate upon first client reference */

/**

 * dma_chan_put - drop a reference to a DMA channel's parent driver module

 * @chan:	channel to release

 *

 * Must be called under dma_list_mutex.

 This channel is not in use, bail out */

 This channel is not in use anymore, free it */

 Make sure all operations have completed */

 If the channel is used via a DMA request router, free the mapping */

/**

 * dma_find_channel - find a channel to carry out the operation

 * @tx_type:	transaction type

/**

 * dma_issue_pending_all - flush all pending operations across all channels

 check if the channel supports slave transactions */

	/*

	 * Check whether it reports it uses the generic slave

	 * capabilities, if not, that means it doesn't support any

	 * kind of slave capabilities reporting.

	/*

	 * DMA engine device might be configured with non-uniformly

	 * distributed slave capabilities per device channels. In this

	 * case the corresponding driver may provide the device_caps

	 * callback to override the generic capabilities with

	 * channel-specific ones.

	/* devices with multiple channels need special handling as we need to

	 * ensure that all channels are either private or public.

 some channels are already publicly allocated */

		/* Found a suitable channel, try to grab, prep, and return it.

		 * We first set DMA_PRIVATE to disable balance_ref_count as this

		 * channel will not be published in the general-purpose

		 * allocator

/**

 * dma_get_slave_channel - try to get specific channel exclusively

 * @chan:	target channel

 lock against __dma_request_channel */

 lock against __dma_request_channel */

/**

 * __dma_request_channel - try to allocate an exclusive channel

 * @mask:	capabilities that the channel must satisfy

 * @fn:		optional callback to disposition available channels

 * @fn_param:	opaque parameter to pass to dma_filter_fn()

 * @np:		device node to look for DMA channels

 *

 * Returns pointer to appropriate DMA channel on success or NULL.

 Find a channel */

 Finds a DMA controller with matching device node */

/**

 * dma_request_chan - try to allocate an exclusive slave channel

 * @dev:	pointer to client device structure

 * @name:	slave channel name

 *

 * Returns pointer to appropriate DMA channel on success or an error pointer.

 If device-tree is present get slave info from here */

 If device was enumerated by ACPI get slave info from here */

 Try to find the channel via the DMA filter map(s) */

/**

 * dma_request_chan_by_mask - allocate a channel satisfying certain capabilities

 * @mask:	capabilities that the channel must satisfy

 *

 * Returns pointer to appropriate DMA channel on success or an error pointer.

 drop PRIVATE cap enabled by __dma_request_channel() */

/**

 * dmaengine_get - register interest in dma_channels

 try to grab channels */

 module removed before we could use it */

	/* if this is the first reference and there were channels

	 * waiting we need to rebalance to get those channels

	 * incorporated into the channel table

/**

 * dmaengine_put - let DMA drivers be removed when ref_count == 0

 drop channel references */

	/* A device that satisfies this test has channels that will never cause

	 * an async_tx channel switch event as all possible operation types can

	 * be handled.

	/*

	 * When the chan_id is a negative value, we are dynamically adding

	 * the channel. Otherwise we are static enumerating.

/**

 * dma_async_device_register - registers DMA devices found

 * @device:	pointer to &struct dma_device

 *

 * After calling this routine the structure should not be freed except in the

 * device_release() callback which will be called after

 * dma_async_device_unregister() is called and no further references are taken.

 validate device routines */

	/* note: this only matters in the

	 * CONFIG_ASYNC_TX_ENABLE_CHANNEL_SWITCH=n case

 represent channels in sysfs. Probably want devs too */

 take references on public channels */

			/* if clients are already waiting for channels we need

			 * to take references on their behalf

				/* note we can only get here for the first

				 * channel as the remaining channels are

				 * guaranteed to get a reference

 Always private */

 if we never registered a channel just release the idr */

/**

 * dma_async_device_unregister - unregister a DMA device

 * @device:	pointer to &struct dma_device

 *

 * This routine is called by dma driver exit routines, dmaengine holds module

 * references to prevent it being called while channels are in use.

	/*

	 * setting DMA_PRIVATE ensures the device being torn down will not

	 * be used in the channel_table

/**

 * dmaenginem_async_device_register - registers DMA devices found

 * @device:	pointer to &struct dma_device

 *

 * The operation is managed and will be undone on driver detach.

 Make sure that the metadata mode is not mixed */

/**

 * dma_wait_for_async_tx - spin wait for a transaction to complete

 * @tx:		in-flight transaction to wait on

/**

 * dma_run_dependencies - process dependent operations on the target channel

 * @tx:		transaction with dependencies

 *

 * Helper routine for DMA drivers to process (start) dependent operations

 * on their target channel.

 we'll submit tx->next now, so clear the link */

	/* keep submitting up until a channel switch is detected

	 * in that case we will be called again as a result of

	 * processing the interrupt from async_tx_channel_switch

 ->next will be submitted */

 submit current dep and terminate */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) Ericsson AB 2007-2008

 * Copyright (C) ST-Ericsson SA 2008-2010

 * Author: Per Forlin <per.forlin@stericsson.com> for ST-Ericsson

 * Author: Jonas Aaberg <jonas.aberg@stericsson.com> for ST-Ericsson

 For masking out/in 2 bit channel positions */

 Maximum iterations taken before giving up suspending a channel */

 Milliseconds */

 Hardware requirement on LCLA alignment */

 Max number of links per event group */

 Max number of logical channels per physical channel */

 Attempts before giving up to trying to get pages that are aligned */

 Bit markings for allocation map */

 Reserved event lines for memcpy only. */

 Default configuration for physical memcpy */

 Default configuration for logical memcpy */

/**

 * enum 40_command - The different commands and/or statuses.

 *

 * @D40_DMA_STOP: DMA channel command STOP or status STOPPED,

 * @D40_DMA_RUN: The DMA channel is RUNNING of the command RUN.

 * @D40_DMA_SUSPEND_REQ: Request the DMA to SUSPEND as soon as possible.

 * @D40_DMA_SUSPENDED: The DMA channel is SUSPENDED.

/*

 * enum d40_events - The different Event Enables for the event lines.

 *

 * @D40_DEACTIVATE_EVENTLINE: De-activate Event line, stopping the logical chan.

 * @D40_ACTIVATE_EVENTLINE: Activate the Event line, to start a logical chan.

 * @D40_SUSPEND_REQ_EVENTLINE: Requesting for suspending a event line.

 * @D40_ROUND_EVENTLINE: Status check for event line.

/*

 * These are the registers that has to be saved and later restored

 * when the DMA hw is powered off.

 * TODO: Add save/restore of D40_DREG_GCC on dma40 v3 or later, if that works.

/*

 * since 9540 and 8540 has the same HW revision

 * use v4a for 9540 or ealier

 * use v4b for 8540 or later

 * HW revision:

 * DB8500ed has revision 0

 * DB8500v1 has revision 2

 * DB8500v2 has revision 3

 * AP9540v1 has revision 4

 * DB8540v1 has revision 4

 * TODO: Check if all these registers have to be saved/restored on dma40 v4a

/**

 * struct d40_interrupt_lookup - lookup table for interrupt handler

 *

 * @src: Interrupt mask register.

 * @clr: Interrupt clear register.

 * @is_error: true if this is an error interrupt.

 * @offset: start delta in the lookup_log_chans in d40_base. If equals to

 * D40_PHY_CHAN, the lookup_phy_chans shall be used instead.

/**

 * struct d40_reg_val - simple lookup struct

 *

 * @reg: The register.

 * @val: The value that belongs to the register in reg.

 Clock every part of the DMA block from start */

 Interrupts on all logical channels */

 Clock every part of the DMA block from start */

 Interrupts on all logical channels */

/**

 * struct d40_lli_pool - Structure for keeping LLIs in memory

 *

 * @base: Pointer to memory area when the pre_alloc_lli's are not large

 * enough, IE bigger than the most common case, 1 dst and 1 src. NULL if

 * pre_alloc_lli is used.

 * @dma_addr: DMA address, if mapped

 * @size: The size in bytes of the memory at base or the size of pre_alloc_lli.

 * @pre_alloc_lli: Pre allocated area for the most common case of transfers,

 * one buffer to one buffer.

 Space for dst and src, plus an extra for padding */

/**

 * struct d40_desc - A descriptor is one DMA job.

 *

 * @lli_phy: LLI settings for physical channel. Both src and dst=

 * points into the lli_pool, to base if lli_len > 1 or to pre_alloc_lli if

 * lli_len equals one.

 * @lli_log: Same as above but for logical channels.

 * @lli_pool: The pool with two entries pre-allocated.

 * @lli_len: Number of llis of current descriptor.

 * @lli_current: Number of transferred llis.

 * @lcla_alloc: Number of LCLA entries allocated.

 * @txd: DMA engine struct. Used for among other things for communication

 * during a transfer.

 * @node: List entry.

 * @is_in_client_list: true if the client owns this descriptor.

 * @cyclic: true if this is a cyclic job

 *

 * This descriptor is used for both logical and physical transfers.

 LLI physical */

 LLI logical */

/**

 * struct d40_lcla_pool - LCLA pool settings and data.

 *

 * @base: The virtual address of LCLA. 18 bit aligned.

 * @dma_addr: DMA address, if mapped

 * @base_unaligned: The orignal kmalloc pointer, if kmalloc is used.

 * This pointer is only there for clean-up on error.

 * @pages: The number of pages needed for all physical channels.

 * Only used later for clean-up on error

 * @lock: Lock to protect the content in this struct.

 * @alloc_map: big map over which LCLA entry is own by which job.

/**

 * struct d40_phy_res - struct for handling eventlines mapped to physical

 * channels.

 *

 * @lock: A lock protection this entity.

 * @reserved: True if used by secure world or otherwise.

 * @num: The physical channel number of this entity.

 * @allocated_src: Bit mapped to show which src event line's are mapped to

 * this physical channel. Can also be free or physically allocated.

 * @allocated_dst: Same as for src but is dst.

 * allocated_dst and allocated_src uses the D40_ALLOC* defines as well as

 * event line number.

 * @use_soft_lli: To mark if the linked lists of channel are managed by SW.

/**

 * struct d40_chan - Struct that describes a channel.

 *

 * @lock: A spinlock to protect this struct.

 * @log_num: The logical number, if any of this channel.

 * @pending_tx: The number of pending transfers. Used between interrupt handler

 * and tasklet.

 * @busy: Set to true when transfer is ongoing on this channel.

 * @phy_chan: Pointer to physical channel which this instance runs on. If this

 * point is NULL, then the channel is not allocated.

 * @chan: DMA engine handle.

 * @tasklet: Tasklet that gets scheduled from interrupt context to complete a

 * transfer and call client callback.

 * @client: Cliented owned descriptor list.

 * @pending_queue: Submitted jobs, to be issued by issue_pending()

 * @active: Active descriptor.

 * @done: Completed jobs

 * @queue: Queued jobs.

 * @prepare_queue: Prepared jobs.

 * @dma_cfg: The client configuration of this dma channel.

 * @slave_config: DMA slave configuration.

 * @configured: whether the dma_cfg configuration is valid

 * @base: Pointer to the device instance struct.

 * @src_def_cfg: Default cfg register setting for src.

 * @dst_def_cfg: Default cfg register setting for dst.

 * @log_def: Default logical channel settings.

 * @lcpa: Pointer to dst and src lcpa settings.

 * @runtime_addr: runtime configured address.

 * @runtime_direction: runtime configured direction.

 *

 * This struct can either "be" a logical or a physical channel.

 Default register configurations */

 Runtime reconfiguration */

/**

 * struct d40_gen_dmac - generic values to represent u8500/u8540 DMA

 * controller

 *

 * @backup: the pointer to the registers address array for backup

 * @backup_size: the size of the registers address array for backup

 * @realtime_en: the realtime enable register

 * @realtime_clear: the realtime clear register

 * @high_prio_en: the high priority enable register

 * @high_prio_clear: the high priority clear register

 * @interrupt_en: the interrupt enable register

 * @interrupt_clear: the interrupt clear register

 * @il: the pointer to struct d40_interrupt_lookup

 * @il_size: the size of d40_interrupt_lookup array

 * @init_reg: the pointer to the struct d40_reg_val

 * @init_reg_size: the size of d40_reg_val array

/**

 * struct d40_base - The big global struct, one for each probe'd instance.

 *

 * @interrupt_lock: Lock used to make sure one interrupt is handle a time.

 * @execmd_lock: Lock for execute command usage since several channels share

 * the same physical register.

 * @dev: The device structure.

 * @virtbase: The virtual base address of the DMA's register.

 * @rev: silicon revision detected.

 * @clk: Pointer to the DMA clock structure.

 * @phy_start: Physical memory start of the DMA registers.

 * @phy_size: Size of the DMA register map.

 * @irq: The IRQ number.

 * @num_memcpy_chans: The number of channels used for memcpy (mem-to-mem

 * transfers).

 * @num_phy_chans: The number of physical channels. Read from HW. This

 * is the number of available channels for this driver, not counting "Secure

 * mode" allocated physical channels.

 * @num_log_chans: The number of logical channels. Calculated from

 * num_phy_chans.

 * @dma_both: dma_device channels that can do both memcpy and slave transfers.

 * @dma_slave: dma_device channels that can do only do slave transfers.

 * @dma_memcpy: dma_device channels that can do only do memcpy transfers.

 * @phy_chans: Room for all possible physical channels in system.

 * @log_chans: Room for all possible logical channels in system.

 * @lookup_log_chans: Used to map interrupt number to logical channel. Points

 * to log_chans entries.

 * @lookup_phy_chans: Used to map interrupt number to physical channel. Points

 * to phy_chans entries.

 * @plat_data: Pointer to provided platform_data which is the driver

 * configuration.

 * @lcpa_regulator: Pointer to hold the regulator for the esram bank for lcla.

 * @phy_res: Vector containing all physical channels.

 * @lcla_pool: lcla pool settings and data.

 * @lcpa_base: The virtual mapped address of LCPA.

 * @phy_lcpa: The physical address of the LCPA.

 * @lcpa_size: The size of the LCPA area.

 * @desc_slab: cache for descriptors.

 * @reg_val_backup: Here the values of some hardware registers are stored

 * before the DMA is powered off. They are restored when the power is back on.

 * @reg_val_backup_v4: Backup of registers that only exits on dma40 v3 and

 * later

 * @reg_val_backup_chan: Backup data for standard channel parameter registers.

 * @regs_interrupt: Scratch space for registers during interrupt.

 * @gcc_pwr_off_mask: Mask to maintain the channels that can be turned off.

 * @gen_dmac: the struct for generic registers values to represent u8500/8540

 * DMA controller

 Physical half channels */

	/*

	 * Allocate both src and dst at the same time, therefore the half

	 * start on 1 since 0 can't be used since zero is used as end marker.

	/*

	 * We may have partially running cyclic transfers, in case we did't get

	 * enough LCLA entries.

	/*

	 * For linkback, we need one LCLA even with only one link, because we

	 * can't link back to the one in LCPA space

		/*

		 * If the channel is expected to use only soft_lli don't

		 * allocate a lcla. This is to avoid a HW issue that exists

		 * in some controller during a peripheral to memory transfer

		 * that uses linked lists.

	/*

	 * For linkback, we normally load the LCPA in the loop since we need to

	 * link it to the second LCLA and not the first.  However, if we

	 * couldn't even get a first LCLA, then we have to run in LCPA and

	 * reload manually.

 First link goes in both LCPA and LCLA */

		/*

		 * One unused LCLA in the cyclic case if the very first

		 * next_lcla fails...

		/*

		 * Cache maintenance is not needed if lcla is

		 * mapped in esram

 remove desc from current queue and add it to the pending_queue */

/*

 * The dma only supports transmitting packages up to

 * STEDMA40_MAX_SEG_SIZE * data_width, where data_width is stored in Bytes.

 *

 * Calculate the total number of dma elements required to send the entire sg list.

			/*

			 * Reduce the number of bus accesses while

			 * waiting for the DMA to suspend.

 Release completed descriptors */

 Release active descriptors */

 Release queued descriptors waiting for transfer */

 Release pending descriptors */

 Release client owned descriptors */

 Release descriptors in prepare queue */

			/*

			 * Reduce the number of bus accesses while

			 * waiting for the DMA to suspend.

	/*

	 * The hardware sometimes doesn't register the enable when src and dst

	 * event lines are active on the same logical channel.  Retry to ensure

	 * it does.  Usually only one retry is sufficient.

 Enable event line connected to device (or memcpy) */

 Odd addresses are even addresses + 4 */

 Setup channel mode to logical or physical */

 Setup operational mode option register */

 Set default config for CFG reg */

 Set LIDX for lcla */

 Clear LNK which will be used by d40_chan_has_events() */

 If bytes left to transfer or linked tx resume job */

 Start queued jobs, if any */

 Remove from queue */

 Add to active queue */

 Initiate DMA job */

 Start dma job */

 called from interrupt context */

 Get first active entry from list */

		/*

		 * If this was a paritially loaded list, we need to reloaded

		 * it, and only when the list is completed.  We need to check

		 * for done because the interrupt will hit for every link, and

		 * not just the last one.

 Start dma job */

 Get first entry from the done list */

 Check if we have reached here for cyclic job */

	/*

	 * If terminating a channel pending_tx is set to zero.

	 * This prevents any finished active jobs to return to the client.

 Callback to client */

 Rescue manouver if receiving double interrupts */

 Read interrupt status of both logical and physical channels */

 No more set bits found? */

			/*

			 * No error because this can happen if something else

			 * in the system is using the channel.

 ACK interrupt */

		/*

		 * DMAC HW supports it. Will be added to this driver,

		 * in case any dma client requires it.

		/*

		 * The DMAC hardware only supports

		 * src (burst x width) == dst (burst x width)

 Physical interrupts are masked per physical full channel */

 Logical channel */

 Logical channel */

 dst event lines are used for logical memcpy */

 Find physical half channel */

 Find logical channel */

		/*

		 * Spread logical channels across all available physical rather

		 * than pack every logical channel at the first available phy

		 * channels.

 Generate interrrupt at end of transfer or relink. */

 Generate interrupt on error. */

 Terminate all queued and active transfers */

	/*

	 * add descriptor to the prepare queue in order to be able

	 * to free them later in terminate_all

	/*

	 * Due to a hardware bug, in some cases a logical channel triggered by

	 * a high priority destination event line can generate extra packet

	 * transactions.

	 *

	 * The workaround is to not set the high priority level for the

	 * destination event lines that trigger logical channels.

 Destination event lines are stored in the upper halfword */

 DMA ENGINE functions */

 If no dma configuration is set use default configuration (memcpy) */

 Unmask the Global Interrupt Mask. */

	/*

	 * Only write channel configuration to the DMA if the physical

	 * resource is free. In case of multiple logical channels

	 * on the same physical resource, only the first write is necessary.

 Busy means that queued jobs are already being processed */

 Runtime reconfiguration extension */

 Configure the memory side */

 Configure the memory side */

 Only valid widths are; 1, 2, 4 and 8. */

 Fill in register values */

 These settings will take precedence later */

 Initialization functions */

		/*

		 * This controller can only access address at even

		 * 32bit boundaries, i.e. 2^2

 Suspend resume functionality */

 Save/Restore channel specific registers */

 Save/Restore global registers */

 Save/Restore registers only existing on dma40 v3 and later */

 Don't disable/enable clocks for v1 due to HW bugs */

 Initialization functions. */

 Mark security only channels as occupied */

 Mark disabled channels as occupied */

 Mark soft_lli channels */

 Verify settings extended vs standard */

	/*

	 * To keep things simple, Enable all clocks initially.

	 * The clocks will get managed later post channel allocation.

	 * The clocks for the event lines on which reserved channels exists

	 * are not managed here.

 Get IO for DMAC base address */

 This is just a regular AMBA PrimeCell ID actually */

	/*

	 * HW revision:

	 * DB8500ed has revision 0

	 * ? has revision 1

	 * DB8500v1 has revision 2

	 * DB8500v2 has revision 3

	 * AP9540v1 has revision 4

	 * DB8540v1 has revision 4

 The number of physical channels on this HW */

 The number of channels used for memcpy */

 Configure all our dma channels to default settings */

 Enable interrupt # */

 Clear interrupt # */

 Set channel to physical mode */

 Write which interrupt to enable */

 Write which interrupt to clear */

 These are __initdata and cannot be accessed after init */

	/*

	 * This is somewhat ugly. We need 8192 bytes that are 18 bit aligned,

	 * To full fill this hardware requirement without wasting 256 kb

	 * we allocate pages until we get an aligned one.

 Calculating how many pages that are required */

		/*

		 * After many attempts and no succees with finding the correct

		 * alignment, try with allocating a big buffer.

 If absent this value will be obtained from h/w. */

 Get IO for logical channel parameter address */

 We make use of ESRAM memory for this. */

 If lcla has to be located in ESRAM we don't need to allocate */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * DMA Engine test module

 *

 * Copyright (C) 2007 Atmel Corporation

 * Copyright (C) 2013 Intel Corporation

/**

 * struct dmatest_params - test parameters.

 * @buf_size:		size of the memcpy test buffer

 * @channel:		bus ID of the channel to test

 * @device:		bus ID of the DMA Engine to test

 * @threads_per_chan:	number of threads to start per channel

 * @max_channels:	maximum number of channels to use

 * @iterations:		iterations before stopping test

 * @xor_sources:	number of xor source buffers

 * @pq_sources:		number of p+q source buffers

 * @timeout:		transfer timeout in msec, -1 for infinite timeout

 * @noverify:		disable data verification

 * @norandom:		disable random offset setup

 * @alignment:		custom data address alignment taken as 2^alignment

 * @transfer_size:	custom transfer size in bytes

 * @polled:		use polling for completion instead of interrupts

/**

 * struct dmatest_info - test information.

 * @params:		test parameters

 * @channels:		channels under test

 * @nr_channels:	number of channels under test

 * @lock:		access protection to the fields of this structure

 * @did_init:		module has been initialized completely

 * @last_error:		test has faced configuration issues

 Test parameters */

 Internal state */

 Maximum amount of mismatched bytes in buffer to print */

/*

 * Initialization patterns. All bytes in the source buffer has bit 7

 * set, all bytes in the destination buffer has bit 7 cleared.

 *

 * Bit 6 is set for all bytes which are to be copied by the DMA

 * engine. Bit 5 is set for all bytes which are to be overwritten by

 * the DMA engine.

 *

 * The remaining bits are the inverse of a counter which increments by

 * one for each byte address.

 Fixed point arithmetic ops */

 poor man's completion - we want to use wait_event_freezable() on it */

		/*

		 * If thread->done, it means that this callback occurred

		 * after the parent thread has cleaned up. This can

		 * happen in the case that driver doesn't implement

		 * the terminate_all() functionality and a dma operation

		 * did not occur within the timeout period

 drop precision until runtime is 32-bits */

 align to alignment restriction */

/*

 * This function repeatedly tests DMA transfers of various lengths and

 * offsets for a given operation type until it is told to exit by

 * kthread_stop(). There may be multiple threads running this function

 * in parallel for a single channel, and there may be multiple channels

 * being tested in parallel.

 *

 * Before each test, the source and destination buffer is initialized

 * with a known pattern. This pattern is different depending on

 * whether it's in an area which is supposed to be copied or

 * overwritten, and different in the source and destination buffers.

 * So if the DMA engine doesn't copy exactly what we tell it to copy,

 * we'll notice.

 force odd to ensure dst = src */

 force odd to ensure dst = src */

 Check if buffer count fits into map count variable (u8) */

	/*

	 * src and dst buffers are freed by ourselves below

 Do not alter transfer size explicitly defined by user */

 map with DMA_BIDIRECTIONAL to force writeback/invalidate */

 terminate all transfers on specified channels */

 terminate all transfers on specified channels */

 srcbuf and dstbuf are allocated by the thread itself */

 add_channel failed, punt */

 no more channels available */

 we have all we need */

 Copy test parameters */

	/* we might be called early to set run=, defer running until all

	 * parameters have been evaluated

			/*

			 * We have nothing to run. This can be due to:

 1) Misconfiguration */

 2) We rely on defaults */

Clear any previously run threads */

 Reject channels that are already registered */

 Check if channel was added successfully */

		/*

		 * if new channel was not successfully added, revert the

		 * "test_channel" string to the name of the last successfully

		 * added channel. exception for when users issues empty string

		 * to channel parameter.

 Clear test_channel if no channels were added successfully */

	/* module parameters are stable, inittime tests are started,

	 * let userspace take over 'run' control

 when compiled-in wait for drivers to load first */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * offload engine driver for the Intel Xscale series of i/o processors

 * Copyright © 2006, Intel Corporation.

/*

 * This driver supports the asynchrounous DMA copy and RAID engines available

 * on the Intel Xscale(R) family of I/O Processors (IOP 32x, 33x, 134x)

/**

 * iop_adma_free_slots - flags descriptor slots for reuse

 * @slot: Slot to free

 * Caller must hold &iop_chan->lock while calling this function

		/* call the callback (must not sleep or submit new

		 * operations to this channel)

 run dependent operations */

	/* the client is allowed to attach dependent operations

	 * until 'ack' is set

	/* leave the last descriptor in the chain

	 * so we can append to it

	/* free completed slots from the chain starting with

	 * the oldest descriptor

		/* do not advance past the current descriptor loaded into the

		 * hardware channel, subsequent descriptors are either in

		 * process or have not been submitted

		/* stop the search if we reach the current descriptor and the

		 * channel is busy, or if it appears that the current descriptor

		 * needs to be re-read (i.e. has been appended to)

 detect the start of a group transaction */

 all the members of a group are complete */

 collect the total results */

 clean up the group */

 the group should be complete at this point */

 wait for group completion */

 write back zero sum results (single descriptor case) */

	/* lockdep will flag depedency submissions as potentially

	 * recursive locking, this is not the case as a dependency

	 * submission will never recurse a channels submit routine.

	 * There are checks in async_tx.c to prevent this.

	/* start search from the last allocated descrtiptor

	 * if a contiguous allocation can not be found start searching

	 * from the beginning of the list

			/* give up after finding the first busy slot

			 * on the second pass through the list

 start the allocation if the slot is correctly aligned */

 pre-ack all but the last descriptor */

 perform direct reclaim if the allocation fails */

 fix up the hardware chain */

 flush */

 check for pre-chained descriptors */

	/* increment the pending count by the number of slots

	 * memcpy operations have a 1:1 (slot:operation) relation

	 * other operations are heavier and will pop the threshold

	 * more often.

/**

 * iop_adma_alloc_chan_resources -  returns the number of allocated descriptors

 * @chan: allocate descriptor resources for this channel

 *

 * Note: We keep the slots for 1 operation on iop_chan->chain at all times.  To

 * avoid deadlock, via async_xor, num_descs_in_pool must at a minimum be

 * greater than 2x the number slots needed to satisfy a device->max_xor

 * request.

 Allocate descriptor slots */

 initialize the channel and the chain with a null operation */

		/* even if P is disabled its destination address (bits

		 * [3:0]) must match Q.  It is ok if P points to an

		 * invalid address, it won't be written.

		/* if we are continuing a previous operation factor in

		 * the old p and q values, see the comment for dma_maxpq

		 * in include/linux/dmaengine.h

		/* for validate operations p and q are tagged onto the

		 * end of the source list

 one is ok since we left it on there on purpose */

/**

 * iop_adma_status - poll the status of an ADMA transaction

 * @chan: ADMA channel handle

 * @cookie: ADMA transaction identifier

 * @txstate: a holder for the current state of the channel or NULL

/*

 * Perform a transaction to verify the HW works.

 Fill in src buffer */

 Start copy, using first DMA channel */

 must be <= 15 */

 Fill in src buffers */

 test xor */

 skip zero sum if the capability is not present */

 zero sum the sources with the destintation page */

 test for non-zero parity sum */

 combined sources, software pq results, and extra hw pq results */

 ptr to the extra hw pq buffers defined above */

 address conversion buffers (dma_map / page_address) */

 Fill in src buffers */

 initialize the dests */

 test pq */

 test correct zero sum using the software generated pq values */

 test incorrect zero sum */

	/* allocate coherent memory for hardware descriptors

	 * note: writecombine gives slightly better performance, but

	 * requires that we explicitly flush the writes

 discover transaction capabilites from the platform data */

 set base routines */

 set prep routines based on capability */

 clear errors before enabling interrupts */

 can not test raid6, so do not publish capability */

		/* initialize the completed cookie to be less than

		 * the most recently used cookie

 channel should not be busy */

 clear any prior error-status bits */

 disable operation */

 set the descriptor address */

		/* 1/ don't add pre-chained descriptors

		 * 2/ dummy read to flush next_desc write

 run the descriptor */

		/* initialize the completed cookie to be less than

		 * the most recently used cookie

 channel should not be busy */

 clear any prior error-status bits */

 disable operation */

 set the descriptor address */

		/* 1/ don't add pre-chained descriptors

		 * 2/ dummy read to flush next_desc write

 run the descriptor */

/*

 * Copyright (C) 2017 Spreadtrum Communications Inc.

 *

 * SPDX-License-Identifier: GPL-2.0

 DMA global registers definition */

 DMA channel registers definition */

 SPRD_DMA_GLB_2STAGE_GRP register definition */

 SPRD_DMA_CHN_INTC register definition */

 SPRD_DMA_CHN_CFG register definition */

 SPRD_DMA_CHN_REQ register definition */

 SPRD_DMA_CHN_PAUSE register definition */

 DMA_CHN_WARP_* register definition */

 SPRD_DMA_CHN_INTC register definition */

 SPRD_DMA_CHN_FRG_LEN register definition */

 SPRD_DMA_CHN_BLK_LEN register definition */

 SPRD_DMA_CHN_TRSC_LEN register definition */

 SPRD_DMA_CHN_TRSF_STEP register definition */

 SPRD DMA_SRC_BLK_STEP register definition */

 define DMA channel mode & trigger mode mask */

 define the DMA transfer step type */

 dma data width values */

 dma channel hardware configuration */

 dma request description */

 dma channel description */

 SPRD dma device */

	/*

	 * The ashb_clk is optional and only for AGCP DMA controller, so we

	 * need add one condition to check if the ashb_clk need enable.

	/*

	 * Need to check if we need disable the optional ashb_clk for AGCP DMA.

 The DMA request id always starts from 0. */

	/*

	 * Set 2-stage configuration if the channel starts one 2-stage

	 * transfer.

	/*

	 * Copy the DMA configuration from DMA descriptor to this hardware

	 * channel.

 cyclic mode schedule callback */

 Check if the dma request descriptor is done. */

		/*

		 * For 2-stage transfer, destination channel step can not be 0,

		 * since destination device is AON IRAM.

	/*

	 * wrap_ptr and wrap_to will save the high 4 bits source address and

	 * destination address.

	/*

	 * If the src step and dst step both are 0 or both are not 0, that means

	 * we can not enable the fix mode. If one is 0 and another one is not,

	 * we can enable the fix mode.

 link-list configuration */

 link-list index */

 Next link-list configuration's physical address offset */

		/*

		 * Set the link-list pointer point to next link-list

		 * configuration's physical address.

	/*

	 * Set channel mode, interrupt mode and trigger mode for 2-stage

	 * transfer.

		/*

		 * The link-list mode needs at least 2 link-list

		 * configurations. If there is only one sg, it doesn't

		 * need to fill the link-list configuration.

 ashb clock is optional for AGCP DMA */

	/*

	 * We have three DMA controllers: AP DMA, AON DMA and AGCP DMA. For AGCP

	 * DMA controller, it can or do not request the irq, which will save

	 * system power without resuming system by DMA interrupts if AGCP DMA

	 * does not request the irq. Thus the DMA interrupts property should

	 * be optional.

 get each channel's registers base address. */

 explicitly free the irq */

 SPDX-License-Identifier: GPL-2.0

/*

 * Microsemi Switchtec(tm) PCIe Management Driver

 * Copyright (c) 2019, Logan Gunthorpe <logang@deltatee.com>

 * Copyright (c) 2019, GigaIO Networks, Inc

 return with the lock held, it will be released in tx_submit */

	/*

	 * Keep sparse happy by restoring an even lock count on

	 * this lock.

	/*

	 * Ensure the descriptor updates are visible to the dma device

	 * before setting the valid bit.

	/*

	 * Ensure the valid bits are visible before starting the

	 * DMA engine.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2014 Emilio López

 * Emilio López <emilio@elopez.com.ar>

* Common macros to normal and dedicated DMA registers **/

* Normal DMA register values **/

 Normal DMA source/destination data request type values */

* Normal DMA register layout **/

 Dedicated DMA source/destination address mode values */

 Normal DMA configuration register layout */

* Dedicated DMA register values **/

 Dedicated DMA source/destination address mode values */

 Dedicated DMA source/destination data request type values */

* Dedicated DMA register layout **/

 Dedicated DMA configuration register layout */

 Dedicated DMA parameter register layout */

* DMA register offsets **/

 General register offsets */

 Normal DMA register offsets */

 Dedicated DMA register offsets */

* DMA Driver **/

/*

 * Normal DMA has 8 channels, and Dedicated DMA has another 8, so

 * that's 16 channels. As for endpoints, there's 29 and 21

 * respectively. Given that the Normal DMA endpoints (other than

 * SDRAM) can be used as tx/rx, we need 78 vchans in total

/* This set of SUN4I_DDMA timing parameters were found experimentally while

 Register base of channel */

 vchan currently being serviced */

 Is this a dedicated pchan? */

 A contract is a set of promises */

 1 -> 0, 4 -> 1, 8 -> 2 */

 8 (1 byte) -> 0, 16 (2 bytes) -> 1, 32 (4 bytes) -> 2 */

	/*

	 * pchans 0-SUN4I_NDMA_NR_MAX_CHANNELS are normal, and

	 * SUN4I_NDMA_NR_MAX_CHANNELS+ are dedicated ones

	/*

	 * Configure addresses and misc parameters depending on type

	 * SUN4I_DDMA has an extra field with timing parameters

/*

 * Execute pending operations on a vchan

 *

 * When given a vchan, this function will try to acquire a suitable

 * pchan and, if successful, will configure it to fulfill a promise

 * from the next pending contract.

 *

 * This function must be called with &vchan->vc.lock held.

 We need a pchan to do anything, so secure one if available */

	/*

	 * Channel endpoints must not be repeated, so if this vchan

	 * has already submitted some work, we can't do anything else

 Figure out which contract we're working with today */

 The contract has been completed so mark it as such */

 Now find out what we need to do */

 ... and make it reality */

/*

 * Generate a promise, to be used in a normal DMA contract.

 *

 * A NDMA promise contains all the information required to program the

 * normal part of the DMA Engine and get data copied. A non-executed

 * promise will live in the demands list on a contract. Once it has been

 * completed, it will be moved to the completed demands list for later freeing.

 * All linked promises will be freed when the corresponding contract is freed

 Source burst */

 Destination burst */

 Source bus width */

 Destination bus width */

/*

 * Generate a promise, to be used in a dedicated DMA contract.

 *

 * A DDMA promise contains all the information required to program the

 * Dedicated part of the DMA Engine and get data copied. A non-executed

 * promise will live in the demands list on a contract. Once it has been

 * completed, it will be moved to the completed demands list for later freeing.

 * All linked promises will be freed when the corresponding contract is freed

 Source burst */

 Destination burst */

 Source bus width */

 Destination bus width */

/*

 * Generate a contract

 *

 * Contracts function as DMA descriptors. As our hardware does not support

 * linked lists, we need to implement SG via software. We use a contract

 * to hold all the pieces of the request and process them serially one

 * after another. Each piece is represented as a promise.

/*

 * Get next promise on a cyclic transfer

 *

 * Cyclic contracts contain a series of promises which are executed on a

 * loop. This function returns the next promise from a cyclic contract,

 * so it can be programmed into the hardware.

/*

 * Free a contract and all its associated promises

 Free all the demands and completed demands */

	/*

	 * We can only do the copy to bus aligned addresses, so

	 * choose the best one so we get decent performance. We also

	 * maximize the burst size for this same reason.

 Configure memcpy mode */

 Fill the contract with our only promise */

 And add it to the vchan */

	/*

	 * We will be using half done interrupts to make two periods

	 * out of a promise, so we need to program the DMA engine less

	 * often

	/*

	 * The engine can interrupt on half-transfer, so we can use

	 * this feature to program the engine half as often as if we

	 * didn't use it (keep in mind the hardware doesn't support

	 * linked lists).

	 *

	 * Say you have a set of periods (| marks the start/end, I for

	 * interrupt, P for programming the engine to do a new

	 * transfer), the easy but slow way would be to do

	 *

	 *  |---|---|---|---| (periods / promises)

	 *  P  I,P I,P I,P  I

	 *

	 * Using half transfer interrupts you can do

	 *

	 *  |-------|-------| (promises as configured on hw)

	 *  |---|---|---|---| (periods)

	 *  P   I  I,P  I   I

	 *

	 * Which requires half the engine programming for the same

	 * functionality.

 Calculate the offset in the buffer and the length needed */

 Make the promise */

 TODO: should we free everything? */

 Then add it to the contract */

 And add it to the vchan */

 Figure out addresses */

		/*

		 * These are the magic DMA engine timings that keep SPI going.

		 * I haven't seen any interface on DMAEngine to configure

		 * timings, and so far they seem to work for everything we

		 * support, so I've kept them here. I don't know if other

		 * devices need different timings because, as usual, we only

		 * have the "para" bitfield meanings, but no comment on what

		 * the values should be when doing a certain operation :|

 And make a suitable promise */

 TODO: should we free everything? */

 Then add it to the contract */

	/*

	 * Once we've got all the promises ready, add the contract

	 * to the pending list on the vchan

	/*

	 * Clearing the configuration register will halt the pchan. Interrupts

	 * may still trigger, so don't forget to disable them.

 Clear these so the vchan is usable again */

 Check if type is Normal or Dedicated */

 Make sure the endpoint looks sane */

 Assign the endpoint to the vchan */

	/*

	 * The hardware is configured to return the remaining byte

	 * quantity. If possible, replace the first listed element's

	 * full size with the actual remaining amount

	/*

	 * If there are pending transactions for this vchan, push one of

	 * them into the engine to get the ball rolling.

 a terminated channel may still interrupt */

		/*

		 * Disable the IRQ and free the pchan if it's an end

		 * interrupt (odd bit)

			/*

			 * Move the promise into the completed list now that

			 * we're done with it

			/*

			 * Cyclic DMA transfers are special:

			 * - There's always something we can dispatch

			 * - We need to run the callback

			 * - Latency is very important, as this is used by audio

			 * We therefore just cycle through the list and dispatch

			 * whatever we have here, reusing the pchan. There's

			 * no need to run the thread after this.

			 *

			 * For non-cyclic transfers we need to look around,

			 * so we can program some more work, or notify the

			 * client that their transfers have been completed.

 Half done interrupt */

 Disable the IRQs for events we handled */

 Writing 1 to the pending field will clear the pending interrupt */

	/*

	 * If a pchan was freed, we may be able to schedule something else,

	 * so have a look around

	/*

	 * Handle newer interrupts if some showed up, but only do it once

	 * to avoid a too long a loop

	/*

	 * [0..SUN4I_NDMA_NR_MAX_CHANNELS) are normal pchans, and

	 * [SUN4I_NDMA_NR_MAX_CHANNELS..SUN4I_DMA_NR_MAX_CHANNELS) are

	 * dedicated ones

	/*

	 * Make sure the IRQs are all disabled and accounted for. The bootloader

	 * likes to leave these dirty

 Disable IRQ so no more work is scheduled */

 sentinel */ },

 SPDX-License-Identifier: GPL-2.0-only

/*

 * offload engine driver for the Marvell XOR engine

 * Copyright (C) 2007, 2008, Marvell International Ltd.

 Enable end-of-descriptor interrupts only for DMA_PREP_INTERRUPT */

 writel ensures all descriptors are flushed before activation */

/*

 * mv_chan_start_new_chain - program the engine to operate on new

 * chain headed by sw_desc

 * Caller must hold &mv_chan->lock while calling this function

 set the hardware chain */

		/* call the callback (must not sleep or submit new

		 * operations to this channel)

 run dependent operations */

	/* the client is allowed to attach dependent operations

	 * until 'ack' is set

 move this slot to the completed_slots */

 This function must be called with the mv_xor_chan spinlock held */

	/* free completed slots from the chain starting with

	 * the oldest descriptor

 clean finished descriptors */

 done processing desc, clean slot */

 break if we did cleaned the current */

			/*

			 * current descriptor cleaned and removed, run

			 * from list head

				/*

				 * descriptors are still waiting after

				 * current, trigger them

				/*

				 * some descriptors are still waiting

				 * to be cleaned

 pre-ack descriptor */

 try to free some slots if the allocation fails */

*********************** DMA engine API functions ****************************/

 fix up the hardware chain */

 if the channel is not busy */

			/*

			 * and the curren desc is the end of the chain before

			 * the append, then we need to start the channel

 returns the number of allocated descriptors */

 Allocate descriptor slots */

/*

 * Check if source or destination is an PCIe/IO address (non-SDRAM) and add

 * a new MBus window if necessary. Use a cache for these check so that

 * the MMIO mapped registers don't have to be accessed for this check

 * to speed up this process.

 Nothing needs to get done for the Armada 3700 */

	/*

	 * Loop over the cached windows to check, if the requested area

	 * is already mapped. If this the case, nothing needs to be done

	 * and we can return.

 Window is already mapped */

	/*

	 * The window is not mapped, so we need to create the new mapping

 If no IO window is found that addr has to be located in SDRAM */

	/*

	 * Mask the base addr 'addr' according to 'size' read back from the

	 * MBus window. Otherwise we might end up with an address located

	 * somewhere in the middle of this area here.

	/*

	 * Reading one of both enabled register is enough, as they are always

	 * programmed to the identical values

 Set 'i' to the first free window to write the new values to */

 Fill the caching variables for later use */

 Check if a new window needs to get added for 'dest' */

 Check if a new window needs to get added for 'src' */

	/*

	 * A MEMCPY operation is identical to an XOR operation with only

	 * a single source address.

	/*

	 * We implement the DMA_INTERRUPT operation as a minimum sized

	 * XOR operation with a single dummy source address.

/**

 * mv_xor_status - poll the status of an XOR transaction

 * @chan: XOR channel handle

 * @cookie: XOR transaction identifier

 * @txstate: XOR transactions state holder (or NULL)

/*

 * Perform a transaction to verify the HW works.

 Fill in src buffer */

 must be <= 15 */

 Fill in src buffers */

 test xor */

	/*

	 * These source and destination dummy buffers are used to implement

	 * a DMA_INTERRUPT operation as a minimum-sized XOR operation.

	 * Hence, we only need to map the buffers at initialization-time.

	/* allocate coherent memory for hardware descriptors

	 * note: writecombine gives slightly better performance, but

	 * requires that we explicitly flush the writes

 discover transaction capabilites from the platform data */

 set base routines */

 set prep routines based on capability */

 clear errors before enabling interrupts */

 Fill the caching variables for later use */

	/*

	 * For Armada3700 open default 4GB Mbus window. The dram

	 * related configuration are done at AXIS level.

/*

 * Since this XOR driver is basically used only for RAID5, we don't

 * need to care about synchronizing ->suspend with DMA activity,

 * because the DMA engine will naturally be quiet due to the block

 * devices being suspended.

	/*

	 * We need to know which type of XOR device we use before

	 * setting up. In non-dt case it can only be the legacy one.

	/*

	 * (Re-)program MBUS remapping windows if we are asked to.

	/* Not all platforms can gate the clock, so it is not

	 * an error if the clock does not exists.

	/*

	 * We don't want to have more than one channel per CPU in

	 * order for async_tx to perform well. So we limit the number

	 * of engines and channels so that we take into account this

	 * constraint. Note that we also want to use channels from

	 * separate engines when possible.  For dual-CPU Armada 3700

	 * SoC with single XOR engine allow using its both channels.

/*

MODULE_AUTHOR("Saeed Bishara <saeed@marvell.com>");

MODULE_DESCRIPTION("DMA engine driver for Marvell's XOR engine");

MODULE_LICENSE("GPL");

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) 2012 Samsung Electronics Co., Ltd.

 *		http://www.samsung.com

 *

 * Copyright (C) 2010 Samsung Electronics Co. Ltd.

 *	Jaswinder Singh <jassi.brar@samsung.com>

 Noncacheable and nonbufferable */

 Bufferable only */

 Cacheable, but do not allocate */

 Cacheable and bufferable, but do not allocate */

 AWCACHE = 0x1000 */

 Cacheable write-through, allocate on writes only */

 Cacheable write-back, allocate on writes only */

 Register and Bit field Definitions */

/*

 * With 256 bytes, we can do more than 2.5MB and 5MB xfers per req

 * at 1byte/burst for P<->M and M<->M respectively.

 * For typical scenario, at 1word/burst, 10MB and 20MB xfers per req

 * should be enough for P<->M and M<->M respectively.

 Use this _only_ to wait on transient states */

 The number of default descriptors */

 Delay for runtime PM autosuspend, ms */

 Populated by the PL330 core driver for DMA API driver's info */

 In number of bits */

/*

 * Request Configuration.

 * The PL330 core does not modify this and uses the last

 * working configuration if the request doesn't provide any.

 *

 * The Client may want to provide this info only for the

 * first request and a request with new settings.

 Address Incrementing */

	/*

	 * For now, the SRC & DST protection levels

	 * and burst size/length are assumed same.

 in power of 2 */

/*

 * One cycle of DMAC operation.

 * There may be more than one xfer in a request.

 Size to xfer */

 The xfer callbacks are made with one of these arguments. */

 The all xfers in the request were success. */

 If req aborted due to global error. */

 If req failed due to problem with Channel. */

 ToBeDone for tasklet */

 A DMAC Thread */

 If the channel is not yet acquired by any client */

 Parent DMAC */

 Only two at a time */

 Index of the last enqueued request */

 Index of the last submitted request or -1 if the DMA is stopped */

 In the DMAC pool */

	/*

	 * Allocated to some channel during prep_xxx

	 * Also may be sitting on the work_list.

	/*

	 * Sitting on the work_list and already submitted

	 * to the PL330 core. Not more than two descriptors

	 * of a channel can be BUSY at any time.

	/*

	 * Sitting on the channel work_list but xfer done

	 * by PL330 core

 Schedule desc completion */

 DMA-Engine Channel */

 List of submitted descriptors */

 List of issued descriptors */

 List of completed descriptors */

	/* Pointer to the DMAC that manages this channel,

	 * NULL if the channel is available to be acquired.

	 * As the parent, this DMAC also provides descriptors

	 * to the channel.

 To protect channel manipulation */

	/*

	 * Hardware channel thread of PL330 DMAC. NULL if the channel is

	 * available.

 For D-to-M and M-to-D channels */

 the peripheral fifo width */

 the number of burst */

 DMA-mapped view of the FIFO; may differ if an IOMMU is present */

 for cyclic capability */

 for runtime pm tracking */

 DMA-Engine Device */

 Pool of descriptors available for the DMAC's channels */

 To protect desc_pool manipulation */

 Size of MicroCode buffers for each channel. */

 ioremap'ed address of PL330 registers. */

 Populated by the PL330 core driver during pl330_add */

 Maximum possible events/irqs */

 BUS address of MicroCode buffer */

 CPU address of MicroCode buffer */

 List of all Channel threads */

 Pointer to the MANAGER thread */

 To handle bad news in interrupt */

 State of DMAC operation */

 Holds list of reqs with due callbacks */

 Peripheral channels connected to this DMAC */

 keep at end */

 To attach to a queue as child */

 Descriptor for the DMA Engine API */

 Xfer for PL330 core */

 The channel which currently holds this desc */

 Index of peripheral for the xfer. */

 Hook to attach to DMAC's list of reqs with due callback */

 If manager of the thread is in Non-Secure mode */

 DMAC increments by 1 internally */

 Returns Time-Out */

 Until Manager is Idle */

 If timed out due to halted state-machine */

 Channel Number */

 Get going */

 Return if nothing needs to be done */

 clear the event */

 Stop generating interrupts for SEV */

 Start doing req 'idx' of thread 'thrd' */

 Return if already ACTIVE */

 Return if no request */

 Return if req is running */

 See 'Abort Sources' point-4 at Page 2-25 */

 Set to generate interrupts for SEV */

 Only manager can execute GO */

 For RESUME, nothing yet */

 check lock-up free version */

 this code should be unreachable */

 this code should be unreachable */

	/*

	 * do FLUSHP at beginning to clear any stale dma requests before the

	 * first WFP.

 this code should be unreachable */

/*

 * only the unaligned burst transfers have the dregs.

 * so, still transfer dregs with a reduced size burst

 * for mem-to-mem, mem-to-dev or dev-to-mem.

	/*

	 * dregs_len = (total bytes - BURST_TO_BYTE(bursts, ccr)) /

	 *             BRST_SIZE(ccr)

	 * the dregs len must be smaller than burst len,

	 * so, for higher efficiency, we can modify CCR

	 * to use a reduced size burst len for the dregs.

 this code should be unreachable */

 Returns bytes consumed and updates bursts */

 Max iterations possible in DMALP is 256 */

	/*

	 * Max bursts that we can unroll due to limit on the

	 * size of backward jump that can be encoded in DMALPEND

	 * which is 8-bits and hence 255

 DMAMOV SAR, x->src_addr */

 DMAMOV DAR, x->dst_addr */

 Setup Loop(s) */

/*

 * A req is a sequence of one or more xfer units.

 * Returns the number of bytes taken to setup the MC for the req.

 DMAMOV CCR, ccr */

 DMASEV peripheral/event */

 DMAEND */

 We set same protection levels for Src and DST for now */

/*

 * Submit a list of xfers after which the client wants notification.

 * Client is not notified after each xfer unit, just once after all

 * xfer units are done or some error occurs.

 If request for non-existing peripheral */

 Prefer Secure Channel */

 First dry run to check if req is acceptable */

 Hook the request */

 If desc aborted */

 The DMAC itself gone nuts */

 Reset the manager too */

 Clear the reset flag */

 Reset all channels */

 Clear the reset flag */

 Clear the reset flag */

 Returns 1 if state was updated, 0 otherwise */

 Check which event happened i.e, thread notified */

 Event occurred */

 Clear the event */

 Aborted */

 Detach the req */

 Get going again ASAP */

 For now, just make a list of callbacks to be done */

 Now that we are in no hurry, do the callbacks */

 Reserve an event */

/* Upon success, returns IdentityToken for the

 * allocated channel, NULL otherwise.

 Release an event */

 If the event is valid and was held by the thread */

/* Initialize the structure for PL330 configuration, that can be used

 * by the client driver the make best use of the DMAC

 Allocate 1 Manager and 'chans' Channel threads */

 Init Channel threads */

 MANAGER is indexed at the end */

	/*

	 * Alloc MicroCode buffer for 'chans' Channel threads.

	 * A channel's buffer offset is (Channel_Id * MCODE_BUFF_PERCHAN)

 Check if we can handle this DMAC */

 Read the configuration of the DMAC */

 Use default MC buffer size if not provided */

 Mark all events as free */

 Allocate resources needed by the DMAC */

 Release Channel threads */

 Free memory */

 Free DMAC resources */

 forward declaration */

 If already submitted */

 QFull or DMAC Dying */

 Unacceptable request */

 Pick up ripe tomatoes */

 Try to submit a req imm. next to the last completed cookie */

 Make sure the PL330 Channel thread is active */

 If work list empty, power down */

/*

 * We need the data direction between the DMAC (the dma-mapping "device") and

 * the FIFO (the dmaengine "dev"), from the FIFO's point of view. Confusing!

 Already mapped for this config? */

 Mark all desc done */

/*

 * We don't support DMA_RESUME command because of hardware

 * limitations, so after pausing the channel we cannot restore

 * it to active state. We have to terminate channel and setup

 * DMA transfer again. This pause feature was implemented to

 * allow safely read residue before channel termination.

 If DMAMOV hasn't finished yet, SAR/DAR can be zero */

 Check in pending list */

			/*

			 * Busy but not running means either just enqueued,

			 * or finished and not yet marked done

		/*

		 * Warn on nothing pending. Empty submitted_list may

		 * break our pm_runtime usage counter as it is

		 * updated on work_list emptiness status.

/*

 * We returned the last one of the circular list of descriptor(s)

 * from prep_xxx, so the argument to submit corresponds to the last

 * descriptor of the list.

 Assign cookies to all nodes */

 Returns the number of descriptors added to the DMAC pool */

 Pluck one desc from the pool of DMAC */

 If the DMAC pool is empty, alloc new */

 Initialize the descriptor */

	/*

	 * Ideally we should lookout for reqs bigger than

	 * those that can be programmed with 256 bytes of

	 * MC buffer, but considering a req size is seldom

	 * going to be word-unaligned and more than 200MB,

	 * we take it easy.

	 * Also, should the limit is reached we'd rather

	 * have the platform increase MC buffer size than

	 * complicating this API driver.

 Call after fixing burst size */

 src/dst_burst_len can't be more than 16 */

 Select max possible burst size */

	/*

	 * Make sure we use a burst size that aligns with all the memcpy

	 * parameters because our DMA programming algorithm doesn't cope with

	 * transfers which straddle an entry in the DMA device's MFIFO.

	/*

	 * If burst size is smaller than bus width then make sure we only

	 * transfer one at a time to avoid a burst stradling an MFIFO entry.

 Return the last desc in the chain */

/*

 * Runtime PM callbacks are provided by amba/bus.c driver.

 *

 * It is assumed here that IRQ safe runtime PM is chosen in probe and amba

 * bus driver will only disable/enable the clock in runtime PM callbacks.

 Allocate a new DMAC and its Channels */

 get quirk */

 Create a descriptor pool of default size */

 Initialize channel parameters */

 Add the channel to the DMAC list */

	/*

	 * This is the limit for transfers with a buswidth of 1, larger

	 * buswidths will have larger limits.

 Idle the DMAC */

 Remove the channel */

 Flush the channel */

 Idle the DMAC */

 Remove the channel */

 Flush the channel */

 SPDX-License-Identifier: GPL-2.0



 Copyright (C) 2019 Linaro Ltd.

 Copyright (C) 2019 Socionext Inc.

 global register */

 channel local register */

 mc->vc.lock must be held by caller */

 mc->vc.lock must be held by caller */

 Setup the channel */

 Start the channel */

 mc->vc.lock must be held by caller */

 Ack and Stop */

 Halt the channel */

	/*

	 * Before reaching here, almost all descriptors have been freed by the

	 * ->device_free_chan_resources() hook. However, each channel might

	 * be still holding one descriptor that was on-flight at that moment.

	 * Terminate it to make sure this hardware is no longer running. Then,

	 * free the channel resources once again to avoid memory leak.

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) ST-Ericsson SA 2007-2010

 * Author: Per Forlin <per.forlin@stericsson.com> for ST-Ericsson

 * Author: Jonas Aaberg <jonas.aberg@stericsson.com> for ST-Ericsson

 Sets up proper LCSP1 and LCSP3 register for a logical channel */

 dst */

 src */

 src is mem? -> increase address pos */

 dst is mem? -> increase address pos */

 src is hw? -> master port 1 */

 dst is hw? -> master port 1 */

 Set master port to 1 */

 Set master port to 1 */

 Interrupt on end of transfer for destination */

 Generate interrupt on error */

 PSIZE */

 Element size */

 Set the priority bit to high for the physical channel */

 Must be aligned */

 Transfer size can't be smaller than (num_elms * elem_size) */

 The number of elements. IE now many chunks */

	/*

	 * Distance to next element sized entry.

	 * Usually the size of the element unless you want gaps.

 Where the data is */

 If this scatter list entry is the last one, no next link */

 Set/clear interrupt generation on this link item.*/

	/*

	 * Post link - D40_SREG_LNK_PHY_PRE_POS = 0

	 * Relink happens after transfer completion.

	/*

	 * This piece may be split up based on d40_seg_size(); we only want the

	 * term int on the last part.

 DMA logical lli operations */

 The number of elements to transfer */

 16 LSBs address of the current element */

 16 MSBs address of the current element */

 src or dst*/

 src or dst*/

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Driver for the TXx9 SoC DMA Controller

 *

 * Copyright (C) 2009 Atsushi Nemoto

 txd.flags will be overwritten in prep funcs */

/*

 * Move a descriptor, including any children, to the free list.

 * `desc' must not be on any lists.

----------------------------------------------------------------------*/

 Called with dc->lock held and bh disabled */

 ASSERT:  channel is idle */

 The tasklet will hopefully advance the queue... */

 All 64-bit DMAC supports SMPCHN */

 Writing a non zero value to CHAR will assert XFACT */

 Writing a non zero value to CHAR will assert XFACT */

----------------------------------------------------------------------*/

	/*

	 * The API requires that no submissions are done from a

	 * callback, so we don't need to drop the lock here

 Make chain-completion interrupt happen */

	/*

	 * Submit queued descriptors ASAP, i.e. before we go through

	 * the completed ones.

	/*

	 * The descriptor currently at the head of the active list is

	 * borked. Since we don't have any way to report errors, we'll

	 * just have to scream loudly and try to carry on.

 Clear all error flags and try to restart the controller */

 Pretend the descriptor completed successfully */

 For dynamic chain, we should look at XFACT instead of NCHNC */

 Everything we've submitted is done */

 last descriptor of this chain */

 This one is currently in progress */

 Currently in progress */

		/*

		 * No descriptors so far seem to be in progress, i.e.

		 * this one must be done.

 Try to continue after resetting the channel... */

	/*

	 * Just disable the interrupts. We'll turn them back on in the

	 * softirq handler.

	/*

	 * Just disable the interrupts. We'll turn them back on in the

	 * softirq handler.

----------------------------------------------------------------------*/

		/*

		 * Workaround for ERT-TX49H2-033, ERT-TX49H3-020,

		 * ERT-TX49H4-016 (slightly conservative)

		/*

		 * The descriptors on tx_list are not reachable from

		 * the dc->queue list or dc->active_list after a

		 * submit.  If we put all descriptors on active_list,

		 * calling of callback on the completion will be more

		 * complex.

 Trigger interrupt after last block */

 Trigger interrupt after last block */

 active_list entries will end up before queued entries */

 Flush all pending and queued descriptors */

 Restart chain DMA */

 ASSERT:  channel is idle */

 ASSERT:  channel is idle */

----------------------------------------------------------------------*/

 force dma off, just in case */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Driver For Marvell Two-channel DMA Engine

 *

 * Copyright: Marvell International Ltd.

/*

 * Two-Channel DMA registers

 Byte Count */

 Src Addr */

 Dst Addr */

 Next Desc */

 Control */

 Priority*/

 Current Desc */

 Int Mask */

 Int Status */

 Two-Channel DMA Control Register */

 Sample Size */

 SSP MOD */

 Channel Abort */

 Close Desc Enable */

 Pack Mode (ADMA Only) */

 Channel Active */

 Fetch Next Desc */

 Channel Enable */

 Interrupt Mode */

 Chain Mode */

 Burst Size */

 Dst Direction */

 Dst Addr Hold */

 Dst Addr Increment */

 Src Direction */

 Src Addr Hold */

 Src Addr Increment */

 Two-Channel DMA Int Mask Register */

 Two-Channel DMA Int Status Register */

/*

 * Two-Channel DMA Descriptor Struct

 * NOTE: desc's buf must be aligned to 16 bytes.

 enable dma chan */

 clear irq */

 enable interrupt */

 disable interrupt */

 alloc channel */

 add the channel to tdma_chan list */

 always have couple channels */

 initialize channel parameters */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * DMA driver for Altera mSGDMA IP core

 *

 * Copyright (C) 2017 Stefan Roese <sr@denx.de>

 *

 * Based on drivers/dma/xilinx/zynqmp_dma.c, which is:

 * Copyright (C) 2016 Xilinx, Inc. All rights reserved.

/**

 * struct msgdma_extended_desc - implements an extended descriptor

 * @read_addr_lo: data buffer source address low bits

 * @write_addr_lo: data buffer destination address low bits

 * @len: the number of bytes to transfer per descriptor

 * @burst_seq_num: bit 31:24 write burst

 *		   bit 23:16 read burst

 *		   bit 15:00 sequence number

 * @stride: bit 31:16 write stride

 *	    bit 15:00 read stride

 * @read_addr_hi: data buffer source address high bits

 * @write_addr_hi: data buffer destination address high bits

 * @control: characteristics of the transfer

 mSGDMA descriptor control field bit definitions */

/*

 * Writing "1" the "go" bit commits the entire descriptor into the

 * descriptor FIFO(s)

 Tx buffer control flags */

 mSGDMA extended descriptor stride definitions */

 mSGDMA dispatcher control and status register map */

 Read / Clear */

 Read / Write */

 31:16 - write fill level */

 15:00 - read fill level */

 response FIFO fill level */

 31:16 - write seq number */

 15:00 - read seq number */

 mSGDMA CSR status register bit definitions */

 mSGDMA CSR control register bit definitions */

 mSGDMA CSR fill level bits */

 mSGDMA response register map */

 mSGDMA response register bit definitions */

/**

 * struct msgdma_sw_desc - implements a sw descriptor

 * @async_tx: support for the async_tx api

 * @hw_desc: assosiated HW descriptor

 * @node: node to move from the free list to the tx list

 * @tx_list: transmit list node

/*

 * struct msgdma_device - DMA device structure

 mSGDMA controller */

 mSGDMA descriptors */

 mSGDMA response */

/**

 * msgdma_get_descriptor - Get the sw descriptor from the pool

 * @mdev: Pointer to the Altera mSGDMA device structure

 *

 * Return: The sw descriptor

/**

 * msgdma_free_descriptor - Issue pending transactions

 * @mdev: Pointer to the Altera mSGDMA device structure

 * @desc: Transaction descriptor pointer

/**

 * msgdma_free_desc_list - Free descriptors list

 * @mdev: Pointer to the Altera mSGDMA device structure

 * @list: List to parse and delete the descriptor

/**

 * msgdma_desc_config - Configure the descriptor

 * @desc: Hw descriptor pointer

 * @dst: Destination buffer address

 * @src: Source buffer address

 * @len: Transfer length

 * @stride: Read/write stride value to set

 Set lower 32bits of src & dst addresses in the descriptor */

 Set upper 32bits of src & dst addresses in the descriptor */

 0 will result in max burst length */

	/*

	 * Don't set interrupt on xfer end yet, this will be done later

	 * for the "last" descriptor

/**

 * msgdma_desc_config_eod - Mark the descriptor as end descriptor

 * @desc: Hw descriptor pointer

/**

 * msgdma_tx_submit - Submit DMA transaction

 * @tx: Async transaction descriptor pointer

 *

 * Return: cookie value

/**

 * msgdma_prep_memcpy - prepare descriptors for memcpy transaction

 * @dchan: DMA channel

 * @dma_dst: Destination buffer address

 * @dma_src: Source buffer address

 * @len: Transfer length

 * @flags: transfer ack flags

 *

 * Return: Async transaction descriptor on success and NULL on failure

 Allocate and populate the descriptor */

/**

 * msgdma_prep_slave_sg - prepare descriptors for a slave sg transaction

 *

 * @dchan: DMA channel

 * @sgl: Destination scatter list

 * @sg_len: Number of entries in destination scatter list

 * @dir: DMA transfer direction

 * @flags: transfer ack flags

 * @context: transfer context (unused)

 Run until we are out of scatterlist entries */

 Allocate and populate the descriptor */

 Fetch the next scatterlist entry */

 Reset mSGDMA */

 Clear all status bits */

 Enable the DMA controller including interrupts */

	/*

	 * Check if the DESC FIFO it not full. If its full, we need to wait

	 * for at least one entry to become free again

	/*

	 * The descriptor needs to get copied into the descriptor FIFO

	 * of the DMA controller. The descriptor will get flushed to the

	 * FIFO, once the last word (control word) is written. Since we

	 * are not 100% sure that memcpy() writes all word in the "correct"

	 * oder (address from low to high) on all architectures, we make

	 * sure this control word is written last by single coding it and

	 * adding some write-barriers here.

 Write control word last to flush this descriptor into the FIFO */

/**

 * msgdma_copy_desc_to_fifo - copy descriptor(s) into controller FIFO

 * @mdev: Pointer to the Altera mSGDMA device structure

 * @desc: Transaction descriptor pointer

/**

 * msgdma_start_transfer - Initiate the new transfer

 * @mdev: Pointer to the Altera mSGDMA device structure

/**

 * msgdma_issue_pending - Issue pending transactions

 * @chan: DMA channel pointer

/**

 * msgdma_chan_desc_cleanup - Cleanup the completed descriptors

 * @mdev: Pointer to the Altera mSGDMA device structure

 Run any dependencies, then free the descriptor */

/**

 * msgdma_complete_descriptor - Mark the active descriptor as complete

 * @mdev: Pointer to the Altera mSGDMA device structure

/**

 * msgdma_free_descriptors - Free channel descriptors

 * @mdev: Pointer to the Altera mSGDMA device structure

/**

 * msgdma_free_chan_resources - Free channel resources

 * @dchan: DMA channel pointer

/**

 * msgdma_alloc_chan_resources - Allocate channel resources

 * @dchan: DMA channel

 *

 * Return: Number of descriptors on success and failure value on error

/**

 * msgdma_tasklet - Schedule completion tasklet

 * @t: Pointer to the Altera sSGDMA channel structure

 Read number of responses that are available */

		/*

		 * Read both longwords to purge this response from the FIFO

		 * On Avalon-MM implementations, size and status do not

		 * have any real values, like transferred bytes or error

		 * bits. So we need to just drop these values.

/**

 * msgdma_irq_handler - Altera mSGDMA Interrupt handler

 * @irq: IRQ number

 * @data: Pointer to the Altera mSGDMA device structure

 *

 * Return: IRQ_HANDLED/IRQ_NONE

 Start next transfer if the DMA controller is idle */

 Clear interrupt in mSGDMA controller */

/**

 * msgdma_chan_remove - Channel remove function

 * @mdev: Pointer to the Altera mSGDMA device structure

/**

 * msgdma_probe - Driver probe function

 * @pdev: Pointer to the platform_device structure

 *

 * Return: '0' on success and failure value on error

 Map CSR space */

 Map (extended) descriptor space */

 Map response space */

 Get interrupt nr from platform data */

 Set DMA capabilities */

 Init DMA link list */

 Set base routines */

 Set DMA mask to 64 bits */

/**

 * msgdma_dma_remove - Driver remove function

 * @pdev: Pointer to the platform_device structure

 *

 * Return: Always '0'

 SPDX-License-Identifier: GPL-2.0



 Copyright (C) 2018 Socionext Inc.

   Author: Masahiro Yamada <yamada.masahiro@socionext.com>

 registers common for all channels */

 issue DMA start/abort */

 1: abort, 0: start */

 per-channel registers */

 current hw status (RO) */

 latched STAT (WOC) */

 IRQ enable mask */

 REQ & EN (RO) */

 mode of source */

 mode of destination */

 source address */

 destination address */

 transfer bytes */

 mc->vc.lock must be held by caller */

 mc->vc.lock must be held by caller */

 write 1 to clear */

 mc->vc.lock must be held by caller */

 mc->vc.lock must be held by caller */

 write 1 to clear */

	/*

	 * Abort should be accepted soon. We poll the bit here instead of

	 * waiting for the interrupt.

	/*

	 * Some channels share a single interrupt line. If the IRQ status is 0,

	 * this is probably triggered by a different channel.

 write 1 to clear */

	/*

	 * UNIPHIER_MDMAC_CH_IRQ__DONE interrupt is asserted even when the DMA

	 * is aborted. To distinguish the normal completion and the abort,

	 * check mc->md. If it is NULL, we are aborting.

 Return immediately if we do not need to compute the residue. */

 residue from the on-flight chunk */

 residue from the queued chunks */

	/*

	 * Before reaching here, almost all descriptors have been freed by the

	 * ->device_free_chan_resources() hook. However, each channel might

	 * be still holding one descriptor that was on-flight at that moment.

	 * Terminate it to make sure this hardware is no longer running. Then,

	 * free the channel resources once again to avoid memory leak.

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Virtual DMA channel support for DMAengine

 *

 * Copyright (C) 2012 Russell King

/**

 * vchan_tx_desc_free - free a reusable descriptor

 * @tx: the transfer

 *

 * This function frees a previously allocated reusable descriptor. The only

 * other way is to clear the DMA_CTRL_REUSE flag and submit one last time the

 * transfer.

 *

 * Returns 0 upon success

/*

 * This tasklet handles the completion of a DMA descriptor by

 * calling its callback and freeing it.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * S3C24XX DMA handling

 *

 * Copyright (c) 2013 Heiko Stuebner <heiko@sntech.de>

 *

 * based on amba-pl08x.c

 *

 * Copyright (c) 2006 ARM Ltd.

 * Copyright (c) 2010 ST-Ericsson SA

 *

 * Author: Peter Pearse <peter.pearse@arm.com>

 * Author: Linus Walleij <linus.walleij@stericsson.com>

 *

 * The DMA controllers in S3C24XX SoCs have a varying number of DMA signals

 * that can be routed to any of the 4 to 8 hardware-channels.

 *

 * Therefore on these DMA controllers the number of channels

 * and the number of incoming DMA signals are two totally different things.

 * It is usually not possible to theoretically handle all physical signals,

 * so a multiplexing scheme with possible denial of use is necessary.

 *

 * Open items:

 * - bursts

/*

 * S3C2410, S3C2440 and S3C2442 SoCs cannot select any physical channel

 * for a DMA source. Instead only specific channels are valid.

 * All of these SoCs have 4 physical channels and the number of request

 * source bits is 3. Additionally we also need 1 bit to mark the channel

 * as valid.

 * Therefore we separate the chansel element of the channel data into 4

 * parts of 4 bits each, to hold the information if the channel is valid

 * and the hw request source to use.

 *

 * Example:

 * SDI is valid on channels 0, 2 and 3 - with varying hw request sources.

 * For it the chansel field would look like

 *

 * ((BIT(3) | 1) << 3 * 4) | // channel 3, with request source 1

 * ((BIT(3) | 2) << 2 * 4) | // channel 2, with request source 2

 * ((BIT(3) | 2) << 0 * 4)   // channel 0, with request source 2

/*

 * struct soc_data - vendor-specific config parameters for individual SoCs

 * @stride: spacing between the registers of each channel

 * @has_reqsel: does the controller use the newer requestselection mechanism

 * @has_clocks: are controllable dma-clocks present

/*

 * enum s3c24xx_dma_chan_state - holds the virtual channel states

 * @S3C24XX_DMA_CHAN_IDLE: the channel is idle

 * @S3C24XX_DMA_CHAN_RUNNING: the channel has allocated a physical transport

 * channel and is running a transfer on it

 * @S3C24XX_DMA_CHAN_WAITING: the channel is waiting for a physical transport

 * channel to become available (only pertains to memcpy channels)

/*

 * struct s3c24xx_sg - structure containing data per sg

 * @src_addr: src address of sg

 * @dst_addr: dst address of sg

 * @len: transfer len in bytes

 * @node: node for txd's dsg_list

/*

 * struct s3c24xx_txd - wrapper for struct dma_async_tx_descriptor

 * @vd: virtual DMA descriptor

 * @dsg_list: list of children sg's

 * @at: sg currently being transfered

 * @width: transfer width

 * @disrcc: value for source control register

 * @didstc: value for destination control register

 * @dcon: base value for dcon register

 * @cyclic: indicate cyclic transfer

/*

 * struct s3c24xx_dma_phy - holder for the physical channels

 * @id: physical index to this channel

 * @valid: does the channel have all required elements

 * @base: virtual memory base (remapped) for the this channel

 * @irq: interrupt for this channel

 * @clk: clock for this channel

 * @lock: a lock to use when altering an instance of this struct

 * @serving: virtual channel currently being served by this physicalchannel

 * @host: a pointer to the host (internal use)

/*

 * struct s3c24xx_dma_chan - this structure wraps a DMA ENGINE channel

 * @id: the id of the channel

 * @name: name of the channel

 * @vc: wrappped virtual channel

 * @phy: the physical channel utilized by this channel, if there is one

 * @runtime_addr: address for RX/TX according to the runtime config

 * @at: active transaction on this channel

 * @lock: a lock for this channel data

 * @host: a pointer to the host (internal use)

 * @state: whether the channel is idle, running etc

 * @slave: whether this channel is a device (slave) or for memcpy

/*

 * struct s3c24xx_dma_engine - the local state holder for the S3C24XX

 * @pdev: the corresponding platform device

 * @pdata: platform data passed in from the platform/machine

 * @base: virtual memory base (remapped)

 * @slave: slave engine for this instance

 * @memcpy: memcpy engine for this instance

 * @phy_chans: array of data for the physical channels

/*

 * Physical channel handling

/*

 * Check whether a certain channel is busy or not.

 every phy is valid for memcopy channels */

 On newer variants all phys can be used for all virtual channels */

/*

 * Allocate a physical channel for a virtual channel

 *

 * Try to locate a physical channel to be used for this transfer. If all

 * are taken return NULL and the requester will have to cope by using

 * some fallback PIO mode or retrying later.

 No physical channel available, cope with it */

 start the phy clock */

/*

 * Mark the physical channel as free.

 *

 * This drops the link between the physical and virtual channel.

/*

 * Stops the channel by writing the stop bit.

 * This should not be used for an on-going transfer, but as a method of

 * shutting down a channel (eg, when it's no longer used) or terminating a

 * transfer.

/*

 * Virtual channel handling

 Reject definitely invalid configurations */

/*

 * Transfer handling

 transfer-size and -count from len and width */

 trigger the dma operation for memcpy transfers */

/*

 * Set the initial DMA register values and start first sg.

 Wait for channel inactive */

 point to the first element of the sg list */

/*

 * Try to allocate a physical channel.  When successful, assign it to

 * this virtual channel, and initiate the next descriptor.  The

 * virtual channel lock must be held at this point.

	/*

	 * We do this without taking the lock; we're really only concerned

	 * about whether this pointer is NULL or not, and we're guaranteed

	 * that this will only be called when it _already_ is non-NULL.

/*

 * Free a physical DMA channel, potentially reallocating it to another

 * virtual channel if we have any pending.

 Find a waiting virtual channel for the next transfer. */

 Ensure that the physical channel is stopped */

		/*

		 * Eww.  We know this isn't going to deadlock

		 * but lockdep probably doesn't.

 Re-check the state now that we have the lock */

 If the state changed, try to find another channel */

 No more jobs, so free up the physical channel */

	/*

	 * Interrupts happen to notify the completion of a transfer and the

	 * channel should have moved into its stop state already on its own.

	 * Therefore interrupts on channels not bound to a virtual channel

	 * should never happen. Nevertheless send a terminate command to the

	 * channel if the unlikely case happens.

 when more sg's are in this txd, start the next one */

			/*

			 * And start the next descriptor (if any),

			 * otherwise free this channel.

 Cyclic: reset at beginning */

/*

 * The DMA ENGINE API

 Mark physical channel as free */

 Dequeue current job */

 Dequeue jobs not yet fired as well */

 Ensure all queued descriptors are freed */

	/*

	 * There's no point calculating the residue if there's

	 * no txstate to store the value.

 On the issued list, so hasn't been processed yet */

		/*

		 * Currently running, so sum over the pending sg's and

		 * the currently active one.

	/*

	 * This cookie not complete yet

	 * Get number of bytes left in the active transactions and queue

 Whether waiting or running, we're in progress */

/*

 * Initialize a descriptor to be used by memcpy submit

	/*

	 * Determine a suitable transfer width.

	 * The DMA controller cannot fetch/store information which is not

	 * naturally aligned on the bus, i.e., a 4 byte fetch must start at

	 * an address divisible by 4 - more generally addr % width must be 0.

	/*

	 * Always assume our peripheral desintation is a fixed

	 * address in memory.

	/*

	 * Individual dma operations are requested by the slave,

	 * so serve only single atomic operations (S3C24XX_DCON_SERV_SINGLE).

 Check last period length */

 DMA_DEV_TO_MEM */

	/*

	 * Always assume our peripheral desintation is a fixed

	 * address in memory.

	/*

	 * Individual dma operations are requested by the slave,

	 * so serve only single atomic operations (S3C24XX_DCON_SERV_SINGLE).

 DMA_DEV_TO_MEM */

/*

 * Slave transactions callback to the slave device to allow

 * synchronization of slave DMA signals with the DMAC enable

/*

 * Bringup and teardown

/*

 * Initialise the DMAC memcpy/slave channels.

 * Make a local wrapper to hold required data

	/*

	 * Register as many many memcpy as we have physical channels,

	 * we won't always be able to use all but the code will have

	 * to cope with that situation.

 s3c2410, s3c2440 and s3c2442 have a 0x40 stride without separate clocks */

 s3c2412 and s3c2413 have a 0x40 stride and dmareqsel mechanism */

 s3c2443 and following have a 0x100 stride and dmareqsel mechanism */

 Basic sanity check */

 acquire irqs and clocks for all physical channels */

 Initialize memcpy engine */

 Initialize slave engine for SoC internal dedicated peripherals */

 Register as many memcpy channels as there are physical channels */

 Register slave channels */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ADMA driver for Nvidia's Tegra210 ADMA controller.

 *

 * Copyright (c) 2016, NVIDIA CORPORATION.  All rights reserved.

/*

 * struct tegra_adma_chip_data - Tegra chip specific data

 * @adma_get_burst_config: Function callback used to set DMA burst size.

 * @global_reg_offset: Register offset of DMA global register.

 * @global_int_clear: Register offset of DMA global interrupt clear.

 * @ch_req_tx_shift: Register offset for AHUB transmit channel select.

 * @ch_req_rx_shift: Register offset for AHUB receive channel select.

 * @ch_base_offset: Register offset of DMA channel registers.

 * @ch_fifo_ctrl: Default value for channel FIFO CTRL register.

 * @ch_req_mask: Mask for Tx or Rx channel select.

 * @ch_req_max: Maximum number of Tx or Rx channels available.

 * @ch_reg_size: Size of DMA channel register space.

 * @nr_channels: Number of DMA channels available.

 * @ch_fifo_size_mask: Mask for FIFO size field.

 * @sreq_index_offset: Slave channel index offset.

 * @has_outstanding_reqs: If DMA channel can have outstanding requests.

/*

 * struct tegra_adma_chan_regs - Tegra ADMA channel registers

/*

 * struct tegra_adma_desc - Tegra ADMA descriptor to manage transfer requests.

/*

 * struct tegra_adma_chan - Tegra ADMA channel information

 Slave channel configuration info */

 Transfer count and position info */

/*

 * struct tegra_adma - Tegra ADMA controller information

 Used to store global command register state when suspending */

 Last member of the structure */

 Clear any interrupts */

 Assert soft reset */

 Wait for reset to clear */

 Enable global ADMA registers */

 Disable ADMA */

 Clear interrupt status */

 Start ADMA */

	/*

	 * Handle wrap around of buffer count register

	/*

	 * 'sreq_index' represents the current ADMAIF channel number and as per

	 * HW recommendation its FIFO size should match with the corresponding

	 * ADMA channel.

	 *

	 * ADMA FIFO size is set as per below (based on default ADMAIF channel

	 * FIFO sizes):

	 *    fifo_size = 0x2 (sreq_index > sreq_index_offset)

	 *    fifo_size = 0x3 (sreq_index <= sreq_index_offset)

	 *

 skip if channel is not active */

 skip if channel was not active earlier */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Driver for the Atmel Extensible DMA Controller (aka XDMAC on AT91 systems)

 *

 * Copyright (C) 2014 Atmel Corporation

 *

 * Author: Ludovic Desroches <ludovic.desroches@atmel.com>

 Global registers */

 Global Type Register */

 Number of Channels Minus One */

 Number of Bytes */

 Number of Peripheral Requests Minus One */

 Global Configuration Register */

 Global Weighted Arbiter Configuration Register */

 Global Interrupt Enable Register */

 Global Interrupt Disable Register */

 Global Interrupt Mask Register */

 Global Interrupt Status Register */

 Global Channel Enable Register */

 Global Channel Disable Register */

 Global Channel Status Register */

 XDMAC Version Register */

 Channel relative registers offsets */

 Channel Interrupt Enable Register */

 End of Block Interrupt Enable Bit */

 End of Linked List Interrupt Enable Bit */

 End of Disable Interrupt Enable Bit */

 End of Flush Interrupt Enable Bit */

 Read Bus Error Interrupt Enable Bit */

 Write Bus Error Interrupt Enable Bit */

 Request Overflow Interrupt Enable Bit */

 Channel Interrupt Disable Register */

 End of Block Interrupt Disable Bit */

 End of Linked List Interrupt Disable Bit */

 End of Disable Interrupt Disable Bit */

 End of Flush Interrupt Disable Bit */

 Read Bus Error Interrupt Disable Bit */

 Write Bus Error Interrupt Disable Bit */

 Request Overflow Interrupt Disable Bit */

 Channel Interrupt Mask Register */

 End of Block Interrupt Mask Bit */

 End of Linked List Interrupt Mask Bit */

 End of Disable Interrupt Mask Bit */

 End of Flush Interrupt Mask Bit */

 Read Bus Error Interrupt Mask Bit */

 Write Bus Error Interrupt Mask Bit */

 Request Overflow Interrupt Mask Bit */

 Channel Interrupt Status Register */

 End of Block Interrupt Status Bit */

 End of Linked List Interrupt Status Bit */

 End of Disable Interrupt Status Bit */

 End of Flush Interrupt Status Bit */

 Read Bus Error Interrupt Status Bit */

 Write Bus Error Interrupt Status Bit */

 Request Overflow Interrupt Status Bit */

 Channel Source Address Register */

 Channel Destination Address Register */

 Channel Next Descriptor Address Register */

 Channel x Next Descriptor Interface */

 Channel x Next Descriptor Address */

 Channel Next Descriptor Control Register */

 Channel x Next Descriptor Enable */

 Channel x Next Descriptor Source Update */

 Channel x Next Descriptor Destination Update */

 Channel x Next Descriptor View 0 */

 Channel x Next Descriptor View 1 */

 Channel x Next Descriptor View 2 */

 Channel x Next Descriptor View 3 */

 Channel Microblock Control Register */

 Channel Block Control Register */

 Channel Configuration Register */

 Channel Transfer Type */

 Memory to Memory Transfer */

 Peripheral to Memory or Memory to Peripheral Transfer */

 Channel Synchronization */

 Channel Protection */

 Channel Software Request Trigger */

 Channel Fill Block of memory */

 Channel Chunk Size */

 Channel Data Width */

 Channel Source Interface Identifier */

 Channel Destination Interface Identifier */

 Channel Source Addressing Mode */

 Channel Source Addressing Mode */

 Channel Initialization Terminated (read only) */

 Read in Progress (read only) */

 Write in Progress (read only) */

 Channel Peripheral Identifier */

 Channel Data Stride Memory Set Pattern */

 Channel Source Microblock Stride */

 Channel Destination Microblock Stride */

 Microblock control members */

 Maximum Microblock Length */

 Next Descriptor Enable */

 Next Descriptor Source Update */

 Next Descriptor Destination Update */

 Next Descriptor View 0 */

 Next Descriptor View 1 */

 Next Descriptor View 2 */

 Next Descriptor View 3 */

 16 data */

 64 bits */

 Global Channel Read Suspend Register */

 Global Write Suspend Register */

 Global Channel Read Write Suspend Register */

 Global Channel Read Write Resume Register */

 Global Channel Software Request Register */

 Global channel Software Request Status Register */

 Global Channel Software Flush Request Register */

 Channel reg base */

 Source/Destination Interface must be specified or not */

 AXI queue priority configuration supported */

 ----- Channels ----- */

 Channel Mask */

 Channel Configuration Register */

 Peripheral ID */

 Peripheral Interface */

 Memory Interface */

 ----- Controller ----- */

 ----- Descriptors ----- */

 Linked List Descriptor */

 Next Descriptor Member */

 Microblock Control Member */

 Source Address Member */

 Destination Address Member */

 Configuration Register */

 Block Control Register */

 Data Stride Register */

 Source Microblock Stride Register */

 Destination Microblock Stride Register */

 64-bit alignment needed to update CNDA and CUBC registers in an atomic way. */

 Following members are only used by the first descriptor */

 Wait that all chans are disabled. */

 Call with lock hold. */

 Set transfer as active to not try to start it again. */

 Tell xdmac where to get the first descriptor. */

	/*

	 * When doing non cyclic transfer we need to use the next

	 * descriptor view 2 since some fields of the configuration register

	 * depend on transfer size and src/dest addresses.

	/*

	 * Even if the register will be updated from the configuration in the

	 * descriptor when using view 2 or higher, the PROT bit won't be set

	 * properly. This bit can be modified only by using the channel

	 * configuration register.

	/*

	 * Request Overflow Error is only for peripheral synchronized transfers

	/*

	 * There is no end of list when doing cyclic dma, we need to get

	 * an interrupt after each periods.

 Call must be protected by lock. */

/*

 * Only check that maxburst and addr width values are supported by the

 * the controller but not that the configuration is good to perform the

 * transfer since we don't know the direction at this stage.

 Protect dma_sconfig field that can be modified by set_slave_conf. */

 Prepare descriptors. */

 Linked list descriptor setup. */

 next descriptor view */

 next descriptor dst parameter update */

 next descriptor src parameter update */

 microblock length */

 Chain lld. */

 Chain lld. */

	/*

	 * Check address alignment to select the greater data width we

	 * can use.

	 *

	 * Some XDMAC implementations don't provide dword transfer, in

	 * this case selecting dword has the same behavior as

	 * selecting word transfers.

	/*

	 * WARNING: The channel configuration is set here since there is no

	 * dmaengine_slave_config call in this case. Moreover we don't know the

	 * direction, it involves we can't dynamically set the source and dest

	 * interface so we have to use the same one. Only interface 0 allows EBI

	 * access. Hopefully we can access DDR through both ports (at least on

	 * SAMA5D4x), so we can use the same interface for source and dest,

	 * that solves the fact we don't know the direction.

	 * ERRATA: Even if useless for memory transfers, the PERID has to not

	 * match the one of another channel. If not, it could lead to spurious

	 * flag status.

	 * For SAMA7G5x case, the SIF and DIF fields are no longer used.

	 * Thus, no need to have the SIF/DIF interfaces here.

	 * For SAMA5D4x and SAMA5D2x the SIF and DIF are already configured as

	 * zero.

 Chain lld. */

	/*

	 * TODO: Handle the case where we have to repeat a chain of

	 * descriptors...

 Length of the block is (BLEN+1) microblocks. */

	/*

	 * WARNING: We don't know the direction, it involves we can't

	 * dynamically set the source and dest interface so we have to use the

	 * same one. Only interface 0 allows EBI access. Hopefully we can

	 * access DDR through both ports (at least on SAMA5D4x), so we can use

	 * the same interface for source and dest, that solves the fact we

	 * don't know the direction.

	 * ERRATA: Even if useless for memory transfers, the PERID has to not

	 * match the one of another channel. If not, it could lead to spurious

	 * flag status.

	 * For SAMA7G5x case, the SIF and DIF fields are no longer used.

	 * Thus, no need to have the SIF/DIF interfaces here.

	 * For SAMA5D4x and SAMA5D2x the SIF and DIF are already configured as

	 * zero.

 Prepare descriptors. */

 Update src and dest addresses. */

 Check remaining length and change data width if needed. */

 Chain lld. */

	/*

	 * WARNING: The channel configuration is set here since there is no

	 * dmaengine_slave_config call in this case. Moreover we don't know the

	 * direction, it involves we can't dynamically set the source and dest

	 * interface so we have to use the same one. Only interface 0 allows EBI

	 * access. Hopefully we can access DDR through both ports (at least on

	 * SAMA5D4x), so we can use the same interface for source and dest,

	 * that solves the fact we don't know the direction.

	 * ERRATA: Even if useless for memory transfers, the PERID has to not

	 * match the one of another channel. If not, it could lead to spurious

	 * flag status.

	 * For SAMA7G5x case, the SIF and DIF fields are no longer used.

	 * Thus, no need to have the SIF/DIF interfaces here.

	 * For SAMA5D4x and SAMA5D2x the SIF and DIF are already configured as

	 * zero.

 Prepare descriptors. */

 Update our strides */

		/*

		 * The scatterlist API gives us only the address and

		 * length of each elements.

		 *

		 * Unfortunately, we don't have the stride, which we

		 * will need to compute.

		 *

		 * That make us end up in a situation like this one:

		 *    len    stride    len    stride    len

		 * +-------+        +-------+        +-------+

		 * |  N-2  |        |  N-1  |        |   N   |

		 * +-------+        +-------+        +-------+

		 *

		 * We need all these three elements (N-2, N-1 and N)

		 * to actually take the decision on whether we need to

		 * queue N-1 or reuse N-2.

		 *

		 * We will only consider N if it is the last element.

				/*

				 * Increment the block count of the

				 * N-2 descriptor

				/*

				 * Put back the N-1 descriptor in the

				 * free descriptor list

				/*

				 * Make our N-1 descriptor pointer

				 * point to the N-2 since they were

				 * actually merged.

			/*

			 * Rule out the case where we don't have

			 * pstride computed yet (our second sg

			 * element)

			 *

			 * We also want to catch the case where there

			 * would be a negative stride,

				/*

				 * Queue the N-1 descriptor after the

				 * N-2

				/*

				 * Add the N-1 descriptor to the list

				 * of the descriptors used for this

				 * transfer

		/*

		 * If we are the last element, just see if we have the

		 * same size than the previous element.

		 *

		 * If so, we can merge it with the previous descriptor

		 * since we don't care about the stride anymore.

			/*

			 * Increment the block count of the N-1

			 * descriptor

			/*

			 * Put back the N descriptor in the free

			 * descriptor list

 Update our descriptors */

 Update our scatter pointers */

	/*

	 * If the transfer has not been started yet, don't need to compute the

	 * residue, it's the transfer length.

	/*

	 * Flush FIFO: only relevant when the transfer is source peripheral

	 * synchronized. Flush is needed before reading CUBC because data in

	 * the FIFO are not reported by CUBC. Reporting a residue of the

	 * transfer length while we have data in FIFO can cause issue.

	 * Usecase: atmel USART has a timeout which means I have received

	 * characters but there is no more character received for a while. On

	 * timeout, it requests the residue. If the data are in the DMA FIFO,

	 * we will return a residue of the transfer length. It means no data

	 * received. If an application is waiting for these data, it will hang

	 * since we won't have another USART timeout without receiving new

	 * data.

	/*

	 * The easiest way to compute the residue should be to pause the DMA

	 * but doing this can lead to miss some data as some devices don't

	 * have FIFO.

	 * We need to read several registers because:

	 * - DMA is running therefore a descriptor change is possible while

	 * reading these registers

	 * - When the block transfer is done, the value of the CUBC register

	 * is set to its initial value until the fetch of the next descriptor.

	 * This value will corrupt the residue calculation so we have to skip

	 * it.

	 *

	 * INITD --------                    ------------

	 *              |____________________|

	 *       _______________________  _______________

	 * NDA       @desc2             \/   @desc3

	 *       _______________________/\_______________

	 *       __________  ___________  _______________

	 * CUBC       0    \/ MAX desc1 \/  MAX desc2

	 *       __________/\___________/\_______________

	 *

	 * Since descriptors are aligned on 64 bits, we can assume that

	 * the update of NDA and CUBC is atomic.

	 * Memory barriers are used to ensure the read order of the registers.

	 * A max number of retries is set because unlikely it could never ends.

	/*

	 * Flush FIFO: only relevant when the transfer is source peripheral

	 * synchronized. Another flush is needed here because CUBC is updated

	 * when the controller sends the data write command. It can lead to

	 * report data that are not written in the memory or the device. The

	 * FIFO flush ensures that data are really written.

	/*

	 * Remove size of all microblocks already transferred and the current

	 * one. Then add the remaining size to transfer of the current

	 * microblock.

 Call must be protected by lock. */

	/*

	 * Remove the transfer from the transfer list then move the transfer

	 * descriptors into the free descriptors list.

	/*

	 * If channel is enabled, do nothing, advance_work will be triggered

	 * after the interruption.

	/*

	 * The descriptor currently at the head of the active list is

	 * broken. Since we don't have any way to report errors, we'll

	 * just have to scream loudly and try to continue with other

	 * descriptors queued (if any).

 Channel must be disabled first as it's not done automatically */

 Print bad descriptor's details if needed */

 Then continue with usual descriptor management */

 We have to find which channel has generated the interrupt. */

 Cancel all pending transfers. */

 Not supported */

 Wait for transfer completion, except in cyclic case. */

 Clear pending interrupts. */

	/*

	 * Read number of xdmac channels, read helper function can't be used

	 * since atxdmac is not yet allocated and we need to know the number

	 * of channels to do the allocation.

 Do not use dev res to prevent races with tasklet */

	/*

	 * Without DMA_PRIVATE the driver is not able to allocate more than

	 * one channel, second allocation fails in private_candidate.

 Disable all chans and interrupts. */

 Init channels. */

 Clear pending interrupts. */

 sentinel */

 SPDX-License-Identifier: GPL-2.0+



 Actions Semi Owl SoCs DMA driver



 Copyright (c) 2014 Actions Semi Inc.

 Author: David Liu <liuwei@actions-semi.com>



 Copyright (c) 2018 Linaro Ltd.

 Author: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>

 Global DMA Controller Registers */

 Channel Registers */

 OWL_DMAX_MODE Bits */

 OWL_DMAX_LINKLIST_CTL Bits */

 OWL_DMAX_INT_CTL Bits */

 OWL_DMAX_INT_STATUS Bits */

 Pack shift and newshift in a single word */

 Frame count value is fixed as 1 */

/**

 * enum owl_dmadesc_offsets - Describe DMA descriptor, hardware link

 * list for dma transfer

 * @OWL_DMADESC_NEXT_LLI: physical address of the next link list

 * @OWL_DMADESC_SADDR: source physical address

 * @OWL_DMADESC_DADDR: destination physical address

 * @OWL_DMADESC_FLEN: frame length

 * @OWL_DMADESC_SRC_STRIDE: source stride

 * @OWL_DMADESC_DST_STRIDE: destination stride

 * @OWL_DMADESC_CTRLA: dma_mode and linklist ctrl config

 * @OWL_DMADESC_CTRLB: interrupt config

 * @OWL_DMADESC_CONST_NUM: data for constant fill

 * @OWL_DMADESC_SIZE: max size of this enum

/**

 * struct owl_dma_lli - Link list for dma transfer

 * @hw: hardware link list

 * @phys: physical address of hardware link list

 * @node: node for txd's lli_list

/**

 * struct owl_dma_txd - Wrapper for struct dma_async_tx_descriptor

 * @vd: virtual DMA descriptor

 * @lli_list: link list of lli nodes

 * @cyclic: flag to indicate cyclic transfers

/**

 * struct owl_dma_pchan - Holder for the physical channels

 * @id: physical index to this channel

 * @base: virtual memory base for the dma channel

 * @vchan: the virtual channel currently being served by this physical channel

/**

 * struct owl_dma_pchan - Wrapper for DMA ENGINE channel

 * @vc: wrappped virtual channel

 * @pchan: the physical channel utilized by this channel

 * @txd: active transaction on this channel

 * @cfg: slave configuration for this channel

 * @drq: physical DMA request ID for this channel

/**

 * struct owl_dma - Holder for the Owl DMA controller

 * @dma: dma engine for this instance

 * @base: virtual memory base for the DMA controller

 * @clk: clock for the DMA controller

 * @lock: a lock to use when change DMA controller global register

 * @lli_pool: a pool for the LLI descriptors

 * @irq: interrupt ID for the DMA controller

 * @nr_pchans: the number of physical channels

 * @pchans: array of data for the physical channels

 * @nr_vchans: the number of physical channels

 * @vchans: array of data for the physical channels

 * @devid: device id based on OWL SoC

	/*

	 * Irrespective of the SoC, ctrlb value starts filling from

	 * bit 18.

		/*

		 * Hardware only supports 32bit and 8bit buswidth. Since the

		 * default is 32bit, select 8bit only when requested.

		/*

		 * Hardware only supports 32bit and 8bit buswidth. Since the

		 * default is 32bit, select 8bit only when requested.

 One link list by default */

 Max frame length is 1MB */

		/*

		 * On S700, word starts from offset 0x1C is shared between

		 * frame count and ctrlb, where first 12 bits are for frame

		 * count and rest of 20 bits are for ctrlb.

		/*

		 * On S900, word starts from offset 0xC is shared between

		 * frame length (max frame length is 1MB) and frame count,

		 * where first 20 bits are for frame length and rest of

		 * 12 bits are for frame count.

 Wait for channel inactive */

 Clear IRQ status for this pchan */

 Start DMA transfer for this pchan */

 Ensure that the physical channel is stopped */

 Clear IRQ status for each pchan */

 Clear pending IRQ */

 Check missed pending IRQ */

 Dummy read to ensure OWL_DMA_IRQ_PD0 value is updated */

 Clear IRQ status for this pchan */

 Update global IRQ pending */

			/*

			 * Start the next descriptor (if any),

			 * otherwise free this channel.

 Reject definitely invalid configurations */

 Get remain count of current node in link list */

 Loop through the preceding nodes to get total remaining bytes */

 Start from the next active node */

 Process the transfer as frame by frame */

 close the cyclic list */

 Ensure all queued descriptors are freed */

 sentinel */ },

	/*

	 * Eventhough the DMA controller is capable of generating 4

	 * IRQ's for DMA priority feature, we only use 1 IRQ for

	 * simplification.

 Init physical channel */

 Init virtual channel */

 Create a pool of consistent memory blocks for hardware descriptors */

 Device-tree DMA controller registration */

 Mask all interrupts for this execution environment */

 Make sure we won't have any further interrupts */

 SPDX-License-Identifier: GPL-2.0+

/*

 * BCM2835 DMA engine support

 *

 * Author:      Florian Meier <florian.meier@koalo.de>

 *              Copyright 2013

 *

 * Based on

 *	OMAP DMAengine support by Russell King

 *

 *	BCM2708 DMA Driver

 *	Copyright (C) 2010 Broadcom

 *

 *	Raspberry Pi PCM I2S ALSA Driver

 *	Copyright (c) by Phil Poole 2013

 *

 *	MARVELL MMP Peripheral DMA Driver

 *	Copyright 2012 Marvell International Ltd.

/**

 * struct bcm2835_dmadev - BCM2835 DMA controller

 * @ddev: DMA device

 * @base: base address of register map

 * @zero_page: bus address of zero page (to detect transactions copying from

 *	zero page and avoid accessing memory if so)

 DMA CS Control and Status bits */

 activate the DMA */

 current CB has ended */

 interrupt status */

 DREQ state */

 Pause requested or not active */

 Is held by DREQ flow control */

#define BCM2835_DMA_WAITING_FOR_WRITES BIT(6) /* waiting for last

					       * AXI-write to ack

 AXI priority */

 panic priority */

 current value of TI.BCM2835_DMA_WAIT_RESP */

 disable debug pause signal */

 Stop current CB, go to next, WO */

 WO, self clearing */

 Transfer information bits - also bcm2835_cb.info field */

 2D-Mode */

 wait for AXI-write to be acked */

 128bit writes if set */

 enable DREQ for destination */

 ignore destination writes */

 128bit writes if set */

 enable SREQ for source */

 ignore source reads - read 0 */

 REQ source */

 add DMA-wait cycles */

 no 2 beat write bursts */

 debug register bits */

 shared registers for all dma channels */

 Valid only for channels 0 - 14, 15 has its own base address */

 Base address */

 the max dma length for different channels */

 lite and normal channels have different max frame length */

 how many frames of max_len size do we need to transfer len bytes */

 set the length taking lite-channel limitations into account */

 finished if we have no period_length */

	/*

	 * period_len means: that we need to generate

	 * transfers that are terminating at every

	 * multiple of period_len - this is typically

	 * used to set the interrupt flag in info

	 * which is required during cyclic transfers

 have we filled in period_length yet? */

 update number of bytes in this period so far */

 calculate the length that remains to reach period_length */

 reset total_length for next period */

 add extrainfo bits in info */

/**

 * bcm2835_dma_create_cb_chain - create a control block and fills data in

 *

 * @chan:           the @dma_chan for which we run this

 * @direction:      the direction in which we transfer

 * @cyclic:         it is a cyclic transfer

 * @info:           the default info bits to apply per controlblock

 * @frames:         number of controlblocks to allocate

 * @src:            the src address to assign (if the S_INC bit is set

 *                  in @info, then it gets incremented)

 * @dst:            the dst address to assign (if the D_INC bit is set

 *                  in @info, then it gets incremented)

 * @buf_len:        the full buffer length (may also be 0)

 * @period_len:     the period length when to apply @finalextrainfo

 *                  in addition to the last transfer

 *                  this will also break some control-blocks early

 * @finalextrainfo: additional bits in last controlblock

 *                  (or when period_len is reached in case of cyclic)

 * @gfp:            the GFP flag to use for allocation

 allocate and setup the descriptor. */

	/*

	 * Iterate over all frames, create a control block

	 * for each frame and link them together.

 fill in the control block */

 set up length in control_block if requested */

 calculate length honoring period_length */

 calculate new remaining length */

 link this the last controlblock */

 update src and dst and length */

 Length of total transfer */

 the last frame requires extra flags */

 detect a size missmatch */

	/*

	 * A zero control block address means the channel is idle.

	 * (The ACTIVE flag in the CS register is not a reliable indicator.)

 Write 0 to the active bit - Pause the DMA */

 Wait for any current AXI transfer to complete */

 Peripheral might be stuck and fail to signal AXI write responses */

 check the shared interrupt */

 check if the interrupt is enabled */

 if not set then we are not the reason for the irq */

	/*

	 * Clear the INT flag to receive further interrupts. Keep the channel

	 * active in case the descriptor is cyclic or in case the client has

	 * already terminated the descriptor and issued a new one. (May happen

	 * if this IRQ handler is threaded.) If the channel is finished, it

	 * will remain idle despite the ACTIVE flag being set.

 call the cyclic callback */

	/*

	 * Control blocks are 256 bit in length and must start at a 256 bit

	 * (32 byte) aligned address (BCM2835 ARM Peripherals, sec. 4.2.1.1).

 if src, dst or len is not given return with an error */

 calculate number of frames */

 allocate the CB chain - this also fills in the pointers */

 count frames in sg list */

 allocate the CB chain */

 fill in frames with scatterlist pointers */

 Grab configuration */

	/*

	 * warn if buf_len is not a multiple of period_len - this may leed

	 * to unexpected latencies for interrupts and thus audiable clicks

 Setup DREQ channel */

 non-lite channels can write zeroes w/o accessing memory */

 calculate number of frames */

 number of periods */

 number of frames per period */

	/*

	 * allocate the CB chain

	 * note that we need to use GFP_NOWAIT, as the ALSA i2s dmaengine

	 * implementation calls prep_dma_cyclic with interrupts disabled.

 wrap around into a loop */

 stop DMA activity */

 check in DEBUG register if this is a LITE channel */

 Set DREQ from param */

 Request DMA channel mask from device tree */

 get irqs for each channel that we support */

 skip masked out channels */

 get the named irq */

 legacy device tree case handling */

		/*

		 * in case of channel >= 11

		 * use the 11th interrupt and that is shared

 get irqs for each channel */

 skip channels without irq */

 check if there are other channels that also use this irq */

 initialize the channel */

 Device-tree DMA controller registration */

/*

 * Copyright (C) 2017 Broadcom

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License as

 * published by the Free Software Foundation version 2.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

/*

 * Broadcom SBA RAID Driver

 *

 * The Broadcom stream buffer accelerator (SBA) provides offloading

 * capabilities for RAID operations. The SBA offload engine is accessible

 * via Broadcom SoC specific ring manager. Two or more offload engines

 * can share same Broadcom SoC specific ring manager due to this Broadcom

 * SoC specific ring manager driver is implemented as a mailbox controller

 * driver and offload engine drivers are implemented as mallbox clients.

 *

 * Typically, Broadcom SoC specific ring manager will implement larger

 * number of hardware rings over one or more SBA hardware devices. By

 * design, the internal buffer size of SBA hardware device is limited

 * but all offload operations supported by SBA can be broken down into

 * multiple small size requests and executed parallely on multiple SBA

 * hardware devices for achieving high through-put.

 *

 * The Broadcom SBA RAID driver does not require any register programming

 * except submitting request to SBA hardware device via mailbox channels.

 * This driver implements a DMA device with one DMA channel using a single

 * mailbox channel provided by Broadcom SoC specific ring manager driver.

 * For having more SBA DMA channels, we can create more SBA device nodes

 * in Broadcom SoC specific DTS based on number of hardware rings supported

 * by Broadcom SoC ring manager.

 ====== Driver macros and defines ===== */

 Driver helper macros */

 ===== Driver data structures ===== */

 Global state */

 Chained requests management */

 BRCM message data */

 SBA commands */

 Underlying device */

 DT configuration parameters */

 Derived configuration parameters */

 Maibox client and Mailbox channels */

 DMA device and DMA channel */

 DMA channel resources */

 DebugFS directory entries */

 ====== Command helper routines ===== */

 ====== General helper routines ===== */

		/*

		 * We have no more free requests so, we peek

		 * mailbox channels hoping few active requests

		 * would have completed which will create more

		 * room for new requests.

 Note: Must be called with sba->reqs_lock held */

 Note: Must be called with sba->reqs_lock held */

 Note: Must be called with sba->reqs_lock held */

 Note: Must be called with sba->reqs_lock held */

 Freeup all alloced request */

 Set all active requests as aborted */

	/*

	 * Note: We expect that aborted request will be eventually

	 * freed by sba_receive_message()

 Freeup all pending request */

 Send message for the request */

 Check error returned by mailbox controller */

 Signal txdone for mailbox channel */

 Note: Must be called with sba->reqs_lock held */

 Process few pending requests */

 Get the first pending request */

 Try to make request active */

 Send request to mailbox channel */

 Process only after all chained requests are received */

 Free all requests chained to first request */

 Free the first request */

 Process pending requests */

 ====== DMAENGINE callbacks ===== */

	/*

	 * Channel resources are pre-alloced so we just free-up

	 * whatever we can so that we can re-use pre-alloced

	 * channel resources next time.

 Cleanup all pending requests */

 Process pending requests */

 Assign cookie and mark all chained requests pending */

 Type-B command to load dummy data into buf0 */

 Type-A command to write buf0 to dummy location */

 Fillup brcm_message */

 Alloc new request */

	/*

	 * Force fence so that no requests are submitted

	 * until DMA callback for this request is invoked.

 Fillup request message */

 Init async_tx descriptor */

 Type-B command to load data into buf0 */

 Type-A command to write buf0 */

 Fillup brcm_message */

 Alloc new request */

 Fillup request message */

 Init async_tx descriptor */

 Create chained requests where each request is upto hw_buf_size */

 Type-B command to load data into buf0 */

 Type-B commands to xor data with buf0 and put it back in buf0 */

 Type-A command to write buf0 */

 Fillup brcm_message */

 Alloc new request */

 Fillup request message */

 Init async_tx descriptor */

 Sanity checks */

 Create chained requests where each request is upto hw_buf_size */

 Type-B command to load old P into buf0 */

 Type-B command to load old Q into buf1 */

 Type-A command to zero all buffers */

 Type-B commands for generate P onto buf0 and Q onto buf1 */

 Type-A command to write buf0 */

 Type-A command to write buf1 */

 Fillup brcm_message */

 Alloc new request */

 Fillup request messages */

 Init async_tx descriptor */

 Type-B command to load old P into buf0 */

		/*

		 * Type-B commands to xor data with buf0 and put it

		 * back in buf0

 Type-B command to load old P into buf0 */

 Type-A command to write buf0 */

 Type-A command to zero all buffers */

	/*

	 * Type-B command to generate initial Q from data

	 * and store output into buf0

 Multiple Type-A command to generate final Q */

		/*

		 * Type-A command to generate Q with buf0 and

		 * buf1 store result in buf0

		/*

		 * Type-B command to XOR previous output with

		 * buf0 and write it into buf0

 Type-A command to write buf0 */

 Fillup brcm_message */

 Alloc new request */

 Fillup request messages */

 Init async_tx descriptor */

 Sanity checks */

 Figure-out P and Q destination addresses */

 Create chained requests where each request is upto hw_buf_size */

 ====== Mailbox callbacks ===== */

 Error count if message has error */

 Process received request */

 ====== Debugfs callbacks ====== */

 Write stats in file */

 ====== Platform driver routines ===== */

 Initialize DMA channel cookie */

 Initialize DMA device capability mask */

	/*

	 * Set mailbox channel device as the base device of

	 * our dma_device because the actual memory accesses

	 * will be done by mailbox controller

 Set base prep routines */

 Set interrupt routine */

 Set memcpy routine */

 Set xor routine and capability */

 Set pq routine and capability */

 Initialize DMA device channel list */

 Register with Linux async DMA framework*/

 Allocate main SBA struct */

 Number of mailbox channels should be atleast 1 */

 Determine SBA version from DT compatible string */

 Derived Configuration parameters */

		/*

		 * We can support max_pq_srcs == max_pq_coefs because

		 * we are limited by number of SBA commands that we can

		 * fit in one message for underlying ring manager HW.

 Setup mailbox client */

 Request mailbox channel */

 Find-out underlying mailbox device */

 Prealloc channel resource */

 Check availability of debugfs */

 Create debugfs root entry */

 Create debugfs stats entry */

 Register DMA device with Linux async framework */

 Print device info */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) Freescale Semicondutor, Inc. 2007, 2008.

 * Copyright (C) Semihalf 2009

 * Copyright (C) Ilya Yanok, Emcraft Systems 2010

 * Copyright (C) Alexander Popov, Promcontroller 2014

 * Copyright (C) Mario Six, Guntermann & Drunck GmbH, 2016

 *

 * Written by Piotr Ziecik <kosmo@semihalf.com>. Hardware description

 * (defines, structures and comments) was taken from MPC5121 DMA driver

 * written by Hongjun Chen <hong-jun.chen@freescale.com>.

 *

 * Approved as OSADL project by a majority of OSADL members and funded

 * by OSADL membership fees in 2009;  for details see www.osadl.org.

/*

 * MPC512x and MPC8308 DMA driver. It supports memory to memory data transfers

 * (tested using dmatest module) and data transfers between memory and

 * peripheral I/O memory by means of slave scatter/gather with these

 * limitations:

 *  - chunked transfers (described by s/g lists with more than one item) are

 *     refused as long as proper support for scatter/gather is missing

 *  - transfers on MPC8308 always start from software as this SoC does not have

 *     external request lines for peripheral flow control

 *  - memory <-> I/O memory transfer chunks of sizes of 1, 2, 4, 16 (for

 *     MPC512x), and 32 bytes are supported, and, consequently, source

 *     addresses and destination addresses must be aligned accordingly;

 *     furthermore, for MPC512x SoCs, the transfer size must be aligned on

 *     (chunk size * maxburst)

 Number of DMA Transfer descriptors allocated per channel */

 Macro definitions */

/*

 * Maximum channel counts for individual hardware variants

 * and the maximum channel count over all supported controllers,

 * used for data structure size

 Arbitration mode of group and channel */

 Error codes */

 MPC5121 DMA engine registers */

 0x00 */

 DMA control register */

 DMA error status */

 0x08 */

 DMA enable request high(channels 63~32) */

 DMA enable request low(channels 31~0) */

 DMA enable error interrupt high(ch63~32) */

 DMA enable error interrupt low(ch31~0) */

 0x18 */

 DMA set enable request */

 DMA clear enable request */

 DMA set enable error interrupt */

 DMA clear enable error interrupt */

 0x1c */

 DMA clear interrupt request */

 DMA clear error */

 DMA set start bit */

 DMA clear DONE status bit */

 0x20 */

 DMA interrupt request high(ch63~32) */

 DMA interrupt request low(ch31~0) */

 DMA error high(ch63~32) */

 DMA error low(ch31~0) */

 0x30 */

 DMA hw request status high(ch63~32) */

 DMA hardware request status low(ch31~0) */

 DMA interrupt high select AXE(ch63~32) */

 (General purpose register on MPC8308) */

 DMA interrupt low select AXE(ch31~0) */

 0x40 ~ 0xff */

 Reserved */

 0x100 */

 DMA channels(0~63) priority */

 0x00 */

 Source address */

 Source address modulo */

 Source data transfer size */

 Destination address modulo */

 Destination data transfer size */

 Signed source address offset */

 0x08 */

 Inner "minor" byte count */

 Last source address adjustment */

 Destination address */

 0x14 */

	u32 citer_elink:1;	/* Enable channel-to-channel linking on

				 * minor loop complete

 Link channel for minor loop complete */

 Current "major" iteration count */

 Signed destination address offset */

 0x18 */

	u32 dlast_sga;		/* Last Destination address adjustment/scatter

				 * gather address

 0x1c */

	u32 biter_elink:1;	/* Enable channel-to-channel linking on major

				 * loop complete

 Beginning "major" iteration count */

 Bandwidth control */

 Link channel number */

 Channel done */

 Channel active */

	u32 major_elink:1;	/* Enable channel-to-channel linking on major

				 * loop complete

 Enable scatter/gather processing */

 Disable request */

	u32 int_half:1;		/* Enable an interrupt when major counter is

				 * half complete

	u32 int_maj:1;		/* Enable an interrupt when major iteration

				 * count completes

 Channel start */

 Settings for access to peripheral FIFO */

 Lock for this structure */

 Lock for error_status field in this structure */

 Convert struct dma_chan to struct mpc_dma_chan */

 Convert struct dma_chan to struct mpc_dma */

/*

 * Execute all queued DMA descriptors.

 *

 * Following requirements must be met while calling mpc_dma_execute():

 *	a) mchan->lock is acquired,

 *	b) mchan->active list is empty,

 *	c) mchan->queued list contains at least one entry.

		/*

		 * Grab either several mem-to-mem transfer descriptors

		 * or one peripheral transfer descriptor,

		 * don't mix mem-to-mem and peripheral transfer descriptors

		 * within the same 'active' list.

 Chain descriptors into one transaction */

 Send first descriptor in chain into hardware */

 MPC8308, no request lines, software initiated start */

 Peripherals involved, start by external request signal */

 Memory to memory transfer, software initiated start */

 Handle interrupt on one half of DMA controller (32 channels) */

 Check error status */

 Execute queued descriptors */

 Interrupt handler */

 Save error status register */

 Handle interrupt on each channel */

 Schedule tasklet */

 process completed descriptors */

 Get all completed descriptors */

 Execute callbacks and run dependencies */

 Free descriptors */

 DMA Tasklet */

 Print nice error report */

 Submit descriptor to hardware */

 Move descriptor to queue */

 If channel is idle, execute all queued descriptors */

 Update cookie */

 Alloc channel resources */

 Alloc DMA memory for Transfer Control Descriptors */

 Alloc descriptors for this channel */

 Return error only if no descriptors were allocated */

 Enable Error Interrupt */

 Free channel resources */

 Channel must be idle */

 Move data */

 Free DMA memory used by descriptors */

 Free descriptors */

 Disable Error Interrupt */

 Send all pending descriptor to hardware */

	/*

	 * We are posting descriptors to the hardware as soon as

	 * they are ready, so this function does nothing.

 Check request completion status */

 Prepare descriptor for memory to memory copy */

 Get free descriptor */

 try to free completed descriptors */

 Prepare Transfer Control Descriptor for this transaction */

 MPC8308 doesn't support 16 byte transfers */

 Place descriptor in prepared list */

 Currently there is no proper support for scatter/gather */

 Try to free completed descriptors */

 Prepare Transfer Control Descriptor for this transaction */

 No major loops for MPC8303 */

 len is too big */

 citer_linkch contains the high bits of iter */

 Place descriptor in prepared list */

 Put the descriptor back */

	/*

	 * Software constraints:

	 *  - only transfers between a peripheral device and memory are

	 *     supported

	 *  - transfer chunk sizes of 1, 2, 4, 16 (for MPC512x), and 32 bytes

	 *     are supported, and, consequently, source addresses and

	 *     destination addresses; must be aligned accordingly; furthermore,

	 *     for MPC512x SoCs, the transfer size must be aligned on (chunk

	 *     size * maxburst)

	 *  - during the transfer, the RAM address is incremented by the size

	 *     of transfer chunk

	 *  - the peripheral port's address is constant during the transfer.

 Apply defaults */

 Disable channel requests */

	/*

	 * Configure DMA Engine:

	 * - Dynamic clock,

	 * - Round-robin group arbitration,

	 * - Round-robin channel arbitration.

 MPC8308 has 16 channels and lacks some registers */

 enable snooping */

 Disable error interrupts */

 Clear interrupts status */

 Disable hardware DMA requests */

 Disable error interrupts */

 Clear interrupts status */

 Route interrupts to IPIC */

 Register DMA engine */

 Register with OF helpers for DMA lookups (nonfatal) */

 SPDX-License-Identifier: GPL-2.0+



 Copyright (c) 2013-2014 Freescale Semiconductor, Inc

 Copyright (c) 2017 Sysam, Angelo Dureghello  <angelo@sysam.it>

 terminate_all called before */

 Set up drvdata for ColdFire edma */

 Enable round robin arbitration */

 SPDX-License-Identifier: GPL-2.0



 Copyright (C) 2019 Linaro Ltd.

 Copyright (C) 2019 Socionext Inc.

 global */

 channel */

 mc->vc.lock must be held by caller */

 mc->vc.lock must be held by caller */

 mc->vc.lock must be held by caller */

 Ack and Disable irqs */

 disable the channel */

 Return immediately if we do not need to compute the residue. */

 residue from the on-flight chunk */

 residue from the queued chunks */

	/*

	 * Before reaching here, almost all descriptors have been freed by the

	 * ->device_free_chan_resources() hook. However, each channel might

	 * be still holding one descriptor that was on-flight at that moment.

	 * Terminate it to make sure this hardware is no longer running. Then,

	 * free the channel resources once again to avoid memory leak.

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Driver for STM32 DMA controller

 *

 * Inspired by dma-jz4740.c and tegra20-apb-dma.c

 *

 * Copyright (C) M'boumba Cedric Madianga 2015

 * Author: M'boumba Cedric Madianga <cedric.madianga@gmail.com>

 *         Pierre-Yves Mordret <pierre-yves.mordret@st.com>

 DMA Low Int Status Reg */

 DMA High Int Status Reg */

 DMA Low Int Flag Clear Reg */

 DMA High Int Flag Clear Reg */

 Transfer Complete Interrupt */

 Half Transfer Interrupt */

 Transfer Error Interrupt */

 Direct Mode Error Interrupt */

 FIFO Error Interrupt */

 DMA Stream x Configuration Register */

 x = 0..7 */

 Bufferable transfer for USART/UART */

 Target in double buffer */

 Double Buffer Mode */

 Peripheral inc offset size */

 Memory increment mode */

 Peripheral increment mode */

 Circular mode */

 Peripheral Flow Controller */

#define STM32_DMA_SCR_TCIE		BIT(4) /* Transfer Complete Int Enable

 Transfer Error Int Enable */

 Direct Mode Err Int Enable */

 Stream Enable */

 DMA Stream x number of data register */

 DMA stream peripheral address register */

 DMA stream x memory 0 address register */

 DMA stream x memory 1 address register */

 DMA stream x FIFO control register */

 FIFO error interrupt enable */

 Direct mode disable */

 DMA direction */

 DMA priority level */

 DMA FIFO threshold selection */

/*

 * Valid transfer starts from @0 to @0xFFFE leading to unaligned scatter

 * gather at boundary. Thus it's safer to round down this value on FIFO

 * size (16 Bytes)

 FIFO is 16 bytes */

 DMA Features */

/**

 * struct stm32_dma_cfg - STM32 DMA custom configuration

 * @channel_id: channel ID

 * @request_line: DMA request

 * @stream_config: 32bit mask specifying the DMA channel configuration

 * @features: 32bit mask specifying the DMA Feature list

			/*

			 * If number of beats fit in several whole bursts

			 * this configuration is allowed.

 If FIFO direct mode, burst is not possible */

	/*

	 * Buffer or period length has to be aligned on FIFO depth.

	 * Otherwise bytes may be stuck within FIFO at buffer or period

	 * length.

 Using direct mode */

 Using FIFO mode */

	/*

	 * Read "flags" from DMA_xISR register corresponding to the selected

	 * DMA channel at the correct bit offset inside that register.

	 *

	 * If (ch % 4) is 2 or 3, left shift the mask by 16 bits.

	 * If (ch % 4) is 1 or 3, additionally left shift the mask by 6 bits.

	/*

	 * Write "flags" to the DMA_xIFCR register corresponding to the selected

	 * DMA channel at the correct bit offset inside that register.

	 *

	 * If (ch % 4) is 2 or 3, left shift the mask by 16 bits.

	 * If (ch % 4) is 1 or 3, additionally left shift the mask by 6 bits.

 Disable interrupts */

 Disable DMA */

 Clear interrupt status if it is there */

 Clear interrupt status if it is there */

 Start DMA */

 Set device data size */

 Set device burst size */

 Set memory data size */

		/*

		 * Set memory burst size - burst not possible if address is not aligned on

		 * the address boundary equal to the size of the transfer

 Set FIFO threshold */

 Set peripheral address */

 Set device data size */

 Set device burst size */

 Set memory data size */

		/*

		 * Set memory burst size - burst not possible if address is not aligned on

		 * the address boundary equal to the size of the transfer

 Set FIFO threshold */

 Set peripheral address */

 Set DMA control register */

 Set peripheral flow controller */

	/*

	 * We allow to take more number of requests till DMA is

	 * not started. The driver will loop over all requests.

	 * Once DMA is started then new requests can be queued only after

	 * terminating the DMA.

  Enable Circular mode or double buffer mode */

 Clear periph ctrl if client set it */

 Compute best burst size */

/**

 * stm32_dma_is_current_sg - check that expected sg_req is currently transferred

 * @chan: dma channel

 *

 * This function called when IRQ are disable, checks that the hardware has not

 * switched on the next transfer in double buffer mode. The test is done by

 * comparing the next_sg memory address with the hardware related register

 * (based on CT bit value).

 *

 * Returns true if expected current transfer is still running or double

 * buffer mode is not activated.

	/*

	 * Calculate the residue means compute the descriptors

	 * information:

	 * - the sg_req currently transferred

	 * - the Hardware remaining position in this sg (NDTR bits field).

	 *

	 * A race condition may occur if DMA is running in cyclic or double

	 * buffer mode, since the DMA register are automatically reloaded at end

	 * of period transfer. The hardware may have switched to the next

	 * transfer (CT bit updated) just before the position (SxNDTR reg) is

	 * read.

	 * In this case the SxNDTR reg could (or not) correspond to the new

	 * transfer position, and not the expected one.

	 * The strategy implemented in the stm32 driver is to:

	 *  - read the SxNDTR register

	 *  - crosscheck that hardware is still in current transfer.

	 * In case of switch, we can assume that the DMA is at the beginning of

	 * the next transfer. So we approximate the residue in consequence, by

	 * pointing on the beginning of next transfer.

	 *

	 * This race condition doesn't apply for none cyclic mode, as double

	 * buffer is not used. In such situation registers are updated by the

	 * software.

	/*

	 * In cyclic mode, for the last period, residue = remaining bytes

	 * from NDTR,

	 * else for all other periods in cyclic mode, and in sg mode,

	 * residue = remaining bytes from NDTR + remaining

	 * periods/sg to be transferred

 Enable Interrupts  */

 sentinel */ },

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2015-2016 Marvell International Ltd.



 DMA Engine Registers */

 Same flags as MV_XOR_V2_DMA_DESQ_ARATTR_OFF */

 XOR Global registers */

/*

 * Descriptors queue size. With 32 bytes descriptors, up to 2^14

 * descriptors are allowed, with 128 bytes descriptors, up to 2^12

 * descriptors are allowed. This driver uses 128 bytes descriptors,

 * but experimentation has shown that a set of 1024 descriptors is

 * sufficient to reach a good level of performance.

/*

 * Threshold values for descriptors and timeout, determined by

 * experimentation as giving a good level of performance.

/**

 * struct mv_xor_v2_descriptor - DMA HW descriptor

 * @desc_id: used by S/W and is not affected by H/W.

 * @flags: error and status flags

 * @crc32_result: CRC32 calculation result

 * @desc_ctrl: operation mode and control flags

 * @buff_size: amount of bytes to be processed

 * @fill_pattern_src_addr: Fill-Pattern or Source-Address and

 * AW-Attributes

 * @data_buff_addr: Source (and might be RAID6 destination)

 * addresses of data buffers in RAID5 and RAID6

 * @reserved: reserved

 Definitions for desc_ctrl */

 Idle operation */

 Pure-DMA operation */

 Mem-Fill operation */

 Mem-Init operation */

 Mem-Compare operation */

 CRC32 calculation */

 RAID5 (XOR) operation */

 RAID6 P&Q-generation */

 RAID6 Recovery */

/**

 * struct mv_xor_v2_device - implements a xor device

 * @lock: lock for the engine

 * @clk: reference to the 'core' clock

 * @reg_clk: reference to the 'reg' clock

 * @dma_base: memory mapped DMA register base

 * @glob_base: memory mapped global register base

 * @irq_tasklet: tasklet used for IRQ handling call-backs

 * @free_sw_desc: linked list of free SW descriptors

 * @dmadev: dma device

 * @dmachan: dma channel

 * @hw_desq: HW descriptors queue

 * @hw_desq_virt: virtual address of DESCQ

 * @sw_desq: SW descriptors queue

 * @desc_size: HW descriptor size

 * @npendings: number of pending descriptors (for which tx_submit has

 * @hw_queue_idx: HW queue index

 * @msi_desc: local interrupt descriptor information

 * been called, but not yet issue_pending)

/**

 * struct mv_xor_v2_sw_desc - implements a xor SW descriptor

 * @idx: descriptor index

 * @async_tx: support for the async_tx api

 * @hw_desc: assosiated HW descriptor

 * @free_list: node of the free SW descriprots list

/*

 * Fill the data buffers to a HW descriptor

	/*

	 * Fill the buffer's addresses to the descriptor.

	 *

	 * The format of the buffers address for 2 sequential buffers

	 * X and X + 1:

	 *

	 *  First word:  Buffer-DX-Address-Low[31:0]

	 *  Second word: Buffer-DX+1-Address-Low[31:0]

	 *  Third word:  DX+1-Buffer-Address-High[47:32] [31:16]

	 *		 DX-Buffer-Address-High[47:32] [15:0]

/*

 * notify the engine of new descriptors, and update the available index.

 write the number of new descriptors in the DESQ. */

/*

 * free HW descriptors

 write the number of new descriptors in the DESQ. */

/*

 * Set descriptor size

 * Return the HW descriptor size in bytes

/*

 * Set the IMSG threshold

 Configure threshold of number of descriptors, and enable timer */

 Configure Timer Threshold */

 No descriptors to process */

 schedule a tasklet to handle descriptors callbacks */

/*

 * submit a descriptor to the DMA engine

 assign coookie */

 copy the HW descriptor from the SW descriptor to the DESQ */

/*

 * Prepare a SW descriptor

 Lock the channel */

 schedule tasklet to free some descriptors */

 Release the channel */

/*

 * Prepare a HW descriptor for a memcpy operation

 set the HW descriptor */

 save the SW descriptor ID to restore when operation is done */

 Set the MEMCPY control word */

 Set source address */

 Set Destination address */

 Set buffers size */

 return the async tx descriptor */

/*

 * Prepare a HW descriptor for a XOR operation

 set the HW descriptor */

 save the SW descriptor ID to restore when operation is done */

 Set the XOR control word */

 Set the data buffers */

 Set Destination address */

 Set buffers size */

 return the async tx descriptor */

/*

 * Prepare a HW descriptor for interrupt operation.

 set the HW descriptor */

 save the SW descriptor ID to restore when operation is done */

 Set the INTERRUPT control word */

 return the async tx descriptor */

/*

 * push pending transactions to hardware

	/*

	 * update the engine with the number of descriptors to

	 * process

 get the next pending descriptor index */

 get the number of descriptors pending handle */

/*

 * handle the descriptors after HW process

 get the pending descriptors parameters */

 loop over free descriptors */

 get the SW descriptor related to the HW descriptor */

 call the callback */

			/*

			 * update the channel's completed cookie - no

			 * lock is required the IMSG threshold provide

			 * the locking

 Lock the channel */

 add the SW descriptor to the free descriptors list */

 Release the channel */

 increment the next descriptor */

 free the descriptores */

/*

 *	Set DMA Interrupt-message (IMSG) parameters

 write the DESQ size to the DMA engine */

 write the DESQ address to the DMA enngine*/

	/*

	 * This is a temporary solution, until we activate the

	 * SMMU. Set the attributes for reading & writing data buffers

	 * & descriptors to:

	 *

	 *  - OuterShareable - Snoops will be performed on CPU caches

	 *  - Enable cacheable - Bufferable, Modifiable, Other Allocate

	 *    and Allocate

	/* BW CTRL - set values to optimize the XOR performance:

	 *

	 *  - Set WrBurstLen & RdBurstLen - the unit will issue

	 *    maximum of 256B write/read transactions.

	 * -  Limit the number of outstanding write & read data

	 *    (OBB/IBB) requests to the maximal value.

 Disable the AXI timer feature */

 enable the DMA engine */

 Set this bit to disable to stop the XOR unit. */

	/*

	 * allocate coherent memory for hardware descriptors

	 * note: writecombine gives slightly better performance, but

	 * requires that we explicitly flush the writes

 alloc memory for the SW descriptors */

 init the free SW descriptors list */

 add all SW descriptors to the free list */

 set DMA capabilities */

 init dma link list */

 set base routines */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ACPI helpers for DMA request / controller

 *

 * Based on of-dma.c

 *

 * Copyright (C) 2013, Intel Corporation

 * Authors: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

 *	    Mika Westerberg <mika.westerberg@linux.intel.com>

/**

 * acpi_dma_parse_resource_group - match device and parse resource group

 * @grp:	CSRT resource group

 * @adev:	ACPI device to match with

 * @adma:	struct acpi_dma of the given DMA controller

 *

 * In order to match a device from DSDT table to the corresponding CSRT device

 * we use MMIO address and IRQ.

 *

 * Return:

 * 1 on success, 0 when no information is available, or appropriate errno value

 * on error.

 Consider initial zero values as resource not found */

 Match device by MMIO */

	/*

	 * acpi_gsi_to_irq() can't be used because some platforms do not save

	 * registered IRQs in the MP table. Instead we just try to register

	 * the GSI, which is the core part of the above mentioned function.

 Match device by Linux vIRQ */

 Check if the request line range is available */

 Set up DMA mask based on value from CSRT */

/**

 * acpi_dma_parse_csrt - parse CSRT to exctract additional DMA resources

 * @adev:	ACPI device to match with

 * @adma:	struct acpi_dma of the given DMA controller

 *

 * CSRT or Core System Resources Table is a proprietary ACPI table

 * introduced by Microsoft. This table can contain devices that are not in

 * the system DSDT table. In particular DMA controllers might be described

 * here.

 *

 * We are using this table to get the request line range of the specific DMA

 * controller to be used later.

/**

 * acpi_dma_controller_register - Register a DMA controller to ACPI DMA helpers

 * @dev:		struct device of DMA controller

 * @acpi_dma_xlate:	translation function which converts a dma specifier

 *			into a dma_chan structure

 * @data:		pointer to controller specific data to be used by

 *			translation function

 *

 * Allocated memory should be freed with appropriate acpi_dma_controller_free()

 * call.

 *

 * Return:

 * 0 on success or appropriate errno value on error.

 Check if the device was enumerated by ACPI */

 Now queue acpi_dma controller structure in list */

/**

 * acpi_dma_controller_free - Remove a DMA controller from ACPI DMA helpers list

 * @dev:	struct device of DMA controller

 *

 * Memory allocated by acpi_dma_controller_register() is freed here.

 *

 * Return:

 * 0 on success or appropriate errno value on error.

/**

 * devm_acpi_dma_controller_register - resource managed acpi_dma_controller_register()

 * @dev:		device that is registering this DMA controller

 * @acpi_dma_xlate:	translation function

 * @data:		pointer to controller specific data

 *

 * Managed acpi_dma_controller_register(). DMA controller registered by this

 * function are automatically freed on driver detach. See

 * acpi_dma_controller_register() for more information.

 *

 * Return:

 * 0 on success or appropriate errno value on error.

/**

 * devm_acpi_dma_controller_free - resource managed acpi_dma_controller_free()

 * @dev:	device that is unregistering as DMA controller

 *

 * Unregister a DMA controller registered with

 * devm_acpi_dma_controller_register(). Normally this function will not need to

 * be called and the resource management code will ensure that the resource is

 * freed.

/**

 * acpi_dma_update_dma_spec - prepare dma specifier to pass to translation function

 * @adma:	struct acpi_dma of DMA controller

 * @dma_spec:	dma specifier to update

 *

 * Accordingly to ACPI 5.0 Specification Table 6-170 "Fixed DMA Resource

 * Descriptor":

 *	DMA Request Line bits is a platform-relative number uniquely

 *	identifying the request line assigned. Request line-to-Controller

 *	mapping is done in a controller-specific OS driver.

 * That's why we can safely adjust slave_id when the appropriate controller is

 * found.

 *

 * Return:

 * 0, if no information is avaiable, -1 on mismatch, and 1 otherwise.

 Set link to the DMA controller device */

 Check if the request line range is available */

 Check if slave_id falls to the range */

	/*

	 * Here we adjust slave_id. It should be a relative number to the base

	 * request line.

/**

 * acpi_dma_parse_fixed_dma - Parse FixedDMA ACPI resources to a DMA specifier

 * @res:	struct acpi_resource to get FixedDMA resources from

 * @data:	pointer to a helper struct acpi_dma_parser_data

 Tell the ACPI core to skip this resource */

/**

 * acpi_dma_request_slave_chan_by_index - Get the DMA slave channel

 * @dev:	struct device to get DMA request from

 * @index:	index of FixedDMA descriptor for @dev

 *

 * Return:

 * Pointer to appropriate dma channel on success or an error pointer.

 Initial values for the request line and channel */

		/*

		 * We are not going to call translation function if slave_id

		 * doesn't fall to the request range.

		/*

		 * Try to get a channel only from the DMA controller that

		 * matches the slave_id. See acpi_dma_update_dma_spec()

		 * description for the details.

/**

 * acpi_dma_request_slave_chan_by_name - Get the DMA slave channel

 * @dev:	struct device to get DMA request from

 * @name:	represents corresponding FixedDMA descriptor for @dev

 *

 * In order to support both Device Tree and ACPI in a single driver we

 * translate the names "tx" and "rx" here based on the most common case where

 * the first FixedDMA descriptor is TX and second is RX.

 *

 * If the device has "dma-names" property the FixedDMA descriptor indices

 * are retrieved based on those. Otherwise the function falls back using

 * hardcoded indices.

 *

 * Return:

 * Pointer to appropriate dma channel on success or an error pointer.

/**

 * acpi_dma_simple_xlate - Simple ACPI DMA engine translation helper

 * @dma_spec: pointer to ACPI DMA specifier

 * @adma: pointer to ACPI DMA controller data

 *

 * A simple translation function for ACPI based devices. Passes &struct

 * dma_spec to the DMA controller driver provided filter function.

 *

 * Return:

 * Pointer to the channel if found or %NULL otherwise.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Ingenic JZ4780 DMA controller

 *

 * Copyright (c) 2015 Imagination Technologies

 * Author: Alex Smith <alex@alex-smith.me.uk>

 Global registers. */

 Per-channel registers. */

 macros for use with jz4780_dma_soc_data.flags */

/**

 * struct jz4780_dma_hwdesc - descriptor structure read by the DMA controller.

 * @dcm: value for the DCM (channel command) register

 * @dsa: source address

 * @dta: target address

 * @dtc: transfer count (number of blocks of the transfer size specified in DCM

 * to transfer) in the low 24 bits, offset of the next descriptor from the

 * descriptor base address in the upper 8 bits.

 Size of allocations for hardware descriptor blocks. */

	/*

	 * 8 byte transfer sizes unsupported so fall back on 4. If it's larger

	 * than the maximum, just limit it. It is perfectly safe to fall back

	 * in this way since we won't exceed the maximum burst size supported

	 * by the device, the only effect is reduced efficiency. This is better

	 * than refusing to perform the request at all.

	/*

	 * This calculates the maximum transfer size that can be used with the

	 * given address, length, width and maximum burst size. The address

	 * must be aligned to the transfer size, the total length must be

	 * divisible by the transfer size, and we must not use more than the

	 * maximum burst specified by the user.

 Automatically proceeed to the next descriptor. */

			/*

			 * The upper 8 bits of the DTC field in the descriptor

			 * must be set to (offset from descriptor base of next

			 * descriptor >> 4).

		/*

		 * Set the link bit to indicate that the controller should

		 * automatically proceed to the next descriptor. In

		 * jz4780_dma_begin(), this will be cleared if we need to issue

		 * an interrupt after each period.

		/*

		 * The upper 8 bits of the DTC field in the descriptor must be

		 * set to (offset from descriptor base of next descriptor >> 4).

		 * If this is the last descriptor, link it back to the first,

		 * i.e. leave offset set to 0, otherwise point to the next one.

			/*

			 * The DMA controller doesn't support triggering an

			 * interrupt after processing each descriptor, only

			 * after processing an entire terminated list of

			 * descriptors. For a cyclic DMA setup the list of

			 * descriptors is not terminated so we can never get an

			 * interrupt.

			 *

			 * If the user requested a callback for a cyclic DMA

			 * setup then we workaround this hardware limitation

			 * here by degrading to a set of unlinked descriptors

			 * which we will submit in sequence in response to the

			 * completion of processing the previous descriptor.

		/*

		 * There is an existing transfer, therefore this must be one

		 * for which we unlinked the descriptors above. Advance to the

		 * next one in the list.

 Enable the channel's clock. */

 Use 4-word descriptors. */

 Set transfer type. */

	/*

	 * Set the transfer count. This is redundant for a descriptor-driven

	 * transfer. However, there can be a delay between the transfer start

	 * time and when DTCn reg contains the new transfer count. Setting

	 * it explicitly ensures residue is computed correctly at all times.

 Write descriptor address and initiate descriptor fetch. */

 Enable the channel. */

 Clear the DMA status and stop the transfer. */

 Copy the reset of the slave configuration, it is used later. */

 On the issued list, so hasn't been processed yet */

 False positive - continue the transfer */

 Clear halt and address error status of all channels. */

 Clear interrupt pending status. */

 Can only select a channel marked as reserved. */

		/*

		 * On JZ4780, if the second memory resource was not supplied,

		 * assume we're using an old devicetree, and calculate the

		 * offset to the control registers.

 Property is optional, if it doesn't exist the value will remain 0. */

	/*

	 * Enable DMA controller, mark all channels as not programmable.

	 * Also set the FMSC bit - it increases MSC performance, so it makes

	 * little sense not to enable it.

 Register with OF DMA helpers. */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2013-2014 Renesas Electronics Europe Ltd.

 * Author: Guennadi Liakhovetski <g.liakhovetski@gmx.de>

 Channel Current Transaction Byte register */

 Channel Status register */

 Channel Control register */

 Channel Configuration register */

 terminal SELect: 0..7 */

 REQuest Direction: DMAREQ is 0: input, 1: output */

 LOw ENable: low DMA request line is: 0: inactive, 1: active */

 HIgh ENable: high DMA request line is: 0: inactive, 1: active */

 LeVeL: DMA request line is sensed as 0: edge, 1: level */

 ACK Mode: 0: Pulse mode, 1: Level mode, b'1x: Bus Cycle */

 Source Data Size: 0: 8 bits,... , 7: 1024 bits */

 Destination Data Size: as above */

 Source ADdress counting: 0: increment, 1: fixed */

 Destination ADdress counting: 0: increment, 1: fixed */

 Transfer Mode: 0: single, 1: block TM */

 DMAEND interrupt Mask */

 DMATCO interrupt Mask */

 Sweep Buffer Enable */

 RM: Register Set sELect */

 RM: Register Select sWitch */

 RM: Register Set Enable */

 0: register mode (RM), 1: link mode (LM) */

 Link Header field */

 0: fixed priority, 1: round robin */

 DMAEND and DMAERR signalling: 0: pulse, 1: level */

/*

 * We've got 3 types of objects, used to describe DMA transfers:

 * 1. high-level descriptor, containing a struct dma_async_tx_descriptor object

 *	in it, used to communicate with the user

 * 2. hardware DMA link descriptors, that we pass to DMAC for DMA transfer

 *	queuing, these must be DMAable, using either the streaming DMA API or

 *	allocated from coherent memory - one per SG segment

 * 3. one per SG segment descriptors, used to manage HW link descriptors from

 *	(2). They do not have to be DMAable. They can either be (a) allocated

 *	together with link descriptors as mixed (DMA / CPU) objects, or (b)

 *	separately. Even if allocated separately it would be best to link them

 *	to link descriptors once during channel resource allocation and always

 *	use them as a single object.

 * Therefore for both cases (a) and (b) at run-time objects (2) and (3) shall be

 * treated as a single SG segment descriptor.

/**

 * struct nbpf_desc - DMA transfer descriptor

 * @async_tx:	dmaengine object

 * @user_wait:	waiting for a user ack

 * @length:	total transfer length

 * @chan:	associated DMAC channel

 * @sg:		list of hardware descriptors, represented by struct nbpf_link_desc

 * @node:	member in channel descriptor lists

 Take a wild guess: allocate 4 segments per descriptor */

/**

 * struct nbpf_channel - one DMAC channel

 * @dma_chan:	standard dmaengine channel object

 * @tasklet:	channel specific tasklet used for callbacks

 * @base:	register address base

 * @nbpf:	DMAC

 * @name:	IRQ name

 * @irq:	IRQ number

 * @slave_src_addr:	source address for slave DMA

 * @slave_src_width:	source slave data size in bytes

 * @slave_src_burst:	maximum source slave burst size in bytes

 * @slave_dst_addr:	destination address for slave DMA

 * @slave_dst_width:	destination slave data size in bytes

 * @slave_dst_burst:	maximum destination slave burst size in bytes

 * @terminal:	DMA terminal, assigned to this channel

 * @dmarq_cfg:	DMA request line configuration - high / low, edge / level for NBPF_CHAN_CFG

 * @flags:	configuration flags from DT

 * @lock:	protect descriptor lists

 * @free_links:	list of free link descriptors

 * @free:	list of free descriptors

 * @queued:	list of queued descriptors

 * @active:	list of descriptors, scheduled for processing

 * @done:	list of completed descriptors, waiting post-processing

 * @desc_page:	list of additionally allocated descriptor pages - if any

 * @running:	linked descriptor of running transaction

 * @paused:	are translations on this channel paused?

/*

 * dmaengine drivers seem to have a lot in common and instead of sharing more

 * code, they reimplement those common algorithms independently. In this driver

 * we try to separate the hardware-specific part from the (largely) generic

 * part. This improves code readability and makes it possible in the future to

 * reuse the generic code in form of a helper library. That generic code should

 * be suitable for various DMA controllers, using transfer descriptors in RAM

 * and pushing one SG list at a time to the DMA controller.

		Hardware-specific part		*/

 Stop the channel, make sure DMA has been aborted */

 Software trigger MEMCPY - only MEMCPY uses the block mode */

 Don't output DMAACK */

	/*

	 * We assume, that only the link mode and DMA request line configuration

	 * have to be set in the configuration register manually. Dynamic

	 * per-transfer configuration will be loaded from transfer descriptors.

 Maximum supported bursts depend on the buffer size */

/*

 * We need a way to recognise slaves, whose data is sent "raw" over the bus,

 * i.e. it isn't known in advance how many bytes will be received. Therefore

 * the slave driver has to provide a "large enough" buffer and either read the

 * buffer, when it is full, or detect, that some data has arrived, then wait for

 * a timeout, if no more data arrives - receive what's already there. We want to

 * handle such slaves in a special way to allow an optimised mode for other

 * users, for whom the amount of data is known in advance. So far there's no way

 * to recognise such slaves. We use a data-width check to distinguish between

 * the SD host and the PL011 UART.

	/*

	 * set config: SAD, DAD, DDS, SDS, etc.

	 * Note on transfer sizes: the DMAC can perform unaligned DMA transfers,

	 * but it is important to have transaction size a multiple of both

	 * receiver and transmitter transfer sizes. It is also possible to use

	 * different RAM and device transfer sizes, and it does work well with

	 * some devices, e.g. with V08R07S01E SD host controllers, which can use

	 * 128 byte transfers. But this doesn't work with other devices,

	 * especially when the transaction size is unknown. This is the case,

	 * e.g. with serial drivers like amba-pl011.c. For reception it sets up

	 * the transaction size of 4K and if fewer bytes are received, it

	 * pauses DMA and reads out data received via DMA as well as those left

	 * in the Rx FIFO. For this to work with the RAM side using burst

	 * transfers we enable the SBE bit and terminate the transfer in our

	 * .device_pause handler.

		/*

		 * Is the slave narrower than 64 bits, i.e. isn't using the full

		 * bus width and cannot use bursts?

 Device-to-RAM DMA is unreliable without REQD set */

		Generic part			*/

 DMA ENGINE functions */

	/*

	 * This function cannot be called from interrupt context, so, no need to

	 * save flags

/*

 * We have to allocate descriptors with the channel lock dropped. This means,

 * before we re-acquire the lock buffers can be taken already, so we have to

 * re-check after re-acquiring the lock and possibly retry, if buffers are gone

 * again.

 No more free descriptors */

 No more free link descriptors */

 See comment in nbpf_prep_one() */

	/*

	 * We could check config->slave_id to match chan->terminal here,

	 * but with DT they would be coming from the same source, so

	 * such a check would be superflous

	/*

	 * This is a private descriptor list, and we own the descriptor. No need

	 * to lock.

 The user has to return the descriptor to us ASAP via .tx_submit() */

 Clean up for if a channel is re-used for MEMCPY after slave DMA */

 Newly completed descriptor, have to process */

				/*

				 * This descriptor was waiting for a user ACK,

				 * it can be recycled now.

 This can happen if TERMINATE_ALL has been called */

		/*

		 * With released lock we cannot dereference desc, maybe it's

		 * still on the "done" list

 ack and callback completed descriptor */

 On error: abort all queued transfers, no callback */

 Add the channel to DMA device channel list */

 maximum 8 channels + error IRQ */;

 DT only */

	/*

	 * 3 IRQ resource schemes are supported:

	 * 1. 1 shared IRQ for error and all channels

	 * 2. 2 IRQs: one for error and one shared for all channels

	 * 3. 1 IRQ for error and an own IRQ for each channel

 Skip the error IRQ */

 2 IRQs and more than one channel */

 Create DMA Channel */

 Common and MEMCPY operations */

	/*

	 * If we drop support for unaligned MEMCPY buffer addresses and / or

	 * lengths by setting

	 * dma_dev->copy_align = 4;

	 * then we can set transfer length to 4 bytes in nbpf_prep_one() for

	 * DMA_MEM_TO_MEM

 Compulsory for DMA_SLAVE fields */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2013-2014 Allwinner Tech Co., Ltd

 * Author: Sugar <shuge@allwinnertech.com>

 *

 * Copyright (C) 2014 Maxime Ripard

 * Maxime Ripard <maxime.ripard@free-electrons.com>

/*

 * Common registers

 Offset between DMA_IRQ_EN and DMA_IRQ_STAT limits number of channels */

/*

 * sun8i specific registers

/*

 * Channels specific registers

/*

 * Various hardware related defines

 forward declaration */

/*

 * Hardware channels / ports representation

 *

 * The hardware is used in several SoCs, with differing numbers

 * of channels and endpoints. This structure ties those numbers

 * to a certain compatible string.

	/*

	 * In the datasheets/user manuals of newer Allwinner SoCs, a special

	 * bit (bit 2 at register 0x20) is present.

	 * It's named "DMA MCLK interface circuit auto gating bit" in the

	 * documents, and the footnote of this register says that this bit

	 * should be set up when initializing the DMA controller.

	 * Allwinner A23/A33 user manuals do not have this bit documented,

	 * however these SoCs really have and need this bit, as seen in the

	 * BSP kernel source code.

/*

 * Hardware representation of the LLI

 *

 * The hardware will be fed the physical address of this structure,

 * and read its content in order to start the transfer.

	/*

	 * This field is not used by the DMA controller, but will be

	 * used by the CPU to go through the list (mostly for dumping

	 * or freeing it).

				/*

				 * No current txd associated with this channel

 Mark this channel free */

 Remove from pending channels */

 Mark this channel allocated */

 cyclic list */

 Disable all interrupts from DMA */

 Prevent spurious interrupts from scheduling the tasklet */

 Make sure we won't have any further interrupts */

 Actually prevent the tasklet from being scheduled */

/*

 * For A31:

 *

 * There's 16 physical channels that can work in parallel.

 *

 * However we have 30 different endpoints for our requests.

 *

 * Since the channels are able to handle only an unidirectional

 * transfer, we need to allocate more virtual channels so that

 * everyone can grab one channel.

 *

 * Some devices can't work in both direction (mostly because it

 * wouldn't make sense), so we have a bit fewer virtual channels than

 * 2 channels per endpoints.

/*

 * The A23 only has 8 physical channels, a maximum DRQ port id of 24,

 * and a total of 37 usable source and destination endpoints.

/*

 * The H3 has 12 physical channels, a maximum DRQ port id of 27,

 * and a total of 34 usable source and destination endpoints.

 * It also supports additional burst lengths and bus widths,

 * and the burst length fields have different offsets.

/*

 * The A64 binding uses the number of dma channels from the

 * device tree node.

/*

 * TODO: Add support for more than 4g physical addressing.

 *

 * The A100 binding uses the number of dma channels from the

 * device tree node.

/*

 * The H6 binding uses the number of dma channels from the

 * device tree node.

/*

 * The V3s have only 8 physical channels, a maximum DRQ port id of 23,

 * and a total of 24 usable source and destination endpoints.

 sentinel */ }

	/*

	 * If the number of vchans is not specified, derive it from the

	 * highest port number, at most one channel per port and direction.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * SA11x0 DMAengine support

 *

 * Copyright (C) 2012 Russell King

 *   Derived in part from arch/arm/mach-sa1100/dma.c,

 *   Copyright (C) 2000, 2001 by Nicolas Pitre

 0 = W, 1 = R */

 0 = LE, 1 = BE */

 0 = BS4, 1 = BS8 */

 0 = 8b, 1 = 16b */

 protected by c->vc.lock */

 protected by d->lock */

 Protected by c->vc.lock */

 Don't try to load the next transfer if both buffers are started */

			/*

			 * We have reached the end of the current descriptor.

			 * Peek at the next descriptor, and if compatible with

			 * the current, start processing it.

 Cyclic: reset back to beginning */

 Select buffer to load according to channel status */

 Cyclic: reset back to beginning */

 Clear reported status bits */

		/*

		 * Now that we're holding the lock, check that the vchan

		 * really is associated with this pchan before touching the

		 * hardware.  This should always succeed, because we won't

		 * change p->vchan or c->phy while the channel is actively

		 * transferring.

 If the issued list is empty, we have no further txds to process */

 The channel should not have any transfers started */

 Clear the run and start bits before changing DDAR */

 Try to start both buffers */

 No current txd associated with this channel */

 Mark this channel free */

 Mark this channel allocated */

	/*

	 * If the cookie is on our issue queue, then the residue is

	 * its total size.

/*

 * Move pending txds to the issued list, and re-init pending list.

 * If not already pending, add this channel to the list of pending

 * channels and trigger the tasklet to run.

 SA11x0 channels can only operate in their native direction */

 Do not allow zero-sized txds */

			/*

			 * Check whether the transfer will fit.  If not, try

			 * to split the transfer up such that we end up with

			 * equal chunks - but make sure that we preserve the

			 * alignment.  This avoids small segments.

 SA11x0 channels can only operate in their native direction */

 Do not allow zero-sized txds */

 Clear the tx descriptor lists */

 vchan is assigned to a pchan - stop the channel */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * DMA driver for Nvidia's Tegra20 APB DMA controller.

 *

 * Copyright (c) 2012-2013, NVIDIA CORPORATION.  All rights reserved.

 CSR register */

 STATUS register */

 AHB memory address */

 AHB sequence register */

 APB address */

 APB sequence register */

 Tegra148 specific registers */

/*

 * If any burst is in flight and DMA paused then this is the time to complete

 * on-flight burst and update DMA status register.

 Channel base address offset from APBDMA base address */

/*

 * tegra_dma_chip_data Tegra chip specific DMA data

 * @nr_channels: Number of channels available in the controller.

 * @channel_reg_size: Channel register size/stride.

 * @max_dma_count: Maximum DMA transfer count supported by DMA controller.

 * @support_channel_pause: Support channel wise pause of dma.

 * @support_separate_wcount_reg: Support separate word count register.

 DMA channel registers */

/*

 * tegra_dma_sg_req: DMA request details to configure hardware. This

 * contains the details for one transfer to configure DMA hw.

 * The client's request for data transfer can be broken into multiple

 * sub-transfer as per requester details and hw support.

 * This sub transfer get added in the list of transfer and point to Tegra

 * DMA descriptor which manages the transfer details.

/*

 * tegra_dma_desc: Tegra DMA descriptors which manages the client requests.

 * This descriptor keep track of transfer status, callbacks and request

 * counts etc.

 tegra_dma_channel: Channel specific information */

 Different lists for managing the requests */

 ISR handler and tasklet for bottom half of isr handling */

 Channel-slave specific configuration */

 tegra_dma: Tegra DMA specific information */

	/*

	 * Counter for managing global pausing of the DMA controller.

	 * Only applicable for devices that don't support individual

	 * channel pausing.

 Last member of the structure */

 Get DMA desc from free list, if not there then allocate it.  */

 Do not allocate if desc are waiting for ack */

 Allocate DMA desc */

 Disable interrupts */

 Disable DMA */

 Clear interrupt status if it is there */

 Start DMA */

	/*

	 * The DMA controller reloads the new configuration for next transfer

	 * after last burst of current transfer completes.

	 * If there is no IEC status then this makes sure that last burst

	 * has not be completed. There may be case that last burst is on

	 * flight and so it can complete but because DMA is paused, it

	 * will not generates interrupt as well as not reload the new

	 * configuration.

	 * If there is already IEC status then interrupt handler need to

	 * load new configuration.

	/*

	 * If interrupt is pending then do nothing as the ISR will handle

	 * the programing for new request.

 Safe to program new configuration */

 Add in cb list if it is not there. */

	/*

	 * Check that head req on list should be in flight.

	 * If it is not in flight then abort transfer as

	 * looping of transfer can not continue.

 Configure next request */

 Do not start DMA if it is going to be terminate */

 if we dma for long enough the transfer count will wrap */

 Callback need to be call */

 If not last req then put at end of pending list */

 Continuous single mode: Configure next req */

			/*

			 * Wait for 1 burst time for configure DMA for

			 * next transfer.

 Pause DMA before checking the queue status */

	/*

	 * CPU, which handles interrupt, could be busy in

	 * uninterruptible state, in this case sibling CPU

	 * should wait until interrupt is handled.

		/*

		 * If wcount wasn't ever polled for this SG before, then

		 * simply assume that transfer hasn't started yet.

		 *

		 * Otherwise it's the end of the transfer.

		 *

		 * The alternative would be to poll the status register

		 * until EOC bit is set or wcount goes UP. That's so

		 * because EOC bit is getting set only after the last

		 * burst's completion and counter is less than the actual

		 * transfer size by 4 bytes. The counter value wraps around

		 * in a cyclic mode before EOC is set(!), so we can't easily

		 * distinguish start of transfer from its end.

		/*

		 * This case will never happen for a non-cyclic transfer.

		 *

		 * For a cyclic transfer, although it is possible for the

		 * next transfer to have already started (resetting the word

		 * count), this case should still not happen because we should

		 * have detected that the EOC bit is set and hence the transfer

		 * was completed.

 Check on wait_ack desc status */

 Check in pending list */

	/*

	 * burst_size from client is in terms of the bus_width.

	 * convert them into AHB memory width which is 4 byte.

 If burst size is 0 then calculate the burst size based on length */

 Make transfer requests */

	/*

	 * Make sure that mode should not be conflicting with currently

	 * configured mode.

	/*

	 * We allow to take more number of requests till DMA is

	 * not started. The driver will loop over all requests.

	 * Once DMA is started then new requests can be queued only after

	 * terminating the DMA.

	/*

	 * We only support cycle transfer when buf_len is multiple of

	 * period_len.

 Split transfer equal to period size */

	/*

	 * Make sure that mode should not be conflicting with currently

	 * configured mode.

 Tegra20 specific DMA controller information */

 Tegra30 specific DMA controller information */

 Tegra114 specific DMA controller information */

 Tegra148 specific DMA controller information */

 reset DMA controller */

 enable global DMA registers */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * timb_dma.c timberdale FPGA DMA driver

 * Copyright (c) 2010 Intel Corporation

/* Supports:

 * Timberdale FPGA DMA engine

 Global DMA registers */

 Channel specific registers */

/* RX instances base addresses are 0x00, 0x40, 0x80 ...

 * TX instances base addresses are 0x18, 0x58, 0x98 ...

 RX registers, relative the instance base */

/* bytes per Row, video specific register

 * which is placed after the TX registers...

 TX registers, relative the instance base */

	spinlock_t		lock; /* Used to protect data structures,

					especially the lists and descriptors,

					from races between the tasklet and calls

 Descriptors to allocate */

 number of elems per descriptor */

 Must be called with the spinlock held */

 enable interrupt for this channel */

 Should be called with the spinlock held */

 length must be word aligned */

 tran, valid */

 Must be called with the spinlock held */

 descriptor address */

 Bytes per line */

 enable RX */

 address high */

 can happen if the descriptor is canceled */

 make sure to stop the transfer */

/* Currently no support for stopping DMA transfers

	else

		iowrite32(0, td_chan->membase + TIMBDMA_OFFS_TX_DLAR);

	/*

	 * The API requires that no submissions are done from a

	 * callback, so we don't need to drop the lock here

 check that all descriptors are free */

 transfer ongoing */

 even channels are for RX, odd for TX */

 first the easy part, put the queue into the free list */

 now tear down the running */

 ack the interrupts */

 disable interrupts, will be re-enabled in tasklet */

 32bit addressing */

 disable and clear any interrupts */

 even channels are RX, odd are TX */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Core driver for the Intel integrated DMA 64-bit

 *

 * Copyright (C) 2015 Intel Corporation

 * Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

 For now we support only two channels */

 ---------------------------------------------------------------------- */

 ---------------------------------------------------------------------- */

 ---------------------------------------------------------------------- */

 Set default burst alignment */

 Enable interrupts */

	/*

	 * Enforce the controller to be turned on.

	 *

	 * The iDMA is turned off in ->probe() and looses context during system

	 * suspend / resume cycle. That's why we have to enable it each time we

	 * use it.

 Get the next descriptor */

 Configure the channel */

 Start the channel with a new descriptor */

 ---------------------------------------------------------------------- */

 idma64_start_transfer() updates idma64c->desc */

 Check if we have any interrupt from the DMA controller */

 ---------------------------------------------------------------------- */

 DMA_DEV_TO_MEM */

 Fill the hardware descriptors and link them to a list */

 Trigger an interrupt after the last block is transfered */

 Disable LLP transfer in the last block */

 Allocate DMA capable memory for hardware descriptor */

 The current chunk is not fully transfered yet */

 Create a pool of consistent memory blocks for hardware descriptors */

 ---------------------------------------------------------------------- */

 Turn off iDMA controller */

	/*

	 * Explicitly call devm_request_irq() to avoid the side effects with

	 * the scheduled tasklets.

 ---------------------------------------------------------------------- */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Driver for the Cirrus Logic EP93xx DMA Controller

 *

 * Copyright (C) 2011 Mika Westerberg

 *

 * DMA M2P implementation is based on the original

 * arch/arm/mach-ep93xx/dma-m2p.c which has following copyrights:

 *

 *   Copyright (C) 2006 Lennert Buytenhek <buytenh@wantstofly.org>

 *   Copyright (C) 2006 Applied Data Systems

 *   Copyright (C) 2009 Ryan Mallon <rmallon@gmail.com>

 *

 * This driver is based on dw_dmac and amba-pl08x drivers.

 M2P registers */

 M2M registers */

/**

 * struct ep93xx_dma_desc - EP93xx specific transaction descriptor

 * @src_addr: source address of the transaction

 * @dst_addr: destination address of the transaction

 * @size: size of the transaction (in bytes)

 * @complete: this descriptor is completed

 * @txd: dmaengine API descriptor

 * @tx_list: list of linked descriptors

 * @node: link used for putting this into a channel queue

/**

 * struct ep93xx_dma_chan - an EP93xx DMA M2P/M2M channel

 * @chan: dmaengine API channel

 * @edma: pointer to to the engine device

 * @regs: memory mapped registers

 * @irq: interrupt number of the channel

 * @clk: clock used by this channel

 * @tasklet: channel specific tasklet used for callbacks

 * @lock: lock protecting the fields following

 * @flags: flags for the channel

 * @buffer: which buffer to use next (0/1)

 * @active: flattened chain of descriptors currently being processed

 * @queue: pending descriptors which are handled next

 * @free_list: list of free descriptors which can be used

 * @runtime_addr: physical address currently used as dest/src (M2M only). This

 *                is set via .device_config before slave operation is

 *                prepared

 * @runtime_ctrl: M2M runtime values for the control register.

 * @slave_config: slave configuration

 *

 * As EP93xx DMA controller doesn't support real chained DMA descriptors we

 * will have slightly different scheme here: @active points to a head of

 * flattened DMA descriptor chain.

 *

 * @queue holds pending transactions. These are linked through the first

 * descriptor in the chain. When a descriptor is moved to the @active queue,

 * the first and chained descriptors are flattened into a single list.

 *

 * @chan.private holds pointer to &struct ep93xx_dma_data which contains

 * necessary channel configuration information. For memcpy channels this must

 * be %NULL.

 protects the fields following */

 Channel is configured for cyclic transfers */

/**

 * struct ep93xx_dma_engine - the EP93xx DMA engine instance

 * @dma_dev: holds the dmaengine device

 * @m2m: is this an M2M or M2P device

 * @hw_setup: method which sets the channel up for operation

 * @hw_synchronize: synchronizes DMA channel termination to current context

 * @hw_shutdown: shuts the channel down and flushes whatever is left

 * @hw_submit: pushes active descriptor(s) to the hardware

 * @hw_interrupt: handle the interrupt

 * @num_channels: number of channels for this instance

 * @channels: array of channels

 *

 * There is one instance of this struct for the M2P channels and one for the

 * M2M channels. hw_xxx() methods are used to perform operations which are

 * different on M2M and M2P channels. These methods are called with channel

 * lock held and interrupts disabled so they cannot sleep.

/**

 * ep93xx_dma_set_active - set new active descriptor chain

 * @edmac: channel

 * @desc: head of the new active descriptor chain

 *

 * Sets @desc to be the head of the new active descriptor chain. This is the

 * chain which is processed next. The active list must be empty before calling

 * this function.

 *

 * Called with @edmac->lock held and interrupts disabled.

 Flatten the @desc->tx_list chain into @edmac->active list */

		/*

		 * We copy the callback parameters from the first descriptor

		 * to all the chained descriptors. This way we can call the

		 * callback without having to find out the first descriptor in

		 * the chain. Useful for cyclic transfers.

 Called with @edmac->lock held and interrupts disabled */

/**

 * ep93xx_dma_advance_active - advances to the next active descriptor

 * @edmac: channel

 *

 * Function advances active descriptor to the next in the @edmac->active and

 * returns %true if we still have descriptors in the chain to process.

 * Otherwise returns %false.

 *

 * When the channel is in cyclic mode always returns %true.

 *

 * Called with @edmac->lock held and interrupts disabled.

	/*

	 * If txd.cookie is set it means that we are back in the first

	 * descriptor in the chain and hence done with it.

/*

 * M2P DMA implementation

	/*

	 * EP93xx User's Guide states that we must perform a dummy read after

	 * write to the control register.

 Clear the error interrupt */

		/*

		 * It seems that there is no easy way of reporting errors back

		 * to client so we just report the error here and continue as

		 * usual.

		 *

		 * Revisit this when there is a mechanism to report back the

		 * errors.

	/*

	 * Even latest E2 silicon revision sometimes assert STALL interrupt

	 * instead of NFB. Therefore we treat them equally, basing on the

	 * amount of data we still have to transfer.

 Disable interrupts */

/*

 * M2M DMA implementation

 This is memcpy channel, nothing to configure */

		/*

		 * This was found via experimenting - anything less than 5

		 * causes the channel to perform only a partial transfer which

		 * leads to problems since we don't get DONE interrupt then.

		/*

		 * This IDE part is totally untested. Values below are taken

		 * from the EP93xx Users's Guide and might not be correct.

 Worst case from the UG */

 Just disable the channel */

	/*

	 * Since we allow clients to configure PW (peripheral width) we always

	 * clear PW bits here and then set them according what is given in

	 * the runtime configuration.

	/*

	 * Now we can finally enable the channel. For M2M channel this must be

	 * done _after_ the BCRx registers are programmed.

		/*

		 * For memcpy channels the software trigger must be asserted

		 * in order to start the memcpy operation.

/*

 * According to EP93xx User's Guide, we should receive DONE interrupt when all

 * M2M DMA controller transactions complete normally. This is not always the

 * case - sometimes EP93xx M2M DMA asserts DONE interrupt when the DMA channel

 * is still running (channel Buffer FSM in DMA_BUF_ON state, and channel

 * Control FSM in DMA_MEM_RD state, observed at least in IDE-DMA operation).

 * In effect, disabling the channel when only DONE bit is set could stop

 * currently running DMA transfer. To avoid this, we use Buffer FSM and

 * Control FSM to check current state of DMA channel.

 Accept only DONE and NFB interrupts */

 Clear the DONE bit */

	/*

	 * Check whether we are done with descriptors or not. This, together

	 * with DMA channel state, determines action to take in interrupt.

	/*

	 * Use M2M DMA Buffer FSM and Control FSM to check current state of

	 * DMA channel. Using DONE and NFB bits from channel status register

	 * or bits from channel interrupt register is not reliable.

		/*

		 * Two buffers are ready for update when Buffer FSM is in

		 * DMA_NO_BUF state. Only one buffer can be prepared without

		 * disabling the channel or polling the DONE bit.

		 * To simplify things, always prepare only one buffer.

 Software trigger for memcpy channel */

	/*

	 * Disable the channel only when Buffer FSM is in DMA_NO_BUF state

	 * and Control FSM is in DMA_STALL state.

 Disable interrupts and the channel */

	/*

	 * Nothing to do this time.

/*

 * DMA engine API implementation

 Re-initialize the descriptor */

/**

 * ep93xx_dma_advance_work - start processing the next pending transaction

 * @edmac: channel

 *

 * If we have pending transactions queued and we are currently idling, this

 * function takes the next queued transaction from the @edmac->queue and

 * pushes it to the hardware for execution.

 Take the next descriptor from the pending queue */

 Push it to the hardware */

	/*

	 * If dma_terminate_all() was called before we get to run, the active

	 * list has become empty. If that happens we aren't supposed to do

	 * anything more than call ep93xx_dma_advance_work().

 mark descriptor complete for non cyclic case only */

 Pick up the next descriptor from the queue */

 Now we can release all the chained descriptors */

/**

 * ep93xx_dma_tx_submit - set the prepared descriptor(s) to be executed

 * @tx: descriptor to be executed

 *

 * Function will execute given descriptor on the hardware or if the hardware

 * is busy, queue the descriptor to be executed later on. Returns cookie which

 * can be used to poll the status of the descriptor.

	/*

	 * If nothing is currently prosessed, we push this descriptor

	 * directly to the hardware. Otherwise we put the descriptor

	 * to the pending queue.

/**

 * ep93xx_dma_alloc_chan_resources - allocate resources for the channel

 * @chan: channel to allocate resources

 *

 * Function allocates necessary resources for the given DMA channel and

 * returns number of allocated descriptors for the channel. Negative errno

 * is returned in case of failure.

 Sanity check the channel parameters */

/**

 * ep93xx_dma_free_chan_resources - release resources for the channel

 * @chan: channel

 *

 * Function releases all the resources allocated for the given channel.

 * The channel must be idle when this is called.

/**

 * ep93xx_dma_prep_dma_memcpy - prepare a memcpy DMA operation

 * @chan: channel

 * @dest: destination bus address

 * @src: source bus address

 * @len: size of the transaction

 * @flags: flags for the descriptor

 *

 * Returns a valid DMA descriptor or %NULL in case of failure.

/**

 * ep93xx_dma_prep_slave_sg - prepare a slave DMA operation

 * @chan: channel

 * @sgl: list of buffers to transfer

 * @sg_len: number of entries in @sgl

 * @dir: direction of tha DMA transfer

 * @flags: flags for the descriptor

 * @context: operation context (ignored)

 *

 * Returns a valid DMA descriptor or %NULL in case of failure.

/**

 * ep93xx_dma_prep_dma_cyclic - prepare a cyclic DMA operation

 * @chan: channel

 * @dma_addr: DMA mapped address of the buffer

 * @buf_len: length of the buffer (in bytes)

 * @period_len: length of a single period

 * @dir: direction of the operation

 * @flags: tx descriptor status flags

 *

 * Prepares a descriptor for cyclic DMA operation. This means that once the

 * descriptor is submitted, we will be submitting in a @period_len sized

 * buffers and calling callback once the period has been elapsed. Transfer

 * terminates only when client calls dmaengine_terminate_all() for this

 * channel.

 *

 * Returns a valid DMA descriptor or %NULL in case of failure.

 Split the buffer into period size chunks */

/**

 * ep93xx_dma_synchronize - Synchronizes the termination of transfers to the

 * current context.

 * @chan: channel

 *

 * Synchronizes the DMA channel termination to the current context. When this

 * function returns it is guaranteed that all transfers for previously issued

 * descriptors have stopped and and it is safe to free the memory associated

 * with them. Furthermore it is guaranteed that all complete callback functions

 * for a previously submitted descriptor have finished running and it is safe to

 * free resources accessed from within the complete callbacks.

/**

 * ep93xx_dma_terminate_all - terminate all transactions

 * @chan: channel

 *

 * Stops all DMA transactions. All descriptors are put back to the

 * @edmac->free_list and callbacks are _not_ called.

 First we disable and flush the DMA channel */

	/*

	 * We then re-enable the channel. This way we can continue submitting

	 * the descriptors by just calling ->hw_submit() again.

/**

 * ep93xx_dma_tx_status - check if a transaction is completed

 * @chan: channel

 * @cookie: transaction specific cookie

 * @state: state of the transaction is stored here if given

 *

 * This function can be used to query state of a given transaction.

/**

 * ep93xx_dma_issue_pending - push pending transactions to the hardware

 * @chan: channel

 *

 * When this function is called, all pending transactions are pushed to the

 * hardware and executed.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Device tree helpers for DMA request / controller

 *

 * Based on of_gpio.c

 *

 * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/

/**

 * of_dma_find_controller - Get a DMA controller in DT DMA helpers list

 * @dma_spec:	pointer to DMA specifier as found in the device tree

 *

 * Finds a DMA controller with matching device node and number for dma cells

 * in a list of registered DMA controllers. If a match is found a valid pointer

 * to the DMA data stored is retuned. A NULL pointer is returned if no match is

 * found.

/**

 * of_dma_router_xlate - translation function for router devices

 * @dma_spec:	pointer to DMA specifier as found in the device tree

 * @ofdma:	pointer to DMA controller data (router information)

 *

 * The function creates new dma_spec to be passed to the router driver's

 * of_dma_route_allocate() function to prepare a dma_spec which will be used

 * to request channel from the real DMA controller.

 translate the request for the real DMA controller */

	/*

	 * Need to put the node back since the ofdma->of_dma_route_allocate

	 * has taken it for generating the new, translated dma_spec

/**

 * of_dma_controller_register - Register a DMA controller to DT DMA helpers

 * @np:			device node of DMA controller

 * @of_dma_xlate:	translation function which converts a phandle

 *			arguments list into a dma_chan structure

 * @data:		pointer to controller specific data to be used by

 *			translation function

 *

 * Returns 0 on success or appropriate errno value on error.

 *

 * Allocated memory should be freed with appropriate of_dma_controller_free()

 * call.

 Now queue of_dma controller structure in list */

/**

 * of_dma_controller_free - Remove a DMA controller from DT DMA helpers list

 * @np:		device node of DMA controller

 *

 * Memory allocated by of_dma_controller_register() is freed here.

/**

 * of_dma_router_register - Register a DMA router to DT DMA helpers as a

 *			    controller

 * @np:				device node of DMA router

 * @of_dma_route_allocate:	setup function for the router which need to

 *				modify the dma_spec for the DMA controller to

 *				use and to set up the requested route.

 * @dma_router:			pointer to dma_router structure to be used when

 *				the route need to be free up.

 *

 * Returns 0 on success or appropriate errno value on error.

 *

 * Allocated memory should be freed with appropriate of_dma_controller_free()

 * call.

 Now queue of_dma controller structure in list */

/**

 * of_dma_match_channel - Check if a DMA specifier matches name

 * @np:		device node to look for DMA channels

 * @name:	channel name to be matched

 * @index:	index of DMA specifier in list of DMA specifiers

 * @dma_spec:	pointer to DMA specifier as found in the device tree

 *

 * Check if the DMA specifier pointed to by the index in a list of DMA

 * specifiers, matches the name provided. Returns 0 if the name matches and

 * a valid pointer to the DMA specifier is found. Otherwise returns -ENODEV.

/**

 * of_dma_request_slave_channel - Get the DMA slave channel

 * @np:		device node to get DMA request from

 * @name:	name of desired channel

 *

 * Returns pointer to appropriate DMA channel on success or an error pointer.

 Silently fail if there is not even the "dmas" property */

	/*

	 * approximate an average distribution across multiple

	 * entries with the same name

/**

 * of_dma_simple_xlate - Simple DMA engine translation function

 * @dma_spec:	pointer to DMA specifier as found in the device tree

 * @ofdma:	pointer to DMA controller data

 *

 * A simple translation function for devices that use a 32-bit value for the

 * filter_param when calling the DMA engine dma_request_channel() function.

 * Note that this translation function requires that #dma-cells is equal to 1

 * and the argument of the dma specifier is the 32-bit filter_param. Returns

 * pointer to appropriate dma channel on success or NULL on error.

/**

 * of_dma_xlate_by_chan_id - Translate dt property to DMA channel by channel id

 * @dma_spec:	pointer to DMA specifier as found in the device tree

 * @ofdma:	pointer to DMA controller data

 *

 * This function can be used as the of xlate callback for DMA driver which wants

 * to match the channel based on the channel id. When using this xlate function

 * the #dma-cells propety of the DMA controller dt node needs to be set to 1.

 * The data parameter of of_dma_controller_register must be a pointer to the

 * dma_device struct the function should match upon.

 *

 * Returns pointer to appropriate dma channel on success or NULL on error.

 SPDX-License-Identifier: GPL-2.0+



 drivers/dma/imx-dma.c



 This file contains a driver for the Freescale i.MX DMA engine

 found on i.MX1/21/27



 Copyright 2010 Sascha Hauer, Pengutronix <s.hauer@pengutronix.de>

 Copyright 2012 Javier Martin, Vista Silicon <javier.martin@vista-silicon.com>

 Control Register */

 Interrupt status Register */

 Interrupt mask Register */

 Burst timeout status Register */

 Request timeout Register */

 Transfer Error Status Register */

 Buffer overflow status Register */

 Burst timeout control Register */

 W-Size Register A */

 X-Size Register A */

 Y-Size Register A */

 W-Size Register B */

 X-Size Register B */

 Y-Size Register B */

 Source Address Registers */

 Destination Address Registers */

 Count Registers */

 Control Registers */

 Request source select Registers */

 Burst length Registers */

 Request timeout Registers */

 Bus Utilization Registers */

 Channel counter Registers */

 For memcpy and interleaved */

 For interleaved transfers */

 For slave sg and cyclic */

 sentinel */

/*

 * imxdma_sg_next - prepare next chunk for scatter-gather DMA emulation

 Tasklet watchdog error handler */

 Tasklet error handler */

				/* FIXME: The timeout should probably be

				 * configurable

 Tasklet progression */

 Tasklet irq */

 Configure and enable */

 Try to get a free 2D slot */

		/*

		 * We fall-through here intentionally, since a 2D transfer is

		 * similar to MEMCPY just adding the 2D slot configuration.

 Cyclic transfer is the same as slave_sg with special sg configuration. */

 Someone might have called terminate all */

	/* If we are dealing with a cyclic descriptor, keep it on ld_active

	 * and dont mark the descriptor as complete.

	 * Only in non-cyclic cases it would be marked as complete

 Free 2D slot if it was an interleaved transfer */

 Set burst length */

 txd.flags will be overwritten in prep funcs */

 close the loop */

 reset DMA module */

 enable DMA module */

 clear all interrupts */

 disable interrupts */

 Initialize 2D global parameters */

 Initialize channel parameters */

 Add the channel to the DMAC list */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2013 - 2015 Linaro Ltd.

 * Copyright (c) 2013 HiSilicon Limited.

 set same priority */

 unmask irq */

 mask irq */

 Avoid losing track of  ds_run if a transaction is in flight */

		/*

		 * fetch and remove request from vc->desc_issued

		 * so vc->desc_issued only contains desc pending

 start dma */

 check new dma request of running channel in vc->desc_issued */

 No current txd associated with this channel */

 Mark this channel free */

 check new channel request in d->chan_pending */

 remove from d->chan_pending */

 Mark this channel allocated */

	/*

	 * If the cookie is on our issue queue, then the residue is

	 * its total size.

 end of lli */

 add request to vc->desc_issued */

 if new channel, add chan_pending */

 check in tasklet */

 default is memtomem, without calling device_config */

 burst = 16 */

 width = 64 bit */

 end of link */

 end of link */

 descriptor asks for TC2 interrupt on completion */

 "Cyclic" == end of link points back to start of link */

 specific request line */

 Prevent this channel being scheduled */

 Clear the tx descriptor lists */

 vchan is assigned to a pchan - stop the channel */

 A DMA memory pool for LLIs, align on 32-byte boundary */

 init phy channel */

 init virtual channel */

 Enable clock before accessing registers */

 SPDX-License-Identifier: GPL-2.0



 Copyright 2011 Freescale Semiconductor, Inc. All Rights Reserved.



 Refer to drivers/dma/imx-sdma.c

/*

 * NOTE: The term "PIO" throughout the mxs-dma implementation means

 * PIO mode of mxs apbh-dma and apbx-dma.  With this working mode,

 * dma can program the controller registers of peripheral devices.

/*

 * The offset of NXTCMDAR register is different per both dma type and version,

 * while stride for each channel is all the same 0x70.

/*

 * ccw bits definitions

 *

 * COMMAND:		0..1	(2)

 * CHAIN:		2	(1)

 * IRQ:			3	(1)

 * NAND_LOCK:		4	(1) - not implemented

 * NAND_WAIT4READY:	5	(1) - not implemented

 * DEC_SEM:		6	(1)

 * WAIT4END:		7	(1)

 * HALT_ON_TERMINATE:	8	(1)

 * TERMINATE_FLUSH:	9	(1)

 * RESERVED:		10..11	(2)

 * PIO_NUM:		12..15	(4)

 not implemented */

 sentinel */ }

	/*

	 * mxs dma channel resets can cause a channel stall. To recover from a

	 * channel stall, we have to reset the whole DMA engine. To avoid this,

	 * we use cyclic DMA with semaphores, that are enhanced in

	 * mxs_dma_int_handler. To reset the channel, we can simply stop writing

	 * into the semaphore counter.

 50ms */

		/*

		 * On i.MX28 APBX, the DMA channel can stop working if we reset

		 * the channel while it is in READ_FLUSH (0x08) state.

		 * We wait here until we leave the state. Then we trigger the

		 * reset. Waiting a maximum of 50ms, the kernel shouldn't crash

		 * because of this.

 set cmd_addr up */

 write 1 to SEMA to kick off the channel */

		/* A cyclic DMA consists of at least 2 segments, so initialize

		 * the semaphore with 2 so we have enough time to add 1 to the

 freeze the channel */

 unfreeze the channel */

 completion status */

 Clear interrupt */

 error status */

	/*

	 * error status bit is in the upper 16 bits, error irq bit in the lower

	 * 16 bits. We transform it into a simpler error code:

	 * err: 0x00 = no error, 0x01 = TERMINATION, 0x02 = BUS_ERROR

 Clear error irq */

	/*

	 * When both completion and error of termination bits set at the

	 * same time, we do not take it as an error.  IOW, it only becomes

	 * an error we need to handle here in case of either it's a bus

	 * error or a termination error with no completion. 0x01 is termination

	 * error, so we can subtract err & completed to get the real error case.

 schedule tasklet on this channel */

 the descriptor is ready */

/*

 * How to use the flags for ->device_prep_slave_sg() :

 *    [1] If there is only one DMA command in the DMA chain, the code should be:

 *            ......

 *            ->device_prep_slave_sg(DMA_CTRL_ACK);

 *            ......

 *    [2] If there are two DMA commands in the DMA chain, the code should be

 *            ......

 *            ->device_prep_slave_sg(0);

 *            ......

 *            ->device_prep_slave_sg(DMA_CTRL_ACK);

 *            ......

 *    [3] If there are more than two DMA commands in the DMA chain, the code

 *        should be:

 *            ......

 *            ->device_prep_slave_sg(0);                                // First

 *            ......

 *            ->device_prep_slave_sg(DMA_CTRL_ACK]);

 *            ......

 *            ->device_prep_slave_sg(DMA_CTRL_ACK); // Last

 *            ......

	/*

	 * If the sg is prepared with append flag set, the sg

	 * will be appended to the last prepared sg.

 enable apbh burst */

 enable irq for all the channels */

 Initialize channel parameters */

 Add the channel to mxs_chan list */

 mxs_dma gets 65535 bytes maximum sg size */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *

 * Copyright (C) STMicroelectronics SA 2017

 * Author(s): M'boumba Cedric Madianga <cedric.madianga@gmail.com>

 *            Pierre-Yves Mordret <pierre-yves.mordret@st.com>

 *

 * DMA Router driver for STM32 DMA MUX

 *

 * Based on TI DMA Crossbar driver

 Number of DMA requests connected to DMAMUX */

 Number of DMA requests routed toward DMAs */

 Protects register access */

 Used DMA channel */

	u32 ccr[STM32_DMAMUX_MAX_DMA_REQUESTS]; /* Used to backup CCR register

						 * in suspend

	u32 dma_reqs[]; /* Number of DMA Request per DMA masters.

			 *  [0] holds number of DMA Masters.

			 *  To be kept at very end end of this structure

 Clear dma request */

 Look for DMA Master */

 The of_node_put() will be done in of_dma_router_xlate function */

 Set dma request */

  craft DMA spec */

 Reset the dmamux */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *

 * Copyright (C) STMicroelectronics SA 2017

 * Author(s): M'boumba Cedric Madianga <cedric.madianga@gmail.com>

 *            Pierre-Yves Mordret <pierre-yves.mordret@st.com>

 *

 * Driver for STM32 MDMA controller

 *

 * Inspired by stm32-dma.c and dma-jz4780.c

  MDMA Generic getter/setter */

 MDMA Int Status Reg 1 */

 MDMA Int Status Reg 2 */

 MDMA Channel x interrupt/status register */

 x = 0..62 */

 MDMA Channel x interrupt flag clear register */

 MDMA Channel x error status register */

 MDMA Channel x control register */

 MDMA Channel x transfer configuration register */

 MDMA Channel x block number of data register */

 MDMA Channel x source address register */

 MDMA Channel x destination address register */

 MDMA Channel x block repeat address update register */

 MDMA Channel x link address register */

 MDMA Channel x trigger and bus selection register */

 MDMA Channel x mask address register */

 MDMA Channel x mask data register */

		/*

		 * Address and buffer length both have to be aligned on

		 * bus width

 Disable interrupts */

 Ensure that any ongoing transfer has been completed */

 Disable DMA */

 Clear interrupt status if it is there */

 Check if memory device is on AHB or AXI */

 Enable HW request mode */

 Set DINC, SINC, DINCOS, SINCOS, TRGM and TLEN retrieve from DT */

	/*

	 * For buffer transfer length (TLEN) we have to set

	 * the number of bytes - 1 in CTCR register

 Disable Pack Enable */

 Check burst size constraints */

	/*

	 * Configure channel control:

	 * - Clear SW request as in this case this is a HW one

	 * - Clear WEX, HEX and BEX bits

	 * - Set priority level

 Configure Trigger selection */

 Set device data size */

 Set device burst value */

 Set memory data size */

 Set memory burst value */

 Select bus */

 Set destination address */

 Set device data size */

 Set device burst value */

 Set memory data size */

 Set memory burst value */

 Select bus */

 Set source address */

 Enable interrupts */

	/*

	 * Once DMA is in setup cyclic mode the channel we cannot assign this

	 * channel anymore. The DMA channel needs to be aborted or terminated

	 * for allowing another request.

	/*

	 * Once DMA is in setup cyclic mode the channel we cannot assign this

	 * channel anymore. The DMA channel needs to be aborted or terminated

	 * for allowing another request.

 Select bus */

 Enable interrupts */

 Configure hwdesc list */

	/*

	 * Once DMA is in setup cyclic mode the channel we cannot assign this

	 * channel anymore. The DMA channel needs to be aborted or terminated

	 * to allow another request

 Enable sw req, some interrupts and clear other bits */

 Enable SW request mode, dest/src inc and clear other bits */

 Reset HW request */

 Select bus */

 Clear CBNDTR registers */

 Setup a buffer transfer */

 Setup a block transfer */

 Set source best burst size */

 Set destination best burst size */

 Prepare hardware descriptor */

 Setup a LLI transfer */

 Set source best burst size */

 Set destination best burst size */

 Prepare hardware descriptor */

 Clear interrupt status if it is there */

 Start DMA */

 Set SW request in case of MEM2MEM transfer */

 Re-configure control register */

 Clear interrupt status if it is there */

 Re-start DMA */

 Set SW request in case of MEM2MEM transfer */

 Start the next transfer if this driver has a next desc */

 Find out which channel generates the interrupt */

		/*

		 * As GISR0 provides status for channel id from 0 to 31,

		 * so GISR1 provides status for channel id from 32 to 62

 Handle interrupt for the channel */

 Mask Channel ReQuest Active bit which can be set in case of MEM2MEM */

 sentinel */ },

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) 2006 ARM Ltd.

 * Copyright (c) 2010 ST-Ericsson SA

 * Copyirght (c) 2017 Linaro Ltd.

 *

 * Author: Peter Pearse <peter.pearse@arm.com>

 * Author: Linus Walleij <linus.walleij@linaro.org>

 *

 * Documentation: ARM DDI 0196G == PL080

 * Documentation: ARM DDI 0218E == PL081

 * Documentation: S3C6410 User's Manual == PL080S

 *

 * PL080 & PL081 both have 16 sets of DMA signals that can be routed to any

 * channel.

 *

 * The PL080 has 8 channels available for simultaneous use, and the PL081

 * has only two channels. So on these DMA controllers the number of channels

 * and the number of incoming DMA signals are two totally different things.

 * It is usually not possible to theoretically handle all physical signals,

 * so a multiplexing scheme with possible denial of use is necessary.

 *

 * The PL080 has a dual bus master, PL081 has a single master.

 *

 * PL080S is a version modified by Samsung and used in S3C64xx SoCs.

 * It differs in following aspects:

 * - CH_CONFIG register at different offset,

 * - separate CH_CONTROL2 register for transfer size,

 * - bigger maximum transfer size,

 * - 8-word aligned LLI, instead of 4-word, due to extra CCTL2 word,

 * - no support for peripheral flow control.

 *

 * Memory to peripheral transfer may be visualized as

 *	Get data from memory to DMAC

 *	Until no data left

 *		On burst request from peripheral

 *			Destination burst from DMAC to peripheral

 *			Clear burst request

 *	Raise terminal count interrupt

 *

 * For peripherals with a FIFO:

 * Source      burst size == half the depth of the peripheral FIFO

 * Destination burst size == the depth of the peripheral FIFO

 *

 * (Bursts are irrelevant for mem to mem transfers - there are no burst

 * signals, the DMA controller will simply facilitate its AHB master.)

 *

 * ASSUMES default (little) endianness for DMA transfers

 *

 * The PL08x has two flow control settings:

 *  - DMAC flow control: the transfer size defines the number of transfers

 *    which occur for the current LLI entry, and the DMAC raises TC at the

 *    end of every LLI entry.  Observed behaviour shows the DMAC listening

 *    to both the BREQ and SREQ signals (contrary to documented),

 *    transferring data if either is active.  The LBREQ and LSREQ signals

 *    are ignored.

 *

 *  - Peripheral flow control: the transfer size is ignored (and should be

 *    zero).  The data is transferred from the current LLI entry, until

 *    after the final transfer signalled by LBREQ or LSREQ.  The DMAC

 *    will then move to the next LLI entry. Unsupported by PL080S.

/**

 * struct vendor_data - vendor-specific config parameters for PL08x derivatives

 * @config_offset: offset to the configuration register

 * @channels: the number of channels available in this variant

 * @signals: the number of request signals available from the hardware

 * @dualmaster: whether this version supports dual AHB masters or not.

 * @nomadik: whether this variant is a ST Microelectronics Nomadik, where the

 *	channels have Nomadik security extension bits that need to be checked

 *	for permission before use and some registers are missing

 * @pl080s: whether this variant is a Samsung PL080S, which has separate

 *	register and LLI word for transfer size.

 * @ftdmac020: whether this variant is a Faraday Technology FTDMAC020

 * @max_transfer_size: the maximum single element transfer size for this

 *	PL08x variant.

/**

 * struct pl08x_bus_data - information of source or destination

 * busses for a transfer

 * @addr: current address

 * @maxwidth: the maximum width of a transfer on this bus

 * @buswidth: the width of this bus in bytes: 1, 2 or 4

/**

 * struct pl08x_phy_chan - holder for the physical channels

 * @id: physical index to this channel

 * @base: memory base address for this physical channel

 * @reg_config: configuration address for this physical channel

 * @reg_control: control address for this physical channel

 * @reg_src: transfer source address register

 * @reg_dst: transfer destination address register

 * @reg_lli: transfer LLI address register

 * @reg_busy: if the variant has a special per-channel busy register,

 * this contains a pointer to it

 * @lock: a lock to use when altering an instance of this struct

 * @serving: the virtual channel currently being served by this physical

 * channel

 * @locked: channel unavailable for the system, e.g. dedicated to secure

 * world

 * @ftdmac020: channel is on a FTDMAC020

 * @pl080s: channel is on a PL08s

/**

 * struct pl08x_sg - structure containing data per sg

 * @src_addr: src address of sg

 * @dst_addr: dst address of sg

 * @len: transfer len in bytes

 * @node: node for txd's dsg_list

/**

 * struct pl08x_txd - wrapper for struct dma_async_tx_descriptor

 * @vd: virtual DMA descriptor

 * @dsg_list: list of children sg's

 * @llis_bus: DMA memory address (physical) start for the LLIs

 * @llis_va: virtual memory address start for the LLIs

 * @cctl: control reg values for current txd

 * @ccfg: config reg values for current txd

 * @done: this marks completed descriptors, which should not have their

 *   mux released.

 * @cyclic: indicate cyclic transfers

 Default cctl value for LLIs */

	/*

	 * Settings to be put into the physical channel when we

	 * trigger this txd.  Other registers are in llis_va[0].

/**

 * enum pl08x_dma_chan_state - holds the PL08x specific virtual channel

 * states

 * @PL08X_CHAN_IDLE: the channel is idle

 * @PL08X_CHAN_RUNNING: the channel has allocated a physical transport

 * channel and is running a transfer on it

 * @PL08X_CHAN_PAUSED: the channel has allocated a physical transport

 * channel, but the transfer is currently paused

 * @PL08X_CHAN_WAITING: the channel is waiting for a physical transport

 * channel to become available (only pertains to memcpy channels)

/**

 * struct pl08x_dma_chan - this structure wraps a DMA ENGINE channel

 * @vc: wrappped virtual channel

 * @phychan: the physical channel utilized by this channel, if there is one

 * @name: name of channel

 * @cd: channel platform data

 * @cfg: slave configuration

 * @at: active transaction on this channel

 * @host: a pointer to the host (internal use)

 * @state: whether the channel is idle, paused, running etc

 * @slave: whether this channel is a device (slave) or for memcpy

 * @signal: the physical DMA request signal which this channel is using

 * @mux_use: count of descriptors using this DMA request signal setting

 * @waiting_at: time in jiffies when this channel moved to waiting state

/**

 * struct pl08x_driver_data - the local state holder for the PL08x

 * @slave: optional slave engine for this instance

 * @memcpy: memcpy engine for this instance

 * @has_slave: the PL08x has a slave engine (routed signals)

 * @base: virtual memory base (remapped) for the PL08x

 * @adev: the corresponding AMBA (PrimeCell) bus entry

 * @vd: vendor data for this PL08x variant

 * @pd: platform data passed in from the platform/machine

 * @phy_chans: array of data for the physical channels

 * @pool: a pool for the LLI descriptors

 * @lli_buses: bitmask to or in to LLI pointer selecting AHB port for LLI

 * fetches

 * @mem_buses: set to indicate memory transfers on AHB2.

 * @lli_words: how many words are used in each LLI item for this variant

/*

 * PL08X specific defines

 The order of words in an LLI. */

 Total words in an LLI. */

/*

 * Number of LLIs in each LLI buffer allocated for one transfer

 * (maximum times we call dma_pool_alloc on this pool without freeing)

/*

 * Mux handling.

 *

 * This gives us the DMA request input to the PL08x primecell which the

 * peripheral described by the channel data will be routed to, possibly

 * via a board/SoC specific external MUX.  One important point to note

 * here is that this does not depend on the physical channel.

/*

 * Physical channel handling

 Whether a certain channel is busy or not */

 If we have a special busy register, take a shortcut */

/*

 * pl08x_write_lli() - Write an LLI into the DMA controller.

 *

 * The PL08x derivatives support linked lists, but the first item of the

 * list containing the source, destination, control word and next LLI is

 * ignored. Instead the driver has to write those values directly into the

 * SRC, DST, LLI and control registers. On FTDMAC020 also the SIZE

 * register need to be set up for the first transfer.

	/*

	 * The FTMAC020 has a different layout in the CCTL word of the LLI

	 * and the CCTL register which is split in CSR and SIZE registers.

	 * Convert the LLI item CCTL into the proper values to write into

	 * the CSR and SIZE registers.

 Write the transfer size (12 bits) to the size register */

		/*

		 * Then write the control bits 28..16 to the control register

		 * by shuffleing the bits around to where they are in the

		 * main register. The mapping is as follows:

		 * Bit 28: TC_MSK - mask on all except last LLI

		 * Bit 27..25: SRC_WIDTH

		 * Bit 24..22: DST_WIDTH

		 * Bit 21..20: SRCAD_CTRL

		 * Bit 19..17: DSTAD_CTRL

		 * Bit 17: SRC_SEL

		 * Bit 16: DST_SEL

		/*

		 * Set up the bits that exist in the CSR but are not

		 * part the LLI, i.e. only gets written to the control

		 * register right here.

		 *

		 * FIXME: do not just handle memcpy, also handle slave DMA.

 Protection flags */

 We are the kernel, so we are in privileged mode */

 Bits are just identical */

 Second control word on the PL080s */

/*

 * Set the initial DMA register values i.e. those for the first LLI

 * The next LLI pointer and the configuration interrupt bit have

 * been set when the LLIs were constructed.  Poke them into the hardware

 * and start the transfer.

 Wait for channel inactive */

 Enable the DMA channel */

 Do not access config register until channel shows as disabled */

 Do not access config register until channel shows as inactive */

/*

 * Pause the channel by setting the HALT bit.

 *

 * For M->P transfers, pause the DMAC first and then stop the peripheral -

 * the FIFO can only drain if the peripheral is still requesting data.

 * (note: this can still timeout if the DMAC FIFO never drains of data.)

 *

 * For P->M transfers, disable the peripheral first to stop it filling

 * the DMAC FIFO, and then pause the DMAC.

 Use the enable bit on the FTDMAC020 */

 Set the HALT bit and wait for the FIFO to drain */

 Wait for channel inactive */

 Use the enable bit on the FTDMAC020 */

 Clear the HALT bit */

/*

 * pl08x_terminate_phy_chan() stops the channel, clears the FIFO and

 * clears any pending interrupt status.  This should not be used for

 * an on-going transfer, but as a method of shutting down a channel

 * (eg, when it's no longer used) or terminating a transfer.

 The layout for the FTDMAC020 is different */

 Disable all interrupts */

 Abort and disable channel */

 Clear ABT and ERR interrupt flags */

 Plain PL08x */

 Plain PL08x */

 The channel should be paused when calling this */

	/*

	 * Follow the LLIs to get the number of remaining

	 * bytes in the currently active transaction.

 First get the remaining bytes in the active transfer */

	/*

	 * Locate the next LLI - as this is an array,

	 * it's simple maths to find.

		/*

		 * A LLI pointer going backward terminates the LLI list

/*

 * Allocate a physical channel for a virtual channel

 *

 * Try to locate a physical channel to be used for this transfer. If all

 * are taken return NULL and the requester will have to cope by using

 * some fallback PIO mode or retrying later.

 No physical channel available, cope with it */

 Mark the physical channel as free.  Note, this write is atomic. */

/*

 * Try to allocate a physical channel.  When successful, assign it to

 * this virtual channel, and initiate the next descriptor.  The

 * virtual channel lock must be held at this point.

	/*

	 * We do this without taking the lock; we're really only concerned

	 * about whether this pointer is NULL or not, and we're guaranteed

	 * that this will only be called when it _already_ is non-NULL.

/*

 * Free a physical DMA channel, potentially reallocating it to another

 * virtual channel if we have any pending.

	/*

	 * Find a waiting virtual channel for the next transfer.

	 * To be fair, time when each channel reached waiting state is compared

	 * to select channel that is waiting for the longest time.

 Ensure that the physical channel is stopped */

		/*

		 * Eww.  We know this isn't going to deadlock

		 * but lockdep probably doesn't.

 Re-check the state now that we have the lock */

 If the state changed, try to find another channel */

 No more jobs, so free up the physical channel */

/*

 * LLI handling

	/*

	 * Remove all src, dst and transfer size bits, then set the

	 * width and size according to the parameters. The bit offsets

	 * are different in the FTDMAC020 so we need to accound for this.

/*

 * Autoselect a master bus to use for the transfer. Slave will be the chosen as

 * victim in case src & dest are not similarly aligned. i.e. If after aligning

 * masters address with width requirements of transfer (by sending few byte by

 * byte data), slave is still not aligned, then its width will be reduced to

 * BYTE.

 * - prefers the destination bus if both available

 * - prefers bus with fixed address (i.e. peripheral)

	/*

	 * The FTDMAC020 only supports memory-to-memory transfer, so

	 * source and destination always increase.

	/*

	 * If either bus is not advancing, i.e. it is a peripheral, that

	 * one becomes master

/*

 * Fills in one LLI for a certain transfer descriptor and advance the counter

 Advance the offset to next LLI. */

 FIXME: only memcpy so far so both increase */

/*

 * This fills in the table of LLIs for the transfer descriptor

 * Note that we assume we never have to change the burst sizes

 * Return 0 for error

 Find maximum width of the source bus */

 Find maximum width of the destination bus */

		/*

		 * Zero length is only allowed if all these requirements are

		 * met:

		 * - flow controller is peripheral.

		 * - src.addr is aligned to src.width

		 * - dst.addr is aligned to dst.width

		 *

		 * sg_len == 1 should be true, as there can be two cases here:

		 *

		 * - Memory addresses are contiguous and are not scattered.

		 *   Here, Only one sg will be passed by user driver, with

		 *   memory address and zero length. We pass this to controller

		 *   and after the transfer it will receive the last burst

		 *   request from peripheral and so transfer finishes.

		 *

		 * - Memory addresses are scattered and are not contiguous.

		 *   Here, Obviously as DMA controller doesn't know when a lli's

		 *   transfer gets over, it can't load next lli. So in this

		 *   case, there has to be an assumption that only one lli is

		 *   supported. Thus, we can't have scattered addresses.

 FTDMAC020 only does memory-to-memory */

		/*

		 * Send byte by byte for following cases

		 * - Less than a bus width available

		 * - until master bus is aligned

			/*

			 * Master now aligned

			 * - if slave is not then we must set its width down

			/*

			 * Bytes transferred = tsize * src width, not

			 * MIN(buswidths)

			/*

			 * Make largest possible LLIs until less than one bus

			 * width left

				/*

				 * If enough left try to send max possible,

				 * otherwise try to send the remainder

				/*

				 * Check against maximum bus alignment:

				 * Calculate actual transfer size in relation to

				 * bus width an get a maximum remainder of the

				 * highest bus width - 1

			/*

			 * Send any odd bytes

 Link back to the first LLI. */

 The final LLI terminates the LLI. */

 The final LLI element shall also fire an interrupt. */

/*

 * The DMA ENGINE API

 Ensure all queued descriptors are freed */

/*

 * Code accessing dma_async_is_complete() in a tight loop may give problems.

 * If slaves are relying on interrupts to signal completion this function

 * must not be called with interrupts disabled.

	/*

	 * There's no point calculating the residue if there's

	 * no txstate to store the value.

 On the issued list, so hasn't been processed yet */

	/*

	 * This cookie not complete yet

	 * Get number of bytes left in the active transactions and queue

 Whether waiting or running, we're in progress */

 PrimeCell DMA extension */

/*

 * Given the source and destination available bus masks, select which

 * will be routed to each port.  We try to have source and destination

 * on separate ports, but always respect the allowable settings.

 The FTDMAC020 use different bits to indicate src/dst bus */

 Access the cell in privileged mode, non-bufferable, non-cacheable */

	/*

	 * If this channel will only request single transfers, set this

	 * down to ONE element.  Also select one element if no maxburst

	 * is specified.

/*

 * Slave transactions callback to the slave device to allow

 * synchronization of slave DMA signals with the DMAC enable

 Conjure cctl */

 Protection flags */

 We are the kernel, so we are in privileged mode */

 Both to be incremented or the code will break */

 Conjure cctl */

	/*

	 * By default mask the TC IRQ on all LLIs, it will be unmasked on

	 * the last LLI item by other code.

	/*

	 * Both to be incremented so leave bits FTDMAC020_LLI_SRCAD_CTL

	 * and FTDMAC020_LLI_DSTAD_CTL as zero

/*

 * Initialize a descriptor to be used by memcpy submit

 Writing CCFG zero ENABLES all interrupts */

	/*

	 * Set up addresses, the PrimeCell configured address

	 * will take precedence since this may configure the

	 * channel target address dynamically at runtime.

 Assign the flow control signal to this channel */

 Reject definitely invalid configurations */

		/*

		 * Mark physical channel as free and free any slave

		 * signal

 Dequeue jobs and free LLIs */

 Dequeue jobs not yet fired as well */

	/*

	 * Anything succeeds on channels with no physical allocation and

	 * no queued transfers.

	/*

	 * Anything succeeds on channels with no physical allocation and

	 * no queued transfers.

 Reject channels for devices not bound to this driver */

 Check that the channel is not taken! */

/*

 * Just check that the device is there and active

 * TODO: turn this bit on/off depending on the number of physical channels

 * actually used, if it is zero... well shut it off. That will save some

 * power. Cut the clock at the same time.

 The Nomadik variant does not have the config register */

 The FTDMAC020 variant does this in another register */

 check & clear - ERR & TC interrupts */

 Locate physical channel */

				/*

				 * This descriptor is done, release its mux

				 * reservation.

				/*

				 * And start the next descriptor (if any),

				 * otherwise free this channel.

/*

 * Initialise the DMAC memcpy/slave channels.

 * Make a local wrapper to hold required data

	/*

	 * Register as many many memcpy as we have physical channels,

	 * we won't always be able to use all but the code will have

	 * to cope with that situation.

			/*

			 * Some implementations have muxed signals, whereas some

			 * use a mux in front of the signals and need dynamic

			 * assignment of signals.

 Expose a simple debugfs interface to view all clocks */

 Trying to get a slave channel from something with no slave support */

 Augment channel data for applicable AHB buses */

 Eligible bus masters for fetching LLIs */

 Eligible bus masters for memory access */

 Parse the memcpy channel properties */

	/*

	 * Allocate channel data for all possible slave channels (one

	 * for each possible signal), channels will then be allocated

	 * for a device and have it's AHB interfaces set up at

	 * translation time.

			/*

			 * chanp->periph_buses will be assigned at translation

 Ensure that we can do DMA */

 Create the driver state holder */

 Assign useful pointers to the driver state */

 Vendor data from feature register */

 Initialize memcpy engine */

	/*

	 * Initialize slave engine, if the block has no signals, that means

	 * we have no slave support.

 Get the platform data */

 By default, AHB1 only.  If dualmaster, from platform */

 A DMA memory pool for LLIs, align on 1-byte boundary */

 Turn on the PL08x */

 Clear any pending interrupts */

 This variant has error IRQs in bits 16-19 */

 Attach the interrupt handler */

 Initialize physical channels */

 FTDMA020 has a special channel busy register */

		/*

		 * Nomadik variants can have channels that are locked

		 * down for the secure world only. Lock up these channels

		 * by perpetually serving a dummy virtual channel.

 Register as many memcpy channels as there are physical channels */

 Register slave channels */

 PL080 has 8 channels and the PL080 have just 2 */

 Samsung PL080S variant */

 PL080 */

 PL081 */

 Nomadik 8815 PL080 variant */

 Faraday Technology FTDMAC020 */

/*

 * MOXA ART SoCs DMA Engine support.

 *

 * Copyright (C) 2013 Jonas Jensen

 *

 * Jonas Jensen <jonas.jensen@gmail.com>

 *

 * This file is licensed under the terms of the GNU General Public

 * License version 2.  This program is licensed "as is" without any

 * warranty of any kind, whether express or implied.

/*

 * Unset: APB

 * Set:   AHB

/*

 * 000: No increment

 * 001: +1 (Burst=0), +4  (Burst=1)

 * 010: +2 (Burst=0), +8  (Burst=1)

 * 011: +4 (Burst=0), +16 (Burst=1)

 * 101: -1 (Burst=0), -4  (Burst=1)

 * 110: -2 (Burst=0), -8  (Burst=1)

 * 111: -4 (Burst=0), -16 (Burst=1)

/*

 * Request signal select source/destination address for DMA hardware handshake.

 *

 * The request line number is a property of the DMA controller itself,

 * e.g. MMC must always request channels where dma_slave_config->slave_id is 5.

 *

 * 0:    No request / Grant signal

 * 1-15: Request    / Grant signal

/*

 * Data width of transfer:

 *

 * 00: Word

 * 01: Half

 * 10: Byte

	/*

	 * There are 4 cycles on 64 bytes copied, i.e. one cycle copies 16

	 * bytes ( when width is APB_DMAB_DATA_WIDTH_4 ).

	/*

	 * dma_cookie_status() assigns initial residue value.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2012 Marvell International Ltd.

 Run Bit (read / write) */

 No-Descriptor Fetch (read / write) */

 Stop Interrupt Enable (read / write) */

 Request Pending (read-only) */

 Stop State (read-only) */

 End Interrupt (read / write) */

 Start Interrupt (read / write) */

 Bus Error Interrupt (read / write) */

 End of Receive Interrupt Enable (R/W) */

 Jump to next descriptor on EOR */

 STOP on an EOR */

 Set Descriptor Compare Status */

 Clear Descriptor Compare Status */

 The Descriptor Compare Status */

 The end of Receive */

 Map Valid (read / write) */

 mask for Channel Number (read / write) */

 Address of next descriptor (mask) */

 Stop (read / write) */

 Source Address Increment Setting. */

 Target Address Increment Setting. */

 Flow Control by the source. */

 Flow Control by the target. */

 Start Interrupt Enable */

 End Interrupt Enable */

 Device Endian-ness. */

 8 byte burst */

 16 byte burst */

 32 byte burst */

 1 byte width */

 2 byte width (HalfWord) */

 4 byte width (Word) */

 length mask (max = 8K - 1) */

 Points to the next descriptor + flags */

 DSADR value for the current transfer */

 DTADR value for the current transfer */

 DCMD value for the current transfer */

	struct mmp_pdma_desc_sw *cyclic_first;	/* first desc_sw if channel

 channel's basic info */

 list for desc */

 Descriptor list lock */

 Link descriptors queue for pending */

 Link descriptors queue for running */

 channel statue machine */

 Descriptors pool */

 protect alloc/free phy channels */

 clear irq */

 only handle interrupts belonging to pdma driver*/

 lookup free phy channel as descending priority */

	/*

	 * dma channel priorities

	 * ch 0 - 3,  16 - 19  <--> (0)

	 * ch 4 - 7,  20 - 23  <--> (1)

	 * ch 8 - 11, 24 - 27  <--> (2)

	 * ch 12 - 15, 28 - 31  <--> (3)

 clear the channel mapping in DRCMR */

/*

 * start_pending_queue - transfer any pending transactions

 * pending list ==> running list

 still in running, irq will start the pending list */

 chance to re-fetch phy channel with higher prio */

	/*

	 * pending -> running

	 * reintilize pending list

	/*

	 * Program the descriptor's address into the DMA controller,

	 * then start the DMA transaction

 desc->tx_list ==> pending list */

 softly link to pending list - desc->tx_list ==> pending list */

 each desc has submit */

/*

 * mmp_pdma_alloc_chan_resources - Allocate resources for DMA channel.

 *

 * This function will create a dma pool for descriptor allocation.

 * Request irq only when channel is requested

 * Return - The number of allocated descriptors.

 Allocate the link descriptor from DMA pool */

 Insert the link descriptor to the LD ring */

 client is in control of this ack */

 last desc and fire IRQ */

 allocate and populate the descriptor */

 Insert the link descriptor to the LD ring */

 update metadata */

 last desc and fire IRQ */

 the buffer length must be a multiple of period_len */

 Allocate the link descriptor from DMA pool */

 Insert the link descriptor to the LD ring */

 client is in control of this ack */

 make the cyclic link */

	/* FIXME: drivers should be ported over to use the filter

	 * function. Once that's done, the following two lines can

	 * be removed.

	/*

	 * If the channel does not have a phy pointer anymore, it has already

	 * been completed. Therefore, its residue is 0.

		/*

		 * 'passed' will be latched once we found the descriptor which

		 * lies inside the boundaries of the curr pointer. All

		 * descriptors that occur in the list _after_ we found that

		 * partially handled descriptor are still to be processed and

		 * are hence added to the residual bytes counter.

		/*

		 * Descriptors that have the ENDIRQEN bit set mark the end of a

		 * transaction chain, and the cookie assigned with it has been

		 * returned previously from mmp_pdma_tx_submit().

		 *

		 * In case we have multiple transactions in the running chain,

		 * and the cookie does not match the one the user asked us

		 * about, reset the state variables and start over.

		 *

		 * This logic does not apply to cyclic transactions, where all

		 * descriptors have the ENDIRQEN bit set, and for which we

		 * can't have multiple transactions on one channel anyway.

 We should only get here in case of cyclic transactions */

/*

 * mmp_pdma_issue_pending - Issue the DMA start command

 * pending list ==> running list

/*

 * dma_do_tasklet

 * Do call back

 * Start pending list

 submit pending list; callback for each desc; free desc */

		/*

		 * move the descriptors to a temporary list so we can drop

		 * the lock during the entire cleanup operation

		/*

		 * Look for the first list entry which has the ENDIRQEN flag

		 * set. That is the descriptor we got an interrupt for, so

		 * complete that transaction and its cookie.

	/*

	 * The hardware is idle and ready for more when the

	 * chain_running list is empty.

 Start any pending transactions automatically */

 Run the callback for each descriptor, in order */

 Remove from the list of transactions */

 Run the link descriptor callback function */

 register virt channel to dma engine */

 default 32 channel */

 all chan share one irq, demux inside */

 Device-tree DMA controller registration */

 SPDX-License-Identifier: GPL-2.0

 Copyright 2014-2015 Freescale

 Copyright 2018 NXP

/*

 * Driver for NXP Layerscape Queue Direct Memory Access Controller

 *

 * Author:

 *  Wen He <wen.he_1@nxp.com>

 *  Jiaheng Fan <jiaheng.fan@nxp.com>

 *

 Register related definition */

 Registers for bit and genmask */

 Size related definition */

 Field definition for CMD */

 Field definition for Descriptor status */

 Field definition for Descriptor offset */

 Field definition for safe loop count*/

/**

 * struct fsl_qdma_format - This is the struct holding describing compound

 *			    descriptor format with qDMA.

 * @status:		    Command status and enqueue status notification.

 * @cfg:		    Frame offset and frame format.

 * @addr_lo:		    Holding the compound descriptor of the lower

 *			    32-bits address in memory 40-bit address.

 * @addr_hi:		    Same as above member, but point high 8-bits in

 *			    memory 40-bit address.

 * @__reserved1:	    Reserved field.

 * @cfg8b_w1:		    Compound descriptor command queue origin produced

 *			    by qDMA and dynamic debug field.

 * @data:		    Pointer to the memory 40-bit address, describes DMA

 *			    source information and DMA destination information.

 qDMA status notification pre information */

 Head Command Descriptor(Frame Descriptor) */

 Status notification is enqueued to status queue. */

 Compound Command Descriptor(Frame List Table) */

 It must be 32 as Compound S/G Descriptor */

 This entry is the last entry. */

 Descriptor Buffer */

/*

 * Pre-request full command descriptor for enqueue.

/*

 * Request a command descriptor for enqueue.

			/*

			 * List for queue command buffer

	/*

	 * Buffer for queue command

 Disable the command queue and wait for idle state. */

 Disable status queue. */

		/*

		 * clear the command queue interrupt detect register for

		 * all queues.

		/* The completion_status is evaluated here

		 * (outside of spin lock)

 A completion error occurred! */

 Write transaction error */

 Read transaction error */

				/* Command/source/destination

				 * description error

 Clear all detected events and interrupts. */

 Try to halt the qDMA engine first. */

		/*

		 * Clear the command queue interrupt detect register for

		 * all queues.

			/*

			 * Initialize Command Queue registers to

			 * point to the first

			 * command descriptor in memory.

			 * Dequeue Pointer Address Registers

			 * Enqueue Pointer Address Registers

 Initialize the queue mode. */

		/*

		 * Workaround for erratum: ERR010812.

		 * We must enable XOFF to avoid the enqueue rejection occurs.

		 * Setting SQCCMR ENTER_WM to 0x20.

		/*

		 * Initialize status queue registers to point to the first

		 * command descriptor in memory.

		 * Dequeue Pointer Address Registers

		 * Enqueue Pointer Address Registers

 Initialize status queue interrupt. */

 Initialize the status queue mode. */

 Initialize controller interrupt register. */

	/*

	 * The dma pool for queue command buffer

	/*

	 * The dma pool for Descriptor(SD/DD) buffer

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * drivers/dma/fsl-edma.c

 *

 * Copyright 2013-2014 Freescale Semiconductor, Inc.

 *

 * Driver for the Freescale eDMA engine with flexible channel multiplexing

 * capability for DMA request sources. The eDMA block can be found on some

 * Vybrid and Layerscape SoCs.

 terminate_all called before */

	/*

	 * 16 channel independent interrupts + 1 error interrupt on i.mx7ulp.

	 * 2 channel share one interrupt, for example, ch0/ch16, ch1/ch17...

	 * For now, just simply request irq without IRQF_SHARED flag, since 16

	 * channels are enough on i.mx7ulp whose M4 domain own some peripherals.

 The last IRQ is for eDMA err */

 sentinel */ }

 on error: disable all previously enabled clks */

 on error: disable all previously enabled clks */

 on error: disable all previously enabled clks */

 Per worst case 'nbytes = 1' take CITER as the max_seg_size */

 enable round robin arbitration */

 Make sure chan is idle or will force disable. */

/*

 * eDMA provides the service to others, so it should be suspend late

 * and resume early. When eDMA suspend, all of the clients should stop

 * the DMA data transmission and let the channel idle.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * DMA Router driver for LPC18xx/43xx DMA MUX

 *

 * Copyright (C) 2015 Joachim Eastwood <manabian@gmail.com>

 *

 * Based on TI DMA Crossbar driver by:

 *   Copyright (C) 2015 Texas Instruments Incorporated - http://www.ti.com

 *   Author: Peter Ujfalusi <peter.ujfalusi@ti.com>

 CREG register offset and macros for mux manipulation */

 The of_node_put() will be done in the core for the node */

 SPDX-License-Identifier: GPL-2.0+



 drivers/dma/imx-sdma.c



 This file contains a driver for the Freescale Smart DMA engine



 Copyright 2010 Sascha Hauer, Pengutronix <s.hauer@pengutronix.de>



 Based on code from Freescale:



 Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.

 SDMA registers */

/*

 * Buffer descriptor status values.

/*

 * Data Node descriptor status values.

/*

 * IPCV2 descriptor status values.

/*

 * Error bit set in the CCB status field by the SDMA,

 * in setbd routine, in case of a transfer error

/*

 * Buffer descriptor commands.

/*

 * Change endianness indicator in the BD command field

/*

 *  p_2_p watermark_level description

 *	Bits		Name			Description

 *	0-7		Lower WML		Lower watermark level

 *	8		PS			1: Pad Swallowing

 *						0: No Pad Swallowing

 *	9		PA			1: Pad Adding

 *						0: No Pad Adding

 *	10		SPDIF			If this bit is set both source

 *						and destination are on SPBA

 *	11		Source Bit(SP)		1: Source on SPBA

 *						0: Source on AIPS

 *	12		Destination Bit(DP)	1: Destination on SPBA

 *						0: Destination on AIPS

 *	13-15		---------		MUST BE 0

 *	16-23		Higher WML		HWML

 *	24-27		N			Total number of samples after

 *						which Pad adding/Swallowing

 *						must be done. It must be odd.

 *	28		Lower WML Event(LWE)	SDMA events reg to check for

 *						LWML event mask

 *						0: LWE in EVENTS register

 *						1: LWE in EVENTS2 register

 *	29		Higher WML Event(HWE)	SDMA events reg to check for

 *						HWML event mask

 *						0: HWE in EVENTS register

 *						1: HWE in EVENTS2 register

 *	30		---------		MUST BE 0

 *	31		CONT			1: Amount of samples to be

 *						transferred is unknown and

 *						script will keep on

 *						transferring samples as long as

 *						both events are detected and

 *						script must be manually stopped

 *						by the application

 *						0: The amount of samples to be

 *						transferred is equal to the

 *						count field of mode word

/**

 * struct sdma_script_start_addrs - SDMA script start pointers

 *

 * start addresses of the different functions in the physical

 * address space of the SDMA engine.

 End of v1 array */

 End of v2 array */

 End of v3 array */

 End of v4 array */

/*

 * Mode/Count of data node descriptors - IPCv2

 size of the buffer pointed by this BD */

 E,R,I,C,W,D status bits stored here */

 command mostly used for channel 0 */

/*

 * Buffer descriptor

 address of the buffer described */

 extended buffer address */

/**

 * struct sdma_channel_control - Channel control Block

 *

 * @current_bd_ptr:	current buffer descriptor processed

 * @base_bd_ptr:	first element of buffer descriptor array

 * @unused:		padding. The SDMA engine expects an array of 128 byte

 *			control blocks

/**

 * struct sdma_state_registers - SDMA context for a channel

 *

 * @pc:		program counter

 * @unused1:	unused

 * @t:		test bit: status of arithmetic & test instruction

 * @rpc:	return program counter

 * @unused0:	unused

 * @sf:		source fault while loading data

 * @spc:	loop start program counter

 * @unused2:	unused

 * @df:		destination fault while storing data

 * @epc:	loop end program counter

 * @lm:		loop mode

/**

 * struct sdma_context_data - sdma context specific to a channel

 *

 * @channel_state:	channel state bits

 * @gReg:		general registers

 * @mda:		burst dma destination address register

 * @msa:		burst dma source address register

 * @ms:			burst dma status register

 * @md:			burst dma data register

 * @pda:		peripheral dma destination address register

 * @psa:		peripheral dma source address register

 * @ps:			peripheral dma status register

 * @pd:			peripheral dma data register

 * @ca:			CRC polynomial register

 * @cs:			CRC accumulator register

 * @dda:		dedicated core destination address register

 * @dsa:		dedicated core source address register

 * @ds:			dedicated core status register

 * @dd:			dedicated core data register

 * @scratch0:		1st word of dedicated ram for context switch

 * @scratch1:		2nd word of dedicated ram for context switch

 * @scratch2:		3rd word of dedicated ram for context switch

 * @scratch3:		4th word of dedicated ram for context switch

 * @scratch4:		5th word of dedicated ram for context switch

 * @scratch5:		6th word of dedicated ram for context switch

 * @scratch6:		7th word of dedicated ram for context switch

 * @scratch7:		8th word of dedicated ram for context switch

/**

 * struct sdma_desc - descriptor structor for one transfer

 * @vd:			descriptor for virt dma

 * @num_bd:		number of descriptors currently handling

 * @bd_phys:		physical address of bd

 * @buf_tail:		ID of the buffer that was processed

 * @buf_ptail:		ID of the previous buffer that was processed

 * @period_len:		period length, used in cyclic.

 * @chn_real_count:	the real count updated from bd->mode.count

 * @chn_count:		the transfer count set

 * @sdmac:		sdma_channel pointer

 * @bd:			pointer of allocate bd

/**

 * struct sdma_channel - housekeeping for a SDMA channel

 *

 * @vc:			virt_dma base structure

 * @desc:		sdma description including vd and other special member

 * @sdma:		pointer to the SDMA engine for this channel

 * @channel:		the channel number, matches dmaengine chan_id + 1

 * @direction:		transfer type. Needed for setting SDMA script

 * @slave_config:	Slave configuration

 * @peripheral_type:	Peripheral type. Needed for setting SDMA script

 * @event_id0:		aka dma request line

 * @event_id1:		for channels that use 2 events

 * @word_size:		peripheral access size

 * @pc_from_device:	script address for those device_2_memory

 * @pc_to_device:	script address for those memory_2_device

 * @device_to_device:	script address for those device_2_device

 * @pc_to_pc:		script address for those memory_2_memory

 * @flags:		loop mode or not

 * @per_address:	peripheral source or destination address in common case

 *                      destination address in p_2_p case

 * @per_address2:	peripheral source address in p_2_p case

 * @event_mask:		event mask used in p_2_p script

 * @watermark_level:	value for gReg[7], some script will extend it from

 *			basic watermark such as p_2_p

 * @shp_addr:		value for gReg[6]

 * @per_addr:		value for gReg[2]

 * @status:		status of dma channel

 * @context_loaded:	ensure context is only loaded once

 * @data:		specific sdma interface structure

 * @bd_pool:		dma_pool for bd

 * @terminate_worker:	used to call back into terminate work function

/**

 * struct sdma_firmware_header - Layout of the firmware image

 *

 * @magic:		"SDMA"

 * @version_major:	increased whenever layout of struct

 *			sdma_script_start_addrs changes.

 * @version_minor:	firmware minor version (for binary compatible changes)

 * @script_addrs_start:	offset of struct sdma_script_start_addrs in this image

 * @num_script_addrs:	Number of script addresses in this image

 * @ram_code_start:	offset of SDMA ram image in this firmware image

 * @ram_code_size:	size of SDMA ram image

 * @script_addrs:	Stores the start address of the SDMA scripts

 *			(in SDMA memory space)

	/*

	 * ecspi ERR009165 fixed should be done in sdma script

	 * and it has been fixed in soc from i.mx6ul.

	 * please get more information from the below link:

	 * https://www.nxp.com/docs/en/errata/IMX6DQCE.pdf

 clock ratio for AHB:SDMA core. 1:1 is 1, 2:1 is 0*/

 sentinel */ }

 indicates if the DSPDMA is used */

 indicates if Real-Time Debug pins are enabled */

 indicates if AHB freq /core freq = 2 or 1 */

 indicates which context switch mode is selected*/

/*

 * sdma_run_channel0 - run a channel and wait till it's done

 Set bits of CONFIG register with dynamic context switching */

	/*

	 * loop mode. Iterate over descriptors, re-setup them and

	 * call callback function.

	       /*

		* We use bd->mode.count to calculate the residue, since contains

		* the number of bytes present in the current buffer descriptor.

		/*

		 * The callback is called from the interrupt context in order

		 * to reduce latency and to avoid the risk of altering the

		 * SDMA transaction status by the time the client tasklet is

		 * executed.

	/*

	 * non loop mode. Iterate over all descriptors, collect

	 * errors and call callback function

 channel 0 is special and not handled here, see run_channel0() */

/*

 * sets the pc of SDMA script according to the peripheral type

	/*

	 * These are needed once we start to support transfers between

	 * two peripherals or memory-to-memory transfers

 Use rom script mcu_2_app if ERR009165 fixed */

	/* Send by context the event mask,base address for peripheral

	 * and watermark level

	/*

	 * According to NXP R&D team a delay of one BD SDMA cost time

	 * (maximum is 1ms) should be added after disable of the channel

	 * bit, to ensure SDMA core has really been stopped after SDMA

	 * clients call .device_terminate_all.

		/*

		 * move out current descriptor into terminated list so that

		 * it could be free in sdma_channel_terminate_work alone

		 * later without potential involving next descriptor raised

		 * up before the last descriptor terminated.

	/*

	 * If LWML(src_maxburst) > HWML(dst_maxburst), we need

	 * swap LWML and HWML of INFO(A.3.2.5.1), also need swap

	 * r0(event_mask[1]) and r1(event_mask[0]).

 Handle multiple event channels differently */

 Address */

 FIXME: M3_BASE_ADDRESS */

	/*

	 * MEMCPY may never setup chan->private by filter function such as

	 * dmatest, thus create 'struct imx_dma_data mem_data' for this case.

	 * Please note in any other slave case, you have to setup chan->private

	 * with 'struct imx_dma_data' in your own filter function if you want to

	 * request dma channel by dma_request_channel() rather than

	 * dma_request_slave_channel(). Othwise, 'MEMCPY in case?' will appear

	 * to warn you to correct your filter function.

 No slave_config called in MEMCPY case, so do here */

 last bd */

 Set ENBLn earlier to make sure dma request triggered after that */

 use the default firmware in ROM if missing external firmware */

	/*

	 * get uart_2_mcu_addr/uartsh_2_mcu_addr rom script specially because

	 * they are now replaced by uart_2_mcu_ram_addr/uartsh_2_mcu_ram_addr

	 * to be compatible with legacy freescale/nxp sdma firmware, and they

	 * are located in the bottom part of sdma_script_start_addrs which are

	 * beyond the SDMA_SCRIPT_ADDRS_ARRAY_SIZE_V1.

 In this case we just use the ROM firmware. */

 download the RAM image for SDMA */

 Be sure SDMA has not started yet */

 disable all channels */

 All channels have priority 0 */

 Set Command Channel (Channel Zero) */

 Set bits of CONFIG register but with static context switching */

 Initializes channel's priorities */

	/*

	 * init dma_request2 to zero, which is not used by the dts.

	 * For P2P, dma_request2 is init from dma_request_channel(),

	 * chan->private will point to the imx_dma_data, and in

	 * device_alloc_chan_resources(), imx_dma_data.dma_request2 will

	 * be set to sdmac->event_id1.

 initially no scripts available */

 Initialize channel parameters */

		/*

		 * Add the channel to the DMAC list. Do not add channel 0 though

		 * because we need it internally in the SDMA driver. This also means

		 * that channel 0 in dmaengine counting matches sdma channel 1.

	/*

	 * Because that device tree does not encode ROM script address,

	 * the RAM script in firmware is mandatory for device tree

	 * probe, otherwise it fails.

 Kill the tasklet */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2015 Robert Jarzmik <robert.jarzmik@free.fr>

 Run Bit (read / write) */

 No-Descriptor Fetch (read / write) */

 Stop Interrupt Enable (R/W) */

 Request Pending (read-only) */

 Stop State (read-only) */

 End Interrupt (read / write) */

 Start Interrupt (read / write) */

 Bus Error Interrupt (read / write) */

 End of Receive IRQ Enable (R/W) */

 Jump to next descriptor on EOR */

 STOP on an EOR */

 Set Descriptor Compare Status */

 Clear Descriptor Compare Status */

 The Descriptor Compare Status */

 The end of Receive */

 Map Valid (read / write) */

 mask for Channel Number (read / write) */

 Address of next descriptor (mask) */

 Stop (read / write) */

 Source Address Increment Setting. */

 Target Address Increment Setting. */

 Flow Control by the source. */

 Flow Control by the target. */

 Start Interrupt Enable */

 End Interrupt Enable */

 Device Endian-ness. */

 8 byte burst */

 16 byte burst */

 32 byte burst */

 1 byte width */

 2 byte width (HalfWord) */

 4 byte width (Word) */

 length mask (max = 8K - 1) */

 Points to the next descriptor + flags */

 DSADR value for the current transfer */

 DTADR value for the current transfer */

 DCMD value for the current transfer */

 Virtual descriptor */

 Number of hw. descriptors */

 Number of bytes xfered */

 First descriptor's addr */

 At least one descriptor has an src/dst address not multiple of 8 */

 Channel's used allocator */

 DMA coherent descriptors */

 Virtual channel */

 Requestor of the channel */

 Required priority of phy */

	/*

	 * At least one desc_sw in submitted or issued transfers on this channel

	 * has one address such as: addr % 8 != 0. This implies the DALGN

	 * setting on the phy.

 Runtime config */

 protected by vc->lock */

 Descriptors pool */

 Phy association */

/*

 * Debug fs

 basic device status */

	/*

	 * dma channel priorities

	 * ch 0 - 3,  16 - 19  <--> (0)

	 * ch 4 - 7,  20 - 23  <--> (1)

	 * ch 8 - 11, 24 - 27  <--> (2)

	 * ch 12 - 15, 28 - 31  <--> (3)

 clear the channel mapping in DRCMR */

	/*

	 * Program the descriptor's address into the DMA controller,

	 * then start the DMA transaction

	/*

	 * Attempt to hot chain the tx if the phy is still running. This is

	 * considered successful only if either the channel is still running

	 * after the chaining, or if the chained transfer is completed after

	 * having been hot chained.

	 * A change of alignment is not allowed, and forbids hotchaining.

 clear irq */

	/*

	 * Fallback to placing the tx in the submitted queue

		/*

		 * Only chain the descriptors if no new misalignment is

		 * introduced. If a new misalignment is chained, let the channel

		 * stop, and be relaunched in misalign mode from the irq

		 * handler.

	/* FIXME: drivers should be ported over to use the filter

	 * function. Once that's done, the following two lines can

	 * be removed.

 the buffer length must be a multiple of period_len */

	/*

	 * If the channel does not have a phy pointer anymore, it has already

	 * been completed. Therefore, its residue is 0.

	/*

	 * curr has to be actually read before checking descriptor

	 * completion, so that a curr inside a status updater

	 * descriptor implies the following test returns true, and

	 * preventing reordering of curr load and the test.

		/*

		 * 'passed' will be latched once we found the descriptor

		 * which lies inside the boundaries of the curr

		 * pointer. All descriptors that occur in the list

		 * _after_ we found that partially handled descriptor

		 * are still to be processed and are hence added to the

		 * residual bytes counter.

 default 32 channel */

 Device-tree DMA controller registration */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Applied Micro X-Gene SoC DMA engine Driver

 *

 * Copyright (c) 2015, Applied Micro Circuits Corporation

 * Authors: Rameshwar Prasad Sahu <rsahu@apm.com>

 *	    Loc Ho <lho@apm.com>

 *

 * NOTE: PM support is currently not available.

 X-Gene DMA ring csr registers and bit definations */

 X-Gene DMA device csr registers and bit definitions */

 X-Gene SoC EFUSE csr register and bit defination */

 X-Gene DMA Descriptor format */

 X-Gene DMA descriptor empty s/w signature */

 X-Gene DMA configurable parameters defines */

 32 Bytes */

 16 KB */

 80 KB */

 X-Gene DMA descriptor error codes */

 X-Gene DMA error interrupt codes */

 X-Gene DMA flyby operation code */

 X-Gene DMA SW descriptor flags */

 Define to dump X-Gene DMA descriptor */

/**

 * struct xgene_dma_chan - internal representation of an X-Gene DMA channel

 * @dma_chan: dmaengine channel object member

 * @pdma: X-Gene DMA device structure reference

 * @dev: struct device reference for dma mapping api

 * @id: raw id of this channel

 * @rx_irq: channel IRQ

 * @name: name of X-Gene DMA channel

 * @lock: serializes enqueue/dequeue operations to the descriptor pool

 * @pending: number of transaction request pushed to DMA controller for

 *	execution, but still waiting for completion,

 * @max_outstanding: max number of outstanding request we can push to channel

 * @ld_pending: descriptors which are queued to run, but have not yet been

 *	submitted to the hardware for execution

 * @ld_running: descriptors which are currently being executing by the hardware

 * @ld_completed: descriptors which have finished execution by the hardware.

 *	These descriptors have already had their cleanup actions run. They

 *	are waiting for the ACK bit to be set by the async tx API.

 * @desc_pool: descriptor pool for DMA operations

 * @tasklet: bottom half where all completed descriptors cleans

 * @tx_ring: transmit ring descriptor that we use to prepare actual

 *	descriptors for further executions

 * @rx_ring: receive ring descriptor that we use to get completed DMA

 *	descriptors during cleanup time

/**

 * struct xgene_dma - internal representation of an X-Gene DMA device

 * @dev: reference to this device's struct device

 * @clk: reference to this device's clock

 * @err_irq: DMA error irq number

 * @ring_num: start id number for DMA ring

 * @csr_dma: base for DMA register access

 * @csr_ring: base for DMA ring register access

 * @csr_ring_cmd: base for DMA ring command register access

 * @csr_efuse: base for efuse register access

 * @dma_dev: embedded struct dma_device

 * @chan: reference to X-Gene DMA channels

 Dummy */

 Dummy */

 Initialize DMA descriptor */

 Set destination address */

 We have multiple source addresses, so need to set NV bit*/

 Set flyby opcode */

 Set 1st to 5th source addresses */

 Update meta data */

 We need always 64B descriptor to perform xor or pq operations */

 Add this transaction list onto the tail of the pending queue */

/**

 * xgene_dma_clean_completed_descriptor - free all descriptors which

 * has been completed and acked

 * @chan: X-Gene DMA channel

 *

 * This function is used on all completed and acked descriptors.

 Run the callback for each descriptor, in order */

/**

 * xgene_dma_run_tx_complete_actions - cleanup a single link descriptor

 * @chan: X-Gene DMA channel

 * @desc: descriptor to cleanup and free

 *

 * This function is used on a descriptor which has been executed by the DMA

 * controller. It will run any callbacks, submit any dependencies.

	/*

	 * If this is not the last transaction in the group,

	 * then no need to complete cookie and run any callback as

	 * this is not the tx_descriptor which had been sent to caller

	 * of this DMA request

 Run the link descriptor callback function */

 Run any dependencies */

/**

 * xgene_dma_clean_running_descriptor - move the completed descriptor from

 * ld_running to ld_completed

 * @chan: X-Gene DMA channel

 * @desc: the descriptor which is completed

 *

 * Free the descriptor directly if acked by async_tx api,

 * else move it to queue ld_completed.

 Remove from the list of running transactions */

	/*

	 * the client is allowed to attach dependent operations

	 * until 'ack' is set

		/*

		 * Move this descriptor to the list of descriptors which is

		 * completed, but still awaiting the 'ack' bit to be set.

 Get hw descriptor from DMA tx ring */

	/*

	 * Increment the head count to point next

	 * descriptor for next time

 Copy prepared sw descriptor data to hw descriptor */

	/*

	 * Check if we have prepared 64B descriptor,

	 * in this case we need one more hw descriptor

 Increment the pending transaction count */

 Notify the hw that we have descriptor ready for execution */

/**

 * xgene_chan_xfer_ld_pending - push any pending transactions to hw

 * @chan : X-Gene DMA channel

 *

 * LOCKING: must hold chan->lock

	/*

	 * If the list of pending descriptors is empty, then we

	 * don't need to do any work at all

	/*

	 * Move elements from the queue of pending transactions onto the list

	 * of running transactions and push it to hw for further executions

		/*

		 * Check if have pushed max number of transactions to hw

		 * as capable, so let's stop here and will push remaining

		 * elements from pening ld queue after completing some

		 * descriptors that we have already pushed

		/*

		 * Delete this element from ld pending queue and append it to

		 * ld running queue

/**

 * xgene_dma_cleanup_descriptors - cleanup link descriptors which are completed

 * and move them to ld_completed to free until flag 'ack' is set

 * @chan: X-Gene DMA channel

 *

 * This function is used on descriptors which have been executed by the DMA

 * controller. It will run any callbacks, submit any dependencies, then

 * free these descriptors if flag 'ack' is set.

 Clean already completed and acked descriptors */

 Move all completed descriptors to ld completed queue, in order */

 Get subsequent hw descriptor from DMA rx ring */

 Check if this descriptor has been completed */

 Check if we have any error with DMA transactions */

 Print the DMA error type */

			/*

			 * We have DMA transactions error here. Dump DMA Tx

 Notify the hw about this completed descriptor */

 Mark this hw descriptor as processed */

		/*

		 * Decrement the pending transaction count

		 * as we have processed one

		/*

		 * Delete this node from ld running queue and append it to

		 * ld completed queue for further processing

	/*

	 * Start any pending transactions automatically

	 * In the ideal case, we keep the DMA controller busy while we go

	 * ahead and free the descriptors below.

 Run the callback for each descriptor, in order */

 Has this channel already been allocated? */

/**

 * xgene_dma_free_desc_list - Free all descriptors in a queue

 * @chan: X-Gene DMA channel

 * @list: the list to free

 *

 * LOCKING: must hold chan->lock

 Process all running descriptor */

 Clean all link descriptor queues */

 Delete this channel DMA pool */

 Allocate the link descriptor from DMA pool */

 Prepare xor DMA descriptor */

 Insert the link descriptor to the LD ring */

 client is in control of this ack */

	/*

	 * Save source addresses on local variable, may be we have to

	 * prepare two descriptor to generate P and Q if both enabled

	 * in the flags by client

 Allocate the link descriptor from DMA pool */

 Insert the link descriptor to the LD ring */

		/*

		 * Prepare DMA descriptor to generate P,

		 * if DMA_PREP_PQ_DISABLE_P flag is not set

		/*

		 * Prepare DMA descriptor to generate Q,

		 * if DMA_PREP_PQ_DISABLE_Q flag is not set

 client is in control of this ack */

 Run all cleanup for descriptors which have been completed */

 Re-enable DMA channel IRQ */

	/*

	 * Disable DMA channel IRQ until we process completed

	 * descriptors

	/*

	 * Schedule the tasklet to handle all cleanup of the current

	 * transaction. It will start a new transaction if there is

	 * one pending.

 Clear DMA interrupts */

 Print DMA error info */

 Clear DMA ring state */

 Set DMA ring type */

 Set recombination buffer and timeout */

 Initialize DMA ring state */

 Write DMA ring configurations */

 Set DMA ring id */

 Set DMA ring buffer */

 Set empty signature to DMA Rx ring descriptors */

 Enable DMA Rx ring interrupt */

 Disable DMA Rx ring interrupt */

 Clear DMA ring state */

 Clear DMA ring configurations */

 De-allocate DMA ring descriptor */

 Setup DMA ring descriptor variables */

 Allocate memory for DMA ring descriptor */

 Configure and enable DMA ring */

 Create DMA Rx ring descriptor */

 Create DMA Tx ring descriptor */

 Set the max outstanding request possible to this channel */

 Configure and enable DMA engine */

	/*

	 * Mask DMA ring overflow, underflow and

	 * AXI write/read error interrupts

 Mask DMA error interrupts */

	/*

	 * Unmask DMA ring overflow, underflow and

	 * AXI write/read error interrupts

 Unmask DMA error interrupts */

 Associate DMA ring to corresponding ring HW */

 Configure RAID6 polynomial control setting */

 Get DMA id and version info */

 DMA device info */

 Bring up memory */

 Force a barrier */

 reset may take up to 1ms */

 program threshold set 1 and all hysteresis */

 Enable QPcore and assign error queue */

 Bring up memory */

 Force a barrier */

 reset may take up to 1ms */

 Register DMA error irq */

 Register DMA channel rx irq */

 Free DMA device error irq */

 Initialize DMA device capability mask */

 Set DMA device capability */

	/* Basically here, the X-Gene SoC DMA engine channel 0 supports XOR

	 * and channel 1 supports XOR, PQ both. First thing here is we have

	 * mechanism in hw to enable/disable PQ/XOR supports on channel 1,

	 * we can make sure this by reading SoC Efuse register.

	 * Second thing, we have hw errata that if we run channel 0 and

	 * channel 1 simultaneously with executing XOR and PQ request,

	 * suddenly DMA engine hangs, So here we enable XOR on channel 0 only

	 * if XOR and PQ supports on channel 1 is disabled.

 Set base and prep routines */

 Setup dma device capabilities and prep routines */

 Initialize DMA device list head */

 Register with Linux async DMA framework*/

 DMA capability info */

 Get DMA csr region */

 Get DMA ring csr region */

 Get DMA ring cmd csr region */

 Get efuse csr region */

 Get DMA error interrupt */

 Get DMA Rx ring descriptor interrupts for all DMA channels */

 Enable clk before accessing registers */

 Remove DMA RAM out of shutdown */

 Initialize DMA channels software state */

 Configue DMA rings */

 Configure and enable DMA engine */

 Register DMA device with linux async framework */

 Mask interrupts and disable DMA engine */

 SPDX-License-Identifier: GPL-2.0

/*

 * External DMA controller driver for UniPhier SoCs

 * Copyright 2019 Socionext Inc.

 * Author: Kunihiko Hayashi <hayashi.kunihiko@socionext.com>

 cut lower bit for maintain alignment of maximum transfer size */

 xc->vc.lock must be held by caller */

 xc->vc.lock must be held by caller */

	/*

	 * The width of MEM side must be 4 or 8 bytes, that does not

	 * affect that of DEV side and transfer size.

 setup transfer factor */

 setup the channel */

 enable interrupt */

 start XDMAC */

 xc->vc.lock must be held by caller */

 disable interrupt */

 stop XDMAC */

 wait until transfer is stopped */

 xc->vc.lock must be held by caller */

 set desc to chan regardless of xd is null */

 write bits to clear */

		/*

		 * Currently transfer that size doesn't align the unit size

		 * (the number of burst words * bus-width) is not allowed,

		 * because the driver does not support the way to transfer

		 * residue size. As a matter of fact, in order to transfer

		 * arbitrary size, 'src_maxburst' or 'dst_maxburst' of

		 * dma_slave_config must be 1.

	/*

	 * Before reaching here, almost all descriptors have been freed by the

	 * ->device_free_chan_resources() hook. However, each channel might

	 * be still holding one descriptor that was on-flight at that moment.

	 * Terminate it to make sure this hardware is no longer running. Then,

	 * free the channel resources once again to avoid memory leak.

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * DMA driver for STMicroelectronics STi FDMA controller

 *

 * Copyright (C) 2014 STMicroelectronics

 *

 * Author: Ludovic Barre <Ludovic.barre@st.com>

 *	   Peter Griffin <peter.griffin@linaro.org>

	/*

	 * dreq_mask is shared for n channels of fdma, so all accesses must be

	 * atomic. if the dreq_mask is changed between ffz and set_bit,

	 * we retry

 start the channel for the descriptor */

 Start the next descriptor (if available) */

 Create the dma pool for descriptor allocation */

 We only require a single descriptor */

 the buffer length must be a multiple of period_len */

 interrupt at end of last node */

 Initialise list of FDMA channels */

 Initialise the FDMA dreq (reserve 0 & 31 for FDMA use) */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Driver for the Analog Devices AXI-DMAC core

 *

 * Copyright 2013-2019 Analog Devices Inc.

 *  Author: Lars-Peter Clausen <lars@metafoo.de>

/*

 * The AXI-DMAC is a soft IP core that is used in FPGA designs. The core has

 * various instantiation parameters which decided the exact feature set support

 * by the core.

 *

 * Each channel of the core has a source interface and a destination interface.

 * The number of channels and the type of the channel interfaces is selected at

 * configuration time. A interface can either be a connected to a central memory

 * interconnect, which allows access to system memory, or it can be connected to

 * a dedicated bus which is directly connected to a data port on a peripheral.

 * Given that those are configuration options of the core that are selected when

 * it is instantiated this means that they can not be changed by software at

 * runtime. By extension this means that each channel is uni-directional. It can

 * either be device to memory or memory to device, but not both. Also since the

 * device side is a dedicated data bus only connected to a single peripheral

 * there is no address than can or needs to be configured for the device side.

 The maximum ID allocated by the hardware is 31 */

 Not aligned */

 Not aligned */

 Queue is full, wait for the next SOT IRQ */

 Already queued in cyclic mode. Wait for it to finish */

 Start again */

	/*

	 * If the hardware supports cyclic transfers and there is no callback to

	 * call and only a single segment, enable hw cyclic mode to avoid

	 * unnecessary interrupts.

 Check if we have any more partial transfers */

	/*

	 * We get here if the last completed segment is partial, which

	 * means we can compute the residue from that segment onwards

 Not yet submitted */

 wrap around */

 One or more transfers have finished */

 Space has become available in the descriptor queue */

 Split into multiple equally sized segments if necessary */

 Take care of alignment */

/*

 * The configuration stored in the devicetree matches the configuration

 * parameters of the peripheral instance and allows the driver to know which

 * features are implemented and how it should behave.

 We only support 1 channel for now */

 widths are stored in log2 */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * IMG Multi-threaded DMA Controller (MDC)

 *

 * Copyright (C) 2009,2012,2013 Imagination Technologies Ltd.

 * Copyright (C) 2014 Google, Inc.

	/*

	 * Not part of the list descriptor, but instead used by the CPU to

	 * traverse the list.

		/*

		 * Determine the number of commands that haven't been

		 * processed (handled by the IRQ handler) yet.

		/*

		 * If the command loaded event hasn't been processed yet, then

		 * the difference above includes an extra command.

	/*

	 * CMDS_DONE may have incremented between reading CMDS_PROCESSED

	 * and clearing INT_ACTIVE.  Re-read CMDS_PROCESSED to ensure we

	 * didn't miss a command completion.

		/*

		 * The first interrupt in a transfer indicates that the

		 * command list has been loaded, not that a command has

		 * been completed.

	/*

	 * Although transfer sizes of up to MDC_TRANSFER_SIZE_MASK + 1 bytes

	 * are supported, this makes it possible for the value reported in

	 * MDC_ACTIVE_TRANSFER_SIZE to be ambiguous - an active transfer size

	 * of MDC_TRANSFER_SIZE_MASK may indicate either that 0 bytes or

	 * MDC_TRANSFER_SIZE_MASK + 1 bytes are remaining.  To eliminate this

	 * ambiguity, restrict transfer sizes to one bus-width less than the

	 * actual maximum.

 Check that all channels are idle */

 CONFIG_PM_SLEEP */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Driver for the Atmel AHB DMA Controller (aka HDMA or DMAC on AT91 systems)

 *

 * Copyright (C) 2008 Atmel Corporation

 *

 * This supports the Atmel AHB DMA Controller found in several Atmel SoCs.

 * The only Atmel DMA Controller that is not covered by this driver is the one

 * found on AT91SAM9263.

/*

 * Glossary

 * --------

 *

 * at_hdmac		: Name of the ATmel AHB DMA Controller

 * at_dma_ / atdma	: ATmel DMA controller entity related

 * atc_	/ atchan	: ATmel DMA Channel entity related

/*

 * Initial number of descriptors to allocate for each channel. This could

 * be increased during dma usage.

/**

 * struct at_dma_platform_data - Controller configuration parameters

 * @nr_channels: Number of channels supported by hardware (max 8)

 * @cap_mask: dma_capability flags supported by the platform

/**

 * struct at_dma_slave - Controller-specific information about a slave

 * @dma_dev: required DMA master device

 * @cfg: Platform-specific initializer for the CFG register

 prototypes */

----------------------------------------------------------------------*/

/**

 * atc_alloc_descriptor - allocate and return an initialized descriptor

 * @chan: the channel to allocate descriptors for

 * @gfp_flags: GFP allocation flags

 *

 * Note: The ack-bit is positioned in the descriptor flag at creation time

 *       to make initial allocation more convenient. This bit will be cleared

 *       and control will be given to client at usage time (during

 *       preparation functions).

 txd.flags will be overwritten in prep functions */

/**

 * atc_desc_get - get an unused descriptor from free_list

 * @atchan: channel we want a new descriptor for

 no more descriptor available in initial pool: create one more */

/**

 * atc_desc_put - move a descriptor, including any children, to the free list

 * @atchan: channel we work on

 * @desc: descriptor, at the head of a chain, to move to free list

/**

 * atc_desc_chain - build chain adding a descriptor

 * @first: address of first descriptor of the chain

 * @prev: address of previous descriptor of the chain

 * @desc: descriptor to queue

 *

 * Called from prep_* functions

 inform the HW lli about chaining */

 insert the link descriptor to the LD ring */

/**

 * atc_dostart - starts the DMA engine for real

 * @atchan: the channel we want to start

 * @first: first descriptor in the list we want to begin with

 *

 * Called with atchan->lock held and bh disabled

 ASSERT:  channel is idle */

 The tasklet will hopefully advance the queue... */

/*

 * atc_get_desc_by_cookie - get the descriptor of a cookie

 * @atchan: the DMA channel

 * @cookie: the cookie to get the descriptor for

/**

 * atc_calc_bytes_left - calculates the number of bytes left according to the

 * value read from CTRLA.

 *

 * @current_len: the number of bytes left before reading CTRLA

 * @ctrla: the value of CTRLA

	/*

	 * According to the datasheet, when reading the Control A Register

	 * (ctrla), the Buffer Transfer Size (btsize) bitfield refers to the

	 * number of transfers completed on the Source Interface.

	 * So btsize is always a number of source width transfers.

/**

 * atc_get_bytes_left - get the number of bytes residue for a cookie

 * @chan: DMA channel

 * @cookie: transaction identifier to check status of

	/*

	 * If the cookie doesn't match to the currently running transfer then

	 * we can return the total length of the associated DMA transfer,

	 * because it is still queued.

 cookie matches to the currently running transfer */

 hardware linked list transfer */

		/*

		 * Calculate the residue by removing the length of the child

		 * descriptors already transferred from the total length.

		 * To get the current child descriptor we can use the value of

		 * the channel's DSCR register and compare it against the value

		 * of the hardware linked list structure of each child

		 * descriptor.

		 *

		 * The CTRLA register provides us with the amount of data

		 * already read from the source for the current child

		 * descriptor. So we can compute a more accurate residue by also

		 * removing the number of bytes corresponding to this amount of

		 * data.

		 *

		 * However, the DSCR and CTRLA registers cannot be read both

		 * atomically. Hence a race condition may occur: the first read

		 * register may refer to one child descriptor whereas the second

		 * read may refer to a later child descriptor in the list

		 * because of the DMA transfer progression inbetween the two

		 * reads.

		 *

		 * One solution could have been to pause the DMA transfer, read

		 * the DSCR and CTRLA then resume the DMA transfer. Nonetheless,

		 * this approach presents some drawbacks:

		 * - If the DMA transfer is paused, RX overruns or TX underruns

		 *   are more likey to occur depending on the system latency.

		 *   Taking the USART driver as an example, it uses a cyclic DMA

		 *   transfer to read data from the Receive Holding Register

		 *   (RHR) to avoid RX overruns since the RHR is not protected

		 *   by any FIFO on most Atmel SoCs. So pausing the DMA transfer

		 *   to compute the residue would break the USART driver design.

		 * - The atc_pause() function masks interrupts but we'd rather

		 *   avoid to do so for system latency purpose.

		 *

		 * Then we'd rather use another solution: the DSCR is read a

		 * first time, the CTRLA is read in turn, next the DSCR is read

		 * a second time. If the two consecutive read values of the DSCR

		 * are the same then we assume both refers to the very same

		 * child descriptor as well as the CTRLA value read inbetween

		 * does. For cyclic tranfers, the assumption is that a full loop

		 * is "not so fast".

		 * If the two DSCR values are different, we read again the CTRLA

		 * then the DSCR till two consecutive read values from DSCR are

		 * equal or till the maxium trials is reach.

		 * This algorithm is very unlikely not to find a stable value for

		 * DSCR.

 ensure DSCR is read before CTRLA */

 ensure DSCR is read after CTRLA */

			/*

			 * If the DSCR register value has not changed inside the

			 * DMA controller since the previous read, we assume

			 * that both the dscr and ctrla values refers to the

			 * very same descriptor.

			/*

			 * DSCR has changed inside the DMA controller, so the

			 * previouly read value of CTRLA may refer to an already

			 * processed descriptor hence could be outdated.

			 * We need to update ctrla to match the current

			 * descriptor.

 ensure DSCR is read before CTRLA */

 for the first descriptor we can be more accurate */

		/*

		 * For the current descriptor in the chain we can calculate

		 * the remaining bytes using the channel's register.

 single transfer */

/**

 * atc_chain_complete - finish work for one transaction chain

 * @atchan: channel we work on

 * @desc: descriptor at the head of the chain we want do complete

 mark the descriptor as complete for non cyclic cases only */

 If the transfer was a memset, free our temporary buffer */

 move children to free_list */

 move myself to free_list */

	/* for cyclic transfers,

/**

 * atc_complete_all - finish work for all transactions

 * @atchan: channel to complete transactions for

 *

 * Eventually submit queued descriptors if any

 *

 * Assume channel is idle while calling this function

 * Called with atchan->lock held and bh disabled

	/*

	 * Submit queued descriptors ASAP, i.e. before we go through

	 * the completed ones.

 empty active_list now it is completed */

 empty queue list by moving descriptors (if any) to active_list */

/**

 * atc_advance_work - at the end of a transaction, move forward

 * @atchan: channel where the transaction ended

 advance work */

/**

 * atc_handle_error - handle errors reported by DMA controller

 * @atchan: channel where error occurs

	/*

	 * The descriptor currently at the head of the active list is

	 * broked. Since we don't have any way to report errors, we'll

	 * just have to scream loudly and try to carry on.

	/* As we are stopped, take advantage to push queued descriptors

 Try to restart the controller */

	/*

	 * KERN_CRITICAL may seem harsh, but since this only happens

	 * when someone submits a bad physical address in a

	 * descriptor, we should consider ourselves lucky that the

	 * controller flagged an error instead of scribbling over

	 * random memory locations.

 Pretend the descriptor completed successfully */

/**

 * atc_handle_cyclic - at the end of a period, run callback function

 * @atchan: channel used for cyclic operations

--  IRQ & Tasklet  ---------------------------------------------------*/

 Disable channel on AHB error */

 Give information to tasklet */

--  DMA Engine API  --------------------------------------------------*/

/**

 * atc_tx_submit - set the prepared descriptor(s) to be executed by the engine

 * @tx: descriptor at the head of the transaction chain

 *

 * Queue chain if DMA engine is working already

 *

 * Cookie increment and adding to active_list or queue must be atomic

/**

 * atc_prep_dma_interleaved - prepare memory to memory interleaved operation

 * @chan: the channel to prepare operation on

 * @xt: Interleaved transfer template

 * @flags: tx descriptor status flags

	/*

	 * The controller can only "skip" X bytes every Y bytes, so we

	 * need to make sure we are given a template that fit that

	 * description, ie a template with chunks that always have the

	 * same size, with the same ICGs.

 create the transfer */

 set end-of-link to the last link descriptor of list*/

 client is in control of this ack */

/**

 * atc_prep_dma_memcpy - prepare a memcpy operation

 * @chan: the channel to prepare operation on

 * @dest: operation virtual destination address

 * @src: operation virtual source address

 * @len: operation length

 * @flags: tx descriptor status flags

	/*

	 * We can be a lot more clever here, but this should take care

	 * of the most common optimization.

 First descriptor of the chain embedds additional information */

 set end-of-link to the last link descriptor of list*/

 client is in control of this ack */

/**

 * atc_prep_dma_memset - prepare a memcpy operation

 * @chan: the channel to prepare operation on

 * @dest: operation virtual destination address

 * @value: value to set memory buffer to

 * @len: operation length

 * @flags: tx descriptor status flags

 set end-of-link on the descriptor */

	/*

	 * Only set the buffer pointers on the last descriptor to

	 * avoid free'ing while we have our transfer still going

 set end-of-link on the descriptor */

/**

 * atc_prep_slave_sg - prepare descriptors for a DMA_SLAVE transaction

 * @chan: DMA channel

 * @sgl: scatterlist to transfer to/from

 * @sg_len: number of entries in @scatterlist

 * @direction: DMA direction

 * @flags: tx descriptor status flags

 * @context: transaction context (ignored)

 set end-of-link to the last link descriptor of list*/

 First descriptor of the chain embedds additional information */

 first link descriptor of list is responsible of flags */

 client is in control of this ack */

/*

 * atc_dma_cyclic_check_values

 * Check for too big/unaligned periods and unaligned DMA buffer

/*

 * atc_dma_cyclic_fill_desc - Fill one period descriptor

 prepare common CRTLA value */

/**

 * atc_prep_dma_cyclic - prepare the cyclic DMA transfer

 * @chan: the DMA channel to prepare

 * @buf_addr: physical DMA address where the buffer starts

 * @buf_len: total number of bytes for the entire buffer

 * @period_len: number of bytes for each period

 * @direction: transfer direction, to or from device

 * @flags: tx descriptor status flags

 Check for too big/unaligned periods and unaligned DMA buffer */

 build cyclic linked list */

 lets make a cyclic list */

 First descriptor of the chain embedds additional information */

 Check if it is chan is configured for slave transfers */

	/*

	 * This is only called when something went wrong elsewhere, so

	 * we don't really care about the data. Just disable the

	 * channel. We still have to poll the channel enable bit due

	 * to AHB/HSB limitations.

 disabling channel: must also remove suspend state */

 confirm that this channel is disabled */

 active_list entries will end up before queued entries */

 Flush all pending and queued descriptors */

 if channel dedicated to cyclic operations, free it */

/**

 * atc_tx_status - poll for transaction completion

 * @chan: DMA channel

 * @cookie: transaction identifier to check status of

 * @txstate: if not %NULL updated with transaction state

 *

 * If @txstate is passed in, upon return it reflect the driver

 * internal state and can be used with dma_async_is_complete() to check

 * the status of multiple cookies without re-checking hardware state.

	/*

	 * There's no point calculating the residue if there's

	 * no txstate to store the value.

  Get number of bytes left in the active transactions */

/**

 * atc_issue_pending - try to finish work

 * @chan: target DMA channel

 Not needed for cyclic transfers */

/**

 * atc_alloc_chan_resources - allocate resources for DMA channel

 * @chan: allocate descriptor resources for this channel

 *

 * return - the number of allocated descriptors

 ASSERT:  channel is idle */

		/*

		 * We need controller-specific data to set up slave

		 * transfers.

 if cfg configuration specified take it instead of default */

 Allocate initial pool of descriptors */

 channel parameters */

/**

 * atc_free_chan_resources - free all channel resources

 * @chan: DMA channel

 ASSERT:  channel is idle */

 free link descriptor */

	/*

	 * Free atslave allocated in at_dma_xlate()

	/*

	 * We can fill both SRC_PER and DST_PER, one of these fields will be

	 * ignored depending on DMA transfer direction.

	/*

	 * We have to translate the value we get from the device tree since

	 * the half FIFO configuration value had to be 0 to keep backward

	 * compatibility.

--  Module Management  -----------------------------------------------*/

 cap_mask is a multi-u32 bitfield, fill it with proper C code. */

 sentinel */

 sentinel */

/**

 * at_dma_off - disable DMA controller

 * @atdma: the Atmel HDAMC device

 disable all interrupts */

 confirm that all channels are disabled */

 setup platform data for each SoC */

 get DMA parameters from controller type */

 discover transaction capabilities */

 force dma off, just in case */

 create a pool of consistent memory blocks for hardware descriptors */

 word alignment */, 0);

 create a pool of consistent memory blocks for memset blocks */

 clear any pending interrupt */

 initialize channels related values */

 set base routines */

 set prep routines based on capability */

 controller can do slave DMA: can trigger cyclic transfers */

	/*

	 * Do not return an error if the dmac node is not present in order to

	 * not break the existing way of requesting channel with

	 * dma_request_channel().

 Disable interrupts */

 wait for transaction completion (except in cyclic case) */

	/* Channel should be paused by user

 now preserve additional data for cyclic operations */

 next descriptor address in the cyclic list */

 preserve data */

 disable DMA controller */

	/* restore channel status for cyclic descriptors list:

	/* channel pause status should be removed by channel user

 bring back DMA controller */

 clear any pending interrupt */

 restore saved data */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Freescale MPC85xx, MPC83xx DMA Engine support

 *

 * Copyright (C) 2007-2010 Freescale Semiconductor, Inc. All rights reserved.

 *

 * Author:

 *   Zhang Wei <wei.zhang@freescale.com>, Jul 2007

 *   Ebony Zhu <ebony.zhu@freescale.com>, May 2007

 *

 * Description:

 *   DMA engine driver for Freescale MPC8540 DMA controller, which is

 *   also fit for MPC8560, MPC8555, MPC8548, MPC8641, and etc.

 *   The support for MPC8349 DMA controller is also added.

 *

 * This driver instructs the DMA controller to issue the PCI Read Multiple

 * command for PCI read operations, instead of using the default PCI Read Line

 * command. Please be aware that this setting may result in read pre-fetching

 * on some platforms.

/*

 * Register Helpers

/*

 * Descriptor Helpers

/*

 * DMA Engine Hardware Control Helpers

 Reset the channel */

		/* Set the channel to below modes:

		 * EIE - Error interrupt enable

		 * EOLNIE - End of links interrupt enable

		 * BWC - Bandwidth sharing among channels

		/* Set the channel to below modes:

		 * EOTIE - End-of-transfer interrupt enable

		 * PRC_RM - PCI read multiple

/*

 * Start the DMA controller

 *

 * Preconditions:

 * - the CDAR register must point to the start descriptor

 * - the MRn[CS] bit must be cleared

 read the mode register */

	/*

	 * The 85xx controller supports channel abort, which will stop

	 * the current transfer. On 83xx, this bit is the transfer error

	 * mask bit, which should not be changed.

 stop the DMA controller */

 wait for the DMA controller to become idle */

/**

 * fsl_chan_set_src_loop_size - Set source address hold transfer size

 * @chan : Freescale DMA channel

 * @size     : Address loop size, 0 for disable loop

 *

 * The set source address hold transfer size. The source

 * address hold or loop transfer size is when the DMA transfer

 * data from source address (SA), if the loop size is 4, the DMA will

 * read data from SA, SA + 1, SA + 2, SA + 3, then loop back to SA,

 * SA + 1 ... and so on.

/**

 * fsl_chan_set_dst_loop_size - Set destination address hold transfer size

 * @chan : Freescale DMA channel

 * @size     : Address loop size, 0 for disable loop

 *

 * The set destination address hold transfer size. The destination

 * address hold or loop transfer size is when the DMA transfer

 * data to destination address (TA), if the loop size is 4, the DMA will

 * write data to TA, TA + 1, TA + 2, TA + 3, then loop back to TA,

 * TA + 1 ... and so on.

/**

 * fsl_chan_set_request_count - Set DMA Request Count for external control

 * @chan : Freescale DMA channel

 * @size     : Number of bytes to transfer in a single request

 *

 * The Freescale DMA channel can be controlled by the external signal DREQ#.

 * The DMA request count is how many bytes are allowed to transfer before

 * pausing the channel, after which a new assertion of DREQ# resumes channel

 * operation.

 *

 * A size of 0 disables external pause control. The maximum size is 1024.

/**

 * fsl_chan_toggle_ext_pause - Toggle channel external pause status

 * @chan : Freescale DMA channel

 * @enable   : 0 is disabled, 1 is enabled.

 *

 * The Freescale DMA channel can be controlled by the external signal DREQ#.

 * The DMA Request Count feature should be used in addition to this feature

 * to set the number of bytes to transfer before pausing the channel.

/**

 * fsl_chan_toggle_ext_start - Toggle channel external start status

 * @chan : Freescale DMA channel

 * @enable   : 0 is disabled, 1 is enabled.

 *

 * If enable the external start, the channel can be started by an

 * external DMA start pin. So the dma_start() does not start the

 * transfer immediately. The DMA channel will wait for the

 * control pin asserted.

	/*

	 * Add the hardware descriptor to the chain of hardware descriptors

	 * that already exists in memory.

	 *

	 * This will un-set the EOL bit of the existing transaction, and the

	 * last link in this transaction will become the EOL descriptor.

	/*

	 * Add the software descriptor and all children to the list

	 * of pending transactions

	/*

	 * assign cookies to all of the software descriptors

	 * that make up this transaction

 put this transaction onto the tail of the pending queue */

/**

 * fsl_dma_free_descriptor - Free descriptor from channel's DMA pool.

 * @chan : Freescale DMA channel

 * @desc: descriptor to be freed

/**

 * fsl_dma_alloc_descriptor - Allocate descriptor from channel's DMA pool.

 * @chan : Freescale DMA channel

 *

 * Return - The descriptor allocated. NULL for failed.

/**

 * fsldma_clean_completed_descriptor - free all descriptors which

 * has been completed and acked

 * @chan: Freescale DMA channel

 *

 * This function is used on all completed and acked descriptors.

 * All descriptors should only be freed in this function.

 Run the callback for each descriptor, in order */

/**

 * fsldma_run_tx_complete_actions - cleanup a single link descriptor

 * @chan: Freescale DMA channel

 * @desc: descriptor to cleanup and free

 * @cookie: Freescale DMA transaction identifier

 *

 * This function is used on a descriptor which has been executed by the DMA

 * controller. It will run any callbacks, submit any dependencies.

 Run the link descriptor callback function */

 Run any dependencies */

/**

 * fsldma_clean_running_descriptor - move the completed descriptor from

 * ld_running to ld_completed

 * @chan: Freescale DMA channel

 * @desc: the descriptor which is completed

 *

 * Free the descriptor directly if acked by async_tx api, or move it to

 * queue ld_completed.

 Remove from the list of transactions */

	/*

	 * the client is allowed to attach dependent operations

	 * until 'ack' is set

		/*

		 * Move this descriptor to the list of descriptors which is

		 * completed, but still awaiting the 'ack' bit to be set.

/**

 * fsl_chan_xfer_ld_queue - transfer any pending transactions

 * @chan : Freescale DMA channel

 *

 * HARDWARE STATE: idle

 * LOCKING: must hold chan->desc_lock

	/*

	 * If the list of pending descriptors is empty, then we

	 * don't need to do any work at all

	/*

	 * The DMA controller is not idle, which means that the interrupt

	 * handler will start any queued transactions when it runs after

	 * this transaction finishes

	/*

	 * If there are some link descriptors which have not been

	 * transferred, we need to start the controller

	/*

	 * Move all elements from the queue of pending transactions

	 * onto the list of running transactions

	/*

	 * The 85xx DMA controller doesn't clear the channel start bit

	 * automatically at the end of a transfer. Therefore we must clear

	 * it in software before starting the transfer.

	/*

	 * Program the descriptor's address into the DMA controller,

	 * then start the DMA transaction

/**

 * fsldma_cleanup_descriptors - cleanup link descriptors which are completed

 * and move them to ld_completed to free until flag 'ack' is set

 * @chan: Freescale DMA channel

 *

 * This function is used on descriptors which have been executed by the DMA

 * controller. It will run any callbacks, submit any dependencies, then

 * free these descriptors if flag 'ack' is set.

 Run the callback for each descriptor, in order */

		/*

		 * do not advance past the current descriptor loaded into the

		 * hardware channel, subsequent descriptors are either in

		 * process or have not been submitted

		/*

		 * stop the search if we reach the current descriptor and the

		 * channel is busy

	/*

	 * Start any pending transactions automatically

	 *

	 * In the ideal case, we keep the DMA controller busy while we go

	 * ahead and free the descriptors below.

/**

 * fsl_dma_alloc_chan_resources - Allocate resources for DMA channel.

 * @chan : Freescale DMA channel

 *

 * This function will create a dma pool for descriptor allocation.

 *

 * Return - The number of descriptors allocated.

 Has this channel already been allocated? */

	/*

	 * We need the descriptor to be aligned to 32bytes

	 * for meeting FSL DMA specification requirement.

 there is at least one descriptor free to be allocated */

/**

 * fsldma_free_desc_list - Free all descriptors in a queue

 * @chan: Freescae DMA channel

 * @list: the list to free

 *

 * LOCKING: must hold chan->desc_lock

/**

 * fsl_dma_free_chan_resources - Free all resources of the channel.

 * @chan : Freescale DMA channel

 Allocate the link descriptor from DMA pool */

 Insert the link descriptor to the LD ring */

 client is in control of this ack */

 Set End-of-link to the last link descriptor of new list */

 Halt the DMA engine */

 Remove and free all of the descriptors in the LD queue */

 make sure the channel supports setting burst size */

 we set the controller burst size depending on direction */

/**

 * fsl_dma_memcpy_issue_pending - Issue the DMA start command

 * @chan : Freescale DMA channel

/**

 * fsl_tx_status - Determine the DMA status

 * @chan : Freescale DMA channel

----------------------------------------------------------------------------*/

 Interrupt Handling                                                         */

----------------------------------------------------------------------------*/

 save and clear the status register */

 check that this was really our device */

	/*

	 * Programming Error

	 * The DMA_INTERRUPT async_tx is a NULL transfer, which will

	 * trigger a PE interrupt.

	/*

	 * For MPC8349, EOCDI event need to update cookie

	 * and start the next transfer if it exist.

	/*

	 * If it current transfer is the end-of-transfer,

	 * we should clear the Channel Start bit for

	 * prepare next transfer.

 check that the DMA controller is really idle */

 check that we handled all of the bits */

	/*

	 * Schedule the tasklet to handle all cleanup of the current

	 * transaction. It will start a new transaction if there is

	 * one pending.

 the hardware is now idle and ready for more */

 Run all cleanup for descriptors which have been completed */

 if we have a per-controller IRQ, use that */

 no per-controller IRQ, use the per-channel IRQs */

 none */; i >= 0; i--) {

----------------------------------------------------------------------------*/

 OpenFirmware Subsystem                                                     */

----------------------------------------------------------------------------*/

 alloc channel */

 ioremap registers for use */

	/*

	 * If the DMA device's feature is different than the feature

	 * of its channels, report the bug

 Initialize the channel */

 Clear cdar registers */

 find the IRQ line, if it exists in the device tree */

 Add the channel to DMA device channel list */

 ioremap the registers for use */

 map the channel IRQ if it exists, but don't hookup the handler yet */

	/*

	 * We cannot use of_platform_bus_probe() because there is no

	 * of_platform_bus_remove(). Instead, we manually instantiate every DMA

	 * channel object.

	/*

	 * Hookup the IRQ handler(s)

	 *

	 * If we have a per-controller interrupt, we prefer that to the

	 * per-channel interrupts to reduce the number of shared interrupt

	 * handlers on the same IRQ line

----------------------------------------------------------------------------*/

 Module Init / Exit                                                         */

----------------------------------------------------------------------------*/

/*

 * drivers/dma/fsl_raid.c

 *

 * Freescale RAID Engine device driver

 *

 * Author:

 *	Harninder Rai <harninder.rai@freescale.com>

 *	Naveen Burmi <naveenburmi@freescale.com>

 *

 * Rewrite:

 *	Xuelin Shi <xuelin.shi@freescale.com>

 *

 * Copyright (c) 2010-2014 Freescale Semiconductor, Inc.

 *

 * Redistribution and use in source and binary forms, with or without

 * modification, are permitted provided that the following conditions are met:

 *     * Redistributions of source code must retain the above copyright

 *       notice, this list of conditions and the following disclaimer.

 *     * Redistributions in binary form must reproduce the above copyright

 *       notice, this list of conditions and the following disclaimer in the

 *       documentation and/or other materials provided with the distribution.

 *     * Neither the name of Freescale Semiconductor nor the

 *       names of its contributors may be used to endorse or promote products

 *       derived from this software without specific prior written permission.

 *

 * ALTERNATIVELY, this software may be distributed under the terms of the

 * GNU General Public License ("GPL") as published by the Free Software

 * Foundation, either version 2 of that License or (at your option) any

 * later version.

 *

 * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY

 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED

 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE

 * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY

 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES

 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;

 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND

 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT

 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS

 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 *

 * Theory of operation:

 *

 * General capabilities:

 *	RAID Engine (RE) block is capable of offloading XOR, memcpy and P/Q

 *	calculations required in RAID5 and RAID6 operations. RE driver

 *	registers with Linux's ASYNC layer as dma driver. RE hardware

 *	maintains strict ordering of the requests through chained

 *	command queueing.

 *

 * Data flow:

 *	Software RAID layer of Linux (MD layer) maintains RAID partitions,

 *	strips, stripes etc. It sends requests to the underlying ASYNC layer

 *	which further passes it to RE driver. ASYNC layer decides which request

 *	goes to which job ring of RE hardware. For every request processed by

 *	RAID Engine, driver gets an interrupt unless coalescing is set. The

 *	per job ring interrupt handler checks the status register for errors,

 *	clears the interrupt and leave the post interrupt processing to the irq

 *	thread.

 Add descriptors into per chan software queue - submit_q */

 Copy descriptor from per chan software queue into hardware job ring */

 compare the hw dma addr to find the completed */

 Per Job Ring interrupt handler */

	/*

	 * There's no way in upper layer (read MD layer) to recover from

	 * error conditions except restart everything. In long term we

	 * need to do something more than just crashing

 Clear interrupt */

 take one desc from free_q */

 Filling xor CDB */

 compute q = src0*coef0^src1*coef1^..., * is GF(8) mult */

 compute P, that is XOR all srcs */

 Filling frame 0 of compound frame descriptor with CDB */

 Fill CFD's 1st frame with dest buffer */

 Fill CFD's rest of the frames with source buffers */

 Setting the final bit in the last source buffer frame in CFD */

/*

 * Prep function for P parity calculation.In RAID Engine terminology,

 * XOR calculation is called GenQ calculation done through GenQ command

 NULL let genq take all coef as 1 */

/*

 * Prep function for P/Q parity calculation.In RAID Engine terminology,

 * P/Q calculation is called GenQQ done through GenQQ command

	/*

	 * RE requires at least 2 sources, if given only one source, we pass the

	 * second source same as the first one.

	 * With only one source, generating P is meaningless, only generate Q.

	/*

	 * During RAID6 array creation, Linux's MD layer gets P and Q

	 * calculated separately in two steps. But our RAID Engine has

	 * the capability to calculate both P and Q with a single command

	 * Hence to merge well with MD layer, we need to provide a hook

	 * here and call re_jq_prep_dma_genq() function

 Filling GenQQ CDB */

 Init gfm_q1[] */

 Align gfm[] to 32bit */

 Init gfm_q2[] */

 Filling frame 0 of compound frame descriptor with CDB */

 Fill CFD's 1st & 2nd frame with dest buffers */

 Fill CFD's rest of the frames with source buffers */

 PQ computation continuation */

 Setting the final bit in the last source buffer frame in CFD */

/*

 * Prep function for memcpy. In RAID Engine, memcpy is done through MOVE

 * command. Logic of this function will need to be modified once multipage

 * support is added in Linux's MD/ASYNC Layer

 Filling move CDB */

 Filling frame 0 of CFD with move CDB */

 Fill CFD's 1st frame with dest buffer */

 Fill CFD's 2nd frame with src buffer */

 create platform device for chan node */

 read reg property from dts */

 read irq property from dts */

 Program the Inbound/Outbound ring base addresses and size */

 Read LIODN value from u-boot */

 Program the CFG reg */

 Enable RE/CHAN */

 Probe function for RAID Engine */

 IOMAP the entire RAID Engine region */

 Program the RE mode */

 Program Galois Field polynomial */

 Parse Device tree to find out the total number of JQs present */

 Find out the Job Rings present under each JQ */

 Cleanup chan related memory areas */

 Unregister the driver */

 SPDX-License-Identifier: GPL-2.0-only

 Copyright(c) 2019 HiSilicon Limited. */

 update other field in sqe */

 make sure data has been updated in sqe */

 update sq tail, point to new sqe position */

 update sq_tail to trigger a new task */

 set sq, cq base */

 set sq, cq depth */

 init sq tail and cq head */

 This function enables all hw channels in a device */

 This will be freed by 'pcim_release()'. See 'pcim_enable_device()' */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2018-2019 Synopsys, Inc. and/or its affiliates.

 * Synopsys DesignWare eDMA v0 core

 *

 * Author: Gustavo Pimentel <gustavo.pimentel@synopsys.com>

 eDMA global registers */

 eDMA interrupts registers */

 eDMA channel context grouping */

 eDMA global registers */

 eDMA interrupts registers */

 eDMA channel context grouping */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2018-2019 Synopsys, Inc. and/or its affiliates.

 * Synopsys DesignWare eDMA v0 core

 *

 * Author: Gustavo Pimentel <gustavo.pimentel@synopsys.com>

 CONFIG_64BIT */

 CONFIG_64BIT */

 eDMA management callbacks */

 Channel control */

 Transfer size */

 SAR */

 CONFIG_64BIT */

 CONFIG_64BIT */

 DAR */

 CONFIG_64BIT */

 CONFIG_64BIT */

 Channel control */

 Linked list */

 CONFIG_64BIT */

 CONFIG_64BIT */

 Enable engine */

 Interrupt unmask - done, abort */

 Linked list error */

 Channel control */

 Linked list */

 CONFIG_64BIT */

 CONFIG_64BIT */

 Doorbell */

 MSI done addr - low, high */

 MSI abort addr - low, high */

 MSI data - low, high */

 Channel odd {1, 3, 5, 7} */

 Channel even {0, 2, 4, 6} */

 eDMA debugfs callbacks */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2018-2019 Synopsys, Inc. and/or its affiliates.

 * Synopsys DesignWare eDMA core driver

 *

 * Author: Gustavo Pimentel <gustavo.pimentel@synopsys.com>

 Create and add new element into the linked list */

 List head */

	/* Toggling change bit (CB) in each chunk, this is a mechanism to

	 * inform the eDMA HW block that this is a new linked list ready

	 * to be consumed.

	 *  - Odd chunks originate CB equal to 0

	 *  - Even chunks originate CB equal to 1

 Create and add new element into the linked list */

 List head */

 Remove all the list elements */

 Remove the list head */

 Remove all the list elements */

 Remove the list head */

 Do nothing */

		/*

		 * The channel is in a false BUSY state, probably didn't

		 * receive or lost an interrupt

 local DMA */

 local DMA */

 remote DMA */

				/* Unlike the typical assumption by other

				 * drivers/IPs the peripheral memory isn't

				 * a FIFO memory, in this case, it's a

				 * linear memory and that why the source

				 * and destination addresses are increased

				 * by the same portion (data length)

				/* Unlike the typical assumption by other

				 * drivers/IPs the peripheral memory isn't

				 * a FIFO memory, in this case, it's a

				 * linear memory and that why the source

				 * and destination addresses are increased

				 * by the same portion (data length)

 Set DMA channel capabilities */

 Set DMA channel callbacks */

 Register DMA device */

 Common IRQ shared among all channels */

 Distribute IRQs equally among all channels */

 Allocate channels */

 Disable eDMA, only to establish the ideal initial conditions */

 Request IRQs */

 Setup write channels */

 Setup read channels */

 Power management */

 Turn debugfs on */

 Disable eDMA */

 Free irqs */

 Power management */

 Deregister eDMA device */

 Turn debugfs off */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2018-2019 Synopsys, Inc. and/or its affiliates.

 * Synopsys DesignWare eDMA PCIe driver

 *

 * Author: Gustavo Pimentel <gustavo.pimentel@synopsys.com>

 eDMA registers location */

 eDMA memory linked list location */

 eDMA memory data location */

 Other */

 eDMA registers location */

  4 Kbytes */

  8 Kbytes */

 eDMA memory linked list location */

 Channel 0 - BAR 2, offset 0 Mbytes, size 2 Kbytes */

 Channel 1 - BAR 2, offset 2 Mbytes, size 2 Kbytes */

 Channel 0 - BAR 2, offset 4 Mbytes, size 2 Kbytes */

 Channel 1 - BAR 2, offset 6 Mbytes, size 2 Kbytes */

 eDMA memory data location */

 Channel 0 - BAR 2, offset 8 Mbytes, size 2 Kbytes */

 Channel 1 - BAR 2, offset 9 Mbytes, size 2 Kbytes */

 Channel 0 - BAR 2, offset 10 Mbytes, size 2 Kbytes */

 Channel 1 - BAR 2, offset 11 Mbytes, size 2 Kbytes */

 Other */

 Enable PCI device */

	/*

	 * Tries to find if exists a PCIe Vendor-Specific Extended Capability

	 * for the DMA, if one exists, then reconfigures it.

 Mapping PCI BAR regions */

 DMA configuration */

 Data structure allocation */

 IRQs allocation */

 Data structure initialization */

 Debug info */

 Validating if PCI interrupts were enabled */

 Starting eDMA driver */

 Saving data structure reference */

 Stopping eDMA driver */

 Freeing IRQs */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.

 * Copyright (c) 2020, Linaro Limited

 TRE flags */

 SPI CONFIG0 WD0 */

 CONFIG0 WD2 */

 SPI GO WD0 */

 GO WD2 */

 I2C Config0 WD0 */

 I2C GO WD0 */

 DMA TRE */

 Register offsets from gpi-top */

 EV Context Array */

 mask type register */

 Mask channel control interrupt register */

 Mask event control interrupt register */

 Mask event interrupt register */

 GPII specific Global - Enable bit register */

 GPII general interrupt - Enable bit register */

 GPII Interrupt Type register */

 QOS Registers */

 Scratch registers */

 # of arguments required from client */

/*

 * @DISABLE_STATE: no register access allowed

 * @CONFIG_STATE:  client has configured the channel

 * @PREP_HARDWARE: register access is allowed

 *		   however, no processing EVENTS

 * @ACTIVE_STATE: channels are fully operational

 * @PREPARE_TERMINATE: graceful termination of channels

 *		       register access is allowed

 * @PAUSE_STATE: channels are active, but not processing any events

ee register base address*/

 maximum # of gpii instances available per gpi block */

 gpii instances available for apps */

 ev ring length factor */

 points to gpi top */

 event processing tasklet */

 DB register to program */

 gpi_write_reg_field - write to specific bit field */

 configure and enable interrupts */

		/*

		 * GPII only uses one EV ring per gpii so we can globally

		 * enable/disable IEOB interrupt

 Sends gpii event or channel command */

 send opcode and wait for completion */

 confirm new ch state is correct , if the cmd is a state change cmd */

 program transfer ring DB register */

 program event ring DB register */

 process transfer completion interrupt */

 process channel control interrupt */

 clear the status */

		/*

		 * CH_CMD_DEALLOC cmd always successful. However cmd does

		 * not change hardware status. So overwriting software state

		 * to default state.

		/*

		 * Triggering complete all if ch_state is not a stop in process.

		 * Stop in process is a transition state and we will wait for

		 * stop interrupt before notifying.

 processing gpi general error interrupts */

 clear the status */

 Clear the register */

 processing gpi level error interrupts */

 only error interrupt should be set */

 gpii interrupt handler */

	/*

	 * States are out of sync to receive interrupt

	 * while software state is in DISABLE state, bailing out.

 global gpii error */

 transfer complete interrupt */

 event control irq */

			/*

			 * CMD EV_CMD_DEALLOC is always successful. However

			 * cmd does not change hardware status. So overwriting

			 * software state to default state.

 channel control irq */

 process DMA Immediate completion data events */

	/*

	 * If channel not active don't process event

	/*

	 * RP pointed by Event is to last TRE processed,

	 * we need to update ring rp to tre + 1

 make sure rp updates are immediately visible to all cores */

 processing transfer completion events */

 only process events on active channel */

	/*

	 * RP pointed by Event is to last TRE processed,

	 * we need to update ring rp to ev_rp + 1

 update must be visible to other cores */

 process all events */

 clear pending IEOB events */

 processing events using tasklet */

 process the events */

 enable IEOB, switching back to interrupts */

 marks all pending events for the channel as stale */

 reset sw state and issue channel reset or de-alloc */

 initialize the local ring ptrs */

 visible to other cores */

 check event ring for any stale events */

 remove all async descriptors */

 gpii CH is active now */

 allocate and configure the transfer channel */

 flush all the writes */

 allocate and configure event ring */

 program event context */

 add events to ring */

 flush all the writes */

 gpii is active now */

 calculate # of ERE/TRE available to queue */

 visible to other cores */

 Update the WP */

 Update the RP */

 visible to other cores */

 allocate memory for transfer and event rings */

 ring len must be power of 2 */

 align the physical mem */

 update to other cores */

 copy tre into transfer ring */

 get next tre location we can copy */

 copy the tre info */

 reset and restart transfer channel */

	/*

	 * treat both channels as a group if its protocol is not UART

	 * STOP, RESET, or START needs to be in lockstep

 stop the channel */

 disable ch state so no more TRE processing */

 send command to Stop the channel */

 reset the channels (clears any pending tre) */

 reprogram channel CNTXT */

 restart the channels */

 pause dma transfer for all channels */

	/*

	 * pause/resume are per gpii not per channel, so

	 * client needs to call pause only once

 send stop command to stop the channels */

 Wait for threads to complete out */

 resume dma transfer */

 send start command to start the channels */

 first create config tre if applicable */

 create the GO tre for Tx */

 create the DMA TRE */

 first create config tre if applicable */

 create the GO tre for Tx */

 create the dma tre */

 copy tre into transfer ring */

 rx */

 calculate # of elements required & available */

 create TREs for xfer */

 set up the descriptor */

 rings transfer ring db to being transfer */

 move all submitted discriptors to issued list */

 nothing to do list is empty */

 check if both channels are configured before continue */

 protocol must be same for both channels */

 allocate memory for event ring */

 configure interrupts */

 allocate event rings */

 Allocate all channels */

 start channels  */

 release all channel resources */

 disable ch state so no more TRE processing for this channel */

 attempt to do graceful hardware shutdown */

 free all allocated memory */

 if other rings are still active exit */

 deallocate EV Ring */

 wait for threads to complete out */

 send command to de allocate event ring */

 disable interrupts */

 set final state to disable */

 allocate channel resources */

 allocate memory for transfer ring */

 check if same seid is already configured for another chid */

 no channels configured with same seid, return next avail gpii */

 check if gpii is configured */

 found a free gpii */

 no gpii instance available to use */

 gpi_of_dma_xlate: open client requested channel */

 find next available gpii to use */

 setup all the supported gpii */

 set up ev cntxt register map */

 set up irq */

 set up channel specific register info */

 set up ch cntxt register map */

 vchan setup */

 clear and Set capabilities */

 configure dmaengine apis */

 register with dmaengine framework */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.

/*

 * QCOM BAM DMA engine driver

 *

 * QCOM BAM DMA blocks are distributed amongst a number of the on-chip

 * peripherals on the MSM 8x74.  The configuration of the channels are dependent

 * on the way they are hard wired to that specific peripheral.  The peripheral

 * device tree entries specify the configuration of each channel.

 *

 * The DMA controller requires the use of external memory for storage of the

 * hardware descriptors for each channel.  The descriptor FIFO is accessed as a

 * circular buffer and operations are managed according to the offset within the

 * FIFO.  After pipe/channel reset, all of the pipe registers and internal state

 * are back to defaults.

 *

 * During DMA operations, we write descriptors to the FIFO, being careful to

 * handle wrapping and then write the last FIFO offset to that channel's

 * P_EVNT_REG register to kick off the transaction.  The P_SW_OFSTS register

 * indicates the current FIFO offset that is being processed, so there is some

 * indication of where the hardware is currently working.

 Buffer physical address */

 Buffer size in bytes */

 transaction flags, EOT|EOB|NWD */

 list node for the desc in the bam_chan list of descriptors */

 BAM CTRL */

 BAM REVISION */

 BAM NUM PIPES */

 BAM CNFG BITS */

 PIPE CTRL */

 BAM_DESC_CNT_TRSHLD */

 BAM_IRQ_SRCS */

 BAM_IRQ_SRCS_MSK */

 BAM_IRQ_STTS */

 BAM_IRQ_CLR */

 BAM_IRQ_EN */

 BAM_P_IRQ_EN */

 BAM_P_SW_OFSTS */

 configuration from device tree */

 runtime configuration */

 fifo storage */

 fifo markers */

 start of active descriptor entries */

 end of active descriptor entries */

 is the channel hw initialized? */

 is the channel paused? */

 new slave config? */

 list of descriptors currently processed */

 execution environment ID, from DT */

 dma start transaction tasklet */

/**

 * bam_addr - returns BAM register address

 * @bdev: bam device

 * @pipe: pipe instance (ignored when register doesn't have multiple instances)

 * @reg:  register enum

/**

 * bam_reset() - reset and initialize BAM registers

 * @bdev: bam device

 s/w reset bam */

 after reset all pipes are disabled and idle */

 make sure previous stores are visible before enabling BAM */

 enable bam */

 set descriptor threshhold, start with 4 bytes */

 Enable default set of h/w workarounds, ie all except BAM_FULL_PIPE */

 enable irqs for errors */

 unmask global bam interrupt */

/**

 * bam_reset_channel - Reset individual BAM DMA channel

 * @bchan: bam channel

 *

 * This function resets a specific BAM channel

 reset channel */

 don't allow cpu to reorder BAM register accesses done after this */

 make sure hw is initialized when channel is used the first time  */

/**

 * bam_chan_init_hw - Initialize channel hardware

 * @bchan: bam channel

 * @dir: DMA transfer direction

 *

 * This function resets and initializes the BAM channel

 Reset the channel to clear internal state of the FIFO */

	/*

	 * write out 8 byte aligned address.  We have enough space for this

	 * because we allocated 1 more descriptor (8 bytes) than we can use

 enable the per pipe interrupts, enable EOT, ERR, and INT irqs */

 unmask the specific pipe and EE combo */

 don't allow cpu to reorder the channel enable done below */

 set fixed direction and mode, then enable channel */

 init FIFO pointers */

/**

 * bam_alloc_chan - Allocate channel resources for DMA channel.

 * @chan: specified channel

 *

 * This function allocates the FIFO descriptor memory

 allocate FIFO descriptor space, but only if necessary */

/**

 * bam_free_chan - Frees dma resources associated with specific channel

 * @chan: specified channel

 *

 * Free the allocated fifo descriptor memory and channel resources

 *

 mask irq for pipe/channel */

 disable irq */

 s/w reset bam */

/**

 * bam_slave_config - set slave configuration for channel

 * @chan: dma channel

 * @cfg: slave configuration

 *

 * Sets slave configuration for channel

 *

/**

 * bam_prep_slave_sg - Prep slave sg transaction

 *

 * @chan: dma channel

 * @sgl: scatter gather list

 * @sg_len: length of sg

 * @direction: DMA transfer direction

 * @flags: DMA flags

 * @context: transfer context (unused)

 calculate number of required entries */

 allocate enough room to accomodate the number of entries */

 fill in temporary descriptors */

/**

 * bam_dma_terminate_all - terminate all transactions on a channel

 * @chan: bam dma channel

 *

 * Dequeues and frees all transactions

 * No callbacks are done

 *

 remove all transactions, including active transaction */

	/*

	 * If we have transactions queued, then some might be committed to the

	 * hardware in the desc fifo.  The only way to reset the desc fifo is

	 * to do a hardware reset (either by pipe or the entire block).

	 * bam_chan_init_hw() will trigger a pipe reset, and also reinit the

	 * pipe.  If the pipe is left disabled (default state after pipe reset)

	 * and is accessed by a connected hardware engine, a fatal error in

	 * the BAM will occur.  There is a small window where this could happen

	 * with bam_chan_init_hw(), but it is assumed that the caller has

	 * stopped activity on any attached hardware engine.  Make sure to do

	 * this first so that the BAM hardware doesn't cause memory corruption

	 * by accessing freed resources.

/**

 * bam_pause - Pause DMA channel

 * @chan: dma channel

 *

/**

 * bam_resume - Resume DMA channel operations

 * @chan: dma channel

 *

/**

 * process_channel_irqs - processes the channel interrupts

 * @bdev: bam controller

 *

 * This function processes the channel interrupts

 *

 return early if no pipe/channel interrupts are present */

 clear pipe irq */

 Number of bytes available to read */

 Not enough data to read */

 manage FIFO */

			/*

			 * if complete, process cookie. Otherwise

			 * push back to front of desc_issued so that

			 * it gets restarted by the tasklet

/**

 * bam_dma_irq - irq handler for bam controller

 * @irq: IRQ of interrupt

 * @data: callback data

 *

 * IRQ handler for the bam controller

 kick off tasklet to start next dma transfer */

		/*

		 * don't allow reorder of the various accesses to the BAM

		 * registers

/**

 * bam_tx_status - returns status of transaction

 * @chan: dma channel

 * @cookie: transaction cookie

 * @txstate: DMA transaction state

 *

 * Return status of dma transaction

/**

 * bam_apply_new_config

 * @bchan: bam dma channel

 * @dir: DMA direction

/**

 * bam_start_dma - start next transaction

 * @bchan: bam dma channel

 on first use, initialize the channel hardware */

 apply new slave config changes, if necessary */

 set any special flags on the last descriptor */

		/*

		 * An interrupt is generated at this desc, if

		 *  - FIFO is FULL.

		 *  - No more descriptors to add.

		 *  - If a callback completion was requested for this DESC,

		 *     In this case, BAM will deliver the completion callback

		 *     for this desc and continue processing the next desc.

 ensure descriptor writes and dma start not reordered */

/**

 * dma_tasklet - DMA IRQ tasklet

 * @t: tasklet argument (bam controller structure)

 *

 * Sets up next DMA operation and then processes all completed transactions

 go through the channels and kick off transactions */

/**

 * bam_issue_pending - starts pending transactions

 * @chan: dma channel

 *

 * Calls tasklet directly which in turn starts any pending transactions

 if work pending and idle, start a transaction */

/**

 * bam_dma_free_desc - free descriptor memory

 * @vd: virtual descriptor

 *

/**

 * bam_init

 * @bdev: bam device

 *

 * Initialization helper for global bam registers

 read revision and configuration information */

 check that configured EE is within range */

 Reset BAM now if fully controlled locally */

 allocate and initialize channels */

 set max dma segment size */

 set capabilities */

 initialize dmaengine apis */

 mask all interrupts for this execution environment */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2013-2015, The Linux Foundation. All rights reserved.

 ADM registers - calculated from channel number and security domain */

 channel status */

 channel result */

 channel conf */

 channel result conf */

 CRCI CTL */

 CI configuration */

 GP CTL */

 Command pointer list entry */

 Command list entry */

 parsed from DT */

 channel id */

/**

 * adm_free_chan - Frees dma resources associated with the specific channel

 *

 * @chan: dma channel

 *

 * Free all allocated descriptors associated with this channel

 free all queued descriptors */

/**

 * adm_get_blksize - Get block size from burst value

 *

 * @burst: Burst size of transaction

/**

 * adm_process_fc_descriptors - Process descriptors for flow controlled xfers

 *

 * @achan: ADM channel

 * @desc: Descriptor memory pointer

 * @sg: Scatterlist entry

 * @crci: CRCI value

 * @burst: Burst size of transaction

 * @direction: DMA transfer direction

 if leftover bytes, do one single descriptor */

/**

 * adm_process_non_fc_descriptors - Process descriptors for non-fc xfers

 *

 * @achan: ADM channel

 * @desc: Descriptor memory pointer

 * @sg: Scatterlist entry

 * @direction: DMA transfer direction

 set last command if this is the end of the whole transaction */

/**

 * adm_prep_slave_sg - Prep slave sg transaction

 *

 * @chan: dma channel

 * @sgl: scatter gather list

 * @sg_len: length of sg

 * @direction: DMA transfer direction

 * @flags: DMA flags

 * @context: transfer context (unused)

	/*

	 * get burst value from slave configuration

 if using flow control, validate burst and crci values */

 iterate through sgs and compute allocation size of structures */

 both command list entry and descriptors must be 8 byte aligned */

 init cmd list */

/**

 * adm_terminate_all - terminate all transactions on a channel

 * @chan: dma channel

 *

 * Dequeues and frees all transactions, aborts current transaction

 * No callbacks are done

 *

 send flush command to terminate current transaction */

/**

 * adm_start_dma - start next transaction

 * @achan: ADM dma channel

 write next command list out to the CMD FIFO */

 reset channel error */

 enable interrupts */

 set the crci block size if this transaction requires CRCI */

 make sure IRQ enable doesn't get reordered */

 write next command list out to the CMD FIFO */

/**

 * adm_dma_irq - irq handler for ADM controller

 * @irq: IRQ of interrupt

 * @data: callback data

 *

 * IRQ handler for the bam controller

 if no result present, skip */

 no valid results, skip */

 flag error if transaction was flushed or failed */

 kick off next DMA */

/**

 * adm_tx_status - returns status of transaction

 * @chan: dma channel

 * @cookie: transaction cookie

 * @txstate: DMA transaction state

 *

 * Return status of dma transaction

	/*

	 * residue is either the full length if it is in the issued list, or 0

	 * if it is in progress.  We have no reliable way of determining

	 * anything inbetween

/**

 * adm_issue_pending - starts pending transactions

 * @chan: dma channel

 *

 * Issues all pending transactions and starts DMA

/**

 * adm_dma_free_desc - free descriptor memory

 * @vd: virtual descriptor

 *

 allocate and initialize channels */

 reset CRCIs */

 configure client interfaces */

 set capabilities */

 initialize dmaengine apis */

 mask IRQs for this channel/EE pair */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Qualcomm Technologies HIDMA debug file

 *

 * Copyright (c) 2015-2016, The Linux Foundation. All rights reserved.

/*

 * hidma_chan_show: display HIDMA channel statistics

 *

 * Display the statistics for the current HIDMA virtual channel device.

/*

 * hidma_dma_show: display HIDMA device info

 *

 * Display the info for the current HIDMA device.

 walk through the virtual channel list */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Qualcomm Technologies HIDMA Management SYS interface

 *

 * Copyright (c) 2015, The Linux Foundation. All rights reserved.

 create each channel directory here */

 populate common parameters */

 populate parameters that are per channel */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Qualcomm Technologies HIDMA DMA engine low level code

 *

 * Copyright (c) 2015-2016, The Linux Foundation. All rights reserved.

 each EVRE is 16 bytes */

 need to have at least one empty spot in the queue */

 set IEOB */

/*

 * Multiple TREs may be queued and waiting in the pending queue.

 call the user if it has been read by the hardware */

	/*

	 * Keep track of pending TREs that SW is expecting to receive

	 * from HW. We got one now. Decrement our counter.

/*

 * Called to handle the interrupt for the channel.

 * Return a positive number if TRE or EVRE were consumed on this run.

 * Return a positive number if there are pending TREs or EVREs.

 * Return 0 if there is nothing to consume or no pending TREs/EVREs found.

	/*

	 * By the time control reaches here the number of EVREs and TREs

	 * may not match. Only consume the ones that hardware told us.

		/*

		 * Read the new event descriptor written by the HW.

		 * As we are processing the delivered events, other events

		 * get queued to the SW for processing.

		/*

		 * An error interrupt might have arrived while we are processing

		 * the completed interrupt.

 record the last processed tre offset */

	/*

	 * Delay 10ms after reset to allow DMA logic to quiesce.

	 * Do a polled read up to 1ms and 10ms maximum.

	/*

	 * Delay 10ms after reset to allow DMA logic to quiesce.

	 * Do a polled read up to 1ms and 10ms maximum.

/*

 * The interrupt handler for HIDMA will try to consume as many pending

 * EVRE from the event queue as possible. Each EVRE has an associated

 * TRE that holds the user interface parameters. EVRE reports the

 * result of the transaction. Hardware guarantees ordering between EVREs

 * and TREs. We use last processed offset to figure out which TRE is

 * associated with which EVRE. If two TREs are consumed by HW, the EVREs

 * are in order in the event ring.

 *

 * This handler will do a one pass for consuming EVREs. Other EVREs may

 * be delivered while we are working. It will try to consume incoming

 * EVREs one more time and return.

 *

 * For unprocessed EVREs, hardware will trigger another interrupt until

 * all the interrupt bits are cleared.

 *

 * Hardware guarantees that by the time interrupt is observed, all data

 * transactions in flight are delivered to their respective places and

 * are visible to the CPU.

 *

 * On demand paging for IOMMU is only supported for PCIe via PRI

 * (Page Request Interface) not for HIDMA. All other hardware instances

 * including HIDMA work on pinned DMA addresses.

 *

 * HIDMA is not aware of IOMMU presence since it follows the DMA API. All

 * IOMMU latency will be built into the data movement time. By the time

 * interrupt happens, IOMMU lookups + data movement has already taken place.

 *

 * While the first read in a typical PCI endpoint ISR flushes all outstanding

 * requests traditionally to the destination, this concept does not apply

 * here for this HW.

 Clear out pending interrupts */

 No further submissions. */

 Driver completes the txn and intimates the client.*/

	/*

	 * Fine tuned for this HW...

	 *

	 * This ISR has been designed for this particular hardware. Relaxed

	 * read and write accessors are used for performance reasons due to

	 * interrupt delivery guarantees. Do not copy this code blindly and

	 * expect that to work.

	 *

	 * Try to consume as many EVREs as possible.

		/*

		 * Another interrupt might have arrived while we are

		 * processing this one. Read the new cause.

 enable irqs */

 both channels have to be enabled before calling this function */

 copy the TRE into its location in the TRE ring */

/*

 * Note that even though we stop this channel if there is a pending transaction

 * in flight it will complete and follow the callback. This request will

 * prevent further requests to be made.

 The channel needs to be in working state */

	/*

	 * Start the wait right after the suspend is confirmed.

	 * Do a polled read up to 1ms and 10ms maximum.

	/*

	 * Start the wait right after the suspend is confirmed

	 * Delay up to 10ms after reset to allow DMA logic to quiesce.

 disable interrupts */

/*

 * Called during initialization and after an error condition

 * to restore hardware state.

 disable interrupts */

 clear all pending interrupts */

	/*

	 * Clear all pending interrupts again.

	 * Otherwise, we observe reset complete interrupts.

 disable interrupts again after reset */

 configure interrupts */

 disable interrupts again after reset */

 support IRQ by default */

 clear all pending interrupts and enable them */

 need at least four TREs */

 need an extra space */

 the TRE ring has to be TRE_SIZE aligned */

 the EVRE ring has to be EVRE_SIZE aligned */

	/*

	 * Clear all pending interrupts again.

	 * Otherwise, we observe reset complete interrupts.

/*

 * Qualcomm Technologies HIDMA DMA engine interface

 *

 * Copyright (c) 2015-2017, The Linux Foundation. All rights reserved.

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License version 2 and

 * only version 2 as published by the Free Software Foundation.

 *

 * This program is distributed in the hope that it will be useful,

 * but WITHOUT ANY WARRANTY; without even the implied warranty of

 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

/*

 * Copyright (C) Freescale Semicondutor, Inc. 2007, 2008.

 * Copyright (C) Semihalf 2009

 * Copyright (C) Ilya Yanok, Emcraft Systems 2010

 * Copyright (C) Alexander Popov, Promcontroller 2014

 *

 * Written by Piotr Ziecik <kosmo@semihalf.com>. Hardware description

 * (defines, structures and comments) was taken from MPC5121 DMA driver

 * written by Hongjun Chen <hong-jun.chen@freescale.com>.

 *

 * Approved as OSADL project by a majority of OSADL members and funded

 * by OSADL membership fees in 2009;  for details see www.osadl.org.

 *

 * This program is free software; you can redistribute it and/or modify it

 * under the terms of the GNU General Public License as published by the Free

 * Software Foundation; either version 2 of the License, or (at your option)

 * any later version.

 *

 * This program is distributed in the hope that it will be useful, but WITHOUT

 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or

 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for

 * more details.

 *

 * The full GNU General Public License is included in this distribution in the

 * file called COPYING.

 Linux Foundation elects GPLv2 license only. */

/*

 * Default idle time is 2 seconds. This parameter can

 * be overridden by changing the following

 * /sys/bus/platform/devices/QCOM8061:<xy>/power/autosuspend_delay_ms

 * during kernel boot.

 process completed descriptors */

 Get all completed descriptors */

 Execute callbacks and run dependencies */

/*

 * Called once for each submitted descriptor.

 * PM is locked once for each descriptor that is currently

 * in execution.

 Delete from the active list, add to completed list */

 calculate the next running descriptor */

 PM will be released in hidma_callback function. */

/*

 * Submit descriptor to hardware.

 * Lock the PM for each descriptor we are sending.

 Move descriptor to queued */

 Update cookie */

 Alloc descriptors for this channel */

 return the allocated descriptors */

 Get free descriptor */

 Place descriptor in prepared list */

 Get free descriptor */

 Place descriptor in prepared list */

 give completed requests a chance to finish */

 this suspends the existing transfer */

 return all user requests */

 move myself to free_list */

 reinitialize the hardware */

 terminate running transactions and free descriptors */

 Move data */

 Free descriptors */

	/*

	 * All interrupts are request driven.

	 * HW doesn't send an interrupt by itself.

 free allocated MSI interrupts above */

 free allocated MSI interrupts above */

 Add callback to free MSIs on teardown */

	/*

	 * This driver only handles the channel IRQs.

	 * Common IRQ is handled by the management driver.

	/*

	 * Determine the MSI capability of the platform. Old HW doesn't

	 * support MSI.

 Set DMA mask to 64 bits. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Qualcomm Technologies HIDMA DMA engine Management interface

 *

 * Copyright (c) 2015-2017, The Linux Foundation. All rights reserved.

 weight needs to be at least one */

 start the HW */

 allocate a resource array */

		/*

		 * It is assumed that calling of_msi_configure is safe on

		 * platforms with or without MSI support.

 device tree based firmware here */

	/*

	 * We do not check for return value here, as it is assumed that

	 * platform_driver_register must not fail. The reason for this is that

	 * the (potential) hidma_mgmt_of_populate_channels calls above are not

	 * cleaned up if it does fail, and to do this work is quite

	 * complicated. In particular, various calls of of_address_to_resource,

	 * of_irq_to_resource, platform_device_register_full, of_dma_configure,

	 * and of_msi_configure which then call other functions and so on, must

	 * be cleaned up - this is not a trivial exercise.

	 *

	 * Currently, this module is not intended to be unloaded, and there is

	 * no module_exit function defined which does the needed cleanup. For

	 * this reason, we have to assume success here.

 SPDX-License-Identifier: GPL-2.0

 Copyright 2019 NXP

 cmd, param, offset, width, type, arg_name */

/**

 * dpdmai_open() - Open a control session for the specified object

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @dpdmai_id:	DPDMAI unique ID

 * @token:	Returned token; use in subsequent API calls

 *

 * This function can be used to open a control session for an

 * already created object; an object may have been declared in

 * the DPL or by calling the dpdmai_create() function.

 * This function returns a unique authentication token,

 * associated with the specific object ID and the specific MC

 * portal; this token must be used in all subsequent commands for

 * this specific object.

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

 retrieve response parameters */

/**

 * dpdmai_close() - Close the control session of the object

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPDMAI object

 *

 * After this function is called, no further operations are

 * allowed on the object without opening a new control session.

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpdmai_create() - Create the DPDMAI object

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @cfg:	Configuration structure

 * @token:	Returned token; use in subsequent API calls

 *

 * Create the DPDMAI object, allocate required resources and

 * perform required initialization.

 *

 * The object can be created either by declaring it in the

 * DPL file, or by calling this function.

 *

 * This function returns a unique authentication token,

 * associated with the specific object ID and the specific MC

 * portal; this token must be used in all subsequent calls to

 * this specific object. For objects that are created using the

 * DPL file, call dpdmai_open() function to get an authentication

 * token first.

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

 retrieve response parameters */

/**

 * dpdmai_destroy() - Destroy the DPDMAI object and release all its resources.

 * @mc_io:      Pointer to MC portal's I/O object

 * @cmd_flags:  Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:      Token of DPDMAI object

 *

 * Return:      '0' on Success; error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpdmai_enable() - Enable the DPDMAI, allow sending and receiving frames.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPDMAI object

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpdmai_disable() - Disable the DPDMAI, stop sending and receiving frames.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPDMAI object

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpdmai_reset() - Reset the DPDMAI, returns the object to initial state.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPDMAI object

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpdmai_get_attributes() - Retrieve DPDMAI attributes.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPDMAI object

 * @attr:	Returned object's attributes

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

 retrieve response parameters */

/**

 * dpdmai_set_rx_queue() - Set Rx queue configuration

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPDMAI object

 * @priority:	Select the queue relative to number of

 *		priorities configured at DPDMAI creation

 * @cfg:	Rx queue configuration

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

/**

 * dpdmai_get_rx_queue() - Retrieve Rx queue attributes.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPDMAI object

 * @priority:	Select the queue relative to number of

 *				priorities configured at DPDMAI creation

 * @attr:	Returned Rx queue attributes

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

 retrieve response parameters */

/**

 * dpdmai_get_tx_queue() - Retrieve Tx queue attributes.

 * @mc_io:	Pointer to MC portal's I/O object

 * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'

 * @token:	Token of DPDMAI object

 * @priority:	Select the queue relative to number of

 *			priorities configured at DPDMAI creation

 * @fqid:	Returned Tx queue

 *

 * Return:	'0' on Success; Error code otherwise.

 prepare command */

 send command to mc*/

 retrieve response parameters */

 SPDX-License-Identifier: GPL-2.0

 Copyright 2019 NXP

/*

 * Request a command descriptor for enqueue.

 fd populated */

	/*

	 * Bypass memory translation, Frame list format, short length disable

	 * we need to disable BMT if fsl-mc use iova addr

 first frame list for descriptor buffer */

 source descriptor CMD */

 dest descriptor CMD */

 first frame list to source descriptor */

 bypass memory translation */

 source and destination frame list */

 source frame list to source buffer */

 single buffer frame or scatter gather frame */

 bypass memory translation */

 destination frame list to destination buffer */

 single buffer frame or scatter gather frame */

 bypass memory translation */

 populate Frame descriptor */

 first frame list for descriptor buffer (logn format) */

 Get the handle for the DPDMAI this interface is associate with */

 obtain FD and process the error */

 obtain a MC portal */

 DPDMAI initialization */

 DPIO */

 DPDMAI binding to DPIO */

 DPDMAI enable */

 SPDX-License-Identifier: GPL-2.0

/*

 * Xilinx ZynqMP DPDMA Engine driver

 *

 * Copyright (C) 2015 - 2020 Xilinx, Inc.

 *

 * Author: Hyun Woo Kwon <hyun.kwon@xilinx.com>

 DPDMA registers */

 Channel register */

 DPDMA descriptor fields */

/**

 * struct xilinx_dpdma_hw_desc - DPDMA hardware descriptor

 * @control: control configuration field

 * @desc_id: descriptor ID

 * @xfer_size: transfer size

 * @hsize_stride: horizontal size and stride

 * @timestamp_lsb: LSB of time stamp

 * @timestamp_msb: MSB of time stamp

 * @addr_ext: upper 16 bit of 48 bit address (next_desc and src_addr)

 * @next_desc: next descriptor 32 bit address

 * @src_addr: payload source address (1st page, 32 LSB)

 * @addr_ext_23: payload source address (3nd and 3rd pages, 16 LSBs)

 * @addr_ext_45: payload source address (4th and 5th pages, 16 LSBs)

 * @src_addr2: payload source address (2nd page, 32 LSB)

 * @src_addr3: payload source address (3rd page, 32 LSB)

 * @src_addr4: payload source address (4th page, 32 LSB)

 * @src_addr5: payload source address (5th page, 32 LSB)

 * @crc: descriptor CRC

/**

 * struct xilinx_dpdma_sw_desc - DPDMA software descriptor

 * @hw: DPDMA hardware descriptor

 * @node: list node for software descriptors

 * @dma_addr: DMA address of the software descriptor

/**

 * struct xilinx_dpdma_tx_desc - DPDMA transaction descriptor

 * @vdesc: virtual DMA descriptor

 * @chan: DMA channel

 * @descriptors: list of software descriptors

 * @error: an error has been detected with this descriptor

/**

 * struct xilinx_dpdma_chan - DPDMA channel

 * @vchan: virtual DMA channel

 * @reg: register base address

 * @id: channel ID

 * @wait_to_stop: queue to wait for outstanding transacitons before stopping

 * @running: true if the channel is running

 * @first_frame: flag for the first frame of stream

 * @video_group: flag if multi-channel operation is needed for video channels

 * @lock: lock to access struct xilinx_dpdma_chan

 * @desc_pool: descriptor allocation pool

 * @err_task: error IRQ bottom half handler

 * @desc: References to descriptors being processed

 * @desc.pending: Descriptor schedule to the hardware, pending execution

 * @desc.active: Descriptor being executed by the hardware

 * @xdev: DPDMA device

 lock to access struct xilinx_dpdma_chan */

/**

 * struct xilinx_dpdma_device - DPDMA device

 * @common: generic dma device structure

 * @reg: register base address

 * @dev: generic device structure

 * @irq: the interrupt number

 * @axi_clk: axi clock

 * @chan: DPDMA channels

 * @ext_addr: flag for 64 bit system (48 bit addressing)

/* -----------------------------------------------------------------------------

 * DebugFS

 Match xilinx_dpdma_testcases vs dpdma_debugfs_reqs[] entry */

 Match xilinx_dpdma_testcases vs dpdma_debugfs_reqs[] entry */

 Supporting single instance of test as of now. */

 Read the testcase name from a user request. */

/* -----------------------------------------------------------------------------

 * I/O Accessors

/* -----------------------------------------------------------------------------

 * Descriptor Operations

/**

 * xilinx_dpdma_sw_desc_set_dma_addrs - Set DMA addresses in the descriptor

 * @xdev: DPDMA device

 * @sw_desc: The software descriptor in which to set DMA addresses

 * @prev: The previous descriptor

 * @dma_addr: array of dma addresses

 * @num_src_addr: number of addresses in @dma_addr

 *

 * Set all the DMA addresses in the hardware descriptor corresponding to @dev

 * from @dma_addr. If a previous descriptor is specified in @prev, its next

 * descriptor DMA address is set to the DMA address of @sw_desc. @prev may be

 * identical to @sw_desc for cyclic transfers.

/**

 * xilinx_dpdma_chan_alloc_sw_desc - Allocate a software descriptor

 * @chan: DPDMA channel

 *

 * Allocate a software descriptor from the channel's descriptor pool.

 *

 * Return: a software descriptor or NULL.

/**

 * xilinx_dpdma_chan_free_sw_desc - Free a software descriptor

 * @chan: DPDMA channel

 * @sw_desc: software descriptor to free

 *

 * Free a software descriptor from the channel's descriptor pool.

/**

 * xilinx_dpdma_chan_dump_tx_desc - Dump a tx descriptor

 * @chan: DPDMA channel

 * @tx_desc: tx descriptor to dump

 *

 * Dump contents of a tx descriptor

/**

 * xilinx_dpdma_chan_alloc_tx_desc - Allocate a transaction descriptor

 * @chan: DPDMA channel

 *

 * Allocate a tx descriptor.

 *

 * Return: a tx descriptor or NULL.

/**

 * xilinx_dpdma_chan_free_tx_desc - Free a virtual DMA descriptor

 * @vdesc: virtual DMA descriptor

 *

 * Free the virtual DMA descriptor @vdesc including its software descriptors.

/**

 * xilinx_dpdma_chan_prep_interleaved_dma - Prepare an interleaved dma

 *					    descriptor

 * @chan: DPDMA channel

 * @xt: dma interleaved template

 *

 * Prepare a tx descriptor including internal software/hardware descriptors

 * based on @xt.

 *

 * Return: A DPDMA TX descriptor on success, or NULL.

/* -----------------------------------------------------------------------------

 * DPDMA Channel Operations

/**

 * xilinx_dpdma_chan_enable - Enable the channel

 * @chan: DPDMA channel

 *

 * Enable the channel and its interrupts. Set the QoS values for video class.

/**

 * xilinx_dpdma_chan_disable - Disable the channel

 * @chan: DPDMA channel

 *

 * Disable the channel and its interrupts.

/**

 * xilinx_dpdma_chan_pause - Pause the channel

 * @chan: DPDMA channel

 *

 * Pause the channel.

/**

 * xilinx_dpdma_chan_unpause - Unpause the channel

 * @chan: DPDMA channel

 *

 * Unpause the channel.

/**

 * xilinx_dpdma_chan_queue_transfer - Queue the next transfer

 * @chan: DPDMA channel

 *

 * Queue the next descriptor, if any, to the hardware. If the channel is

 * stopped, start it first. Otherwise retrigger it with the next descriptor.

	/*

	 * Assign the cookie to descriptors in this transaction. Only 16 bit

	 * will be used, but it should be enough.

		/*

		 * Trigger the transfer only when all channels in the group are

		 * ready.

/**

 * xilinx_dpdma_chan_ostand - Number of outstanding transactions

 * @chan: DPDMA channel

 *

 * Read and return the number of outstanding transactions from register.

 *

 * Return: Number of outstanding transactions from the status register.

/**

 * xilinx_dpdma_chan_notify_no_ostand - Notify no outstanding transaction event

 * @chan: DPDMA channel

 *

 * Notify waiters for no outstanding event, so waiters can stop the channel

 * safely. This function is supposed to be called when 'no outstanding'

 * interrupt is generated. The 'no outstanding' interrupt is disabled and

 * should be re-enabled when this event is handled. If the channel status

 * register still shows some number of outstanding transactions, the interrupt

 * remains enabled.

 *

 * Return: 0 on success. On failure, -EWOULDBLOCK if there's still outstanding

 * transaction(s).

 Disable 'no outstanding' interrupt */

/**

 * xilinx_dpdma_chan_wait_no_ostand - Wait for the no outstanding irq

 * @chan: DPDMA channel

 *

 * Wait for the no outstanding transaction interrupt. This functions can sleep

 * for 50ms.

 *

 * Return: 0 on success. On failure, -ETIMEOUT for time out, or the error code

 * from wait_event_interruptible_timeout().

 Wait for a no outstanding transaction interrupt upto 50msec */

/**

 * xilinx_dpdma_chan_poll_no_ostand - Poll the outstanding transaction status

 * @chan: DPDMA channel

 *

 * Poll the outstanding transaction status, and return when there's no

 * outstanding transaction. This functions can be used in the interrupt context

 * or where the atomicity is required. Calling thread may wait more than 50ms.

 *

 * Return: 0 on success, or -ETIMEDOUT.

 Poll at least for 50ms (20 fps). */

/**

 * xilinx_dpdma_chan_stop - Stop the channel

 * @chan: DPDMA channel

 *

 * Stop a previously paused channel by first waiting for completion of all

 * outstanding transaction and then disabling the channel.

 *

 * Return: 0 on success, or -ETIMEDOUT if the channel failed to stop.

/**

 * xilinx_dpdma_chan_done_irq - Handle hardware descriptor completion

 * @chan: DPDMA channel

 *

 * Handle completion of the currently active descriptor (@chan->desc.active). As

 * we currently support cyclic transfers only, this just invokes the cyclic

 * callback. The descriptor will be completed at the VSYNC interrupt when a new

 * descriptor replaces it.

/**

 * xilinx_dpdma_chan_vsync_irq - Handle hardware descriptor scheduling

 * @chan: DPDMA channel

 *

 * At VSYNC the active descriptor may have been replaced by the pending

 * descriptor. Detect this through the DESC_ID and perform appropriate

 * bookkeeping.

 If the retrigger raced with vsync, retry at the next frame. */

	/*

	 * Complete the active descriptor, if any, promote the pending

	 * descriptor to active, and queue the next transfer, if any.

/**

 * xilinx_dpdma_chan_err - Detect any channel error

 * @chan: DPDMA channel

 * @isr: masked Interrupt Status Register

 * @eisr: Error Interrupt Status Register

 *

 * Return: true if any channel error occurs, or false otherwise.

/**

 * xilinx_dpdma_chan_handle_err - DPDMA channel error handling

 * @chan: DPDMA channel

 *

 * This function is called when any channel error or any global error occurs.

 * The function disables the paused channel by errors and determines

 * if the current active descriptor can be rescheduled depending on

 * the descriptor status.

 Reschedule if there's no new descriptor */

/* -----------------------------------------------------------------------------

 * DMA Engine Operations

/**

 * xilinx_dpdma_alloc_chan_resources - Allocate resources for the channel

 * @dchan: DMA channel

 *

 * Allocate a descriptor pool for the channel.

 *

 * Return: 0 on success, or -ENOMEM if failed to allocate a pool.

/**

 * xilinx_dpdma_free_chan_resources - Free all resources for the channel

 * @dchan: DMA channel

 *

 * Free resources associated with the virtual DMA channel, and destroy the

 * descriptor pool.

	/*

	 * The destination address doesn't need to be specified as the DPDMA is

	 * hardwired to the destination (the DP controller). The transfer

	 * width, burst size and port window size are thus meaningless, they're

	 * fixed both on the DPDMA side and on the DP controller side.

	/*

	 * Abuse the slave_id to indicate that the channel is part of a video

	 * group.

/**

 * xilinx_dpdma_terminate_all - Terminate the channel and descriptors

 * @dchan: DMA channel

 *

 * Pause the channel without waiting for ongoing transfers to complete. Waiting

 * for completion is performed by xilinx_dpdma_synchronize() that will disable

 * the channel to complete the stop.

 *

 * All the descriptors associated with the channel that are guaranteed not to

 * be touched by the hardware. The pending and active descriptor are not

 * touched, and will be freed either upon completion, or by

 * xilinx_dpdma_synchronize().

 *

 * Return: 0 on success, or -ETIMEDOUT if the channel failed to stop.

 Pause the channel (including the whole video group if applicable). */

 Gather all the descriptors we can free and free them. */

/**

 * xilinx_dpdma_synchronize - Synchronize callback execution

 * @dchan: DMA channel

 *

 * Synchronizing callback execution ensures that all previously issued

 * transfers have completed and all associated callbacks have been called and

 * have returned.

 *

 * This function waits for the DMA channel to stop. It assumes it has been

 * paused by a previous call to dmaengine_terminate_async(), and that no new

 * pending descriptors have been issued with dma_async_issue_pending(). The

 * behaviour is undefined otherwise.

/* -----------------------------------------------------------------------------

 * Interrupt and Tasklet Handling

/**

 * xilinx_dpdma_err - Detect any global error

 * @isr: Interrupt Status Register

 * @eisr: Error Interrupt Status Register

 *

 * Return: True if any global error occurs, or false otherwise.

/**

 * xilinx_dpdma_handle_err_irq - Handle DPDMA error interrupt

 * @xdev: DPDMA device

 * @isr: masked Interrupt Status Register

 * @eisr: Error Interrupt Status Register

 *

 * Handle if any error occurs based on @isr and @eisr. This function disables

 * corresponding error interrupts, and those should be re-enabled once handling

 * is done.

 Disable channel error interrupts until errors are handled. */

/**

 * xilinx_dpdma_enable_irq - Enable interrupts

 * @xdev: DPDMA device

 *

 * Enable interrupts.

/**

 * xilinx_dpdma_disable_irq - Disable interrupts

 * @xdev: DPDMA device

 *

 * Disable interrupts.

/**

 * xilinx_dpdma_chan_err_task - Per channel tasklet for error handling

 * @t: pointer to the tasklet associated with this handler

 *

 * Per channel error handling tasklet. This function waits for the outstanding

 * transaction to complete and triggers error handling. After error handling,

 * re-enable channel error interrupts, and restart the channel if needed.

 Proceed error handling even when polling fails. */

		/*

		 * There's a single VSYNC interrupt that needs to be processed

		 * by each running channel to update the active descriptor.

/* -----------------------------------------------------------------------------

 * Initialization & Cleanup

 Disable all interrupts */

 Stop all channels */

 Clear the interrupt status registers */

 TODO: Can we achieve better granularity ? */

 Start by disabling the IRQ to avoid races during cleanup. */

 end of table */ },

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * DMA driver for Xilinx Video DMA Engine

 *

 * Copyright (C) 2010-2014 Xilinx, Inc. All rights reserved.

 *

 * Based on the Freescale DMA driver.

 *

 * Description:

 * The AXI Video Direct Memory Access (AXI VDMA) core is a soft Xilinx IP

 * core that provides high-bandwidth direct memory access between memory

 * and AXI4-Stream type video target peripherals. The core provides efficient

 * two dimensional DMA operations with independent asynchronous read (S2MM)

 * and write (MM2S) channel operation. It can be configured to have either

 * one channel or two channels. If configured as two channels, one is to

 * transmit to the video device (MM2S) and another is to receive from the

 * video device (S2MM). Initialization, status, interrupt and management

 * registers are accessed through an AXI4-Lite slave interface.

 *

 * The AXI Direct Memory Access (AXI DMA) core is a soft Xilinx IP core that

 * provides high-bandwidth one dimensional direct memory access between memory

 * and AXI4-Stream target peripherals. It supports one receive and one

 * transmit channel, both of them optional at synthesis time.

 *

 * The AXI CDMA, is a soft IP, which provides high-bandwidth Direct Memory

 * Access (DMA) between a memory-mapped source address and a memory-mapped

 * destination address.

 *

 * The AXI Multichannel Direct Memory Access (AXI MCDMA) core is a soft

 * Xilinx IP that provides high-bandwidth direct memory access between

 * memory and AXI4-Stream target peripherals. It provides scatter gather

 * (SG) interface with multiple channels independent configuration support.

 *

 Register/Descriptor Offsets */

 Control Registers */

 Register Direct Mode Registers */

 HW specific definitions */

/*

 * Recoverable errors are DMA Internal error, SOF Early, EOF Early

 * and SOF Late. They are only recoverable when C_FLUSH_ON_FSYNC

 * is enabled in the h/w system.

 Axi VDMA Flush on Fsync bits */

 Delay loop counter to prevent hardware failure */

 AXI DMA Specific Registers/Offsets */

 AXI DMA Specific Masks/Bit fields */

 AXI CDMA Specific Registers/Offsets */

 AXI CDMA Specific Masks */

 AXI MCDMA Specific Registers/Offsets */

 AXI MCDMA Specific Masks/Shifts */

/**

 * struct xilinx_vdma_desc_hw - Hardware Descriptor

 * @next_desc: Next Descriptor Pointer @0x00

 * @pad1: Reserved @0x04

 * @buf_addr: Buffer address @0x08

 * @buf_addr_msb: MSB of Buffer address @0x0C

 * @vsize: Vertical Size @0x10

 * @hsize: Horizontal Size @0x14

 * @stride: Number of bytes between the first

 *	    pixels of each horizontal line @0x18

/**

 * struct xilinx_axidma_desc_hw - Hardware Descriptor for AXI DMA

 * @next_desc: Next Descriptor Pointer @0x00

 * @next_desc_msb: MSB of Next Descriptor Pointer @0x04

 * @buf_addr: Buffer address @0x08

 * @buf_addr_msb: MSB of Buffer address @0x0C

 * @reserved1: Reserved @0x10

 * @reserved2: Reserved @0x14

 * @control: Control field @0x18

 * @status: Status field @0x1C

 * @app: APP Fields @0x20 - 0x30

/**

 * struct xilinx_aximcdma_desc_hw - Hardware Descriptor for AXI MCDMA

 * @next_desc: Next Descriptor Pointer @0x00

 * @next_desc_msb: MSB of Next Descriptor Pointer @0x04

 * @buf_addr: Buffer address @0x08

 * @buf_addr_msb: MSB of Buffer address @0x0C

 * @rsvd: Reserved field @0x10

 * @control: Control Information field @0x14

 * @status: Status field @0x18

 * @sideband_status: Status of sideband signals @0x1C

 * @app: APP Fields @0x20 - 0x30

/**

 * struct xilinx_cdma_desc_hw - Hardware Descriptor

 * @next_desc: Next Descriptor Pointer @0x00

 * @next_desc_msb: Next Descriptor Pointer MSB @0x04

 * @src_addr: Source address @0x08

 * @src_addr_msb: Source address MSB @0x0C

 * @dest_addr: Destination address @0x10

 * @dest_addr_msb: Destination address MSB @0x14

 * @control: Control field @0x18

 * @status: Status field @0x1C

/**

 * struct xilinx_vdma_tx_segment - Descriptor segment

 * @hw: Hardware descriptor

 * @node: Node in the descriptor segments list

 * @phys: Physical address of segment

/**

 * struct xilinx_axidma_tx_segment - Descriptor segment

 * @hw: Hardware descriptor

 * @node: Node in the descriptor segments list

 * @phys: Physical address of segment

/**

 * struct xilinx_aximcdma_tx_segment - Descriptor segment

 * @hw: Hardware descriptor

 * @node: Node in the descriptor segments list

 * @phys: Physical address of segment

/**

 * struct xilinx_cdma_tx_segment - Descriptor segment

 * @hw: Hardware descriptor

 * @node: Node in the descriptor segments list

 * @phys: Physical address of segment

/**

 * struct xilinx_dma_tx_descriptor - Per Transaction structure

 * @async_tx: Async transaction descriptor

 * @segments: TX segments list

 * @node: Node in the channel descriptors list

 * @cyclic: Check for cyclic transfers.

 * @err: Whether the descriptor has an error.

 * @residue: Residue of the completed descriptor

/**

 * struct xilinx_dma_chan - Driver specific DMA channel structure

 * @xdev: Driver specific device structure

 * @ctrl_offset: Control registers offset

 * @desc_offset: TX descriptor registers offset

 * @lock: Descriptor operation lock

 * @pending_list: Descriptors waiting

 * @active_list: Descriptors ready to submit

 * @done_list: Complete descriptors

 * @free_seg_list: Free descriptors

 * @common: DMA common channel

 * @desc_pool: Descriptors pool

 * @dev: The dma device

 * @irq: Channel IRQ

 * @id: Channel ID

 * @direction: Transfer direction

 * @num_frms: Number of frames

 * @has_sg: Support scatter transfers

 * @cyclic: Check for cyclic transfers.

 * @genlock: Support genlock mode

 * @err: Channel has errors

 * @idle: Check for channel idle

 * @terminating: Check for channel being synchronized by user

 * @tasklet: Cleanup work after irq

 * @config: Device configuration info

 * @flush_on_fsync: Flush on Frame sync

 * @desc_pendingcount: Descriptor pending count

 * @ext_addr: Indicates 64 bit addressing is supported by dma channel

 * @desc_submitcount: Descriptor h/w submitted count

 * @seg_v: Statically allocated segments base

 * @seg_mv: Statically allocated segments base for MCDMA

 * @seg_p: Physical allocated segments base

 * @cyclic_seg_v: Statically allocated segment base for cyclic transfers

 * @cyclic_seg_p: Physical allocated segments base for cyclic dma

 * @start_transfer: Differentiate b/w DMA IP's transfer

 * @stop_transfer: Differentiate b/w DMA IP's quiesce

 * @tdest: TDEST value for mcdma

 * @has_vflip: S2MM vertical flip

/**

 * enum xdma_ip_type - DMA IP type.

 *

 * @XDMA_TYPE_AXIDMA: Axi dma ip.

 * @XDMA_TYPE_CDMA: Axi cdma ip.

 * @XDMA_TYPE_VDMA: Axi vdma ip.

 * @XDMA_TYPE_AXIMCDMA: Axi MCDMA ip.

 *

/**

 * struct xilinx_dma_device - DMA device structure

 * @regs: I/O mapped base address

 * @dev: Device Structure

 * @common: DMA device structure

 * @chan: Driver specific DMA channel

 * @flush_on_fsync: Flush on frame sync

 * @ext_addr: Indicates 64 bit addressing is supported by dma device

 * @pdev: Platform device structure pointer

 * @dma_config: DMA config structure

 * @axi_clk: DMA Axi4-lite interace clock

 * @tx_clk: DMA mm2s clock

 * @txs_clk: DMA mm2s stream clock

 * @rx_clk: DMA s2mm clock

 * @rxs_clk: DMA s2mm stream clock

 * @s2mm_chan_id: DMA s2mm channel identifier

 * @mm2s_chan_id: DMA mm2s channel identifier

 * @max_buffer_len: Max buffer length

 Macros */

 IO accessors */

/**

 * vdma_desc_write_64 - 64-bit descriptor write

 * @chan: Driver specific VDMA channel

 * @reg: Register to write

 * @value_lsb: lower address of the descriptor.

 * @value_msb: upper address of the descriptor.

 *

 * Since vdma driver is trying to write to a register offset which is not a

 * multiple of 64 bits(ex : 0x5c), we are writing as two separate 32 bits

 * instead of a single 64 bit register write.

 Write the lsb 32 bits*/

 Write the msb 32 bits */

/* -----------------------------------------------------------------------------

 * Descriptors and segments alloc and free

/**

 * xilinx_vdma_alloc_tx_segment - Allocate transaction segment

 * @chan: Driver specific DMA channel

 *

 * Return: The allocated segment on success and NULL on failure.

/**

 * xilinx_cdma_alloc_tx_segment - Allocate transaction segment

 * @chan: Driver specific DMA channel

 *

 * Return: The allocated segment on success and NULL on failure.

/**

 * xilinx_axidma_alloc_tx_segment - Allocate transaction segment

 * @chan: Driver specific DMA channel

 *

 * Return: The allocated segment on success and NULL on failure.

/**

 * xilinx_aximcdma_alloc_tx_segment - Allocate transaction segment

 * @chan: Driver specific DMA channel

 *

 * Return: The allocated segment on success and NULL on failure.

/**

 * xilinx_dma_free_tx_segment - Free transaction segment

 * @chan: Driver specific DMA channel

 * @segment: DMA transaction segment

/**

 * xilinx_mcdma_free_tx_segment - Free transaction segment

 * @chan: Driver specific DMA channel

 * @segment: DMA transaction segment

/**

 * xilinx_cdma_free_tx_segment - Free transaction segment

 * @chan: Driver specific DMA channel

 * @segment: DMA transaction segment

/**

 * xilinx_vdma_free_tx_segment - Free transaction segment

 * @chan: Driver specific DMA channel

 * @segment: DMA transaction segment

/**

 * xilinx_dma_alloc_tx_descriptor - Allocate transaction descriptor

 * @chan: Driver specific DMA channel

 *

 * Return: The allocated descriptor on success and NULL on failure.

/**

 * xilinx_dma_free_tx_descriptor - Free transaction descriptor

 * @chan: Driver specific DMA channel

 * @desc: DMA transaction descriptor

 Required functions */

/**

 * xilinx_dma_free_desc_list - Free descriptors list

 * @chan: Driver specific DMA channel

 * @list: List to parse and delete the descriptor

/**

 * xilinx_dma_free_descriptors - Free channel descriptors

 * @chan: Driver specific DMA channel

/**

 * xilinx_dma_free_chan_resources - Free channel resources

 * @dchan: DMA channel

 Free memory that is allocated for BD */

 Free Memory that is allocated for cyclic DMA Mode */

 Free memory that is allocated for BD */

/**

 * xilinx_dma_get_residue - Compute residue for a given descriptor

 * @chan: Driver specific dma channel

 * @desc: dma transaction descriptor

 *

 * Return: The number of residue bytes for the descriptor.

/**

 * xilinx_dma_chan_handle_cyclic - Cyclic dma callback

 * @chan: Driver specific dma channel

 * @desc: dma transaction descriptor

 * @flags: flags for spin lock

/**

 * xilinx_dma_chan_desc_cleanup - Clean channel descriptors

 * @chan: Driver specific DMA channel

 Remove from the list of running transactions */

 Run the link descriptor callback function */

 Run any dependencies, then free the descriptor */

		/*

		 * While we ran a callback the user called a terminate function,

		 * which takes care of cleaning up any remaining descriptors

/**

 * xilinx_dma_do_tasklet - Schedule completion tasklet

 * @t: Pointer to the Xilinx DMA channel structure

/**

 * xilinx_dma_alloc_chan_resources - Allocate channel resources

 * @dchan: DMA channel

 *

 * Return: '0' on success and failure value on error

 Has this channel already been allocated? */

	/*

	 * We need the descriptor to be aligned to 64bytes

	 * for meeting Xilinx VDMA specification requirement.

 Allocate the buffer descriptors. */

		/*

		 * For cyclic DMA mode we need to program the tail Descriptor

		 * register with a value which is not a part of the BD chain

		 * so allocating a desc segment during channel allocation for

		 * programming tail descriptor.

 Allocate the buffer descriptors. */

		/* For AXI DMA resetting once channel will reset the

		 * other channel as well so enable the interrupts here.

/**

 * xilinx_dma_calc_copysize - Calculate the amount of data to copy

 * @chan: Driver specific DMA channel

 * @size: Total data that needs to be copied

 * @done: Amount of data that has been already copied

 *

 * Return: Amount of data that has to be copied

		/*

		 * If this is not the last descriptor, make sure

		 * the next one will be properly aligned

/**

 * xilinx_dma_tx_status - Get DMA transaction status

 * @dchan: DMA channel

 * @cookie: Transaction identifier

 * @txstate: Transaction state

 *

 * Return: DMA transaction status

		/*

		 * VDMA and simple mode do not support residue reporting, so the

		 * residue field will always be 0.

/**

 * xilinx_dma_stop_transfer - Halt DMA channel

 * @chan: Driver specific DMA channel

 *

 * Return: '0' on success and failure value on error

 Wait for the hardware to halt */

/**

 * xilinx_cdma_stop_transfer - Wait for the current transfer to complete

 * @chan: Driver specific DMA channel

 *

 * Return: '0' on success and failure value on error

/**

 * xilinx_dma_start - Start DMA channel

 * @chan: Driver specific DMA channel

 Wait for the hardware to start */

/**

 * xilinx_vdma_start_transfer - Starts VDMA transfer

 * @chan: Driver specific channel struct pointer

 This function was invoked with lock held */

 Configure the hardware using info in the config structure */

 If not parking, enable circular mode */

 Start the hardware */

 Start the transfer */

 HW expects these parameters to be same for one transaction */

/**

 * xilinx_cdma_start_transfer - Starts cdma transfer

 * @chan: Driver specific channel struct pointer

 Update tail ptr register which will start the transfer */

 In simple mode */

 Start the transfer */

/**

 * xilinx_dma_start_transfer - Starts DMA transfer

 * @chan: Driver specific channel struct pointer

 Start the transfer */

 Start the transfer */

/**

 * xilinx_mcdma_start_transfer - Starts MCDMA transfer

 * @chan: Driver specific channel struct pointer

	/*

	 * lock has been held by calling functions, so we don't need it

	 * to take it here again.

 Program current descriptor */

 Program channel enable register */

 Start the fetch of BDs for the channel */

 Start the transfer */

/**

 * xilinx_dma_issue_pending - Issue pending transactions

 * @dchan: DMA channel

/**

 * xilinx_dma_device_config - Configure the DMA channel

 * @dchan: DMA channel

 * @config: channel configuration

/**

 * xilinx_dma_complete_descriptor - Mark the active descriptor as complete

 * @chan : xilinx DMA channel

 *

 * CONTEXT: hardirq

 This function was invoked with lock held */

/**

 * xilinx_dma_reset - Reset DMA channel

 * @chan: Driver specific DMA channel

 *

 * Return: '0' on success and failure value on error

 Wait for the hardware to finish reset */

/**

 * xilinx_dma_chan_reset - Reset DMA channel and enable interrupts

 * @chan: Driver specific DMA channel

 *

 * Return: '0' on success and failure value on error

 Reset VDMA */

 Enable interrupts */

/**

 * xilinx_mcdma_irq_handler - MCDMA Interrupt handler

 * @irq: IRQ number

 * @data: Pointer to the Xilinx MCDMA channel structure

 *

 * Return: IRQ_HANDLED/IRQ_NONE

 Read the channel id raising the interrupt*/

 Read the status and ack the interrupts. */

		/*

		 * Device takes too long to do the transfer when user requires

		 * responsiveness.

/**

 * xilinx_dma_irq_handler - DMA Interrupt handler

 * @irq: IRQ number

 * @data: Pointer to the Xilinx DMA channel structure

 *

 * Return: IRQ_HANDLED/IRQ_NONE

 Read the status and ack the interrupts. */

		/*

		 * An error occurred. If C_FLUSH_ON_FSYNC is enabled and the

		 * error is recoverable, ignore it. Otherwise flag the error.

		 *

		 * Only recoverable errors can be cleared in the DMASR register,

		 * make sure not to write to other error bits to 1.

		/*

		 * Device takes too long to do the transfer when user requires

		 * responsiveness.

/**

 * append_desc_queue - Queuing descriptor

 * @chan: Driver specific dma channel

 * @desc: dma transaction descriptor

	/*

	 * Add the hardware descriptor to the chain of hardware descriptors

	 * that already exists in memory.

	/*

	 * Add the software descriptor and all children to the list

	 * of pending transactions

/**

 * xilinx_dma_tx_submit - Submit DMA transaction

 * @tx: Async transaction descriptor

 *

 * Return: cookie value on success and failure value on error

		/*

		 * If reset fails, need to hard reset the system.

		 * Channel is no longer functional

 Put this transaction onto the tail of the pending queue */

/**

 * xilinx_vdma_dma_prep_interleaved - prepare a descriptor for a

 *	DMA_SLAVE transaction

 * @dchan: DMA channel

 * @xt: Interleaved template pointer

 * @flags: transfer ack flags

 *

 * Return: Async transaction descriptor on success and NULL on failure

 Allocate a transaction descriptor. */

 Allocate the link descriptor from DMA pool */

 Fill in the hardware descriptor */

 Insert the segment into the descriptor segments list. */

 Link the last hardware descriptor with the first. */

/**

 * xilinx_cdma_prep_memcpy - prepare descriptors for a memcpy transaction

 * @dchan: DMA channel

 * @dma_dst: destination address

 * @dma_src: source address

 * @len: transfer length

 * @flags: transfer ack flags

 *

 * Return: Async transaction descriptor on success and NULL on failure

 Allocate the link descriptor from DMA pool */

 Insert the segment into the descriptor segments list. */

/**

 * xilinx_dma_prep_slave_sg - prepare descriptors for a DMA_SLAVE transaction

 * @dchan: DMA channel

 * @sgl: scatterlist to transfer to/from

 * @sg_len: number of entries in @scatterlist

 * @direction: DMA direction

 * @flags: transfer ack flags

 * @context: APP words of the descriptor

 *

 * Return: Async transaction descriptor on success and NULL on failure

 Allocate a transaction descriptor. */

 Build transactions using information in the scatter gather list */

 Loop until the entire scatterlist entry is used */

 Get a free segment */

			/*

			 * Calculate the maximum number of bytes to transfer,

			 * making sure it is less than the hw limit

 Fill in the descriptor */

			/*

			 * Insert the segment into the descriptor segments

			 * list.

 For the last DMA_MEM_TO_DEV transfer, set EOP */

/**

 * xilinx_dma_prep_dma_cyclic - prepare descriptors for a DMA_SLAVE transaction

 * @dchan: DMA channel

 * @buf_addr: Physical address of the buffer

 * @buf_len: Total length of the cyclic buffers

 * @period_len: length of individual cyclic buffer

 * @direction: DMA direction

 * @flags: transfer ack flags

 *

 * Return: Async transaction descriptor on success and NULL on failure

 Allocate a transaction descriptor. */

 Get a free segment */

			/*

			 * Calculate the maximum number of bytes to transfer,

			 * making sure it is less than the hw limit

			/*

			 * Insert the segment into the descriptor segments

			 * list.

 For the last DMA_MEM_TO_DEV transfer, set EOP */

/**

 * xilinx_mcdma_prep_slave_sg - prepare descriptors for a DMA_SLAVE transaction

 * @dchan: DMA channel

 * @sgl: scatterlist to transfer to/from

 * @sg_len: number of entries in @scatterlist

 * @direction: DMA direction

 * @flags: transfer ack flags

 * @context: APP words of the descriptor

 *

 * Return: Async transaction descriptor on success and NULL on failure

 Allocate a transaction descriptor. */

 Build transactions using information in the scatter gather list */

 Loop until the entire scatterlist entry is used */

 Get a free segment */

			/*

			 * Calculate the maximum number of bytes to transfer,

			 * making sure it is less than the hw limit

 Fill in the descriptor */

			/*

			 * Insert the segment into the descriptor segments

			 * list.

 For the last DMA_MEM_TO_DEV transfer, set EOP */

/**

 * xilinx_dma_terminate_all - Halt the channel and free descriptors

 * @dchan: Driver specific DMA Channel pointer

 *

 * Return: '0' always.

 Remove and free all of the descriptors in the lists */

/**

 * xilinx_vdma_channel_set_config - Configure VDMA channel

 * Run-time configuration for Axi VDMA, supports:

 * . halt the channel

 * . configure interrupt coalescing and inter-packet delay threshold

 * . start/stop parking

 * . enable genlock

 *

 * @dchan: DMA channel

 * @cfg: VDMA device configuration pointer

 *

 * Return: '0' on success and failure value on error

 genlock settings */

 FSync Source selection */

/* -----------------------------------------------------------------------------

 * Probe and remove

/**

 * xilinx_dma_chan_remove - Per Channel remove function

 * @chan: Driver specific DMA channel

 Disable all interrupts */

/**

 * xilinx_dma_chan_probe - Per Channel Probing

 * It get channel features from the device tree entry and

 * initialize special channel handling routines

 *

 * @xdev: Driver specific device structure

 * @node: Device node

 *

 * Return: '0' on success and failure value on error

 Allocate and initialize the channel structure */

	/* This variable ensures that descriptors are not

	 * Submitted when dma engine is in progress. This variable is

	 * Added to avoid polling for a bit in the status register to

	 * Know dma state in the driver hot path.

 Retrieve the channel properties from the device tree */

 Convert bits to bytes */

 If data width is greater than 8 bytes, DRE is not in hw */

 Request the interrupt */

 check if SG is enabled (only for AXIDMA, AXIMCDMA, and CDMA) */

 Initialize the tasklet */

	/*

	 * Initialize the DMA channel and add it to the DMA engine channels

	 * list.

 Reset the channel */

/**

 * xilinx_dma_child_probe - Per child node probe

 * It get number of dma-channels per child node from

 * device-tree and initializes all the channels.

 *

 * @xdev: Driver specific device structure

 * @node: Device node

 *

 * Return: 0 always.

/**

 * of_dma_xilinx_xlate - Translation function

 * @dma_spec: Pointer to DMA specifier as found in the device tree

 * @ofdma: Pointer to DMA controller data

 *

 * Return: DMA channel pointer on success and NULL on error

/**

 * xilinx_dma_probe - Driver probe function

 * @pdev: Pointer to the platform_device structure

 *

 * Return: '0' on success and failure value on error

 Allocate and initialize the DMA engine structure */

 Request and map I/O memory */

 Retrieve the DMA engine properties from the device tree */

 Set the dma mask bits */

 Initialize the DMA engine */

 Residue calculation is supported by only AXI DMA and CDMA */

 Residue calculation is supported by only AXI DMA and CDMA */

 Initialize the channels */

 Register the DMA engine with the core */

/**

 * xilinx_dma_remove - Driver remove function

 * @pdev: Pointer to the platform_device structure

 *

 * Return: Always '0'

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * DMA driver for Xilinx ZynqMP DMA Engine

 *

 * Copyright (C) 2016 Xilinx, Inc. All rights reserved.

 Register Offsets */

 Interrupt registers bit field definitions */

 Control 0 register bit field definitions */

 Control 1 register bit field definitions */

 Data Attribute register bit field definitions */

 Descriptor Attribute register bit field definitions */

 Control register 2 bit field definitions */

 Buffer Descriptor definitions */

 Interrupt Mask specific definitions */

 Max number of descriptors per channel */

 Max transfer size per descriptor */

 Max burst lengths */

 Reset values for data attributes */

 Bus width in bits */

/**

 * struct zynqmp_dma_desc_ll - Hw linked list descriptor

 * @addr: Buffer address

 * @size: Size of the buffer

 * @ctrl: Control word

 * @nxtdscraddr: Next descriptor base address

 * @rsvd: Reserved field and for Hw internal use.

/**

 * struct zynqmp_dma_desc_sw - Per Transaction structure

 * @src: Source address for simple mode dma

 * @dst: Destination address for simple mode dma

 * @len: Transfer length for simple mode dma

 * @node: Node in the channel descriptor list

 * @tx_list: List head for the current transfer

 * @async_tx: Async transaction descriptor

 * @src_v: Virtual address of the src descriptor

 * @src_p: Physical address of the src descriptor

 * @dst_v: Virtual address of the dst descriptor

 * @dst_p: Physical address of the dst descriptor

/**

 * struct zynqmp_dma_chan - Driver specific DMA channel structure

 * @zdev: Driver specific device structure

 * @regs: Control registers offset

 * @lock: Descriptor operation lock

 * @pending_list: Descriptors waiting

 * @free_list: Descriptors free

 * @active_list: Descriptors active

 * @sw_desc_pool: SW descriptor pool

 * @done_list: Complete descriptors

 * @common: DMA common channel

 * @desc_pool_v: Statically allocated descriptor base

 * @desc_pool_p: Physical allocated descriptor base

 * @desc_free_cnt: Descriptor available count

 * @dev: The dma device

 * @irq: Channel IRQ

 * @is_dmacoherent: Tells whether dma operations are coherent or not

 * @tasklet: Cleanup work after irq

 * @idle : Channel status;

 * @desc_size: Size of the low level descriptor

 * @err: Channel has errors

 * @bus_width: Bus width

 * @src_burst_len: Source burst length

 * @dst_burst_len: Dest burst length

/**

 * struct zynqmp_dma_device - DMA device structure

 * @dev: Device Structure

 * @common: DMA device structure

 * @chan: Driver specific DMA channel

 * @clk_main: Pointer to main clock

 * @clk_apb: Pointer to apb clock

/**

 * zynqmp_dma_update_desc_to_ctrlr - Updates descriptor to the controller

 * @chan: ZynqMP DMA DMA channel pointer

 * @desc: Transaction descriptor pointer

/**

 * zynqmp_dma_desc_config_eod - Mark the descriptor as end descriptor

 * @chan: ZynqMP DMA channel pointer

 * @desc: Hw descriptor pointer

/**

 * zynqmp_dma_config_sg_ll_desc - Configure the linked list descriptor

 * @chan: ZynqMP DMA channel pointer

 * @sdesc: Hw descriptor pointer

 * @src: Source buffer address

 * @dst: Destination buffer address

 * @len: Transfer length

 * @prev: Previous hw descriptor pointer

/**

 * zynqmp_dma_init - Initialize the channel

 * @chan: ZynqMP DMA channel pointer

 Clearing the interrupt account rgisters */

/**

 * zynqmp_dma_tx_submit - Submit DMA transaction

 * @tx: Async transaction descriptor pointer

 *

 * Return: cookie value

/**

 * zynqmp_dma_get_descriptor - Get the sw descriptor from the pool

 * @chan: ZynqMP DMA channel pointer

 *

 * Return: The sw descriptor

 Clear the src and dst descriptor memory */

/**

 * zynqmp_dma_free_descriptor - Issue pending transactions

 * @chan: ZynqMP DMA channel pointer

 * @sdesc: Transaction descriptor pointer

/**

 * zynqmp_dma_free_desc_list - Free descriptors list

 * @chan: ZynqMP DMA channel pointer

 * @list: List to parse and delete the descriptor

/**

 * zynqmp_dma_alloc_chan_resources - Allocate channel resources

 * @dchan: DMA channel

 *

 * Return: Number of descriptors on success and failure value on error

/**

 * zynqmp_dma_start - Start DMA channel

 * @chan: ZynqMP DMA channel pointer

/**

 * zynqmp_dma_handle_ovfl_int - Process the overflow interrupt

 * @chan: ZynqMP DMA channel pointer

 * @status: Interrupt status value

/**

 * zynqmp_dma_device_config - Zynqmp dma device configuration

 * @dchan: DMA channel

 * @config: DMA device config

 *

 * Return: 0 always

/**

 * zynqmp_dma_start_transfer - Initiate the new transfer

 * @chan: ZynqMP DMA channel pointer

/**

 * zynqmp_dma_chan_desc_cleanup - Cleanup the completed descriptors

 * @chan: ZynqMP DMA channel

 Run any dependencies, then free the descriptor */

/**

 * zynqmp_dma_complete_descriptor - Mark the active descriptor as complete

 * @chan: ZynqMP DMA channel pointer

/**

 * zynqmp_dma_issue_pending - Issue pending transactions

 * @dchan: DMA channel pointer

/**

 * zynqmp_dma_free_descriptors - Free channel descriptors

 * @chan: ZynqMP DMA channel pointer

/**

 * zynqmp_dma_free_chan_resources - Free channel resources

 * @dchan: DMA channel pointer

/**

 * zynqmp_dma_reset - Reset the channel

 * @chan: ZynqMP DMA channel pointer

/**

 * zynqmp_dma_irq_handler - ZynqMP DMA Interrupt handler

 * @irq: IRQ number

 * @data: Pointer to the ZynqMP DMA channel structure

 *

 * Return: IRQ_HANDLED/IRQ_NONE

/**

 * zynqmp_dma_do_tasklet - Schedule completion tasklet

 * @t: Pointer to the ZynqMP DMA channel structure

/**

 * zynqmp_dma_device_terminate_all - Aborts all transfers on a channel

 * @dchan: DMA channel pointer

 *

 * Return: Always '0'

/**

 * zynqmp_dma_prep_memcpy - prepare descriptors for memcpy transaction

 * @dchan: DMA channel

 * @dma_dst: Destination buffer address

 * @dma_src: Source buffer address

 * @len: Transfer length

 * @flags: transfer ack flags

 *

 * Return: Async transaction descriptor on success and NULL on failure

 Allocate and populate the descriptor */

/**

 * zynqmp_dma_chan_remove - Channel remove function

 * @chan: ZynqMP DMA channel pointer

/**

 * zynqmp_dma_chan_probe - Per Channel Probing

 * @zdev: Driver specific device structure

 * @pdev: Pointer to the platform_device structure

 *

 * Return: '0' on success and failure value on error

/**

 * of_zynqmp_dma_xlate - Translation function

 * @dma_spec: Pointer to DMA specifier as found in the device tree

 * @ofdma: Pointer to DMA controller data

 *

 * Return: DMA channel pointer on success and NULL on error

/**

 * zynqmp_dma_suspend - Suspend method for the driver

 * @dev:	Address of the device structure

 *

 * Put the driver into low power mode.

 * Return: 0 on success and failure value on error

/**

 * zynqmp_dma_resume - Resume from suspend

 * @dev:	Address of the device structure

 *

 * Resume operation after suspend.

 * Return: 0 on success and failure value on error

/**

 * zynqmp_dma_runtime_suspend - Runtime suspend method for the driver

 * @dev:	Address of the device structure

 *

 * Put the driver into low power mode.

 * Return: 0 always

/**

 * zynqmp_dma_runtime_resume - Runtime suspend method for the driver

 * @dev:	Address of the device structure

 *

 * Put the driver into low power mode.

 * Return: 0 always

/**

 * zynqmp_dma_probe - Driver probe function

 * @pdev: Pointer to the platform_device structure

 *

 * Return: '0' on success and failure value on error

/**

 * zynqmp_dma_remove - Driver remove function

 * @pdev: Pointer to the platform_device structure

 *

 * Return: Always '0'

 SPDX-License-Identifier: GPL-2.0

/*

 * Renesas RZ/G2L DMA Controller Driver

 *

 * Based on imx-dma.c

 *

 * Copyright (C) 2021 Renesas Electronics Corp.

 * Copyright 2010 Sascha Hauer, Pengutronix <s.hauer@pengutronix.de>

 * Copyright 2012 Javier Martin, Vista Silicon <javier.martin@vista-silicon.com>

 For slave sg */

/*

 * -----------------------------------------------------------------------------

 * Registers

 LINK MODE DESCRIPTOR */

/*

 * -----------------------------------------------------------------------------

 * Device access

/*

 * -----------------------------------------------------------------------------

 * Initialization

/*

 * -----------------------------------------------------------------------------

 * Descriptors preparation

 prepare descriptor */

/*

 * -----------------------------------------------------------------------------

 * DMA engine operations

	/*

	 * Place holder

	 * Descriptor allocation is done during alloc_chan_resources and

	 * get freed during free_chan_resources.

	 * list is used to manage the descriptors and avoid any memory

	 * allocation/free during DMA read/write.

/*

 * -----------------------------------------------------------------------------

 * IRQ handling

 handle DMAERR irq */

 Someone might have called terminate all */

/*

 * -----------------------------------------------------------------------------

 * OF xlate and channel filter

 Only slave DMA channels can be allocated via DT */

/*

 * -----------------------------------------------------------------------------

 * Probe and remove

 Request the channel interrupt. */

 Set io base address for each channel */

 Allocate descriptors */

 Initialize register for each channel */

 Request resources */

 Register interrupt handler for error */

 Initialize the channels. */

 Register the DMAC as a DMA provider for DT. */

 Register the DMA engine device. */

 Sentinel */ }

 SPDX-License-Identifier: GPL-2.0

/*

 * Renesas R-Car Gen2/Gen3 DMA Controller Driver

 *

 * Copyright (C) 2014-2019 Renesas Electronics Inc.

 *

 * Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

/*

 * struct rcar_dmac_xfer_chunk - Descriptor for a hardware transfer

 * @node: entry in the parent's chunks list

 * @src_addr: device source address

 * @dst_addr: device destination address

 * @size: transfer size in bytes

/*

 * struct rcar_dmac_hw_desc - Hardware descriptor for a transfer chunk

 * @sar: value of the SAR register (source address)

 * @dar: value of the DAR register (destination address)

 * @tcr: value of the TCR register (transfer count)

/*

 * struct rcar_dmac_desc - R-Car Gen2 DMA Transfer Descriptor

 * @async_tx: base DMA asynchronous transaction descriptor

 * @direction: direction of the DMA transfer

 * @xfer_shift: log2 of the transfer size

 * @chcr: value of the channel configuration register for this transfer

 * @node: entry in the channel's descriptors lists

 * @chunks: list of transfer chunks for this transfer

 * @running: the transfer chunk being currently processed

 * @nchunks: number of transfer chunks for this transfer

 * @hwdescs.use: whether the transfer descriptor uses hardware descriptors

 * @hwdescs.mem: hardware descriptors memory for the transfer

 * @hwdescs.dma: device address of the hardware descriptors memory

 * @hwdescs.size: size of the hardware descriptors in bytes

 * @size: transfer size in bytes

 * @cyclic: when set indicates that the DMA transfer is cyclic

/*

 * struct rcar_dmac_desc_page - One page worth of descriptors

 * @node: entry in the channel's pages list

 * @descs: array of DMA descriptors

 * @chunks: array of transfer chunk descriptors

/*

 * struct rcar_dmac_chan_slave - Slave configuration

 * @slave_addr: slave memory address

 * @xfer_size: size (in bytes) of hardware transfers

/*

 * struct rcar_dmac_chan_map - Map of slave device phys to dma address

 * @addr: slave dma address

 * @dir: direction of mapping

 * @slave: slave configuration that is mapped

/*

 * struct rcar_dmac_chan - R-Car Gen2 DMA Controller Channel

 * @chan: base DMA channel object

 * @iomem: channel I/O memory base

 * @index: index of this channel in the controller

 * @irq: channel IRQ

 * @src: slave memory address and size on the source side

 * @dst: slave memory address and size on the destination side

 * @mid_rid: hardware MID/RID for the DMA client using this channel

 * @lock: protects the channel CHCR register and the desc members

 * @desc.free: list of free descriptors

 * @desc.pending: list of pending descriptors (submitted with tx_submit)

 * @desc.active: list of active descriptors (activated with issue_pending)

 * @desc.done: list of completed descriptors

 * @desc.wait: list of descriptors waiting for an ack

 * @desc.running: the descriptor being processed (a member of the active list)

 * @desc.chunks_free: list of free transfer chunk descriptors

 * @desc.pages: list of pages used by allocated descriptors

/*

 * struct rcar_dmac - R-Car Gen2 DMA Controller

 * @engine: base DMA engine object

 * @dev: the hardware device

 * @dmac_base: remapped base register block

 * @chan_base: remapped channel register block (optional)

 * @n_channels: number of available channels

 * @channels: array of DMAC channels

 * @channels_mask: bitfield of which DMA channels are managed by this driver

 * @modules: bitmask of client modules in use

/*

 * struct rcar_dmac_of_data - This driver's OF data

 * @chan_offset_base: DMAC channels base offset

 * @chan_offset_stride: DMAC channels offset stride

/* -----------------------------------------------------------------------------

 * Registers

 Not on R-Car V3U */

 For R-Car V3U */

 Hardcode the MEMCPY transfer size to 4 bytes. */

/* -----------------------------------------------------------------------------

 * Device access

/* -----------------------------------------------------------------------------

 * Initialization and configuration

		/*

		 * Errata: When descriptor memory is accessed through an IOMMU

		 * the DMADAR register isn't initialized automatically from the

		 * first descriptor at beginning of transfer by the DMAC like it

		 * should. Initialize it manually with the destination address

		 * of the first chunk.

		/*

		 * Program the descriptor stage interrupt to occur after the end

		 * of the first stage.

		/*

		 * If the descriptor isn't cyclic enable normal descriptor mode

		 * and the transfer completion interrupt.

		/*

		 * If the descriptor is cyclic and has a callback enable the

		 * descriptor stage interrupt in infinite repeat mode.

		/*

		 * Otherwise just select infinite repeat mode without any

		 * interrupt.

 Clear all channels and enable the DMAC globally. */

/* -----------------------------------------------------------------------------

 * Descriptors submission

/* -----------------------------------------------------------------------------

 * Descriptors allocation and free

/*

 * rcar_dmac_desc_alloc - Allocate a page worth of DMA descriptors

 * @chan: the DMA channel

 * @gfp: allocation flags

/*

 * rcar_dmac_desc_put - Release a DMA transfer descriptor

 * @chan: the DMA channel

 * @desc: the descriptor

 *

 * Put the descriptor and its transfer chunk descriptors back in the channel's

 * free descriptors lists. The descriptor's chunks list will be reinitialized to

 * an empty list as a result.

 *

 * The descriptor must have been removed from the channel's lists before calling

 * this function.

	/*

	 * We have to temporarily move all descriptors from the wait list to a

	 * local list as iterating over the wait list, even with

	 * list_for_each_entry_safe, isn't safe if we release the channel lock

	 * around the rcar_dmac_desc_put() call.

 Put the remaining descriptors back in the wait list. */

/*

 * rcar_dmac_desc_get - Allocate a descriptor for a DMA transfer

 * @chan: the DMA channel

 *

 * Locking: This function must be called in a non-atomic context.

 *

 * Return: A pointer to the allocated descriptor or NULL if no descriptor can

 * be allocated.

 Recycle acked descriptors before attempting allocation. */

		/*

		 * No free descriptors, allocate a page worth of them and try

		 * again, as someone else could race us to get the newly

		 * allocated descriptors. If the allocation fails return an

		 * error.

/*

 * rcar_dmac_xfer_chunk_alloc - Allocate a page worth of transfer chunks

 * @chan: the DMA channel

 * @gfp: allocation flags

/*

 * rcar_dmac_xfer_chunk_get - Allocate a transfer chunk for a DMA transfer

 * @chan: the DMA channel

 *

 * Locking: This function must be called in a non-atomic context.

 *

 * Return: A pointer to the allocated transfer chunk descriptor or NULL if no

 * descriptor can be allocated.

		/*

		 * No free descriptors, allocate a page worth of them and try

		 * again, as someone else could race us to get the newly

		 * allocated descriptors. If the allocation fails return an

		 * error.

	/*

	 * dma_alloc_coherent() allocates memory in page size increments. To

	 * avoid reallocating the hardware descriptors when the allocated size

	 * wouldn't change align the requested size to a multiple of the page

	 * size.

/* -----------------------------------------------------------------------------

 * Stop and reset

	/*

	 * Ensure that the setting of the DE bit is actually 0 after

	 * clearing it.

 set DE=0 and flush remaining data */

 make sure all remaining data was flushed */

 Move all non-free descriptors to the local lists. */

 Stop all channels. */

 Stop and reinitialize the channel. */

/* -----------------------------------------------------------------------------

 * Descriptors preparation

/*

 * rcar_dmac_chan_prep_sg - prepare transfer descriptors from an SG list

 *

 * Common routine for public (MEMCPY) and slave DMA. The MEMCPY case is also

 * converted to scatter-gather to guarantee consistent locking and a correct

 * list manipulation. For slave DMA direction carries the usual meaning, and,

 * logically, the SG list is RAM and the addr variable contains slave address,

 * e.g., the FIFO I/O register. For MEMCPY direction equals DMA_MEM_TO_MEM

 * and the SG list contains only one element and points at the source buffer.

	/*

	 * Allocate and fill the transfer chunk descriptors. We own the only

	 * reference to the DMA descriptor, there's no need for locking.

			/*

			 * Prevent individual transfers from crossing 4GB

			 * boundaries.

	/*

	 * Use hardware descriptor lists if possible when more than one chunk

	 * needs to be transferred (otherwise they don't make much sense).

	 *

	 * Source/Destination address should be located in same 4GiB region

	 * in the 40bit address space when it uses Hardware descriptor,

	 * and cross_boundary is checking it.

/* -----------------------------------------------------------------------------

 * DMA engine operations

 Preallocate descriptors. */

 Protect against ISR */

	/*

	 * Now no new interrupts will occur, but one might already be

	 * running. Wait for it to finish before freeing resources.

 The caller is holding dma_list_mutex */

 Remove slave mapping if present. */

 Reuse current map if possible. */

 Remove old mapping if present. */

 Create new slave address map. */

 Someone calling slave DMA on a generic channel? */

 Someone calling slave DMA on a generic channel? */

	/*

	 * Allocate the sg list dynamically as it would consume too much stack

	 * space.

	/*

	 * We could lock this, but you shouldn't be configuring the

	 * channel, while using it...

	/*

	 * FIXME: No new interrupt can occur now, but the IRQ thread might still

	 * be running.

	/*

	 * If the cookie corresponds to a descriptor that has been completed

	 * there is no residue. The same check has already been performed by the

	 * caller but without holding the channel lock, so the descriptor could

	 * now be complete.

	/*

	 * If the cookie doesn't correspond to the currently running transfer

	 * then the descriptor hasn't been processed yet, and the residue is

	 * equal to the full descriptor size.

	 * Also, a client driver is possible to call this function before

	 * rcar_dmac_isr_channel_thread() runs. In this case, the "desc.running"

	 * will be the next descriptor, and the done list will appear. So, if

	 * the argument cookie matches the done list's cookie, we can assume

	 * the residue is zero.

		/*

		 * No descriptor found for the cookie, there's thus no residue.

		 * This shouldn't happen if the calling driver passes a correct

		 * cookie value.

	/*

	 * We need to read two registers.

	 * Make sure the control register does not skip to next chunk

	 * while reading the counter.

	 * Trying it 3 times should be enough: Initial read, retry, retry

	 * for the paranoid.

 Still the same? */

	/*

	 * In descriptor mode the descriptor running pointer is not maintained

	 * by the interrupt handler, find the running descriptor from the

	 * descriptor pointer field in the CHCRB register. In non-descriptor

	 * mode just use the running descriptor pointer.

 Compute the size of all chunks still to be transferred. */

 Add the residue for the current chunk. */

 if there's no residue, the cookie is complete */

 Append the pending list to the active list. */

	/*

	 * If no transfer is running pick the first descriptor from the active

	 * list and start the transfer.

/* -----------------------------------------------------------------------------

 * IRQ handling

		/*

		 * This should never happen, there should always be a running

		 * cyclic descriptor when a descriptor stage end interrupt is

		 * triggered. Warn and return.

 Program the interrupt pointer to the next stage. */

		/*

		 * This should never happen, there should always be a running

		 * descriptor when a transfer end interrupt is triggered. Warn

		 * and return.

	/*

	 * The transfer end interrupt isn't generated for each chunk when using

	 * descriptor mode. Only update the running chunk pointer in

	 * non-descriptor mode.

		/*

		 * If we haven't completed the last transfer chunk simply move

		 * to the next one. Only wake the IRQ thread if the transfer is

		 * cyclic.

		/*

		 * We've completed the last transfer chunk. If the transfer is

		 * cyclic, move back to the first one.

 The descriptor is complete, move it to the done list. */

 Queue the next descriptor, if any. */

		/*

		 * We don't need to call rcar_dmac_chan_halt()

		 * because channel is already stopped in error case.

		 * We need to clear register and check DE bit as recovery.

 For cyclic transfers notify the user after every chunk. */

	/*

	 * Call the callback function for all descriptors on the done list and

	 * move them to the ack wait list.

			/*

			 * We own the only reference to this descriptor, we can

			 * safely dereference it without holding the channel

			 * lock.

 Recycle all acked descriptors. */

/* -----------------------------------------------------------------------------

 * OF xlate and channel filter

	/*

	 * FIXME: Using a filter on OF platforms is a nonsense. The OF xlate

	 * function knows from which device it wants to allocate a channel from,

	 * and would be perfectly capable of selecting the channel it wants.

	 * Forcing it to call dma_request_channel() and iterate through all

	 * channels from all controllers is just pointless.

 Only slave DMA channels can be allocated via DT */

/* -----------------------------------------------------------------------------

 * Power management

	/*

	 * TODO for system sleep/resume:

	 *   - Wait for the current transfer to complete and stop the device,

	 *   - Resume transfers, if any.

/* -----------------------------------------------------------------------------

 * Probe and remove

 Request the channel interrupt. */

	/*

	 * Initialize the DMA engine channel and add it to the DMA engine

	 * channels list.

 The hardware and driver don't support more than 32 bits in CHCLR */

	/*

	 * If the driver is unable to read dma-channel-mask property,

	 * the driver assumes that it can use all channels.

 If the property has out-of-channel mask, this driver clears it */

	/*

	 * A still unconfirmed hardware bug prevents the IPMMU microTLB 0 to be

	 * flushed correctly, resulting in memory corruption. DMAC 0 channel 0

	 * is connected to microTLB 0 on currently supported platforms, so we

	 * can't use it with the IPMMU. As the IOMMU API operates at the device

	 * level we can't disable it selectively, so ignore channel 0 for now if

	 * the device is part of an IOMMU group.

 Request resources. */

 Enable runtime PM and initialize the device. */

 Initialize engine */

 Register the DMAC as a DMA provider for DT. */

	/*

	 * Register the DMA engine device.

	 *

	 * Default transfer size of 32 bytes requires 32-byte alignment.

 Sentinel */ }

 SPDX-License-Identifier: GPL-2.0

/*

 * Renesas USB DMA Controller Driver

 *

 * Copyright (C) 2015 Renesas Electronics Corporation

 *

 * based on rcar-dmac.c

 * Copyright (C) 2014 Renesas Electronics Inc.

 * Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

/*

 * struct usb_dmac_sg - Descriptor for a hardware transfer

 * @mem_addr: memory address

 * @size: transfer size in bytes

/*

 * struct usb_dmac_desc - USB DMA Transfer Descriptor

 * @vd: base virtual channel DMA transaction descriptor

 * @direction: direction of the DMA transfer

 * @sg_allocated_len: length of allocated sg

 * @sg_len: length of sg

 * @sg_index: index of sg

 * @residue: residue after the DMAC completed a transfer

 * @node: node for desc_got and desc_freed

 * @done_cookie: cookie after the DMAC completed a transfer

 * @sg: information for the transfer

/*

 * struct usb_dmac_chan - USB DMA Controller Channel

 * @vc: base virtual DMA channel object

 * @iomem: channel I/O memory base

 * @index: index of this channel in the controller

 * @irq: irq number of this channel

 * @desc: the current descriptor

 * @descs_allocated: number of descriptors allocated

 * @desc_got: got descriptors

 * @desc_freed: freed descriptors after the DMAC completed a transfer

/*

 * struct usb_dmac - USB DMA Controller

 * @engine: base DMA engine object

 * @dev: the hardware device

 * @iomem: remapped I/O memory base

 * @n_channels: number of available channels

 * @channels: array of DMAC channels

/* -----------------------------------------------------------------------------

 * Registers

 Hardcode the xfer_shift to 5 (32bytes) */

 for descriptors */

/* -----------------------------------------------------------------------------

 * Device access

/* -----------------------------------------------------------------------------

 * Initialization and configuration

	/*

	 * Please refer to the Figure "Example of Final Transaction Valid

	 * Data Transfer Enable (EDTEN) Setting" in the data sheet.

 This function is already held by vc.lock */

 This function is already held by vc.lock */

	/*

	 * Remove this request from vc->desc_issued. Otherwise, this driver

	 * will get the previous value from vchan_next_desc() after a transfer

	 * was completed.

 Clear all channels and enable the DMAC globally. */

/* -----------------------------------------------------------------------------

 * Descriptors allocation and free

 Get a freed descritpor */

 Allocate a new descriptor */

 If allocated the desc, it was added to tail of the list */

/* -----------------------------------------------------------------------------

 * Stop and reset

 Don't issue soft reset if any one of channels is busy */

/* -----------------------------------------------------------------------------

 * DMA engine operations

 Protect against ISR */

	/*

	 * We cannot use USB_DMATCR to calculate residue because USB_DMATCR

	 * has unsuited value to calculate.

 Compute the size of all usb_dmac_sg still to be transferred */

 Add the residue for the current sg */

 a client driver will get residue after DMA_COMPLETE */

/* -----------------------------------------------------------------------------

 * IRQ handling

 Restart the next transfer if this driver has a next desc */

 An interruption of TE will happen after we set FTE */

/* -----------------------------------------------------------------------------

 * OF xlate and channel filter

 USB-DMAC should be used with fixed usb controller's FIFO */

 Only slave DMA channels can be allocated via DT */

/* -----------------------------------------------------------------------------

 * Power management

 CONFIG_PM */

/* -----------------------------------------------------------------------------

 * Probe and remove

 Request the channel interrupt. */

 Request resources. */

 Enable runtime PM and initialize the device. */

 Initialize the channels. */

 Register the DMAC as a DMA provider for DT. */

	/*

	 * Register the DMA engine device.

	 *

	 * Default transfer size of 32 bytes requires 32-byte alignment.

 Sentinel */ }

 SPDX-License-Identifier: GPL-2.0

/*

 * Dmaengine driver base library for DMA controllers, found on SH-based SoCs

 *

 * extracted from shdma.c

 *

 * Copyright (C) 2011-2012 Guennadi Liakhovetski <g.liakhovetski@gmx.de>

 * Copyright (C) 2009 Nobuhiro Iwamatsu <iwamatsu.nobuhiro@renesas.com>

 * Copyright (C) 2009 Renesas Solutions, Inc. All rights reserved.

 * Copyright (C) 2007 Freescale Semiconductor, Inc. All rights reserved.

 DMA descriptor control */

 completed, have to call callback */

 callback called, waiting for ack / re-submit */

/*

 * For slave DMA we assume, that there is a finite number of DMA slaves in the

 * system, and that each such slave can only use a finite number of channels.

 * We use slave channel IDs to make sure, that no such slave channel ID is

 * allocated more than once.

 A bitmask with slave_num bits */

 Called under spin_lock_irq(&schan->chan_lock") */

 DMA work check */

 Find the first not transferred descriptor */

 Mark all chunks of this descriptor as submitted, move to the queue */

		/*

		 * All chunks are on the global ld_free, so, we have to find

		 * the end of the chain ourselves

 Callback goes to the last chunk */

 Have we been reset, while waiting? */

			/*

			 * TODO: .xfer_setup() might fail on some platforms.

			 * Make it int then, on error remove chunks from the

			 * queue again

		/*

		 * Tell .device_issue_pending() not to run the queue, interrupts

		 * will do it anyway

 Called with desc_lock held */

	/*

	 * This relies on the guarantee from dmaengine that alloc_chan_resources

	 * never runs concurrently with itself or free_chan_resources.

 Legacy mode: .private is set in filter */

 Normal mode: real_slave_id was set by filter */

/*

 * This is the standard shdma filter function to be used as a replacement to the

 * "old" method, using the .private pointer.

 * You always have to pass a valid slave id as the argument, old drivers that

 * pass ERR_PTR(-EINVAL) as a filter parameter and set it up in dma_slave_config

 * need to be updated so we can remove the slave_id field from dma_slave_config.

 * parameter. If this filter is used, the slave driver, after calling

 * dma_request_channel(), will also have to call dmaengine_slave_config() with

 * .direction, and either .src_addr or .dst_addr set.

 *

 * NOTE: this filter doesn't support multiple DMAC drivers with the DMA_SLAVE

 * capability! If this becomes a requirement, hardware glue drivers, using this

 * services would have to provide their own filters, which first would check

 * the device driver, similar to how other DMAC drivers, e.g., sa11x0-dma.c, do

 * this, and only then, in case of a match, call this common filter.

 * NOTE 2: This filter function is also used in the DT case by shdma_of_xlate().

 * In that case the MID-RID value is used for slave channel filtering and is

 * passed to this function in the "arg" parameter.

 Only support channels handled by this driver. */

	/*

	 * For DT, the schan->slave_id field is generated by the

	 * set_slave function from the slave ID that is passed in

	 * from xlate. For the non-DT case, the slave ID is

	 * directly passed into the filter function by the driver

 No slave requested - arbitrary channel */

 Is the "exposed" head of a chain acked? */

		/*

		 * queue is ordered, and we use this loop to (1) clean up all

		 * completed descriptors, and to (2) update descriptor flags of

		 * any chunks in a (partially) completed chain

 Call callback on the last chunk */

 Remove from ld_queue list */

 reuse as cyclic */

		/*

		 * Terminating and the loop completed normally: forgive

		 * uncompleted cookies

/*

 * shdma_chan_ld_cleanup - Clean up link descriptors

 *

 * Clean up the ld_queue of DMA channel.

/*

 * shdma_free_chan_resources - Free all resources of the channel.

 Protect against ISR */

 Now no new interrupts will occur */

 Prepared and not submitted descriptors can still be on the queue */

 The caller is holding dma_list_mutex */

/**

 * shdma_add_desc - get, set up and return one transfer descriptor

 * @schan:	DMA channel

 * @flags:	DMA transfer flags

 * @dst:	destination DMA address, incremented when direction equals

 *		DMA_DEV_TO_MEM or DMA_MEM_TO_MEM

 * @src:	source DMA address, incremented when direction equals

 *		DMA_MEM_TO_DEV or DMA_MEM_TO_MEM

 * @len:	DMA transfer length

 * @first:	if NULL, set to the current descriptor and cookie set to -EBUSY

 * @direction:	needed for slave DMA to decide which address to keep constant,

 *		equals DMA_MEM_TO_MEM for MEMCPY

 * Returns 0 or an error

 * Locks: called with desc_lock held

 Allocate the link descriptor from the free list */

 First desc */

 Other desc - invisible to the user */

/*

 * shdma_prep_sg - prepare transfer descriptors from an SG list

 *

 * Common routine for public (MEMCPY) and slave DMA. The MEMCPY case is also

 * converted to scatter-gather to guarantee consistent locking and a correct

 * list manipulation. For slave DMA direction carries the usual meaning, and,

 * logically, the SG list is RAM and the addr variable contains slave address,

 * e.g., the FIFO I/O register. For MEMCPY direction equals DMA_MEM_TO_MEM

 * and the SG list contains only one element and points at the source buffer.

 compiler... */;

 Have to lock the whole loop to protect against concurrent release */

	/*

	 * Chaining:

	 * first descriptor is what user is dealing with in all API calls, its

	 *	cookie is at first set to -EBUSY, at tx-submit to a positive

	 *	number

	 * if more than one chunk is needed further chunks have cookie = -EINVAL

	 * the last chunk, if not equal to the first, has cookie = -ENOSPC

	 * all chunks are linked onto the tx_list head with their .node heads

	 *	only during this function, then they are immediately spliced

	 *	back onto the free list in form of a chain

 Put them back on the free list, so, they don't get lost */

 Someone calling slave DMA on a generic channel? */

 Someone calling slave DMA on a generic channel? */

	/*

	 * Allocate the sg list dynamically as it would consumer too much stack

	 * space.

 Record partial transfer */

	/*

	 * So far only .slave_id is used, but the slave drivers are

	 * encouraged to also set a transfer direction and an address.

	/*

	 * overriding the slave_id through dma_slave_config is deprecated,

	 * but possibly some out-of-tree drivers still do it.

	/*

	 * We could lock this, but you shouldn't be configuring the

	 * channel, while using it...

	/*

	 * If we don't find cookie on the queue, it has been aborted and we have

	 * to report error

 Called from error IRQ or NMI */

 Reset all channels */

 Stop the channel */

 Complete all  */

 Next desc */

 reference struct dma_device */

 Init descripter manage list */

 Add the channel to DMA device channel list */

	/*

	 * Require all call-backs for now, they can trivially be made optional

	 * later as required

 Common and MEMCPY operations */

 Compulsory for DMA_SLAVE fields */

 SPDX-License-Identifier: GPL-2.0+

/*

 * Renesas SuperH DMA Engine support

 *

 * base is drivers/dma/flsdma.c

 *

 * Copyright (C) 2011-2012 Guennadi Liakhovetski <g.liakhovetski@gmx.de>

 * Copyright (C) 2009 Nobuhiro Iwamatsu <iwamatsu.nobuhiro@renesas.com>

 * Copyright (C) 2009 Renesas Solutions, Inc. All rights reserved.

 * Copyright (C) 2007 Freescale Semiconductor, Inc. All rights reserved.

 *

 * - DMA of SuperH does not have Hardware DMA chain mode.

 * - MAX DMA size is 16MB.

 *

 DMA registers */

 Source Address Register */

 Destination Address Register */

 Transfer Count Register */

 Channel Control Register */

 DMA Operation Register */

 USB-DMAC */

 Default MEMCPY transfer size = 2^2 = 4 bytes */

/*

 * Used for write-side mutual exclusion for the global device list,

 * read-side synchronization by way of RCU, and per-controller data.

/*

 * Different DMAC implementations provide different ways to clear DMA channels:

 * (1) none - no CHCLR registers are available

 * (2) one CHCLR register per channel - 0 has to be written to it to clear

 *     channel buffers

 * (3) one CHCLR per several channels - 1 has to be written to the bit,

 *     corresponding to the specific channel to reset it

/*

 * Reset DMA controller

 *

 * SH7780 has two DMAOR register

 working */

 waiting */

	/*

	 * Default configuration for dual address memory-memory transfer.

 If DMA is active, cannot set CHCR. TODO: remove this superfluous check */

 in the case of a missing DMARS resource use first memory window */

 Get the ld start address from ld_queue */

/*

 * Find a slave channel configuration from the contoller list by either a slave

 * ID in the non-DT case, or by a MID/RID value in the DT case

 DMA stop */

 Called from error IRQ or NMI */

 halt the dma controller */

 We cannot detect, which channel caused the error, have to reset all */

 Fast path out if NMIF is not asserted for this controller */

	/*

	 * Only concern ourselves with NMI events.

	 *

	 * Normally we would check the die chain value, but as this needs

	 * to be architecture independent, check for NMI context instead.

		/*

		 * Only stop if one of the controllers has NMIF asserted,

		 * we do not want to interfere with regular address error

		 * handling or NMI events that don't concern the DMACs.

 Run before NMI debug handler and KGDB */

 set up channel irq */

 remove from dmaengine device node */

	/*

	 * Implicit BUG_ON(!sh_chan->config)

	 * This is an exclusive slave DMA operation, may only be called after a

	 * successful slave configuration.

 get platform data */

 DMARS area is optional */

	/*

	 * IRQ resources:

	 * 1. there always must be at least one IRQ IO-resource. On SH4 it is

	 *    the error IRQ, in which case it is the only IRQ in this resource:

	 *    start == end. If it is the only IRQ resource, all channels also

	 *    use the same IRQ.

	 * 2. DMA channel IRQ resources can be specified one per resource or in

	 *    ranges (start != end)

	 * 3. iff all events (channels and, optionally, error) on this

	 *    controller use the same IRQ, only one IRQ resource can be

	 *    specified, otherwise there must be one IRQ per channel, even if

	 *    some of them are equal

	 * 4. if all IRQs on this controller are equal or if some specific IRQs

	 *    specify IORESOURCE_IRQ_SHAREABLE in their resources, they will be

	 *    requested with the IRQF_SHARED flag

 Default transfer size of 32 bytes requires 32-byte alignment */

 platform data */

 reset dma controller - only needed as a test */

 Special case - all multiplexed */

 Create DMA Channel */

 Wire up NMI handling */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * SiFive FU540 Platform DMA driver

 * Copyright (C) 2019 SiFive

 *

 * Based partially on:

 * - drivers/dma/fsl-edma.c

 * - drivers/dma/dw-edma/

 * - drivers/dma/pxa-dma.c

 *

 * See the following sources for further documentation:

 * - Chapter 12 "Platform DMA Engine (PDMA)" of

 *   SiFive FU540-C000 v1.0

 *   https://static.dev.sifive.com/FU540-C000-v1.0.pdf

 fail to recover */

 retry */

 submit next trascatioin if possible */

/**

 * sf_pdma_irq_init() - Init PDMA IRQ Handlers

 * @pdev: pointer of platform_device

 * @pdma: pointer of PDMA engine. Caller should check NULL

 *

 * Initialize DONE and ERROR interrupt handler for 4 channels. Caller should

 * make sure the pointer passed in are non-NULL. This function should be called

 * only one time during the device probe.

 *

 * Context: Any context.

 *

 * Return:

 * * 0		- OK to init all IRQ handlers

 * * -EINVAL	- Fail to request IRQ

/**

 * sf_pdma_setup_chans() - Init settings of each channel

 * @pdma: pointer of PDMA engine. Caller should check NULL

 *

 * Initialize all data structure and register base. Caller should make sure

 * the pointer passed in are non-NULL. This function should be called only

 * one time during the device probe.

 *

 * Context: Any context.

 *

 * Return: none

 Setup capability */

 Setup DMA APIs */

 do early init */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2006-2009 DENX Software Engineering.

 *

 * Author: Yuri Tikhonov <yur@emcraft.com>

 *

 * Further porting to arch/powerpc by

 * 	Anatolij Gustschin <agust@denx.de>

/*

 * This driver supports the asynchrounous DMA copy and RAID engines available

 * on the AMCC PPC440SPe Processors.

 * Based on the Intel Xscale(R) family of I/O Processors (IOP 32x, 33x, 134x)

 * ADMA driver written by D.Williams.

 The list of channels exported by ppc440spe ADMA */

/* This flag is set when want to refetch the xor chain in the interrupt

 * handler

 Pointer to DMA0, DMA1 CP/CS FIFO */

 Pointers to last submitted to DMA0, DMA1 CDBs */

 Pointer to last linked and submitted xor CB */

 This array is used in data-check operations for storing a pattern */

/* Since RXOR operations use the common register (MQ0_CF2H) for setting-up

 * the block size in transactions, then we do not allow to activate more than

 * only one RXOR transactions simultaneously. So use this var to store

 * the information about is RXOR currently active (PPC440SPE_RXOR_RUN bit is

 * set) or not (PPC440SPE_RXOR_RUN is clear).

/* These are used in enable & check routines

/******************************************************************************

 * Command (Descriptor) Blocks low-level routines

/**

 * ppc440spe_desc_init_interrupt - initialize the descriptor for INTERRUPT

 * pseudo operation

 NOP with Command Block Complete Enable */

 NOP with interrupt */

/**

 * ppc440spe_desc_init_null_xor - initialize the descriptor for NULL XOR

 * pseudo operation

/**

 * ppc440spe_desc_init_xor - initialize the descriptor for XOR operation

 Enable interrupt on completion */

/**

 * ppc440spe_desc_init_dma2pq - initialize the descriptor for PQ

 * operation in DMA2 controller

 Enable interrupt on completion */

/**

 * ppc440spe_desc_init_dma01pq - initialize the descriptors for PQ operation

 * with DMA0/1

 Common initialization of a PQ descriptors chain */

	/* WXOR MULTICAST if both P and Q are being computed

	 * MV_SG1_SG2 if Q only

 set 'next' pointer */

			/* this is the last descriptor.

			 * this slot will be pasted from ADMA level

			 * each time it wants to configure parameters

			 * of the transaction (src, dst, ...)

 Set OPS depending on WXOR/RXOR type of operation */

		/* This is a WXOR only chain:

		 * - first descriptors are for zeroing destinations

		 *   if PPC440SPE_ZERO_P/Q set;

		 * - descriptors remained are for GF-XOR operations.

 This is either RXOR-only or mixed RXOR/WXOR */

		/* The first 1 or 2 slots in chain are always RXOR,

		 * if need to calculate P & Q, then there are two

		 * RXOR slots; if only P or only Q, then there is one

 The remaining descs (if any) are WXORs */

/**

 * ppc440spe_desc_init_dma01pqzero_sum - initialize the descriptor

 * for PQ_ZERO_SUM operation

	/*

	 * Initialize starting from 2nd or 3rd descriptor dependent

	 * on dst_cnt. First one or two slots are for cloning P

	 * and/or Q to chan->pdest and/or chan->qdest as we have

	 * to preserve original P/Q.

 initialize each source descriptor in chain */

		/* This is a ZERO_SUM operation:

		 * - <src_cnt> descriptors starting from 2nd or 3rd

		 *   descriptor are for GF-XOR operations;

		 * - remaining <dst_cnt> descriptors are for checking the result

			/* MV_SG1_SG2 if only Q is being verified

			 * MULTICAST if both P and Q are being verified

 DMA_CDB_OPC_DCHECK128 operation */

 set 'next' pointer */

			/* this is the last descriptor.

			 * this slot will be pasted from ADMA level

			 * each time it wants to configure parameters

			 * of the transaction (src, dst, ...)

			/* always enable interrupt generation since we get

			 * the status of pqzero from the handler

/**

 * ppc440spe_desc_init_memcpy - initialize the descriptor for MEMCPY operation

/**

 * ppc440spe_desc_set_src_addr - set source address into the descriptor

/**

 * ppc440spe_desc_set_src_mult - set source address mult into the descriptor

		/* for RXOR operations set multiplier

		 * into source cued address

		/* for WXOR operations set multiplier

		 * into destination cued address(es)

/**

 * ppc440spe_desc_set_dest_addr - set destination address into the descriptor

/**

 * ppc440spe_desc_set_byte_count - set number of data bytes involved

 * into the operation

/**

 * ppc440spe_desc_set_rxor_block_size - set RXOR block size

	/* assume that byte_count is aligned on the 512-boundary;

	 * thus write it directly to the register (bits 23:31 are

	 * reserved there).

/**

 * ppc440spe_desc_set_dcheck - set CHECK pattern

/**

 * ppc440spe_xor_set_link - set link address in xor CB

/**

 * ppc440spe_desc_set_link - set the address of descriptor following this

 * descriptor in chain

		/* If previous next is overwritten something is wrong.

		 * though we may refetch from append to initiate list

		 * processing; in this case - it's ok.

 do s/w chaining both for DMA and XOR descriptors */

 bind descriptor to the chain */

 do not link to the last submitted CB */

/**

 * ppc440spe_desc_get_link - get the address of the descriptor that

 * follows this one

/**

 * ppc440spe_desc_is_aligned - check alignment

/**

 * ppc440spe_chan_xor_slot_count - get the number of slots necessary for

 * XOR operation

 each XOR descriptor provides up to 16 source operands */

/**

 * ppc440spe_dma2_pq_slot_count - get the number of slots necessary for

 * DMA2 PQ operation

 direct RXOR */

 reverse RXOR */

/******************************************************************************

 * ADMA channel low-level routines

/**

 * ppc440spe_adma_device_clear_eot_status - interrupt ack to XOR or DMA engine

 read FIFO to ack */

			/* Clear opcode to ack. This is necessary for

			 * ZeroSum operations only

				/* probably this is a completed RXOR op,

				 * get pointer to CDB using the fact that

				 * physical and virtual addresses of CDB

				 * in pools have the same offsets

 this is a RXOR */

				/* ZeroSum check failed

				/*

				 * Update the status of corresponding

				 * descriptor.

				/*

				 * if cannot find the corresponding

				 * slot it's a bug

 write back to clear */

 reset status bits to ack */

				/* Read PLB Timeout Error.

				 * Try to resubmit the CB

		/*  if the XORcore is idle, but there are unprocessed CBs

		 * then refetch the s/w chain here

/**

 * ppc440spe_chan_is_busy - get the channel status

		/*  if command FIFO's head and tail pointers are equal and

		 * status tail is the same as command, then channel is free

		/* use the special status bit for the XORcore

/**

 * ppc440spe_chan_set_first_xor_descriptor -  init XORcore chain

/**

 * ppc440spe_dma_put_desc - put DMA0,1 descriptor to FIFO.

 * called with irqs disabled

/**

 * ppc440spe_chan_append - update the h/w chain in the channel

 first peer */

 is there something new to append */

 flush descriptors from the s/w queue to fifo */

 update h/w links and refetch */

		/* the last linked CDB has to generate an interrupt

		 * that we'd be able to append the next lists to h/w

		 * regardless of the XOR engine state at the moment of

		 * appending of these next lists

 XORcore is idle. Refetch now */

 XORcore is running. Refetch later in the handler */

/**

 * ppc440spe_chan_get_current_descriptor - get the currently executed descriptor

 h/w descriptor chain is not initialized yet */

/**

 * ppc440spe_chan_run - enable the channel

 DMAs are always enabled, do nothing */

 drain write buffer */

 fetch descriptor pointed to in <link> */

/******************************************************************************

 * ADMA device level

/**

 * ppc440spe_can_rxor - check if the operands may be processed with RXOR

 Skip holes in the source list before checking */

 direct RXOR */

 reverse RXOR */

/**

 * ppc440spe_adma_device_estimate - estimate the efficiency of processing

 *	the operation given on this channel. It's assumed that 'chan' is

 *	capable to process 'cap' type of operation.

 * @chan: channel to use

 * @cap: type of transaction

 * @dst_lst: array of destination pointers

 * @dst_cnt: number of destination operands

 * @src_lst: array of source pointers

 * @src_cnt: number of source operands

 * @src_sz: size of each source operand

		/* If RAID-6 capabilities were not activated don't try

		 * to use them

	/*  In the current implementation of ppc440spe ADMA driver it

	 * makes sense to pick out only pq case, because it may be

	 * processed:

	 * (1) either using Biskup method on DMA2;

	 * (2) or on DMA0/1.

	 *  Thus we give a favour to (1) if the sources are suitable;

	 * else let it be processed on one of the DMA0/1 engines.

	 *  In the sum_product case where destination is also the

	 * source process it on DMA0/1 only.

 sum_product case, process on DMA0/1 */

 override (DMA0/1 + idle) */

 can't process on DMA2 if !rxor */

 channel idleness increases the priority */

		/*

		 * should a user of the api ever pass > PAGE_SIZE requests

		 * we sort out cases where temporary page-sized buffers

		 * are used.

/**

 * ppc440spe_get_group_entry - get group entry with index idx

 * @tdesc: is the last allocated slot in the group.

/**

 * ppc440spe_adma_free_slots - flags descriptor slots for reuse

 * @slot: Slot to free

 * Caller must hold &ppc440spe_chan->lock while calling this function

/**

 * ppc440spe_adma_run_tx_complete_actions - call functions to be called

 * upon completion

		/* call the callback (must not sleep or submit new

		 * operations to this channel)

 run dependent operations */

/**

 * ppc440spe_adma_clean_slot - clean up CDB slot (if ack is set)

	/* the client is allowed to attach dependent operations

	 * until 'ack' is set

	/* leave the last descriptor in the chain

	 * so we can append to it

		/* our DMA interrupt handler clears opc field of

		 * each processed descriptor. For all types of

		 * operations except for ZeroSum we do not actually

		 * need ack from the interrupt handler. ZeroSum is a

		 * special case since the result of this operation

		 * is available from the handler only, so if we see

		 * such type of descriptor (which is unprocessed yet)

		 * then leave it in chain.

/**

 * __ppc440spe_adma_slot_cleanup - this is the common clean-up routine

 *	which runs through the channel CDBs list until reach the descriptor

 *	currently processed. When routine determines that all CDBs of group

 *	are completed then corresponding callbacks (if any) are called and slots

 *	are freed.

		/*  There were no transactions yet, so

		 * nothing to clean

	/* free completed slots from the chain starting with

	 * the oldest descriptor

		/* do not advance past the current descriptor loaded into the

		 * hardware channel,subsequent descriptors are either in process

		 * or have not been submitted

		/* stop the search if we reach the current descriptor and the

		 * channel is busy, or if it appears that the current descriptor

		 * needs to be re-read (i.e. has been appended to)

				/* not all descriptors of the group have

				 * been completed; exit.

 detect the start of a group transaction */

 all the members of a group are complete */

 clean up the group */

 Should wait for ZeroSum completion */

 the group should be complete at this point */

 wait for group completion */

/**

 * ppc440spe_adma_tasklet - clean up watch-dog initiator

/**

 * ppc440spe_adma_slot_cleanup - clean up scheduled initiator

/**

 * ppc440spe_adma_alloc_slots - allocate free slots (if any)

	/* start search from the last allocated descrtiptor

	 * if a contiguous allocation can not be found start searching

	 * from the beginning of the list

 start the allocation if the slot is correctly aligned */

 pre-ack all but the last descriptor */

 try to free some slots if the allocation fails */

/**

 * ppc440spe_adma_alloc_chan_resources -  allocate pools for CDB slots

 Allocate descriptor slots */

 initialize the channel and the chain with a null operation */

 Use WXOR for self-testing */

/**

 * ppc440spe_rxor_set_region_data -

/**

 * ppc440spe_rxor_set_src -

/**

 * ppc440spe_rxor_set_mult -

/**

 * ppc440spe_adma_check_threshold - append CDBs to h/w chain if threshold

 *	has been achieved

/**

 * ppc440spe_adma_tx_submit - submit new descriptor group to the channel

 *	(it's not necessary that descriptors will be submitted to the h/w

 *	chains too right now)

 first peer */

 isn't first peer, bind CDBs to chain */

 fix up the hardware chain */

 increment the pending count by the number of operations */

/**

 * ppc440spe_adma_prep_dma_interrupt - prepare CDB for a pseudo DMA operation

/**

 * ppc440spe_adma_prep_dma_memcpy - prepare CDB for a MEMCPY operation

/**

 * ppc440spe_adma_prep_dma_xor - prepare CDB for a XOR operation

/**

 * ppc440spe_adma_init_dma2rxor_slot -

 initialize CDB */

/**

 * ppc440spe_dma01_prep_mult -

 * for Q operation where destination is also the source

 use WXOR, each descriptor occupies one slot */

		/* First descriptor, zero data in the destination and copy it

		 * to q page using MULTICAST transfer.

 set 'next' pointer */

		/*

		 * Second descriptor, multiply data from the q page

		 * and store the result in real destination.

/**

 * ppc440spe_dma01_prep_sum_product -

 * Dx = A*(P+Pxy) + B*(Q+Qxy) operation where destination is also

 * the source.

 WXOR, each descriptor occupies one slot */

 1st descriptor, src[1] data to q page and zero destination */

		/* 2nd descriptor, multiply src[1] data and store the

 set 'next' pointer */

		/*

		 * 3rd descriptor, multiply src[0] data and xor it

		 * with destination

	/*  select operations WXOR/RXOR depending on the

	 * source addresses of operators and the number

	 * of destinations (RXOR support only Q-parity calculations)

		/* no active RXOR;

		 * do RXOR if:

		 * - there are more than 1 source,

		 * - len is aligned on 512-byte boundary,

		 * - source addresses fit to one of 4 possible regions.

 may do RXOR R1 R2 */

 may try to enhance region of RXOR */

 do RXOR R1 R2 R3 */

 do RXOR R1 R2 R4 */

 do RXOR R1 R2 R5 */

 do RXOR R1 R2 */

 do RXOR R1 R2 */

 can not do this operation with RXOR */

 can do; set block size right now */

 Number of necessary slots depends on operation type selected */

		/*  This is a WXOR only chain. Need descriptors for each

		 * source to GF-XOR them with WXOR, and need descriptors

		 * for each destination to zero them with WXOR

		/*  Need 1/2 descriptor for RXOR operation, and

		 * need (src_cnt - (2 or 3)) for WXOR of sources

		 * remained (if any)

		/*  Thus we have either RXOR only chain or

		 * mixed RXOR/WXOR

 RXOR only chain */

 for both RXOR/WXOR each descriptor occupies one slot */

 setup dst/src/mult */

			/* NOTE: "Multi = 0 is equivalent to = 1" as it

			 * stated in 440SPSPe_RAID6_Addendum_UM_1_17.pdf

			 * doesn't work for RXOR with DMA0/1! Instead, multi=0

			 * leads to zeroing source data after RXOR.

			 * So, for P case set-up mult=1 explicitly.

 Setup byte count foreach slot just allocated */

	/*pr_debug("%s: dst_cnt %d, src_cnt %d, len %d\n",

 depending on number of sources we have 1 or 2 RXOR chains */

 set 'next' pointer */

 this is the last descriptor. */

 fixup head descriptor */

 setup dst/src/mult */

			/* handle descriptors (if dst_cnt == 2) inside

			 * the ppc440spe_adma_pq_set_srcxxx() functions

/**

 * ppc440spe_adma_prep_dma_pq - prepare CDB (group) for a GF-XOR operation

 dst[1] is real destination (Q) */

 this is the page to multicast source data to */

/**

 * ppc440spe_adma_prep_dma_pqzero_sum - prepare CDB group for

 * a PQ_ZERO_SUM operation

	/* Always use WXOR for P/Q calculations (two destinations).

	 * Need 1 or 2 extra slots to verify results are zero.

	/* One additional slot per destination to clone P/Q

	 * before calculation (we have to preserve destinations).

 Setup byte count for each slot just allocated */

 override pdest to preserve original P */

 override qdest to preserve original Q */

 Setup destinations for P/Q ops */

 Setup zero QWORDs into DCHECK CDBs */

			/*

			 * The last CDB corresponds to Q-parity check,

			 * the one before last CDB corresponds

			 * P-parity check

			/*

			 * set it to zero, if check fail then result will

			 * be updated

 Setup sources and mults for P/Q ops */

/**

 * ppc440spe_adma_prep_dma_xor_zero_sum - prepare CDB group for

 * XOR ZERO_SUM operation

 validate P, disable Q */

/**

 * ppc440spe_adma_set_dest - set destination address into descriptor

		/* to do: support transfers lengths >

		 * PPC440SPE_ADMA_DMA/XOR_MAX_BYTE_COUNT

	/*  To clear destinations update the descriptor

	 * (P or Q depending on index) as follows:

	 * addr is destination (0 corresponds to SG2):

 ... and the addr is source: */

 addr is always SG2 then the mult is always DST1 */

/**

 * ppc440spe_adma_pq_set_dest - set destination address into descriptor

 * for the PQXOR operation

		/* walk through the WXOR source list and set P/Q-destinations

		 * for each slot:

 This is WXOR-only chain; may have 1/2 zero descs */

 one destination */

 two destinations */

				/*  To clear destinations update the descriptor

				 * (1st,2nd, or both depending on flags)

 This is RXOR-only or RXOR/WXOR mixed chain */

			/* If we want to include destination into calculations,

			 * then make dest addresses cued with mult=1 (XOR).

 Setup destination(s) in RXOR slot(s) */

 two destinations */

				/* Setup destination(s) in remaining WXOR

				 * slots

 one destination */

 two destinations */

		/* DMA2 descriptors have only 1 destination, so there are

		 * two chains - one for each dest.

		 * If we want to include destination into calculations,

		 * then make dest addresses cued with mult=1 (XOR).

 Two destinations; setup Q here */

/**

 * ppc440spe_adma_pq_zero_sum_set_dest - set destination address into descriptor

 * for the PQ_ZERO_SUM operation

	/* walk through the WXOR source list and set P/Q-destinations

	 * for each slot

 set end */

 set start */

 two destinations */

 one destination */

	/*  The remaining descriptors are DATACHECK. These have no need in

	 * destination. Actually, these destinations are used there

	 * as sources for check operation. So, set addr as source.

/**

 * ppc440spe_desc_set_xor_src_cnt - set source count into descriptor

/**

 * ppc440spe_adma_pq_set_src - set source address into descriptor

		/* DMA0,1 may do: WXOR, RXOR, RXOR+WXORs chain

 RXOR-only or RXOR/WXOR operation */

 1st slot (RXOR) */

				/* setup sources region (R1-2-3, R1-2-4,

				 * or R1-2-5)

				/* 1st slot (RXOR)

				 * shall actually set source address only once

				 * instead of first <iskip>

				/* 2nd/3d and next slots (WXOR);

				 * skip first slot with RXOR

			/* WXOR-only operation; skip first slots with

			 * zeroing destinations

				/* if we have two destinations for RXOR, then

				 * setup source in the second descr too

 DMA2 may do Biskup */

 both P & Q calculations required; set P src here */

 this is for Q */

/**

 * ppc440spe_adma_memcpy_xor_set_src - set source address into descriptor

/**

 * ppc440spe_adma_dma2rxor_inc_addr  -

/**

 * ppc440spe_adma_dma2rxor_prep_src - setup RXOR types in DMA2 CDB

 direct RXOR */

 reverse RXOR */

/**

 * ppc440spe_adma_dma2rxor_set_src - set RXOR source address; it's assumed that

 *	ppc440spe_adma_dma2rxor_prep_src() has already done prior this call

 get the RXOR operand which corresponds to index addr */

 reverse operand order; put last op in RXOR group */

 direct operand order; put first op in RXOR group */

/**

 * ppc440spe_adma_dma2rxor_set_mult - set RXOR multipliers; it's assumed that

 *	ppc440spe_adma_dma2rxor_prep_src() has already done prior this call

 get the RXOR operand which corresponds to index mult */

 reverse order */

 direct order */

/**

 * ppc440spe_init_rxor_cursor -

/**

 * ppc440spe_adma_pq_set_src_mult - set multiplication coefficient into

 * descriptor for the PQXOR operation

 RXOR multipliers */

 WXOR multiplier */

			/* WXOR-only;

			 * skip first slots with destinations (if ZERO_DST has

			 * place)

				/* if we have two destinations for RXOR, then

				 * we've just set Q mult. Set-up P now.

 both P & Q calculations required; set P mult here */

 and then set Q mult */

/**

 * ppc440spe_adma_free_chan_resources - free the resources allocated

 one is ok since we left it on there on purpose */

/**

 * ppc440spe_adma_tx_status - poll the status of an ADMA transaction

 * @chan: ADMA channel handle

 * @cookie: ADMA transaction identifier

 * @txstate: a holder for the current state of the channel

/**

 * ppc440spe_adma_eot_handler - end of transfer interrupt handler

/**

 * ppc440spe_adma_err_handler - DMA error interrupt handler;

 *	do the same things as a eot handler

/**

 * ppc440spe_test_callback - called when test operation has been done

/**

 * ppc440spe_adma_issue_pending - flush all pending descriptors to h/w

/**

 * ppc440spe_chan_start_null_xor - initiate the first XOR operation (DMA engines

 *	use FIFOs (as opposite to chains used in XOR) so this is a XOR

 *	specific operation)

		/* initialize the completed cookie to be less than

		 * the most recently used cookie

 channel should not be busy */

 set the descriptor address */

 run the descriptor */

/**

 * ppc440spe_test_raid6 - test are RAID-6 capabilities enabled successfully.

 *	For this we just perform one WXOR operation with the same source

 *	and destination addresses, the GF-multiplier is 1; so if RAID-6

 *	capabilities are enabled then we'll get src/dst filled with zero.

 1 src, 1 dsr, int_ena, WXOR */

 Fill the test page with ones */

 Setup addresses */

 Now check if the test page is zeroed */

 page is zero - RAID-6 enabled */

 RAID-6 was not enabled */

 Set base routines */

 Set prep routines based on capability */

	/* only DMA engines have a separate error IRQ

	 * so it's Ok if err_irq < 0 in XOR engine case.

 both DMA engines share common error IRQ */

 enable XOR engine interrupts */

		/* Unmask 'CS FIFO Attention' interrupts and

		 * enable generating interrupts on errors

 disable XOR engine interrupts */

 disable DMAx engine interrupts */

/**

 * ppc440spe_adma_probe - probe the asynch device

		/* As far as the XOR engine is concerned, it does not

		 * use FIFOs but uses linked list. So there is no dependency

		 * between pool size to allocate and the engine configuration.

 it is DMA0 or DMA1 */

		/* DMA0,1 engines use FIFO to maintain CDBs, so we

		 * should allocate the pool accordingly to size of this

		 * FIFO. Thus, the pool size depends on the FIFO depth:

		 * how much CDBs pointers the FIFO may contain then so

		 * much CDBs we should provide in the pool.

		 * That is

		 *   CDB size = 32B;

		 *   CDBs number = (DMA0_FIFO_SIZE >> 3);

		 *   Pool size = CDBs number * CDB size =

		 *      = (DMA0_FIFO_SIZE >> 3) << 5 = DMA0_FIFO_SIZE << 2.

 create a device */

 allocate coherent memory for hardware descriptors */

 Reset XOR */

		/* DMAx_FIFO_SIZE is defined in bytes,

		 * <fsiz> - is defined in number of CDB pointers (8byte).

		 * DMA FIFO Length = CSlength + CPlength, where

		 * CSlength = CPlength = (fsiz + 1) * 8.

 Configure DMA engine */

 Clear Status */

 create a channel */

	/* allocate and map helper pages for async validation or

	 * async_mult/async_sum_product operations on DMA0/1.

/**

 * ppc440spe_adma_remove - remove the asynch device

/*

 * /sys driver interface to enable h/w RAID-6 capabilities

 * Files created in e.g. /sys/devices/plb.0/400100100.dma0/driver/

 * directory are "devices", "enable" and "poly".

 * "devices" shows available engines.

 * "enable" is used to enable RAID-6 capabilities or to check

 * whether these has been activated.

 * "poly" allows setting/checking used polynomial (for PPC440SPe only).

 Write a key */

 Verify whether it really works now */

 440SP has fixed polynomial */

 440SP uses default 0x14D polynomial only */

 e.g., 0x14D or 0x11D */

/*

 * Common initialisation for RAID engines; allocate memory for

 * DMAx FIFOs, perform configuration common for all DMA engines.

 * Further DMA engine specific configuration is done at probe time.

 Get I2O DCRs base */

	/* Provide memory regions for DMA's FIFOs: I2O, DMA0 and DMA1 share

	 * the base address of FIFO memory space.

	 * Actually we need twice more physical memory than programmed in the

	 * <fsiz> register (because there are two FIFOs for each DMA: CP and CS)

	/*

	 * Configure h/w

 Reset I2O/DMA */

 Setup the base address of mmaped registers */

 Setup FIFO memory space base address */

	/* set zero FIFO size for I2O, so the whole

	 * ppc440spe_dma_fifo_buf is used by DMAs.

	 * DMAx_FIFOs will be configured while probe.

	/* To prepare WXOR/RXOR functionality we need access to

	 * Memory Queue Module DCRs (finally it will be enabled

	 * via /sys interface of the ppc440spe ADMA driver).

 Get MQ DCRs base */

 Set HB alias */

	/* Set:

	 * - LL transaction passing limit to 1;

	 * - Memory controller cycle limit to 1;

	 * - Galois Polynomial to 0x14d (default)

 Initialization status */

 RAID-6 h/w enable entry */

 GF polynomial to use */

 User will not be able to enable h/w RAID-6 */

 SPDX-License-Identifier: GPL-2.0

/*

 * Lightning Mountain centralized DMA controller driver

 *

 * Copyright (c) 2016 - 2020 Intel Corporation.

 Adaptive Burst Chop */

/*

 * If header mode is set in DMA descriptor,

 *   If bit 30 is disabled, HDR_LEN must be configured according to channel

 *     requirement.

 *   If bit 30 is enabled(checksum with heade mode), HDR_LEN has no need to

 *     be configured. It will enable check sum for switch

 * If header mode is not set in DMA descriptor,

 *   This register setting doesn't matter

 DMA controller capability */

 DMA flags */

 Descriptor fields */

 back pointer */

 Channel name */

 Channel id in hardware */

 central way or channel based way */

 Virtual address */

 Number of descriptors */

 Descriptors pool */

 back pointer */

 Instance specific data */

 Fetch On Demand */

 Outstanding read count */

 channel list on this DMA or port */

 Controller register exclusive */

 Read from hardware */

 Keep the class value unchanged */

 Clear all interrupts and disabled it */

 3 bits low */

 2 bits high */

 If descriptors not configured, not allow to turn on channel */

 Higher 4 bits of 36 bit addressing */

 NB, csum disabled, hdr length must be provided */

 Only valid for RX channel */

 read back */

 DMA port initialization */

 DMA channel initialization */

 Get the next descriptor */

	/*

	 * clear any pending work if any. In that

	 * case the resource needs to be free here.

 Disable channel interrupts  */

 Mask */

 Ack */

 TX and RX has the same burst length */

 sop and eop has to be handled nicely */

 Only 32 bit address supported */

 Ensure data ready before ownership change */

 Ensure ownership changed before moving forward */

 if args_count is 1 driver use default settings */

 Real channel number */

 Link controller to platform device */

 Power up and reset the dma engine, some DMAs always on?? */

 Channel initializations */

 Port Initializations */

 Channels Initializations */

/*

 * Perform this driver as device_initcall to make sure initialization happens

 * before its DMA clients of some are platform specific and also to provide

 * registered DMA channels and DMA capabilities to clients before their

 * initialization.

 SPDX-License-Identifier: GPL-2.0

 Copyright (C) 2013,2018,2020-2021 Intel Corporation

 DMA Channel ID Configuration register must be programmed first */

 Configure channel attributes */

		/*

		 * Memory-to-Memory and Device-to-Device are ignored for now.

		 *

		 * For Memory-to-Memory transfers we would need to set mode

		 * and disable snooping on both sides.

 Configure crossbar selection */

 DEVFN selection */

 Memory-to-Memory and Device-to-Device are ignored for now */

 Configure DMA channel low and high registers */

 Memory-to-Memory and Device-to-Device are ignored for now */

 Set default burst alignment */

 Low 4 bits of the request lines */

 Request line extension (2 bits) */

 Set default burst alignment */

 Low 4 bits of the request lines */

 Request line extension (2 bits) */

/*

 * Program FIFO size of channels.

 *

 * By default full FIFO (512 bytes) is assigned to channel 0. Here we

 * slice FIFO on equal parts between channels.

 Fill FIFO_PARTITION low bits (Channels 0..1, 4..5) */

 Fill FIFO_PARTITION high bits (Channels 2..3, 6..7) */

 Program FIFO Partition registers - 64 bytes per channel */

 Channel operations */

 Device operations */

 SPDX-License-Identifier: GPL-2.0

/*

 * Platform driver for the Synopsys DesignWare DMA Controller

 *

 * Copyright (C) 2007-2008 Atmel Corporation

 * Copyright (C) 2010-2011 ST Microelectronics

 * Copyright (C) 2013 Intel Corporation

 TODO: there should be a simpler way to do this */

 Try deprecated property first */

 If "data_width" and "data-width" both provided use the latter one */

 SPDX-License-Identifier: GPL-2.0

/*

 * PCI driver for the Synopsys DesignWare DMA Controller

 *

 * Copyright (C) 2013 Intel Corporation

 * Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

 CONFIG_PM_SLEEP */

 Medfield (GPDMA) */

 BayTrail */

 Merrifield */

 Braswell */

 Elkhart Lake iDMA 32-bit (PSE DMA) */

 Haswell */

 Broadwell */

 SPDX-License-Identifier: GPL-2.0

 Copyright (C) 2007-2008 Atmel Corporation

 Copyright (C) 2010-2011 ST Microelectronics

 Copyright (C) 2013,2018 Intel Corporation

 Set polarity of handshake interface */

	/*

	 * Fix burst size according to dw_dmac. We need to convert them as:

	 * 1 -> 0, 4 -> 1, 8 -> 2, 16 -> 3.

 Channel operations */

 Device operations */

 SPDX-License-Identifier: GPL-2.0

/*

 * Platform driver for the Synopsys DesignWare DMA Controller

 *

 * Copyright (C) 2007-2008 Atmel Corporation

 * Copyright (C) 2010-2011 ST Microelectronics

 * Copyright (C) 2013 Intel Corporation

 *

 * Some parts of this driver are derived from the original dw_dmac.

	/*

	 * We have to call do_dw_dma_disable() to stop any ongoing transfer. On

	 * some platforms we can't do that since DMA device is powered off.

	 * Moreover we have no possibility to check if the platform is affected

	 * or not. That's why we call pm_runtime_get_sync() / pm_runtime_put()

	 * unconditionally. On the other hand we can't use

	 * pm_runtime_suspended() because runtime PM framework is not fully

	 * used by the driver.

 Elkhart Lake iDMA 32-bit (PSE DMA) */

 CONFIG_PM_SLEEP */

 SPDX-License-Identifier: GPL-2.0

/*

 * Core driver for the Synopsys DesignWare DMA Controller

 *

 * Copyright (C) 2007-2008 Atmel Corporation

 * Copyright (C) 2010-2011 ST Microelectronics

 * Copyright (C) 2013 Intel Corporation

/*

 * This supports the Synopsys "DesignWare AHB Central DMA Controller",

 * (DW_ahb_dmac) which is used with various AMBA 2.0 systems (not all

 * of which use ARM any more).  See the "Databook" from Synopsys for

 * information beyond what licensees probably provide.

 *

 * The driver has been tested with the Atmel AT32AP7000, which does not

 * support descriptor writeback.

 The set of bus widths supported by the DMA controller */

----------------------------------------------------------------------*/

	/*

	 * REVISIT: We should attempt to chain as many descriptors as

	 * possible, perhaps even appending to those already submitted

	 * for DMA. But this is hard to do in a race-free manner.

 Enable interrupts */

----------------------------------------------------------------------*/

----------------------------------------------------------------------*/

 Perform single block transfer */

	/*

	 * Software emulation of LLP mode relies on interrupts to continue

	 * multi block transfer.

 Move pointer to next descriptor */

 Called with dwc->lock held and bh disabled */

 ASSERT:  channel is idle */

 The tasklet will hopefully advance the queue... */

 Submit first block */

----------------------------------------------------------------------*/

 async_tx_ack */

 Try to continue after resetting the channel... */

	/*

	 * Submit queued descriptors ASAP, i.e. before we go through

	 * the completed ones.

 Returns how many bytes were already received from source */

 Everything we've submitted is done */

			/*

			 * We are inside first active descriptor.

			 * Otherwise something is really wrong.

 Update residue to reflect last sent descriptor */

 Submit next block */

 We are done here */

 Initial residue value */

 Check first descriptors addr */

 Check first descriptors llp */

 This one is currently in progress */

 Currently in progress */

		/*

		 * No descriptors so far seem to be in progress, i.e.

		 * this one must be done.

 Try to continue after resetting the channel... */

	/*

	 * The descriptor currently at the head of the active list is

	 * borked. Since we don't have any way to report errors, we'll

	 * just have to scream loudly and try to carry on.

 Clear the error flag and try to restart the controller */

	/*

	 * WARN may seem harsh, but since this only happens

	 * when someone submits a bad physical address in a

	 * descriptor, we should consider ourselves lucky that the

	 * controller flagged an error instead of scribbling over

	 * random memory locations.

 Pretend the descriptor completed successfully */

 Re-enable interrupts */

 Check if we have any interrupt from the DMAC which is not in use */

 Check if we have any interrupt from the DMAC */

	/*

	 * Just disable the interrupts. We'll turn them back on in the

	 * softirq handler.

 Try to recover */

----------------------------------------------------------------------*/

 Trigger interrupt after last block */

 Trigger interrupt after last block */

 permit channels in accordance with the channels mask */

 We have to copy data since dws can be temporary storage */

 timeout iterations */

 active_list entries will end up before queued entries */

 Flush all pending and queued descriptors */

----------------------------------------------------------------------*/

 ASSERT:  channel is idle */

	/*

	 * NOTE: some controllers may have additional features that we

	 * need to initialize here, like "scatter-gather" (which

	 * doesn't mean what you think it means), and status writeback.

	/*

	 * We need controller-specific data to set up slave transfers.

 Enable controller here if needed */

 ASSERT:  channel is idle */

 Clear custom channel configuration */

 Disable interrupts */

 Disable controller in case it was a last user */

	/*

	 * It might be crucial for some devices to have the hardware

	 * accelerated multi-block transfers supported, aka LLPs in DW DMAC

	 * notation. So if LLPs are supported then max_sg_burst is set to

	 * zero which means unlimited number of SG entries can be handled in a

	 * single DMA transaction, otherwise it's just one SG entry.

 Reassign the platform data pointer */

 Get hardware configuration parameters */

 Fill platform data with the default values */

 Reassign the platform data pointer */

 Calculate all channel mask before DMA setup */

 Force dma off, just in case */

 Device and instance ID for IRQ and DMA pool */

 Create a pool of consistent memory blocks for hardware descriptors */

 7 is highest priority & 0 is lowest. */

 Hardware configuration */

			/*

			 * Decode maximum block size for given channel. The

			 * stored 4 bit value represents blocks from 0x00 for 3

			 * up to 0x0a for 4095.

			/*

			 * According to the DW DMA databook the true scatter-

			 * gether LLPs aren't available if either multi-block

			 * config is disabled (CHx_MULTI_BLK_EN == 0) or the

			 * LLP register is hard-coded to zeros

			 * (CHx_HC_LLP == 1).

 Clear all interrupts on all channels. */

 Set capabilities */

 DMA capabilities */

	/*

	 * For now there is no hardware with non uniform maximum block size

	 * across all of the device channels, so we set the maximum segment

	 * size as the block size found for the very first channel.

 SPDX-License-Identifier: GPL-2.0

 Copyright (C) 2013,2019 Intel Corporation

 SPDX-License-Identifier: GPL-2.0-only

/*

 * PCI driver for the High Speed UART DMA

 *

 * Copyright (C) 2015 Intel Corporation

 * Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

 *

 * Partially based on the bits found in drivers/tty/serial/mfd.c.

	/*

	 * On Intel Tangier B0 and Anniedale the interrupt line, disregarding

	 * to have different numbers, is shared between HSU DMA and UART IPs.

	 * Thus on such SoCs we are expecting that IRQ handler is called in

	 * UART driver only. Instead of handling the spurious interrupt

	 * from HSU DMA here and waste CPU time and delay HSU UART interrupt

	 * handling, disable the interrupt entirely.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Core driver for the High Speed UART DMA

 *

 * Copyright (C) 2015 Intel Corporation

 * Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

 *

 * Partially based on the bits found in drivers/tty/serial/mfd.c.

/*

 * DMA channel allocation:

 * 1. Even number chans are used for DMA Read (UART TX), odd chans for DMA

 *    Write (UART RX).

 * 2. 0/1 channel are assigned to port 0, 2/3 chan to port 1, 4/5 chan to

 *    port 3, and so on.

 to shut the compiler up */

 Set descriptors */

 Prepare value for DCR */

 timeout bit, see HSU Errata 1 */

 Only for the last descriptor in the chain */

 Get the next descriptor */

 Start the channel with a new descriptor */

/*

 *      hsu_dma_get_status() - get DMA channel status

 *      @chip: HSUART DMA chip

 *      @nr: DMA channel number

 *      @status: pointer for DMA Channel Status Register value

 *

 *      Description:

 *      The function reads and clears the DMA Channel Status Register, checks

 *      if it was a timeout interrupt and returns a corresponding value.

 *

 *      Caller should provide a valid pointer for the DMA Channel Status

 *      Register value that will be returned in @status.

 *

 *      Return:

 *      1 for DMA timeout status, 0 for other DMA status, or error code for

 *      invalid parameters or no interrupt pending.

 Sanity check */

	/*

	 * No matter what situation, need read clear the IRQ status

	 * There is a bug, see Errata 5, HSD 2900918

 Check if any interrupt is pending */

 Timeout IRQ, need wait some time, see Errata 2 */

	/*

	 * At this point, at least one of Descriptor Time Out, Channel Error

	 * or Descriptor Done bits must be set. Clear the Descriptor Time Out

	 * bits and if sr is still non-zero, it must be channel error or

	 * descriptor done which are higher priority than timeout and handled

	 * in hsu_dma_do_irq(). Else, it must be a timeout.

/*

 *      hsu_dma_do_irq() - DMA interrupt handler

 *      @chip: HSUART DMA chip

 *      @nr: DMA channel number

 *      @status: Channel Status Register value

 *

 *      Description:

 *      This function handles Channel Error and Descriptor Done interrupts.

 *      This function should be called after determining that the DMA interrupt

 *      is not a normal timeout interrupt, ie. hsu_dma_get_status() returned 0.

 *

 *      Return:

 *      0 for invalid channel number, 1 otherwise.

 Sanity check */

 desc->active = 0 by kzalloc */

 Calculate nr_channels from the IO space length */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * AMD Passthru DMA device driver

 * -- Based on the CCP driver

 *

 * Copyright (C) 2016,2021 Advanced Micro Devices, Inc.

 *

 * Author: Sanjay R Mehta <sanju.mehta@amd.com>

 * Author: Tom Lendacky <thomas.lendacky@amd.com>

 * Author: Gary R Hook <gary.hook@amd.com>

/*

 * pt_alloc_struct - allocate and initialize the pt_device struct

 *

 * @dev: device struct of the PTDMA

 Couldn't get MSI-X vectors, try MSI */

 Couldn't get MSI interrupt */

 Last entry must be zero */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * AMD Passthrough DMA device driver

 * -- Based on the CCP driver

 *

 * Copyright (C) 2016,2021 Advanced Micro Devices, Inc.

 *

 * Author: Sanjay R Mehta <sanju.mehta@amd.com>

 * Author: Gary R Hook <gary.hook@amd.com>

 DebugFS helpers */

/*

 * Return a formatted buffer containing the current

 * statistics of queue for PTDMA

 SPDX-License-Identifier: GPL-2.0-only

/*

 * AMD Passthru DMA device driver

 * -- Based on the CCP driver

 *

 * Copyright (C) 2016,2021 Advanced Micro Devices, Inc.

 *

 * Author: Sanjay R Mehta <sanju.mehta@amd.com>

 * Author: Gary R Hook <gary.hook@amd.com>

 Human-readable error strings */

 Turn on the run bit */

 Turn off the run bit */

 Copy 32-byte command descriptor to hw queue. */

 The data used by this command must be flushed to memory */

 Write the new tail address back to the queue register */

 Turn the queue back on using our cached control register */

	       /*

		* Log the error and flush the queue by

		* moving the head pointer

 On error, only save the first error value */

 Acknowledge the interrupt */

 Allocate a dma pool for the queue */

 ptdma core initialisation */

 Page alignment satisfies our needs for N <= 128 */

 Preset some register values */

 Turn off the queues and disable interrupts until ready */

 Start with nothing */

 Clear the interrupt status */

 Request an irq */

 Update the device registers with queue information. */

 Register the DMA engine support */

 Set up debugfs entries */

 Unregister the DMA engine */

 Disable and clear interrupts */

 Turn off the run bit */

 Clear the interrupt status */

 Flush the cmd queue */

 Invoke the callback directly with an error code */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * AMD Passthrough DMA device driver

 * -- Based on the CCP driver

 *

 * Copyright (C) 2016,2021 Advanced Micro Devices, Inc.

 *

 * Author: Sanjay R Mehta <sanju.mehta@amd.com>

 * Author: Gary R Hook <gary.hook@amd.com>

 Execute the command */

 Get the next DMA descriptor on the active list */

 Loop over descriptors until one is found with commands */

 No errors, keep going */

 Check for DMA descriptor completion */

 Don't submit cmd if no descriptor or DMA is paused */

 If there was nothing active, start processing */

 If there was something active, re-start */

	/*

	 * PTDMA is intended to be used with the AMD NTB devices, hence

	 * marking it as DMA_PRIVATE.

 Set base and prep routines */

 SPDX-License-Identifier: GPL-2.0

 Copyright(c) 2021 Intel Corporation. All rights rsvd. */

 SPDX-License-Identifier: GPL-2.0

 Copyright(c) 2021 Intel Corporation. All rights rsvd. */

 SPDX-License-Identifier: GPL-2.0

 Copyright(c) 2019 Intel Corporation. All rights rsvd. */

	/*

	 * On host, MSIX vecotr 0 is used for misc interrupt. Therefore when we match

	 * vector 1:1 to the WQ id, we need to add 1

	/*

	 * At this point, the desc needs to be aborted is held by the completion

	 * handler where it has taken it off the pending list but has not added to the

	 * work list. It will be cleaned up by the interrupt handler when it sees the

	 * IDXD_COMP_DESC_ABORT for completion status.

	/*

	 * Grab the list lock so it will block the irq thread handler. This allows the

	 * abort code to locate the descriptor need to be aborted.

	/*

	 * The wmb() flushes writes to coherent DMA data before

	 * possibly triggering a DMA read. The wmb() is necessary

	 * even on UP because the recipient is a device.

	/*

	 * Pending the descriptor to the lockless list for the irq_entry

	 * that we designated the descriptor to.

		/*

		 * It's not likely that we would receive queue full rejection

		 * since the descriptor allocation gates at wq size. If we

		 * receive a -EAGAIN, that means something went wrong such as the

		 * device is not accepting descriptor at all.

 abort operation frees the descriptor */

 SPDX-License-Identifier: GPL-2.0

 Copyright(c) 2019 Intel Corporation. All rights rsvd. */

	/*

	 * For dedicated WQ, this field is ignored and HW will use the WQCFG.priv

	 * field instead. This field should be set to 1 for kernel descriptors.

/*

 * issue_pending() does not need to do anything since tx_submit() does the job

 * already.

	/*

	 * This pointer is protected by the refs taken by the dma_chan. It will remain valid

	 * as long as there are outstanding channels.

 SPDX-License-Identifier: GPL-2.0

 Copyright(c) 2019 Intel Corporation. All rights rsvd. */

 DSA ver 1.0 platforms */

 IAX ver 1.0 platforms */

	/*

	 * We implement 1 completion list per MSI-X entry except for

	 * entry 0, which is for errors and others.

 first MSI-X entry is not for wq interrupts */

			/*

			 * The MSIX vector enumeration starts at 1 with vector 0 being the

			 * misc interrupt that handles non I/O completion events. The

			 * interrupt handles are for IMS enumeration on guest. The misc

			 * interrupt vector does not require a handle and therefore we start

			 * the int_handles at index 0. Since 'i' starts at 1, the first

			 * int_handles index will be 0.

 Disable error interrupt generation */

 reading generic capabilities */

 reading group capabilities */

 read engine capabilities */

 read workqueue capabilities */

 reading operation capabilities */

 If the configs are readonly, then load them from device */

	/*

	 * When ->release() is called for the idxd->conf_dev, it frees all the memory related

	 * to the idxd context. The driver still needs those bits in order to do the rest of

	 * the cleanup. However, we do need to unbound the idxd sub-driver. So take a ref

	 * on the device here to hold off the freeing while allowing the idxd sub-driver

	 * to unbind.

	/*

	 * If the CPU does not support MOVDIR64B or ENQCMDS, there's no point in

	 * enumerating the device. We can not utilize it.

 SPDX-License-Identifier: GPL-2.0

 Copyright(c) 2019 Intel Corporation. All rights rsvd. */

 IDXD engine attributes */

 Group attributes */

 IDXD work queue attribs */

 If we are changing queue type, clear the name */

	/*

	 * This is temporarily placed here until we have SVM support for

	 * dmaengine.

 IDXD device attribs */

 SPDX-License-Identifier: GPL-2.0

 Copyright(c) 2019 Intel Corporation. All rights rsvd. */

 Interrupt control bits */

 WQ control bits */

 Device control bits */

/*

 * This is function is only used for reset during probe and will

 * poll for completion. Once the device is setup with interrupts,

 * all commands will be done via interrupt completion.

	/*

	 * After command submitted, release lock and go to sleep until

	 * the command completes via interrupt.

 Wake up other pending commands */

 If the command is successful or if the device was enabled */

 If the command is successful or if the device was disabled */

 Device configuration bits */

 setup GRPWQCFG */

 setup GRPENGCFG */

 setup GRPFLAGS */

 Setup bandwidth token limit */

	/*

	 * Instead of memset the entire shadow copy of WQCFG, copy from the hardware after

	 * wq reset. This will copy back the sticky values that are present on some devices.

 byte 0-3 */

 bytes 4-7 */

 byte 8-11 */

	/*

	 * Here the priv bit is set depending on the WQ type. priv = 1 if the

	 * WQ type is kernel to indicate privileged access. This setting only

	 * matters for dedicated WQ. According to the DSA spec:

	 * If the WQ is in dedicated mode, WQ PASID Enable is 1, and the

	 * Privileged Mode Enable field of the PCI Express PASID capability

	 * is 0, this field must be 0.

	 *

	 * In the case of a dedicated kernel WQ that is not able to support

	 * the PASID cap, then the configuration will be rejected.

 bytes 12-15 */

 TC-A 0 and TC-B 1 should be defaults */

 The driver does not support shared WQ mode in read-only config yet */

	/*

	 * Load WQS bit fields

	 * Iterate through all 256 bits 64 bits at a time

 Iterate through all 64 bits and check for wq set */

 No need to check beyond max wqs */

 Set group assignment for wq if wq bit is set */

 Iterate through all 64 bits to check engines set */

 Shared WQ checks */

		/*

		 * Shared wq with the threshold set to 0 means the user

		 * did not set the threshold or transitioned from a

		 * dedicated wq but did not set threshold. A value

		 * of 0 would effectively disable the shared wq. The

		 * driver does not allow a value of 0 to be set for

		 * threshold via sysfs.

	/*

	 * Device should be in disabled state for the idxd_drv to load. If it's in

	 * enabled state, then the device was altered outside of driver's control.

	 * If the state is in halted state, then we don't want to proceed.

 Device configuration */

 Start device */

 Setup DMA device without channels */

 SPDX-License-Identifier: GPL-2.0

 Copyright(c) 2019 Intel Corporation. All rights rsvd. */

/*

 * ictx is an array based off of accelerator types. enum idxd_type

 * is used as index

 Wait for in-flight operations to complete. */

 The wq disable in the disable pasid function will drain the wq */

 SPDX-License-Identifier: GPL-2.0

 Copyright(c) 2019 Intel Corporation. All rights rsvd. */

 Driver does not utilize occupancy interrupt */

			/*

			 * If we need a software reset, we will throw the work

			 * on a system workqueue in order to allow interrupts

			 * for the device command completions.

			/*

			 * Check against the original status as ABORT is software defined

			 * and 0xff, which DSA_COMP_STATUS_MASK can mask out.

	/*

	 * This lock protects list corruption from access of list outside of the irq handler

	 * thread.

		/*

		 * Check against the original status as ABORT is software defined

		 * and 0xff, which DSA_COMP_STATUS_MASK can mask out.

	/*

	 * There are two lists we are processing. The pending_llist is where

	 * submmiter adds all the submitted descriptor after sending it to

	 * the workqueue. It's a lockless singly linked list. The work_list

	 * is the common linux double linked list. We are in a scenario of

	 * multiple producers and a single consumer. The producers are all

	 * the kernel submitters of descriptors, and the consumer is the

	 * kernel irq handler thread for the msix vector when using threaded

	 * irq. To work with the restrictions of llist to remain lockless,

	 * we are doing the following steps:

	 * 1. Iterate through the work_list and process any completed

	 *    descriptor. Delete the completed entries during iteration.

	 * 2. llist_del_all() from the pending list.

	 * 3. Iterate through the llist that was deleted from the pending list

	 *    and process the completed entries.

	 * 4. If the entry is still waiting on hardware, list_add_tail() to

	 *    the work_list.

 SPDX-License-Identifier: GPL-2.0

 Copyright(c) 2020 Intel Corporation. All rights rsvd. */

/*

 * perf userspace reads this attribute to determine which cpus to open

 * counters on.  It's connected to perfmon_dsa_cpu_mask, which is

 * maintained by the cpu hotplug handlers.

/*

 * These attributes specify the bits in the config word that the perf

 * syscall uses to pass the event ids and categories to perfmon.

/*

 * These attributes specify the bits in the config1 word that the perf

 * syscall uses to pass filter data to perfmon.

/*

 * Check whether there are enough counters to satisfy that all the

 * events in the group can actually be scheduled at the same time.

 *

 * To do this, create a fake idxd_pmu object so the event collection

 * and assignment functions can be used without affecting the internal

 * state of the real idxd_pmu object.

 sampling not supported */

 non-group events have themselves as leader */

	/*

	 * While updating overflowed counters, other counters behind

	 * them could overflow and be missed in a given pass.

	 * Normally this could happen at most n_counters times, but in

	 * theory a tiny counter width could result in continual

	 * overflows and endless looping.  max_loop provides a

	 * failsafe in that highly unlikely case.

 Figure out which counter(s) overflowed */

 Update event->count for overflowed counter */

 Writing 1 to OVFSTATUS bit clears it */

	/*

	 * Should never happen.  If so, it means a counter(s) looped

	 * around twice while this handler was running.

 Obtain event category and event value from user space */

 Obtain filter configuration from user space */

 Read the start value */

 Set counter to event/category */

 Set interrupt on overflow and counter enable bits */

 remove this event from event list */

 select the first online CPU as the designated reader */

 migrate events if there is a valid target */

	/*

	 * perfmon module initialization failed, nothing to do

	/*

	 * If perfmon_offset or num_counters is 0, it means perfmon is

	 * not supported on this hardware.

	/*

	 * If total perf counter is 0, stop further registration.

	 * This is necessary in order to support driver running on

	 * guest which does not have pmon support.

 A counter width of 0 means it can't count */

 Overflow interrupt and counter freeze support must be available */

 Number of event categories cannot be 0 */

	/*

	 * We don't support per-counter capabilities for now.

 check filter capability.  If 0, then filters are not supported */

 Store the total number of counters categories, and counter width */

 SPDX-License-Identifier: GPL-2.0

/*

 * MediaTek UART APDMA driver.

 *

 * Copyright (c) 2019 MediaTek Inc.

 * Author: Long Cheng <long.cheng@mediatek.com>

 The default number of virtual channel */

 rx valid size >=  vff thre */

 tx left size >= vff thre */

/*

 * interrupt trigger level for tx

 * if threshold is n, no polling is required to start tx.

 * otherwise need polling VFF_FLUSH.

 interrupt trigger level for rx */

 invert this bit when wrap ring head again */

 TX: the buffer size HW can read. RX: the buffer size SW can read. */

 TX: the buffer size SW can write. RX: the buffer size HW can write. */

 Let DMA start moving data */

 HW auto set to 0 when left size >= threshold */

	/*

	 * The buffer is ring buffer. If wrap bit different,

	 * represents the start of the next cycle for WPT

/*

 * dmaengine_prep_slave_single will call the function. and sglen is 1.

 * 8250 uart using one ring buffer, and deal with one sg.

 Now allocate and setup the descriptor */

	/*

	 * Stop need 3 steps.

	 * 1. set stop to 1

	 * 2. wait en to 0

	 * 3. set stop as 0

 sentinel */ },

 Device-tree DMA controller registration */

 CONFIG_PM_SLEEP */

 CONFIG_PM */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2017-2018 MediaTek Inc.

/*

 * Driver for MediaTek High-Speed DMA Controller

 *

 * Author: Sean Wang <sean.wang@mediatek.com>

 *

 The default number of virtual channel */

 Only one physical channel supported */

 Macro for physical descriptor (PD) manipulation */

 The number of PD which must be 2 of power */

 Registers for underlying ring manipulation */

 Registers for global setup */

 Registers for reset */

 Registers for interrupt control */

 Interrupt fires when the pending number's more than the specified */

 Interrupt fires when the pending time's more than the specified in 20 us */

/**

 * struct mtk_hsdma_pdesc - This is the struct holding info describing physical

 *			    descriptor (PD) and its placement must be kept at

 *			    4-bytes alignment in little endian order.

 * @desc1:		    | The control pad used to indicate hardware how to

 * @desc2:		    | deal with the descriptor such as source and

 * @desc3:		    | destination address and data length. The maximum

 * @desc4:		    | data length each pdesc can handle is 0x3f80 bytes

/**

 * struct mtk_hsdma_vdesc - This is the struct holding info describing virtual

 *			    descriptor (VD)

 * @vd:			    An instance for struct virt_dma_desc

 * @len:		    The total data size device wants to move

 * @residue:		    The remaining data size device will move

 * @dest:		    The destination address device wants to move to

 * @src:		    The source address device wants to move from

/**

 * struct mtk_hsdma_cb - This is the struct holding extra info required for RX

 *			 ring to know what relevant VD the the PD is being

 *			 mapped to.

 * @vd:			 Pointer to the relevant VD.

 * @flag:		 Flag indicating what action should be taken when VD

 *			 is completed.

/**

 * struct mtk_hsdma_ring - This struct holds info describing underlying ring

 *			   space

 * @txd:		   The descriptor TX ring which describes DMA source

 *			   information

 * @rxd:		   The descriptor RX ring which describes DMA

 *			   destination information

 * @cb:			   The extra information pointed at by RX ring

 * @tphys:		   The physical addr of TX ring

 * @rphys:		   The physical addr of RX ring

 * @cur_tptr:		   Pointer to the next free descriptor used by the host

 * @cur_rptr:		   Pointer to the last done descriptor by the device

/**

 * struct mtk_hsdma_pchan - This is the struct holding info describing physical

 *			   channel (PC)

 * @ring:		   An instance for the underlying ring

 * @sz_ring:		   Total size allocated for the ring

 * @nr_free:		   Total number of free rooms in the ring. It would

 *			   be accessed and updated frequently between IRQ

 *			   context and user context to reflect whether ring

 *			   can accept requests from VD.

/**

 * struct mtk_hsdma_vchan - This is the struct holding info describing virtual

 *			   channel (VC)

 * @vc:			   An instance for struct virt_dma_chan

 * @issue_completion:	   The wait for all issued descriptors completited

 * @issue_synchronize:	   Bool indicating channel synchronization starts

 * @desc_hw_processing:	   List those descriptors the hardware is processing,

 *			   which is protected by vc.lock

/**

 * struct mtk_hsdma_soc - This is the struct holding differences among SoCs

 * @ddone:		  Bit mask for DDONE

 * @ls0:		  Bit mask for LS0

/**

 * struct mtk_hsdma_device - This is the struct holding info describing HSDMA

 *			     device

 * @ddev:		     An instance for struct dma_device

 * @base:		     The mapped register I/O base

 * @clk:		     The clock that device internal is using

 * @irq:		     The IRQ that device are using

 * @dma_requests:	     The number of VCs the device supports to

 * @vc:			     The pointer to all available VCs

 * @pc:			     The pointer to the underlying PC

 * @pc_refcnt:		     Track how many VCs are using the PC

 * @lock:		     Lock protect agaisting multiple VCs access PC

 * @soc:		     The pointer to area holding differences among

 *			     vaious platform

 Lock used to protect against multiple VCs access PC */

	/*

	 * Allocate ring space where [0 ... MTK_DMA_SIZE - 1] is for TX ring

	 * and [MTK_DMA_SIZE ... 2 * MTK_DMA_SIZE - 1] is for RX ring.

 Disable HSDMA and wait for the completion */

 Reset */

 Setup HSDMA initial pointer in the ring */

 Enable HSDMA */

 Setup delayed interrupt */

 Enable interrupt */

 Disable HSDMA and then wait for the completion */

 Reset pointer in the ring */

 Protect against PC is accessed by multiple VCs simultaneously */

	/*

	 * Reserve rooms, where pc->nr_free is used to track how many free

	 * rooms in the ring being updated in user and IRQ context.

 Limit size by PD capability for valid data moving */

		/*

		 * Setup PDs using the remaining VD info mapped on those

		 * reserved rooms. And since RXD is shared memory between the

		 * host and the device allocated by dma_alloc_coherent call,

		 * the helper macro WRITE_ONCE can ensure the data written to

		 * RAM would really happens.

 Associate VD, the PD belonged to */

 Move forward the pointer of TX ring */

 Update VD with remaining data */

	/*

	 * Tagging flag for the last PD for VD will be responsible for

	 * completing VD.

 Ensure all changes indeed done before we're going on */

	/*

	 * Updating into hardware the pointer of TX ring lets HSDMA to take

	 * action for those pending PDs.

 Map VD into PC and all VCs shares a single PC */

		/*

		 * Move VD from desc_issued to desc_hw_processing when entire

		 * VD is fit into available PDs. Otherwise, the uncompleted

		 * VDs would stay in list desc_issued and then restart the

		 * processing as soon as possible once underlying ring space

		 * got freed.

		/*

		 * The extra list desc_hw_processing is used because

		 * hardware can't provide sufficient information allowing us

		 * to know what VDs are still working on the underlying ring.

		 * Through the additional list, it can help us to implement

		 * terminate_all, residue calculation and such thing needed

		 * to know detail descriptor status on the hardware.

 Read IRQ status */

	/*

	 * Using a fail-safe loop with iterations of up to MTK_DMA_SIZE to

	 * reclaim these finished descriptors: The most number of PDs the ISR

	 * can handle at one time shouldn't be more than MTK_DMA_SIZE so we

	 * take it as limited count instead of just using a dangerous infinite

	 * poll.

		/*

		 * If MTK_HSDMA_DESC_DDONE is no specified, that means data

		 * moving for the PD is still under going.

 Update residue of VD the associated PD belonged to */

 Complete VD until the relevant last PD is finished */

 Remove VD from list desc_hw_processing */

 Add VD into list desc_completed */

		/*

		 * Recycle the RXD with the helper WRITE_ONCE that can ensure

		 * data written into RAM would really happens.

 Release rooms */

 Ensure all changes indeed done before we're going on */

 Update CPU pointer for those completed PDs */

	/*

	 * Acking the pending IRQ allows hardware no longer to keep the used

	 * IRQ line in certain trigger state when software has completed all

	 * the finished physical descriptors.

 ASAP handles pending VDs in all VCs after freeing some rooms */

 All completed PDs are cleaned up, so enable interrupt again */

	/*

	 * Disable interrupt until all completed PDs are cleaned up in

	 * mtk_hsdma_free_rooms call.

 At the point, we don't expect users put descriptor into VC again */

	/*

	 * Once issue_synchronize is being set, which means once the hardware

	 * consumes all descriptors for the channel in the ring, the

	 * synchronization must be be notified immediately it is completed.

	/*

	 * At the point, we expect that all remaining descriptors in the ring

	 * for the channel should be all processing done.

 Free all descriptors in list desc_completed */

	/*

	 * Free pending descriptors not processed yet by hardware that have

	 * previously been submitted to the channel.

	/*

	 * However, the DMA engine doesn't provide any way to stop these

	 * descriptors being processed currently by hardware. The only way is

	 * to just waiting until these descriptors are all processed completely

	 * through mtk_hsdma_free_active_desc call.

	/*

	 * Since HSDMA has only one PC, the resource for PC is being allocated

	 * when the first VC is being created and the other VCs would run on

	 * the same PC.

		/*

		 * refcount_inc would complain increment on 0; use-after-free.

		 * Thus, we need to explicitly set it as 1 initially.

 Free all descriptors in all lists on the VC */

 The resource for PC is not freed until all the VCs are destroyed */

 sentinel */ }

 Kill VC task */

 Disable DMA interrupt */

 Waits for any pending IRQ handlers to complete */

 Disable hardware */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2018-2019 MediaTek Inc.

/*

 * Driver for MediaTek Command-Queue DMA Controller

 *

 * Author: Shun-Chih Yu <shun-chih.yu@mediatek.com>

 *

 The default number of virtual channel */

 The default number of physical channel */

 Registers for underlying dma manipulation */

 Registers setting */

/**

 * struct mtk_cqdma_vdesc - The struct holding info describing virtual

 *                         descriptor (CVD)

 * @vd:                    An instance for struct virt_dma_desc

 * @len:                   The total data size device wants to move

 * @residue:               The remaining data size device will move

 * @dest:                  The destination address device wants to move to

 * @src:                   The source address device wants to move from

 * @ch:                    The pointer to the corresponding dma channel

 * @node:                  The lise_head struct to build link-list for VDs

 * @parent:                The pointer to the parent CVD

/**

 * struct mtk_cqdma_pchan - The struct holding info describing physical

 *                         channel (PC)

 * @queue:                 Queue for the PDs issued to this PC

 * @base:                  The mapped register I/O base of this PC

 * @irq:                   The IRQ that this PC are using

 * @refcnt:                Track how many VCs are using this PC

 * @tasklet:               Tasklet for this PC

 * @lock:                  Lock protect agaisting multiple VCs access PC

 lock to protect PC */

/**

 * struct mtk_cqdma_vchan - The struct holding info describing virtual

 *                         channel (VC)

 * @vc:                    An instance for struct virt_dma_chan

 * @pc:                    The pointer to the underlying PC

 * @issue_completion:	   The wait for all issued descriptors completited

 * @issue_synchronize:	   Bool indicating channel synchronization starts

/**

 * struct mtk_cqdma_device - The struct holding info describing CQDMA

 *                          device

 * @ddev:                   An instance for struct dma_device

 * @clk:                    The clock that device internal is using

 * @dma_requests:           The number of VCs the device supports to

 * @dma_channels:           The number of PCs the device supports to

 * @vc:                     The pointer to all available VCs

 * @pc:                     The pointer to all the underlying PCs

 wait for the previous transaction done */

 warm reset the dma engine for the new transaction */

 setup the source */

 setup the destination */

 setup the length */

 start dma engine */

 need to trigger dma engine if PC's queue is empty */

 add VD into PC's queue */

 start the dma engine */

 remove VD from list desc_issued */

/*

 * return true if this VC is active,

 * meaning that there are VDs under processing by the PC

/*

 * return the pointer of the CVD that is just consumed by the PC

 consume a CVD from PC's queue */

 update residue of the parent CVD */

 delete CVD from PC's queue */

 check whether all the child CVDs completed */

 add the parent VD into list desc_completed */

 setup completion if this VC is under synchronization */

 start transaction for next CVD in the queue */

 consume the queue */

 submit the next CVD */

		/*

		 * free child CVD after completion.

		 * the parent CVD would be freeed with desc_free by user.

 re-enable interrupt before leaving tasklet */

 clear interrupt flags for each PC */

 clear interrupt */

 disable interrupt */

 schedule the tasklet to handle the transactions */

 acquire PC's lock before VS's lock for lock dependency in tasklet */

	/*

	 * In the case that trsanction length is larger than the

	 * DMA engine supports, a single memcpy transaction needs

	 * to be separated into several DMA transactions.

	 * Each DMA transaction would be described by a CVD,

	 * and the first one is referred as the parent CVD,

	 * while the others are child CVDs.

	 * The parent CVD's tx descriptor is the only tx descriptor

	 * returned to the DMA user, and it should not be completed

	 * until all the child CVDs completed.

 setup dma channel */

 setup sourece, destination, and length */

 setup tx descriptor */

 update the src, dest, len, prev_tx for the next CVD */

	/*

	 * set desc_allocated, desc_submitted,

	 * and desc_issued as the candicates to be freed

 free descriptor lists */

 acquire PC's lock first due to lock dependency in dma ISR */

 synchronization is required if this VC is active */

 waiting for the completion of this VC */

 free all descriptors in list desc_completed */

 free descriptors not processed yet by hardware */

 free descriptors being processed by hardware */

 allocate PC with the minimun refcount */

 allocate PC when the refcount is zero */

 enable interrupt for this PC */

		/*

		 * refcount_inc would complain increment on 0; use-after-free.

		 * Thus, we need to explicitly set it as 1 initially.

 free all descriptors in all lists on the VC */

 PC is not freed until there is no VC mapped to it */

 start the flush operation and stop the engine */

 wait for the completion of flush operation */

 clear the flush bit and interrupt flag */

 disable interrupt for this PC */

 reset all PCs */

 reset all PCs */

 sentinel */ }

 initialization for PCs */

 allocate IRQ resource */

 allocate resource for VCs */

 initialize tasklet for each PC */

 kill VC task */

 disable interrupt */

 Waits for any pending IRQ handlers to complete */

 disable hardware */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Bestcomm ATA task microcode

 *

 * Copyright (c) 2004 Freescale Semiconductor, Inc.

 *

 * Created based on bestcom/code_dma/image_rtos1/dma_image.hex

/*

 * The header consists of the following fields:

 *	u32	magic;

 *	u8	desc_size;

 *	u8	var_size;

 *	u8	inc_size;

 *	u8	first_var;

 *	u8	reserved[8];

 *

 * The size fields contain the number of 32-bit words.

 header */

 Task descriptors */

 LCD: idx0 = var3; idx0 <= var2; idx0 += inc3 */

   DRD1A: var3 = var1; FN=0 MORE init=31 WS=0 RS=0 */

   LCD: idx1 = *idx0, idx2 = var0; idx1 < var9; idx1 += inc4, idx2 += inc4 */

     DRD1A: var3 = idx0; FN=0 MORE init=0 WS=0 RS=0 */

     DRD2A: EU0=0 EU1=0 EU2=0 EU3=2 EXT init=0 WS=2 RS=2 */

     DRD2B1: *idx2 = EU3(); EU3(*idx2,var10)  */

   LCDEXT: idx1 = idx1; idx1 > var9; idx1 += inc0 */

   LCDEXT: idx2 = *(idx0 + var00000015); ; idx2 += inc2 */

   LCD: idx3 = *(idx0 + var00000019); ; idx3 += inc1 */

     DRD1A: *idx3 = *idx2; FN=0 TFD init=31 WS=3 RS=3 */

   LCD: idx1 = idx1; idx1 once var0; idx1 += inc5 */

     DRD2A: EU0=0 EU1=0 EU2=0 EU3=5 INT EXT init=0 WS=0 RS=0 */

     DRD2B1: *idx0 = EU3(); EU3(idx1,var9)  */

 NOP */

 VAR[9]-VAR[14] */

 INC[0]-INC[6] */

/*

 * Simple memory allocator for on-board SRAM

 *

 *

 * Maintainer : Sylvain Munaut <tnt@246tNt.com>

 *

 * Copyright (C) 2005 Sylvain Munaut <tnt@246tNt.com>

 *

 * This file is licensed under the terms of the GNU General Public License

 * version 2. This program is licensed "as is" without any warranty of any

 * kind, whether express or implied.

 Struct keeping our 'state' */

 needed for inline functions */

 ======================================================================== */

 Public API                                                               */

 ======================================================================== */

/* DO NOT USE in interrupts, if needed in irq handler, we should use the

 Create our state struct */

 Get address and size of the sram */

 Request region */

 Map SRAM */

 sram is not really __iomem */

 Create an rheap (defaults to 32 bits word alignment) */

 Attach the free zones */

 Currently disabled ... for future use only */

 Attach the whole zone */

 Attach each zone independently */

 Init our spinlock */

 Free resources */

/*

 * Driver for MPC52xx processor BestComm peripheral controller

 *

 *

 * Copyright (C) 2006-2007 Sylvain Munaut <tnt@246tNt.com>

 * Copyright (C) 2005      Varma Electronics Oy,

 *                         ( by Andrey Volkov <avolkov@varma-el.com> )

 * Copyright (C) 2003-2004 MontaVista, Software, Inc.

 *                         ( by Dale Farnsworth <dfarnsworth@mvista.com> )

 *

 * This file is licensed under the terms of the GNU General Public License

 * version 2. This program is licensed "as is" without any warranty of any

 * kind, whether express or implied.

 MPC5200 device tree match tables */

 needed for inline functions */

 ======================================================================== */

 Public and private API                                                   */

 ======================================================================== */

 Private API */

 Don't try to do anything if bestcomm init failed */

 Get and reserve a task num */

 we use stop as a marker */

 dummy addr */

 Allocate our structure */

 Get IRQ of that task */

 Init the BDs, if needed */

 Stop the task */

 Clear TDT */

 Free everything */

 Safety checks */

 Initial load or reload */

 Clear & copy */

 Just setting tcr is apparently not enough due to some problem */

 with it. So we just go thru all the microcode and replace in  */

 the DRD directly */

 Public API */

 ======================================================================== */

 Engine init/cleanup                                                      */

 ======================================================================== */

 Function Descriptor table */

 this will need to be updated if Freescale changes their task code FDT */

 FDT[48] - load_acc()	  */

 FDT[49] - unload_acc() */

 FDT[50] - and()        */

 FDT[51] - or()         */

 FDT[52] - xor()        */

 FDT[53] - andn()       */

 FDT[54] - not()        */

 FDT[55] - add()        */

 FDT[56] - sub()        */

 FDT[57] - lsh()        */

 FDT[58] - rsh()        */

 FDT[59] - crc8()       */

 FDT[60] - crc16()      */

 FDT[61] - crc32()      */

 FDT[62] - endian32()   */

 FDT[63] - endian16()   */

 Allocate & clear SRAM zones for FDT, TDTs, contexts and vars/incs */

 Copy the FDT for the EU#3 */

 Initialize Task base structure */

 Init 'always' initiator */

 Disable COMM Bus Prefetch on the original 5200; it's broken */

 Init lock */

 Stop all tasks */

 Release the SRAM zones */

 ======================================================================== */

 OF platform driver                                                       */

 ======================================================================== */

 Inform user we're ok so far */

 Get the bestcomm node */

 Prepare SRAM */

 Get a clean struct */

 Save the node */

 Get, reserve & map io */

 Now, do the real init */

 Done ! */

 Error path */

 Clean up the engine */

 Cleanup SRAM */

 Release regs */

 Release the node */

 Release memory */

 ======================================================================== */

 Module                                                                   */

 ======================================================================== */

 If we're not a module, we must make sure everything is setup before  */

 anyone tries to use us ... that's why we use subsys_initcall instead */

 of module_init. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Bestcomm FEC RX task microcode

 *

 * Copyright (c) 2004 Freescale Semiconductor, Inc.

 *

 * Automatically created based on BestCommAPI-2.2/code_dma/image_rtos1/dma_image.hex

 * on Tue Mar 22 11:19:38 2005 GMT

/*

 * The header consists of the following fields:

 *	u32	magic;

 *	u8	desc_size;

 *	u8	var_size;

 *	u8	inc_size;

 *	u8	first_var;

 *	u8	reserved[8];

 *

 * The size fields contain the number of 32-bit words.

 header */

 Task descriptors */

 LCD: idx0 = var1, idx1 = var4; idx1 <= var3; idx0 += inc4, idx1 += inc3 */

   DRD1A: var4 = var2; FN=0 MORE init=3 WS=0 RS=0 */

   LCD: idx2 = *idx1, idx3 = var0; idx2 < var9; idx2 += inc4, idx3 += inc4 */

     DRD1A: var4 = idx1; FN=0 MORE init=0 WS=0 RS=0 */

     DRD2A: EU0=0 EU1=0 EU2=0 EU3=2 EXT init=0 WS=2 RS=2 */

     DRD2B1: *idx3 = EU3(); EU3(*idx3,var10)  */

   LCDEXT: idx2 = 0x00000000; ; */

   LCD: idx3 = *(idx1 + var00000015); idx3 once var0; idx3 += inc5 */

     DRD2A: EU0=0 EU1=0 EU2=0 EU3=2 EXT init=0 WS=0 RS=0 */

     DRD2B1: idx2 = EU3(); EU3(idx3,var12)  */

   LCD: idx2 = idx2, idx3 = idx3; idx2 > var11; idx2 += inc6, idx3 += inc2 */

     DRD1A: *idx3 = *idx0; FN=0 init=3 WS=1 RS=1 */

   LCDEXT: idx2 = 0x00000000; ; */

   LCD: idx3 = idx3; idx3 once var0; idx3 += inc5 */

     DRD2A: EU0=0 EU1=0 EU2=0 EU3=2 EXT MORE init=0 WS=0 RS=0 */

     DRD2B1: var13 = EU3(); EU3(*idx1,var14)  */

     DRD1A: idx2 = var13; FN=0 init=0 WS=0 RS=0 */

   LCD: idx2 = idx2, idx3 = idx3; idx2 > var13; idx2 += inc0, idx3 += inc1 */

     DRD1A: *idx3 = *idx0; FN=0 init=3 WS=3 RS=3 */

   LCD: idx2 = idx2, idx3 = idx3; idx2 > var9; idx2 += inc6, idx3 += inc2 */

     DRD1A: *idx3 = *idx0; FN=0 INT init=3 WS=1 RS=1 */

   LCD: idx2 = idx0; idx2 once var0; idx2 += inc5 */

     DRD1A: *idx1 = *idx2; FN=0 init=3 WS=0 RS=0 */

   NOP */

 VAR[9]-VAR[14] */

 INC[0]-INC[6] */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Bestcomm GenBD RX task microcode

 *

 * Copyright (C) 2006 AppSpec Computer Technologies Corp.

 *                    Jeff Gibbons <jeff.gibbons@appspec.com>

 * Copyright (c) 2004 Freescale Semiconductor, Inc.

 *

 * Based on BestCommAPI-2.2/code_dma/image_rtos1/dma_image.hex

 * on Tue Mar 4 10:14:12 2006 GMT

/*

 * The header consists of the following fields:

 *	u32	magic;

 *	u8	desc_size;

 *	u8	var_size;

 *	u8	inc_size;

 *	u8	first_var;

 *	u8	reserved[8];

 *

 * The size fields contain the number of 32-bit words.

 header */

 Task descriptors */

 LCD: idx0 = var1, idx1 = var4; idx1 <= var3; idx0 += inc3, idx1 += inc2 */

   DRD1A: var4 = var2; FN=0 MORE init=31 WS=0 RS=0 */

   LCD: idx2 = *idx1, idx3 = var0; idx2 < var9; idx2 += inc3, idx3 += inc3 */

     DRD1A: var4 = idx1; FN=0 MORE init=0 WS=0 RS=0 */

     DRD2A: EU0=0 EU1=0 EU2=0 EU3=2 EXT init=0 WS=2 RS=2 */

     DRD2B1: *idx3 = EU3(); EU3(*idx3,var10)  */

   LCDEXT: idx2 = idx2; idx2 > var9; idx2 += inc0 */

   LCD: idx3 = *(idx1 + var00000015); ; idx3 += inc1 */

     DRD1A: *idx3 = *idx0; FN=0 INT init=31 WS=3 RS=3 */

   LCD: idx2 = idx2; idx2 once var0; idx2 += inc4 */

     DRD2A: EU0=0 EU1=0 EU2=0 EU3=5 EXT init=0 WS=0 RS=0 */

     DRD2B1: *idx1 = EU3(); EU3(idx2,var9)  */

   NOP */

 VAR[9]-VAR[10] */

 INC[0]-INC[3] */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Driver for MPC52xx processor BestComm General Buffer Descriptor

 *

 * Copyright (C) 2007 Sylvain Munaut <tnt@246tNt.com>

 * Copyright (C) 2006 AppSpec Computer Technologies Corp.

 *                    Jeff Gibbons <jeff.gibbons@appspec.com>

 ======================================================================== */

 Task image/var/inc                                                       */

 ======================================================================== */

 gen_bd tasks images */

 rx task vars that need to be set before enabling the task */

 (u16*) address of task's control register */

 (u32*) address of gen_bd's fifo */

 (struct bcom_bd*) beginning of ring buffer */

 (struct bcom_bd*) end of ring buffer */

 (struct bcom_bd*) current bd */

 size of receive buffer */

 rx task incs that need to be set before enabling the task */

 tx task vars that need to be set before enabling the task */

 (u32*) address of gen_bd's fifo */

 (u16*) address of task's control register */

 (struct bcom_bd*) beginning of ring buffer */

 (struct bcom_bd*) end of ring buffer */

 (struct bcom_bd*) current bd */

 set by uCode for each packet */

 tx task incs that need to be set before enabling the task */

 private structure */

 ======================================================================== */

 Task support code                                                        */

 ======================================================================== */

 Shutdown the task */

 Reset the microcode */

 Reset the BDs */

 Configure some stuff */

 Clear ints */

 Nothing special for the GenBD tasks */

 Shutdown the task */

 Reset the microcode */

 Reset the BDs */

 Configure some stuff */

 Clear ints */

 Nothing special for the GenBD tasks */

/* ---------------------------------------------------------------------

 * PSC support code

/**

 * bcom_psc_parameters - Bestcomm initialization value table for PSC devices

 *

 * This structure is only used internally.  It is a lookup table for PSC

 * specific parameters to bestcomm tasks.

/**

 * bcom_psc_gen_bd_rx_init - Allocate a receive bcom_task for a PSC port

 * @psc_num:	Number of the PSC to allocate a task for

 * @queue_len:	number of buffer descriptors to allocate for the task

 * @fifo:	physical address of FIFO register

 * @maxbufsize:	Maximum receive data size in bytes.

 *

 * Allocate a bestcomm task structure for receiving data from a PSC.

/**

 * bcom_psc_gen_bd_tx_init - Allocate a transmit bcom_task for a PSC port

 * @psc_num:	Number of the PSC to allocate a task for

 * @queue_len:	number of buffer descriptors to allocate for the task

 * @fifo:	physical address of FIFO register

 *

 * Allocate a bestcomm task structure for transmitting data to a PSC.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Bestcomm FEC TX task microcode

 *

 * Copyright (c) 2004 Freescale Semiconductor, Inc.

 *

 * Automatically created based on BestCommAPI-2.2/code_dma/image_rtos1/dma_image.hex

 * on Tue Mar 22 11:19:29 2005 GMT

/*

 * The header consists of the following fields:

 *	u32	magic;

 *	u8	desc_size;

 *	u8	var_size;

 *	u8	inc_size;

 *	u8	first_var;

 *	u8	reserved[8];

 *

 * The size fields contain the number of 32-bit words.

 header */

 Task descriptors */

 LCD: idx0 = var0; idx0 <= var0; idx0 += inc3 */

   DRD2A: EU0=0 EU1=0 EU2=0 EU3=5 EXT init=0 WS=0 RS=0 */

   DRD2B1: var7 = EU3(); EU3(*idx0,var13)  */

 LCD: idx0 = var1, idx1 = var5; idx1 <= var4; idx0 += inc4, idx1 += inc3 */

   DRD1A: var5 = var3; FN=0 MORE init=4 WS=0 RS=0 */

   LCDEXT: idx2 = *idx1, idx3 = var2; idx2 < var14; idx2 += inc4, idx3 += inc4 */

   LCD: idx4 = var0; ; idx4 += inc4 */

     DRD1A: var5 = idx1; FN=0 MORE init=0 WS=0 RS=0 */

     DRD2A: EU0=0 EU1=0 EU2=0 EU3=2 EXT init=0 WS=2 RS=2 */

     DRD2B1: *idx3 = EU3(); EU3(*idx3,var15)  */

   LCD: idx2 = idx2, idx3 = idx4; idx2 once var0; idx2 += inc5, idx3 += inc4 */

     DRD2A: EU0=0 EU1=0 EU2=0 EU3=2 EXT MORE init=0 WS=0 RS=0 */

     DRD2B1: var9 = EU3(); EU3(*idx1,var13)  */

     DRD2A: EU0=0 EU1=0 EU2=0 EU3=3 EXT init=0 WS=0 RS=0 */

     DRD2B1: *idx3 = EU3(); EU3(var9,var7)  */

   LCDEXT: idx2 = 0x00000000; ; */

   LCD: idx3 = *(idx1 + var0000001a); idx3 once var0; idx3 += inc5 */

     DRD2A: EU0=0 EU1=0 EU2=0 EU3=2 EXT MORE init=0 WS=0 RS=0 */

     DRD2B1: idx2 = EU3(); EU3(idx3,var17)  */

     DRD1A: var11 = idx2; FN=0 init=0 WS=0 RS=0 */

   LCD: idx2 = idx2, idx3 = idx3; idx2 > var16; idx2 += inc6, idx3 += inc2 */

     DRD1A: *idx0 = *idx3; FN=0 init=4 WS=1 RS=1 */

   LCDEXT: idx2 = 0x00000000; ; */

   LCD: idx3 = idx3; idx3 once var0; idx3 += inc5 */

     DRD2A: EU0=0 EU1=0 EU2=0 EU3=2 EXT MORE init=0 WS=0 RS=0 */

     DRD2B1: var18 = EU3(); EU3(*idx1,var19)  */

     DRD2A: EU0=0 EU1=0 EU2=0 EU3=8 EXT init=0 WS=0 RS=0 */

     DRD2B1: idx2 = EU3(); EU3(var18,var11)  */

   LCD: idx2 = idx2, idx3 = idx3; idx2 > var18; idx2 += inc0, idx3 += inc1 */

     DRD1A: *idx0 = *idx3; FN=0 init=4 WS=3 RS=3 */

   LCD: idx2 = idx2, idx3 = idx3; idx2 > var14; idx2 += inc6, idx3 += inc2 */

     DRD1A: *idx0 = *idx3; FN=0 TFD init=4 WS=1 RS=1 */

   LCD: idx2 = idx2; idx2 once var0; idx2 += inc5 */

     DRD2A: EU0=0 EU1=0 EU2=0 EU3=5 EXT init=0 WS=0 RS=0 */

     DRD2B1: *idx1 = EU3(); EU3(idx2,var14)  */

   NOP */

 VAR[13]-VAR[19] */

 INC[0]-INC[6] */

/*

 * Bestcomm ATA task driver

 *

 *

 * Patterned after bestcomm/fec.c by Dale Farnsworth <dfarnsworth@mvista.com>

 *                                   2003-2004 (c) MontaVista, Software, Inc.

 *

 * Copyright (C) 2006-2007 Sylvain Munaut <tnt@246tNt.com>

 * Copyright (C) 2006      Freescale - John Rigby

 *

 * This file is licensed under the terms of the GNU General Public License

 * version 2. This program is licensed "as is" without any warranty of any

 * kind, whether express or implied.

 ======================================================================== */

 Task image/var/inc                                                       */

 ======================================================================== */

 ata task image */

 ata task vars that need to be set before enabling the task */

 (u16*) address of task's control register */

 (struct bcom_bd*) beginning of ring buffer */

 (struct bcom_bd*) end of ring buffer */

 (struct bcom_bd*) current bd */

 size of receive buffer */

 ata task incs that need to be set before enabling the task */

 ======================================================================== */

 Task support code                                                        */

 ======================================================================== */

 Prefetch breaks ATA DMA.  Turn it off for ATA DMA */

 Configure some stuff */

 Clear ints */

 Reset all BD */

 Nothing special for the ATA tasks */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Bestcomm GenBD TX task microcode

 *

 * Copyright (C) 2006 AppSpec Computer Technologies Corp.

 *                    Jeff Gibbons <jeff.gibbons@appspec.com>

 * Copyright (c) 2004 Freescale Semiconductor, Inc.

 *

 * Based on BestCommAPI-2.2/code_dma/image_rtos1/dma_image.hex

 * on Tue Mar 4 10:14:12 2006 GMT

/*

 * The header consists of the following fields:

 *	u32	magic;

 *	u8	desc_size;

 *	u8	var_size;

 *	u8	inc_size;

 *	u8	first_var;

 *	u8	reserved[8];

 *

 * The size fields contain the number of 32-bit words.

 header */

 Task descriptors */

 LCD: idx0 = var0, idx1 = var4; idx1 <= var3; idx0 += inc4, idx1 += inc3 */

   DRD1A: var4 = var2; FN=0 MORE init=31 WS=0 RS=0 */

   LCD: idx2 = *idx1, idx3 = var1; idx2 < var9; idx2 += inc4, idx3 += inc4 */

     DRD1A: var4 = idx1; FN=0 MORE init=0 WS=0 RS=0 */

     DRD2A: EU0=0 EU1=0 EU2=0 EU3=2 EXT init=0 WS=2 RS=2 */

     DRD2B1: *idx3 = EU3(); EU3(*idx3,var10)  */

   LCDEXT: idx2 = idx2; idx2 > var12; idx2 += inc0 */

   LCD: idx3 = *(idx1 + var00000015); ; idx3 += inc1 */

     DRD1A: *idx0 = *idx3; FN=0 init=31 WS=3 RS=3 */

   LCD: idx2 = idx2, idx3 = idx3; idx2 > var9; idx2 += inc5, idx3 += inc2 */

     DRD1A: *idx0 = *idx3; FN=0 TFD INT init=31 WS=1 RS=1 */

   LCD: idx2 = idx2; idx2 once var0; idx2 += inc6 */

     DRD2A: EU0=0 EU1=0 EU2=0 EU3=5 EXT init=0 WS=0 RS=0 */

     DRD2B1: *idx1 = EU3(); EU3(idx2,var9)  */

   NOP */

 VAR[9]-VAR[12] */

 INC[0]-INC[5] */

/*

 * Bestcomm FEC tasks driver

 *

 *

 * Copyright (C) 2006-2007 Sylvain Munaut <tnt@246tNt.com>

 * Copyright (C) 2003-2004 MontaVista, Software, Inc.

 *                         ( by Dale Farnsworth <dfarnsworth@mvista.com> )

 *

 * This file is licensed under the terms of the GNU General Public License

 * version 2. This program is licensed "as is" without any warranty of any

 * kind, whether express or implied.

 ======================================================================== */

 Task image/var/inc                                                       */

 ======================================================================== */

 fec tasks images */

 rx task vars that need to be set before enabling the task */

 (u16*) address of task's control register */

 (u32*) address of fec's fifo */

 (struct bcom_bd*) beginning of ring buffer */

 (struct bcom_bd*) end of ring buffer */

 (struct bcom_bd*) current bd */

 size of receive buffer */

 rx task incs that need to be set before enabling the task */

 tx task vars that need to be set before enabling the task */

 (u32*) address of self-modified DRD */

 (u32*) address of fec's fifo */

 (u16*) address of task's control register */

 (struct bcom_bd*) beginning of ring buffer */

 (struct bcom_bd*) end of ring buffer */

 (struct bcom_bd*) current bd */

 set by uCode for each packet */

 tx task incs that need to be set before enabling the task */

 private structure in the task */

 ======================================================================== */

 Task support code                                                        */

 ======================================================================== */

 Shutdown the task */

 Reset the microcode */

 These should be in the   */

 task image, but we stick */

 to the official ones     */

 Reset the BDs */

 Configure some stuff */

 Clear ints */

 Nothing special for the FEC tasks */

 Return 2nd to last DRD */

	/* This is an ugly hack, but at least it's only done

 Shutdown the task */

 Reset the microcode */

 These should be in the   */

 task image, but we stick */

 to the official ones     */

 Reset the BDs */

 Configure some stuff */

 Clear ints */

 Nothing special for the FEC tasks */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Intel I/OAT DMA Linux driver

 * Copyright(c) 2004 - 2015 Intel Corporation.

/* provide a lookup table for setting the source address in the base or

 * extended descriptor of an xor or pq descriptor

 we leave the channel locked to ensure in order submission */

	/* we need 2x the number of descriptors to cover greater than 5

	 * sources

	/* completion writes from the raid engine may pass completion

	 * writes from the legacy engine, so we need one extra null

	 * (legacy) descriptor to ensure all completion writes arrive in

	 * order.

		/* save a branch by unconditionally retrieving the

		 * extended descriptor xor_set_src() knows to not write

		 * to it in the single descriptor case

 last xor descriptor carries the unmap parameters and fence bit */

 completion descriptor carries interrupt bit */

 we leave the channel locked to ensure in order submission */

	/* the cleanup routine only sets bits on validate failure, it

	 * does not clear bits on validate success... so clear it here

	/* the engine requires at least two sources (we provide

	 * at least 1 implied source in the DMA_PREP_CONTINUE case)

	/* we need 2x the number of descriptors to cover greater than 3

	 * sources (we need 1 extra source in the q-only continuation

	 * case and 3 extra sources in the p+q continuation case.

	/* completion writes from the raid engine may pass completion

	 * writes from the legacy engine, so we need one extra null

	 * (legacy) descriptor to ensure all completion writes arrive in

	 * order.

		/* save a branch by unconditionally retrieving the

		 * extended descriptor pq_set_src() knows to not write

		 * to it in the single descriptor case

 see the comment for dma_maxpq in include/linux/dmaengine.h */

 we turn on descriptor write back error status */

 last pq descriptor carries the unmap parameters and fence bit */

 completion descriptor carries interrupt bit */

 we leave the channel locked to ensure in order submission */

 this function is only called with 9-16 sources */

	/*

	 * 16 source pq is only available on cb3.3 and has no completion

	 * write hw bug.

 see the comment for dma_maxpq in include/linux/dmaengine.h */

 we turn on descriptor write back error status */

 last pq descriptor carries the unmap parameters and fence bit */

 with cb3.3 we should be able to do completion w/o a null desc */

 we leave the channel locked to ensure in order submission */

 specify valid address for disabled result */

	/* handle the single source multiply case from the raid6

	 * recovery path

 specify valid address for disabled result */

	/* the cleanup routine only sets bits on validate failure, it

	 * does not clear bits on validate success... so clear it here

 specify valid address for disabled result */

	/* the cleanup routine only sets bits on validate failure, it

	 * does not clear bits on validate success... so clear it here

 specify valid address for disabled result */

 we leave the channel locked to ensure in order submission */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Intel I/OAT DMA Linux driver

 * Copyright(c) 2004 - 2015 Intel Corporation.

/*

 * This driver supports an Intel I/OAT DMA engine, which does asynchronous

 * copy operations.

/**

 * ioat_dma_do_interrupt - handler used for single vector interrupt mode

 * @irq: interrupt id

 * @data: interrupt data

/**

 * ioat_dma_do_interrupt_msix - handler used for vector-per-channel interrupt mode

 * @irq: interrupt id

 * @data: interrupt data

	/* 1/ stop irq from firing tasklets

	 * 2/ stop the tasklet from re-arming irqs

 flush inflight interrupts */

 flush inflight timers */

 flush inflight tasklet runs */

 final cleanup now that everything is quiesced and can't re-arm */

/**

 * ioat_update_pending - log pending descriptors

 * @ioat_chan: ioat+ channel

 *

 * Check if the number of unsubmitted descriptors has exceeded the

 * watermark.  Called with prep_lock held

 set size to non-zero value (channel returns error when size is 0) */

 make sure descriptors are written before we submit */

 set the tail to be re-issued */

	/* make descriptor updates visible before advancing ioat->head,

	 * this is purposefully not smp_wmb() since we are also

	 * publishing the descriptor updates to a dma device

 allocate the array to hold the software ring */

 link descs */

 setup descriptor pre-fetching for v3.4 */

/**

 * ioat_check_space_lock - verify space and grab ring producer lock

 * @ioat_chan: ioat,3 channel (ring) to operate on

 * @num_descs: allocation length

	/* never allow the last descriptor to be consumed, we need at

	 * least one free at all times to allow for on-the-fly ring

	 * resizing.

 with ioat->prep_lock held */

	/* progress reclaim in the allocation failure case we may be

	 * called under bh_disabled so we need to trigger the timer

	 * event directly

 check if there's error written */

 need to set a chanerr var for checking to clear later */

/**

 * __cleanup - reclaim used descriptors

 * @ioat_chan: channel (ring) to clean

 * @phys_complete: zeroed (or not) completion address (from status)

	/*

	 * At restart of the channel, the completion address and the

	 * channel status will be 0 due to starting a new chain. Since

	 * it's new chain and the first descriptor "fails", there is

	 * nothing to clean up. We do not want to reap the entire submitted

	 * chain due to this 0 address value and then BUG.

 set err stat if we are using dwbes */

 skip extended descriptors */

 cleanup super extended descriptors */

 finish all descriptor reads before incrementing tail */

 no active descs have written a completion? */

 microsecond delay by sysfs variable  per pending descriptor */

 set the completion address register again */

	/*

	 * We assume that the failed descriptor has been processed.

	 * Now we are just returning all the remaining submitted

	 * descriptors to abort.

 we skip the failed descriptor that tail points to */

 skip extended descriptors */

 cleanup super extended descriptors */

 finish all descriptor reads before incrementing tail */

 cleanup so tail points to descriptor that caused the error */

 fault on unhandled error or spurious halt */

 cleanup the faulty descriptor since we are continuing */

 mark faulting descriptor as complete */

 we need abort all descriptors */

 clean up the channel, we could be in weird state */

	/* when halted due to errors check for channel

	 * programming errors before advancing the completion state

 handle the no-actives case */

 handle the missed cleanup case */

		/* timer restarted in ioat_cleanup_preamble

		 * and IOAT_COMPLETION_ACK cleared

	/* if we haven't made progress and we have already

	 * acknowledged a pending completion once, then be more

	 * forceful with a restart

 handle missed issue pending case */

	/* throw away whatever the channel was doing and get it

	 * initialized, with ioat3 specific workarounds

 clear any pending errors */

		/* Clear DMAUNCERRSTS Cfg-Reg Parity Error status bit

		 * (workaround for spurious config parity error after restart)

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Intel I/OAT DMA Linux driver

 * Copyright(c) 2004 - 2015 Intel Corporation.

 I/OAT v3 platforms */

 I/OAT v3.2 platforms */

 I/OAT v3.3 platforms */

 I/OAT v3.4 platforms */

 even though not Atom, BDX-DE has same DMA silicon */

/*

 * Perform a IOAT transaction to verify the HW works.

/**

 * ioat_dma_self_test - Perform a IOAT transaction to verify the HW works.

 * @ioat_dma: dma device to be tested

 Fill in src buffer */

 Start copy, using first DMA channel */

/**

 * ioat_dma_setup_interrupts - setup interrupt handler

 * @ioat_dma: ioat dma device

 The number of MSI-X vectors should equal the number of channels */

 Disable all interrupt generation */

 Disable all interrupt generation */

/**

 * ioat_enumerate_channels - find and initialize the device's channels

 * @ioat_dma: the ioat dma device to be enumerated

 bits [4:0] valid */

 bits [4:0] valid */

/**

 * ioat_free_chan_resources - release all the descriptors

 * @c: the channel to be cleaned

	/* Before freeing channel resources first check

	 * if they have been previously allocated for this channel.

 Put LTR to idle */

/* ioat_alloc_chan_resources - allocate/initialize ioat descriptor ring

 * @chan: channel to be initialized

 have we already been set up? */

 Setup register to interrupt and write completion status on error */

 allocate a completion writeback area */

 doing 2 32bit writes to mmio since 1 64b write doesn't work */

 Setting up LTR values for 3.4 or later */

 Select to active */

 check that we got off the ground */

 common channel initialization */

 must be <= 8 */

 Fill in src buffers */

 test xor */

 skip validate if the capability is not present */

 validate the sources with the destintation page */

 test for non-zero parity sum */

	/*

	 * if we have descriptor write back error status, we mask the

	 * error interrupts

 dca is incompatible with raid operations */

 starting with CB3.3 super extended descriptors are supported */

 allocate SED DMA pool */

 disable relaxed ordering */

 clear relaxed ordering enable */

		/*

		 * Synchronization rule for del_timer_sync():

		 *  - The caller must not hold locks which would prevent

		 *    completion of the timer's handler.

		 * So prep_lock cannot be held before calling it.

 this should quiesce then reset */

 no need to reset as shutdown already did that */

 quiesce and block I/O */

 initialize and bring everything back */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Intel I/OAT DMA Linux driver

 * Copyright(c) 2004 - 2015 Intel Corporation.

 ...taken outside the lock, no need to be precise */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Intel I/OAT DMA Linux driver

 * Copyright(c) 2007 - 2009 Intel Corporation.

 either a kernel change is needed, or we need something like this in kernel */

/*

 * Bit 7 of a tag map entry is the "valid" bit, if it is set then bits 0:6

 * contain the bit number of the APIC ID to map into the DCA tag.  If the valid

 * bit is not set, then the value must be 0 or 1 and defines the bit in the tag.

 expected tag map bytes for I/OAT ver.2 */

/*

 * "Legacy" DCA systems do not implement the DCA register set in the

 * I/OAT device.  Software needs direct support for their tag mappings.

 pack PCI B/D/F into a u16 */

 CPUID level 9 returns DCA configuration */

 Bit 0 indicates DCA enabled by the BIOS */

 requester device */

 requester id, as used by IOAT */

 This implementation only supports PCI-Express */

 found an empty slot */

 Error, ioatdma->requester_count is out of whack */

 This implementation only supports PCI-Express */

	/*

	 * If the tag map is not programmed by the BIOS the default is:

	 * 0x80 0x80 0x80 0x80 0x80 0x00 0x00 0x00

	 *

	 * This an invalid map and will result in only 2 possible tags

	 * 0x1F and 0x00.  0x00 is an invalid DCA tag so we know that

	 * this entire definition is invalid.

 some bios might not know to turn these on */

 TODO version, compatibility and configuration checks */

 copy out the APIC to DCA tag map */

 SPDX-License-Identifier:  GPL-2.0

 (C) 2017-2018 Synopsys, Inc. (www.synopsys.com)

/*

 * Synopsys DesignWare AXI DMA Controller driver.

 *

 * Author: Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>

/*

 * The set of bus widths supported by the DMA controller. DW AXI DMAC supports

 * master data bus width up to 512 bits (for both AXI master interfaces), but

 * it depends on IP block configurarion.

	/*

	 * We split one 64 bit write for two 32 bit write as some HW doesn't

	 * support 64 bit access.

 Called in chan locked context */

 Select AXI0 master for LLI fetching */

 Generate 'suspend' status but don't generate interrupt */

 ASSERT: channel is idle */

 LLI address must be aligned to a 64-byte boundary */

 ASSERT: channel is idle */

	/*

	 * An unused DMA channel has a default value of 0x3F.

	 * Lock the DMA channel by assign a handshake number to the channel.

	 * Unlock the DMA channel by assign 0x3F to the channel.

 Channel is already allocated, set handshake as per channel ID */

 64 bit write should handle for 8 channels */

/*

 * If DW_axi_dmac sees CHx_CTL.ShadowReg_Or_LLI_Last bit of the fetched LLI

 * as 1, it understands that the current block is the final block in the

 * transfer and completes the DMA transfer operation at the end of current

 * block transfer.

 Select AXI0 for source master */

 Select AXI1 for source master if available */

 Select AXI0 master for LLI fetching */

		/* Set end-of-link to the linked descriptor, so that cyclic

		 * callback function can be triggered during interrupt.

 Managed transfer list */

 Select AXI0 master for LLI fetching */

 Set end-of-link to the last link descriptor of list */

 Managed transfer list */

 Select AXI0 master for LLI fetching */

		/*

		 * Take care for the alignment.

		 * Actually source and destination widths can be different, but

		 * make them same to be simpler.

		/*

		 * block_ts indicates the total number of data of width

		 * to be transferred in a DMA block transfer.

		 * BLOCK_TS register should be set to block_ts - 1

 update the length and addresses for the next loop cycle */

 Set end-of-link to the last link descriptor of list */

 Managed transfer list */

 The bad descriptor currently is in the head of vc list */

 Remove the completed descriptor from issued list */

 WARN about bad descriptor */

 Try to restart the controller */

 The completed descriptor currently is in the head of vc list */

 Remove the completed descriptor from issued list before completing */

 Submit queued descriptors after processing the completed ones */

 Disable DMAC inerrupts. We'll enable them after processing chanels */

 Poll, clear and process every chanel interrupt status */

 Re-enable interrupts */

 timeout iterations */

 Called in chan locked context */

 Priority value must be programmed within [0:nr_channels-1] range */

 axi-max-burst-len is optional property */

 Set capabilities */

 DMA capabilities */

	/*

	 * Synopsis DesignWare AxiDMA datasheet mentioned Maximum

	 * supported blocks is 1024. Device register width is 4 bytes.

	 * Therefore, set constraint to 1024 * 4.

	/*

	 * We can't just call pm_runtime_get here instead of

	 * pm_runtime_get_noresume + axi_dma_resume because we need

	 * driver to work also without Runtime PM.

 Register with OF helpers for DMA lookups */

 Enable clk before accessing to registers */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * OMAP DMAengine support

 for assigning logical channels */

 Type 2 descriptor with Source or Destination address update */

 src or dst */

 number of elements (24-bit) */

 number of frames (16-bit) */

 for double indexing */

 for double indexing */

 Linked list */

 for OMAP_DMA_SYNC_PACKET / double indexing */

 for double indexing */

 CSDP_DATA_TYPE_xxx */

 CCR value */

 CLNK_CTRL value */

 CICR value */

 CSDP value */

 Linked List type1/2/3 */

 Linked List type4 */

 OMAP1 only */

 OMAP1 only */

 OMAP1 only */

 OMAP2+ only */

 OMAP2+ only */

 OMAP2+ only */

 OMAP1 only */

 OMAP1 only */

 OMAP1 only */

 OMAP1 only */

 OMAP1 only */

 OMAP1 only */

 OMAP1 only */

 OMAP1 only */

 OMAP1 only */

 OMAP1 only */

 OMAP1 only */

 OMAP1 only */

 OMAP1 only */

 OMAP2+ only */

 OMAP2+ only */

 OMAP2+ only */

 OMAP2+ only */

 OMAP2+ only */

 OMAP2+ only */

 Enable interrupts */

 Enable channel */

 Wait for sDMA FIFO to drain */

 disable irq */

 set the STOP_LNK bit */

	/*

	 * This provides the necessary barrier to ensure data held in

	 * DMA coherent memory is visible to the DMA engine prior to

	 * the transfer starting.

 This should never happen */

 Duplicate what plat-omap/dma.c does */

/*

 * OMAP 3.2/3.3 erratum: sometimes 0 is returned if CSAC/CDAC is

 * read before the DMA controller finished disabling the channel.

		/*

		 * CDAC == 0 indicates that the DMA transfer on the channel has

		 * not been started (no data has been transferred so far).

		 * Return the programmed source start address in this case.

		/*

		 * CDAC == 0 indicates that the DMA transfer on the channel

		 * has not been started (no data has been transferred so

		 * far).  Return the programmed destination start address in

		 * this case.

		/*

		 * The channel is no longer active, set the return value

		 * accordingly and mark it as completed

 Bus width translates to the element size (ES) */

 not reached */

 Now allocate and setup the descriptor. */

 When the port_window is used, one frame must cover the window */

		/*

		 * One frame covers the port_window and by  configure

		 * the source frame index to be -1 * (port_window - 1)

		 * we instruct the sDMA that after a frame is processed

		 * it should move back to the start of the window.

	/*

	 * Build our scatterlist entries: each contains the address,

	 * the number of elements (EN) in each frame, and the number of

	 * frames (FN).  Number of bytes for this entry = ES * EN * FN.

	 *

	 * Burst size translates to number of elements with frame sync.

	 * Note: DMA engine defines burst to be the number of dev-width

	 * transfers.

 Release the dma_pool entries if one allocation failed */

 Bus width translates to the element size (ES) */

 not reached */

 Now allocate and setup the descriptor. */

 Slave mode is not supported */

	/*

	 * Stop DMA activity: we assume the callback will not be called

	 * after omap_dma_stop() returns (even if it does, it will see

	 * c->desc is NULL and exit.)

 Avoid stopping the dma twice */

	/*

	 * We do not allow DMA_MEM_TO_DEV transfers to be paused.

	 * From the AM572x TRM, 16.1.4.18 Disabling a Channel During Transfer:

	 * "When a channel is disabled during a transfer, the channel undergoes

	 * an abort, unless it is hardware-source-synchronized …".

	 * A source-synchronised channel is one where the fetching of data is

	 * under control of the device. In other words, a device-to-memory

	 * transfer. So, a destination-synchronised channel (which would be a

	 * memory-to-device transfer) undergoes an abort if the the CCR_ENABLE

	 * bit is cleared.

	 * From 16.1.4.20.4.6.2 Abort: "If an abort trigger occurs, the channel

	 * aborts immediately after completion of current read/write

	 * transactions and then the FIFO is cleaned up." The term "cleaned up"

	 * is not defined. TI recommends to check that RD_ACTIVE and WR_ACTIVE

	 * are both clear _before_ disabling the channel, otherwise data loss

	 * will occur.

	 * The problem is that if the channel is active, then device activity

	 * can result in DMA activity starting between reading those as both

	 * clear and the write to DMA_CCR to clear the enable bit hitting the

	 * hardware. If the DMA hardware can't drain the data in its FIFO to the

	 * destination, then data loss "might" occur (say if we write to an UART

	 * and the UART is not accepting any further data).

 Restore channel link register */

 Currently used by omap2 & 3 to block deeper SoC idle states */

 Currently only used for omap2. For omap1, also a check for lcd_dma is needed */

/*

 * We are using IRQENABLE_L1, and legacy DMA code was using IRQENABLE_L0.

 * As the DSP may be using IRQENABLE_L2 and L3, let's not touch those for

 * now. Context save seems to be only currently needed on omap3.

 Clear IRQSTATUS_L0 as legacy DMA code is no longer doing it */

 Clear dma channels */

 Currently only used for omap3 */

 No need to restore context */

 Set only for omap2430 and later */

/*

 * No flags currently set for default configuration as omap1 is still

 * using platform data.

 CCEN: 24bit unsigned */

 Number of DMA requests */

 Number of available logical channels */

 Mask of allowed logical channels */

 Tag channels not in mask as reserved */

 Disable all interrupts */

 Device-tree DMA controller registration */

 Disable all interrupts */

 SPDX-License-Identifier: GPL-2.0-only

 DMA engine */

 DMA scheduler */

 Queue manager */

 4 KiB of memory for descriptors, 2 for each endpoint */

 Packet Descriptor */

 Node for pending list */

 Pending queued transfers */

 Lock for pending list */

 context for suspend/resume */

 USB0 ENDP 1 */

 USB1 ENDP1 */

 USB0 ENDP 1 */

 USB1 ENDP 1 */

 Usecount for chan_busy[], paired with push_desc_queue() */

 set corresponding bit for completetion Q 93 */

 not set all bits for queues less than Q 93 */

 now invert and keep only Q 93+ set */

			/*

			 * This should never trigger, see the comments in

			 * push_desc_queue()

	/*

	 * We don't use writel() but __raw_writel() so we have to make sure

	 * that the DMA descriptor in coherent memory made to the main memory

	 * before starting the dma engine.

	/*

	 * DMA transfers can take at least 200ms to complete with USB mass

	 * storage connected. To prevent autosuspend timeouts, we must use

	 * pm_runtime_get/put() when chan_busy[] is modified. This will get

	 * cleared in desc_to_chan() or cppi41_stop_chan() depending on the

	 * outcome of the transfer.

/*

 * Caller must hold cdd->lock to prevent push_desc_queue()

 * getting called out of order. We have both cppi41_dma_issue_pending()

 * and cppi41_runtime_resume() call this function.

 PD3 = packet size */

 PD6 buffer size */

 We need to use more than one desc once musb supports sg */

	/*

	 * If the TX descriptor / channel is in use, the caller needs to poke

	 * his TD bit multiple times. After that he hardware releases the

	 * transfer descriptor followed by TD descriptor. Waiting seems not to

	 * cause any difference.

	 * RX seems to be thrown out right away. However once the TearDown

	 * descriptor gets through we are done. If we have seens the transfer

	 * descriptor before the TD we fetch it from enqueue, it has to be

	 * there waiting for us.

 Invoke the callback to do the necessary clean-up */

		/*

		 * channels might still be in the pendling list if

		 * cppi41_dma_issue_pending() is called after

		 * cppi41_runtime_suspend() is called

 Usecount for chan_busy[], paired with push_desc_queue() */

	/*

	 * The channels can only be used as TX or as RX. So we add twice

	 * that much dma channels because USB can only do RX or TX.

/*

 * The param format is:

 * X Y

 * X: Port

 * Y: 0 = RX else TX

 SPDX-License-Identifier: GPL-2.0

/*

 *  Copyright (C) 2019 Texas Instruments Incorporated - http://www.ti.com

 *  Author: Peter Ujfalusi <peter.ujfalusi@ti.com>

 RPSTR0 */

 RPSTR0 */

 RPSTR1 */

 How SRC/DST tag should be updated by UDMA in the descriptor's Word 3 */

 Transmit ring */

 Transmit Completion ring */

 applicable only for PKTDMA */

 Free Descriptor ring */

 Receive ring */

 K3 UDMA Output Event Offset */

 BCDMA Output Event Offsets */

 PKTDMA Output Event Offsets */

 TR descriptor internal pointers */

 alignment to use for descriptors */

 Only used for cyclic in packet mode */

 pointer to provided metadata buffer (EPIP, PSdata) */

 not active, no teardown is in progress */

 Normal operation */

 channel is being terminated */

 TR or packet */

 EPIB is needed for the communication or not */

 size of Protocol Specific Data */

 (needs_epib ? 16:0) + psd_size */

 Size of a packet descriptor in packet mode */

 Suppress sending TDC packet */

 Channel Throughput Level */

 PKDMA mapped channel */

 PKTDMA default tflow or rflow for mapped channel */

 number of bytes completed since the start of the channel */

 Channel configuration parameters */

 dmapool for packet mode descriptors */

 Generic register access functions */

 TCHANRT */

 RCHANRT */

 No special handling for the channel */

 If more to purge, schedule the work again */

 RX flush packet: idx == -1 is only passed in case of DEV_TO_MEM */

 Ensure that writes are not moved over this point */

 Ensure that reads are not moved before this point */

 Teardown completion */

 Check for flush descriptor */

 make sure we are not leaking memory by stalled descriptor */

 Reset all counters */

 Hard reset: re-initialize the channel to reset */

 restore the channel configuration */

		/*

		 * Setting forced teardown after forced reset helps recovering

		 * the rchan.

		/*

		 * UDMA only: Push all descriptors to ring for packet mode

		 * cyclic or RX

		 * PKTDMA supports pre-linked descriptor and cyclic is not

		 * supported

 Only PDMAs have staticTR */

 Check if the staticTR configuration has changed for TX */

 Channel is already running and does not need reconfiguration */

 Make sure that we clear the teardown bit, if it is set */

 Push descriptors before we start the channel */

 Config remote TR */

 save the current staticTR configuration */

 Enable remote */

 Config remote TR */

 save the current staticTR configuration */

 Enable remote */

 Only TX towards PDMA is affected */

 Transfer is incomplete, store current residue and time stamp */

 Get previous residue and time stamp */

			/*

			 * Get current residue and time stamp or see if

			 * transfer is complete

			/*

			 * Find the time delta and residue delta w.r.t

			 * previous poll

				/*

				 * Try to guess when we should check

				 * next time by calculating rate at

				 * which data is being drained at the

				 * peer device

 No progress, check again in 1 second  */

 Teardown completion message */

 active descriptor */

			/*

			 * terminated descriptor, mark the descriptor as

			 * completed to update the channel's cookie marker

 TODO: figure out the real amount of data */

/**

 * __udma_alloc_gp_rflow_range - alloc range of GP RX flows

 * @ud: UDMA device

 * @from: Start the search from this flow id number

 * @cnt: Number of consecutive flow ids to allocate

 *

 * Allocate range of RX flow ids for future use, those flows can be requested

 * only using explicit flow id number. if @from is set to -1 it will try to find

 * first free range. if @from is positive value it will force allocation only

 * of the specified range of flows.

 *

 * Returns -ENOMEM if can't find free range.

 * -EEXIST if requested range is busy.

 * -EINVAL if wrong input values passed.

 * Returns flow id on success.

 default flows can't be allocated and accessible only by id */

	/*

	 * Attempt to request rflow by ID can be made for any rflow

	 * if not in use with assumption that caller knows what's doing.

	 * TI-SCI FW will perform additional permission check ant way, it's

	 * safe

 GP rflow has to be allocated first */

	/*

	 * Use normal channels for peripherals, and highest TPL channel for

	 * mem2mem

	/*

	 * mapped_channel_id is -1 for UDMA, BCDMA and PKTDMA unmapped channels.

	 * For PKTDMA mapped channels it is configured to a channel which must

	 * be used to service the peripheral.

 Only PKTDMA have support for tx flows */

	/*

	 * mapped_channel_id is -1 for UDMA, BCDMA and PKTDMA unmapped channels.

	 * For PKTDMA mapped channels it is configured to a channel which must

	 * be used to service the peripheral.

 Can be optimized, but let's have it like this for now */

	/*

	 * Try to use the highest TPL channel pair for MEM_TO_MEM channels

	 * Note: in UDMAP the channel TPL is symmetric between tchan and rchan

 UDMA does not use tx flows */

 For MEM_TO_MEM we don't need rflow or rings */

 Non synchronized - mem to mem type of transfer */

 wait for peer to complete the teardown for PDMAs */

 wait for peer to complete the teardown for PDMAs */

 in case of MEM_TO_MEM we have maximum of two TRs */

	/*

	 * Make sure that the completion is in a known state:

	 * No teardown, the channel is idle

 Non synchronized - mem to mem type of transfer */

 Slave transfer synchronized - mem to dev (TX) trasnfer */

 Slave transfer synchronized - dev to mem (RX) trasnfer */

 Can not happen */

 check if the channel configuration was successful */

 PSI-L pairing */

 Event from UDMA (TR events) only needed for slave TR mode channels */

 Only TR mode is supported */

	/*

	 * Make sure that the completion is in a known state:

	 * No teardown, the channel is idle

 Non synchronized - mem to mem type of transfer */

 Slave transfer synchronized - mem to dev (TX) trasnfer */

 Slave transfer synchronized - dev to mem (RX) trasnfer */

 Can not happen */

 check if the channel configuration was successful */

 PSI-L pairing */

 Event from BCDMA (TR events) only needed for slave channels */

	/*

	 * Make sure that the completion is in a known state:

	 * No teardown, the channel is idle

 Slave transfer synchronized - mem to dev (TX) trasnfer */

 Slave transfer synchronized - dev to mem (RX) trasnfer */

 Can not happen */

 check if the channel configuration was successful */

 PSI-L pairing */

 We have only one descriptor containing multiple TRs */

 Allocate memory for DMA ring descriptor */

 Start of the TR req records */

 Start address of the TR response array */

/**

 * udma_get_tr_counters - calculate TR counters for a given length

 * @len: Length of the trasnfer

 * @align_to: Preferred alignment

 * @tr0_cnt0: First TR icnt0

 * @tr0_cnt1: First TR icnt1

 * @tr1_cnt0: Second (if used) TR icnt0

 *

 * For len < SZ_64K only one TR is enough, tr1_cnt0 is not updated

 * For len >= SZ_64K two TRs are used in a simple way:

 * First TR: SZ_64K-alignment blocks (tr0_cnt0, tr0_cnt1)

 * Second TR: the remaining length (tr1_cnt0)

 *

 * Returns the number of TRs the length needs (1 or 2)

 * -EINVAL if the length can not be supported

 estimate the number of TRs we will need */

 Now allocate and setup the descriptor. */

 estimate the number of TRs we will need */

 Now allocate and setup the descriptor. */

 Bus width translates to the element size (ES) */

 not reached */

	/*

	 * PDMA must to close the packet when the channel is in packet mode.

	 * For TR mode when the channel is not cyclic we also need PDMA to close

	 * the packet otherwise the transfer will stall because PDMA holds on

	 * the data it has received from the peripheral.

 Flow and Packed ID */

 attach the sg buffer to the descriptor */

 Attach link as host buffer descriptor */

 static TR for remote PDMA */

 Now allocate and setup the descriptor. */

 TODO: re-check this... */

 Flow and Packed ID */

 attach each period to a new descriptor */

 static TR for remote PDMA */

 If we have something pending and no active descriptor, then */

		/*

		 * start a descriptor if the channel is NOT [marked as

		 * terminating _and_ it is still running (teardown has not

		 * completed yet)].

 pause the channel */

 resume the channel */

 Provide residue information for the client */

/*

 * This tasklet handles the completion of a DMA descriptor by

 * calling its callback and freeing it.

 Release PSI-L pairing */

 Normal Channels */

 H Channels */

 No UH Channels */

 Normal Channels */

 H Channels */

 No UH Channels */

 Normal Channels */

 H Channels */

 UH Channels */

 MEM_TO_MEM is slow via MCU UDMA */

 Normal Channels */

 H Channels */

 No UH Channels */

 for tchan and rchan, not applicable to bchan */

 Supported via bchan */

 Normal Channels */

 No H Channels */

 No UH Channels */

 PKTDMA does not support MEM_TO_MEM */

 Normal Channels */

 No H Channels */

 No UH Channels */

 Sentinel */ },

 Sentinel */ },

 Sentinel */ },

 sentinel */ }

 Set up the throughput level start indexes */

	/*

	 * RX flows with the same Ids as RX channels are reserved to be used

	 * as default flows if remote HW can't generate flow_ids. Those

	 * RX flows can be requested only explicitly by id.

 by default no GP rflows are assigned to Linux */

 Get resource ranges from tisci */

 tchan ranges */

 rchan and matching default flow ranges */

 GP rflow ranges */

 all gp flows are assigned exclusively to Linux */

 Set up the throughput level start indexes */

 BCDMA do not really have flows, but the driver expect it */

 Get resource ranges from tisci */

 bchan ranges */

 tchan ranges */

 rchan ranges */

 Set up the throughput level start indexes */

 Get resource ranges from tisci */

 tchan ranges */

 rchan ranges */

 rflow ranges */

 all rflows are assigned exclusively to Linux */

 tflow ranges */

 all tflows are assigned exclusively to Linux */

 Allocate 1K buffer for discarded data on RX channel teardown */

 Set up descriptor to be used for TR mode */

 Start of the TR req records */

 Start address of the TR response array */

 Set up descriptor to be used for packet mode */

 CONFIG_DEBUG_FS */

 Get the highest TPL level the device supports for memcpy */

 cyclic operation is not supported via PKTDMA */

 Use custom vchan completion handling */

 Configure the copy_align to the maximum burst size the device supports */

 Private interfaces to UDMA */

/*

 * TI EDMA DMA engine driver

 *

 * Copyright 2012 Texas Instruments

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License as

 * published by the Free Software Foundation version 2.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

 Offsets matching "struct edmacc_param" */

 Offsets for EDMA CC global channel registers and their shadows */

 64 bits */

 64 bits */

 64 bits */

 64 bits */

 64 bits */

 64 bits */

 64 bits */

 64 bits */

 64 bits */

 64 bits */

 64 bits */

 64 bits */

 64 bits */

 64 bits */

 Offsets for EDMA CC global registers */

 8 registers */

 8 registers (4 on OMAP-L1xx) */

 64 bits */

 64 bits */

 4 x 64 bits*/

 4 registers */

 2 x 16 registers */

 2 registers */

 global channel registers */

 4 shadow regions */

 PaRAM entries */

 64 registers */

 CCCFG register */

 bits 0-2 */

 bits 4-6 */

 bits 12-14 */

 bits 16-18 */

 bits 20-21 */

 CCSTAT register */

/*

 * Max of 20 segments per channel to conserve PaRAM slots

 * Also note that MAX_NR_SG should be atleast the no.of periods

 * that are required for ASoC, otherwise DMA prep calls will

 * fail. Today davinci-pcm is the only user of this driver and

 * requires atleast 17 slots, so we setup the default to 20.

 for edma_alloc_channel() */

 for edma_alloc_slot() */

/*

 * 64bit array registers are split into two 32bit registers:

 * reg0: channel/event 0-31

 * reg1: channel/event 32-63

 *

 * bit 5 in the channel number tells the array index (0/1)

 * bit 0-4 (0x1f) is the bit offset within the register

 PaRAM slots are laid out like this */

 fields in edmacc_param.opt */

	/*

	 * The following 4 elements are used for residue accounting.

	 *

	 * - processed_stat: the number of SG elements we have traversed

	 * so far to cover accounting. This is updated directly to processed

	 * during edma_callback and is always <= processed, because processed

	 * refers to the number of pending transfer (programmed to EDMA

	 * controller), where as processed_stat tracks number of transfers

	 * accounted for so far.

	 *

	 * - residue: The amount of bytes we have left to transfer for this desc

	 *

	 * - residue_stat: The residue in bytes of data we have covered

	 * so far for accounting. This is updated directly to residue

	 * during callbacks to keep it current.

	 *

	 * - sg_len: Tracks the length of the current intermediate transfer,

	 * this is required to update the residue during intermediate transfer

	 * completion callback.

 eDMA3 resource information */

	/*

	 * The slot_inuse bit for each PaRAM slot is clear unless the slot is

	 * in use by Linux or if it is allocated to be used by DSP.

	/*

	 * For tracking reserved channels used by DSP.

	 * If the bit is cleared, the channel is allocated to be used by DSP

	 * and Linux must not touch it.

 dummy param set used to (re)initialize parameter RAM slots */

/*

 * paRAM slot management functions

/**

 * edma_alloc_slot - allocate DMA parameter RAM

 * @ecc: pointer to edma_cc struct

 * @slot: specific slot to allocate; negative for "any unused slot"

 *

 * This allocates a parameter RAM slot, initializing it to hold a

 * dummy transfer.  Slots allocated using this routine have not been

 * mapped to a hardware DMA channel, and will normally be used by

 * linking to them from a slot associated with a DMA channel.

 *

 * Normal use is to pass EDMA_SLOT_ANY as the @slot, but specific

 * slots may be allocated on behalf of DSP firmware.

 *

 * Returns the number of the slot, else negative errno.

 Requesting entry paRAM slot for a HW triggered channel. */

/**

 * edma_link - link one parameter RAM slot to another

 * @ecc: pointer to edma_cc struct

 * @from: parameter RAM slot originating the link

 * @to: parameter RAM slot which is the link target

 *

 * The originating slot should not be part of any active DMA transfer.

/**

 * edma_get_position - returns the current transfer point

 * @ecc: pointer to edma_cc struct

 * @slot: parameter RAM slot being examined

 * @dst:  true selects the dest position, false the source

 *

 * Returns the position of the current active slot

/*

 * Channels with event associations will be triggered by their hardware

 * events, and channels without such associations will be triggered by

 * software.  (At this writing there is no interface for using software

 * triggers except with channels that don't support hardware triggers.)

 EDMA channels without event association */

 EDMA channel with event association */

 Clear any pending event or error */

 Clear any SER */

 clear possibly pending completion interrupt */

	/* REVISIT:  consider guarding against inappropriate event

	 * chaining by overwriting with dummy_paramset.

/*

 * Temporarily disable EDMA hardware events on the specified channel,

 * preventing them from triggering new transfers

 Re-enable EDMA hardware events on the specified channel.  */

 Clear the corresponding EMR bits */

 Clear any SER */

 Move channel to a specific event queue */

 default to low priority queue */

 ensure access through shadow region 0 */

 ensure no events are pending */

 ensure no events are pending */

 REVISIT should probably take out of shadow region 0 */

 Dispatch a queued descriptor to the controller (caller holds lock) */

 Setup is needed for the first transfer */

 Find out how many left */

 Write descriptor PaRAM set(s) */

 Link to the previous slot if not the last set */

	/*

	 * If this is either the last set in a set of SG-list transactions

	 * then setup a link to the dummy slot, this results in all future

	 * events being absorbed and that's OK because we're done

		/*

		 * This happens due to setup times between intermediate

		 * transfers in long SG lists which have to be broken up into

		 * transfers of MAX_NR_SG

	/*

	 * Stop DMA activity: we assume the callback will not be called

	 * after edma_dma() returns (even if it does, it will see

	 * echan->edesc is NULL and exit.)

 Move the cyclic channel back to default queue */

/*

 * A PaRAM set configuration abstraction used by other modes

 * @chan: Channel who's PaRAM set we're configuring

 * @pset: PaRAM set to initialize and setup.

 * @src_addr: Source address of the DMA

 * @dst_addr: Destination address of the DMA

 * @burst: In units of dev_width, how much to send

 * @dev_width: How much is the dev_width

 * @dma_length: Total length of the DMA transfer

 * @direction: Direction of the transfer

 src/dst_maxburst == 0 is the same case as src/dst_maxburst == 1 */

	/*

	 * If the maxburst is equal to the fifo width, use

	 * A-synced transfers. This allows for large contiguous

	 * buffer transfers using only one PaRAM set.

		/*

		 * For the A-sync case, bcnt and ccnt are the remainder

		 * and quotient respectively of the division of:

		 * (dma_length / acnt) by (SZ_64K -1). This is so

		 * that in case bcnt over flows, we have ccnt to use.

		 * Note: In A-sync tranfer only, bcntrld is used, but it

		 * only applies for sg_dma_len(sg) >= SZ_64K.

		 * In this case, the best way adopted is- bccnt for the

		 * first frame will be the remainder below. Then for

		 * every successive frame, bcnt will be SZ_64K-1. This

		 * is assured as bcntrld = 0xffff in end of function.

		/*

		 * If bcnt is non-zero, we have a remainder and hence an

		 * extra frame to transfer, so increment ccnt.

		/*

		 * If maxburst is greater than the fifo address_width,

		 * use AB-synced transfers where A count is the fifo

		 * address_width and B count is the maxburst. In this

		 * case, we are limited to transfers of C count frames

		 * of (address_width * maxburst) where C count is limited

		 * to SZ_64K-1. This places an upper bound on the length

		 * of an SG segment that can be handled.

 Configure A or AB synchronized transfers */

	/*

	 * Only time when (bcntrld) auto reload is required is for

	 * A-sync case, and in this case, a requirement of reload value

	 * of SZ_64K-1 only is assured. 'link' is initially set to NULL

	 * and then later will be populated by edma_execute.

 Allocate a PaRAM slot, if needed */

 Configure PaRAM sets for each SG */

 Get address for each SG */

 Enable completion interrupt */

			/*

			 * Enable early completion interrupt for the

			 * intermediateset. In this case the driver will be

			 * notified when the paRAM set is submitted to TC. This

			 * will allow more time to set up the next set of slots.

 Align the array size (acnt block) with the transfer properties */

		/*

		 * Transfer size less than 64K can be handled with one paRAM

		 * slot and with one burst.

		 * ACNT = length

		/*

		 * Transfer size bigger than 64K will be handled with maximum of

		 * two paRAM slots.

		 * slot1: (full_length / 32767) times 32767 bytes bursts.

		 *	  ACNT = 32767, length1: (full_length / 32767) * 32767

		 * slot2: the remaining amount of data after slot1.

		 *	  ACNT = full_length - length1, length2 = ACNT

		 *

		 * When the full_length is multibple of 32767 one slot can be

		 * used to complete the transfer.

 One slot is enough for lengths multiple of (SZ_32K -1) */

 Enable transfer complete interrupt if requested */

 Enable transfer complete chaining for the first slot */

 Enable transfer complete interrupt if requested */

 Slave mode is not supported */

 Enable transfer complete interrupt if requested */

	/*

	 * Cyclic DMA users such as audio cannot tolerate delays introduced

	 * by cases where the number of periods is more than the maximum

	 * number of SGs the EDMA driver can handle at a time. For DMA types

	 * such as Slave SGs, such delays are tolerable and synchronized,

	 * but the synchronization is difficult to achieve with Cyclic and

	 * cannot be guaranteed, so we error out early.

		/*

		 * If the burst and period sizes are the same, we can put

		 * the full buffer into a single period and activate

		 * intermediate interrupts. This will produce interrupts

		 * after each burst, which is also after each desired period.

 Allocate a PaRAM slot, if needed */

		/*

		 * Enable period interrupt only if it is requested

 Also enable intermediate interrupts if necessary */

 Place the cyclic channel to highest priority queue */

 Update statistics for tx_status */

 eDMA interrupt handler */

 Clear the corresponding IPR bits */

	/*

	 * Issue later based on missed flag which will be sure

	 * to happen as:

	 * (1) we finished transmitting an intermediate slot and

	 *     edma_execute is coming up.

	 * (2) or we finished current transfer and issue will

	 *     call edma_execute.

	 *

	 * Important note: issuing can be dangerous here and

	 * lead to some nasty recursion when we are in a NULL

	 * slot. So we avoid doing so and set the missed flag.

		/*

		 * The slot is already programmed but the event got

		 * missed, so its safe to issue it here.

 eDMA error interrupt handler */

		/*

		 * The registers indicate no pending error event but the irq

		 * handler has been called.

		 * Ask eDMA to re-evaluate the error registers.

 Event missed register(s) */

 Clear the corresponding EMR bits */

 Clear any SER */

 Not reported, just clear the interrupt reason. */

 Not reported, just clear the interrupt reason. */

 Alloc channel resources */

 memcpy channel */

 Set up channel -> slot mapping for the entry slot */

 Free channel resources */

 Terminate transfers */

 Free EDMA PaRAM slots */

 Set entry slot to the dummy slot */

 Free EDMA channel */

 Send pending descriptor to hardware */

/*

 * This limit exists to avoid a possible infinite loop when waiting for proof

 * that a particular transfer is completed. This limit can be hit if there

 * are large bursts to/from slow devices or the CPU is never able to catch

 * the DMA hardware idle. On an AM335x transfering 48 bytes from the UART

 * RX-FIFO, as many as 55 loops have been seen.

	/*

	 * We always read the dst/src position from the first RamPar

	 * pset. That's the one which is active now.

	/*

	 * "pos" may represent a transfer request that is still being

	 * processed by the EDMACC or EDMATC. We will busy wait until

	 * any one of the situations occurs:

	 *   1. while and event is pending for the channel

	 *   2. a position updated

	 *   3. we hit the loop limit

	/*

	 * Cyclic is simple. Just subtract pset[0].addr from pos.

	 *

	 * We never update edesc->residue in the cyclic case, so we

	 * can tell the remaining room to the end of the circular

	 * buffer.

	/*

	 * If the position is 0, then EDMA loaded the closing dummy slot, the

	 * transfer is completed

	/*

	 * For SG operation we catch up with the last processed

	 * status.

		/*

		 * If we are inside this pset address range, we know

		 * this is the active one. Get the current delta and

		 * stop walking the psets.

 Otherwise mark it done and update residue_stat. */

 Check request completion status */

 Provide a dummy dma_tx_state for completion checking */

	/*

	 * Mark the cookie completed if the residue is 0 for non cyclic

	 * transfers

 CIDX: 16bit signed */

 Decode the eDMA3 configuration from CCCFG register */

 Nothing need to be done if queue priority is provided */

	/*

	 * Configure TC/queue priority as follows:

	 * Q0 - priority 0

	 * Q1 - priority 1

	 * Q2 - priority 2

	 * ...

	 * The meaning of priority numbers: 0 highest priority, 7 lowest

	 * priority. So Q0 is the highest priority queue and the last queue has

	 * the lowest priority.

 Default queue has the lowest priority */

 Invalidate last entry for the other user of this mess */

 Get the list of channels allocated to be used for memcpy */

 The channel is going to be used as HW synchronized */

 When booting with DT the pdev->id is -1 */

 Get eDMA3 configuration from IP */

 Allocate memory based on the information we got from the IP */

 Mark all channels available initially */

 Set the reserved slots in inuse list */

 Clear channels not usable for Linux */

 Reset only unused - not reserved - paRAM slots */

 See if we have optional dma-channel-mask array */

 Event queue priority mapping */

 Init the dma device and channels */

 Do not touch reserved channels */

 Assign all channels to the default queue */

 Set entry slot to the dummy slot */

 re initialize dummy slot to dummy param set */

 Event queue priority mapping */

 ensure access through shadow region 0 */

 Set up channel -> slot mapping for the entry slot */

 The channel is going to be used as HW synchronized */

 SPDX-License-Identifier: GPL-2.0

/*

 *  Copyright (C) 2019 Texas Instruments Incorporated - http://www.ti.com

 *  Author: Peter Ujfalusi <peter.ujfalusi@ti.com>

 Exported register access functions */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  Copyright (C) 2015 Texas Instruments Incorporated - http://www.ti.com

 *  Author: Peter Ujfalusi <peter.ujfalusi@ti.com>

 Crossbar on AM335x/AM437x family */

 maximum number of events to select in xbar */

 number of DMA requests on eDMA */

	/*

	 * TPCC_EVT_MUX_60_63 register layout is different than the

	 * rest, in the sense, that event 63 is mapped to lowest byte

	 * and event 60 is mapped to highest, handle it separately.

 The of_node_put() will be done in the core for the node */

 Reset the crossbar */

 Crossbar on DRA7xx family */

 Value to rest the crossbar lines */

 number of DMA requests connected to XBAR */

 number of DMA requests forwarded to DMA */

 The of_node_put() will be done in the core for the node */

 Reset the crossbar */

 Restore the defaults for the crossbar */

 SPDX-License-Identifier: GPL-2.0

/*

 *  Copyright (C) 2019 Texas Instruments Incorporated - http://www.ti.com

 *  Author: Peter Ujfalusi <peter.ujfalusi@ti.com>

 PSI-L source thread IDs, used for RX (DMA_DEV_TO_MEM) */

 SA2UL */

 PRU_ICSSG0 */

 PRU_ICSSG1 */

 PRU_ICSSG2 */

 PDMA0 - McASPs */

 PDMA1 - SPI0-4 */

 PDMA1 - USART0-2 */

 CPSW0 */

 MCU_PDMA0 - ADCs */

 MCU_PDMA1 - MCU_SPI0-2 */

 MCU_PDMA1 - MCU_USART0 */

 PSI-L destination thread IDs, used for TX (DMA_MEM_TO_DEV) */

 SA2UL */

 PRU_ICSSG0 */

 PRU_ICSSG1 */

 PRU_ICSSG2 */

 CPSW0 */

 SPDX-License-Identifier: GPL-2.0

/*

 *  Copyright (C) 2020 Texas Instruments Incorporated - https://www.ti.com

 *  Author: Peter Ujfalusi <peter.ujfalusi@ti.com>

 PSI-L source thread IDs, used for RX (DMA_DEV_TO_MEM) */

 SAUL */

 ICSS_G0 */

 ICSS_G1 */

 PDMA_MAIN0 - SPI0-3 */

 PDMA_MAIN0 - USART0-1 */

 PDMA_MAIN1 - SPI4 */

 PDMA_MAIN1 - USART2-6 */

 PDMA_MAIN1 - ADCs */

 CPSW2 */

 PSI-L destination thread IDs, used for TX (DMA_MEM_TO_DEV) */

 SAUL */

 ICSS_G0 */

 ICSS_G1 */

 CPSW2 */

 SPDX-License-Identifier: GPL-2.0

/*

 *  Copyright (C) 2019 Texas Instruments Incorporated - http://www.ti.com

 *  Author: Peter Ujfalusi <peter.ujfalusi@ti.com>

 sentinel */ }

 check in destination thread map */

 SPDX-License-Identifier: GPL-2.0

/*

 *  Copyright (C) 2019 Texas Instruments Incorporated - http://www.ti.com

 *  Author: Peter Ujfalusi <peter.ujfalusi@ti.com>

 PSI-L source thread IDs, used for RX (DMA_DEV_TO_MEM) */

 SA2UL */

 PRU_ICSSG0 */

 PRU_ICSSG1 */

 PDMA6 (PSIL_PDMA_MCASP_G0) - McASP0-2 */

 PDMA7 (PSIL_PDMA_MCASP_G1) - McASP3-11 */

 PDMA8 (PDMA_MISC_G0) - SPI0-1 */

 PDMA9 (PDMA_MISC_G1) - SPI2-3 */

 PDMA10 (PDMA_MISC_G2) - SPI4-5 */

 PDMA11 (PDMA_MISC_G3) */

 PDMA13 (PDMA_USART_G0) - UART0-1 */

 PDMA14 (PDMA_USART_G1) - UART2-3 */

 PDMA15 (PDMA_USART_G2) - UART4-9 */

 CSI2RX */

 CPSW9 */

 CPSW0 */

 MCU_PDMA0 (MCU_PDMA_MISC_G0) - SPI0 */

 MCU_PDMA1 (MCU_PDMA_MISC_G1) - SPI1-2 */

 MCU_PDMA2 (MCU_PDMA_MISC_G2) - UART0 */

 MCU_PDMA_ADC - ADC0-1 */

 SA2UL */

 PSI-L destination thread IDs, used for TX (DMA_MEM_TO_DEV) */

 SA2UL */

 PRU_ICSSG0 */

 PRU_ICSSG1 */

 CPSW9 */

 CPSW0 */

 SA2UL */

 SPDX-License-Identifier: GPL-2.0

/*

 * K3 NAVSS DMA glue interface

 *

 * Copyright (C) 2019 Texas Instruments Incorporated - http://www.ti.com

 *

 The struct containing the device is devm managed */

 get psil endpoint config */

 parse of udmap channel */

 request and cfg UDMAP TX channel */

 prepare the channel device as coherent */

 request and cfg rings */

 Set the dma_dev for the rings to be configured */

 Set the ASEL value for DMA rings of PKTDMA */

 request and cfg psi-l */

	/*

	 * TXQ reset need to be special way as it is input for udma and its

	 * state cached by udma, so:

	 * 1) save TXQ occ

	 * 2) clean up TXQ and call callback .cleanup() for each desc

	 * 3) reset TXQ in a special way

 reset TXCQ as it is not input for udma - expected to be empty */

	/*

	 * TODO: we can't support rxcq_qnum/RCHAN[a]_RCQ cfg with current sysfw

	 * and udmax impl, so just configure it to invalid value.

	 * req.rxcq_qnum = k3_ringacc_get_ring_id(rx_chn->flows[0].ringrx);

 Default flow + extra ones */

 request and cfg rings */

 Set the dma_dev for the rings to be configured */

 Set the ASEL value for DMA rings of PKTDMA */

 default rflow */

 not a GP rflows */

 Allocate range of GP rflows */

 parse of udmap channel */

 request and cfg UDMAP RX channel */

 prepare the channel device as coherent */

 Use RX channel id as flow id: target dev can't generate flow_id */

 request and cfg psi-l */

 init default RX flow only if flow_num = 1 */

	/*

	 * Remote RX channel is under control of Remote CPU core, so

	 * Linux can only request and manipulate by dedicated RX flows

 parse of udmap channel */

 prepare the channel device as coherent */

 reset RXCQ as it is not input for udma - expected to be empty */

 Skip RX FDQ in case one FDQ is used for the set of flows */

	/*

	 * RX FDQ reset need to be special way as it is input for udma and its

	 * state cached by udma, so:

	 * 1) save RX FDQ occ

	 * 2) clean up RX FDQ and call callback .cleanup() for each desc

	 * 3) reset RX FDQ in a special way

 SPDX-License-Identifier: GPL-2.0

/*

 *  Copyright (C) 2019 Texas Instruments Incorporated - http://www.ti.com

 *  Author: Peter Ujfalusi <peter.ujfalusi@ti.com>

 PSI-L source thread IDs, used for RX (DMA_DEV_TO_MEM) */

 PDMA_MCASP - McASP0-2 */

 PDMA_SPI_G0 - SPI0-3 */

 PDMA_SPI_G1 - SPI4-7 */

 PDMA_USART_G0 - UART0-1 */

 PDMA_USART_G1 - UART2-3 */

 PDMA_USART_G2 - UART4-9 */

 CPSW5 */

 CPSW0 */

 MCU_PDMA_MISC_G0 - SPI0 */

 MCU_PDMA_MISC_G1 - SPI1-2 */

 MCU_PDMA_MISC_G2 - UART0 */

 MCU_PDMA_ADC - ADC0-1 */

 SA2UL */

 PSI-L destination thread IDs, used for TX (DMA_MEM_TO_DEV) */

 CPSW5 */

 CPSW0 */

 SA2UL */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2008

 * Guennadi Liakhovetski, DENX Software Engineering, <lg@denx.de>

 *

 * Copyright (C) 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.

/*

 * There can be only one, we could allocate it dynamically, but then we'd have

 * to add an extra parameter to some functions, and use something as ugly as

 *	struct ipu *ipu = to_ipu(to_idmac(ichan->dma_chan.device));

 * in the ISR

/*****************************************************************************

 * IPU / IC common functions

 generic data */

 generic data */

 Enable direct write to memory by the Camera Sensor Interface */

 Called under spin_lock_irqsave(&ipu_data.lock) */

 Word 0 */

 Word 1 */

 Word 0 */

 Word 1 */

Represents 8-bit Generic data */

 SAT = use 32-bit access */

Represents 32-bit Generic data */

 SAT = use 32-bit access */

 SAT = 32-bit access */

 Red bit offset */

 Green bit offset */

 Blue bit offset */

 Alpha bit offset */

 Red bit width - 1 */

 Green bit width - 1 */

 Blue bit width - 1 */

 24 BPP & RGB PFS */

 SAT = 32-bit access */

 Red bit offset */

 Green bit offset */

 Blue bit offset */

 Alpha bit offset */

 Red bit width - 1 */

 Green bit width - 1 */

 Blue bit width - 1 */

 24 BPP & RGB PFS */

 SAT = 32-bit access */

 Red bit offset */

 Green bit offset */

 Blue bit offset */

 Alpha bit offset */

 Red bit width - 1 */

 Green bit width - 1 */

 Blue bit width - 1 */

 SAT = 32-bit access */

 Red bit offset */

 Green bit offset */

 Blue bit offset */

 Alpha bit offset */

 Red bit width - 1 */

 Green bit width - 1 */

 Blue bit width - 1 */

 Alpha bit width - 1 */

 SAT = 32-bit access */

 Red bit offset */

 Green bit offset */

 Blue bit offset */

 Alpha bit offset */

 Red bit width - 1 */

 Green bit width - 1 */

 Blue bit width - 1 */

 Alpha bit width - 1 */

 SAT = 32-bit access */

 SAT = 32-bit access */

 SAT = 32-bit access */

 SAT = 32-bit access */

 set to word 0 */

 increment to next row */

 Cannot downsize more than 8:1 */

 compute downsizing coefficient */

	/*

	 * compute resizing coefficient using the following formula:

	 * resize_coeff = M*(SI -1)/(SO - 1)

	 * where M = 2^13, SI - input size, SO - output size

 Setup vertical resizing */

 Setup horizontal resizing */

 Setup color space conversion */

	/*

	 * Colourspace conversion unsupported yet - see _init_csc() in

	 * Freescale sources

 Channel Parameter Memory */

/**

 * ipu_enable_channel() - enable an IPU channel.

 * @idmac:	IPU DMAC context.

 * @ichan:	IDMAC channel.

 * @return:	0 on success or negative error code on failure.

 Reset to buffer 0 */

/**

 * ipu_init_channel_buffer() - initialize a buffer for logical IPU channel.

 * @ichan:	IDMAC channel.

 * @pixel_fmt:	pixel format of buffer. Pixel format is a FOURCC ASCII code.

 * @width:	width of buffer in pixels.

 * @height:	height of buffer in pixels.

 * @stride:	stride length of buffer in pixels.

 * @rot_mode:	rotation mode of buffer. A rotation setting other than

 *		IPU_ROTATE_VERT_FLIP should only be used for input buffers of

 *		rotation channels.

 * @phyaddr_0:	buffer 0 physical address.

 * @phyaddr_1:	buffer 1 physical address. Setting this to a value other than

 *		NULL enables double buffering mode.

 * @return:	0 on success or negative error code on failure.

 IC channel's stride must be a multiple of 8 pixels */

 Build parameter memory data for DMA channel */

/**

 * ipu_select_buffer() - mark a channel's buffer as ready.

 * @channel:	channel ID.

 * @buffer_n:	buffer number to mark ready.

 No locking - this is a write-one-to-set register, cleared by IPU */

 Mark buffer 0 as ready. */

 Mark buffer 1 as ready. */

/**

 * ipu_update_channel_buffer() - update physical address of a channel buffer.

 * @ichan:	IDMAC channel.

 * @buffer_n:	buffer number to update.

 *		0 or 1 are the only valid values.

 * @phyaddr:	buffer physical address.

 Called under spin_lock(_irqsave)(&ichan->lock) */

 44.3.3.1.9 - Row Number 1 (WORD1, offset 0) */

 Check if double-buffering is already enabled */

 44.3.3.1.9 - Row Number 1 (WORD1, offset 1) */

 Called under spin_lock_irqsave(&ichan->lock) */

	/*

	 * On first invocation this shouldn't be necessary, the call to

	 * ipu_init_channel_buffer() above will set addresses for us, so we

	 * could make it conditional on status >= IPU_CHANNEL_ENABLED, but

	 * doing it again shouldn't hurt either.

 Called under spin_lock_irqsave(&ichan->lock) */

 Sanity check */

 The descriptor doesn't belong to client */

		/*

		 * Initial buffer assignment - the first two sg-entries from

		 * the descriptor will end up in the IDMAC buffers

 ipu->lock can be taken under ichan->lock, but not v.v. */

 submit_buffers() atomically verifies and fills empty sg slots */

 Called with ichan->chan_mutex held */

 No interrupts, just disable the tasklet for a moment */

/**

 * ipu_init_channel() - initialize an IPU channel.

 * @idmac:	IPU DMAC context.

 * @ichan:	pointer to the channel object.

 * @return      0 on success or negative error code on failure.

 Enable IPU sub module */

/**

 * ipu_uninit_channel() - uninitialize an IPU channel.

 * @idmac:	IPU DMAC context.

 * @ichan:	pointer to the channel object.

 Reset the double buffer */

/**

 * ipu_disable_channel() - disable an IPU channel.

 * @idmac:		IPU DMAC context.

 * @ichan:		channel object pointer.

 * @wait_for_stop:	flag to set whether to wait for channel end of frame or

 *			return immediately.

 * @return:		0 on success or negative error code on failure.

 This waiting always fails. Related to spurious irq problem */

 SDC BG and FG must be disabled before DMA is disabled */

 Disable IC task */

 Disable DMA channel(s) */

 next sg-element in this list */

 No more descriptors on the queue */

 Fetch next descriptor */

/*

 * We have several possibilities here:

 * current BUF		next BUF

 *

 * not last sg		next not last sg

 * not last sg		next last sg

 * last sg		first sg from next descriptor

 * last sg		NULL

 *

 * Besides, the descriptor queue might be empty or not. We process all these

 * cases carefully.

 Next transfer descriptor */

 IDMAC has cleared the respective BUFx_RDY bit, we manage the buffer */

		/*

		 * Doing this

		 * ichan->sg[0] = ichan->sg[1] = NULL;

		 * you can force channel re-enable on the next tx_submit(), but

		 * this is dirty - think about descriptors with multiple

		 * sg elements.

 Other interrupts do not interfere with this channel */

	/*

	 * active_buffer is a software flag, it shows which buffer we are

	 * currently expecting back from the hardware, IDMAC should be

	 * processing the other buffer already

 Find the descriptor of sgnext */

	/*

	 * if sgnext == NULL sg must be the last element in a scatterlist and

	 * queue must be empty

 Continue to check for complete descriptor */

 Calculate and submit the next sg element */

		/*

		 * Last element in scatterlist done, remove from the queue,

		 * _init for debugging

 Flip the active buffer - even if update above failed */

 Allocate and initialise a transfer descriptor. */

 We only can handle these three channels so far */

 Re-select the current buffer and re-activate the channel */

 This is not always needed, but doesn't hurt either */

	/*

	 * Might need to perform some parts of initialisation from

	 * ipu_enable_channel(), but not all, we do not want to reset to buffer

	 * 0, don't need to set priority again either, but re-enabling the task

	 * and the channel might be a good idea.

 Return all descriptors into "prepared" state */

 ichan->queue is modified in ISR, have to spinlock */

 Descriptor was prepared, but not submitted */

 dmaengine.c now guarantees to only offer free channels */

	/*

	 * Important to first disable the channel, because maybe someone

	 * used it before us, e.g., the bootloader

 Compulsory common fields */

 Compulsory for DMA_SLAVE fields */

/*****************************************************************************

 * IPU common probe / remove

 Remap IPU common registers */

 Remap Image Converter and Image DMA Controller registers */

 Get IPU clock */

 Make sure IPU HSP clock is running */

 Disable all interrupts */

 Initialize DMA engine */

/*

 * We need two MEM resources - with IPU-common and Image Converter registers,

 * including PF_CONF and IDMAC_* registers, and two IRQs - function and error

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2008

 * Guennadi Liakhovetski, DENX Software Engineering, <lg@denx.de>

/*

 * Register read / write - shall be inlined by the compiler

/*

 * IPU IRQ chip driver

 3 groups of functional interrupts */

 2 groups of error interrupts */

 Protects allocations from the above array of maps */

 Protects register accesses and individual mappings */

/**

 * ipu_irq_status() - returns the current interrupt status of the specified IRQ.

 * @irq:	interrupt line to get status for.

 * @return:	true if the interrupt is pending/asserted or false if the

 *		interrupt is not pending.

/**

 * ipu_irq_map() - map an IPU interrupt source to an IRQ number

 * @source:	interrupt source bit position (see below)

 * @return:	mapped IRQ number or negative error code

 *

 * The source parameter has to be explained further. On i.MX31 IPU has 137 IRQ

 * sources, they are broken down in 5 32-bit registers, like 32, 32, 24, 32, 17.

 * However, the source argument of this function is not the sequence number of

 * the possible IRQ, but rather its bit position. So, first interrupt in fourth

 * register has source number 96, and not 88. This makes calculations easier,

 * and also provides forward compatibility with any future IPU implementations

 * with any interrupt bit assignments.

/**

 * ipu_irq_unmap() - unmap an IPU interrupt source

 * @source:	interrupt source bit position (see ipu_irq_map())

 * @return:	0 or negative error code

 Chained IRQ handler for IPU function and error interrupt */

		/*

		 * Don't think we have to clear all interrupts here, they will

		 * be acked by ->handle_irq() (handle_level_irq). However, we

		 * might want to clear unhandled interrupts after the loop...

 Install the IRQ handler */

/*

 * Broadcom specific AMBA

 * PCI Core in hostmode

 *

 * Copyright 2005 - 2011, Broadcom Corporation

 * Copyright 2006, 2007, Michael Buesch <m@bues.ch>

 * Copyright 2011, 2012, Hauke Mehrtens <hauke@hauke-m.de>

 *

 * Licensed under the GNU/GPL. See COPYING for details.

/* Probe a 32bit value on the bus and catch bus exceptions.

 * Returns nonzero on a bus exception.

 Assume one-hot slot wiring */

	/* Issue config commands only when the data link is up (atleast

	 * one external pcie device is present).

 Type 0 transaction */

 Slide the PCI window to the appropriate slot */

 Calculate the address */

 we support only two functions on device 0 */

		/* accesses to config registers with offsets >= 256

		 * requires indirect access.

 we support only two functions on device 0 */

		/* accesses to config registers with offsets >= 256

		 * requires indirect access.

		/* accesses to config registers with offsets >= 256

		 * requires indirect access.

 return cap_offset if requested capability exists in the PCI config space */

 check for Header type 0 */

 check if the capability pointer field exists */

 check if the capability pointer is 0x00 */

	/* loop thr'u the capability list and see if the requested capabilty

 found the caller requested capability */

 copy the cpability data excluding cap ID and next ptr */

/* If the root port is capable of returning Config Request

 * Retry Status (CRS) Completion Status to software then

 * enable the feature.

 Enable CRS software visibility */

		/* Initiate a configuration request to read the vendor id

		 * field of the device function's config space header after

		 * 100 ms wait time from the end of Reset. If the device is

		 * not done with its internal initialization, it must at

		 * least return a completion TLP, with a completion status

		 * of "Configuration Request Retry Status (CRS)". The root

		 * complex must complete the request to the host by returning

		 * a read-data value of 0001h for the Vendor ID field and

		 * all 1s for any additional bytes included in the request.

		 * Poll using the config reads for max wait time of 1 sec or

		 * until we receive the successful completion status. Repeat

		 * the procedure for all the devices.

 Reset RC */

	/* 64 MB I/O access window. On 4716, use

	 * sbtopcie0 to access the device registers. We

	 * can't use address match 2 (1 GB window) region

	 * as mips can't generate 64-bit address on the

	 * backplane.

 64 MB configuration access window */

 1 GB memory access window */

	/* As per PCI Express Base Spec 1.1 we need to wait for

	 * at least 100 ms from the end of a reset (cold/warm/hot)

	 * before issuing configuration requests to PCI Express

	 * devices.

 Max payload size of 512 */

 MRRS 512 */

 Enable PCI bridge BAR0 memory & master access */

 Enable PCI interrupts */

	/* Ok, ready to run, register it to the system.

	 * The following needs change, if we want to port hostmode

	/* Give some time to the PCI controller to configure itself with the new

 Early PCI fixup for a device on the PCI-core bridge. */

 This is not a device on the PCI-core bridge. */

 Enable PCI bridge bus mastering and memory space */

 Enable PCI bridge BAR1 prefetch and burst */

 Early PCI fixup for all PCI-cores to set the correct memory address. */

 This is not a device on the PCI-core bridge. */

/* This function is called when doing a pci_enable_device().

 This is not a device on the PCI-core bridge. */

 Fix up interrupt lines */

 PCI device IRQ mapping. */

 This is not a device on the PCI-core bridge. */

/*

 * Broadcom specific AMBA

 * GBIT MAC COMMON Core

 *

 * Licensed under the GNU/GPL. See COPYING for details.

/*

 * Broadcom specific AMBA

 * PCI Core

 *

 * Copyright 2005, 2011, Broadcom Corporation

 * Copyright 2006, 2007, Michael Buesch <m@bues.ch>

 * Copyright 2011, 2012, Hauke Mehrtens <hauke@hauke-m.de>

 *

 * Licensed under the GNU/GPL. See COPYING for details.

/**************************************************

 * R/W ops.

 enable mdio access to SERDES */

 Wait for the device to complete the transaction */

 enable mdio access to SERDES */

 Wait for the device to complete the transaction */

/**************************************************

 * Early init.

/*

 * Apply some early fixes required before accessing SPROM.

 * See also si_pci_fixcfg.

/**************************************************

 * Workarounds.

 Fix MISC config to allow coming out of L2/L3-Ready state w/o PRST */

 Needs to happen when coming out of 'standby'/'hibernate' */

/**************************************************

 * Init.

/*

 * Broadcom specific AMBA

 * System on Chip (SoC) Host

 *

 * Licensed under the GNU/GPL. See COPYING for details.

 CONFIG_BCMA_BLOCKIO */

	/* iomap only first core. We have to read some register on this core

	 * to scan the bus.

 Host specific */

 Initialize struct, detect chip */

 Scan bus and initialize it */

 Alloc */

 Map MMIO */

 Host specific */

 Initialize struct, detect chip */

 Register */

 CONFIG_OF */

/*

 * Broadcom specific AMBA

 * Bus scanning

 *

 * Licensed under the GNU/GPL. See COPYING for details.

 search manufacturer specific names */

 get CIs */

 parse CIs */

 check if component is a core at all */

 Some specific cores don't need wrappers */

 Not used yet: case BCMA_CORE_OOB_ROUTER: */

 get & parse master ports */

	/* First Slave Address Descriptor should be port 0:

	 * the main register space for the core

 Try again to see if it is a bridge */

 get & parse slave ports */

 no more entries for port _i_ */

				/* pr_debug("erom: slave port %d "

 get & parse master wrappers */

 no more entries for port _i_ */

				/* pr_debug("erom: master wrapper %d "

 get & parse slave wrappers */

 no more entries for port _i_ */

				/* pr_debug("erom: master wrapper %d "

 Skip if bus was already scanned (e.g. during early register) */

/*

 * Broadcom specific AMBA

 * ChipCommon core driver

 *

 * Copyright 2005, Broadcom Corporation

 * Copyright 2006, 2007, Michael Buesch <m@bues.ch>

 * Copyright 2012, Hauke Mehrtens <hauke@hauke-m.de>

 *

 * Licensed under the GNU/GPL. See COPYING for details.

			/* 53573B0 and 53573B1 have bugged PMU watchdog. It can

			 * be enabled but timer can't be bumped. Use CC one

			 * instead.

			/* 4706 CC and PMU watchdogs are clocked at 1/4 of ALP

			 * clock

 based on 32KHz ILP clock */

 Set chip watchdog reset timer to fire in 'ticks' backplane cycles */

 instant NMI */

/*

 * If the bit is set to 0, chipcommon controlls this GPIO,

 * if the bit is set to 1, it is used by some part of the chip and not our code.

 Turn off UART clock before switching clocksource. */

 Set the override bit so we don't divide it */

 Re-enable the UART clock. */

 Determine the registers of the UARTs */

 CONFIG_BCMA_DRIVER_MIPS */

/*

 * Broadcom specific AMBA

 * PCIe Gen 2 Core

 *

 * Copyright 2014, Broadcom Corporation

 * Copyright 2014, Rafał Miłecki <zajec5@gmail.com>

 *

 * Licensed under the GNU/GPL. See COPYING for details.

/**************************************************

 * R/W ops.

/**************************************************

 * Init.

 restore back to default */

 flush */

 LTR0 */

 LTR1 */

 LTR2 */

 force the right LTR values */

		/* TODO:

		 *si_core_wrapperreg(pcie2, 3, 0x60, 0x8080, 0);

 enable the LTR */

 set the LTR state to be active */

 set the LTR state to be sleep */

 TODO */

/**************************************************

 * Runtime ops.

/*

 * Broadcom specific AMBA

 * ChipCommon NAND flash interface

 *

 * Licensed under the GNU/GPL. See COPYING for details.

 Initialize NAND flash access */

	/* Prepare platform device, but don't register it yet. It's too early,

/*

 * Broadcom specific AMBA

 * Broadcom MIPS32 74K core driver

 *

 * Copyright 2009, Broadcom Corporation

 * Copyright 2006, 2007, Michael Buesch <mb@bu3sch.de>

 * Copyright 2010, Bernhard Loos <bernhardloos@googlemail.com>

 * Copyright 2011, Hauke Mehrtens <hauke@hauke-m.de>

 *

 * Licensed under the GNU/GPL. See COPYING for details.

 The 47162a0 hangs when reading MIPS DMP registers registers */

 The 5357b0 hangs when reading USB20H DMP registers */

/* Get the MIPS IRQ assignment for a specified device.

 * If unassigned, 0 is returned.

 * If disabled, 5 is returned.

 * If not supported, 6 is returned.

 clear the old irq */

 assign the new one */

			/* backplane irq line is in use, find out who uses

			 * it and set user to irq 0

 Determine flash type this SoC boots from */

	/* Fixup the interrupts in 4716/4748 for i2s core (2010 Broadcom SDK)

	 * (IRQ flags > 7 are ignored when setting the interrupt masks)

/*

 * Broadcom specific AMBA

 * GPIO driver

 *

 * Copyright 2011, Broadcom Corporation

 * Copyright 2012, Hauke Mehrtens <hauke@hauke-m.de>

 *

 * Licensed under the GNU/GPL. See COPYING for details.

 clear pulldown */

 Set pullup */

 clear pullup */

 This will let us handle the parent IRQ in the driver */

	/*

	 * Register SoC GPIO devices with absolute GPIO pin base.

	 * On MIPS, we don't have Device Tree and we can't use relative (per chip)

	 * GPIO numbers.

	 * On some ARM devices, user space may want to access some system GPIO

	 * pins directly, which is easier to do with a predictable GPIO base.

/*

 * Broadcom specific AMBA

 * SPROM reading

 *

 * Copyright 2011, 2012, Hauke Mehrtens <hauke@hauke-m.de>

 *

 * Licensed under the GNU/GPL. See COPYING for details.

/**

 * bcma_arch_register_fallback_sprom - Registers a method providing a

 * fallback SPROM if no SPROM is found.

 *

 * @sprom_callback: The callback function.

 *

 * With this function the architecture implementation may register a

 * callback handler which fills the SPROM data structure. The fallback is

 * used for PCI based BCMA devices, where no valid SPROM can be found

 * in the shadow registers and to provide the SPROM for SoCs where BCMA is

 * to controll the system bus.

 *

 * This function is useful for weird architectures that have a half-assed

 * BCMA device hardwired to their PCI bus.

 *

 * This function is available for architecture code, only. So it is not

 * exported.

/**************************************************

 * R/W ops.

/**************************************************

 * Validation.

 Polynomial:   x^8 + x^7 + x^6 + x^4 + x^2 + 1   */

/**************************************************

 * SPROM extraction.

 If unset use 2dBm */

 Q5.2 Fractional part is stored in 0xC0 */

 Extract cores power info info */

 Extract the antenna gain values. */

/*

 * Indicates the presence of external SPROM.

 older chipcommon revisions use chip status register */

/*

 * Indicates that on-chip OTP memory is present and enabled.

 for these chips OTP is always available */

/*

 * Verify OTP is filled and determine the byte

 * offset where SPROM data is located.

 *

 * On error, returns 0; byte offset otherwise.

 verify OTP status */

 obtain bit offset from otplayout register */

		/*

		 * External SPROM takes precedence so check

		 * on-chip OTP only when no external SPROM

		 * is present.

 determine offset */

			/*

			 * Maybe there is no SPROM on the device?

			 * Now we ask the arch code if there is some sprom

			 * available for this device in some other storage.

/*

 * Broadcom specific AMBA

 * ChipCommon serial flash interface

 *

 * Licensed under the GNU/GPL. See COPYING for details.

 Initialize serial flash access */

	/* Prepare platform device, but don't register it yet. It's too early,

/*

 * Broadcom specific AMBA

 * Core ops

 *

 * Licensed under the GNU/GPL. See COPYING for details.

		/*

		 * Mask the PLL but don't wait for it to be disabled. PLL may be

		 * shared between cores and will be still up if there is another

		 * core using it.

/*

 * Broadcom specific AMBA

 * ChipCommon Power Management Unit driver

 *

 * Copyright 2009, Michael Buesch <m@bues.ch>

 * Copyright 2007, 2011, Broadcom Corporation

 * Copyright 2011, 2012, Hauke Mehrtens <hauke@hauke-m.de>

 *

 * Licensed under the GNU/GPL. See COPYING for details.

 pmu2_xtaltab0_adfll_485 */

 Turn off PLL */

 Flush */

 TODO: Do we need to update OTP? */

 Set the resource masks. */

	/*

	 * Add some delay; allow resources to come up and settle.

	 * Delay is required for SoC (early init).

 Disable to allow reading SPROM. Don't know the adventages of enabling it. */

		/*

		 * enable 12 mA drive strenth for 4313 and set chipControl

		 * register bit 1

 Ext PA lines must be enabled for tx on BCM4331 */

		/*

		 * enable 12 mA drive strenth for 43224 and set chipControl

		 * register bit 15

 always 20Mhz */

 always 25Mhz */

/* Find the output of the "m" pll divider given pll controls that start with

 * pllreg "pll0" i.e. 12 for main 6 for phy, 0 for misc.

 Detect failure in clock setting */

 Do calculation in Mhz */

 Return clock in Hertz */

 Get N, P1 and P2 dividers to determine CPU clock */

 Low cost bonding: Fixed reference clock 25MHz and m = 4 */

 Fixed reference clock 25MHz and m = 2 */

 query bus clock frequency for PMU-enabled chipcommon */

 query cpu clock frequency for PMU-enabled chipcommon */

 New PMUs can have different clock for bus and CPU */

 On old PMUs CPU has the same clock as the bus */

 5357[ab]0, 43236[ab]0, and 6362b0 */

		/*

		 * BCM5357 needs to touch PLL1_PLLCTL[02],

		 * so offset PLL0_PLLCTL[02] by 6

 RMW only the P1 divider */

 RMW only the int feedback divider */

 LCNXN */

		/*

		 * PLL Settings for spur avoidance on/off mode,

		 * no on2 support for 43228A0

/*

 * Broadcom specific AMBA

 * ChipCommon parallel flash

 *

 * Licensed under the GNU/GPL. See COPYING for details.

/*

 * Broadcom specific AMBA

 * PCI Host

 *

 * Licensed under the GNU/GPL. See COPYING for details.

/* Provides access to the requested core. Returns base offset that has to be

 Alloc */

 Basic PCI configuration */

	/* Disable the RETRY_TIMEOUT register (0x41) to keep

 SSB needed additional powering up, do we have any AMBA PCI cards? */

 Map MMIO */

 Host specific */

 Initialize struct, detect chip */

 Scan bus to find out generation of PCIe core */

 Register */

 CONFIG_PM_SLEEP */

 CONFIG_PM_SLEEP */

 0xa8d8 */

 0xa8db, BCM43217 (sic!) */

 0xa8dc */

/**************************************************

 * Runtime ops for drivers.

 See also pcicore_up */

 See also pcicore_down */

 See also si_pci_setup */

		/* This bcma device is not on a PCI host-bus. So the IRQs are

		 * not routed through the PCI core.

/*

 * Broadcom specific AMBA

 * ChipCommon B Unit driver

 *

 * Copyright 2014, Hauke Mehrtens <hauke@hauke-m.de>

 *

 * Licensed under the GNU/GPL. See COPYING for details.

/*

 * Broadcom specific AMBA

 * Bus subsystem

 *

 * Licensed under the GNU/GPL. See COPYING for details.

 contains the number the next bus should get. */

 bcma_buses_mutex locks the bcma_bus_next_num */

 We support that cores ourself */

 Early cores were already registered */

 Only first GMAC core on BCM4706 is connected and working */

 Now noone uses internally-handled cores, we can free them */

 Scan for devices (cores) */

 Early init CC core */

 Early init PCIE core */

 Cores providing flash access go before SPROM init */

 Try to get SPROM */

 Init CC core */

 Init CC core */

 Init MIPS core */

 Init PCIE core */

 Init PCIE core */

 Init PCIe Gen 2 core */

 Init GBIT MAC COMMON core */

 Register found cores */

/*

 * This is a special version of bus registration function designed for SoCs.

 * It scans bus and performs basic initialization of main cores only.

 * Please note it requires memory allocation, however it won't try to sleep.

 Scan for devices (cores) */

 Early init CC core */

 Early init MIPS core */

 Init CC core */

/*

 * If built-in, bus has to be registered early, before any driver calls

 * bcma_driver_register.

 * Otherwise registering driver would trigger BUG in driver_register.

 Main initialization has to be done with SPI/mtd/NAND/SPROM available */

 SPDX-License-Identifier: GPL-2.0

/* uio_pci_generic - generic UIO driver for PCI 2.3 devices

 *

 * Copyright (C) 2009 Red Hat, Inc.

 * Author: Michael S. Tsirkin <mst@redhat.com>

 *

 * Since the driver does not declare any device ids, you must allocate

 * id and bind the device to the driver yourself.  For example:

 *

 * # echo "8086 10f5" > /sys/bus/pci/drivers/uio_pci_generic/new_id

 * # echo -n 0000:00:19.0 > /sys/bus/pci/drivers/e1000e/unbind

 * # echo -n 0000:00:19.0 > /sys/bus/pci/drivers/uio_pci_generic/bind

 * # ls -l /sys/bus/pci/devices/0000:00:19.0/driver

 * .../0000:00:19.0/driver -> ../../../bus/pci/drivers/uio_pci_generic

 *

 * Driver won't bind to devices which do not support the Interrupt Disable Bit

 * in the command register. All devices compliant to PCI 2.3 (circa 2002) and

 * all compliant PCI Express devices should support this bit.

	/*

	 * This driver is insecure when used with devices doing DMA, but some

	 * people (mis)use it with such devices.

	 * Let's at least make sure DMA isn't left enabled after the userspace

	 * driver closes the fd.

	 * Note that there's a non-zero chance doing this will wedge the device

	 * at least until reset.

/* Interrupt handler. Read/modify/write the command register to disable

 UIO core will signal the user process. */

 only dynamic id's */

 SPDX-License-Identifier: GPL-2.0

/* uio_fsl_elbc_gpcm: UIO driver for eLBC/GPCM peripherals



   Copyright (C) 2014 Linutronix GmbH

     Author: John Ogness <john.ogness@linutronix.de>



   This driver provides UIO access to memory of a peripheral connected

   to the Freescale enhanced local bus controller (eLBC) interface

   using the general purpose chip-select mode (GPCM).



   Here is an example of the device tree entries:



	localbus@ffe05000 {

		ranges = <0x2 0x0 0x0 0xff810000 0x10000>;



		dpm@2,0 {

			compatible = "fsl,elbc-gpcm-uio";

			reg = <0x2 0x0 0x10000>;

			elbc-gpcm-br = <0xff810800>;

			elbc-gpcm-or = <0xffff09f7>;

			interrupt-parent = <&mpic>;

			interrupts = <4 1>;

			device_type = "netx5152";

			uio_name = "netx_custom";

			netx5152,init-win0-offset = <0x0>;

		};

	};



   Only the entries reg (to identify bank) and elbc-gpcm-* (initial BR/OR

   values) are required. The entries interrupt*, device_type, and uio_name

   are optional (as well as any type-specific options such as

   netx5152,init-win0-offset). As long as no interrupt handler is needed,

   this driver can be used without any type-specific implementation.



   The netx5152 type has been tested to work with the netX 51/52 hardware

   from Hilscher using the Hilscher userspace netX stack.



   The netx5152 type should serve as a model to add new type-specific

   devices as needed.

 parse use input */

 read current values */

 not allowed to change effective base address */

 not allowed to change mode */

 write new value (force valid) */

 not allowed to change access mask */

 write new value */

 check if an interrupt is enabled and active */

 disable interrupts */

 get an optional initial win0 offset */

 disable interrupts */

 disable interrupts */

 check specified bank */

 check specified mode (BR_MS_GPCM is 0) */

 check specified mask vs. resource size */

 check specified address */

 get the memory resource */

 get the bank number */

 get BR value to set */

 get OR value to set */

 get optional peripheral type */

 get optional irq value */

 sanity check device tree data */

 get optional uio name */

 allocate private data */

 get device tree data */

 allocate UIO structure */

 get current BR/OR values */

 if bank already configured, make sure it matches */

 warn if behavior settings changing */

 configure the bank (force base address and GPCM) */

 map the memory resource */

 set all UIO data */

 register UIO device */

 store private data */

 SPDX-License-Identifier: GPL-2.0

/*

 * drivers/uio/uio.c

 *

 * Copyright(C) 2005, Benedikt Spranger <b.spranger@linutronix.de>

 * Copyright(C) 2005, Thomas Gleixner <tglx@linutronix.de>

 * Copyright(C) 2006, Hans J. Koch <hjk@hansjkoch.de>

 * Copyright(C) 2006, Greg Kroah-Hartman <greg@kroah.com>

 *

 * Userspace IO

 *

 * Base Functions

 Protect idr accesses */

/*

 * attributes

 need to NULL terminate the list of attributes */

 UIO class infrastructure */

/*

 * device functions

/**

 * uio_event_notify - trigger an interrupt event

 * @info: UIO device capabilities

/**

 * uio_interrupt - hardware interrupt handler

 * @irq: IRQ number, can be UIO_IRQ_CYCLIC for cyclic timer

 * @dev_id: Pointer to the devices uio_device structure

	/*

	 * We need to subtract mi because userspace uses offset = N*PAGE_SIZE

	 * to use mem[N].

	/*

	 * We cannot use the vm_iomap_memory() helper here,

	 * because vma->vm_pgoff is the map index we looked

	 * up above in uio_find_mem_index(), rather than an

	 * actual page offset into the mmap.

	 *

	 * So we just do the physical mmap without a page

	 * offset.

 This is the first time in here, set everything up properly */

/**

 * __uio_register_device - register a new userspace IO device

 * @owner:	module that creates the new device

 * @parent:	parent device

 * @info:	UIO device capabilities

 *

 * returns zero on success or a negative error code.

		/*

		 * Note that we deliberately don't use devm_request_irq

		 * here. The parent module can unregister the UIO device

		 * and call pci_disable_msi, which requires that this

		 * irq has been freed. However, the device may have open

		 * FDs at the time of unregister and therefore may not be

		 * freed until they are released.

/**

 * __devm_uio_register_device - Resource managed uio_register_device()

 * @owner:	module that creates the new device

 * @parent:	parent device

 * @info:	UIO device capabilities

 *

 * returns zero on success or a negative error code.

/**

 * uio_unregister_device - unregister a industrial IO device

 * @info:	UIO device capabilities

 *

 SPDX-License-Identifier: GPL-2.0

/*

 * UIO Hilscher CIF card driver

 *

 * (C) 2007 Hans J. Koch <hjk@hansjkoch.de>

 * Original code (C) 2005 Benedikt Spranger <b.spranger@linutronix.de>

 Disable interrupt */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * UIO driver fo Humusoft MF624 DAQ card.

 * Copyright (C) 2011 Rostislav Lisovy <lisovy@gmail.com>,

 *                    Czech Technical University in Prague

 BAR0 Interrupt control/status register */

 Note: Datasheet says device uses BAR0, BAR1, BAR2 -- do not trust it */

 BAR0 */

 BAR2 */

 BAR4 */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * drivers/uio/uio_dmem_genirq.c

 *

 * Userspace I/O platform driver with generic IRQ handling code.

 *

 * Copyright (C) 2012 Damian Hobson-Garcia

 *

 * Based on uio_pdrv_genirq.c by Magnus Damm

 Wait until the Runtime PM code has woken up the device */

 Tell the Runtime PM code that the device has become idle */

	/* Just disable the interrupt in the interrupt controller, and

	 * remember the state so we can allow user space to enable it later.

	/* Allow user space to enable and disable the interrupt

	 * in the interrupt controller, but keep track of the

	 * state to prevent per-irq depth damage.

	 *

	 * Serialize this operation to support multiple tasks.

 alloc uioinfo for one device */

 interrupt is enabled to begin with */

 Multiple IRQs are not supported */

		/*

		 * If a level interrupt, dont do lazy disable. Otherwise the

		 * irq will fire again since clearing of the actual cause, on

		 * device level, is done in userspace

		 * irqd_is_level_type() isn't used since isn't valid until

		 * irq is configured.

	/* This driver requires no hardware specific kernel code to handle

	 * interrupts. Instead, the interrupt handler simply disables the

	 * interrupt in the interrupt controller. User space is responsible

	 * for performing hardware specific acknowledge and re-enabling of

	 * the interrupt in the interrupt controller.

	 *

	 * Interrupt sharing is not supported.

	/* Enable Runtime PM for this device:

	 * The device starts in suspended state to allow the hardware to be

	 * turned off by default. The Runtime PM bus code should power on the

	 * hardware and enable clocks at open().

	/* Runtime PM callback shared between ->runtime_suspend()

	 * and ->runtime_resume(). Simply returns success.

	 *

	 * In this driver pm_runtime_get_sync() and pm_runtime_put_sync()

	 * are used at open() and release() time. This allows the

	 * Runtime PM code to turn off power to the device while the

	 * device is unused, ie before open() and after release().

	 *

	 * This Runtime PM callback does not need to save or restore

	 * any registers since user space is responsbile for hardware

	 * register reinitialization after open().

 empty for now */ },

 SPDX-License-Identifier: GPL-2.0-only

/*

 * drivers/uio/uio_pdrv_genirq.c

 *

 * Userspace I/O platform driver with generic IRQ handling code.

 *

 * Copyright (C) 2008 Magnus Damm

 *

 * Based on uio_pdrv.c by Uwe Kleine-Koenig,

 * Copyright (C) 2008 by Digi International Inc.

 * All rights reserved.

 Bits in uio_pdrv_genirq_platdata.flags */

 Wait until the Runtime PM code has woken up the device */

 Tell the Runtime PM code that the device has become idle */

	/* Just disable the interrupt in the interrupt controller, and

	 * remember the state so we can allow user space to enable it later.

	/* Allow user space to enable and disable the interrupt

	 * in the interrupt controller, but keep track of the

	 * state to prevent per-irq depth damage.

	 *

	 * Serialize this operation to support multiple tasks and concurrency

	 * with irq handler on SMP systems.

 alloc uioinfo for one device */

 Multiple IRQs are not supported */

 interrupt is enabled to begin with */

		/*

		 * If a level interrupt, dont do lazy disable. Otherwise the

		 * irq will fire again since clearing of the actual cause, on

		 * device level, is done in userspace

		 * irqd_is_level_type() isn't used since isn't valid until

		 * irq is configured.

	/* This driver requires no hardware specific kernel code to handle

	 * interrupts. Instead, the interrupt handler simply disables the

	 * interrupt in the interrupt controller. User space is responsible

	 * for performing hardware specific acknowledge and re-enabling of

	 * the interrupt in the interrupt controller.

	 *

	 * Interrupt sharing is not supported.

	/* Enable Runtime PM for this device:

	 * The device starts in suspended state to allow the hardware to be

	 * turned off by default. The Runtime PM bus code should power on the

	 * hardware and enable clocks at open().

	/* Runtime PM callback shared between ->runtime_suspend()

	 * and ->runtime_resume(). Simply returns success.

	 *

	 * In this driver pm_runtime_get_sync() and pm_runtime_put_sync()

	 * are used at open() and release() time. This allows the

	 * Runtime PM code to turn off power to the device while the

	 * device is unused, ie before open() and after release().

	 *

	 * This Runtime PM callback does not need to save or restore

	 * any registers since user space is responsbile for hardware

	 * register reinitialization after open().

 This is filled with module_parm */ },

 Sentinel */ },

 SPDX-License-Identifier: GPL-2.0

/* sercos3: UIO driver for the Automata Sercos III PCI card



   Copyright (C) 2008 Linutronix GmbH

     Author: John Ogness <john.ogness@linutronix.de>



   This is a straight-forward UIO driver, where interrupts are disabled

   by the interrupt handler and re-enabled via a write to the UIO device

   by the userspace-part.



   The only part that may seem odd is the use of a logical OR when

   storing and restoring enabled interrupts. This is done because the

   userspace-part could directly modify the Interrupt Enable Register

   at any time. To reduce possible conflicts, the kernel driver uses

   a logical OR to make more controlled changes (rather than blindly

   overwriting previous values).



   Race conditions exist if the userspace-part directly modifies the

   Interrupt Enable Register while in operation. The consequences are

   that certain interrupts would fail to be enabled or disabled. For

   this reason, the userspace-part should only directly modify the

   Interrupt Enable Register at the beginning (to get things going).

   The userspace-part can safely disable interrupts at any time using

   a write to the UIO device.

 ID's for SERCOS III PCI card (PLX 9030) */

 Interrupt Enable Register */

 Interrupt Status Register */

 this function assumes ier0_cache_lock is locked! */

 add enabled interrupts to cache */

 disable interrupts */

 this function assumes ier0_cache_lock is locked! */

 restore previously enabled interrupts */

 we only need PCI BAR's 0, 2, 3, 4, 5 */

 SPDX-License-Identifier: GPL-2.0

/*

 * uio_hv_generic - generic UIO driver for VMBus

 *

 * Copyright (c) 2013-2016 Brocade Communications Systems, Inc.

 * Copyright (c) 2016, Microsoft Corporation.

 *

 * Since the driver does not declare any device ids, you must allocate

 * id and bind the device to the driver yourself.  For example:

 *

 * Associate Network GUID with UIO device

 * # echo "f8615163-df3e-46c5-913f-f2d2f965ed0e" \

 *    > /sys/bus/vmbus/drivers/uio_hv_generic/new_id

 * Then rebind

 * # echo -n "ed963694-e847-4b2a-85af-bc9cfc11d6f3" \

 *    > /sys/bus/vmbus/drivers/hv_netvsc/unbind

 * # echo -n "ed963694-e847-4b2a-85af-bc9cfc11d6f3" \

 *    > /sys/bus/vmbus/drivers/uio_hv_generic/bind

 pages */

/*

 * List of resources to be mapped to user space

 * can be extended up to MAX_UIO_MAPS(5) items

 "recv_4294967295" */

/*

 * This is the irqcontrol callback to be registered to uio_info.

 * It can be used to disable/enable interrupt from user space processes.

 *

 * @param info

 *  pointer to uio_info.

 * @param irq_state

 *  state value. 1 to enable interrupt, 0 to disable interrupt.

/*

 * Callback from vmbus_event when something is in inbound ring.

/*

 * Callback from vmbus_event when channel is rescinded.

	/*

	 * Turn off the interrupt file handle

	 * Next read for event will return -EIO

 Wake up reader */

/* Sysfs API to allow mmap of the ring buffers

 * The ring buffer is allocated as contiguous memory by vmbus_open

 Callback from VMBUS subsystem when new channel created. */

 Create host communication ring */

 Disable interrupts on sub channel */

 free the reserved buffers for send and receive */

 VMBus primary channel is opened on first use */

 VMBus primary channel is closed on last close */

 Communicating with host has to be via shared memory not hypercall */

 Fill general uio info */

 mem resources */

 put Global Physical Address Label in name */

 only dynamic id's */

 SPDX-License-Identifier: GPL-2.0

/*

 * Generic DFL driver for Userspace I/O devicess

 *

 * Copyright (C) 2021 Intel Corporation, Inc.

 Irq is yet to be supported */

/*

 * Programmable Real-Time Unit Sub System (PRUSS) UIO driver (uio_pruss)

 *

 * This driver exports PRUSS host event out interrupts and PRUSS, L3 RAM,

 * and DDR RAM to user space for applications interacting with PRUSS firmware

 *

 * Copyright (C) 2010-11 Texas Instruments Incorporated - http://www.ti.com/

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License as

 * published by the Free Software Foundation version 2.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

/*

 * Host event IRQ numbers from PRUSS - PRUSS can generate up to 8 interrupt

 * events to AINTC of ARM host processor - which can be used for IPC b/w PRUSS

 * firmware and user space application, async notification from PRU firmware

 * to user space application

 * 3	PRU_EVTOUT0

 * 4	PRU_EVTOUT1

 * 5	PRU_EVTOUT2

 * 6	PRU_EVTOUT3

 * 7	PRU_EVTOUT4

 * 8	PRU_EVTOUT5

 * 9	PRU_EVTOUT6

 * 10	PRU_EVTOUT7

 Is interrupt enabled and active ? */

 Disable interrupt */

 Power on PRU in case its not done as part of boot-loader */

 Register PRUSS IRQ lines */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * uio_aec.c -- simple driver for Adrienne Electronics Corp time code PCI device

 *

 * Copyright (C) 2008 Brandon Philips <brandon@ifup.org>

 application writes 0x00 to 0x2F to get next interrupt */

 disable interrupts */

 read mailbox to ensure board drops irq */

 SPDX-License-Identifier: GPL-2.0

/*

 * UIO driver for Hilscher NetX based fieldbus cards (cifX, comX).

 * See http://www.hilscher.com for details.

 *

 * (C) 2007 Hans J. Koch <hjk@hansjkoch.de>

 * (C) 2008 Manuel Traut <manut@linutronix.de>

 *

 Is one of our interrupts enabled and active ? */

 Disable interrupt */

 BAR0 or 2 points to the card's dual port memory */

 Make sure all interrupts are disabled */

 Disable all interrupts */

/*

 *    Zorro Bus Services

 *

 *    Copyright (C) 1995-2003 Geert Uytterhoeven

 *

 *    This file is subject to the terms and conditions of the GNU General Public

 *    License.  See the file COPYING in the main directory of this archive

 *    for more details.

    /*

     *  Zorro Expansion Devices

    /*

     *  Zorro bus

    /*

     *  Find Zorro Devices

    /*

     *  Bitmask indicating portions of available Zorro II RAM that are unused

     *  by the system. Every bit represents a 64K chunk, for a maximum of 8MB

     *  (128 chunks, physical 0x00200000-0x009fffff).

     *

     *  If you want to use (= allocate) portions of this RAM, you should clear

     *  the corresponding bits.

     *

     *  Possible uses:

     *      - z2ram device

     *      - SCSI DMA bounce buffers

     *

     *  FIXME: use the normal resource management

 Initialize the Zorro bus */

 First identify all devices ... */

 GVP quirk */

 ... then register them */

 Mark all available Zorro II memory */

 Unmark all used Zorro II memory */

/*

 *  File Attributes for Zorro Devices

 *

 *  Copyright (C) 2003 Geert Uytterhoeven

 *

 *  Loosely based on drivers/pci/pci-sysfs.c

 *

 *  This file is subject to the terms and conditions of the GNU General Public

 *  License.  See the file COPYING in the main directory of this archive

 *  for more details.

 show configuration fields */

 Construct a ConfigDev */

 SPDX-License-Identifier: GPL-2.0

/*

 *	Zorro Device Name Tables

 *

 *	Copyright (C) 1999--2000 Geert Uytterhoeven

 *

 *	Based on the PCI version:

 *

 *	Copyright 1992--1999 Drew Eckhardt, Frederic Potter,

 *	David Mosberger-Tang, Martin Mares

/*

 * This is ridiculous, but we want the strings in

 * the .init section so that they don't take up

 * real memory.. Parse the same file multiple times

 * to get all the info.

 Couldn't find either the manufacturer nor the product */

 Ok, found the manufacturer, but unknown product */

 Full match */

 SPDX-License-Identifier: GPL-2.0

/*

 *	Generate devlist.h from the Zorro ID file.

 *

 *	(c) 2000 Geert Uytterhoeven <geert@linux-m68k.org>

 *

 *	Based on the PCI version:

 *

 *	(c) 1999--2000 Martin Mares <mj@ucw.cz>

 Too long, try cutting off long description */

/*

 *  Zorro Driver Services

 *

 *  Copyright (C) 2003 Geert Uytterhoeven

 *

 *  Loosely based on drivers/pci/pci-driver.c

 *

 *  This file is subject to the terms and conditions of the GNU General Public

 *  License.  See the file COPYING in the main directory of this archive

 *  for more details.

    /**

     *  zorro_match_device - Tell if a Zorro device structure has a matching

     *                       Zorro device id structure

     *  @ids: array of Zorro device id structures to search in

     *  @dev: the Zorro device structure to match against

     *

     *  Used by a driver to check whether a Zorro device present in the

     *  system is in its list of supported devices. Returns the matching

     *  zorro_device_id structure or %NULL if there is no match.

    /**

     *  zorro_register_driver - register a new Zorro driver

     *  @drv: the driver structure to register

     *

     *  Adds the driver structure to the list of registered drivers

     *  Returns zero or a negative error value.

 initialize common driver fields */

 register with core */

    /**

     *  zorro_unregister_driver - unregister a zorro driver

     *  @drv: the driver structure to unregister

     *

     *  Deletes the driver structure from the list of registered Zorro drivers,

     *  gives it a chance to clean up by calling its remove() function for

     *  each device it was responsible for, and marks those devices as

     *  driverless.

    /**

     *  zorro_bus_match - Tell if a Zorro device structure has a matching Zorro

     *                    device id structure

     *  @ids: array of Zorro device id structures to search in

     *  @dev: the Zorro device structure to match against

     *

     *  Used by the driver core to check whether a Zorro device present in the

     *  system is in a driver's list of supported devices.  Returns 1 if

     *  supported, and 0 if there is no match.

 SPDX-License-Identifier: GPL-2.0

/*

 *	Procfs interface for the Zorro bus.

 *

 *	Copyright (C) 1998-2003 Geert Uytterhoeven

 *

 *	Heavily based on the procfs interface for the PCI bus, which is

 *

 *	Copyright (C) 1997, 1998 Martin Mares <mj@atrey.karlin.mff.cuni.cz>

 Construct a ConfigDev */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * MEN Chameleon Bus.

 *

 * Copyright (C) 2014 MEN Mikroelektronik GmbH (www.men.de)

 * Author: Andreas Werner <andreas.werner@men.de>

 SPDX-License-Identifier: GPL-2.0-only

	/*

	 * If the BAR is missing, dev_mapbase is zero, or if the

	 * device is IO mapped we just print a warning and go on with the

	 * next device, instead of completely stop the gdd parser

 skip reg1 */

	/*

	 * For those devices which are not connected

	 * to the PCI Bus (e.g. LPC) there is a bar

	 * descriptor located directly after the

	 * chameleon header. This header is comparable

	 * to a PCI header.

 Extract header information */

 We only support chameleon v2 at the moment */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * MEN Chameleon Bus.

 *

 * Copyright (C) 2013 MEN Mikroelektronik GmbH (www.men.de)

 * Author: Johannes Thumshirn <johannes.thumshirn@men.de>

/**

 * __mcb_register_driver() - Register a @mcb_driver at the system

 * @drv: The @mcb_driver

 * @owner: The @mcb_driver's module

 * @mod_name: The name of the @mcb_driver's module

 *

 * Register a @mcb_driver at the system. Perform some sanity checks, if

 * the .probe and .remove methods are provided by the driver.

/**

 * mcb_unregister_driver() - Unregister a @mcb_driver from the system

 * @drv: The @mcb_driver

 *

 * Unregister a @mcb_driver from the system.

/**

 * mcb_device_register() - Register a mcb_device

 * @bus: The @mcb_bus of the device

 * @dev: The @mcb_device

 *

 * Register a specific @mcb_device at a @mcb_bus and the system itself.

/**

 * mcb_alloc_bus() - Allocate a new @mcb_bus

 *

 * Allocate a new @mcb_bus.

/**

 * mcb_release_bus() - Free a @mcb_bus

 * @bus: The @mcb_bus to release

 *

 * Release an allocated @mcb_bus from the system.

/**

 * mcb_bus_put() - Increment refcnt

 * @bus: The @mcb_bus

 *

 * Get a @mcb_bus' ref

/**

 * mcb_bus_put() - Decrement refcnt

 * @bus: The @mcb_bus

 *

 * Release a @mcb_bus' ref

/**

 * mcb_alloc_dev() - Allocate a device

 * @bus: The @mcb_bus the device is part of

 *

 * Allocate a @mcb_device and add bus.

/**

 * mcb_free_dev() - Free @mcb_device

 * @dev: The device to free

 *

 * Free a @mcb_device

/**

 * mcb_bus_add_devices() - Add devices in the bus' internal device list

 * @bus: The @mcb_bus we add the devices

 *

 * Add devices in the bus' internal device list to the system.

/**

 * mcb_get_resource() - get a resource for a mcb device

 * @dev: the mcb device

 * @type: the type of resource

/**

 * mcb_request_mem() - Request memory

 * @dev: The @mcb_device the memory is for

 * @name: The name for the memory reference.

 *

 * Request memory for a @mcb_device. If @name is NULL the driver name will

 * be used.

/**

 * mcb_release_mem() - Release memory requested by device

 * @dev: The @mcb_device that requested the memory

 *

 * Release memory that was prior requested via @mcb_request_mem().

/**

 * mcb_get_irq() - Get device's IRQ number

 * @dev: The @mcb_device the IRQ is for

 *

 * Get the IRQ number of a given @mcb_device.

/* mcb must be initialized after PCI but before the chameleon drivers.

 * That means we must use some initcall between subsys_initcall and

 * device_initcall.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * MEN Chameleon Bus.

 *

 * Copyright (C) 2014 MEN Mikroelektronik GmbH (www.men.de)

 * Author: Johannes Thumshirn <johannes.thumshirn@men.de>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Perf support for the Statistical Profiling Extension, introduced as

 * part of ARMv8.2.

 *

 * Copyright (C) 2016 ARM Limited

 *

 * Author: Will Deacon <will.deacon@arm.com>

 PPI */

 Convert a free-running index from perf into an SPE buffer offset */

 Keep track of our dynamic hotplug state */

 This sysfs gunk was really good fun to write. */

 User ABI */

 PMSCR_EL1.TS */

 PMSCR_EL1.PA */

 PMSCR_EL1.PCT */

 PMSIRR_EL1.RND */

 PMSFCR_EL1.B */

 PMSFCR_EL1.LD */

 PMSFCR_EL1.ST */

 PMSEVFR_EL1 */

 PMSLATFR_EL1.MINLAT */

 Why does everything I do descend into this? */

 Convert between user ABI and register values */

	/*

	 * The trace format isn't parseable in reverse, so clamp

	 * the limit to half of the buffer size in snapshot mode

	 * so that the worst case is half a buffer of records, as

	 * opposed to a single record.

	/*

	 * If we're within max_record_sz of the limit, we must

	 * pad, move the head index and recompute the limit.

	/*

	 * The head can be misaligned for two reasons:

	 *

	 * 1. The hardware left PMBPTR pointing to the first byte after

	 *    a record when generating a buffer management event.

	 *

	 * 2. We used perf_aux_output_skip to consume handle->size bytes

	 *    and CIRC_SPACE was used to compute the size, which always

	 *    leaves one entry free.

	 *

	 * Deal with this by padding to the next alignment boundary and

	 * moving the head index. If we run out of buffer space, we'll

	 * reduce handle->size to zero and end up reporting truncation.

 If we've run out of free space, then nothing more to do */

 Compute the tail and wakeup indices now that we've aligned head */

	/*

	 * Avoid clobbering unconsumed data. We know we have space, so

	 * if we see head == tail we know that the buffer is empty. If

	 * head > tail, then there's nothing to clobber prior to

	 * wrapping.

	/*

	 * Wakeup may be arbitrarily far into the future. If it's not in

	 * the current generation, either we'll wrap before hitting it,

	 * or it's in the past and has been handled already.

	 *

	 * If there's a wakeup before we wrap, arrange to be woken up by

	 * the page boundary following it. Keep the tail boundary if

	 * that's lower.

	/*

	 * If the head has come too close to the end of the buffer,

	 * then pad to the end and recompute the limit.

 Start a new aux session */

		/*

		 * We still need to clear the limit pointer, since the

		 * profiler might only be disabled by virtue of a fault.

 Disable profiling at EL0 and EL1 */

 Drain any buffered data */

 Disable the profiling buffer */

 IRQ handling */

	/*

	 * Ensure new profiling data is visible to the CPU and any external

	 * aborts have been resolved.

 Ensure hardware updates to PMBPTR_EL1 are visible */

 Service required? */

	/*

	 * If we've lost data, disable profiling and also set the PARTIAL

	 * flag to indicate that the last record is corrupted.

 Report collisions to userspace so that it can up the period */

 We only expect buffer management events */

 Handled below */

 Buffer management event */

	/*

	 * Ensure perf callbacks have completed, which may disable the

	 * profiling buffer in response to a TRUNCATION flag.

		/*

		 * If a fatal exception occurred then leaving the profiling

		 * buffer enabled is a recipe waiting to happen. Since

		 * fatal faults don't always imply truncation, make sure

		 * that the profiling buffer is disabled explicitly before

		 * clearing the syndrome register.

		/*

		 * We handled the fault (the buffer was full), so resume

		 * profiling as long as we didn't detect truncation.

		 * PMBPTR might be misaligned, but we'll burn that bridge

		 * when we get to it.

 We've seen you before, but GCC has the memory of a sieve. */

 The buffer pointers are now sane, so resume profiling. */

 Return the highest version we support in default */

 Perf callbacks */

 This is, of course, deeply driver-specific */

	/*

	 * Feedback-directed frequency throttling doesn't work when we

	 * have a buffer of samples. We'd need to manually count the

	 * samples in the buffer when it fills up and adjust the event

	 * count to reflect that. Instead, just force the user to specify

	 * a sample period.

 If we're already stopped, then nothing to do */

 Stop all trace generation */

		/*

		 * If there's a fault pending then ensure we contain it

		 * to this buffer, since we might be on the context-switch

		 * path.

		/*

		 * This may also contain ECOUNT, but nobody else should

		 * be looking at period_left, since we forbid frequency

		 * based sampling.

 We need at least two pages for this to work. */

	/*

	 * We require an even number of pages for snapshot mode, so that

	 * we can effectively treat the buffer as consisting of two equal

	 * parts and give userspace a fighting chance of getting some

	 * useful data out of it.

 Initialisation and teardown functions */

		/*

		 * We hitch a ride on the software context here, so that

		 * we can support per-task profiling (which is not possible

		 * with the invalid context as it doesn't get sched callbacks).

		 * This requires that userspace either uses a dummy event for

		 * perf_event_open, since the aux buffer is not setup until

		 * a subsequent mmap, or creates the profiling event in a

		 * disabled state and explicitly PERF_EVENT_IOC_ENABLEs it

		 * once the buffer has been created.

 Read PMBIDR first to determine whether or not we have access */

 Minimum alignment. If it's out-of-range, then fail the probe */

 It's now safe to read PMSIDR and figure out what we've got */

 This field has a spaced out encoding, so just use a look-up */

 Maximum record size. If it's out-of-range, then fail the probe */

	/*

	 * This is probably overkill, as we have no idea where we're

	 * draining any buffered data to...

 Reset the buffer base pointer */

 Clear any pending management interrupts */

 Make sure we probe the hardware on a relevant CPU */

 Request our PPIs (note that the IRQ is still disabled) */

	/*

	 * Register our hotplug notifier now so we don't miss any events.

	 * This will enable the IRQ for any supported CPUs that are already

	 * up.

 Driver and device probing */

 Sentinel */ },

	/*

	 * If kernelspace is unmapped when running at EL0, then the SPE

	 * buffer will fault and prematurely terminate the AUX session.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ARM performance counter support.

 *

 * Copyright (C) 2009 picoChip Designs, Ltd., Jamie Iles

 * Copyright (C) 2010 ARM Ltd., Will Deacon <will.deacon@arm.com>

 *

 * This code is based on the sparc64 perf event code, which is in turn based

 * on the x86 code.

	/*

	 * Limit the maximum period to prevent the counter value

	 * from overtaking the one we are about to program. In

	 * effect we are reducing max_period to account for

	 * interrupt latency (and we are being very conservative).

	/*

	 * ARM pmu always has to update the counter, so ignore

	 * PERF_EF_UPDATE, see comments in armpmu_start().

	/*

	 * ARM pmu always has to reprogram the period, so ignore

	 * PERF_EF_RELOAD, see the comment below.

	/*

	 * Set the period again. Some counters can't be stopped, so when we

	 * were stopped we simply disabled the IRQ source and the counter

	 * may have been left counting. If we don't do this step then we may

	 * get an interrupt too soon or *way* too late if the overflow has

	 * happened since disabling.

 Clear the allocated counter */

 An event following a process won't be stopped earlier */

 If we don't have a space for the counter then finish early. */

	/*

	 * If there is an event in the counter we are going to use then make

	 * sure it is disabled.

 Propagate our changes to the userspace mapping. */

	/*

	 * Reject groups spanning multiple HW PMUs (e.g. CPU + CCI). The

	 * core perf code won't check that the pmu->ctx == leader->ctx

	 * until after pmu->event_init(event).

	/*

	 * Initialise the fake PMU. We only need to populate the

	 * used_mask for the purposes of validation.

	/*

	 * we request the IRQ with a (possibly percpu) struct arm_pmu**, but

	 * the handlers expect a struct arm_pmu*. The percpu_irq framework will

	 * do any necessary shifting, we just need to perform the first

	 * dereference.

	/*

	 * We don't assign an index until we actually place the event onto

	 * hardware. Use -1 to signify that we haven't decided where to put it

	 * yet. For SMP systems, each core has it's own PMU so we can't do any

	 * clever allocation or constraints checking at this point.

	/*

	 * Check whether we need to exclude the counter from certain modes.

	/*

	 * Store the event encoding into the config_base field.

		/*

		 * For non-sampling runs, limit the sample_period to half

		 * of the counter width. That way, the new counter value

		 * is far less likely to overtake the previous one unless

		 * you have some serious IRQ latency issues.

	/*

	 * Reject CPU-affine events for CPUs that are of a different class to

	 * that which this PMU handles. Process-following events (where

	 * event->cpu == -1) can be migrated between CPUs, and thus we have to

	 * reject them later (in armpmu_add) if they're scheduled on a

	 * different class of CPU.

 does not support taken branch sampling */

 For task-bound events we may be called on other CPUs */

 For task-bound events we may be called on other CPUs */

/*

 * In heterogeneous systems, events are specific to a particular

 * microarchitecture, and aren't suitable for another. Thus, only match CPUs of

 * the same microarchitecture.

 If cannot get an NMI, get a normal interrupt */

 If cannot get an NMI, get a normal interrupt */

 Per cpudevid irq was already requested by another CPU */

/*

 * PMU hardware loses all context when a CPU goes offline.

 * When a CPU is hotplugged back in, since some hardware registers are

 * UNKNOWN at reset, the PMU must be explicitly reset to avoid reading

 * junk values out of them.

			/*

			 * Stop and update the counter

			 /*

			  * Restore and enable the counter.

			  * armpmu_start() indirectly calls

			  *

			  * perf_event_update_userpage()

			  *

			  * that requires RCU read locking to be functional,

			  * wrap the call within RCU_NONIDLE to make the

			  * RCU subsystem aware this cpu is not idle from

			  * an RCU perspective for the armpmu_start() call

			  * duration.

	/*

	 * Always reset the PMU registers on power-up even if

	 * there are no events running.

		/*

		 * This is a CPU PMU potentially in a heterogeneous

		 * configuration (e.g. big.LITTLE). This is not an uncore PMU,

		 * and we have taken ctx sharing into account (e.g. with our

		 * pmu::filter_match callback and pmu::event_init group

		 * validation).

 SPDX-License-Identifier: GPL-2.0

/*

 * platform_device probing code for ARM performance counters.

 *

 * Copyright (C) 2009 picoChip Designs, Ltd., Jamie Iles

 * Copyright (C) 2010 ARM Ltd., Will Deacon <will.deacon@arm.com>

	/*

	 * If we don't have an interrupt-affinity property, we guess irq

	 * affinity matches our logical CPU order, as we used to assume.

	 * This is fragile, so we'll warn in pmu_parse_irqs().

	/*

	 * In this case we have no idea which CPUs are covered by the PMU.

	 * To match our prior behaviour, we assume all CPUs in this case.

 arm64 systems boot only as non-secure */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * APM X-Gene SoC PMU (Performance Monitor Unit)

 *

 * Copyright (c) 2016, Applied Micro Circuits Corporation

 * Author: Hoan Tran <hotran@apm.com>

 *         Tai Nguyen <ttnguyen@apm.com>

 PMU registers for V3 */

/*

 * sysfs format attributes

/*

 * sysfs event attributes

/*

 * sysfs cpumask attributes

/*

 * Per PMU device attribute groups of PMU v1 and v2

/*

 * Per PMU device attribute groups of PMU v3

	/*

	 * v3 has 64-bit counter registers composed by 2 32-bit registers

	 * This can be a problem if the counter increases and carries

	 * out of bit [31] between 2 reads. The extra reads would help

	 * to prevent this issue.

 v3 has 64-bit counter registers composed by 2 32-bit registers */

 Test the event attr type check for PMU enumeration */

	/*

	 * SOC PMU counters are shared across all cores.

	 * Therefore, it does not support per-process mode.

	 * Also, it does not support event sampling mode.

	/*

	 * Many perf core operations (eg. events rotation) operate on a

	 * single CPU context. This is obvious for CPU PMUs, where one

	 * expects the same sets of events being observed on all CPUs,

	 * but can lead to issues for off-core PMUs, where each

	 * event could be theoretically assigned to a different CPU. To

	 * mitigate this, we enforce CPU assignment to one, selected

	 * processor (the one described in the "cpumask" attribute).

	/*

	 * Each bit of the config1 field represents an agent from which the

	 * request of the event come. The event is counted only if it's caused

	 * by a request of an agent has the bit cleared.

	 * By default, the event is counted for all agents.

	/*

	 * We must NOT create groups containing mixed PMUs, although software

	 * events are acceptable

	/*

	 * For 32 bit counter, it has a period of 2^32. To account for the

	 * possibility of extreme interrupt latency we program for a period of

	 * half that. Hopefully, we can handle the interrupt before another 2^31

	 * events occur and the counter overtakes its previous value.

	 * For 64 bit counter, we don't expect it overflow.

 Allocate an event counter */

 Update counter event pointer for Interrupt handler */

 clear the assigned counter */

 First version PMU supports only single event counter */

 Perf driver registration */

 Hardware counter init */

 Clear interrupt flag */

 Ignore if we don't have an event. */

 Get Interrupt PMU source */

 Dual MCB active */

 Probe all active MC(s) */

 Single MCB active */

 Probe all active MC(s) */

 Dual MCB active */

 Probe all active L3C(s), maximum is 8 */

 Probe all active MC(s), maximum is 8 */

 Single MCB active */

 Probe all active L3C(s), maximum is 4 */

 Probe all active MC(s), maximum is 4 */

 Dual MCB active */

 Probe all active MC(s) */

 Single MCB active */

 Probe all active MC(s) */

 A PMU device node without enable-bit-index is always enabled */

 Can't add the PMU device, skip it */

 A PMU device node without enable-bit-index is always enabled */

 Can't add the PMU device, skip it */

 Overflow interrupt also should use the same CPU */

 Overflow interrupt also should use the same CPU */

 Install a hook to update the reader CPU in case it goes offline */

 Check for active MCBs and MCUs */

 Add this instance to the list used by the hotplug callback */

 Walk through the tree for all PMU perf devices */

 Enable interrupt */

 SPDX-License-Identifier: GPL-2.0-only

/* Copyright (c) 2015-2017 The Linux Foundation. All rights reserved.

/*

 * Events

/*

 * Aggregate PMU. Implements the core pmu functions and manages

 * the hardware PMUs.

/*

 * The cache is made up of one or more clusters, each cluster has its own PMU.

 * Each cluster is associated with one or more CPUs.

 * This structure represents one of the hardware PMUs.

 *

 * Events can be envisioned as a 2-dimensional array. Each column represents

 * a group of events. There are 8 groups. Only one entry from each

 * group can be in use at a time.

 *

 * Events are specified as 0xCCG, where CC is 2 hex digits specifying

 * the code (array row) and G specifies the group (column).

 *

 * In addition there is a cycle counter event specified by L2CYCLE_CTR_RAW_CODE

 * which is outside the above scheme.

 The CPU that is used for collecting events on this cluster */

 All the CPUs associated with this cluster */

 Reset all counters */

/*

 * Hardware allows filtering of events based on the originating

 * CPU. Turn this off by setting filter bits to allow events from

 * all CPUS, subunits and ID independent events in this cluster.

	/*

	 * The cycle counter is 64-bit, but all other counters are

	 * 32-bit, and we must handle 32-bit overflow explicitly.

	/*

	 * We limit the max period to half the max counter value so

	 * that even in the case of extreme interrupt latency the

	 * counter will (hopefully) not wrap past its initial value.

 The counters are all in use. */

	/*

	 * Check for column exclusion: event column already in use by another

	 * event. This is for events which are not in the same group.

	 * Conflicting events in the same group are detected in event_init.

/*

 * Implementation of abstract pmu functionality required by

 * the core perf events code.

	/*

	 * Although there is only one PMU (per socket) controlling multiple

	 * physical PMUs (per cluster), because we do not support per-task mode

	 * each event is associated with a CPU. Each event has pmu_enable

	 * called on its CPU, so here it is only necessary to enable the

	 * counters for the current CPU.

 Don't allow groups with mixed PMUs, except for s/w events */

 CPU has not been initialised */

 Ensure all events in a group are on the same cpu */

	/*

	 * Ensure all events are on the same cpu so all events are in the

	 * same cpu context, to avoid races on pmu_enable etc.

 Propagate changes to the userspace mapping. */

 CCG format for perf RAW codes. */

/*

 * Generic device handlers

	/*

	 * Read number of counters from L2PMCR and add 1

	 * for the cycle counter.

	/*

	 * This assumes that the cluster_id is in MPIDR[aff1] for

	 * single-threaded cores, and MPIDR[aff2] for multi-threaded

	 * cores. This logic will have to be updated if this changes.

 First time this CPU has come online */

 Only if broken firmware doesn't list every cluster */

 If another CPU is managing this cluster, we're done */

	/*

	 * All CPUs on this cluster were down, use this one.

	 * Reset to put it into sane state.

 If this CPU is not managing the cluster, we're done */

 Give up ownership of cluster */

 Any other CPU for this cluster which is still online */

 suffix is instance id for future use with multiple sockets */

 Read cluster info and initialize each cluster */

 SPDX-License-Identifier: GPL-2.0

 CCI Cache Coherent Interconnect PMU driver

 Copyright (C) 2013-2018 Arm Ltd.

 Author: Punit Agrawal <punit.agrawal@arm.com>, Suzuki Poulose <suzuki.poulose@arm.com>

 Types of interfaces that can generate events */

/*

 * struct cci_pmu_model:

 * @fixed_hw_cntrs - Number of fixed event counters

 * @num_hw_cntrs - Maximum number of programmable event counters

 * @cntr_size - Size of an event counter mapping

 CCI400 PMU Specific definitions */

 Port ids */

/*

 * Instead of an event id to monitor CCI cycles, a dedicated counter is

 * provided. Use 0xff to represent CCI cycles and hope that no future revisions

 * make use of this event in hardware.

/*

 * CCI PMU event id is an 8-bit value made of two parts - bits 7:5 for one of 8

 * ports and bits 4:0 are event codes. There are different event codes

 * associated with each port type.

 *

 * Additionally, the range of events associated with the port types changed

 * between Rev0 and Rev1.

 *

 * The constants below define the range of valid codes for each port type for

 * the different revisions and are used to validate the event to be monitored.

 Slave events */

 Master events */

 Special event for cycles counter */

 Slave events */

 Master events */

 Special event for cycles counter */

 cycles event idx is fixed */

 No counters available */

 Slave Interface */

 Master Interface */

 !CONFIG_ARM_CCI400_PMU */

 CONFIG_ARM_CCI400_PMU */

/*

 * CCI5xx PMU event id is an 9-bit value made of two parts.

 *	 bits [8:5] - Source for the event

 *	 bits [4:0] - Event code (specific to type of interface)

 *

 *

 Port ids */

 Slave events */

 Master events */

 Global events */

 Global events have single fixed source code */

/*

 * CCI500 provides 8 independent event counters that can count

 * any of the events available.

 * CCI500 PMU event source ids

 *	0x0-0x6 - Slave interfaces

 *	0x8-0xD - Master interfaces

 *	0xf     - Global Events

 *	0x7,0xe - Reserved

/*

 * CCI550 provides 8 independent event counters that can count

 * any of the events available.

 * CCI550 PMU event source ids

 *	0x0-0x6 - Slave interfaces

 *	0x8-0xe - Master interfaces

 *	0xf     - Global Events

 *	0x7	- Reserved

 CONFIG_ARM_CCI5xx_PMU */

/*

 * Program the CCI PMU counters which have PERF_HES_ARCH set

 * with the event period and mark them ready before we enable

 * PMU.

 Leave the events which are not counting */

 Should be called with cci_pmu->hw_events->pmu_lock held */

 Enable all the PMU counters. */

 Should be called with cci_pmu->hw_events->pmu_lock held */

 Should be called with cci_pmu->hw_events->pmu_lock held */

 Disable all the PMU counters. */

 source parameter is mandatory for normal PMU events */

/*

 * For all counters on the CCI-PMU, disable any 'enabled' counters,

 * saving the changed counters in the mask, so that we can restore

 * it later using pmu_restore_counters. The mask is private to the

 * caller. We cannot rely on the used_mask maintained by the CCI_PMU

 * as it only tells us if the counter is assigned to perf_event or not.

 * The state of the perf_event cannot be locked by the PMU layer, hence

 * we check the individual counter status (which can be locked by

 * cci_pm->hw_events->pmu_lock).

 *

 * @mask should be initialised to empty by the caller.

/*

 * Restore the status of the counters. Reversal of the pmu_save_counters().

 * For each counter set in the mask, enable the counter back.

/*

 * Returns the number of programmable counters actually implemented

 * by the cci

 Generic code to find an unused idx from the mask */

 No counters available */

	/*

	 * Register all available CCI PMU interrupts. In the interrupt handler

	 * we iterate over the counters checking for interrupt source (the

	 * overflowing counter) and clear it.

	 *

	 * This should allow handling of non-unique interrupt for the counters.

/*

 * CCI-500/CCI-550 has advanced power saving policies, which could gate the

 * clocks to the PMU counters, which makes the writes to them ineffective.

 * The only way to write to those counters is when the global counters

 * are enabled and the particular counter is enabled.

 *

 * So we do the following :

 *

 * 1) Disable all the PMU counters, saving their current state

 * 2) Enable the global PMU profiling, now that all counters are

 *    disabled.

 *

 * For each counter to be programmed, repeat steps 3-7:

 *

 * 3) Write an invalid event code to the event control register for the

      counter, so that the counters are not modified.

 * 4) Enable the counter control for the counter.

 * 5) Set the counter value

 * 6) Disable the counter

 * 7) Restore the event in the target counter

 *

 * 8) Disable the global PMU.

 * 9) Restore the status of the rest of the counters.

 *

 * We choose an event which for CCI-5xx is guaranteed not to count.

 * We use the highest possible event code (0x1f) for the master interface 0.

	/*

	 * Now that all the counters are disabled, we can safely turn the PMU on,

	 * without syncing the status of the counters

 CONFIG_ARM_CCI5xx_PMU */

	/*

	 * The CCI PMU counters have a period of 2^32. To account for the

	 * possiblity of extreme interrupt latency we program for a period of

	 * half that. Hopefully we can handle the interrupt before another 2^31

	 * events occur and the counter overtakes its previous value.

	/*

	 * CCI PMU uses PERF_HES_ARCH to keep track of the counters, whose

	 * values needs to be sync-ed with the s/w state before the PMU is

	 * enabled.

	 * Mark this counter for sync.

 Disable the PMU while we walk through the counters */

	/*

	 * Iterate over counters and update the corresponding perf events.

	 * This should work regardless of whether we have per-counter overflow

	 * interrupt or a combined overflow interrupt.

 Did this counter overflow? */

 Enable the PMU and sync possibly overflowed counters */

/*

 * Check if the idx represents a non-programmable counter.

 * All the fixed event counters are mapped before the programmable

 * counters.

	/*

	 * To handle interrupt latency, we always reprogram the period

	 * regardlesss of PERF_EF_RELOAD.

 Configure the counter unless you are counting a fixed event */

	/*

	 * We always reprogram the counter, so ignore PERF_EF_UPDATE. See

	 * cci_pmu_start()

 If we don't have a space for the counter then finish early. */

 Propagate our changes to the userspace mapping. */

	/*

	 * Reject groups spanning multiple HW PMUs (e.g. CPU + CCI). The

	 * core perf code won't check that the pmu->ctx == leader->ctx

	 * until after pmu->event_init(event).

		/*

		 * Initialise the fake PMU. We only need to populate the

		 * used_mask for the purposes of validation.

	/*

	 * We don't assign an index until we actually place the event onto

	 * hardware. Use -1 to signify that we haven't decided where to put it

	 * yet.

	/*

	 * Store the event encoding into the config_base field.

 Shared by all CPUs, no meaningful state to sample */

	/*

	 * Following the example set by other "uncore" PMUs, we accept any CPU

	 * and rewrite its affinity dynamically rather than having perf core

	 * handle cpu == -1 and pid == -1 for this case.

	 *

	 * The perf core will pin online CPUs for the duration of this call and

	 * the event being installed into its context, so the PMU's CPU can't

	 * change under our feet.

 Filled in cci_pmu_init_attrs */

 Filled in cci_pmu_init_attrs */

 Cycle counter */

 Cycle counter */

	/*

	 * All allocations are devm_* hence we don't have to free

	 * them explicitly on an error, as it would end up in driver

	 * detach.

	/*

	 * CCI PMU has one overflow interrupt per counter; but some may be tied

	 * together to a common interrupt.

	/*

	 * Ensure that the device tree has as many interrupts as the number

	 * of counters.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright 2017 NXP

 * Copyright 2016 Freescale Semiconductor, Inc.

 AXI_MASKING(MSB 16bits) + AXI_ID(LSB 16bits) */

 DDR Perf hardware feature */

 support AXI ID filter */

 support enhanced AXI ID filter */

 quirks needed for different DDR Perf core */

 system PMU identifier for userspace */

 sentinel */ }

	/*

	 * Always map cycle event to counter 0

	 * Cycles counter is dedicated for cycle event

	 * can't used for the other events

	/*

	 * return bytes instead of bursts from ddr transaction for

	 * axid-read and axid-write event if PMU core supports enhanced

	 * filter.

	/*

	 * We must NOT create groups containing mixed PMUs, although software

	 * events are acceptable (for example to create a CCN group

	 * periodically read when a hrtimer aka cpu-clock leader triggers).

		/*

		 * cycle counter is special which should firstly write 0 then

		 * write 1 into CLEAR bit to clear it. Other counters only

		 * need write 0 into CLEAR bit and it turns out to be 1 by

		 * hardware. Below enable flow is harmless for all counters.

 Disable counter */

	/*

	 * For legacy SoCs: event counter continue counting when overflow,

	 *                  no need to clear the counter.

	 * For new SoCs: event counter stop counting when overflow, need

	 *               clear counter to let it count again.

 clear counter every time for both cycle counter and event counter */

 revert axi id masking(axi_mask) value */

 enable cycle counter if cycle is not active event list */

 all counter will stop if cycle counter disabled */

	/*

	 * When the cycle counter overflows, all counters are stopped,

	 * and an IRQ is raised. If any other counter overflows, it

	 * continues counting, and no IRQ is raised. But for new SoCs,

	 * such as i.MX8MP, event counter would stop when overflow, so

	 * we need use cycle counter to stop overflow of event counter.

	 *

	 * Cycles occur at least 4 times as often as other events, so we

	 * can update all events on a cycle counter overflow and not

	 * lose events.

	 *

 Register the pmu instance for cpu hotplug */

 Request irq */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ARM DMC-620 memory controller PMU driver

 *

 * Copyright (C) 2020 Ampere Computing LLC.

/*

 * The PMU registers start at 0xA00 in the DMC-620 memory map, and these

 * offsets are relative to that base.

 *

 * Each counter has a group of control/value registers, and the

 * DMC620_PMU_COUNTERn offsets are within a counter group.

 *

 * The counter registers groups start at 0xA10.

 Offset of the registers for a given counter, relative to 0xA00 */

	/*

	 * We put all clkdiv2 and clk counters to a same array.

	 * The first DMC620_PMU_CLKDIV2_MAX_COUNTERS bits belong to

	 * clkdiv2 counters, the last DMC620_PMU_CLK_MAX_COUNTERS

	 * belong to clk counters.

 clkdiv2 events list */

 clk events list */

 User ABI */

 The counters are all in use. */

 We may also be called from the irq handler */

		/*

		 * HW doesn't provide a control to atomically disable all counters.

		 * To prevent race condition (overflow happens while clearing status register),

		 * disable all events before continuing

 Pick one CPU to be the preferred one to use */

	/*

	 * DMC 620 PMUs are shared across all cpus and cannot

	 * support task bound and sampling events.

	/*

	 * Many perf core operations (eg. events rotation) operate on a

	 * single CPU context. This is obvious for CPU PMUs, where one

	 * expects the same sets of events being observed on all CPUs,

	 * but can lead to issues for off-core PMUs, where each

	 * event could be theoretically assigned to a different CPU. To

	 * mitigate this, we enforce CPU assignment to one, selected

	 * processor.

	/*

	 * We can't atomically disable all HW counters so only one event allowed,

	 * although software events are acceptable.

 We're only reading, but this isn't the place to be involving RCU */

 Make sure device is reset before enabling interrupt */

 perf will synchronise RCU before devres can free dmc620_pmu */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ARM DynamIQ Shared Unit (DSU) PMU driver

 *

 * Copyright (C) ARM Limited, 2017.

 *

 * Based on ARM CCI-PMU, ARMv8 PMU-v3 drivers.

 PMU event codes */

/*

 * We use the index of the counters as they appear in the counter

 * bit maps in the PMU registers (e.g CLUSTERPMSELR).

 * i.e,

 *	counter 0	- Bit 0

 *	counter 1	- Bit 1

 *	...

 *	Cycle counter	- Bit 31

 All event counters are 32bit, with a 64bit Cycle counter */

/*

 * struct dsu_pmu	- DSU PMU descriptor

 *

 * @pmu_lock		: Protects accesses to DSU PMU register from normal vs

 *			  interrupt handler contexts.

 * @hw_events		: Holds the event counter state.

 * @associated_cpus	: CPUs attached to the DSU.

 * @active_cpu		: CPU to which the PMU is bound for accesses.

 * @cpuhp_node		: Node for CPU hotplug notifier link.

 * @num_counters	: Number of event counters implemented by the PMU,

 *			  excluding the cycle counter.

 * @irq			: Interrupt line for counter overflow.

 * @cpmceid_bitmap	: Bitmap for the availability of architected common

 *			  events (event_code < 0x40).

 We may also be called from the irq handler */

/**

 * dsu_pmu_set_event_period: Set the period for the counter.

 *

 * All DSU PMU event counters, except the cycle counter are 32bit

 * counters. To handle cases of extreme interrupt latency, we program

 * the counter with half of the max count for the counters.

 We always reprogram the counter */

 If no counters are added, skip enabling the PMU */

 Reject groups spanning multiple HW PMUs. */

/*

 * Make sure the group of events can be scheduled at once

 * on the PMU.

 We don't support sampling */

 We cannot support task bound events */

	/*

	 * Choose the current active CPU to read the events. We don't want

	 * to migrate the event contexts, irq handling etc to the requested

	 * CPU. As long as the requested CPU is within the same DSU, we

	 * are fine.

	/*

	 * Initialise the number of counters to -1, until we probe

	 * the real number on a connected CPU.

/**

 * dsu_pmu_dt_get_cpus: Get the list of CPUs in the cluster

 * from device tree.

		/*

		 * We have to ignore the failures here and continue scanning

		 * the list to handle cases where the nr_cpus could be capped

		 * in the running kernel.

/**

 * dsu_pmu_acpi_get_cpus: Get the list of CPUs in the cluster

 * from ACPI.

	/*

	 * A dsu pmu node is inside a cluster parent node along with cpu nodes.

	 * We need to find out all cpus that have the same parent with this pmu.

/*

 * dsu_pmu_probe_pmu: Probe the PMU details on a CPU in the cluster.

 We can only support up to 31 independent counters */

/*

 * dsu_pmu_init_pmu: Initialise the DSU PMU configurations if

 * we haven't done it already.

 Reset the interrupt overflow mask */

 If the PMU is already managed, there is nothing to do */

 If there are no active CPUs in the DSU, leave IRQ disabled */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *

 * Copyright (C) 2014 ARM Limited

 RN-D = RN-I + DVM */

 Pseudotype */

 Pseudoevent */

 See DT.dbg_id.num_watchpoints */

 See DT.dbg_id.num_pmucntr */

/*

 * Bit shifts and masks in these defines must be kept in sync with

 * arm_ccn_pmu_config_set() and CCN_FORMAT_ATTRs below!

/*

 * Events defined in TRM for MN, HN-I and SBSX are actually watchpoints set on

 * their ports in XP they are connected to. For the sake of usability they are

 * explicitly defined here (and translated into a relevant watchpoint in

 * arm_ccn_pmu_event_init()) so the user can easily request them without deep

 * knowledge of the flit format.

/*

 * RN-I & RN-D (RN-D = RN-I + DVM) nodes have different type ID depending

 * on configuration. One of them is picked to represent the whole group,

 * as they all share the same event types.

 Arguments required by an event */

 Populated in arm_ccn_init() */

/*

 * Default poll period is 10ms, which is way over the top anyway,

 * as in the worst case scenario (an event every cycle), with 1GHz

 * clocked bus, the smallest, 32 bit counter will overflow in

 * more than 4s.

 All RN-I and RN-D nodes have identical PMUs */

 Allocate the cycle counter */

 Allocate an event counter */

 Allocate an event source or a watchpoint */

	/*

	 * Many perf core operations (eg. events rotation) operate on a

	 * single CPU context. This is obvious for CPU PMUs, where one

	 * expects the same sets of events being observed on all CPUs,

	 * but can lead to issues for off-core PMUs, like CCN, where each

	 * event could be theoretically assigned to a different CPU. To

	 * mitigate this, we enforce CPU assignment to one, selected

	 * processor (the one described in the "cpumask" attribute).

 Validate node/xp vs topology */

 Validate event ID vs available for the type */

 Watchpoint-based event for a node is actually set on XP */

	/*

	 * We must NOT create groups containing mixed PMUs, although software

	 * events are acceptable (for example to create a CCN group

	 * periodically read when a hrtimer aka cpu-clock leader triggers).

 40 bit counter, can do snapshot and read in two parts */

 Nothing to do for cycle counter */

 Set the DT bus input, engaging the counter */

 Disable counting, setting the DT bus to pass-through mode */

 Direction (RX/TX), device (port) & virtual channel */

 Comparison values */

 Mask */

 These *_event_sel regs should be identical, but let's make sure... */

 Set the event id for the pre-allocated counter */

 Cycle counter requires no setup */

 Set the DT bus "distance" register */

	/*

	 * Pin the timer, so that the overflows are handled by the chosen

	 * event->cpu (this is the same one as presented in "cpumask"

	 * attribute).

 Initialize DT subsystem */

 Get a convenient /sys/event_source/devices/ name */

 Perf driver registration */

 No overflow interrupt? Have to use a timer instead. */

 Pick one CPU which we will use to collect data from CCN... */

 Also make sure that the overflow interrupt is handled by this CPU */

 This should be really handled by firmware... */

 PMU overflow is a special case */

 Have to read all err_sig_vals to clear them */

 Check if we can use the interrupt */

 Can set 'disable' bits, so can acknowledge interrupts */

 Build topology */

 SPDX-License-Identifier: GPL-2.0

/*

 * CAVIUM THUNDERX2 SoC PMU UNCORE

 * Copyright (C) 2018 Cavium Inc.

 * Author: Ganapatrao Kulkarni <gkulkarni@cavium.com>

/* Each ThunderX2(TX2) Socket has a L3C and DMC UNCORE PMU device.

 * Each UNCORE PMU device consists of 4 independent programmable counters.

 * Counters are 32 bit and do not support overflow interrupt,

 * they need to be sampled before overflow(i.e, at every 2 seconds).

 /* 1 byte per counter(4 counters).

  * Event id is encoded in bits [5:1] of a byte,

 bits[3:0] to select counters, are indexed from 8 to 15. */

 L3C event IDs */

 DMC event IDs */

/*

 * Each socket has 3 uncore devices associated with a PMU. The DMC and

 * L3C have 4 32-bit counters and the CCPI2 has 8 64-bit counters.

/*

 * sysfs event attributes

/*

 * sysfs cpumask attributes

/*

 * Per PMU device attribute groups

 counter ctrl/data reg offset at 8 */

 counter data reg offset at 0xc */

 event id encoded in bits [07:03] */

	/* enable and start counters.

	 * 8 bits for each counter, bits[05:01] of a counter to set event type.

 clear event type(bits[05:01]) to stop counter */

	/* Bit [09:00] to set event id.

	 * Bits [10], set level to rising edge.

	 * Bits [11], set type to edge sensitive.

 reset[4], enable[0] and start[1] counters */

 disable and stop counter */

 handles rollover of 32 bit counter */

 DMC event data_transfers granularity is 16 Bytes, convert it to 64 */

	/* L3C and DMC has 16 and 8 interleave channels respectively.

	 * The sampled value is for channel 0 and multiplied with

	 * prorate_factor to get the count for a device.

 Reject groups spanning multiple HW PMUs. */

/*

 * Make sure the group of events can be scheduled at once

 * on the PMU.

	/*

	 * If the group requires more counters than the HW has,

	 * it cannot ever be scheduled.

 Test the event attr type check for PMU enumeration */

	/*

	 * SOC PMU counters are shared across all cores.

	 * Therefore, it does not support per-process mode.

	 * Also, it does not support event sampling mode.

 store event id */

 Validate the group */

 No hrtimer needed for CCPI2, 64-bit counters */

 Start timer for first event */

 Allocate a free counter */

 set counter control and data registers base address */

 clear the assigned counter */

 Perf event registration */

 register hotplug callback for the pmu */

 Add to list */

 CCPI2 has 8 counters */

 Can't add the PMU device, abort */

	/* Pick this CPU, If there is no CPU/PMU association and both are

	 * from same node.

 Walk through the tree for all PMU UNCORE devices */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Driver for the L3 cache PMUs in Qualcomm Technologies chips.

 *

 * The driver supports a distributed cache architecture where the overall

 * cache for a socket is comprised of multiple slices each with its own PMU.

 * Access to each individual PMU is provided even though all CPUs share all

 * the slices. User space needs to aggregate to individual counts to provide

 * a global picture.

 *

 * See Documentation/admin-guide/perf/qcom_l3_pmu.rst for more details.

 *

 * Copyright (c) 2015-2017, The Linux Foundation. All rights reserved.

/*

 * General constants

 Number of counters on each PMU */

 Mask for the event type field within perf_event_attr.config and EVTYPE reg */

/*

 * Bit position of the 'long counter' flag within perf_event_attr.config.

 * Reserve some space between the event type and this flag to allow expansion

 * in the event type field.

/*

 * Register offsets

 Perfmon registers */

 Basic counter registers */

/*

 * Bit field definitions

 L3_HML3_PM_CR */

 L3_HML3_PM_XCNTCTL/L3_HML3_PM_CNTCTLx */

 L3_HML3_PM_EVTYPEx */

 Reset value for all the filter registers */

 L3_M_BC_CR */

 L3_M_BC_SATROLL_CR */

 L3_M_BC_CNTENSET */

 L3_M_BC_CNTENCLR */

 L3_M_BC_INTENSET */

 L3_M_BC_INTENCLR */

 L3_M_BC_GANG */

 L3_M_BC_OVSR */

 L3_M_BC_IRQCTL */

/*

 * Events

/*

 * Decoding of settings from perf_event_attr

 *

 * The config format for perf events is:

 * - config: bits 0-7: event type

 *           bit  32:  HW counter size requested, 0: 32 bits, 1: 64 bits

/*

 * Main PMU, inherits from the core perf PMU type

/*

 * Type used to group hardware counter operations

 *

 * Used to implement two types of hardware counters, standard (32bits) and

 * long (64bits). The hardware supports counter chaining which we use to

 * implement long counters. This support is exposed via the 'lc' flag field

 * in perf_event_attr.config.

 Called to start event monitoring */

 Called to stop event monitoring */

 Called to update the perf_event */

/*

 * Implementation of long counter operations

 *

 * 64bit counters are implemented by chaining two of the 32bit physical

 * counters. The PMU only supports chaining of adjacent even/odd pairs

 * and for simplicity the driver always configures the odd counter to

 * count the overflows of the lower-numbered even counter. Note that since

 * the resulting hardware counter is 64bits no IRQs are required to maintain

 * the software counter which is also 64bits.

 Set the odd counter to count the overflows of the even counter */

 Initialize the hardware counters and reset prev_count*/

	/*

	 * Set the event types, the upper half must use zero and the lower

	 * half the actual event type

 Finally, enable the counters */

 Disable the counters */

 Disable chaining */

/*

 * Implementation of standard counter operations

 *

 * 32bit counters use a single physical counter and a hardware feature that

 * asserts the overflow IRQ on the toggling of the most significant bit in

 * the counter. This feature allows the counters to be left free-running

 * without needing the usual reprogramming required to properly handle races

 * during concurrent calls to update.

 Set the counter to assert the overflow IRQ on MSB toggling */

 Initialize the hardware counter and reset prev_count*/

 Set the event type */

 Enable interrupt generation by this counter */

 Finally, enable the counter */

 Disable the counter */

 Disable interrupt generation by this counter */

 Set the counter to not assert the overflow IRQ on MSB toggling */

 Retrieve the appropriate operations for the given event */

/*

 * Top level PMU functions.

	/*

	 * Use writel for the first programming command to ensure the basic

	 * counter unit is stopped before proceeding

	/*

	 * Use writel here to ensure all programming commands are done

	 *  before proceeding

 Read the overflow status register */

 Clear the bits we read on the overflow status register */

		/*

		 * Since the IRQ is not enabled for events using long counters

		 * we should never see one of those here, however, be consistent

		 * and use the ops indirections like in the other operations.

/*

 * Implementation of abstract pmu functionality required by

 * the core perf events code.

 Ensure the other programming commands are observed before enabling */

 Ensure the basic counter unit is stopped before proceeding */

/*

 * We must NOT create groups containing events from multiple hardware PMUs,

 * although mixing different software and hardware PMUs is allowed.

	/*

	 * If the group requires more counters than the HW has, it

	 * cannot ever be scheduled.

	/*

	 * Is the event for this PMU?

	/*

	 * Sampling not supported since these events are not core-attributable.

	/*

	 * Task mode not available, we run the counters as socket counters,

	 * not attributable to any CPU and therefore cannot attribute per-task.

 Validate the group */

	/*

	 * Many perf core operations (eg. events rotation) operate on a

	 * single CPU context. This is obvious for CPU PMUs, where one

	 * expects the same sets of events being observed on all CPUs,

	 * but can lead to issues for off-core PMUs, like this one, where

	 * each event could be theoretically assigned to a different CPU.

	 * To mitigate this, we enforce CPU assignment to one designated

	 * processor (the one described in the "cpumask" attribute exported

	 * by the PMU device). perf user space tools honor this and avoid

	 * opening more than one copy of the events.

	/*

	 * Try to allocate a counter.

 The counters are all in use. */

 Propagate changes to the userspace mapping. */

 Stop and clean up */

 Propagate changes to the userspace mapping. */

/*

 * Add sysfs attributes

 *

 * We export:

 * - formats, used by perf user space and other tools to configure events

 * - events, used by perf user space and other tools to create events

 *   symbolically, e.g.:

 *     perf stat -a -e l3cache_0_0/event=read-miss/ ls

 *     perf stat -a -e l3cache_0_0/event=0x21/ ls

 * - cpumask, used by perf user space and other tools to know on which CPUs

 *   to open the events

 formats */

 events */

 cpumask */

/*

 * Per PMU device attribute groups

/*

 * Probing functions and data.

 If there is not a CPU/PMU association pick this CPU */

 Initialize the PMU data structures */

 Add this instance to the list used by the offline callback */

 Install a hook to update the reader CPU in case it goes offline */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ACPI probing code for ARM performance counters.

 *

 * Copyright (C) 2017 ARM Ltd.

	/*

	 * Per the ACPI spec, the MADT cannot describe a PMU that doesn't

	 * have an interrupt. QEMU advertises this by using a GSI of zero,

	 * which is not known to be valid on any hardware despite being

	 * valid per the spec. Take the pragmatic approach and reject a

	 * GSI of zero for now.

	/*

	 * Helpfully, the MADT GICC doesn't have a polarity flag for the

	 * "performance interrupt". Luckily, on compliant GICs the polarity is

	 * a fixed value in HW (for both SPIs and PPIs) that we cannot change

	 * from SW.

	 *

	 * Here we pass in ACPI_ACTIVE_HIGH to keep the core code happy. This

	 * may not match the real polarity, but that should not matter.

	 *

	 * Other interrupt controllers are not supported with ACPI.

 irq */

/*

 * For lack of a better place, hook the normal PMU MADT walk

 * and create a SPE device if we detect a recent MADT with

 * a homogeneous PPI mapping.

	/*

	 * Sanity check all the GICC tables for the same interrupt number.

	 * For now, we only support homogeneous ACPI/SPE machines.

 CONFIG_ARM_SPE_PMU */

		/*

		 * Log and request the IRQ so the core arm_pmu code can manage

		 * it. We'll have to sanity-check IRQs later when we associate

		 * them with their PMUs.

		/*

		 * Blat all copies of the IRQ so that we only unregister the

		 * corresponding GSI once (e.g. when we have PPIs).

/*

 * Check whether the new IRQ is compatible with those already associated with

 * the PMU (e.g. we don't have mismatched PPIs).

/*

 * This must run before the common arm_pmu hotplug logic, so that we can

 * associate a CPU and its interrupt before the common code tries to manage the

 * affinity and so on.

 *

 * Note that hotplug events are serialized, so we cannot race with another CPU

 * coming up. The perf core won't open events while a hotplug event is in

 * progress.

 If we've already probed this CPU, we have nothing to do */

	/*

	 * Ideally, we'd probe the PMU here when we find the first matching

	 * CPU. We can't do that for several reasons; see the comment in

	 * arm_pmu_acpi_init().

	 *

	 * So for the time being, we're done.

	/*

	 * Initialise and register the set of PMUs which we know about right

	 * now. Ideally we'd do this in arm_pmu_acpi_cpu_starting() so that we

	 * could handle late hotplug, but this may lead to deadlock since we

	 * might try to register a hotplug notifier instance from within a

	 * hotplug notifier.

	 *

	 * There's also the problem of having access to the right init_fn,

	 * without tying this too deeply into the "real" PMU driver.

	 *

	 * For the moment, as with the platform/DT case, we need at least one

	 * of a PMU's CPUs to be online at probe time.

 PMU not handled by this driver, or not present */

 SPDX-License-Identifier: GPL-2.0

/*

 * This driver adds support for perf events to use the Performance

 * Monitor Counter Groups (PMCG) associated with an SMMUv3 node

 * to monitor that node.

 *

 * SMMUv3 PMCG devices are named as smmuv3_pmcg_<phys_addr_page> where

 * <phys_addr_page> is the physical page address of the SMMU PMCG wrapped

 * to 4K boundary. For example, the PMCG at 0xff88840000 is named

 * smmuv3_pmcg_ff88840

 *

 * Filtering by stream id is done by specifying filtering parameters

 * with the event. options are:

 *   filter_enable    - 0 = no filtering, 1 = filtering enabled

 *   filter_span      - 0 = exact match, 1 = pattern match

 *   filter_stream_id - pattern to filter against

 *

 * To match a partial StreamID where the X most-significant bits must match

 * but the Y least-significant bits might differ, STREAMID is programmed

 * with a value that contains:

 *  STREAMID[Y - 1] == 0.

 *  STREAMID[Y - 2:0] == 1 (where Y > 1).

 * The remainder of implemented bits of STREAMID (X bits, from bit Y upwards)

 * contain a value to match from the corresponding bits of event StreamID.

 *

 * Example: perf stat -e smmuv3_pmcg_ff88840/transaction,filter_enable=1,

 *                    filter_span=1,filter_stream_id=0x42/ -a netperf

 * Applies filter pattern 0x42 to transaction events, which means events

 * matching stream ids 0x42 and 0x43 are counted. Further filtering

 * information is available in the SMMU documentation.

 *

 * SMMU events are not attributable to a CPU, so task mode and sampling

 * are not supported.

 MSI config fields */

 handle overflow. */

		/*

		 * On platforms that require this quirk, if the counter starts

		 * at < half_counter value and wraps, the current logic of

		 * handling the overflow may not work. It is expected that,

		 * those platforms will have full 64 counter bits implemented

		 * so that such a possibility is remote(eg: HiSilicon HIP08).

		/*

		 * We limit the max period to half the max counter value

		 * of the counter size, so that even in the case of extreme

		 * interrupt latency the counter will (hopefully) not wrap

		 * past its initial value.

	/*

	 * Per-counter filtering, or scheduling the first globally-filtered

	 * event into an empty PMU so idx == 0 and it works out equivalent.

 Otherwise, must match whatever's currently scheduled */

 The counters are all in use. */

/*

 * Implementation of abstract pmu functionality required by

 * the core perf events code.

 Verify specified event is supported on this PMU */

 Don't allow groups with mixed PMUs, except for s/w events */

	/*

	 * Ensure all events are on the same cpu so all events are in the

	 * same cpu context, to avoid races on pmu_enable etc.

 As the counter gets updated on _start, ignore PERF_EF_UPDATE */

 Propagate changes to the userspace mapping. */

 cpumask */

 Events */

 Formats */

/*

 * Generic device handlers

 Clear MSI address reg */

 MSI supported or not */

 Add callback to free MSIs on teardown */

 Disable counter and interrupt */

 HiSilicon Erratum 162001800 */

 Determine if page 1 is present */

 Pick one CPU to be the preferred one to use */

 SPDX-License-Identifier: GPL-2.0

 Copyright (C) 2016-2020 Arm Limited

 CMN-600 Coherent Mesh Network PMU driver

 Common register stuff */

 The CFG node has one other useful purpose */

 PMU registers occupy the 3rd 4KB page of each node's 16KB space */

 For most nodes, this is all there is */

 DTMs live in the PMU space of XP registers */

 The DTC node is where the magic happens */

 DTC counters are paired in 64-bit registers on a 16-byte stride. Yuck */

/*

 * Even in the worst case a DTC counter can't wrap in fewer than 2^42 cycles,

 * so throwing away one bit to make overflow handling easy is no big deal.

 Similarly for the 40-bit cycle counter */

 Event attributes */

 Made-up event IDs for watchpoint direction */

 r0px probably don't exist in silicon, thankfully */

 Not a real node type */

 Device node */

 DN/HN-F/CXHA */

 XP */

 Watchpoints aren't nodes */

 Revision-specific differences */

 Good thing there are only 3 fundamental XP events... */

	/*

	 * DVM node events conflict with HN-I events in the equivalent PMU

	 * slot, but our lazy short-cut of using the DTM counter index for

	 * the PMU index as well happens to avoid that by construction.

 We treat watchpoints as a special made-up class of XP events */

 DTC events (i.e. cycles) already have everything they need */

 For watchpoints we need the actual XP node here */

 ...and we need a "real" direction */

	/*

	 * By assuming events count in all DTC domains, we cunningly avoid

	 * needing to know anything about how XPs are assigned to domains.

 Grab a free global counter first... */

 ...then the local counters to feed it. */

 Go go go! */

/*

 * We stop the PMU for both add and read, to avoid skew across DTM counters.

 * In theory we could use snapshots to read without stopping, but then it

 * becomes a lot trickier to deal with overlow and racing against interrupts,

 * plus it seems they don't work properly on some hardware anyway :(

 We can reasonably accommodate DTCs of the same CMN sharing IRQs */

 isn't C great? */

 We do at least know that a DTC's XP must be in that DTC's domain */

 To the PMU, RN-Ds don't add anything over RN-Is, so smoosh them together */

 Pass 1: visit the XPs, enumerate their children */

 Cheeky +1 to help terminate pointer-based iteration */

 Pass 2: now we can actually populate the nodes */

		/*

		 * Thanks to the order in which XP logical IDs seem to be

		 * assigned, we can handily infer the mesh X dimension by

		 * looking out for the XP at (0,1) without needing to know

		 * the exact node ID format, which we can later derive.

			/*

			 * Don't even try to touch anything external, since in general

			 * we haven't a clue how to power up arbitrary CHI requesters.

			 * As of CMN-600r1 these could only be RN-SAMs or CXLAs,

			 * neither of which have any PMU events anyway.

			 * (Actually, CXLAs do seem to have grown some events in r1p2,

			 * but they don't go to regular XP DTMs, and they depend on

			 * secure configuration which we can't easily deal with)

 These guys have PMU events */

 Nothing to see here */

 Something has gone horribly wrong */

 Correct for any nodes we skipped */

	/*

	 * If mesh_x wasn't set during discovery then we never saw

	 * an XP at (0,1), thus we must have an Nx1 configuration.

	/*

	 * Note that devm_ioremap_resource() is dumb and won't let the platform

	 * device claim cfg when the ACPI companion device has already claimed

	 * root within it. But since they *are* already both claimed in the

	 * appropriate name, we don't really need to do it again here anyway.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * HiSilicon SoC DDRC uncore Hardware event counters support

 *

 * Copyright (C) 2017 HiSilicon Limited

 * Author: Shaokun Zhang <zhangshaokun@hisilicon.com>

 *         Anurup M <anurup.m@huawei.com>

 *

 * This code is based on the uncore PMUs like arm-cci and arm-ccn.

 DDRC register definition in v1 */

 DDRC register definition in v2 */

 DDRC has 8-counters */

/*

 * For PMU v1, there are eight-events and every event has been mapped

 * to fixed-purpose counters which register offset is not consistent.

 * Therefore there is no write event type and we assume that event

 * code (0 to 7) is equal to counter index in PMU driver.

/*

 * Select the counter register offset using the counter index.

 * In PMU v1, there are no programmable counter, the count

 * is read form the statistics counter register itself.

/*

 * For DDRC PMU v1, event has been mapped to fixed-purpose counter by hardware,

 * so there is no need to write event type, while it is programmable counter in

 * PMU v2.

 Set perf_enable in DDRC_PERF_CTRL to start event counting */

 Clear perf_enable in DDRC_PERF_CTRL to stop event counting */

 Set counter index(event code) in DDRC_EVENT_CTRL register */

 Clear counter index(event code) in DDRC_EVENT_CTRL register */

 For DDRC PMU, we use event code as counter index */

 Write 0 to enable interrupt */

 Write 1 to mask interrupt */

	/*

	 * Use the SCCL_ID and DDRC channel ID to identify the

	 * DDRC PMU, while SCCL_ID is in MPIDR[aff2].

 DDRC PMUs only share the same SCCL */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * HiSilicon SoC L3C uncore Hardware event counters support

 *

 * Copyright (C) 2017 HiSilicon Limited

 * Author: Anurup M <anurup.m@huawei.com>

 *         Shaokun Zhang <zhangshaokun@hisilicon.com>

 *

 * This code is based on the uncore PMUs like arm-cci and arm-ccn.

 L3C register definition */

/*

 * If the HW version only supports a 48-bit counter, then

 * bits [63:48] are reserved, which are Read-As-Zero and

 * Writes-Ignored.

 L3C has 8-counters */

 Set request-type for tracetag */

 Enable request-tracetag statistics */

 Clear request-type */

 Disable request-tracetag statistics */

	/*

	 * Select the appropriate datasource register(L3C_DATSRC_TYPE0/1).

	 * There are 2 datasource ctrl register for the 8 hardware counters.

	 * Datasrc is 8-bits and for the former 4 hardware counters,

	 * L3C_DATSRC_TYPE0 is chosen. For the latter 4 hardware counters,

	 * L3C_DATSRC_TYPE1 is chosen.

 Config and enable core information */

 Enable core-tracetag statistics */

 Clear core information */

 Disable core-tracetag statistics */

/*

 * Select the counter register offset using the counter index

	/*

	 * Select the appropriate event select register(L3C_EVENT_TYPE0/1).

	 * There are 2 event select registers for the 8 hardware counters.

	 * Event code is 8-bits and for the former 4 hardware counters,

	 * L3C_EVENT_TYPE0 is chosen. For the latter 4 hardware counters,

	 * L3C_EVENT_TYPE1 is chosen.

 Write event code to L3C_EVENT_TYPEx Register */

	/*

	 * Set perf_enable bit in L3C_PERF_CTRL register to start counting

	 * for all enabled counters.

	/*

	 * Clear perf_enable bit in L3C_PERF_CTRL register to stop counting

	 * for all enabled counters.

 Enable counter index in L3C_EVENT_CTRL register */

 Clear counter index in L3C_EVENT_CTRL register */

 Write 0 to enable interrupt */

 Write 1 to mask interrupt */

	/*

	 * Use the SCCL_ID and CCL_ID to identify the L3C PMU, while

	 * SCCL_ID is in MPIDR[aff2] and CCL_ID is in MPIDR[aff1].

	/*

	 * CCL_ID is used to identify the L3C in the same SCCL which was

	 * used _UID by mistake.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * HiSilicon SLLC uncore Hardware event counters support

 *

 * Copyright (C) 2020 HiSilicon Limited

 * Author: Shaokun Zhang <zhangshaokun@hisilicon.com>

 *

 * This code is based on the uncore PMUs like arm-cci and arm-ccn.

 SLLC register definition */

 Enable the tgtid */

 Disable the tgtid */

 Enable the srcid */

 Disable the srcid */

	/*

	 * Select the appropriate event select register(SLLC_EVENT_TYPE0/1).

	 * There are 2 event select registers for the 8 hardware counters.

	 * Event code is 8-bits and for the former 4 hardware counters,

	 * SLLC_EVENT_TYPE0 is chosen. For the latter 4 hardware counters,

	 * SLLC_EVENT_TYPE1 is chosen.

 Write event code to SLLC_EVENT_TYPEx Register */

 Write 0 to enable interrupt */

 Write 1 to mask interrupt */

	/*

	 * Use the SCCL_ID and the index ID to identify the SLLC PMU,

	 * while SCCL_ID is from MPIDR_EL1 by CPU.

 SLLC PMUs only share the same SCCL */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * HiSilicon PA uncore Hardware event counters support

 *

 * Copyright (C) 2020 HiSilicon Limited

 * Author: Shaokun Zhang <zhangshaokun@hisilicon.com>

 *

 * This code is based on the uncore PMUs like arm-cci and arm-ccn.

 PA register definition */

	/*

	 * Select the appropriate event select register(PA_EVENT_TYPE0/1).

	 * There are 2 event select registers for the 8 hardware counters.

	 * Event code is 8-bits and for the former 4 hardware counters,

	 * PA_EVENT_TYPE0 is chosen. For the latter 4 hardware counters,

	 * PA_EVENT_TYPE1 is chosen.

 Write event code to pa_EVENT_TYPEx Register */

 Enable counter index in PA_EVENT_CTRL register */

 Clear counter index in PA_EVENT_CTRL register */

 Write 0 to enable interrupt */

 Write 1 to mask interrupt */

	/*

	 * Use the SCCL_ID and the index ID to identify the PA PMU,

	 * while SCCL_ID is the nearst SCCL_ID from this SICL and

	 * CPU core is chosen from this SCCL to manage this PMU.

	/*

	 * PA is attached in SICL and the CPU core is chosen to manage this

	 * PMU which is the nearest SCCL, while its SCCL_ID is greater than

	 * one with the SICL_ID.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * HiSilicon SoC Hardware event counters support

 *

 * Copyright (C) 2017 HiSilicon Limited

 * Author: Anurup M <anurup.m@huawei.com>

 *         Shaokun Zhang <zhangshaokun@hisilicon.com>

 *

 * This code is based on the uncore PMUs like arm-cci and arm-ccn.

/*

 * PMU format attributes

/*

 * PMU event attributes

/*

 * sysfs cpumask attributes. For uncore PMU, we only have a single CPU to show

 Include count for the event */

		/*

		 * We must NOT create groups containing mixed PMUs, although

		 * software events are acceptable

 Increment counter for the leader */

 Increment counter for each sibling */

 The group can not count events more than the counters in the HW */

	/*

	 * Find the counter index which overflowed if the bit was set

	 * and handle it.

 Write 1 to clear the IRQ status flag */

 Get the corresponding event struct */

	/*

	 * We do not support sampling as the counters are all

	 * shared by all CPU cores in a CPU die(SCCL). Also we

	 * do not support attach to a task(per-process mode)

	/*

	 *  The uncore counters not specific to any CPU, so cannot

	 *  support per-task

	/*

	 * Validate if the events in group does not exceed the

	 * available counters in hardware.

	/*

	 * We don't assign an index until we actually place the event onto

	 * hardware. Use -1 to signify that we haven't decided where to put it

	 * yet.

 Enforce to use the same CPU for all events in this PMU */

/*

 * Set the counter to count the event that we're interested in,

 * and enable interrupt and counter.

/*

 * Disable counter and interrupt.

	/*

	 * The HiSilicon PMU counters support 32 bits or 48 bits, depending on

	 * the PMU. We reduce it to 2^(counter_bits - 1) to account for the

	 * extreme interrupt latency. So we could hopefully handle the overflow

	 * interrupt before another 2^(counter_bits - 1) events occur and the

	 * counter overtakes its previous value.

 Write start value to the hardware event counter */

 Read the count from the counter register */

	/*

	 * compute the delta

 Read hardware counter and update the perf counter statistics */

 Get an available counter index for counting */

 Read hardware counter and update the perf counter statistics */

/*

 * The Super CPU Cluster (SCCL) and CPU Cluster (CCL) IDs can be

 * determined from the MPIDR_EL1, but the encoding varies by CPU:

 *

 * - For MT variants of TSV110:

 *   SCCL is Aff2[7:3], CCL is Aff2[2:0]

 *

 * - For other MT parts:

 *   SCCL is Aff3[7:0], CCL is Aff2[7:0]

 *

 * - For non-MT parts:

 *   SCCL is Aff2[7:0], CCL is Aff1[7:0]

/*

 * Check whether the CPU is associated with this uncore PMU

 If CCL_ID is -1, the PMU only shares the same SCCL */

 If another CPU is already managing this PMU, simply return. */

 Use this CPU in cpumask for event counting */

 Overflow interrupt also should use the same CPU */

 Nothing to do if this CPU doesn't own the PMU */

 Give up ownership of the PMU */

 Choose a new CPU to migrate ownership of the PMU to */

 Use this CPU for event counting */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * HiSilicon SoC HHA uncore Hardware event counters support

 *

 * Copyright (C) 2017 HiSilicon Limited

 * Author: Shaokun Zhang <zhangshaokun@hisilicon.com>

 *         Anurup M <anurup.m@huawei.com>

 *

 * This code is based on the uncore PMUs like arm-cci and arm-ccn.

 HHA register definition */

/*

 * If the HW version only supports a 48-bit counter, then

 * bits [63:48] are reserved, which are Read-As-Zero and

 * Writes-Ignored.

 HHA PMU v1 has 16 counters and v2 only has 8 counters */

/*

 * Select the counter register offset using the counter index

 * each counter is 48-bits.

 Read 64 bits and like L3C, top 16 bits are RAZ */

 Write 64 bits and like L3C, top 16 bits are WI */

	/*

	 * Select the appropriate event select register(HHA_EVENT_TYPEx).

	 * There are 4 event select registers for the 16 hardware counters.

	 * Event code is 8-bits and for the first 4 hardware counters,

	 * HHA_EVENT_TYPE0 is chosen. For the next 4 hardware counters,

	 * HHA_EVENT_TYPE1 is chosen and so on.

 Write event code to HHA_EVENT_TYPEx register */

	/*

	 * Set perf_enable bit in HHA_PERF_CTRL to start event

	 * counting for all enabled counters.

	/*

	 * Clear perf_enable bit in HHA_PERF_CTRL to stop event

	 * counting for all enabled counters.

 Enable counter index in HHA_EVENT_CTRL register */

 Clear counter index in HHA_EVENT_CTRL register */

 Write 0 to enable interrupt */

 Write 1 to mask interrupt */

	/*

	 * Use SCCL_ID and UID to identify the HHA PMU, while

	 * SCCL_ID is in MPIDR[aff2].

	/*

	 * Early versions of BIOS support _UID by mistake, so we support

	 * both "hisilicon, idx-id" as preference, if available.

 HHA PMUs only share the same SCCL */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Driver for BCM6358 memory-mapped LEDs, based on leds-syscon.c

 *

 * Copyright 2015 Álvaro Fernández Rojas <noltari@gmail.com>

/**

 * struct bcm6358_led - state container for bcm6358 based LEDs

 * @cdev: LED class device for this LED

 * @mem: memory resource

 * @lock: memory lock

 * @pin: LED pin number

 * @active_low: LED is active low

 memory lock */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * LP5521/LP5523/LP55231/LP5562 Common Driver

 *

 * Copyright 2012 Texas Instruments

 *

 * Author: Milo(Woogyom) Kim <milo.kim@ti.com>

 *

 * Derived from leds-lp5521.c, leds-lp5523.c

 External clock rate */

 no error checking here because no ACK from the device after reset */

 handling firmware data is chip dependent */

 firmware should be released for other channel use */

 select the engine to be run */

 run or stop the selected engine */

 Keep enable down at least 1ms */

 500us abs min. */

	/*

	 * Exact value is not available. 10 - 20ms

	 * appears to be enough for reset.

 chip specific initialization */

 do not initialize channels that are not connected */

 setting led current at each channel */

 LP8501 specific */

 SPDX-License-Identifier: BSD-2-Clause OR GPL-2.0-or-later

/*

 * Dell Wyse 3020 a.k.a. "Ariel" Embedded Controller LED Driver

 *

 * Copyright (C) 2020 Lubomir Rintel

 SPDX-License-Identifier: GPL-2.0-only

/* Copyright (c) 2010, 2011, 2016 The Linux Foundation. All rights reserved.

 5 bits */

 4 bits */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  MEN 14F021P00 Board Management Controller (BMC) LEDs Driver.

 *

 *  This is the core LED driver of the MEN 14F021P00 BMC.

 *  There are four LEDs available which can be switched on and off.

 *  STATUS LED, HOT SWAP LED, USER LED 1, USER LED 2

 *

 *  Copyright (C) 2014 MEN Mikro Elektronik Nuernberg GmbH

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2006 - Florian Fainelli <florian@openwrt.org>

 *

 * Control the Cobalt Qube/RaQ front LED

 SPDX-License-Identifier: GPL-2.0

 Copyright 2015 Texas Instruments

 Copyright 2018 Sebastian Reichel

 Copyright 2018 Pavel Machek <pavel@ucw.cz>

 TI LMU LED common framework, based on previous work from

 Milo Kim <milo.kim@ti.com>

	/*

	 * Brightness register update

	 *

	 * 11 bit dimming: update LSB bits and write MSB byte.

	 *		   MSB brightness should be shifted.

	 *  8 bit dimming: write MSB byte.

 Find an approximate index by looking up the table */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *	LED driver for TI lp3952 controller

 *

 *	Copyright (C) 2016, DAQRI, LLC.

 *	Author: Tony Makkiel <tony.makkiel@daqri.com>

/*

 * Using Imax to control brightness. There are 4 possible

 * setting 25, 50, 75 and 100 % of Imax. Possible values are

 * values 0-4. 0 meaning turn off.

 Enable the LED in case it is not enabled already */

 Disable any LEDs on from any previous conf. */

 enable rgb patter, loop */

 Update Bit 6 (Active mode), Select both Led sets, Bit [1:0] */

 Set Cmd1 for RGB intensity,cmd and transition time */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * leds-lp3944.c - driver for National Semiconductor LP3944 Funlight Chip

 *

 * Copyright (C) 2009 Antonio Ospite <ospite@studenti.unina.it>

/*

 * I2C driver for National Semiconductor LP3944 Funlight Chip

 * http://www.national.com/pf/LP/LP3944.html

 *

 * This helper chip can drive up to 8 leds, with two programmable DIM modes;

 * it could even be used as a gpio expander but this driver assumes it is used

 * as a led controller.

 *

 * The DIM modes are used to set _blink_ patterns for leds, the pattern is

 * specified supplying two parameters:

 *   - period: from 0s to 1.6s

 *   - duty cycle: percentage of the period the led is on, from 0 to 100

 *

 * LP3944 can be found on Motorola A910 smartphone, where it drives the rgb

 * leds, the camera flash light and the displays backlights.

 Read Only Registers */

 LEDs 0-7 InputRegister (Read Only) */

 None (Read Only) */

 Frequency Prescaler 0 (R/W) */

 PWM Register 0 (R/W) */

 Frequency Prescaler 1 (R/W) */

 PWM Register 1 (R/W) */

 LEDs 0-3 Selector (R/W) */

 LEDs 4-7 Selector (R/W) */

/* These registers are not used to control leds in LP3944, they can store

 * arbitrary values which the chip will ignore.

 period in ms */

 duty cycle is a percentage */

 Saved data */

/**

 * lp3944_dim_set_period() - Set the period for DIM status

 *

 * @client: the i2c client

 * @dim: either LP3944_DIM0 or LP3944_DIM1

 * @period: period of a blink, that is a on/off cycle, expressed in ms.

 Convert period to Prescaler value */

/**

 * lp3944_dim_set_dutycycle - Set the duty cycle for DIM status

 *

 * @client: the i2c client

 * @dim: either LP3944_DIM0 or LP3944_DIM1

 * @duty_cycle: percentage of a period during which a led is ON

 Convert duty cycle to PWM value */

/**

 * lp3944_led_set() - Set the led status

 *

 * @led: a lp3944_led_data structure

 * @status: one of LP3944_LED_STATUS_OFF

 *                 LP3944_LED_STATUS_ON

 *                 LP3944_LED_STATUS_DIM0

 *                 LP3944_LED_STATUS_DIM1

	/*

	 * Invert status only when it's < 2 (i.e. 0 or 1) which means it's

	 * controlling the on/off state directly.

	 * When, instead, status is >= 2 don't invert it because it would mean

	 * to mess with the hardware blinking mode.

 set led status */

 units are in ms */

		/* Special case: the leds subsystem requires a default user

		 * friendly blink pattern for the LED.  Let's blink the led

		 * slowly (1Hz).

 duty_cycle is the percentage of period during which the led is ON */

	/* invert duty cycle for inverted leds, this has the same effect of

	 * swapping delay_on and delay_off

	/* NOTE: using always the first DIM mode, this means that all leds

	 * will have the same blinking pattern.

	 *

	 * We could find a way later to have two leds blinking in hardware

	 * with different patterns at the same time, falling back to software

	 * control for the other ones.

 to expose the default value to userspace */

 Set the default led status */

 Let's see whether this adapter can support what we need. */

 lp3944 i2c driver struct */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Userspace driver for the LED subsystem

 *

 * Copyright (C) 2016 David Lechner <david@lechnology.com>

 *

 * Based on uinput.c: Aristeu Sergio Rozanski Filho <aris@cathedrallabs.org>

 SPDX-License-Identifier: GPL-2.0-only

/*

* Simple driver for Texas Instruments LM355x LED Flash driver chip

* Copyright (C) 2012 Texas Instruments

 operation mode */

 register map info. */

 specific indicator function for lm3556 */

 indicator pattern data only for lm3556 */

 chip initialize */

 input and output pins configuration */

 chip control */

 brightness 0 means shutdown */

 operation mode control */

 torch */

 flash */

 indicator */

 indicator pattern only for lm3556*/

 module initialize */

 flash */

 torch */

 indicator */

 indicator pattern control only for LM3556 */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * leds-lm3533.c -- LM3533 LED driver

 *

 * Copyright (C) 2011-2012 Texas Instruments

 *

 * Author: Johan Hovold <jhovold@gmail.com>

 disable blink */

 Pattern generator defines (delays in us). */

 t_step = (t_max - t_min) / (v_max - v_min) */

 Delay limits for hardware accelerated blinking (in ms). */

/*

 * Returns linear map of *t from [t_min,t_max] to [v_min,v_max] with a step

 * size of t_step, where

 *

 *	t_step = (t_max - t_min) / (v_max - v_min)

 *

 * and updates *t to reflect the mapped value.

/*

 * Returns time code corresponding to *delay (in ms) and updates *delay to

 * reflect actual hardware delay.

 *

 * Hardware supports 256 discrete delay times, divided into three groups with

 * the following ranges and step-sizes:

 *

 *	[   16,   999]	[0x00, 0x3e]	step  16 ms

 *	[ 1130,  9781]	[0x3d, 0x7f]	step 131 ms

 *	[10306, 76890]	[0x80, 0xff]	step 524 ms

 *

 * Note that delay group 3 is only available for delay_off.

/*

 * Set delay register base to *delay (in ms) and update *delay to reflect

 * actual hardware delay used.

 Delay group 3 is only available for low time (delay off). */

/*

 * Pattern generator rise/fall times:

 *

 *   0 - 2048 us (default)

 *   1 - 262 ms

 *   2 - 524 ms

 *   3 - 1.049 s

 *   4 - 2.097 s

 *   5 - 4.194 s

 *   6 - 8.389 s

 *   7 - 16.78 s

	/* The class framework makes a callback to get brightness during

	 * registration so use parent device (for error reporting) until

	 * registered.

 disable blink */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * LED Driver for Dialog DA9052 PMICs.

 *

 * Copyright(c) 2012 Dialog Semiconductor Ltd.

 *

 * Author: David Dajun Chen <dchen@diasemi.com>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * LED Class Core

 *

 * Copyright (C) 2005 John Lenz <lenz@cs.wisc.edu>

 * Copyright (C) 2005-2007 Richard Purdie <rpurdie@openedhand.com>

 no lock needed for this */

/**

 * led_classdev_suspend - suspend an led_classdev.

 * @led_cdev: the led_classdev to suspend.

/**

 * led_classdev_resume - resume an led_classdev.

 * @led_cdev: the led_classdev to resume.

/**

 * of_led_get() - request a LED device via the LED framework

 * @np: device node to get the LED device from

 * @index: the index of the LED

 *

 * Returns the LED device parsed from the phandle specified in the "leds"

 * property of a device tree node or a negative error-code on failure.

/**

 * led_put() - release a LED device

 * @led_cdev: LED device

/**

 * devm_of_led_get - Resource-managed request of a LED device

 * @dev:	LED consumer

 * @index:	index of the LED to obtain in the consumer

 *

 * The device node of the device is parse to find the request LED device.

 * The LED device returned from this function is automatically released

 * on driver detach.

 *

 * @return a pointer to a LED device or ERR_PTR(errno) on failure.

/**

 * led_classdev_register_ext - register a new object of led_classdev class

 *			       with init data.

 *

 * @parent: parent of LED device

 * @led_cdev: the led_classdev structure for this device.

 * @init_data: LED class device initialization data

 add to the list of leds */

/**

 * led_classdev_unregister - unregisters a object of led_properties class.

 * @led_cdev: the led device to unregister

 *

 * Unregisters a previously registered via led_classdev_register object.

 Stop blinking */

/**

 * devm_led_classdev_register_ext - resource managed led_classdev_register_ext()

 *

 * @parent: parent of LED device

 * @led_cdev: the led_classdev structure for this device.

 * @init_data: LED class device initialization data

/**

 * devm_led_classdev_unregister() - resource managed led_classdev_unregister()

 * @dev: The device to unregister.

 * @led_cdev: the led_classdev structure for this device.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * LP5562 LED driver

 *

 * Copyright (C) 2013 Texas Instruments

 *

 * Author: Milo(Woogyom) Kim <milo.kim@ti.com>

 ENABLE Register 00h */

 Chip master enable */

 Logarithmic PWM adjustment */

 OPMODE Register 01h */

 BRIGHTNESS Registers */

 CURRENT Registers */

 CONFIG Register 08h */

 Internal clock */

 RESET Register 0Dh */

 PROGRAM ENGINE Registers */

 LEDMAP Register 70h */

 R:ENG1, G:ENG2, B:ENG3 */

 W:ENG1 */

 W:ENG2 */

 W:ENG3 */

 Program Commands */

 operation mode change needs to be longer than 153 us */

 it takes more 488 us to update ENABLE register */

 stop engine */

	/*

	 * To run the engine,

	 * operation mode and enable register should updated at the same time

 change operation mode to RUN only when each engine is loading */

 clear program memory before updating */

 separate sscanfs because length is working only for %s */

 Each instruction is 16bit long. Check that length is even */

	/*

	 * the firmware is encoded in ascii hex character, with 2 chars

	 * per byte

	/*

	 * Program memory sequence

	 *  1) set engine mode to "LOAD"

	 *  2) write firmware data into program memory

 Set all PWMs to direct control mode */

 Update configuration for the clock setting */

 Initialize all channels PWM to zero -> leds off */

 Set LED map as register PWM by default */

 check the size of program count */

 Set LED map as RGB */

 Load engines */

 Clear program registers */

 Program engines */

 Run engines */

	/* LED map

	 * R ... Engine 1 (fixed)

	 * G ... Engine 2 (fixed)

	 * B ... Engine 3 (fixed)

	 * W ... Engine 1 or 2 or 3

 Chip specific configurations */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * LEDs driver for Soekris net48xx

 *

 * Copyright (C) 2006 Chris Boot <bootc@bootc.net>

 *

 * Based on leds-ams-delta.c

 small hack, but scx200_gpio doesn't set .dev if the probe fails */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * leds-max8997.c - LED class driver for MAX8997 LEDs.

 *

 * Copyright (C) 2011 Samsung Electronics

 * Donggeun Kim <dg77.kim@samsung.com>

 initialize mode and brightness according to platform_data */

 SPDX-License-Identifier: GPL-2.0-only

/* drivers/leds/leds-s3c24xx.c

 *

 * (c) 2006 Simtec Electronics

 *	http://armlinux.simtec.co.uk/

 *	Ben Dooks <ben@simtec.co.uk>

 *

 * S3C24XX - LEDs GPIO driver

 our context */

 Default to off */

 register our new led device */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * LEDs driver for the "User LED" on Routerboard532

 *

 * Copyright (C) 2009 Phil Sutter <n0-1@freewrt.org>

 *

 * Based on leds-cobalt-qube.c by Florian Fainelly and

 * rb-diag.c (my own standalone driver for both LED and

 * button of Routerboard532).

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  LEDs driver for the Cobalt Raq series.

 *

 *  Copyright (C) 2007  Yoichi Yuasa <yuasa@linux-mips.org>

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  Copyright (C) 2011 Paul Parsons <lost.distance@yahoo.com>

/*

 *	The HTC ASIC3 LED GPIOs are inputs, not outputs.

 *	Hence we turn the LEDs on/off via the TimeBase register.

/*

 *	When TimeBase is 4 the clock resolution is about 32Hz.

 *	This driver supports hardware blinking with an on+off

 *	period from 62ms (2 clocks) to 125s (4000 clocks).

 Fits into 12-bit Time registers */

 If both are zero then a sensible default should be chosen */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2014 Belkin Inc.

 * Copyright 2015 Andrew Lunn <andrew@lunn.ch>

 LED Driver Output State, determine the source that drives LED outputs */

 Output LOW */

 Output HI-Z */

 Dimming */

 Blinking */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * struct clevo_mail_led_dmi_table - List of known good models

 *

 * Contains the known good models this driver is compatible with.

 * When adding a new model try to be as strict as possible. This

 * makes it possible to keep the false positives (the model is

 * detected as working, but in reality it is not) as low as

 * possible.

 ms */ && *delay_off == 0 
		/* Special case: the leds subsystem requested us to

		 * chose one user friendly blinking of the LED, and

		 * start it. Let's blink the led slowly (0.5Hz).

 ms */

 ms */

 ms */ && *delay_off == 500 
 blink the led with 1Hz */

 ms */ && *delay_off == 1000 
 blink the led with 0.5Hz */

 Check with the help of DMI if we are running on supported hardware */

sourceforge.net/projects/clevo-mailled/\n");

 SPDX-License-Identifier: GPL-2.0-only

/*

 * LEDs driver for GPIOs

 *

 * Copyright (C) 2007 8D Technologies inc.

 * Raphael Assenat <raph@8d.com>

 * Copyright (C) 2008 Freescale Semiconductor, Inc.

		/*

		 * Acquire gpiod from DT with uninitialized label, which

		 * will be updated after LED class device is registered,

		 * Only then the final LED name is known.

 Set gpiod label to match the corresponding LED name. */

	/*

	 * This means the LED does not come from the device tree

	 * or ACPI, so let's try just getting it by index from the

	 * device, this will hit the board file, if any and get

	 * the GPIO from there.

	/*

	 * This is the legacy code path for platform code that

	 * still uses GPIO numbers. Ultimately we would like to get

	 * rid of this block completely.

 skip leds that aren't available */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2015-16 Golden Delicious Computers

 *

 * Author: Nikolaus Schaller <hns@goldelico.com>

 *

 * LED driver for the IS31FL319{0,1,3,6,9} to drive 1, 3, 6 or 9 light

 * effect LEDs.

 register numbers */

 CS (Current Setting) in CONFIG2 register */

 Audio gain in CONFIG2 register */

/*

 * regmap is used as a cache of chip's register space,

 * to avoid reading back brightness values from chip,

 * which is known to hang.

 update PWM register */

 read current brightness of all PWM channels */

		/*

		 * since neither cdev nor the chip can provide

		 * the current setting, we read from the regmap cache

 0..2 => bit 0..2 */

 3..5 => bit 4..6 */

 6..8 => bit 0..2 */

 update PWMs */

 enable chip from shut down */

 shut down (no need to clear CTRL1/2) */

 is optional */

 not supported */

 we have no readable registers */

 volatile registers are not cached */

 always write-through */

 round down to nearest supported value (range check done by caller) */

 CS encoding */

 round down to nearest supported value (range check done by caller) */

 check for write-reply from chip (we can't read any registers) */

 does not answer */

	/*

	 * Kernel conventions require per-LED led-max-microamp property.

	 * But the chip does not allow to limit individual LEDs.

	 * So we take minimum from all subnodes for safety of hardware.

/*

 * i2c-core (and modalias) requires that id_table be properly filled,

 * even though it is not used for DeviceTree based instantiation.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * LED Driver for the Freecom FSG-3

 *

 * Copyright (c) 2008 Rod Whitby <rod@whitby.id.au>

 *

 * Author: Rod Whitby <rod@whitby.id.au>

 *

 * Based on leds-spitz.c

 * Copyright 2005-2006 Openedhand Ltd.

 * Author: Richard Purdie <rpurdie@openedhand.com>

 Map the LED chip select address space */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * pca9532.c - 16-bit Led dimmer

 *

 * Copyright (C) 2011 Jan Weitzel

 * Copyright (C) 2008 Riku Voipio

 *

 * Datasheet: http://www.nxp.com/documents/data_sheet/PCA9532.pdf

 m =  num_leds*/

/* We have two pwm/blinkers, but 16 possible leds to drive. Additionally,

 * the clever Thecus people are using one pwm to drive the beeper. So,

 * as a compromise we average one pwm to the values requested by all

 * leds that are not ON/OFF.

 Set LED routing */

 zero led bits */

 set the new value */

 Thecus: hardcode one pwm */

 led subsystem ask us for a blink rate */

 Thecus specific: only use PSC/PWM 0 */

 XXX: allow different kind of beeps with psc/pwm modifications */

 To use as input ensure pin is not driven */

 CONFIG_LEDS_PCA9532_GPIO */

 Use data->gpio.dev as a flag for freeing gpiochip */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2008

 * Guennadi Liakhovetski, DENX Software Engineering, <lg@denx.de>

 *

 * LED driver for the DAC124S085 SPI DAC

/*

 * drivers/leds/leds-mlxcpld.c

 * Copyright (c) 2016 Mellanox Technologies. All rights reserved.

 * Copyright (c) 2016 Vadim Pasternak <vadimp@mellanox.com>

 *

 * Redistribution and use in source and binary forms, with or without

 * modification, are permitted provided that the following conditions are met:

 *

 * 1. Redistributions of source code must retain the above copyright

 *    notice, this list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright

 *    notice, this list of conditions and the following disclaimer in the

 *    documentation and/or other materials provided with the distribution.

 * 3. Neither the names of the copyright holders nor the names of its

 *    contributors may be used to endorse or promote products derived from

 *    this software without specific prior written permission.

 *

 * Alternatively, this software may be distributed under the terms of the

 * GNU General Public License ("GPL") version 2 as published by the Free

 * Software Foundation.

 *

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"

 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE

 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE

 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE

 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR

 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF

 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS

 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN

 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)

 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE

 * POSSIBILITY OF SUCH DAMAGE.

 LPC bus access */

 Color codes for LEDs */

 Offset from solid: 3Hz blink */

 Offset from solid: 6Hz blink */

 Off */

 Solid red */

 Solid green */

 ~167 msec off/on */

 ~83 msec off/on */

/**

 * struct mlxcpld_param - LED access parameters:

 * @offset: offset for LED access in CPLD device

 * @mask: mask for LED access in CPLD device

 * @base_color: base color code for LED

/**

 * struct mlxcpld_led_priv - LED private data:

 * @cled: LED class device instance

 * @param: LED CPLD access parameters

/**

 * struct mlxcpld_led_profile - system LED profile (defined per system class):

 * @offset: offset for LED access in CPLD device

 * @mask: mask for LED access in CPLD device

 * @base_color: base color code

 * @brightness: default brightness setting (on/off)

 * @name: LED name

/**

 * struct mlxcpld_led_pdata - system LED private data

 * @pdev: platform device pointer

 * @pled: LED class device instance

 * @profile: system configuration profile

 * @num_led_instances: number of LED instances

 * @lock: device access lock

/* Default profile fit the next Mellanox systems:

 * "msx6710", "msx6720", "msb7700", "msn2700", "msx1410",

 * "msn2410", "msb7800", "msn2740"

 Profile fit the Mellanox systems based on "msn2100" */

	/*

	 * Each LED is controlled through low or high nibble of the relevant

	 * CPLD register. Register offset is specified by off parameter.

	 * Parameter vset provides color code: 0x0 for off, 0x5 for solid red,

	 * 0x6 for 3Hz blink red, 0xd for solid green, 0xe for 3Hz blink

	 * green.

	 * Parameter mask specifies which nibble is used for specific LED: mask

	 * 0xf0 - lower nibble is to be used (bits from 0 to 3), mask 0x0f -

	 * higher nibble (bits from 4 to 7).

	/*

	 * HW supports two types of blinking: full (6Hz) and half (3Hz).

	 * For delay on/off zero default setting 3Hz is used.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * LED Class Core

 *

 * Copyright 2005-2006 Openedhand Ltd.

 *

 * Author: Richard Purdie <rpurdie@openedhand.com>

 Time to switch the LED on. */

		/* Store the current brightness value to be able

		 * to restore it when the delay_off period is over.

	/* Return in next iteration if led is in one-shot mode and we are in

	 * the final blink state so that the led is toggled each delay_on +

	 * delay_off milliseconds in worst case.

 LED HW might have been unplugged, therefore don't warn */

 never on - just set to off */

 never off - just set to brightness */

 blink with 1 Hz as default if nothing specified */

	/*

	 * If software blink is active, delay brightness setting

	 * until the next timer tick.

		/*

		 * If we need to disable soft blinking delegate this to the

		 * work queue task to avoid problems in case we are called

		 * from hard irq context.

 Use brightness_set op if available, it is guaranteed not to sleep */

 If brightness setting can sleep, delegate it to a work queue task */

 Caller must ensure led_cdev->led_access held */

 Caller must ensure led_cdev->led_access held */

	/* We want to label LEDs that can produce full range of colors

		/*

		 * If init_data.devicename is NULL, then it indicates that

		 * DT label should be used as-is for LED class device name.

		 * Otherwise the label is prepended with devicename to compose

		 * the final LED class device name.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * LED driver for Mediatek MT6323 PMIC

 *

 * Copyright (C) 2017 Sean Wang <sean.wang@mediatek.com>

/*

 * Register field for MT6323_TOP_CKPDN0 to enable

 * 32K clock common for LED device.

/*

 * Register field for MT6323_TOP_CKPDN2 to enable

 * individual clock for LED device.

/*

 * Register field for MT6323_TOP_CKCON1 to select

 * clock source.

/*

 * Register for MT6323_ISINK_CON0 to setup the

 * duty cycle of the blink.

 Register to setup the period of the blink. */

 Register to control the brightness. */

 Register to LED channel enablement. */

/**

 * struct mt6323_led - state container for the LED device

 * @id:			the identifier in MT6323 LED device

 * @parent:		the pointer to MT6323 LED controller

 * @cdev:		LED class device for this LED device

 * @current_brightness: current state of the LED device

/**

 * struct mt6323_leds -	state container for holding LED controller

 *			of the driver

 * @dev:		the device pointer

 * @hw:			the underlying hardware providing shared

 *			bus for the register operations

 * @lock:		the lock among process context

 * @led:		the array that contains the state of individual

 *			LED device

 protect among process context */

	/*

	 * Setup current output for the corresponding

	 * brightness level.

	/*

	 * Setup required clock source, enable the corresponding

	 * clock and channel and let work with continuous blink as

	 * the default.

	/*

	 * LED subsystem requires a default user

	 * friendly blink pattern for the LED so using

	 * 1Hz duty cycle 50% here if without specific

	 * value delay_on and delay off being assigned.

	/*

	 * Units are in ms, if over the hardware able

	 * to support, fallback into software blink

	/*

	 * Calculate duty_hw based on the percentage of period during

	 * which the led is ON.

 hardware doesn't support zero duty cycle. */

	/*

	 * Set max_brightness as the software blink behavior

	 * when no blink brightness.

	/*

	 * leds->hw points to the underlying bus for the register

	 * controlled.

 Turn the LEDs off on driver removal. */

 SPDX-License-Identifier: GPL-2.0

 Copyright (C) 2018 Spreadtrum Communications Inc.

 PMIC global control register definition */

 Breathing light controller register definition */

 Stage duration step, in milliseconds */

 Minimum and maximum duration, in milliseconds */

 Reset the rise, high, fall and low time to zero. */

	/*

	 * Must contain 4 tuples to configure the rise time, high time, fall

	 * time and low time to enable the breathing mode.

 Enable the LED breathing mode */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * LEDs driver for Analog Devices ADP5520/ADP5501 MFD PMICs

 *

 * Copyright 2009 Analog Devices Inc.

 *

 * Loosely derived from leds-da903x:

 * Copyright (C) 2008 Compulab, Ltd.

 *	Mike Rapoport <mike@compulab.co.il>

 *

 * Copyright (C) 2006-2008 Marvell International Ltd.

 *	Eric Miao <eric.miao@marvell.com>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * LEDs driver for Dialog Semiconductor DA9030/DA9034

 *

 * Copyright (C) 2008 Compulab, Ltd.

 *	Mike Rapoport <mike@compulab.co.il>

 *

 * Copyright (C) 2006-2008 Marvell International Ltd.

 *	Eric Miao <eric.miao@marvell.com>

 Vibrator Control */

 EN bit */

 PWM<2:0> */

 EN bit */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * leds-bd2802.c - RGB LED Driver

 *

 * Copyright (C) 2009 Samsung Electronics

 * Kim Kyuwon <q1.kim@samsung.com>

 *

 * Datasheet: http://www.rohm.com/products/databook/driver/pdf/bd2802gu-e.pdf

 3.2mA */

 0.0mA */

/*

 * State '0' : 'off'

 * State '1' : 'blink'

 * State '2' : 'on'.

	/*

	 * Making led_classdev as array is not recommended, because array

	 * members prevent using 'container_of' macro. So repetitive works

	 * are needed.

	/*

	 * Advanced Configuration Function(ADF) mode:

	 * In ADF mode, user can set registers of BD2802GU directly,

	 * therefore BD2802GU doesn't enter reset state.

 General attributes of RGB LEDs */

--------------------------------------------------------------*/

	BD2802GU helper functions					*/

--------------------------------------------------------------*/

--------------------------------------------------------------*/

	BD2802GU core functions					*/

--------------------------------------------------------------*/

	/*

	 * In this case, other led is turned on, and current led is turned

	 * off. So set RGB LED Control register to stop the current RGB LED

	/*

	 * Configure RESET GPIO (L: RESET, H: RESET cancel)

	 *

	 * We request the reset GPIO as OUT_LOW which means de-asserted,

	 * board files specifying this GPIO line in a machine descriptor

	 * table should take care to specify GPIO_ACTIVE_LOW for this line.

 Tacss = min 0.1ms */

 Detect BD2802GU */

 To save the power, reset BD2802 after detecting */

 Default attributes */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) 2017 Sebastian Reichel <sre@kernel.org>

 aux display light */

 camera privacy led */

 5 bit */

 4 bit */

 Avoid HW issue by turning off current before duty cycle */

 SPDX-License-Identifier: GPL-2.0+

		/*

		 * There is no separate controls which can disable LEDs

		 * individually, there is only RESET_LEDS command that turns

		 * off both LEDs.

		 *

		 * RESET_LEDS turns off both LEDs, thus restore other LED if

		 * it's turned ON.

 reset and turn off LEDs */

 SPDX-License-Identifier: GPL-2.0+

 Driver for Awinic AW2013 3-channel LED driver

 Reset and ID register */

 Global control register */

 LED channel enable register */

 LED channel control registers */

 Should be 0-3

 LED channel PWM registers */

 LED channel timing registers */

 Should be 0-7

 Should be 0-5

 Should be 0-7

 Should be 0-7

 Should be 0-8

 Should be 0-15

 ms */

 held when writing to registers */

 If no blink specified, default to 1 Hz. */

 Never on - just set to off */

 Never off - brightness is already set, disable blinking */

 Convert into values the HW will understand. */

 Set timings */

 Finally, enable the LED */

 5mA

 sentinel */ },

 SPDX-License-Identifier: GPL-2.0-only

/*

 * TI LP8501 9 channel LED Driver

 *

 * Copyright (C) 2013 Texas Instruments

 *

 * Author: Milo(Woogyom) Kim <milo.kim@ti.com>

 Registers */

 Chip startup time is 500 us, 1 - 2 ms gives some margin */

 Power selection for each output */

 stop engine */

	/*

	 * To run the engine,

	 * operation mode and enable register should updated at the same time

 change operation mode to RUN only when each engine is loading */

 clear program memory before updating */

 separate sscanfs because length is working only for %s */

 Each instruction is 16bit long. Check that length is even */

	/*

	 * Program memory sequence

	 *  1) set engine mode to "LOAD"

	 *  2) write firmware data into program memory

 Chip specific configurations */

/*

 * Bachmann ot200 leds driver.

 *

 * Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>

 *         Christian Gmeiner <christian.gmeiner@gmail.com>

 *

 * License: GPL as published by the FSF.

/*

 * The device has three leds on the back panel (led_err, led_init and led_run)

 * and can handle up to seven leds on the front panel.

/*

 * we need to store the current led states, as it is not

 * possible to read the current led state via inb().

 turn off all front leds */

 turn on init led */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2019 Sven Van Asbroeck

 This instance is not set for torch mode so bail out */

 fwnode/devicetree is optional. NULL is allowed for priv->fwnode */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * lp5523.c - LP5523, LP55231 LED Driver

 *

 * Copyright (C) 2010 Nokia Corporation

 * Copyright (C) 2012 Texas Instruments

 *

 * Contact: Samu Onkalo <samu.p.onkalo@nokia.com>

 *          Milo(Woogyom) Kim <milo.kim@ti.com>

 bytes */

/* Memory is used like this:

 * 0x00 engine 1 program

 * 0x10 engine 2 program

 * 0x20 engine 3 program

 * 0x30 engine 1 muxing info

 * 0x40 engine 2 muxing info

 * 0x50 engine 3 muxing info

 Registers */

 Bit description in registers */

 Memory Page Selection */

 Program Memory Operations */

 Operation Mode Register */

 Enable Register */

 Chip startup time is 500 us, 1 - 2 ms gives some margin */

 turn on all leds */

 stop engine */

	/*

	 * To run the engine,

	 * operation mode and enable register should updated at the same time

 change operation mode to RUN only when each engine is loading */

 one pattern per engine setting LED MUX start and stop addresses */

 hardcode 32 bytes of memory for each engine from program memory */

 write LED MUX address space for each engine */

 Let the programs run for couple of ms and check the engine status */

 separate sscanfs because length is working only for %s */

 Each instruction is 16bit long. Check that length is even */

	/*

	 * Program memory sequence

	 *  1) set engine mode to "LOAD"

	 *  2) write firmware data into program memory

 Check that ext clock is really in use if requested */

 Measure VDD (i.e. VBAT) first (channel 16 corresponds to VDD) */

 ADC conversion time is typically 2.7 ms */

 Was not ready. Wait little bit */

 There may be some fluctuation in measurement */

 Skip non-existing channels */

 Set default current */

 let current stabilize 2 - 4ms before measurements start */

 ADC conversion time is 2.7 ms typically */

 Was not ready. Wait. */

 Restore current */

 Chip specific configurations */

 SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)



 Copyright (c) 2018 Mellanox Technologies. All rights reserved.

 Copyright (c) 2018 Vadim Pasternak <vadimp@mellanox.com>

 Codes for LEDs. */

 Offset from solid: 3Hz blink */

 Offset from solid: 6Hz blink */

 Off */

 Solid red */

 Solid green */

 Solid amber */

 ~167 msec off/on - HW support */

 ~83 msec off/on - HW support */

 Clear mask */

/**

 * struct mlxreg_led_data - led control data:

 *

 * @data: led configuration data;

 * @led_cdev: led class data;

 * @base_color: base led color (other colors have constant offset from base);

 * @led_data: led data;

 * @data_parent: pointer to private device control data of parent;

 * @led_cdev_name: class device name

/**

 * struct mlxreg_led_priv_data - platform private data:

 *

 * @pdev: platform device;

 * @pdata: platform data;

 * @access_lock: mutex for attribute IO access;

 protect IO operations */

	/*

	 * Each LED is controlled through low or high nibble of the relevant

	 * register byte. Register offset is specified by off parameter.

	 * Parameter vset provides color code: 0x0 for off, 0x5 for solid red,

	 * 0x6 for 3Hz blink red, 0xd for solid green, 0xe for 3Hz blink

	 * green.

	 * Parameter mask specifies which nibble is used for specific LED: mask

	 * 0xf0 - lower nibble is to be used (bits from 0 to 3), mask 0x0f -

	 * higher nibble (bits from 4 to 7).

	/*

	 * Each LED is controlled through low or high nibble of the relevant

	 * register byte. Register offset is specified by off parameter.

	 * Parameter vset provides color code: 0x0 for off, 0x5 for solid red,

	 * 0x6 for 3Hz blink red, 0xd for solid green, 0xe for 3Hz blink

	 * green.

	 * Parameter mask specifies which nibble is used for specific LED: mask

	 * 0xf0 - lower nibble is to be used (bits from 0 to 3), mask 0x0f -

	 * higher nibble (bits from 4 to 7).

 Assume the LED is OFF */

	/*

	 * HW supports two types of blinking: full (6Hz) and half (3Hz).

	 * For delay on/off zero LED is setting to solid color. For others

	 * combination blinking is to be controlled by the software timer.

			/*

			 * Field "bit" can contain one capability bit in 0 byte

			 * and offset bit in 1-3 bytes. Clear capability bit and

			 * keep only offset bit.

 SPDX-License-Identifier: GPL-2.0

 TI LM3532 LED driver

 Copyright (C) 2019 Texas Instruments Incorporated - https:
 https:
 Control Enable */

 PWM Zone Control */

 Brightness Configuration */

 Zone Boundary Register */

/*

 * struct lm3532_als_data

 * @config: value of ALS configuration register

 * @als1_imp_sel: value of ALS1 resistor select register

 * @als2_imp_sel: value of ALS2 resistor select register

 * @als_avrg_time: ALS averaging time

 * @als_input_mode: ALS input mode for brightness control

 * @als_vmin: Minimum ALS voltage

 * @als_vmax: Maximum ALS voltage

 * @zone_lo: values of ALS lo ZB(Zone Boundary) registers

 * @zone_hi: values of ALS hi ZB(Zone Boundary) registers

/**

 * struct lm3532_led

 * @led_dev: led class device

 * @priv: Pointer the device data structure

 * @control_bank: Control bank the LED is associated to

 * @mode: Mode of the LED string

 * @ctrl_brt_pointer: Zone target register that controls the sink

 * @num_leds: Number of LED strings are supported in this array

 * @full_scale_current: The full-scale current setting for the current sink.

 * @led_strings: The LED strings supported in this array

 * @enabled: Enabled status

/**

 * struct lm3532_data

 * @enable_gpio: Hardware enable gpio

 * @regulator: regulator

 * @client: i2c client

 * @regmap: Devices register map

 * @dev: Pointer to the devices device struct

 * @lock: Lock for reading/writing the device

 * @als_data: Pointer to the als data struct

 * @runtime_ramp_up: Runtime ramp up setting

 * @runtime_ramp_down: Runtime ramp down setting

 * @leds: Array of LED strings

 Find an approximate index by looking up the table */

 Find an approximate index by looking up the table */

 Caller must take care of locking */

 Caller must take care of locking */

	/*

	 * This could be hard coded to the default value but the control

	 * brightness register may have changed during boot.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * LED driver for WM831x status LEDs

 *

 * Copyright(C) 2009 Wolfson Microelectronics PLC.

 Control register */

 Control register value */

 Pick some defaults if we've not been given times */

	/* We only have a limited selection of settings, see if we can

 Actually 62.5ms */

	/* We cache the configuration register and read startup values

	/* Set a default source if configured, otherwise leave the

	 * current hardware setting.

 SPDX-License-Identifier: GPL-2.0

 LED Multicolor class interface

 Copyright (C) 2019-20 Texas Instruments Incorporated - http:
 Author: Dan Murphy <dmurphy@ti.com>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * LED driver for WM8350 driven LEDS.

 *

 * Copyright(C) 2007, 2008 Wolfson Microelectronics PLC.

 Microamps */

	/* This scales linearly into the index of valid current

	 * settings which results in a linear scaling of perceived

	 * brightness due to the non-linear current settings provided

	 * by the hardware.

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Crane Merchandising Systems. All rights reserved.

 Copyright (C) 2019 Oleh Kravchenko <oleg@kaa.org.ua>

/*

 * EL15203000 SPI protocol description:

 * +-----+---------+

 * | LED | COMMAND |

 * +-----+---------+

 * |  1  |    1    |

 * +-----+---------+

 * (*) LEDs MCU board expects 20 msec delay per byte.

 *

 * LEDs:

 * +----------+--------------+-------------------------------------------+

 * |    ID    |     NAME     |         DESCRIPTION                       |

 * +----------+--------------+-------------------------------------------+

 * | 'P' 0x50 |     Pipe     | Consists from 5 LEDs, controlled by board |

 * +----------+--------------+-------------------------------------------+

 * | 'S' 0x53 | Screen frame | Light tube around the screen              |

 * +----------+--------------+-------------------------------------------+

 * | 'V' 0x56 | Vending area | Highlights a cup of coffee                |

 * +----------+--------------+-------------------------------------------+

 *

 * COMMAND:

 * +----------+-----------------+--------------+--------------+

 * |  VALUES  |       PIPE      | SCREEN FRAME | VENDING AREA |

 * +----------+-----------------+--------------+--------------+

 * | '0' 0x30 |                      Off                      |

 * +----------+-----------------------------------------------+

 * | '1' 0x31 |                      On                       |

 * +----------+-----------------+--------------+--------------+

 * | '2' 0x32 |     Cascade     |   Breathing  |

 * +----------+-----------------+--------------+

 * | '3' 0x33 | Inverse cascade |

 * +----------+-----------------+

 * | '4' 0x34 |     Bounce      |

 * +----------+-----------------+

 * | '5' 0x35 | Inverse bounce  |

 * +----------+-----------------+

 EL15203000 default settings */

 for all LEDs */

 for Screen LED */

 for Pipe LED */

 to avoid SPI mistiming with firmware we should wait some time */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Driver for ISSI IS31FL32xx family of I2C LED controllers

 *

 * Copyright 2015 Allworx Corp.

 *

 * Datasheets:

 *   http://www.issi.com/US/product-analog-fxled-driver.shtml

 *   http://www.si-en.com/product.asp?parentid=890

 Used to indicate a device has no such register */

 Software Shutdown bit in Shutdown Register */

 IS31FL3216 has a number of unique registers */

 Software Shutdown bit in 3216 Config Register */

 1-based, max priv->cdef->channels */

/**

 * struct is31fl32xx_chipdef - chip-specific attributes

 * @channels            : Number of LED channels

 * @shutdown_reg        : address of Shutdown register (optional)

 * @pwm_update_reg      : address of PWM Update register

 * @global_control_reg  : address of Global Control register (optional)

 * @reset_reg           : address of Reset register (optional)

 * @pwm_register_base   : address of first PWM register

 * @pwm_registers_reversed: : true if PWM registers count down instead of up

 * @led_control_register_base : address of first LED control register (optional)

 * @enable_bits_per_led_control_register: number of LEDs enable bits in each

 * @reset_func          : pointer to reset function

 * @sw_shutdown_func    : pointer to software shutdown function

 *

 * For all optional register addresses, the sentinel value %IS31FL32XX_REG_NONE

 * indicates that this chip has no such register.

 *

 * If non-NULL, @reset_func will be called during probing to set all

 * necessary registers to a known initialization state. This is needed

 * for chips that do not have a @reset_reg.

 *

 * @enable_bits_per_led_control_register must be >=1 if

 * @led_control_register_base != %IS31FL32XX_REG_NONE.

/*

 * Custom reset function for IS31FL3216 because it does not have a RESET

 * register the way that the other IS31FL32xx chips do. We don't bother

 * writing the GPIO and animation registers, because the registers we

 * do write ensure those will have no effect.

/*

 * Custom Software-Shutdown function for IS31FL3216 because it does not have

 * a SHUTDOWN register the way that the other IS31FL32xx chips do.

 * We don't bother doing a read/modify/write on the CONFIG register because

 * we only ever use a value of '0' for the other fields in that register.

/*

 * NOTE: A mutex is not needed in this function because:

 * - All referenced data is read-only after probe()

 * - The I2C core has a mutex on to protect the bus

 * - There are no read/modify/write operations

 * - Intervening operations between the write of the PWM register

 *   and the Update register are harmless.

 *

 * Example:

 *	PWM_REG_1 write 16

 *	UPDATE_REG write 0

 *	PWM_REG_2 write 128

 *	UPDATE_REG write 0

 *   vs:

 *	PWM_REG_1 write 16

 *	PWM_REG_2 write 128

 *	UPDATE_REG write 0

 *	UPDATE_REG write 0

 * are equivalent. Poking the Update register merely applies all PWM

 * register writes up to that point.

 NOTE: led_data->channel is 1-based */

	/*

	 * Set enable bit for all channels.

	 * We will control state with PWM registers alone.

 Detect if channel is already in use by another child */

/*

 * i2c-core (and modalias) requires that id_table be properly filled,

 * even though it is not used for DeviceTree based instantiation.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * LED Triggers Core

 * For the HP Jornada 620/660/680/690 handhelds

 *

 * Copyright 2008 Kristoffer Ericson <kristoffer.ericson@gmail.com>

 *     this driver is based on leds-spitz.c by Richard Purdie.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * leds-tca6507

 *

 * The TCA6507 is a programmable LED controller that can drive 7

 * separate lines either by holding them low, or by pulsing them

 * with modulated width.

 * The modulation can be varied in a simple pattern to produce a

 * blink or double-blink.

 *

 * This driver can configure each line either as a 'GPIO' which is

 * out-only (pull-up resistor required) or as an LED with variable

 * brightness and hardware-assisted blinking.

 *

 * Apart from OFF and ON there are three programmable brightness

 * levels which can be programmed from 0 to 15 and indicate how many

 * 500usec intervals in each 8msec that the led is 'on'.  The levels

 * are named MASTER, BANK0 and BANK1.

 *

 * There are two different blink rates that can be programmed, each

 * with separate time for rise, on, fall, off and second-off.  Thus if

 * 3 or more different non-trivial rates are required, software must

 * be used for the extra rates. The two different blink rates must

 * align with the two levels BANK0 and BANK1.  This driver does not

 * support double-blink so 'second-off' always matches 'off'.

 *

 * Only 16 different times can be programmed in a roughly logarithmic

 * scale from 64ms to 16320ms.  To be precise the possible times are:

 *    0, 64, 128, 192, 256, 384, 512, 768,

 *    1024, 1536, 2048, 3072, 4096, 5760, 8128, 16320

 *

 * Times that cannot be closely matched with these must be handled in

 * software.  This driver allows 12.5% error in matching.

 *

 * This driver does not allow rise/fall rates to be set explicitly.

 * When trying to match a given 'on' or 'off' period, an appropriate

 * pair of 'change' and 'hold' times are chosen to get a close match.

 * If the target delay is even, the 'change' number will be the

 * smaller; if odd, the 'hold' number will be the smaller.



 * Choosing pairs of delays with 12.5% errors allows us to match

 * delays in the ranges: 56-72, 112-144, 168-216, 224-27504,

 * 28560-36720.

 * 26% of the achievable sums can be matched by multiple pairings.

 * For example 1536 == 1536+0, 1024+512, or 768+768.

 * This driver will always choose the pairing with the least

 * maximum - 768+768 in this case.  Other pairings are not available.

 *

 * Access to the 3 levels and 2 blinks are on a first-come,

 * first-served basis.  Access can be shared by multiple leds if they

 * have the same level and either same blink rates, or some don't

 * blink.  When a led changes, it relinquishes access and tries again,

 * so it might lose access to hardware blink.

 *

 * If a blink engine cannot be allocated, software blink is used.  If

 * the desired brightness cannot be allocated, the closest available

 * non-zero brightness is used.  As 'full' is always available, the

 * worst case would be to have two different blink rates at '1', with

 * Max at '2', then other leds will have to choose between '2' and

 * '16'.  Hopefully this is not likely.

 *

 * Each bank (BANK0 and BANK1) has two usage counts - LEDs using the

 * brightness and LEDs using the blink.  It can only be reprogrammed

 * when the appropriate counter is zero.  The MASTER level has a

 * single usage count.

 *

 * Each LED has programmable 'on' and 'off' time as milliseconds.

 * With each there is a flag saying if it was explicitly requested or

 * defaulted.  Similarly the banks know if each time was explicit or a

 * default.  Defaults are permitted to be changed freely - they are

 * not recognised when matching.

 LED select registers determine the source that drives LED outputs */

 Output HI-Z (off) */

 Output HI-Z (off) - not used */

 Output LOW with Bank0 rate */

 Output LOW with Bank1 rate */

 Output LOW (on) */

 Output LOW with Master Intensity */

 Blink at Bank0 rate */

 Blink at Bank1 rate */

 PWM registers */

/*

 * 0x00, 0x01, 0x02 encode the TCA6507_LS_* values, each output

 * owns one bit in each register

 Convert an led.brightness level (0..255) to a TCA6507 level (0..15) */

 ...and convert back */

	int			reg_set;	/* One bit per register where

						 * a '1' means the register

 Bank 2 is Master Intensity and doesn't use times */

 Bank used, or -1 */

 Set if hardware-blinking */

	/*

	 * Choose two timecodes which add to 'msec' as near as

	 * possible.  The first returned is the 'on' or 'off' time.

	 * The second is to be used as a 'fade-on' or 'fade-off' time.

	 * If 'msec' is even, the first will not be smaller than the

	 * second.  If 'msec' is odd, the first will not be larger

	 * than the second.

	 * If we cannot get a sum within 1/8 of 'msec' fail with

	 * -EINVAL, otherwise return the sum that was achieved, plus 1

	 * if the first is smaller.

	 * If two possibilities are equally good (e.g. 512+0,

	 * 256+256), choose the first pair so there is more

	 * change-time visible (i.e. it is softer).

	/* We start at '1' to ensure we never even think of choosing a

	 * total time of '0'.

 This works! */

 Best yet */

 No close match */

/*

 * Update the register file with the appropriate 3-bit state for the

 * given led.

/* Update the register file with the appropriate 4-bit code for one

 * bank or other.  This can be used for timers, for levels, or for

 * initialization.

 Update brightness level. */

 Record all relevant time codes for a given bank */

 Write all needed register of tca6507 */

 If led owns any resource, release it. */

	/* Assign this led to a bank, configuring that bank if

		/*

		 * Just set the brightness, choosing first usable

		 * bank.  If none perfect, choose best.  Count

		 * backwards so we check MASTER bank first to avoid

		 * wasting a timer.

 full-on */

 Best brightness is full-on */

	/*

	 * We have on/off time so we need to try to allocate a timing

	 * bank.  First check if times are compatible with hardware

	 * and give up if not.

 not in use - it is ours! */

 Incompatible level - skip */

			/* FIX: if timer matches we maybe should consider

			 * this anyway...

 Timer not in use, and level matches - use it */

 on time is incompatible */

 off time is incompatible */

 looks like a suitable match */

 Nothing matches - how sad */

		/*

		 * Can only fail on timer setup.  In that case we need

		 * to re-establish as steady level.

	/*

	 * 'OFF' is floating high, and 'ON' is pulled down, so it has

	 * the inverse sense of 'val'.

 Configure as a gpio */

 CONFIG_GPIOLIB */

 CONFIG_GPIOLIB */

 set all registers to known state - zero */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * SS4200-E Hardware API

 * Copyright (c) 2009, Intel Corporation.

 * Copyright IBM Corporation, 2009

 *

 * Author: Dave Hansen <dave@sr71.net>

/*

 * ICH7 LPC/GPIO PCI Config register offsets

/*

 * The ICH7 GPIO register block is 64 bytes in size.

/*

 * Define register offsets within the ICH7 register block.

/*

 * PCI ID of the Intel ICH7 LPC Device within which the GPIO block lives.

 NULL entry */

/*

 * struct nas_led_whitelist - List of known good models

 *

 * Contains the known good models this driver is compatible with.

 * When adding a new model try to be as strict as possible. This

 * makes it possible to keep the false positives (the model is

 * detected as working, but in reality it is not) as low as

 * possible.

		/*

		 * FUJITSU SIEMENS SCALEO Home Server/SS4200-E

		 * BIOS V090L 12/19/2007

/*

 * Base I/O address assigned to the Power Management register block

/*

 * Base I/O address assigned to the ICH7 GPIO register block

/*

 * When we successfully register a region, we are returned a resource.

 * We use these to identify which regions we need to release on our way

 * back out.

/*

 * gpio_bit(s) are the ICH7 GPIO bit assignments

 GPIO10 */

/*

 * This protects access to the gpio ports.

/*

 * There are two gpio ports, one for blinking and the other

 * for power.  @port tells us if we're doing blinking or

 * power control.

 *

 * Caller must hold nasgpio_gpio_lock

/*

 * There is actual brightness control in the hardware,

 * but it is via smbus commands and not implemented

 * in this driver.

	/*

	 * Hold the lock across both operations.  This ensures

	 * consistency so that both the "turn off blinking"

	 * and "turn light off" operations complete as a set.

	/*

	 * LED class documentation asks that past blink state

	 * be disabled when brightness is turned to zero.

	/*

	 * These are very approximate.

/*

 * Initialize the ICH7 GPIO registers for NAS usage.  The BIOS should have

 * already taken care of this, but we will do so in a non destructive manner

 * so that we have what we need whether the BIOS did it or not.

	/*

	 * We need to enable all of the GPIO lines used by the NAS box,

	 * so we will read the current Use Selection and add our usage

	 * to it.  This should be benign with regard to the original

	 * BIOS configuration.

	/*

	 * The LED GPIO outputs need to be configured for output, so we

	 * will ensure that all LED lines are cleared for output and the

	 * RECOVERY line ready for input.  This too should be benign with

	 * regard to BIOS configuration.

	/*

	 * In our final system, the BIOS will initialize the state of all

	 * of the LEDs.  For now, we turn them all off (or Low).

	/*

	 * In our final system, the BIOS will initialize the blink state of all

	 * of the LEDs.  For now, we turn blink off for all of them.

	/*

	 * At this moment, I am unsure if anything needs to happen with GPI_INV

	/*

	 * If we were given exclusive use of the GPIO

	 * I/O Address range, we must return it.

/*

 * The OS has determined that the LPC of the Intel ICH7 Southbridge is present

 * so we can retrive the required operational information and prepare the GPIO.

	/*

	 * Insure that we have exclusive access to the GPIO I/O address range.

	/*

	 * Initialize the GPIO for NAS/Home Server Use

/*

 * pci_driver structure passed to the PCI modules

	/*

	 * LED_OFF implies disabling future blinking

/*

 * module load/initialization

	/*

	 * When the system powers on, the BIOS leaves the power

	 * light blue and blinking.  This will turn it solid

	 * amber once the driver is loaded.

/*

 * module unload

 SPDX-License-Identifier: GPL-2.0-only

/*

 *

 * h3xxx atmel micro companion support, notification LED subdevice

 *

 * Author : Linus Walleij <linus.walleij@linaro.org>

 LED ON/OFF 0:off, 1:on                       */

 LED ON/OFF auto stop set 0:disable, 1:enable */

 LED Interrupt Mask 0:No mask, 1:mask         */

	/*

	 * In this message:

	 * Byte 0 = LED color: 0 = yellow, 1 = green

	 *          yellow LED is always ~30 blinks per minute

	 * Byte 1 = duration (flags?) appears to be ignored

	 * Byte 2 = green ontime in 1/10 sec (deciseconds)

	 *          1 = 1/10 second

	 *          0 = 256/10 second

	 * Byte 3 = green offtime in 1/10 sec (deciseconds)

	 *          1 = 1/10 second

	 *          0 = 256/10 seconds

 Duty cycle 256 */

 Duty cycle 256 */

 Maximum duty cycle in ms 256/10 sec = 25600 ms */

	/*

	 * In this message:

	 * Byte 0 = LED color: 0 = yellow, 1 = green

	 *          yellow LED is always ~30 blinks per minute

	 * Byte 1 = duration (flags?) appears to be ignored

	 * Byte 2 = green ontime in 1/10 sec (deciseconds)

	 *          1 = 1/10 second

	 *          0 = 256/10 second

	 * Byte 3 = green offtime in 1/10 sec (deciseconds)

	 *          1 = 1/10 second

	 *          0 = 256/10 seconds

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * leds-netxbig.c - Driver for the 2Big and 5Big Network series LEDs

 *

 * Copyright (C) 2010 LaCie

 *

 * Author: Simon Guinot <sguinot@lacie.com>

/*

 * GPIO extension bus.

 Enable select is done on the raising edge. */

/*

 * Class LED driver.

 Look for a LED mode with the requested timer frequency. */

 Keep 'timer' mode. */

	/*

	 * Note that the brightness register is shared between all the

	 * SATA LEDs. So, change the brightness setting for a single

	 * SATA LED will affect all the others.

 Keep modes 'off' and 'timer'. */

	/*

	 * Because the GPIO extension bus don't allow to read registers

	 * value, there is no way to probe the LED initial state.

	 * So, the initial sysfs LED value for the "brightness" and "sata"

	 * attributes are inconsistent.

	 *

	 * Note that the initial LED state can't be reconfigured.

	 * The reason is that the LED behaviour must stay uniform during

	 * the whole boot process (bootloader+linux).

	/*

	 * If available, expose the SATA activity blink capability through

	 * a "sata" sysfs attribute.

/**

 * netxbig_gpio_ext_remove() - Clean up GPIO extension data

 * @data: managed resource data to clean up

 *

 * Since we pick GPIO descriptors from another device than the device our

 * driver is probing to, we need to register a specific callback to free

 * these up using managed resources.

/**

 * netxbig_gpio_ext_get() - Obtain GPIO extension device data

 * @dev: main LED device

 * @gpio_ext_dev: the GPIO extension device

 * @gpio_ext: the data structure holding the GPIO extension data

 *

 * This function walks the subdevice that only contain GPIO line

 * handles in the device tree and obtains the GPIO descriptors from that

 * device.

	/*

	 * We cannot use devm_ managed resources with these GPIO descriptors

	 * since they are associated with the "GPIO extension device" which

	 * does not probe any driver. The device tree parser will however

	 * populate a platform device for it so we can anyway obtain the

	 * GPIO descriptors from the device.

 GPIO extension */

 Timers (optional) */

 LEDs */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2016 National Instruments Corp.

 Unlock LED register */

 Lock LED register */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * LED driver for Marvell 88PM860x

 *

 * Copyright (C) 2009 Marvell International Ltd.

 *	Haojian Zhuang <haojian.zhuang@marvell.com>

 unset current since no led is lighting */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2018 Crane Merchandising Systems. All rights reserved.

 Copyright (C) 2018 Oleh Kravchenko <oleg@kaa.org.ua>

/*

 *  CR0014114 SPI protocol descrtiption:

 *  +----+-----------------------------------+----+

 *  | CMD|             BRIGHTNESS            |CRC |

 *  +----+-----------------------------------+----+

 *  |    | LED0| LED1| LED2| LED3| LED4| LED5|    |

 *  |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |

 *  |    |R|G|B|R|G|B|R|G|B|R|G|B|R|G|B|R|G|B|    |

 *  | 1  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 1  |

 *  |    |1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|    |

 *  |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |

 *  |    |               18                  |    |

 *  +----+-----------------------------------+----+

 *  |                    20                       |

 *  +---------------------------------------------+

 *

 *  PS: Boards can be connected to the chain:

 *      SPI -> board0 -> board1 -> board2 ..

 CR0014114 SPI commands */

 CR0014114 default settings */

 special case when CRC matches the SPI commands */

 to avoid SPI mistiming with firmware we should wait some time */

 setup recount work to workaround buggy firmware */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * PowerNV LED Driver

 *

 * Copyright IBM Corp. 2015

 *

 * Author: Vasant Hegde <hegdevasant@linux.vnet.ibm.com>

 * Author: Anshuman Khandual <khandual@linux.vnet.ibm.com>

 Map LED type to description. */

	/*

	 * By default unload path resets all the LEDs. But on PowerNV

	 * platform we want to retain LED state across reboot as these

	 * are controlled by firmware. Also service processor can modify

	 * the LEDs independent of OS. Hence avoid resetting LEDs in

	 * unload path.

 Max supported LED type */

 glabal lock */

 PowerNV LED data */

 LED location code */

 OPAL_SLOT_LED_TYPE_* */

 Returns OPAL_SLOT_LED_TYPE_* for given led type string */

/*

 * This commits the state change of the requested LED through an OPAL call.

 * This function is called from work queue task context when ever it gets

 * scheduled. This function can sleep at opal_async_wait_response call.

 Prepare for the OPAL call */

 OPAL async call */

/*

 * This function fetches the LED state for a given LED type for

 * mentioned LED classdev structure.

 Fetch all LED status */

 LED status available */

 LED status value */

/*

 * LED classdev 'brightness_get' function. This schedules work

 * to update LED state.

 Do not modify LED in unload path */

 LED classdev 'brightness_get' function */

/*

 * This function registers classdev structure for any given type of LED on

 * a given child LED device node.

 Make sure LED type is supported */

 Create the name for classdev */

 Register the classdev */

 Go through LED device tree node and register LED classdev structure */

 while end */

 Platform driver probe */

 Platform driver remove */

 Disable LED operation */

 Destroy lock */

 Platform driver property match */

 SPDX-License-Identifier: GPL-2.0-only

/* leds-sunfire.c: SUNW,Ultra-Enterprise LED driver.

 *

 * Copyright (C) 2008 David S. Miller <davem@davemloft.net>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2007-2008 Extreme Engineering Solutions, Inc.

 *

 * Author: Nate Case <ncase@xes-inc.com>

 *

 * LED driver for various PCA955x I2C LED drivers

 *

 * Supported devices:

 *

 *	Device		Description		7-bit slave address

 *	------		-----------		-------------------

 *	PCA9550		2-bit driver		0x60 .. 0x61

 *	PCA9551		8-bit driver		0x60 .. 0x67

 *	PCA9552		16-bit driver		0x60 .. 0x67

 *	PCA9553/01	4-bit driver		0x62

 *	PCA9553/02	4-bit driver		0x63

 *

 * Philips PCA955x LED driver chips follow a register map as shown below:

 *

 *	Control Register		Description

 *	----------------		-----------

 *	0x0				Input register 0

 *					..

 *	NUM_INPUT_REGS - 1		Last Input register X

 *

 *	NUM_INPUT_REGS			Frequency prescaler 0

 *	NUM_INPUT_REGS + 1		PWM register 0

 *	NUM_INPUT_REGS + 2		Frequency prescaler 1

 *	NUM_INPUT_REGS + 3		PWM register 1

 *

 *	NUM_INPUT_REGS + 4		LED selector 0

 *	NUM_INPUT_REGS + 4

 *	    + NUM_LED_REGS - 1		Last LED selector

 *

 *  where NUM_INPUT_REGS and NUM_LED_REGS vary depending on how many

 *  bits the chip supports.

 LED select registers determine the source that drives LED outputs */

 Output LOW */

 Output HI-Z */

 Blink at PWM0 rate */

 Blink at PWM1 rate */

 7-bit slave address mask */

 Number of bits to ignore */

 110000x */ 0x60,

 1100xxx */ 0x60,

 1100xxx */ 0x60,

 0110xxx */ 0x30,

 110001x */ 0x62,

 0 .. 15 potentially */

 8 bits per input register */

 4 bits per LED selector register */

/*

 * Return an LED selector register value based on an existing one, with

 * the appropriate 2-bit state value set for the given LED number (0-3).

/*

 * Write to frequency prescaler register, used to program the

 * period of the PWM output.  period = (PSCx + 1) / 38

/*

 * Write to PWM register, which determines the duty cycle of the

 * output.  LED is OFF when the count is less than the value of this

 * register, and ON when it is greater.  If PWMx == 0, LED is always OFF.

 *

 * Duty cycle is (256 - PWMx) / 256

/*

 * Write to LED selector register, which determines the source that

 * drives the LED output.

/*

 * Read the LED selector register, which determines the source that

 * drives the LED output.

 which LSx to use (0-3 potentially) */

 which set of bits within LSx to use (0-3) */

		/*

		 * Use PWM1 for all other values.  This has the unwanted

		 * side effect of making all LEDs on the chip share the

		 * same brightness level if set to a value other than

		 * OFF, HALF, or FULL.  But, this is probably better than

		 * just turning off for all other values.

/*

 * Read the INPUT register, which contains the state of LEDs.

 There is nothing we can do about errors */

 To use as input ensure pin is not driven. */

 CONFIG_LEDS_PCA955X_GPIO */

 Make sure the slave address / chip type combo given is possible */

			/*

			 * For default-state == "keep", let the core update the

			 * brightness from the hardware, then check the

			 * brightness to see if it's using PWM1. If so, PWM1

			 * should not be written below.

 PWM0 is used for half brightness or 50% duty cycle */

 PWM1 is used for variable brightness, default to OFF */

 Set to fast frequency so we do not see flashing */

 Use data->gpio.dev as a flag for freeing gpiochip */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * LEDs driver for Freescale MC13783/MC13892/MC34708

 *

 * Copyright (C) 2010 Philippe Rétornaz

 *

 * Based on leds-da903x:

 * Copyright (C) 2008 Compulab, Ltd.

 *      Mike Rapoport <mike@compulab.co.il>

 *

 * Copyright (C) 2006-2008 Marvell International Ltd.

 *      Eric Miao <eric.miao@marvell.com>

 SPDX-License-Identifier: GPL-2.0-only

/*

 * LP5521 LED chip driver.

 *

 * Copyright (C) 2010 Nokia Corporation

 * Copyright (C) 2012 Texas Instruments

 *

 * Contact: Samu Onkalo <samu.p.onkalo@nokia.com>

 *          Milo(Woogyom) Kim <milo.kim@ti.com>

 Registers */

 Base register to set LED current */

 Base register to set the brightness */

 Bits in ENABLE register */

 Chip master enable */

 Logarithmic PWM adjustment */

 CONFIG register */

 PWM: 0 = 256Hz, 1 = 558Hz */

 1 = Power save mode */

 Charge pump (CP) off */

 CP forced to bypass mode */

 CP forced to 1.5x mode */

 Automatic mode selection */

 R out: 0 = CP, 1 = Vbat */

 Internal clock */

 Status */

 default R channel current register value */

 Reset register value */

 Program Memory Operations */

 Operation Mode Register */

 Enable Register */

 operation mode change needs to be longer than 153 us */

 it takes more 488 us to update ENABLE register */

 stop engine */

	/*

	 * To run the engine,

	 * operation mode and enable register should updated at the same time

 change operation mode to RUN only when each engine is loading */

 separate sscanfs because length is working only for %s */

 Each instruction is 16bit long. Check that length is even */

	/*

	 * Program memory sequence

	 *  1) set engine mode to "LOAD"

	 *  2) write firmware data into program memory

	/*

	 * Make sure that the chip is reset by reading back the r channel

	 * current reg. This is dummy read is required on some platforms -

	 * otherwise further access to the R G B channels in the

	 * LP5521_REG_ENABLE register will not have any effect - strange!

 Set all PWMs to direct control mode */

 Update configuration for the clock setting */

 Initialize all channels PWM to zero -> leds off */

 Set engines are set to run state when OP_MODE enables engines */

 Check that ext clock is really in use if requested */

 device attributes */

 Chip specific configurations */

 Three channel chip */

 SPDX-License-Identifier: GPL-2.0



 Copyright (C) 2018 BayLibre SAS

 Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>



 LED driver for MAXIM 77650/77651 charger/power-supply.

 Enable EN_LED_MSTR. */

 100% on duty */

 for backwards compatibility if `label` is not present */

/*

 * drivers/leds/leds-apu.c

 * Copyright (C) 2017 Alan Mizrahi, alan at mizrahi dot com dot ve

 *

 * Redistribution and use in source and binary forms, with or without

 * modification, are permitted provided that the following conditions are met:

 *

 * 1. Redistributions of source code must retain the above copyright

 *    notice, this list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright

 *    notice, this list of conditions and the following disclaimer in the

 *    documentation and/or other materials provided with the distribution.

 * 3. Neither the names of the copyright holders nor the names of its

 *    contributors may be used to endorse or promote products derived from

 *    this software without specific prior written permission.

 *

 * Alternatively, this software may be distributed under the terms of the

 * GNU General Public License ("GPL") version 2 as published by the Free

 * Software Foundation.

 *

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"

 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE

 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE

 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE

 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR

 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF

 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS

 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN

 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)

 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE

 * POSSIBILITY OF SUCH DAMAGE.

 LED access parameters */

 for ioread/iowrite */

 LED private data */

 LED profile */

 for devm_ioremap */

 PC Engines APU with factory bios "SageBios_PCEngines_APU-45" */

 PC Engines APU with "Mainline" bios >= 4.6.8 */

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2009,2018 Daniel Mack <daniel@zonque.org>

	/*

	 * The LT3593 resets its internal current level register to the maximum

	 * level on the first falling edge on the control pin. Each following

	 * falling edge decreases the current level by 625uA. Up to 32 pulses

	 * can be sent, so the maximum power reduction is 20mA.

	 * After a timeout of 128us, the value is taken from the register and

	 * applied is to the output driver.

 SPDX-License-Identifier: GPL-2.0

 TI LM3697 LED chip family driver

 Copyright (C) 2018 Texas Instruments Incorporated - https:
/**

 * struct lm3697_led -

 * @hvled_strings: Array of LED strings associated with a control bank

 * @label: LED label

 * @led_dev: LED class device

 * @priv: Pointer to the device struct

 * @lmu_data: Register and setting values for common code

 * @control_bank: Control bank the LED is associated to. 0 is control bank A

 *		   1 is control bank B

 * @enabled: LED brightness level (or LED_OFF)

 * @num_leds: Number of LEDs available

/**

 * struct lm3697 -

 * @enable_gpio: Hardware enable gpio

 * @regulator: LED supply regulator pointer

 * @client: Pointer to the I2C client

 * @regmap: Devices register map

 * @dev: Pointer to the devices device struct

 * @lock: Lock for reading/writing the device

 * @leds: Array of LED strings

 * @bank_cfg: OUTPUT_CONFIG register values

 * @num_banks: Number of control banks

 for backwards compatibility if `label` is not present */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Generic Syscon LEDs Driver

 *

 * Copyright (c) 2014, Linaro Limited

 * Author: Linus Walleij <linus.walleij@linaro.org>

/**

 * struct syscon_led - state container for syscon based LEDs

 * @cdev: LED class device for this LED

 * @map: regmap to access the syscon device backing this LED

 * @offset: the offset into the syscon regmap for the LED register

 * @mask: the bit in the register corresponding to the LED

 * @state: current state of the LED

 SPDX-License-Identifier: GPL-2.0-only

/*

 * leds-regulator.c - LED class driver for regulator driven LEDs.

 *

 * Copyright (C) 2009 Antonio Ospite <ospite@studenti.unina.it>

 *

 * Inspired by leds-wm8350 driver.

	/* even if regulator can't change voltages,

	 * we still assume it can change status

	 * and the LED can be turned on and off.

 to handle correctly an already enabled regulator */

 to expose the default value to userspace */

 Set the default led status */

 SPDX-License-Identifier: GPL-2.0

 TI LM36274 LED chip family driver

 Copyright (C) 2019 Texas Instruments Incorporated - https:
/**

 * struct lm36274

 * @pdev: platform device

 * @led_dev: led class device

 * @lmu_data: Register and setting values for common code

 * @regmap: Devices register map

 * @dev: Pointer to the devices device struct

 * @led_sources: The LED strings supported in this array

 * @num_leds: Number of LED strings are supported in this array

 There should only be 1 node */

 for backwards compatibility when `label` property is not present */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * TI LP8860 4-Channel LED Driver

 *

 * Copyright (C) 2014 Texas Instruments

 *

 * Author: Dan Murphy <dmurphy@ti.com>

/**

 * struct lp8860_led

 * @lock: Lock for reading/writing the device

 * @client: Pointer to the I2C client

 * @led_dev: led class device pointer

 * @regmap: Devices register map

 * @eeprom_regmap: EEPROM register map

 * @enable_gpio: VDDIO/EN gpio to enable communication interface

 * @regulator: LED supply regulator pointer

 Attempt to clear any faults */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2011 Pengutronix

 * Uwe Kleine-Koenig <u.kleine-koenig@pengutronix.de>

/**

 * gpio_led_register_device - register a gpio-led device

 * @pdata: the platform data used for the new device

 * @id: platform ID

 *

 * Makes a copy of pdata and pdata->leds and registers a new leds-gpio device

 * with the result. This allows to have pdata and pdata-leds in .init.rodata

 * and so saves some bytes compared to a static struct platform_device with

 * static platform data.

 *

 * Returns the registered device or an error pointer.

 SPDX-License-Identifier: GPL-2.0

/*

 * LED Driver for SGI Octane machines

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2019 Christian Mauderer <oss@c-mauderer.de>

/*

 * The driver supports controllers with a very simple SPI protocol:

 * - one LED is controlled by a single byte on MOSI

 * - the value of the byte gives the brightness between two values (lowest to

 *   highest)

 * - no return value is necessary (no MISO signal)

 *

 * The value for minimum and maximum brightness depends on the device

 * (compatible string).

 *

 * Supported devices:

 * - "ubnt,acb-spi-led": Microcontroller (SONiX 8F26E611LA) based device used

 *   for example in Ubiquiti airCube ISP. Reverse engineered protocol for this

 *   controller:

 *   * Higher two bits set a mode. Lower six bits are a parameter.

 *   * Mode: 00 -> set brightness between 0x00 (min) and 0x3F (max)

 *   * Mode: 01 -> pulsing pattern (min -> max -> min) with an interval. From

 *     some tests, the period is about (50ms + 102ms * parameter). There is a

 *     slightly different pattern starting from 0x10 (longer gap between the

 *     pulses) but the time still follows that calculation.

 *   * Mode: 10 -> same as 01 but with only a ramp from min to max. Again a

 *     slight jump in the pattern at 0x10.

 *   * Mode: 11 -> blinking (off -> 25% -> off -> 25% -> ...) with a period of

 *     (105ms * parameter)

 *   NOTE: This driver currently only supports mode 00.

 SPI byte that will be send to switch the LED off */

 SPI byte that will be send to switch the LED to maximum brightness */

 all other cases except "off" */

 SPDX-License-Identifier: GPL-2.0

/*

 * CZ.NIC's Turris Omnia LEDs driver

 *

 * 2020 by Marek Behún <kabel@kernel.org>

 put the LED into software mode */

 disable the LED */

/*

 * On the front panel of the Turris Omnia router there is also a button which

 * can be used to control the intensity of all the LEDs at once, so that if they

 * are too bright, user can dim them.

 * The microcontroller cycles between 8 levels of this global brightness (from

 * 100% to 0%), but this setting can have any integer value between 0 and 100.

 * It is therefore convenient to be able to change this setting from software.

 * We expose this setting via a sysfs attribute file called "brightness". This

 * file lives in the device directory of the LED controller, not an individual

 * LED, so it should not confuse users.

 put all LEDs into default (HW triggered) mode */

 set all LEDs color to [255, 255, 255] */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2011 bct electronic GmbH

 * Copyright 2013 Qtechnology/AS

 *

 * Author: Peter Meerwald <p.meerwald@bct-electronic.com>

 * Author: Ricardo Ribalda <ribalda@kernel.org>

 *

 * Based on leds-pca955x.c

 *

 * LED driver for the PCA9633 I2C LED driver (7-bit slave address 0x62)

 * LED driver for the PCA9634/5 I2C LED driver (7-bit slave address set by hw.)

 *

 * Note that hardware blinking violates the leds infrastructure driver

 * interface since the hardware only supports blinking all LEDs with the

 * same delay_on/delay_off rates.  That is, only the LEDs that are set to

 * blink will actually blink but all LEDs that are set to blink will blink

 * in identical fashion.  The delay_on/delay_off values of the last LED

 * that is set to blink will be used for all of the blinking LEDs.

 * Hardware blinking is disabled by default but can be enabled by setting

 * the 'blink_type' member in the platform_data struct to 'PCA963X_HW_BLINK'

 * or by adding the 'nxp,hw-blink' property to the DTS.

 LED select registers determine the source that drives LED outputs */

 LED driver off */

 LED driver on */

 Controlled through PWM */

 Controlled through PWM/GRPPWM */

 Open-drain or totem pole */

 Normal or inverted direction */

 Enable blinking */

 Total blink period in milliseconds */

 0 .. 15 potentially */

 If both zero, pick reasonable defaults of 500ms each */

 If period not supported by hardware, default to someting sane. */

	/*

	 * From manual: duty cycle = (GDC / 256) ->

	 *	(time_on / period) = (GDC / 256) ->

	 *		GDC = ((time_on * 256) / period)

	/*

	 * From manual: period = ((GFRQ + 1) / 24) in seconds.

	 * So, period (in ms) = (((GFRQ + 1) / 24) * 1000) ->

	 *		GFRQ = ((period * 24 / 1000) - 1)

 default to open-drain unless totem pole (push-pull) is specified */

 default to non-inverted output, unless inverted is specified */

 for backwards compatibility */

 Turn off LEDs by default*/

 Disable LED all-call address, and power down initially */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2011 ST-Ericsson SA.

 * Copyright (C) 2009 Motorola, Inc.

 *

 * Simple driver for National Semiconductor LM3530 Backlight driver chip

 *

 * Author: Shreshtha Kumar SAHU <shreshthakumar.sahu@stericsson.com>

 * based on leds-lm3530.c by Dan Murphy <D.Murphy@motorola.com>

 General Control Register */

 ALS Config Register Options */

 Brightness Ramp Rate Register */

 ALS Resistor Select */

 Zone Boundary Register defaults */

 Zone Target Register defaults */

 7 bits are used for the brightness : LM3530_BRT_CTRL_REG */

/**

 * struct lm3530_data

 * @led_dev: led class device

 * @client: i2c client

 * @pdata: LM3530 platform data

 * @mode: mode of operation - manual, ALS, PWM

 * @regulator: regulator

 * @brightness: previous brightness value

 * @enable: regulator is enabled

/*

 * struct lm3530_als_data

 * @config  : value of ALS configuration register

 * @imp_sel : value of ALS resistor select register

 * @zone    : values of ALS ZB(Zone Boundary) registers

 n zone boundary makes n+1 zones */

 LM3530_GEN_CONFIG */

 LM3530_ALS_CONFIG */

 LM3530_BRT_RAMP_RATE */

 LM3530_ALS_IMP_SELECT */

 LM3530_BRT_CTRL_REG */

 LM3530_ALS_ZB0_REG */

 LM3530_ALS_ZB1_REG */

 LM3530_ALS_ZB2_REG */

 LM3530_ALS_ZB3_REG */

 LM3530_ALS_Z0T_REG */

 LM3530_ALS_Z1T_REG */

 LM3530_ALS_Z2T_REG */

 LM3530_ALS_Z3T_REG */

 LM3530_ALS_Z4T_REG */

 do not update brightness register when pwm mode */

 set the brightness in brightness control register*/

 set pwm to low if unnecessary */

 BL mode */

 SPDX-License-Identifier: GPL-2.0+



 Driver for Panasonic AN30259A 3-channel LED driver



 Copyright (c) 2018 Simon Shields <simon@lineageos.org>



 Datasheet:

 https:
 LED power registers */

 slope control registers */

 detention time control (length of each slope step) */

 ms */

 ms */

 held when writing to registers */

 slope time can only be a multiple of 500ms. */

 up to a maximum of 7500ms. */

 if no blink specified, default to 1 Hz. */

 convert into values the HW will understand. */

 duty min should be zero (=off), delay should be zero. */

 reset detention time (no "breathing" effect). */

 slope time controls on/off cycle length. */

 Finally, enable slope mode. */

 sentinel */ },

 sentinel */ },

 SPDX-License-Identifier: GPL-2.0-only

/*

 * LED Flash class interface

 *

 * Copyright (C) 2015 Samsung Electronics Co., Ltd.

 * Author: Jacek Anaszewski <j.anaszewski@samsung.com>

 no lock needed for this */

 no lock needed for this */

 Select the sysfs attributes to be created for the device */

 Register led class device */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * linux/drivers/leds-pwm.c

 *

 * simple PWM based LED control

 *

 * Copyright 2009 Luotao Fu @ Pengutronix (l.fu@pengutronix.de)

 *

 * based on leds-gpio.c by Raphael Assenat <raph@8d.com>

 init PWM state */

 set brightness */

 SPDX-License-Identifier: GPL-2.0

 TI LP50XX LED chip family driver

 Copyright (C) 2018-20 Texas Instruments Incorporated - https:
 LP5009 and LP5012 registers */

 LP5018 and LP5024 registers */

 LP5030 and LP5036 registers */

 There are 3 LED outputs per bank */

 LEDX_BRT registers are all 0xff for defaults */

 OUTX_CLR registers are all 0x0 for defaults */

 LEDX_BRT registers are all 0xff for defaults */

 OUTX_CLR registers are all 0x0 for defaults */

 LEDX_BRT registers are all 0xff for defaults */

 OUTX_CLR registers are all 0x0 for defaults */

/**

 * struct lp50xx_chip_info -

 * @lp50xx_regmap_config: regmap register configuration

 * @model_id: LED device model

 * @max_modules: total number of supported LED modules

 * @num_leds: number of LED outputs available on the device

 * @led_brightness0_reg: first brightness register of the device

 * @mix_out0_reg: first color mix register of the device

 * @bank_brt_reg: bank brightness register

 * @bank_mix_reg: color mix register

 * @reset_reg: device reset register

/**

 * struct lp50xx -

 * @enable_gpio: hardware enable gpio

 * @regulator: LED supply regulator pointer

 * @client: pointer to the I2C client

 * @regmap: device register map

 * @dev: pointer to the devices device struct

 * @lock: lock for reading/writing the device

 * @chip_info: chip specific information (ie num_leds)

 * @num_of_banked_leds: holds the number of banked LEDs

 * @leds: array of LED strings

 This needs to be at the end of the struct */

		/*

		 * There are only 3 LEDs per module otherwise they should be

		 * banked which also is presented as 3 LEDs.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * TI LP8788 MFD - keyled driver

 *

 * Copyright 2012 Texas Instruments

 *

 * Author: Milo(Woogyom) Kim <milo.kim@ti.com>

 scale configuration */

 current configuration */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * LED Triggers Core

 *

 * Copyright 2005-2007 Openedhand Ltd.

 *

 * Author: Richard Purdie <rpurdie@openedhand.com>

/*

 * Nests outside led_cdev->trigger_lock

 Used by LED Class */

 we come here only if buf matches no trigger */

/*

 * It was stupid to create 10000 cpu triggers, but we are stuck with it now.

 * Don't make that mistake again. We work around it here by creating binary

 * attribute, which is not limited by length. This is _not_ good design, do not

 * copy it.

 Caller must ensure led_cdev->trigger_lock held */

 Remove any existing trigger */

 ensure it's no longer visible on the led_cdevs list */

 new name must be on a temporary string to prevent races */

	/* this assumes that trig->name was originaly allocated to

 LED Trigger Interface */

 Make sure the trigger's name isn't already in use */

 Add to the list of led triggers */

 Register with any LEDs that have this as a default trigger */

 Remove from the list of led triggers */

 Remove anyone actively using this trigger */

 Simple LED Trigger Interface */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * leds-ns2.c - Driver for the Network Space v2 (and parents) dual-GPIO LED

 *

 * Copyright (C) 2010 LaCie

 *

 * Author: Simon Guinot <sguinot@lacie.com>

 *

 * Based on leds-gpio.c by Raphael Assenat <raph@8d.com>

/*

 * If the size of this structure or types of its members is changed,

 * the filling of array modval in function ns2_led_register must be changed

 * accordingly.

/*

 * The Network Space v2 dual-GPIO LED is wired to a CPLD. Three different LED

 * modes are available: off, on and SATA activity blinking. The LED modes are

 * controlled through two GPIOs (command and slow): each combination of values

 * for the command/slow GPIOs corresponds to a LED mode.

 True when SATA mode active. */

 Lock GPIOs. */

 Set LED initial state. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * linux/drivers/leds/leds-locomo.c

 *

 * Copyright (C) 2005 John Lenz <lenz@cs.wisc.edu>

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  leds-blinkm.c

 *  (c) Jan-Simon Möller (dl9pf@gmx.de)

 Addresses to scan - BlinkM is on 0x09 by default*/

 used for led class interface */

 used for "blinkm" sysfs interface */

 color red */

 color green */

 color blue */

 next values to use for transfer */

 color red */

 color green */

 color blue */

 internal use */

 set of args for transmission */

 i2c addr */

 firmware version */

 used, but not from userspace */

 HSB  hue */

 HSB  saturation */

 HSB  brightness */

 HSB  hue */

 HSB  saturation */

 HSB  brightness */

 currently unused / todo */

 fade speed     1 - 255 */

 time adjust -128 - 127 */

 fade on = 1, off = 0 */

 rand fade mode on = 1 */

 script ID */

 repeats of script */

 line to start */

 Colors */

 mapping command names to cmd chars - see datasheet */

 Length & Repeats */

/* BlinkM Commands

 *  as extracted out of the datasheet:

 *

 *  cmdchar = command (ascii)

 *  cmdbyte = command in hex

 *  nr_args = number of arguments (to send)

 *  nr_ret  = number of return values (to read)

 *  dir = direction (0 = read, 1 = write, 2 = both)

 *

 cmdchar, cmdbyte, nr_args, nr_ret,  dir */

 if mode ... */

test */

 TODO: HSB, fade, timeadj, script ... */

 write out cmd to blinkm - always / default step */

 no args to write out */

 repeat for arglen */

 repeat for retlen */

	/* the protocol is simple but non-standard:

	 * e.g.  cmd 'g' (= 0x67) for "get device address"

	 * - which defaults to 0x09 - would be the sequence:

	 *   a) write 0x67 to the device (byte write)

	 *   b) read the value (0x09) back right after (byte read)

	 *

	 * Watch out for "unfinished" sequences (i.e. not enough reads

	 * or writes after a command. It will make the blinkM misbehave.

	 * Sequence is key here.

 args / return are in private data struct */

	/* We start hardware transfers which are not to be

 switch cmd - usually write before reads */

 end switch(cmd) */

 transfers done, unlock */

 led_brightness is 0, 127 or 255 - we just use it here as-is */

 bail out if there's no change */

 bail out if there's no change */

 bail out if there's no change */

 Return 0 if detection is successful, -ENODEV otherwise */

 Now, we do the remaining detection. Simple for now. */

 We might need more guards to protect other i2c slaves */

 make sure the blinkM is balanced (read/writes) */

 Step 1: Read BlinkM address back  -  cmd_char 'a' */

 allow a small delay */

 i2c addr  - use fake addr of 0x08 initially (real is 0x09) */

	/* firmware version - use fake until we read real value

 Register sysfs hooks */

 RED = 0, GREEN = 1, BLUE = 2 */

 end switch */

 end for */

 Initialize the blinkm */

 make sure no workqueue entries are pending */

 reset rgb */

 reset hsb */

 red fade to off */

 off */

 This is the driver that will be inserted */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * LEDs driver for PCEngines WRAP

 *

 * Copyright (C) 2006 Kristian Kielhofner <kris@krisk.org>

 *

 * Based on leds-net48xx.c

 SPDX-License-Identifier: GPL-2.0-only

/*

* Simple driver for Texas Instruments LM3642 LED Flash driver chip

* Copyright (C) 2012 Texas Instruments

 chip initialize */

 set enable register */

 chip control */

 brightness 0 means off-state */

 torch */

 torch pin config for lm3642 */

 flash */

 strobe pin config for lm3642*/

 indicator */

 flash */

 torch */

 indicator */

 SPDX-License-Identifier: GPL-2.0

 TI LM3692x LED chip family driver

 Copyright (C) 2017-18 Texas Instruments Incorporated - https:
 Brightness Control Bits */

 PWM Register Bits */

 Boost Control Bits */

 Fault Control Bits */

 Fault Flag Bits */

/**

 * struct lm3692x_led

 * @lock: Lock for reading/writing the device

 * @client: Pointer to the I2C client

 * @led_dev: LED class device pointer

 * @regmap: Devices register map

 * @enable_gpio: VDDIO/EN gpio to enable communication interface

 * @regulator: LED supply regulator pointer

 * @led_enable: LED sync to be enabled

 * @model_id: Current device model ID enumerated

	/* The first read may clear the fault.  Check again to see if the fault

	 * still exits and return that value.

	/*

	 * For glitch free operation, the following data should

	 * only be written while LEDx enable bits are 0 and the device enable

	 * bit is set to 1.

	 * per Section 7.5.14 of the data sheet

	/* Set the brightness to 0 so when enabled the LEDs do not come

	 * on with full brightness.

 see p.12 of LM36922 data sheet for brightness formula */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Driver for BCM6328 memory-mapped LEDs, based on leds-syscon.c

 *

 * Copyright 2015 Álvaro Fernández Rojas <noltari@gmail.com>

 * Copyright 2015 Jonas Gorski <jogo@openwrt.org>

/**

 * struct bcm6328_led - state container for bcm6328 based LEDs

 * @cdev: LED class device for this LED

 * @mem: memory resource

 * @lock: memory lock

 * @pin: LED pin number

 * @blink_leds: blinking LEDs

 * @blink_delay: blinking delay

 * @active_low: LED is active low

/*

 * LEDMode 64 bits / 24 LEDs

 * bits [31:0] -> LEDs 8-23

 * bits [47:32] -> LEDs 0-7

 * bits [63:48] -> unused

 LEDs 0-7 (bits 47:32) */

 LEDs 8-23 (bits 31:0) */

 Remove LED from cached HW blinking intervals */

 Set LED on/off */

	/*

	 * Check if any of the two configurable HW blinking intervals is

	 * available:

	 *   1. No LEDs assigned to the HW blinking interval.

	 *   2. Only this LED is assigned to the HW blinking interval.

	 *   3. LEDs with the same delay assigned.

 Add LED to the first HW blinking interval cache */

 Remove LED from the second HW blinking interval cache */

 Cache first HW blinking interval delay */

 Update the delay for the first HW blinking interval */

 Set the LED to first HW blinking interval */

 Remove LED from the first HW blinking interval */

 Add LED to the second HW blinking interval */

 Cache second HW blinking interval delay */

 Update the delay for the second HW blinking interval */

 Set the LED to second HW blinking interval */

 Only LEDs 0-7 can be activity/link controlled */

 memory lock */

 SPDX-License-Identifier: GPL-2.0

/*

 * Intel Lightning Mountain SoC LED Serial Shift Output Controller driver

 *

 * Copyright (c) 2020 Intel Corporation.

 Fixed Divider Shift Clock */

 Driver MACRO */

 0-rising, 1-falling */

/*

 * Update Source to update the SOUTs

 * SW - Software has to update the SWU bit

 * GPTC - General Purpose timer is used as clock source

 * FPID - Divided FSC clock (FPID) is used as clock source

 1 to 4 */

 5 to 8 */

 9 to 10 */

 led 0 - 23 in led 32 location */

 set blink rate idx */

 select clock source */

 HW blink off */

 set freq */

 set brightness */

 enable output */

 To exclude pins from control, use "gpio-reserved-ranges" */

 Clear all duty cycles */

 4 groups for total 32 pins */

 NO HW directly controlled pin by default */

 NO BLINK for all pins */

 OUTPUT 0 by default */

 update edge */

 Set GPIO update rate */

 Register shift clock */

 unregister led */

 clear HW control bit */

 default first freq rate */

 unregister leds */

 gate clock */

 fpid clock */

 SPDX-License-Identifier: GPL-2.0

 Copyright (C) 2020 Luca Weiss <luca@z3ntu.xyz>

 250ms */

 300ms */

 current timeout in us */

 maximum timeout in us */

 Init flash timeout setting */

 Init flash intensity setting */

	/*

	 * Set default timeout to FLASH_DEFAULT_TIMEOUT except if max_timeout

	 * from DT is lower.

 Register in the LED subsystem */

 Create V4L2 Flash subdev */

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0-only

/*

 * LED driver : leds-ktd2692.c

 *

 * Copyright (C) 2015 Samsung Electronics

 * Ingi Kim <ingi2.kim@samsung.com>

 Value related the movie mode */

 Value related the flash mode */

 Macro for getting offset of flash timeout */

 Base register address */

 Set bit coding time for expresswire interface */

 KTD2692 default length of name */

 Movie / Flash Mode Control */

 default */

 maximum LED current in movie mode */

 maximum LED current in flash mode */

 maximum flash timeout */

 max LED brightness level */

 Related LED Flash class device */

 secures access to the device */

	/*

	 * The Low Bit(0) and High Bit(1) is based on a time detection

	 * algorithm between time low and time high

	 * Time_(L_LB) : Low time of the Low Bit(0)

	 * Time_(H_LB) : High time of the LOW Bit(0)

	 * Time_(L_HB) : Low time of the High Bit(1)

	 * Time_(H_HB) : High time of the High Bit(1)

	 *

	 * It can be simplified to:

	 * Low Bit(0) : 2 * Time_(H_LB) < Time_(L_LB)

	 * High Bit(1) : 2 * Time_(L_HB) < Time_(H_HB)

	 * HIGH  ___           ____    _..     _________    ___

	 *          |_________|    |_..  |____|         |__|

	 * LOW        <L_LB>  <H_LB>     <L_HB>  <H_HB>

	 *          [  Low Bit (0) ]     [  High Bit(1) ]

 sentinel */ },

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * LED driver for Richtek RT8515 flash/torch white LEDs

 * found on some Samsung mobile phones.

 *

 * This is a 1.5A Boost dual channel driver produced around 2011.

 *

 * The component lacks a datasheet, but in the schematic picture

 * from the LG P970 service manual you can see the connections

 * from the RT8515 to the LED, with two resistors connected

 * from the pins "RFS" and "RTS" to ground.

 *

 * On the LG P970:

 * RFS (resistance flash setting?) is 20 kOhm

 * RTS (resistance torch setting?) is 39 kOhm

 *

 * Some sleuthing finds us the RT9387A which we have a datasheet for:

 * https://static5.arrow.com/pdfs/2014/7/27/8/21/12/794/rtt_/manual/94download_ds.jspprt9387a.jspprt9387a.pdf

 * This apparently works the same way so in theory this driver

 * should cover RT9387A as well. This has not been tested, please

 * update the compatibles if you add RT9387A support.

 *

 * Linus Walleij <linus.walleij@linaro.org>

 We can provide 15-700 mA out to the LED */

 The maximum intensity is 1-16 for flash and 1-100 for torch */

 Flash max timeout */

	/*

	 * Toggling a GPIO line with a small delay increases the

	 * brightness one step at a time.

 This is setting the torch light level */

 Off */

 Step it up to movie mode brightness using the flash pin */

 Max torch brightness requested */

 Enable LED flash mode and set brightness */

 Set timeout */

 Turn the LED off */

 After this the torch LED will be disabled */

 The timeout is stored in the led-class-flash core */

 Turn the LED off */

 Init flash timeout setting */

	/*

	 * Set default timeout to RT8515_TIMEOUT_US except if

	 * max_timeout from DT is lower.

 Configure the V2L2 flash subdevice */

	/*

	 * Init flash intensity setting: this is a linear scale

	 * capped from the device tree max intensity setting

	 * 1..flash_max_intensity

 Can't be 0 so 0 is undefined */

 Missing info in DT, OK go with hardware maxima */

	/*

	 * Formula from the datasheet, this is the maximum current

	 * defined by the hardware.

	/*

	 * Calculate max intensity (linear scaling)

	 * Formula is ((ua / 1000) / max_ma) * 100, then simplified

 ENF - Enable Flash line */

 ENT - Enable Torch line */

 Create a V4L2 Flash device if V4L2 flash is enabled */

		/*

		 * Continue without the V4L2 flash

		 * (we still have the classdev)

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0-only

 Reset registers to make sure all off before shutdown */

 SPDX-License-Identifier: GPL-2.0

 Flash and torch driver for Texas Instruments LM3601X LED

 Flash driver chip family

 Copyright (C) 2018 Texas Instruments Incorporated - https:
 Registers */

 Enable Mode bits */

 Flag Mask */

/**

 * struct lm3601x_led -

 * @fled_cdev: flash LED class device pointer

 * @client: Pointer to the I2C client

 * @regmap: Devices register map

 * @lock: Lock for reading/writing the device

 * @led_name: LED label for the Torch or IR LED

 * @flash_timeout: the timeout for the flash

 * @last_flag: last known flags register value

 * @torch_current_max: maximum current for the torch

 * @flash_current_max: maximum current for the flash

 * @max_flash_timeout: maximum timeout for the flash

 * @led_mode: The mode to enable either IR or Torch

 SPDX-License-Identifier: GPL-2.0-only

/*

 * drivers/leds/leds-as3645a.c - AS3645A and LM3555 flash controllers driver

 *

 * Copyright (C) 2008-2011 Nokia Corporation

 * Copyright (c) 2011, 2017 Intel Corporation.

 *

 * Based on drivers/media/i2c/as3645a.c.

 *

 * Contact: Sakari Ailus <sakari.ailus@iki.fi>

 Register definitions */

 Read-only Design info register: Reset state: xxxx 0001 */

/* Read-only Version control register: Reset state: 0000 0000

 * for first engineering samples

 Read / Write	(Indicator and timer register): Reset state: 0000 1111 */

 Read / Write	(Current set register): Reset state: 0110 1001 */

 Read / Write	(Control register): Reset state: 1011 0100 */

 Read only (D3 is read / write) (Fault and info): Reset state: 0000 x000 */

 Boost register */

 Password register is used to unlock boost register writing */

 W:0x60, R:0x61 */

 us */

 uA */

 uA */

 uA */

 LED numbers for Devicetree */

 Return negative errno else zero on success */

 Return negative errno else a data byte received from the device. */

/* -----------------------------------------------------------------------------

 * Hardware configuration and trigger

/**

 * as3645a_set_current - Set flash configuration registers

 * @flash: The flash

 *

 * Configure the hardware with flash, assist and indicator currents, as well as

 * flash timeout.

 *

 * Return 0 on success, or a negative error code if an I2C communication error

 * occurred.

/**

 * as3645a_set_control - Set flash control register

 * @flash: The flash

 * @mode: Desired output mode

 * @on: Desired output state

 *

 * Configure the hardware with output mode and state.

 *

 * Return 0 on success, or a negative error code if an I2C communication error

 * occurred.

 Configure output parameters and operation mode. */

 NOTE: reading register clears fault status */

 Register value 0 is 20 mA. */

 clear errors */

 read status */

 Verify the chip model and version. */

 Value 0 is off in LED class. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *	LED Flash class driver for the AAT1290

 *	1.5A Step-Up Current Regulator for Flash LEDs

 *

 *	Copyright (C) 2015, Samsung Electronics Co., Ltd.

 *	Author: Jacek Anaszewski <j.anaszewski@samsung.com>

 maximum LED current in movie mode */

 maximum LED current in flash mode */

 maximum flash timeout */

 external strobe capability */

 max LED brightness level */

 platform device data */

 secures access to the device */

 corresponding LED Flash class device */

 V4L2 Flash device */

 FLEN pin */

 EN|SET pin  */

 movie mode current scale */

 device mode */

 brightness cache */

 write address */

 write data */

 LED subsystem callbacks */

	/*

	 * To reenter movie mode after a flash event the part must be cycled

	 * off and back on to reset the movie mode and reprogrammed via the

	 * AS2Cwire. Therefore the brightness and movie_mode properties needs

	 * to be updated here to reflect the actual state.

	/*

	 * Don't do anything - flash timeout is cached in the led-class-flash

	 * core and will be applied in the strobe_set op, as writing the

	 * safety timer register spuriously turns the torch mode on.

	/*

	 * led-max-microamp will default to 1/20 of flash-max-microamp

	 * in case it is missing.

	/*

	 * Init non-linear movie mode current scale basing

	 * on the max flash current from led configuration.

 Init flash timeout setting */

 Initialize LED Flash class device */

 Register LED Flash class device */

 Create V4L2 Flash subdev. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * LED Flash class driver for the flash cell of max77693 mfd.

 *

 *	Copyright (C) 2015, Samsung Electronics Co., Ltd.

 *

 *	Authors: Jacek Anaszewski <j.anaszewski@samsung.com>

 *		 Andrzej Hajda <a.hajda@samsung.com>

 corresponding FLED output identifier */

 corresponding LED Flash class device */

 V4L2 Flash device */

 brightness cache */

 flash timeout cache */

 flash faults that may have occurred */

 parent mfd regmap */

 platform device data */

 secures access to the device */

 sub led data */

 maximum torch current values for FLED outputs */

 maximum flash current values for FLED outputs */

 current flash timeout cache */

 ITORCH register cache */

 mode of fled outputs */

 recently strobed fled */

 bitmask of FLED outputs use state (bit 0. - FLED1, bit 1. - FLED2) */

 FLED modes that can be set */

 arrangement of current outputs */

			/*

			 * Enable hw triggering also for torch mode, as some

			 * camera sensors use torch led to fathom ambient light

			 * conditions before strobing the flash.

 Reset the register only prior setting flash modes */

 Span the mode on FLED2 for joint iouts case */

	/*

	 * FLASH_EXTERNAL mode activates FLASHEN and TORCHEN pins in the device.

	 * Corresponding register bit fields interfere with SW triggered modes,

	 * thus clear them to ensure proper device configuration.

	/*

	 * Clear flash mode flag after setting the mode to avoid spurious flash

	 * strobing on each subsequent torch mode setting.

 Clear mode also on FLED2 for joint iouts case */

	/*

	 * Initialize only flash current. Torch current doesn't

	 * require initialization as ITORCH register is written with

	 * new value each time brightness_set op is called.

 LED subsystem callbacks */

 Boost must be enabled if both current outputs are used */

 Init flash intensity setting */

 Init flash timeout setting */

 Init flash faults config */

 Initialize LED Flash class device */

 Init flash timeout cache */

 Register in the LED subsystem */

 Register in the V4L2 subsystem. */

 Initialize LED Flash class device */

		/*

		 * Register LED Flash class device and corresponding

		 * V4L2 Flash device.

			/*

			 * At this moment FLED1 might have been already

			 * registered and it needs to be released.

 It is possible than only FLED2 was to be registered */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Activity LED trigger

 *

 * Copyright (C) 2017 Willy Tarreau <w@1wt.eu>

 * Partially based on Atsushi Nemoto's ledtrig-heartbeat.c.

 full brightness in case of panic */

	/* We come here every 100ms in the worst case, so that's 100M ns of

	 * cumulated time. By dividing by 2^16, we get the time resolution

	 * down to 16us, ensuring we won't overflow 32-bit computations below

	 * even up to 3k CPUs, while keeping divides cheap on smaller systems.

	/*

	 * Now we know the total boot_time multiplied by the number of CPUs, and

	 * the total idle+wait time for all CPUs. We'll compare how they evolved

	 * since last call. The % of overall CPU usage is :

	 *

	 *      1 - delta_idle / delta_boot

	 *

	 * What we want is that when the CPU usage is zero, the LED must blink

	 * slowly with very faint flashes that are detectable but not disturbing

	 * (typically 10ms every second, or 10ms ON, 990ms OFF). Then we want

	 * blinking frequency to increase up to the point where the load is

	 * enough to saturate one core in multi-core systems or 50% in single

	 * core systems. At this point it should reach 10 Hz with a 10/90 duty

	 * cycle (10ms ON, 90ms OFF). After this point, the blinking frequency

	 * remains stable (10 Hz) and only the duty cycle increases to report

	 * the activity, up to the point where we have 90ms ON, 10ms OFF when

	 * all cores are saturated. It's important that the LED never stays in

	 * a steady state so that it's easy to distinguish an idle or saturated

	 * machine from a hung one.

	 *

	 * This gives us :

	 *   - a target CPU usage of min(50%, 100%/#CPU) for a 10% duty cycle

	 *     (10ms ON, 90ms OFF)

	 *   - below target :

	 *      ON_ms  = 10

	 *      OFF_ms = 90 + (1 - usage/target) * 900

	 *   - above target :

	 *      ON_ms  = 10 + (usage-target)/(100%-target) * 80

	 *      OFF_ms = 90 - (usage-target)/(100%-target) * 80

	 *

	 * In order to keep a good responsiveness, we cap the sleep time to

	 * 100 ms and keep track of the sleep time left. This allows us to

	 * quickly change it if needed.

 ON  */

 OFF */

 ON  */

 OFF */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * LED Heartbeat Trigger

 *

 * Copyright (C) 2006 Atsushi Nemoto <anemo@mba.ocn.ne.jp>

 *

 * Based on Richard Purdie's ledtrig-timer.c and some arch's

 * CONFIG_HEARTBEAT code.

 acts like an actual heart beat -- ie thump-thump-pause... */

		/*

		 * The hyperbolic function below modifies the

		 * heartbeat period length in dependency of the

		 * current (1min) load. It goes through the points

		 * f(0)=1260, f(1)=860, f(5)=510, f(inf)->300.

 SPDX-License-Identifier: GPL-2.0

 Copyright 2017 Ben Whitten <ben.whitten@gmail.com>

 Copyright 2007 Oliver Jowett <oliver@opencloud.com>



 LED Kernel Netdev Trigger



 Toggles the LED to reflect the link and traffic state of a named net device



 Derived from ledtrig-timer.c which is:

  Copyright 2005-2006 Openedhand Ltd.

  Author: Richard Purdie <rpurdie@openedhand.com>

/*

 * Configurable sysfs attributes:

 *

 * device_name - network device name to monitor

 * interval - duration of LED blink, in milliseconds

 * link -  LED's normal state reflects whether the link is up

 *         (has carrier) or not

 * tx -  LED blinks on transmitted data

 * rx -  LED blinks on receive data

 *

		/* If we are looking for RX/TX start periodically

		 * checking stats

 impose some basic bounds on the timer interval */

 resets timer */

 here's the real work! */

 If we dont have a device, insure we are off */

 If we are not looking for RX/TX then return  */

 base state is ON (link present) */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * LED Kernel Default ON Trigger

 *

 * Copyright 2008 Nick Forbes <nick.forbes@incepta.com>

 *

 * Based on Richard Purdie's ledtrig-timer.c.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * LED Kernel Timer Trigger

 *

 * Copyright 2005-2006 Openedhand Ltd.

 *

 * Author: Richard Purdie <rpurdie@openedhand.com>

 led_blink_set() called by caller */

		/*

		 * Mark as initialized even on pattern_init() error because

		 * any consecutive call to it would produce the same error.

	/*

	 * If "set brightness to 0" is pending in workqueue, we don't

	 * want that to be reordered after blink_set()

 Stop blinking */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Kernel Panic LED Trigger

 *

 * Copyright 2016 Ezequiel Garcia <ezequiel@vanguardiasur.com.ar>

/*

 * This is called in a special context by the atomic panic

 * notifier. This means the trigger can be changed without

 * worrying about locking.

 Avoid the delayed blink path */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * One-shot LED Trigger

 *

 * Copyright 2012, Fabio Baltieri <fabio.baltieri@gmail.com>

 *

 * Based on ledtrig-timer.c by Richard Purdie <rpurdie@openedhand.com>

 content is ignored */

		/*

		 * Mark as initialized even on pattern_init() error because

		 * any consecutive call to it would produce the same error.

 Stop blinking */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * LED Disk Activity Trigger

 *

 * Copyright 2006 Openedhand Ltd.

 *

 * Author: Richard Purdie <rpurdie@openedhand.com>

 SPDX-License-Identifier: GPL-2.0



 LED Kernel Transient Trigger



 Transient trigger allows one shot timer activation. Please refer to

 Documentation/leds/ledtrig-transient.rst for details

 Copyright (C) 2012 Shuah Khan <shuahkhan@gmail.com>



 Based on Richard Purdie's ledtrig-timer.c and Atsushi Nemoto's

 ledtrig-heartbeat.c

 Design and use-case input from Jonas Bonn <jonas@southpole.se> and

 Neil Brown <neilb@suse.de>

 cancel the running timer */

 start timer if there is no active timer */

	/* state == 0 && transient_data->activate == 0

	/* state == 1 && transient_data->activate == 1

 SPDX-License-Identifier: GPL-2.0-only

/*

 * LED MTD trigger

 *

 * Copyright 2016 Ezequiel Garcia <ezequiel@vanguardiasur.com.ar>

 *

 * Based on LED IDE-Disk Activity Trigger

 *

 * Copyright 2006 Openedhand Ltd.

 *

 * Author: Richard Purdie <rpurdie@openedhand.com>

 SPDX-License-Identifier: GPL-2.0

/*

 * LED pattern trigger

 *

 * Idea discussed with Pavel Machek. Raphael Teysseyre implemented

 * the first version, Baolin Wang simplified and improved the approach.

/*

 * When doing gradual dimming, the led brightness will be updated

 * every 50 milliseconds.

	/*

	 * If current tuple's duration is less than the dimming interval,

	 * we should treat it as a step change of brightness instead of

	 * doing gradual dimming.

 Step change of brightness */

 Skip the tuple with zero duration */

 Select next tuple */

 Gradual dimming */

			/*

			 * If the accumulation time is larger than current

			 * tuple's duration, we should go next one and re-check

			 * if we repeated done.

 Accumulate the gradual dimming time */

 At least 2 tuples for software pattern. */

 Number 0 and negative numbers except -1 are invalid. */

 -1 means repeat indefinitely */

		/*

		 * Mark as initialized even on pattern_init() error because

		 * any consecutive call to it would produce the same error.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Camera Flash and Torch On/Off Trigger

 *

 * based on ledtrig-ide-disk.c

 *

 * Copyright 2013 Texas Instruments

 *

 * Author: Milo(Woogyom) Kim <milo.kim@ti.com>

 SPDX-License-Identifier: GPL-2.0

 exit without rescheduling */

 try to get the tty corresponding to $ttyname */

			/*

			 * A device with this name might appear later, so keep

			 * retrying.

 What to do? retry or abort */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ledtrig-gio.c - LED Trigger Based on GPIO events

 *

 * Copyright 2009 Felipe Balbi <me@felipebalbi.com>

 desired brightness when led is on */

 true when gpio is inverted */

 gpio that triggers the leds */

 After inverting, we need to update the LED. */

 After changing the GPIO, we need to update the LED. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ledtrig-cpu.c - LED trigger based on CPU activity

 *

 * This LED trigger will be registered for first 8 CPUs and named

 * as cpu0..cpu7. There's additional trigger called cpu that

 * is on when any CPU is active.

 *

 * If you want support for arbitrary number of CPUs, make it one trigger,

 * with additional sysfs file selecting which CPU to watch.

 *

 * It can be bound to any LED just like other triggers using either a

 * board file or via sysfs interface.

 *

 * An API named ledtrig_cpu is exported for any user, who want to add CPU

 * activity indication in their code.

 *

 * Copyright 2011 Linus Walleij <linus.walleij@linaro.org>

 * Copyright 2011 - 2012 Bryan Wu <bryan.wu@canonical.com>

/**

 * ledtrig_cpu - emit a CPU event as a trigger

 * @ledevt: CPU event to be emitted

 *

 * Emit a CPU event on a CPU core, which will trigger a

 * bound LED to turn on or turn off.

 Locate the correct CPU LED */

 Will turn the LED on, max brightness */

 Will turn the LED off */

 Will leave the LED as it is */

 Update trigger state */

 Supports up to 9999 cpu cores */

	/*

	 * Registering a trigger for all CPUs.

	/*

	 * Registering CPU led trigger for each CPU core here

	 * ignores CPU hotplug, but after this CPU hotplug works

	 * fine with this trigger.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Backlight emulation LED trigger

 *

 * Copyright 2008 (C) Rodolfo Giometti <giometti@linux.it>

 * Copyright 2008 (C) Eurotech S.p.A. <info@eurotech.it>

 If we aren't interested in this event, skip it immediately ... */

 After inverting, we need to update the LED. */

 SPDX-License-Identifier: GPL-2.0



 Audio Mute LED trigger



 SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)

/**

 * ntb_msi_init() - Initialize the MSI context

 * @ntb:	NTB device context

 *

 * This function must be called before any other ntb_msi function.

 * It initializes the context for MSI operations and maps

 * the peer memory windows.

 *

 * This function reserves the last N outbound memory windows (where N

 * is the number of peers).

 *

 * Return: Zero on success, otherwise a negative error number.

/**

 * ntb_msi_setup_mws() - Initialize the MSI inbound memory windows

 * @ntb:	NTB device context

 *

 * This function sets up the required inbound memory windows. It should be

 * called from a work function after a link up event.

 *

 * Over the entire network, this function will reserves the last N

 * inbound memory windows for each peer (where N is the number of peers).

 *

 * ntb_msi_init() must be called before this function.

 *

 * Return: Zero on success, otherwise a negative error number.

/**

 * ntb_msi_clear_mws() - Clear all inbound memory windows

 * @ntb:	NTB device context

 *

 * This function tears down the resources used by ntb_msi_setup_mws().

/**

 * ntbm_msi_request_threaded_irq() - allocate an MSI interrupt

 * @ntb:	NTB device context

 * @handler:	Function to be called when the IRQ occurs

 * @thread_fn:  Function to be called in a threaded interrupt context. NULL

 *              for clients which handle everything in @handler

 * @devname:    An ascii name for the claiming device, dev_name(dev) if NULL

 * @dev_id:     A cookie passed back to the handler function

 *

 * This function assigns an interrupt handler to an unused

 * MSI interrupt and returns the descriptor used to trigger

 * it. The descriptor can then be sent to a peer to trigger

 * the interrupt.

 *

 * The interrupt resource is managed with devres so it will

 * be automatically freed when the NTB device is torn down.

 *

 * If an IRQ allocated with this function needs to be freed

 * separately, ntbm_free_irq() must be used.

 *

 * Return: IRQ number assigned on success, otherwise a negative error number.

/**

 * ntbm_msi_free_irq() - free an interrupt

 * @ntb:	NTB device context

 * @irq:	Interrupt line to free

 * @dev_id:	Device identity to free

 *

 * This function should be used to manually free IRQs allocated with

 * ntbm_request_[threaded_]irq().

/**

 * ntb_msi_peer_trigger() - Trigger an interrupt handler on a peer

 * @ntb:	NTB device context

 * @peer:	Peer index

 * @desc:	MSI descriptor data which triggers the interrupt

 *

 * This function triggers an interrupt on a peer. It requires

 * the descriptor structure to have been passed from that peer

 * by some other means.

 *

 * Return: Zero on success, otherwise a negative error number.

/**

 * ntb_msi_peer_addr() - Get the DMA address to trigger a peer's MSI interrupt

 * @ntb:	NTB device context

 * @peer:	Peer index

 * @desc:	MSI descriptor data which triggers the interrupt

 * @msi_addr:   Physical address to trigger the interrupt

 *

 * This function allows using DMA engines to trigger an interrupt

 * (for example, trigger an interrupt to process the data after

 * sending it). To trigger the interrupt, write @desc.data to the address

 * returned in @msi_addr

 *

 * Return: Zero on success, otherwise a negative error number.

/*

 * This file is provided under a dual BSD/GPLv2 license.  When using or

 *   redistributing this file, you may do so under either license.

 *

 *   GPL LICENSE SUMMARY

 *

 *   Copyright(c) 2012 Intel Corporation. All rights reserved.

 *   Copyright (C) 2015 EMC Corporation. All Rights Reserved.

 *

 *   This program is free software; you can redistribute it and/or modify

 *   it under the terms of version 2 of the GNU General Public License as

 *   published by the Free Software Foundation.

 *

 *   BSD LICENSE

 *

 *   Copyright(c) 2012 Intel Corporation. All rights reserved.

 *   Copyright (C) 2015 EMC Corporation. All Rights Reserved.

 *

 *   Redistribution and use in source and binary forms, with or without

 *   modification, are permitted provided that the following conditions

 *   are met:

 *

 *     * Redistributions of source code must retain the above copyright

 *       notice, this list of conditions and the following disclaimer.

 *     * Redistributions in binary form must reproduce the above copy

 *       notice, this list of conditions and the following disclaimer in

 *       the documentation and/or other materials provided with the

 *       distribution.

 *     * Neither the name of Intel Corporation nor the names of its

 *       contributors may be used to endorse or promote products derived

 *       from this software without specific prior written permission.

 *

 *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS

 *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT

 *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR

 *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT

 *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,

 *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT

 *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,

 *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY

 *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT

 *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE

 *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 *

 * PCIe NTB Transport Linux driver

 *

 * Contact Information:

 * Jon Mason <jon.mason@intel.com>

 Only two-ports NTB devices are supported */

 ntb_queue list reference */

 pointers to data to be transferred */

 Only 64 QP's are allowed.  0-63 */

 ntb_rx_q_lock: synchronize access to rx_XXXX_q */

 Stats */

/**

 * ntb_transport_unregister_client_dev - Unregister NTB client device

 * @device_name: Name of NTB client device

 *

 * Unregister an NTB client device with the NTB transport layer

/**

 * ntb_transport_register_client_dev - Register NTB client device

 * @device_name: Name of NTB client device

 *

 * Register an NTB client device with the NTB transport layer

 setup and register client devices */

/**

 * ntb_transport_register_client - Register NTB client driver

 * @drv: NTB client driver to be registered

 *

 * Register an NTB client driver with the NTB transport layer

 *

 * RETURNS: An appropriate -ERRNO error value on error, or zero for success.

/**

 * ntb_transport_unregister_client - Unregister NTB client driver

 * @drv: NTB client driver to be unregistered

 *

 * Unregister an NTB client driver with the NTB transport layer

 *

 * RETURNS: An appropriate -ERRNO error value on error, or zero for success.

 Due to housekeeping, there must be atleast 2 buffs */

	/*

	 * Checking to see if we have more entries than the default.

	 * We should add additional entries if that is the case so we

	 * can be in sync with the transport frames.

 setup the hdr offsets with 0's */

	/*

	 * we must ensure that the memory address allocated is BAR size

	 * aligned in order for the XLAT register to take the value. This

	 * is a requirement of the hardware. It is recommended to setup CMA

	 * for BAR sizes equal or greater than 4MB.

 No need to re-setup */

 Alloc memory for receiving data.  Must be aligned */

 Notify HW the memory location of the receive buffer */

 Pass along the info to any clients */

	/* The scratchpad registers keep the values if the remote side

	 * goes down, blast them now to give them a sane value the next

	 * time they are accessed

 send the local info, in the opposite order of the way we read it */

 Query the remote side for its info */

 if there's an actual failure, we should just bail */

 query remote spad for qp ready bits */

 See if the remote side is up */

 Due to housekeeping, there must be atleast 2 buffs */

	/*

	 * If we are using MSI, and have at least one extra memory window,

	 * we will reserve the last MW for the MSI window.

 Limit the MW's based on the availability of scratchpads */

 verify that all the qp's are freed */

 we need to check DMA results if we are using DMA */

 Ensure that the data is fully copied out before clearing the flag */

	/* Limit the number of packets processed in a single interrupt to

	 * provide fairness to others

 there is more work to do */

 the doorbell bit is set: clear it */

 ntb_db_read ensures ntb_db_clear write is committed */

		/* an interrupt may have arrived between finishing

		 * ntb_process_rxc and clearing the doorbell bit:

		 * there might be some more work to do.

 we need to check DMA results if we are using DMA */

 resubmit via CPU */

	/* The entry length can only be zero if the packet is intended to be a

	 * "link down" or similar.  Since no payload is being sent in these

	 * cases, there is nothing to add to the completion queue.

	/*

	 * Using non-temporal mov to improve performance on non-cached

	 * writes, even though we aren't actually copying from user space.

 Ensure that the data is fully copied out before setting the flags */

/**

 * ntb_transport_create_queue - Create a new NTB transport layer queue

 * @rx_handler: receive callback function

 * @tx_handler: transmit callback function

 * @event_handler: event callback function

 *

 * Create a new NTB transport layer queue and provide the queue with a callback

 * routine for both transmit and receive.  The receive callback routine will be

 * used to pass up data when the transport has received it on the queue.   The

 * transmit callback routine will be called when the transport has completed the

 * transmission of the data on the queue and the data is ready to be freed.

 *

 * RETURNS: pointer to newly created ntb_queue, NULL on error.

 decrement free_queue to make it zero based */

/**

 * ntb_transport_free_queue - Frees NTB transport queue

 * @qp: NTB queue to be freed

 *

 * Frees NTB transport queue

		/* Putting the dma_chan to NULL will force any new traffic to be

		 * processed by the CPU instead of the DAM engine

		/* Try to be nice and wait for any queued DMA engine

		 * transactions to process before smashing it with a rock

		/* Putting the dma_chan to NULL will force any new traffic to be

		 * processed by the CPU instead of the DAM engine

		/* Try to be nice and wait for any queued DMA engine

		 * transactions to process before smashing it with a rock

/**

 * ntb_transport_rx_remove - Dequeues enqueued rx packet

 * @qp: NTB queue to be freed

 * @len: pointer to variable to write enqueued buffers length

 *

 * Dequeues unused buffers from receive queue.  Should only be used during

 * shutdown of qp.

 *

 * RETURNS: NULL error value on error, or void* for success.

/**

 * ntb_transport_rx_enqueue - Enqueue a new NTB queue entry

 * @qp: NTB transport layer queue the entry is to be enqueued on

 * @cb: per buffer pointer for callback function to use

 * @data: pointer to data buffer that incoming packets will be copied into

 * @len: length of the data buffer

 *

 * Enqueue a new receive buffer onto the transport queue into which a NTB

 * payload can be received into.

 *

 * RETURNS: An appropriate -ERRNO error value on error, or zero for success.

/**

 * ntb_transport_tx_enqueue - Enqueue a new NTB queue entry

 * @qp: NTB transport layer queue the entry is to be enqueued on

 * @cb: per buffer pointer for callback function to use

 * @data: pointer to data buffer that will be sent

 * @len: length of the data buffer

 *

 * Enqueue a new transmit buffer onto the transport queue from which a NTB

 * payload will be transmitted.  This assumes that a lock is being held to

 * serialize access to the qp.

 *

 * RETURNS: An appropriate -ERRNO error value on error, or zero for success.

/**

 * ntb_transport_link_up - Notify NTB transport of client readiness to use queue

 * @qp: NTB transport layer queue to be enabled

 *

 * Notify NTB transport layer of client readiness to use queue

/**

 * ntb_transport_link_down - Notify NTB transport to no longer enqueue data

 * @qp: NTB transport layer queue to be disabled

 *

 * Notify NTB transport layer of client's desire to no longer receive data on

 * transport queue specified.  It is the client's responsibility to ensure all

 * entries on queue are purged or otherwise handled appropriately.

/**

 * ntb_transport_link_query - Query transport link state

 * @qp: NTB transport layer queue to be queried

 *

 * Query connectivity to the remote system of the NTB transport queue

 *

 * RETURNS: true for link up or false for link down

/**

 * ntb_transport_qp_num - Query the qp number

 * @qp: NTB transport layer queue to be queried

 *

 * Query qp number of the NTB transport queue

 *

 * RETURNS: a zero based number specifying the qp number

/**

 * ntb_transport_max_size - Query the max payload size of a qp

 * @qp: NTB transport layer queue to be queried

 *

 * Query the maximum payload size permissible on the given qp

 *

 * RETURNS: the max payload size of a qp

 If DMA engine usage is possible, try to find the max size for that */

/*

 * This file is provided under a dual BSD/GPLv2 license.  When using or

 *   redistributing this file, you may do so under either license.

 *

 *   GPL LICENSE SUMMARY

 *

 *   Copyright (C) 2015 EMC Corporation. All Rights Reserved.

 *   Copyright (C) 2016 T-Platforms. All Rights Reserved.

 *

 *   This program is free software; you can redistribute it and/or modify

 *   it under the terms of version 2 of the GNU General Public License as

 *   published by the Free Software Foundation.

 *

 *   This program is distributed in the hope that it will be useful, but

 *   WITHOUT ANY WARRANTY; without even the implied warranty of

 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU

 *   General Public License for more details.

 *

 *   BSD LICENSE

 *

 *   Copyright (C) 2015 EMC Corporation. All Rights Reserved.

 *   Copyright (C) 2016 T-Platforms. All Rights Reserved.

 *

 *   Redistribution and use in source and binary forms, with or without

 *   modification, are permitted provided that the following conditions

 *   are met:

 *

 *     * Redistributions of source code must retain the above copyright

 *       notice, this list of conditions and the following disclaimer.

 *     * Redistributions in binary form must reproduce the above copy

 *       notice, this list of conditions and the following disclaimer in

 *       the documentation and/or other materials provided with the

 *       distribution.

 *     * Neither the name of Intel Corporation nor the names of its

 *       contributors may be used to endorse or promote products derived

 *       from this software without specific prior written permission.

 *

 *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS

 *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT

 *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR

 *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT

 *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,

 *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT

 *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,

 *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY

 *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT

 *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE

 *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 *

 * PCIe NTB Linux driver

 *

 * Contact Information:

 * Allen Hubbe <Allen.Hubbe@emc.com>

/*

 *   This file is provided under a dual BSD/GPLv2 license.  When using or

 *   redistributing this file, you may do so under either license.

 *

 *   GPL LICENSE SUMMARY

 *

 *   Copyright (C) 2015 EMC Corporation. All Rights Reserved.

 *   Copyright (C) 2017 T-Platforms. All Rights Reserved.

 *

 *   This program is free software; you can redistribute it and/or modify

 *   it under the terms of version 2 of the GNU General Public License as

 *   published by the Free Software Foundation.

 *

 *   This program is distributed in the hope that it will be useful, but

 *   WITHOUT ANY WARRANTY; without even the implied warranty of

 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU

 *   General Public License for more details.

 *

 *   BSD LICENSE

 *

 *   Copyright (C) 2015 EMC Corporation. All Rights Reserved.

 *   Copyright (C) 2017 T-Platforms. All Rights Reserved.

 *

 *   Redistribution and use in source and binary forms, with or without

 *   modification, are permitted provided that the following conditions

 *   are met:

 *

 *     * Redistributions of source code must retain the above copyright

 *       notice, this list of conditions and the following disclaimer.

 *     * Redistributions in binary form must reproduce the above copy

 *       notice, this list of conditions and the following disclaimer in

 *       the documentation and/or other materials provided with the

 *       distribution.

 *     * Neither the name of Intel Corporation nor the names of its

 *       contributors may be used to endorse or promote products derived

 *       from this software without specific prior written permission.

 *

 *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS

 *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT

 *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR

 *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT

 *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,

 *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT

 *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,

 *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY

 *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT

 *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE

 *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 *

 * PCIe NTB Pingpong Linux driver

/*

 * How to use this tool, by example.

 *

 * Assuming $DBG_DIR is something like:

 * '/sys/kernel/debug/ntb_perf/0000:00:03.0'

 * Suppose aside from local device there is at least one remote device

 * connected to NTB with index 0.

 *-----------------------------------------------------------------------------

 * Eg: install driver with specified delay between doorbell event and response

 *

 * root@self# insmod ntb_pingpong.ko delay_ms=1000

 *-----------------------------------------------------------------------------

 * Eg: get number of ping-pong cycles performed

 *

 * root@self# cat $DBG_DIR/count

 Find next available peer */

 Read pong data */

	/*

	 * Scratchpad and message data may differ, since message register can't

	 * be rewritten unless status is cleared. Additionally either of them

	 * might be unsupported

 Find global port index */

 Skip message events masking if unsupported */

 Might be not necessary */

 SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)

/*

 * This file is provided under a dual BSD/GPLv2 license.  When using or

 *   redistributing this file, you may do so under either license.

 *

 *   GPL LICENSE SUMMARY

 *

 *   Copyright (C) 2015 EMC Corporation. All Rights Reserved.

 *   Copyright (C) 2017 T-Platforms All Rights Reserved.

 *

 *   This program is free software; you can redistribute it and/or modify

 *   it under the terms of version 2 of the GNU General Public License as

 *   published by the Free Software Foundation.

 *

 *   This program is distributed in the hope that it will be useful, but

 *   WITHOUT ANY WARRANTY; without even the implied warranty of

 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU

 *   General Public License for more details.

 *

 *   BSD LICENSE

 *

 *   Copyright (C) 2015 EMC Corporation. All Rights Reserved.

 *   Copyright (C) 2017 T-Platforms All Rights Reserved.

 *

 *   Redistribution and use in source and binary forms, with or without

 *   modification, are permitted provided that the following conditions

 *   are met:

 *

 *     * Redistributions of source code must retain the above copyright

 *       notice, this list of conditions and the following disclaimer.

 *     * Redistributions in binary form must reproduce the above copy

 *       notice, this list of conditions and the following disclaimer in

 *       the documentation and/or other materials provided with the

 *       distribution.

 *     * Neither the name of Intel Corporation nor the names of its

 *       contributors may be used to endorse or promote products derived

 *       from this software without specific prior written permission.

 *

 *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS

 *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT

 *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR

 *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT

 *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,

 *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT

 *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,

 *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY

 *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT

 *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE

 *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 *

 * PCIe NTB Debugging Tool Linux driver

/*

 * How to use this tool, by example.

 *

 * Assuming $DBG_DIR is something like:

 * '/sys/kernel/debug/ntb_tool/0000:00:03.0'

 * Suppose aside from local device there is at least one remote device

 * connected to NTB with index 0.

 *-----------------------------------------------------------------------------

 * Eg: check local/peer device information.

 *

 * # Get local device port number

 * root@self# cat $DBG_DIR/port

 *

 * # Check local device functionality

 * root@self# ls $DBG_DIR

 * db            msg1          msg_sts     peer4/        port

 * db_event      msg2          peer0/      peer5/        spad0

 * db_mask       msg3          peer1/      peer_db       spad1

 * link          msg_event     peer2/      peer_db_mask  spad2

 * msg0          msg_mask      peer3/      peer_spad     spad3

 * # As one can see it supports:

 * # 1) four inbound message registers

 * # 2) four inbound scratchpads

 * # 3) up to six peer devices

 *

 * # Check peer device port number

 * root@self# cat $DBG_DIR/peer0/port

 *

 * # Check peer device(s) functionality to be used

 * root@self# ls $DBG_DIR/peer0

 * link             mw_trans0       mw_trans6        port

 * link_event       mw_trans1       mw_trans7        spad0

 * msg0             mw_trans2       peer_mw_trans0   spad1

 * msg1             mw_trans3       peer_mw_trans1   spad2

 * msg2             mw_trans4       peer_mw_trans2   spad3

 * msg3             mw_trans5       peer_mw_trans3

 * # As one can see we got:

 * # 1) four outbound message registers

 * # 2) four outbound scratchpads

 * # 3) eight inbound memory windows

 * # 4) four outbound memory windows

 *-----------------------------------------------------------------------------

 * Eg: NTB link tests

 *

 * # Set local link up/down

 * root@self# echo Y > $DBG_DIR/link

 * root@self# echo N > $DBG_DIR/link

 *

 * # Check if link with peer device is up/down:

 * root@self# cat $DBG_DIR/peer0/link

 *

 * # Block until the link is up/down

 * root@self# echo Y > $DBG_DIR/peer0/link_event

 * root@self# echo N > $DBG_DIR/peer0/link_event

 *-----------------------------------------------------------------------------

 * Eg: Doorbell registers tests (some functionality might be absent)

 *

 * # Set/clear/get local doorbell

 * root@self# echo 's 1' > $DBG_DIR/db

 * root@self# echo 'c 1' > $DBG_DIR/db

 * root@self# cat  $DBG_DIR/db

 *

 * # Set/clear/get local doorbell mask

 * root@self# echo 's 1' > $DBG_DIR/db_mask

 * root@self# echo 'c 1' > $DBG_DIR/db_mask

 * root@self# cat $DBG_DIR/db_mask

 *

 * # Ring/clear/get peer doorbell

 * root@peer# echo 's 1' > $DBG_DIR/peer_db

 * root@peer# echo 'c 1' > $DBG_DIR/peer_db

 * root@peer# cat $DBG_DIR/peer_db

 *

 * # Set/clear/get peer doorbell mask

 * root@self# echo 's 1' > $DBG_DIR/peer_db_mask

 * root@self# echo 'c 1' > $DBG_DIR/peer_db_mask

 * root@self# cat $DBG_DIR/peer_db_mask

 *

 * # Block until local doorbell is set with specified value

 * root@self# echo 1 > $DBG_DIR/db_event

 *-----------------------------------------------------------------------------

 * Eg: Message registers tests (functionality might be absent)

 *

 * # Set/clear/get in/out message registers status

 * root@self# echo 's 1' > $DBG_DIR/msg_sts

 * root@self# echo 'c 1' > $DBG_DIR/msg_sts

 * root@self# cat $DBG_DIR/msg_sts

 *

 * # Set/clear in/out message registers mask

 * root@self# echo 's 1' > $DBG_DIR/msg_mask

 * root@self# echo 'c 1' > $DBG_DIR/msg_mask

 *

 * # Get inbound message register #0 value and source of port index

 * root@self# cat  $DBG_DIR/msg0

 *

 * # Send some data to peer over outbound message register #0

 * root@self# echo 0x01020304 > $DBG_DIR/peer0/msg0

 *-----------------------------------------------------------------------------

 * Eg: Scratchpad registers tests (functionality might be absent)

 *

 * # Write/read to/from local scratchpad register #0

 * root@peer# echo 0x01020304 > $DBG_DIR/spad0

 * root@peer# cat $DBG_DIR/spad0

 *

 * # Write/read to/from peer scratchpad register #0

 * root@peer# echo 0x01020304 > $DBG_DIR/peer0/spad0

 * root@peer# cat $DBG_DIR/peer0/spad0

 *-----------------------------------------------------------------------------

 * Eg: Memory windows tests

 *

 * # Create inbound memory window buffer of specified size/get its base address

 * root@peer# echo 16384 > $DBG_DIR/peer0/mw_trans0

 * root@peer# cat $DBG_DIR/peer0/mw_trans0

 *

 * # Write/read data to/from inbound memory window

 * root@peer# echo Hello > $DBG_DIR/peer0/mw0

 * root@peer# head -c 7 $DBG_DIR/peer0/mw0

 *

 * # Map outbound memory window/check it settings (on peer device)

 * root@peer# echo 0xADD0BA5E:16384 > $DBG_DIR/peer0/peer_mw_trans0

 * root@peer# cat $DBG_DIR/peer0/peer_mw_trans0

 *

 * # Write/read data to/from outbound memory window (on peer device)

 * root@peer# echo olleH > $DBG_DIR/peer0/peer_mw0

 * root@peer# head -c 7 $DBG_DIR/peer0/peer_mw0

/*

 * Inbound and outbound memory windows descriptor. Union members selection

 * depends on the MW type the structure describes. mm_base/dma_base are the

 * virtual and DMA address of an inbound MW. io_base/tr_base are the MMIO

 * mapped virtual and xlat addresses of an outbound MW respectively.

/*

 * Wrapper structure is used to distinguish the outbound MW peers reference

 * within the corresponding DebugFS directory IO operation.

/*==============================================================================

 *                               NTB events handlers

 *==============================================================================

/*==============================================================================

 *                        Common read/write methods

 *==============================================================================

/*==============================================================================

 *                            Port read/write methods

 *==============================================================================

/*==============================================================================

 *                       Link state read/write methods

 *==============================================================================

/*==============================================================================

 *                  Memory windows read/write/setting methods

 *==============================================================================

 Initialize outbound memory windows */

 Initialize inbound memory windows and outbound MWs wrapper */

 Free outbound memory windows */

 Free outbound memory windows */

/*==============================================================================

 *                       Doorbell read/write methods

 *==============================================================================

/*==============================================================================

 *                       Scratchpads read/write methods

 *==============================================================================

 Initialize inbound scratchpad structures */

 Initialize outbound scratchpad structures */

/*==============================================================================

 *                       Messages read/write methods

 *==============================================================================

 Initialize inbound message structures */

 Initialize outbound message structures */

/*==============================================================================

 *                          Initialization methods

 *==============================================================================

 This modules is useless without dbgfs... */

/*

 * This file is provided under a dual BSD/GPLv2 license.  When using or

 *   redistributing this file, you may do so under either license.

 *

 *   GPL LICENSE SUMMARY

 *

 *   Copyright(c) 2015 Intel Corporation. All rights reserved.

 *   Copyright(c) 2017 T-Platforms. All Rights Reserved.

 *

 *   This program is free software; you can redistribute it and/or modify

 *   it under the terms of version 2 of the GNU General Public License as

 *   published by the Free Software Foundation.

 *

 *   BSD LICENSE

 *

 *   Copyright(c) 2015 Intel Corporation. All rights reserved.

 *   Copyright(c) 2017 T-Platforms. All Rights Reserved.

 *

 *   Redistribution and use in source and binary forms, with or without

 *   modification, are permitted provided that the following conditions

 *   are met:

 *

 *     * Redistributions of source code must retain the above copyright

 *       notice, this list of conditions and the following disclaimer.

 *     * Redistributions in binary form must reproduce the above copy

 *       notice, this list of conditions and the following disclaimer in

 *       the documentation and/or other materials provided with the

 *       distribution.

 *     * Neither the name of Intel Corporation nor the names of its

 *       contributors may be used to endorse or promote products derived

 *       from this software without specific prior written permission.

 *

 *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS

 *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT

 *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR

 *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT

 *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,

 *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT

 *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,

 *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY

 *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT

 *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE

 *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 *

 * PCIe NTB Perf Linux driver

/*

 * How to use this tool, by example.

 *

 * Assuming $DBG_DIR is something like:

 * '/sys/kernel/debug/ntb_perf/0000:00:03.0'

 * Suppose aside from local device there is at least one remote device

 * connected to NTB with index 0.

 *-----------------------------------------------------------------------------

 * Eg: install driver with specified chunk/total orders and dma-enabled flag

 *

 * root@self# insmod ntb_perf.ko chunk_order=19 total_order=28 use_dma

 *-----------------------------------------------------------------------------

 * Eg: check NTB ports (index) and MW mapping information

 *

 * root@self# cat $DBG_DIR/info

 *-----------------------------------------------------------------------------

 * Eg: start performance test with peer (index 0) and get the test metrics

 *

 * root@self# echo 0 > $DBG_DIR/run

 * root@self# cat $DBG_DIR/run

 no larger than 1M */

 512K */

 1G */

 default to 0 */

/*==============================================================================

 *                         Perf driver data definition

 *==============================================================================

 invalid spad command */

 send out buffer size */

 recv in  buffer size */

 send in  buffer xlat */

 recv out buffer xlat */

 clear allocated memory */

 init is done */

 link up state flag */

 Outbound MW params */

 Inbound MW params */

 NTB connection setup service */

 DMA-based test sync parameters */

 Data source and measured statistics */

 Global device index and peers descriptors */

 Performance measuring work-threads interface */

 Scratchpad/Message IO operations */

/*

 * Scratchpads-base commands interface

/*

 * Messages-base commands interface

/*==============================================================================

 *                           Static data declarations

 *==============================================================================

/*==============================================================================

 *                  NTB cross-link commands execution service

 *==============================================================================

	/*

	 * Perform predefined number of attempts before give up.

	 * We are sending the data to the port specific scratchpad, so

	 * to prevent a multi-port access race-condition. Additionally

	 * there is no need in local locking since only thread-safe

	 * service work is using this method.

	/*

	 * We start scanning all over, since cleared DB may have been set

	 * by any peer. Yes, it makes peer with smaller index being

	 * serviced with greater priority, but it's convenient for spad

	 * and message code unification and simplicity.

 Next command can be retrieved from now */

	/*

	 * Perform predefined number of attempts before give up. Message

	 * registers are free of race-condition problem when accessed

	 * from different ports, so we don't need splitting registers

	 * by global device index. We also won't have local locking,

	 * since the method is used from service work only.

 This call shall trigger peer message event */

 Next command can be retrieved from now */

 No need of memory barrier, since bit ops have invernal lock */

 Return 0 if no data left to process, otherwise an error */

 Just receive all available commands */

 Messages are only sent one-by-one */

 Outbuf size can be unaligned due to custom max_mw_size */

 Initialization is finally done */

 Get inbound MW parameters */

	/*

	 * We submit inbuf xlat transmission cmd for execution here to follow

	 * the code architecture, even though this method is called from service

	 * work itself so the command will be executed right after it returns.

 Might be not necessary */

/*==============================================================================

 *                      Performance measuring work-thread

 *==============================================================================

 Copied field is cleared on test launch stage */

 Give up CPU to give a chance for other threads to use it */

	/*

	 * If test finished without errors, termination isn't needed.

	 * We call it anyway just to be sure of the transfers completion.

	/*

	 * Perform stages in compliance with use_dma flag value.

	 * Test status is changed only if error happened, otherwise

	 * status -ENODATA is kept while test is on-fly. Results

	 * synchronization is performed only if test fininshed

	 * without an error or interruption.

/*==============================================================================

 *                               DebugFS nodes

 *==============================================================================

 They are made read-only for test exec safety and integrity */

/*==============================================================================

 *                        Basic driver initialization

 *==============================================================================

 Get outbound MW parameters and map it */

	/*

	 * Hardware with only two ports may not have unique port

	 * numbers. In this case, the gidxs should all be zero.

 SPDX-License-Identifier: GPL-2.0

/**

 * Host side endpoint driver to implement Non-Transparent Bridge functionality

 *

 * Copyright (C) 2020 Texas Instruments

 * Author: Kishon Vijay Abraham I <kishon@ti.com>

 1 Sec */

 Mutex to protect providing commands to NTB EPF */

 BAR that contains both control region and self spad region */

 BAR that contains peer spad region */

 BAR that contains Doorbell region and Memory window '1' */

 One Link interrupt and rest doorbell interrupt */

/*

 *   This file is provided under a GPLv2 license.  When using or

 *   redistributing this file, you may do so under that license.

 *

 *   GPL LICENSE SUMMARY

 *

 *   Copyright (C) 2016-2018 T-Platforms JSC All Rights Reserved.

 *

 *   This program is free software; you can redistribute it and/or modify it

 *   under the terms and conditions of the GNU General Public License,

 *   version 2, as published by the Free Software Foundation.

 *

 *   This program is distributed in the hope that it will be useful, but

 *   WITHOUT ANY WARRANTY; without even the implied warranty of

 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General

 *   Public License for more details.

 *

 *   You should have received a copy of the GNU General Public License along

 *   with this program; if not, one can be found http://www.gnu.org/licenses/.

 *

 *   The full GNU General Public License is included in this distribution in

 *   the file called "COPYING".

 *

 *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS

 *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT

 *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR

 *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT

 *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,

 *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT

 *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,

 *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY

 *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT

 *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE

 *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 *

 * IDT PCIe-switch NTB Linux driver

 *

 * Contact Information:

 * Serge Semin <fancer.lancer@gmail.com>, <Sergey.Semin@t-platforms.ru>

/*

 * NT Endpoint registers table simplifying a loop access to the functionally

 * related registers

/*

 * NT Endpoint ports data table with the corresponding pcie command, link

 * status, control and BAR-related registers

0*/	{ IDT_SW_NTP0_PCIECMDSTS,	IDT_SW_NTP0_PCIELCTLSTS,

1*/	{0},

2*/	{ IDT_SW_NTP2_PCIECMDSTS,	IDT_SW_NTP2_PCIELCTLSTS,

3*/	{0},

4*/	{ IDT_SW_NTP4_PCIECMDSTS,	IDT_SW_NTP4_PCIELCTLSTS,

5*/	{0},

6*/	{ IDT_SW_NTP6_PCIECMDSTS,	IDT_SW_NTP6_PCIELCTLSTS,

7*/	{0},

8*/	{ IDT_SW_NTP8_PCIECMDSTS,	IDT_SW_NTP8_PCIELCTLSTS,

9*/	{0},

10*/	{0},

11*/	{0},

12*/	{ IDT_SW_NTP12_PCIECMDSTS,	IDT_SW_NTP12_PCIELCTLSTS,

13*/	{0},

14*/	{0},

15*/	{0},

16*/	{ IDT_SW_NTP16_PCIECMDSTS,	IDT_SW_NTP16_PCIELCTLSTS,

17*/	{0},

18*/	{0},

19*/	{0},

20*/	{ IDT_SW_NTP20_PCIECMDSTS,	IDT_SW_NTP20_PCIELCTLSTS,

21*/	{0},

22*/	{0},

23*/	{0}

/*

 * IDT PCIe-switch partitions table with the corresponding control, status

 * and messages control registers

0*/	{ IDT_SW_SWPART0CTL,	IDT_SW_SWPART0STS,

1*/	{ IDT_SW_SWPART1CTL,	IDT_SW_SWPART1STS,

2*/	{ IDT_SW_SWPART2CTL,	IDT_SW_SWPART2STS,

3*/	{ IDT_SW_SWPART3CTL,	IDT_SW_SWPART3STS,

4*/	{ IDT_SW_SWPART4CTL,	IDT_SW_SWPART4STS,

5*/	{ IDT_SW_SWPART5CTL,	IDT_SW_SWPART5STS,

6*/	{ IDT_SW_SWPART6CTL,	IDT_SW_SWPART6STS,

7*/	{ IDT_SW_SWPART7CTL,	IDT_SW_SWPART7STS,

/*

 * DebugFS directory to place the driver debug file

/*=============================================================================

 *                1. IDT PCIe-switch registers IO-functions

 *

 *    Beside ordinary configuration space registers IDT PCIe-switch expose

 * global configuration registers, which are used to determine state of other

 * device ports as well as being notified of some switch-related events.

 * Additionally all the configuration space registers of all the IDT

 * PCIe-switch functions are mapped to the Global Address space, so each

 * function can determine a configuration of any other PCI-function.

 *    Functions declared in this chapter are created to encapsulate access

 * to configuration and global registers, so the driver code just need to

 * provide IDT NTB hardware descriptor and a register address.

 *=============================================================================

/*

 * idt_nt_write() - PCI configuration space registers write method

 * @ndev:	IDT NTB hardware driver descriptor

 * @reg:	Register to write data to

 * @data:	Value to write to the register

 *

 * IDT PCIe-switch registers are all Little endian.

	/*

	 * It's obvious bug to request a register exceeding the maximum possible

	 * value as well as to have it unaligned.

 Just write the value to the specified register */

/*

 * idt_nt_read() - PCI configuration space registers read method

 * @ndev:	IDT NTB hardware driver descriptor

 * @reg:	Register to write data to

 *

 * IDT PCIe-switch Global configuration registers are all Little endian.

 *

 * Return: register value

	/*

	 * It's obvious bug to request a register exceeding the maximum possible

	 * value as well as to have it unaligned.

 Just read the value from the specified register */

/*

 * idt_sw_write() - Global registers write method

 * @ndev:	IDT NTB hardware driver descriptor

 * @reg:	Register to write data to

 * @data:	Value to write to the register

 *

 * IDT PCIe-switch Global configuration registers are all Little endian.

	/*

	 * It's obvious bug to request a register exceeding the maximum possible

	 * value as well as to have it unaligned.

 Lock GASA registers operations */

 Set the global register address */

 Put the new value of the register */

 Unlock GASA registers operations */

/*

 * idt_sw_read() - Global registers read method

 * @ndev:	IDT NTB hardware driver descriptor

 * @reg:	Register to write data to

 *

 * IDT PCIe-switch Global configuration registers are all Little endian.

 *

 * Return: register value

	/*

	 * It's obvious bug to request a register exceeding the maximum possible

	 * value as well as to have it unaligned.

 Lock GASA registers operations */

 Set the global register address */

 Get the data of the register (read ops acts as MMIO barrier) */

 Unlock GASA registers operations */

/*

 * idt_reg_set_bits() - set bits of a passed register

 * @ndev:	IDT NTB hardware driver descriptor

 * @reg:	Register to change bits of

 * @reg_lock:	Register access spin lock

 * @valid_mask:	Mask of valid bits

 * @set_bits:	Bitmask to set

 *

 * Helper method to check whether a passed bitfield is valid and set

 * corresponding bits of a register.

 *

 * WARNING! Make sure the passed register isn't accessed over plane

 * idt_nt_write() method (read method is ok to be used concurrently).

 *

 * Return: zero on success, negative error on invalid bitmask.

 Lock access to the register unless the change is written back */

 Unlock the register */

/*

 * idt_reg_clear_bits() - clear bits of a passed register

 * @ndev:	IDT NTB hardware driver descriptor

 * @reg:	Register to change bits of

 * @reg_lock:	Register access spin lock

 * @set_bits:	Bitmask to clear

 *

 * Helper method to check whether a passed bitfield is valid and clear

 * corresponding bits of a register.

 *

 * NOTE! Invalid bits are always considered cleared so it's not an error

 * to clear them over.

 *

 * WARNING! Make sure the passed register isn't accessed over plane

 * idt_nt_write() method (read method is ok to use concurrently).

 Lock access to the register unless the change is written back */

 Unlock the register */

/*===========================================================================

 *                           2. Ports operations

 *

 *    IDT PCIe-switches can have from 3 up to 8 ports with possible

 * NT-functions enabled. So all the possible ports need to be scanned looking

 * for NTB activated. NTB API will have enumerated only the ports with NTB.

 *===========================================================================

/*

 * idt_scan_ports() - scan IDT PCIe-switch ports collecting info in the tables

 * @ndev:	Pointer to the PCI device descriptor

 *

 * Return: zero on success, otherwise a negative error number.

 Retrieve the local port number */

 Retrieve the local partition number */

 Initialize port/partition -> index tables with invalid values */

	/*

	 * Walk over all the possible ports checking whether any of them has

	 * NT-function activated

 Skip local port */

 Read the port status register to get it partition */

 Retrieve the partition status */

 Check if partition state is active and port has NTB */

 Save the port and partition numbers */

 Fill in the port/partition -> index tables */

 It's useless to have this driver loaded if there is no any peer */

/*

 * idt_ntb_port_number() - get the local port number

 * @ntb:	NTB device context.

 *

 * Return: the local port number

/*

 * idt_ntb_peer_port_count() - get the number of peer ports

 * @ntb:	NTB device context.

 *

 * Return the count of detected peer NT-functions.

 *

 * Return: number of peer ports

/*

 * idt_ntb_peer_port_number() - get peer port by given index

 * @ntb:	NTB device context.

 * @pidx:	Peer port index.

 *

 * Return: peer port or negative error

 Return the detected NT-function port number */

/*

 * idt_ntb_peer_port_idx() - get peer port index by given port number

 * @ntb:	NTB device context.

 * @port:	Peer port number.

 *

 * Internal port -> index table is pre-initialized with -EINVAL values,

 * so we just need to return it value

 *

 * Return: peer NT-function port index or negative error

/*===========================================================================

 *                         3. Link status operations

 *    There is no any ready-to-use method to have peer ports notified if NTB

 * link is set up or got down. Instead global signal can be used instead.

 * In case if any one of ports changes local NTB link state, it sends

 * global signal and clears corresponding global state bit. Then all the ports

 * receive a notification of that, so to make client driver being aware of

 * possible NTB link change.

 *    Additionally each of active NT-functions is subscribed to PCIe-link

 * state changes of peer ports.

 *===========================================================================

/*

 * idt_init_link() - Initialize NTB link state notification subsystem

 * @ndev:	IDT NTB hardware driver descriptor

 *

 * Function performs the basic initialization of some global registers

 * needed to enable IRQ-based notifications of PCIe Link Up/Down and

 * Global Signal events.

 * NOTE Since it's not possible to determine when all the NTB peer drivers are

 * unloaded as well as have those registers accessed concurrently, we must

 * preinitialize them with the same value and leave it uncleared on local

 * driver unload.

 Initialize spin locker of Mapping Table access registers */

 Walk over all detected peers collecting port and partition masks */

 Clean the Link Up/Down and GLobal Signal status registers */

 Unmask NT-activated partitions to receive Global Switch events */

 Enable PCIe Link Up events of NT-activated ports */

 Enable PCIe Link Down events of NT-activated ports */

 Unmask NT-activated partitions to receive Global Signal events */

 Unmask Link Up/Down and Global Switch Events */

/*

 * idt_deinit_link() - deinitialize link subsystem

 * @ndev:	IDT NTB hardware driver descriptor

 *

 * Just disable the link back.

 Disable the link */

/*

 * idt_se_isr() - switch events ISR

 * @ndev:	IDT NTB hardware driver descriptor

 * @ntint_sts:	NT-function interrupt status

 *

 * This driver doesn't support IDT PCIe-switch dynamic reconfigurations,

 * Failover capability, etc, so switch events are utilized to notify of

 * PCIe and NTB link events.

 * The method is called from PCIe ISR bottom-half routine.

 Read Switch Events status */

 Clean the Link Up/Down and Global Signal status registers */

 Clean the corresponding interrupt bit */

 Notify the client driver of possible link state change */

/*

 * idt_ntb_local_link_enable() - enable the local NTB link.

 * @ndev:	IDT NTB hardware driver descriptor

 *

 * In order to enable the NTB link we need:

 * - enable Completion TLPs translation

 * - initialize mapping table to enable the Request ID translation

 * - notify peers of NTB link state change

 Enable the ID protection and Completion TLPs translation */

 Retrieve the current Requester ID (Bus:Device:Function) */

	/*

	 * Set the corresponding NT Mapping table entry of port partition index

	 * with the data to perform the Request ID translation

 Notify the peers by setting and clearing the global signal bit */

/*

 * idt_ntb_local_link_disable() - disable the local NTB link.

 * @ndev:	IDT NTB hardware driver descriptor

 *

 * In order to enable the NTB link we need:

 * - disable Completion TLPs translation

 * - clear corresponding mapping table entry

 * - notify peers of NTB link state change

 Disable Completion TLPs translation */

 Clear the corresponding NT Mapping table entry */

 Notify the peers by setting and clearing the global signal bit */

/*

 * idt_ntb_local_link_is_up() - test wethter local NTB link is up

 * @ndev:	IDT NTB hardware driver descriptor

 *

 * Local link is up under the following conditions:

 * - Bus mastering is enabled

 * - NTCTL has Completion TLPs translation enabled

 * - Mapping table permits Request TLPs translation

 * NOTE: We don't need to check PCIe link state since it's obviously

 * up while we are able to communicate with IDT PCIe-switch

 *

 * Return: true if link is up, otherwise false

 Read the local Bus Master Enable status */

 Read the local Completion TLPs translation enable status */

 Read Mapping table entry corresponding to the local partition */

/*

 * idt_ntb_peer_link_is_up() - test whether peer NTB link is up

 * @ndev:	IDT NTB hardware driver descriptor

 * @pidx:	Peer port index

 *

 * Peer link is up under the following conditions:

 * - PCIe link is up

 * - Bus mastering is enabled

 * - NTCTL has Completion TLPs translation enabled

 * - Mapping table permits Request TLPs translation

 *

 * Return: true if link is up, otherwise false

 Retrieve the device port number */

 Check whether PCIe link is up */

 Check whether bus mastering is enabled on the peer port */

 Check if Completion TLPs translation is enabled on the peer port */

 Read Mapping table entry corresponding to the peer partition */

/*

 * idt_ntb_link_is_up() - get the current ntb link state (NTB API callback)

 * @ntb:	NTB device context.

 * @speed:	OUT - The link speed expressed as PCIe generation number.

 * @width:	OUT - The link width expressed as the number of PCIe lanes.

 *

 * Get the bitfield of NTB link states for all peer ports

 *

 * Return: bitfield of indexed ports link state: bit is set/cleared if the

 *         link is up/down respectively.

 Retrieve the local link speed and width */

 If local NTB link isn't up then all the links are considered down */

 Collect all the peer ports link states into the bitfield */

/*

 * idt_ntb_link_enable() - enable local port ntb link (NTB API callback)

 * @ntb:	NTB device context.

 * @max_speed:	The maximum link speed expressed as PCIe generation number.

 * @max_width:	The maximum link width expressed as the number of PCIe lanes.

 *

 * Enable just local NTB link. PCIe link parameters are ignored.

 *

 * Return: always zero.

 Just enable the local NTB link */

/*

 * idt_ntb_link_disable() - disable local port ntb link (NTB API callback)

 * @ntb:	NTB device context.

 *

 * Disable just local NTB link.

 *

 * Return: always zero.

 Just disable the local NTB link */

/*=============================================================================

 *                         4. Memory Window operations

 *

 *    IDT PCIe-switches have two types of memory windows: MWs with direct

 * address translation and MWs with LUT based translation. The first type of

 * MWs is simple map of corresponding BAR address space to a memory space

 * of specified target port. So it implemets just ont-to-one mapping. Lookup

 * table in its turn can map one BAR address space to up to 24 different

 * memory spaces of different ports.

 *    NT-functions BARs can be turned on to implement either direct or lookup

 * table based address translations, so:

 * BAR0 - NT configuration registers space/direct address translation

 * BAR1 - direct address translation/upper address of BAR0x64

 * BAR2 - direct address translation/Lookup table with either 12 or 24 entries

 * BAR3 - direct address translation/upper address of BAR2x64

 * BAR4 - direct address translation/Lookup table with either 12 or 24 entries

 * BAR5 - direct address translation/upper address of BAR4x64

 *    Additionally BAR2 and BAR4 can't have 24-entries LUT enabled at the same

 * time. Since the BARs setup can be rather complicated this driver implements

 * a scanning algorithm to have all the possible memory windows configuration

 * covered.

 *

 * NOTE 1 BAR setup must be done before Linux kernel enumerated NT-function

 * of any port, so this driver would have memory windows configurations fixed.

 * In this way all initializations must be performed either by platform BIOS

 * or using EEPROM connected to IDT PCIe-switch master SMBus.

 *

 * NOTE 2 This driver expects BAR0 mapping NT-function configuration space.

 * Easy calculation can give us an upper boundary of 29 possible memory windows

 * per each NT-function if all the BARs are of 32bit type.

 *=============================================================================

/*

 * idt_get_mw_count() - get memory window count

 * @mw_type:	Memory window type

 *

 * Return: number of memory windows with respect to the BAR type

/*

 * idt_get_mw_name() - get memory window name

 * @mw_type:	Memory window type

 *

 * Return: pointer to a string with name

/*

 * idt_scan_mws() - scan memory windows of the port

 * @ndev:	IDT NTB hardware driver descriptor

 * @port:	Port to get number of memory windows for

 * @mw_cnt:	Out - number of memory windows

 *

 * It walks over BAR setup registers of the specified port and determines

 * the memory windows parameters if any activated.

 *

 * Return: array of memory windows

 Retrieve the array of the BARs registers */

 Scan all the BARs belonging to the port */

 Read BARSETUP register value */

 Skip disabled BARs */

 Skip next BARSETUP if current one has 64bit addressing */

 Skip configuration space mapping BARs */

 Retrieve MW type/entries count and aperture size */

 Save configurations of all available memory windows */

			/*

			 * IDT can expose a limited number of MWs, so it's bug

			 * to have more than the driver expects

 Save basic MW info */

 It's always DWORD aligned */

 DIR and LUT approachs differently configure MWs */

 Allocate memory for memory window descriptors */

 Copy the info of detected memory windows */

/*

 * idt_init_mws() - initialize memory windows subsystem

 * @ndev:	IDT NTB hardware driver descriptor

 *

 * Scan BAR setup registers of local and peer ports to determine the

 * outbound and inbound memory windows parameters

 *

 * Return: zero on success, otherwise a negative error number

 Scan memory windows of the local port */

 Scan memory windows of the peer ports */

 Initialize spin locker of the LUT registers */

/*

 * idt_ntb_mw_count() - number of inbound memory windows (NTB API callback)

 * @ntb:	NTB device context.

 * @pidx:	Port index of peer device.

 *

 * The value is returned for the specified peer, so generally speaking it can

 * be different for different port depending on the IDT PCIe-switch

 * initialization.

 *

 * Return: the number of memory windows.

/*

 * idt_ntb_mw_get_align() - inbound memory window parameters (NTB API callback)

 * @ntb:	NTB device context.

 * @pidx:	Port index of peer device.

 * @widx:	Memory window index.

 * @addr_align:	OUT - the base alignment for translating the memory window

 * @size_align:	OUT - the size alignment for translating the memory window

 * @size_max:	OUT - the maximum size of the memory window

 *

 * The peer memory window parameters have already been determined, so just

 * return the corresponding values, which mustn't change within session.

 *

 * Return: Zero on success, otherwise a negative error number.

/*

 * idt_ntb_peer_mw_count() - number of outbound memory windows

 *			     (NTB API callback)

 * @ntb:	NTB device context.

 *

 * Outbound memory windows parameters have been determined based on the

 * BAR setup registers value, which are mostly constants within one session.

 *

 * Return: the number of memory windows.

/*

 * idt_ntb_peer_mw_get_addr() - get map address of an outbound memory window

 *				(NTB API callback)

 * @ntb:	NTB device context.

 * @widx:	Memory window index (within ntb_peer_mw_count() return value).

 * @base:	OUT - the base address of mapping region.

 * @size:	OUT - the size of mapping region.

 *

 * Return just parameters of BAR resources mapping. Size reflects just the size

 * of the resource

 *

 * Return: Zero on success, otherwise a negative error number.

 Mapping address is just properly shifted BAR resource start */

 Mapping size has already been calculated at MWs scanning */

/*

 * idt_ntb_peer_mw_set_trans() - set a translation address of a memory window

 *				 (NTB API callback)

 * @ntb:	NTB device context.

 * @pidx:	Port index of peer device the translation address received from.

 * @widx:	Memory window index.

 * @addr:	The dma address of the shared memory to access.

 * @size:	The size of the shared memory to access.

 *

 * The Direct address translation and LUT base translation is initialized a

 * bit differenet. Although the parameters restriction are now determined by

 * the same code.

 *

 * Return: Zero on success, otherwise an error number.

	/*

	 * Retrieve the memory window config to make sure the passed arguments

	 * fit it restrictions

 DIR and LUT based translations are initialized differently */

 Set destination partition of translation */

 Set translation base address */

 Set the custom BAR aperture limit */

 Initialize corresponding LUT entry */

 Limit address isn't specified since size is fixed for LUT */

/*

 * idt_ntb_peer_mw_clear_trans() - clear the outbound MW translation address

 *				   (NTB API callback)

 * @ntb:	NTB device context.

 * @pidx:	Port index of peer device.

 * @widx:	Memory window index.

 *

 * It effectively disables the translation over the specified outbound MW.

 *

 * Return: Zero on success, otherwise an error number.

 DIR and LUT based translations are initialized differently */

 Read BARSETUP to check BAR type */

 Disable translation by specifying zero BAR limit */

 Clear the corresponding LUT entry up */

/*=============================================================================

 *                          5. Doorbell operations

 *

 *    Doorbell functionality of IDT PCIe-switches is pretty unusual. First of

 * all there is global doorbell register which state can be changed by any

 * NT-function of the IDT device in accordance with global permissions. These

 * permissions configs are not supported by NTB API, so it must be done by

 * either BIOS or EEPROM settings. In the same way the state of the global

 * doorbell is reflected to the NT-functions local inbound doorbell registers.

 * It can lead to situations when client driver sets some peer doorbell bits

 * and get them bounced back to local inbound doorbell if permissions are

 * granted.

 *    Secondly there is just one IRQ vector for Doorbell, Message, Temperature

 * and Switch events, so if client driver left any of Doorbell bits set and

 * some other event occurred, the driver will be notified of Doorbell event

 * again.

 *=============================================================================

/*

 * idt_db_isr() - doorbell event ISR

 * @ndev:	IDT NTB hardware driver descriptor

 * @ntint_sts:	NT-function interrupt status

 *

 * Doorbell event happans when DBELL bit of NTINTSTS switches from 0 to 1.

 * It happens only when unmasked doorbell bits are set to ones on completely

 * zeroed doorbell register.

 * The method is called from PCIe ISR bottom-half routine.

	/*

	 * Doorbell IRQ status will be cleaned only when client

	 * driver unsets all the doorbell bits.

 Notify the client driver of possible doorbell state change */

/*

 * idt_ntb_db_valid_mask() - get a mask of doorbell bits supported by the ntb

 *			     (NTB API callback)

 * @ntb:	NTB device context.

 *

 * IDT PCIe-switches expose just one Doorbell register of DWORD size.

 *

 * Return: A mask of doorbell bits supported by the ntb.

/*

 * idt_ntb_db_read() - read the local doorbell register (NTB API callback)

 * @ntb:	NTB device context.

 *

 * There is just on inbound doorbell register of each NT-function, so

 * this method return it value.

 *

 * Return: The bits currently set in the local doorbell register.

/*

 * idt_ntb_db_clear() - clear bits in the local doorbell register

 *			(NTB API callback)

 * @ntb:	NTB device context.

 * @db_bits:	Doorbell bits to clear.

 *

 * Clear bits of inbound doorbell register by writing ones to it.

 *

 * NOTE! Invalid bits are always considered cleared so it's not an error

 * to clear them over.

 *

 * Return: always zero as success.

/*

 * idt_ntb_db_read_mask() - read the local doorbell mask (NTB API callback)

 * @ntb:	NTB device context.

 *

 * Each inbound doorbell bit can be masked from generating IRQ by setting

 * the corresponding bit in inbound doorbell mask. So this method returns

 * the value of the register.

 *

 * Return: The bits currently set in the local doorbell mask register.

/*

 * idt_ntb_db_set_mask() - set bits in the local doorbell mask

 *			   (NTB API callback)

 * @ntb:	NTB device context.

 * @db_bits:	Doorbell mask bits to set.

 *

 * The inbound doorbell register mask value must be read, then OR'ed with

 * passed field and only then set back.

 *

 * Return: zero on success, negative error if invalid argument passed.

/*

 * idt_ntb_db_clear_mask() - clear bits in the local doorbell mask

 *			     (NTB API callback)

 * @ntb:	NTB device context.

 * @db_bits:	Doorbell bits to clear.

 *

 * The method just clears the set bits up in accordance with the passed

 * bitfield. IDT PCIe-switch shall generate an interrupt if there hasn't

 * been any unmasked bit set before current unmasking. Otherwise IRQ won't

 * be generated since there is only one IRQ vector for all doorbells.

 *

 * Return: always zero as success

/*

 * idt_ntb_peer_db_set() - set bits in the peer doorbell register

 *			   (NTB API callback)

 * @ntb:	NTB device context.

 * @db_bits:	Doorbell bits to set.

 *

 * IDT PCIe-switches exposes local outbound doorbell register to change peer

 * inbound doorbell register state.

 *

 * Return: zero on success, negative error if invalid argument passed.

/*=============================================================================

 *                          6. Messaging operations

 *

 *    Each NT-function of IDT PCIe-switch has four inbound and four outbound

 * message registers. Each outbound message register can be connected to one or

 * even more than one peer inbound message registers by setting global

 * configurations. Since NTB API permits one-on-one message registers mapping

 * only, the driver acts in according with that restriction.

 *=============================================================================

/*

 * idt_init_msg() - initialize messaging interface

 * @ndev:	IDT NTB hardware driver descriptor

 *

 * Just initialize the message registers routing tables locker.

 Init the messages routing table lockers */

/*

 * idt_msg_isr() - message event ISR

 * @ndev:	IDT NTB hardware driver descriptor

 * @ntint_sts:	NT-function interrupt status

 *

 * Message event happens when MSG bit of NTINTSTS switches from 0 to 1.

 * It happens only when unmasked message status bits are set to ones on

 * completely zeroed message status register.

 * The method is called from PCIe ISR bottom-half routine.

	/*

	 * Message IRQ status will be cleaned only when client

	 * driver unsets all the message status bits.

 Notify the client driver of possible message status change */

/*

 * idt_ntb_msg_count() - get the number of message registers (NTB API callback)

 * @ntb:	NTB device context.

 *

 * IDT PCIe-switches support four message registers.

 *

 * Return: the number of message registers.

/*

 * idt_ntb_msg_inbits() - get a bitfield of inbound message registers status

 *			  (NTB API callback)

 * @ntb:	NTB device context.

 *

 * NT message status register is shared between inbound and outbound message

 * registers status

 *

 * Return: bitfield of inbound message registers.

/*

 * idt_ntb_msg_outbits() - get a bitfield of outbound message registers status

 *			  (NTB API callback)

 * @ntb:	NTB device context.

 *

 * NT message status register is shared between inbound and outbound message

 * registers status

 *

 * Return: bitfield of outbound message registers.

/*

 * idt_ntb_msg_read_sts() - read the message registers status (NTB API callback)

 * @ntb:	NTB device context.

 *

 * IDT PCIe-switches expose message status registers to notify drivers of

 * incoming data and failures in case if peer message register isn't freed.

 *

 * Return: status bits of message registers

/*

 * idt_ntb_msg_clear_sts() - clear status bits of message registers

 *			     (NTB API callback)

 * @ntb:	NTB device context.

 * @sts_bits:	Status bits to clear.

 *

 * Clear bits in the status register by writing ones.

 *

 * NOTE! Invalid bits are always considered cleared so it's not an error

 * to clear them over.

 *

 * Return: always zero as success.

/*

 * idt_ntb_msg_set_mask() - set mask of message register status bits

 *			    (NTB API callback)

 * @ntb:	NTB device context.

 * @mask_bits:	Mask bits.

 *

 * Mask the message status bits from raising an IRQ.

 *

 * Return: zero on success, negative error if invalid argument passed.

/*

 * idt_ntb_msg_clear_mask() - clear message registers mask

 *			      (NTB API callback)

 * @ntb:	NTB device context.

 * @mask_bits:	Mask bits.

 *

 * Clear mask of message status bits IRQs.

 *

 * Return: always zero as success.

/*

 * idt_ntb_msg_read() - read message register with specified index

 *			(NTB API callback)

 * @ntb:	NTB device context.

 * @pidx:	OUT - Port index of peer device a message retrieved from

 * @midx:	Message register index

 *

 * Read data from the specified message register and source register.

 *

 * Return: inbound message register value.

 Retrieve source port index of the message */

 Sanity check partition index (for initial case) */

 Retrieve data of the corresponding message register */

/*

 * idt_ntb_peer_msg_write() - write data to the specified message register

 *			      (NTB API callback)

 * @ntb:	NTB device context.

 * @pidx:	Port index of peer device a message being sent to

 * @midx:	Message register index

 * @msg:	Data to send

 *

 * Just try to send data to a peer. Message status register should be

 * checked by client driver.

 *

 * Return: zero on success, negative error if invalid argument passed.

 Collect the routing information */

 Lock the messages routing table of the specified register */

 Set the route and send the data */

 Unlock the messages routing table */

 Client driver shall check the status register */

/*=============================================================================

 *                      7. Temperature sensor operations

 *

 *    IDT PCIe-switch has an embedded temperature sensor, which can be used to

 * check current chip core temperature. Since a workload environment can be

 * different on different platforms, an offset and ADC/filter settings can be

 * specified. Although the offset configuration is only exposed to the sysfs

 * hwmon interface at the moment. The rest of the settings can be adjusted

 * for instance by the BIOS/EEPROM firmware.

 *=============================================================================

/*

 * idt_get_deg() - convert millidegree Celsius value to just degree

 * @mdegC:	IN - millidegree Celsius value

 *

 * Return: Degree corresponding to the passed millidegree value

/*

 * idt_get_frac() - retrieve 0/0.5 fraction of the millidegree Celsius value

 * @mdegC:	IN - millidegree Celsius value

 *

 * Return: 0/0.5 degree fraction of the passed millidegree value

/*

 * idt_get_temp_fmt() - convert millidegree Celsius value to 0:7:1 format

 * @mdegC:	IN - millidegree Celsius value

 *

 * Return: 0:7:1 format acceptable by the IDT temperature sensor

/*

 * idt_get_temp_sval() - convert temp sample to signed millidegree Celsius

 * @data:	IN - shifted to LSB 8-bits temperature sample

 *

 * Return: signed millidegree Celsius

/*

 * idt_get_temp_sval() - convert temp sample to unsigned millidegree Celsius

 * @data:	IN - shifted to LSB 8-bits temperature sample

 *

 * Return: unsigned millidegree Celsius

/*

 * idt_read_temp() - read temperature from chip sensor

 * @ntb:	NTB device context.

 * @type:	IN - type of the temperature value to read

 * @val:	OUT - integer value of temperature in millidegree Celsius

 Alter the temperature field in accordance with the passed type */

 This is the only field with signed 0:7:1 format */

 The rest of the fields accept unsigned 0:7:1 format */

/*

 * idt_write_temp() - write temperature to the chip sensor register

 * @ntb:	NTB device context.

 * @type:	IN - type of the temperature value to change

 * @val:	IN - integer value of temperature in millidegree Celsius

 Retrieve the properly formatted temperature value */

/*

 * idt_sysfs_show_temp() - printout corresponding temperature value

 * @dev:	Pointer to the NTB device structure

 * @da:		Sensor device attribute structure

 * @buf:	Buffer to print temperature out

 *

 * Return: Number of written symbols or negative error

/*

 * idt_sysfs_set_temp() - set corresponding temperature value

 * @dev:	Pointer to the NTB device structure

 * @da:		Sensor device attribute structure

 * @buf:	Buffer to print temperature out

 * @count:	Size of the passed buffer

 *

 * Return: Number of written symbols or negative error

 Clamp the passed value in accordance with the type */

/*

 * idt_sysfs_reset_hist() - reset temperature history

 * @dev:	Pointer to the NTB device structure

 * @da:		Sensor device attribute structure

 * @buf:	Buffer to print temperature out

 * @count:	Size of the passed buffer

 *

 * Return: Number of written symbols or negative error

	/* Just set the maximal value to the lowest temperature field and

	 * minimal value to the highest temperature field

/*

 * Hwmon IDT sysfs attributes

/*

 * Hwmon IDT sysfs attributes group

/*

 * idt_init_temp() - initialize temperature sensor interface

 * @ndev:	IDT NTB hardware driver descriptor

 *

 * Simple sensor initializarion method is responsible for device switching

 * on and resource management based hwmon interface registration. Note, that

 * since the device is shared we won't disable it on remove, but leave it

 * working until the system is powered off.

 Enable sensor if it hasn't been already */

 Initialize hwmon interface fields */

/*=============================================================================

 *                           8. ISRs related operations

 *

 *    IDT PCIe-switch has strangely developed IRQ system. There is just one

 * interrupt vector for doorbell and message registers. So the hardware driver

 * can't determine actual source of IRQ if, for example, message event happened

 * while any of unmasked doorbell is still set. The similar situation may be if

 * switch or temperature sensor events pop up. The difference is that SEVENT

 * and TMPSENSOR bits of NT interrupt status register can be cleaned by

 * IRQ handler so a next interrupt request won't have false handling of

 * corresponding events.

 *    The hardware driver has only bottom-half handler of the IRQ, since if any

 * of events happened the device won't raise it again before the last one is

 * handled by clearing of corresponding NTINTSTS bit.

 *=============================================================================

/*

 * idt_init_isr() - initialize PCIe interrupt handler

 * @ndev:	IDT NTB hardware driver descriptor

 *

 * Return: zero on success, otherwise a negative error number.

 Allocate just one interrupt vector for the ISR */

 Retrieve the IRQ vector */

 Set the IRQ handler */

 Unmask Message/Doorbell/SE interrupts */

 From now on the interrupts are enabled */

/*

 * idt_deinit_ist() - deinitialize PCIe interrupt handler

 * @ndev:	IDT NTB hardware driver descriptor

 *

 * Disable corresponding interrupts and free allocated IRQ vectors.

 Mask interrupts back */

 Manually free IRQ otherwise PCI free irq vectors will fail */

 Free allocated IRQ vectors */

/*

 * idt_thread_isr() - NT function interrupts handler

 * @irq:	IRQ number

 * @devid:	Custom buffer

 *

 * It reads current NT interrupts state register and handles all the event

 * it declares.

 * The method is bottom-half routine of actual default PCIe IRQ handler.

 Read the NT interrupts status register */

 Handle messaging interrupts */

 Handle doorbell interrupts */

 Handle switch event interrupts */

/*===========================================================================

 *                     9. NTB hardware driver initialization

 *===========================================================================

/*

 * NTB API operations

/*

 * idt_register_device() - register IDT NTB device

 * @ndev:	IDT NTB hardware driver descriptor

 *

 * Return: zero on success, otherwise a negative error number.

 Initialize the rest of NTB device structure and register it */

/*

 * idt_unregister_device() - unregister IDT NTB device

 * @ndev:	IDT NTB hardware driver descriptor

 Just unregister the NTB device */

/*=============================================================================

 *                        10. DebugFS node initialization

 *=============================================================================

/*

 * Driver DebugFS info file operations

/*

 * idt_dbgfs_info_read() - DebugFS read info node callback

 * @file:	File node descriptor.

 * @ubuf:	User-space buffer to put data to

 * @count:	Size of the buffer

 * @offp:	Offset within the buffer

 Lets limit the buffer size the way the Intel/AMD drivers do */

 Allocate the memory for the buffer */

 Put the data into the string buffer */

 General local device configurations */

 Peer ports information */

 Links status */

 Mapping table entries */

 Print valid entries only */

 Outbound memory windows information */

 Print Memory Window information */

 Inbound memory windows information */

 Print Memory Windows information */

 Doorbell information */

 Messaging information */

 Current temperature */

 Copy the buffer to the User Space */

/*

 * idt_init_dbgfs() - initialize DebugFS node

 * @ndev:	IDT NTB hardware driver descriptor

 *

 * Return: zero on success, otherwise a negative error number.

 If the top directory is not created then do nothing */

 Create the info file node */

/*

 * idt_deinit_dbgfs() - deinitialize DebugFS node

 * @ndev:	IDT NTB hardware driver descriptor

 *

 * Just discard the info node from DebugFS

/*=============================================================================

 *                     11. Basic PCIe device initialization

 *=============================================================================

/*

 * idt_check_setup() - Check whether the IDT PCIe-swtich is properly

 *		       pre-initialized

 * @pdev:	Pointer to the PCI device descriptor

 *

 * Return: zero on success, otherwise a negative error number.

 Read the BARSETUP0 */

 Check whether the BAR0 register is enabled to be of config space */

 Configuration space BAR0 must have certain size */

/*

 * Create the IDT PCIe-switch driver descriptor

 * @pdev:	Pointer to the PCI device descriptor

 * @id:		IDT PCIe-device configuration

 *

 * It just allocates a memory for IDT PCIe-switch device structure and

 * initializes some commonly used fields.

 *

 * No need of release method, since managed device resource is used for

 * memory allocation.

 *

 * Return: pointer to the descriptor, otherwise a negative error number.

 Allocate memory for the IDT PCIe-device descriptor */

 Save the IDT PCIe-switch ports configuration */

 Save the PCI-device pointer inside the NTB device structure */

 Initialize spin locker of Doorbell, Message and GASA registers */

/*

 * idt_init_pci() - initialize the basic PCI-related subsystem

 * @ndev:	Pointer to the IDT PCIe-switch driver descriptor

 *

 * Managed device resources will be freed automatically in case of failure or

 * driver detachment.

 *

 * Return: zero on success, otherwise negative error number.

 Initialize the bit mask of PCI/NTB DMA */

	/*

	 * Enable the device advanced error reporting. It's not critical to

	 * have AER disabled in the kernel.

 Cleanup nonfatal error status before getting to init */

 First enable the PCI device */

	/*

	 * Enable the bus mastering, which effectively enables MSI IRQs and

	 * Request TLPs translation

 Request all BARs resources and map BAR0 only */

 Retrieve virtual address of BAR0 - PCI configuration space */

 Put the IDT driver data pointer to the PCI-device private pointer */

/*

 * idt_deinit_pci() - deinitialize the basic PCI-related subsystem

 * @ndev:	Pointer to the IDT PCIe-switch driver descriptor

 *

 * Managed resources will be freed on the driver detachment

 Clean up the PCI-device private data pointer */

 Clear the bus master disabling the Request TLPs translation */

 Disable the AER capability */

/*===========================================================================

 *                       12. PCI bus callback functions

 *===========================================================================

/*

 * idt_pci_probe() - PCI device probe callback

 * @pdev:	Pointer to PCI device structure

 * @id:		PCIe device custom descriptor

 *

 * Return: zero on success, otherwise negative error number

 Check whether IDT PCIe-switch is properly pre-initialized */

 Allocate the memory for IDT NTB device data */

 Initialize the basic PCI subsystem of the device */

 Scan ports of the IDT PCIe-switch */

 Initialize NTB link events subsystem */

 Initialize MWs subsystem */

 Initialize Messaging subsystem */

 Initialize hwmon interface */

 Initialize IDT interrupts handler */

 Register IDT NTB devices on the NTB bus */

 Initialize DebugFS info node */

 IDT PCIe-switch NTB driver is finally initialized */

 May the force be with us... */

/*

 * idt_pci_probe() - PCI device remove callback

 * @pdev:	Pointer to PCI device structure

 Deinit the DebugFS node */

 Unregister NTB device */

 Stop the interrupts handling */

 Deinitialize link event subsystem */

 Deinit basic PCI subsystem */

 IDT PCIe-switch NTB driver is finally initialized */

 Sayonara... */

/*

 * IDT PCIe-switch models ports configuration structures

/*

 * PCI-ids table of the supported IDT PCIe-switch devices

/*

 * IDT PCIe-switch NT-function device driver structure definition

 Create the top DebugFS directory if the FS is initialized */

 Register the NTB hardware driver to handle the PCI device */

 Unregister the NTB hardware driver */

 Discard the top DebugFS directory */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Microsemi Switchtec(tm) PCIe Management Driver

 * Copyright (c) 2017, Microsemi Corporation

 synchronize rmw access of db_mask and hw reg */

		/*

		 * In certain circumstances we can get a buffer that is

		 * not aligned to its size. (Most of the time

		 * dma_alloc_coherent ensures this). This can happen when

		 * using large buffers allocated by the CMA

		 * (see CMA_CONFIG_ALIGNMENT)

		/*

		 * This is the direct BAR shared with the LUTs

		 * which means the actual window will be offset

		 * by the size of all the LUT entries.

/*

 * In crosslink configuration there is a virtual partition in the

 * middle of the two switches. The BARs in this partition have to be

 * enumerated and assigned addresses.

/*

 * There are 64 doorbells in the switch hardware but this is

 * shared among all partitions. So we must split them in half

 * (32 for each partition). However, the message interrupts are

 * also shared with the top 4 doorbells so we just limit this to

 * 28 doorbells per partition.

 *

 * In crosslink mode, each side has it's own dbmsg register so

 * they can each use all 60 of the available doorbells.

	/*

	 * Root Complex Requester ID (which is 0:00.0)

	/*

	 * Host Bridge Requester ID (as read from the mmap address)

	/*

	 * If this host crashed, the other host may think the link is

	 * still up. Tell them to force it down (it will go back up

	 * once we register the ntb device).

 SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)

 Copyright(c) 2020 Intel Corporation. All rights reserved. */

	/*

	 * We need to write to DLLSCS bit in the SLOTSTS before we

	 * can clear the hardware link interrupt on ICX NTB.

	/*

	 * The MSIX vectors and the interrupt status bits are not lined up

	 * on Gen3 (Skylake) and Gen4. By default the link status bit is bit

	 * 32, however it is by default MSIX vector0. We need to fixup to

	 * line them up. The vectors at reset is 1-32,0. We need to reprogram

	 * to 0-32.

 setup incoming bar limits == base addrs (zero length windows) */

 zero incoming translation addrs */

, ppd0*/;

 init link setup */

 hardware requires that addr is aligned to bar size */

 make sure the range fits in the usable mw size */

 Set the limit if supported, if size is not mw_size */

 set and verify setting the translation address */

 set and verify setting the limit */

 Setup active snoop LTR values */

 Setup active non-snoop values */

 Setup idle snoop LTR values */

 Setup idle non-snoop values */

 setup PCIe LTR to active */

 start link training in PPD0 */

 make sure link training has started */

 clear the snoop bits */

 set LTR to idle */

/*

 * This file is provided under a dual BSD/GPLv2 license.  When using or

 *   redistributing this file, you may do so under either license.

 *

 *   GPL LICENSE SUMMARY

 *

 *   Copyright(c) 2017 Intel Corporation. All rights reserved.

 *

 *   This program is free software; you can redistribute it and/or modify

 *   it under the terms of version 2 of the GNU General Public License as

 *   published by the Free Software Foundation.

 *

 *   BSD LICENSE

 *

 *   Copyright(c) 2017 Intel Corporation. All rights reserved.

 *

 *   Redistribution and use in source and binary forms, with or without

 *   modification, are permitted provided that the following conditions

 *   are met:

 *

 *     * Redistributions of source code must retain the above copyright

 *       notice, this list of conditions and the following disclaimer.

 *     * Redistributions in binary form must reproduce the above copy

 *       notice, this list of conditions and the following disclaimer in

 *       the documentation and/or other materials provided with the

 *       distribution.

 *     * Neither the name of Intel Corporation nor the names of its

 *       contributors may be used to endorse or promote products derived

 *       from this software without specific prior written permission.

 *

 *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS

 *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT

 *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR

 *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT

 *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,

 *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT

 *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,

 *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY

 *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT

 *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE

 *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 *

 * Intel PCIe GEN3 NTB Linux driver

 *

	.bar0_base		= GEN3_EMBAR0_OFFSET, */

	/*

	 * The MSIX vectors and the interrupt status bits are not lined up

	 * on Skylake. By default the link status bit is bit 32, however it

	 * is by default MSIX vector0. We need to fixup to line them up.

	 * The vectors at reset is 1-32,0. We need to reprogram to 0-32.

 move link status down one as workaround */

 setup incoming bar limits == base addrs (zero length windows) */

 zero incoming translation addrs */

 DB fixup for using 31 right now */

 Enable Bus Master and Memory Space on the secondary side */

 hardware requires that addr is aligned to bar size */

 make sure the range fits in the usable mw size */

 Set the limit if supported, if size is not mw_size */

 set and verify setting the translation address */

 set and verify setting the limit */

 setup the EP */

 set and verify setting the limit */

/*

 * This file is provided under a dual BSD/GPLv2 license.  When using or

 *   redistributing this file, you may do so under either license.

 *

 *   GPL LICENSE SUMMARY

 *

 *   Copyright(c) 2012 Intel Corporation. All rights reserved.

 *   Copyright (C) 2015 EMC Corporation. All Rights Reserved.

 *   Copyright (C) 2016 T-Platforms. All Rights Reserved.

 *

 *   This program is free software; you can redistribute it and/or modify

 *   it under the terms of version 2 of the GNU General Public License as

 *   published by the Free Software Foundation.

 *

 *   BSD LICENSE

 *

 *   Copyright(c) 2012 Intel Corporation. All rights reserved.

 *   Copyright (C) 2015 EMC Corporation. All Rights Reserved.

 *   Copyright (C) 2016 T-Platforms. All Rights Reserved.

 *

 *   Redistribution and use in source and binary forms, with or without

 *   modification, are permitted provided that the following conditions

 *   are met:

 *

 *     * Redistributions of source code must retain the above copyright

 *       notice, this list of conditions and the following disclaimer.

 *     * Redistributions in binary form must reproduce the above copy

 *       notice, this list of conditions and the following disclaimer in

 *       the documentation and/or other materials provided with the

 *       distribution.

 *     * Neither the name of Intel Corporation nor the names of its

 *       contributors may be used to endorse or promote products derived

 *       from this software without specific prior written permission.

 *

 *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS

 *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT

 *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR

 *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT

 *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,

 *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT

 *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,

 *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY

 *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT

 *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE

 *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 *

 * Intel PCIe NTB Linux driver

 Only B2B has a workaround to avoid SDOORBELL */

 No low level workaround to avoid SB01BASE */

 Mask all doorbell interrupts */

 Try to set up msix irq */

 Try to set up msi irq */

 Try to set up intx irq */

 Mask all doorbell interrupts */

 hardware requires that addr is aligned to bar size */

 make sure the range fits in the usable mw size */

 Set the limit if supported, if size is not mw_size */

 set and verify setting the translation address */

 set and verify setting the limit */

 split bar addr range must all be 32 bit */

 Set the limit if supported, if size is not mw_size */

 set and verify setting the translation address */

 set and verify setting the limit */

		/* TODO MAYBE: is it possible to observe the link speed and

 Bring NTB link down */

 Numbers of inbound and outbound memory windows match */

 accept bogus PRI_DSD */

 accept bogus SEC_DSD */

	/* Reset the secondary bar sizes to match the primary bar sizes,

	 * except disable or halve the size of the b2b secondary bar.

	 *

	 * Note: code for each specific bar size register, because the register

	 * offsets are not in a consistent order (bar5sz comes after ppd, odd).

 SBAR01 hit by first part of the b2b bar */

	/* Other SBAR are normally hit by the PBAR xlat, except for b2b bar.

	 * The b2b bar is either disabled above, or configured half-size, and

	 * it starts at the PBAR xlat + offset.

 setup incoming bar limits == base addrs (zero length windows) */

 zero incoming translation addrs */

 zero outgoing translation limits (whole bar size windows) */

 set outgoing translation offsets */

 set the translation offset for b2b registers */

 B2B_XLAT_OFFSET is 64bit, but can only take 32bit writes */

 map peer ntb mmio config space registers */

 enable link to allow secondary side device to appear */

 use half the spads for the peer */

 use half the spads for the peer */

 Enable Bus Master and Memory Space on the secondary side */

	/* There is a Xeon hardware errata related to writes to SDOORBELL or

	 * B2BDOORBELL in conjunction with inbound access to NTB MMIO Space,

	 * which may hang the system.  To workaround this use the second memory

	 * window to access the interrupt and scratch pad registers on the

	 * remote system.

	/* There is a hardware errata related to accessing any register in

	 * SB01BASE in the presence of bidirectional traffic crossing the NTB.

	/* HW Errata on bit 14 of b2bdoorbell register.  Writes will not be

	 * mirrored to the remote system.  Shrink the number of bits by one,

	 * since bit 14 is the last bit.

		/* This is a way for transparent BAR to figure out if we are

		 * doing split BAR or not. There is no way for the hw on the

		 * transparent side to know and set the PPD.

 second half of the scratchpads */

	/* Note: no primary .bar0_base visible to the secondary side.

	 *

	 * The secondary side cannot get the base address stored in primary

	 * bars.  The base address is necessary to set the limit register to

	 * any value other than zero, or unlimited.

	 *

	 * WITHOUT THE BASE ADDRESS, THE SECONDARY SIDE CANNOT DISABLE the

	 * window by setting the limit equal to base, nor can it limit the size

	 * of the memory window by setting the limit to base + size.

 operations for primary side of local ntb */

 GEN1 */

 GEN3 */

 GEN4 */

/*

 * This file is provided under a dual BSD/GPLv2 license.  When using or

 *   redistributing this file, you may do so under either license.

 *

 *   GPL LICENSE SUMMARY

 *

 *   Copyright (C) 2016 Advanced Micro Devices, Inc. All Rights Reserved.

 *   Copyright (C) 2016 T-Platforms. All Rights Reserved.

 *

 *   This program is free software; you can redistribute it and/or modify

 *   it under the terms of version 2 of the GNU General Public License as

 *   published by the Free Software Foundation.

 *

 *   BSD LICENSE

 *

 *   Copyright (C) 2016 Advanced Micro Devices, Inc. All Rights Reserved.

 *   Copyright (C) 2016 T-Platforms. All Rights Reserved.

 *

 *   Redistribution and use in source and binary forms, with or without

 *   modification, are permitted provided that the following conditions

 *   are met:

 *

 *     * Redistributions of source code must retain the above copyright

 *       notice, this list of conditions and the following disclaimer.

 *     * Redistributions in binary form must reproduce the above copy

 *       notice, this list of conditions and the following disclaimer in

 *       the documentation and/or other materials provided with the

 *       distribution.

 *     * Neither the name of AMD Corporation nor the names of its

 *       contributors may be used to endorse or promote products derived

 *       from this software without specific prior written permission.

 *

 *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS

 *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT

 *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR

 *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT

 *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,

 *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT

 *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,

 *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY

 *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT

 *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE

 *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 *

 * AMD PCIe NTB Linux driver

 *

 * Contact Information:

 * Xiangliang Yu <Xiangliang.Yu@amd.com>

 make sure the range fits in the usable mw size */

 Set the limit if supported */

 set and verify setting the translation address */

 set and verify setting the limit */

 Set the limit if supported */

 set and verify setting the translation address */

 set and verify setting the limit */

 Locate the pointer to Downstream Switch for this device */

			/*

			 * Locate the pointer to Upstream Switch for

			 * the Downstream Switch.

		/*

		 * For NTB primary, we simply read the Link Status and control

		 * register of the NTB device itself.

 Catch all for everything else */

	/*

	 * We consider the link to be up under two conditions:

	 *

	 *   - When a link-up event is received. This is indicated by

	 *     AMD_LINK_UP_EVENT set in peer_sta.

	 *   - When driver on both sides of the link have been loaded.

	 *     This is indicated by bit 1 being set in the peer

	 *     SIDEINFO register.

	 *

	 * This function should return 1 when the latter of the above

	 * two conditions is true.

	 *

	 * Now consider the sequence of events - Link-Up event occurs,

	 * then the peer side driver loads. In this case, we would have

	 * received LINK_UP event and bit 1 of peer SIDEINFO is also

	 * set. What happens now if the link goes down? Bit 1 of

	 * peer SIDEINFO remains set, but LINK_DOWN bit is set in

	 * peer_sta. So we should return 0 from this function. Not only

	 * that, we clear bit 1 of peer SIDEINFO to 0, since the peer

	 * side driver did not even get a chance to clear it before

	 * the link went down. This can be the case of surprise link

	 * removal.

	 *

	 * LINK_UP event will always occur before the peer side driver

	 * gets loaded the very first time. So there can be a case when

	 * the LINK_UP event has occurred, but the peer side driver hasn't

	 * yet loaded. We return 0 in that case.

	 *

	 * There is also a special case when the primary side driver is

	 * unloaded and then loaded again. Since there is no change in

	 * the status of NTB secondary in this case, there is no Link-Up

	 * or Link-Down notification received. We recognize this condition

	 * with peer_sta being set to 0.

	 *

	 * If bit 1 of peer SIDEINFO register is not set, then we

	 * simply return 0 irrespective of the link up or down status

	 * set in peer_sta.

		/*

		 * We need to check the below only for NTB primary. For NTB

		 * secondary, simply checking the result of PSIDE_INFO

		 * register will suffice.

 Clear peer sideinfo register */

 NTB_TOPO_SEC */

 Enable event interrupt */

 Disable event interrupt */

 The same as for inbound MWs */

 link down first */

 polling peer status */

 link down */

 check if this is WAKEUP event */

 start a timer to poll link status */

 Clear the interrupt status */

	/*

	 * Since we had reserved highest order bit of DB for signaling peer of

	 * a special event, this is the only status bit we should be concerned

	 * here now.

 send link down event notification */

		/*

		 * If we are here, that means the peer has signalled a special

		 * event which notifies that the peer driver has been

		 * un-loaded for some reason. Since there is a chance that the

		 * peer will load its driver again sometime, we schedule link

		 * polling routine.

 Try to set up msix irq */

	/* NOTE: Disable MSIX if msix count is less than 16 because of

	 * hardware limitation.

 Try to set up msi irq */

 Try to set up intx irq */

 Mask all doorbell interrupts */

 Mask event interrupts */

	/*

	 * We reserve the highest order bit of the DB register which will

	 * be used to notify peer when the driver on this side is being

	 * un-loaded.

	/*

	 * Since now there is one less bit to account for, the DB count

	 * and DB mask should be adjusted accordingly.

 Enable Link-Up and Link-Down event interrupts */

 write side info */

	/*

	 * Clear the READY bit in SIDEINFO register before sending DB event

	 * to the peer. This will make sure that when the peer handles the

	 * DB event, it correctly reads this bit as being 0.

 Send link down notification */

 for device 145b */

 for device 148b */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * vhost transport for vsock

 *

 * Copyright (C) 2013-2015 Red Hat, Inc.

 * Author: Asias He <asias@redhat.com>

 *         Stefan Hajnoczi <stefanha@redhat.com>

/* Max number of bytes transferred before requeueing the job.

/* Max number of packets transferred before requeueing the job.

 * Using this limit prevents one virtqueue from starving others with

 * small pkts.

 Used to track all the vhost_vsock instances on the system. */

 Link to global vhost_vsock_hash, writes use vhost_vsock_mutex */

 host->guest pending packets */

/* Callers that dereference the return value must hold vhost_vsock_mutex or the

 * RCU read lock.

 Skip instances that have no CID yet */

 Avoid further vmexits, we're already processing the virtqueue */

			/* We cannot finish yet if more buffers snuck in while

			 * re-enabling notify.

		/* If the packet is greater than the space available in the

		 * buffer, we split it using multiple buffers.

			/* As we are copying pieces of large packet's buffer to

			 * small rx buffers, headers of packets in rx queue are

			 * created dynamically and are initialized with header

			 * of current packet(except length). But in case of

			 * SOCK_SEQPACKET, we also must clear message delimeter

			 * bit (VIRTIO_VSOCK_SEQ_EOM) and MSG_EOR bit

			 * (VIRTIO_VSOCK_SEQ_EOR) if set. Otherwise,

			 * there will be sequence of packets with these

			 * bits set. After initialized header will be copied to

			 * rx buffer, these required bits will be restored.

 Set the correct length in the header */

		/* Deliver to monitoring devices all packets that we

		 * will transmit.

		/* If we didn't send all the payload we can requeue the packet

		 * to send it with the next available buffer.

			/* We are queueing the same virtio_vsock_pkt to handle

			 * the remaining bytes, and we want to deliver it

			 * to monitoring devices in the next iteration.

				/* Do we have resources to resume tx

				 * processing?

 Find the vhost_vsock according to guest context id  */

 Find the vhost_vsock according to guest context id  */

 No payload */

 The pkt is too big */

 Is there space left for replies to rx packets? */

 paired with atomic_inc() and atomic_dec_return() */

			/* Stop tx until the device processes already

			 * pending replies.  Leave tx virtqueue

			 * callbacks disabled.

 Deliver to monitoring devices all received packets */

 Only accept correctly addressed packets */

	/* Some packets may have been queued before the device was started,

	 * let's kick the send worker to send them.

	/* This struct is large and allocation could fail, fall back to vmalloc

	 * if there is no other way.

 no CID assigned yet */

	/* vmci_transport.c doesn't take sk_lock here either.  At least we're

	 * under vsock_table_lock so the sock cannot disappear while we're

	 * executing.

 If the peer is still valid, no need to reset connection */

	/* If the close timeout is pending, let it expire.  This avoids races

	 * with the timeout callback.

 Wait for other CPUs to finish using vsock */

	/* Iterating over all connections for all CIDs to find orphans is

 Refuse reserved CIDs */

 64-bit CIDs are not yet supported */

	/* Refuse if CID is assigned to the guest->host transport (i.e. nested

	 * VM), to make the loopback work.

 Refuse if CID is already in use */

 SPDX-License-Identifier: GPL-2.0-only

/* Copyright (C) 2020 Red Hat, Inc.

 * Author: Jason Wang <jasowang@redhat.com>

 *

 * IOTLB implementation for vhost.

/**

 * vhost_iotlb_map_free - remove a map node and free it

 * @iotlb: the IOTLB

 * @map: the map that want to be remove and freed

/**

 * vhost_iotlb_add_range_ctx - add a new range to vhost IOTLB

 * @iotlb: the IOTLB

 * @start: start of the IOVA range

 * @last: last of IOVA range

 * @addr: the address that is mapped to @start

 * @perm: access permission of this range

 * @opaque: the opaque pointer for the new mapping

 *

 * Returns an error last is smaller than start or memory allocation

 * fails

/**

 * vhost_iotlb_del_range - delete overlapped ranges from vhost IOTLB

 * @iotlb: the IOTLB

 * @start: start of the IOVA range

 * @last: last of IOVA range

/**

 * vhost_iotlb_alloc - add a new vhost IOTLB

 * @limit: maximum number of IOTLB entries

 * @flags: VHOST_IOTLB_FLAG_XXX

 *

 * Returns an error is memory allocation fails

/**

 * vhost_iotlb_reset - reset vhost IOTLB (free all IOTLB entries)

 * @iotlb: the IOTLB to be reset

/**

 * vhost_iotlb_free - reset and free vhost IOTLB

 * @iotlb: the IOTLB to be freed

/**

 * vhost_iotlb_itree_first - return the first overlapped range

 * @iotlb: the IOTLB

 * @start: start of IOVA range

 * @last: last byte in IOVA range

/**

 * vhost_iotlb_itree_next - return the next overlapped range

 * @map: the starting map node

 * @start: start of IOVA range

 * @last: last byte IOVA range

 SPDX-License-Identifier: GPL-2.0-only

/* Copyright (C) 2009 Red Hat, Inc.

 * Author: Michael S. Tsirkin <mst@redhat.com>

 *

 * virtio-net server in host kernel.

/* Max number of bytes transferred before requeueing the job.

/* Max number of packets transferred before requeueing the job.

 * Using this limit prevents one virtqueue from starving others with small

 * pkts.

 MAX number of TX used buffers for outstanding zerocopy */

/*

 * For transmit, used buffer len is unused; we override it to track buffer

 * status internally; used for zerocopy tx only.

 Lower device DMA failed */

 Lower device DMA done */

 Lower device DMA in progress */

 Buffer unused */

	/* refcount follows semantics similar to kref:

	 *  0: object is released

	 *  1: no outstanding ubufs

	 * >1: outstanding ubufs

 vhost zerocopy support fields below: */

 last used idx for outstanding DMA zerocopy buffers */

	/* For TX, first used idx for DMA done zerocopy buffers

	 * For RX, number of batched heads

 Number of XDP frames batched */

 an array of userspace buffers info */

	/* Reference counting for outstanding ubufs.

 Batched XDP buffs */

	/* Number of TX recently submitted.

	/* Number of times zerocopy TX recently failed.

 Flush in progress. Protected by tx vq lock. */

 Private page frag */

 Refcount bias of page frag */

 No zero copy backend? Nothing to count. */

	/* TX flush waits for outstanding DMAs to be done.

	 * Don't start new DMAs.

/* In case of DMA done not in order in lower device driver for some reason.

 * upend_idx is used to track end of used idx, done_idx is used to track head

 * of used idx. Once lower device DMA done contiguously, we will signal KVM

 * guest used idx.

 set len to mark this desc buffers done DMA */

	/*

	 * Trigger polling thread if guest stopped submitting new buffers:

	 * in this case, the refcount after decrement will eventually reach 1.

	 * We also trigger polling periodically after each 16 packets

	 * (the value 16 here is more or less arbitrary, it's tuned to trigger

	 * less than 10% of times).

		/* free pages owned by XDP; since this is an unlikely error path,

		 * keep it simple and avoid more complex bulk update for the

		 * used pages

	/* Try to hold the vq mutex of the paired virtqueue. We can't

	 * use mutex_lock() here since we could not guarantee a

	 * consistenet lock ordering.

 On tx here, sock has no rx data. */

 Flush batched packets first */

 Skip header. TODO: support TSO. */

 Sanity check */

 Avoid direct reclaim but allow kswapd to wake */

 On error, stop handling until the next kick. */

 Nothing new?  Wait for eventfd to tell us they refilled. */

		/* For simplicity, TX batching is only enabled if

		 * sndbuf is unlimited.

			/* We can't build XDP buff, go for single

			 * packet path but let's flush batched

			 * packets.

 Release DMAs done buffers first */

 On error, stop handling until the next kick. */

 Nothing new?  Wait for eventfd to tell us they refilled. */

 use msg_control to pass vhost zerocopy ubuf info to skb */

/* Expects to be always run from workqueue - which acts as

 Flush batched heads first */

 Both tx vq and rx socket were polled here */

/* This is a multi-buffer version of vhost_get_desc, that works if

 *	vq has read descriptors only.

 * @vq		- the relevant virtqueue

 * @datalen	- data length we'll be reading

 * @iovcount	- returned count of io vectors we fill

 * @log		- vhost log

 * @log_num	- log offset

 * @quota       - headcount quota, 1 for big buffer

 *	returns number of buffer heads allocated, negative on error

	/* len is always initialized before use since we are always called with

	 * datalen > 0.

 Detect overrun */

/* Expects to be always run from workqueue - which acts as

 FIXME: get and handle RX aux data. */

 On error, stop handling until the next kick. */

 OK, now we need to know about added descriptors. */

				/* They have slipped one in as we were

			/* Nothing new?  Wait for eventfd to tell us

 On overrun, truncate and discard */

 We don't need to be notified again. */

			/* We will supply the header ourselves

			 * TODO: support TSO.

		/* Userspace might have consumed the packet meanwhile:

		 * it's not supposed to do this usually, but might be hard

 Supply virtio_net_hdr if VHOST_NET_F_VIRTIO_NET_HDR */

			/* Header came from socket; we'll need to patch

			 * ->num_buffers over if VIRTIO_NET_F_MRG_RXBUF

 TODO: Should check and handle checksum. */

 Wait for all lower device DMAs done. */

 Make sure no callbacks are outstanding */

	/* We do an extra flush before freeing memory,

 Parameter checking */

 special case to disable backend */

 Verify that ring has been setup correctly. */

 start polling new socket */

 vhost provides vnet_hdr */

 socket provides vnet_hdr */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Helpers for the host side of a virtio ring.

 *

 * Since these may be in userspace, we use (inline) accessors.

 Returns vring->num if empty, -ve on error. */

 Only get avail ring entries after they have been exposed by guest. */

/**

 * vringh_kiov_advance - skip bytes from vring_kiov

 * @iov: an iov passed to vringh_getdesc_*() (updated as we consume)

 * @len: the maximum length to advance

 Fix up old iov element then increment. */

 Copy some bytes to/from the iovec.  Returns num copied. */

 May reduce *len if range is shorter. */

 To end of memory? */

 Otherwise, don't wrap. */

 No reason for this code to be inline. */

 Indirect tables can't have indirect. */

 We will check this when we follow it! */

 Now, start at the first indirect. */

 We start traversing vring's descriptor table. */

 You must want something! */

 Make sure it's OK, and get offset. */

 We need to save this range to use offset */

 Make sure it's OK, and get offset. */

 Just in case we need to finish traversing above. */

 Compiler knows num_used == 1 sometimes, hence extra check */

 Make sure buffer is written before we update index. */

	/* Flush out used index update. This is paired with the

	 * barrier that the Guest executes when enabling

 Old-style, without event indices. */

 Modern: we know when other side wants to know. */

 Just in case we added so many that we wrap. */

 Old-school; update flags. */

	/* They could have slipped one in as we were doing that: make

	/* This is unlikely, so we just leave notifications enabled

	 * (if we're using event_indices, we'll only get one

 Old-school; update flags. */

 Userspace access helpers: in this case, addresses are really userspace. */

/**

 * vringh_init_user - initialize a vringh for a userspace vring.

 * @vrh: the vringh to initialize.

 * @features: the feature bits for this ring.

 * @num: the number of elements.

 * @weak_barriers: true if we only need memory barriers, not I/O.

 * @desc: the userpace descriptor pointer.

 * @avail: the userpace avail pointer.

 * @used: the userpace used pointer.

 *

 * Returns an error if num is invalid: you should check pointers

 * yourself!

 Sane power of 2 please! */

 vring expects kernel addresses, but only used via accessors. */

/**

 * vringh_getdesc_user - get next available descriptor from userspace ring.

 * @vrh: the userspace vring.

 * @riov: where to put the readable descriptors (or NULL)

 * @wiov: where to put the writable descriptors (or NULL)

 * @getrange: function to call to check ranges.

 * @head: head index we received, for passing to vringh_complete_user().

 *

 * Returns 0 if there was no descriptor, 1 if there was, or -errno.

 *

 * Note that on error return, you can tell the difference between an

 * invalid ring and a single invalid descriptor: in the former case,

 * *head will be vrh->vring.num.  You may be able to ignore an invalid

 * descriptor, but there's not much you can do with an invalid ring.

 *

 * Note that you can reuse riov and wiov with subsequent calls. Content is

 * overwritten and memory reallocated if more space is needed.

 * When you don't have to use riov and wiov anymore, you should clean up them

 * calling vringh_iov_cleanup() to release the memory, even on error!

 Empty... */

 We need the layouts to be the identical for this to work */

/**

 * vringh_iov_pull_user - copy bytes from vring_iov.

 * @riov: the riov as passed to vringh_getdesc_user() (updated as we consume)

 * @dst: the place to copy.

 * @len: the maximum length to copy.

 *

 * Returns the bytes copied <= len or a negative errno.

/**

 * vringh_iov_push_user - copy bytes into vring_iov.

 * @wiov: the wiov as passed to vringh_getdesc_user() (updated as we consume)

 * @src: the place to copy from.

 * @len: the maximum length to copy.

 *

 * Returns the bytes copied <= len or a negative errno.

/**

 * vringh_abandon_user - we've decided not to handle the descriptor(s).

 * @vrh: the vring.

 * @num: the number of descriptors to put back (ie. num

 *	 vringh_get_user() to undo).

 *

 * The next vringh_get_user() will return the old descriptor(s) again.

	/* We only update vring_avail_event(vr) when we want to be notified,

/**

 * vringh_complete_user - we've finished with descriptor, publish it.

 * @vrh: the vring.

 * @head: the head as filled in by vringh_getdesc_user.

 * @len: the length of data we have written.

 *

 * You should check vringh_need_notify_user() after one or more calls

 * to this function.

/**

 * vringh_complete_multi_user - we've finished with many descriptors.

 * @vrh: the vring.

 * @used: the head, length pairs.

 * @num_used: the number of used elements.

 *

 * You should check vringh_need_notify_user() after one or more calls

 * to this function.

/**

 * vringh_notify_enable_user - we want to know if something changes.

 * @vrh: the vring.

 *

 * This always enables notifications, but returns false if there are

 * now more buffers available in the vring.

/**

 * vringh_notify_disable_user - don't tell us if something changes.

 * @vrh: the vring.

 *

 * This is our normal running state: we disable and then only enable when

 * we're going to sleep.

/**

 * vringh_need_notify_user - must we tell the other side about used buffers?

 * @vrh: the vring we've called vringh_complete_user() on.

 *

 * Returns -errno or 0 if we don't need to tell the other side, 1 if we do.

 Kernelspace access helpers. */

/**

 * vringh_init_kern - initialize a vringh for a kernelspace vring.

 * @vrh: the vringh to initialize.

 * @features: the feature bits for this ring.

 * @num: the number of elements.

 * @weak_barriers: true if we only need memory barriers, not I/O.

 * @desc: the userpace descriptor pointer.

 * @avail: the userpace avail pointer.

 * @used: the userpace used pointer.

 *

 * Returns an error if num is invalid.

 Sane power of 2 please! */

/**

 * vringh_getdesc_kern - get next available descriptor from kernelspace ring.

 * @vrh: the kernelspace vring.

 * @riov: where to put the readable descriptors (or NULL)

 * @wiov: where to put the writable descriptors (or NULL)

 * @head: head index we received, for passing to vringh_complete_kern().

 * @gfp: flags for allocating larger riov/wiov.

 *

 * Returns 0 if there was no descriptor, 1 if there was, or -errno.

 *

 * Note that on error return, you can tell the difference between an

 * invalid ring and a single invalid descriptor: in the former case,

 * *head will be vrh->vring.num.  You may be able to ignore an invalid

 * descriptor, but there's not much you can do with an invalid ring.

 *

 * Note that you can reuse riov and wiov with subsequent calls. Content is

 * overwritten and memory reallocated if more space is needed.

 * When you don't have to use riov and wiov anymore, you should clean up them

 * calling vringh_kiov_cleanup() to release the memory, even on error!

 Empty... */

/**

 * vringh_iov_pull_kern - copy bytes from vring_iov.

 * @riov: the riov as passed to vringh_getdesc_kern() (updated as we consume)

 * @dst: the place to copy.

 * @len: the maximum length to copy.

 *

 * Returns the bytes copied <= len or a negative errno.

/**

 * vringh_iov_push_kern - copy bytes into vring_iov.

 * @wiov: the wiov as passed to vringh_getdesc_kern() (updated as we consume)

 * @src: the place to copy from.

 * @len: the maximum length to copy.

 *

 * Returns the bytes copied <= len or a negative errno.

/**

 * vringh_abandon_kern - we've decided not to handle the descriptor(s).

 * @vrh: the vring.

 * @num: the number of descriptors to put back (ie. num

 *	 vringh_get_kern() to undo).

 *

 * The next vringh_get_kern() will return the old descriptor(s) again.

	/* We only update vring_avail_event(vr) when we want to be notified,

/**

 * vringh_complete_kern - we've finished with descriptor, publish it.

 * @vrh: the vring.

 * @head: the head as filled in by vringh_getdesc_kern.

 * @len: the length of data we have written.

 *

 * You should check vringh_need_notify_kern() after one or more calls

 * to this function.

/**

 * vringh_notify_enable_kern - we want to know if something changes.

 * @vrh: the vring.

 *

 * This always enables notifications, but returns false if there are

 * now more buffers available in the vring.

/**

 * vringh_notify_disable_kern - don't tell us if something changes.

 * @vrh: the vring.

 *

 * This is our normal running state: we disable and then only enable when

 * we're going to sleep.

/**

 * vringh_need_notify_kern - must we tell the other side about used buffers?

 * @vrh: the vring we've called vringh_complete_kern() on.

 *

 * Returns -errno or 0 if we don't need to tell the other side, 1 if we do.

 Atomic read is needed for getu16 */

 Atomic write is needed for putu16 */

/**

 * vringh_init_iotlb - initialize a vringh for a ring with IOTLB.

 * @vrh: the vringh to initialize.

 * @features: the feature bits for this ring.

 * @num: the number of elements.

 * @weak_barriers: true if we only need memory barriers, not I/O.

 * @desc: the userpace descriptor pointer.

 * @avail: the userpace avail pointer.

 * @used: the userpace used pointer.

 *

 * Returns an error if num is invalid.

/**

 * vringh_set_iotlb - initialize a vringh for a ring with IOTLB.

 * @vrh: the vring

 * @iotlb: iotlb associated with this vring

 * @iotlb_lock: spinlock to synchronize the iotlb accesses

/**

 * vringh_getdesc_iotlb - get next available descriptor from ring with

 * IOTLB.

 * @vrh: the kernelspace vring.

 * @riov: where to put the readable descriptors (or NULL)

 * @wiov: where to put the writable descriptors (or NULL)

 * @head: head index we received, for passing to vringh_complete_iotlb().

 * @gfp: flags for allocating larger riov/wiov.

 *

 * Returns 0 if there was no descriptor, 1 if there was, or -errno.

 *

 * Note that on error return, you can tell the difference between an

 * invalid ring and a single invalid descriptor: in the former case,

 * *head will be vrh->vring.num.  You may be able to ignore an invalid

 * descriptor, but there's not much you can do with an invalid ring.

 *

 * Note that you can reuse riov and wiov with subsequent calls. Content is

 * overwritten and memory reallocated if more space is needed.

 * When you don't have to use riov and wiov anymore, you should clean up them

 * calling vringh_kiov_cleanup() to release the memory, even on error!

 Empty... */

/**

 * vringh_iov_pull_iotlb - copy bytes from vring_iov.

 * @vrh: the vring.

 * @riov: the riov as passed to vringh_getdesc_iotlb() (updated as we consume)

 * @dst: the place to copy.

 * @len: the maximum length to copy.

 *

 * Returns the bytes copied <= len or a negative errno.

/**

 * vringh_iov_push_iotlb - copy bytes into vring_iov.

 * @vrh: the vring.

 * @wiov: the wiov as passed to vringh_getdesc_iotlb() (updated as we consume)

 * @src: the place to copy from.

 * @len: the maximum length to copy.

 *

 * Returns the bytes copied <= len or a negative errno.

/**

 * vringh_abandon_iotlb - we've decided not to handle the descriptor(s).

 * @vrh: the vring.

 * @num: the number of descriptors to put back (ie. num

 *	 vringh_get_iotlb() to undo).

 *

 * The next vringh_get_iotlb() will return the old descriptor(s) again.

	/* We only update vring_avail_event(vr) when we want to be notified,

	 * so we haven't changed that yet.

/**

 * vringh_complete_iotlb - we've finished with descriptor, publish it.

 * @vrh: the vring.

 * @head: the head as filled in by vringh_getdesc_iotlb.

 * @len: the length of data we have written.

 *

 * You should check vringh_need_notify_iotlb() after one or more calls

 * to this function.

/**

 * vringh_notify_enable_iotlb - we want to know if something changes.

 * @vrh: the vring.

 *

 * This always enables notifications, but returns false if there are

 * now more buffers available in the vring.

/**

 * vringh_notify_disable_iotlb - don't tell us if something changes.

 * @vrh: the vring.

 *

 * This is our normal running state: we disable and then only enable when

 * we're going to sleep.

/**

 * vringh_need_notify_iotlb - must we tell the other side about used buffers?

 * @vrh: the vring we've called vringh_complete_iotlb() on.

 *

 * Returns -errno or 0 if we don't need to tell the other side, 1 if we do.

 SPDX-License-Identifier: GPL-2.0+

/*******************************************************************************

 * Vhost kernel TCM fabric driver for virtio SCSI initiators

 *

 * (C) Copyright 2010-2013 Datera, Inc.

 * (C) Copyright 2010-2012 IBM Corp.

 *

 * Authors: Nicholas A. Bellinger <nab@daterainc.com>

 *          Stefan Hajnoczi <stefanha@linux.vnet.ibm.com>

/* Max number of requests before requeueing the job.

 * Using this limit prevents one virtqueue from starving others with

 * request.

 Wait for the flush operation to finish */

 Refcount for the inflight reqs */

 Descriptor from vhost_get_vq_desc() for virt_queue segment */

 virtio-scsi initiator task attribute */

 virtio-scsi response incoming iovecs */

 virtio-scsi initiator data direction */

 Expected data transfer length from virtio-scsi header */

 The Tag from include/linux/virtio_scsi.h:struct virtio_scsi_cmd_req */

 The number of scatterlists associated with this cmd */

 Saved unpacked SCSI LUN for vhost_scsi_target_queue_cmd() */

 Pointer to the SGL formatted memory from virtio-scsi */

 Pointer to response header iovec */

 Pointer to vhost_scsi for our device */

 Pointer to vhost_virtqueue for the cmd */

 Pointer to vhost nexus memory */

 The TCM I/O descriptor that is accessed via container_of() */

 Copy of the incoming SCSI command descriptor block (CDB) */

 Sense buffer that will be mapped into outgoing status */

 Completed commands list, serviced from vhost worker thread */

 Used to track inflight cmd */

 Pointer to TCM session for I_T Nexus */

 Vhost port target portal group tag for TCM */

 Used to track number of TPG Port/Lun Links wrt to explict I_T Nexus shutdown */

 Used for vhost_scsi device reference to tpg_nexus, protected by tv_tpg_mutex */

 Used for enabling T10-PI with legacy devices */

 list for vhost_scsi_list */

 Used to protect access for tpg_nexus */

 Pointer to the TCM VHost I_T Nexus for this TPG endpoint */

 Pointer back to vhost_scsi_tport */

 Returned by vhost_scsi_make_tpg() */

 Pointer back to vhost_scsi, protected by tv_tpg_mutex */

 SCSI protocol the tport is providing */

 Binary World Wide unique Port Name for Vhost Target port */

 ASCII formatted WWPN for Vhost Target port */

 Returned by vhost_scsi_make_tport() */

 event to be sent to guest */

 event list, serviced from vhost worker thread */

 Note: can't set VIRTIO_F_VERSION_1 yet, since that implies ANY_LAYOUT. */

	/*

	 * Reference counting for inflight reqs, used for flush operation. At

	 * each time, one reference tracks new commands submitted, while we

	 * wait for another one to reach 0.

	/*

	 * Indicate current inflight in use, protected by vq->mutex.

	 * Writers must also take dev mutex and flush under it.

 Protected by vhost_scsi->dev.mutex */

 cmd completion work item */

 cmd completion queue */

 evt injection work item */

 evt injection queue */

 any missed events, protected by vq->mutex */

 num of pending events, protected by vq->mutex */

/*

 * Context for processing request and control queue operations.

 Global spinlock to protect vhost_scsi TPG list for vhost IOCTL access */

 store old infight */

 setup new infight */

 Go ahead and process the write immediately */

/* Fill in status and signal that we are done processing this command

 *

 * This is scheduled in the vhost work queue so we are called with the owner

 * process mm and can access the vring.

 TODO is status_qualifier field needed? */

/*

 * Map a user memory range into a scatterlist

 *

 * Returns the number of scatterlist entries used or -errno on error.

 No pages were pinned */

 FIXME: BIDI operation */

 On error, stop handling until the next kick. */

 Nothing new?  Wait for eventfd to tell us they refilled. */

	/*

	 * Get the size of request and response buffers.

	 * FIXME: Not correct for BIDI operation

	/*

	 * Copy over the virtio-scsi request header, which for a

	 * ANY_LAYOUT enabled guest may span multiple iovecs, or a

	 * single iovec may contain both the header + outgoing

	 * WRITE payloads.

	 *

	 * copy_from_iter() will advance out_iter, so that it will

	 * point at the start of the outgoing WRITE payload, if

	 * DMA_TO_DEVICE is set.

 virtio-scsi spec requires byte 0 of the lun to be 1 */

 validated at handler entry */

	/*

	 * We can handle the vq only after the endpoint is setup by calling the

	 * VHOST_SCSI_SET_ENDPOINT ioctl.

		/*

		 * Setup pointers and values based upon different virtio-scsi

		 * request header if T10_PI is enabled in KVM guest.

		/*

		 * Validate the size of request and response buffers.

		 * Check for a sane response buffer so we can report

		 * early errors back to the guest.

 bad target on any error from here on */

		/*

		 * Determine data_direction by calculating the total outgoing

		 * iovec sizes + incoming iovec sizes vs. virtio-scsi request +

		 * response headers respectively.

		 *

		 * For DMA_TO_DEVICE this is out_iter, which is already pointing

		 * to the right place.

		 *

		 * For DMA_FROM_DEVICE, the iovec will be just past the end

		 * of the virtio-scsi response header in either the same

		 * or immediately following iovec.

		 *

		 * Any associated T10_PI bytes for the outgoing / incoming

		 * payloads are included in calculation of exp_data_len here.

		/*

		 * If T10_PI header + payload is present, setup prot_iter values

		 * and recalculate data_iter for vhost_scsi_mapal() mapping to

		 * host scatterlists via get_user_pages_fast().

			/*

			 * Set prot_iter to data_iter and truncate it to

			 * prot_bytes, and advance data_iter past any

			 * preceeding prot_bytes that may be present.

			 *

			 * Also fix up the exp_data_len to reflect only the

			 * actual data payload length.

		/*

		 * Check that the received CDB size does not exceeded our

		 * hardcoded max for vhost-scsi, then get a pre-allocated

		 * cmd descriptor for the new virtio-scsi tag.

		 *

		 * TODO what if cdb was too small for varlen cdb header?

		/*

		 * Save the descriptor from vhost_get_vq_desc() to be used to

		 * complete the virtio-scsi request in TCM callback context via

		 * vhost_scsi_queue_data_in() and vhost_scsi_queue_status()

		/*

		 * ENXIO:  No more requests, or read error, wait for next kick

		 * EINVAL: Invalid response buffer, drop the request

		 * EIO:    Respond with bad target

		 * EAGAIN: Pending request

 event_actual = 0 */

	/*

	 * We can handle the vq only after the endpoint is setup by calling the

	 * VHOST_SCSI_SET_ENDPOINT ioctl.

		/*

		 * Get the request type first in order to setup

		 * other parameters dependent on the type.

			/*

			 * The size of the response buffer depends on the

			 * request type and must be validated against it.

			 * Since the request type is not known, don't send

			 * a response.

		/*

		 * Validate the size of request and response buffers.

		 * Check for a sane response buffer so we can report

		 * early errors back to the guest.

		/*

		 * Get the rest of the request now that its size is known.

		/*

		 * ENXIO:  No more requests, or read error, wait for next kick

		 * EINVAL: Invalid response buffer, drop the request

		 * EIO:    Respond with bad target

		 * EAGAIN: Pending request

 TODO: share lun setup code with virtio-scsi.ko */

		/*

		 * Note: evt->event is zeroed when we allocate it and

		 * lun[4-7] need to be zero according to virtio-scsi spec.

 Callers must hold dev mutex */

 Init new inflight and remember the old inflight */

	/*

	 * The inflight->kref was initialized to 1. We decrement it here to

	 * indicate the start of the flush operation so that it will reach 0

	 * when all the reqs are finished.

 Flush both the vhost poll and vhost work */

 Wait for all reqs issued before the flush to be finished */

/*

 * Called from vhost_scsi_ioctl() context to walk the list of available

 * vhost_scsi_tpg with an active struct vhost_scsi_nexus

 *

 *  The lock nesting rule is:

 *    vhost_scsi_mutex -> vs->dev.mutex -> tpg->tv_tpg_mutex -> vq->mutex

 Verify that ring has been setup correctly. */

 Verify that ring has been setup correctly. */

			/*

			 * In order to ensure individual vhost-scsi configfs

			 * groups cannot be removed while in use by vhost ioctl,

			 * go ahead and take an explicit se_tpg->tpg_group.cg_item

			 * dependency now.

	/*

	 * Act as synchronize_rcu to make sure access to

	 * old vs->vs_tpg is finished.

 Verify that ring has been setup correctly. */

		/*

		 * Release se_tpg->tpg_group.cg_item configfs dependency now

		 * to allow vhost-scsi WWPN se_tpg->tpg_group shutdown to occur.

 Make sure cmds are not running before tearing them down. */

	/*

	 * Act as synchronize_rcu to make sure access to

	 * old vs->vs_tpg is finished.

 Jobs can re-queue themselves in evt kick handler. Do extra flush. */

 TODO: flush backend after dev ioctl. */

	/*

	 * Since we are running in 'demo mode' this call with generate a

	 * struct se_node_acl for the vhost_scsi struct se_portal_group with

	 * the SCSI Initiator port name of the passed configfs group 'name'.

	/*

	 * Release the SCSI I_T Nexus to the emulated vhost Target Port

	/*

	 * Shutdown the active I_T nexus if 'NULL' is passed..

	/*

	 * Otherwise make sure the passed virtual Initiator port WWN matches

	 * the fabric protocol_id set in vhost_scsi_make_tport(), and call

	 * vhost_scsi_make_nexus().

 Skip over "fc." */

	/*

	 * Clear any trailing newline for the NAA WWN

	/*

	 * Release the virtual I_T Nexus for this vhost TPG

	/*

	 * Deregister the se_tpg from TCM..

	/* if (vhost_scsi_parse_wwn(name, &wwpn, 1) < 0)

	/*

	 * Determine the emulated Protocol Identifier and Target Port Name

	 * based on the incoming configfs directory name.

 Skip over "fc." */

	/*

	 * Setup callers for generic logic in target_core_fabric_configfs.c

 SPDX-License-Identifier: GPL-2.0-only

/* Copyright (C) 2009 Red Hat, Inc.

 * Author: Michael S. Tsirkin <mst@redhat.com>

 *

 * test virtio server in host kernel.

/* Max number of bytes transferred before requeueing the job.

/* Max number of packets transferred before requeueing the job.

 * Using this limit prevents one virtqueue from starving others with

 * pkts.

/* Expects to be always run from workqueue - which acts as

 On error, stop handling until the next kick. */

 Nothing new?  Wait for eventfd to tell us they refilled. */

 Sanity check */

	/* We do an extra flush before freeing memory,

 Verify that ring has been setup correctly. */

 start polling new socket */

 Verify that ring has been setup correctly. */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2018-2020 Intel Corporation.

 * Copyright (C) 2020 Red Hat, Inc.

 *

 * Author: Tiwei Bie <tiwei.bie@intel.com>

 *         Jason Wang <jasowang@redhat.com>

 *

 * Thanks Michael S. Tsirkin for the valuable comments and

 * suggestions.  And thanks to Cunming Liang and Zhihong Wang for all

 * their supports.

	/*

	 * Userspace shouldn't remove status bits unless reset the

	 * status to 0.

	/*

	 * It's not allowed to change the features after they have

	 * been negotiated.

 Limit the use of memory for bookkeeping */

 Pin a contiguous chunk of memory */

					/*

					 * Unpin the pages that are left unmapped

					 * from this point on in the current

					 * page_list. The remaining outstanding

					 * ones which may stride across several

					 * chunks will be covered in the common

					 * error path subsequently.

 Pin the rest chunk */

			/*

			 * Unpin the outstanding pages which are yet to be

			 * mapped but haven't due to vdpa_map() or

			 * pin_user_pages() failure.

			 *

			 * Mapped pages are accounted in vdpa_map(), hence

			 * the corresponding unpinning will be handled by

			 * vdpa_unmap().

 Device want to do DMA by itself */

	/* To be safe and easily modelled by userspace, We only

	 * support the doorbell which sits on the page boundary and

	 * does not share the page with other registers.

 CONFIG_MMU */

 CONFIG_MMU */

 SPDX-License-Identifier: GPL-2.0-only

/* Copyright (C) 2009 Red Hat, Inc.

 * Copyright (C) 2006 Rusty Russell IBM Corporation

 *

 * Author: Michael S. Tsirkin <mst@redhat.com>

 *

 * Inspiration, some code, and most witty comments come from

 * Documentation/virtual/lguest/lguest.c, by Rusty Russell

 *

 * Generic code for virtio server in host kernel.

	/* Note for legacy virtio: user_be is initialized at reset time

	 * according to the host endianness. If userspace does not set an

	 * explicit endianness, the default behavior is native endian, as

	 * expected by legacy virtio.

 CONFIG_VHOST_CROSS_ENDIAN_LEGACY */

 Init poll structure */

/* Start polling a file. We add ourselves to file's wait queue. The caller must

/* Stop polling a file. After this function returns, it becomes safe to drop the

/* Flush any work that has been scheduled. When calling this, don't hold any

		/* We can only add the work to the list after we're

		 * sure it was not in the list.

		 * test_and_set_bit() implies a memory barrier.

 A lockless hint for busy polling code to exit the loop */

 mb paired w/ kthread_stop */

 make sure flag is seen after deletion */

 Helper to allocate iovec buffers for all vqs. */

 Caller should have device mutex */

 Are you the owner? If not, I don't think you mean to do that */

 Caller should have device mutex */

 No owner, become one */

		/* vDPA device does not use worker thead, so there's

		 * no need to hold the address space for mm. This help

		 * to avoid deadlock in the case of mmap() which may

		 * held the refcnt of the file and depends on release

		 * method to remove vma.

 Caller should have device mutex */

 Is there an owner already? */

 avoid contributing to loadavg */

 Caller should have device mutex */

	/* We don't need VQ locks below since vhost_dev_cleanup makes sure

	 * VQs aren't running.

 No one will access memory at this point */

 Make sure 64 bit math will not overflow. */

 Make sure 64 bit math will not overflow. */

 Caller should have vq mutex and device mutex. */

 Can we switch to this memory table? */

 Caller should have device mutex but not vq mutex */

 If ring is inactive, will check when it's enabled. */

		/* This function should be called after iotlb

		 * prefetch, which means we're sure that all vq

		 * could be access through iotlb. So -EAGAIN should

		 * not happen in this case.

		/* This function should be called after iotlb

		 * prefetch, which means we're sure that vq

		 * could be access through iotlb. So -EAGAIN should

		 * not happen in this case.

/* This function should be called after iotlb

 * prefetch, which means we're sure that vq

 * could be access through iotlb. So -EAGAIN should

 * not happen in this case.

 Make sure 64 bit math will not overflow. */

		/* There maybe a hole after type for V1 message type,

		 * so skip it here.

	/* If an IOTLB device is present, the vring addresses are

			/* Report the possible access violation by

			 * request another translation from userspace.

 Can we log writes? */

 Caller should have device mutex but not vq mutex */

	/* If an IOTLB device is present, log_addr is a GIOVA that

 Verify access for write logging. */

 Caller should have vq mutex and device mutex */

 Can we start vq? */

 Caller should have vq mutex and device mutex */

 All memory accesses are done under some VQ mutex. */

	/* Resizing ring with an active backend?

	/* For 32bit, verify that the top 32bits of the user

 Make sure it's safe to cast pointers to vring types. */

	/* We only verify access here if backend is configured.

	 * If it is not, we don't as size might not have been setup.

 Also validate log access for used ring if enabled. */

		/* Moving base with an active backend?

 Forget the cached index value. */

 Caller must have device mutex */

 If you are not the owner, you can become one */

 You must be the owner to do anything else */

 If ring is inactive, will check when it's enabled. */

/* TODO: This is really inefficient.  We need something like get_user()

 * (instruction directly accesses the data, with an exception table entry

 * returning -EFAULT). See Documentation/x86/exception-tables.rst.

		/* More than one GPAs can be mapped into a single HVA. So

		 * iterate all possible umems here to be safe.

 Make sure data written is seen before log. */

 Length written exceeds what we have stored. This is a bug. */

 Make sure the flag is seen before log. */

 Log used flag write. */

 Make sure the event is seen before log. */

 Log avail event write */

/* Each buffer in the virtqueues is actually a chain of descriptors.  This

 * function returns the next descriptor in the chain,

 If this descriptor says it doesn't chain, we're done. */

 Check they're not leading us off end of descriptors. */

 Sanity check */

	/* Buffers are chained via a 16 bit next field, so

 If this is an input descriptor, increment that count. */

			/* If it's an output descriptor, they're all supposed

/* This looks in the virtqueue and for the first available buffer, and converts

 * it to an iovec for convenient access.  Since descriptors consist of some

 * number of output then some number of input descriptors, it's actually two

 * iovecs, but we pack them into one and note how many of each there were.

 *

 * This function returns the descriptor number found, or vq->num (which is

 * never a valid descriptor number) if none was found.  A negative code is

 Check it isn't doing very strange things with descriptor numbers. */

		/* If there's nothing new since last we looked, return

		 * invalid.

		/* Only get avail ring entries after they have been

		 * exposed by guest.

	/* Grab the next descriptor number they're advertising, and increment

 If their number is silly, that's an error. */

 When we start there are none of either input nor output. */

			/* If this is an input descriptor,

			/* If it's an output descriptor, they're all supposed

 On success, increment avail index. */

	/* Assume notifications from guest are disabled at this point,

 Reverse the effect of vhost_get_vq_desc. Useful for error handling. */

/* After we've used one of their buffers, we tell them about it.  We'll then

 Make sure data is seen before log. */

 Log used ring entry write. */

	/* If the driver never bothers to signal in a very long while,

	 * used index might wrap around. If that happens, invalidate

	 * signalled_used index we stored. TODO: make sure driver

/* After we've used one of their buffers, we tell them about it.  We'll then

 Make sure buffer is written before we update index. */

 Make sure used idx is seen before log. */

 Log used index update. */

	/* Flush out used index updates. This is paired

	 * with the barrier that the Guest executes when enabling

 This actually signals the guest, using eventfd. */

 Signal the Guest tell them we used something up. */

 And here's the combo meal deal.  Supersize me! */

 multi-buffer version of vhost_add_used_and_signal */

 return true if we're sure that avaiable ring is empty */

 OK, now we need to know about added descriptors. */

	/* They could have slipped one in as we were doing that: make

 We don't need to be notified again. */

 Create a new message. */

 Make sure all padding within the structure is initialized. */

/*

 * Intel X38 Memory Controller kernel module

 * Copyright (C) 2008 Cluster Computing, Inc.

 *

 * This file may be distributed under the terms of the

 * GNU General Public License.

 *

 * This file is based on i3200_edac.c

 *

 Intel X38 register addresses - device 0 function 0 - DRAM Controller */

 MCH Memory Mapped Register BAR */

 bits 35:14 */

#define X38_TOM	0xa0	/* Top of Memory (16b)

				 *

				 * 15:10 reserved

				 *  9:0  total populated physical memory

 bits 9:0 */

 64MiB grain */

#define X38_ERRSTS	0xc8	/* Error Status Register (16b)

				 *

				 * 15    reserved

				 * 14    Isochronous TBWRR Run Behind FIFO Full

				 *       (ITCV)

				 * 13    Isochronous TBWRR Run Behind FIFO Put

				 *       (ITSTV)

				 * 12    reserved

				 * 11    MCH Thermal Sensor Event

				 *       for SMI/SCI/SERR (GTSE)

				 * 10    reserved

				 *  9    LOCK to non-DRAM Memory Flag (LCKF)

				 *  8    reserved

				 *  7    DRAM Throttle Flag (DTF)

				 *  6:2  reserved

				 *  1    Multi-bit DRAM ECC Error Flag (DMERR)

				 *  0    Single-bit DRAM ECC Error Flag (DSERR)

 Intel  MMIO register space - device 0 function 0 - MMR space */

#define X38_C0DRB	0x200	/* Channel 0 DRAM Rank Boundary (16b x 4)

				 *

				 * 15:10 reserved

				 *  9:0  Channel 0 DRAM Rank Boundary Address

 Channel 1 DRAM Rank Boundary (16b x 4) */

 bits 9:0 */

 64MiB grain */

#define X38_C0ECCERRLOG 0x280	/* Channel 0 ECC Error Log (64b)

				 *

				 * 63:48 Error Column Address (ERRCOL)

				 * 47:32 Error Row Address (ERRROW)

				 * 31:29 Error Bank Address (ERRBANK)

				 * 28:27 Error Rank Address (ERRRANK)

				 * 26:24 reserved

				 * 23:16 Error Syndrome (ERRSYND)

				 * 15: 2 reserved

				 *    1  Multiple Bit Error Status (MERRSTS)

				 *    0  Correctable Error Status (CERRSTS)

 Channel 1 ECC Error Log (64b) */

 see P.94 of spec for details */

 8th byte of CAPID0 */

 check DCD: Dual Channel Disable */

	/*

	 * Clear any error bits.

	 * (Yes, we really clear bits by writing 1 to them.)

	/*

	 * This is a mess because there is no atomic way to read all the

	 * registers at once and the registers can transition from CE being

	 * overwritten by UE.

	/*

	 * If the error is the same for both reads then the first set

	 * of reads is valid.  If there is a change then there is a CE

	 * with no info and the second set of reads is valid and

	 * should be UE info.

 FIXME: unconventional pvt_info usage */

	/*

	 * The dram rank boundary (DRB) reg values are boundary addresses

	 * for each DRAM rank with a granularity of 64MB.  DRB regs are

	 * cumulative; the last one will contain the total memory

	 * contained in all ranks.

 get this far and it's successful */

 0 terminated list. */

 Ensure that the OPSTATE is set correctly for POLL or NMI */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Driver for Pondicherry2 memory controller.

 *

 * Copyright (c) 2016, Intel Corporation.

 *

 * [Derived from sb_edac.c]

 *

 * Translation of system physical addresses to DIMM addresses

 * is a two stage process:

 *

 * First the Pondicherry 2 memory controller handles slice and channel interleaving

 * in "sys2pmi()". This is (almost) completley common between platforms.

 *

 * Then a platform specific dunit (DIMM unit) completes the process to provide DIMM,

 * rank, bank, row and column using the appropriate "dunit_ops" functions/parameters.

 Max DIMMs per channel */

 All requests go to PMI CH0 on each slice (CH1 disabled) */

/*

 * System address space is divided into multiple regions with

 * different interleave rules in each. The as0/as1 regions

 * have no interleaving at all. The as2 region is interleaved

 * between two channels. The mot region is magic and may overlap

 * other regions, with its interleave rules taking precedence.

 * Addresses not in any of these regions are interleaved across

 * all four channels.

 Debug macros */

/*

 * On Apollo Lake we access memory controller registers via a

 * side-band mailbox style interface in a hidden PCI device

 * configuration space.

 Unhide the P2SB device, if it's hidden */

 Hide the P2SB device, if it was hidden before */

 Unhide the P2SB device, if it's hidden */

 Hide the P2SB device, if it was hidden before */

 MMIO via memory controller hub base address */

 MMIO via sideband register base address */

 Both PMI channels in one slice enabled */

 Apollo Lake dunit */

/*

 * Validated on board with just two DIMMs in the [0] and [2] positions

 * in this array. Other port number matches documentation, but caution

 * advised.

 Denverton dunit */

	/*

	 * RD_REGP() will fail for unpopulated or non-existent

	 * DIMM slots. Return success if we find at least one DIMM.

/*

 * Read all the h/w config registers once here (they don't

 * change at run time. Figure out which address ranges have

 * which interleave characteristics.

 PMI channel idx (always 0) for asymmetric region */

 PMI channel bitmap (always 1) for symmetric region */

 Get a contiguous memory address (remove the MMIO gap) */

 Squeeze out one address bit, shift upper part down to fill gap */

 XOR all the bits from addr specified in mask */

/*

 * First stage decode. Take the system address and figure out which

 * second stage will deal with it based on interleave modes.

 Determine if address is in the MOT region. */

 Calculate the number of symmetric regions enabled. */

	/*

	 * The amount we need to shift the asym base can be determined by the

	 * number of enabled symmetric channels.

	 * NOTE: This can only work because symmetric memory is not supposed

	 * to do a 3-way interleave.

 Give up if address is out of range, or in MMIO gap */

 Get a contiguous memory address (remove the MMIO gap) */

 Otherwise we're in normal, boring symmetric mode. */

 Remove the chan_selector bit first */

 Remove the slice bit (we remove it second because it must be lower */

 Translate PMI address to memory (rank, row, bank, column) */

 column */

 bank */

 row */

 rank */

 addrdec values */

 dden values */

 dwid values */

 Second stage decode. Compute rank, bank, row & column. */

		/*

		 * On single rank DIMMs ignore the rank select bit

		 * and shift remainder of "bits[]" down one place.

 Pluck bit "in" from pmiaddr and return value shifted to bit "out" */

 Rank 0 or 1 */

 Rank 2 or 3 */

	/*

	 * Normally ranks 0,1 are DIMM0, and 2,3 are DIMM1, but we

	 * flip them if DIMM1 is larger than DIMM0.

 64/72 bit dram channel width */

 32/40 bit dram channel width */

 Check dramtype and ECC mode for each present DIMM */

 pmi channel idx to dimm channel idx */

	/*

	 * According with Table 15-9 of the Intel Architecture spec vol 3A,

	 * memory errors should fit in this mask:

	 *	000f 0000 1mmm cccc (binary)

	 * where:

	 *	f = Correction Report Filtering Bit. If 1, subsequent errors

	 *	    won't be shown

	 *	mmm = error type

	 *	cccc = channel

	 * If the mask doesn't match, report an error to the parsing logic

 Only decode errors with an valid address (ADDRV) */

 Call the helper to output message */

 DIMM0 is present if rank0 and/or rank1 is enabled */

 DIMM1 is present if rank2 and/or rank3 is enabled */

 Allocate a new MC control structure */

 Get dimm basic config and the memory layout */

 Remove MC sysfs nodes */

/*

 * Callback function registered with core kernel mce code.

 * Called once for each logged error.

	/*

	 * Just let mcelog handle it if the error is

	 * outside the memory controller. A memory error

	 * is indicated by bit 7 = 1 and bits = 8-11,13-15 = 0.

	 * bit 12 has an special meaning.

 Advice mcelog that the error were handled */

/*

 * Write an address to this file to exercise the address decode

 * logic in this driver.

 ADDRV + MemRd + Unknown channel */

 CONFIG_EDAC_DEBUG */

 Ensure that the OPSTATE is set correctly for POLL or NMI */

/*

 * Intel 5000(P/V/X) class Memory Controllers kernel module

 *

 * This file may be distributed under the terms of the

 * GNU General Public License.

 *

 * Written by Douglas Thompson Linux Networx (http://lnxi.com)

 *	norsk5@xmission.com

 *

 * This module is based on the following document:

 *

 * Intel 5000X Chipset Memory Controller Hub (MCH) - Datasheet

 * 	http://developer.intel.com/design/chipsets/datashts/313070.htm

 *

/*

 * Alter this version for the I5000 module when modifications are made

/* Device 16,

 * Function 0: System Address

 * Function 1: Memory Branch Map, Control, Errors Register

 * Function 2: FSB Error Registers

 *

 * All 3 functions of Device 16 (0,1,2) share the SAME DID

 OFFSETS for Function 0 */

 OFFSETS for Function 1 */

 Thermal and SPD or BFD errors */

 Correctable errors */

 Non-Retry or redundant Retry errors */

 Uncorrectable errors */

 OFFSETS for Function 2 */

/*

 * Device 21,

 * Function 0: Memory Map Branch 0

 *

 * Device 22,

 * Function 0: Memory Map Branch 1

/* Defines to extract the various fields from the

 *	MTRx - Memory Technology Registers

 enables the report of miscellaneous messages as CE errors - default off */

 Enumeration of supported devices */

 future */

 future */

 Device name and register DID (Device ID) */

 name for this device */

 DID for the branchmap,control */

 Table of devices attributes supported by this driver */

 size, 0 means not present  */

 max possible channels */

 max possible csrows per channel */

 driver private data structure */

 16.0 */

 16.1 */

 16.2 */

 21.0 */

 22.0 */

 top of low memory */

 AMB BAR */

 Memory Technlogy Reg */

 Branch 0, Channel 0 */

 Brnach 0, Channel 1 */

 Memory Technlogy Reg */

 Branch 1, Channel 8 */

 Branch 1, Channel 1 */

 DIMM information matrix, allocating architecture maximums */

 Actual values for this controller */

 Max channels */

 Max DIMMs per channel */

 I5000 MCH error information retrieved from Hardware */

 These registers are always read from the MC */

 First Errors Fatal */

 Next Errors Fatal */

 First Errors Non-Fatal */

 Next Errors Non-Fatal */

 These registers are input ONLY if there was a Recoverable  Error */

 Recoverable Mem Data Error log B */

 Recoverable Mem Error log A */

 Recoverable Mem Error log B */

	/* These registers are input ONLY if there was a

 Non-Recoverable Mem log A */

 Non-Recoverable Mem log B */

/*

 *	i5000_get_error_info	Retrieve the hardware error information from

 *				the hardware and cache it in the 'info'

 *				structure

 read in the 1st FATAL error register */

	/* Mask only the bits that the doc says are valid

 If there is an error, then read in the */

 NEXT FATAL error register and the Memory Error Log Register A */

 harvest the various error data we need */

 Clear the error bits, by writing them back */

 read in the 1st NON-FATAL error register */

	/* If there is an error, then read in the 1st NON-FATAL error

 harvest the various error data we need */

 Clear the error bits, by writing them back */

/*

 * i5000_process_fatal_error_info(struct mem_ctl_info *mci,

 * 					struct i5000_error_info *info,

 * 					int handle_errors);

 *

 *	handle the Intel FATAL errors, if any

 mask off the Error bits that are possible */

 if no error, return now */

 Use the NON-Recoverable macros to extract data */

 Only 1 bit will be on */

		/*

		 * This error is generated to inform that the intelligent

		 * throttling is disabled and the temperature passed the

		 * specified middle point. Since this is something the BIOS

		 * should take care of, we'll warn only once to avoid

		 * worthlessly flooding the log.

 Form out message */

 Call the helper to output message */

/*

 * i5000_process_fatal_error_info(struct mem_ctl_info *mci,

 * 				struct i5000_error_info *info,

 * 				int handle_errors);

 *

 *	handle the Intel NON-FATAL errors, if any

 mask off the Error bits that are possible */

 if no error, return now */

 ONLY ONE of the possible error bits will be set, as per the docs */

		/*

		 * According with i5000 datasheet, bit 28 has no significance

		 * for errors M4Err-M12Err and M17Err-M21Err, on FERR_NF_FBD

 Form out message */

 Call the helper to output message */

 Check correctable errors */

		/* Convert channel to be based from zero, instead of

 Form out message */

 Call the helper to output message */

 Form out message */

 Call the helper to output message */

/*

 *	i5000_process_error_info	Process the error info that is

 *	in the 'info' structure, previously retrieved from hardware

 First handle any fatal errors that occurred */

 now handle any non-fatal errors that occurred */

/*

 *	i5000_clear_error	Retrieve any error from the hardware

 *				but do NOT process that error.

 *				Used for 'clearing' out of previous errors

 *				Called by the Core module.

/*

 *	i5000_check_error	Retrieve and process errors reported by the

 *				hardware. Called by the Core module.

/*

 *	i5000_get_devices	Find and perform 'get' operation on the MCH's

 *			device/functions we want to reference for this driver

 *

 *			Need to 'get' device 16 func 1 and func 2

const struct i5000_dev_info *i5000_dev = &i5000_devs[dev_idx];

 Attempt to 'get' the MCH register we want */

 End of list, leave */

 Scan for device 16 func 1 */

 Attempt to 'get' the MCH register we want */

 Scan for device 16 func 1 */

	/* If this device claims to have more than 2 channels then

	 * fetch Branch 1's information

/*

 *	i5000_put_devices	'put' all the devices that we have

 *				reserved via 'get'

 FUNC 1 */

 FUNC 2 */

 DEV 21 */

 Only if more than 2 channels do we release the second branch */

 DEV 22 */

/*

 *	determine_amb_resent

 *

 *		the information is contained in NUM_MTRS different registers

 *		determineing which of the NUM_MTRS requires knowing

 *		which channel is in question

 *

 *	2 branches, each with 2 channels

 *		b0_ambpresent0 for channel '0'

 *		b0_ambpresent1 for channel '1'

 *		b1_ambpresent0 for channel '2'

 *		b1_ambpresent1 for channel '3'

/*

 * determine_mtr(pvt, csrow, channel)

 *

 *	return the proper MTR register as determine by the csrow and channel desired

/*

 Determine if there is a DIMM present in this DIMM slot */

			/* Start with the number of bits for a Bank

 Add the number of ROW bits */

 add the number of COLUMN bits */

 Dual-rank memories have twice the size */

 add 64 bits per DIMM */

 divide by 2^^20 */

 8 bits per bytes */

/*

 *	calculate_dimm_size

 *

 *	also will output a DIMM matrix map, if debug is enabled, for viewing

 *	how the DIMMs are populated

 ================= Generate some debug output ================= */

	/* Scan all the actual slots

	 * and calculate the information for each DIMM

	 * Start with the highest slot first, to display it first

	 * and work toward the 0th slot

		/* on an odd slot, first output a 'boundary' marker,

 Output the last bottom 'boundary' marker */

 now output the 'channel' labels */

 output the last message and free buffer */

/*

 *	i5000_get_mc_regs	read in the necessary registers and

 *				cache locally

 *

 *			Fills in the private data members

 Get the Branch Map regs */

 Get the MIR[0-2] regs */

 Get the MTR[0-3] regs */

 Read and dump branch 0's MTRs */

 Only if we have 2 branchs (4 channels) */

 Read and dump  branch 1's MTRs */

	/* Go and determine the size of each DIMM and place in an

/*

 *	i5000_init_csrows	Initialize the 'csrows' table within

 *				the mci control	structure with the

 *				addressing of memory.

 *

 *	return:

 *		0	success

 *		1	no actual memory found on this MC

 Assume NO memory */

	/*

	 * FIXME: The memory layout used to map slot/channel into the

	 * real memory architecture is weird: branch+slot are "csrows"

	 * and channel is channel. That required an extra array (dimm_info)

	 * to map the dimms. A good cleanup would be to remove this array,

	 * and do a loop here with branch, channel, slot

 Assume DDR2 for now */

 ask what device type on this row */

/*

 *	i5000_enable_error_reporting

 *			Turn on the memory reporting features of the hardware

 Read the FBD Error Mask Register */

 Enable with a '0' */

/*

 * i5000_get_dimm_and_channel_counts(pdev, &nr_csrows, &num_channels)

 *

 *	ask the device how many channels are present and how many CSROWS

 *	 as well

	/* Need to retrieve just how many channels and dimms per channel are

	 * supported on this memory controller

/*

 *	i5000_probe1	Probe for ONE instance of device to see if it is

 *			present.

 *	return:

 *		0 for FOUND a device

 *		< 0 for error code

 We only are looking for func 0 of the set */

	/* Ask the devices for the number of CSROWS and CHANNELS so

	 * that we can calculate the memory resources, etc

	 *

	 * The Chipset will report what it can handle which will be greater

	 * or equal to what the motherboard manufacturer will implement.

	 *

	 * As we don't have a motherboard identification routine to determine

	 * actual number of slots/dimms per channel, we thus utilize the

	 * resource as specified by the chipset. Thus, we might have

	 * have more DIMMs per channel than actually on the mobo, but this

	 * allows the driver to support up to the chipset max, without

	 * some fancy mobo determination.

 allocate a new MC control structure */

 record ptr  to the generic device */

 Record this device in our private */

 'get' the pci devices we want to reserve for our use */

 Time to get serious */

 retrieve the hardware registers */

 Set the function pointer to an actual operation function */

	/* initialize the MC control structure 'csrows' table

 no csrows found */

 add this new MC control structure to EDAC's list of MCs */

		/* FIXME: perhaps some code should go here that disables error

		 * reporting if we just enabled it

 allocating generic PCI control info */

 Error exit unwinding stack */

/*

 *	i5000_init_one	constructor for one instance of device

 *

 * 	returns:

 *		negative on error

 *		count (>= 0)

 wake up device */

 now probe and enable the device */

/*

 *	i5000_remove_one	destructor for one instance of device

 *

 retrieve references to resources, and free those resources */

/*

 *	pci_device_id	table for which devices we are looking for

 *

 *	The "E500P" device is the first device supported.

 0 terminated list. */

/*

 *	i5000_driver	pci_driver structure for this module

 *

/*

 *	i5000_init		Module entry function

 *			Try to initialize this module for its devices

 Ensure that the OPSTATE is set correctly for POLL or NMI */

/*

 *	i5000_exit()	Module exit function

 *			Unregister the driver

lnxi.com) Doug Thompson <norsk5@xmission.com>");

/*

 * AMD 76x Memory Controller kernel module

 * (C) 2003 Linux Networx (http://lnxi.com)

 * This file may be distributed under the terms of the

 * GNU General Public License.

 *

 * Written by Thayne Harbaugh

 * Based on work by Dan Hollis <goemon at anime dot net> and others.

 *	http://www.anime.net/~goemon/linux-ecc/

 *

 * $Id: edac_amd76x.c,v 1.4.2.5 2005/10/05 00:43:44 dsp_llnl Exp $

 *

 AMD 76x register addresses - device 0 function 0 - PCI bridge */

#define AMD76X_ECC_MODE_STATUS	0x48	/* Mode and status of ECC (32b)

					 *

					 * 31:16 reserved

					 * 15:14 SERR enabled: x1=ue 1x=ce

					 * 13    reserved

					 * 12    diag: disabled, enabled

					 * 11:10 mode: dis, EC, ECC, ECC+scrub

					 *  9:8  status: x1=ue 1x=ce

					 *  7:4  UE cs row

					 *  3:0  CE cs row

#define AMD76X_DRAM_MODE_STATUS	0x58	/* DRAM Mode and status (32b)

					 *

					 * 31:26 clock disable 5 - 0

					 * 25    SDRAM init

					 * 24    reserved

					 * 23    mode register service

					 * 22:21 suspend to RAM

					 * 20    burst refresh enable

					 * 19    refresh disable

					 * 18    reserved

					 * 17:16 cycles-per-refresh

					 * 15:8  reserved

					 *  7:0  x4 mode enable 7 - 0

#define AMD76X_MEM_BASE_ADDR	0xC0	/* Memory base address (8 x 32b)

					 *

					 * 31:23 chip-select base

					 * 22:16 reserved

					 * 15:7  chip-select mask

					 *  6:3  reserved

					 *  2:1  address mode

					 *  0    chip-select enable

/**

 *	amd76x_get_error_info	-	fetch error information

 *	@mci: Memory controller

 *	@info: Info to fill in

 *

 *	Fetch and store the AMD76x ECC status. Clear pending status

 *	on the chip so that further errors will be reported

/**

 *	amd76x_process_error_info	-	Error check

 *	@mci: Memory controller

 *	@info: Previously fetched information from chip

 *	@handle_errors: 1 if we should do recovery

 *

 *	Process the chip state and decide if an error has occurred.

 *	A return of 1 indicates an error. Also if handle_errors is true

 *	then attempt to handle and clean up after the error

	/*

	 *      Check for an uncorrectable error

	/*

	 *      Check for a correctable error

/**

 *	amd76x_check	-	Poll the controller

 *	@mci: Memory controller

 *

 *	Called by the poll handlers this function reads the status

 *	from the controller and checks for errors.

 find the DRAM Chip Select Base address and mask */

/**

 *	amd76x_probe1	-	Perform set up for detected device

 *	@pdev; PCI device detected

 *	@dev_idx: Device type index

 *

 *	We have found an AMD76x and now need to set up the memory

 *	controller status reporting. We configure and set up the

 *	memory controller reporting and claim the device.

 clear counters */

	/* Here we assume that we will never see multiple instances of this

	 * type of memory controller.  The ID is therefore hardcoded to 0.

 allocating generic PCI control info */

 get this far and it's successful */

 returns count (>= 0), or negative on error */

 don't need to call pci_enable_device() */

/**

 *	amd76x_remove_one	-	driver shutdown

 *	@pdev: PCI device being handed back

 *

 *	Called when the driver is unloaded. Find the matching mci

 *	structure for the device then delete the mci and free the

 *	resources.

 0 terminated list. */

 Ensure that the OPSTATE is set correctly for POLL or NMI */

lnxi.com) Thayne Harbaugh");

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2011-2012 Calxeda, Inc.

 DDR Ctrlr Error Registers */

 DDR Ctrlr Interrupt Registers */

 Read the interrupt status register */

 clear the error, clears the interrupt */

 Only a single 4GB DIMM is supported */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Intel E3-1200

 * Copyright (C) 2014 Jason Baron <jbaron@akamai.com>

 *

 * Support for the E3-1200 processor family. Heavily based on previous

 * Intel EDAC drivers.

 *

 * Since the DRAM controller is on the cpu chip, we can use its PCI device

 * id to identify these processors.

 *

 * PCI DRAM controller device ids (Taken from The PCI ID Repository - https://pci-ids.ucw.cz/)

 *

 * 0108: Xeon E3-1200 Processor Family DRAM Controller

 * 010c: Xeon E3-1200/2nd Generation Core Processor Family DRAM Controller

 * 0150: Xeon E3-1200 v2/3rd Gen Core processor DRAM Controller

 * 0158: Xeon E3-1200 v2/Ivy Bridge DRAM Controller

 * 015c: Xeon E3-1200 v2/3rd Gen Core processor DRAM Controller

 * 0c04: Xeon E3-1200 v3/4th Gen Core Processor DRAM Controller

 * 0c08: Xeon E3-1200 v3 Processor DRAM Controller

 * 1918: Xeon E3-1200 v5 Skylake Host Bridge/DRAM Registers

 * 5918: Xeon E3-1200 Xeon E3-1200 v6/7th Gen Core Processor Host Bridge/DRAM Registers

 * 3e..: 8th/9th Gen Core Processor Host Bridge/DRAM Registers

 *

 * Based on Intel specification:

 * https://www.intel.com/content/dam/www/public/us/en/documents/datasheets/xeon-e3-1200v3-vol-2-datasheet.pdf

 * http://www.intel.com/content/www/us/en/processors/xeon/xeon-e3-1200-family-vol-2-datasheet.html

 * https://www.intel.com/content/www/us/en/processors/core/7th-gen-core-family-mobile-h-processor-lines-datasheet-vol-2.html

 * https://www.intel.com/content/www/us/en/products/docs/processors/core/8th-gen-core-family-datasheet-vol-2.html

 *

 * According to the above datasheet (p.16):

 * "

 * 6. Software must not access B0/D0/F0 32-bit memory-mapped registers with

 * requests that cross a DW boundary.

 * "

 *

 * Thus, we make use of the explicit: lo_hi_readq(), which breaks the readq into

 * 2 readl() calls. This restriction may be lifted in subsequent chip releases,

 * but lo_hi_readq() ensures that we are safe across all e3-1200 processors.

 Coffee Lake-S */

 Test if HB is for Skylake or later. */

 Intel IE31200 register addresses - device 0 function 0 - DRAM Controller */

/*

 * Error Status Register (16b)

 *

 * 15    reserved

 * 14    Isochronous TBWRR Run Behind FIFO Full

 *       (ITCV)

 * 13    Isochronous TBWRR Run Behind FIFO Put

 *       (ITSTV)

 * 12    reserved

 * 11    MCH Thermal Sensor Event

 *       for SMI/SCI/SERR (GTSE)

 * 10    reserved

 *  9    LOCK to non-DRAM Memory Flag (LCKF)

 *  8    reserved

 *  7    DRAM Throttle Flag (DTF)

 *  6:2  reserved

 *  1    Multi-bit DRAM ECC Error Flag (DMERR)

 *  0    Single-bit DRAM ECC Error Flag (DSERR)

/*

 * Channel 0 ECC Error Log (64b)

 *

 * 63:48 Error Column Address (ERRCOL)

 * 47:32 Error Row Address (ERRROW)

 * 31:29 Error Bank Address (ERRBANK)

 * 28:27 Error Rank Address (ERRRANK)

 * 26:24 reserved

 * 23:16 Error Syndrome (ERRSYND)

 * 15: 2 reserved

 *    1  Multiple Bit Error Status (MERRSTS)

 *    0  Correctable Error Status (CERRSTS)

 Skylake reports 1GB increments, everything else is 256MB */

 in multiples of 256MB, except Skylake is 1GB */

 0 means x8 width */

 2nd byte of CAPID0 */

 check PDCD: Dual Channel Disable */

 check DDPCD - check if both channels are filled */

 4th byte of CAPID0 */

	/*

	 * Clear any error bits.

	 * (Yes, we really clear bits by writing 1 to them.)

	/*

	 * This is a mess because there is no atomic way to read all the

	 * registers at once and the registers can transition from CE being

	 * overwritten by UE.

	/*

	 * If the error is the same for both reads then the first set

	 * of reads is valid.  If there is a change then there is a CE

	 * with no info and the second set of reads is valid and

	 * should be UE info.

	/*

	 * Kaby Lake, Coffee Lake seem to work like Skylake. Please re-visit

	 * this logic when adding new CPU support.

 populate DIMM info */

	/*

	 * The dram rank boundary (DRB) reg values are boundary addresses

	 * for each DRAM rank with a granularity of 64MB.  DRB regs are

	 * cumulative; the last one will contain the total memory

	 * contained in all ranks.

 just a guess */

 same guess */

 get this far and it's successful */

 0 terminated list. */

 Ensure that the OPSTATE is set correctly for POLL or NMI */

 SPDX-License-Identifier: GPL-2.0

/*

 * Driver for Intel(R) 10nm server memory controller.

 * Copyright (c) 2019, Intel Corporation.

 *

 Debug macros */

 Save default configurations */

 Restore default configurations */

 Clear status bits */

/*

 * Debug feature.

 * Exercise the address decode logic by writing an address to

 * /sys/kernel/debug/edac/i10nm_test/addr.

 ADDRV + MemRd + Unknown channel */

 One corrected error */

CONFIG_EDAC_DEBUG*/

 SPDX-License-Identifier: GPL-2.0-only

 SPDX-License-Identifier: GPL-2.0

/*

 * Driver for Intel client SoC with integrated memory controller using IBECC

 *

 * Copyright (C) 2020 Intel Corporation

 *

 * The In-Band ECC (IBECC) IP provides ECC protection to all or specific

 * regions of the physical memory space. It's used for memory controllers

 * that don't support the out-of-band ECC which often needs an additional

 * storage device to each channel for storing ECC data.

 Debug macros */

 Max memory controllers */

 Max channels */

 Max DIMMs per channel */

 Size of physical memory */

 Top of low usable DRAM */

 Capability register C */

 Capability register E */

 Error Status */

 Error Command */

 IBECC MMIO base address */

 IBECC error log */

 Host MMIO base address */

 Parameters for the channel decode stage */

 Parameters for DRAM decode stage */

 DIMM characteristics */

 Hash for memory controller selection */

 Hash for channel selection */

 Hash for enhanced channel selection */

 Parameters for memory slice decode stage */

 Convert error address logged in IBECC to system physical address */

 Convert error address logged in IBECC to integrated memory controller address */

 The top of low usable DRAM */

 The size of physical memory */

/*

 * In the NMI handler, the driver uses the lock-less memory allocator

 * to allocate memory to store the IBECC error logs and links the logs

 * to the lock-less list. Delay printk() and the work of error reporting

 * to EDAC core in a worker.

 Compute die IDs for Elkhart Lake with IBECC */

 Compute die IDs for ICL-NNPI with IBECC */

 Compute die IDs for Tiger Lake with IBECC */

 Compute die IDs for Alder Lake with IBECC */

 Remove the interleave bit and shift upper part down to fill gap */

 Decode channel */

 Decode sub-channel/DIMM */

/*

 * Either the memory-mapped I/O status register ECC_ERROR_LOG or the PCI

 * configuration space status register ERRSTS can indicate whether a

 * correctable error or an uncorrectable error occurred. We only use the

 * ECC_ERROR_LOG register to check error type, but need to clear both

 * registers to enable future error events.

 Clear CE/UE bits by writing 1s */

 Clear CE/UE bits by writing 1s */

 errsts_clear() isn't NMI-safe. Delay it in the IRQ context */

	/*

	 * Both In-Band ECC correctable error and uncorrectable error are

	 * reported by SERR# NMI. The NMI generic code (see pci_serr_error())

	 * doesn't clear the bit NMI_REASON_CLEAR_SERR (in port 0x61) to

	 * re-enable the SERR# NMI after NMI handling. So clear this bit here

	 * to re-enable SERR# NMI for receiving future In-Band ECC errors.

	/*

	 * Ignore unless this is a memory related error.

	 * We don't check the bit MCI_STATUS_ADDRV of MCi_STATUS here,

	 * since this bit isn't set on some CPU (e.g., Tiger Lake UP3).

	/*

	 * We just use the Machine Check for the memory error notification.

	 * Each memory controller is associated with an IBECC instance.

	 * Directly read and clear the error information(error address and

	 * error type) on all the IBECC instances so that we know on which

	 * memory controller the memory error(s) occurred.

 Top of upper usable DRAM */

	/*

	 * EDAC core uses mci->pdev(pointer of structure device) as

	 * memory controller ID. The client SoCs attach one or more

	 * memory controllers to single pci_dev (single pci_dev->dev

	 * can be for multiple memory controllers).

	 *

	 * To make mci->pdev unique, assign pci_dev->dev to mci->pdev

	 * for the first memory controller and assign a unique imc->dev

	 * to mci->pdev for each non-first memory controller.

 Check if any pending errors before registering the NMI handler */

 Enable error reporting */

/*

 * Intel 5100 Memory Controllers kernel module

 *

 * This file may be distributed under the terms of the

 * GNU General Public License.

 *

 * This module is based on the following document:

 *

 * Intel 5100X Chipset Memory Controller Hub (MCH) - Datasheet

 *      http://download.intel.com/design/chipsets/datashts/318378.pdf

 *

 * The intel 5100 has two independent channels. EDAC core currently

 * can not reflect this configuration so instead the chip-select

 * rows for each respective channel are laid out one after another,

 * the first half belonging to channel 0, the second half belonging

 * to channel 1.

 *

 * This driver is for DDR2 DIMMs, and it uses chip select to select among the

 * several ranks. However, instead of showing memories as ranks, it outputs

 * them as DIMM's. An internal table creates the association between ranks

 * and DIMM's.

 register addresses */

 device 16, func 1 */

 Memory Control Register */

 Memory Status Register */

 Serial Presence Detect Status Reg */

 Serial Presence Detect Command Reg */

 Top of Low Memory */

 Memory Interleave Range 0 */

 Memory Interleave Range 1 */

 Adjusted Memory Interleave Range 0 */

 Adjusted Memory Interleave Range 1 */

 MC First Non Fatal Errors */

 MC Next Non-Fatal Errors */

 MC Error Mask Register */

 Injection Mask0 Register Channel 0 */

 Injection Mask0 Register Channel 1 */

 Injection Mask1 Register Channel 0 */

 Injection Mask1 Register Channel 1 */

 Device 19, Function 0 */

 device 21 and 22, func 0 */

 Memory Technology Registers 0-3 */

 DIMM Interleave Range */

 Valid Log Markers */

 Non-Recoverable Memory Error Log Reg A */

 Non-Recoverable Memory Error Log Reg B */

 Recoverable Memory Data Error Log Reg A */

 Recoverable Memory Data Error Log Reg B */

 Recoverable Memory Error Log Reg A */

 Recoverable Memory Error Log Reg B */

 Memory Technology Registers 4,5 */

 bit field accessors */

 some generic limits */

 64 bits / 8 bits per byte */

 ranks on each dimm -- 0 maps to not present -- obtained via SPD */

	/*

	 * mainboard chip select map -- maps i5100 chip selects to

	 * DIMM slot chip selects.  In the case of only 4 ranks per

	 * channel, the mapping is fairly obvious but not unique.

	 * we map -1 -> NC and assume both channels use the same

	 * map...

	 *

 memory interleave range */

 adjusted memory interleave range register */

 dimm interleave range */

 memory technology registers... */

 0 or 1 */

 0 or 1 */

 4 or 8 bits  */

 2 or 3 lines */

 13 .. 16 lines */

 11 .. 12 lines */

 top of low memory in bytes */

 number of ranks per channel */

 device 16 func 1 */

 device 19 func 0 */

 device 21 func 0 */

 device 22 func 0 */

 Error injection */

 map a rank/chan to a slot number on the mainboard */

 0 */

 1 */

 2 */

 3 */

 4 */

 5 */

 6 */

 7 */

 8 */

 9 */

 10 */

 11 */

 12 */

 13 */

 14 */

 15 */

 16 */

 17 */

 18 */

 19 */

 20 */

 21 */

 convert csrow index into a rank (per channel -- 0..5) */

 convert csrow index into a channel (0..1) */

 Form out message */

 Form out message */

		/* FIXME:  not really sure if this is what merr is...

		/* FIXME:  not really sure if this is what merr is...

/* The i5100 chipset will scrub the entire memory once, then

 * set a done bit. Continuous scrubbing is achieved by enqueing

 * delayed work to a workqueue, checking every few minutes if

 * the scrubbing has completed and if so reinitiating it.

/*

 * The bandwidth is based on experimentation, feel free to refine it.

 dimm present? */

/*

 * FIXME: make this into a real i2c adapter (so that dimm-decode

 * will work)?

 wait up to 100ms */

/*

 * fill dimm chip select map

 *

 * FIXME:

 *   o not the only way to may chip selects to dimm slots

 *   o investigate if there is some way to obtain this map from the bios

 default NC */

 only 2 chip selects per slot... */

/****************************************************************************

 *                       Error injection routines

	/* MEM[1:0]EINJMSK0

	 * 31    - ADDRMATCHEN

	 * 29:28 - HLINESEL

	 *         00 Reserved

	 *         01 Lower half of cache line

	 *         10 Upper half of cache line

	 *         11 Both upper and lower parts of cache line

	 * 27    - EINJEN

	 * 25:19 - XORMASK1 for deviceptr1

	 * 9:5   - SEC2RAM for deviceptr2

	 * 4:0   - FIR2RAM for deviceptr1

	/* MEM[1:0]EINJMSK1

	 * 15:0  - XORMASK2 for deviceptr2

	/* Error Injection Response Function

	 * Intel 5100 Memory Controller Hub Chipset (318378) datasheet

	 * hints about this register but carry no data about them. All

	 * data regarding device 19 is based on experimentation and the

	 * Intel 7300 Chipset Memory Controller Hub (318082) datasheet

	 * which appears to be accurate for the i5100 in this area.

	 *

	 * The injection code don't work without setting this register.

	 * The register needs to be flipped off then on else the hardware

	 * will only preform the first injection.

	 *

	 * Stop condition bits 7:4

	 * 1010 - Stop after one injection

	 * 1011 - Never stop injecting faults

	 *

	 * Start condition bits 3:0

	 * 1010 - Never start

	 * 1011 - Start immediately

 ECC enabled? */

 figure out how many ranks, from strapped state of 48GB_Mode input */

 enable error reporting... */

 device 21, func 0, Channel 0 Memory Map, Error Flag/Mask, etc... */

 device 22, func 0, Channel 1 Memory Map, Error Flag/Mask, etc... */

 device 19, func 0, Error injection */

 If scrubbing was already enabled by the bios, start maintaining it */

 this strange construction seems to be in every driver, dunno why */

 Device 16, Function 0, Channel 0 Memory Map, Error Flag/Mask, ... */

/*

 * This file is subject to the terms and conditions of the GNU General Public

 * License.  See the file "COPYING" in the main directory of this archive

 * for more details.

 *

 * Copyright (C) 2009 Wind River Systems,

 *   written by Ralf Baechle <ralf@linux-mips.org>

 *

 * Copyright (c) 2013 by Cisco Systems, Inc.

 * All rights reserved.

 Done, re-arm */

 Done, re-arm */

 Done, re-arm */

 Done, re-arm */

*********************** MC SYSFS parts ***********************************/

 Only a couple naming differences per template, so very similar */

 We poll */

 OCTEON II */

 We poll */

/*

 * Freescale Memory Controller kernel module

 *

 * Author: York Sun <york.sun@nxp.com>

 *

 * Copyright 2016 NXP Semiconductor

 *

 * Derived from mpc85xx_edac.c

 * Author: Dave Jiang <djiang@mvista.com>

 *

 * 2006-2007 (c) MontaVista Software, Inc. This file is licensed under

 * the terms of the GNU General Public License version 2. This program

 * is licensed "as is" without any warranty of any kind, whether express

 * or implied.

 make sure error reporting method is sane */

/*

 * Intel e7xxx Memory Controller kernel module

 * (C) 2003 Linux Networx (http://lnxi.com)

 * This file may be distributed under the terms of the

 * GNU General Public License.

 *

 * See "enum e7xxx_chips" below for supported chipsets

 *

 * Written by Thayne Harbaugh

 * Based on work by Dan Hollis <goemon at anime dot net> and others.

 *	http://www.anime.net/~goemon/linux-ecc/

 *

 * Datasheet:

 *	http://www.intel.com/content/www/us/en/chipsets/e7501-chipset-memory-controller-hub-datasheet.html

 *

 * Contributors:

 *	Eric Biederman (Linux Networx)

 *	Tom Zimmerman (Linux Networx)

 *	Jim Garlick (Lawrence Livermore National Labs)

 *	Dave Peterson (Lawrence Livermore National Labs)

 *	That One Guy (Some other place)

 *	Wang Zhenyu (intel.com)

 *

 * $Id: edac_e7xxx.c,v 1.5.2.9 2005/10/05 00:43:44 dsp_llnl Exp $

 *

 PCI_DEVICE_ID_INTEL_7205_0 */

 PCI_DEVICE_ID_INTEL_7205_1_ERR */

 PCI_DEVICE_ID_INTEL_7500_0 */

 PCI_DEVICE_ID_INTEL_7500_1_ERR */

 PCI_DEVICE_ID_INTEL_7501_0 */

 PCI_DEVICE_ID_INTEL_7501_1_ERR */

 PCI_DEVICE_ID_INTEL_7505_0 */

 PCI_DEVICE_ID_INTEL_7505_1_ERR */

 number of csrows */

 2 channels, 4 dimms/channel */

 E7XXX register addresses - device 0 function 0 */

 DRAM row boundary register (8b) */

 DRAM row attribute register (8b) */

					/*

					 * 31   Device width row 7 0=x8 1=x4

					 * 27   Device width row 6

					 * 23   Device width row 5

					 * 19   Device width row 4

					 * 15   Device width row 3

					 * 11   Device width row 2

					 *  7   Device width row 1

					 *  3   Device width row 0

 DRAM controller mode reg (32b) */

					/*

					 * 22    Number channels 0=1,1=2

					 * 19:18 DRB Granularity 32/64MB

 DRAM top of low memory reg (16b) */

 DRAM remap base address reg (16b) */

 DRAM remap limit address reg (16b) */

 E7XXX register addresses - device 0 function 1 */

 DRAM first error register (8b) */

 DRAM next error register (8b) */

 DRAM first correctable memory */

     error address register (32b) */

					/*

					 * 31:28 Reserved

					 * 27:6  CE address (4k block 33:12)

					 *  5:0  Reserved

 DRAM first uncorrectable memory */

     error address register (32b) */

					/*

					 * 31:28 Reserved

					 * 27:6  CE address (4k block 33:12)

					 *  5:0  Reserved

 DRAM first correctable memory */

     error syndrome register (16b) */

 FIXME - is this valid for both SECDED and S4ECD4ED? */

 read the error address */

 FIXME - should use PAGE_SHIFT */

 convert the address to 4k page */

 read the syndrome */

 FIXME - check for -1 */

 convert syndrome to channel */

 read the error address */

 FIXME - should use PAGE_SHIFT */

 convert to 4k address */

 decode and report errors */

 check first error correctable */

 check first error uncorrectable */

 check next error correctable */

 check next error uncorrectable */

 Return 1 if dual channel mode is active.  Else return 0. */

 Return DRB granularity (0=32mb, 1=64mb). */

 only e7501 can be single channel */

	/* The dram row boundary (DRB) reg values are boundary address

	 * for each DRAM row with a granularity of 32 or 64MB (single/dual

	 * channel operation).  DRB regs are cumulative; therefore DRB7 will

	 * contain the total memory contained in all eight rows.

 mem_dev 0=x8, 1=x4 */

 convert a 64 or 32 MiB DRB to a page size. */

 not populated */

		/*

		* if single channel or x8 devices then SECDED

		* if dual channel and x4 then S4ECD4ED

 4KiB - resolution of CELOG */

 only one type supported */

	/*

	 * According with the datasheet, this device has a maximum of

	 * 4 DIMMS per channel, either single-rank or dual-rank. So, the

	 * total amount of dimms is 8 (E7XXX_NR_DIMMS).

	 * That means that the DIMM is mapped as CSROWs, and the channel

	 * will map the rank. So, an error to either channel should be

	 * attributed to the same dimm.

 FIXME - what if different memory types are in different csrows? */

 load the top of low memory, remap base, and remap limit vars */

 clear any pending errors, or initial state bits */

	/* Here we assume that we will never see multiple instances of this

	 * type of memory controller.  The ID is therefore hardcoded to 0.

 allocating generic PCI control info */

 get this far and it's successful */

 returns count (>= 0), or negative on error */

 wake up and enable device */

 0 terminated list. */

 Ensure that the OPSTATE is set correctly for POLL or NMI */

lnxi.com) Thayne Harbaugh et al\n"

 SPDX-License-Identifier: GPL-2.0-only

/*

 * cpc925_edac.c, EDAC driver for IBM CPC925 Bridge and Memory Controller.

 *

 * Copyright (c) 2008 Wind River Systems, Inc.

 *

 * Authors:	Cao Qingtao <qingtao.cao@windriver.com>

/*

 * CPC925 registers are of 32 bits with bit0 defined at the

 * most significant bit and bit31 at that of least significant.

/*

 * EDAC device names for the error detections of

 * CPU Interface and Hypertransport Link.

 Suppose DDR Refresh cycle is 15.6 microsecond */

 bytes */

/*

 * All registers and bits definitions are taken from

 * "CPC925 Bridge and Memory Controller User Manual, SA14-2761-02".

/*

 * CPU and Memory Controller Registers

/************************************************************

 *	Processor Interface Exception Mask Register (APIMASK)

 DART Exception */

 Handshake Error on PI0_ADI */

 Handshake Error on PI1_ADI */

 Status Exception */

 Data Error Exception */

 Addressing Exception on PI0 */

 Addressing Exception on PI1 */

 BIT(7) Reserved */

 UECC upper */

 CECC upper */

 UECC lower */

 CECC lower */

/************************************************************

 *	Processor Interface Exception Register (APIEXCP)

 DART Exception */

 Handshake Error on PI0_ADI */

 Handshake Error on PI1_ADI */

 Status Exception */

 Data Error Exception */

 Addressing Exception on PI0 */

 Addressing Exception on PI1 */

 BIT(7) Reserved */

 UECC upper */

 CECC upper */

 UECC lower */

 CECC lower */

/************************************************************

 *	Memory Bus Configuration Register (MBCR)

/************************************************************

 *	Memory Bank Mode Register (MBMR)

/************************************************************

 *	Memory Bank Boundary Address Register (MBBAR)

/************************************************************

 *	Memory Scrub Control Register (MSCR)

 scrub_mod - bit0:1*/

 01 */

 si - bit8:15*/

/************************************************************

 *	Memory Scrub Range Start Register (MSRSR)

/************************************************************

 *	Memory Scrub Range End Register (MSRER)

/************************************************************

 *	Memory Scrub Pattern Register (MSPR)

/************************************************************

 *	Memory Check Control Register (MCCR)

 ECC high and low check */

/************************************************************

 *	Memory Check Range End Register (MCRER)

/************************************************************

 *	Memory Error Address Register (MEAR)

/************************************************************

 *	Memory Error Syndrome Register (MESR)

/************************************************************

 *	Memory Mode Control Register (MMCR)

/*

 * HyperTransport Link Registers

/************************************************************

 *  Error Handling/Enumeration Scratch Pad Register (ERRCTRL)

 nonfatal interrupts for */

 system error */

 CRC error */

 Response error */

 End-Of-Chain error */

 Overflow error */

 Protocol error */

 Response error received */

 Sync flooding detected */

/************************************************************

 *  Link Configuration and Link Control Register (LINKCTRL)

/************************************************************

 *  Link FreqCap/Error/Freq/Revision ID Register (LINKERR)

 End-Of-Chain error */

 Receive Buffer Overflow */

 Protocol error */

/************************************************************

 *	Bridge Control Register (BRGCTRL)

 SERR on Secondary Bus */

 Secondary Bus Reset */

 Private structure for edac memory controller */

 Private structure for common edac device */

 Get total memory size from Open Firmware DTB */

 not populated */

 256M */

 Single channel */

 four-beat burst of 32 bytes */

 Dual channel */

 four-beat burst of 64 bytes */

 0110, no way to differentiate X8 VS X16 */

 0101 */

 1000 */

 0111 */

 1001 */

 Enable memory controller ECC detection */

 Enable various ECC error exceptions */

 Enable ECC detection */

 Disable memory controller ECC detection */

	/*

	 * WARNING:

	 * We are supposed to clear the ECC error detection bits,

	 * and it will be no problem to do so. However, once they

	 * are cleared here if we want to re-install CPC925 EDAC

	 * module later, setting them up in cpc925_mc_init() will

	 * trigger machine check exception.

	 * Also, it's ok to leave ECC error detection bits enabled,

	 * since they are reset to 1 by default or by boot loader.

/*

 * Revert DDR column/row/bank addresses into page frame number and

 * offset in page.

 *

 * Suppose memory mode is 0x0111(128-bit mode, identical DIMM pairs),

 * physical address(PA) bits to column address(CA) bits mappings are:

 * CA	0   1   2   3   4   5   6   7   8   9   10

 * PA	59  58  57  56  55  54  53  52  51  50  49

 *

 * physical address(PA) bits to bank address(BA) bits mappings are:

 * BA	0   1

 * PA	43  44

 *

 * physical address(PA) bits to row address(RA) bits mappings are:

 * RA	0   1   2   3   4   5   6   7   8   9   10   11   12

 * PA	36  35  34  48  47  46  45  40  41  42  39   38   37

 Revert csrow number */

 Revert column address */

 Revert bank address */

 Revert row address, in 4 steps */

 Check memory controller registers for ECC errors */

 APIEXCP is cleared when read */

 Revert column/row addresses into page frame number, etc */

******************* CPU err device********************************/

 use cached value if available */

		/* We assume that each CPU sits on it's own PI and that

		 * for present CPUs the reg property equals to the PI

 Enable CPU Errors detection */

 Disable CPU Errors detection */

	/*

	 * WARNING:

	 * We are supposed to clear the CPU error detection bits,

	 * and it will be no problem to do so. However, once they

	 * are cleared here if we want to re-install CPC925 EDAC

	 * module later, setting them up in cpc925_cpu_init() will

	 * trigger machine check exception.

	 * Also, it's ok to leave CPU error detection bits enabled,

	 * since they are reset to 1 by default.

 Check for CPU Errors */

 APIEXCP is cleared when read */

******************* HT Link err device****************************/

 Enable HyperTransport Link Error detection */

 Disable HyperTransport Link Error detection */

 Check for HyperTransport Link errors */

 Clear by write 1 */

 Initiate Secondary Bus Reset to clear the chain failure */

/*

 * Add CPU Err detection and HyperTransport Link Err detection

 * as common "edac_device", they have no corresponding device

 * nodes in the Open Firmware DTB and we have to add platform

 * devices for them. Also, they will share the MMIO with that

 * of memory controller.

		/*

		 * Don't have to allocate private structure but

		 * make use of cpc925_devs[] instead.

/*

 * Delete the common "edac_device" for CPU Err Detection

 * and HyperTransport Link Err Detection

 Convert current back-ground scrub rate into byte/sec bandwidth */

 Return 0 for single channel; 1 for dual channel */

	/*

	 * Dual channel only when 128-bit wide physical bus

	 * and 128-bit configuration.

 Setup memory controller registers */

 get this far and it's successful */

	/*

	 * Delete common edac devices before edac mc, because

	 * the former share the MMIO of the latter.

 Only support POLL mode so far */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * GHES/EDAC Linux driver

 *

 * Copyright (c) 2013 by Mauro Carvalho Chehab

 *

 * Red Hat Inc. https://www.redhat.com

 Buffers for the error handling routine */

/*

 * Access to ghes_pvt must be protected by ghes_lock. The spinlock

 * also provides the necessary (implicit) memory barrier for the SMP

 * case to make the pointer visible on another CPU.

/*

 * This driver's representation of the system hardware, as collected

 * from DMI.

 GHES registration mutex */

/*

 * Sync with other, potentially concurrent callers of

 * ghes_edac_report_mem_error(). We don't know what the

 * "inventive" firmware would do.

 "ghes_edac.force_load=1" skips the platform check */

 Memory Device - Type 17 of SMBIOS spec */

 both strings must be non-zero */

 Unknown */

	/*

	 * Actually, we can only detect if the memory has bits for

	 * checksum or not

 Likely, worse case */

 Enlarge the array with additional 16 */

	/*

	 * We can do the locking below because GHES defers error processing

	 * from NMI to IRQ context. Whenever that changes, we'd at least

	 * know.

 Cleans the error report buffer */

 Error type, mapped on e->msg */

 Error address */

 Error grain */

 Memory error location, mapped on e->location */

 All other fields are mapped on e->other_detail */

/*

 * Known systems that are safe to enable this module.

 End */

 Check if safe to enable on this system */

 finish another registration/unregistration instance first */

	/*

	 * We have only one logical memory controller to which all DIMMs belong.

 Check if we've got a bogus BIOS */

			/*

			 * If no src->label, preserve default label assigned

			 * from EDAC core.

 only set on success */

 Not needed anymore */

	/*

	 * Wait for the irq handler being finished.

/*

 * Cavium ThunderX memory controller kernel module

 *

 * This file is subject to the terms and conditions of the GNU General Public

 * License.  See the file "COPYING" in the main directory of this archive

 * for more details.

 *

 * Copyright Cavium, Inc. (C) 2015-2017. All rights reserved.

 *

/*

 * To get an ECC error injected, the following steps are needed:

 * - Setup the ECC injection by writing the appropriate parameters:

 *	echo <bit mask value> > /sys/kernel/debug/<device number>/ecc_mask0

 *	echo <bit mask value> > /sys/kernel/debug/<device number>/ecc_mask2

 *	echo 0x802 > /sys/kernel/debug/<device number>/ecc_parity_test

 * - Do the actual injection:

 *	echo 1 > /sys/kernel/debug/<device number>/inject_ecc

 Trigger the interrupt */

		/*

		 * Flush L1 cachelines to the PoC (L2).

		 * This will cause cacheline eviction to the L2.

		/*

		 * Flush L2 cachelines to the DRAM.

		 * This will cause cacheline eviction to the DRAM

		 * and ECC corruption according to the masks set.

		/*

		 * Invalidate L2 cachelines.

		 * The subsequent load will cause cacheline fetch

		 * from the DRAM and an error interrupt

		/*

		 * Invalidate L1 cachelines.

		 * The subsequent load will cause cacheline fetch

		 * from the L2 and/or DRAM

			/*

			 * Do a load from the previously rigged location

			 * This should generate an error interrupt.

 Clear the interrupt */

---------------------- OCX driver ---------------------------------*/

 This handler is threaded */

---------------------- L2C driver ---------------------------------*/

Should never ever get here

/*

 * Radisys 82600 Embedded chipset Memory Controller kernel module

 * (C) 2005 EADS Astrium

 * This file may be distributed under the terms of the

 * GNU General Public License.

 *

 * Written by Tim Small <tim@buttersideup.com>, based on work by Thayne

 * Harbaugh, Dan Hollis <goemon at anime dot net> and others.

 *

 * $Id: edac_r82600.c,v 1.1.2.6 2005/10/05 00:43:44 dsp_llnl Exp $

 *

 * Written with reference to 82600 High Integration Dual PCI System

 * Controller Data Book:

 * www.radisys.com/files/support_downloads/007-01277-0002.82600DataBook.pdf

 * references to this document given in []

/* Radisys say "The 82600 integrates a main memory SDRAM controller that

 * supports up to four banks of memory. The four banks can support a mix of

 * sizes of 64 bit wide (72 bits with ECC) Synchronous DRAM (SDRAM) DIMMs,

 * each of which can be any size from 16MB to 512MB. Both registered (control

 * signals buffered) and unbuffered DIMM types are supported. Mixing of

 * registered and unbuffered DIMMs as well as mixing of ECC and non-ECC DIMMs

 * is not allowed. The 82600 SDRAM interface operates at the same frequency as

 * the CPU bus, 66MHz, 100MHz or 133MHz."

 Radisys 82600 register addresses - device 0 function 0 - PCI bridge */

#define R82600_DRAMC	0x57	/* Various SDRAM related control bits

				 * all bits are R/W

				 *

				 * 7    SDRAM ISA Hole Enable

				 * 6    Flash Page Mode Enable

				 * 5    ECC Enable: 1=ECC 0=noECC

				 * 4    DRAM DIMM Type: 1=

				 * 3    BIOS Alias Disable

				 * 2    SDRAM BIOS Flash Write Enable

				 * 1:0  SDRAM Refresh Rate: 00=Disabled

				 *          01=7.8usec (256Mbit SDRAMs)

				 *          10=15.6us 11=125usec

#define R82600_SDRAMC	0x76	/* "SDRAM Control Register"

				 * More SDRAM related control bits

				 * all bits are R/W

				 *

				 * 15:8 Reserved.

				 *

				 * 7:5  Special SDRAM Mode Select

				 *

				 * 4    Force ECC

				 *

				 *        1=Drive ECC bits to 0 during

				 *          write cycles (i.e. ECC test mode)

				 *

				 *        0=Normal ECC functioning

				 *

				 * 3    Enhanced Paging Enable

				 *

				 * 2    CAS# Latency 0=3clks 1=2clks

				 *

				 * 1    RAS# to CAS# Delay 0=3 1=2

				 *

				 * 0    RAS# Precharge     0=3 1=2

#define R82600_EAP	0x80	/* ECC Error Address Pointer Register

				 *

				 * 31    Disable Hardware Scrubbing (RW)

				 *        0=Scrub on corrected read

				 *        1=Don't scrub on corrected read

				 *

				 * 30:12 Error Address Pointer (RO)

				 *        Upper 19 bits of error address

				 *

				 * 11:4  Syndrome Bits (RO)

				 *

				 * 3     BSERR# on multibit error (RW)

				 *        1=enable 0=disable

				 *

				 * 2     NMI on Single Bit Eror (RW)

				 *        1=NMI triggered by SBE n.b. other

				 *          prerequeists

				 *        0=NMI not triggered

				 *

				 * 1     MBE (R/WC)

				 *        read 1=MBE at EAP (see above)

				 *        read 0=no MBE, or SBE occurred first

				 *        write 1=Clear MBE status (must also

				 *          clear SBE)

				 *        write 0=NOP

				 *

				 * 1     SBE (R/WC)

				 *        read 1=SBE at EAP (see above)

				 *        read 0=no SBE, or MBE occurred first

				 *        write 1=Clear SBE status (must also

				 *          clear MBE)

				 *        write 0=NOP

#define R82600_DRBA	0x60	/* + 0x60..0x63 SDRAM Row Boundary Address

				 *  Registers

				 *

				 * 7:0  Address lines 30:24 - upper limit of

				 * each row [p57]

 Clear error to allow next error to be reported [p.62] */

 Clear error to allow next error to be reported [p.62] */

 bits 30:12 store the upper 19 bits of the 32 bit error address */

 Syndrome in bits 11:4 [p.62]       */

	/* the R82600 reports at less than page *

 CE? */

 UE? */

 82600 doesn't give enough info */

 SDRAM Row Boundary Address Register */

 find the DRAM Chip Select Base address and mask */

		row_high_limit = ((u32)drbar << 24) | 0xffffffUL; */

 Empty row [p.57] */

		/* Error address is top 19 bits - so granularity is      *

 FIXME - check that this is unknowable with this chipset */

 Mode is global on 82600 */

	/* FIXME try to work out if the chip leads have been used for COM2

	 * instead on this board? [MA6?] MAYBE:

	/* On the R82600, the pins for memory bits 72:65 - i.e. the   *

	 * EC bits are shared with the pins for COM2 (!), so if COM2  *

	 * is enabled, we assume COM2 is wired up, and thus no EDAC   *

 clear counters */

	/* Here we assume that we will never see multiple instances of this

	 * type of memory controller.  The ID is therefore hardcoded to 0.

 get this far and it's successful */

 allocating generic PCI control info */

 returns count (>= 0), or negative on error */

 don't need to call pci_enable_device() */

 0 terminated list. */

 Ensure that the OPSTATE is set correctly for POLL or NMI */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2017 Texas Instruments Incorporated - https://www.ti.com/

 *

 * Texas Instruments DDR3 ECC error correction and detection driver

 *

 * This program is free software; you can redistribute it and/or modify it

 * under the terms and conditions of the GNU General Public License,

 * version 2, as published by the Free Software Foundation.

 *

 * This program is distributed in the hope it will be useful, but WITHOUT

 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or

 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for

 * more details.

 *

 * You should have received a copy of the GNU General Public License along with

 * this program.  If not, see <http://www.gnu.org/licenses/>.

 EMIF controller registers */

 Bit definitions for EMIF_SDRAM_CONFIG */

 IRQ bit definitions */

 Bit 31 enables ECC and 28 enables RMW */

 Allocate ID number for our EMIF controller */

 Setup memory layout */

 add EMIF ECC error handler */

 Generate an interrupt with each 1b error */

 Enable interrupts */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright 2011-2012 Calxeda, Inc.

/*

 * Intel 82975X Memory Controller kernel module

 * (C) 2007 aCarLab (India) Pvt. Ltd. (http://acarlab.com)

 * (C) 2007 jetzbroadband (http://jetzbroadband.com)

 * This file may be distributed under the terms of the

 * GNU General Public License.

 *

 * Written by Arvind R.

 *   Copied from i82875p_edac.c source:

 PCI_DEVICE_ID_INTEL_82975_0 */

 Intel 82975X register addresses - device 0 function 0 - DRAM Controller */

#define I82975X_EAP		0x58	/* Dram Error Address Pointer (32b)

					 *

					 * 31:7  128 byte cache-line address

					 * 6:1   reserved

					 * 0     0: CH0; 1: CH1

#define I82975X_DERRSYN		0x5c	/* Dram Error SYNdrome (8b)

					 *

					 *  7:0  DRAM ECC Syndrome

#define I82975X_DES		0x5d	/* Dram ERRor DeSTination (8b)

					 * 0h:    Processor Memory Reads

					 * 1h:7h  reserved

					 * More - See Page 65 of Intel DocSheet.

#define I82975X_ERRSTS		0xc8	/* Error Status Register (16b)

					 *

					 * 15:12 reserved

					 * 11    Thermal Sensor Event

					 * 10    reserved

					 *  9    non-DRAM lock error (ndlock)

					 *  8    Refresh Timeout

					 *  7:2  reserved

					 *  1    ECC UE (multibit DRAM error)

					 *  0    ECC CE (singlebit DRAM error)

/* Error Reporting is supported by 3 mechanisms:

  1. DMI SERR generation  ( ERRCMD )

  2. SMI DMI  generation  ( SMICMD )

  3. SCI DMI  generation  ( SCICMD )

NOTE: Only ONE of the three must be enabled

#define I82975X_ERRCMD		0xca	/* Error Command (16b)

					 *

					 * 15:12 reserved

					 * 11    Thermal Sensor Event

					 * 10    reserved

					 *  9    non-DRAM lock error (ndlock)

					 *  8    Refresh Timeout

					 *  7:2  reserved

					 *  1    ECC UE (multibit DRAM error)

					 *  0    ECC CE (singlebit DRAM error)

#define I82975X_SMICMD		0xcc	/* Error Command (16b)

					 *

					 * 15:2  reserved

					 *  1    ECC UE (multibit DRAM error)

					 *  0    ECC CE (singlebit DRAM error)

#define I82975X_SCICMD		0xce	/* Error Command (16b)

					 *

					 * 15:2  reserved

					 *  1    ECC UE (multibit DRAM error)

					 *  0    ECC CE (singlebit DRAM error)

#define I82975X_XEAP	0xfc	/* Extended Dram Error Address Pointer (8b)

					 *

					 * 7:1   reserved

					 * 0     Bit32 of the Dram Error Address

#define I82975X_MCHBAR		0x44	/*

					 *

					 * 31:14 Base Addr of 16K memory-mapped

					 *	configuration space

					 * 13:1  reserved

					 *  0    mem-mapped config space enable

 NOTE: Following addresses have to indexed using MCHBAR offset (44h, 32b) */

 Intel 82975x memory mapped register space */

 fixed 32MiB grain */

#define I82975X_DRB		0x100	/* DRAM Row Boundary (8b x 8)

					 *

					 * 7   set to 1 in highest DRB of

					 *	channel if 4GB in ch.

					 * 6:2 upper boundary of rank in

					 *	32MB grains

					 * 1:0 set to 0

#define I82975X_DRA		0x108	/* DRAM Row Attribute (4b x 8)

					 *  defines the PAGE SIZE to be used

					 *	for the rank

					 *  7    reserved

					 *  6:4  row attr of odd rank, i.e. 1

					 *  3    reserved

					 *  2:0  row attr of even rank, i.e. 0

					 *

					 * 000 = unpopulated

					 * 001 = reserved

					 * 010 = 4KiB

					 * 011 = 8KiB

					 * 100 = 16KiB

					 * others = reserved

#define I82975X_BNKARC	0x10e /* Type of device in each rank - Bank Arch (16b)

					 *

					 * 15:8  reserved

					 * 7:6  Rank 3 architecture

					 * 5:4  Rank 2 architecture

					 * 3:2  Rank 1 architecture

					 * 1:0  Rank 0 architecture

					 *

					 * 00 => 4 banks

					 * 01 => 8 banks

#define I82975X_DRC		0x120 /* DRAM Controller Mode0 (32b)

					 *

					 * 31:30 reserved

					 * 29    init complete

					 * 28:11 reserved, according to Intel

					 *    22:21 number of channels

					 *		00=1 01=2 in 82875

					 *		seems to be ECC mode

					 *		bits in 82975 in Asus

					 *		P5W

					 *	 19:18 Data Integ Mode

					 *		00=none 01=ECC in 82875

					 * 10:8  refresh mode

					 *  7    reserved

					 *  6:4  mode select

					 *  3:2  reserved

					 *  1:0  DRAM type 10=Second Revision

					 *		DDR2 SDRAM

					 *         00, 01, 11 reserved

#define I82975X_DRC_M1	0x124 /* DRAM Controller Mode1 (32b)

					 * 31	0=Standard Address Map

					 *	1=Enhanced Address Map

					 * 30:0	reserved

 the channel is bit 0 of EAP */

 extended eap bit */

static struct pci_dev *mci_pdev;	/* init dev: in case that AGP code has

					 * already registered driver

	/*

	 * This is a mess because there is no atomic way to read all the

	 * registers at once and the registers can transition from CE being

	 * overwritten by UE.

	/*

	 * If the error is the same then we can for both reads then

	 * the first set of reads is valid.  If there is a change then

	 * there is a CE no info and the second set of reads is valid

	 * and should be UE info.

 Return 1 if dual channel mode is active.  Else return 0. */

	/*

	 * We treat interleaved-symmetric configuration as dual-channel - EAP's

	 * bit-0 giving the channel of the error location.

	 *

	 * All other configurations are treated as single channel - the EAP's

	 * bit-0 will resolve ok in symmetric area of mixed

	 * (symmetric/asymmetric) configurations

	/*

	 * 82875 comment:

	 * The dram row boundary (DRB) reg values are boundary address

	 * for each DRAM row with a granularity of 32 or 64MB (single/dual

	 * channel operation).  DRB regs are cumulative; therefore DRB7 will

	 * contain the total memory contained in all rows.

	 *

		/*

		 * Adjust cumul_size w.r.t number of channels

		 *

		/*

		 * Initialise dram labels

		 * index values:

		 *   [0-7] for single-channel; i.e. csrow->nr_channels = 1

		 *   [0-3] for dual-channel; i.e. csrow->nr_channels = 2

 128Byte cache-line resolution */

 ECC is possible on i92975x ONLY with DEV_X8.  */

 I82975x supports only DDR2 */

 only supported */

 #define  i82975x_DEBUG_IOMEM */

	/*

	 * The register meanings are from Intel specs;

	 * (shows 13-5-5-5 for 800-DDR2)

	 * Asus P5W Bios reports 15-5-4-4

	 * What's your religion?

 bits 31:14 used for 16K window */

 assuming only one controller, index thus is 0 */

 clear counters */

 finalize this instance of memory controller with edac core */

 get this far and it's successful */

 returns count (>= 0), or negative on error */

 0 terminated list. */

 Ensure that the OPSTATE is set correctly for POLL or NMI */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2018, The Linux Foundation. All rights reserved.

 Single & double bit syndrome register offsets */

 Error register offsets */

 TRP, DRP interrupt register offsets */

 Mask and shift macros */

 Config registers offsets*/

 Tag RAM, Data RAM interrupt register offsets */

	/*

	 * Configure interrupt enable registers such that Tag, Data RAM related

	 * interrupts are propagated to interrupt controller for servicing

 Clear the error interrupt and counter registers */

 Dump Syndrome registers data for Tag RAM, Data RAM bit errors*/

 Iterate over the banks and look for Tag RAM or Data RAM errors */

 Allocate edac control info */

 Request for ecc irq */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * APM X-Gene SoC EDAC (error detection and correction)

 *

 * Copyright (c) 2015, Applied Micro Circuits Corporation

 * Author: Feng Kan <fkan@apm.com>

 *         Loc Ho <lho@apm.com>

 Global error configuration status registers (CSR) */

 Memory controller error CSR */

 Detect uncorrectable memory error */

 Detected uncorrectable memory error */

 Detect correctable memory error */

 Clear all error registers */

 Detect memory controller error */

	/*

	 * As there is only single bit for enable error and interrupt mask,

	 * we must only enable top level interrupt after all MCUs are

	 * registered. Otherwise, if there is an error and the corresponding

	 * MCU has not registered, the interrupt will never get cleared. To

	 * determine all MCU have registered, we will keep track of active

	 * MCUs and registered MCUs.

 Set registered MCU bit */

 Enable interrupt after all active MCU registered */

 Enable memory controller top level interrupt */

 Enable MCU interrupt and error reporting */

 Disable MCU interrupt */

 Disable memory controller top level interrupt */

 Clear registered MCU bit */

		/*

		 * Dual MCB active - Determine if all 4 active or just MCU0

		 * and MCU2 active

		/*

		 * Single MCB active - Determine if MCU0/MCU1 or just MCU0

		 * active

 Save active MC mask if hasn't set already */

 Ignore non-active MCU */

 Copy over resource value */

 CPU L1/L2 error CSR */

/*

 * Processor Module Domain (PMD) context - Context for a pair of processsors.

 * Each PMD consists of 2 CPUs and a shared L2 cache. Each CPU consists of

 * its own L1 cache.

 Clear any HW errors */

 Clear any HW errors */

 Clear any HW errors */

 Check L2 */

 Clear any HW errors */

 Check if any memory request timed out on L2 cache */

 Check CPU L1 error */

 Check CPU L2 error */

	/*

	 * Enable CPU memory error:

	 *  MEMERR_CPU_ICFESRA, MEMERR_CPU_LSUESRA, and MEMERR_CPU_MMUESRA

 Enable PMD memory error - MEMERR_L2C_L2ECR and L2C_L2RTOCR */

 Configure L2C HW request time out feature if supported */

 Enable PMD error interrupt */

 Two CPUs per a PMD */

 Determine if this PMD is disabled */

 L3 Error device */

/*

 * Version 1 of the L3 controller has broken single bit correctable logic for

 * certain error syndromes. Log them as uncorrectable in that case.

	/*

	 * NOTE: Address [41:38] in L3C_ELR_PADDRHIGH(l3celr).

	 *       Address [37:6] in l3caelr. Lower 6 bits are zero.

 Clear L3C error interrupt */

 On disable, we just disable interrupt but keep error enabled */

 Enable/disable L3 error top level interrupt */

 Generate all errors */

 SoC error device */

 IO Bus Registers */

 GIC transaction error interrupt */

 IOB memory error */

 If the register bus resource isn't available, just skip it */

	/*

	 * Check RB access errors

	 * 1. Out of range

	 * 2. Un-implemented page

	 * 3. Un-aligned access

	 * 4. Offline slave IP

 IOB Bridge agent transaction error interrupt */

 IOB Processing agent transaction error interrupt */

 IOB AXI0 Error */

 IOB AXI1 Error */

 Enable SoC IP error interrupt */

	/*

	 * NOTE: The register bus resource is optional for compatibility

	 * reason.

 Make sure error reporting method is sane */

/*

 * (C) 2005, 2006 Linux Networx (http://lnxi.com)

 * This file may be distributed under the terms of the

 * GNU General Public License.

 *

 * Written Doug Thompson <norsk5@xmission.com>

 *

 data variables exported via sysfs */

 default NO check PCI parity */

 default NO panic on PCI Parity */

 log PCI parity errors */

 log PCI non-parity error errors */

 one second workq period */

 getter functions for the data variables */

*************************** EDAC PCI sysfs instance *******************/

 DEVICE instance kobject release() function */

 Form pointer to containing struct, the pci control struct */

 decrement reference count on top main kobj */

 Free the control struct */

 instance specific attribute structure */

 Function to 'show' fields from the edac_pci 'instance' structure */

 Function to 'store' fields into the edac_pci 'instance' structure */

 fs_ops table */

 pci instance attributes */

 the ktype for a pci instance */

/*

 * edac_pci_create_instance_kobj

 *

 *	construct one EDAC PCI instance's kobject for use

	/* First bump the ref count on the top main kobj, which will

	 * track the number of PCI instances we have, and thus nest

	 * properly on keeping the module loaded

 And now register this new kobject under the main kobj */

 Error unwind statck */

/*

 * edac_pci_unregister_sysfs_instance_kobj

 *

 *	unregister the kobj for the EDAC PCI instance

	/* Unregister the instance kobject and allow its release

	 * function release the main reference count and then

	 * kfree the memory

**************************** EDAC PCI sysfs root **********************/

 simple show/store functions for attributes */

 Set of show/store abstract level functions for PCI Parity object */

 PCI Parity control files */

 Base Attributes of the memory ECC object */

/*

 * edac_pci_release_main_kobj

 *

 *	This release function is called when the reference count to the

 *	passed kobj goes to zero.

 *

 *	This kobj is the 'main' kobject that EDAC PCI instances

 *	link to, and thus provide for proper nesting counts

	/* last reference to top EDAC PCI kobject has been removed,

	 * NOW release our ref count on the core module

 ktype struct for the EDAC PCI main kobj */

/**

 * edac_pci_main_kobj_setup: Setup the sysfs for EDAC PCI attributes.

 check and count if we have already created the main kobject */

	/* First time, so create the main kobject and its

	 * controls and attributes

	/* Bump the reference count on this module to ensure the

	 * modules isn't unloaded until we deconstruct the top

	 * level main kobj for EDAC PCI

 Instanstiate the pci object */

	/* At this point, to 'release' the top level kobject

	 * for EDAC PCI, then edac_pci_main_kobj_teardown()

	 * must be used, for resources to be cleaned up properly

 Error unwind statck */

 if are on this error exit, nothing to tear down */

/*

 * edac_pci_main_kobj_teardown()

 *

 *	if no longer linked (needed) remove the top level EDAC PCI

 *	kobject with its controls and attributes

	/* Decrement the count and only if no more controller instances

	 * are connected perform the unregisteration of the top level

	 * main kobj

 create the top main EDAC PCI kobject, IF needed */

 Create this instance's kobject under the MAIN kobject */

 Error unwind stack */

 Remove the symlink */

 remove this PCI instance's sysfs entries */

	/* Call the main unregister function, which will determine

	 * if this 'pci' is the last instance.

	 * If it is, the main kobject will be unregistered as a result

*********************** PCI error handling *************************/

	/* If we get back 0xFFFF then we must suspect that the card has been

	 * pulled but the Linux PCI layer has not yet finished cleaning up.

	 * We don't want to report on such devices

 reset only the bits we are interested in */

 Clear any PCI parity errors logged by this device. */

 read the device TYPE, looking for bridges */

/*

 *  PCI Parity polling

 *

 *	Function to retrieve the current parity status

 *	and decode it

 *

 stop any interrupts until we can acquire the status */

 read the STATUS register on this device */

 read the device TYPE, looking for bridges */

	/* check the status reg for errors on boards NOT marked as broken

	 * if broken, we cannot trust any of the status bits

 On bridges, need to examine secondary status register  */

		/* check the secondary status reg for errors,

		 * on NOT broken boards

 reduce some complexity in definition of the iterator */

/*

 * pci_dev parity list iterator

 *

 *	Scan the PCI device list looking for SERRORs, Master Parity ERRORS or

 *	Parity ERRORs on primary or secondary devices.

/*

 * edac_pci_do_parity_check

 *

 *	performs the actual PCI parity check operation

 if policy has PCI check off, leave now */

	/* scan all PCI devices looking for a Parity Error on devices and

	 * bridges.

	 * The iterator calls pci_get_device() which might sleep, thus

	 * we cannot disable interrupts in this scan.

 Only if operator has selected panic on PCI Error */

 If the count is different 'after' from 'before' */

/*

 * edac_pci_clear_parity_errors

 *

 *	function to perform an iteration over the PCI devices

 *	and clearn their current status

	/* Clear any PCI bus parity errors that devices initially have logged

	 * in their registers.

/*

 * edac_pci_handle_pe

 *

 *	Called to handle a PARITY ERROR event

 global PE counter incremented by edac_pci_do_parity_check() */

	/*

	 * poke all PCI devices and see which one is the troublemaker

	 * panic() is called if set

/*

 * edac_pci_handle_npe

 *

 *	Called to handle a NON-PARITY ERROR event

 global NPE counter incremented by edac_pci_do_parity_check() */

	/*

	 * poke all PCI devices and see which one is the troublemaker

	 * panic() is called if set

/*

 * Define the PCI parameter to the module

/*

 * Intel 82443BX/GX (440BX/GX chipset) Memory Controller EDAC kernel

 * module (C) 2006 Tim Small

 *

 * This file may be distributed under the terms of the GNU General

 * Public License.

 *

 * Written by Tim Small <tim@buttersideup.com>, based on work by Linux

 * Networx, Thayne Harbaugh, Dan Hollis <goemon at anime dot net> and

 * others.

 *

 * 440GX fix by Jason Uhlenkott <juhlenko@akamai.com>.

 *

 * Written with reference to 82443BX Host Bridge Datasheet:

 * http://download.intel.com/design/chipsets/datashts/29063301.pdf

 * references to this document given in [].

 *

 * This module doesn't support the 440LX, but it may be possible to

 * make it do so (the 440LX's register definitions are different, but

 * not completely so - I haven't studied them in enough detail to know

 * how easy this would be).

/* The 82443BX supports SDRAM, or EDO (EDO for mobile only), "Memory

 * Size: 8 MB to 512 MB (1GB with Registered DIMMs) with eight memory

 * rows" "The 82443BX supports multiple-bit error detection and

 * single-bit error correction when ECC mode is enabled and

 * single/multi-bit error detection when correction is disabled.

 * During writes to the DRAM, the 82443BX generates ECC for the data

 * on a QWord basis. Partial QWord writes require a read-modify-write

 * cycle when ECC is enabled."

/* "Additionally, the 82443BX ensures that the data is corrected in

 * main memory so that accumulation of errors is prevented. Another

 * error within the same QWord would result in a double-bit error

 * which is unrecoverable. This is known as hardware scrubbing since

 * it requires no software intervention to correct the data in memory."

/* [Also see page 100 (section 4.3), "DRAM Interface"]

 * [Also see page 112 (section 4.6.1.4), ECC]

 82443 PCI Device 0 */

#define I82443BXGX_NBXCFG 0x50	/* 32bit register starting at this PCI

#define I82443BXGX_NBXCFG_OFFSET_NON_ECCROW 24	/* Array of bits, zero if

 2 bits,00=100MHz,10=66 MHz */

 2 bits:       */

 00 = Non-ECC */

 01 = EC (only) */

 10 = ECC */

 11 = ECC + HW Scrub */

 82443 PCI Device 0 */

#define I82443BXGX_EAP   0x80	/* 32bit register starting at this PCI

				 * config space offset, Error Address

 High 20 bits of error address */

 Err at EAP was multi-bit (W1TC) */

 Err at EAP was single-bit (W1TC) */

#define I82443BXGX_ERRCMD  0x90	/* 8bit register starting at this PCI

 1 = enable */

 1 = enable */

#define I82443BXGX_ERRSTS  0x91	/* 16bit register starting at this PCI

 3 bits - first err row multibit */

 1 = MBE occurred */

 3 bits - first err row singlebit */

 1 = SBE occurred */

#define I82443BXGX_DRAMC 0x57	/* 8bit register starting at this PCI

 2 bits, DRAM Type */

 00 = EDO */

 01 = SDRAM */

 10 = Registered SDRAM */

#define I82443BXGX_DRB 0x60	/* 8x 8bit registers starting at this PCI

 FIXME - don't poll when ECC disabled? */

static struct pci_dev *mci_pdev;	/* init dev: in case that AGP code has

					 * already registered driver

 Clear error to allow next error to be reported [p.61] */

 Clear error to allow next error to be reported [p.61] */

	/* bits 30:12 hold the 4kb block in which the error occurred

 find the DRAM Chip Select Base address and mask */

 440GX goes to 2GB, represented with a DRB of 0. */

 This row is empty [p.49] */

 EAP reports in 4kilobyte granularity [61] */

 I don't think 440BX can tell you device type? FIXME? */

 Mode is global to all rows on 440BX */

	/* Something is really hosed if PCI config space reads from

	 * the MC aren't working.

	/* Many BIOSes don't clear error flags on boot, so do this

	 * here, or we get "phantom" errors occurring at module-load

 allocating generic PCI control info */

 returns count (>= 0), or negative on error */

 don't need to call pci_enable_device() */

 0 terminated list. */

 Ensure that the OPSTATE is set correctly for POLL or NMI */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2006-2007 PA Semi, Inc

 *

 * Author: Egor Martovetsky <egor@pasemi.com>

 * Maintained by: Olof Johansson <olof@lixom.net>

 *

 * Driver for the PWRficient onchip memory controllers

 uncorrectable/multi-bit errors */

 correctable/single-bit errors */

	/*

	 * We should think about enabling other error detection later on

	/*

	 * Clear status

 get this far and it's successful */

 Ensure that the OPSTATE is set correctly for POLL or NMI */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * amd8131_edac.c, AMD8131 hypertransport chip EDAC kernel module

 *

 * Copyright (c) 2008 Wind River Systems, Inc.

 *

 * Authors:	Cao Qingtao <qingtao.cao@windriver.com>

 * 		Benjamin Walsh <benjamin.walsh@windriver.com>

 * 		Hu Yongqi <yongqi.hu@windriver.com>

 Wrapper functions for accessing PCI configuration space */

 Support up to two AMD8131 chipsets on a platform */

 First clear error detection flags */

 Clear Discard Timer Timedout flag */

 Clear CRC Error flag on link side A */

 Clear CRC Error flag on link side B */

	/*

	 * Then enable all error detections.

	 *

	 * Setup Discard Timer Sync Flood Enable,

	 * System Error Enable and Parity Error Enable.

 Enable overall SERR Error detection */

 Setup CRC Flood Enable for link side A */

 Setup CRC Flood Enable for link side B */

 Disable SERR, PERR and DTSE Error detection */

 Disable overall System Error detection */

 Disable CRC Sync Flood on link side A */

 Disable CRC Sync Flood on link side B */

 Check PCI-X Bridge Memory Base-Limit Register for errors */

 Check if Discard Timer timed out */

 Check if CRC error happens on link side A */

 Check if CRC error happens on link side B */

/*

 * There are 4 PCIX Bridges on ATCA-6101 that share the same PCI Device ID,

 * so amd8131_probe() would be called by kernel 4 times, with different

 * address of pci_dev for each of them each time.

 should never happen */

	/*

	 * We can't call pci_get_device() as we are used to do because

	 * there are 4 of them but pci_dev_get() instead.

	/*

	 * we do not allocate extra private structure for

	 * edac_pci_ctl_info, but make use of existing

	 * one instead.

 should never happen */

 table is NULL-terminated */

 Only POLL mode supported so far */

 SPDX-License-Identifier: GPL-2.0

/*

 * SiFive Platform EDAC Driver

 *

 * Copyright (C) 2018-2019 SiFive, Inc.

 *

 * This driver is partially based on octeon_edac-pc.c

 *

/**

 * EDAC error callback

 *

 * @event: non-zero if unrecoverable.

/*

 * Intel 5400 class Memory Controllers kernel module (Seaburg)

 *

 * This file may be distributed under the terms of the

 * GNU General Public License.

 *

 * Copyright (c) 2008 by:

 *	 Ben Woodard <woodard@redhat.com>

 *	 Mauro Carvalho Chehab

 *

 * Red Hat Inc. https://www.redhat.com

 *

 * Forked and adapted from the i5000_edac driver which was

 * written by Douglas Thompson Linux Networx <norsk5@xmission.com>

 *

 * This module is based on the following document:

 *

 * Intel 5400 Chipset Memory Controller Hub (MCH) - Datasheet

 * 	http://developer.intel.com/design/chipsets/datashts/313070.htm

 *

 * This Memory Controller manages DDR2 FB-DIMMs. It has 2 branches, each with

 * 2 channels operating in lockstep no-mirror mode. Each channel can have up to

 * 4 dimm's, each with up to 8GB.

 *

/*

 * Alter this version for the I5400 module when modifications are made

 Limits for i5400 */

/* Device 16,

 * Function 0: System Address

 * Function 1: Memory Branch Map, Control, Errors Register

 * Function 2: FSB Error Registers

 *

 * All 3 functions of Device 16 (0,1,2) share the SAME DID and

 * uses PCI_DEVICE_ID_INTEL_5400_ERR for device 16 (0,1,2),

 * PCI_DEVICE_ID_INTEL_5400_FBD0 and PCI_DEVICE_ID_INTEL_5400_FBD1

 * for device 21 (0,1).

 OFFSETS for Function 0 */

 AMB Mem Mapped Reg Region Base */

 Max Channel Number */

 Max DIMM PER Channel Number */

 OFFSETS for Function 1 */

 bits [17:9] indicate ODD, [8:0]  indicate EVEN */

 Fatal error registers */

 also called as FERR_FAT_FB_DIMM at datasheet */

 channel index where the highest-order error occurred */

 also called as FERR_NFAT_FB_DIMM at datasheet */

 Non-fatal error register */

 Enable error mask */

 No OFFSETS for Device 16 Function 2 */

/*

 * Device 21,

 * Function 0: Memory Map Branch 0

 *

 * Device 22,

 * Function 0: Memory Map Branch 1

 OFFSETS for Function 0 */

 OFFSETS for Function 1 */

/*

 * Error indicator bits and masks

 * Error masks are according with Table 5-17 of i5400 datasheet

 Memory Write error on non-redundant retry */

 Memory or FB-DIMM configuration CRC read error */

 Reserved */

 Uncorrectable Data ECC on Replay */

 Aliased Uncorrectable Non-Mirrored Demand Data ECC */

 Unsupported on i5400 */

 Aliased Uncorrectable Resilver- or Spare-Copy Data ECC */

 Aliased Uncorrectable Patrol Data ECC */

 Non-Aliased Uncorrectable Non-Mirrored Demand Data ECC */

 Unsupported on i5400 */

 Non-Aliased Uncorrectable Resilver- or Spare-Copy Data ECC  */

 Non-Aliased Uncorrectable Patrol Data ECC */

 Memory Write error on first attempt */

 FB-DIMM Configuration Write error on first attempt */

 Memory or FB-DIMM configuration CRC read error */

 Channel Failed-Over Occurred */

 Correctable Non-Mirrored Demand Data ECC */

 Unsupported on i5400 */

 Correctable Resilver- or Spare-Copy Data ECC */

 Correctable Patrol Data ECC */

 FB-DIMM Northbound parity error on FB-DIMM Sync Status */

 SPD protocol Error */

 Non-Redundant Fast Reset Timeout */

 Refresh error */

 Memory Write error on redundant retry */

 Redundant Fast Reset Timeout */

 Correctable Counter Threshold Exceeded */

 DIMM-Spare Copy Completed */

 DIMM-Isolation Completed */

/*

 * Names to translate bit error into something useful

 Reserved */

 M6 Unsupported on i5400 */

 M10 Unsupported on i5400 */

 M18 Unsupported on i5400 */

 Fatal errors */

 Correctable errors */

 Recoverable errors */

 uncorrectable errors */

 mask to all non-fatal errors */

/*

 * Define error masks for the several registers

 Enable all fatal and non fatal errors */

 mask for fatal error registers */

 masks for non-fatal error register */

 Bit 28 */

 Bits 0 to 27 */

/* Defines to extract the vaious fields from the

 *	MTRx - Memory Technology Registers

 This applies to FERR_NF_FB-DIMM as well as FERR_FAT_FB-DIMM */

 Device name and register DID (Device ID) */

 name for this device */

 DID for the branchmap,control */

 Table of devices attributes supported by this driver */

 size, 0 means not present  */

 driver private data structure */

 16.0 */

 16.1 */

 16.2 */

 21.0 */

 22.0 */

 top of low memory */

 AMB BAR */

 Memory Technlogy Reg */

 Branch 0, Channel 0 */

 Brnach 0, Channel 1 */

 Memory Technlogy Reg */

 Branch 1, Channel 8 */

 Branch 1, Channel 1 */

 DIMM information matrix, allocating architecture maximums */

 Actual values for this controller */

 Max channels */

 Max DIMMs per channel */

 I5400 MCH error information retrieved from Hardware */

 These registers are always read from the MC */

 First Errors Fatal */

 Next Errors Fatal */

 First Errors Non-Fatal */

 Next Errors Non-Fatal */

 These registers are input ONLY if there was a Recoverable Error */

 Recoverable Mem Data Error log B */

 Recoverable Mem Error log A */

 Recoverable Mem Error log B */

 These registers are input ONLY if there was a Non-Rec Error */

 Non-Recoverable Mem log A */

 Non-Recoverable Mem log B */

/* note that nrec_rdwr changed from NRECMEMA to NRECMEMB between the 5000 and

/* This applies to both NREC and REC string so it can be used with nrec_rdwr

/*

 *	i5400_get_error_info	Retrieve the hardware error information from

 *				the hardware and cache it in the 'info'

 *				structure

 read in the 1st FATAL error register */

	/* Mask only the bits that the doc says are valid

	/* If there is an error, then read in the

	   NEXT FATAL error register and the Memory Error Log Register A

 harvest the various error data we need */

 Clear the error bits, by writing them back */

 read in the 1st NON-FATAL error register */

	/* If there is an error, then read in the 1st NON-FATAL error

 harvest the various error data we need */

 Clear the error bits, by writing them back */

/*

 * i5400_proccess_non_recoverable_info(struct mem_ctl_info *mci,

 * 					struct i5400_error_info *info,

 * 					int handle_errors);

 *

 *	handle the Intel FATAL and unrecoverable errors, if any

 if no error, return now */

 ONLY ONE of the possible error bits will be set, as per the docs */

 Use the NON-Recoverable macros to extract data */

 Only 1 bit will be on */

 Form out message */

/*

 * i5400_process_fatal_error_info(struct mem_ctl_info *mci,

 * 				struct i5400_error_info *info,

 * 				int handle_errors);

 *

 *	handle the Intel NON-FATAL errors, if any

 mask off the Error bits that are possible */

 if no error, return now */

 ONLY ONE of the possible error bits will be set, as per the docs */

 Correctable errors */

		/* Convert channel to be based from zero, instead of

 Only 1 bit will be on */

 Form out message */

 Miscellaneous errors */

/*

 *	i5400_process_error_info	Process the error info that is

 *	in the 'info' structure, previously retrieved from hardware

 First handle any fatal errors that occurred */

 now handle any non-fatal errors that occurred */

/*

 *	i5400_clear_error	Retrieve any error from the hardware

 *				but do NOT process that error.

 *				Used for 'clearing' out of previous errors

 *				Called by the Core module.

/*

 *	i5400_check_error	Retrieve and process errors reported by the

 *				hardware. Called by the Core module.

/*

 *	i5400_put_devices	'put' all the devices that we have

 *				reserved via 'get'

 Decrement usage count for devices */

/*

 *	i5400_get_devices	Find and perform 'get' operation on the MCH's

 *			device/functions we want to reference for this driver

 *

 *			Need to 'get' device 16 func 1 and func 2

 Attempt to 'get' the MCH register we want */

 End of list, leave */

 Store device 16 func 1 */

 End of list, leave */

 Store device 16 func 2 */

	/* If this device claims to have more than 2 channels then

	 * fetch Branch 1's information

/*

 *	determine_amb_present

 *

 *		the information is contained in DIMMS_PER_CHANNEL different

 *		registers determining which of the DIMMS_PER_CHANNEL requires

 *              knowing which channel is in question

 *

 *	2 branches, each with 2 channels

 *		b0_ambpresent0 for channel '0'

 *		b0_ambpresent1 for channel '1'

 *		b1_ambpresent0 for channel '2'

 *		b1_ambpresent1 for channel '3'

/*

 * determine_mtr(pvt, dimm, channel)

 *

 * return the proper MTR register as determine by the dimm and desired channel

	/* There is one MTR for each slot pair of FB-DIMMs,

	   Each slot pair may be at branch 0 or branch 1.

/*

 Determine if there is a DIMM present in this DIMM slot */

			/* Start with the number of bits for a Bank

 Add thenumber of ROW bits */

 add the number of COLUMN bits */

 add the number of RANK bits */

 add 64 bits per DIMM */

 divide by 2^^20 */

 8 bits per bytes */

/*

 *	calculate_dimm_size

 *

 *	also will output a DIMM matrix map, if debug is enabled, for viewing

 *	how the DIMMs are populated

 ================= Generate some debug output ================= */

	/* Scan all the actual DIMMS

	 * and calculate the information for each DIMM

	 * Start with the highest dimm first, to display it first

	 * and work toward the 0th dimm

		/* on an odd dimm, first output a 'boundary' marker,

 Output the last bottom 'boundary' marker */

 now output the 'channel' labels */

 output the last message and free buffer */

/*

 *	i5400_get_mc_regs	read in the necessary registers and

 *				cache locally

 *

 *			Fills in the private data members

 Get the Branch Map regs */

 Get the MIR[0-1] regs */

 Get the set of MTR[0-3] regs by each branch */

 Branch 0 set of MTR registers */

 Branch 1 set of MTR registers */

 Read and dump branch 0's MTRs */

 Only if we have 2 branchs (4 channels) */

 Read and dump  branch 1's MTRs */

	/* Go and determine the size of each DIMM and place in an

/*

 *	i5400_init_dimms	Initialize the 'dimms' table within

 *				the mci control	structure with the

 *				addressing of memory.

 *

 *	return:

 *		0	success

 *		1	no actual memory found on this MC

	/*

	 * FIXME: remove  pvt->dimm_info[slot][channel] and use the 3

	 * layers here.

 if no DIMMS on this slot, continue */

			/*

			 * The eccc mechanism is SDDC (aka SECC), with

			 * is similar to Chipkill.

	/*

	 * When just one memory is provided, it should be at location (0,0,0).

	 * With such single-DIMM mode, the SDCC algorithm degrades to SECDEC+.

/*

 *	i5400_enable_error_reporting

 *			Turn on the memory reporting features of the hardware

 Read the FBD Error Mask Register */

 Enable with a '0' */

/*

 *	i5400_probe1	Probe for ONE instance of device to see if it is

 *			present.

 *	return:

 *		0 for FOUND a device

 *		< 0 for error code

 We only are looking for func 0 of the set */

	/*

	 * allocate a new MC control structure

	 *

	 * This drivers uses the DIMM slot as "csrow" and the rest as "channel".

 record ptr  to the generic device */

 Record this device in our private */

 'get' the pci devices we want to reserve for our use */

 Time to get serious */

 retrieve the hardware registers */

 Set the function pointer to an actual operation function */

	/* initialize the MC control structure 'dimms' table

 no dimms found */

 add this new MC control structure to EDAC's list of MCs */

		/* FIXME: perhaps some code should go here that disables error

		 * reporting if we just enabled it

 allocating generic PCI control info */

 Error exit unwinding stack */

/*

 *	i5400_init_one	constructor for one instance of device

 *

 * 	returns:

 *		negative on error

 *		count (>= 0)

 wake up device */

 now probe and enable the device */

/*

 *	i5400_remove_one	destructor for one instance of device

 *

 retrieve references to resources, and free those resources */

/*

 *	pci_device_id	table for which devices we are looking for

 *

 *	The "E500P" device is the first device supported.

 0 terminated list. */

/*

 *	i5400_driver	pci_driver structure for this module

 *

/*

 *	i5400_init		Module entry function

 *			Try to initialize this module for its devices

 Ensure that the OPSTATE is set correctly for POLL or NMI */

/*

 *	i5400_exit()	Module exit function

 *			Unregister the driver

www.redhat.com)");

 SPDX-License-Identifier: GPL-2.0

/*

 * Bluefield-specific EDAC driver.

 *

 * Copyright (c) 2019 Mellanox Technologies.

/*

 * Mellanox BlueField EMI (External Memory Interface) register definitions.

/*

 * Request MLNX_SIP_GET_DIMM_INFO

 *

 * Retrieve information about DIMM on a certain slot.

 *

 * Call register usage:

 * a0: MLNX_SIP_GET_DIMM_INFO

 * a1: (Memory controller index) << 16 | (Dimm index in memory controller)

 * a2-7: not used.

 *

 * Return status:

 * a0: MLXBF_DIMM_INFO defined below describing the DIMM.

 * a1-3: not used.

 Format for the SMC response about the memory information */

/*

 * Gather the ECC information from the External Memory Interface registers

 * and report it to the edac handler.

	/*

	 * Tell the External Memory Interface to populate the relevant

	 * registers with information about the last ECC error occurrence.

	/*

	 * Verify that the ECC reported info in the registers is of the

	 * same type as the one asked to report. If not, just report the

	 * error without the detailed information.

	/*

	 * The memory controller might not be initialized by the firmware

	 * when there isn't memory, which may lead to bad register readings.

 Write to clear reported errors. */

 Initialize the DIMMs information for the given memory controller. */

 Mem controller for BlueField only supports x4, x8 and x16 */

 Read the MSS (Memory SubSystem) index from ACPI table. */

 Read the DIMMs per MC from ACPI table. */

 Initialize mci with the actual populated DIMM information. */

 Register with EDAC core */

 Only POLL mode supported so far. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * amd8111_edac.c, AMD8111 Hyper Transport chip EDAC kernel module

 *

 * Copyright (c) 2008 Wind River Systems, Inc.

 *

 * Authors:	Cao Qingtao <qingtao.cao@windriver.com>

 * 		Benjamin Walsh <benjamin.walsh@windriver.com>

 * 		Hu Yongqi <yongqi.hu@windriver.com>

 Wrapper functions for accessing PCI configuration space */

/*

 * device-specific methods for amd8111 PCI Bridge Controller

 *

 * Error Reporting and Handling for amd8111 chipset could be found

 * in its datasheet 3.1.2 section, P37

 First clear error detection flags on the host interface */

 Clear SSE/SMA/STA flags in the global status register*/

 Clear CRC and Link Fail flags in HT Link Control reg */

 Second clear all fault on the secondary interface */

 Clear error flags in the memory-base limit reg. */

 Clear Discard Timer Expired flag in Interrupt/Bridge Control reg */

 Last enable error detections */

 Enable System Error reporting in global status register */

 Enable CRC Sync flood packets to HyperTransport Link */

 Enable SSE reporting etc in Interrupt control reg */

 Disable System Error reporting */

 Disable CRC flood packets */

 Disable DTSERREN/MARSP/SERREN in Interrupt Control reg */

 Check out PCI Bridge Status and Command Register */

 Check out HyperTransport Link Control Register */

 Check out PCI Interrupt and Bridge Control Register */

 Check out PCI Bridge Memory Base-Limit Register */

 device-specific methods for amd8111 LPC Bridge device */

 First clear REG_AT_COMPAT[SERR, IOCHK] if necessary */

 buggy port */

 Second clear error flags on LPC bridge */

 General devices represented by edac_device_ctl_info */

 PCI controllers represented by edac_pci_ctl_info */

	/*

	 * we do not allocate extra private structure for

	 * edac_device_ctl_info, but make use of existing

	 * one instead.

 should never happen */

	/*

	 * we do not allocate extra private structure for

	 * edac_pci_ctl_info, but make use of existing

	 * one instead.

 should never happen */

 PCI Device ID talbe for general EDAC device */

 table is NULL-terminated */

 PCI Device ID table for EDAC PCI controller */

 table is NULL-terminated */

 Only POLL mode supported so far */

 SPDX-License-Identifier: GPL-2.0

/*

 * EDAC driver for DMC-520 memory controller.

 *

 * The driver supports 10 interrupt lines,

 * though only dram_ecc_errc and dram_ecc_errd are currently handled.

 *

 * Authors:	Rui Zhao <ruizhao@microsoft.com>

 *		Lei Wang <lewan@microsoft.com>

 *		Shiping Ji <shji@microsoft.com>

 DMC-520 registers */

 DMC-520 types, masks and bitfields */

 Driver settings */

/*

 * The max-length message would be: "rank:7 bank:15 row:262143 col:1023".

 * Max length is 34. Using a 40-size buffer is enough.

 the data bus width for the attached memory chips. */

 memory type */

 memory device width */

 The interrupt config */

 The interrupt mappings */

/*

 * The EDAC driver private data.

 * error_lock is to protect concurrent writes to the mci->error_desc through

 * edac_mc_handle_error().

 Each rank's error counter takes one byte. */

 Reset error counters */

 Get the memory data bus width, in number of bytes. */

 Parse the device node */

 Initialize dmc520 edac */

 Clear interrupts, not affecting other unrelated interrupts */

 Reset DRAM CE/UE counters */

 Enable interrupts, not affecting other unrelated interrupts */

 Disable interrupts */

 free irq's */

 end of table */ }

/*

 * file for managing the edac_device subsystem of devices for EDAC

 *

 * (C) 2007 SoftwareBitMaker

 *

 * This file may be distributed under the terms of the

 * GNU General Public License.

 *

 * Written Doug Thompson <norsk5@xmission.com>

 *

/*

 * Set of edac_device_ctl_info attribute store/show functions

 'log_ue' */

 if parameter is zero, turn off flag, if non-zero turn on flag */

 'log_ce' */

 if parameter is zero, turn off flag, if non-zero turn on flag */

 'panic_on_ue' */

 if parameter is zero, turn off flag, if non-zero turn on flag */

 'poll_msec' show and store functions*/

	/* get the value and enforce that it is non-zero, must be at least

	 * one millisecond for the delay period, between scans

	 * Then cancel last outstanding delay for the work request

	 * and set a new one.

 edac_device_ctl_info specific attribute structure */

 Function to 'show' fields from the edac_dev 'ctl_info' structure */

 Function to 'store' fields into the edac_dev 'ctl_info' structure */

 edac_dev file operations for an 'ctl_info' */

 Declare the various ctl_info attributes here and their respective ops */

 Base Attributes of the EDAC_DEVICE ECC object */

/*

 * edac_device_ctrl_master_release

 *

 *	called when the reference count for the 'main' kobj

 *	for a edac_device control struct reaches zero

 *

 *	Reference count model:

 *		One 'main' kobject for each control structure allocated.

 *		That main kobj is initially set to one AND

 *		the reference count for the EDAC 'core' module is

 *		bumped by one, thus added 'keep in memory' dependency.

 *

 *		Each new internal kobj (in instances and blocks) then

 *		bumps the 'main' kobject.

 *

 *		When they are released their release functions decrement

 *		the 'main' kobj.

 *

 *		When the main kobj reaches zero (0) then THIS function

 *		is called which then decrements the EDAC 'core' module.

 *		When the module reference count reaches zero then the

 *		module no longer has dependency on keeping the release

 *		function code in memory and module can be unloaded.

 *

 *		This will support several control objects as well, each

 *		with its own 'main' kobj.

 decrement the EDAC CORE module ref count */

	/* free the control struct containing the 'main' kobj

	 * passed in to this routine

 ktype for the main (master) kobject */

/*

 * edac_device_register_sysfs_main_kobj

 *

 *	perform the high level setup for the new edac_device instance

 *

 * Return:  0 SUCCESS

 *         !0 FAILURE

 get the /sys/devices/system/edac reference */

 Point to the 'edac_subsys' this instance 'reports' to */

 Init the devices's kobject */

	/* Record which module 'owns' this control structure

	 * and bump the ref count of the module

 register */

	/* At this point, to 'free' the control struct,

	 * edac_device_unregister_sysfs_main_kobj() must be used

 Error exit stack */

/*

 * edac_device_unregister_sysfs_main_kobj:

 *	the '..../edac/<name>' kobject

	/*

	 * Unregister the edac device's kobject and

	 * allow for reference count to reach 0 at which point

	 * the callback will be called to:

	 *   a) module_put() this module

	 *   b) 'kfree' the memory

 edac_dev -> instance information */

/*

 * Set of low-level instance attribute show functions

 DEVICE instance kobject release() function */

	/* map from this kobj to the main control struct

	 * and then dec the main kobj count

 instance specific attribute structure */

 Function to 'show' fields from the edac_dev 'instance' structure */

 Function to 'store' fields into the edac_dev 'instance' structure */

 edac_dev file operations for an 'instance' */

/*

 * Define attributes visible for the edac_device instance object

 *	Each contains a pointer to a show and an optional set

 *	function pointer that does the low level output/input

 list of edac_dev 'instance' attributes */

 The 'ktype' for each edac_dev 'instance' */

 edac_dev -> instance -> block information */

/*

 * Set of low-level block attribute show functions

 DEVICE block kobject release() function */

 get the container of the kobj */

	/* map from 'block kobj' to 'block->instance->controller->main_kobj'

	 * now 'release' the block kobject

 Function to 'show' fields from the edac_dev 'block' structure */

 Function to 'store' fields into the edac_dev 'block' structure */

 edac_dev file operations for a 'block' */

 list of edac_dev 'block' attributes */

 The 'ktype' for each edac_dev 'block' */

 block ctor/dtor  code */

/*

 * edac_device_create_block

 init this block's kobject */

	/* bump the main kobject's reference count for this controller

	 * and this instance is dependent on the main

 Add this block's kobject */

	/* If there are driver level block attributes, then added them

	 * to the block kobject

 Create each block_attribute file */

 Error unwind stack */

/*

 * edac_device_delete_block(edac_dev,block);

	/* if this block has 'attributes' then we need to iterate over the list

	 * and 'remove' the attributes on this block

 remove each block_attrib file */

	/* unregister this block's kobject, SEE:

	 *	edac_device_ctrl_block_release() callback operation

 instance ctor/dtor code */

/*

 * edac_device_create_instance

 *	create just one instance of an edac_device 'instance'

 Init the instance's kobject */

	/* bump the main kobject's reference count for this controller

	 * and this instance is dependent on the main

 Formally register this instance's kobject under the edac_device */

 register all blocks of this instance */

 If any fail, remove all previous ones */

 error unwind stack */

/*

 * edac_device_remove_instance

 *	remove an edac_device instance

 unregister all blocks in this instance */

	/* unregister this instance's kobject, SEE:

	 *	edac_device_ctrl_instance_release() for callback operation

/*

 * edac_device_create_instances

 *	create the first level of 'instances' for this device

 *	(ie  'cache' might have 'cache0', 'cache1', 'cache2', etc

 iterate over creation of the instances */

 unwind previous instances on error */

/*

 * edac_device_delete_instances(edac_dev);

 *	unregister all the kobjects of the instances

 iterate over creation of the instances */

 edac_dev sysfs ctor/dtor  code */

/*

 * edac_device_add_main_sysfs_attributes

 *	add some attributes to this instance's main kobject

		/* iterate over the array and create an attribute for each

		 * entry in the list

/*

 * edac_device_remove_main_sysfs_attributes

 *	remove any attributes to this instance's main kobject

	/* if there are main attributes, defined, remove them. First,

	 * point to the start of the array and iterate over it

	 * removing each attribute listed from this device's instance's kobject

/*

 * edac_device_create_sysfs() Constructor

 *

 * accept a created edac_device control structure

 * and 'export' it to sysfs. The 'main' kobj should already have been

 * created. 'instance' and 'block' kobjects should be registered

 * along with any 'block' attributes from the low driver. In addition,

 * the main attributes (if any) are connected to the main kobject of

 * the control structure.

 *

 * Return:

 *	0	Success

 *	!0	Failure

  go create any main attributes callers wants */

	/* create a symlink from the edac device

	 * to the platform 'device' being used for this

	/* Create the first level instance directories

	 * In turn, the nested blocks beneath the instances will

	 * be registered as well

 Error unwind stack */

 remove the sym link */

/*

 * edac_device_remove_sysfs() destructor

 *

 * given an edac_device struct, tear down the kobject resources

 remove any main attributes for this device */

 remove the device sym link */

 walk the instance/block kobject tree, deconstructing it */

/*

 * Cell MIC driver for ECC counting

 *

 * Copyright 2007 Benjamin Herrenschmidt, IBM Corp.

 *                <benh@kernel.crashing.org>

 *

 * This file may be distributed under the terms of the

 * GNU General Public License.

 Address decoding is likely a bit bogus, to dbl check */

 TODO: Decoding of the error address */

 Address decoding is likely a bit bogus, to dbl check */

 TODO: Decoding of the error address */

 The procedure for clearing FIR bits is a bit ... weird */

 sync up */

		/* We "know" that the Cell firmware only creates one entry

		 * in the "memory" nodes. If that changes, this code will

		 * need to be adapted.

 Get channel population */

 Allocate & init EDAC MC data structure */

 Register with EDAC core */

 Sanity check registers data structure */

 SPDX-License-Identifier: GPL-2.0-only

 Create a toplevel dir under EDAC's debugfs hierarchy */

 Create a toplevel dir under EDAC's debugfs hierarchy with parent @parent */

/*

 * Create a file under EDAC's hierarchy or a sub-hierarchy:

 *

 * @name: file name

 * @mode: file permissions

 * @parent: parent dentry. If NULL, it becomes the toplevel EDAC dir

 * @data: private data of caller

 * @fops: file operations of this file

 Wrapper for debugfs_create_x8() */

 Wrapper for debugfs_create_x16() */

 Wrapper for debugfs_create_x32() */

 SPDX-License-Identifier: GPL-2.0

/*

 *

 * Shared code by both skx_edac and i10nm_edac. Originally split out

 * from the skx_edac driver.

 *

 * This file is linked into both skx_edac and i10nm_edac drivers. In

 * order to avoid link errors, this file must be like a pure library

 * without including symbols and defines which would otherwise conflict,

 * when linked once into a module and into a built-in object, at the

 * same time. For example, __this_module symbol references when that

 * file is being linked into a built-in object.

 *

 * Copyright (c) 2018, Intel Corporation.

/*

 * We use the per-socket device @cfg->did to count how many sockets are present,

 * and to detemine which PCI buses are associated with each socket. Allocate

 * and build the full list of all the skx_dev structures that we need here.

	/*

	 * Compute size in 8-byte (2^3) words, then shift to MiB (2^20)

 likely better than this */

 likely better than this */

 Allocate a new MC control structure */

 Associate skx_dev and mci for future usage */

 Record ptr to the generic device */

 Add this new MC control structure to EDAC's list of MCs */

 Remove MC sysfs nodes */

	/*

	 * According to Intel Architecture spec vol 3B,

	 * Table 15-10 "IA32_MCi_Status [15:0] Compound Error Code Encoding"

	 * memory errors should fit one of these masks:

	 *	000f 0000 1mmm cccc (binary)

	 *	000f 0010 1mmm cccc (binary)	[RAM used as cache]

	 * where:

	 *	f = Correction Report Filtering Bit. If 1, subsequent errors

	 *	    won't be shown

	 *	mmm = error type

	 *	cccc = channel

	 * If the mask doesn't match, report an error to the parsing logic

 Call the helper to output message */

 ignore unless this is memory related with an address */

/*

 * This file is subject to the terms and conditions of the GNU General Public

 * License.  See the file "COPYING" in the main directory of this archive

 * for more details.

 *

 * Copyright (C) 2012 Cavium, Inc.

 * Copyright (C) 2009 Wind River Systems,

 *   written by Ralf Baechle <ralf@linux-mips.org>

 Detected parity error */

 Reset  */

 Reset */

 Reset */

 Reset */

 Reset */

 Reset */

/*

 * Intel e752x Memory Controller kernel module

 * (C) 2004 Linux Networx (http://lnxi.com)

 * This file may be distributed under the terms of the

 * GNU General Public License.

 *

 * Implement support for the e7520, E7525, e7320 and i3100 memory controllers.

 *

 * Datasheets:

 *	https://www.intel.in/content/www/in/en/chipsets/e7525-memory-controller-hub-datasheet.html

 *	ftp://download.intel.com/design/intarch/datashts/31345803.pdf

 *

 * Written by Tom Zimmerman

 *

 * Contributors:

 * 	Thayne Harbaugh at realmsys.com (?)

 * 	Wang Zhenyu at intel.com

 * 	Dave Jiang at mvista.com

 *

 PCI_DEVICE_ID_INTEL_7520_0      */

 PCI_DEVICE_ID_INTEL_7520_1_ERR  */

 PCI_DEVICE_ID_INTEL_7525_0      */

 PCI_DEVICE_ID_INTEL_7525_1_ERR  */

 PCI_DEVICE_ID_INTEL_7320_0 */

 PCI_DEVICE_ID_INTEL_7320_1_ERR */

 PCI_DEVICE_ID_INTEL_3100_0 */

 PCI_DEVICE_ID_INTEL_3100_1_ERR */

 number of csrows */

 E752X register addresses - device 0 function 0 */

 Memory Scrub register (16b) */

					/*

					 * 6:5     Scrub Completion Count

					 * 3:2     Scrub Rate (i3100 only)

					 *      01=fast 10=normal

					 * 1:0     Scrub Mode enable

					 *      00=off 10=on

 DRAM row boundary register (8b) */

 DRAM row attribute register (8b) */

					/*

					 * 31:30   Device width row 7

					 *      01=x8 10=x4 11=x8 DDR2

					 * 27:26   Device width row 6

					 * 23:22   Device width row 5

					 * 19:20   Device width row 4

					 * 15:14   Device width row 3

					 * 11:10   Device width row 2

					 *  7:6    Device width row 1

					 *  3:2    Device width row 0

 DRAM controller mode reg (32b) */

 FIXME:IS THIS RIGHT? */

					/*

					 * 22    Number channels 0=1,1=2

					 * 19:18 DRB Granularity 32/64MB

 Dimm mapping register */

 DDR control and status reg (16b) */

					/*

					 * 14:12 1 single A, 2 single B, 3 dual

 DRAM top of low memory reg (16b) */

 DRAM remap base address reg (16b) */

 DRAM remap limit address reg (16b) */

 DRAM remap limit offset reg (16b) */

 E752X register addresses - device 0 function 1 */

 Global first error register (32b) */

 Global next error register (32b) */

 Hub interface first error reg (8b) */

 Hub interface next error reg (8b) */

 Hub interface error mask reg (8b) */

 Hub interface SMI command reg (8b) */

 System buss first error reg (16b) */

 System buss next error reg (16b) */

 System buss error mask reg (16b) */

 System buss SMI command reg (16b) */

 Memory buffer first error reg (8b) */

 Memory buffer next error reg (8b) */

 Memory buffer error mask reg (8b) */

 Memory buffer SMI cmd reg (8b) */

 DRAM first error register (16b) */

 DRAM next error register (16b) */

 DRAM error mask register (8b) */

 DRAM SMI command register (8b) */

 DRAM Retry address register (32b) */

 DRAM first correctable memory */

     error address register (32b) */

					/*

					 * 31    Reserved

					 * 30:2  CE address (64 byte block 34:6

					 * 1     Reserved

					 * 0     HiLoCS

 DRAM first correctable memory */

     error address register (32b) */

					/*

					 * 31    Reserved

					 * 30:2  CE address (64 byte block 34:6)

					 * 1     Reserved

					 * 0     HiLoCS

 DRAM first uncorrectable memory */

     error address register (32b) */

					/*

					 * 31    Reserved

					 * 30:2  CE address (64 byte block 34:6)

					 * 1     Reserved

					 * 0     HiLoCS

 DRAM 1st uncorrectable scrub mem */

     error address register (32b) */

					/*

					 * 31    Reserved

					 * 30:2  CE address (64 byte block 34:6

					 * 1     Reserved

					 * 0     HiLoCS

 DRAM first correctable memory */

     error syndrome register (16b) */

 DRAM second correctable memory */

     error syndrome register (16b) */

 Device Present 1 register (8b) */

 3100 IMCH specific register addresses - device 0 function 1 */

 NSI first error reg (32b) */

 NSI next error reg (32b) */

 NSI SMI command register (32b) */

 NSI error mask register (32b) */

 ICH5R register addresses - device 30 function 0 */

 PCI status register (16b) */

 PCI status secondary reg (16b) */

 PCI bridge control register (16b) */

/*

 * Those chips Support single-rank and dual-rank memories only.

 *

 * On e752x chips, the odd rows are present only on dual-rank memories.

 * Dividing the rank by two will provide the dimm#

 *

 * i3100 MC has a different mapping: it supports only 4 ranks.

 *

 * The mapping is (from 1 to n):

 *	slot	   single-ranked	double-ranked

 *	dimm #1 -> rank #4		NA

 *	dimm #2 -> rank #3		NA

 *	dimm #3 -> rank #2		Ranks 2 and 3

 *	dimm #4 -> rank $1		Ranks 1 and 4

 *

 * FIXME: The current mapping for i3100 considers that it supports up to 8

 *	  ranks/chanel, but datasheet says that the MC supports only 4 ranks.

 3100 only */

 3100 only */

 all but 3100 */

 all but 3100 */

/* Valid scrub rates for the e752x/3100 hardware memory scrubber. We

 * map the scrubbing bandwidth to a hardware register value. The 'set'

 * operation finds the 'matching or higher value'.  Note that scrubbing

 * on the e752x can only be enabled/disabled.  The 3100 supports

 * a normal and fast mode.

 bandwidth consumed by scrubbing in bytes/sec */

 register value for scrub rate */

/* Rate below assumes same performance as i3100 using PC3200 DDR2 in

 * normal mode.  e752x bridges don't support choosing normal or fast mode,

 * so the scrubbing bandwidth value isn't all that important - scrubbing is

 * either on or off.

 Scrubbing Off */

 Scrubbing On */

 End of Table */

/* Fast mode: 2 GByte PC3200 DDR2 scrubbed in 33s = 63161283 bytes/s

 * Normal mode: 125 (32000 / 256) times slower than fast mode.

 Scrubbing Off */

 Normal mode - 32k clocks */

 Fast mode - 256 clocks */

 End of Table */

 convert the addr to 4k page */

 FIXME - check for -1 */

 chip select are bits 14 & 13 */

 test for channel remapping */

 0 = channel A, 1 = channel B */

 e752x mc reads 34:6 of the DRAM linear address */

 convert to 4k address */

 chip select are bits 14 & 13 */

 e752x mc reads 34:6 of the DRAM linear address */

 convert to 4k address */

 chip select are bits 14 & 13 */

 e752x mc reads 34:6 of the DRAM linear address */

 convert the addr to 4k page */

 chip select are bits 14 & 13 */

 9th entry */

			/* If the error is from DRAM Controller OR

			 * we are to report ALL errors, then

			 * report the error

 NSI_FERR/NSI_NERR bit 0, fatal error */

 reserved */

 bit 2, non-fatal */

 reserved */

 reserved */

 bit 5, non-fatal */

 bit 6, non-fatal */

 bit 7, fatal */

 reserved */

 bit 9, non-fatal */

 reserved */

 bit 11, non-fatal */

 bit 12, non-fatal */

 bit 13, non-fatal */

 reserved */

 bit 15, non-fatal */

 reserved */

 reserved */

 reserved */

 bit 19, fatal */

 reserved */

 bit 21, non-fatal */

 reserved */

 bit 23, non-fatal */

 bit 24, non-fatal */

 bit 25, non-fatal */

 bit 26, fatal */

 bit 27, fatal */

 reserved */

 bit 29, non-fatal */

pci_read_config_byte(dev,E752X_HI_FERR,&stat8);

 Error, so process */

pci_read_config_byte(dev,E752X_HI_NERR,&stat8);

 Error, so process */

 Error, so process */

 check for fatal errors */

 check for non-fatal ones */

pci_read_config_dword(dev,E752X_SYSBUS_FERR,&stat32);

 no errors */

 Error, so process */

 Error, so process */

 decode and report errors */

 check first error correctable */

 check next error correctable */

 ignore the reserved bits just in case */

 Program byte/sec bandwidth scrub rate to hardware */

	/* Translate the desired scrub rate to a e752x/3100 register value.

	 * Search for the bandwidth that is equal or greater than the

	 * desired rate and program the cooresponding register value.

 Convert current scrub rate value into byte/sec bandwidth */

 Find the bandwidth matching the memory scrubber configuration */

 Return 1 if dual channel mode is active.  Else return 0. */

/* Remap csrow index numbers if map_type is "reverse"

 DRB granularity 0=64mb, 1=128mb */

 DRAM Data Integrity Mode 0=none, 2=edac */

 128 in dual mode, 64 in single */

	/* The dram row boundary (DRB) reg values are boundary address for

	 * each DRAM row with a granularity of 64 or 128MB (single/dual

	 * channel operation).  DRB regs are cumulative; therefore DRB7 will

	 * contain the total memory contained in all eight rows.

 mem_dev 0=x8, 1=x4 */

 convert a 128 or 64 MiB DRB to a page size. */

 not populated */

		/*

		* if single channel or x8 devices then SECDED

		* if dual channel and x4 then S4ECD4ED

 4KiB - resolution of CELOG */

 only one type supported */

 test if there is a dimm in this slot */

 no dimm in the slot, so flag it as empty */

 there is a dimm in the slot */

			/* test the next value to see if the dimm is double

			 * sided

 the dimm is single sided, so flag as empty */

 this is a double sided dimm to save the next row #*/

 Return 0 on success or 1 on failure. */

/* Setup system bus parity mask register.

 * Sysbus parity supported on:

 * e7320/e7520/e7525 + Xeon

 Allow module parameter override, else see if CPU supports parity */

 Turn off error disable & SMI in case the BIOS turned it on */

 Number of channels 0=1chan,1=2chan */

	/* check to see if device 0 function 1 is enabled; if it isn't, we

	 * assume the BIOS has reserved it for a reason and is expecting

	 * exclusive access, we take care not to violate that assumption and

 FIXME: should check >>12 or 0xf, true for all? */

 Dual channel = 1, Single channel = 0 */

 3100 IMCH supports SECDEC only */

 FIXME - what if different memory types are in different csrows? */

	/* set the map type.  1 = normal, 0 = reversed

	 * Must be set before e752x_init_csrows in case csrow mapping

	 * is reversed.

 the only mode supported */

 load the top of low memory, remap base, and remap limit vars */

	/* Here we assume that we will never see multiple instances of this

	 * type of memory controller.  The ID is therefore hardcoded to 0.

 clear other MCH errors */

 allocating generic PCI control info */

 get this far and it's successful */

 returns count (>= 0), or negative on error */

 wake up and enable device */

 0 terminated list. */

 Ensure that the OPSTATE is set correctly for POLL or NMI */

lnxi.com) Tom Zimmerman\n");

/*

 * Freescale MPC85xx Memory Controller kernel module

 *

 * Parts Copyrighted (c) 2013 by Freescale Semiconductor, Inc.

 *

 * Author: Dave Jiang <djiang@mvista.com>

 *

 * 2006-2007 (c) MontaVista Software, Inc. This file is licensed under

 * the terms of the GNU General Public License version 2. This program

 * is licensed "as is" without any warranty of any kind, whether express

 * or implied.

 *

/*

 * PCI Err defines

*************************** PCI Err device ***************************/

 master aborts can happen during PCI config cycles */

 clear error bits */

 clear error bits */

 reset error capture */

 make sure error reporting method is sane */

 we only need the error registers */

 PCI master abort is expected during config cycles */

 disable master abort reporting */

 clear error bits */

 reset error capture */

		/*

		 * Enable all PCIe error interrupt & error detect except invalid

		 * PEX_CONFIG_ADDR/PEX_CONFIG_DATA access interrupt generation

		 * enable bit and invalid PEX_CONFIG_ADDR/PEX_CONFIG_DATA access

		 * detection enable bit. Because PCIe bus code to initialize and

		 * configure these PCIe devices on booting will use some invalid

		 * PEX_CONFIG_ADDR/PEX_CONFIG_DATA, edac driver prints the much

		 * notice information. So disable this detect to fix ugly print.

 CONFIG_PCI */

*************************** L2 Err device ***************************/

*********************** L2 SYSFS parts ***********************************/

 End of list */

**************************** L2 ops ***********************************/

 clear error detect register */

 we only need the error registers */

 clear the err_dis */

 deprecate the fsl,85.. forms in the future, 2.6.30? */

 deprecate the fsl,85.. forms in the future, 2.6.30? */

 make sure error reporting method is sane */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Set by command line parameter. If BIOS has enabled the ECC, this override is

 * cleared to prevent re-enabling the hardware by this driver.

 Per-node stuff */

 Device for the PCI component */

/*

 * Valid scrub rates for the K8 hardware memory scrubber. We map the scrubbing

 * bandwidth to a valid bit pattern. The 'set' operation finds the 'matching-

 * or higher value'.

 *

 *FIXME: Produce a better mapping/linearisation.

 bit pattern for scrub rate */

 bandwidth consumed (bytes/sec) */

 scrubbing off */

/*

 * Select DCT to which PCI cfg accesses are routed

/*

 *

 * Depending on the family, F2 DCT reads need special handling:

 *

 * K8: has a single DCT only and no address offsets >= 0x100

 *

 * F10h: each DCT has its own set of regs

 *	DCT0 -> F2x040..

 *	DCT1 -> F2x140..

 *

 * F16h: has only 1 DCT

 *

 * F15h: we select which DCT we access using F1x10C[DctCfgSel]

			/*

			 * Note: If ganging is enabled, barring the regs

			 * F2x[1,0]98 and F2x[1,0]9C; reads reads to F2x1xx

			 * return 0. (cf. Section 2.8.1 F10h BKDG)

		/*

		 * F15h: F2x1xx addresses do not map explicitly to DCT1.

		 * We should select which DCT we access using F1x10C[DctCfgSel]

/*

 * Memory scrubber control interface. For K8, memory scrubbing is handled by

 * hardware and can involve L2 cache, dcache as well as the main memory. With

 * F10, this is extended to L3 cache scrubbing on CPU models sporting that

 * functionality.

 *

 * This causes the "units" for the scrubbing speed to vary from 64 byte blocks

 * (dram) over to cache lines. This is nasty, so we will use bandwidth in

 * bytes/sec for the setting.

 *

 * Currently, we only do dram scrubbing. If the scrubbing is done in software on

 * other archs, we might not have access to the caches directly.

	/*

	 * Fam17h supports scrub values between 0x5 and 0x14. Also, the values

	 * are shifted down by 0x5, so scrubval 0x5 is written to the register

	 * as 0x0, scrubval 0x6 as 0x1, etc.

/*

 * Scan the scrub rate mapping table for a close or matching bandwidth value to

 * issue. If requested is too big, then use last maximum value found.

	/*

	 * map the configured rate (new_bw) to a value specific to the AMD64

	 * memory controller and apply to register. Search for the first

	 * bandwidth entry that is greater or equal than the setting requested

	 * and program that. If at last entry, turn off DRAM scrubbing.

	 *

	 * If no suitable bandwidth is found, turn off DRAM scrubbing entirely

	 * by falling back to the last element in scrubrates[].

		/*

		 * skip scrub rates which aren't recommended

		 * (see F10 BKDG, F3x58)

 Erratum #505 */

 Erratum #505 */

/*

 * returns true if the SysAddr given by sys_addr matches the

 * DRAM base/limit associated with node_id

	/* The K8 treats this as a 40-bit value.  However, bits 63-40 will be

	 * all ones if the most significant implemented address bit is 1.

	 * Here we discard bits 63-40.  See section 3.4.2 of AMD publication

	 * 24592: AMD x86-64 Architecture Programmer's Manual Volume 1

	 * Application Programming.

/*

 * Attempt to map a SysAddr to a node. On success, return a pointer to the

 * mem_ctl_info structure for the node that the SysAddr maps to.

 *

 * On failure, return NULL.

	/*

	 * Here we use the DRAM Base (section 3.4.4.1) and DRAM Limit (section

	 * 3.4.4.2) registers to map the SysAddr to a node ID.

	/*

	 * The value of this field should be the same for all DRAM Base

	 * registers.  Therefore we arbitrarily choose to read it from the

	 * register for node 0.

 intlv_sel field matches */

 sanity test for sys_addr */

/*

 * compute the CS base address of the @csrow on the DRAM controller @dct.

 * For details see F2x[5C:40] in the processor's BKDG

	/*

	 * F16h and F15h, models 30h and later need two addr_shift values:

	 * 8 for high and 6 for low (cf. F16h BKDG).

 poke holes for the csmask */

 poke holes for the csmask */

 OR them in */

/*

 * @input_addr is an InputAddr associated with the node given by mci. Return the

 * csrow that input_addr maps to, or -1 on failure (no csrow claims input_addr).

/*

 * Obtain info from the DRAM Hole Address Register (section 3.4.8, pub #26094)

 * for the node represented by mci. Info is passed back in *hole_base,

 * *hole_offset, and *hole_size.  Function returns 0 if info is valid or 1 if

 * info is invalid. Info may be invalid for either of the following reasons:

 *

 * - The revision of the node is not E or greater.  In this case, the DRAM Hole

 *   Address Register does not exist.

 *

 * - The DramHoleValid bit is cleared in the DRAM Hole Address Register,

 *   indicating that its contents are not valid.

 *

 * The values passed back in *hole_base, *hole_offset, and *hole_size are

 * complete 32-bit values despite the fact that the bitfields in the DHAR

 * only represent bits 31-24 of the base and offset values.

 only revE and later have the DRAM Hole Address Register */

 valid for Fam10h and above */

 This node has Memory Hoisting */

	/* +------------------+--------------------+--------------------+-----

	 * | memory           | DRAM hole          | relocated          |

	 * | [0, (x - 1)]     | [x, 0xffffffff]    | addresses from     |

	 * |                  |                    | DRAM hole          |

	 * |                  |                    | [0x100000000,      |

	 * |                  |                    |  (0x100000000+     |

	 * |                  |                    |   (0xffffffff-x))] |

	 * +------------------+--------------------+--------------------+-----

	 *

	 * Above is a diagram of physical memory showing the DRAM hole and the

	 * relocated addresses from the DRAM hole.  As shown, the DRAM hole

	 * starts at address x (the base address) and extends through address

	 * 0xffffffff.  The DRAM Hole Address Register (DHAR) relocates the

	 * addresses in the hole so that they start at 0x100000000.

/*

 * update NUM_DBG_ATTRS in case you add new members

/*

 * store error injection section value which refers to one of 4 16-byte sections

 * within a 64-byte cacheline

 *

 * range: 0..3

/*

 * store error injection word value which refers to one of 9 16-bit word of the

 * 16-byte (128-bit + ECC bits) section

 *

 * range: 0..8

/*

 * store 16 bit error injection vector which enables injecting errors to the

 * corresponding bit within the error injection word above. When used during a

 * DRAM ECC read, it holds the contents of the of the DRAM ECC bits.

/*

 * Do a DRAM ECC read. Assemble staged values in the pvt area, format into

 * fields needed by the injection registers and read the NB Array Data Port.

 Form value to choose 16-byte section of cacheline */

 Issue 'word' and 'bit' along with the READ request */

/*

 * Do a DRAM ECC write. Assemble staged values in the pvt area and format into

 * fields needed by the injection registers.

 Form value to choose 16-byte section of cacheline */

 Issue 'word' and 'bit' along with the READ request */

 wait until injection happens */

/*

 * update NUM_INJ_ATTRS in case you add new members

 Families which have that injection hw */

 CONFIG_EDAC_DEBUG */

/*

 * Return the DramAddr that the SysAddr given by @sys_addr maps to.  It is

 * assumed that sys_addr maps to the node given by mci.

 *

 * The first part of section 3.4.4 (p. 70) shows how the DRAM Base (section

 * 3.4.4.1) and DRAM Limit (section 3.4.4.2) registers are used to translate a

 * SysAddr to a DramAddr. If the DRAM Hole Address Register (DHAR) is enabled,

 * then it is also involved in translating a SysAddr to a DramAddr. Sections

 * 3.4.8 and 3.5.8.2 describe the DHAR and how it is used for memory hoisting.

 * These parts of the documentation are unclear. I interpret them as follows:

 *

 * When node n receives a SysAddr, it processes the SysAddr as follows:

 *

 * 1. It extracts the DRAMBase and DRAMLimit values from the DRAM Base and DRAM

 *    Limit registers for node n. If the SysAddr is not within the range

 *    specified by the base and limit values, then node n ignores the Sysaddr

 *    (since it does not map to node n). Otherwise continue to step 2 below.

 *

 * 2. If the DramHoleValid bit of the DHAR for node n is clear, the DHAR is

 *    disabled so skip to step 3 below. Otherwise see if the SysAddr is within

 *    the range of relocated addresses (starting at 0x100000000) from the DRAM

 *    hole. If not, skip to step 3 below. Else get the value of the

 *    DramHoleOffset field from the DHAR. To obtain the DramAddr, subtract the

 *    offset defined by this value from the SysAddr.

 *

 * 3. Obtain the base address for node n from the DRAMBase field of the DRAM

 *    Base register for node n. To obtain the DramAddr, subtract the base

 *    address from the SysAddr, as shown near the start of section 3.4.4 (p.70).

 use DHAR to translate SysAddr to DramAddr */

	/*

	 * Translate the SysAddr to a DramAddr as shown near the start of

	 * section 3.4.4 (p. 70).  Although sys_addr is a 64-bit value, the k8

	 * only deals with 40-bit values.  Therefore we discard bits 63-40 of

	 * sys_addr below.  If bit 39 of sys_addr is 1 then the bits we

	 * discard are all 1s.  Otherwise the bits we discard are all 0s.  See

	 * section 3.4.2 of AMD publication 24592: AMD x86-64 Architecture

	 * Programmer's Manual Volume 1 Application Programming.

/*

 * @intlv_en is the value of the IntlvEn field from a DRAM Base register

 * (section 3.4.4.1).  Return the number of bits from a SysAddr that are used

 * for node interleaving.

 Translate the DramAddr given by @dram_addr to an InputAddr. */

	/*

	 * See the start of section 3.4.4 (p. 70, BKDG #26094, K8, revA-E)

	 * concerning translating a DramAddr to an InputAddr.

/*

 * Translate the SysAddr represented by @sys_addr to an InputAddr.  It is

 * assumed that @sys_addr maps to the node given by mci.

 Map the Error address to a PAGE and PAGE OFFSET. */

/*

 * @sys_addr is an error address (a SysAddr) extracted from the MCA NB Address

 * Low (section 3.6.4.5) and MCA NB Address High (section 3.6.4.6) registers

 * of a node that detected an ECC memory error.  mci represents the node that

 * the error address maps to (possibly different from the node that detected

 * the error).  Return the number of the csrow that sys_addr maps to, or -1 on

 * error.

/*

 * Determine if the DIMMs have ECC enabled. ECC is enabled ONLY if all the DIMMs

 * are ECC capable.

 UMC Configuration bit 12 (DimmEccEn) */

		/*

		 * It's assumed all LRDIMMs in a DCT are going to be of

		 * same 'type' until proven otherwise. So, use a cs

		 * value of '0' here to get dcsm value.

 Asymmetric dual-rank DIMM support. */

	/*

	 * 3 Rank inteleaving support.

	 * There should be only three bases enabled and their two masks should

	 * be equal.

 Display and decode various NB registers for debug purposes. */

 everything below this point is Fam10h and above */

 Only if NOT ganged does dclr1 have valid info */

 Display and decode various NB registers for debug purposes. */

/*

 * See BKDG, F2x[1,0][5C:40], F2[1,0][6C:60]

/*

 * Function 2 Offset F10_DCSB0; read in the DCS Base and DCS Mask registers

		/*

		 * Model 0x60h needs special handling:

		 *

		 * We use a Chip Select value of '0' to obtain dcsm.

		 * Theoretically, it is possible to populate LRDIMMs of different

		 * 'Rank' value on a DCT. But this is not the common case. So,

		 * it's reasonable to assume all DIMMs are going to be of same

		 * 'type' until proven otherwise.

 Get the number of DCT channels the memory controller is using. */

 RevF (NPT) and later */

 RevE and earlier */

 not used */

 On F10h and later ErrAddr is MC4_ADDR[47:1] */

	/*

	 * Erratum 637 workaround

 add [47:27] + 3 trailing bits */

 reverse and add DramIntlvEn */

 pin at [47:24] */

 faster log2 */

 OR DramIntlvSel into bits [14:12] */

 add remaining [11:0] bits from original MC4_ADDR */

 F15h: factor in CC6 save area by reading dst node's limit reg */

 {[39:27],111b} */

 [47:40] */

	/*

	 * Find out which node the error address belongs to. This may be

	 * different from the node that detected the error.

 Now map the sys_addr to a CSROW */

 CHIPKILL enabled */

			/*

			 * Syndrome didn't map, so we don't know which of the

			 * 2 DIMMs is in error. So we need to ID 'both' of them

			 * as suspect.

		/*

		 * non-chipkill ecc mode

		 *

		 * The k8 documentation is unclear about how to determine the

		 * channel number when using non-chipkill memory.  This method

		 * was obtained from email communication with someone at AMD.

		 * (Wish the email was placed in this comment - norsk)

		/*

		 * the below calculation, besides trying to win an obfuscated C

		 * contest, maps cs_mode values to DIMM chip select sizes. The

		 * mappings are:

		 *

		 * cs_mode	CS size (mb)

		 * =======	============

		 * 0		32

		 * 1		64

		 * 2		128

		 * 3		128

		 * 4		256

		 * 5		512

		 * 6		256

		 * 7		512

		 * 8		1024

		 * 9		1024

		 * 10		2048

		 *

		 * Basically, it calculates a value with which to shift the

		 * smallest CS size of 32MB.

		 *

		 * ddr[23]_cs_size have a similar purpose.

/*

 * Get the number of DCT channels in use.

 *

 * Return:

 *	number of Memory Channels in operation

 * Pass back:

 *	contents of the DCL0_LOW register

 On F10h, if we are in 128 bit mode, then we are using 2 channels */

	/*

	 * Need to check if in unganged mode: In such, there are 2 channels,

	 * but they are not in 128 bit mode and thus the above 'dclr0' status

	 * bit will be OFF.

	 *

	 * Need to check DCT0[0] and DCT1[0] to see if only one of them has

	 * their CSEnable bit on. If so, then SINGLE DIMM case.

	/*

	 * Check DRAM Bank Address Mapping values for each DIMM to see if there

	 * is more than just one DIMM present in unganged mode. Need to check

	 * both controllers since DIMMs can be placed in either one.

 SDP Control bit 31 (SdpInit) is clear for unused UMC channels */

 Min cs_size = 1G */

/*

 * F15h supports only 64bit DCT interfaces

 F15h M60h supports DDR4 mapping as well.. */

 Minimum cs size is 512mb for F15hM60h*/

/*

 * F16h and F15h model 30h have only limited cs_modes.

 No Chip Selects are enabled. */

 Requested size of an even CS but none are enabled. */

 Requested size of an odd CS but none are enabled. */

	/*

	 * There is one mask per DIMM, and two Chip Selects per DIMM.

	 *	CS0 and CS1 -> DIMM0

	 *	CS2 and CS3 -> DIMM1

 Asymmetric dual-rank DIMM support. */

	/*

	 * The number of zero bits in the mask is equal to the number of bits

	 * in a full mask minus the number of bits in the current mask.

	 *

	 * The MSB is the number of bits in the full mask because BIT[0] is

	 * always 0.

	 *

	 * In the special 3 Rank interleaving case, a single bit is flipped

	 * without swapping with the most significant bit. This can be handled

	 * by keeping the MSB where it is and ignoring the single zero bit.

 Take the number of zero bits off from the top of the mask. */

 Register [31:1] = Address [39:9]. Size is in kBs here. */

 Return size in MBs. */

/*

 * Determine channel (DCT) based on the interleaving mode (see F15h M30h BKDG,

 * 2.10.12 Memory Interleaving Modes).

/*

 * Determine channel (DCT) based on the interleaving mode: F10h BKDG, 2.8.9 Memory

 * Interleaving Modes.

	/*

	 * see F2x110[DctSelIntLvAddr] - channel interleave mode

 return DCT select function: 0=DCT0, 1=DCT1 */

 Convert the sys_addr to the normalized DCT address */

		/*

		 * if

		 * base address of high range is below 4Gb

		 * (bits [47:27] at [31:11])

		 * DRAM address space on this DCT is hoisted above 4Gb	&&

		 * sys_addr > 4Gb

		 *

		 *	remove hole offset from sys_addr

		 * else

		 *	remove high range offset from sys_addr

		/*

		 * if

		 * we have a valid hole		&&

		 * sys_addr > 4Gb

		 *

		 *	remove hole

		 * else

		 *	remove dram base to normalize to DCT address

/*

 * checks if the csrow passed in is marked as SPARED, if so returns the new

 * spare row

/*

 * Iterate over the DRAM DCT "base" and "mask" registers looking for a

 * SystemAddr match on the specified 'ChannelSelect' and 'NodeID'

 *

 * Return:

 *	-EINVAL:  NOT FOUND

 *	0..csrow = Chip-Select Row

/*

 * See F2x10C. Non-interleaved graphics framebuffer memory under the 16G is

 * swapped with a region located at the bottom of memory so that the GPU can use

 * the interleaved region and thus two channels.

 only revC3 and revE have that feature */

 For a given @dram_range, check if @sys_addr falls within it. */

	/*

	 * check whether addresses >= DctSelBaseAddr[47:27] are to be used to

	 * select between DCT0 and DCT1.

 Remove node interleaving, see F1x120 */

 remove channel interleave */

 hash 9 */

 A[6] or hash 6 */

 A[12] */

 Verify sys_addr is within DCT Range. */

 Verify number of dct's that participate in channel interleaving. */

 Verify we stay within the MAX number of channels allowed */

 Get normalized DCT addr */

 remove channel interleave */

	/*

	 * Find Chip select:

	 * if channel = 3, then alias it to 1. This is because, in F15 M30h,

	 * there is support for 4 DCT's, but only 2 are currently functional.

	 * They are DCT0 and DCT3. But we have read all registers of DCT3 into

	 * pvt->csels[1]. So we need to use '1' here to get correct info.

	 * Refer F15 M30h BKDG Section 2.10 and 2.10.3 for clarifications.

/*

 * For reference see "2.8.5 Routing DRAM Requests" in F10 BKDG. This code maps

 * a @sys_addr to NodeID, DCT (channel) and chip select (CSROW).

 *

 * The @sys_addr is usually an error address received from the hardware

 * (MCX_ADDR).

	/*

	 * We need the syndromes for channel detection only when we're

	 * ganged. Otherwise @chan should already contain the channel at

	 * this point.

/*

 * debug routine to display the memory sizes of all logical DIMMs and its

 * CSROWs

 K8 families < revF not supported yet */

 Dump memory sizes for DIMM and its CSROWs */

			/*

			 * For F15m60h, we need multiplier for LRDIMM cs_size

			 * calculation. We pass dimm value to the dbam_to_cs

			 * mapper so we can find the multiplier from the

			 * corresponding DCSM.

/*

 * These are tables of eigenvectors (one per line) which can be used for the

 * construction of the syndrome tables. The modified syndrome search algorithm

 * uses those to find the symbol in error and thus the DIMM.

 *

 * Algorithm courtesy of Ross LaFetra from AMD.

 walk over all 16 bits of the syndrome */

 if bit is set in that eigenvector... */

 ... and bit set in the modified syndrome, */

 remove it. */

 can't get to zero, move to next symbol */

 x8 symbols */

 imaginary bits not in a DIMM */

 Bail out early if this was an 'observed' error */

 Do only ECC errors */

/*

 * To find the UMC channel represented by this bank we need to match on its

 * instance_id. The instance_id of a bank is held in the lower 32 bits of its

 * IPID.

 *

 * Currently, we can derive the channel number by looking at the 6th nibble in

 * the instance_id. For example, instance_id=0xYXXXXX where Y is the channel

 * number.

/*

 * Use pvt->F3 which contains the F3 CPU PCI device to get the related

 * F1 (AddrMap) and F2 (Dct) devices. Return negative value on error.

 * Reserve F0 and F6 on systems with a UMC.

 Reserve the ADDRESS MAP Device */

 Reserve the DCT Device */

 Check enabled channels only: */

 F16h has only DCT0, so no need to read dbam1. */

 F10h, revD and later can do x8 ECC too. */

/*

 * Retrieve the hardware registers of the memory controller.

 Read registers from each UMC */

/*

 * Retrieve the hardware registers of the memory controller (this includes the

 * 'Address Map' and 'Misc' device regs)

	/*

	 * Retrieve TOP_MEM and TOP_MEM2; no masking off of reserved bits since

	 * those are Read-As-Zero.

 Check first whether TOP_MEM2 is enabled: */

 read settings for this DRAM range */

/*

 * NOTE: CPU Revision Dependent code

 *

 * Input:

 *	@csrow_nr ChipSelect Row Number (0..NUM_CHIPSELECTS-1)

 *	k8 private pointer to -->

 *			DRAM Bank Address mapping register

 *			node_id

 *			DCL register where dual_channel_active is

 *

 * The DBAM register consists of 4 sets of 4 bits each definitions:

 *

 * Bits:	CSROWs

 * 0-3		CSROWs 0 and 1

 * 4-7		CSROWs 2 and 3

 * 8-11		CSROWs 4 and 5

 * 12-15	CSROWs 6 and 7

 *

 * Values range from: 0 to 15

 * The meaning of the values depends on CPU revision and dual-channel state,

 * see relevant BKDG more info.

 *

 * The memory controller provides for total of only 8 CSROWs in its current

 * architecture. Each "pair" of CSROWs normally represents just one DIMM in

 * single channel or two (2) DIMMs in dual channel mode.

 *

 * The following code logic collapses the various tables for CSROW based on CPU

 * revision.

 *

 * Returns:

 *	The number of PAGE_SIZE pages on the specified CSROW number it

 *	encompasses

 *

/*

 * Initialize the array of csrow attribute instances, based on the values

 * from pci config hardware registers.

	/*

	 * We iterate over DCT0 here but we look at DCT1 in parallel, if needed.

 K8 has only one DCT */

 Determine DIMM ECC mode: */

 get all cores on this DCT */

 check MCG_CTL on all the cpus on this node */

			/*

			 * Turn off NB MCE reporting only when it was off before

 UECC/CECC enable */

 Attempt to turn on DRAM ECC Enable */

 UECC/CECC enable */

 restore previous BIOS DRAM ECC "off" setting we force-enabled */

 restore the NB Enable MCGCTL bit */

 Only check enabled UMCs. */

 Check whether at least one UMC is enabled: */

 Assume UMC MCA banks are enabled. */

 Set chipkill only if ECC is enabled: */

 memory scrubber interface */

/*

 * returns a pointer to the family descriptor on success, NULL otherwise.

 Richland is only client */

	/*

	 * We need to determine how many memory channels there are. Then use

	 * that information for calculating the size of the dynamic instance

	 * tables in the 'mci' structure.

	/*

	 * Always allocate two channels since we can have setups with DIMMs on

	 * only one channel. Also, this simplifies handling later for the price

	 * of a couple of KBs tops.

 Remove from EDAC CORE tracking list */

 Free the EDAC CORE resources */

 unwind properly */

 register stuff with EDAC MCE */

 unregister from EDAC MCE */

/*

 * edac_module.c

 *

 * (C) 2007 www.softwarebitmaker.com

 *

 * This file is licensed under the terms of the GNU General Public

 * License version 2. This program is licensed "as is" without any

 * warranty of any kind, whether express or implied.

 *

 * Author: Doug Thompson <dougthompson@xmission.com>

 *

 Values of 0 to 4 will generate output */

/*

 * edac_op_state_to_string()

/*

 * sysfs object: /sys/devices/system/edac

 *	need to export to other files

 create the /sys/devices/system/edac directory */

 return pointer to the 'edac' node in sysfs */

/*

 * edac_init

 *      module initialization entry point

	/*

	 * Harvest and clear any boot/initialization PCI parity errors

	 *

	 * FIXME: This only clears errors logged by devices present at time of

	 *      module initialization.  We should also do an initial clear

	 *      of each newly hotplugged device.

/*

 * edac_exit()

 *      module exit/termination function

 tear down the various subsystems */

/*

 * Inform the kernel of our entry and exit points

/*

 * Intel 3000/3010 Memory Controller kernel module

 * Copyright (C) 2007 Akamai Technologies, Inc.

 * Shamelessly copied from:

 * 	Intel D82875P Memory Controller kernel module

 * 	(C) 2003 Linux Networx (http://lnxi.com)

 *

 * This file may be distributed under the terms of the

 * GNU General Public License.

 Intel 3000 register addresses - device 0 function 0 - DRAM Controller */

 MCH Memory Mapped Register BAR */

#define I3000_EDEAP	0x70	/* Extended DRAM Error Address Pointer (8b)

				 *

				 * 7:1   reserved

				 * 0     bit 32 of address

#define I3000_DEAP	0x58	/* DRAM Error Address Pointer (32b)

				 *

				 * 31:7  address

				 * 6:1   reserved

				 * 0     Error channel 0/1

/*

 * Helper functions to decode the DEAP/EDEAP hardware registers.

 *

 * The type promotion here is deliberate; we're deriving an

 * unsigned long pfn and offset from hardware regs which are u8/u32.

#define I3000_DERRSYN	0x5c	/* DRAM Error Syndrome (8b)

				 *

				 *  7:0  DRAM ECC Syndrome

#define I3000_ERRSTS	0xc8	/* Error Status Register (16b)

				 *

				 * 15:12 reserved

				 * 11    MCH Thermal Sensor Event

				 *         for SMI/SCI/SERR

				 * 10    reserved

				 *  9    LOCK to non-DRAM Memory Flag (LCKF)

				 *  8    Received Refresh Timeout Flag (RRTOF)

				 *  7:2  reserved

				 *  1    Multi-bit DRAM ECC Error Flag (DMERR)

				 *  0    Single-bit DRAM ECC Error Flag (DSERR)

 bits which indicate errors */

#define I3000_ERRCMD	0xca	/* Error Command (16b)

				 *

				 * 15:12 reserved

				 * 11    SERR on MCH Thermal Sensor Event

				 *         (TSESERR)

				 * 10    reserved

				 *  9    SERR on LOCK to non-DRAM Memory

				 *         (LCKERR)

				 *  8    SERR on DRAM Refresh Timeout

				 *         (DRTOERR)

				 *  7:2  reserved

				 *  1    SERR Multi-Bit DRAM ECC Error

				 *         (DMERR)

				 *  0    SERR on Single-Bit ECC Error

				 *         (DSERR)

 Intel  MMIO register space - device 0 function 0 - MMR space */

 32MiB grain */

#define I3000_C0DRB	0x100	/* Channel 0 DRAM Rank Boundary (8b x 4)

				 *

				 * 7:0   Channel 0 DRAM Rank Boundary Address

#define I3000_C1DRB	0x180	/* Channel 1 DRAM Rank Boundary (8b x 4)

				 *

				 * 7:0   Channel 1 DRAM Rank Boundary Address

#define I3000_C0DRA	0x108	/* Channel 0 DRAM Rank Attribute (8b x 2)

				 *

				 * 7     reserved

				 * 6:4   DRAM odd Rank Attribute

				 * 3     reserved

				 * 2:0   DRAM even Rank Attribute

				 *

				 * Each attribute defines the page

				 * size of the corresponding rank:

				 *     000: unpopulated

				 *     001: reserved

				 *     010: 4 KB

				 *     011: 8 KB

				 *     100: 16 KB

				 *     Others: reserved

 Channel 1 DRAM Rank Attribute (8b x 2) */

#define I3000_C0DRC0	0x120	/* DRAM Controller Mode 0 (32b)

				 *

				 * 31:30 reserved

				 * 29    Initialization Complete (IC)

				 * 28:11 reserved

				 * 10:8  Refresh Mode Select (RMS)

				 * 7     reserved

				 * 6:4   Mode Select (SMS)

				 * 3:2   reserved

				 * 1:0   DRAM Type (DT)

#define I3000_C0DRC1	0x124	/* DRAM Controller Mode 1 (32b)

				 *

				 * 31    Enhanced Addressing Enable (ENHADE)

				 * 30:0  reserved

	/*

	 * This is a mess because there is no atomic way to read all the

	 * registers at once and the registers can transition from CE being

	 * overwritten by UE.

	/*

	 * If the error is the same for both reads then the first set

	 * of reads is valid.  If there is a change then there is a CE

	 * with no info and the second set of reads is valid and

	 * should be UE info.

	/*

	 * Clear any error bits.

	 * (Yes, we really clear bits by writing 1 to them.)

	/*

	 * If the channels aren't populated identically then

	 * we're not interleaved.

	/*

	 * If the rank boundaries for the two channels are different

	 * then we're not interleaved.

 ranks 0,1 */

 ranks 2,3 */

 ranks 0,1 */

 ranks 2,3 */

	/*

	 * Figure out how many channels we have.

	 *

	 * If we have what the datasheet calls "asymmetric channels"

	 * (essentially the same as what was called "virtual single

	 * channel mode" in the i82875) then it's a single channel as

	 * far as EDAC is concerned.

	/*

	 * The dram rank boundary (DRB) reg values are boundary addresses

	 * for each DRAM rank with a granularity of 32MB.  DRB regs are

	 * cumulative; the last one will contain the total memory

	 * contained in all ranks.

	 *

	 * If we're in interleaved mode then we're only walking through

	 * the ranks of controller 0, so we double all the values we see.

	/*

	 * Clear any error bits.

	 * (Yes, we really clear bits by writing 1 to them.)

 allocating generic PCI control info */

 get this far and it's successful */

 returns count (>= 0), or negative on error */

 0 terminated list. */

 Ensure that the OPSTATE is set correctly for POLL or NMI */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * string representation for the different MCA reported error types, see F3x48

 * or MSR0000_0411.

 transaction type */

 cache level */

 memory transaction type */

 participating processor */

 request timeout */

 memory or i/o */

 internal error type */

 xec = 0xd */

 xec = 010 */

 xec = 0x4 */

 xec = 0x10 */

 xec = 0x1c */

 Scalable MCA error strings */

 TLB error signatures are the same across families */

 special handling for DRAM ECCs */

 no ECCs on F11h */

 Decode errors according to Scalable MCA specification */

 Only print the decode of valid error codes */

 do the two bits[14:13] together */

 F15h, bank4, bit 43 is part of McaStatSubCache. */

 Doesn't matter which member to test. */

/*

 * This file is subject to the terms and conditions of the GNU General Public

 * License.  See the file "COPYING" in the main directory of this archive

 * for more details.

 *

 * Copyright (C) 2012 Cavium, Inc.

 *

 * Copyright (C) 2009 Wind River Systems,

 *   written by Ralf Baechle <ralf@linux-mips.org>

/**

 * EDAC CPU cache error callback

 *

 * @event: non-zero if unrecoverable.

 Clear the error indication */

 SPDX-License-Identifier: GPL-2.0

/*

 *  Copyright (C) 2017-2018, Intel Corporation. All rights reserved

 *  Copyright Altera Corporation (C) 2014-2016. All rights reserved.

 *  Copyright 2011-2012 Calxeda, Inc.

********************** EDAC Memory Controller Functions ****************/

 The SDRAM controller uses the EDAC Memory Controller framework.       */

 Clear IRQ to resume */

	/* Error are injected by writing a word while the SBE or DBE

	 * bit in the CTLCFG register is set. Reading the word will

	 * trigger the SBE or DBE error and the corresponding IRQ.

 Clear the error injection bits */

 Ensure it has been written out */

	/*

	 * To trigger the error, we need to read the data back

	 * (the data was written with errors above).

	 * The READ_ONCE macros and printk are used to prevent the

	 * the compiler optimizing these reads out.

 Force Read */

 Get total memory size from Open Firmware DTB */

 Grab the register range from the sdr controller in device tree */

 Check specific dependencies for the module */

 Validate the SDRAM controller has ECC enabled */

 Grab memory size from device tree. */

 Ensure the SDRAM Interrupt is disabled */

 Toggle to clear the SDRAM Error count */

 Arria10 has a 2nd IRQ */

 Only the Arria10 has separate IRQs */

 Arria10 specific initialization */

 Infrastructure ready - enable the IRQ */

/*

 * If you want to suspend, need to disable EDAC by removing it

 * from the device tree or defconfig.

 CONFIG_EDAC_ALTERA_SDRAM */

************************ EDAC Parent Probe *************************/

************************ EDAC Device Functions *************************/

/*

 * EDAC Device Functions (shared between various IPs).

 * The discrete memories use the EDAC Device framework. The probe

 * and error handling functions are very similar between memories

 * so they are shared. The memory allocation and freeing for EDAC

 * trigger testing are different for each memory.

	/*

	 * Note that generic_ptr is initialized to the device * but in

	 * some alloc_functions, this is overridden and returns data.

 write ECC corrupted data out. */

 Read data so we're in the correct state */

 Toggle Error bit (it is latched), leave ECC enabled */

 Ensure it has been written out */

 Read out written data. ECC error caused here */

/*

 * altr_edac_device_probe()

 *	This is a generic EDAC device driver that will support

 *	various Altera memory devices such as the L2 cache ECC and

 *	OCRAM ECC as well as the memories for other peripherals.

 *	Module specific initialization is done by passing the

 *	function index in the device tree.

 Get driver specific data for this EDAC device */

 Check specific dependencies for the module */

****************** Arria10 Device ECC Shared Functions *****************/

/*

 *  Test for memory's ECC dependencies upon entry because platform specific

 *  startup should have initialized the memory and enabled the ECC.

 *  Can't turn on ECC here because accessing un-initialized memory will

 *  cause CE/UE errors possibly causing an ABORT.

****************** Arria10 Memory Buffer Functions *********************/

/*

 * This function uses the memory initialization block in the Arria10 ECC

 * controller to initialize/clear the entire memory data and ECC data.

 Clear any pending ECC interrupts */

 Get the ECC Manager - parent of the device EDACs */

 Map the ECC Block */

 Disable ECC */

 Ensure all writes complete */

 Use HW initialization block to initialize memory for ECC */

 Interrupt mode set to every SBERR */

 Enable ECC */

 Ensure all writes complete */

 Get matching node and check for valid result */

 Validate private data pointer before dereferencing */

********************** SDRAM EDAC Device Functions *********************/

 CONFIG_EDAC_ALTERA_SDRAM */

********************** OCRAM EDAC Device Functions *********************/

 Ensure data is written out */

 Remember this handle for freeing  later */

 Verify OCRAM has been initialized */

 Enable IRQ on Single Bit Error */

 Ensure all writes complete */

	/*

	 * OCRAM panic on uncorrectable error because sleep/resume

	 * functions and FPGA contents are stored in OCRAM. Prefer

	 * a kernel panic over executing/loading corrupted data.

 CONFIG_EDAC_ALTERA_OCRAM */

******************** L2 Cache EDAC Device Functions ********************/

 Make sure everything is written out */

	/*

	 * Clean all cache levels up to LoC (includes L2)

	 * This ensures the corrupted data is written into

	 * L2 cache for readback test (which causes ECC error).

/*

 * altr_l2_check_deps()

 *	Test for L2 cache ECC dependencies upon entry because

 *	platform specific startup should have initialized the L2

 *	memory and enabled the ECC.

 *	Bail if ECC is not enabled.

 *	Note that L2 Cache Enable is forced at build time.

 CONFIG_EDAC_ALTERA_L2C */

******************** Ethernet Device Functions ********************/

 CONFIG_EDAC_ALTERA_ETHERNET */

********************* NAND Device Functions **********************/

 CONFIG_EDAC_ALTERA_NAND */

********************* DMA Device Functions **********************/

 CONFIG_EDAC_ALTERA_DMA */

********************* USB Device Functions **********************/

 CONFIG_EDAC_ALTERA_USB */

********************* QSPI Device Functions **********************/

 CONFIG_EDAC_ALTERA_QSPI */

******************** SDMMC Device Functions **********************/

 Create the PortB EDAC device */

 Initialize the PortB EDAC device structure from PortA structure */

 Update PortB specific values */

	/*

	 * Update the PortB IRQs - A10 has 4, S10 has 2, Index accordingly

	 *

	 * FIXME: Instead of ifdefs with different architectures the driver

	 *        should properly use compatibles.

 Use IRQ to determine SError origin instead of assigning IRQ */

 Init portB */

 Setup portB */

 CONFIG_EDAC_ALTERA_SDMMC */

******************** Arria10 EDAC Device Functions *************************/

/*

 * The Arria10 EDAC Device Functions differ from the Cyclone5/Arria5

 * because 2 IRQs are shared among the all ECC peripherals. The ECC

 * manager manages the IRQs and the children.

 * Based on xgene_edac.c peripheral code.

 Ensure the interrupt test bits are set */

/*

 * The Stratix10 EDAC Error Injection Functions differ from Arria10

 * slightly. A few Arria10 peripherals can use this injection function.

 * Inject the error into the memory and then readback to trigger the IRQ.

 Setup read/write of 4 bytes */

 Setup Address to 0 */

 Setup accctrl to read & ecc & data override */

 Kick it. */

 Setup write for single bit change */

 Copy Read ECC to Write ECC */

 Setup accctrl to write & ecc override & data override */

 Kick it. */

 Setup accctrl to read & ecc overwrite & data overwrite */

 Kick it. */

 Ensure the interrupt test bits are set */

 SDRAM must be present for Linux (implied parent) */

 Ensure parent device is enabled if parent node exists */

 Get matching node and check for valid result */

 Get driver specific data for this EDAC device */

 Check specific dependencies for the module */

 Use IRQ to determine SError origin instead of assigning IRQ */

************* Stratix 10 EDAC Double Bit Error Handler ************/

 panic routine issues reboot on non-zero panic_timeout */

/*

 * The double bit error is handled through SError which is fatal. This is

 * called as a panic notifier to printout ECC error info as part of the panic.

 Find the matching DBE in the list of devices */

 Notify the System through SMC. Reboot delay = 1 second */

***************** Arria 10 EDAC Probe Function *********************/

 Printout a message if uncorrectable error previously. */

 Reset the sticky registers */

/*

 * edac_device.c

 * (C) 2007 www.douglaskthompson.com

 *

 * This file may be distributed under the terms of the

 * GNU General Public License.

 *

 * Written by Doug Thompson <norsk5@xmission.com>

 *

 * edac_device API implementation

 * 19 Jan 2007

/* lock for the list: 'edac_device_list', manipulation of this list

 * is protected by the 'device_ctls_mutex' lock

 CONFIG_EDAC_DEBUG */

 zero, 1, or other based offset */

	/* Calculate the size of memory we need to allocate AND

	 * determine the offsets of the various item arrays

	 * (instance,block,attrib) from the start of an  allocated structure.

	 * We want the alignment of each item  (instance,block,attrib)

	 * to be at least as stringent as what the compiler would

	 * provide if we could simply hardcode everything into a single struct.

	/* Calc the 'end' offset past end of ONE ctl_info structure

	 * which will become the start of the 'instance' array

	/* Calc the 'end' offset past the instance array within the ctl_info

	 * which will become the start of the block array

	/* Calc the 'end' offset past the dev_blk array

	 * which will become the start of the attrib array, if any.

 calc how many nr_attrib we need */

 Calc the 'end' offset past the attributes array */

	/* 'pvt' now points to where the private data area is.

	 * At this point 'pvt' (like dev_inst,dev_blk and dev_attrib)

	 * is baselined at ZERO

 Allocate the amount of memory for the set of control structures */

	/* Adjust pointers so they point within the actual memory we

	 * just allocated rather than an imaginary chunk of memory

	 * located at address 0.

	 * 'dev_ctl' points to REAL memory, while the others are

	 * ZERO based and thus need to be adjusted to point within

	 * the allocated memory.

 Begin storing the information into the control info structure */

 Default logging of CEs and UEs */

 Name of this edac device */

 Initialize every Instance */

 name of this instance */

 Initialize every block in each instance */

			/* if there are NO attributes OR no attribute pointer

			 * then continue on to next block iteration

 setup the attribute array for this block */

			/* Initialize every user specified attribute in this

			 * block with the data the caller passed in

			 * Each block gets its own copy of pointers,

			 * and its unique 'value'

				/* populate the unique per attrib

				 * with the code pointers and info

 up link */

 Mark this instance as merely ALLOCATED */

	/*

	 * Initialize the 'root' kobj for the edac_device controller

	/* at this point, the root kobj is valid, and in order to

	 * 'free' the object, then the function:

	 *	edac_device_unregister_sysfs_main_kobj() must be called

	 * which will perform kobj unregistration and the actual free

	 * will occur during the kobject callback operation

/*

 * find_edac_device_by_dev

 *	scans the edac_device list for a specific 'struct device *'

 *

 *	lock to be held prior to call:	device_ctls_mutex

 *

 *	Return:

 *		pointer to control structure managing 'dev'

 *		NULL if not found on list

/*

 * add_edac_dev_to_global_list

 *	Before calling this function, caller must

 *	assign a unique value to edac_dev->dev_idx.

 *

 *	lock to be held prior to call:	device_ctls_mutex

 *

 *	Return:

 *		0 on success

 *		1 on failure.

 Determine if already on the list */

 Insert in ascending order by 'dev_idx', so find position */

/*

 * del_edac_device_from_global_list

	/* these are for safe removal of devices from global list while

	 * NMI handlers may be traversing list

/*

 * edac_device_workq_function

 *	performs the operation scheduled by a workq request

 *

 *	this workq is embedded within an edac_device_ctl_info

 *	structure, that needs to be polled for possible error events.

 *

 *	This operation is to acquire the list mutex lock

 *	(thus preventing insertation or deletion)

 *	and then call the device's poll function IFF this device is

 *	running polled and there is a poll function defined.

 If we are being removed, bail out immediately */

 Only poll controllers that are running polled and have a check */

	/* Reschedule the workq for the next time period to start again

	 * if the number of msec is for 1 sec, then adjust to the next

	 * whole one second to save timers firing all over the period

	 * between integral seconds

/*

 * edac_device_workq_setup

 *	initialize a workq item for this edac_device instance

 *	passing in the new delay period in msec

	/* take the arg 'msec' and set it into the control structure

	 * to used in the time period calculation

	 * then calc the number of jiffies that represents

	/* optimize here for the 1 second case, which will be normal value, to

	 * fire ON the 1 second time event. This helps reduce all sorts of

	 * timers firing on sub-second basis, while they are happy

	 * to fire together on the 1 second exactly

/*

 * edac_device_workq_teardown

 *	stop the workq processing on this edac_dev

/*

 * edac_device_reset_delay_period

 *

 *	need to stop any outstanding workq queued up at this time

 *	because we will be resetting the sleep time.

 *	Then restart the workq on the new delay

 set load time so that error rate can be tracked */

 create this instance's sysfs entries */

 If there IS a check routine, then we are running POLLED */

 This instance is NOW RUNNING */

		/*

		 * enable workq processing on this instance,

		 * default = 1000 msec

 Report action taken */

 Some error, so remove the entry from the lsit */

 Find the structure on the list, if not there, then leave */

 mark this instance as OFFLINE */

 deregister from global list */

 clear workq processing on this instance */

 Tear down the sysfs entries for this instance */

 Propagate the count up the 'totals' tree */

 Propagate the count up the 'totals' tree */

 SPDX-License-Identifier: GPL-2.0-only

/* Intel Sandy Bridge -EN/-EP/-EX Memory Controller kernel module

 *

 * This driver supports the memory controllers found on the Intel

 * processor family Sandy Bridge.

 *

 * Copyright (c) 2011 by:

 *	 Mauro Carvalho Chehab

 Static vars */

/*

 * Alter this version for the module when modifications are made

/*

 * Debug macros

/*

 * Get a bit field at register value <v>, from bit <lo> to bit <hi>

 Devices 12 Function 6, Offsets 0x80 to 0xcc */

 0-4 */

 5-9 */

 10-14 */

 15-19 */

 20-23 */

 0-4 */

 5-9 */

 10-14 */

 15-19 */

 20-23 */

 Devices 12 Function 7 */

 Device 13 Function 6 */

 Device 14 function 0 */

 Device 15, function 0 */

 Device 15, function 1 */

 Device 15, functions 2-5 */

 Device 16, functions 2-7 */

/*

 * FIXME: Implement the error count reads directly

 Currently unused*/

 Device 17, function 0 */

/*

 * sbridge structs

 Max channels per MC */

 Max DIMMS per channel */

 KNL max num. of Cache Home Agents */

 KNL max num. of PCI channels */

 Embedded DRAM controllers */

 Intel IA32 SDM 15-14 */

 tolm, tohm */

 Devices per socket */

 Devices per memory controller */

 Memory type detection */

 Memory description */

 Processor Home Agent */

 Memory controller */

 System Address Decoder */

 Broadcast Registers */

 0 terminated list. */

/* This changes depending if 1HA or 2HA:

 * 1HA:

 *	0x0eb8 (17.0) is DDRIO0

 * 2HA:

 *	0x0ebc (17.4) is DDRIO0

 pci ids */

 Processor Home Agent */

 Memory controller */

 Optional, mode 2HA */

 System Address Decoder */

 Broadcast Registers */

 0 terminated list. */

 Haswell support */

/* EN processor:

 *	- 1 IMC

 *	- 3 DDR3 channels, 2 DPC per channel

 * EP processor:

 *	- 1 or 2 IMC

 *	- 4 DDR4 channels, 3 DPC per channel

 * EP 4S processor:

 *	- 2 IMC

 *	- 4 DDR4 channels, 3 DPC per channel

 * EX processor:

 *	- 2 IMC

 *	- each IMC interfaces with a SMI 2 channel

 *	- each SMI channel interfaces with a scalable memory buffer

 *	- each scalable memory buffer supports 4 DDR3/DDR4 channels, 3 DPC

 Ditto on Broadwell */

 first item must be the HA */

 0 terminated list. */

 Knight's Landing Support */

/*

 * KNL's memory channels are swizzled between memory controllers.

 * MC0 is mapped to CH3,4,5 and MC1 is mapped to CH0,1,2

 Memory controller, TAD tables, error injection - 2-8-0, 2-9-0 (2 of these) */

 DRAM channel stuff; bank addrs, dimmmtr, etc.. 2-8-2 - 2-9-4 (6 of these) */

 kdrwdbu TAD limits/offsets, MCMTR - 2-10-1, 2-11-1 (2 of these) */

 CHA broadcast registers, dram rules - 1-29-0 (1 of these) */

 SAD target - 1-29-1 (1 of these) */

 Caching / Home Agent */

 Device with TOLM and TOHM, 0-5-0 (1 of these) */

/*

 * KNL differs from SB, IB, and Haswell in that it has multiple

 * instances of the same device with the same device ID, so we handle that

 * by creating as many copies in the table as we expect to find.

 * (Like device ID must be grouped together.)

/*

 * Broadwell support

 *

 * DE processor:

 *	- 1 IMC

 *	- 2 DDR3 channels, 2 DPC per channel

 * EP processor:

 *	- 1 or 2 IMC

 *	- 4 DDR4 channels, 3 DPC per channel

 * EP 4S processor:

 *	- 2 IMC

 *	- 4 DDR4 channels, 3 DPC per channel

 * EX processor:

 *	- 2 IMC

 *	- each IMC interfaces with a SMI 2 channel

 *	- each SMI channel interfaces with a scalable memory buffer

 *	- each scalable memory buffer supports 4 DDR3/DDR4 channels, 3 DPC

 first item must be the HA */

 0 terminated list. */

/****************************************************************************

			Ancillary status routines

	/*

	 * If we have devices scattered across several busses that pertain

	 * to the same memory controller, we'll lump them all together.

 Address range is 32:28 */

 FIXME: Can also be LRDIMM */

 Is_Rdimm */

 for KNL value is fixed */

 there's no way to figure out */

	/*

	 * ddr3_width on the documentation but also valid for DDR4 on

	 * Haswell

 ddr3_width on the documentation but also valid for DDR4 */

 DDR4 RDIMMS and LRDIMMS are supported */

/*

 * Use the reporting bank number to determine which memory

 * controller (also known as "ha" for "home agent"). Sandy

 * Bridge only has one memory controller per socket, so the

 * answer is always zero.

/*

 * On Ivy Bridge, Haswell and Broadwell the error may be in a

 * home agent bank (7, 8), or one of the per-channel memory

 * controller banks (9 .. 16).

 Not used, but included for safety/symmetry */

 on Ivy Bridge, nodeID is SASS, where A is HA and S is node id */

	/*

	 * XOR even bits from 12:26 to bit0 of idx,

	 *     odd bits from 13:27 to bit1

 Low bits of TAD limit, and some metadata. */

 Low bits of TAD offset. */

 High 16 bits of TAD limit and offset. */

 Number of ways a tad entry is interleaved. */

/*

 * Retrieve the n'th Target Address Decode table entry

 * from the memory controller's TAD table.

 *

 * @pvt:	driver private data

 * @entry:	which entry you want to retrieve

 * @mc:		which memory controller (0 or 1)

 * @offset:	output tad range offset

 * @limit:	output address of first byte above tad range

 * @ways:	output number of interleave ways

 *

 * The offset value has curious semantics.  It's a sort of running total

 * of the sizes of all the memory regions that aren't mapped in this

 * tad table.

 Is this TAD entry enabled? */

	/*

	 * The least significant 6 bits of base and limit are truncated.

	 * For limit, we fill the missing bits with 1s.

 Determine which memory controller is responsible for a given channel. */

/*

 * Get the Nth entry from EDC_ROUTE_TABLE register.

 * (This is the per-tile mapping of logical interleave targets to

 *  physical EDC modules.)

 *

 * entry 0: 0:2

 *       1: 3:5

 *       2: 6:8

 *       3: 9:11

 *       4: 12:14

 *       5: 15:17

 *       6: 18:20

 *       7: 21:23

 * reserved: 24:31

/*

 * Get the Nth entry from MC_ROUTE_TABLE register.

 * (This is the per-tile mapping of logical interleave targets to

 *  physical DRAM channels modules.)

 *

 * entry 0: mc 0:2   channel 18:19

 *       1: mc 3:5   channel 20:21

 *       2: mc 6:8   channel 22:23

 *       3: mc 9:11  channel 24:25

 *       4: mc 12:14 channel 26:27

 *       5: mc 15:17 channel 28:29

 * reserved: 30:31

 *

 * Though we have 3 bits to identify the MC, we should only see

 * the values 0 or 1.

/*

 * Render the EDC_ROUTE register in human-readable form.

 * Output string s should be at least KNL_MAX_EDCS*2 bytes.

/*

 * Render the MC_ROUTE register in human-readable form.

 * Output string s should be at least KNL_MAX_CHANNELS*2 bytes.

 Is this dram rule backed by regular DRAM in flat mode? */

 Is this dram rule cached? */

 Is this rule backed by edc ? */

 Is this rule backed by DRAM, cacheable in EDRAM? */

 Is this rule mod3? */

/*

 * Figure out how big our RAM modules are.

 *

 * The DIMMMTR register in KNL doesn't tell us the size of the DIMMs, so we

 * have to figure this out from the SAD rules, interleave lists, route tables,

 * and TAD rules.

 *

 * SAD rules can have holes in them (e.g. the 3G-4G hole), so we have to

 * inspect the TAD rules to figure out how large the SAD regions really are.

 *

 * When we know the real size of a SAD region and how many ways it's

 * interleaved, we know the individual contribution of each channel to

 * TAD is size/ways.

 *

 * Finally, we have to check whether each channel participates in each SAD

 * region.

 *

 * Fortunately, KNL only supports one DIMM per channel, so once we know how

 * much memory the channel uses, we know the DIMM is at least that large.

 * (The BIOS might possibly choose not to map all available memory, in which

 * case we will underreport the size of the DIMM.)

 *

 * In theory, we could try to determine the EDC sizes as well, but that would

 * only work in flat mode, not in cache mode.

 *

 * @mc_sizes: Output sizes of channels (must have space for KNL_MAX_CHANNELS

 *            elements)

 sad size accounting for holes, per mc */

 Read the EDC route table in each CHA. */

 Read the MC route table in each CHA. */

 Process DRAM rules */

 previous limit becomes the new base */

		/*

		 * Find out how many ways this dram rule is interleaved.

		 * We stop when we see the first channel again.

				/*

				 * 0 bit means memory is non-local,

				 * which KNL doesn't support

		/*

		 * Find out how big the SAD region really is by iterating

		 * over TAD tables (SAD regions may contain holes).

		 * Each memory controller might have a different TAD table, so

		 * we have to look at both.

		 *

		 * Livespace is the memory that's mapped in this TAD table,

		 * deadspace is the holes (this could be the MMIO hole, or it

		 * could be memory that's mapped by the other TAD table but

		 * not this one).

 TAD region is completely inside SAD region */

 Ignore EDRAM rule */

 Figure out which channels participate in interleave. */

		/* For each channel, does at least one CHA have

		 * this channel mapped to the given target?

 For DDR4, this is fixed. */

	/* KNL doesn't support mirroring or lockstep,

	 * and is always closed page

	/*

	 * Step 1) Get TOLM/TOHM ranges

 Address range is already 45:25 */

	/*

	 * Step 2) Get SAD range and SAD Interleave list

	 * TAD registers contain the interleave wayness. However, it

	 * seems simpler to just discover it indirectly, with the

	 * algorithm bellow.

 SAD_LIMIT Address range is 45:26 */

	/*

	 * Step 3) Get TAD range

	/*

	 * Step 4) Get TAD offsets, per each channel

	/*

	 * Step 6) Get RIR Wayness/Limit, per each channel

	/*

	 * Step 0) Check if the address is at special memory ranges

	 * The check bellow is probably enough to fill all cases where

	 * the error is not inside a memory, except for the legacy

	 * range (e. g. VGA addresses). It is unlikely, however, that the

	 * memory controller would generate an error on that range.

	/*

	 * Step 1) Get socket

 A7 mode swaps P9 with P6 */

 interleave mode will XOR {8,7,6} with {18,17,16} */

 MCChanShiftUpEnable */

 Ivy Bridge's SAD mode doesn't support XOR interleave mode */

	/*

	 * Move to the proper node structure, in order to access the

	 * right PCI registers

	/*

	 * Step 2) Get memory channel

	/*

	 * FIXME: Shouldn't we use CHN_IDX_OFFSET() here, when ch_way == 3 ???

 Calculate channel address */

 Remove the TAD offset */

	/*

	 * Step 3) Decode rank

 FIXME: Datasheet says to shift by 15 */

/****************************************************************************

	Device initialization routines: put/get, init/exit

/*

 *	sbridge_put_all_devices	'put' all the devices that we have

 *				reserved via 'get'

 if the HA wasn't found */

 End of list, leave */

 If the HA1 wasn't found, don't create EDAC second memory controller */

 pdev belongs to more than one IMC, do extra gets */

 Be sure that the device is enabled */

	/*

	 * As stated on drivers/pci/search.c, the reference count for

	 * @from is always decremented if it is not %NULL. So, as we need

	 * to get all devices up to null, we need to do a get for the device

/*

 * sbridge_get_all_devices - Find and perform 'get' operation on the MCH's

 *			     devices we want to reference for this driver.

 * @num_mc: pointer to the memory controllers count, to be incremented in case

 *	    of success.

 * @table: model specific table

 *

 * returns 0 in case of success or error code

/*

 * Device IDs for {SBRIDGE,IBRIDGE,HASWELL,BROADWELL}_IMC_HA0_TAD0 are in

 * the format: XXXa. So we can convert from a device to the corresponding

 * channel like this

 Check if everything were registered */

 Check if everything were registered */

 -EN/-EX */

 -EP */

 there's only one device per system; not tied to any bus */

 result will be checked later */

 Check if everything were registered */

 -EN/-EX */

 -EP */

 there's only one device per system; not tied to any bus */

 result will be checked later */

 Check if everything were registered */

 -EN/-EX */

 -EP */

 Extract PCI device and function. */

			/* There are one of these per tile, and range from

			 * 1.14.0 to 1.18.5.

			/*

			 *  MC0 channels 0-2 are device 9 function 2-4,

			 *  MC1 channels 3-5 are device 8 function 2-4.

/****************************************************************************

			Error check routines

/*

 * While Sandy Bridge has error count registers, SMI BIOS read values from

 * and resets the counters. So, they are not reliable for the OS to read

 * from them. So, we have no option but to just trust on whatever MCE is

 * telling us about the errors.

	/*

	 * Bits 5-0 of MCi_MISC give the least significant bit that is valid.

	 * A value 6 is for cache line aligned address, a value 12 is for page

	 * aligned address reported by patrol scrubber.

	/*

	 * According with Table 15-9 of the Intel Architecture spec vol 3A,

	 * memory errors should fit in this mask:

	 *	000f 0000 1mmm cccc (binary)

	 * where:

	 *	f = Correction Report Filtering Bit. If 1, subsequent errors

	 *	    won't be shown

	 *	mmm = error type

	 *	cccc = channel

	 * If the mask doesn't match, report an error to the parsing logic

			/*

			 * Reported channel is in range 0-2, so we can't map it

			 * back to mc. To figure out mc we check machine check

			 * bank register that reported this error.

			 * bank15 means mc0 and bank16 means mc1.

	/*

	 * FIXME: On some memory configurations (mirror, lockstep), the

	 * Memory Controller can't point the error to a single DIMM. The

	 * EDAC core should be handling the channel mask, in order to point

	 * to the group of dimm's where the error may be happening.

 FIXME: need support for channel mask */

 Call the helper to output message */

/*

 * Check that logging is enabled and that this is the right type

 * of error for us to handle.

	/*

	 * Just let mcelog handle it if the error is

	 * outside the memory controller. A memory error

	 * is indicated by bit 7 = 1 and bits = 8-11,13-15 = 0.

	 * bit 12 has an special meaning.

 Check ADDRV bit in STATUS */

 Check MISCV bit in STATUS */

 Check address type in MISC (physical address only) */

 Advice mcelog that the error were handled */

/****************************************************************************

			EDAC register/unregister logic

 Remove MC sysfs nodes */

 allocate a new MC control structure */

 Associate sbridge_dev and mci for future usage */

 Store pci devices at mci for faster access */

 Store pci devices at mci for faster access */

 rankcfgr isn't used */

 Store pci devices at mci for faster access */

 rankcfgr isn't used */

 Store pci devices at mci for faster access */

 pvt->info.rankcfgr == ??? */

 Get dimm basic config and the memory layout */

 record ptr to the generic device */

 add this new MC control structure to EDAC's list of MCs */

/*

 *	sbridge_probe	Get all devices and register memory controllers

 *			present.

 *	return:

 *		0 for FOUND a device

 *		< 0 for error code

 get the pci devices we want to reserve for our use */

/*

 *	sbridge_remove	cleanup

 *

 Release PCI resources */

/*

 *	sbridge_init		Module entry function

 *			Try to initialize this module for its devices

 Ensure that the OPSTATE is set correctly for POLL or NMI */

/*

 *	sbridge_exit()	Module exit function

 *			Unregister the driver

www.redhat.com)");

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2017 Pengutronix, Jan Luebbe <kernel@pengutronix.de>

*********************** EDAC MC (DDR RAM) ********************************/

 width in bytes */

 bank interleaving */

 derived from "DRAM Address Multiplexing" in the ARMADA XP Functional Spec */

 64 bit */

 bank interleaved */

 32 bit */

 bank interleaved */

 16 bit */

 bank interleaved */

 clear cause registers */

 clear error counter registers */

 report earlier errors */

 error count */

 pfn, offset, syndrome */

 top, mid, low layer */

 error count */

 pfn, offset, syndrome */

 top, mid, low layer */

 report details for most recent error */

 11 chars */

  9 chars */

 11 chars */

  4 chars */

 error count */

 top, mid, low layer */

 error count */

 top, mid, low layer */

 64 bit */

 32 bit */

 2GBit */

 256MBit */

 512MBit */

 1GBit */

 4GBit */

 8GBit */

 These SoCs have a reduced width bus */

 configure SBE threshold */

 it seems that SBEs are not captured otherwise */

 clear cause registers */

 clear counter registers */

*********************** EDAC Device (L2 Cache) ***************************/

 error injection via debugfs */

 clear error counter registers */

 clear error capture registers */

 UnCorrECC or TagParity */

 report remaining errors */

 clear registers */

*********************** Driver registration ******************************/

 only polling is supported */

 SPDX-License-Identifier: GPL-2.0+

/*

 * Copyright 2018, 2019 Cisco Systems

 protection key register */

 configuration register */

 interrupt control/status register */

 address of first un-recoverable error */

 address of last recoverable error */

 enable write to MCR register set */

 disable write to MCR register set */

 report first few errors (if there are) */

 note: no addresses are recorded */

 page, offset and syndrome are not available */

 report last error */

 note: rec_addr is the last recoverable error addr */

 syndrome is not available */

 report 1. error */

 note: un_rec_addr is the first unrecoverable error addr */

 syndrome is not available */

 report further errors (if there are) */

 note: no addresses are recorded */

 page, offset and syndrome are not available */

 collect data about recoverable and unrecoverable errors */

 clear interrupt flags and error counters: */

 process recoverable and unrecoverable errors */

 register interrupt handler */

 enable interrupts */

 retrieve info about physical memory from device tree */

 bail out if ECC mode is not configured */

 allocate & init EDAC MC data structure */

 register with edac core */

 register interrupt handler and enable interrupts */

 disable interrupts */

 free resources */

/*

 * Synopsys DDR ECC Driver

 * This driver is based on ppc4xx_edac.c drivers

 *

 * Copyright (C) 2012 - 2014 Xilinx, Inc.

 *

 * This program is free software: you can redistribute it and/or modify

 * it under the terms of the GNU General Public License as published by

 * the Free Software Foundation, either version 2 of the License, or

 * (at your option) any later version.

 *

 * This program is distributed in the hope that it will be useful,

 * but WITHOUT ANY WARRANTY; without even the implied warranty of

 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

 *

 * This file is subject to the terms and conditions of the GNU General Public

 * License.  See the file "COPYING" in the main directory of this archive

 * for more details

 Number of cs_rows needed per memory controller */

 Number of channels per memory controller */

 Granularity of reported error in bytes */

 Synopsys DDR memory controller registers that are relevant to ECC */

 ECC control register */

 ECC log register */

 ECC address register */

 ECC data[31:0] register */

 Uncorrectable error info registers */

 Control register bit field definitions */

 ZQ register bit field definitions */

 ECC control register bit field definitions */

 ECC correctable/uncorrectable error log register definitions */

 ECC correctable/uncorrectable error address register definitions */

 ECC statistic register definitions */

 ECC scrub register definitions */

 DDR ECC Quirks */

 ZynqMP Enhanced DDR memory controller registers that are relevant to ECC */

 ECC Configuration Registers */

 ECC Status Register */

 ECC Clear Register */

 ECC Error count Register */

 ECC Corrected Error Address Register */

 ECC Syndrome Registers */

 ECC Bit Mask0 Address Register */

 ECC UnCorrected Error Address Register */

 ECC Syndrome Registers */

 ECC Poison Address Reg */

 Control register bitfield definitions */

 DDR Control Register width definitions  */

 ECC status register definitions */

 DDR QOS Interrupt register definitions */

 ECC Corrected Error Register Mask and Shifts*/

 ECC Poison register shifts */

 DDR Memory type defines */

 DDRC Software control register */

 DDRC ECC CE & UE poison mask */

 DDRC Device config masks */

/**

 * struct ecc_error_info - ECC error log information.

 * @row:	Row number.

 * @col:	Column number.

 * @bank:	Bank number.

 * @bitpos:	Bit position.

 * @data:	Data causing the error.

 * @bankgrpnr:	Bank group number.

 * @blknr:	Block number.

/**

 * struct synps_ecc_status - ECC status information to report.

 * @ce_cnt:	Correctable error count.

 * @ue_cnt:	Uncorrectable error count.

 * @ceinfo:	Correctable error log information.

 * @ueinfo:	Uncorrectable error log information.

/**

 * struct synps_edac_priv - DDR memory controller private instance data.

 * @baseaddr:		Base address of the DDR controller.

 * @message:		Buffer for framing the event specific info.

 * @stat:		ECC status information.

 * @p_data:		Platform data.

 * @ce_cnt:		Correctable Error count.

 * @ue_cnt:		Uncorrectable Error count.

 * @poison_addr:	Data poison address.

 * @row_shift:		Bit shifts for row bit.

 * @col_shift:		Bit shifts for column bit.

 * @bank_shift:		Bit shifts for bank bit.

 * @bankgrp_shift:	Bit shifts for bank group bit.

 * @rank_shift:		Bit shifts for rank bit.

/**

 * struct synps_platform_data -  synps platform data structure.

 * @get_error_info:	Get EDAC error info.

 * @get_mtype:		Get mtype.

 * @get_dtype:		Get dtype.

 * @get_ecc_state:	Get ECC state.

 * @quirks:		To differentiate IPs.

/**

 * zynq_get_error_info - Get the current ECC error info.

 * @priv:	DDR memory controller private instance data.

 *

 * Return: one if there is no error, otherwise zero.

/**

 * zynqmp_get_error_info - Get the current ECC error info.

 * @priv:	DDR memory controller private instance data.

 *

 * Return: one if there is no error otherwise returns zero.

/**

 * handle_error - Handle Correctable and Uncorrectable errors.

 * @mci:	EDAC memory controller instance.

 * @p:		Synopsys ECC status structure.

 *

 * Handles ECC correctable and uncorrectable errors.

/**

 * intr_handler - Interrupt Handler for ECC interrupts.

 * @irq:        IRQ number.

 * @dev_id:     Device ID.

 *

 * Return: IRQ_NONE, if interrupt not set or IRQ_HANDLED otherwise.

/**

 * check_errors - Check controller for ECC errors.

 * @mci:	EDAC memory controller instance.

 *

 * Check and post ECC errors. Called by the polling thread.

/**

 * zynq_get_dtype - Return the controller memory width.

 * @base:	DDR memory controller base address.

 *

 * Get the EDAC device type width appropriate for the current controller

 * configuration.

 *

 * Return: a device type width enumeration.

/**

 * zynqmp_get_dtype - Return the controller memory width.

 * @base:	DDR memory controller base address.

 *

 * Get the EDAC device type width appropriate for the current controller

 * configuration.

 *

 * Return: a device type width enumeration.

/**

 * zynq_get_ecc_state - Return the controller ECC enable/disable status.

 * @base:	DDR memory controller base address.

 *

 * Get the ECC enable/disable status of the controller.

 *

 * Return: true if enabled, otherwise false.

/**

 * zynqmp_get_ecc_state - Return the controller ECC enable/disable status.

 * @base:	DDR memory controller base address.

 *

 * Get the ECC enable/disable status for the controller.

 *

 * Return: a ECC status boolean i.e true/false - enabled/disabled.

/**

 * get_memsize - Read the size of the attached memory device.

 *

 * Return: the memory size in bytes.

/**

 * zynq_get_mtype - Return the controller memory type.

 * @base:	Synopsys ECC status structure.

 *

 * Get the EDAC memory type appropriate for the current controller

 * configuration.

 *

 * Return: a memory type enumeration.

/**

 * zynqmp_get_mtype - Returns controller memory type.

 * @base:	Synopsys ECC status structure.

 *

 * Get the EDAC memory type appropriate for the current controller

 * configuration.

 *

 * Return: a memory type enumeration.

/**

 * init_csrows - Initialize the csrow data.

 * @mci:	EDAC memory controller instance.

 *

 * Initialize the chip select rows associated with the EDAC memory

 * controller instance.

/**

 * mc_init - Initialize one driver instance.

 * @mci:	EDAC memory controller instance.

 * @pdev:	platform device.

 *

 * Perform initialization of the EDAC memory controller instance and

 * related driver-private data associated with the memory controller the

 * instance is bound to.

 Initialize controller capabilities and configuration */

 Enable UE/CE Interrupts */

 Disable UE/CE Interrupts */

 end of table */

/**

 * ddr_poison_setup -	Update poison registers.

 * @priv:		DDR memory controller private instance data.

 *

 * Update poison registers as per DDR mapping.

 * Return: none.

/**

 * setup_address_map -	Set Address Map by querying ADDRMAP registers.

 * @priv:		DDR memory controller private instance data.

 *

 * Set Address Map by querying ADDRMAP registers.

 *

 * Return: none.

 CONFIG_EDAC_DEBUG */

/**

 * mc_probe - Check controller and bind driver.

 * @pdev:	platform device.

 *

 * Probe a specific controller instance for binding with the driver.

 *

 * Return: 0 if the controller instance was successfully bound to the

 * driver; otherwise, < 0 on error.

	/*

	 * Start capturing the correctable and uncorrectable errors. A write of

	 * 0 starts the counters.

/**

 * mc_remove - Unbind driver from controller.

 * @pdev:	Platform device.

 *

 * Return: Unconditionally 0

/*

 * edac_mc kernel module

 * (C) 2005, 2006 Linux Networx (http://lnxi.com)

 * This file may be distributed under the terms of the

 * GNU General Public License.

 *

 * Written by Thayne Harbaugh

 * Based on work by Dan Hollis <goemon at anime dot net> and others.

 *	http://www.anime.net/~goemon/linux-ecc/

 *

 * Modified by Dave Peterson and Doug Thompson

 *

 lock to memory controller's control array */

/*

 * Used to lock EDAC MC to just one module, avoiding two drivers e. g.

 *	apei/ghes and i7core_edac to be used at the same time.

 CONFIG_EDAC_DEBUG */

/**

 * edac_align_ptr - Prepares the pointer offsets for a single-shot allocation

 * @p:		pointer to a pointer with the memory offset to be used. At

 *		return, this will be incremented to point to the next offset

 * @size:	Size of the data structure to be reserved

 * @n_elems:	Number of elements that should be reserved

 *

 * If 'size' is a constant, the compiler will optimize this whole function

 * down to either a no-op or the addition of a constant to the value of '*p'.

 *

 * The 'p' pointer is absolutely needed to keep the proper advancing

 * further in memory to the proper offsets when allocating the struct along

 * with its embedded structs, as edac_device_alloc_ctl_info() does it

 * above, for example.

 *

 * At return, the pointer 'p' will be incremented to be used on a next call

 * to this function.

	/*

	 * 'p' can possibly be an unaligned item X such that sizeof(X) is

	 * 'size'.  Adjust 'p' so that its alignment is at least as

	 * stringent as what the compiler would provide for X and return

	 * the aligned result.

	 * Here we assume that the alignment of a "long long" is the most

	 * stringent alignment that the compiler will ever provide by default.

	 * As far as I know, this is a reasonable assumption.

	/*

	 * Alocate and fill the csrow/channels structs

	/*

	 * Allocate and fill the dimm structs

		/*

		 * Copy DIMM location and initialize it.

 Link it to the csrows old API data */

 Increment csrow location */

 Increment dimm location */

	/*

	 * Calculate the total amount of dimms and csrows/cschannels while

	 * in the old API emulation mode

	/* Figure out the offsets of the various items from the start of an mc

	 * structure.  We want the alignment of each item to be at least as

	 * stringent as what the compiler would provide if we could simply

	 * hardcode everything into a single struct.

	/* Adjust pointers so they point within the memory we just allocated

	 * rather than an imaginary chunk of memory located at address 0.

 setup index and various internal pointers */

 Caller must hold mem_ctls_mutex */

/**

 * find_mci_by_dev

 *

 *	scan list of controllers looking for the one that manages

 *	the 'dev' device

 * @dev: pointer to a struct device related with the MCI

/*

 * edac_mc_workq_function

 *	performs the operation scheduled by a workq request

 Queue ourselves again. */

/*

 * edac_mc_reset_delay_period(unsigned long value)

 *

 *	user space has updated our poll period value, need to

 *	reset our workq delays

/* Return 0 on success, 1 on failure.

 * Before calling this function, caller must

 * assign a unique value to mci->mc_idx.

 *

 *	locking model:

 *

 *		called with the mem_ctls_mutex lock held

	/* these are for safe removal of devices from global list while

	 * NMI handlers may be traversing list

 FIXME - should a warning be printed if no error detection? correction? */

 set load time so that error rate can be tracked */

 Report action taken */

 find the requested mci struct in the global list */

 mark MCI offline: */

 remove from sysfs */

 ECC error page was not in our memory. Ignore it. */

 Find the actual page structure then map it and fix */

 Perform architecture specific atomic scrub operation */

 Unmap and complete */

 FIXME - should return -1 */

		/*

			* Some memory controllers (called MCs below) can remap

			* memory so that it is still available at a different

			* address when PCI devices map into memory.

			* MC's that can't do this, lose the memory where PCI

			* devices are mapped. This mapping is MC-dependent

			* and so we call back into the MC driver for it to

			* map the MC page to a physical (CPU) page which can

			* then be mapped to a virtual page - which can then

			* be scrubbed.

 Sanity-check driver-supplied grain value. */

 Report the error via the trace interface */

 Fills the error report buffer */

 need valid strings here for both: */

	/*

	 * Check if the event report is consistent and if the memory location is

	 * known. If it is, the DIMM(s) label info will be filled and the DIMM's

	 * error counters will be incremented.

			/*

			 * Instead of just returning it, let's use what's

			 * known about the error. The increment routines and

			 * the DIMM filter logic will do the right thing by

			 * pointing the likely damaged DIMMs.

	/*

	 * Get the dimm label/grain that applies to the match criteria.

	 * As the error algorithm may not be able to point to just one memory

	 * stick, the logic here will get all possible labels that could

	 * pottentially be affected by the error.

	 * On FB-DIMM memory controllers, for uncorrected errors, it is common

	 * to have only the MC channel and the MC dimm (also called "branch")

	 * but the channel is not known, as the memory is arranged in pairs,

	 * where each memory belongs to a separate channel within the same

	 * branch.

 get the max grain, over the error match range */

		/*

		 * If the error is memory-controller wide, there's no need to

		 * seek for the affected DIMMs because the whole channel/memory

		 * controller/... may be affected. Also, don't show errors for

		 * empty DIMM slots.

		/*

		 * get csrow/channel of the DIMM, in order to allow

		 * incrementing the compat API counters

 Fill the RAM location data */

/*

 * Intel 3200/3210 Memory Controller kernel module

 * Copyright (C) 2008-2009 Akamai Technologies, Inc.

 * Portions by Hitoshi Mitake <h.mitake@gmail.com>.

 *

 * This file may be distributed under the terms of the

 * GNU General Public License.

 Intel 3200 register addresses - device 0 function 0 - DRAM Controller */

 MCH Memory Mapped Register BAR */

 bits 35:14 */

#define I3200_TOM		0xa0	/* Top of Memory (16b)

		 *

		 * 15:10 reserved

		 *  9:0  total populated physical memory

 bits 9:0 */

 64MiB grain */

#define I3200_ERRSTS		0xc8	/* Error Status Register (16b)

		 *

		 * 15    reserved

		 * 14    Isochronous TBWRR Run Behind FIFO Full

		 *       (ITCV)

		 * 13    Isochronous TBWRR Run Behind FIFO Put

		 *       (ITSTV)

		 * 12    reserved

		 * 11    MCH Thermal Sensor Event

		 *       for SMI/SCI/SERR (GTSE)

		 * 10    reserved

		 *  9    LOCK to non-DRAM Memory Flag (LCKF)

		 *  8    reserved

		 *  7    DRAM Throttle Flag (DTF)

		 *  6:2  reserved

		 *  1    Multi-bit DRAM ECC Error Flag (DMERR)

		 *  0    Single-bit DRAM ECC Error Flag (DSERR)

 Intel  MMIO register space - device 0 function 0 - MMR space */

#define I3200_C0DRB	0x200	/* Channel 0 DRAM Rank Boundary (16b x 4)

		 *

		 * 15:10 reserved

		 *  9:0  Channel 0 DRAM Rank Boundary Address

 Channel 1 DRAM Rank Boundary (16b x 4) */

 bits 9:0 */

 64MiB grain */

#define I3200_C0ECCERRLOG	0x280	/* Channel 0 ECC Error Log (64b)

		 *

		 * 63:48 Error Column Address (ERRCOL)

		 * 47:32 Error Row Address (ERRROW)

		 * 31:29 Error Bank Address (ERRBANK)

		 * 28:27 Error Rank Address (ERRRANK)

		 * 26:24 reserved

		 * 23:16 Error Syndrome (ERRSYND)

		 * 15: 2 reserved

		 *    1  Multiple Bit Error Status (MERRSTS)

		 *    0  Correctable Error Status (CERRSTS)

 Chan 1 ECC Error Log (64b) */

 P.95 of spec for details */

 8th byte of CAPID0 */

 check DCD: Dual Channel Disable */

 check if both channels are filled */

	/*

	 * Clear any error bits.

	 * (Yes, we really clear bits by writing 1 to them.)

	/*

	 * This is a mess because there is no atomic way to read all the

	 * registers at once and the registers can transition from CE being

	 * overwritten by UE.

	/*

	 * If the error is the same for both reads then the first set

	 * of reads is valid.  If there is a change then there is a CE

	 * with no info and the second set of reads is valid and

	 * should be UE info.

	/*

	 * The dram rank boundary (DRB) reg values are boundary addresses

	 * for each DRAM rank with a granularity of 64MB.  DRB regs are

	 * cumulative; the last one will contain the total memory

	 * contained in all ranks.

 get this far and it's successful */

 0 terminated list. */

 Ensure that the OPSTATE is set correctly for POLL or NMI */

/*

 * edac_mc kernel module

 * (C) 2005-2007 Linux Networx (http://lnxi.com)

 *

 * This file may be distributed under the terms of the

 * GNU General Public License.

 *

 * Written Doug Thompson <norsk5@xmission.com> www.softwarebitmaker.com

 *

 * (c) 2012-2013 - Mauro Carvalho Chehab

 *	The entire API were re-written, and ported to use struct device

 *

 MC EDAC Controls, setable by module parameter, and sysfs */

 Getter functions for above */

 this is temporary */

 notify edac_mc engine to reset the poll period */

 Parameter declarations for above */

/*

 * various constants for Memory Controllers

/*

 * EDAC sysfs CSROW data structures and methods

/*

 * We need it to avoid namespace conflicts between the legacy API

 * and the per-dimm/per-rank one

 Set of more default csrow<id> attribute show/store functions */

 show/store functions for DIMM Label attributes */

 if field has not been initialized, there is nothing to send */

 show function for dynamic chX_ce_count attribute */

 cwrow<id>/attribute files */

 default attributes of the CSROW<id> object */

/*

 * possible dynamic channel DIMM Label attribute files

 *

 Total possible dynamic DIMM Label attribute file table */

 possible dynamic channel ce_count attribute files */

 Total possible dynamic ce_count attribute file table */

 Only expose populated DIMMs */

	/*

	 * Nothing to do, just unregister sysfs here. The mci

	 * device owns the data and will also release it.

 Create a CSROW object under specifed edac_mc_device */

 Create a CSROW object under specifed edac_mc_device */

/*

 * Per-dimm (or per-rank) devices

 show/store functions for DIMM Label attributes */

 if field has not been initialized, there is nothing to send */

 dimm/rank attribute files */

 attributes of the dimm<id>/rank<id> object */

	/*

	 * Nothing to do, just unregister sysfs here. The mci

	 * device owns the data and will also release it.

 Create a DIMM object under specifed memory controller device */

/*

 * Memory controller device

/* Memory scrubbing interface:

 *

 * A MC driver can limit the scrubbing bandwidth based on the CPU type.

 * Therefore, ->set_sdram_scrub_rate should be made to return the actual

 * bandwidth that is accepted or 0 when scrubbing is to be disabled.

 *

 * Negative value still means that an error has occurred while setting

 * the scrub rate.

/*

 * ->get_sdram_scrub_rate() return value semantics same as above.

 default attribute files for the MCI object */

 default Control file */

 default Attribute files */

 memory scrubber attribute file */

 umode set later in is_visible */

/*

 * Create a new Memory Controller kobject instance,

 *	mc<id> under the 'mc' directory

 *

 * Return:

 *	0	Success

 *	!0	Failure

 get the /sys/devices/system/edac subsys reference */

 no put_device() here, free mci with _edac_mc_free() */

	/*

	 * Create the dimm/rank devices

 Only expose populated DIMMs */

/*

 * remove a Memory Controller instance

 only remove the device, but keep mci */

	/*

	 * There's no container structure here, as this is just the mci

	 * parent device, used to create the /sys/devices/mc sysfs node.

	 * So, there are no attributes on it.

/*

 * Init/exit code for the module. Basically, creates/removes /sys/class/rc

 SPDX-License-Identifier: GPL-2.0

/*

 * EDAC driver for Intel(R) Xeon(R) Skylake processors

 * Copyright (c) 2016, Intel Corporation.

/*

 * Debug macros

 Mask for 2^26 */

 Mask for 2^29 */

/*

 * List of PCI device ids that we need together with some device

 * number and function numbers to tell which memory controller the

 * device belongs to.

 Be sure that the device is enabled */

			/*

			 * one of these devices per core, including cores

			 * that don't exist on this SKU. Ignore any that

			 * read a route table of zero, make sure all the

			 * non-zero values match.

 Only the mcmtr on the first channel is effective */

 Simple sanity check for I/O space or out of range */

 If point to another node, find it and start over */

 which bit used for both socket and channel interleave */

 Must handle channel first, then socket */

 Handle socket then channel. Preserve low bits from original address */

 C10 is autoprecharge, always set */

/*

 * Debug feature.

 * Exercise the address decode logic by writing an address to

 * /sys/kernel/debug/edac/skx_test/addr.

 ADDRV + MemRd + Unknown channel */

 One corrected error */

CONFIG_EDAC_DEBUG*/

/*

 * skx_init:

 *	make sure we are running on the correct cpu model

 *	search for all the devices we need

 *	check which DIMMs are present.

 Ensure that the OPSTATE is set correctly for POLL or NMI */

/*

 * Intel D82875P Memory Controller kernel module

 * (C) 2003 Linux Networx (http://lnxi.com)

 * This file may be distributed under the terms of the

 * GNU General Public License.

 *

 * Written by Thayne Harbaugh

 * Contributors:

 *	Wang Zhenyu at intel.com

 *

 * $Id: edac_i82875p.c,v 1.5.2.11 2005/10/05 00:43:44 dsp_llnl Exp $

 *

 * Note: E7210 appears same as D82875P - zhenyu.z.wang at intel.com

 PCI_DEVICE_ID_INTEL_82875_0 */

 PCI_DEVICE_ID_INTEL_82875_6 */

 four csrows in dual channel, eight in single channel */

 Intel 82875p register addresses - device 0 function 0 - DRAM Controller */

#define I82875P_EAP		0x58	/* Error Address Pointer (32b)

					 *

					 * 31:12 block address

					 * 11:0  reserved

#define I82875P_DERRSYN		0x5c	/* DRAM Error Syndrome (8b)

					 *

					 *  7:0  DRAM ECC Syndrome

#define I82875P_DES		0x5d	/* DRAM Error Status (8b)

					 *

					 *  7:1  reserved

					 *  0    Error channel 0/1

#define I82875P_ERRSTS		0xc8	/* Error Status Register (16b)

					 *

					 * 15:10 reserved

					 *  9    non-DRAM lock error (ndlock)

					 *  8    Sftwr Generated SMI

					 *  7    ECC UE

					 *  6    reserved

					 *  5    MCH detects unimplemented cycle

					 *  4    AGP access outside GA

					 *  3    Invalid AGP access

					 *  2    Invalid GA translation table

					 *  1    Unsupported AGP command

					 *  0    ECC CE

#define I82875P_ERRCMD		0xca	/* Error Command (16b)

					 *

					 * 15:10 reserved

					 *  9    SERR on non-DRAM lock

					 *  8    SERR on ECC UE

					 *  7    SERR on ECC CE

					 *  6    target abort on high exception

					 *  5    detect unimplemented cyc

					 *  4    AGP access outside of GA

					 *  3    SERR on invalid AGP access

					 *  2    invalid translation table

					 *  1    SERR on unsupported AGP command

					 *  0    reserved

 Intel 82875p register addresses - device 6 function 0 - DRAM Controller */

#define I82875P_PCICMD6		0x04	/* PCI Command Register (16b)

					 *

					 * 15:10 reserved

					 *  9    fast back-to-back - ro 0

					 *  8    SERR enable - ro 0

					 *  7    addr/data stepping - ro 0

					 *  6    parity err enable - ro 0

					 *  5    VGA palette snoop - ro 0

					 *  4    mem wr & invalidate - ro 0

					 *  3    special cycle - ro 0

					 *  2    bus master - ro 0

					 *  1    mem access dev6 - 0(dis),1(en)

					 *  0    IO access dev3 - 0(dis),1(en)

#define I82875P_BAR6		0x10	/* Mem Delays Base ADDR Reg (32b)

					 *

					 * 31:12 mem base addr [31:12]

					 * 11:4  address mask - ro 0

					 *  3    prefetchable - ro 0(non),1(pre)

					 *  2:1  mem type - ro 0

					 *  0    mem space - ro 0

 Intel 82875p MMIO register space - device 0 function 0 - MMR space */

 64MiB grain */

#define I82875P_DRB		0x00	/* DRAM Row Boundary (8b x 8)

					 *

					 *  7    reserved

					 *  6:0  64MiB row boundary addr

#define I82875P_DRA		0x10	/* DRAM Row Attribute (4b x 8)

					 *

					 *  7    reserved

					 *  6:4  row attr row 1

					 *  3    reserved

					 *  2:0  row attr row 0

					 *

					 * 000 =  4KiB

					 * 001 =  8KiB

					 * 010 = 16KiB

					 * 011 = 32KiB

#define I82875P_DRC		0x68	/* DRAM Controller Mode (32b)

					 *

					 * 31:30 reserved

					 * 29    init complete

					 * 28:23 reserved

					 * 22:21 nr chan 00=1,01=2

					 * 20    reserved

					 * 19:18 Data Integ Mode 00=none,01=ecc

					 * 17:11 reserved

					 * 10:8  refresh mode

					 *  7    reserved

					 *  6:4  mode select

					 *  3:2  reserved

					 *  1:0  DRAM type 01=DDR

static struct pci_dev *mci_pdev;	/* init dev: in case that AGP code has

					 * already registered driver

	/*

	 * This is a mess because there is no atomic way to read all the

	 * registers at once and the registers can transition from CE being

	 * overwritten by UE.

	/*

	 * If the error is the same then we can for both reads then

	 * the first set of reads is valid.  If there is a change then

	 * there is a CE no info and the second set of reads is valid

	 * and should be UE info.

 Return 0 on success or 1 on failure. */

		/* Intel tells BIOS developers to hide device 6 which

		 * configures the overflow device access containing

		 * the DRBs - this is where we expose device 6.

		 * http://www.x86-secret.com/articles/tweak/pat/patsecrets-2.htm

 cache is irrelevant for PCI bus reads/writes */

 NOTE: the ovrfl proc entry and pci_dev are intentionally left */

 Return 1 if dual channel mode is active.  Else return 0. */

 DRAM Data Integrity Mode 0=none,2=edac */

	/* The dram row boundary (DRB) reg values are boundary address

	 * for each DRAM row with a granularity of 32 or 64MB (single/dual

	 * channel operation).  DRB regs are cumulative; therefore DRB7 will

	 * contain the total memory contained in all eight rows.

 not populated */

 I82875P_EAP has 4KiB reolution */

 clear counters */

	/* Here we assume that we will never see multiple instances of this

	 * type of memory controller.  The ID is therefore hardcoded to 0.

 allocating generic PCI control info */

 get this far and it's successful */

 NOTE: the ovrfl proc entry and pci_dev are intentionally left */

 returns count (>= 0), or negative on error */

CORRECT_BIOS */

 0 terminated list. */

 Ensure that the OPSTATE is set correctly for POLL or NMI */

lnxi.com) Thayne Harbaugh");

 SPDX-License-Identifier: GPL-2.0-only

/* Intel i7 core/Nehalem Memory Controller kernel module

 *

 * This driver supports the memory controllers found on the Intel

 * processor families i7core, i7core 7xx/8xx, i5core, Xeon 35xx,

 * Xeon 55xx and Xeon 56xx also known as Nehalem, Nehalem-EP, Lynnfield

 * and Westmere-EP.

 *

 * Copyright (c) 2009-2010 by:

 *	 Mauro Carvalho Chehab

 *

 * Red Hat Inc. https://www.redhat.com

 *

 * Forked and adapted from the i5400_edac driver

 *

 * Based on the following public Intel datasheets:

 * Intel Core i7 Processor Extreme Edition and Intel Core i7 Processor

 * Datasheet, Volume 2:

 *	http://download.intel.com/design/processor/datashts/320835.pdf

 * Intel Xeon Processor 5500 Series Datasheet Volume 2

 *	http://www.intel.com/Assets/PDF/datasheet/321322.pdf

 * also available at:

 * 	http://www.arrownac.com/manufacturers/intel/s/nehalem/5500-datasheet-v2.pdf

 Static vars */

/*

 * This is used for Nehalem-EP and Nehalem-EX devices, where the non-core

 * registers start at bus 255, and are not reported by BIOS.

 * We currently find devices with only 2 sockets. In order to support more QPI

 * Quick Path Interconnect, just increment this number.

/*

 * Alter this version for the module when modifications are made

/*

 * Debug macros

/*

 * i7core Memory Controller Registers

 OFFSETS for Device 0 Function 0 */

 OFFSETS for Device 3 Function 0 */

/*

 * OFFSETS for Device 3 Function 4, as indicated on Xeon 5500 datasheet:

 * http://www.arrownac.com/manufacturers/intel/s/nehalem/5500-datasheet-v2.pdf

 OFFSETS for Device 3 Function 2, as indicated on Xeon 5500 datasheet */

 OFFSETS for Devices 4,5 and 6 Function 0 */

 OFFSETS for Devices 4,5 and 6 Function 1 */

/*

 * i7core structs

 Max DIMMS per channel */

 Error address mask */

 ECC corrected errors counts per udimm */

 ECC corrected errors counts per rdimm */

 DCLK Frequency used for computing scrub rate */

 Struct to control EDAC polling */

 Memory controller */

 Exists only for RDIMM */

 Channel 0 */

 Channel 1 */

 Channel 2 */

 Generic Non-core registers */

	/*

	 * This is the PCI device on i7core and on Xeon 35xx (8086:2c41)

	 * On Xeon 55xx, however, it has a different id (8086:2c40). So,

	 * the probing code needs to test for the other address in case of

	 * failure of this one

	/*

	 * This is the PCI device has an alternate address on some

	 * processors like Core i7 860

 Memory controller */

 Exists only for RDIMM */

 Channel 0 */

 Channel 1 */

 Channel 2 */

 Generic Non-core registers */

 0 terminated list. */

/*

 *	pci_device_id	table for which devices we are looking for

 0 terminated list. */

/****************************************************************************

			Ancillary status routines

 MC_CONTROL bits */

 MC_STATUS bits */

 MC_MAX_DOD read functions */

/****************************************************************************

			Memory check routines

 Get data from the MC register, function 0 */

 Device 3 function 0 reads */

 FIXME: need to handle the error codes */

 Devices 4-6 function 0 */

 Devices 4-6 function 1 */

 DDR3 has 8 I/O banks */

/****************************************************************************

			Error insertion routines

/* The i7core has independent error injection features per channel.

   However, to have a simpler code, we don't allow enabling error injection

   on more than one channel.

   Also, since a change at an inject parameter will be applied only at enable,

   we're disabling error injection on all write calls to the sysfs nodes that

   controls the error code injection.

/*

 * i7core inject inject.section

 *

 *	accept and store error injection inject.section value

 *	bit 0 - refers to the lower 32-byte half cacheline

 *	bit 1 - refers to the upper 32-byte half cacheline

/*

 * i7core inject.type

 *

 *	accept and store error injection inject.section value

 *	bit 0 - repeat enable - Enable error repetition

 *	bit 1 - inject ECC error

 *	bit 2 - inject parity error

/*

 * i7core_inject_inject.eccmask_store

 *

 * The type of error (UE/CE) will depend on the inject.eccmask value:

 *   Any bits set to a 1 will flip the corresponding ECC bit

 *   Correctable errors can be injected by flipping 1 bit or the bits within

 *   a symbol pair (2 consecutive aligned 8-bit pairs - i.e. 7:0 and 15:8 or

 *   23:16 and 31:24). Flipping bits in two symbol pairs will cause an

 *   uncorrectable error to be injected.

/*

 * i7core_addrmatch

 *

 * The type of error (UE/CE) will depend on the inject.eccmask value:

 *   Any bits set to a 1 will flip the corresponding ECC bit

 *   Correctable errors can be injected by flipping 1 bit or the bits within

 *   a symbol pair (2 consecutive aligned 8-bit pairs - i.e. 7:0 and 15:8 or

 *   23:16 and 31:24). Flipping bits in two symbol pairs will cause an

 *   uncorrectable error to be injected.

/*

 * This routine prepares the Memory Controller for error injection.

 * The error will be injected when some process tries to write to the

 * memory that matches the given criteria.

 * The criteria can be set in terms of a mask where dimm, rank, bank, page

 * and col can be specified.

 * A -1 value for any of the mask items will make the MCU to ignore

 * that matching criteria for error injection.

 *

 * It should be noticed that the error will only happen after a write operation

 * on a memory that matches the condition. if REPEAT_EN is not enabled at

 * inject mask, then it will produce just one error. Otherwise, it will repeat

 * until the injectmask would be cleaned.

 *

 * FIXME: This routine assumes that MAXNUMDIMMS value of MC_MAX_DOD

 *    is reliable enough to check if the MC is using the

 *    three channels. However, this is not clear at the datasheet.

 Sets pvt->inject.dimm mask */

 Sets pvt->inject.rank mask */

 Sets pvt->inject.bank mask */

 Sets pvt->inject.page mask */

 Sets pvt->inject.column mask */

	/*

	 * bit    0: REPEAT_EN

	 * bits 1-2: MASK_HALF_CACHELINE

	 * bit    3: INJECT_ECC

	 * bit    4: INJECT_ADDR_PARITY

 Unlock writes to registers - this register is write only */

	/*

	 * This is something undocumented, based on my tests

	 * Without writing 8 to this register, errors aren't injected. Not sure

	 * why.

/*

 * inject_addrmatch device sysfs struct

/*

 * all_channel_counts sysfs struct

/*

 * inject sysfs attributes

/****************************************************************************

	Device initialization routines: put/get, init/exit

/*

 *	i7core_put_all_devices	'put' all the devices that we have

 *				reserved via 'get'

	/*

	 * On Xeon 55xx, the Intel Quick Path Arch Generic Non-core pci buses

	 * aren't announced by acpi. So, we need to use a legacy scan probing

	 * to detect them

/*

 *	i7core_get_all_devices	Find and perform 'get' operation on the MCH's

 *			device/functions we want to reference for this driver

 *

 *			Need to 'get' device 16 func 1 and func 2

	/*

	 * On Xeon 55xx, the Intel QuickPath Arch Generic Non-core regs

	 * is at addr 8086:2c40, instead of 8086:2c41. So, we need

	 * to probe for the alternate address in case of failure

 pci_get_device will put it */

 pci_get_device will put it */

 End of list, leave */

 Sanity check */

 Be sure that the device is enabled */

	/*

	 * As stated on drivers/pci/search.c, the reference count for

	 * @from is always decremented if it is not %NULL. So, as we need

	 * to get all devices up to null, we need to do a get for the device

 Detect the processor family */

/****************************************************************************

			Error check routines

 Updates CE counters if it is not the first time here */

 Updates CE counters */

 Store the new values */

updated the edac core */

Read DEV 3: FUN 2:  MC_COR_ECC_CNT regs directly*/

if the channel has 3 dimms*/

/* This function is based on the device 3 function 4 registers as described on:

 * Intel Xeon Processor 5500 Series Datasheet Volume 2

 *	http://www.intel.com/Assets/PDF/datasheet/321322.pdf

 * also available at:

 * 	http://www.arrownac.com/manufacturers/intel/s/nehalem/5500-datasheet-v2.pdf

 Corrected test errors */

 Store the new values */

 Updates CE counters if it is not the first time here */

 Updates CE counters */

 Store the new values */

/*

 * According with tables E-11 and E-12 of chapter E.3.3 of Intel 64 and IA-32

 * Architectures Software Developer’s Manual Volume 3B.

 * Nehalem are defined as family 0x06, model 0x1a

 *

 * The MCA registers used here are the following ones:

 *     struct mce field	MCA Register

 *     m->status	MSR_IA32_MC8_STATUS

 *     m->addr		MSR_IA32_MC8_ADDR

 *     m->misc		MSR_IA32_MC8_MISC

 * In the case of Nehalem, the error information is masked at .status and .misc

 * fields

	/*

	 * Call the helper to output message

	 * FIXME: what to do if core_err_cnt > 1? Currently, it generates

	 * only one event

/*

 *	i7core_check_error	Retrieve and process errors reported by the

 *				hardware. Called by the Core module.

	/*

	 * Now, let's increment CE error counts

/*

 * Check that logging is enabled and that this is the right type

 * of error for us to handle.

	/*

	 * Just let mcelog handle it if the error is

	 * outside the memory controller

 Bank 8 registers are the only ones that we know how to handle */

 Advise mcelog that the errors were handled */

/*

 * Decode the DRAM Clock Frequency, be paranoid, make sure that all

 * memory devices show the same speed, and if they don't then consider

 * all speeds to be invalid.

 Check that a DIMM is present */

		/*

		 * Pick the configured speed if it's available, otherwise

		 * pick the DIMM speed, or we don't have a speed.

 First pass, speed was 0 */

 Set speed if a valid speed is read */

 Otherwise we don't have a valid speed */

			/*

			 * If we have a speed, check that all DIMMS are the same

			 * speed, otherwise set the speed as invalid.

/*

 * The default DCLK frequency is used as a fallback if we

 * fail to find anything reliable in the DMI. The value

 * is taken straight from the datasheet.

/*

 * set_sdram_scrub_rate		This routine sets byte/sec bandwidth scrub rate

 *				to hardware according to SCRUBINTERVAL formula

 *				found in datasheet.

 Get data from the MC register, function 2 */

 Prepare to disable petrol scrub */

 Stop the patrol scrub engine */

 Get current status of scrub rate and set bit to disable */

		/*

		 * Translate the desired scrub rate to a register value and

		 * program the corresponding register value.

 Start the patrol scrub engine */

 Get current status of scrub rate and set bit to enable */

 Disable or enable scrubbing */

/*

 * get_sdram_scrub_rate		This routine convert current scrub rate value

 *				into byte/sec bandwidth according to

 *				SCRUBINTERVAL formula found in datasheet.

 Get data from the MC register, function 2 */

 Get current scrub control data */

 Mask highest 8-bits to 0 */

 Calculate scrub rate value into byte/sec bandwidth */

 Unlock writes to pci registers */

 Lock writes to pci registers */

 Disable scrubrate setting */

 Disable EDAC polling */

 Remove MC sysfs nodes */

 allocate a new MC control structure */

 Associates i7core_dev and mci for future usage */

	/*

	 * FIXME: how to handle RDDR3 at MCI level? It is possible to have

	 * Mixed RDDR3/UDDR3 with Nehalem, provided that they are on different

	 * memory channels

 Store pci devices at mci for faster access */

 Get dimm basic config */

 record ptr to the generic device */

 Enable scrubrate setting */

 add this new MC control structure to EDAC's list of MCs */

		/* FIXME: perhaps some code should go here that disables error

		 * reporting if we just enabled it

 Default error mask is any memory */

 allocating generic PCI control info */

 DCLK for scrub rate setting */

/*

 *	i7core_probe	Probe for ONE instance of device to see if it is

 *			present.

 *	return:

 *		0 for FOUND a device

 *		< 0 for error code

 get the pci devices we want to reserve for our use */

	/*

	 * All memory controllers are allocated at the first pass.

	/*

	 * Nehalem-EX uses a different memory controller. However, as the

	 * memory controller is not visible on some Nehalem/Nehalem-EP, we

	 * need to indirectly probe via a X58 PCI device. The same devices

	 * are found on (some) Nehalem-EX. So, on those machines, the

	 * probe routine needs to return -ENODEV, as the actual Memory

	 * Controller registers won't be detected.

/*

 *	i7core_remove	destructor for one instance of device

 *

	/*

	 * we have a trouble here: pdev value for removal will be wrong, since

	 * it will point to the X58 register used to detect that the machine

	 * is a Nehalem or upper design. However, due to the way several PCI

	 * devices are grouped together to provide MC functionality, we need

	 * to use a different method for releasing the devices

 Release PCI resources */

/*

 *	i7core_driver	pci_driver structure for this module

 *

/*

 *	i7core_init		Module entry function

 *			Try to initialize this module for its devices

 Ensure that the OPSTATE is set correctly for POLL or NMI */

/*

 *	i7core_exit()	Module exit function

 *			Unregister the driver

www.redhat.com)");

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.

 Registers Offset */

 Registers Fields */

	/*

	 * In case both interrupts (ue/ce) are to be found, use interrupt mode.

	 * In case none of the interrupt are foud, use polling mode.

	 * In case only one interrupt is found, use interrupt mode for it but

	 * keep polling mode enable for the other.

/*

 * Freescale Memory Controller kernel module

 *

 * Support Power-based SoCs including MPC85xx, MPC86xx, MPC83xx and

 * ARM-based Layerscape SoCs including LS2xxx and LS1021A. Originally

 * split out from mpc85xx_edac EDAC driver.

 *

 * Parts Copyrighted (c) 2013 by Freescale Semiconductor, Inc.

 *

 * Author: Dave Jiang <djiang@mvista.com>

 *

 * 2006-2007 (c) MontaVista Software, Inc. This file is licensed under

 * the terms of the GNU General Public License version 2. This program

 * is licensed "as is" without any warranty of any kind, whether express

 * or implied.

*********************** MC SYSFS parts ***********************************/

 CONFIG_EDAC_DEBUG */

*************************** MC Err device ***************************/

/*

 * Taken from table 8-55 in the MPC8641 User's Manual and/or 9-61 in the

 * MPC8572 User's Manual.  Each line represents a syndrome bit column as a

 * 64-bit value, but split into an upper and lower 32-bit chunk.  The labels

 * below correspond to Freescale's manuals.

 MSB           LSB */

 [0:31]    [32:63] */

 Syndrome bit 7 */

 Syndrome bit 0 */

/*

 * Calculate the correct ECC value for a 64-bit value specified by high:low

/*

 * Create the syndrome code which is generated if the data line specified by

 * 'bit' failed.  Eg generate an 8-bit codes seen in Table 8-55 in the MPC8641

 * User's Manual and 9-61 in the MPC8572 User's Manual.

	/*

	 * Cycle through the upper or lower 32-bit portion of each value in

	 * ecc_table depending on if 'bit' is in the upper or lower half of

	 * 64-bit data.

/*

 * Decode data and ecc syndrome to determine what went wrong

 * Note: This can only decode single-bit errors

	/*

	 * Calculate the ECC of the captured data and XOR it with the captured

	 * ECC to find an ECC syndrome value we can search for

 Check if a data line is stuck... */

 If data is correct, check ECC bits for errors... */

 no more processing if not ECC bit errors */

 Mask off appropriate bits of syndrome based on bus width */

	/*

	 * Analyze single-bit errors on 64-bit wide buses

	 * TODO: Add support for 32-bit wide buses

 we are out of range */

 not populated */

	/*

	 * Get the endianness of DDR controller registers.

	 * Default is big endian.

 no ECC */

 store the original error disable bits */

 clear all error bits */

 store the original error management threshold */

 set threshold to 1 error per interrupt */

 register interrupts */

/*

 * EDAC PCI component

 *

 * Author: Dave Jiang <djiang@mvista.com>

 *

 * 2007 (c) MontaVista Software, Inc. This file is licensed under

 * the terms of the GNU General Public License version 2. This program

 * is licensed "as is" without any warranty of any kind, whether express

 * or implied.

 *

 Alloc the needed control struct memory */

 Now much private space */

/*

 * find_edac_pci_by_dev()

 * 	scans the edac_pci list for a specific 'struct device *'

 *

 *	return NULL if not found, or return control struct pointer

/*

 * add_edac_pci_to_global_list

 * 	Before calling this function, caller must assign a unique value to

 * 	edac_dev->pci_idx.

 * 	Return:

 * 		0 on success

 * 		1 on failure

 Determine if already on the list */

 Insert in ascending order by 'pci_idx', so find position */

/*

 * del_edac_pci_from_global_list

 *

 *	remove the PCI control struct from the global list

	/* these are for safe removal of devices from global list while

	 * NMI handlers may be traversing list

/*

 * edac_pci_workq_function()

 *

 * 	periodic function that performs the operation

 *	scheduled by a workq request, for a given PCI control struct

 if we are on a one second period, then use round */

 error unwind stack */

	/* ensure the control struct is on the global list

	 * if not, then leave

/*

 * edac_pci_generic_check

 *

 *	a Generic parity check API

 free running instance index counter */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2008 Nuovation System Designs, LLC

 *   Grant Erickson <gerickson@nuovations.com>

/*

 * This file implements a driver for monitoring and handling events

 * associated with the IMB DDR2 ECC controller found in the AMCC/IBM

 * 405EX[r], 440SP, 440SPe, 460EX, 460GT and 460SX.

 *

 * As realized in the 405EX[r], this controller features:

 *

 *   - Support for registered- and non-registered DDR1 and DDR2 memory.

 *   - 32-bit or 16-bit memory interface with optional ECC.

 *

 *     o ECC support includes:

 *

 *       - 4-bit SEC/DED

 *       - Aligned-nibble error detect

 *       - Bypass mode

 *

 *   - Two (2) memory banks/ranks.

 *   - Up to 1 GiB per bank/rank in 32-bit mode and up to 512 MiB per

 *     bank/rank in 16-bit mode.

 *

 * As realized in the 440SP and 440SPe, this controller changes/adds:

 *

 *   - 64-bit or 32-bit memory interface with optional ECC.

 *

 *     o ECC support includes:

 *

 *       - 8-bit SEC/DED

 *       - Aligned-nibble error detect

 *       - Bypass mode

 *

 *   - Up to 4 GiB per bank/rank in 64-bit mode and up to 2 GiB

 *     per bank/rank in 32-bit mode.

 *

 * As realized in the 460EX and 460GT, this controller changes/adds:

 *

 *   - 64-bit or 32-bit memory interface with optional ECC.

 *

 *     o ECC support includes:

 *

 *       - 8-bit SEC/DED

 *       - Aligned-nibble error detect

 *       - Bypass mode

 *

 *   - Four (4) memory banks/ranks.

 *   - Up to 16 GiB per bank/rank in 64-bit mode and up to 8 GiB

 *     per bank/rank in 32-bit mode.

 *

 * At present, this driver has ONLY been tested against the controller

 * realization in the 405EX[r] on the AMCC Kilauea and Haleakala

 * boards (256 MiB w/o ECC memory soldered onto the board) and a

 * proprietary board based on those designs (128 MiB ECC memory, also

 * soldered onto the board).

 *

 * Dynamic feature detection and handling needs to be added for the

 * other realizations of this controller listed above.

 *

 * Eventually, this driver will likely be adapted to the above variant

 * realizations of this controller as well as broken apart to handle

 * the other known ECC-capable controllers prevalent in other 4xx

 * processors:

 *

 *   - IBM SDRAM (405GP, 405CR and 405EP) "ibm,sdram-4xx"

 *   - IBM DDR1 (440GP, 440GX, 440EP and 440GR) "ibm,sdram-4xx-ddr"

 *   - Denali DDR1/DDR2 (440EPX and 440GRX) "denali,sdram-4xx-ddr2"

 *

 * For this controller, unfortunately, correctable errors report

 * nothing more than the beat/cycle and byte/lane the correction

 * occurred on and the check bit group that covered the error.

 *

 * In contrast, uncorrectable errors also report the failing address,

 * the bus master and the transaction direction (i.e. read or write)

 *

 * Regardless of whether the error is a CE or a UE, we report the

 * following pieces of information in the driver-unique message to the

 * EDAC subsystem:

 *

 *   - Device tree path

 *   - Bank(s)

 *   - Check bit error group

 *   - Beat(s)/lane(s)

 Preprocessor Definitions */

/*

 * Kernel logging without an EDAC instance

/*

 * Kernel logging with an EDAC instance

/*

 * Macros to convert bank configuration size enumerations into MiB and

 * page values.

/*

 * The ibm,sdram-4xx-ddr2 Device Control Registers (DCRs) are

 * indirectly accessed and have a base and length defined by the

 * device tree. The base can be anything; however, we expect the

 * length to be precisely two registers, the first for the address

 * window and the second for the data window.

/*

 * Device tree interrupt indices

 Double-bit Error Detect */

 Single-bit Error Correct */

 Type Definitions */

/*

 * PPC4xx SDRAM memory controller private instance data

 Indirect DCR address/data window mapping */

 Single-bit correctable error IRQ assigned */

 Double-bit detectable error IRQ assigned */

/*

 * Various status data gathered and manipulated when checking and

 * reporting ECC status.

 Function Prototypes */

 Global Variables */

/*

 * Device tree node type and compatible tuples this driver can match

 * on.

/*

 * TODO: The row and channel parameters likely need to be dynamically

 * set based on the aforementioned variant controller realizations.

/*

 * Strings associated with PLB master IDs capable of being posted in

 * SDRAM_BESR or SDRAM_WMIRQ on uncorrectable ECC errors.

/**

 * mfsdram - read and return controller register data

 * @dcr_host: A pointer to the DCR mapping.

 * @idcr_n: The indirect DCR register to read.

 *

 * This routine reads and returns the data associated with the

 * controller's specified indirect DCR register.

 *

 * Returns the read data.

/**

 * mtsdram - write controller register data

 * @dcr_host: A pointer to the DCR mapping.

 * @idcr_n: The indirect DCR register to write.

 * @value: The data to write.

 *

 * This routine writes the provided data to the controller's specified

 * indirect DCR register.

/**

 * ppc4xx_edac_check_bank_error - check a bank for an ECC bank error

 * @status: A pointer to the ECC status structure to check for an

 *          ECC bank error.

 * @bank: The bank to check for an ECC error.

 *

 * This routine determines whether the specified bank has an ECC

 * error.

 *

 * Returns true if the specified bank has an ECC error; otherwise,

 * false.

/**

 * ppc4xx_edac_generate_bank_message - generate interpretted bank status message

 * @mci: A pointer to the EDAC memory controller instance associated

 *       with the bank message being generated.

 * @status: A pointer to the ECC status structure to generate the

 *          message from.

 * @buffer: A pointer to the buffer in which to generate the

 *          message.

 * @size: The size, in bytes, of space available in buffer.

 *

 * This routine generates to the provided buffer the portion of the

 * driver-unique report message associated with the ECCESS[BKNER]

 * field of the specified ECC status.

 *

 * Returns the number of characters generated on success; otherwise, <

 * 0 on error.

/**

 * ppc4xx_edac_generate_checkbit_message - generate interpretted checkbit message

 * @mci: A pointer to the EDAC memory controller instance associated

 *       with the checkbit message being generated.

 * @status: A pointer to the ECC status structure to generate the

 *          message from.

 * @buffer: A pointer to the buffer in which to generate the

 *          message.

 * @size: The size, in bytes, of space available in buffer.

 *

 * This routine generates to the provided buffer the portion of the

 * driver-unique report message associated with the ECCESS[CKBER]

 * field of the specified ECC status.

 *

 * Returns the number of characters generated on success; otherwise, <

 * 0 on error.

/**

 * ppc4xx_edac_generate_lane_message - generate interpretted byte lane message

 * @mci: A pointer to the EDAC memory controller instance associated

 *       with the byte lane message being generated.

 * @status: A pointer to the ECC status structure to generate the

 *          message from.

 * @buffer: A pointer to the buffer in which to generate the

 *          message.

 * @size: The size, in bytes, of space available in buffer.

 *

 * This routine generates to the provided buffer the portion of the

 * driver-unique report message associated with the ECCESS[BNCE]

 * field of the specified ECC status.

 *

 * Returns the number of characters generated on success; otherwise, <

 * 0 on error.

/**

 * ppc4xx_edac_generate_ecc_message - generate interpretted ECC status message

 * @mci: A pointer to the EDAC memory controller instance associated

 *       with the ECCES message being generated.

 * @status: A pointer to the ECC status structure to generate the

 *          message from.

 * @buffer: A pointer to the buffer in which to generate the

 *          message.

 * @size: The size, in bytes, of space available in buffer.

 *

 * This routine generates to the provided buffer the portion of the

 * driver-unique report message associated with the ECCESS register of

 * the specified ECC status.

 *

 * Returns the number of characters generated on success; otherwise, <

 * 0 on error.

/**

 * ppc4xx_edac_generate_plb_message - generate interpretted PLB status message

 * @mci: A pointer to the EDAC memory controller instance associated

 *       with the PLB message being generated.

 * @status: A pointer to the ECC status structure to generate the

 *          message from.

 * @buffer: A pointer to the buffer in which to generate the

 *          message.

 * @size: The size, in bytes, of space available in buffer.

 *

 * This routine generates to the provided buffer the portion of the

 * driver-unique report message associated with the PLB-related BESR

 * and/or WMIRQ registers of the specified ECC status.

 *

 * Returns the number of characters generated on success; otherwise, <

 * 0 on error.

/**

 * ppc4xx_edac_generate_message - generate interpretted status message

 * @mci: A pointer to the EDAC memory controller instance associated

 *       with the driver-unique message being generated.

 * @status: A pointer to the ECC status structure to generate the

 *          message from.

 * @buffer: A pointer to the buffer in which to generate the

 *          message.

 * @size: The size, in bytes, of space available in buffer.

 *

 * This routine generates to the provided buffer the driver-unique

 * EDAC report message from the specified ECC status.

/**

 * ppc4xx_ecc_dump_status - dump controller ECC status registers

 * @mci: A pointer to the EDAC memory controller instance

 *       associated with the status being dumped.

 * @status: A pointer to the ECC status structure to generate the

 *          dump from.

 *

 * This routine dumps to the kernel log buffer the raw and

 * interpretted specified ECC status.

 DEBUG */

/**

 * ppc4xx_ecc_get_status - get controller ECC status

 * @mci: A pointer to the EDAC memory controller instance

 *       associated with the status being retrieved.

 * @status: A pointer to the ECC status structure to populate the

 *          ECC status with.

 *

 * This routine reads and masks, as appropriate, all the relevant

 * status registers that deal with ibm,sdram-4xx-ddr2 ECC errors.

 * While we read all of them, for correctable errors, we only expect

 * to deal with ECCES. For uncorrectable errors, we expect to deal

 * with all of them.

/**

 * ppc4xx_ecc_clear_status - clear controller ECC status

 * @mci: A pointer to the EDAC memory controller instance

 *       associated with the status being cleared.

 * @status: A pointer to the ECC status structure containing the

 *          values to write to clear the ECC status.

 *

 * This routine clears--by writing the masked (as appropriate) status

 * values back to--the status registers that deal with

 * ibm,sdram-4xx-ddr2 ECC errors.

/**

 * ppc4xx_edac_handle_ce - handle controller correctable ECC error (CE)

 * @mci: A pointer to the EDAC memory controller instance

 *       associated with the correctable error being handled and reported.

 * @status: A pointer to the ECC status structure associated with

 *          the correctable error being handled and reported.

 *

 * This routine handles an ibm,sdram-4xx-ddr2 controller ECC

 * correctable error. Per the aforementioned discussion, there's not

 * enough status available to use the full EDAC correctable error

 * interface, so we just pass driver-unique message to the "no info"

 * interface.

/**

 * ppc4xx_edac_handle_ue - handle controller uncorrectable ECC error (UE)

 * @mci: A pointer to the EDAC memory controller instance

 *       associated with the uncorrectable error being handled and

 *       reported.

 * @status: A pointer to the ECC status structure associated with

 *          the uncorrectable error being handled and reported.

 *

 * This routine handles an ibm,sdram-4xx-ddr2 controller ECC

 * uncorrectable error.

/**

 * ppc4xx_edac_check - check controller for ECC errors

 * @mci: A pointer to the EDAC memory controller instance

 *       associated with the ibm,sdram-4xx-ddr2 controller being

 *       checked.

 *

 * This routine is used to check and post ECC errors and is called by

 * both the EDAC polling thread and this driver's CE and UE interrupt

 * handler.

/**

 * ppc4xx_edac_isr - SEC (CE) and DED (UE) interrupt service routine

 * @irq:    The virtual interrupt number being serviced.

 * @dev_id: A pointer to the EDAC memory controller instance

 *          associated with the interrupt being handled.

 *

 * This routine implements the interrupt handler for both correctable

 * (CE) and uncorrectable (UE) ECC errors for the ibm,sdram-4xx-ddr2

 * controller. It simply calls through to the same routine used during

 * polling to check, report and clear the ECC status.

 *

 * Unconditionally returns IRQ_HANDLED.

/**

 * ppc4xx_edac_get_dtype - return the controller memory width

 * @mcopt1: The 32-bit Memory Controller Option 1 register value

 *          currently set for the controller, from which the width

 *          is derived.

 *

 * This routine returns the EDAC device type width appropriate for the

 * current controller configuration.

 *

 * TODO: This needs to be conditioned dynamically through feature

 * flags or some such when other controller variants are supported as

 * the 405EX[r] is 16-/32-bit and the others are 32-/64-bit with the

 * 16- and 64-bit field definition/value/enumeration (b1) overloaded

 * among them.

 *

 * Returns a device type width enumeration.

/**

 * ppc4xx_edac_get_mtype - return controller memory type

 * @mcopt1: The 32-bit Memory Controller Option 1 register value

 *          currently set for the controller, from which the memory type

 *          is derived.

 *

 * This routine returns the EDAC memory type appropriate for the

 * current controller configuration.

 *

 * Returns a memory type enumeration.

/**

 * ppc4xx_edac_init_csrows - initialize driver instance rows

 * @mci: A pointer to the EDAC memory controller instance

 *       associated with the ibm,sdram-4xx-ddr2 controller for which

 *       the csrows (i.e. banks/ranks) are being initialized.

 * @mcopt1: The 32-bit Memory Controller Option 1 register value

 *          currently set for the controller, from which bank width

 *          and memory typ information is derived.

 *

 * This routine initializes the virtual "chip select rows" associated

 * with the EDAC memory controller instance. An ibm,sdram-4xx-ddr2

 * controller bank/rank is mapped to a row.

 *

 * Returns 0 if OK; otherwise, -EINVAL if the memory bank size

 * configuration cannot be determined.

 Establish the memory type and width */

 Establish EDAC mode */

	/*

	 * Initialize each chip select row structure which correspond

	 * 1:1 with a controller bank/rank.

		/*

		 * Get the configuration settings for this

		 * row/bank/rank and skip disabled banks.

 Map the bank configuration size setting to pages. */

		/*

		 * It's unclear exactly what grain should be set to

		 * here. The SDRAM_ECCES register allows resolution of

		 * an error down to a nibble which would potentially

		 * argue for a grain of '1' byte, even though we only

		 * know the associated address for uncorrectable

		 * errors. This value is not used at present for

		 * anything other than error reporting so getting it

		 * wrong should be of little consequence. Other

		 * possible values would be the PLB width (16), the

		 * page size (PAGE_SIZE) or the memory width (2 or 4).

/**

 * ppc4xx_edac_mc_init - initialize driver instance

 * @mci: A pointer to the EDAC memory controller instance being

 *       initialized.

 * @op: A pointer to the OpenFirmware device tree node associated

 *      with the controller this EDAC instance is bound to.

 * @dcr_host: A pointer to the DCR data containing the DCR mapping

 *            for this controller instance.

 * @mcopt1: The 32-bit Memory Controller Option 1 register value

 *          currently set for the controller, from which ECC capabilities

 *          and scrub mode are derived.

 *

 * This routine performs initialization of the EDAC memory controller

 * instance and related driver-private data associated with the

 * ibm,sdram-4xx-ddr2 memory controller the instance is bound to.

 *

 * Returns 0 if OK; otherwise, < 0 on error.

 Initial driver pointers and private data */

 Initialize controller capabilities and configuration */

	/*

	 * Update the actual capabilites based on the MCOPT1[MCHK]

	 * settings. Scrubbing is only useful if reporting is enabled.

 Initialize strings */

 Initialize callbacks */

 Initialize chip select rows */

/**

 * ppc4xx_edac_register_irq - setup and register controller interrupts

 * @op: A pointer to the OpenFirmware device tree node associated

 *      with the controller this EDAC instance is bound to.

 * @mci: A pointer to the EDAC memory controller instance

 *       associated with the ibm,sdram-4xx-ddr2 controller for which

 *       interrupts are being registered.

 *

 * This routine parses the correctable (CE) and uncorrectable error (UE)

 * interrupts from the device tree node and maps and assigns them to

 * the associated EDAC memory controller instance.

 *

 * Returns 0 if OK; otherwise, -ENODEV if the interrupts could not be

 * mapped and assigned.

/**

 * ppc4xx_edac_map_dcrs - locate and map controller registers

 * @np: A pointer to the device tree node containing the DCR

 *      resources to map.

 * @dcr_host: A pointer to the DCR data to populate with the

 *            DCR mapping.

 *

 * This routine attempts to locate in the device tree and map the DCR

 * register resources associated with the controller's indirect DCR

 * address and data windows.

 *

 * Returns 0 if the DCRs were successfully mapped; otherwise, < 0 on

 * error.

 Get the DCR resource extent and sanity check the values. */

  Attempt to map the DCR extent. */

/**

 * ppc4xx_edac_probe - check controller and bind driver

 * @op: A pointer to the OpenFirmware device tree node associated

 *      with the controller being probed for driver binding.

 *

 * This routine probes a specific ibm,sdram-4xx-ddr2 controller

 * instance for binding with the driver.

 *

 * Returns 0 if the controller instance was successfully bound to the

 * driver; otherwise, < 0 on error.

	/*

	 * At this point, we only support the controller realized on

	 * the AMCC PPC 405EX[r]. Reject anything else.

	/*

	 * Next, get the DCR property and attempt to map it so that we

	 * can probe the controller.

	/*

	 * First determine whether ECC is enabled at all. If not,

	 * there is no useful checking or monitoring that can be done

	 * for this controller.

	/*

	 * At this point, we know ECC is enabled, allocate an EDAC

	 * controller instance and perform the appropriate

	 * initialization.

	/*

	 * We have a valid, initialized EDAC instance bound to the

	 * controller. Attempt to register it with the EDAC subsystem

	 * and, if necessary, register interrupts.

/**

 * ppc4xx_edac_remove - unbind driver from controller

 * @op: A pointer to the OpenFirmware device tree node associated

 *      with the controller this EDAC instance is to be unbound/removed

 *      from.

 *

 * This routine unbinds the EDAC memory controller instance associated

 * with the specified ibm,sdram-4xx-ddr2 controller described by the

 * OpenFirmware device tree node passed as a parameter.

 *

 * Unconditionally returns 0.

/**

 * ppc4xx_edac_opstate_init - initialize EDAC reporting method

 *

 * This routine ensures that the EDAC memory controller reporting

 * method is mapped to a sane value as the EDAC core defines the value

 * to EDAC_OPSTATE_INVAL by default. We don't call the global

 * opstate_init as that defaults to polling and we want interrupt as

 * the default.

/**

 * ppc4xx_edac_init - driver/module insertion entry point

 *

 * This routine is the driver/module insertion entry point. It

 * initializes the EDAC memory controller reporting state and

 * registers the driver as an OpenFirmware device tree platform

 * driver.

/**

 * ppc4xx_edac_exit - driver/module removal entry point

 *

 * This routine is the driver/module removal entry point. It

 * unregisters the driver as an OpenFirmware device tree platform

 * driver.

/*

 * Intel 82860 Memory Controller kernel module

 * (C) 2005 Red Hat (http://www.redhat.com)

 * This file may be distributed under the terms of the

 * GNU General Public License.

 *

 * Written by Ben Woodard <woodard@redhat.com>

 * shamelessly copied from and based upon the edac_i82875 driver

 * by Thayne Harbaugh of Linux Networx. (http://lnxi.com)

 PCI_DEVICE_ID_INTEL_82860_0 */

static struct pci_dev *mci_pdev;	/* init dev: in case that AGP code

					 * has already registered driver

	/*

	 * This is a mess because there is no atomic way to read all the

	 * registers at once and the registers can transition from CE being

	 * overwritten by UE.

	/*

	 * If the error is the same for both reads then the first set of reads

	 * is valid.  If there is a change then there is a CE no info and the

	 * second set of reads is valid and should be UE info.

 DRAM Data Integrity Mode 0=none, 2=edac */

	/* The group row boundary (GRA) reg values are boundary address

	 * for each DRAM row with a granularity of 16MB.  GRA regs are

	 * cumulative; therefore GRA15 will contain the total memory contained

	 * in all eight rows.

 not populated */

 I82860_EAP has 4KiB reolution */

	/*

	 * RDRAM has channels but these don't map onto the csrow abstraction.

	 * According with the datasheet, there are 2 Rambus channels, supporting

	 * up to 16 direct RDRAM devices.

	 * The device groups from the GRA registers seem to map reasonably

	 * well onto the notion of a chip select row.

	 * There are 16 GRA registers and since the name is associated with

	 * the channel and the GRA registers map to physical devices so we are

	 * going to make 1 channel for group.

 I"m not sure about this but I think that all RDRAM is SECDED */

 clear counters */

	/* Here we assume that we will never see multiple instances of this

	 * type of memory controller.  The ID is therefore hardcoded to 0.

 allocating generic PCI control info */

 get this far and it's successful */

 returns count (>= 0), or negative on error */

 0 terminated list. */

 Ensure that the OPSTATE is set correctly for POLL or NMI */

www.redhat.com) "

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Intel 7300 class Memory Controllers kernel module (Clarksboro)

 *

 * Copyright (c) 2010 by:

 *	 Mauro Carvalho Chehab

 *

 * Red Hat Inc. https://www.redhat.com

 *

 * Intel 7300 Chipset Memory Controller Hub (MCH) - Datasheet

 *	http://www.intel.com/Assets/PDF/datasheet/318082.pdf

 *

 * TODO: The chipset allow checking for PCI Express errors also. Currently,

 *	 the driver covers only memory error errors

 *

 * This driver uses "csrows" EDAC attribute to represent DIMM slot#

/*

 * Alter this version for the I7300 module when modifications are made

/***********************************************

 * i7300 Limit constants Structs and static vars

/*

 * Memory topology is organized as:

 *	Branch 0 - 2 channels: channels 0 and 1 (FDB0 PCI dev 21.0)

 *	Branch 1 - 2 channels: channels 2 and 3 (FDB1 PCI dev 22.0)

 * Each channel can have to 8 DIMM sets (called as SLOTS)

 * Slots should generally be filled in pairs

 *	Except on Single Channel mode of operation

 *		just slot 0/channel0 filled on this mode

 *	On normal operation mode, the two channels on a branch should be

 *		filled together for the same SLOT#

 * When in mirrored mode, Branch 1 replicate memory at Branch 0, so, the four

 *		channels on both branches should be filled

 Limits for i7300 */

 Device name and register DID (Device ID) */

 name for this device */

 DID for the branchmap,control */

 Table of devices attributes supported by this driver */

 size, 0 means not present  */

 driver private data structure */

 16.0 */

 16.1 */

 16.2 */

 21.0  and 22.0 */

 top of low memory */

 AMB BAR */

 Report several settings */

 Memory Interleave Reg*/

 Memory Technlogy Reg */

 AMB present regs */

 DIMM information matrix, allocating architecture maximums */

 Temporary buffer for use when preparing error messages */

 FIXME: Why do we need to have this static? */

/***************************************************

 * i7300 Register definitions for memory enumeration

/*

 * Device 16,

 * Function 0: System Address (not documented)

 * Function 1: Memory Branch Map, Control, Errors Register

 OFFSETS for Function 0 */

 AMB Mem Mapped Reg Region Base */

 Max Channel Number */

 Max DIMM PER Channel Number */

 OFFSETS for Function 1 */

/*

 * Note: Other Intel EDAC drivers use AMBPRESENT to identify if the available

 * memory. From datasheet item 7.3.1 (FB-DIMM technology & organization), it

 * seems that we cannot use this information directly for the same usage.

 * Each memory slot may have up to 2 AMB interfaces, one for income and another

 * for outcome interface to the next slot.

 * For now, the driver just stores the AMB present registers, but rely only at

 * the MTR info to detect memory.

 * Datasheet is also not clear about how to map each AMBPRESENT registers to

 * one of the 4 available channels.

/*

 * Defines to extract the vaious fields from the

 *	MTRx - Memory Technology Registers

/************************************************

 * i7300 Register definitions for error detection

/*

 * Device 16.1: FBD Error Registers

/*

 * Device 16.2: Global Error Registers

/********************************************

 * i7300 Functions related to error detection

/**

 * get_err_from_table() - Gets the error message from a table

 * @table:	table name (array of char *)

 * @size:	number of elements at the table

 * @pos:	position of the element to be returned

 *

 * This is a small routine that gets the pos-th element of a table. If the

 * element doesn't exist (or it is empty), it returns "reserved".

 * Instead of calling it directly, the better is to call via the macro

 * GET_ERR_FROM_TABLE(), that automatically checks the table size via

 * ARRAY_SIZE() macro

/**

 * i7300_process_error_global() - Retrieve the hardware error information from

 *				  the hardware global error registers and

 *				  sends it to dmesg

 * @mci: struct mem_ctl_info pointer

 read in the 1st FATAL error register */

 Clear the error bit */

 Clear the error bit */

/**

 * i7300_process_fbd_error() - Retrieve the hardware error information from

 *			       the FBD error registers and sends it via

 *			       EDAC error API calls

 * @mci: struct mem_ctl_info pointer

 read in the 1st FATAL error register */

 Clean the error register */

 read in the 1st NON-FATAL error register */

 Second channel ? */

 Clear the error bit */

 Form out message */

/**

 * i7300_check_error() - Calls the error checking subroutines

 * @mci: struct mem_ctl_info pointer

/**

 * i7300_clear_error() - Clears the error registers

 * @mci: struct mem_ctl_info pointer

	/*

	 * All error values are RWC - we need to read and write 1 to the

	 * bit that we want to cleanup

 Clear global error registers */

 Clear FBD error registers */

/**

 * i7300_enable_error_reporting() - Enable the memory reporting logic at the

 *				    hardware

 * @mci: struct mem_ctl_info pointer

 Read the FBD Error Mask Register */

 Enable with a '0' */

/************************************************

 * i7300 Functions related to memory enumberation

/**

 * decode_mtr() - Decodes the MTR descriptor, filling the edac structs

 * @pvt: pointer to the private data struct used by i7300 driver

 * @slot: DIMM slot (0 to 7)

 * @ch: Channel number within the branch (0 or 1)

 * @branch: Branch number (0 or 1)

 * @dinfo: Pointer to DIMM info where dimm size is stored

 * @dimm: Pointer to the struct dimm_info that corresponds to that element

 Determine if there is a DIMM present in this DIMM slot */

	/* Start with the number of bits for a Bank

 Add thenumber of ROW bits */

 add the number of COLUMN bits */

 add the number of RANK bits */

 add 64 bits per DIMM */

 divide by 2^^20 */

 8 bits per bytes */

	/*

	 * The type of error detection actually depends of the

	 * mode of operation. When it is just one single memory chip, at

	 * socket 0, channel 0, it uses 8-byte-over-32-byte SECDED+ code.

	 * In normal or mirrored mode, it uses Lockstep mode,

	 * with the possibility of using an extended algorithm for x8 memories

	 * See datasheet Sections 7.3.6 to 7.3.8

 ask what device type on this row */

/**

 * print_dimm_size() - Prints dump of the memory organization

 * @pvt: pointer to the private data struct used by i7300 driver

 *

 * Useful for debug. If debug is disabled, this routine do nothing

/**

 * i7300_init_csrows() - Initialize the 'csrows' table within

 *			 the mci control structure with the

 *			 addressing of memory.

 * @mci: struct mem_ctl_info pointer

 Get the AMB present registers for the four channels */

 Read and dump branch 0's MTRs */

 Get the set of MTR[0-7] regs by each branch */

 if no DIMMS on this row, continue */

/**

 * decode_mir() - Decodes Memory Interleave Register (MIR) info

 * @mir_no: number of the MIR register to decode

 * @mir: array with the MIR data cached on the driver

/**

 * i7300_get_mc_regs() - Get the contents of the MC enumeration registers

 * @mci: struct mem_ctl_info pointer

 *

 * Data read is cached internally for its usage when needed

 Get the Branch Map regs */

 Get memory controller settings */

 Get Memory Interleave Range registers */

 Decode the MIR regs */

	/* Go and determine the size of each DIMM and place in an

/*************************************************

 * i7300 Functions related to device probe/release

/**

 * i7300_put_devices() - Release the PCI devices

 * @mci: struct mem_ctl_info pointer

 Decrement usage count for devices */

/**

 * i7300_get_devices() - Find and perform 'get' operation on the MCH's

 *			 device/functions we want to reference for this driver

 * @mci: struct mem_ctl_info pointer

 *

 * Access and prepare the several devices for usage:

 * I7300 devices used by this driver:

 *    Device 16, functions 0,1 and 2:	PCI_DEVICE_ID_INTEL_I7300_MCH_ERR

 *    Device 21 function 0:		PCI_DEVICE_ID_INTEL_I7300_MCH_FB0

 *    Device 22 function 0:		PCI_DEVICE_ID_INTEL_I7300_MCH_FB1

 Attempt to 'get' the MCH register we want */

 Store device 16 funcs 1 and 2 */

 At least one device was not found */

/**

 * i7300_init_one() - Probe for one instance of the device

 * @pdev: struct pci_dev pointer

 * @id: struct pci_device_id pointer - currently unused

 wake up device */

 We only are looking for func 0 of the set */

 allocate a new MC control structure */

 record ptr  to the generic device */

 Record this device in our private */

 'get' the pci devices we want to reserve for our use */

 Set the function pointer to an actual operation function */

	/* initialize the MC control structure 'csrows' table

 no csrows found */

 add this new MC control structure to EDAC's list of MCs */

		/* FIXME: perhaps some code should go here that disables error

		 * reporting if we just enabled it

 allocating generic PCI control info */

 Error exit unwinding stack */

/**

 * i7300_remove_one() - Remove the driver

 * @pdev: struct pci_dev pointer

 retrieve references to resources, and free those resources */

/*

 * pci_device_id: table for which devices we are looking for

 *

 * Has only 8086:360c PCI ID

 0 terminated list. */

/*

 * i7300_driver: pci_driver structure for this module

/**

 * i7300_init() - Registers the driver

 Ensure that the OPSTATE is set correctly for POLL or NMI */

/**

 * i7300_init() - Unregisters the driver

www.redhat.com)");

/*

 * This file is subject to the terms and conditions of the GNU General Public

 * License.  See the file "COPYING" in the main directory of this archive

 * for more details.

 *

 * Copyright (C) 2012 Cavium, Inc.

 *

 * Copyright (C) 2009 Wind River Systems,

 *   written by Ralf Baechle <ralf@linux-mips.org>

 'Tags' are block 0, 'Data' is block 1*/

 We poll */

 We poll */

 OCTEON II */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * HID Sensors Driver

 * Copyright (c) 2012, Intel Corporation.

/**

 * struct sensor_hub_data - Hold a instance data for a HID hub device

 * @mutex:		Mutex to serialize synchronous request.

 * @lock:		Spin lock to protect pending request structure.

 * @dyn_callback_list:	Holds callback function

 * @dyn_callback_lock:	spin lock to protect callback list

 * @hid_sensor_hub_client_devs:	Stores all MFD cells for a hub instance.

 * @hid_sensor_client_cnt: Number of MFD cells, (no of sensors attached).

 * @ref_cnt:		Number of MFD clients have opened this device

/**

 * struct hid_sensor_hub_callbacks_list - Stores callback list

 * @list:		list head.

 * @usage_id:		usage id for a physical device.

 * @hsdev:		Stored hid instance for current hub device.

 * @usage_callback:	Stores registered callback functions.

 * @priv:		Private data for a physical device.

	/*

	 * If there is a handler registered for the collection type, then

	 * it will handle all reports for sensors in this collection. If

	 * there is also an individual sensor handler registration, then

	 * we want to make sure that the reports are directed to collection

	 * handler, as this may be a fusion sensor. So add collection handlers

	 * to the beginning of the list, so that they are matched first.

 calculate number of bytes required to read this field */

 Initialize with defaults */

/*

 * Handle raw report as sent by device

 Skip report id */

	/*

	 * Checks if the report descriptor of Thinkpad Helix 2 has a logical

	 * minimum for magnetic flux axis greater than the maximum.

 Sets negative logical minimum for mag x, y and z */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * HID driver for Holtek keyboard

 * Copyright (c) 2012 Tom Harwood

/*

/* Holtek based keyboards (USB ID 04d9:a055) have the following issues:

 * - The report descriptor specifies an excessively large number of consumer

 *   usages (2^15), which is more than HID_MAX_USAGES. This prevents proper

 *   parsing of the report descriptor.

 * - The report descriptor reports on caps/scroll/num lock key presses, but

 *   doesn't have an LED output usage block.

 *

 * The replacement descriptor below fixes the number of consumer usages,

 * and provides an LED output usage block. LED output events are redirected

 * to the boot interface.

 Original report descriptor, with reduced number of consumer usages */

  Usage Page (Desktop),                         */

  Usage (Sys Control),                          */

  Collection (Application),                     */

      Report ID (1),                            */

      Usage Minimum (Sys Power Down),           */

      Usage Maximum (Sys Wake Up),              */

      Logical Minimum (0),                      */

      Logical Maximum (1),                      */

      Report Count (3),                         */

      Report Size (1),                          */

      Input (Variable),                         */

      Report Count (1),                         */

      Report Size (5),                          */

      Input (Constant),                         */

  End Collection,                               */

  Usage Page (Consumer),                        */

  Usage (Consumer Control),                     */

  Collection (Application),                     */

      Report ID (2),                            */

      Usage Minimum (00h),                      */

      Usage Maximum (0x2FFF), previously 0x7FFF */

      Logical Minimum (0),                      */

      Logical Maximum (0x2FFF),previously 0x7FFF*/

      Report Count (1),                         */

      Report Size (16),                         */

      Input,                                    */

  End Collection,                               */

  Usage Page (Desktop),                         */

  Usage (Keyboard),                             */

  Collection (Application),                     */

      Report ID (3),                            */

      Report Count (56),                        */

      Report Size (1),                          */

      Logical Minimum (0),                      */

      Logical Maximum (1),                      */

      Usage Page (Keyboard),                    */

      Usage Minimum (KB Leftcontrol),           */

      Usage Maximum (KB Right GUI),             */

      Usage Minimum (None),                     */

      Usage Maximum (KB Lboxbracket And Lbrace),*/

      Input (Variable),                         */

  End Collection,                               */

  Usage Page (Desktop),                         */

  Usage (Keyboard),                             */

  Collection (Application),                     */

      Report ID (4),                            */

      Report Count (56),                        */

      Report Size (1),                          */

      Logical Minimum (0),                      */

      Logical Maximum (1),                      */

      Usage Page (Keyboard),                    */

      Usage Minimum (KB Rboxbracket And Rbrace),*/

      Usage Maximum (KP Equals),                */

      Input (Variable),                         */

  End Collection                                */

 LED usage for the boot protocol interface */

  Usage Page (Desktop),                         */

  Usage (Keyboard),                             */

  Collection (Application),                     */

      Usage Page (LED),                         */

      Usage Minimum (01h),                      */

      Usage Maximum (03h),                      */

      Logical Minimum (0),                      */

      Logical Maximum (1),                      */

      Report Size (1),                          */

      Report Count (3),                         */

      Output (Variable),                        */

      Report Count (5),                         */

      Output (Constant),                        */

  End Collection                                */

 Locate the boot interface, to receive the LED change events */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  HID driver for PenMount touchscreens

 *

 *  Copyright (c) 2014 Christian Gmeiner <christian.gmeiner <at> gmail.com>

 *

 *  based on hid-penmount copyrighted by

 *    PenMount Touch Solutions <penmount <at> seed.net.tw>

/*

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Roccat Arvo driver for Linux

 *

 * Copyright (c) 2011 Stefan Achatz <erazor_de@users.sourceforge.net>

/*

/*

 * Roccat Arvo is a gamer keyboard with 5 macro keys that can be configured in

 * 5 profiles.

 retval is 1-5 on success, < 0 on error */

 SPDX-License-Identifier: GPL-2.0

/*

 * HID driver for Xiaomi Mi Dual Mode Wireless Mouse Silent Edition

 *

 * Copyright (c) 2021 Ilya Skriblovsky

 Fixed Mi Silent Mouse report descriptor */

 Button's Usage Maximum changed from 3 to 5 to make side buttons work */

  Usage Page (Desktop),               */

  Usage (Mouse),                      */

  Collection (Application),           */

      Report ID (3),                  */

      Usage (Pointer),                */

      Collection (Physical),          */

          Usage Page (Button),        */

          Usage Minimum (01h),        */

 X */ 
          Logical Minimum (0),        */

          Logical Maximum (1),        */

          Report Size (1),            */

          Report Count (5),           */

          Input (Variable),           */

          Report Size (3),            */

          Report Count (1),           */

          Input (Constant),           */

          Usage Page (Desktop),       */

          Usage (X),                  */

          Usage (Y),                  */

          Logical Minimum (-127),     */

          Logical Maximum (127),      */

          Report Size (8),            */

          Report Count (2),           */

          Input (Variable, Relative), */

          Usage (Wheel),              */

          Logical Minimum (-127),     */

          Logical Maximum (127),      */

          Report Size (8),            */

          Report Count (1),           */

          Input (Variable, Relative), */

      End Collection,                 */

  End Collection,                     */

  Usage Page (FF01h),                 */

  Usage (01h),                        */

  Collection (Application),           */

      Report ID (5),                  */

      Usage (05h),                    */

      Logical Minimum (0),            */

      Logical Maximum (255),          */

      Report Size (8),                */

      Report Count (4),               */

      Feature (Variable),             */

  End Collection                      */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  HID driver for some ezkey "special" devices

 *

 *  Copyright (c) 1999 Andreas Gal

 *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>

 *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc

 *  Copyright (c) 2006-2007 Jiri Kosina

 *  Copyright (c) 2008 Jiri Slaby

/*

	/*

	 * this keyboard has a scrollwheel implemented in

	 * totally broken way. We map this usage temporarily

	 * to HWHEEL and handle it in the event quirk handler

 handle the temporary quirky mapping to HWHEEL */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  HID driver for the Prodikeys PC-MIDI Keyboard

 *  providing midi & extra multimedia keys functionality

 *

 *  Copyright (c) 2009 Don Prince <dhprince.devel@yahoo.co.uk>

 *

 *  Controls for Octave Shift Up/Down, Channel, and

 *  Sustain Duration available via sysfs.

/*

 pcmidi device context */

 Output routine for the sysfs channel file */

 Input routine for the sysfs channel file */

 Output routine for the sysfs sustain file */

 Input routine for the sysfs sustain file */

 Output routine for the sysfs octave file */

 Input routine for the sysfs octave file */

 should never get here */

KEY_MAIL or octave down*/

 octave down */

KEY_WWW or sustain*/

 sustain on/off*/

 continue key processing */

 note on */

 1001nnnn */

 force note on */

 note off */

 1000nnnn */

 break keys */

 make keys */

 Fn lock*/

 midi launcher..send a key (qwerty) or not? */

 KEY_MESSENGER or octave up */

 midi keys (qwerty)*/

 midi keyboard (musical)*/

 multimedia/midi keys (qwerty)*/

	/* reassigned functionality for N/A keys

		MY PICTURES =>	KEY_WORDPROCESSOR

		MY MUSIC=>	KEY_SPREADSHEET

 only set up ONCE for interace 1 */

 only set up ONCE for interace 1 */

 only set up midi device ONCE for interace 1 */

 Setup sound card */

 Setup sound device */

 Set up rawmidi */

 create sysfs variables */

 register it */

/*

 * PC-MIDI report descriptor for report id is wrong.

 report 4: was 0x10 report count */

 midi keys (qwerty)*/

 midi keyboard (musical)*/

 extra/midi keys (qwerty)*/

 hid_parse cleared all the quirks */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * MSI GT683R led driver

 *

 * Copyright (c) 2014 Janne Kanniainen <janne.kanniainen@gmail.com>

/*

 * GT683R_LED_OFF: all LEDs are off

 * GT683R_LED_AUDIO: LEDs brightness depends on sound level

 * GT683R_LED_BREATHING: LEDs brightness varies at human breathing rate

 * GT683R_LED_NORMAL: LEDs are fully on when enabled

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Roccat Savu driver for Linux

 *

 * Copyright (c) 2012 Stefan Achatz <erazor_de@users.sourceforge.net>

/*

/* Roccat Savu is a gamer mouse with macro keys that can be configured in

 * 5 profiles.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Roccat common functions for device specific drivers

 *

 * Copyright (c) 2011 Stefan Achatz <erazor_de@users.sourceforge.net>

/*

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Force feedback support for GreenAsia (Product ID 0x12) based devices

 *

 *  The devices are distributed under various names and the same USB device ID

 *  can be used in many game controllers.

 *

 *  0e8f:0012 "GreenAsia Inc.    USB Joystick     "

 *   - tested with MANTA Warior MM816 and SpeedLink Strike2 SL-6635.

 *

 *  Copyright (c) 2008 Lukasz Lubojanski <lukasz@lubojanski.info>

/*

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  HID driver for various devices which are apparently based on the same chipset

 *  from certain vendor which produces chips that contain wrong LogicalMaximum

 *  value in their HID report descriptor. Currently supported devices are:

 *

 *    Ortek PKB-1700

 *    Ortek WKB-2000

 *    iHome IMAC-A210S

 *    Skycable wireless presenter

 *

 *  Copyright (c) 2010 Johnathon Harris <jmharris@gmail.com>

 *  Copyright (c) 2011 Jiri Kosina

/*

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Roccat driver for Linux

 *

 * Copyright (c) 2010 Stefan Achatz <erazor_de@users.sourceforge.net>

/*

/*

 * Module roccat is a char device used to report special events of roccat

 * hardware to userland. These events include requests for on-screen-display of

 * profile or dpi settings or requests for execution of macro sequences that are

 * not stored in device. The information in these events depends on hid device

 * implementation and contains data that is not available in a single hid event

 * or else hidraw could have been used.

 * It is inspired by hidraw, but uses only one circular buffer for all readers.

 should be a power of 2 for performance reason */

 protects modifications of readers list */

	/*

	 * circular_buffer has one writer and multiple readers with their own

	 * read pointers

 protects modifications of devices array */

 no data? */

 wait for data */

 here we either have data or a reason to return if retval is set */

	/*

	 * If report is larger than requested amount of data, rest of report

	 * is lost!

 power on device on adding first reader */

 new reader doesn't get old events */

 removing last reader */

/*

 * roccat_report_event() - output data to readers

 * @minor: minor device number returned by roccat_connect()

 * @data: pointer to data

 *

 * Return value is zero on success, a negative error code on failure.

 *

 * This is called from interrupt handler.

 passing NULL is safe */

		/*

		 * As we already inserted one element, the buffer can't be

		 * empty. If start and end are equal, buffer is full and we

		 * increase start, so that slow reader misses one event, but

		 * gets the newer ones in the right order.

/*

 * roccat_connect() - create a char device for special event output

 * @class: the class thats used to create the device. Meant to hold device

 * specific sysfs attributes.

 * @hid: the hid device the char device should be connected to.

 * @report_size: size of reports

 *

 * Return value is minor device number in Range [0, ROCCAT_MAX_DEVICES] on

 * success, a negative error code on failure.

/* roccat_disconnect() - remove char device from hid device

 * @minor: the minor device number returned by roccat_connect()

 TODO exist maybe not needed */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

*  HID driver for zydacron remote control

*

*  Copyright (c) 2010 Don Prince <dhprince.devel@yahoo.co.uk>

/*

/*

* Zydacron remote control has an invalid HID report descriptor,

* that needs fixing before we can parse it.

 report 2 */

 report 3 */

 report 4 */

 break keys */

 SPDX-License-Identifier: GPL-2.0+

/*

 *  LED & force feedback support for BigBen Interactive

 *

 *  0x146b:0x0902 "Bigben Interactive Bigben Game Pad"

 *  "Kid-friendly Wired Controller" PS3OFMINIPAD SONY

 *  sold for use with the PS3

 *

 *  Copyright (c) 2018 Hanno Zulla <kontakt@hanno.de>

/*

 * The original descriptor for 0x146b:0x0902

 *

 *   0x05, 0x01,        // Usage Page (Generic Desktop Ctrls)

 *   0x09, 0x05,        // Usage (Game Pad)

 *   0xA1, 0x01,        // Collection (Application)

 *   0x15, 0x00,        //   Logical Minimum (0)

 *   0x25, 0x01,        //   Logical Maximum (1)

 *   0x35, 0x00,        //   Physical Minimum (0)

 *   0x45, 0x01,        //   Physical Maximum (1)

 *   0x75, 0x01,        //   Report Size (1)

 *   0x95, 0x0D,        //   Report Count (13)

 *   0x05, 0x09,        //   Usage Page (Button)

 *   0x19, 0x01,        //   Usage Minimum (0x01)

 *   0x29, 0x0D,        //   Usage Maximum (0x0D)

 *   0x81, 0x02,        //   Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)

 *   0x95, 0x03,        //   Report Count (3)

 *   0x81, 0x01,        //   Input (Const,Array,Abs,No Wrap,Linear,Preferred State,No Null Position)

 *   0x05, 0x01,        //   Usage Page (Generic Desktop Ctrls)

 *   0x25, 0x07,        //   Logical Maximum (7)

 *   0x46, 0x3B, 0x01,  //   Physical Maximum (315)

 *   0x75, 0x04,        //   Report Size (4)

 *   0x95, 0x01,        //   Report Count (1)

 *   0x65, 0x14,        //   Unit (System: English Rotation, Length: Centimeter)

 *   0x09, 0x39,        //   Usage (Hat switch)

 *   0x81, 0x42,        //   Input (Data,Var,Abs,No Wrap,Linear,Preferred State,Null State)

 *   0x65, 0x00,        //   Unit (None)

 *   0x95, 0x01,        //   Report Count (1)

 *   0x81, 0x01,        //   Input (Const,Array,Abs,No Wrap,Linear,Preferred State,No Null Position)

 *   0x26, 0xFF, 0x00,  //   Logical Maximum (255)

 *   0x46, 0xFF, 0x00,  //   Physical Maximum (255)

 *   0x09, 0x30,        //   Usage (X)

 *   0x09, 0x31,        //   Usage (Y)

 *   0x09, 0x32,        //   Usage (Z)

 *   0x09, 0x35,        //   Usage (Rz)

 *   0x75, 0x08,        //   Report Size (8)

 *   0x95, 0x04,        //   Report Count (4)

 *   0x81, 0x02,        //   Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)

 *   0x06, 0x00, 0xFF,  //   Usage Page (Vendor Defined 0xFF00)

 *   0x09, 0x20,        //   Usage (0x20)

 *   0x09, 0x21,        //   Usage (0x21)

 *   0x09, 0x22,        //   Usage (0x22)

 *   0x09, 0x23,        //   Usage (0x23)

 *   0x09, 0x24,        //   Usage (0x24)

 *   0x09, 0x25,        //   Usage (0x25)

 *   0x09, 0x26,        //   Usage (0x26)

 *   0x09, 0x27,        //   Usage (0x27)

 *   0x09, 0x28,        //   Usage (0x28)

 *   0x09, 0x29,        //   Usage (0x29)

 *   0x09, 0x2A,        //   Usage (0x2A)

 *   0x09, 0x2B,        //   Usage (0x2B)

 *   0x95, 0x0C,        //   Report Count (12)

 *   0x81, 0x02,        //   Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)

 *   0x0A, 0x21, 0x26,  //   Usage (0x2621)

 *   0x95, 0x08,        //   Report Count (8)

 *   0xB1, 0x02,        //   Feature (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position,Non-volatile)

 *   0x0A, 0x21, 0x26,  //   Usage (0x2621)

 *   0x91, 0x02,        //   Output (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position,Non-volatile)

 *   0x26, 0xFF, 0x03,  //   Logical Maximum (1023)

 *   0x46, 0xFF, 0x03,  //   Physical Maximum (1023)

 *   0x09, 0x2C,        //   Usage (0x2C)

 *   0x09, 0x2D,        //   Usage (0x2D)

 *   0x09, 0x2E,        //   Usage (0x2E)

 *   0x09, 0x2F,        //   Usage (0x2F)

 *   0x75, 0x10,        //   Report Size (16)

 *   0x95, 0x04,        //   Report Count (4)

 *   0x81, 0x02,        //   Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)

 *   0xC0,              // End Collection

/*

 * The fixed descriptor for 0x146b:0x0902

 *

 * - map buttons according to gamepad.rst

 * - assign right stick from Z/Rz to Rx/Ry

 * - map previously unused analog trigger data to Z/RZ

 * - simplify feature and output descriptor

 Usage Page (Generic Desktop Ctrls) */

 Usage (Game Pad) */

 Collection (Application) */

   Logical Minimum (0) */

   Logical Maximum (1) */

   Physical Minimum (0) */

   Physical Maximum (1) */

   Report Size (1) */

   Report Count (13) */

   Usage Page (Button) */

   Usage (BTN_WEST) */

   Usage (BTN_SOUTH) */

   Usage (BTN_EAST) */

   Usage (BTN_NORTH) */

   Usage (BTN_TL) */

   Usage (BTN_TR) */

   Usage (BTN_TL2) */

   Usage (BTN_TR2) */

   Usage (BTN_SELECT) */

   Usage (BTN_START) */

   Usage (BTN_THUMBL) */

   Usage (BTN_THUMBR) */

   Usage (BTN_MODE) */

   Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position) */

   Report Size (1) */

   Report Count (3) */

   Input (Const,Array,Abs,No Wrap,Linear,Preferred State,No Null Position) */

   Usage Page (Generic Desktop Ctrls) */

   Logical Maximum (7) */

   Physical Maximum (315) */

   Report Size (4) */

   Report Count (1) */

   Unit (System: English Rotation, Length: Centimeter) */

   Usage (Hat switch) */

   Input (Data,Var,Abs,No Wrap,Linear,Preferred State,Null State) */

   Unit (None) */

   Report Count (1) */

   Input (Const,Array,Abs,No Wrap,Linear,Preferred State,No Null Position) */

   Logical Maximum (255) */

   Physical Maximum (255) */

   Usage (X) */

   Usage (Y) */

   Usage (Rx) */

   Usage (Ry) */

   Report Size (8) */

   Report Count (4) */

   Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position) */

   Report Count (10) */

   Input (Const,Array,Abs,No Wrap,Linear,Preferred State,No Null Position) */

   Usage Page (Generic Desktop Ctrls) */

   Logical Maximum (255) */

   Physical Maximum (255) */

   Usage (Z) */

   Usage (Rz) */

   Report Count (2) */

   Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position) */

   Report Count (8) */

   Input (Const,Array,Abs,No Wrap,Linear,Preferred State,No Null Position) */

   Usage Page (Vendor Defined 0xFF00) */

   Feature (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position,Non-volatile) */

   Usage (0x2621) */

   Report Count (8) */

   Output (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position,Non-volatile) */

   Usage (0x2621) */

   Report Count (8) */

   Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position) */

 End Collection */

 LED1 = 1 .. LED4 = 8 */

 right motor off/on 0/1 */

 left motor force 0-255 */

 1 = led message */

 reserved value, always 8 */

 padding */

 padding */

 padding */

 padding */

 padding */

 2 = rumble effect message */

 reserved value, always 8 */

 duration 0-254 (255 = nonstop) */

 padding */

 padding */

 padding */

 initial state: LED1 is on, no rumble effect */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  HID support for Linux

 *

 *  Copyright (c) 1999 Andreas Gal

 *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>

 *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc

 *  Copyright (c) 2007-2008 Oliver Neukum

 *  Copyright (c) 2006-2012 Jiri Kosina

 *  Copyright (c) 2012 Henrik Rydberg

/*

	/*

	 * If any other driver wants the device, leave the device to this other

	 * driver.

 SPDX-License-Identifier: GPL-2.0

/*

 * HID support for Vivaldi Keyboard

 *

 * Copyright 2020 Google LLC.

 * Author: Sean O'Brien <seobrien@chromium.org>

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Roccat Pyra driver for Linux

 *

 * Copyright (c) 2010 Stefan Achatz <erazor_de@users.sourceforge.net>

/*

/*

 * Roccat Pyra is a mobile gamer mouse which comes in wired and wireless

 * variant. Wireless variant is not tested.

 * Userland tools can be found at http://sourceforge.net/projects/roccat

 pyra_class is used for creating sysfs attributes via roccat char device */

			/*

			 * pyra reports profile numbers with range 1-5.

			 * Keeping this behaviour.

 class name has to be same as driver name */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright (c) 2000-2001 Vojtech Pavlik

 *  Copyright (c) 2006-2010 Jiri Kosina

 *

 *  HID to Linux Input mapping

/*

 *

 * Should you need to contact me, the author, you can do so either by

 * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:

 * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic

	/*

	 * We should exclude unmapped usages when doing lookup by keycode.

		/*

		 * Set the keybit for the old keycode if the old keycode is used

		 * by another key

/**

 * hidinput_calc_abs_res - calculate an absolute axis resolution

 * @field: the HID report field to calculate resolution for

 * @code: axis code

 *

 * The formula is:

 *                         (logical_maximum - logical_minimum)

 * resolution = ----------------------------------------------------------

 *              (physical_maximum - physical_minimum) * 10 ^ unit_exponent

 *

 * as seen in the HID specification v1.11 6.2.2.7 Global Items.

 *

 * Only exponent 1 length units are processed. Centimeters and inches are

 * converted to millimeters. Degrees are converted to radians.

 Check if the extents are sane */

	/*

	 * Verify and convert units.

	 * See HID specification v1.11 6.2.2.7 Global Items for unit decoding

 If centimeters */

 Convert to millimeters */

 If inches */

 Convert to millimeters */

 If degrees */

 Convert to radians */

 If not radians */

 Apply negative unit exponent */

 Apply positive unit exponent */

 Calculate resolution */

 always reports percent */

 ask for feature report */

 completely ignore the battery */

 already initialized? */

	/*

	 * Stylus is normally not connected to the device and thus we

	 * can't query the device and get meaningful battery strength.

	 * We have to wait for the device to report it on its own.

 !CONFIG_HID_BATTERY_STRENGTH */

 CONFIG_HID_BATTERY_STRENGTH */

 Ignore if report count is out of bounds. */

 only LED usages are supported in output fields */

 SystemControl */

 SC - Display */

		/*

		 * Some lazy vendors declare 255 usages for System Control,

		 * leading to the creation of ABS_X|Y axis and too many others.

		 * It wouldn't be a problem if joydev doesn't consider the

		 * device as a joystick then.

 D-pad */

 These usage IDs map directly to the usage codes. */

 MS wireless radio ctl extension, also check CA */

 We need to simulate the btn release */

 HID-Value:                   */

   "Num Lock"                 */

   "Caps Lock"                */

   "Scroll Lock"              */

   "Compose"                  */

   "Kana"                     */

   "Stand-By"                 */

   "System Suspend"           */

   "Mute"                     */

   "Generic Indicator"        */

   "Message Waiting"          */

   "External Power Connected" */

 Digitizer */

 Pen */

 Undefined */

 TipPressure */

 InRange */

 Battery Strength */

 Invert */

 X Tilt */

 Y Tilt */

 Touch */

 TipSwitch */

 TipSwitch2 */

 BarrelSwitch */

 ERASER */

			/*

			 * This event is reported when eraser tip touches the surface.

			 * Actual eraser (BTN_TOOL_RUBBER) is set by Invert usage when

			 * tool gets in proximity.

 TabletPick */

 SecondaryBarrelSwitch */

 TransducerSerialNumber */

 TransducerSerialNumber2 */

 USB HUT v1.12, pages 75-84 */

 Menu */

 Menu Pick */

 Menu Up */

 Menu Down */

 Menu Left */

 Menu Right */

 Menu Escape */

 Menu Value Increase */

 Menu Value Decrease */

 Data On Screen */

 Closed Caption */

 VCR/TV */

 Snapshot */

 AC Pan */

 Reported on a Dutch layout HP5308 */

 Reported on Logitech and Apple USB keyboards */

 intentional fallback */

 intentional fallback */

 Mapping failed, bail out */

		/*

		 * The driver indicated that no further generic handling

		 * of the usage is desired.

	/*

	 * This part is *really* controversial:

	 * - HID aims at being generic so we should do our best to export

	 *   all incoming events

	 * - HID describes what events are, so there is no reason for ABS_X

	 *   to be mapped to ABS_Y

	 * - HID is using *_MISC+N as a default value, but nothing prevents

	 *   *_MISC+N to overwrite a legitimate even, which confuses userspace

	 *   (for instance ABS_MISC + 7 is ABS_MT_SLOT, which has a different

	 *   processing)

	 *

	 * If devices still want to use this (at their own risk), they will

	 * have to use the quirk HID_QUIRK_INCREMENT_USAGE_ON_DUPLICATE, but

	 * the default should be a reliable mapping.

 use a larger default input buffer for MT devices */

	/* for those devices which produce Consumer volume usage as relative,

	 * we emulate pressing volumeup/volumedown appropriate number of times

	 * in hidinput_hid_event()

	/*

	 * Windows reports one wheel click as value 120. Where a high-res

	 * scroll wheel is present, a fraction of 120 is reported instead.

	 * Our REL_WHEEL_HI_RES axis does the same because all HW must

	 * adhere to the 120 expectation.

 Simultaneous Effects Max */

 Key 0 is "unassigned", not KEY_UNKNOWN */

	/*

	 * Ignore out-of-range values as per HID specification,

	 * section 5.10 and 6.2.25, when NULL state bit is present.

	 * When it's not, clamp the value to match Microsoft's input

	 * driver as mentioned in "Required HID usages for digitizers":

	 * https://msdn.microsoft.com/en-us/library/windows/hardware/dn672278(v=vs.85).asp

	 *

	 * The logical_minimum < logical_maximum check is done so that we

	 * don't unintentionally discard values sent by devices which

	 * don't specify logical min and max.

	/*

	 * Ignore reports for absolute data if the data didn't change. This is

	 * not only an optimization but also fixes 'dead' key reports. Some

	 * RollOver implementations for localized keys (like BACKSLASH/PIPE; HID

	 * 0x31 and 0x32) report multiple keys, even though a localized keyboard

	 * can only have one of them physically available. The 'dead' keys

	 * report constant 0. As all map to the same keycode, they'd confuse

	 * the input layer. If we filter the 'dead' keys on the HID level, we

	 * skip the keycode translation and only forward real events.

 report the usage code as scancode if the key status has changed */

	/*

	 * field->report is accessed unlocked regarding HID core. So there might

	 * be another incoming SET-LED request from user-space, which changes

	 * the LED state while we assemble our outgoing buffer. However, this

	 * doesn't matter as hid_output_report() correctly converts it into a

	 * boolean value no matter what information is currently set on the LED

	 * field (even garbage). So the remote device will always get a valid

	 * request.

	 * And in case we send a wrong value, a next led worker is spawned

	 * for every SET-LED request so the following worker will send the

	 * correct value, guaranteed!

 use custom SET_REPORT request if possible (asynchronous) */

 fall back to generic raw-output-report */

 synchronous output report */

		/* There is no good reason for a Resolution

		 * Multiplier to have a count other than 1.

		 * Ignore that case.

			/*

			 * If we have more than one feature within this

			 * report we need to fill in the bits from the

			 * others before we can overwrite the ones for the

			 * Resolution Multiplier.

			 *

			 * But if we're not allowed to read from the device,

			 * we just bail. Such a device should not exist

			 * anyway.

 refresh our structs */

 Ignore if report count is out of bounds. */

 Verify if Battery Strength feature is available */

		/*

		 * Keep SystemControl and ConsumerControl applications together

		 * with the main keyboard, if present.

/*

 * Register the input device; print a message.

 * Configure the input layer interface

 * Read all reports and initialize the absolute field values.

			/*

			 * Find the previous hidinput report attached

			 * to this report id.

 no need to register an input device not populated */

 unwind the ones we already registered */

	/* led_work is spawned by input_dev callbacks, but doesn't access the

	 * parent input_dev at all. Once all input devices are removed, we

	 * know that led_work will never get restarted, so we can cancel it

 SPDX-License-Identifier: GPL-2.0-only

/*

 * HID driver for primax and similar keyboards with in-band modifiers

 *

 * Copyright 2011 Google Inc. All Rights Reserved

 *

 * Author:

 *	Terry Lambert <tlambert@google.com>

 keyboard input */

		/*

		 * Convert in-band modifier key values into out of band

		 * modifier bits and pull the key strokes from the report.

		 * Thus a report data set which looked like:

		 *

		 * [00][00][E0][30][00][00][00][00]

		 * (no modifier bits + "Left Shift" key + "1" key)

		 *

		 * Would be converted to:

		 *

		 * [01][00][00][30][00][00][00][00]

		 * (Left Shift modifier bit + "1" key)

		 *

		 * As long as it's in the size range, the upper level

		 * drivers don't particularly care if there are in-band

		 * 0-valued keys, so they don't stop parsing.

 unknown report */

 Unknown report type; pass upstream */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  HID driver for some microsoft "special" devices

 *

 *  Copyright (c) 1999 Andreas Gal

 *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>

 *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc

 *  Copyright (c) 2006-2007 Jiri Kosina

 *  Copyright (c) 2008 Jiri Slaby

/*

	/*

	 * Microsoft Wireless Desktop Receiver (Model 1028) has

	 * 'Usage Min/Max' where it ought to have 'Physical Min/Max'

		/*

		 * Microsoft uses these 2 reserved usage ids for 2 keys on

		 * the MS office kb labelled "Office Home" and "Task Pane".

 Special keypad keys */

 Scroll wheel */

		/*

		 * This byte contains a copy of the modifier keys byte of a

		 * standard hid keyboard report, as send by interface 0

		 * (this usage is found on interface 1).

		 *

		 * This byte only gets send when another key in the same report

		 * changes state, and as such is useless, ignore it.

 ignore those axis */

 ignore those axis */

 Handling MS keyboards special buttons */

 Special keypad keys */

 Scroll wheel */

	/*

	 * Specifying maximum duration and maximum loop count should

	 * cover maximum duration of a single effect, which is 65536

	 * ms

 left actuator */

 right actuator */

	/*

	 * Magnitude is 0..100 so scale the 16-bit input here

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  HID driver for ELECOM devices:

 *  - BM084 Bluetooth Mouse

 *  - EX-G Trackballs (M-XT3DRBK, M-XT3URBK, M-XT4DRBK)

 *  - DEFT Trackballs (M-DT1DRBK, M-DT1URBK, M-DT2DRBK, M-DT2URBK)

 *  - HUGE Trackballs (M-HT1DRBK, M-HT1URBK)

 *

 *  Copyright (c) 2010 Richard Nauber <Richard.Nauber@gmail.com>

 *  Copyright (c) 2016 Yuxuan Shui <yshuiv7@gmail.com>

 *  Copyright (c) 2017 Diego Elio Pettenò <flameeyes@flameeyes.eu>

 *  Copyright (c) 2017 Alex Manoussakis <amanou@gnu.org>

 *  Copyright (c) 2017 Tomasz Kramkowski <tk@the-tk.com>

 *  Copyright (c) 2020 YOSHIOKA Takuma <lo48576@hard-wi.red>

/*

/*

 * Certain ELECOM mice misreport their button count meaning that they only work

 * correctly with the ELECOM mouse assistant software which is unavailable for

 * Linux. A four extra INPUT reports and a FEATURE report are described by the

 * report descriptor but it does not appear that these enable software to

 * control what the extra buttons map to. The only simple and straightforward

 * solution seems to involve fixing up the report descriptor.

		/* The BM084 Bluetooth mouse includes a non-existing horizontal

		/*

		 * Report descriptor format:

		 * 20: button bit count

		 * 28: padding bit count

		 * 22: button report size

		 * 14: button usage maximum

		/*

		 * Report descriptor format:

		 * 12: button bit count

		 * 30: padding bit count

		 * 14: button report size

		 * 20: button usage maximum

		/*

		 * Report descriptor format:

		 * 12: button bit count

		 * 30: padding bit count

		 * 14: button report size

		 * 20: button usage maximum

 SPDX-License-Identifier: GPL-2.0-only

/*

 * hid-sensor-custom.c

 * Copyright (c) 2015, Intel Corporation.

 Header for each sample to user space via dev interface */

	/*

	 * It is possible that the power/report state ids are not present.

	 * In this case this function will return success. But if the

	 * ids are present, then it will return error if set fails.

 If any error occurs in a sample, rest of the fields are ignored */

 Create sysfs attributes */

 For power or report field store indexes */

 We essentially have single reader and writer */

 luid defined in FW (e.g. ISH).  Maybe used to identify sensor. */

 get manufacturer info */

 convert from wide char to char */

 ensure it's ISH sensor */

 get real usage id */

 convert from wide char to char */

 get table index with luid (not matching 'LUID: ' in luid) */

 copy real usage id */

 usage id are all lowcase */

 HID-SENSOR-INT-REAL_USAGE_ID */

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0-only

/*

 * HID driver for some ITE "special" devices

 * Copyright (c) 2017 Hans de Goede <hdegoede@redhat.com>

 For Acer Aspire Switch 10 SW5-012 keyboard-dock */

 For Acer One S1002/S1003 keyboard-dock */

 For Acer Aspire Switch 10E (SW3-016) keyboard-dock */

 Touchpad on, userspace expects F22 for this */

 Touchpad off, userspace expects F23 for this */

	/*

	 * The ITE8595 always reports 0 as value for the rfkill button. Luckily

	 * it is the only button in its report, and it sends a report on

	 * release only, so receiving a report means the button was pressed.

 ITE8595 USB kbd ctlr, with Synaptics touchpad connected to it. */

 ITE8910 USB kbd ctlr, with Synaptics touchpad connected to it. */

 ITE8910 USB kbd ctlr, with Synaptics touchpad connected to it. */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  HID driver for Kensigton Slimblade Trackball

 *

 *  Copyright (c) 2009 Jiri Kosina

/*

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  HID driver for Aureal Cy se W-01RN USB_V3.1 devices

 *

 *  Copyright (c) 2010 Franco Catrin <fcatrin@gmail.com>

 *  Copyright (c) 2010 Ben Cropley <bcropley@internode.on.net>

 *

 *  Based on HID sunplus driver by

 *  Copyright (c) 1999 Andreas Gal

 *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>

 *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc

 *  Copyright (c) 2006-2007 Jiri Kosina

 *  Copyright (c) 2008 Jiri Slaby

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  HID driver for some gyration "special" devices

 *

 *  Copyright (c) 1999 Andreas Gal

 *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>

 *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc

 *  Copyright (c) 2008 Jiri Slaby

 *  Copyright (c) 2006-2008 Jiri Kosina

/*

 Reported on Gyration MCE Remote */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  HID driver for some sunplus "special" devices

 *

 *  Copyright (c) 1999 Andreas Gal

 *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>

 *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc

 *  Copyright (c) 2006-2007 Jiri Kosina

 *  Copyright (c) 2008 Jiri Slaby

/*

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Simple USB RGB LED driver

 *

 * Copyright 2016 Heiner Kallweit <hkallweit1@gmail.com>

 * Based on drivers/hid/hid-thingm.c and

 * drivers/usb/misc/usbled.c

 R+2G+4B -> riso kagaku color index */

 black   */

 red     */

 green   */

 yellow  */

 blue    */

 magenta */

 cyan    */

 white   */

	/*

	 * buffer provided to hid_hw_raw_request must not be on the stack

	 * and must not be part of a data structure

 reading data is supported for report type RAW_REQUEST only */

 Dream Cheeky magic */

 Check for firmware major version 1 */

	/*

	 * enable LED

	 * We can't do this in the init function already because the device

	 * is internally reset later.

	/*

	 * Several Delcom devices share the same USB VID/PID

	 * Check for family id 2 for Visual Signal Indicator

 Register the red diode */

 Register the green diode */

 Register the blue diode */

 SPDX-License-Identifier: GPL-2.0+

/*

 *  HID driver for UC-Logic devices not fully compliant with HID standard

 *  - tablet initialization and parameter retrieval

 *

 *  Copyright (c) 2018 Nikolai Kondrashov

/*

 * This program is free software; you can redistribute it and/or modify it

 * under the terms of the GNU General Public License as published by the Free

 * Software Foundation; either version 2 of the License, or (at your option)

 * any later version.

/**

 * uclogic_params_pen_inrange_to_str() - Convert a pen in-range reporting type

 *                                       to a string.

 *

 * @inrange:	The in-range reporting type to convert.

 *

 * Returns:

 *	The string representing the type, or NULL if the type is unknown.

/**

 * uclogic_params_get_str_desc - retrieve a string descriptor from a HID

 * device interface, putting it into a kmalloc-allocated buffer as is, without

 * character encoding conversion.

 *

 * @pbuf:	Location for the kmalloc-allocated buffer pointer containing

 *		the retrieved descriptor. Not modified in case of error.

 *		Can be NULL to have retrieved descriptor discarded.

 * @hdev:	The HID device of the tablet interface to retrieve the string

 *		descriptor from. Cannot be NULL.

 * @idx:	Index of the string descriptor to request from the device.

 * @len:	Length of the buffer to allocate and the data to retrieve.

 *

 * Returns:

 *	number of bytes retrieved (<= len),

 *	-EPIPE, if the descriptor was not found, or

 *	another negative errno code in case of other error.

 Check arguments */

/**

 * uclogic_params_pen_cleanup - free resources used by struct

 * uclogic_params_pen (tablet interface's pen input parameters).

 * Can be called repeatedly.

 *

 * @pen:	Pen input parameters to cleanup. Cannot be NULL.

/**

 * uclogic_params_pen_init_v1() - initialize tablet interface pen

 * input and retrieve its parameters from the device, using v1 protocol.

 *

 * @pen:	Pointer to the pen parameters to initialize (to be

 *		cleaned up with uclogic_params_pen_cleanup()). Not modified in

 *		case of error, or if parameters are not found. Cannot be NULL.

 * @pfound:	Location for a flag which is set to true if the parameters

 *		were found, and to false if not (e.g. device was

 *		incompatible). Not modified in case of error. Cannot be NULL.

 * @hdev:	The HID device of the tablet interface to initialize and get

 *		parameters from. Cannot be NULL.

 *

 * Returns:

 *	Zero, if successful. A negative errno code on error.

 Buffer for (part of) the string descriptor */

 Minimum descriptor length required, maximum seen so far is 18 */

 Pen report descriptor template parameters */

 Check arguments */

	/*

	 * Read string descriptor containing pen input parameters.

	 * The specific string descriptor and data were discovered by sniffing

	 * the Windows driver traffic.

	 * NOTE: This enables fully-functional tablet mode.

	/*

	 * Fill report descriptor parameters from the string descriptor

	/*

	 * Generate pen report descriptor

	/*

	 * Fill-in the parameters

/**

 * uclogic_params_get_le24() - get a 24-bit little-endian number from a

 * buffer.

 *

 * @p:	The pointer to the number buffer.

 *

 * Returns:

 *	The retrieved number

/**

 * uclogic_params_pen_init_v2() - initialize tablet interface pen

 * input and retrieve its parameters from the device, using v2 protocol.

 *

 * @pen:	Pointer to the pen parameters to initialize (to be

 *		cleaned up with uclogic_params_pen_cleanup()). Not modified in

 *		case of error, or if parameters are not found. Cannot be NULL.

 * @pfound:	Location for a flag which is set to true if the parameters

 *		were found, and to false if not (e.g. device was

 *		incompatible). Not modified in case of error. Cannot be NULL.

 * @hdev:	The HID device of the tablet interface to initialize and get

 *		parameters from. Cannot be NULL.

 *

 * Returns:

 *	Zero, if successful. A negative errno code on error.

 Buffer for (part of) the string descriptor */

 Descriptor length required */

 Pen report descriptor template parameters */

 Check arguments */

	/*

	 * Read string descriptor containing pen input parameters.

	 * The specific string descriptor and data were discovered by sniffing

	 * the Windows driver traffic.

	 * NOTE: This enables fully-functional tablet mode.

		/*

		 * Check it's not just a catch-all UTF-16LE-encoded ASCII

		 * string (such as the model name) some tablets put into all

		 * unknown string descriptors.

	/*

	 * Fill report descriptor parameters from the string descriptor

	/*

	 * Generate pen report descriptor

	/*

	 * Fill-in the parameters

/**

 * uclogic_params_frame_cleanup - free resources used by struct

 * uclogic_params_frame (tablet interface's frame controls input parameters).

 * Can be called repeatedly.

 *

 * @frame:	Frame controls input parameters to cleanup. Cannot be NULL.

/**

 * uclogic_params_frame_init_with_desc() - initialize tablet's frame control

 * parameters with a static report descriptor.

 *

 * @frame:	Pointer to the frame parameters to initialize (to be cleaned

 *		up with uclogic_params_frame_cleanup()). Not modified in case

 *		of error. Cannot be NULL.

 * @desc_ptr:	Report descriptor pointer. Can be NULL, if desc_size is zero.

 * @desc_size:	Report descriptor size.

 * @id:		Report ID used for frame reports, if they should be tweaked,

 *		zero if not.

 *

 * Returns:

 *	Zero, if successful. A negative errno code on error.

/**

 * uclogic_params_frame_init_v1_buttonpad() - initialize abstract buttonpad

 * on a v1 tablet interface.

 *

 * @frame:	Pointer to the frame parameters to initialize (to be cleaned

 *		up with uclogic_params_frame_cleanup()). Not modified in case

 *		of error, or if parameters are not found. Cannot be NULL.

 * @pfound:	Location for a flag which is set to true if the parameters

 *		were found, and to false if not (e.g. device was

 *		incompatible). Not modified in case of error. Cannot be NULL.

 * @hdev:	The HID device of the tablet interface to initialize and get

 *		parameters from. Cannot be NULL.

 *

 * Returns:

 *	Zero, if successful. A negative errno code on error.

 Check arguments */

	/*

	 * Enable generic button mode

/**

 * uclogic_params_cleanup - free resources used by struct uclogic_params

 * (tablet interface's parameters).

 * Can be called repeatedly.

 *

 * @params:	Input parameters to cleanup. Cannot be NULL.

/**

 * uclogic_params_get_desc() - Get a replacement report descriptor for a

 *                             tablet's interface.

 *

 * @params:	The parameters of a tablet interface to get report

 *		descriptor for. Cannot be NULL.

 * @pdesc:	Location for the resulting, kmalloc-allocated report

 *		descriptor pointer, or for NULL, if there's no replacement

 *		report descriptor. Not modified in case of error. Cannot be

 *		NULL.

 * @psize:	Location for the resulting report descriptor size, not set if

 *		there's no replacement report descriptor. Not modified in case

 *		of error. Cannot be NULL.

 *

 * Returns:

 *	Zero, if successful.

 *	-EINVAL, if invalid arguments are supplied.

 *	-ENOMEM, if failed to allocate memory.

 Check arguments */

/**

 * uclogic_params_init_invalid() - initialize tablet interface parameters,

 * specifying the interface is invalid.

 *

 * @params:		Parameters to initialize (to be cleaned with

 *			uclogic_params_cleanup()). Cannot be NULL.

/**

 * uclogic_params_init_with_opt_desc() - initialize tablet interface

 * parameters with an optional replacement report descriptor. Only modify

 * report descriptor, if the original report descriptor matches the expected

 * size.

 *

 * @params:		Parameters to initialize (to be cleaned with

 *			uclogic_params_cleanup()). Not modified in case of

 *			error. Cannot be NULL.

 * @hdev:		The HID device of the tablet interface create the

 *			parameters for. Cannot be NULL.

 * @orig_desc_size:	Expected size of the original report descriptor to

 *			be replaced.

 * @desc_ptr:		Pointer to the replacement report descriptor.

 *			Can be NULL, if desc_size is zero.

 * @desc_size:		Size of the replacement report descriptor.

 *

 * Returns:

 *	Zero, if successful. -EINVAL if an invalid argument was passed.

 *	-ENOMEM, if failed to allocate memory.

 Check arguments */

 Replace report descriptor, if it matches */

 Output parameters */

/**

 * uclogic_params_init_with_pen_unused() - initialize tablet interface

 * parameters preserving original reports and generic HID processing, but

 * disabling pen usage.

 *

 * @params:		Parameters to initialize (to be cleaned with

 *			uclogic_params_cleanup()). Not modified in case of

 *			error. Cannot be NULL.

/**

 * uclogic_params_huion_init() - initialize a Huion tablet interface and discover

 * its parameters.

 *

 * @params:	Parameters to fill in (to be cleaned with

 *		uclogic_params_cleanup()). Not modified in case of error.

 *		Cannot be NULL.

 * @hdev:	The HID device of the tablet interface to initialize and get

 *		parameters from. Cannot be NULL.

 *

 * Returns:

 *	Zero, if successful. A negative errno code on error.

 The resulting parameters (noop) */

 Check arguments */

 If it's not a pen interface */

 TODO: Consider marking the interface invalid */

 Try to get firmware version */

 If this is a transition firmware */

 Try to probe v2 pen parameters */

 Create v2 buttonpad parameters */

 Set bitmask marking frame reports in pen reports */

 Try to probe v1 pen parameters */

 Try to probe v1 buttonpad */

 Set bitmask marking frame reports */

 Output parameters */

/**

 * uclogic_params_init() - initialize a tablet interface and discover its

 * parameters.

 *

 * @params:	Parameters to fill in (to be cleaned with

 *		uclogic_params_cleanup()). Not modified in case of error.

 *		Cannot be NULL.

 * @hdev:	The HID device of the tablet interface to initialize and get

 *		parameters from. Cannot be NULL. Must be using the USB low-level

 *		driver, i.e. be an actual USB tablet.

 *

 * Returns:

 *	Zero, if successful. A negative errno code on error.

 The resulting parameters (noop) */

 Check arguments */

	/*

	 * Set replacement report descriptor if the original matches the

	 * specified size. Otherwise keep interface unchanged.

	/*

	 * Handle specific interfaces for specific tablets.

	 *

	 * Observe the following logic:

	 *

	 * If the interface is recognized as producing certain useful input:

	 *	Mark interface as valid.

	 *	Output interface parameters.

	 * Else, if the interface is recognized as *not* producing any useful

	 * input:

	 *	Mark interface as invalid.

	 * Else:

	 *	Mark interface as valid.

	 *	Output noop parameters.

	 *

	 * Rule of thumb: it is better to disable a broken interface than let

	 *		  it spew garbage input.

 Try to probe v1 pen parameters */

		/*

		 * If it is not a three-interface version, which is known to

		 * respond to initialization.

 If this is the pen interface */

 Probe v1 pen parameters */

 TODO: Consider marking the interface invalid */

 If this is the pen and frame interface */

 Probe v1 pen parameters */

 Initialize frame parameters */

 TODO: Consider marking the interface invalid */

 Ignore non-pen interfaces */

 Ignore non-pen interfaces */

 Output parameters */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Device Modules for Nintendo Wii / Wii U HID Driver

 * Copyright (c) 2011-2013 David Herrmann <dh.herrmann@gmail.com>

/*

/*

 * Wiimote Modules

 * Nintendo devices provide different peripherals and many new devices lack

 * initial features like the IR camera. Therefore, each peripheral device is

 * implemented as an independent module and we probe on each device only the

 * modules for the hardware that really is available.

 *

 * Module registration is sequential. Unregistration is done in reverse order.

 * After device detection, the needed modules are loaded. Users can trigger

 * re-detection which causes all modules to be unloaded and then reload the

 * modules for the new detected device.

 *

 * wdata->input is a shared input device. It is always initialized prior to

 * module registration. If at least one registered module is marked as

 * WIIMOD_FLAG_INPUT, then the input device will get registered after all

 * modules were registered.

 * Please note that it is unregistered _before_ the "remove" callbacks are

 * called. This guarantees that no input interaction is done, anymore. However,

 * the wiimote core keeps a reference to the input device so it is freed only

 * after all modules were removed. It is safe to send events to unregistered

 * input devices.

/*

 * Keys

 * The initial Wii Remote provided a bunch of buttons that are reported as

 * part of the core protocol. Many later devices dropped these and report

 * invalid data in the core button reports. Load this only on devices which

 * correctly send button reports.

 * It uses the shared input device.

 WIIPROTO_KEY_LEFT */

 WIIPROTO_KEY_RIGHT */

 WIIPROTO_KEY_UP */

 WIIPROTO_KEY_DOWN */

 WIIPROTO_KEY_PLUS */

 WIIPROTO_KEY_MINUS */

 WIIPROTO_KEY_ONE */

 WIIPROTO_KEY_TWO */

 WIIPROTO_KEY_A */

 WIIPROTO_KEY_B */

 WIIPROTO_KEY_HOME */

/*

 * Rumble

 * Nearly all devices provide a rumble feature. A small motor for

 * force-feedback effects. We provide an FF_RUMBLE memless ff device on the

 * shared input device if this module is loaded.

 * The rumble motor is controlled via a flag on almost every output report so

 * the wiimote core handles the rumble flag. But if a device doesn't provide

 * the rumble motor, this flag shouldn't be set.

 used by wiimod_rumble and wiipro_rumble */

	/*

	 * The wiimote supports only a single rumble motor so if any magnitude

	 * is set to non-zero then we start the rumble motor. If both are set to

	 * zero, we stop the rumble motor.

	/* Locking state.lock here might deadlock with input_event() calls.

/*

 * Battery

 * 1 byte of battery capacity information is sent along every protocol status

 * report. The wiimote core caches it but we try to update it on every

 * user-space request.

 * This is supported by nearly every device so it's almost always enabled.

/*

 * LED

 * 0 to 4 player LEDs are supported by devices. The "arg" field of the

 * wiimod_ops structure specifies which LED this module controls. This allows

 * to register a limited number of LEDs.

 * State is managed by wiimote core.

 enable LED1 to stop initial LED-blinking */

/*

 * Accelerometer

 * 3 axis accelerometer data is part of nearly all DRMs. If not supported by a

 * device, it's mostly cleared to 0. This module parses this data and provides

 * it via a separate input device.

	/*

	 * payload is: BB BB XX YY ZZ

	 * Accelerometer data is encoded into 3 10bit values. XX, YY and ZZ

	 * contain the upper 8 bits of each value. The lower 2 bits are

	 * contained in the buttons data BB BB.

	 * Bits 6 and 7 of the first buttons byte BB is the lower 2 bits of the

	 * X accel value. Bit 5 of the second buttons byte is the 2nd bit of Y

	 * accel value and bit 6 is the second bit of the Z value.

	 * The first bit of Y and Z values is not available and always set to 0.

	 * 0x200 is returned on no movement.

/*

 * IR Cam

 * Up to 4 IR sources can be tracked by a normal Wii Remote. The IR cam needs

 * to be initialized with a fairly complex procedure and consumes a lot of

 * power. Therefore, as long as no application uses the IR input device, it is

 * kept offline.

 * Nearly no other device than the normal Wii Remotes supports the IR cam so

 * you can disable this module for these devices.

	/*

	 * Basic IR data is encoded into 3 bytes. The first two bytes are the

	 * lower 8 bit of the X/Y data, the 3rd byte contains the upper 2 bits

	 * of both.

	 * If data is packed, then the 3rd byte is put first and slightly

	 * reordered. This allows to interleave packed and non-packed data to

	 * have two IR sets in 5 bytes instead of 6.

	 * The resulting 10bit X/Y values are passed to the ABS_HAT? input dev.

 send PIXEL CLOCK ENABLE cmd first */

 enable IR LOGIC */

 enable IR cam but do not make it send data, yet */

 write first sensitivity block */

 write second sensitivity block */

 put IR cam into desired state */

 make IR cam send data */

 request new DRM mode compatible to IR mode */

/*

 * Nunchuk Extension

 * The Nintendo Wii Nunchuk was the first official extension published by

 * Nintendo. It provides two additional keys and a separate accelerometer. It

 * can be hotplugged to standard Wii Remotes.

 WIIMOD_NUNCHUK_KEY_C */

 WIIMOD_NUNCHUK_KEY_Z */

	/*   Byte |   8    7 |  6    5 |  4    3 |  2 |  1  |

	 *   -----+----------+---------+---------+----+-----+

	 *    1   |              Button X <7:0>             |

	 *    2   |              Button Y <7:0>             |

	 *   -----+----------+---------+---------+----+-----+

	 *    3   |               Speed X <9:2>             |

	 *    4   |               Speed Y <9:2>             |

	 *    5   |               Speed Z <9:2>             |

	 *   -----+----------+---------+---------+----+-----+

	 *    6   | Z <1:0>  | Y <1:0> | X <1:0> | BC | BZ  |

	 *   -----+----------+---------+---------+----+-----+

	 * Button X/Y is the analog stick. Speed X, Y and Z are the

	 * accelerometer data in the same format as the wiimote's accelerometer.

	 * The 6th byte contains the LSBs of the accelerometer data.

	 * BC and BZ are the C and Z buttons: 0 means pressed

	 *

	 * If reported interleaved with motionp, then the layout changes. The

	 * 5th and 6th byte changes to:

	 *   -----+-----------------------------------+-----+

	 *    5   |            Speed Z <9:3>          | EXT |

	 *   -----+--------+-----+-----+----+----+----+-----+

	 *    6   |Z <2:1> |Y <1>|X <1>| BC | BZ | 0  |  0  |

	 *   -----+--------+-----+-----+----+----+----+-----+

	 * All three accelerometer values lose their LSB. The other data is

	 * still available but slightly moved.

	 *

	 * Center data for button values is 128. Center value for accelerometer

	 * values it 512 / 0x200

/*

 * Classic Controller

 * Another official extension from Nintendo. It provides a classic

 * gamecube-like controller that can be hotplugged on the Wii Remote.

 * It has several hardware buttons and switches that are all reported via

 * a normal extension device.

 WIIMOD_CLASSIC_KEY_A */

 WIIMOD_CLASSIC_KEY_B */

 WIIMOD_CLASSIC_KEY_X */

 WIIMOD_CLASSIC_KEY_Y */

 WIIMOD_CLASSIC_KEY_ZL */

 WIIMOD_CLASSIC_KEY_ZR */

 WIIMOD_CLASSIC_KEY_PLUS */

 WIIMOD_CLASSIC_KEY_MINUS */

 WIIMOD_CLASSIC_KEY_HOME */

 WIIMOD_CLASSIC_KEY_LEFT */

 WIIMOD_CLASSIC_KEY_RIGHT */

 WIIMOD_CLASSIC_KEY_UP */

 WIIMOD_CLASSIC_KEY_DOWN */

 WIIMOD_CLASSIC_KEY_LT */

 WIIMOD_CLASSIC_KEY_RT */

	/*   Byte |  8  |  7  |  6  |  5  |  4  |  3  |  2  |  1  |

	 *   -----+-----+-----+-----+-----+-----+-----+-----+-----+

	 *    1   | RX <5:4>  |              LX <5:0>             |

	 *    2   | RX <3:2>  |              LY <5:0>             |

	 *   -----+-----+-----+-----+-----------------------------+

	 *    3   |RX<1>| LT <5:4>  |         RY <5:1>            |

	 *   -----+-----+-----------+-----------------------------+

	 *    4   |     LT <3:1>    |         RT <5:1>            |

	 *   -----+-----+-----+-----+-----+-----+-----+-----+-----+

	 *    5   | BDR | BDD | BLT | B-  | BH  | B+  | BRT |  1  |

	 *   -----+-----+-----+-----+-----+-----+-----+-----+-----+

	 *    6   | BZL | BB  | BY  | BA  | BX  | BZR | BDL | BDU |

	 *   -----+-----+-----+-----+-----+-----+-----+-----+-----+

	 * All buttons are 0 if pressed

	 * RX and RY are right analog stick

	 * LX and LY are left analog stick

	 * LT is left trigger, RT is right trigger

	 * BLT is 0 if left trigger is fully pressed

	 * BRT is 0 if right trigger is fully pressed

	 * BDR, BDD, BDL, BDU form the D-Pad with right, down, left, up buttons

	 * BZL is left Z button and BZR is right Z button

	 * B-, BH, B+ are +, HOME and - buttons

	 * BB, BY, BA, BX are A, B, X, Y buttons

	 * LSB of RX, RY, LT, and RT are not transmitted and always 0.

	 *

	 * With motionp enabled it changes slightly to this:

	 *   Byte |  8  |  7  |  6  |  5  |  4  |  3  |  2  |  1  |

	 *   -----+-----+-----+-----+-----+-----+-----+-----+-----+

	 *    1   | RX <5:4>  |          LX <5:1>           | BDU |

	 *    2   | RX <3:2>  |          LY <5:1>           | BDL |

	 *   -----+-----+-----+-----+-----------------------+-----+

	 *    3   |RX<1>| LT <5:4>  |         RY <5:1>            |

	 *   -----+-----+-----------+-----------------------------+

	 *    4   |     LT <3:1>    |         RT <5:1>            |

	 *   -----+-----+-----+-----+-----+-----+-----+-----+-----+

	 *    5   | BDR | BDD | BLT | B-  | BH  | B+  | BRT | EXT |

	 *   -----+-----+-----+-----+-----+-----+-----+-----+-----+

	 *    6   | BZL | BB  | BY  | BA  | BX  | BZR |  0  |  0  |

	 *   -----+-----+-----+-----+-----+-----+-----+-----+-----+

	 * Only the LSBs of LX and LY are lost. BDU and BDL are moved, the rest

	 * is the same as before.

/*

 * Balance Board Extension

 * The Nintendo Wii Balance Board provides four hardware weight sensor plus a

 * single push button. No other peripherals are available. However, the

 * balance-board data is sent via a standard Wii Remote extension. All other

 * data for non-present hardware is zeroed out.

 * Some 3rd party devices react allergic if we try to access normal Wii Remote

 * hardware, so this extension module should be the only module that is loaded

 * on balance boards.

 * The balance board needs 8 bytes extension data instead of basic 6 bytes so

 * it needs the WIIMOD_FLAG_EXT8 flag.

	/*

	 * Balance board data layout:

	 *

	 *   Byte |  8  7  6  5  4  3  2  1  |

	 *   -----+--------------------------+

	 *    1   |    Top Right <15:8>      |

	 *    2   |    Top Right  <7:0>      |

	 *   -----+--------------------------+

	 *    3   | Bottom Right <15:8>      |

	 *    4   | Bottom Right  <7:0>      |

	 *   -----+--------------------------+

	 *    5   |     Top Left <15:8>      |

	 *    6   |     Top Left  <7:0>      |

	 *   -----+--------------------------+

	 *    7   |  Bottom Left <15:8>      |

	 *    8   |  Bottom Left  <7:0>      |

	 *   -----+--------------------------+

	 *

	 * These values represent the weight-measurements of the Wii-balance

	 * board with 16bit precision.

	 *

	 * The balance-board is never reported interleaved with motionp.

 apply calibration data */

/*

 * Pro Controller

 * Released with the Wii U was the Nintendo Wii U Pro Controller. It does not

 * work together with the classic Wii, but only with the new Wii U. However, it

 * uses the same protocol and provides a builtin "classic controller pro"

 * extension, few standard buttons, a rumble motor, 4 LEDs and a battery.

 * We provide all these via a standard extension device as the device doesn't

 * feature an extension port.

 WIIMOD_PRO_KEY_A */

 WIIMOD_PRO_KEY_B */

 WIIMOD_PRO_KEY_X */

 WIIMOD_PRO_KEY_Y */

 WIIMOD_PRO_KEY_PLUS */

 WIIMOD_PRO_KEY_MINUS */

 WIIMOD_PRO_KEY_HOME */

 WIIMOD_PRO_KEY_LEFT */

 WIIMOD_PRO_KEY_RIGHT */

 WIIMOD_PRO_KEY_UP */

 WIIMOD_PRO_KEY_DOWN */

 WIIMOD_PRO_KEY_TL */

 WIIMOD_PRO_KEY_TR */

 WIIMOD_PRO_KEY_ZL */

 WIIMOD_PRO_KEY_ZR */

 WIIMOD_PRO_KEY_THUMBL */

 WIIMOD_PRO_KEY_THUMBR */

	/*   Byte |  8  |  7  |  6  |  5  |  4  |  3  |  2  |  1  |

	 *   -----+-----+-----+-----+-----+-----+-----+-----+-----+

	 *    1   |                   LX <7:0>                    |

	 *   -----+-----------------------+-----------------------+

	 *    2   |  0     0     0     0  |       LX <11:8>       |

	 *   -----+-----------------------+-----------------------+

	 *    3   |                   RX <7:0>                    |

	 *   -----+-----------------------+-----------------------+

	 *    4   |  0     0     0     0  |       RX <11:8>       |

	 *   -----+-----------------------+-----------------------+

	 *    5   |                   LY <7:0>                    |

	 *   -----+-----------------------+-----------------------+

	 *    6   |  0     0     0     0  |       LY <11:8>       |

	 *   -----+-----------------------+-----------------------+

	 *    7   |                   RY <7:0>                    |

	 *   -----+-----------------------+-----------------------+

	 *    8   |  0     0     0     0  |       RY <11:8>       |

	 *   -----+-----+-----+-----+-----+-----+-----+-----+-----+

	 *    9   | BDR | BDD | BLT | B-  | BH  | B+  | BRT |  1  |

	 *   -----+-----+-----+-----+-----+-----+-----+-----+-----+

	 *   10   | BZL | BB  | BY  | BA  | BX  | BZR | BDL | BDU |

	 *   -----+-----+-----+-----+-----+-----+-----+-----+-----+

	 *   11   |  1  |     BATTERY     | USB |CHARG|LTHUM|RTHUM|

	 *   -----+-----+-----------------+-----------+-----+-----+

	 * All buttons are low-active (0 if pressed)

	 * RX and RY are right analog stick

	 * LX and LY are left analog stick

	 * BLT is left trigger, BRT is right trigger.

	 * BDR, BDD, BDL, BDU form the D-Pad with right, down, left, up buttons

	 * BZL is left Z button and BZR is right Z button

	 * B-, BH, B+ are +, HOME and - buttons

	 * BB, BY, BA, BX are A, B, X, Y buttons

	 *

	 * Bits marked as 0/1 are unknown and never changed during tests.

	 *

	 * Not entirely verified:

	 *   CHARG: 1 if uncharging, 0 if charging

	 *   USB: 1 if not connected, 0 if connected

	 *   BATTERY: battery capacity from 000 (empty) to 100 (full)

 zero-point offsets */

	/* Trivial automatic calibration. We don't know any calibration data

	 * in the EEPROM so we must use the first report to calibrate the

	 * null-position of the analog sticks. Users can retrigger calibration

	 * via sysfs, or set it explicitly. If data is off more than abs(500),

 apply calibration data */

	/*

	 * The wiimote supports only a single rumble motor so if any magnitude

	 * is set to non-zero then we start the rumble motor. If both are set to

	 * zero, we stop the rumble motor.

	/* Locking state.lock here might deadlock with input_event() calls.

/*

 * Drums

 * Guitar-Hero, Rock-Band and other games came bundled with drums which can

 * be plugged as extension to a Wiimote. Drum-reports are still not entirely

 * figured out, but the most important information is known.

 * We create a separate device for drums and report all information via this

 * input device.

	/*   Byte |  8  |  7  |  6  |  5  |  4  |  3  |  2  |  1  |

	 *   -----+-----+-----+-----+-----+-----+-----+-----+-----+

	 *    1   |  0  |  0  |              SX <5:0>             |

	 *    2   |  0  |  0  |              SY <5:0>             |

	 *   -----+-----+-----+-----------------------------+-----+

	 *    3   | HPP | NON |         WHICH <5:1>         |  ?  |

	 *   -----+-----+-----+-----+-----+-----+-----+-----+-----+

	 *    4   |   SOFT <7:5>    |  0  |  1  |  1  |  0  |  ?  |

	 *   -----+-----+-----+-----+-----+-----+-----+-----+-----+

	 *    5   |  ?  |  1  |  1  | B-  |  1  | B+  |  1  |  ?  |

	 *   -----+-----+-----+-----+-----+-----+-----+-----+-----+

	 *    6   |  O  |  R  |  Y  |  G  |  B  | BSS |  1  |  1  |

	 *   -----+-----+-----+-----+-----+-----+-----+-----+-----+

	 * All buttons are 0 if pressed

	 *

	 * With Motion+ enabled, the following bits will get invalid:

	 *   Byte |  8  |  7  |  6  |  5  |  4  |  3  |  2  |  1  |

	 *   -----+-----+-----+-----+-----+-----+-----+-----+-----+

	 *    1   |  0  |  0  |              SX <5:1>       |XXXXX|

	 *    2   |  0  |  0  |              SY <5:1>       |XXXXX|

	 *   -----+-----+-----+-----------------------------+-----+

	 *    3   | HPP | NON |         WHICH <5:1>         |  ?  |

	 *   -----+-----+-----+-----+-----+-----+-----+-----+-----+

	 *    4   |   SOFT <7:5>    |  0  |  1  |  1  |  0  |  ?  |

	 *   -----+-----+-----+-----+-----+-----+-----+-----+-----+

	 *    5   |  ?  |  1  |  1  | B-  |  1  | B+  |  1  |XXXXX|

	 *   -----+-----+-----+-----+-----+-----+-----+-----+-----+

	 *    6   |  O  |  R  |  Y  |  G  |  B  | BSS |XXXXX|XXXXX|

	 *   -----+-----+-----+-----+-----+-----+-----+-----+-----+

 Bass shares pressure with hi-hat (set via hhp) */

 Hi-hat has no on/off values, just pressure. Force to off/0. */

/*

 * Guitar

 * Guitar-Hero, Rock-Band and other games came bundled with guitars which can

 * be plugged as extension to a Wiimote.

 * We create a separate device for guitars and report all information via this

 * input device.

 WIIMOD_GUITAR_KEY_G */

 WIIMOD_GUITAR_KEY_R */

 WIIMOD_GUITAR_KEY_Y */

 WIIMOD_GUITAR_KEY_B */

 WIIMOD_GUITAR_KEY_O */

 WIIMOD_GUITAR_KEY_UP */

 WIIMOD_GUITAR_KEY_DOWN */

 WIIMOD_GUITAR_KEY_PLUS */

 WIIMOD_GUITAR_KEY_MINUS */

	/*   Byte |  8  |  7  |  6  |  5  |  4  |  3  |  2  |  1  |

	 *   -----+-----+-----+-----+-----+-----+-----+-----+-----+

	 *    1   |  0  |  0  |              SX <5:0>             |

	 *    2   |  0  |  0  |              SY <5:0>             |

	 *   -----+-----+-----+-----+-----------------------------+

	 *    3   |  0  |  0  |  0  |      TB <4:0>               |

	 *   -----+-----+-----+-----+-----------------------------+

	 *    4   |  0  |  0  |  0  |      WB <4:0>               |

	 *   -----+-----+-----+-----+-----+-----+-----+-----+-----+

	 *    5   |  1  | BD  |  1  | B-  |  1  | B+  |  1  |  1  |

	 *   -----+-----+-----+-----+-----+-----+-----+-----+-----+

	 *    6   | BO  | BR  | BB  | BG  | BY  |  1  |  1  | BU  |

	 *   -----+-----+-----+-----+-----+-----+-----+-----+-----+

	 * All buttons are 0 if pressed

	 *

	 * With Motion+ enabled, it will look like this:

	 *   Byte |  8  |  7  |  6  |  5  |  4  |  3  |  2  |  1  |

	 *   -----+-----+-----+-----+-----+-----+-----+-----+-----+

	 *    1   |  0  |  0  |              SX <5:1>       | BU  |

	 *    2   |  0  |  0  |              SY <5:1>       |  1  |

	 *   -----+-----+-----+-----+-----------------------+-----+

	 *    3   |  0  |  0  |  0  |      TB <4:0>               |

	 *   -----+-----+-----+-----+-----------------------------+

	 *    4   |  0  |  0  |  0  |      WB <4:0>               |

	 *   -----+-----+-----+-----+-----+-----+-----+-----+-----+

	 *    5   |  1  | BD  |  1  | B-  |  1  | B+  |  1  |XXXXX|

	 *   -----+-----+-----+-----+-----+-----+-----+-----+-----+

	 *    6   | BO  | BR  | BB  | BG  | BY  |  1  |XXXXX|XXXXX|

	 *   -----+-----+-----+-----+-----+-----+-----+-----+-----+

/*

 * Builtin Motion Plus

 * This module simply sets the WIIPROTO_FLAG_BUILTIN_MP protocol flag which

 * disables polling for Motion-Plus. This should be set only for devices which

 * don't allow MP hotplugging.

/*

 * No Motion Plus

 * This module simply sets the WIIPROTO_FLAG_NO_MP protocol flag which

 * disables motion-plus. This is needed for devices that advertise this but we

 * don't know how to use it (or whether it is actually present).

/*

 * Motion Plus

 * The Motion Plus extension provides rotation sensors (gyro) as a small

 * extension device for Wii Remotes. Many devices have them built-in so

 * you cannot see them from the outside.

 * Motion Plus extensions are special because they are on a separate extension

 * port and allow other extensions to be used simultaneously. This is all

 * handled by the Wiimote Core so we don't have to deal with it.

	/*        |   8    7    6    5    4    3 |  2  |  1  |

	 *   -----+------------------------------+-----+-----+

	 *    1   |               Yaw Speed <7:0>            |

	 *    2   |              Roll Speed <7:0>            |

	 *    3   |             Pitch Speed <7:0>            |

	 *   -----+------------------------------+-----+-----+

	 *    4   |       Yaw Speed <13:8>       | Yaw |Pitch|

	 *   -----+------------------------------+-----+-----+

	 *    5   |      Roll Speed <13:8>       |Roll | Ext |

	 *   -----+------------------------------+-----+-----+

	 *    6   |     Pitch Speed <13:8>       |  1  |  0  |

	 *   -----+------------------------------+-----+-----+

	 * The single bits Yaw, Roll, Pitch in the lower right corner specify

	 * whether the wiimote is rotating fast (0) or slow (1). Speed for slow

	 * roation is 8192/440 units / deg/s and for fast rotation 8192/2000

	 * units / deg/s. To get a linear scale for fast rotation we multiply

	 * by 2000/440 = ~4.5454 and scale both fast and slow by 9 to match the

	 * previous scale reported by this driver.

	 * This leaves a linear scale with 8192*9/440 (~167.564) units / deg/s.

	 * If the wiimote is not rotating the sensor reports 2^13 = 8192.

	 * Ext specifies whether an extension is connected to the motionp.

	 * which is parsed by wiimote-core.

 module table */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * HID driver for ELO usb touchscreen 4000/4500

 *

 * Copyright (c) 2013 Jiri Slaby

 *

 * Data parsing taken from elousb driver by Vojtech Pavlik.

 msec */

 Elo SmartSet commands */

 Flush all pending smartset responses */

 Send a smartset command */

 Get a smartset response */

 Diagnostics command */

	/*

	 * ELO devices have one Button usage in GenDesk field, which makes

	 * hid-input map it to BTN_LEFT; that confuses userspace, which then

	 * considers the device to be a mouse/touchpad instead of touchscreen.

 Mandatory ELO packet marker */

 unknown report */

 Unknown report type; pass upstream */

 send Diagnostics command */

 get the result */

 read the ack */

/*

 * Not all Elo devices need the periodic HID descriptor reads.

 * Only firmware version M needs this.

 iterate sibling devices of the touch controller */

		/*

		 * If one of the devices below is present attached as a sibling of 

		 * the touch controller then  this is a newer IBM 4820 monitor that 

		 * does not need the IBM-requested workaround if fw level is

		 * 0x010d - aka 'M'.

		 * No other HW can have this combination.

 4820 21x Video */

 4820 51x Video */

 4820 2Lx Video */

 4820 5Lx Video */

 SPDX-License-Identifier: GPL-2.0-only

/***************************************************************************

 *   Copyright (C) 2010-2012 by Bruno Prémont <bonbons@linux-vserver.org>  *

 *                                                                         *

 *   Based on Logitech G13 driver (v0.4)                                   *

 *     Copyright (C) 2009 by Rick L. Vinyard, Jr. <rvinyard@cs.nmsu.edu>   *

 *                                                                         *

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  USB HID quirks support for Network Technologies, Inc. "USB-SUN" USB

 *  adapter for pre-USB Sun keyboards

 *

 *  Copyright (c) 2011 Google, Inc.

 *

 * Based on HID apple driver by

 *  Copyright (c) 1999 Andreas Gal

 *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>

 *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc

 *  Copyright (c) 2006-2007 Jiri Kosina

 *  Copyright (c) 2008 Jiri Slaby <jirislaby@gmail.com>

/*

/*

 * NTI Sun keyboard adapter has wrong logical maximum in report descriptor

 SPDX-License-Identifier: GPL-2.0+

/*

 *  HID driver for Cougar 500k Gaming Keyboard

 *

 *  Copyright (c) 2018 Daniel M. Lambea <dmlambea@gmail.com>

/* Default key mappings. The special key COUGAR_KEY_G6 is defined first

 * because it is more frequent to use the spacebar rather than any other

 * special keys. Depending on the value of the parameter 'g6_is_space',

 * the mapping will be updated in the probe function.

/* The following keys are handled by the hardware itself, so no special

 * treatment is required:

	{ COUGAR_KEY_FN, KEY_RESERVED },

	{ COUGAR_KEY_MR, KEY_RESERVED },

	{ COUGAR_KEY_M1, KEY_RESERVED },

	{ COUGAR_KEY_M2, KEY_RESERVED },

	{ COUGAR_KEY_M3, KEY_RESERVED },

	{ COUGAR_KEY_LEDS, KEY_RESERVED },

/**

 * cougar_fix_g6_mapping - configure the mapping for key G6/Spacebar

/*

 * Constant-friendly rdesc fixup for mouse interface

 Try to find an already-probed interface from the same device */

/*

 * Bind the device group's shared data to this cougar struct.

 * If no shared data exists for this group, create and initialize it.

	/* The custom vendor interface will use the hid_input registered

	 * for the keyboard interface, in order to send translated key codes

	 * to it.

 Preinit the mapping table */

/*

 * Convert events from vendor intf to input key events

 Avoid warnings on the same unmapped key twice */

 Stop the vendor intf to process more events */

 SPDX-License-Identifier: GPL-2.0+

/*

 *  HID driver for Google Hammer device.

 *

 *  Copyright (c) 2017 Google Inc.

 *  Author: Wei-Ning Huang <wnhuang@google.com>

/*

 * This program is free software; you can redistribute it and/or modify it

 * under the terms of the GNU General Public License as published by the Free

 * Software Foundation; either version 2 of the License, or (at your option)

 * any later version.

/*

 * C(hrome)B(ase)A(ttached)S(witch) - switch exported by Chrome EC and reporting

 * state of the "Whiskers" base - attached or detached. Whiskers USB device also

 * reports position of the keyboard - folded or not. Combining base state and

 * position allows us to generate proper "Tablet mode" events.

 The platform device (EC) */

			/*

			 * While input layer dedupes the events, we do not want

			 * to disrupt the state reported by the base by

			 * overriding it with state reported by the LID. Only

			 * report changes, as we assume that on attach the base

			 * is not folded.

		/*

		 * Only report if base is disconnected. If base is connected,

		 * it will resend its state on resume, and we'll update it

		 * in hammer_event().

 Take the lock so hammer_event() does not race with us here */

 Seed the state */

	/*

	 * Request USB HID device to be in Full On mode, so that sending

	 * hardware output report and hardware raw request won't fail.

 Request USB HID device back to Normal Mode. */

 Set backlight to 0% initially. */

 HID usage for keyboard backlight (Alphanumeric display brightness) */

		/*

		 * We do not want to have this usage mapped as it will get

		 * mixed in with "base attached" signal and delivered over

		 * separate input device for tablet switch mode.

	/*

	 * If we are getting events from Whiskers that means that it

	 * is attached to the lid.

 We handled this event */

	/*

	 * We always want to poll for, and handle tablet mode events from

	 * devices that have folded usage, even when nobody has opened the input

	 * device. This also prevents the hid core from dropping early tablet

	 * mode events from the device.

		/*

		 * If we are disconnecting then most likely Whiskers is

		 * being removed. Even if it is not removed, without proper

		 * keyboard we should not stay in clamshell mode.

		 *

		 * The reason for doing it here and not waiting for signal

		 * from EC, is that on some devices there are high leakage

		 * on Whiskers pins and we do not detect disconnect reliably,

		 * resulting in devices being stuck in clamshell mode.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * HID driver for Holtek gaming mice

 * Copyright (c) 2013 Christian Ohm

 * Heavily inspired by various other HID drivers that adjust the report

 * descriptor.

/*

/*

 * The report descriptor of some Holtek based gaming mice specifies an

 * excessively large number of consumer usages (2^15), which is more than

 * HID_MAX_USAGES. This prevents proper parsing of the report descriptor.

 *

 * This driver fixes the report descriptor for:

 * - USB ID 04d9:a067, sold as Sharkoon Drakonia and Perixx MX-2000

 * - USB ID 04d9:a04a, sold as Tracer Sniper TRM-503, NOVA Gaming Slider X200

 *   and Zalman ZM-GM1

 * - USB ID 04d9:a081, sold as SHARKOON DarkGlider Gaming mouse

 * - USB ID 04d9:a072, sold as LEETGION Hellion Gaming Mouse

 * - USB ID 04d9:a0c2, sold as ETEKCITY Scroll T-140 Gaming Mouse

		/* Change usage maximum and logical maximum from 0x7fff to

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * HID driver for Corsair devices

 *

 * Supported devices:

 *  - Vengeance K70 Keyboard

 *  - K70 RAPIDFIRE Keyboard

 *  - Vengeance K90 Keyboard

 *  - Scimitar PRO RGB Gaming Mouse

 *

 * Copyright (c) 2015 Clement Vuchener

 * Copyright (c) 2017 Oscar Campos

 * Copyright (c) 2017 Aaron Bottegal

/*

 G1 (0xd0) to G16 (0xdf) */

 G17 (0xe8) to G18 (0xe9) */

 USB control protocol */

/*

 * LED class devices

/*

 * Keyboard attributes

/*

 * Driver functions

 Init LED device for record LED */

 Init attributes */

/*

 * The report descriptor of some of the Corsair gaming mice is

 * non parseable as they define two consecutive Logical Minimum for

 * the Usage Page (Consumer) in rdescs bytes 75 and 77 being 77 0x16

 * that should be obviousy 0x26 for Logical Magimum of 16 bits. This

 * prevents poper parsing of the report descriptor due Logical

 * Minimum being larger than Logical Maximum.

 *

 * This driver fixes the report descriptor for:

 * - USB ID 1b1c:1b34, sold as GLAIVE RGB Gaming mouse

 * - USB ID 1b1c:1b3e, sold as Scimitar RGB Pro Gaming mouse

		/*

		 * Corsair GLAIVE RGB and Scimitar RGB Pro report descriptor is

		 * broken and defines two different Logical Minimum for the

		 * Consumer Application. The byte 77 should be a 0x26 defining

		 * a 16 bits integer for the Logical Maximum but it is a 0x16

		 * instead (Logical Minimum)

	/*

	 * Vengeance K70 and K70 RAPIDFIRE share product IDs.

 Original K90 driver author */

 Scimitar PRO RGB driver author */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * HID driver for Google Fiber TV Box remote controls

 *

 * Copyright (c) 2014-2015 Google Inc.

 *

 * Author: Petri Gynther <pgynther@google.com>

 Google Fiber GFRM100 (Bluetooth classic) */

 Google Fiber GFRM200 (Bluetooth LE) */

 Consumer.0004 -> KEY_INFO */

 Consumer.0041 -> KEY_OK */

	/*

	 * Convert GFRM100 Search key reports into Consumer.0221 (Key.Search)

	 * reports. Ignore audio data.

	/*

	 * Enable software autorepeat with:

	 * - repeat delay: 400 msec

	 * - repeat period: 100 msec

		/*

		 * GFRM100 HID Report Descriptor does not describe the Search

		 * key reports. Thus, we need to add it manually here, so that

		 * those reports reach gfrm_raw_event() from hid_input_report().

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  (c) 1999 Andreas Gal		<gal@cs.uni-magdeburg.de>

 *  (c) 2000-2001 Vojtech Pavlik	<vojtech@ucw.cz>

 *  (c) 2007-2009 Jiri Kosina

 *

 *  HID debugging support

/*

 *

 * Should you need to contact me, the author, you can do so either by

 * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:

 * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic

 pages 0xff00 to 0xffff are vendor-specific */

/* Either output directly into simple seq_file, or (if f == NULL)

 * allocate a separate buffer that will then be passed to the 'events'

 * ringbuffer.

 *

 * This is because these functions can be called both for "one-shot"

 * "rdesc" while resolving, or for blocking "events".

 *

 * This holds both for resolv_usage_page() and hid_resolv_usage().

 First nibble tells us which system we're in. */

 This is a _signed_ nibble(!) */

 enqueue string to 'events' ring buffer */

 dump the report */

 dump HID report descriptor */

 dump parsed data and input mappings */

			/* if list->hdev is NULL we cannot remove_wait_queue().

			 * if list->hdev->debug is 0 then hid_debug_unregister()

			 * was already called and list->hdev is being destroyed.

			 * if we add remove_wait_queue() here we can hit a race.

 allow O_NONBLOCK from other threads */

	/* pass the fifo content to userspace, locking is not needed with only

	 * one concurrent reader and one concurrent writer

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *   Apple "Magic" Wireless Mouse driver

 *

 *   Copyright (c) 2010 Michael Poole <mdpoole@troilus.org>

 *   Copyright (c) 2010 Chase Douglas <chase.douglas@canonical.com>

/*

/* These definitions are not precise, but they're close enough.  (Bits

 * 0x03 seem to indicate the aspect ratio of the touch, bits 0x70 seem

 * to be some kind of bit mask -- 0x20 may be a near-field reading,

 * and 0x40 is actual contact, and 0x10 may be a start/stop or change

 * indication.)

 Number of high-resolution events for each low-resolution detent. */

 units */

/* Touch surface information. Dimension is in hundredths of a mm, min and max

/**

 * struct magicmouse_sc - Tracks Magic Mouse-specific data.

 * @input: Input device through which we report events.

 * @quirks: Currently unused.

 * @ntouches: Number of touches in most recent touch report.

 * @scroll_accel: Number of consecutive scroll motions.

 * @scroll_jiffies: Time of last scroll motion.

 * @touches: Most recent data for a touch, indexed by tracking ID.

 * @tracking_ids: Mapping of current touch input data to @touches.

	/* If there is only one "firm" touch, set touch to its

	 * tracking ID.

 Ignore this touch. */

		/* If some button was pressed before, keep it held

		 * down.  Otherwise, if there's exactly one firm

		 * touch, use that to override the mouse's guess.

 The button was released. */

 else: we keep the mouse's guess */

 USB_DEVICE_ID_APPLE_MAGICTRACKPAD */

 Store tracking ID and other fields. */

	/* If requested, emulate a scroll wheel by detecting small

	 * vertical touch motions.

 Calculate and apply the scroll motion. */

 Reset acceleration after half a second. */

 Generate the input events for this touch. */

 Expect four bytes of prefix, and N*9 bytes of touch data. */

		/* The following bits provide a device specific timestamp. They

		 * are unused here.

		 *

		 * ts = data[1] >> 6 | data[2] << 2 | data[3] << 10;

 Expect twelve bytes of prefix and N*9 bytes of touch data. */

 Expect six bytes of prefix, and N*8 bytes of touch data. */

		/* When emulating three-button mode, it is important

		 * to have the current touch information before

		 * generating a click event.

		/* The following bits provide a device specific timestamp. They

		 * are unused here.

		 *

		 * ts = data[3] >> 6 | data[4] << 2 | data[5] << 10;

 Size is either 8 or (14 + 8 * N) */

		/* When emulating three-button mode, it is important

		 * to have the current touch information before

		 * generating a click event.

		/* The following bits provide a device specific timestamp. They

		 * are unused here.

		 *

		 * ts = data[11] >> 6 | data[12] << 2 | data[13] << 10;

		/* Sometimes the trackpad sends two touch reports in one

		 * packet.

 USB_DEVICE_ID_APPLE_MAGICTRACKPAD */

		/*

		 * magic_mouse_raw_event has done all the work. Skip hidinput.

		 *

		 * Specifically, hidinput may modify BTN_LEFT and BTN_RIGHT,

		 * breaking emulate_3button.

		/* setting the device name to ensure the same driver settings

		 * get loaded, whether connected through bluetooth or USB

 USB_DEVICE_ID_APPLE_MAGICTRACKPAD */

		/* input->keybit is initialized with incorrect button info

		 * for Magic Trackpad. There really is only one physical

		 * button (BTN_LEFT == BTN_MOUSE). Make sure we don't

		 * advertise buttons that don't exist...

	/* Note: Touch Y position from the device is inverted relative

	 * to how pointer motion is reported (and relative to how USB

	 * HID recommends the coordinates work).  This driver keeps

	 * the origin at the same position, and just uses the additive

	 * inverse of the reported Y.

 USB_DEVICE_ID_APPLE_MAGICTRACKPAD */

	/*

	 * hid-input may mark device as using autorepeat, but neither

	 * the trackpad, nor the mouse actually want it.

 Magic Trackpad does not give relative data after switching to MT */

 clean msc->input to notify probe() of the failure */

 USB_VENDOR_ID_APPLE */

 USB_VENDOR_ID_APPLE */

 USB_DEVICE_ID_APPLE_MAGICTRACKPAD */

	/*

	 * Some devices repond with 'invalid report id' when feature

	 * report switching it into multitouch mode is sent to it.

	 *

	 * This results in -EIO from the _raw low-level transport callback,

	 * but there seems to be no other way of switching the mode.

	 * Thus the super-ugly hacky success check below.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Force feedback support for Betop based devices

 *

 *  The devices are distributed under various names and the same USB device ID

 *  can be used in both adapters and actual game controllers.

 *

 *  0x11c2:0x2208 "BTP2185 BFM mode Joystick"

 *   - tested with BTP2185 BFM Mode.

 *

 *  0x11C0:0x5506 "BTP2185 PC mode Joystick"

 *   - tested with BTP2185 PC Mode.

 *

 *  0x8380:0x1850 "BTP2185 V2 PC mode USB Gamepad"

 *   - tested with BTP2185 PC Mode with another version.

 *

 *  0x20bc:0x5500 "BTP2185 V2 BFM mode Joystick"

 *   - tested with BTP2171s.

 *  Copyright (c) 2014 Huang Bo <huangbobupt@163.com>

/*

	/*

	 * Actually there are 4 fields for 4 Bytes as below:

	 * -----------------------------------------

	 * Byte0  Byte1  Byte2	  Byte3

	 * 0x00   0x00   left_motor right_motor

	 * -----------------------------------------

	 * Do init them with default value.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Roccat Isku driver for Linux

 *

 * Copyright (c) 2011 Stefan Achatz <erazor_de@users.sourceforge.net>

/*

/*

 * Roccat Isku is a gamer keyboard with macro keys that can be configured in

 * 5 profiles.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * HID driver for THQ PS3 uDraw tablet

 *

 * Copyright (C) 2016 Red Hat Inc. All Rights Reserved

/*

 * Protocol information from:

 * https://brandonw.net/udraw/

 * and the source code of:

 * https://vvvv.org/contribution/udraw-hid

/*

 * The device is setup with multiple input devices:

 * - the touch area which works as a touchpad

 * - the tablet area which works as a touchpad/drawing tablet

 * - a joypad with a d-pad, and 7 buttons

 * - an accelerometer device

/*

 * Accelerometer min/max values

 * in order, X, Y and Z

 resolution in pixels */

 size in mm */

	/*

	 * The device's two-finger support is pretty unreliable, as

	 * the device could report a single touch when the two fingers

	 * are too close together, and the distance between fingers, even

	 * though reported is not in the same unit as the touches.

	 *

	 * We'll make do without it, and try to report the first touch

	 * as reliably as possible.

 joypad */

 For pen and touchpad */

 Save the last one-finger touch */

		/*

		 * We have a problem because x/y is the one for the

		 * second finger but we want the first finger given

		 * to user-space otherwise it'll look as if it jumped.

		 *

		 * See the udraw struct definition for why this was

		 * implemented this way.

 Save the position of the 2nd finger */

			/*

			 * Offset the 2-finger coords using the

			 * saved data from the first finger

 touchpad */

 pen */

 accel */

 let hidraw and hiddev handle the report */

 1G accel is reported as ~256, so clamp to 2G */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * drivers/input/tablet/wacom_sys.c

 *

 *  USB Wacom tablet support - system specific code

/*

 Queue events which have invalid tool type or serial number */

 If we go out of range, we need to flush the queue ASAP */

	/*

	 * wacom->hdev should never be null, but surprisingly, I had the case

	 * once while unplugging the Wacom Wireless Receiver.

/*

 * Calculate the resolution of the X or Y axis using hidinput_calc_abs_res.

	/*

	 * The Dell Canvas 27 needs to be switched to its vendor-defined

	 * report to provide the best resolution.

	/*

	 * ISDv4 devices which predate HID's adoption of the

	 * HID_DG_BARELSWITCH2 usage use 0x000D0000 in its

	 * position instead. We can accurately detect if a

	 * usage with that value should be HID_DG_BARRELSWITCH2

	 * based on the surrounding usages, which have remained

	 * constant across generations.

	/*

	 * Wacom's AES devices use different vendor-defined usages to

	 * report serial number information compared to their branded

	 * hardware. The usages are also sometimes ill-defined and do

	 * not have the correct logical min/max values set. Lets patch

	 * the descriptor to use the branded usage convention and fix

	 * the errors.

 2nd-generation Intuos Pro Large has incorrect Y maximum */

 leave touch_max as is if predefined */

 read manually */

 Ignore if value index is out of bounds. */

 read manually */

/*

 * Interface Descriptor of wacom devices can be incomplete and

 * inconsistent so wacom_features table is used to store stylus

 * device's packet lengths, various maximum values, and tablet

 * resolution based on product ID's.

 *

 * For devices that contain 2 interfaces, wacom_features table is

 * inaccurate for the touch interface.  Since the Interface Descriptor

 * for touch interfaces has pretty complete data, this function exists

 * to query tablet for this missing information instead of hard coding in

 * an additional table.

 *

 * A typical Interface Descriptor for a stylus will contain a

 * boot mouse application collection that is not of interest and this

 * function will ignore it.

 *

 * It also contains a digitizer application collection that also is not

 * of interest since any information it contains would be duplicate

 * of what is in wacom_features. Usually it defines a report of an array

 * of bytes that could be used as max length of the stylus packet returned.

 * If it happens to define a Digitizer-Stylus Physical Collection then

 * the X and Y logical values contain valid data but it is ignored.

 *

 * A typical Interface Descriptor for a touch interface will contain a

 * Digitizer-Finger Physical Collection which will define both logical

 * X/Y maximum as well as the physical size of tablet. Since touch

 * interfaces haven't supported pressure or distance, this is enough

 * information to override invalid values in the wacom_features table.

 *

 * Intuos5 touch interface and 3rd gen Bamboo Touch do not contain useful

 * data. We deal with them after returning from this function.

	/*

	* Requiring Stylus Usage will ignore boot mouse

	* X/Y values and some cases of invalid Digitizer X/Y

	* values commonly reported.

 Any last-minute generic device setup */

 check features first */

 Ignore if report count is out of bounds. */

 now check the input usages */

		/*

		 * Note that if the raw queries fail, it's not a hard failure

		 * and it is safe to continue

/*

 * Switch the tablet into its most-capable mode. Wacom tablets are

 * typically configured to power-up in a mode which sends mouse-like

 * reports to the OS. To get absolute position, pressure data, etc.

 * from the tablet, it is necessary to switch the tablet out of this

 * mode and into one which sends the full range of tablet data.

 MT Tablet PC touch */

 default features */

	/*

	 * The wireless device HID is basic and layout conflicts with

	 * other tablets (monitor and touch interface can look like pen).

	 * Skip the query for this type and modify defaults based on

	 * interface number.

 The defined oVid/oPid must match that of the sibling */

	/*

	 * Devices with the same VID/PID must share the same physical

	 * device path, while those with different VID/PID must share

	 * the same physical parent device path.

 Skip the remaining heuristics unless you are a HID_GENERIC device */

	/*

	 * Direct-input devices may not be siblings of indirect-input

	 * devices.

	/*

	 * Indirect-input devices may not be siblings of direct-input

	 * devices.

 Pen devices may only be siblings of touch devices */

 Touch devices may only be siblings of pen devices */

	/*

	 * No reason could be found for these two devices to NOT be

	 * siblings, so there's a good chance they ARE siblings

 Try to find an already-probed interface from the same device */

 Fallback to finding devices that appear to be "siblings" */

 wireless connected */

		/*

		 * Touch Ring and crop mark LED luminance may take on

		 * one of four values:

		 *    0 = Low; 1 = Medium; 2 = High; 3 = Off

 Power Connection LED (ORANGE)

 BT Connection LED (BLUE)

 Paper Mode (RED?)

 Paper Mode (GREEN?)

 Paper Mode (BLUE?)

 4 chunks are needed to be sent */

 Send 'start' command */

 Send 'stop' */

 device doesn't support brightness tuning */

	/*

	 * There is a bug (?) in devm_led_classdev_register() in which its

	 * increments the refcount of the parent. If the parent is an input

	 * device, that means the ref count never reaches 0 when

	 * devm_input_device_release() gets called.

	 * This means that the LEDs are still there after disconnect.

	 * Manually force the release of the group so that the leds are released

	 * once we are done using them.

/*

 * wacom_led_next: gives the next available led with a wacom trigger.

 *

 * returns the next available struct wacom_led which has its default trigger

 * or the current one if none is available.

 Initialize default values */

 no pen in use on this interface */

 no touch in use on this interface */

 no pad in use on this interface */

/*

 * Not all devices report physical dimensions from HID.

 * Compute the default from hardcoded logical dimension

 * and resolution before driver overwrites them.

 set unit to "100th of a mm" for devices not reported by HID */

 Leave some room for suffixes */

 Generic devices name unspecified */

 strip out excess whitespaces */

 shift everything including the terminator */

 get rid of trailing whitespace */

 Append the device type to the name */

		/* Hardware touch switch may be off. Wait until

		 * we know the switch state to decide is_touch_on.

		 * Softkey state should be initialized to "on" to

		 * match historic default.

	/*

	 * Bamboo Pad has a generic hid handling for the Pen, and we switch it

	 * into debug mode for the touch part.

	 * We ignore the other interfaces.

 set the default size in case we do not get them from hid */

 Retrieve the physical and logical size for touch devices */

 pen only Bamboo neither support touch nor pad */

 Regular HID work starts now */

 Note that if query fails it is not a hard failure */

 touch only Bamboo doesn't support pen */

	/*

	 * Regardless if this is a disconnect or a new tablet,

	 * remove any existing input and battery devices.

 Stylus interface */

 Touch interface */

 Stylus interface */

 Touch interface */

	/* A remote can pair more than once with an EKR,

	 * check to make sure this serial isn't already paired.

 hid-core sets this quirk for the boot interface */

 ask for the report descriptor to be loaded by HID */

 make sure we don't trigger the LEDs */

 switch to wacom mode first */

 CONFIG_PM */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  HID driver for Retrode 2 controller adapter and plug-in extensions

 *

 *  Copyright (c) 2017 Bastien Nocera <hadess@hadess.net>

/*

 Has no effect on the mouse device */

 SPDX-License-Identifier: GPL-2.0+

/*

 * HID driver for Valve Steam Controller

 *

 * Copyright (c) 2018 Rodrigo Rivas Costa <rodrigorivascosta@gmail.com>

 *

 * Supports both the wired and wireless interfaces.

 *

 * This controller has a builtin emulation of mouse and keyboard: the right pad

 * can be used as a mouse, the shoulder buttons are mouse buttons, A and B

 * buttons are ENTER and ESCAPE, and so on. This is implemented as additional

 * HID interfaces.

 *

 * This is known as the "lizard mode", because apparently lizards like to use

 * the computer from the coach, without a proper mouse and keyboard.

 *

 * This driver will disable the lizard mode when the input device is opened

 * and re-enable it when the input device is closed, so as not to break user

 * mode behaviour. The lizard_mode parameter can be used to change that.

 *

 * There are a few user space applications (notably Steam Client) that use

 * the hidraw interface directly to create input devices (XTest, uinput...).

 * In order to avoid breaking them this driver creates a layered hidraw device,

 * so it can detect when the client is running and then:

 *  - it will not send any command to the controller.

 *  - this input device will be removed, to avoid double input of the same

 *    user action.

 * When the client is closed, this input device will be created again.

 *

 * For additional functions, such as changing the right-pad margin or switching

 * the led, you can use the user-space tool at:

 *

 *   https://github.com/rodrigorc/steamctrl

 Touch pads are 40 mm in diameter and 65535 units */

 Trigger runs are about 5 mm and 256 units */

 Joystick runs are about 5 mm and 256 units */

/*

 * Commands that can be sent in a feature report.

 * Thanks to Valve for some valuable hints.

 Some useful register ids */

 Raw event identifiers */

 Values for GYRO_MODE (bitmask) */

 Other random constants */

	/*

	 * The report ID is always 0, so strip the first byte from the output.

	 * hid_report_len() is not counting the report ID, so +1 to the length

	 * or else we get a EOVERFLOW. We are safe from a buffer overflow

	 * because hid_alloc_report_buf() allocates +7 bytes.

 The report ID is always 0 */

	/*

	 * Sometimes the wireless controller fails with EPIPE

	 * when sending a feature report.

	 * Doing a HID_REQ_GET_REPORT and waiting for a while

	 * seems to fix that.

 u8 reg, u16 val */...)

 Send: 0x87 len (reg valLo valHi)* */

	/*

	 * Send: 0xae 0x15 0x01

	 * Recv: 0xae 0x15 0x01 serialnumber (10 chars)

/*

 * This command requests the wireless adaptor to post an event

 * with the connection status. Useful if this driver is loaded when

 * the controller is already connected.

 enable esc, enter, cursors */

 enable mouse */

 enable margin */

 disable esc, enter, cursor */

 disable mouse */

 disable margin */

 mV -> uV */

 avoid the warning of 0% battery while waiting for the first info */

	/*

	 * This function can be called several times in a row with the

	 * wireless adaptor, without steam_unregister() between them, because

	 * another client send a get_connection_status command, for example.

	 * The battery and serial number are set just once per device.

		/*

		 * Unlikely, but getting the serial could fail, and it is not so

		 * important, so make up a serial number and go on.

 ignore battery errors, we can live without it */

	/*

	 * The wired device creates 3 interfaces:

	 *  0: emulated mouse.

	 *  1: emulated keyboard.

	 *  2: the real game pad.

	 * The wireless device creates 5 interfaces:

	 *  0: emulated keyboard.

	 *  1-4: slots where up to 4 real game pads will be connected to.

	 * We know which one is the real gamepad interface because they are the

	 * only ones with a feature report.

	/*

	 * Since we use the same device info than the real interface to

	 * trick userspace, we will be calling steam_probe recursively.

	 * We need to recognize the client interface somehow.

	/*

	 * The virtual client_dev is only used for hidraw.

	 * Also avoid the recursive probe.

	/*

	 * The non-valve interfaces (mouse and keyboard emulation) are

	 * connected without changes.

	/*

	 * With the real steam controller interface, do not connect hidraw.

	 * Instead, create the client_hid and connect that.

 If using a wireless adaptor ask for connection status */

 A wired connection is always present */

/*

 * Some input data in the protocol has the opposite sign.

 * Clamp the values to 32767..-32767 so that the range is

 * symmetrical and can be negated safely.

/*

 * The size for this message payload is 60.

 * The known values are:

 *  (* values are not sent through wireless)

 *  (* accelerator/gyro is disabled by default)

 *  Offset| Type  | Mapped to |Meaning

 * -------+-------+-----------+--------------------------

 *  4-7   | u32   | --        | sequence number

 *  8-10  | 24bit | see below | buttons

 *  11    | u8    | ABS_HAT2Y | left trigger

 *  12    | u8    | ABS_HAT2X | right trigger

 *  13-15 | --    | --        | always 0

 *  16-17 | s16   | ABS_X/ABS_HAT0X     | X value

 *  18-19 | s16   | ABS_Y/ABS_HAT0Y     | Y value

 *  20-21 | s16   | ABS_RX    | right-pad X value

 *  22-23 | s16   | ABS_RY    | right-pad Y value

 *  24-25 | s16   | --        | * left trigger

 *  26-27 | s16   | --        | * right trigger

 *  28-29 | s16   | --        | * accelerometer X value

 *  30-31 | s16   | --        | * accelerometer Y value

 *  32-33 | s16   | --        | * accelerometer Z value

 *  34-35 | s16   | --        | gyro X value

 *  36-36 | s16   | --        | gyro Y value

 *  38-39 | s16   | --        | gyro Z value

 *  40-41 | s16   | --        | quaternion W value

 *  42-43 | s16   | --        | quaternion X value

 *  44-45 | s16   | --        | quaternion Y value

 *  46-47 | s16   | --        | quaternion Z value

 *  48-49 | --    | --        | always 0

 *  50-51 | s16   | --        | * left trigger (uncalibrated)

 *  52-53 | s16   | --        | * right trigger (uncalibrated)

 *  54-55 | s16   | --        | * joystick X value (uncalibrated)

 *  56-57 | s16   | --        | * joystick Y value (uncalibrated)

 *  58-59 | s16   | --        | * left-pad X value

 *  60-61 | s16   | --        | * left-pad Y value

 *  62-63 | u16   | --        | * battery voltage

 *

 * The buttons are:

 *  Bit  | Mapped to  | Description

 * ------+------------+--------------------------------

 *  8.0  | BTN_TR2    | right trigger fully pressed

 *  8.1  | BTN_TL2    | left trigger fully pressed

 *  8.2  | BTN_TR     | right shoulder

 *  8.3  | BTN_TL     | left shoulder

 *  8.4  | BTN_Y      | button Y

 *  8.5  | BTN_B      | button B

 *  8.6  | BTN_X      | button X

 *  8.7  | BTN_A      | button A

 *  9.0  | BTN_DPAD_UP    | lef-pad up

 *  9.1  | BTN_DPAD_RIGHT | lef-pad right

 *  9.2  | BTN_DPAD_LEFT  | lef-pad left

 *  9.3  | BTN_DPAD_DOWN  | lef-pad down

 *  9.4  | BTN_SELECT | menu left

 *  9.5  | BTN_MODE   | steam logo

 *  9.6  | BTN_START  | menu right

 *  9.7  | BTN_GEAR_DOWN | left back lever

 * 10.0  | BTN_GEAR_UP   | right back lever

 * 10.1  | --         | left-pad clicked

 * 10.2  | BTN_THUMBR | right-pad clicked

 * 10.3  | BTN_THUMB  | left-pad touched (but see explanation below)

 * 10.4  | BTN_THUMB2 | right-pad touched

 * 10.5  | --         | unknown

 * 10.6  | BTN_THUMBL | joystick clicked

 * 10.7  | --         | lpad_and_joy

 24 bits of buttons */

	/*

	 * These two bits tells how to interpret the values X and Y.

	 * lpad_and_joy tells that the joystick and the lpad are used at the

	 * same time.

	 * lpad_touched tells whether X/Y are to be read as lpad coord or

	 * joystick values.

	 * (lpad_touched || lpad_and_joy) tells if the lpad is really touched.

 Check if joystick is centered */

 Check if lpad is untouched */

/*

 * The size for this message payload is 11.

 * The known values are:

 *  Offset| Type  | Meaning

 * -------+-------+---------------------------

 *  4-7   | u32   | sequence number

 *  8-11  | --    | always 0

 *  12-13 | u16   | voltage (mV)

 *  14    | u8    | battery percent

 Creating the battery may have failed */

	/*

	 * All messages are size=64, all values little-endian.

	 * The format is:

	 *  Offset| Meaning

	 * -------+--------------------------------------------

	 *  0-1   | always 0x01, 0x00, maybe protocol version?

	 *  2     | type of message

	 *  3     | length of the real payload (not checked)

	 *  4-n   | payload data, depends on the type

	 *

	 * There are these known types of message:

	 *  0x01: input data (60 bytes)

	 *  0x03: wireless connect/disconnect (1 byte)

	 *  0x04: battery status (11 bytes)

		/*

		 * The payload of this event is a single byte:

		 *  0x01: disconnected.

		 *  0x02: connected.

 Wired Steam Controller */

 Wireless Steam Controller */

 SPDX-License-Identifier: GPL-2.0+

/*

 * HID driver for Nintendo Switch Joy-Cons and Pro Controllers

 *

 * Copyright (c) 2019-2021 Daniel J. Ogorchock <djogorchock@gmail.com>

 *

 * The following resources/projects were referenced for this driver:

 *   https://github.com/dekuNukem/Nintendo_Switch_Reverse_Engineering

 *   https://gitlab.com/pjranki/joycon-linux-kernel (Peter Rankin)

 *   https://github.com/FrotBot/SwitchProConLinuxUSB

 *   https://github.com/MTCKC/ProconXInput

 *   https://github.com/Davidobot/BetterJoyForCemu

 *   hid-wiimote kernel hid driver

 *   hid-logitech-hidpp driver

 *   hid-sony driver

 *

 * This driver supports the Nintendo Switch Joy-Cons and Pro Controllers. The

 * Pro Controllers can either be used over USB or Bluetooth.

 *

 * The driver will retrieve the factory calibration info from the controllers,

 * so little to no user calibration should be required.

 *

/*

 * Reference the url below for the following HID report defines:

 * https://github.com/dekuNukem/Nintendo_Switch_Reverse_Engineering

 Output Reports */

 Subcommand IDs */

 Input Reports */

 Feature Reports */

 USB Commands */

 Magic value denoting presence of user calibration */

 SPI storage addresses of user calibration data */

 SPI storage addresses of factory calibration data */

 SPI storage addresses of IMU factory calibration data */

 SPI storage addresses of IMU user calibration data */

 The raw analog joystick values will be mapped in terms of this magnitude */

 Hat values for pro controller's d-pad */

 Under most circumstances IMU reports are pushed every 15ms; use as default */

 How many samples to sum before calculating average IMU report delta */

 Controls how many dropped IMU packets at once trigger a warning message */

/*

 * The controller's accelerometer has a sensor resolution of 16bits and is

 * configured with a range of +-8000 milliGs. Therefore, the resolution can be

 * calculated thus: (2^16-1)/(8000 * 2) = 4.096 digits per milliG

 * Resolution per G (rather than per millliG): 4.096 * 1000 = 4096 digits per G

 * Alternatively: 1/4096 = .0002441 Gs per digit

/*

 * The controller's gyroscope has a sensor resolution of 16bits and is

 * configured with a range of +-2000 degrees/second.

 * Digits per dps: (2^16 -1)/(2000*2) = 16.38375

 * dps per digit: 16.38375E-1 = .0610

 *

 * STMicro recommends in the datasheet to add 15% to the dps/digit. This allows

 * the full sensitivity range to be saturated without clipping. This yields more

 * accurate results, so it's the technique this driver uses.

 * dps per digit (corrected): .0610 * 1.15 = .0702

 * digits per dps (corrected): .0702E-1 = 14.247

 *

 * Now, 14.247 truncating to 14 loses a lot of precision, so we rescale the

 * min/max range by 1000.

 Note: change mag and res_per_dps if prec_range_scale is ever altered */

 (2^16-1)*1000 */

 (14.247*1000) */

 frequency/amplitude tables for rumble */

 Hz*/

/*

 * These tables are from

 * https://github.com/dekuNukem/Nintendo_Switch_Reverse_Engineering/blob/master/rumble_data_table.md

 high, low, freq */

 high, low, amp */

 States for controller state machine */

 Controller type received as part of device info */

/*

 * All the controller's button values are stored in a u32.

 * They can be accessed with bitwise ANDs.

 capture button */

 must be 0x01 for subcommand, 0x10 for rumble only */

 incremented every send */

 length depends on the subcommand */

 MSB 1 for ACK, 0 for NACK */

 id of requested subcmd */

 will be at most 35 bytes */

 battery and connection info */

 IMU input reports contain 3 samples */

 Each physical controller is associated with a joycon_ctlr struct */

 player leds */

 The following members are used for synchronous sends/receives */

 factory calibration data */

 prevents needlessly recalculating these divisors every sample */

 power supply data */

 rumble */

 imu */

 helps in initiating timestamp */

 timestamp we report to userspace */

 used to calc imu report delta */

 the following are used to track the average imu report time delta */

 Helper macros for checking controller type */

 Does this controller have inputs associated with left joycon? */

 Does this controller have inputs associated with right joycon? */

	/*

	 * If we are in the proper reporting mode, wait for an input

	 * report prior to sending the subcommand. This improves

	 * reliability considerably.

 We will still proceed, even with a timeout here */

/*

 * Sending subcommands and/or rumble data at too high a rate can cause bluetooth

 * controller disconnections.

	/*

	 * The controller occasionally seems to drop subcommands. In testing,

	 * doing one retry after a timeout appears to always work.

	/*

	 * If the controller has been removed, just return ENODEV so the LED

	 * subsystem doesn't print invalid errors on removal.

 Supply nibbles for flash and on. Ones correspond to active */

 The read data starts at the 6th byte */

/*

 * User calibration's presence is denoted with a magic byte preceding it.

 * returns 0 if magic val is present, 1 if not present, < 0 on error

 stick calibration parsing: note the order differs based on stick */

 check if user stick calibrations are present */

 read the left stick calibration data */

 read the right stick calibration data */

/*

 * These divisors are calculated once rather than for each sample. They are only

 * dependent on the IMU calibration values. They are used when processing the

 * IMU input reports.

= 0*/;

= 0*/;

 check if user calibration exists */

 request IMU calibration data */

 IMU calibration parsing */

 standard, full report mode */

 note: 0x00 would disable */

 note: 0x00 would disable */

 point to next imu sample */

 3 reports per packet */

	/*

	 * There are complexities surrounding how we determine the timestamps we

	 * associate with the samples we pass to userspace. The IMU input

	 * reports do not provide us with a good timestamp. There's a quickly

	 * incrementing 8-bit counter per input report, but it is not very

	 * useful for this purpose (it is not entirely clear what rate it

	 * increments at or if it varies based on packet push rate - more on

	 * the push rate below...).

	 *

	 * The reverse engineering work done on the joy-cons and pro controllers

	 * by the community seems to indicate the following:

	 * - The controller samples the IMU every 1.35ms. It then does some of

	 *   its own processing, probably averaging the samples out.

	 * - Each imu input report contains 3 IMU samples, (usually 5ms apart).

	 * - In the standard reporting mode (which this driver uses exclusively)

	 *   input reports are pushed from the controller as follows:

	 *      * joy-con (bluetooth): every 15 ms

	 *      * joy-cons (in charging grip via USB): every 15 ms

	 *      * pro controller (USB): every 15 ms

	 *      * pro controller (bluetooth): every 8 ms (this is the wildcard)

	 *

	 * Further complicating matters is that some bluetooth stacks are known

	 * to alter the controller's packet rate by hardcoding the bluetooth

	 * SSR for the switch controllers (android's stack currently sets the

	 * SSR to 11ms for both the joy-cons and pro controllers).

	 *

	 * In my own testing, I've discovered that my pro controller either

	 * reports IMU sample batches every 11ms or every 15ms. This rate is

	 * stable after connecting. It isn't 100% clear what determines this

	 * rate. Importantly, even when sending every 11ms, none of the samples

	 * are duplicates. This seems to indicate that the time deltas between

	 * reported samples can vary based on the input report rate.

	 *

	 * The solution employed in this driver is to keep track of the average

	 * time delta between IMU input reports. In testing, this value has

	 * proven to be stable, staying at 15ms or 11ms, though other hardware

	 * configurations and bluetooth stacks could potentially see other rates

	 * (hopefully this will become more clear as more people use the

	 * driver).

	 *

	 * Keeping track of the average report delta allows us to submit our

	 * timestamps to userspace based on that. Each report contains 3

	 * samples, so the IMU sampling rate should be avg_time_delta/3. We can

	 * also use this average to detect events where we have dropped a

	 * packet. The userspace timestamp for the samples will be adjusted

	 * accordingly to prevent unwanted behvaior.

 avg imu report delta housekeeping */

 don't ever want divide by zero shenanigans */

 useful for debugging IMU sample rate */

 check if any packets have been dropped */

 Each IMU input report contains three samples */

		/*

		 * These calculations (which use the controller's calibration

		 * settings to improve the final values) are based on those

		 * found in the community's reverse-engineering repo (linked at

		 * top of driver). For hid-nintendo, we make sure that the final

		 * value given to userspace is always in terms of the axis

		 * resolution we provided.

		 *

		 * Currently only the gyro calculations subtract the calibration

		 * offsets from the raw value itself. In testing, doing the same

		 * for the accelerometer raw values decreased accuracy.

		 *

		 * Note that the gyro values are multiplied by the

		 * precision-saving scaling factor to prevent large inaccuracies

		 * due to truncation of the resolution value which would

		 * otherwise occur. To prevent overflow (without resorting to 64

		 * bit integer math), the mult_frac macro is used.

		/*

		 * The right joy-con has 2 axes negated, Y and Z. This is due to

		 * the orientation of the IMU in the controller. We negate those

		 * axes' values in order to be consistent with the left joy-con

		 * and the pro controller:

		 *   X: positive is pointing toward the triggers

		 *   Y: positive is pointing to the left

		 *   Z: positive is pointing up (out of the buttons/sticks)

		 * The axes follow the right-hand rule.

 negate all but x axis */

 convert to micros and divide by 3 (3 samples per report). */

		/*

		 * When this value reaches 0, we know we've sent multiple

		 * packets to the controller instructing it to disable rumble.

		 * We can safely stop sending periodic rumble packets until the

		 * next ff effect.

 Parse the battery status */

 empty */

 low */

 medium */

 high */

 full */

 Parse the buttons and sticks */

 get raw stick values */

 map the stick values */

 report sticks */

 report buttons */

 Report the S buttons as the non-existent triggers */

 Report d-pad as digital buttons for the joy-cons */

 d-pad x */

 d-pad y */

 get raw stick values */

 map stick values */

 report sticks */

 report buttons */

 Report the S buttons as the non-existent triggers */

	/*

	 * Immediately after receiving a report is the most reliable time to

	 * send a subcommand to the controller. Wake any subcommand senders

	 * waiting for a report.

 parse IMU data if present */

	/*

	 * If the controller has been removed, just return ENODEV so the LED

	 * subsystem doesn't print invalid errors on removal.

 -ENODEV means the controller was just unplugged */

 limit number of silent rumble packets to reduce traffic */

 right joy-con */

 left joy-con */

 don't wait for the periodic send (reduces latency) */

 IS_ENABLED(CONFIG_NINTENDO_FF) */

 0 signals end of array */

 0 signals end of array */

 We report joy-con d-pad inputs as buttons and pro controller as a hat. */

 Should be impossible */

 set up sticks and buttons */

 configure d-pad differently for joy-con vs pro controller */

 Let's report joy-con S triggers separately */

 set up rumble */

 configure the imu input device */

 configure imu axes */

 determine which player led this is */

 Set the default controller player leds based on controller number */

 configure the player LEDs */

 configure the home LED */

 Set the home LED to 0 as default state */

 Set initially to unknown before receiving first input report */

 Configure the battery's description */

 Retrieve the type so we can distinguish for charging grip */

 Common handler for parsing inputs */

 make sure it contains the input report */

 This message has been handled */

	/*

	 * Patch the hw version of pro controller/joycons, so applications can

	 * distinguish between the default HID mappings and the mappings defined

	 * by the Linux game controller spec. This is important for the SDL2

	 * library, which has a game controller database, which uses device ids

	 * in combination with version as a key.

 Initialize the controller */

 if handshake command fails, assume ble pro controller */

 set baudrate for improved latency */

 handshake */

		/*

		 * Set no timeout (to keep controller in USB mode).

		 * This doesn't send a response, so ignore the timeout.

 get controller calibration data, and parse it */

		/*

		 * We can function with default calibration, but it may be

		 * inaccurate. Provide a warning, and continue on.

 get IMU calibration data, and parse it */

		/*

		 * We can function with default calibration, but it may be

		 * inaccurate. Provide a warning, and continue on.

 Set the reporting mode to 0x30, which is the full report mode */

 Enable rumble */

 Enable the IMU */

 Initialize the leds */

 Initialize the battery power supply */

 Prevent further attempts at sending subcommands. */

 SPDX-License-Identifier: GPL-2.0+

/*

 *  HID driver for gaming keys on Logitech gaming keyboards (such as the G15)

 *

 *  Copyright (c) 2019 Hans de Goede <hdegoede@redhat.com>

 Must be first for proper dma alignment */

 Protects the transfer_buf and led brightness */

******* G15 and G15 v2 LED functions ********/

 Ignore LED off on unregister / keyboard unplug */

 Success */

******* G510 LED functions ********/

 Must be called with g15->mutex locked */

 Success */

 Ignore LED off on unregister / keyboard unplug */

 Ignore LED off on unregister / keyboard unplug */

 Success */

******* Generic LED functions ********/

		/*

		 * Getting the LCD backlight brightness is not supported.

		 * Reading Feature(2) fails with -EPIPE and this crashes

		 * the LCD and touch keys part of the speakers.

 Never reached */

******* Input functions ********/

 On the G15 Mark I Logitech has been quite creative with which bit is what */

 Most left (round/display) button below the LCD */

 4 other buttons below the LCD */

 G1 - G6 */

 G7 - G12 */

 G13 - G17 */

 G18 */

 M1 - M3 */

 MR */

 Backlight cycle button pressed? */

 G1 - G6 */

 M1 - M3 + MR */

 Round button to the left of the LCD */

 4 buttons below the LCD */

 Backlight cycle button pressed? */

 G1 - G18 */

 Game mode on/off slider */

 M1 - M3 */

 MR */

 LCD menu keys */

 Headphone Mute */

 Microphone Mute */

	/*

	 * The G510 ignores backlight updates when the backlight is turned off

	 * through the light toggle button on the keyboard, to work around this

	 * we queue a workitem to sync values when the backlight is turned on.

			/*

			 * The G510 does not have a separate LCD brightness,

			 * but it does have a separate power-on (reset) value.

 Common input device init code shared between keyboards and Z-10 speaker handling */

 Keys below the LCD, intended for controlling a menu on the LCD */

	/*

	 * Some models have multiple interfaces, we want the interface with

	 * with the f000.0000 application input report.

		/*

		 * The G15 and G15 v2 use a separate usb-device (on a builtin

		 * hub) which emulates a keyboard for the F1 - F12 emulation

		 * on the G-keys, which we disable, rendering the emulated kbd

		 * non-functional, so we do not let hid-input connect.

 Tell the keyboard to stop sending F1-F12 + 1-6 for G1 - G18 */

		/*

		 * The kbd ignores our output report if we do not queue

		 * an URB on the USB input endpoint first...

 Get initial brightness levels */

 All done */

 Setup and register input device */

 G-keys */

 M1 - M3 and MR keys */

	/*

	 * On the G510 only report headphone and mic mute keys when *not* using

	 * the builtin USB audio device. When the builtin audio is used these

	 * keys directly toggle mute (and the LEDs) on/off.

 Userspace expects F20 for micmute */

 Register LED devices */

 The G11 is a G15 without the LCD, treat it as a G15 */

 G510 without a headset plugged in */

 G510 with headset plugged in / with extra USB audio interface */

 Z-10 speakers */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  HID driver for Waltop devices not fully compliant with HID standard

 *

 *  Copyright (c) 2010 Nikolai Kondrashov

/*

/*

 * There exists an official driver on the manufacturer's website, which

 * wasn't submitted to the kernel, for some reason. The official driver

 * doesn't seem to support extra features of some tablets, like wheels.

 *

 * It shows that the feature report ID 2 could be used to control any waltop

 * tablet input mode, switching it between "default", "tablet" and "ink".

 *

 * This driver only uses "default" mode for all the supported tablets. This

 * mode tries to be HID-compatible (not very successfully), but cripples the

 * resolution of some tablets.

 *

 * The "tablet" mode uses some proprietary, yet decipherable protocol, which

 * represents the correct resolution, but is possibly HID-incompatible (i.e.

 * indescribable by a report descriptor).

 *

 * The purpose of the "ink" mode is unknown.

 *

 * The feature reports needed for switching to each mode are these:

 *

 * 02 16 00     default

 * 02 16 01     tablet

 * 02 16 02     ink

 Size of the original report descriptor of Slim Tablet 5.8 inch */

 Fixed Slim Tablet 5.8 inch descriptor */

  Usage Page (Digitizer),             */

  Usage (Pen),                        */

  Collection (Application),           */

      Report ID (16),                 */

      Usage (Stylus),                 */

      Collection (Physical),          */

          Usage (Tip Switch),         */

          Usage (Barrel Switch),      */

          Usage (Tablet Pick),        */

          Logical Minimum (1),        */

          Logical Maximum (3),        */

          Report Size (4),            */

          Report Count (1),           */

          Input,                      */

          Usage (In Range),           */

          Logical Minimum (0),        */

          Logical Maximum (1),        */

          Report Size (1),            */

          Report Count (1),           */

          Input (Variable),           */

          Report Count (3),           */

          Input (Constant, Variable), */

          Report Size (16),           */

          Report Count (1),           */

          Logical Minimum (0),        */

          Push,                       */

          Usage Page (Desktop),       */

          Unit (Inch),                */

          Unit Exponent (-3),         */

          Physical Minimum (0),       */

          Usage (X),                  */

          Physical Maximum (5000),    */

          Logical Maximum (10000),    */

          Input (Variable),           */

          Usage (Y),                  */

          Physical Maximum (3000),    */

          Logical Maximum (6000),     */

          Input (Variable),           */

          Pop,                        */

          Usage (Tip Pressure),       */

          Logical Maximum (1023),     */

          Input (Variable),           */

      End Collection,                 */

  End Collection                      */

 Size of the original report descriptor of Slim Tablet 12.1 inch */

 Fixed Slim Tablet 12.1 inch descriptor */

  Usage Page (Digitizer),             */

  Usage (Pen),                        */

  Collection (Application),           */

      Report ID (16),                 */

      Usage (Stylus),                 */

      Collection (Physical),          */

          Usage (Tip Switch),         */

          Usage (Barrel Switch),      */

          Usage (Tablet Pick),        */

          Logical Minimum (1),        */

          Logical Maximum (3),        */

          Report Size (4),            */

          Report Count (1),           */

          Input,                      */

          Usage (In Range),           */

          Logical Minimum (0),        */

          Logical Maximum (1),        */

          Report Size (1),            */

          Report Count (1),           */

          Input (Variable),           */

          Report Count (3),           */

          Input (Constant, Variable), */

          Report Size (16),           */

          Report Count (1),           */

          Logical Minimum (0),        */

          Push,                       */

          Usage Page (Desktop),       */

          Unit (Inch),                */

          Unit Exponent (-3),         */

          Physical Minimum (0),       */

          Usage (X),                  */

          Physical Maximum (10000),   */

          Logical Maximum (20000),    */

          Input (Variable),           */

          Usage (Y),                  */

          Physical Maximum (6250),    */

          Logical Maximum (12500),    */

          Input (Variable),           */

          Pop,                        */

          Usage (Tip Pressure),       */

          Logical Maximum (1023),     */

          Input (Variable),           */

      End Collection,                 */

  End Collection                      */

 Size of the original report descriptor of Q Pad */

 Fixed Q Pad descriptor */

  Usage Page (Digitizer),             */

  Usage (Pen),                        */

  Collection (Application),           */

      Report ID (16),                 */

      Usage (Stylus),                 */

      Collection (Physical),          */

          Usage (Tip Switch),         */

          Usage (Barrel Switch),      */

          Usage (Tablet Pick),        */

          Logical Minimum (1),        */

          Logical Maximum (3),        */

          Report Size (4),            */

          Report Count (1),           */

          Input,                      */

          Usage (In Range),           */

          Logical Minimum (0),        */

          Logical Maximum (1),        */

          Report Size (1),            */

          Report Count (1),           */

          Input (Variable),           */

          Report Count (3),           */

          Input (Constant, Variable), */

          Report Size (16),           */

          Report Count (1),           */

          Logical Minimum (0),        */

          Push,                       */

          Usage Page (Desktop),       */

          Unit (Inch),                */

          Unit Exponent (-3),         */

          Physical Minimum (0),       */

          Usage (X),                  */

          Physical Maximum (6000),    */

          Logical Maximum (12288),    */

          Input (Variable),           */

          Usage (Y),                  */

          Physical Maximum (4500),    */

          Logical Maximum (9216),     */

          Input (Variable),           */

          Pop,                        */

          Usage (Tip Pressure),       */

          Logical Maximum (1023),     */

          Input (Variable),           */

      End Collection,                 */

  End Collection                      */

 Size of the original report descriptor of tablet with PID 0038 */

/*

 * Fixed report descriptor for tablet with PID 0038.

  Usage Page (Digitizer),             */

  Usage (Pen),                        */

  Collection (Application),           */

      Report ID (16),                 */

      Usage (Stylus),                 */

      Collection (Physical),          */

          Usage (Tip Switch),         */

          Usage (Barrel Switch),      */

          Usage (Tablet Pick),        */

          Logical Minimum (1),        */

          Logical Maximum (3),        */

          Report Size (4),            */

          Report Count (1),           */

          Input,                      */

          Usage (In Range),           */

          Logical Minimum (0),        */

          Logical Maximum (1),        */

          Report Size (1),            */

          Report Count (1),           */

          Input (Variable),           */

          Report Count (3),           */

          Input (Constant, Variable), */

          Report Size (16),           */

          Report Count (1),           */

          Logical Minimum (0),        */

          Push,                       */

          Usage Page (Desktop),       */

          Unit (Inch),                */

          Unit Exponent (-3),         */

          Physical Minimum (0),       */

          Usage (X),                  */

          Physical Maximum (8750),    */

          Logical Maximum (17920),    */

          Input (Variable),           */

          Usage (Y),                  */

          Physical Maximum (5250),    */

          Logical Maximum (10752),    */

          Input (Variable),           */

          Pop,                        */

          Usage (Tip Pressure),       */

          Logical Maximum (1023),     */

          Input (Variable),           */

      End Collection,                 */

  End Collection                      */

 Size of the original report descriptor of Media Tablet 10.6 inch */

 Fixed Media Tablet 10.6 inch descriptor */

  Usage Page (Digitizer),             */

  Usage (Pen),                        */

  Collection (Application),           */

      Report ID (16),                 */

      Usage (Stylus),                 */

      Collection (Physical),          */

          Usage (Tip Switch),         */

          Usage (Barrel Switch),      */

          Usage (Tablet Pick),        */

          Logical Minimum (1),        */

          Logical Maximum (3),        */

          Report Size (4),            */

          Report Count (1),           */

          Input,                      */

          Report Size (1),            */

          Usage (In Range),           */

          Logical Minimum (0),        */

          Logical Maximum (1),        */

          Report Count (1),           */

          Input (Variable),           */

          Report Count (3),           */

          Input (Constant, Variable), */

          Report Size (16),           */

          Report Count (1),           */

          Logical Minimum (0),        */

          Push,                       */

          Usage Page (Desktop),       */

          Unit (Inch),                */

          Unit Exponent (-3),         */

          Physical Minimum (0),       */

          Usage (X),                  */

          Physical Maximum (9000),    */

          Logical Maximum (18000),    */

          Input (Variable),           */

          Usage (Y),                  */

          Physical Maximum (5500),    */

          Logical Maximum (11000),    */

          Input (Variable),           */

          Pop,                        */

          Usage (Tip Pressure),       */

          Logical Maximum (1023),     */

          Input (Variable),           */

      End Collection,                 */

  End Collection,                     */

  Usage Page (Desktop),               */

  Usage (Mouse),                      */

  Collection (Application),           */

      Report ID (1),                  */

      Usage (Pointer),                */

      Collection (Physical),          */

          Report Size (8),            */

          Report Count (3),           */

          Input (Constant, Variable), */

          Report Count (2),           */

          Logical Minimum (-1),       */

          Logical Maximum (1),        */

          Usage (Wheel),              */

          Usage (Consumer AC Pan),    */

          Input (Variable, Relative), */

          Report Count (2),           */

          Input (Constant, Variable), */

      End Collection,                 */

  End Collection,                     */

  Usage Page (Consumer),              */

  Usage (Consumer Control),           */

  Collection (Application),           */

      Report ID (13),                 */

      Report Count (1),               */

      Report Size (16),               */

      Input (Constant, Variable),     */

      Usage (AC Zoom),                */

      Usage (AC Zoom Out),            */

      Usage (AC Zoom In),             */

      Usage (Scan Previous Track),    */

      Usage (Scan Next Track),        */

      Usage (00h),                    */

      Usage (00h),                    */

      Usage (00h),                    */

      Usage (00h),                    */

      Usage (00h),                    */

      Usage (AC Zoom Out),            */

      Usage (AC Zoom In),             */

      Logical Minimum (12),           */

      Logical Maximum (23),           */

      Report Size (5),                */

      Input,                          */

      Report Size (3),                */

      Input (Constant, Variable),     */

      Report Size (32),               */

      Input (Constant, Variable),     */

  End Collection,                     */

  Usage (Consumer Control),           */

  Collection (Application),           */

      Report ID (12),                 */

      Report Size (1),                */

      Usage (Volume Inc),             */

      Usage (Volume Dec),             */

      Usage (Mute),                   */

      Logical Minimum (0),            */

      Logical Maximum (1),            */

      Report Count (3),               */

      Input (Variable, Relative),     */

      Report Count (53),              */

      Input (Constant, Variable),     */

  End Collection                      */

 Size of the original report descriptor of Media Tablet 14.1 inch */

 Fixed Media Tablet 14.1 inch descriptor */

  Usage Page (Digitizer),             */

  Usage (Pen),                        */

  Collection (Application),           */

      Report ID (16),                 */

      Usage (Stylus),                 */

      Collection (Physical),          */

          Usage (Tip Switch),         */

          Usage (Barrel Switch),      */

          Usage (Tablet Pick),        */

          Logical Minimum (1),        */

          Logical Maximum (3),        */

          Report Size (4),            */

          Report Count (1),           */

          Input,                      */

          Report Size (1),            */

          Usage (In Range),           */

          Logical Minimum (0),        */

          Logical Maximum (1),        */

          Report Count (1),           */

          Input (Variable),           */

          Report Count (3),           */

          Input (Constant, Variable), */

          Report Size (16),           */

          Report Count (1),           */

          Logical Minimum (0),        */

          Push,                       */

          Usage Page (Desktop),       */

          Unit (Inch),                */

          Unit Exponent (-3),         */

          Physical Minimum (0),       */

          Usage (X),                  */

          Physical Maximum (12000),   */

          Logical Maximum (16383),    */

          Input (Variable),           */

          Usage (Y),                  */

          Physical Maximum (7250),    */

          Logical Maximum (16383),    */

          Input (Variable),           */

          Pop,                        */

          Usage (Tip Pressure),       */

          Logical Maximum (1023),     */

          Input (Variable),           */

      End Collection,                 */

  End Collection,                     */

  Usage Page (Desktop),               */

  Usage (Mouse),                      */

  Collection (Application),           */

      Report ID (1),                  */

      Usage (Pointer),                */

      Collection (Physical),          */

          Report Size (8),            */

          Report Count (3),           */

          Input (Constant, Variable), */

          Report Count (2),           */

          Logical Minimum (-1),       */

          Logical Maximum (1),        */

          Usage (Wheel),              */

          Usage (Consumer AC Pan),    */

          Input (Variable, Relative), */

      End Collection,                 */

  End Collection,                     */

  Usage Page (Consumer),              */

  Usage (Consumer Control),           */

  Collection (Application),           */

      Report ID (13),                 */

      Report Count (1),               */

      Report Size (16),               */

      Input (Constant, Variable),     */

      Usage (AC Zoom),                */

      Usage (AC Zoom Out),            */

      Usage (AC Zoom In),             */

      Usage (Scan Previous Track),    */

      Usage (Scan Next Track),        */

      Usage (00h),                    */

      Usage (00h),                    */

      Usage (00h),                    */

      Usage (00h),                    */

      Usage (00h),                    */

      Usage (AC Zoom Out),            */

      Usage (AC Zoom In),             */

      Logical Minimum (12),           */

      Logical Maximum (23),           */

      Report Size (5),                */

      Input,                          */

      Report Size (3),                */

      Input (Constant, Variable),     */

      Report Size (32),               */

      Input (Constant, Variable),     */

  End Collection,                     */

  Usage (Consumer Control),           */

  Collection (Application),           */

      Report ID (12),                 */

      Report Size (1),                */

      Usage (Volume Inc),             */

      Usage (Volume Dec),             */

      Usage (Mute),                   */

      Logical Minimum (0),            */

      Logical Maximum (1),            */

      Report Count (3),               */

      Input (Variable, Relative),     */

      Report Size (5),                */

      Input (Constant, Variable),     */

  End Collection                      */

 Size of the original report descriptor of Sirius Battery Free Tablet */

 Fixed Sirius Battery Free Tablet descriptor */

  Usage Page (Digitizer),             */

  Usage (Pen),                        */

  Collection (Application),           */

      Report ID (16),                 */

      Usage (Stylus),                 */

      Collection (Physical),          */

          Report Count (1),           */

          Logical Minimum (1),        */

          Logical Maximum (3),        */

          Report Size (2),            */

          Usage (Tip Switch),         */

          Usage (Barrel Switch),      */

          Usage (Tablet Pick),        */

          Input,                      */

          Logical Minimum (0),        */

          Logical Maximum (1),        */

          Report Size (1),            */

          Usage (Invert),             */

          Input (Variable),           */

          Input (Constant, Variable), */

          Usage (In Range),           */

          Input (Variable),           */

          Report Count (3),           */

          Input (Constant, Variable), */

          Push,                       */

          Usage Page (Desktop),       */

          Unit Exponent (-3),         */

          Unit (Inch),                */

          Physical Minimum (0),       */

          Logical Minimum (0),        */

          Report Size (16),           */

          Report Count (1),           */

          Physical Maximum (10000),   */

          Logical Maximum (20000),    */

          Usage (X),                  */

          Input (Variable),           */

          Physical Maximum (6000),    */

          Logical Maximum (12000),    */

          Usage (Y),                  */

          Input (Variable),           */

          Pop,                        */

          Report Size (16),           */

          Report Count (1),           */

          Logical Minimum (0),        */

          Logical Maximum (1023),     */

          Usage (Tip Pressure),       */

          Input (Variable),           */

          Push,                       */

          Unit Exponent (-2),         */

          Unit (Radians),             */

          Physical Minimum (-105),    */

          Physical Maximum (105),     */

          Logical Minimum (-105),     */

          Logical Maximum (105),      */

          Report Size (8),            */

          Report Count (2),           */

          Usage (X Tilt),             */

          Usage (Y Tilt),             */

          Input (Variable),           */

          Pop,                        */

      End Collection,                 */

  End Collection,                     */

  Usage Page (Desktop),               */

  Usage (Mouse),                      */

  Collection (Application),           */

      Report ID (1),                  */

      Usage (Pointer),                */

      Collection (Physical),          */

          Report Size (8),            */

          Report Count (3),           */

          Input (Constant, Variable), */

          Usage (Wheel),              */

          Logical Minimum (-1),       */

          Logical Maximum (1),        */

          Report Size (8),            */

          Report Count (1),           */

          Input (Variable, Relative), */

          Report Size (8),            */

          Report Count (3),           */

          Input (Constant, Variable), */

      End Collection,                 */

  End Collection,                     */

  Usage Page (Desktop),               */

  Usage (Keyboard),                   */

  Collection (Application),           */

      Report ID (13),                 */

      Usage Page (Keyboard),          */

      Usage Minimum (KB Leftcontrol), */

      Usage Maximum (KB Right GUI),   */

      Logical Minimum (0),            */

      Logical Maximum (1),            */

      Report Size (1),                */

      Report Count (8),               */

      Input (Variable),               */

      Report Size (8),                */

      Report Count (1),               */

      Input (Constant),               */

      Usage Minimum (None),           */

      Usage Maximum (KB Application), */

      Logical Minimum (0),            */

      Logical Maximum (101),          */

      Report Size (8),                */

      Report Count (5),               */

      Input,                          */

  End Collection,                     */

  Usage Page (Consumer),              */

  Usage (Consumer Control),           */

  Collection (Application),           */

      Report ID (12),                 */

      Usage (Volume Inc),             */

      Usage (Volume Dec),             */

      Logical Minimum (0),            */

      Logical Maximum (1),            */

      Report Size (1),                */

      Report Count (2),               */

      Input (Variable),               */

      Report Size (6),                */

      Report Count (1),               */

      Input (Constant, Variable),     */

      Report Size (16),               */

      Report Count (3),               */

      Input (Constant, Variable),     */

  End Collection                      */

 If this is a pen input report */

		/*

		 * Ignore reported pressure when a barrel button is pressed,

		 * because it is rarely correct.

 If a barrel button is pressed */

 Report zero pressure */

 If this is a pen input report of Sirius Battery Free Tablet */

		/*

		 * The tablet reports tilt as roughly sin(a)*21 (18 means 60

		 * degrees).

		 *

		 * This array stores angles as radians * 100, corresponding to

		 * reported values up to 60 degrees, as expected by userspace.

		/*

		 * Reverse the Y Tilt direction to match the HID standard and

		 * userspace expectations. See HID Usage Tables v1.12 16.3.2

		 * Tilt Orientation.

		/*

		 * This effectively clamps reported tilt to 60 degrees - the

		 * range expected by userspace

 SPDX-License-Identifier: GPL-2.0-only

/*

 * HID driver for the apple ir device

 *

 * Original driver written by James McKenzie

 * Ported to recent 2.6 kernel versions by Greg Kroah-Hartman <gregkh@suse.de>

 * Updated to support newer remotes by Bastien Nocera <hadess@hadess.net>

 * Ported to HID subsystem by Benjamin Tissoires <benjamin.tissoires@gmail.com>

 *

 * Copyright (C) 2006 James McKenzie

 * Copyright (C) 2008 Greg Kroah-Hartman <greg@kroah.com>

 * Copyright (C) 2008 Novell Inc.

 * Copyright (C) 2010, 2012 Bastien Nocera <hadess@hadess.net>

 * Copyright (C) 2013 Benjamin Tissoires <benjamin.tissoires@gmail.com>

 * Copyright (C) 2013 Red Hat Inc. All Rights Reserved

/*

 * James McKenzie has two devices both of which report the following

 * 25 87 ee 83 0a	+

 * 25 87 ee 83 0c	-

 * 25 87 ee 83 09	<<

 * 25 87 ee 83 06	>>

 * 25 87 ee 83 05	>"

 * 25 87 ee 83 03	menu

 * 26 00 00 00 00	for key repeat

/*

 * Thomas Glanzmann reports the following responses

 * 25 87 ee ca 0b	+

 * 25 87 ee ca 0d	-

 * 25 87 ee ca 08	<<

 * 25 87 ee ca 07	>>

 * 25 87 ee ca 04	>"

 * 25 87 ee ca 02	menu

 * 26 00 00 00 00       for key repeat

 *

 * He also observes the following event sometimes

 * sent after a key is release, which I interpret

 * as a flat battery message

 * 25 87 e0 ca 06	flat battery

/*

 * Alexandre Karpenko reports the following responses for Device ID 0x8242

 * 25 87 ee 47 0b	+

 * 25 87 ee 47 0d	-

 * 25 87 ee 47 08	<<

 * 25 87 ee 47 07	>>

 * 25 87 ee 47 04	>"

 * 25 87 ee 47 02	menu

 * 26 87 ee 47 **	for key repeat (** is the code of the key being held)

/*

 * Bastien Nocera's remote

 * 25 87 ee 91 5f	followed by

 * 25 87 ee 91 05	gives you >"

 *

 * 25 87 ee 91 5c	followed by

 * 25 87 ee 91 05	gives you the middle button

/*

 * Fabien Andre's remote

 * 25 87 ee a3 5e	followed by

 * 25 87 ee a3 04	gives you >"

 *

 * 25 87 ee a3 5d	followed by

 * 25 87 ee a3 04	gives you the middle button

 timer for key up */

 protects .current_key */

 the currently pressed key */

 key index in a 2 packets message */

	/*

	 * The key is coded accross bits 2..9:

	 *

	 * 0x00 or 0x01 (        )	key:  0		-> KEY_RESERVED

	 * 0x02 or 0x03 (  menu  )	key:  1		-> KEY_MENU

	 * 0x04 or 0x05 (   >"   )	key:  2		-> KEY_PLAYPAUSE

	 * 0x06 or 0x07 (   >>   )	key:  3		-> KEY_FORWARD

	 * 0x08 or 0x09 (   <<   )	key:  4		-> KEY_BACK

	 * 0x0a or 0x0b (    +   )	key:  5		-> KEY_VOLUMEUP

	 * 0x0c or 0x0d (    -   )	key:  6		-> KEY_VOLUMEDOWN

	 * 0x0e or 0x0f (        )	key:  7		-> KEY_RESERVED

	 * 0x50 or 0x51 (        )	key:  8		-> KEY_RESERVED

	 * 0x52 or 0x53 (        )	key:  9		-> KEY_RESERVED

	 * 0x54 or 0x55 (        )	key: 10		-> KEY_RESERVED

	 * 0x56 or 0x57 (        )	key: 11		-> KEY_RESERVED

	 * 0x58 or 0x59 (        )	key: 12		-> KEY_RESERVED

	 * 0x5a or 0x5b (        )	key: 13		-> KEY_RESERVED

	 * 0x5c or 0x5d ( middle )	key: 14		-> KEY_ENTER

	 * 0x5e or 0x5f (   >"   )	key: 15		-> KEY_PLAYPAUSE

	 *

	 * Packets starting with 0x5 are part of a two-packets message,

	 * we notify the caller by sending a negative value.

 Part of a 2 packets-command */

		/*

		 * If we already have a key down, take it up before marking

		 * this one down

 Handle dual packet commands */

			/*

			 * Remote doesn't do key up, either pull them up, in

			 * the test above, or here set a timer which pulls

			 * them up after 1/8 s

 Remember key for next packet */

		/*

		 * Remote doesn't do key up, either pull them up, in the test

		 * above, or here set a timer which pulls them up after 1/8 s

 Fall through */

 let hidraw and hiddev handle the report */

 force input as some remotes bypass the input registration */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  HID driver for Lenovo:

 *  - ThinkPad USB Keyboard with TrackPoint (tpkbd)

 *  - ThinkPad Compact Bluetooth Keyboard with TrackPoint (cptkbd)

 *  - ThinkPad Compact USB Keyboard with TrackPoint (cptkbd)

 *

 *  Copyright (c) 2012 Bernhard Seibold

 *  Copyright (c) 2014 Jamie Lentin <jm@lentin.co.uk>

 *

 * Linux IBM/Lenovo Scrollpoint mouse driver:

 * - IBM Scrollpoint III

 * - IBM Scrollpoint Pro

 * - IBM Scrollpoint Optical

 * - IBM Scrollpoint Optical 800dpi

 * - IBM Scrollpoint Optical 800dpi Pro

 * - Lenovo Scrollpoint Optical

 *

 *  Copyright (c) 2012 Peter De Wachter <pdewacht@gmail.com>

 *  Copyright (c) 2018 Peter Ganzhorn <peter.ganzhorn@gmail.com>

/*

 Userspace expects F20 for mic-mute KEY_MICMUTE does not work */

 Must be first for proper alignment */

 0:Up, 1:Down (undecided), 2:Scrolling */

 Usage Page (Vendor Usage Page 0x88)	*/

 Usage (Vendor Usage 0x01)		*/

 Collection (Application)		*/

  Report ID (4)			*/

  Usage Minimum (0)			*/

  Usage Maximum (65535)		*/

		/* the fixups that need to be done:

		 *   - get a reasonable usage max for the vendor collection

		 *     0x8801 from the report ID 4

 This sub-device contains trackpoint, mark it */

 HID_UP_LNVENDOR = USB, HID_UP_MSVENDOR = BT */

 Fn-F4: Mic mute */

 Fn-F5: Brightness down */

 Fn-F6: Brightness up */

 Fn-F7: External display (projector) */

 Fn-F8: Wireless */

 Fn-F9: Control panel */

 Fn-F11: View open applications (3 boxes) */

 Fn-F12: Open My computer (6 boxes) USB-only */

 NB: This mapping is invented in raw_event below */

 Fn-Esc: Fn-lock toggle */

 Middle mouse button (in native mode) */

 Compatibility middle/wheel mappings should be ignored */

 Map wheel emulation reports: 0xffa1 = USB, 0xff10 = BT */

	/*

	 * The ThinkPad 10 Ultrabook Keyboard uses 0x000c0001 usage for

	 * a bunch of keys which have no standard consumer page code.

 Fn-Esc: Fn-lock toggle */

 Fn-F4: Mic mute */

 Fn-F7: Control panel */

 Fn-F8: Search (magnifier glass) */

 Fn-F10: Open My computer (6 boxes) */

	/*

	 * The Ultrabook Keyboard sends a spurious F23 key-press when resuming

	 * from suspend and it does not actually have a F23 key, ignore it.

	/*

	 * The ThinkPad X1 Tablet Thin Keyboard uses 0x000c0001 usage for

	 * a bunch of keys which have no standard consumer page code.

 Fn-F10: Enable/disable bluetooth */

 Fn-F11: Keyboard settings */

 Fn-F12: User function / Cortana */

 Fn-PrtSc: Snipping tool */

 Fn-Esc: Fn-lock toggle */

 Fn-F4: Mute/unmute microphone */

 Fn-F9: Settings */

 Fn-F7: Manage external displays */

 Fn-F8: Enable/disable wifi */

 Send a config command to the keyboard */

 BT returns 0, USB returns sizeof(buf) */

	/*

	 * Compact USB keyboard's Fn-F12 report holds down many other keys, and

	 * its own key is outside the usage page range. Remove extra

	 * keypresses and remap to inside usage page.

		/*

		 * The user has toggled the Fn-lock state. Toggle our own

		 * cached value of it and sync our value to the keyboard to

		 * ensure things are in sync (the sycning should be a no-op).

 "wheel" scroll events */

 Scroll events disable middle-click event */

 Middle click events */

 No scrolling inbetween, send middle-click */

 unknown setting, imitate windows driver

	/*

	 * Only register extra settings against subdevice where input_mapping

	 * set drvdata to 1, i.e. the trackpoint.

 Validate required reports. */

 set same default values as windows driver

 All the custom action happens on the USBMOUSE device for USB */

	/*

	 * Tell the keyboard a driver understands it, and turn F7, F9, F11 into

	 * regular keys

 Switch middle button to native mode */

 Set keyboard settings to known state */

	/*

	 * The LEDs and the Fn-lock functionality use output report 9,

	 * with an application of 0xffa0001, add the LEDs on the interface

	 * with this output report.

	/*

	 * The Thinkpad 10 ultrabook USB kbd dock's Fn-lock defaults to on.

	 * We cannot read the state, only set it, so we force it to on here

	 * (which should be a no-op) to make sure that our state matches the

	 * keyboard's FN-lock state. This is the same as what Windows does.

	/*

	 * Only the trackpoint half of the keyboard has drvdata and stuff that

	 * needs unregistering.

 set only for trackpoint device */

	/*

	 * Note bind to the HID_GROUP_GENERIC group, so that we only bind to the keyboard

	 * part, while letting hid-multitouch.c handle the touchpad and trackpoint.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * HID driver for Nintendo Wii / Wii U peripherals

 * Copyright (c) 2011-2013 David Herrmann <dh.herrmann@gmail.com>

/*

 output queue handling */

	/*

	 * Copy new request into our output queue and check whether the

	 * queue is full. If it is full, discard this request.

	 * If it is empty we need to start a new worker that will

	 * send out the buffer to the hid device.

	 * If the queue is not empty, then there must be a worker

	 * that is currently sending out our buffer and this worker

	 * will reschedule itself until the queue is empty.

/*

 * This sets the rumble bit on the given output report if rumble is

 * currently enabled.

 * \cmd1 must point to the second byte in the output report => &cmd[1]

 * This must be called on nearly every output report before passing it

 * into the output queue!

/*

 * Check what peripherals of the wiimote are currently

 * active and select a proper DRM that supports all of

 * the requested data inputs.

 *

 * Not all combinations are actually supported. The following

 * combinations work only with limitations:

 *  - IR cam in extended or full mode disables any data transmission

 *    of extension controllers. There is no DRM mode that supports

 *    extension bytes plus extended/full IR.

 *  - IR cam with accelerometer and extension *_EXT8 is not supported.

 *    However, all extensions that need *_EXT8 are devices that don't

 *    support IR cameras. Hence, this shouldn't happen under normal

 *    operation.

 *  - *_EXT16 is only supported in combination with buttons and

 *    accelerometer. No IR or similar can be active simultaneously. As

 *    above, all modules that require it are mutually exclusive with

 *    IR/etc. so this doesn't matter.

 some 3rd-party balance-boards are hard-coded to KEE, *sigh* */

			/* GEN10 and ealier devices bind IR formats to DRMs.

			 * Hence, we cannot use DRM_KAI here as it might be

			 * bound to IR_EXT. Use DRM_KAIE unconditionally so we

			 * work with all devices and our parsers can use the

 requries the cmd-mutex to be held */

 requries the cmd-mutex to be held */

 requires the cmd-mutex to be held */

 initialize extension */

 disable default encryption */

 requires the cmd-mutex to be held */

 read extension ID */

 requires the cmd-mutex to be held */

 initialize MP */

 disable default encryption */

 requires the cmd-mutex to be held */

 map MP with correct pass-through mode */

 requires the cmd-mutex to be held */

 read motion plus ID */

 requires the cmd-mutex to be held */

 read motion plus ID */

 device module handling */

 find end of list */

 empty */ ;

 device extension handling */

 device (re-)initialization and detection */

/* Try to guess the device type based on all collected information. We

 * first try to detect by static extension types, then VID/PID and the

 * device name. If we cannot detect the device, we use

 schedule MP timer */

/*

 * MP hotplug events are not generated by the wiimote. Therefore, we need

 * polling to detect it. We use a 4s interval for polling MP registers. This

 * seems reasonable considering applications can trigger it manually via

 * sysfs requests.

 load/unload MP module if it changed */

/*

 * Check whether the wiimote is in the expected state. The extension registers

 * may change during hotplug and initialization so we might get hotplug events

 * that we caused by remapping some memory.

 * We use some heuristics here to check known states. If the wiimote is in the

 * expected state, we can ignore the hotplug event.

 *

 * Returns "true" if the device is in expected state, "false" if we should

 * redo hotplug handling and extension initialization.

	/* If MP is used and active, but the extension is not, we expect:

	 *   read_mp_mapped() == WIIMOTE_MP_SINGLE

	 *   state.flags == !EXT_ACTIVE && !MP_PLUGGED && MP_ACTIVE

	 * We do not check EXT_PLUGGED because it might change during

	 * initialization of MP without extensions.

	 *  - If MP is unplugged/replugged, read_mp_mapped() fails

 while MP is mapped, we get EXT_PLUGGED events */

	/* If MP is unused, but the extension port is used, we expect:

	 *   read_ext == state.exttype

	 *   state.flags == !MP_ACTIVE && EXT_ACTIVE

	 * - If MP is plugged/unplugged, our timer detects it

 poll MP for hotplug events */

	/* If neither MP nor an extension are used, we expect:

	 *   read_ext() == WIIMOTE_EXT_NONE

	 *   state.flags == !MP_ACTIVE && !EXT_ACTIVE && !EXT_PLUGGED

	 * No need to perform any action in this case as everything is

	 * disabled already.

	 * - If MP is plugged/unplugged, our timer detects it

 poll MP for hotplug events */

	/* The trickiest part is if both EXT and MP are active. We cannot read

	 * the EXT ID, anymore, because MP is mapped over it. However, we use

	 * a handy trick here:

	 *   - EXT_ACTIVE is unset whenever !MP_PLUGGED is sent

	 * MP_PLUGGED might be re-sent again before we are scheduled, but

	 * EXT_ACTIVE will stay unset.

	 * So it is enough to check for mp_mapped() and MP_ACTIVE and

 while MP is mapped, we get EXT_PLUGGED events */

 unknown state */

 only poll for MP if requested and if state didn't change */

/*

 * Handle hotplug events

 * If we receive an hotplug event and the device-check failed, we deinitialize

 * the extension ports, re-read all extension IDs and set the device into

 * the desired state. This involves mapping MP into the main extension

 * registers, setting up extension passthrough modes and initializing the

 * requested extensions.

 get state snapshot that we will then work on */

 disable event forwarding temporarily */

 init extension and MP (deactivates current extension or MP) */

 load/unload extension module if it changed */

 unload previous extension */

 try loading new extension */

 load/unload MP module if it changed */

 if MP is not used, do not map or activate it */

 map MP into main extension registers if used */

 delete MP hotplug timer */

 reschedule MP hotplug timer */

 enable data forwarding again and set expected hotplug state */

 request status report for hotplug state updates */

 protocol handlers */

 if MP is active, track MP slot hotplugging */

 this bit is set for invalid events (eg. during hotplug) */

 detect MP data that is sent interleaved with EXT data */

 ignore EXT events if no extension is active */

 try forwarding to extension handler, first */

 try forwarding to MP handler */

 try forwarding to loaded modules */

 reduced status report with "BB BB" key data only */

 on status reports the drm is reset so we need to resend the drm */

 extended status report with "BB BB LF 00 00 VV" data */

 update extension status */

 reduced generic report with "BB BB" key data only */

 prevent init_worker from being scheduled again */

 schedule device detection */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Force feedback support for Zeroplus based devices

 *

 *  Copyright (c) 2005, 2006 Anssi Hannula <anssi.hannula@gmail.com>

/*

	/*

	 * The following is specified the other way around in the Zeroplus

	 * datasheet but the order below is correct for the XFX Executioner;

	 * however it is possible that the XFX Executioner is an exception

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Force feedback support for hid-compliant for some of the devices from

 * Logitech, namely:

 * - WingMan Cordless RumblePad

 * - WingMan Force 3D

 *

 *  Copyright (c) 2002-2004 Johann Deneux

 *  Copyright (c) 2006 Anssi Hannula <anssi.hannula@gmail.com>

/*

 *

 * Should you need to contact me, the author, you can do so by

 * e-mail - mail your message to <johann.deneux@it.uu.se>

 0x7f is center */

 clockwise strength */

 counter-clockwise strength */

 Check that the report looks ok */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Roccat Lua driver for Linux

 *

 * Copyright (c) 2012 Stefan Achatz <erazor_de@users.sourceforge.net>

/*

/*

 * Roccat Lua is a gamer mouse which cpi, button and light settings can be

 * configured.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  HID driver for Gembird Joypad, "PC Game Controller"

 *

 *  Copyright (c) 2015 Red Hat, Inc

 *  Copyright (c) 2015 Benjamin Tissoires

/*

   Report Size (8)		*/

   Report Count (5)		*/

   Logical Minimum (0)	*/

   Logical Maximum (255)	*/

   Physical Minimum (0)	*/

   Physical Maximum (255)	*/

   Usage (X)			*/

   Usage (Y)			*/

   Usage (Z)			*/

   Usage (Z)			*/

   Usage (Rz)			*/

   Input (Data,Var,Abs)	*/

/*

 * we fix the report descriptor by:

 * - marking the first Z axis as constant (so it is ignored by HID)

 * - assign the original second Z to Rx

 * - assign the original Rz to Ry

   Report Size (8)		*/

   Report Count (2)		*/

   Logical Minimum (0)	*/

   Logical Maximum (255)	*/

   Physical Minimum (0)	*/

   Physical Maximum (255)	*/

   Usage (X)			*/

   Usage (Y)			*/

   Input (Data,Var,Abs)	*/

   Report Count (1)		*/

   Usage (Z)			*/

   Input (Cnst,Arr,Abs)	*/

   Report Count (2)		*/

   Usage (Rx)			*/

   Usage (Ry)			*/

   Input (Data,Var,Abs)	*/

 delta_size is > 0 */

 start by copying the end of the rdesc */

 add the correct beginning */

 replace the faulty part with the fixed one */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * HID driver for TwinHan IR remote control

 *

 * Based on hid-gyration.c

 *

 * Copyright (c) 2009 Bruno Prémont <bonbons@linux-vserver.org>

/*

/*	Remote control key layout + listing:

 *

 * 	Full Screen                              Power

 *	KEY_SCREEN                          KEY_POWER2

 *

 *	1                     2                      3

 *	KEY_NUMERIC_1   KEY_NUMERIC_2    KEY_NUMERIC_3

 *

 *	4                     5                      6

 *	KEY_NUMERIC_4   KEY_NUMERIC_5    KEY_NUMERIC_6

 *

 *	7                     8                      9

 *	KEY_NUMERIC_7   KEY_NUMERIC_8    KEY_NUMERIC_9

 *

 *	REC                   0               Favorite

 *	KEY_RECORD      KEY_NUMERIC_0    KEY_FAVORITES

 *

 *	Rewind                                 Forward

 *	KEY_REWIND           CH+           KEY_FORWARD

 *	               KEY_CHANNELUP

 *

 *	VOL-                  >                   VOL+

 *	KEY_VOLUMEDOWN    KEY_PLAY        KEY_VOLUMEUP

 *

 *	                     CH-

 *	              KEY_CHANNELDOWN

 *	Recall                                    Stop

 *	KEY_RESTART                           KEY_STOP

 *

 *	Timeshift/Pause     Mute                Cancel

 *	KEY_PAUSE         KEY_MUTE          KEY_CANCEL

 *

 *	Capture            Preview                 EPG

 *	KEY_PRINT        KEY_PROGRAM           KEY_EPG

 *

 *	Record List          Tab              Teletext

 *	KEY_LIST            KEY_TAB           KEY_TEXT

 Map all keys from Twinhan Remote */

 Power       = 0x0e0 + 0x0e1 + 0x0e2 + 0x03f */

 Volume down = 0x0e1 + 0x051                 */

 Volume up   = 0x0e1 + 0x052                 */

	/* Kill the extra keys used for multi-key "power" and "volume" keys

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright (c) 2016 Masaki Ota <masaki.ota@jp.alps.com>

 ALPS Device Product ID */

 Mouse data ReportID */

 Absolute data ReportID */

 FW-PTP Absolute data ReportID */

 Feature ReportID */

 Feature ReportID */

 Feature Report Length */

 SP Support */

/**

 * struct alps_dev

 *

 * @input: pointer to the kernel input device

 * @input2: pointer to the kernel input2 device

 * @hdev: pointer to the struct hid_device

 *

 * @dev_type: device type

 * @max_fingers: total number of fingers

 * @has_sp: boolean of sp existense

 * @sp_btn_info: button information

 * @x_active_len_mm: active area length of X (mm)

 * @y_active_len_mm: active area length of Y (mm)

 * @x_max: maximum x coordinate value

 * @y_max: maximum y coordinate value

 * @x_min: minimum x coordinate value

 * @y_min: minimum y coordinate value

 * @btn_cnt: number of buttons

 * @sp_btn_cnt: number of stick buttons

 Calculate the checksum */

 Calculate the checksum */

 Device initialization */

 Button pad */

 Check StickPointer device */

 Allow incoming hid reports */

 Stick device initialization */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  HID driver for Semitek keyboards

 *

 *  Copyright (c) 2021 Benjamin Moody

	/* In the report descriptor for interface 2, fix the incorrect

	   description of report ID 0x04 (the report contains a

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  HID driver for Speedlink Vicious and Divine Cezanne (USB mouse).

 *  Fixes "jumpy" cursor and removes nonexistent keyboard LEDS from

 *  the HID descriptor.

 *

 *  Copyright (c) 2011, 2013 Stefan Kriwanek <dev@stefankriwanek.de>

/*

	/*

	 * The Cezanne mouse has a second "keyboard" USB endpoint for it is

	 * able to map keyboard events to the button presses.

	 * It sends a standard keyboard report descriptor, though, whose

	 * LEDs we ignore.

 No other conditions due to usage_table. */

	/* This fixes the "jumpy" cursor occuring due to invalid events sent

	 * by the device. Some devices only send them with value==+256, others

	 * don't. However, catching abs(value)>=256 is restrictive enough not

	 * to interfere with devices that were bug-free (has been tested).

 Drop useless distance 0 events (on button clicks etc.) as well */

 SPDX-License-Identifier: GPL-2.0-only

/***************************************************************************

 *   Copyright (C) 2010-2012 by Bruno Prémont <bonbons@linux-vserver.org>  *

 *                                                                         *

 *   Based on Logitech G13 driver (v0.4)                                   *

 *     Copyright (C) 2009 by Rick L. Vinyard, Jr. <rvinyard@cs.nmsu.edu>   *

 *                                                                         *

 ignore if rc_dev is NULL or status is shunned */

	/* PicoLCD USB packets contain 16-bit intervals in network order,

	 * with value negated for pulse. Intervals are in microseconds.

	 *

	 * Note: some userspace LIRC code for PicoLCD says negated values

	 * for space - is it a matter of IR chip? (pulse for my TSOP2236)

	 *

	 * In addition, the first interval seems to be around 15000 + base

	 * interval for non-first report of IR data - thus the quirk below

	 * to get RC_CODE to understand Sony and JVC remotes I have at hand

 Quirk!! - see above */

 initialize CIR input device */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Force feedback support for Logitech Gaming Wheels

 *

 *  Including G27, G25, DFP, DFGT, FFEX, Momo, Momo2 &

 *  Speed Force Wireless (WiiWheel)

 *

 *  Copyright (c) 2010 Simon Wood <simon@mungewell.org>

/*

 Protect output HID report */

 Number of commands to send */

 Multimode wheel identificators */

 Multimode wheel identification checklists */

 Compatibility mode switching commands */

 EXT_CMD9 - Understood by G27 and DFGT */

 Revert mode upon USB reset */

 Switch mode to DF-EX with detach */

 Revert mode upon USB reset */

 Switch mode to DFP with detach */

 Revert mode upon USB reset */

 Switch mode to G25 with detach */

 Revert mode upon USB reset */

 Switch mode to DFGT with detach */

 Revert mode upon USB reset */

 Switch mode to G27 with detach */

 Revert mode upon USB reset */

 Switch mode to G29 with detach */

 EXT_CMD1 - Understood by DFP, G25, G27 and DFGT */

 EXT_CMD16 - Understood by G25 and G27 */

 Recalculates X axis value accordingly to currently selected range */

 adjust HID report present combined pedals data */

 Compute a combined axis when wheel does not supply it */

 0x80 is no force */

 De-activate force in slot-1*/

 Slot 1 */

/* Sends default autocentering command compatible with

 De-activate Auto-Center */

 Adjust for non-MOMO wheels */

 Activate Auto-Center */

 Sends autocentering command compatible with Formula Force EX */

 Sends command to set range compatible with G25/G27/Driving Force GT */

 Sends commands to set range compatible with Driving Force Pro wheel */

 Prepare "coarse" limit command */

 Set later */

 Prepare "fine" limit command */

 Do not apply any fine limit */

 Construct fine limit command */

 DFP can only be switched to its native mode */

 G25 can only be switched to DFP mode or its native mode */

 G27 can only be switched to DF-EX, DFP, G25 or its native mode */

 G29 can only be switched to DF-EX, DFP, DFGT, G25, G27 or its native mode */

 DFGT can only be switched to DF-EX, DFP or its native mode */

 No other wheels have multiple modes */

 Print tag and full name */

 Mark the currently active mode with an asterisk */

 Allow \n at the end of the input parameter */

 Not needed anymore */

 Nothing to do */

 Automatic switching has to be disabled for the switch to DF-EX mode to work correctly */

 Take care of hardware limitations */

 Export the currently set range of the wheel */

/* Set range to user specified value, call appropriate function

	/* Check if the wheel supports range setting

 Real ID is a read-only value */

 identify current mode from USB PID */

	/* No match found. This is either Driving Force or an unknown

 Probed wheel is not a multimode wheel */

	/* Switch from "Driving Force" mode to native mode automatically.

			/* Wheel could not have been switched to native mode,

 Check that the report looks ok */

	/* Check if a multimode wheel has been connected and

	/* Wheel has been told to switch to native mode. There is no point in going on

	 * with the initialization as the wheel will do a USB reset when it switches mode

 Check what wheel has been connected */

 Set supported force feedback capabilities */

 Initialize device properties */

	/* Check if autocentering is available and

 Formula Force EX expects different autocentering command */

 Create sysfs interface */

 Set the maximum range to start with */

 register led subsystem - G27/G29 only */

 Deregister LEDs (if any) */

 Let the driver continue without LEDs */

 Nothing more to do */

 Multimode devices will have at least the "MODE_NATIVE" bit set */

 Deregister LEDs (if any) */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  HID driver for some monterey "special" devices

 *

 *  Copyright (c) 1999 Andreas Gal

 *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>

 *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc

 *  Copyright (c) 2006-2007 Jiri Kosina

 *  Copyright (c) 2008 Jiri Slaby

/*

 SPDX-License-Identifier: GPL-2.0-only

/*

 * HID raw devices, giving access to raw HID events.

 *

 * In comparison to hiddev, this device does not process the

 * hid events at all (no parsing, no lookups). This lets applications

 * to work on raw hid events as they want to, and avoids a need to

 * use a transport-specific userspace libhid/libusb libraries.

 *

 *  Copyright (c) 2007-2014 Jiri Kosina

 allow O_NONBLOCK to work well from other threads */

/*

 * The first byte of the report buffer is expected to be a report number.

		/*

		 * compatibility with old implementation of USB-HID and I2C-HID:

		 * if the device does not support receiving output reports,

		 * on an interrupt endpoint, fallback to SET_REPORT HID command.

/*

 * This function performs a Get_Report transfer over the control endpoint

 * per section 7.2.1 of the HID specification, version 1.1.  The first byte

 * of buffer is the report number to request, or 0x0 if the device does not

 * use numbered reports. The report_type parameter can be HID_FEATURE_REPORT

 * or HID_INPUT_REPORT.

	/*

	 * Read the first byte from the user. This is the report number,

	 * which is passed to hid_hw_raw_request().

 hidraw is always writable */

 close device for last reader */

 Begin Read-only ioctls. */

 we accept any HID device, all applications */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * MCP2221A - Microchip USB to I2C Host Protocol Bridge

 *

 * Copyright (c) 2020, Rishi Gupta <gupt21@gmail.com>

 *

 * Datasheet: https://ww1.microchip.com/downloads/en/DeviceDoc/20005565B.pdf

 Commands codes in a raw output report */

 Response codes in a raw input report */

 MCP GPIO direction encoding */

 MCP GPIO set command layout */

 MCP GPIO get command layout */

/*

 * There is no way to distinguish responses. Therefore next command

 * is sent only after response to previous has been received. Mutex

 * lock is used for this purpose mainly.

/*

 * Default i2c bus clock frequency 400 kHz. Modify this if you

 * want to set some other frequency (min 50 kHz - max 400 kHz).

 Synchronously send output report to the device */

 mcp2221 uses interrupt endpoint for out reports */

/*

 * Send o/p report to the device and wait for i/p report to be

 * received from the device. If the device does not respond,

 * we timeout.

 Check pass/fail for actual communication with i2c slave */

 Cancels last command releasing i2c bus just in case occupied */

 Small delay is needed here */

/*

 * An output report can contain minimum 1 and maximum 60 user data

 * bytes. If the number of data bytes is more then 60, we send it

 * in chunks of 60 bytes. Last chunk may contain exactly 60 or less

 * bytes. Total number of bytes is informed in very first report to

 * mcp2221, from that point onwards it first collect all the data

 * from host and then send to i2c slave device.

		/*

		 * Testing shows delay is needed between successive writes

		 * otherwise next write fails on first-try from i2c core.

		 * This value is obtained through automated stress testing.

/*

 * Device reads all data (0 - 65535 bytes) from i2c slave device and

 * stores it in device itself. This data is read back from device to

 * host in multiples of 60 bytes using input reports.

 Setting speed before every transaction is required for mcp2221 */

 Ex transaction; send reg address and read its contents */

 1 is due to command byte itself */

 Can't configure as output, bailout early */

 Gives current state of i2c engine inside mcp2221 */

/*

 * MCP2221 uses interrupt endpoint for input reports. This function

 * is called by HID layer when it receives i/p report from mcp2221,

 * which is actually a response to the previously sent command.

 *

 * MCP2221A firmware specific return codes are parsed and 0 or

 * appropriate negative error code is returned. Delayed response

 * results in timeout error and stray reponses results in -EIO.

 Set I2C bus clock diviser */

 Setup GPIO chip */

 Register with HID core */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * HID Driver for ELAN Touchpad

 *

 * Currently only supports touchpad found on HP Pavilion X2 10

 *

 * Copyright (c) 2016 Alexandrov Stanislav <neko@nya.ai>

	/*

	 * (value from firmware) * 10 + 790 = dpi

	 * dpi * 10 / 254 = dots/mm

	/*

	 * There is 3 types of reports: for single touch,

	 * for multitouch - first finger and for multitouch - second finger

	 *

	 * packet structure for ELAN_SINGLE_FINGER and ELAN_MT_FIRST_FINGER:

	 *

	 * byte 1: 1   0   0   0   0   0   0   1  // 0x81 or 0x82

	 * byte 2: 0   0   0   0   0   0   0   0  // looks like unused

	 * byte 3: f5  f4  f3  f2  f1  0   0   L

	 * byte 4: x12 x11 x10 x9  0?  y11 y10 y9

	 * byte 5: x8  x7  x6  x5  x4  x3  x2  x1

	 * byte 6: y8  y7  y6  y5  y4  y3  y2  y1

	 * byte 7: sy4 sy3 sy2 sy1 sx4 sx3 sx2 sx1

	 * byte 8: p8  p7  p6  p5  p4  p3  p2  p1

	 *

	 * packet structure for ELAN_MT_SECOND_FINGER:

	 *

	 * byte 1: 1   0   0   0   0   0   1   1  // 0x83

	 * byte 2: x12 x11 x10 x9  0   y11 y10 y9

	 * byte 3: x8  x7  x6  x5  x4  x3  x2  x1

	 * byte 4: y8  y7  y6  y5  y4  y3  y2  y1

	 * byte 5: sy4 sy3 sy2 sy1 sx4 sx3 sx2 sx1

	 * byte 6: p8  p7  p6  p5  p4  p3  p2  p1

	 * byte 7: 0   0   0   0   0   0   0   0

	 * byte 8: 0   0   0   0   0   0   0   0

	 *

	 * f5-f1: finger touch bits

	 * L: clickpad button

	 * sy / sx: finger width / height expressed in traces, the total number

	 *          of traces can be queried by doing a HID_REQ_SET_REPORT

	 *          { 0x0d, 0x05, 0x03, 0x05, 0x01 } followed by a GET, in the

	 *          returned buf, buf[3]=no-x-traces, buf[4]=no-y-traces.

	 * p: pressure

	/*

	 * When touched with two fingers Elan touchpad will emit two HID reports

	 * first is ELAN_MT_FIRST_FINGER and second is ELAN_MT_SECOND_FINGER

	 * we will save ELAN_MT_FIRST_FINGER report and wait for

	 * ELAN_MT_SECOND_FINGER to finish multitouch

	/*

	 * Elan MT touchpads in i2c mode send finger data in the same format

	 * as in USB mode, but then with all fingers in a single packet.

	 *

	 * packet structure for ELAN_MT_I2C:

	 *

	 * byte     1: 1   0   0   1   1   1   0   1   // 0x5d

	 * byte     2: f5  f4  f3  f2  f1  0   0   L

	 * byte     3: x12 x11 x10 x9  0?  y11 y10 y9

	 * byte     4: x8  x7  x6  x5  x4  x3  x2  x1

	 * byte     5: y8  y7  y6  y5  y4  y3  y2  y1

	 * byte     6: sy4 sy3 sy2 sy1 sx4 sx3 sx2 sx1

	 * byte     7: p8  p7  p6  p5  p4  p3  p2  p1

	 * byte  8-12: Same as byte 3-7 for second finger down

	 * byte 13-17: Same as byte 3-7 for third finger down

	 * byte 18-22: Same as byte 3-7 for fourth finger down

	 * byte 23-27: Same as byte 3-7 for fifth finger down

	/*

	 * This byte sequence will enable multitouch mode and disable

	 * mouse emulation

 SPDX-License-Identifier: GPL-2.0

/*

 * When connected to the machine, the Thrustmaster wheels appear as

 * a «generic» hid gamepad called "Thrustmaster FFB Wheel".

 *

 * When in this mode not every functionality of the wheel, like the force feedback,

 * are available. To enable all functionalities of a Thrustmaster wheel we have to send

 * to it a specific USB CONTROL request with a code different for each wheel.

 *

 * This driver tries to understand which model of Thrustmaster wheel the generic

 * "Thrustmaster FFB Wheel" really is and then sends the appropriate control code.

 *

 * Copyright (c) 2020-2021 Dario Pagani <dario.pagani.146+linuxk@gmail.com>

 * Copyright (c) 2020-2021 Kim Kuparinen <kimi.h.kuparinen@gmail.com>

/*

 * These interrupts are used to prevent a nasty crash when initializing the

 * T300RS. Used in thrustmaster_interrupts().

/*

 * This struct contains for each type of

 * Thrustmaster wheel

 *

 * Note: The values are stored in the CPU

 * endianness, the USB protocols always use

 * little endian; the macro cpu_to_le[BIT]()

 * must be used when preparing USB packets

 * and vice-versa

	/*

	 * See when the USB control out packet is prepared...

	 * @TODO The TMX seems to require multiple control codes to switch.

/*

 * Known wheels.

 * Note: TMX does not work as it requires 2 control packets

{0x0407, 0x0001, "Thrustmaster TMX"}

/*

 * This structs contains (in little endian) the response data

 * of the wheel to the request 73

 *

 * A sufficient research to understand what each field does is not

 * beign conducted yet. The position and meaning of fields are a

 * just a very optimistic guess based on instinct....

	/*

	 * Seems to be the type of packet

	 * - 0x0049 if is data.a (15 bytes)

	 * - 0x0047 if is data.b (7 bytes)

			/*

			 * Seems to be the model code of the wheel

			 * Read table thrustmaster_wheels to values

 The control packet to send to wheel */

 Will be filled by the driver

/*

 * On some setups initializing the T300RS crashes the kernel,

 * these interrupts fix that particular issue. So far they haven't caused any

 * adverse effects in other wheels.

 The wheel seems to kill himself before answering the host and therefore is violating the USB protocol...

/*

 * Called by the USB subsystem when the wheel responses to our request

 * to get [what it seems to be] the wheel's model.

 *

 * If the model id is recognized then we send an opportune USB CONTROL REQUEST

 * to switch the wheel to its full capabilities

 We do not expect any response from the wheel

/*

 * Function called by HID when a hid Thrustmaster FFB wheel is connected to the host.

 * This function starts the hid dev, tries to allocate the tm_wheel data structure and

 * finally send an USB CONTROL REQUEST to the wheel to get [what it seems to be] its

 * model type.

 Now we allocate the tm_wheel

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  HID driver for multitouch panels

 *

 *  Copyright (c) 2010-2012 Stephane Chatty <chatty@enac.fr>

 *  Copyright (c) 2010-2013 Benjamin Tissoires <benjamin.tissoires@gmail.com>

 *  Copyright (c) 2010-2012 Ecole Nationale de l'Aviation Civile, France

 *  Copyright (c) 2012-2013 Red Hat, Inc

 *

 *  This code is partly based on hid-egalax.c:

 *

 *  Copyright (c) 2010 Stephane Chatty <chatty@enac.fr>

 *  Copyright (c) 2010 Henrik Rydberg <rydberg@euromail.se>

 *  Copyright (c) 2010 Canonical, Ltd.

 *

 *  This code is partly based on hid-3m-pct.c:

 *

 *  Copyright (c) 2009-2010 Stephane Chatty <chatty@enac.fr>

 *  Copyright (c) 2010      Henrik Rydberg <rydberg@euromail.se>

 *  Copyright (c) 2010      Canonical, Ltd.

/*

/*

 * This driver is regularly tested thanks to the test suite in hid-tools[1].

 * Please run these regression tests before patching this module so that

 * your patch won't break existing known devices.

 *

 * [1] https://gitlab.freedesktop.org/libevdev/hid-tools

 quirks to control the device */

 default for true */

 default for false */

 default for 0 */

 the device ContactID assigned to this slot */

 is the touch valid? */

 is the finger in proximity of the sensor? */

 is the touch made by a finger? */

 mt usages list */

 scantime reported */

 max value for raw scantime */

 contact count in the report */

 left button state */

 flags to pass to input-mt */

	unsigned long *pending_palm_slots;	/* slots where we reported palm

 how many contacts we received */

 expected last contact index */

 number of physical buttons per touchpad */

	__u8 touches_by_report;	/* how many touches are present in one report:

				 * 1 means we should use a serial protocol

				 * > 1 means hybrid (multitouch) protocol

 the scan time provided by the device */

 the frame's jiffies */

 the timestamp to be sent */

 scantime reported previously */

 MT_CLS */

 Signal/noise ratio for move events */

 Signal/noise ratio for width events */

 Signal/noise ratio for height events */

 Signal/noise ratio for pressure events */

 true for touchpads */

 do not ignore mouse, keyboards, etc... */

 our mt device class */

 to release sticky fingers */

 hid_device we're attached to */

 mt flags (MT_IO_FLAGS_*) */

 InputMode HID feature value */

 is this device a button pad? */

 need to check for serial protocol */

 classes of device behavior */

 reserved					0x0008 */

 reserved					0x0010 */

 reserved					0x0011 */

 reserved					0x0014 */

 vendor specific classes */

 reserved					0x0102 */

/*

 * Resync device and local timestamps after that many microseconds without

 * receiving data.

/*

 * these device-dependent functions determine what slot corresponds

 * to a valid contact that was just read.

	/*

	 * vendor specific classes

	/*

	 * Do not fetch the feature report if the device has been explicitly

	 * marked as non-capable.

 check if the maxcontacts is given by the class */

 Retrieve the Win8 blob once to enable some devices */

 set some defaults so we do not need to check for null pointers */

	/*

	 * Model touchscreens providing buttons as touchpads.

 the value has already been filled, create a new slot */

	/*

	 * Model touchscreens providing buttons as touchpads.

 count the buttons on touchpads */

			/*

			 * A system multi-axis that exports X and Y has a high

			 * chance of being used directly on a surface

				/*

				 * Only set ABS_MT_ORIENTATION if it is not

				 * already set by the HID_DG_AZIMUTH usage.

			/*

			 * Azimuth has the range of [0, MAX) representing a full

			 * revolution. Set ABS_MT_ORIENTATION to a quarter of

			 * MAX according the definition of ABS_MT_ORIENTATION

 contact max are global to the report */

			/* Legacy devices use TIPSWITCH and not TOUCH.

 let hid-input decide for the others */

		/*

		 * MS PTP spec says that external buttons left and right have

		 * usages 2 and 3.

 we do not want to map these: no input-oriented meaning */

/*

 * this function is called when a whole packet has been received and processed,

 * so that it can decide what to send to the input layer.

 HID_DG_SCANTIME is expressed in 100us, we want it in us. */

 No data received for a while, resync the timestamp. */

 we will handle the hidinput part later, now remains hiddev */

			/*

			 * The non-confidence was reported for

			 * previously valid contact that is also no

			 * longer valid. We can't simply report

			 * lift-off as userspace will not be aware

			 * of non-confidence, so we need to split

			 * it into 2 events: active MT_TOOL_PALM

			 * and a separate liftoff.

 this finger is in proximity of the sensor */

			/*

			 * Azimuth is counter-clockwise and ranges from [0, MAX)

			 * (a full revolution). Convert it to clockwise ranging

			 * [-MAX/2, MAX/2].

			 *

			 * Note that ABS_MT_ORIENTATION require us to report

			 * the limit of [-MAX/4, MAX/4], but the value can go

			 * out of range to [-MAX/2, MAX/2] to report an upside

			 * down ellipsis.

			/*

			 * divided by two to match visual scale of touch

			 * for devices with this quirk

		/*

		 * For Win8 PTP touchpads we should only look at

		 * non finger/touch events in the first_packet of a

		 * (possible) multi-packet frame.

		/*

		 * For Win8 PTP touchpads we map both the clickpad click

		 * and any "external" left buttons to BTN_LEFT if a

		 * device claims to have both we need to report 1 for

		 * BTN_LEFT if either is pressed, so we or all values

		 * together and report the result in mt_sync_frame().

 sticky fingers release in progress, abort */

	/*

	 * Includes multi-packet support where subsequent

	 * packets are sent with zero contactcount.

		/*

		 * For Win8 PTPs the first packet (td->num_received == 0) may

		 * have a contactcount of 0 if there only is a button event.

		 * We double check that this is not a continuation packet

		 * of a possible multi-packet frame be checking that the

		 * timestamp has changed.

 A non 0 contact count always indicates a first packet */

	/*

	 * Windows 8 specs says 2 things:

	 * - once a contact has been reported, it has to be reported in each

	 *   subsequent report

	 * - the report rate when fingers are present has to be at least

	 *   the refresh rate of the screen, 60 or 120 Hz

	 *

	 * I interprete this that the specification forces a report rate of

	 * at least 60 Hz for a touchscreen to be certified.

	 * Which means that if we do not get a report whithin 16 ms, either

	 * something wrong happens, either the touchscreen forgets to send

	 * a release. Taking a reasonable margin allows to remove issues

	 * with USB communication or the load of the machine.

	 *

	 * Given that Win 8 devices are forced to send a release, this will

	 * only affect laggish machines and the ones that have a firmware

	 * defect.

 check for clickpads */

	/*

	 * If mtclass.export_all_inputs is not set, only map fields from

	 * TouchScreen or TouchPad collections. We need to ignore fields

	 * that belong to other collections such as Mouse that might have

	 * the same GenericDesktop usages.

	/*

	 * Some Asus keyboard+touchpad devices have the hotkeys defined in the

	 * touchpad report descriptor. We need to treat these as an array to

	 * map usages to input keys.

	/*

	 * some egalax touchscreens have "application == DG_TOUCHSCREEN"

	 * for the stylus. Overwrite the hid_input application

 let hid-core decide for the others */

 We own these mappings, tell hid-input to ignore them */

 let hid-core decide for the others */

		/*

		 * Some elan panels wrongly declare 2 input mode features,

		 * and silently ignore when we set the value in the second

		 * field. Skip the second feature and hope for the best.

 no need to update the report */

 Ignore if report count is out of bounds. */

 unknown serial device needs special quirks */

 already handled by hid core */

 we do not set suffix = "Touchscreen" */

 force BTN_STYLUS to allow tablet matching in udev */

	/*

	 * An input report came in just before we release the sticky fingers,

	 * it will take care of the sticky fingers.

 MT_CLS_DEFAULT */

	/* This allows the driver to correctly support devices

	 * that emit events over several HID messages.

	/*

	 * This allows the driver to handle different input sensors

	 * that emits events through different applications on the same HID

	 * device.

 High latency is desirable for power savings during S3/S0ix */

	/* Some Elan legacy devices require SET_IDLE to be set on resume.

	 * It should be safe to send it to other devices too.

/*

 * This list contains only:

 * - VID/PID of products not working with the default multitouch handling

 * - 2 generic rules.

 * So there is no point in adding here any device with MT_CLS_DEFAULT.

 3M panels */

 Anton devices */

 Asus T101HA */

 Asus T304UA */

 Atmel panels */

 Baanto multitouch devices */

 Cando panels */

 Chunghwa Telecom touch panels */

 CJTouch panels */

 CVTouch panels */

 eGalax devices (resistive) */

 eGalax devices (capacitive) */

 Elan devices */

 Elitegroup panel */

 Flatfrog Panels */

 FocalTech Panels */

 GeneralTouch panel */

 Gametel game controller */

 GoodTouch panels */

 Hanvon panels */

 Ilitek dual touch panel */

 LG Melfas panel */

 Lenovo X1 TAB Gen 2 */

 Lenovo X1 TAB Gen 3 */

 MosArt panels */

 Novatek Panel */

 Ntrig Panel */

 Panasonic panels */

 PixArt optical touch screen */

 PixCir-based panels */

 Quanta-based panels */

 Razer touchpads */

 Smart Tech panels */

 Stantum panels */

 Synaptics devices */

 TopSeed panels */

 Touch International panels */

 Unitec panels */

 VTL panels */

 Winbond Electronics Corp. */

 Wistron panels */

 XAT */

 Xiroku */

 Google MT devices */

 Generic MT device */

 Generic Win 8 certified MT device */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  USB HID driver for Glorious PC Gaming Race

 *  Glorious Model O, O- and D mice.

 *

 *  Copyright (c) 2020 Samuel Čavoj <sammko@sammserver.com>

/*

/*

 * Glorious Model O and O- specify the const flag in the consumer input

 * report descriptor, which leads to inputs being ignored. Fix this

 * by patching the descriptor.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  HID driver for Sony DualSense(TM) controller.

 *

 *  Copyright (c) 2020 Sony Interactive Entertainment

 List of connected playstation devices. */

 Base class for playstation devices. */

 Name of primary input device. */

 Note: stored in little endian order. */

 Calibration data for playstation motion sensors. */

 Seed values for DualShock4 / DualSense CRC32 for different report types. */

 Button masks for DualSense input report. */

 Status field of DualSense input report. */

/*

 * Status of a DualSense touch point contact.

 * Contact IDs, with highest bit set are 'inactive'

 * and any associated data is then invalid.

 Magic value required in tag field of Bluetooth output report. */

 Flags for DualSense output report. */

 DualSense hardware limits */

 Calibration data for accelerometer and gyroscope. */

 Timestamp for sensor data */

 Compatible rumble state */

 RGB lightbar */

 Microphone */

 Player leds */

 Sequence number for output report. */

 Main DualSense input report excluding any BT/USB specific headers. */

 Motion sensors */

 x, y, z */

 x, y, z */

 Touchpad */

 Common input report size shared equals the size of the USB report minus 1 byte for ReportID. */

 Common data between DualSense BT/USB main output report. */

 For DualShock 4 compatibility mode. */

 Audio controls */

 LEDs and lightbar */

 0x31 */

 0x02 */

/*

 * The DualSense has a main output report used to control most features. It is

 * largely the same between Bluetooth and USB except for different headers and CRC.

 * This structure hide the differences between the two to simplify sending output reports.

 Start of data */

 Size of output report */

 Points to Bluetooth data payload in case for a Bluetooth report else NULL. */

 Points to USB data payload in case for a USB report else NULL. */

 Points to common section of report, so past any headers. */

/*

 * Common gamepad buttons across DualShock 3 / 4 and DualSense.

 * Note: for device with a touchpad, touchpad button is not included

 *        as it will be part of the touchpad device.

 Square */

 Triangle */

 Circle */

 Cross */

 L1 */

 R1 */

 L2 */

 R2 */

 Create (PS5) / Share (PS4) */

 Option */

 L3 */

 R3 */

 PS Home */

/*

 * Add a new ps_device to ps_devices if it doesn't exist.

 * Return error on duplicate device, which can happen if the same

 * device is connected using both Bluetooth and USB.

 Compute crc32 of HID data and compare against expected CRC. */

 Last 4 bytes contains crc32. */

 Register a DualSense/DualShock4 RGB lightbar represented by a multicolor LED. */

 Accelerometer */

 Gyroscope */

 Map button underneath touchpad to BTN_LEFT. */

	/*

	 * Set gyroscope calibration and normalization parameters.

	 * Data values will be normalized to 1/DS_GYRO_RES_PER_DEG_S degree/s.

	/*

	 * Set accelerometer calibration and normalization parameters.

	 * Data values will be normalized to 1/DS_ACC_RES_PER_G g.

 Tag must be set. Exact meaning is unclear. */

		/*

		 * Highest 4-bit is a sequence number, which needs to be increased

		 * every report. Lowest 4-bit is tag and can be zero for now.

 USB */

/*

 * Helper function to send DualSense output reports. Applies a CRC at the end of a report

 * for Bluetooth reports.

 Bluetooth packets need to be signed with a CRC in the last 4 bytes. */

 Select classic rumble style haptics and enable it. */

 Disable microphone */

 Enable microphone */

	/*

	 * DualSense in USB uses the full HID report for reportID 1, but

	 * Bluetooth uses a minimal HID report for reportID 1 and reports

	 * the full report using reportID 49.

 Last 4 bytes of input report contain crc32 */

 center */

	/*

	 * The DualSense has an internal microphone, which can be muted through a mute button

	 * on the device. The driver is expected to read the button state and program the device

	 * to mute/unmute audio at the hardware level.

 toggle */

 Schedule updating of microphone state at hardware level. */

 Parse and calibrate gyroscope data. */

 Parse and calibrate accelerometer data. */

 Convert timestamp (in 0.33us unit) to timestamp_us */

		/*

		 * Each unit of battery data corresponds to 10%

		 * 0 = 0-9%, 1 = 10-19%, .. and 10 = 100%

 voltage or temperature out of range */

 temperature error */

 charging error */

	/*

	 * On Bluetooth the DualSense outputs an animation on the lightbar

	 * during startup and maintains a color afterwards. We need to explicitly

	 * reconfigure the lightbar before we can do any programming later on.

	 * In USB the lightbar is not on by default, but redoing the setup there

	 * doesn't hurt.

 Fade light out. */

	/*

	 * The DualSense controller has a row of 5 LEDs used for player ids.

	 * Behavior on the PlayStation 5 console is to center the player id

	 * across the LEDs, so e.g. player 1 would be "--x--" with x being 'on'.

	 * Follow a similar mapping here.

	/*

	 * Patch version to allow userspace to distinguish between

	 * hid-generic vs hid-playstation axis and button mapping.

 initial value until parse_report. */

 Use gamepad input device name as primary device name for e.g. LEDs */

	/*

	 * The hardware may have control over the LEDs (e.g. in Bluetooth on startup).

	 * Reset the LEDs (lightbar, mute, player leds), so we can control them

	 * from software.

 Set default lightbar color. */

 blue */

 Set player LEDs to our player id. */

	/*

	 * Reporting hardware and firmware is important as there are frequent updates, which

	 * can change behavior.

 SPDX-License-Identifier: GPL-2.0-only

/***************************************************************************

 *   Copyright (C) 2010-2012 by Bruno Prémont <bonbons@linux-vserver.org>  *

 *                                                                         *

 *   Based on Logitech G13 driver (v0.4)                                   *

 *     Copyright (C) 2009 by Rick L. Vinyard, Jr. <rvinyard@cs.nmsu.edu>   *

 *                                                                         *

/*

 * lcd class device

 SPDX-License-Identifier: GPL-2.0-only

/*

 * hid-cp2112.c - Silicon Labs HID USB to SMBus master bridge

 * Copyright (c) 2013,2014 Uplogix, Inc.

 * David Barksdale <dbarksdale@uplogix.com>

/*

 * The Silicon Labs CP2112 chip is a USB HID device which provides an

 * SMBus controller for talking to slave devices and 8 GPIO pins. The

 * host communicates with the CP2112 via raw HID reports.

 *

 * Data Sheet:

 *   https://www.silabs.com/Support%20Documents/TechnicalDocs/CP2112.pdf

 * Programming Interface Specification:

 *   https://www.silabs.com/documents/public/application-notes/an495-cp2112-interface-specification.pdf

 CP2112_SMBUS_CONFIG */

 Hz */

 Stored in the upper 7 bits */

 1 = enabled, 0 = disabled */

 ms, 0 = no timeout */

 ms, 0 = no timeout */

 1 = enabled, 0 = disabled */

 # of retries, 0 = no limit */

 CP2112_USB_CONFIG */

 Vendor ID */

 Product ID */

 Power requested in 2mA units */

	u8 power_mode;	/* 0x00 = bus powered

			   0x01 = self powered & regulator off

 What fields to program */

 CP2112_DATA_READ_REQUEST */

 CP2112_DATA_WRITE_READ_REQUEST */

 CP2112_DATA_WRITE_REQUEST */

 CP2112_DATA_READ_FORCE_SEND */

 CP2112_TRANSFER_STATUS_RESPONSE */

 STATUS0_* */

 STATUS1_* */

 force .string to be aligned */

 CP2112_*_STRING */

 length in bytes of everything after .report */

 USB_DT_STRING */

 UTF16_LITTLE_ENDIAN string */

/* Number of times to request transfer status before giving up waiting for a

   transfer to complete. This may need to be changed if SMBUS clock, retries,

/* Time in ms to wait for a CP2112_DATA_READ_RESPONSE or

	/*

	 * Set gpio value when output direction is already set,

	 * as specified in AN495, Rev. 0.2, cpt. 4.4

	/* We have sent either a CP2112_TRANSFER_STATUS_REQUEST or a

	 * CP2112_DATA_READ_FORCE_SEND and we are waiting for the response to

	 * come in cp2112_raw_event or timeout. There will only be one of these

	 * in flight at any one time. The timeout is extremely large and is a

	 * last resort if the CP2112 has died. If we do timeout we don't expect

	 * to receive the response which would cause data races, it's not like

	 * we can do anything about it anyway.

 no repeated start in rev 1 */

			/*

			 * The hardware returned too much data.

			 * This is mostly harmless because cp2112_read()

			 * has a limit check so didn't overrun our

			 * buffer.  Nevertheless, we return an error

			 * because something is seriously wrong and

			 * it shouldn't go unnoticed.

 return the number of transferred messages */

/* Chmoding our sysfs attributes is simply a way to expose which fields in the

 * PROM have already been programmed. We do not depend on this preventing

 * writing to these attributes since the CP2112 will simply ignore writes to

 * already-programmed fields. This is why there is no sense in fixing this

 * racy behaviour.

 the hardware has been disconnected */

 Level High */

 Level Low */

 The event comes from the outside so no parent handler */

	/* i2c_del_adapter has finished removing all i2c devices from our

	 * adapter. Well behaved devices should no longer call our cp2112_xfer

	 * and should have waited for any pending calls to finish. It has also

	 * waited for device_unregister(&adap->dev) to complete. Therefore we

	 * can safely free our struct cp2112_device.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  HID driver for some belkin "special" devices

 *

 *  Copyright (c) 1999 Andreas Gal

 *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>

 *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc

 *  Copyright (c) 2006-2007 Jiri Kosina

 *  Copyright (c) 2008 Jiri Slaby

/*

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  HID driver for some a4tech "special" devices

 *

 *  Copyright (c) 1999 Andreas Gal

 *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>

 *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc

 *  Copyright (c) 2006-2007 Jiri Kosina

 *  Copyright (c) 2008 Jiri Slaby

/*

		/*

		 * We do not want to have this usage mapped to anything as it's

		 * nonstandard and doesn't really behave like an HID report.

		 * It's only selecting the orientation (vertical/horizontal) of

		 * the previous mouse wheel report. The input_events will be

		 * generated once both reports are recorded in a4_event().

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Roccat Kova[+] driver for Linux

 *

 * Copyright (c) 2011 Stefan Achatz <erazor_de@users.sourceforge.net>

/*

/*

 * Roccat Kova[+] is a bigger version of the Pyra with two more side buttons.

 retval is 0-4 on success, < 0 on error */

 device will freeze with just 60 */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Roccat Kone[+] driver for Linux

 *

 * Copyright (c) 2010 Stefan Achatz <erazor_de@users.sourceforge.net>

/*

/*

 * Roccat Kone[+] is an updated/improved version of the Kone with more memory

 * and functionality and without the non-standard behaviours the Kone had.

 * KoneXTD has same capabilities but updated sensor.

 retval is 0-4 on success, < 0 on error */

 class name has to be same as driver name */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  HID driver for some samsung "special" devices

 *

 *  Copyright (c) 1999 Andreas Gal

 *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>

 *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc

 *  Copyright (c) 2006-2007 Jiri Kosina

 *  Copyright (c) 2008 Jiri Slaby

 *  Copyright (c) 2010 Don Prince <dhprince.devel@yahoo.co.uk>

 *

 *  This driver supports several HID devices:

 *

 *  [0419:0001] Samsung IrDA remote controller (reports as Cypress USB Mouse).

 *	various hid report fixups for different variants.

 *

 *  [0419:0600] Creative Desktop Wireless 6000 keyboard/mouse combo

 *	several key mappings used from the consumer usage page

 *	deviate from the USB HUT 1.12 standard.

/*

/*

 * There are several variants for 0419:0001:

 *

 * 1. 184 byte report descriptor

 * Vendor specific report #4 has a size of 48 bit,

 * and therefore is not accepted when inspecting the descriptors.

 * As a workaround we reinterpret the report as:

 *   Variable type, count 6, size 8 bit, log. maximum 255

 * The burden to reconstruct the data is moved into user space.

 *

 * 2. 203 byte report descriptor

 * Report #4 has an array field with logical range 0..18 instead of 1..15.

 *

 * 3. 135 byte report descriptor

 * Report #4 has an array field with logical range 0..17 instead of 1..14.

 *

 * 4. 171 byte report descriptor

 * Report #3 has an array field with logical range 0..1 instead of 1..3.

 report 2 */

 disable hidinput, force hiddev */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Force feedback support for DragonRise Inc. game controllers

 *

 * From what I have gathered, these devices are mass produced in China and are

 * distributed under several vendors. They often share the same design as

 * the original PlayStation DualShock controller.

 *

 * 0079:0006 "DragonRise Inc.   Generic   USB  Joystick  "

 *  - tested with a Tesun USB-703 game controller.

 *

 * Copyright (c) 2009 Richard Walmsley <richwalm@gmail.com>

/*

		/* While reverse engineering this device, I found that when

		   this value is set, it causes the strong rumble to function

/*

 * The original descriptor of joystick with PID 0x0011, represented by DVTech PC

 * JS19. It seems both copied from another device and a result of confusion

 * either about the specification or about the program used to create the

 * descriptor. In any case, it's a wonder it works on Windows.

 *

 *  Usage Page (Desktop),             ; Generic desktop controls (01h)

 *  Usage (Joystick),                 ; Joystick (04h, application collection)

 *  Collection (Application),

 *    Collection (Logical),

 *      Report Size (8),

 *      Report Count (5),

 *      Logical Minimum (0),

 *      Logical Maximum (255),

 *      Physical Minimum (0),

 *      Physical Maximum (255),

 *      Usage (X),                    ; X (30h, dynamic value)

 *      Usage (X),                    ; X (30h, dynamic value)

 *      Usage (X),                    ; X (30h, dynamic value)

 *      Usage (X),                    ; X (30h, dynamic value)

 *      Usage (Y),                    ; Y (31h, dynamic value)

 *      Input (Variable),

 *      Report Size (4),

 *      Report Count (1),

 *      Logical Maximum (7),

 *      Physical Maximum (315),

 *      Unit (Degrees),

 *      Usage (00h),

 *      Input (Variable, Null State),

 *      Unit,

 *      Report Size (1),

 *      Report Count (10),

 *      Logical Maximum (1),

 *      Physical Maximum (1),

 *      Usage Page (Button),          ; Button (09h)

 *      Usage Minimum (01h),

 *      Usage Maximum (0Ah),

 *      Input (Variable),

 *      Usage Page (FF00h),           ; FF00h, vendor-defined

 *      Report Size (1),

 *      Report Count (10),

 *      Logical Maximum (1),

 *      Physical Maximum (1),

 *      Usage (01h),

 *      Input (Variable),

 *    End Collection,

 *    Collection (Logical),

 *      Report Size (8),

 *      Report Count (4),

 *      Physical Maximum (255),

 *      Logical Maximum (255),

 *      Usage (02h),

 *      Output (Variable),

 *    End Collection,

 *  End Collection

 Size of the original descriptor of the PID 0x0011 joystick */

 Fixed report descriptor for PID 0x011 joystick */

  Usage Page (Desktop),           */

  Usage (Joystick),               */

  Collection (Application),       */

      Collection (Logical),       */

          Logical Minimum (0),    */

          Report Size (8),        */

          Report Count (3),       */

          Input (Constant),       */

          Logical Maximum (255),  */

          Report Count (2),       */

          Usage (X),              */

          Usage (Y),              */

          Input (Variable),       */

          Report Size (1),        */

          Report Count (4),       */

          Input (Constant),       */

          Logical Maximum (1),    */

          Report Count (10),      */

          Usage Page (Button),    */

          Usage Minimum (01h),    */

          Usage Maximum (0Ah),    */

          Input (Variable),       */

          Report Count (10),      */

          Input (Constant),       */

      End Collection,             */

  End Collection                  */

	/*

	 * revert to the old hid-input behavior where axes

	 * can be randomly assigned when hid->usage is reused.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * HID driver for Elo Accutouch touchscreens

 *

 * Copyright (c) 2016, Collabora Ltd.

 * Copyright (c) 2016, General Electric Company

 *

 * based on hid-penmount.c

 *  Copyright (c) 2014 Christian Gmeiner <christian.gmeiner <at> gmail.com>

/*

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright (c) 2013 Andrew Duggan <aduggan@synaptics.com>

 *  Copyright (c) 2013 Synaptics Incorporated

 *  Copyright (c) 2014 Benjamin Tissoires <benjamin.tissoires@gmail.com>

 *  Copyright (c) 2014 Red Hat, Inc

 Mouse emulation Report */

 Output Report */

 Output Report */

 Input Report */

 Input Report */

 Feature Report */

 flags */

 device flags */

/*

 * retrieve the ctrl registers

 * the ctrl register has a size of 20 but a fw bug split it into 16 + 4,

 * and there is no way to know if the first 20 bytes are here or not.

 * We use only the first 12 bytes, so get only them.

/**

 * struct rmi_data - stores information for hid communication

 *

 * @page_mutex: Locks current page to avoid changing pages in unexpected ways.

 * @page: Keeps track of the current virtual page

 * @xport: transport device to be registered with the RMI4 core.

 *

 * @wait: Used for waiting for read data

 *

 * @writeReport: output buffer when writing RMI registers

 * @readReport: input buffer when reading RMI registers

 *

 * @input_report_size: size of an input report (advertised by HID)

 * @output_report_size: size of an output report (advertised by HID)

 *

 * @flags: flags for the current device (started, reading, etc...)

 *

 * @reset_work: worker which will be called in case of a mouse report

 * @hdev: pointer to the struct hid_device

 *

 * @device_flags: flags which describe the device

 *

 * @domain: the IRQ domain allocated for this RMI4 device

 * @rmi_irq: the irq that will be used to generate events to rmi-core

/**

 * rmi_set_page - Set RMI page

 * @hdev: The pointer to the hid_device struct

 * @page: The new page address.

 *

 * RMI devices have 16-bit addressing, but some of the physical

 * implementations (like SMBus) only have 8-bit addressing. So RMI implements

 * a page address at 0xff of every page so we can reliable page addresses

 * every 256 registers.

 *

 * The page_mutex lock must be held when this function is entered.

 *

 * Returns zero on success, non-zero on failure.

		/*

		 * Talk to device by using SET_REPORT requests instead.

 old 1 byte read count */

 switch the device to RMI if we receive a generic mouse report */

	/*

	 * On the Dell XPS 13 9333, the bus sometimes get confused and fills

	 * the report with a sentinel value "ff". Synaptics told us that such

	 * behavior does not comes from the touchpad itself, so we filter out

	 * such reports here.

 Make sure the HID device is ready to receive events */

 CONFIG_PM */

 Allow incoming hid reports */

	/*

	 * we want to make HID ignore the advertised HID collection

	 * for RMI deivces

	/*

	 * Check for the RMI specific report ids. If they are misisng

	 * simply return and let the events be processed by hid-input

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  USB HID quirks support for Linux

 *

 *  Copyright (c) 1999 Andreas Gal

 *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>

 *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc

 *  Copyright (c) 2006-2007 Jiri Kosina

 *  Copyright (c) 2008 Jiri Slaby <jirislaby@gmail.com>

/*

 0x0008 reserved, was: APPLE_HIDDEV */

 0x0080 reserved, was: APPLE_IGNORE_HIDINPUT */

 Look for the translation */

 should never happen */

/*

 * MacBook JIS keyboard has wrong logical maximum

 * Magic Keyboard JIS has wrong logical maximum

 Enable all needed keys */

 The fn key on Apple USB keyboards */

 we want the hid layer to go through standard path (set and ignore) */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * hid-ft260.c - FTDI FT260 USB HID to I2C host bridge

 *

 * Copyright (c) 2021, Michael Zaidman <michaelz@xsightlabs.com>

 *

 * Data Sheet:

 *   https://www.ftdichip.com/Support/Documents/DataSheets/ICs/DS_FT260.pdf

/*

 * The input report format assigns 62 bytes for the data payload, but ft260

 * returns 60 and 2 in two separate transactions. To minimize transfer time

 * in reading chunks mode, set the maximum read payload length to 60 bytes.

/*

 * Device interface configuration.

 * The FT260 has 2 interfaces that are controlled by DCNF0 and DCNF1 pins.

 * First implementes USB HID to I2C bridge function and

 * second - USB HID to UART bridge function.

 Control pipe */

 Report IDs / Feature In */

 Feature Out */

 Response codes in I2C status report */

 I2C Conditions flags */

 Feature In reports */

 FT260_CHIP_VERSION */

 FTDI chip identification code */

 FT260_SYSTEM_SETTINGS */

 DCNF0 and DCNF1 status, bits 0-1 */

 0 - 12MHz, 1 - 24MHz, 2 - 48MHz */

 0 - not suspended, 1 - suspended */

 0 - FT260 is not ready, 1 - ready */

 0 - disabled, 1 - enabled */

 0 - OFF; 1 - RTS_CTS, 2 - DTR_DSR, */

 3 - XON_XOFF, 4 - No flow control */

 0 - disabled, 1 - enabled */

 0 - GPIO,  1 - SUSPOUT, */

 2 - PWREN, 4 - TX_LED */

 0 - GPIO, 3 - TX_ACTIVE, 4 - TX_LED */

 0 - GPIO, 2 - PWREN, */

 5 - RX_LED, 6 - BCD_DET */

 0 - active-high, 1 - active-low */

 0 - disabled, 1 - enabled */

 Interrupt trigger conditions */

 0 - disabled, 1 - enabled */

 FT260_I2C_STATUS */

 I2C bus status */

 I2C bus clock in range 60-3400 KHz */

 Feature Out reports */

 FT260_SYSTEM_SETTINGS */

 FT260_SET_CLOCK */

 0 - 12MHz, 1 - 24MHz, 2 - 48MHz */

 FT260_SYSTEM_SETTINGS */

 FT260_SET_I2C_MODE */

 0 - disabled, 1 - enabled */

 FT260_SYSTEM_SETTINGS */

 FT260_SET_UART_MODE */

 0 - OFF; 1 - RTS_CTS, 2 - DTR_DSR, */

 3 - XON_XOFF, 4 - No flow control */

 FT260_SYSTEM_SETTINGS */

 FT260_SET_I2C_RESET */

 FT260_SYSTEM_SETTINGS */

 FT260_SET_I2C_CLOCK_SPEED */

 I2C bus clock in range 60-3400 KHz */

 Data transfer reports */

 FT260_I2C_REPORT */

 7-bit I2C address */

 I2C transaction condition */

 data payload length */

 data payload */

 FT260_I2C_READ_REQ */

 7-bit I2C address */

 I2C transaction condition */

 data payload length */

 FT260_I2C_REPORT */

 data payload length */

 data payload */

 END OF LIST */ }

 transfer time = 1 / clock(KHz) * 10 bits * bytes */

/*

 * A random read operation is implemented as a dummy write operation, followed

 * by a current address read operation. The dummy write operation is used to

 * load the target byte address into the current byte address counter, from

 * which the subsequent current address read operation then reads.

 Combined write then read message */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  HID driver for Keytouch devices not fully compliant with HID standard

 *

 *  Copyright (c) 2011 Jiri Kosina

/*

/* Replace the broken report descriptor of this device with rather

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  HID driver for some chicony "special" devices

 *

 *  Copyright (c) 1999 Andreas Gal

 *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>

 *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc

 *  Copyright (c) 2006-2007 Jiri Kosina

 *  Copyright (c) 2007 Paul Walmsley

 *  Copyright (c) 2008 Jiri Slaby

/*

		/* Change usage maximum and logical maximum from 0x7fff to

 SPDX-License-Identifier: GPL-2.0+

/*

 *  HID driver for UC-Logic devices not fully compliant with HID standard

 *  - original and fixed report descriptors

 *

 *  Copyright (c) 2010-2017 Nikolai Kondrashov

 *  Copyright (c) 2013 Martin Rusko

/*

 * This program is free software; you can redistribute it and/or modify it

 * under the terms of the GNU General Public License as published by the Free

 * Software Foundation; either version 2 of the License, or (at your option)

 * any later version.

 Fixed WP4030U report descriptor */

  Usage Page (Digitizer),             */

  Usage (Pen),                        */

  Collection (Application),           */

      Report ID (9),                  */

      Usage (Stylus),                 */

      Collection (Physical),          */

          Report Size (1),            */

          Usage (Tip Switch),         */

          Usage (Barrel Switch),      */

          Usage (Tablet Pick),        */

          Logical Minimum (0),        */

          Logical Maximum (1),        */

          Report Count (3),           */

          Input (Variable),           */

          Report Count (5),           */

          Input (Constant),           */

          Report Size (16),           */

          Report Count (1),           */

          Logical Minimum (0),        */

          Push,                       */

          Usage Page (Desktop),       */

          Unit Exponent (-3),         */

          Unit (Inch),                */

          Physical Minimum (0),       */

          Usage (X),                  */

          Physical Maximum (4000),    */

          Logical Maximum (32767),    */

          Input (Variable),           */

          Usage (Y),                  */

          Physical Maximum (3000),    */

          Logical Maximum (32767),    */

          Input (Variable),           */

          Pop,                        */

          Usage (Tip Pressure),       */

          Logical Maximum (1023),     */

          Input (Variable),           */

      End Collection,                 */

  End Collection                      */

 Fixed WP5540U report descriptor */

  Usage Page (Digitizer),             */

  Usage (Pen),                        */

  Collection (Application),           */

      Report ID (9),                  */

      Usage (Stylus),                 */

      Collection (Physical),          */

          Report Size (1),            */

          Usage (Tip Switch),         */

          Usage (Barrel Switch),      */

          Usage (Tablet Pick),        */

          Logical Minimum (0),        */

          Logical Maximum (1),        */

          Report Count (3),           */

          Input (Variable),           */

          Report Count (5),           */

          Input (Constant),           */

          Report Size (16),           */

          Report Count (1),           */

          Logical Minimum (0),        */

          Push,                       */

          Usage Page (Desktop),       */

          Unit Exponent (-3),         */

          Unit (Inch),                */

          Physical Minimum (0),       */

          Usage (X),                  */

          Physical Maximum (5500),    */

          Logical Maximum (32767),    */

          Input (Variable),           */

          Usage (Y),                  */

          Physical Maximum (4000),    */

          Logical Maximum (32767),    */

          Input (Variable),           */

          Pop,                        */

          Usage (Tip Pressure),       */

          Logical Maximum (1023),     */

          Input (Variable),           */

      End Collection,                 */

  End Collection,                     */

  Usage Page (Desktop),               */

  Usage (Mouse),                      */

  Collection (Application),           */

      Report ID (8),                  */

      Usage (Pointer),                */

      Collection (Physical),          */

          Report Size (1),            */

          Usage Page (Button),        */

          Usage Minimum (01h),        */

          Usage Maximum (03h),        */

          Logical Minimum (0),        */

          Logical Maximum (1),        */

          Report Count (3),           */

          Input (Variable),           */

          Report Count (5),           */

          Input (Constant),           */

          Usage Page (Desktop),       */

          Report Size (8),            */

          Usage (X),                  */

          Usage (Y),                  */

          Logical Minimum (-127),     */

          Logical Maximum (127),      */

          Report Count (2),           */

          Input (Variable, Relative), */

          Usage (Wheel),              */

          Logical Minimum (-1),       */

          Logical Maximum (1),        */

          Report Count (1),           */

          Input (Variable, Relative), */

          Input (Constant),           */

      End Collection,                 */

  End Collection                      */

 Fixed WP8060U report descriptor */

  Usage Page (Digitizer),             */

  Usage (Pen),                        */

  Collection (Application),           */

      Report ID (9),                  */

      Usage (Stylus),                 */

      Collection (Physical),          */

          Report Size (1),            */

          Usage (Tip Switch),         */

          Usage (Barrel Switch),      */

          Usage (Tablet Pick),        */

          Logical Minimum (0),        */

          Logical Maximum (1),        */

          Report Count (3),           */

          Input (Variable),           */

          Report Count (5),           */

          Input (Constant),           */

          Report Size (16),           */

          Report Count (1),           */

          Logical Minimum (0),        */

          Push,                       */

          Usage Page (Desktop),       */

          Unit Exponent (-3),         */

          Unit (Inch),                */

          Physical Minimum (0),       */

          Usage (X),                  */

          Physical Maximum (8000),    */

          Logical Maximum (32767),    */

          Input (Variable),           */

          Usage (Y),                  */

          Physical Maximum (6000),    */

          Logical Maximum (32767),    */

          Input (Variable),           */

          Pop,                        */

          Usage (Tip Pressure),       */

          Logical Maximum (1023),     */

          Input (Variable),           */

      End Collection,                 */

  End Collection,                     */

  Usage Page (Desktop),               */

  Usage (Mouse),                      */

  Collection (Application),           */

      Report ID (8),                  */

      Usage (Pointer),                */

      Collection (Physical),          */

          Report Size (1),            */

          Usage Page (Button),        */

          Usage Minimum (01h),        */

          Usage Maximum (03h),        */

          Logical Minimum (0),        */

          Logical Maximum (1),        */

          Report Count (3),           */

          Input (Variable),           */

          Report Count (5),           */

          Input (Constant),           */

          Usage Page (Desktop),       */

          Report Size (8),            */

          Usage (X),                  */

          Usage (Y),                  */

          Logical Minimum (-127),     */

          Logical Maximum (127),      */

          Report Count (2),           */

          Input (Variable, Relative), */

          Usage (Wheel),              */

          Logical Minimum (-1),       */

          Logical Maximum (1),        */

          Report Count (1),           */

          Input (Variable, Relative), */

          Input (Constant),           */

      End Collection,                 */

  End Collection                      */

 Fixed WP1062 report descriptor */

  Usage Page (Digitizer),             */

  Usage (Pen),                        */

  Collection (Application),           */

      Report ID (9),                  */

      Usage (Stylus),                 */

      Collection (Physical),          */

          Report Size (1),            */

          Usage (Tip Switch),         */

          Usage (Barrel Switch),      */

          Usage (Tablet Pick),        */

          Logical Minimum (0),        */

          Logical Maximum (1),        */

          Report Count (3),           */

          Input (Variable),           */

          Report Count (4),           */

          Input (Constant),           */

          Usage (In Range),           */

          Report Count (1),           */

          Input (Variable),           */

          Report Size (16),           */

          Report Count (1),           */

          Logical Minimum (0),        */

          Push,                       */

          Usage Page (Desktop),       */

          Unit Exponent (-3),         */

          Unit (Inch),                */

          Physical Minimum (0),       */

          Usage (X),                  */

          Physical Maximum (10000),   */

          Logical Maximum (20000),    */

          Input (Variable),           */

          Usage (Y),                  */

          Physical Maximum (6583),    */

          Logical Maximum (13166),    */

          Input (Variable),           */

          Pop,                        */

          Usage (Tip Pressure),       */

          Logical Maximum (1023),     */

          Input (Variable),           */

      End Collection,                 */

  End Collection                      */

 Fixed PF1209 report descriptor */

  Usage Page (Digitizer),             */

  Usage (Pen),                        */

  Collection (Application),           */

      Report ID (9),                  */

      Usage (Stylus),                 */

      Collection (Physical),          */

          Report Size (1),            */

          Usage (Tip Switch),         */

          Usage (Barrel Switch),      */

          Usage (Tablet Pick),        */

          Logical Minimum (0),        */

          Logical Maximum (1),        */

          Report Count (3),           */

          Input (Variable),           */

          Report Count (5),           */

          Input (Constant),           */

          Report Size (16),           */

          Report Count (1),           */

          Logical Minimum (0),        */

          Push,                       */

          Usage Page (Desktop),       */

          Unit Exponent (-3),         */

          Unit (Inch),                */

          Physical Minimum (0),       */

          Usage (X),                  */

          Physical Maximum (12000),   */

          Logical Maximum (32767),    */

          Input (Variable),           */

          Usage (Y),                  */

          Physical Maximum (9000),    */

          Logical Maximum (32767),    */

          Input (Variable),           */

          Pop,                        */

          Usage (Tip Pressure),       */

          Logical Maximum (1023),     */

          Input (Variable),           */

      End Collection,                 */

  End Collection,                     */

  Usage Page (Desktop),               */

  Usage (Mouse),                      */

  Collection (Application),           */

      Report ID (8),                  */

      Usage (Pointer),                */

      Collection (Physical),          */

          Report Size (1),            */

          Usage Page (Button),        */

          Usage Minimum (01h),        */

          Usage Maximum (03h),        */

          Logical Minimum (0),        */

          Logical Maximum (1),        */

          Report Count (3),           */

          Input (Variable),           */

          Report Count (5),           */

          Input (Constant),           */

          Usage Page (Desktop),       */

          Report Size (8),            */

          Usage (X),                  */

          Usage (Y),                  */

          Logical Minimum (-127),     */

          Logical Maximum (127),      */

          Report Count (2),           */

          Input (Variable, Relative), */

          Usage (Wheel),              */

          Logical Minimum (-1),       */

          Logical Maximum (1),        */

          Report Count (1),           */

          Input (Variable, Relative), */

          Input (Constant),           */

      End Collection,                 */

  End Collection                      */

 Fixed PID 0522 tablet report descriptor, interface 0 (stylus) */

  Usage Page (Digitizer),             */

  Usage (Pen),                        */

  Collection (Application),           */

      Report ID (9),                  */

      Usage (Stylus),                 */

      Collection (Physical),          */

          Logical Minimum (0),        */

          Logical Maximum (1),        */

          Report Size (1),            */

          Report Count (3),           */

          Usage (Tip Switch),         */

          Usage (Barrel Switch),      */

          Usage (Tablet Pick),        */

          Input (Variable),           */

          Input (Constant, Variable), */

          Report Count (1),           */

          Usage (In Range),           */

          Input (Variable),           */

          Input (Constant, Variable), */

          Report Size (16),           */

          Push,                       */

          Usage Page (Desktop),       */

          Unit (Inch),                */

          Unit Exponent (-3),         */

          Physical Minimum (0),       */

          Usage (X),                  */

          Physical Maximum (8000),    */

          Logical Maximum (32000),    */

          Input (Variable),           */

          Usage (Y),                  */

          Physical Maximum (5000),    */

          Logical Maximum (20000),    */

          Input (Variable),           */

          Pop,                        */

          Usage (Tip Pressure),       */

          Logical Maximum (1023),     */

          Input (Variable),           */

      End Collection,                 */

  End Collection                      */

 Fixed PID 0522 tablet report descriptor, interface 1 (mouse) */

  Usage Page (Desktop),               */

  Usage (Mouse),                      */

  Collection (Application),           */

      Report ID (1),                  */

      Usage (Pointer),                */

      Collection (Physical),          */

          Usage Page (Button),        */

          Report Size (1),            */

          Report Count (3),           */

          Usage Minimum (01h),        */

          Usage Maximum (03h),        */

          Logical Minimum (0),        */

          Logical Maximum (1),        */

          Input (Variable),           */

          Report Count (5),           */

          Input (Constant, Variable), */

          Usage Page (Desktop),       */

          Usage (X),                  */

          Usage (Y),                  */

          Logical Minimum (-32768),   */

          Logical Maximum (32767),    */

          Report Size (16),           */

          Report Count (2),           */

          Input (Variable, Relative), */

          Usage (Wheel),              */

          Logical Minimum (-1),       */

          Logical Maximum (1),        */

          Report Count (1),           */

          Report Size (8),            */

          Input (Variable, Relative), */

          Input (Constant, Variable), */

      End Collection,                 */

  End Collection                      */

 Fixed PID 0522 tablet report descriptor, interface 2 (frame buttons) */

  Usage Page (Desktop),               */

  Usage (Keyboard),                   */

  Collection (Application),           */

      Report ID (3),                  */

      Usage Page (Keyboard),          */

      Logical Minimum (0),            */

      Usage Minimum (KB Leftcontrol), */

      Usage Maximum (KB Right GUI),   */

      Logical Maximum (1),            */

      Report Size (1),                */

      Report Count (8),               */

      Input (Variable),               */

      Usage Minimum (None),           */

      Usage Maximum (FFh),            */

      Logical Maximum (255),          */

      Report Size (8),                */

      Report Count (6),               */

      Input,                          */

  End Collection                      */

 Fixed TWHA60 report descriptor, interface 0 (stylus) */

  Usage Page (Digitizer),             */

  Usage (Pen),                        */

  Collection (Application),           */

      Report ID (9),                  */

      Usage (Stylus),                 */

      Collection (Physical),          */

          Report Size (1),            */

          Usage (Tip Switch),         */

          Usage (Barrel Switch),      */

          Usage (Tablet Pick),        */

          Logical Minimum (0),        */

          Logical Maximum (1),        */

          Report Count (3),           */

          Input (Variable),           */

          Report Count (4),           */

          Input (Constant),           */

          Usage (In Range),           */

          Report Count (1),           */

          Input (Variable),           */

          Report Size (16),           */

          Report Count (1),           */

          Logical Minimum (0),        */

          Push,                       */

          Usage Page (Desktop),       */

          Unit Exponent (-3),         */

          Unit (Inch),                */

          Physical Minimum (0),       */

          Usage (X),                  */

          Physical Maximum (10000),   */

          Logical Maximum (39999),    */

          Input (Variable),           */

          Usage (Y),                  */

          Physical Maximum (6250),    */

          Logical Maximum (24999),    */

          Input (Variable),           */

          Pop,                        */

          Usage (Tip Pressure),       */

          Logical Maximum (1023),     */

          Input (Variable),           */

      End Collection,                 */

  End Collection                      */

 Fixed TWHA60 report descriptor, interface 1 (frame buttons) */

  Usage Page (Desktop),       */

  Usage (Keyboard),           */

  Collection (Application),   */

      Report ID (5),          */

      Usage Page (Keyboard),  */

      Logical Minimum (0),    */

      Logical Maximum (1),    */

      Report Size (1),        */

      Report Count (8),       */

      Input (Constant),       */

      Report Count (12),      */

      Usage Minimum (KB F1),  */

      Usage Maximum (KB F12), */

      Input (Variable),       */

      Report Count (12),      */

      Usage Minimum (KB F13), */

      Usage Maximum (KB F24), */

      Input (Variable),       */

      Report Count (8),       */

      Input (Constant),       */

  End Collection              */

 Fixed report descriptor template for (tweaked) v1 pen reports */

  Usage Page (Digitizer),                 */

  Usage (Pen),                            */

  Collection (Application),               */

      Report ID (7),                      */

      Usage (Stylus),                     */

      Collection (Physical),              */

          Logical Minimum (0),            */

          Logical Maximum (1),            */

          Report Size (1),                */

          Usage (Tip Switch),             */

          Usage (Barrel Switch),          */

          Usage (Tablet Pick),            */

          Report Count (3),               */

          Input (Variable),               */

          Report Count (3),               */

          Input (Constant, Variable),     */

          Usage (In Range),               */

          Report Count (1),               */

          Input (Variable),               */

          Report Count (1),               */

          Input (Constant, Variable),     */

          Report Size (16),               */

          Report Count (1),               */

          Push,                           */

          Usage Page (Desktop),           */

          Unit (Inch),                    */

          Unit Exponent (-3),             */

          Physical Minimum (0),           */

          Usage (X),                      */

          Logical Maximum (PLACEHOLDER),  */

          Physical Maximum (PLACEHOLDER), */

          Input (Variable),               */

          Usage (Y),                      */

          Logical Maximum (PLACEHOLDER),  */

          Physical Maximum (PLACEHOLDER), */

          Input (Variable),               */

          Pop,                            */

          Usage (Tip Pressure),           */

          Logical Maximum (PLACEHOLDER),  */

          Input (Variable),               */

      End Collection,                     */

  End Collection                          */

 Fixed report descriptor template for (tweaked) v2 pen reports */

  Usage Page (Digitizer),                 */

  Usage (Pen),                            */

  Collection (Application),               */

      Report ID (8),                      */

      Usage (Stylus),                     */

      Collection (Physical),              */

          Logical Minimum (0),            */

          Logical Maximum (1),            */

          Report Size (1),                */

          Usage (Tip Switch),             */

          Usage (Barrel Switch),          */

          Usage (Tablet Pick),            */

          Report Count (3),               */

          Input (Variable),               */

          Report Count (3),               */

          Input (Constant, Variable),     */

          Usage (In Range),               */

          Report Count (1),               */

          Input (Variable),               */

          Report Count (1),               */

          Input (Constant, Variable),     */

          Report Count (1),               */

          Push,                           */

          Usage Page (Desktop),           */

          Unit (Inch),                    */

          Unit Exponent (-3),             */

          Report Size (24),               */

          Physical Minimum (0),           */

          Usage (X),                      */

          Logical Maximum (PLACEHOLDER),  */

          Physical Maximum (PLACEHOLDER), */

          Input (Variable),               */

          Usage (Y),                      */

          Logical Maximum (PLACEHOLDER),  */

          Physical Maximum (PLACEHOLDER), */

          Input (Variable),               */

          Pop,                            */

          Usage (Tip Pressure),           */

          Report Size (16),               */

          Logical Maximum (PLACEHOLDER),  */

          Input (Variable),               */

          Input (Constant, Variable),     */

      End Collection,                     */

  End Collection                          */

/*

 * Expand to the contents of a generic buttonpad report descriptor.

 *

 * @_padding:	Padding from the end of button bits at bit 44, until

 *		the end of the report, in bits.

  Usage Page (Desktop),               */ \

  Usage (Keypad),                     */ \

  Collection (Application),           */ \

      Report ID (247),                */ \

      Logical Minimum (0),            */ \

      Logical Maximum (1),            */ \

      Report Size (1),                */ \

      Usage Page (Digitizer),         */ \

      Usage (Tablet Function Keys),   */ \

      Collection (Physical),          */ \

          Usage (Barrel Switch),      */ \

          Report Count (1),           */ \

          Input (Variable),           */ \

          Usage Page (Desktop),       */ \

          Usage (X),                  */ \

          Usage (Y),                  */ \

          Report Count (2),           */ \

          Input (Variable),           */ \

          Report Count (21),          */ \

          Input (Constant),           */ \

          Usage Page (Button),        */ \

          Usage Minimum (01h),        */ \

          Usage Maximum (0Ah),        */ \

          Report Count (10),          */ \

          Input (Variable),           */ \

      End Collection,                 */ \

      Usage Page (Desktop),           */ \

      Usage (Gamepad),                */ \

      Collection (Physical),          */ \

          Usage Page (Button),        */ \

          Usage Minimum (01h),        */ \

          Usage Maximum (02h),        */ \

          Report Count (2),           */ \

          Input (Variable),           */ \

          Report Count (_padding),    */ \

          Input (Constant),           */ \

      End Collection,                 */ \

  End Collection                      */

 Fixed report descriptor for (tweaked) v1 buttonpad reports */

 Fixed report descriptor for (tweaked) v2 buttonpad reports */

 Fixed report descriptor for Ugee EX07 buttonpad */

  Usage Page (Desktop),                   */

  Usage (Keypad),                         */

  Collection (Application),               */

      Report ID (6),                      */

      Usage Page (Digitizer),             */

      Usage (Tablet Function Keys),       */

      Collection (Physical),              */

          Usage Page (Button),            */

          Report Size (1),                */

          Usage Minimum (03h),            */

          Usage Maximum (06h),            */

          Report Count (4),               */

          Input (Variable),               */

          Report Count (26),              */

          Input (Constant, Variable),     */

          Usage Minimum (01h),            */

          Usage Maximum (02h),            */

          Report Count (2),               */

          Input (Variable),               */

      End Collection,                     */

  End Collection                          */

 Fixed report descriptor for Ugee G5 frame controls */

  Usage Page (Desktop),               */

  Usage (Keypad),                     */

  Collection (Application),           */

      Report ID (6),                  */

      Usage Page (Digitizer),         */

      Usage (Tablet Function Keys),   */

      Collection (Physical),          */

          Logical Minimum (0),        */

          Logical Maximum (1),        */

          Usage Page (Desktop),       */

          Usage Page (Button),        */

          Usage Minimum (01h),        */

          Usage Maximum (05h),        */

          Report Size (1),            */

          Report Count (5),           */

          Input (Variable),           */

          Report Size (1),            */

          Report Count (3),           */

          Input (Constant),           */

          Usage Page (Digitizer),     */

          Usage (FFFFh),              */

          Logical Maximum (255),      */

          Report Size (8),            */

          Report Count (1),           */

          Input (Variable),           */

          Logical Maximum (1),        */

          Usage (Barrel Switch),      */

          Report Size (1),            */

          Report Count (1),           */

          Input (Variable),           */

          Usage Page (Desktop),       */

          Usage (X),                  */

          Usage (Y),                  */

          Report Size (1),            */

          Report Count (2),           */

          Input (Variable),           */

          Report Size (1),            */

          Report Count (11),          */

          Input (Constant),           */

          Usage Page (Desktop),       */

          Usage (Wheel),              */

          Logical Minimum (-1),       */

          Logical Maximum (1),        */

          Report Size (2),            */

          Report Count (1),           */

          Input (Variable, Relative), */

      End Collection,                 */

  End Collection                      */

 Fixed report descriptor for XP-Pen Deco 01 frame controls */

  Usage Page (Desktop),               */

  Usage (Keypad),                     */

  Collection (Application),           */

      Report ID (6),                  */

      Logical Minimum (0),            */

      Logical Maximum (1),            */

      Report Size (1),                */

      Usage Page (Digitizer),         */

      Usage (Tablet Function Keys),   */

      Collection (Physical),          */

          Usage Page (Button),        */

          Usage Minimum (01h),        */

          Usage Maximum (08h),        */

          Report Count (8),           */

          Input (Variable),           */

          Usage Page (Digitizer),     */

          Usage (Barrel Switch),      */

          Report Count (1),           */

          Input (Variable),           */

          Usage Page (Desktop),       */

          Usage (X),                  */

          Usage (Y),                  */

          Report Count (2),           */

          Input (Variable),           */

          Report Count (21),          */

          Input (Constant),           */

      End Collection,                 */

  End Collection                      */

/**

 * uclogic_rdesc_template_apply() - apply report descriptor parameters to a

 * report descriptor template, creating a report descriptor. Copies the

 * template over to the new report descriptor and replaces every occurrence of

 * UCLOGIC_RDESC_PH_HEAD, followed by an index byte, with the value from the

 * parameter list at that index.

 *

 * @template_ptr:	Pointer to the template buffer.

 * @template_size:	Size of the template buffer.

 * @param_list:		List of template parameters.

 * @param_num:		Number of parameters in the list.

 *

 * Returns:

 *	Kmalloc-allocated pointer to the created report descriptor,

 *	or NULL if allocation failed.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  HID driver for TiVo Slide Bluetooth remote

 *

 *  Copyright (c) 2011 Jarod Wilson <jarod@redhat.com>

 *  based on the hid-topseed driver, which is in turn, based on hid-cherry...

/*

 TiVo button */

 Live TV */

 Red thumbs down */

 Green thumbs up */

 Enter/Last (default mapping: KEY_LAST) */

 Info (default mapping: KEY_PROPS) */

	/* This means we found a matching mapping here, else, look in the

 TiVo Slide Bluetooth remote, pairs with a Broadcom dongle */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  HID driver for LC Power Model RC1000MCE

 *

 *  Copyright (c) 2011 Chris Schlund 

 *  based on hid-topseed module

/*

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * drivers/input/tablet/wacom_wac.c

 *

 *  USB Wacom tablet support - Wacom specific code

/*

 resolution for penabled devices */

 Newer Cintiq and DTU have an offset between tablet and screen areas */

/*

 * Scale factor relating reported contact size to logical contact area.

 * 2^14/pi is a good approximation on Intuos5 and 3rd-gen Bamboo

/*

 * Percent of battery capacity for Graphire.

 * 8th value means AC online and show 100% capacity.

/*

 * Percent of battery capacity for Intuos4 WL, AC has a separate bit.

 report tool id */

 report tool id */

 report tool id */

	/* If the eraser is in prox, STYLUS2 is always set. If we

	 * mis-detected the type and notice that STYLUS2 isn't set

	 * then force the eraser out of prox and let the pen in.

 Only allow the stylus2 button to be reported for the pen tool. */

 report tool id */

 Going into proximity select tool */

 out-prox */

 Rubber */

 Pen */

 out-prox */

 Pen */

 Rubber */

 Mouse with wheel */

 Mouse without wheel */

 Compute distance between mouse and tablet */

 Mouse with wheel */

 report tool id */

 sync last event */

 send pad data */

 Store current battery capacity and power supply state */

 pad packets. Works as a second tool and is always in prox */

		/*

		 * Three "buttons" are available on the 24HD which are

		 * physically implemented as a touchstrip. Each button

		 * is approximately 3 bits wide with a 2 bit spacing.

		 * The raw touchstrip bits are stored at:

		 *    ((data[3] & 0x1f) << 8) | data[4])

		/*

		 * Do not send hardware buttons under Android. They

		 * are already sent to the system through GPIO (and

		 * have different meaning).

		 *

		 * d-pad right  -> data[4] & 0x10

		 * d-pad up     -> data[4] & 0x20

		 * d-pad left   -> data[4] & 0x40

		 * d-pad down   -> data[4] & 0x80

		 * d-pad center -> data[3] & 0x01

		/* d-pad right  -> data[2] & 0x10

		 * d-pad up     -> data[2] & 0x20

		 * d-pad left   -> data[2] & 0x40

		 * d-pad down   -> data[2] & 0x80

		 * d-pad center -> data[1] & 0x01

		/*

		 * ExpressKeys on Intuos5/Intuos Pro have a capacitive sensor in

		 * addition to the mechanical switch. Switch data is

		 * stored in data[4], capacitive data in data[5].

		 *

		 * Touch ring mode switch (data[3]) has no capacitive sensor

 Inking pen */

 Intuos3 Inking pen */

 Intuos4/5 Inking Pen */

 Pen */

 Intuos3 Grip Pen */

 Intuos3 Classic Pen */

 Intuos3 Marker Pen */

 Intuos4/5 13HD/24HD General Pen */

 Intuos4/5 13HD/24HD Marker Pen */

 IntuosHT2 pen */

 Intuos4/5 13HD/24HD Art Pen */

 MobileStudio Pro Pro Pen slim */

 Intuos4/5 13HD/24HD Classic Pen */

 Cintiq 13HD Pro Pen */

 DTH2242 Pen */

 Intuos4/5 13HD/24HD General Pen */

 Stroke pen */

 Mouse 4D and 2D */

 Intuos3 2D Mouse */

 Intuos4 Mouse */

 Lens cursor */

 Intuos3 Lens cursor */

 Intuos4 Lens cursor */

 Eraser */

 Intuos3 Grip Pen Eraser */

 Intuos3 Classic Pen Eraser */

 Intuos3 Airbrush Eraser */

 Intuos4/5 13HD/24HD Marker Pen Eraser */

 Intuos4/5 13HD/24HD General Pen Eraser */

 Intuos4/5 13HD/24HD Airbrush Eraser */

 Intuos4/5 13HD/24HD Classic Pen Eraser */

 Intuos4/5 13HD/24HD Airbrush Eraser */

 Intuos4/5 13HD/24HD Art Pen Eraser */

 MobileStudio Pro Pro Pen slim Eraser */

 Cintiq 13HD Pro Pen Eraser */

 DTH2242 Eraser */

 Intuos4/5 13HD/24HD General Pen Eraser */

 Intuos3 Airbrush */

 Intuos4/5 13HD/24HD Airbrush */

 Intuos4/5 13HD/24HD Airbrush */

 Unknown tool */

	/*

	 * Reset all states otherwise we lose the initial states

	 * when in-prox next time

 reset tool id */

 in prox */

 in range */

 out prox */

 Enter report */

 serial number of the tool */

 in Range */

 in Range while exiting */

 Exit report */

 don't report exit if we don't know the ID */

 don't report events if we don't know the tool ID */

 but reschedule a read of the current tool */

	/*

	 * don't report events for invalid data

 older I4 styli don't work with new Cintiqs */

 Only large Intuos support Lense Cursor */

 Cintiq doesn't send data when RDY bit isn't set */

 general pen packet */

 airbrush second packet */

 Rotation packet */

 I3 marker pen rotation */

 4D mouse 2nd packet */

 4D mouse 1st packet */

 I4 mouse */

 2D mouse packet */

 I3 2D mouse side buttons */

 Lens cursor packets */

 unhandled */

 report tool id */

 process pad events */

 process in/out prox events */

 process general packets */

Which mode select (LED light) is currently on?*/

 Add back in missing bits of ID for non-USI pens */

 first in range */

 Going into range select tool */

 Fix rotation alignment: userspace expects zero at left */

 report tool id */

		/*

		 * First packet resets the counter since only the first

		 * packet in series will have non-zero current_num_contacts.

 Be careful that we don't accidentally call input_sync with

 only a partial set of fingers of processed

 Fix touchring data: userspace expects 0 at left and increasing clockwise */

 maximum contacts per packet */

	/*

	 * First packet resets the counter since only the first

	 * packet in series will have non-zero current_num_contacts.

 MTTPC does not support Height and Width */

	/*

	 * First packet resets the counter since only the first

	 * packet in series will have non-zero current_num_contacts.

 There are at most 5 contacts per packet */

 keep touch state for pen event */

 keep touch state for pen events */

 first in prox */

 Going into proximity select tool */

 keep pen state for touch events */

	/* send pen events only when touch is up or forced out

	 * or touch arbitration is off

 softkey touch switch */

		/*

		 * These two usages, which are used to mute touch events, come

		 * from the pad packet, but are reported on the touch

		 * interface. Because the touch interface may not have

		 * been created yet, we cannot call wacom_map_usage(). In

		 * order to process the usages when we receive them, we set

		 * the usage type and code directly.

		/*

		 * Only set up type/code association. Completely mapping

		 * this usage may overwrite the axis resolution and range.

 do not overwrite previous data */

	/*

	 * Avoid reporting this event and setting inrange_state if this usage

	 * hasn't been mapped.

		/*

		 * Userspace expects touchrings to increase in value with

		 * clockwise gestures and have their zero point at the

		 * tablet's left. HID events "should" be clockwise-

		 * increasing and zero at top, though the MobileStudio

		 * Pro and 2nd-gen Intuos Pro don't do this...

 MobileStudio Pro */

 Intuos Pro 2 */

 Intuos Pro 2 */

 MobileStudio Pro */

 MobileStudio Pro */

 report prox for expresskey events */

		/*

		 * HID_GD_Z "should increase as the control's position is

		 * moved from high to low", while ABS_DISTANCE instead

		 * increases in value as the tool moves from low to high.

		/*

		 * Userspace expects pen twist to have its zero point when

		 * the buttons/finger is on the tablet's left. HID values

		 * are zero when buttons are toward the top.

			/*

			 * Non-USI EMR devices may contain additional tool type

			 * information here. See WACOM_HID_WD_TOOLTYPE case for

			 * more details.

		/*

		 * Some devices (MobileStudio Pro, and possibly later

		 * devices as well) do not return the complete tool

		 * type in their WACOM_HID_WD_TOOLTYPE usage. Use a

		 * bitwise OR so the complete value can be built

		 * up over time :(

	/* send pen events only when touch is up or forced out

	 * or touch arbitration is off

 send pen events only when the pen is in range */

 first in range */

 Going into range select tool */

 keep pen state for touch events */

		/*

		 * Non-USI EMR tools should have their IDs mangled to

		 * match the legacy behavior of wacom_intuos_general

		/*

		 * To ensure compatibility with xf86-input-wacom, we should

		 * report the BTN_TOOL_* event prior to the ABS_MISC or

		 * MSC_SERIAL events.

			/*

			 * The HID descriptor for G11 sensors leaves logical

			 * maximum set to '1' despite it being a multitouch

			 * device. Override to a sensible number.

 No data to send for this slot; short-circuit

 if there was nothing to process, don't send an empty sync */

	/* If more packets of data are expected, give us a chance to

	 * process them rather than immediately syncing a partial

	 * update.

 keep touch state for pen event */

 usage tests must precede field tests */

 usage tests must precede field tests */

	/*

	 * Non-input reports may be sent prior to the device being

	 * completely initialized. Since only their events need

	 * to be processed, exit after 'wacom_report_events' has

	 * been called to prevent potential crashes in the report-

	 * processing functions.

			/*

			 * "a" is a scaled-down area which we assume is

			 * roughly circular and which can be described as:

			 * a=(pi*r^2)/C.

 data has up to 7 fixed sized 8-byte messages starting at data[2] */

 only update touch if we actually have a touchpad and touch data changed */

		/*

		 * Convert distance from out prox to distance from tablet.

		 * distance will be greater than distance_max once

		 * touching and applying pressure; do not report negative

		 * distance.

 PEN or RUBBER */

 TOOL ID */

	/*

	 * We need to reroute the event from the debug interface to the

	 * pen interface.

	 * We need to add the report ID to the actual pen report, so we

	 * temporary overwrite the first byte to prevent having to kzalloc/kfree

	 * and memcpy the report.

	/*

	 * actually reroute the event.

	 * No need to check if wacom->shared->pen is valid, hid_input_report()

	 * will check for us.

 keep touch state for pen event */

 disconnected while previously connected */

 wireless module is attached */

 The pen and pad share the same interface on most devices */

 touch device found but size is not defined. use default */

	/*

	 * Intuos5/Pro and Bamboo 3rd gen have no useful data about its

	 * touch interface in its HID descriptor. If this is the touch

	 * interface (PacketSize of WACOM_PKGLEN_BBTOUCH3), override the

	 * tablet values.

	/*

	 * Hack for the Bamboo One:

	 * the device presents a PAD/Touch interface as most Bamboos and even

	 * sends ghosts PAD data on it. However, later, we must disable this

	 * ghost interface, and we can not detect it unless we set it here

	 * to WACOM_DEVICETYPE_PAD or WACOM_DEVICETYPE_TOUCH.

	/*

	 * Raw Wacom-mode pen and touch events both come from interface

	 * 0, whose HID descriptor has an application usage of 0xFF0D

	 * (i.e., WACOM_HID_WD_DIGITIZER). We route pen packets back

	 * out through the HID_GENERIC device created for interface 1,

	 * so rewrite this one to be of type WACOM_DEVICETYPE_TOUCH.

 quirk for bamboo touch with 2 low res touches */

	/* HID descriptor for DTK-2451 / DTH-2452 claims to report lots

	 * of things it shouldn't. Lets fix up the damage...

 setup has already been done */

 penabled devices have fixed resolution for each model */

 setup has already been done */

	/*

	 * 24HD has LED group 1 to the left and LED group 0 to the right.

	 * So group 0 matches the second half of the buttons and thus the mask

	 * needs to be shifted.

	/*

	 * 21UX2 has LED group 1 to the left and LED group 0

	 * to the right. We need to reverse the group to match this

	 * historical behavior.

 kept for making legacy xf86-input-wacom working with the wheels */

 kept for making legacy xf86-input-wacom accepting the pad */

 kept for making udev and libwacom accepting the pad */

 points/g */

		/*

		 * For Bluetooth devices, the udev rule does not work correctly

		 * for pads unless we add a stylus capability, which forces

		 * ID_INPUT_TABLET to be set.

 no pad supported */

 Pen */

 Touch */

 Touch */

 Pen */

 Touch */

 Pen-only */

 Pen-only */

 Pen-only */

 Pen-only */

 Pen-only */

 Touch */

 Touch */

 Touch */

 Touch */

 Touch */

 SPDX-License-Identifier: GPL-2.0+

/*

 *  HID driver for quirky Macally devices

 *

 *  Copyright (c) 2019 Alex Henrie <alexhenrie24@gmail.com>

/*

 * The Macally ikey keyboard says that its logical and usage maximums are both

 * 101, but the power key is 102 and the equals key is 103

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Plantronics USB HID Driver

 *

 *  Copyright (c) 2014 JD Cole <jd.cole@plantronics.com>

 *  Copyright (c) 2015-2018 Terry Junge <terry.junge@plantronics.com>

/*

 ms */

 special case for PTT products */

 handle volume up/down mapping */

 non-standard types or multi-HID interfaces - plt_type is PID */

 handle standard types - plt_type is 0xffa0uuuu or 0xffa2uuuu */

 'basic telephony compliant' - allow default consumer page map */

 not 'basic telephony' - apply legacy mapping */

 only map if the field is in the device's primary vendor page */

/*

 * Future mapping of call control or other usages,

 * if and when keys are defined would go here

 * otherwise, ignore everything else that was not mapped

 Usages are filtered in plantronics_usages. */

 Handle key presses only. */

 Ignore the repeated key. */

 multi-HID interfaces? - plt_type is PID */

 determine primary vendor page */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Force feedback support for Logitech RumblePad and Rumblepad 2

 *

 *  Copyright (c) 2008 Anssi Hannula <anssi.hannula@gmail.com>

/*

 Check that the report looks ok */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Roccat KonePure driver for Linux

 *

 * Copyright (c) 2012 Stefan Achatz <erazor_de@users.sourceforge.net>

/*

/*

 * Roccat KonePure is a smaller version of KoneXTD with less buttons and lights.

 always KONEPURE_MOUSE_REPORT_NUMBER_BUTTON */

 SPDX-License-Identifier: GPL-2.0-only

/***************************************************************************

 *   Copyright (C) 2010-2012 by Bruno Prémont <bonbons@linux-vserver.org>  *

 *                                                                         *

 *   Based on Logitech G13 driver (v0.4)                                   *

 *     Copyright (C) 2009 by Rick L. Vinyard, Jr. <rvinyard@cs.nmsu.edu>   *

 *                                                                         *

/*

 * The "eeprom" file

 prepare buffer with info about what we want to read (addr & len) */

 successful read :) */

 anything else is some kind of IO error */

 check if written data matches */

/*

 * Notes:

 * - read/write happens in chunks of at most 20 bytes, it's up to userspace

 *   to loop in order to get more data.

 * - on write errors on otherwise correct write request the bytes

 *   that should have been written are in undefined state.

/*

 * The "flash" file

 record a flash address to buf (bounds check to be done by caller) */

 read a given size of data (bounds check to be done by caller) */

 erase block aligned to 64bytes boundary */

 write a given size of data (bounds check to be done by caller) */

/*

 * Notes:

 * - concurrent writing is prevented by mutex and all writes must be

 *   n*64 bytes and 64-byte aligned, each write being preceded by an

 *   ERASE which erases a 64byte block.

 *   If less than requested was written or an error is returned for an

 *   otherwise correct write request the next 64-byte block which should

 *   have been written is in undefined state (mostly: original, erased,

 *   (half-)written with write error)

 * - reading can happen without special restriction

/*

 * Helper code for HID report level dumping/debugging

 Avoid unnecessary overhead if debugfs is disabled */

 1 data byte with GPO state */

 1 data byte with brightness */

 1 data byte with contrast */

 2 data bytes with reset duration in ms */

 63 data bytes with LCD commands */

 TODO: format decoding */

 63 data bytes with LCD data */

 TODO: format decoding */

 63 data bytes with LCD commands and data */

 TODO: format decoding */

 3 data bytes with read area description */

 3+1..20 data bytes with write area description */

 3 data bytes with pointer inside erase block */

 4 data bytes with read area description */

 4+1..32 data bytes with write adrea description */

 TODO */

 Avoid unnecessary overhead if debugfs is disabled */

 2 data bytes with affected report and error code */

 2 data bytes with key state */

 Up to 20 byes of IR scancode data */

 Data buffer in response to REPORT_EE_READ or REPORT_EE_WRITE */

 Data buffer in response to REPORT_READ_MEMORY or REPORT_WRITE_MEMORY */

 TODO */

 TODO */

 TODO */

 reset */

 eeprom */

 flash */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Force feedback support for various HID compliant devices by ThrustMaster:

 *    ThrustMaster FireStorm Dual Power 2

 * and possibly others whose device ids haven't been added.

 *

 *  Modified to support ThrustMaster devices by Zinx Verituse

 *  on 2003-01-25 from the Logitech force feedback driver,

 *  which is by Johann Deneux.

 *

 *  Copyright (c) 2003 Zinx Verituse <zinx@epicsol.org>

 *  Copyright (c) 2002 Johann Deneux

/*

 Usages for thrustmaster devices I know about */

 Changes values from 0 to 0xffff into values from minimum to maximum */

 Changes values from -0x80 to 0x7f into values from minimum to maximum */

 Rumbling */

 2-in-1 strong motor is left */

 Find the report to use */

 FireStorm Dual Power 2 (and 3) */

 Dual Trigger 2-in-1 */

 Dual Trigger 3-in-1 (PC Mode) */

 Dual Trigger 3-in-1 (PS3 Mode) */

 NASCAR PRO FF2 Wheel */

 FGT Rumble Force Wheel */

 RGT Force Feedback CLUTCH Raging Wheel */

 FGT Force Feedback Wheel */

 F430 Force Feedback Wheel */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  ION iCade input driver

 *

 *  Copyright (c) 2012 Bastien Nocera <hadess@hadess.net>

 *  Copyright (c) 2012 Benjamin Tissoires <benjamin.tissoires@gmail.com>

/*

/*

 *   ↑      A C Y L

 *  ← →

 *   ↓      B X Z R

 *

 *

 *  UP ON,OFF  = w,e

 *  RT ON,OFF  = d,c

 *  DN ON,OFF  = x,z

 *  LT ON,OFF  = a,q

 *  A  ON,OFF  = y,t

 *  B  ON,OFF  = h,r

 *  C  ON,OFF  = u,f

 *  X  ON,OFF  = j,n

 *  Y  ON,OFF  = i,m

 *  Z  ON,OFF  = k,p

 *  L  ON,OFF  = o,g

 *  R  ON,OFF  = l,v

/* The translation code uses HID usage instead of input layer

 * keys. This code generates a lookup table that makes

 * translation quick.

 *

 * #include <linux/input.h>

 * #include <stdio.h>

 * #include <assert.h>

 *

 * #define unk     KEY_UNKNOWN

 *

 * < copy of hid_keyboard[] from hid-input.c >

 *

 * struct icade_key_translation {

 *     int         from;

 *     const char *to;

 *     int         press;

 * };

 *

 * static const struct icade_key_translation icade_keys[] = {

 *    { KEY_W,        "KEY_UP",         1 },

 *    { KEY_E,        "KEY_UP",         0 },

 *    { KEY_D,        "KEY_RIGHT",      1 },

 *    { KEY_C,        "KEY_RIGHT",      0 },

 *    { KEY_X,        "KEY_DOWN",       1 },

 *    { KEY_Z,        "KEY_DOWN",       0 },

 *    { KEY_A,        "KEY_LEFT",       1 },

 *    { KEY_Q,        "KEY_LEFT",       0 },

 *    { KEY_Y,        "BTN_A",          1 },

 *    { KEY_T,        "BTN_A",          0 },

 *    { KEY_H,        "BTN_B",          1 },

 *    { KEY_R,        "BTN_B",          0 },

 *    { KEY_U,        "BTN_C",          1 },

 *    { KEY_F,        "BTN_C",          0 },

 *    { KEY_J,        "BTN_X",          1 },

 *    { KEY_N,        "BTN_X",          0 },

 *    { KEY_I,        "BTN_Y",          1 },

 *    { KEY_M,        "BTN_Y",          0 },

 *    { KEY_K,        "BTN_Z",          1 },

 *    { KEY_P,        "BTN_Z",          0 },

 *    { KEY_O,        "BTN_THUMBL",     1 },

 *    { KEY_G,        "BTN_THUMBL",     0 },

 *    { KEY_L,        "BTN_THUMBR",     1 },

 *    { KEY_V,        "BTN_THUMBR",     0 },

 *

 *    { }

 * };

 *

 * static int

 * usage_for_key (int key)

 * {

 *     int i;

 *     for (i = 0; i < 256; i++) {

 *     if (hid_keyboard[i] == key)

 *         return i;

 *     }

 *     assert(0);

 * }

 *

 * int main (int argc, char **argv)

 * {

 *     const struct icade_key_translation *trans;

 *     int max_usage = 0;

 *

 *     for (trans = icade_keys; trans->from; trans++) {

 *         int usage = usage_for_key (trans->from);

 *         max_usage = usage > max_usage ? usage : max_usage;

 *     }

 *

 *     printf ("#define ICADE_MAX_USAGE %d\n\n", max_usage);

 *     printf ("struct icade_key {\n");

 *     printf ("\tu16 to;\n");

 *     printf ("\tu8 press:1;\n");

 *     printf ("};\n\n");

 *     printf ("static const struct icade_key "

 *             "icade_usage_table[%d] = {\n", max_usage + 1);

 *     for (trans = icade_keys; trans->from; trans++) {

 *         printf ("\t[%d] = { %s, %d },\n",

 *                 usage_for_key (trans->from), trans->to, trans->press);

 *     }

 *     printf ("};\n");

 *

 *     return 0;

 * }

 We ignore the fake key up, and act only on key down */

 ignore others */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  HID driver for Steelseries SRW-S1

 *

 *  Copyright (c) 2013 Simon Wood

/*

 the last element is used for setting all leds simultaneously */

/* Fixed report descriptor for Steelseries SRW-S1 wheel controller

 *

 * The original descriptor hides the sensitivity and assists dials

 * a custom vendor usage page. This inserts a patch to make them

 * appear in the 'Generic Desktop' usage.

  Usage Page (Desktop)                */

  Usage (MultiAxis), Changed          */

  Collection (Application),           */

      Collection (Logical),           */

          Report Count (1),           */

 Changed  Usage Page (Desktop),       */

 Changed  Usage (X),                  */

          Logical Minimum (-1800),    */

          Logical Maximum (1800),     */

          Unit (Degrees),             */

          Unit Exponent (15),         */

          Report Size (16),           */

          Input (Variable),           */

 Changed  Usage (Y),                  */

          Logical Minimum (0),        */

          Logical Maximum (1023),     */

          Report Size (12),           */

          Input (Variable),           */

 Changed  Usage (Z),                  */

          Logical Minimum (0),        */

          Logical Maximum (1023),     */

          Report Size (12),           */

          Input (Variable),           */

          Usage Page (Desktop),       */

          Usage (Hat Switch),         */

          Logical Maximum (7),        */

          Physical Minimum (0),       */

          Physical Maximum (315),     */

          Unit (Degrees),             */

          Report Size (4),            */

          Report Count (1),           */

          Input (Variable),           */

          Logical Maximum (1),        */

          Physical Maximum (1),       */

          Unit,                       */

          Report Size (1),            */

          Report Count (3),           */

          Input (Constant),           */

          Usage Page (Button),        */

          Usage Minimum (01h),        */

          Usage Maximum (11h),        */

          Report Count (17),          */

          Input (Variable),           */

   ---- Dial patch starts here ----   */

          Usage Page (Desktop),       */

          Usage (RX),                 */

          Report Size (4),            */

          Report Count (2),           */

          Logical Minimum (0),        */

          Logical Maximum (b),        */

          Input (Variable),           */

          Usage (RZ),                 */

          Report Size (4),            */

          Report Count (1),           */

          Logical Maximum (3),        */

          Input (Variable),           */

    ---- Dial patch ends here ----    */

          Usage Page (FF00h),         */

          Usage (01h),                */

 Changed  Report Size (4),            */

 Changed  Report Count (13),          */

          Input (Variable),           */

      End Collection,                 */

      Collection (Logical),           */

          Usage (02h),                */

          Report Size (8),            */

          Report Count (16),          */

          Output (Variable),          */

      End Collection,                 */

  End Collection                      */

 Note: LED change does not show on device until the device is read/polled */

 register led subsystem */

 'ALL', for setting all LEDs simultaneously */

 Each individual LED */

 Deregister all LEDs (if any) */

 but let the driver continue without LEDs */

 Deregister LEDs (if any) */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  HID driver for some petalynx "special" devices

 *

 *  Copyright (c) 1999 Andreas Gal

 *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>

 *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc

 *  Copyright (c) 2006-2007 Jiri Kosina

 *  Copyright (c) 2008 Jiri Slaby

/*

 Petalynx Maxter Remote has maximum for consumer page set too low */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * User-space I/O driver support for HID subsystem

 * Copyright (c) 2012 David Herrmann

/*

 blocking GET_REPORT support; state changes protected by qlock */

 must be called with report_lock held */

 id for old report; drop it silently */

 this _always_ takes ownership of @ev */

 this _always_ takes ownership of @ev */

 Apparently we haven't stepped on these rakes enough times yet. */

			/*

			 * This is our messed up request with compat pointer.

			 * It is largish (more than 256 bytes) so we better

			 * allocate it from the heap.

 Shuffle the data over to proper structure */

 All others can be copied directly */

 @hid is zero-initialized, strncpy() is correct, strlcpy() not */

	/* Adding of a HID device is done through a worker, to allow HID drivers

	 * which use feature requests during .probe to work, without they would

	 * be blocked on devlock, which is held by uhid_char_write.

 they need at least the "type" member of uhid_event */

 we need at least the "type" member of uhid_event */

		/*

		 * 'struct uhid_create_req' contains a __user pointer which is

		 * copied from, so it's unsafe to allow this with elevated

		 * privileges (e.g. from a setuid binary) or via kernel_write().

 return "count" not "len" to not confuse the caller */

 uhid is always writable */

 SPDX-License-Identifier: GPL-2.0

/*

 * U2F Zero LED and RNG driver

 *

 * Copyright 2018 Andrej Shadura <andrew@shadura.me>

 * Loosely based on drivers/hid/hid-led.c

 *              and drivers/usb/misc/chaoskey.c

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License as

 * published by the Free Software Foundation, version 2.

 We only use broadcast (CID-less) messages */

 URB for the RNG data */

 Embedded struct for led */

 Embedded struct for hwrng */

 valid packets must have a correct header */

 ignore errors or packets without data */

 only take the minimum amount of data it is safe to take */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Force feedback support for ACRUX game controllers

 *

 * From what I have gathered, these devices are mass produced in China

 * by several vendors. They often share the same design as the original

 * Xbox 360 controller.

 *

 * 1a34:0802 "ACRUX USB GAMEPAD 8116"

 *  - tested with an EXEQ EQ-PCU-02090 game controller.

 *

 * Copyright (c) 2010 Sergei Kolzun <x0r@dv-life.ru>

/*

		/*

		 * Do not fail device initialization completely as device

		 * may still be partially operable, just warn.

	/*

	 * We need to start polling device right away, otherwise

	 * it will go into a coma.

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  Copyright (c) 2009, Citrix Systems, Inc.

 *  Copyright (c) 2010, Microsoft Corporation.

 *  Copyright (c) 2011, Novell Inc.

 The maximum size of a synthetic input message. */

/*

 * Current version

 *

 * History:

 * Beta, RC < 2008/1/22        1,0

 * RC > 2008/1/22              2,0

/*

 * Message types in the synthetic input protocol

/*

 * Basic message structures.

 Enclosed message */

/*

 * Protocol messages

/*

 * Represents an mousevsc device

 Synchronize the request/response if needed */

 The pointer is not NULL when we resume from hibernation */

 The pointer is not NULL when we resume from hibernation */

 Send the ack */

		/*

		 * While it will be impossible for us to protect against

		 * malicious/buggy hypervisor/host, add a check here to

		 * ensure we don't corrupt memory.

		/*

		 * Parse out the device info into device attr,

		 * hid desc and report desc

	/*

	 * We should have gotten the device attr, hid desc and report

	 * desc at this point

 workaround SA-167 */

 Mouse guid */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  HID driver for Logitech receivers

 *

 *  Copyright (c) 2011 Logitech

 For to_usb_interface for kvm extra intf check */

 Command Switch to DJ mode */

 Command to Get the list of Paired devices */

 Device Paired Notification */

 Device Un-Paired Notification */

 Connection Status Notification */

 Error Notification */

 supported DJ HID && RF report types */

 RF Report types bitfield */

 Fake (bitnr > NUMBER_OF_HID_REPORTS) bit to track HID++ capability */

 HID++ Device Connected Notification */

 in jiffies */

 WORKITEM_TYPE_* */

 Keyboard descriptor (1) */

 USAGE_PAGE (generic Desktop)     */

 USAGE (Keyboard)         */

 COLLECTION (Application)     */

 REPORT_ID (1)            */

   REPORT_COUNT (8)           */

   REPORT_SIZE (1)            */

   LOGICAL_MINIMUM (0)        */

   LOGICAL_MAXIMUM (1)        */

   USAGE_PAGE (Keyboard)      */

   USAGE_MINIMUM (Left Control)   */

   USAGE_MAXIMUM (Right GUI)      */

   INPUT (Data,Var,Abs)       */

   REPORT_COUNT (6)           */

   REPORT_SIZE (8)            */

   LOGICAL_MINIMUM (0)        */

   LOGICAL_MAXIMUM (255)      */

   USAGE_PAGE (Keyboard)      */

   USAGE_MINIMUM (no event)       */

   USAGE_MAXIMUM (reserved)       */

   INPUT (Data,Ary,Abs)       */

 REPORT_ID (14)               */

   USAGE PAGE (LED page)      */

   REPORT COUNT (5)           */

   REPORT SIZE (1)            */

   LOGICAL_MINIMUM (0)        */

   LOGICAL_MAXIMUM (1)        */

   USAGE MINIMUM (1)          */

   USAGE MAXIMUM (5)          */

   OUTPUT (Data, Variable, Absolute)  */

   REPORT COUNT (1)           */

   REPORT SIZE (3)            */

   OUTPUT (Constant)          */

 Mouse descriptor (2)     */

  USAGE_PAGE (Generic Desktop)        */

  USAGE (Mouse)                       */

  COLLECTION (Application)            */

    REPORT_ID = 2                     */

    USAGE (pointer)                   */

    COLLECTION (physical)             */

      USAGE_PAGE (buttons)            */

      USAGE_MIN (1)                   */

      USAGE_MAX (16)                  */

      LOGICAL_MIN (0)                 */

      LOGICAL_MAX (1)                 */

      REPORT_COUNT (16)               */

      REPORT_SIZE (1)                 */

      INPUT (data var abs)            */

      USAGE_PAGE (generic desktop)    */

      LOGICAL_MIN (-2047)             */

      LOGICAL_MAX (2047)              */

      REPORT_SIZE (12)                */

      REPORT_COUNT (2)                */

      USAGE (X)                       */

      USAGE (Y)                       */

      INPUT                           */

      LOGICAL_MIN (-127)              */

      LOGICAL_MAX (127)               */

      REPORT_SIZE (8)                 */

      REPORT_COUNT (1)                */

      USAGE (wheel)                   */

      INPUT                           */

      USAGE_PAGE(consumer)            */

      USAGE(AC Pan)                   */

      REPORT_COUNT (1)                */

      INPUT                           */

    END_COLLECTION                    */

  END_COLLECTION                      */

 Mouse descriptor (2) for 27 MHz receiver, only 8 buttons */

  USAGE_PAGE (Generic Desktop)        */

  USAGE (Mouse)                       */

  COLLECTION (Application)            */

    REPORT_ID = 2                     */

    USAGE (pointer)                   */

    COLLECTION (physical)             */

      USAGE_PAGE (buttons)            */

      USAGE_MIN (1)                   */

      USAGE_MAX (8)                   */

      LOGICAL_MIN (0)                 */

      LOGICAL_MAX (1)                 */

      REPORT_COUNT (8)                */

      REPORT_SIZE (1)                 */

      INPUT (data var abs)            */

      USAGE_PAGE (generic desktop)    */

      LOGICAL_MIN (-2047)             */

      LOGICAL_MAX (2047)              */

      REPORT_SIZE (12)                */

      REPORT_COUNT (2)                */

      USAGE (X)                       */

      USAGE (Y)                       */

      INPUT                           */

      LOGICAL_MIN (-127)              */

      LOGICAL_MAX (127)               */

      REPORT_SIZE (8)                 */

      REPORT_COUNT (1)                */

      USAGE (wheel)                   */

      INPUT                           */

      USAGE_PAGE(consumer)            */

      USAGE(AC Pan)                   */

      REPORT_COUNT (1)                */

      INPUT                           */

    END_COLLECTION                    */

  END_COLLECTION                      */

 Mouse descriptor (2) for Bluetooth receiver, low-res hwheel, 12 buttons */

  USAGE_PAGE (Generic Desktop)        */

  USAGE (Mouse)                       */

  COLLECTION (Application)            */

    REPORT_ID = 2                     */

    USAGE (pointer)                   */

    COLLECTION (physical)             */

      USAGE_PAGE (buttons)            */

      USAGE_MIN (1)                   */

      USAGE_MAX (8)                   */

      LOGICAL_MIN (0)                 */

      LOGICAL_MAX (1)                 */

      REPORT_COUNT (8)                */

      REPORT_SIZE (1)                 */

      INPUT (data var abs)            */

      USAGE_PAGE (generic desktop)    */

      LOGICAL_MIN (-2047)             */

      LOGICAL_MAX (2047)              */

      REPORT_SIZE (12)                */

      REPORT_COUNT (2)                */

      USAGE (X)                       */

      USAGE (Y)                       */

      INPUT                           */

      LOGICAL_MIN (-127)              */

      LOGICAL_MAX (127)               */

      REPORT_SIZE (8)                 */

      REPORT_COUNT (1)                */

      USAGE (wheel)                   */

      INPUT                           */

      USAGE_PAGE(consumer)            */

      USAGE(AC Pan)                   */

      LOGICAL_MIN (-7)                */

      LOGICAL_MAX (7)                 */

      REPORT_SIZE (4)                 */

      REPORT_COUNT (1)                */

      INPUT                           */

      USAGE_PAGE (buttons)            */

      USAGE_MIN (9)                   */

      USAGE_MAX (12)                  */

      LOGICAL_MIN (0)                 */

      LOGICAL_MAX (1)                 */

      REPORT_SIZE (1)                 */

      REPORT_COUNT (4)                */

      INPUT (Data,Var,Abs)            */

    END_COLLECTION                    */

  END_COLLECTION                      */

 Mouse descriptor (5) for Bluetooth receiver, normal-res hwheel, 8 buttons */

  USAGE_PAGE (Generic Desktop)        */

  Usage (Mouse)                       */

  Collection (Application)            */

   Report ID (5)                      */

   Usage (Pointer)                    */

   Collection (Physical)              */

    Usage Page (Button)               */

    Usage Minimum (1)                 */

    Usage Maximum (8)                 */

    Logical Minimum (0)               */

    Logical Maximum (1)               */

    Report Count (8)                  */

    Report Size (1)                   */

    Input (Data,Var,Abs)              */

    Usage Page (Generic Desktop)      */

    Logical Minimum (-2047)           */

    Logical Maximum (2047)            */

    Report Size (12)                  */

    Report Count (2)                  */

    Usage (X)                         */

    Usage (Y)                         */

    Input (Data,Var,Rel)              */

    Logical Minimum (-127)            */

    Logical Maximum (127)             */

    Report Size (8)                   */

    Report Count (1)                  */

    Usage (Wheel)                     */

    Input (Data,Var,Rel)              */

    Usage Page (Consumer Devices)     */

    Usage (AC Pan)                    */

    Logical Minimum (-127)            */

    Logical Maximum (127)             */

    Report Size (8)                   */

    Report Count (1)                  */

    Input (Data,Var,Rel)              */

   End Collection                     */

  End Collection                      */

 Gaming Mouse descriptor (2) */

  USAGE_PAGE (Generic Desktop)        */

  USAGE (Mouse)                       */

  COLLECTION (Application)            */

    REPORT_ID = 2                     */

    USAGE (pointer)                   */

    COLLECTION (physical)             */

      USAGE_PAGE (buttons)            */

      USAGE_MIN (1)                   */

      USAGE_MAX (16)                  */

      LOGICAL_MIN (0)                 */

      LOGICAL_MAX (1)                 */

      REPORT_COUNT (16)               */

      REPORT_SIZE (1)                 */

      INPUT (data var abs)            */

      USAGE_PAGE (generic desktop)    */

      LOGICAL_MIN (-32767)            */

      LOGICAL_MAX (32767)             */

      REPORT_SIZE (16)                */

      REPORT_COUNT (2)                */

      USAGE (X)                       */

      USAGE (Y)                       */

      INPUT                           */

      LOGICAL_MIN (-127)              */

      LOGICAL_MAX (127)               */

      REPORT_SIZE (8)                 */

      REPORT_COUNT (1)                */

      USAGE (wheel)                   */

      INPUT                           */

      USAGE_PAGE(consumer)            */

      USAGE(AC Pan)                   */

      REPORT_COUNT (1)                */

      INPUT                           */

    END_COLLECTION                    */

  END_COLLECTION                      */

 Consumer Control descriptor (3) */

 USAGE_PAGE (Consumer Devices)       */

 USAGE (Consumer Control)            */

 COLLECTION (Application)            */

 REPORT_ID = 3                       */

 REPORT_SIZE (16)                    */

 REPORT_COUNT (2)                    */

 LOGICAL_MIN (1)                     */

 LOGICAL_MAX (767)                   */

 USAGE_MIN (1)                       */

 USAGE_MAX (767)                     */

 INPUT (Data Ary Abs)                */

 END_COLLECTION                      */

                                     */

 System control descriptor (4) */

   USAGE_PAGE (Generic Desktop)      */

   USAGE (System Control)            */

   COLLECTION (Application)          */

   REPORT_ID = 4                     */

   REPORT_SIZE (2)                   */

   REPORT_COUNT (1)                  */

   LOGICAL_MIN (1)                   */

   LOGICAL_MAX (3)                   */

   USAGE (System Sleep)              */

   USAGE (System Power Down)         */

   USAGE (System Wake Up)            */

   INPUT (Data Ary Abs NPrf Null)    */

   REPORT_SIZE (6)                   */

   INPUT (Cnst Var Abs)              */

   END_COLLECTION                    */

 Media descriptor (8) */

 Usage Page 0xffbc                   */

 Usage 0x0088                        */

 BeginCollection                     */

   Report ID 8                       */

   Usage Min 0x0001                  */

   Usage Max 0x00ff                  */

   Logical Min 1                     */

   Logical Max 255                   */

   Report Size 8                     */

   Report Count 1                    */

   Input                             */

 EndCollection                       */

                                     */

 HIDPP descriptor */

 Usage Page (Vendor Defined Page 1)  */

 Usage (Vendor Usage 1)              */

 Collection (Application)            */

   Report ID (16)                    */

   Report Size (8)                   */

   Report Count (6)                  */

   Logical Minimum (0)               */

   Logical Maximum (255)             */

   Usage (Vendor Usage 1)            */

   Input (Data,Arr,Abs)              */

   Usage (Vendor Usage 1)            */

   Output (Data,Arr,Abs)             */

 End Collection                      */

 Usage Page (Vendor Defined Page 1)  */

 Usage (Vendor Usage 2)              */

 Collection (Application)            */

   Report ID (17)                    */

   Report Size (8)                   */

   Report Count (19)                 */

   Logical Minimum (0)               */

   Logical Maximum (255)             */

   Usage (Vendor Usage 2)            */

   Input (Data,Arr,Abs)              */

   Usage (Vendor Usage 2)            */

   Output (Data,Arr,Abs)             */

 End Collection                      */

 Usage Page (Vendor Defined Page 1)  */

 Usage (Vendor Usage 0x04)           */

 Collection (Application)            */

   Report ID (32)                    */

   Report Size (8)                   */

   Report Count (14)                 */

   Logical Minimum (0)               */

   Logical Maximum (255)             */

   Usage (Vendor Usage 0x41)         */

   Input (Data,Arr,Abs)              */

   Usage (Vendor Usage 0x41)         */

   Output (Data,Arr,Abs)             */

   Report ID (33)                    */

   Report Count (31)                 */

   Logical Minimum (0)               */

   Logical Maximum (255)             */

   Usage (Vendor Usage 0x42)         */

   Input (Data,Arr,Abs)              */

   Usage (Vendor Usage 0x42)         */

   Output (Data,Arr,Abs)             */

 End Collection                      */

 Maximum size of all defined hid reports in bytes (including report id) */

 Make sure all descriptors are present here */

/* Number of possible hid report types that can be created by this driver.

 *

 * Right now, RF report types have the same report types (or report id's)

 * than the hid report created from those RF reports. In the future

 * this doesnt have to be true.

 *

 * For instance, RF report type 0x01 which has a size of 8 bytes, corresponds

 * to hid report id 0x01, this is standard keyboard. Same thing applies to mice

 * reports and consumer control, etc. If a new RF report is created, it doesn't

 * has to have the same report id as its corresponding hid report, so an

 * translation may have to take place for future report types.

 Standard keyboard */

 Standard mouse */

 Consumer control */

 System control */

 Media Center */

/*

 * dj/HID++ receivers are really a single logical entity, but for BIOS/Windows

 * compatibility they have multiple USB interfaces. On HID++ receivers we need

 * to listen for input reports on both interfaces. The functions below are used

 * to create a single struct dj_receiver_dev for all interfaces belonging to

 * a single USB-device / receiver.

	/*

	 * The bluetooth receiver contains a built-in hub and has separate

	 * USB-devices for the keyboard and mouse interfaces.

 Try to find an already-probed interface from the same device */

 Called in delayed work context */

 Called in delayed work context */

	/* Device index goes from 1 to 6, we need 3 bytes to store the

	 * semicolon, the index, and a null terminator

 We are the only one ever adding a device, no need to lock */

 The device is already known. No need to reallocate it. */

	/*

	 * Since we attach to multiple interfaces, we may get scheduled before

	 * we are bound to the HID++ interface, catch this.

/*

 * Sometimes we receive reports for which we do not have a paired dj_device

 * associated with the device_index or report-type to forward the report to.

 * This means that the original "device paired" notification corresponding

 * to the dj_device never arrived to this driver. Possible reasons for this are:

 * 1) hid-core discards all packets coming from a device during probe().

 * 2) if the receiver is plugged into a KVM switch then the pairing reports

 * are only forwarded to it if the focus is on this PC.

 * This function deals with this by re-asking the receiver for the list of

 * connected devices in the delayed work callback.

 * This function MUST be called with djrcv->lock held.

 Rate limit queries done because of unhandled reports to 2/sec */

 We are called from atomic context (tasklet && djrcv->lock held) */

/*

 * Some quad/bluetooth keyboards have a builtin touchpad in this case we see

 * only 1 paired device with a device_type of REPORT_TYPE_KEYBOARD. For the

 * touchpad to work we must also forward mouse input reports to the dj_hiddev

 * created for the keyboard (instead of forwarding them to a second paired

 * device with a device_type of REPORT_TYPE_MOUSE as we normally would).

 *

 * On Dinovo receivers the keyboard's touchpad and an optional paired actual

 * mouse send separate input reports, INPUT(2) aka STD_MOUSE for the mouse

 * and INPUT(5) aka KBD_MOUSE for the keyboard's touchpad.

 *

 * On MX5x00 receivers (which can also be paired with a Dinovo keyboard)

 * INPUT(2) is used for both an optional paired actual mouse and for the

 * keyboard's touchpad.

 Dinovo Edge */

 Dinovo Mini */

 Index 1 is always a mouse */

 Index 2 is always a mouse */

 Index 3 is always the keyboard */

gitlab.freedesktop.org/jwrdegoede/logitech-27mhz-keyboard-encryption-setup/\n");

 Index 4 is used for an optional separate numpad */

 We are called from atomic context (tasklet && djrcv->lock held) */

 Bluetooth connect packet contents is the same as (e)QUAD */

 custom receiver device (eg. powerplay) */

 We are called from atomic context (tasklet && djrcv->lock held) */

 We are called from atomic context (tasklet && djrcv->lock held) */

 We are called from atomic context (tasklet && djrcv->lock held) */

		/*

		 * Ugly sleep to work around a USB 3.0 bug when the receiver is

		 * still processing the "switch-to-dj" command while we send an

		 * other command.

		 * 50 msec should gives enough time to the receiver to be ready.

	/*

	 * Magical bits to set up hidpp notifications when the dj devices

	 * are connected/disconnected.

	 *

	 * We can reuse dj_report because HIDPP_REPORT_SHORT_LENGTH is smaller

	 * than DJREPORT_SHORT_LENGTH.

/*

 * Register 0xB5 is "pairing information". It is solely intended for the

 * receiver, so do not overwrite the device index.

		/* special case where we should not overwrite

 usbhid overrides the report ID and ignores the first byte */

	/*

	 * Here we receive all data coming from iface 2, there are 3 cases:

	 *

	 * 1) Data is intended for this driver i. e. data contains arrival,

	 * departure, etc notifications, in which case we queue them for delayed

	 * processing by the work queue. We return 1 to hid-core as no further

	 * processing is required from it.

	 *

	 * 2) Data informs a connection change, if the change means rf link

	 * loss, then we must send a null report to the upper layer to discard

	 * potentially pressed keys that may be repeated forever by the input

	 * layer. Return 1 to hid-core as no further processing is required.

	 *

	 * 3) Data is an actual input event from a paired DJ device in which

	 * case we forward it to the correct hid device (via hid_input_report()

	 * ) and return 1 so hid-core does not anything else with it.

		/*

		 * Device index is wrong, bail out.

		 * This driver can ignore safely the receiver notifications,

		 * so ignore those reports too.

 received an event for an unknown device, bail out */

 pairing notifications are handled above the switch */

		/* special case were the device wants to know its unifying

	/*

	 * Data is from the HID++ collection, in this case, we forward the

	 * data to the corresponding child dj device and return 0 to hid-core

	 * so he data also goes to the hidraw device of the receiver. This

	 * allows a user space application to implement the full HID++ routing

	 * via the receiver.

		/*

		 * Device index is wrong, bail out.

		 * This driver can ignore safely the receiver notifications,

		 * so ignore those reports too.

	/*

	 * With 27 MHz receivers, we do not get an explicit unpair event,

	 * remove the old device if the user has paired a *different* device.

 logi_hidpp_recv_queue_notif will queue the work */

			/*

			 * For the keyboard, we can reuse the same report by

			 * using the second byte which is constant in the USB

			 * HID report descriptor.

 restore previous state */

		/*

		 * Mouse-only receivers send unnumbered mouse data. The 27 MHz

		 * receiver uses 6 byte packets, the nano receiver 8 bytes.

 Prepend report id */

	/*

	 * Call to usbhid to fetch the HID descriptors of the current

	 * interface subsequently call to the hid/hid-core to parse the

	 * fetched descriptors.

	/*

	 * Some KVMs add an extra interface for e.g. mouse emulation. If we

	 * treat these as logitech-dj interfaces then this causes input events

	 * reported through this extra interface to not be reported correctly.

	 * To avoid this, we treat these as generic-hid devices.

 no input reports, bail out */

	/*

	 * Check for the HID++ application.

	 * Note: we should theoretically check for HID++ and DJ

	 * collections, but this will do.

	/*

	 * Ignore interfaces without DJ/HID++ collection, they will not carry

	 * any data, dont create any hid_device for them.

 get the current application attached to the node */

	/* Starts the usb device and connects to upper interfaces hiddev and

 This is enabling the polling urb on the IN endpoint */

 Allow incoming packets to arrive: */

			/*

			 * This can happen with a KVM, let the probe succeed,

			 * logi_dj_recv_queue_unknown_work will retry later.

	/*

	 * This ensures that if the work gets requeued from another

	 * interface of the same receiver it will be a no-op.

	/*

	 * For proper operation we need access to all interfaces, so we destroy

	 * the paired devices when we're unbound from any interface.

	 *

	 * Note we may still be bound to other interfaces, sharing the same

	 * djrcv_dev, so we need locking here.

 Logitech unifying receiver (0xc52b) */

 Logitech unifying receiver (0xc532) */

 Logitech Nano mouse only receiver (0xc52f) */

 Logitech Nano (non DJ) receiver (0xc534) */

 Logitech G700(s) receiver (0xc531) */

 Logitech G602 receiver (0xc537) */

 Logitech lightspeed receiver (0xc539) */

 Logitech powerplay receiver (0xc53a) */

 Logitech lightspeed receiver (0xc53f) */

 Logitech 27 MHz HID++ 1.0 receiver (0xc513) */

 Logitech 27 MHz HID++ 1.0 receiver (0xc517) */

 Logitech 27 MHz HID++ 1.0 mouse-only receiver (0xc51b) */

 Logitech MX5000 HID++ / bluetooth receiver keyboard intf. (0xc70e) */

 Logitech MX5000 HID++ / bluetooth receiver mouse intf. (0xc70a) */

 Logitech MX5500 HID++ / bluetooth receiver keyboard intf. (0xc71b) */

 Logitech MX5500 HID++ / bluetooth receiver mouse intf. (0xc71c) */

 Logitech Dinovo Edge HID++ / bluetooth receiver keyboard intf. (0xc713) */

 Logitech Dinovo Edge HID++ / bluetooth receiver mouse intf. (0xc714) */

 Logitech DiNovo Mini HID++ / bluetooth receiver mouse intf. (0xc71e) */

 Logitech DiNovo Mini HID++ / bluetooth receiver keyboard intf. (0xc71f) */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  HID driver for Asus notebook built-in keyboard.

 *  Fixes small logical maximum to match usage maximum.

 *

 *  Currently supported devices are:

 *    EeeBook X205TA

 *    VivoBook E200HA

 *

 *  Copyright (c) 2016 Yusuke Fujimaki <usk.fujimaki@gmail.com>

 *

 *  This module based on hid-ortek by

 *  Copyright (c) 2010 Johnathon Harris <jmharris@gmail.com>

 *  Copyright (c) 2011 Jiri Kosina

 *

 *  This module has been updated to add support for Asus i2c touchpad.

 *

 *  Copyright (c) 2016 Brendan McGrath <redmcg@redmandi.dyndns.org>

 *  Copyright (c) 2016 Victor Vlasenko <victor.vlasenko@sysgears.com>

 *  Copyright (c) 2016 Frederik Wenigwieser <frederik.wenigwieser@gmail.com>

/*

 For to_usb_interface for T100 touchpad intf check */

 2 byte header + 5 * 5 + 1 byte footer */,

 units/mm */

 units/mm */

 2 byte header + 5 * 5 + 1 byte footer */,

 units/mm */

 units/mm */

 2 byte header + 5 * 5 + 1 byte footer */,

 units/mm */

 units/mm */

 2 byte header + 5 * 5 + 1 byte footer */,

 units/mm */

 units/mm */

 2 byte header + 3 * 4 + 1 byte footer */,

 units/mm */

 units/mm */

 2 byte header + 5 * 5 + 5 byte footer */,

 Required for Synaptics Palm Detection */

 Handle broken mute key which only sends press events */

 Handle custom touchpad toggle key which only sends press events */

		/*

		 * Skip these report ID, the device emits a continuous stream associated

		 * with the AURA mode it is in which looks like an 'echo'.

 Additional report filtering */

			/*

			 * G14 and G15 send these codes on some keypresses with no

			 * discernable reason for doing so. We'll filter them out to avoid

			 * unmapped warning messages later.

			/*

			 * G713 and G733 send these codes on some keypresses, depending on

			 * the key pressed it can trigger a shutdown event if not caught.

		/*

		 * CLAYMORE II keyboard sends this packet when it goes to sleep

		 * this causes the whole system to go into suspend.

	/*

	 * The report ID should be set from the incoming buffer due to LED and key

	 * interfaces having different pages

 The first message is an init start */

 Followed by a string */

 Followed by a string */

 begin second report ID with same data */

/* WMI-based keyboard backlight LED control (via asus-wmi driver) takes

 * precedence. We only activate HID-based backlight control when the

 * WMI control is not available.

 Initialize keyboard */

 Get keyboard functions */

 Check for backlight support */

 No need to have this still around */

/*

 * [0]       REPORT_ID (same value defined in report descriptor)

 * [1]	     rest battery level. range [0..255]

 * [2]..[7]  Bluetooth hardware address (MAC address)

 * [8]       charging status

 *            = 0 : AC offline / discharging

 *            = 1 : AC online  / charging

 *            = 2 : AC online  / fully charged

 notify only the autonomous event by device */

 60[sec] */

 T100CHI uses MULTI_INPUT, bind the touchpad to the mouse hid_input */

 Handle MULTI_INPUT on E1239T mouse/touchpad USB interface */

 Touchpad report, handled below */

 Ignore other reports */

		/* Don't map anything from the HID report.

		 * We do it all manually in asus_input_configured

	/*

	 * Ignore a bunch of bogus collections in the T100CHI descriptor.

	 * This avoids a bunch of non-functional hid_input devices getting

	 * created because of the T100CHI using HID_QUIRK_MULTI_INPUT.

 ASUS-specific keyboard hotkeys and led backlight */

 ASUS touchpad toggle */

 ROG key */

 Fn+C ASUS Splendid */

 Fn+Space Power4Gear Hybrid */

 Fn+F5 "fan" symbol on FX503VD */

 Fn+F5 "fan" symbol on N-Key keyboard */

 Fn+Ret "Calc" symbol on N-Key keyboard */

 Fn+Left Aura mode previous on N-Key keyboard */

 Fn+Right Aura mode next on N-Key keyboard */

			/* ASUS lazily declares 256 usages, ignore the rest,

		/*

		 * Check and enable backlight only on devices with UsagePage ==

		 * 0xff31 to avoid initializing the keyboard firmware multiple

		 * times on devices with multiple HID descriptors but same

		 * PID/VID.

 Mute */

 Volume up */

 Volume down */

			/* Ignore dummy Consumer usages which make the

			 * keyboard incorrectly appear as a pointer device.

	/*

	 * The mute button is broken and only sends press events, we

	 * deal with this in our raw_event handler, so do not map it.

	/*

	 * T90CHI's keyboard dock returns same ID values as T100CHI's dock.

	 * Thus, identify T90CHI dock with product name string.

			/*

			 * The T100HA uses the same USB-ids as the T100TAF and

			 * the T200TA uses the same USB-ids as the T100TA, while

			 * both have different max x/y values as the T100TA[F].

		/*

		 * All functionality is on a single HID interface and for

		 * userspace the touchpad must be a separate input_dev.

 For separate input-devs for tp and tp toggle key */

   Usage Minimum (0x00)       */

   Usage Maximum (0xFF)       */

 For the T100TA/T200TA keyboard dock */

 For the T100CHI/T90CHI keyboard dock */

		/*

		 * Change Usage (76h) to Usage Minimum (00h), Usage Maximum

		 * (FFh) and clear the flags in the Input() byte.

		 * Note the descriptor has a bogus 0 byte at the end so we

		 * only need 1 extra byte.

 report is missing usage mninum and maximum */

 copy the valid part */

 insert missing part */

 copy remaining data */

	/*

	 * Note bind to the HID_GROUP_GENERIC group, so that we only bind to the keyboard

	 * part, while letting hid-multitouch.c handle the touchpad.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Jabra USB HID Driver

 *

 *  Copyright (c) 2017 Niels Skou Olsen <nolsen@jabra.com>

/*

 Ignore vendor defined usages, default map standard usages */

 SPDX-License-Identifier: GPL-2.0

/*

 * HID driver for the Creative SB0540 receiver

 *

 * Copyright (C) 2019 Red Hat Inc. All Rights Reserved

 *

 text: 24bit */

 24bit wheel up */

 24bit wheel down */

 text: CMSS */

 CMSS wheel Up */

 CMSS wheel Down */

 text: EAX */

 EAX wheel up */

 EAX wheel down */

 text: 3D Midi */

 3D Midi wheel up */

 3D Midi wheel down */

 text: Return, symbol: Jump to */

 text: Start */

 text: Cancel */

 text: Display */

/*

 * Codes and keys from lirc's

 * remotes/creative/lircd.conf.alsa_usb

 * order and size must match creative_sb0540_key_table[] above

 From daemons/hw_hiddev.c sb0540_rec() in lirc */

	/*

	 * Flip to get values in the same format as

	 * remotes/creative/lircd.conf.alsa_usb in lirc

 let hidraw and hiddev handle the report */

	/*

	 * We are remapping the keys ourselves, so ignore the hid-input

	 * keymap processing.

 force input as some remotes bypass the input registration */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Force feedback support for PantherLord/GreenAsia based devices

 *

 *  The devices are distributed under various names and the same USB device ID

 *  can be used in both adapters and actual game controllers.

 *

 *  0810:0001 "Twin USB Joystick"

 *   - tested with PantherLord USB/PS2 2in1 Adapter

 *   - contains two reports, one for each port (HID_QUIRK_MULTI_INPUT)

 *

 *  0e8f:0003 "GreenAsia Inc.    USB Joystick     "

 *   - tested with König Gaming gamepad

 *

 *  0e8f:0003 "GASIA USB Gamepad"

 *   - another version of the König gamepad

 *

 *  0f30:0111 "Saitek Color Rumble Pad"

 *

 *  Copyright (c) 2007, 2009 Anssi Hannula <anssi.hannula@gmail.com>

/*

 #define DEBUG */

	/* The device contains one output report per physical device, all

	   containing 1 field, which contains 4 ff00.0002 usages and 4 16bit

	   absolute values.



	   The input reports also contain a field which contains

	   8 ff00.0001 usages and 8 boolean values. Their meaning is

	   currently unknown.

	   

	   A version of the 0e8f:0003 exists that has all the values in

	   separate fields and misses the extra input field, thus resembling

	   Zeroplus (hid-zpff) devices.

 Twin USB Joystick */

 Twin USB Joystick */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Roccat Ryos driver for Linux

 *

 * Copyright (c) 2013 Stefan Achatz <erazor_de@users.sourceforge.net>

/*

 RYOS_REPORT_NUMBER_SPECIAL */

/*

 *  HID driver for Redragon keyboards

 *

 *  Copyright (c) 2017 Robert Munteanu

 *  SPDX-License-Identifier: GPL-2.0+

/*

 * This program is free software; you can redistribute it and/or modify it

 * under the terms of the GNU General Public License as published by the Free

 * Software Foundation; either version 2 of the License, or (at your option)

 * any later version.

/*

 * The Redragon Asura keyboard sends an incorrect HID descriptor.

 * At byte 100 it contains

 *

 *   0x81, 0x00

 *

 * which is Input (Data, Arr, Abs), but it should be

 *

 *   0x81, 0x02

 *

 * which is Input (Data, Var, Abs), which is consistent with the way

 * key codes are generated.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Roccat Kone driver for Linux

 *

 * Copyright (c) 2010 Stefan Achatz <erazor_de@users.sourceforge.net>

/*

/*

 * Roccat Kone is a gamer mouse which consists of a mouse part and a keyboard

 * part. The keyboard part enables the mouse to execute stored macros with mixed

 * key- and button-events.

 *

 * TODO implement on-the-fly polling-rate change

 *      The windows driver has the ability to change the polling rate of the

 *      device on the press of a mousebutton.

 *      Is it possible to remove and reinstall the urb in raw-event- or any

 *      other handler, or to defer this action to be executed somewhere else?

 *

 * TODO is it possible to overwrite group for sysfs attributes via udev?

 kone_class is used for creating sysfs attributes via roccat char device */

/*

 * Checks success after writing data to mouse

 * On success returns 0

 * On failure returns errno

		/*

		 * Mouse needs 50 msecs until it says ok, but there are

		 * 30 more msecs needed for next write to work.

		/*

		 * value of 3 seems to mean something like

		 * "not finished yet, but it looks good"

		 * So check again after a moment.

 everything alright */

 unknown answer */

/*

 * Reads settings from mouse and stores it in @buf

 * On success returns 0

 * On failure returns errno

/*

 * Writes settings from @buf to mouse

 * On success returns 0

 * On failure returns errno

/*

 * Reads profile data from mouse and stores it in @buf

 * @number: profile number to read

 * On success returns 0

 * On failure returns errno

/*

 * Writes profile data to mouse.

 * @number: profile number to write

 * On success returns 0

 * On failure returns errno

/*

 * Reads value of "fast-clip-weight" and stores it in @result

 * On success returns 0

 * On failure returns errno

/*

 * Reads firmware_version of mouse and stores it in @result

 * On success returns 0

 * On failure returns errno

/*

 * Writing settings automatically activates startup_profile.

 * This function keeps values in kone_device up to date and assumes that in

 * case of error the old data is still valid

 I need to get my data in one piece */

 Writes data only if different to stored data */

 I need to get my data in one piece */

 weight is read each time, since we don't get informed when it's changed */

/*

 * Calibrating the tcu is the only action that changes settings data inside the

 * mouse, so this data needs to be reread

 state activate */

 tcu needs this time for calibration */

		/*

		 * Kone needs this time to settle things.

		 * Reading settings too early will result in invalid data.

		 * Roccat's driver waits 1 sec, maybe this time could be

		 * shortened.

 calibration changes values in settings, so reread */

 only write settings back if activation state is different */

			/*

			 * try to reread valid settings into buffer overwriting

			 * first error code

 calibration resets profile */

 changing the startup profile immediately activates this profile */

	/*

	 * Read actual dpi settings.

	 * Returns raw value for further processing. Refer to enum

	 * kone_polling_rates to get real value.

	/*

	 * The mouse can be equipped with one of four supplied weights from 5

	 * to 20 grams which are recognized and its value can be read out.

	 * This returns the raw value reported by the mouse for easy evaluation

	 * by software. Refer to enum kone_weights to get corresponding real

	 * weight.

	/*

	 * Prints firmware version stored in mouse as integer.

	 * The raw value reported by the mouse is returned for easy evaluation,

	 * to get the real version number the decimal point has to be shifted 2

	 * positions to the left. E.g. a value of 138 means 1.38.

	/*

	 * Prints state of Tracking Control Unit as number where 0 = off and

	 * 1 = on. Writing 0 deactivates tcu and writing 1 calibrates and

	 * activates the tcu

 Prints and takes the number of the profile the mouse starts with */

/*

 * Since IGNORE_MOUSE quirk moved to hid-apple, there is no way to bind only to

 * mousepart if usb_hid is compiled into the kernel and kone is compiled as

 * module.

 * Secial behaviour is bound only to mousepart since only mouseevents contain

 * additional notifications.

 be tolerant about not getting chrdev */

 handle special events and keep actual profile and dpi values up to date */

/*

 * Is called for keyboard- and mousepart.

 * Only mousepart gets informations about special events in its extended event

 * structure.

 keyboard events are always processed by default handler */

	/*

	 * Firmware 1.38 introduced new behaviour for tilt and special buttons.

	 * Pressed button is reported in each movement event.

	 * Workaround sends only one event per press.

 always do further processing */

 class name has to be same as driver name */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Force feedback support for SmartJoy PLUS PS2->USB adapter

 *

 *  Copyright (c) 2009 Jussi Kivilinna <jussi.kivilinna@mbnet.fi>

 *

 *  Based of hid-pl.c and hid-gaff.c

 *   Copyright (c) 2007, 2009 Anssi Hannula <anssi.hannula@gmail.com>

 *   Copyright (c) 2008 Lukasz Lubojanski <lukasz@lubojanski.info>

/*

 #define DEBUG */

 on/off only */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  HID driver for some cypress "special" devices

 *

 *  Copyright (c) 1999 Andreas Gal

 *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>

 *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc

 *  Copyright (c) 2006-2007 Jiri Kosina

 *  Copyright (c) 2008 Jiri Slaby

/*

/*

 * Some USB barcode readers from cypress have usage min and usage max in

 * the wrong order

	/*

	 * Varmilo VA104M (with VID Cypress and device ID 07B1) incorrectly

	 * reports Logical Minimum of its Consumer Control device as 572

	 * (0x02 0x3c). Fix this by setting its Logical Minimum to zero.

 SPDX-License-Identifier: GPL-2.0-only

/***************************************************************************

 *   Copyright (C) 2010-2012 by Bruno Prémont <bonbons@linux-vserver.org>  *

 *                                                                         *

 *   Based on Logitech G13 driver (v0.4)                                   *

 *     Copyright (C) 2009 by Rick L. Vinyard, Jr. <rvinyard@cs.nmsu.edu>   *

 *                                                                         *

/* Input device

 *

 * The PicoLCD has an IR receiver header, a built-in keypad with 5 keys

 * and header for 4x4 key matrix. The built-in keys are part of the matrix.

 none */

 col 4 + row 1 */

 col 3 + row 1 */

 col 2 + row 1 */

 col 1 + row 1 */

 col 4 + row 2 */

 col 3 + row 2 */

 col 2 + row 2 */

 col 1 + row 2 */

 col 4 + row 3 */

 col 3 + row 3 */

 col 2 + row 3 */

 col 1 + row 3 */

 col 4 + row 4 */

 col 3 + row 4 */

 col 2 + row 4 */

 col 1 + row 4 */

 Find a given report */

/* Submit a report and wait for a reply from device - if device fades away

/*

 * input class device

	/*

	 * Keypad event

	 * First and second data bytes list currently pressed keys,

	 * 0x00 means no key and at most 2 keys may be pressed at same time

 determine newly pressed keys */

 determine newly released keys */

/*

 * Reset our device and wait for answer to VERSION request

 perform the reset */

/*

 * The "operation_mode" sysfs attribute

/*

 * The "operation_mode_delay" sysfs attribute

/*

 * Handle raw report as sent by device

		/*

		 * We let the caller of picolcd_send_and_wait() check if the

		 * report we got is one of the expected ones or not.

 initialize keypad input device */

 Setup keypad input device */

 Setup CIR input device */

 Set up the framebuffer device */

 Setup lcd class device */

 Setup backlight class device */

 Setup the LED class devices */

	/*

	 * Let's allocate the picolcd data structure, set some reasonable

	 * defaults, and associate it with the device

 Parse the device reports and start it up */

 Shortcut potential pending reply that will never arrive */

 Cleanup LED */

 Clean up the framebuffer */

 Cleanup input */

 Finally, clean up the picolcd data itself */

 SPDX-License-Identifier: GPL-2.0+

/*

 *  HID driver for ViewSonic devices not fully compliant with HID standard

 *

 *  Copyright (c) 2017 Nikolai Kondrashov

/*

 * This program is free software; you can redistribute it and/or modify it

 * under the terms of the GNU General Public License as published by the Free

 * Software Foundation; either version 2 of the License, or (at your option)

 * any later version.

 Size of the original descriptor of PD1011 signature pad */

 Fixed report descriptor of PD1011 signature pad */

  Usage Page (Digitizer),             */

  Usage (Pen),                        */

  Collection (Application),           */

      Report ID (2),                  */

      Usage (Stylus),                 */

      Collection (Physical),          */

          Report Size (16),           */

          Report Count (1),           */

          Push,                       */

          Usage Page (Desktop),       */

          Unit (Inch),                */

          Unit Exponent (-3),         */

          Physical Minimum (0),       */

          Usage (X),                  */

          Physical Maximum (8541),    */

          Logical Maximum (43392),    */

          Input (Variable),           */

          Usage (Y),                  */

          Physical Maximum (5338),    */

          Logical Maximum (27120),    */

          Input (Variable),           */

          Pop,                        */

          Logical Minimum (0),        */

          Logical Maximum (1),        */

          Report Size (1),            */

          Report Count (1),           */

          Input (Constant, Variable), */

          Usage (In Range),           */

          Usage (Tip Switch),         */

          Report Count (2),           */

          Input (Variable),           */

          Report Count (5),           */

          Input (Constant, Variable), */

          Report Size (16),           */

          Report Count (1),           */

          Usage (Tip Pressure),       */

          Logical Minimum (5),        */

          Logical Maximum (2047),     */

          Input (Variable),           */

          Report Size (16),           */

          Report Count (1),           */

          Input (Constant, Variable), */

      End Collection,                 */

  End Collection                      */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Force feedback support for Mayflash game controller adapters.

 *

 * These devices are manufactured by Mayflash but identify themselves

 * using the vendor ID of DragonRise Inc.

 *

 * Tested with:

 * 0079:1801 "DragonRise Inc. Mayflash PS3 Game Controller Adapter"

 * 0079:1803 "DragonRise Inc. Mayflash Wireless Sensor DolphinBar"

 * 0079:1843 "DragonRise Inc. Mayflash GameCube Game Controller Adapter"

 * 0079:1844 "DragonRise Inc. Mayflash GameCube Game Controller Adapter (v04)"

 *

 * The following adapters probably work too, but need to be tested:

 * 0079:1800 "DragonRise Inc. Mayflash WIIU Game Controller Adapter"

 *

 * Copyright (c) 2016-2017 Marcel Hasler <mahasler@gmail.com>

/*

 Setup each of the four inputs */

 Apply quirks as needed */

 No quirk required */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Force feedback support for EMS Trio Linker Plus II

 *

 *  Copyright (c) 2010 Ignaz Forster <ignaz.forster@gmx.de>

/*

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Force feedback support for Holtek On Line Grip based gamepads

 *

 *  These include at least a Brazilian "Clone Joypad Super Power Fire"

 *  which uses vendor ID 0x1241 and identifies as "HOLTEK On Line Grip".

 *

 *  Copyright (c) 2011 Anssi Hannula <anssi.hannula@iki.fi>

/*

/*

 * These commands and parameters are currently known:

 *

 * byte 0: command id:

 * 	01  set effect parameters

 * 	02  play specified effect

 * 	03  stop specified effect

 * 	04  stop all effects

 * 	06  stop all effects

 * 	(the difference between 04 and 06 isn't known; win driver

 * 	 sends 06,04 on application init, and 06 otherwise)

 * 

 * Commands 01 and 02 need to be sent as pairs, i.e. you need to send 01

 * before each 02.

 *

 * The rest of the bytes are parameters. Command 01 takes all of them, and

 * commands 02,03 take only the effect id.

 *

 * byte 1:

 *	bits 0-3: effect id:

 * 		1: very strong rumble

 * 		2: periodic rumble, short intervals

 * 		3: very strong rumble

 * 		4: periodic rumble, long intervals

 * 		5: weak periodic rumble, long intervals

 * 		6: weak periodic rumble, short intervals

 * 		7: periodic rumble, short intervals

 * 		8: strong periodic rumble, short intervals

 * 		9: very strong rumble

 * 		a: causes an error

 * 		b: very strong periodic rumble, very short intervals

 * 		c-f: nothing

 *	bit 6: right (weak) motor enabled

 *	bit 7: left (strong) motor enabled

 *

 * bytes 2-3:  time in milliseconds, big-endian

 * bytes 5-6:  unknown (win driver seems to use at least 10e0 with effect 1

 * 		       and 0014 with effect 6)

 * byte 7:

 *	bits 0-3: effect magnitude

 effect type 1, length 65535 msec */

 The device takes a single magnitude, so we just sum them up. */

 initialize the same way as win driver does */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  HID driver for some logitech "special" devices

 *

 *  Copyright (c) 1999 Andreas Gal

 *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>

 *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc

 *  Copyright (c) 2006-2007 Jiri Kosina

 *  Copyright (c) 2008 Jiri Slaby

 *  Copyright (c) 2010 Hendrik Iben

/*

 Size of the original descriptors of the Driving Force (and Pro) wheels */

/* Fixed report descriptors for Logitech Driving Force (and Pro)

 * wheel controllers

 *

 * The original descriptors hide the separate throttle and brake axes in

 * a custom vendor usage page, providing only a combined value as

 * GenericDesktop.Y.

 * These descriptors remove the combined Y axis and instead report

 * separate throttle (Y) and brake (RZ).

  Usage Page (Desktop),                   */

  Usage (Joystick),                       */

  Collection (Application),               */

      Collection (Logical),               */

          Report Count (1),               */

          Report Size (10),               */

          Logical Minimum (0),            */

          Logical Maximum (1023),         */

          Physical Minimum (0),           */

          Physical Maximum (1023),        */

          Usage (X),                      */

          Input (Variable),               */

          Report Count (12),              */

          Report Size (1),                */

          Logical Maximum (1),            */

          Physical Maximum (1),           */

          Usage (Buttons),                */

          Usage Minimum (1),              */

          Usage Maximum (12),             */

          Input (Variable),               */

          Report Count (2),               */

          Usage Page (Vendor: 65280),     */

          Usage (?: 1),                   */

          Input (Variable),               */

          Usage Page (Desktop),           */

          Logical Maximum (255),          */

          Physical Maximum (255),         */

          Report Count (1),               */

          Report Size (8),                */

          Input (Variable),               */

          Logical Maximum (7),            */

          Physical Maximum (315),         */

          Report Size (4),                */

          Unit (Degrees),                 */

          Usage (Hat Switch),             */

          Input (Variable, Null State),   */

          Report Size (1),                */

          Report Count (4),               */

          Unit (none),                    */

          Usage Page (Vendor: 65280),     */

          Usage (?: 1),                   */

          Logical Maximum (1),            */

          Physical Maximum (1),           */

          Input (Variable),               */

          Usage Page (Desktop),           */

          Report Count (1),               */

          Report Size (8),                */

          Logical Maximum (255),          */

          Physical Maximum (255),         */

          Usage (Y),                      */

          Input (Variable),               */

          Usage (Rz),                     */

          Input (Variable),               */

      End Collection,                     */

      Collection (Logical),               */

          Logical Maximum (255),          */

          Physical Maximum (255),         */

          Report Count (7),               */

          Report Size (8),                */

          Usage (?: 3),                   */

          Output (Variable),              */

      End Collection,                     */

  End Collection                          */

  Usage Page (Desktop),                   */

  Usage (Joystick),                       */

  Collection (Application),               */

      Collection (Logical),               */

          Report Count (1),               */

          Report Size (14),               */

          Logical Minimum (0),            */

          Logical Maximum (16383),        */

          Physical Minimum (0),           */

          Physical Maximum (16383),       */

          Usage (X),                      */

          Input (Variable),               */

          Report Count (14),              */

          Report Size (1),                */

          Logical Maximum (1),            */

          Physical Maximum (1),           */

          Usage Page (Button),            */

          Usage Minimum (01h),            */

          Usage Maximum (0Eh),            */

          Input (Variable),               */

          Usage Page (Desktop),           */

          Report Count (1),               */

          Report Size (4),                */

          Logical Maximum (7),            */

          Physical Maximum (315),         */

          Unit (Degrees),                 */

          Usage (Hat Switch),             */

          Input (Variable, Nullstate),    */

          Unit,                           */

          Logical Maximum (255),          */

          Physical Maximum (255),         */

          Report Size (8),                */

          Input (Constant),               */

          Usage (Y),                      */

          Input (Variable),               */

          Usage (Rz),                     */

          Input (Variable),               */

          Input (Constant),               */

      End Collection,                     */

      Collection (Logical),               */

          Usage (02h),                    */

          Report Count (7),               */

          Output (Variable),              */

      End Collection,                     */

  End Collection                          */

  Usage Page (Desktop),                   */

  Usage (Joystick),                       */

  Collection (Application),               */

      Collection (Logical),               */

          Report Count (1),               */

          Report Size (10),               */

          Logical Minimum (0),            */

          Logical Maximum (1023),         */

          Physical Minimum (0),           */

          Physical Maximum (1023),        */

          Usage (X),                      */

          Input (Variable),               */

          Report Count (12),              */

          Report Size (1),                */

          Logical Maximum (1),            */

          Physical Maximum (1),           */

          Usage Page (Button),            */

          Usage Minimum (01h),            */

          Usage Maximum (0Ch),            */

          Input (Variable),               */

          Report Count (2),               */

          Usage Page (FF00h),             */

          Usage (01h),                    */

          Input (Variable),               */

          Usage (02h),                    */

          Logical Maximum (255),          */

          Physical Maximum (255),         */

          Report Count (1),               */

          Report Size (8),                */

          Input (Variable),               */

          Usage Page (Desktop),           */

          Logical Maximum (7),            */

          Physical Maximum (315),         */

          Report Size (4),                */

          Unit (Degrees),                 */

          Usage (Hat Switch),             */

          Input (Variable, Null State),   */

          Report Size (1),                */

          Report Count (4),               */

          Unit,                           */

          Usage Page (FF00h),             */

          Usage (01h),                    */

          Logical Maximum (1),            */

          Physical Maximum (1),           */

          Input (Variable),               */

          Usage Page (Desktop),           */

          Report Count (1),               */

          Report Size (8),                */

          Logical Maximum (255),          */

          Physical Maximum (255),         */

          Usage (Y),                      */

          Input (Variable),               */

          Usage (Z),                      */

          Input (Variable),               */

      End Collection,                     */

      Collection (Logical),               */

          Logical Maximum (255),          */

          Physical Maximum (255),         */

          Report Count (7),               */

          Report Size (8),                */

          Usage (03h),                    */

          Output (Variable),              */

      End Collection,                     */

  End Collection                          */

  Usage Page (Desktop),               */

  Usage (Joystick),                   */

  Collection (Application),           */

      Collection (Logical),           */

          Report Count (1),           */

          Report Size (10),           */

          Logical Minimum (0),        */

          Logical Maximum (1023),     */

          Physical Minimum (0),       */

          Physical Maximum (1023),    */

          Usage (X),                  */

          Input (Variable),           */

          Report Count (8),           */

          Report Size (1),            */

          Logical Maximum (1),        */

          Physical Maximum (1),       */

          Usage Page (Button),        */

          Usage Minimum (01h),        */

          Usage Maximum (08h),        */

          Input (Variable),           */

          Usage Page (FF00h),         */

          Report Size (14),           */

          Report Count (1),           */

          Logical Maximum (255),      */

          Physical Maximum (255),     */

          Usage (00h),                */

          Input (Variable),           */

          Usage Page (Desktop),       */

          Report Size (8),            */

          Usage (Y),                  */

          Input (Variable),           */

          Usage (Z),                  */

          Input (Variable),           */

          Usage Page (FF00h),         */

          Usage (01h),                */

          Input (Variable),           */

      End Collection,                 */

      Collection (Logical),           */

          Usage (02h),                */

          Report Count (7),           */

          Output (Variable),          */

      End Collection,                 */

  End Collection                      */

  Usage Page (Desktop),               */

  Usage (Joystick),                   */

  Collection (Application),           */

      Collection (Logical),           */

          Report Count (1),           */

          Report Size (10),           */

          Logical Minimum (0),        */

          Logical Maximum (1023),     */

          Physical Minimum (0),       */

          Physical Maximum (1023),    */

          Usage (X),                  */

          Input (Variable),           */

          Report Count (10),          */

          Report Size (1),            */

          Logical Maximum (1),        */

          Physical Maximum (1),       */

          Usage Page (Button),        */

          Usage Minimum (01h),        */

          Usage Maximum (0Ah),        */

          Input (Variable),           */

          Usage Page (FF00h),         */

          Usage (00h),                */

          Report Count (4),           */

          Input (Variable),           */

          Report Count (1),           */

          Report Size (8),            */

          Logical Maximum (255),      */

          Physical Maximum (255),     */

          Usage (01h),                */

          Input (Variable),           */

          Usage Page (Desktop),       */

          Usage (Y),                  */

          Input (Variable),           */

          Usage (Z),                  */

          Input (Variable),           */

          Usage Page (FF00h),         */

          Usage (00h),                */

          Input (Variable),           */

      End Collection,                 */

      Collection (Logical),           */

          Usage (02h),                */

          Report Count (7),           */

          Output (Variable),          */

      End Collection,                 */

  End Collection                      */

  Usage Page (Desktop),               */

  Usage (Joystik),                    */

  Collection (Application),           */

      Collection (Logical),           */

          Report Count (1),           */

          Report Size (10),           */

          Logical Minimum (0),        */

          Logical Maximum (1023),     */

          Physical Minimum (0),       */

          Physical Maximum (1023),    */

          Usage (X),                  */

          Input (Variable),           */

          Report Count (6),           */

          Report Size (1),            */

          Logical Maximum (1),        */

          Physical Maximum (1),       */

          Usage Page (Button),        */

          Usage Minimum (01h),        */

          Usage Maximum (06h),        */

          Input (Variable),           */

          Report Count (1),           */

          Report Size (8),            */

          Logical Maximum (255),      */

          Physical Maximum (255),     */

          Usage Page (FF00h),         */

          Usage (01h),                */

          Input (Variable),           */

          Usage Page (Desktop),       */

          Input (Constant),           */

          Usage (Y),                  */

          Input (Variable),           */

          Usage (Z),                  */

          Input (Variable),           */

          Usage Page (FF00h),         */

          Usage (01h),                */

          Input (Variable),           */

      End Collection,                 */

      Collection (Logical),           */

          Usage (02h),                */

          Report Count (7),           */

          Output (Variable),          */

      End Collection,                 */

  End Collection                      */

  Usage Page (Desktop),               */

  Usage (Joystik),                    */

  Collection (Application),           */

      Collection (Logical),           */

          Logical Minimum (0),        */

          Logical Maximum (255),      */

          Physical Minimum (0),       */

          Physical Maximum (255),     */

          Report Size (8),            */

          Report Count (1),           */

          Usage (X),                  */

          Input (Variable),           */

  Push,                               */

          Logical Maximum (1),        */

          Physical Maximum (1),       */

          Report Size (1),            */

          Report Count (2),           */

          Input (Constant),           */

          Report Count (6),           */

          Usage Page (Button),        */

          Usage Minimum (01h),        */

          Usage Maximum (06h),        */

          Input (Variable),           */

          Usage Page (Desktop),       */

  Pop,                                */

          Input (Constant),           */

          Usage (Y),                  */

          Input (Variable),           */

          Usage (Z),                  */

          Input (Variable),           */

      End Collection,                 */

      Collection (Logical),           */

          Logical Maximum (255),      */

          Physical Maximum (255),     */

          Report Size (8),            */

          Report Count (4),           */

          Usage (02h),                */

          Feature (Variable),         */

      End Collection,                 */

  End Collection,                     */

/*

 * Certain Logitech keyboards send in report #3 keys which are far

 * above the logical maximum described in descriptor. This extends

 * the original value of 0x28c of logical maximum to 0x104d

 Several wheels report as this id when operating in emulation mode. */

 Reported on Logitech Ultra X Media Remote */

 The following two entries are Playlist 1 and 2 on the MX3200 */

 this one is marked as 'Rotate' */

	/* The following two are 'Start/answer call' and 'End/reject call'

	/* extended mapping for certain Logitech hardware (Logitech cordless

 Special handling for Logitech Cordless Desktop */

 Ensure that Logitech wheels are not given a default fuzz/flat value */

 G29 only work with the 1st interface */

 Setup wireless link with Logitech Wii wheel */

 insert a little delay of 10 jiffies ~ 40ms */

 Select random Address */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  HID driver for some cherry "special" devices

 *

 *  Copyright (c) 1999 Andreas Gal

 *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>

 *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc

 *  Copyright (c) 2006-2007 Jiri Kosina

 *  Copyright (c) 2008 Jiri Slaby

/*

/*

 * Cherry Cymotion keyboard have an invalid HID report descriptor,

 * that needs fixing before we can parse it.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Force feedback support for Logitech Flight System G940

 *

 *  Copyright (c) 2009 Gary Stein <LordCnidarian@gmail.com>

/*

/*

 * G940 Theory of Operation (from experimentation)

 *

 * There are 63 fields (only 3 of them currently used)

 * 0 - seems to be command field

 * 1 - 30 deal with the x axis

 * 31 -60 deal with the y axis

 *

 * Field 1 is x axis constant force

 * Field 31 is y axis constant force

 *

 * other interesting fields 1,2,3,4 on x axis

 * (same for 31,32,33,34 on y axis)

 *

 * 0 0 127 127 makes the joystick autocenter hard

 *

 * 127 0 127 127 makes the joystick loose on the right,

 * but stops all movemnt left

 *

 * -127 0 -127 -127 makes the joystick loose on the left,

 * but stops all movement right

 *

 * 0 0 -127 -127 makes the joystick rattle very hard

 *

 * I'm sure these are effects that I don't know enough about them

/*

 * Available values in the field should always be 63, but we only use up to

 * 35. Instead, clear the entire area, however big it is.

/*

 * Already clamped in ff_memless

 * 0 is center (different then other logitech)

 send command byte */

/*

 * Sign backwards from other Force3d pro

 * which get recast here in two's complement 8 bits

/*

 * Auto Centering probed from device

 * NOTE: deadman's switch on G940 must be covered

 * for effects to work

 Check that the report looks ok */

 Assume single fixed device G940 */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  HID driver for Xin-Mo devices, currently only the Dual Arcade controller.

 *  Fixes the negative axis event values (the devices sends -2) to match the

 *  logical axis minimum of the HID report descriptor (the report announces

 *  -1). It is needed because hid-input discards out of bounds values.

 *  (This module is based on "hid-saitek" and "hid-lg".)

 *

 *  Copyright (c) 2013 Olivier Scherler

/*

/*

 * Fix negative events that are out of bounds.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  HID driver for Sony / PS2 / PS3 / PS4 BD devices.

 *

 *  Copyright (c) 1999 Andreas Gal

 *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>

 *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc

 *  Copyright (c) 2008 Jiri Slaby

 *  Copyright (c) 2012 David Dillow <dave@thedillows.org>

 *  Copyright (c) 2006-2013 Jiri Kosina

 *  Copyright (c) 2013 Colin Leitner <colin.leitner@gmail.com>

 *  Copyright (c) 2014-2016 Frank Praznik <frank.praznik@gmail.com>

 *  Copyright (c) 2018 Todd Kelner

 *  Copyright (c) 2020-2021 Pascal Giard <pascal.giard@etsmtl.ca>

 *  Copyright (c) 2020 Sanjay Govind <sanjay.govind9@gmail.com>

 *  Copyright (c) 2021 Daniel Nguyen <daniel.nguyen.1@ens.etsmtl.ca>

/*

/*

 * NOTE: in order for the Sony PS3 BD Remote Control to be found by

 * a Bluetooth host, the key combination Start+Enter has to be kept pressed

 * for about 7 seconds with the Bluetooth Host Controller in discovering mode.

 *

 * There will be no PIN request from the device.

/* The PS3/Wii U dongles require a poke every 10 seconds, but the PS4

 * requires one every 8 seconds. Using 8 seconds for all for simplicity.

 In seconds */

/* Magic data taken from GHLtarUtility:

 * https://github.com/ghlre/GHLtarUtility/blob/master/PS3Guitar.cs

 * Note: The Wii U and PS3 dongles happen to share the same!

/* Magic data for the PS4 dongles sniffed with a USB protocol

 * analyzer.

 PS/3 Motion controller */

  Usage Page (Desktop),               */

  Usage (Joystick),                   */

  Collection (Application),           */

      Collection (Logical),           */

          Report ID (1),              */

          Report Size (1),            */

          Report Count (21),          */

          Logical Minimum (0),        */

          Logical Maximum (1),        */

          Physical Minimum (0),       */

          Physical Maximum (1),       */

          Usage Page (Button),        */

          Usage Minimum (01h),        */

          Usage Maximum (15h),        */

          Input (Variable),           * Buttons */

          Report Count (11),          */

          Usage Page (FF00h),         */

          Input (Constant, Variable), * Padding */

          Logical Minimum (0),        */

          Logical Maximum (255),      */

          Usage Page (Desktop),       */

          Collection (Physical),      */

              Report Size (8),        */

              Report Count (1),       */

              Physical Minimum (0),   */

              Physical Maximum (255), */

              Usage (X),              */

              Input (Variable),       * Trigger */

          End Collection,             */

          Usage Page (FF00h),         */

          Report Size (8),            */

          Report Count (7),           * skip 7 bytes */

          Input (Variable),           */

          Usage Page (Desktop),       */

          Report Size (16),           */

          Physical Maximum (65535),   */

      Logical Maximum (65535),    */

          Report Count (3),           * 3x Accels */

              Usage (rX),             */

              Usage (rY),             */

              Usage (rZ),             */

          Input (Variable),           */

          Usage Page (FF00h),         */

          Report Count (3),           * Skip Accels 2nd frame */

          Input (Variable),           */

          Usage Page (Desktop),       */

          Usage (Pointer),            */

          Report Count (3),           * 3x Gyros */

          Input (Variable),           */

          Usage Page (FF00h),         */

          Report Count (3),           * Skip Gyros 2nd frame */

          Input (Variable),           */

          Report Size (12),           */

          Physical Maximum (4095),    */

          Logical Maximum (4095),     */

          Report Count (4),           * Skip Temp and Magnetometers */

          Input (Variable),           */

          Report Size (8),            */

          Physical Maximum (255),     */

          Logical Maximum (255),      */

          Report Count (6),           * Skip Timestamp and Extension Bytes */

          Input (Variable),           */

          Report Size (8),            */

          Report Count (48),          */

          Usage (Pointer),            */

          Output (Variable),          */

          Report Size (8),            */

          Report Count (48),          */

          Usage (Pointer),            */

          Feature (Variable),         */

      End Collection,                 */

      Collection (Logical),           */

          Report ID (2),              */

          Report Size (8),            */

          Report Count (48),          */

          Usage (Pointer),            */

          Feature (Variable),         */

      End Collection,                 */

      Collection (Logical),           */

          Report ID (238),            */

          Report Size (8),            */

          Report Count (48),          */

          Usage (Pointer),            */

          Feature (Variable),         */

      End Collection,                 */

      Collection (Logical),           */

          Report ID (239),            */

          Report Size (8),            */

          Report Count (48),          */

          Usage (Pointer),            */

          Feature (Variable),         */

      End Collection,                 */

  End Collection                      */

 GUsagePage Generic Desktop */

 LUsage 0x05 [Game Pad] */

 MCollection Application (mouse, keyboard) */

 Use collection 1 for joypad buttons */

 MCollection Logical (interrelated data) */

	  /*

	   * Ignore the 1st byte, maybe it is used for a controller

	   * number but it's not needed for correct operation

 GReportSize 0x08 [8] */

 GReportCount 0x01 [1] */

 MInput 0x01 (Const[0] Arr[1] Abs[2]) */

	  /*

	   * Bytes from 2nd to 4th are a bitmap for joypad buttons, for these

	   * buttons multiple keypresses are allowed

 GUsagePage Button */

 LUsageMinimum 0x01 [Button 1 (primary/trigger)] */

 LUsageMaximum 0x18 [Button 24] */

 GLogicalMinimum [0] */

 GLogicalMaximum 0x01 [1] */

 GReportSize 0x01 [1] */

 GReportCount 0x18 [24] */

 MInput 0x02 (Data[0] Var[1] Abs[2]) */

 MEndCollection */

 Use collection 2 for remote control buttons */

 MCollection Logical (interrelated data) */

 5th byte is used for remote control buttons */

 GUsagePage Button */

 LUsageMinimum [No button pressed] */

 LUsageMaximum 0xFE [Button 254] */

 GLogicalMinimum [0] */

 GLogicalMaximum 0x00FE [254] */

 GReportSize 0x08 [8] */

 GReportCount 0x01 [1] */

 MInput  */

	  /*

	   * Ignore bytes from 6th to 11th, 6th to 10th are always constant at

	   * 0xff and 11th is for press indication

 GReportSize 0x08 [8] */

 GReportCount 0x06 [6] */

 MInput 0x01 (Const[0] Arr[1] Abs[2]) */

 12th byte is for battery strength */

 GUsagePage Generic Device Controls */

 LUsage 0x20 [Battery Strength] */

 GLogicalMinimum [0] */

 GLogicalMaximum 0x05 [5] */

 GReportSize 0x08 [8] */

 GReportCount 0x01 [1] */

 MInput 0x02 (Data[0] Var[1] Abs[2]) */

 MEndCollection */

 MEndCollection [Game Pad] */

 L3 */

 R3 */

 L2 */

 R2 */

 L1 */

 R1 */

 options/triangle */

 back/circle */

 cross */

 view/square */

 PS button */

 return */

 top menu */

 scan back */

 scan forward */

 pop up/menu */

 slow/step back */

 slow/step forward */

 display */

	/*

	 * The controller has 4 remote buzzers, each with one LED and 5

	 * buttons.

	 *

	 * We use the mapping chosen by the controller, which is:

	 *

	 * Key          Offset

	 * -------------------

	 * Buzz              1

	 * Blue              5

	 * Orange            4

	 * Green             3

	 * Yellow            2

	 *

	 * So, for example, the orange button on the third buzzer is mapped to

	 * BTN_TRIGGER_HAPPY14

/* The Navigation controller is a partial DS3 and uses the same HID report

 * and hence the same keymap indices, however not not all axes/buttons

 * are physically present. We use the same axis and button mapping as

 * the DS3, which uses the Linux gamepad spec.

 L2 */

/* Buttons not physically available on the device, but still available

 * in the reports are explicitly set to 0 for documentation purposes.

 Select */

 L3 */

 R3 */

 Start */

 Up */

 Right */

 Down */

 Left */

 L2 */

 R2 */

 L1 */

 R1 */

 Triangle */

 Circle */

 Cross */

 Square */

 PS */

 right stick X */

 right stick Y */

 Select */

 L3 */

 R3 */

 Start */

 Up */

 Right */

 Down */

 Left */

 L2 */

 R2 */

 L1 */

 R1 */

 Triangle */

 Circle */

 Cross */

 Square */

 PS */

 right stick X */

 L2 */

 R2 */

 right stick Y */

 Square */

 Cross */

 Circle */

 Triangle */

 L1 */

 R1 */

 L2 */

 R2 */

 Share */

 Options */

 L3 */

 R3 */

 PS */

 the total time the led is active (0xff means forever) */

 how long a cycle is in deciseconds (0 means "really fast") */

 % of duty_length the led is off (0xff means 100%) */

 % of duty_length the led is on (0xff mean 100%) */

 Right motor duration (0xff means forever) */

 Right (small) motor on/off, only supports values of 0 or 1 (off/on) */

 Left motor duration (0xff means forever) */

 left (large) motor, supports force values from 0 to 255 */

 bitmap of enabled LEDs: LED_1 = 0x02, LED_2 = 0x04, ... */

 LEDx at (4 - x) */

 LED5, not actually soldered */

/* Offsets relative to USB input report (0x1). Bluetooth (0x11) requires an

 * additional +2.

 Default to 4ms poll interval, which is same as USB (not adjustable). */

 Used for calibration of DS4 accelerometer and gyro. */

	/* Calibration requires scaling against a sensitivity value, which is a

	 * float. Store sensitivity as a fraction to limit floating point

	 * calculations until final calibration.

 DS4 calibration data */

 GH Live */

		/* See comment in sixaxis_mapping, basically the L2 (and R2)

		 * triggers are reported through GD Pointer.

		 * In addition we ignore any analog button 'axes' and only

		 * support digital buttons.

 L2 */

		/* The DS3 provides analog values for most buttons and even

		 * for HAT axes through GD Pointer. L2 and R2 are reported

		 * among these as well instead of as GD Z / RZ. Remap L2

		 * and R2 and ignore other analog 'button axes' as there is

		 * no good way for reporting them.

 L2 */

 R2 */

 Let the HID parser deal with the HAT. */

	/*

	 * Some Sony RF receivers wrongly declare the mouse pointer as a

	 * a constant non-data variable.

 usage page: generic desktop controls */

 rdesc[0] == 0x05 && rdesc[1] == 0x01 && */

 usage: mouse */

 input (usage page for x,y axes): constant, variable, relative */

 input: data, variable, relative */

	/*

	 * Some knock-off USB dongles incorrectly report their button count

	 * as 13 instead of 16 causing three non-functional buttons.

 Report Count (13) */

 Usage Maximum (13) */

 Report Count (3) */

	/*

	 * The sixaxis is charging if the battery value is 0xee

	 * and it is fully charged if the value is 0xef.

	 * It does not report the actual level while charging so it

	 * is set to 100% while charging is in progress.

 Y and Z are swapped and inversed */

 When using Bluetooth the header is 2 bytes longer, so skip these. */

 Second bit of third button byte is for the touchpad button. */

	/*

	 * The default behavior of the Dualshock 4 is to send reports using

	 * report type 1 when running over Bluetooth. However, when feature

	 * report 2 is requested during the controller initialization it starts

	 * sending input reports in report 17. Since report 17 is undefined

	 * in the default HID descriptor, the HID layer won't generate events.

	 * While it is possible (and this was done before) to fixup the HID

	 * descriptor to add this mapping, it was better to do this manually.

	 * The reason is there were various pieces software both open and closed

	 * source, relying on the descriptors to be the same across various

	 * operating systems. If the descriptors wouldn't match some

	 * applications e.g. games on Wine would not be able to function due

	 * to different descriptors, which such applications are not parsing.

 Center 0, 0 */

 Convert timestamp (in 5.33us unit) to timestamp_us */

 Store data in int for more precision during mult_frac. */

		/* High precision is needed during calibration, but the

		 * calibrated values are within 32-bit.

		 * Note: we swap numerator 'x' and 'numer' in mult_frac for

		 *       precision reasons so we don't need 64-bit.

	/*

	 * The lower 4 bits of byte 30 (or 32 for BT) contain the battery level

	 * and the 5th bit contains the USB cable state.

	/*

	 * Interpretation of the battery_capacity data depends on the cable state.

	 * When no cable is connected (bit4 is 0):

	 * - 0:10: percentage in units of 10%.

	 * When a cable is plugged in:

	 * - 0-10: percentage in units of 10%.

	 * - 11: battery is full

	 * - 14: not charging due to Voltage or temperature error

	 * - 15: charge error

			/* Take the mid-point for each battery capacity value,

			 * because on the hardware side 0 = 0-9%, 1=10-19%, etc.

			 * This matches official platform behavior, which does

			 * the same.

 14, 15 and undefined values */

 10 */

	/*

	 * The Dualshock 4 multi-touch trackpad data starts at offset 33 on USB

	 * and 35 on Bluetooth.

	 * The first byte indicates the number of touch data in the report.

	 * Trackpad data starts 2 bytes later (e.g. 35 for USB).

 Skip past timestamp */

		/*

		 * The first 7 bits of the first byte is a counter and bit 8 is

		 * a touch indicator that is 0 when pressed and 1 when not

		 * pressed.

		 * The next 3 bytes are two 12 bit touch coordinates, X and Y.

		 * The data for the second touch is in the same format and

		 * immediately follows the data for the first.

	/*

	 * The NSG-MRxU multi-touch trackpad data starts at offset 1 and

	 *   the touch-related data starts at offset 2.

	 * For the first byte, bit 0 is set when touchpad button is pressed.

	 * Bit 2 is set when a touch is active and the drag (Fn) key is pressed.

	 * This drag key is mapped to BTN_LEFT.  It is operational only when a 

	 *   touch point is active.

	 * Bit 4 is set when only the first touch point is active.

	 * Bit 6 is set when only the second touch point is active.

	 * Bits 5 and 7 are set when both touch points are active.

	 * The next 3 bytes are two 12 bit X/Y coordinates for the first touch.

	 * The following byte, offset 5, has the touch width and length.

	 *   Bits 0-4=X (width), bits 5-7=Y (length).

	 * A signed relative X coordinate is at offset 6.

	 * The bytes at offset 7-9 are the second touch X/Y coordinates.

	 * Offset 10 has the second touch width and length.

	 * Offset 11 has the relative Y coordinate.

			/*

			 * The relative coordinates belong to the first touch

			 * point, when present, or to the second touch point

			 * when the first is not active.

	/*

	 * Sixaxis HID report has acclerometers/gyro with MSByte first, this

	 * has to be BYTE_SWAPPED before passing up to joystick interface

		/*

		 * When connected via Bluetooth the Sixaxis occasionally sends

		 * a report with the second byte 0xff and the rest zeroed.

		 *

		 * This report does not reflect the actual state of the

		 * controller must be ignored to avoid generating false input

		 * events.

 CRC check */

		/*

		 * In the case of a DS4 USB dongle, bit[2] of byte 31 indicates

		 * if a DS4 is actually connected (indicated by '0').

		 * For non-dongle, this bit is always 0 (connected).

		/*

		 * The dongle always sends input reports even when no

		 * DS4 is attached. When a DS4 is connected, we need to

		 * obtain calibration data before we can use it.

		 * The code below tracks dongle state and kicks of

		 * calibration when needed and only allows us to process

		 * input if a DS4 is actually connected.

			/* Don't process the report since we don't have

			 * calibration data, but let hidraw have it anyway.

 Return 0, so hidraw can get the report. */

 Return 0, so hidraw can get the report. */

 Let hid-core decide for the others */

	/* Append a suffix to the controller name as there are various

	 * DS4 compatible non-Sony devices with different names.

 We map the button underneath the touchpad to BTN_LEFT. */

	/* Append a suffix to the controller name as there are various

	 * DS4 compatible non-Sony devices with different names.

		/* For the DS3 we only support the accelerometer, which works

		 * quite well even without calibration. The device also has

		 * a 1-axis gyro, but it is very difficult to manage from within

		 * the driver even to get data, the sensor is inaccurate and

		 * the behavior is very different between hardware revisions.

/*

 * Sending HID_REQ_GET_REPORT changes the operation mode of the ps3 controller

 * to "operational".  Without this, the ps3 controller will not report any

 * events.

	/*

	 * Some compatible controllers like the Speedlink Strike FX and

	 * Gasia need another query plus an USB interrupt to get operational.

	/*

	 * But the USB interrupt would cause SHANWAN controllers to

	 * start rumbling non-stop, so skip step 3 for these controllers.

/*

 * Request DS4 calibration data for the motion sensors.

 * For Bluetooth this also affects the operating mode (see below).

	/* For Bluetooth we use a different request, which supports CRC.

	 * Note: in Bluetooth mode feature report 0x02 also changes the state

	 * of the controller, so that it sends input reports of type 0x11.

		/* We should normally receive the feature report data we asked

		 * for, but hidraw applications such as Steam can issue feature

		 * reports as well. In particular for Dongle reconnects, Steam

		 * and this function are competing resulting in often receiving

		 * data for a different HID report, so retry a few times.

 CRC check */

 BT + Dongle */

	/* Set gyroscope calibration and normalization parameters.

	 * Data values will be normalized to 1/DS4_GYRO_RES_PER_DEG_S degree/s.

	/* Set accelerometer calibration and normalization parameters.

	 * Data values will be normalized to 1/DS4_ACC_RES_PER_G G.

		/* This call is very unlikely to fail for the dongle. When it

		 * fails we are probably in a very bad state, so mark the

		 * dongle as disabled. We will re-enable the dongle if a new

		 * DS4 hotplug is detect from sony_raw_event as any issues

		 * are likely resolved then (the dongle is quite stupid).

 The first 4 color/index entries match what the PS4 assigns */

 Blue   */	{ 0x00, 0x00, 0x40 },

 Red	  */	{ 0x40, 0x00, 0x00 },

 Green  */	{ 0x00, 0x40, 0x00 },

 Pink   */	{ 0x20, 0x00, 0x20 },

 Orange */	{ 0x02, 0x01, 0x00 },

 Teal   */	{ 0x00, 0x01, 0x01 },

 White  */	{ 0x01, 0x01, 0x01 }

	/*

	 * The Sixaxis on USB will override any LED settings sent to it

	 * and keep flashing all of the LEDs until the PS button is pressed.

	 * Updates, even if redundant, must be always be sent to the

	 * controller to avoid having to toggle the state of an LED just to

	 * stop the flashing later on.

 Setting the brightness stops the blinking */

 Max delay is 255 deciseconds or 2550 milliseconds */

 Blink at 1 Hz if both values are zero */

 This LED is not registered on this device */

 Don't schedule work if the values didn't change */

 Validate expected report characteristics. */

	/*

	 * Clear LEDs as we have no way of reading their initial state. This is

	 * only relevant if the driver is loaded after somebody actively set the

	 * LEDs to on

 Initialize the report with default values */

 Set flag for all leds off, required for 3rd party INTEC controller */

	/*

	 * The LEDs in the report are indexed in reverse order to their

	 * corresponding light on the controller.

	 * Index 0 = LED 4, index 1 = LED 3, etc...

	 *

	 * In the case of both delay values being zero (blinking disabled) the

	 * default report values should be used or the controller LED will be

	 * always off.

 SHANWAN controllers require output reports via intr channel */

	/*

	 * NOTE: The lower 6 bits of buf[1] field of the Bluetooth report

	 * control the interval at which Dualshock 4 reports data:

	 * 0x00 - 1ms

	 * 0x01 - 1ms

	 * 0x02 - 2ms

	 * 0x3E - 62ms

	 * 0x3F - disabled

 blink + LEDs + motor */

 HID + CRC */ | sc->ds4_bt_poll_interval;

 blink + LEDs + motor */

 LED 3 is the global control */

 If both delay values are zero the DualShock 4 disables blinking. */

 CRC generation */

 set leds */

	/*

	 * Set the default battery level to 100% to avoid low battery warnings

	 * if the battery is polled before the first device report is received.

/*

 * If a controller is plugged in via USB while already connected via Bluetooth

 * it will show up as two devices. A global list of connected controllers and

 * their MAC addresses is maintained to ensure that a device is only connected

 * once.

 *

 * Some USB-only devices masquerade as Sixaxis controllers and all have the

 * same dummy Bluetooth address, so a comparison of the connection type is

 * required.  Devices are only rejected in the case where two devices have

 * matching Bluetooth addresses on different bus types.

 HIDP stores the device MAC address as a string in the uniq field. */

		/*

		 * sony_get_bt_devaddr() attempts to parse the Bluetooth MAC

		 * address from the uniq string where HIDP stores it.

		 * As uniq cannot be guaranteed to be a MAC address in all cases

		 * a failure of this function should not prevent the connection.

		/*

		 * The MAC address of a DS4 controller connected via USB can be

		 * retrieved with feature report 0x81. The address begins at

		 * offset 1.

		/*

		 * The MAC address of a Sixaxis controller connected via USB can

		 * be retrieved with feature report 0xf2. The address begins at

		 * offset 4.

		/*

		 * The Sixaxis device MAC in the report is big-endian and must

		 * be byte-swapped.

	/*

	 * Only DualShock 4 or Sixaxis controllers get an id.

	 * All others are set to -1.

		/*

		 * The Sony Sixaxis does not handle HID Output Reports on the

		 * Interrupt EP like it could, so we need to force HID Output

		 * Reports to use HID_REQ_SET_REPORT on the Control EP.

		 *

		 * There is also another issue about HID Output Reports via USB,

		 * the Sixaxis does not want the report_id as part of the data

		 * packet, so we have to discard buf[0] when sending the actual

		 * control message, even for numbered reports, humpf!

		 *

		 * Additionally, the Sixaxis on USB isn't properly initialized

		 * until the PS logo button is pressed and as such won't retain

		 * any state set by an output report, so the initial

		 * configuration report is deferred until the first input

		 * report arrives.

		/*

		 * The Navigation controller wants output reports sent on the ctrl

		 * endpoint when connected via Bluetooth.

		/*

		 * The Sony Sixaxis does not handle HID Output Reports on the

		 * Interrupt EP and the device only becomes active when the

		 * PS button is pressed. See comment for Navigation controller

		 * above for more details.

		/*

		 * The Sixaxis wants output reports sent on the ctrl endpoint

		 * when connected via Bluetooth.

		/*

		 * The Dualshock 4 touchpad supports 2 touches and has a

		 * resolution of 1920x942 (44.86 dots/mm).

		/*

		 * The NSG-MRxU touchpad supports 2 touches and has a

		 * resolution of 1667x1868

 Open the device to receive reports with battery info */

	/* Piggy back on the default ds4_bt_ poll_interval to determine

	 * if we need to remove the file as we don't know for sure if we

	 * executed that logic.

	/* Patch the hw version on DS3/4 compatible devices, so applications can

	 * distinguish between the default HID mappings and the mappings defined

	 * by the Linux game controller spec. This is important for the SDL2

	 * library, which has a game controller database, which uses device ids

	 * in combination with version as a key.

	/* sony_input_configured can fail, but this doesn't result

	 * in hid_hw_start failures (intended). Check whether

	 * the HID layer claimed the device else fail.

	 * We don't know the actual reason for the failure, most

	 * likely it is due to EEXIST in case of double connection

	 * of USB and Bluetooth, but could have been due to ENOMEM

	 * or other reasons as well.

 On suspend stop any running force-feedback events */

	/*

	 * The Sixaxis and navigation controllers on USB need to be

	 * reinitialized on resume or they won't behave properly.

	/*

	 * Wired Buzz Controller. Reported as Sony Hub from its USB ID and as

	 * Logitech joystick from the device descriptor.

 PS3 BD Remote Control */

 Logitech Harmony Adapter for PS3 */

 SMK-Link PS3 BD Remote Control */

 Sony Dualshock 4 controllers for PS4 */

 Nyko Core Controller for PS3 */

 SMK-Link NSG-MR5U Remote Control */

 SMK-Link NSG-MR7U Remote Control */

 Guitar Hero Live PS3 and Wii U guitar dongles */

 Guitar Hero PC Guitar Dongle */

 Guitar Hero PS3 World Tour Guitar Dongle */

 Guitar Hero Live PS4 guitar dongles */

 SPDX-License-Identifier: GPL-2.0+

/*

 *  HID driver for UC-Logic devices not fully compliant with HID standard

 *

 *  Copyright (c) 2010-2014 Nikolai Kondrashov

 *  Copyright (c) 2013 Martin Rusko

/*

 * This program is free software; you can redistribute it and/or modify it

 * under the terms of the GNU General Public License as published by the Free

 * Software Foundation; either version 2 of the License, or (at your option)

 * any later version.

 Driver data */

 Interface parameters */

 Pointer to the replacement report descriptor. NULL if none. */

	/*

	 * Size of the replacement report descriptor.

	 * Only valid if desc_ptr is not NULL

 Pen input device */

 In-range timer */

 Last rotary encoder state, or U8_MAX for none */

/**

 * uclogic_inrange_timeout - handle pen in-range state timeout.

 * Emulate input events normally generated when pen goes out of range for

 * tablets which don't report that.

 *

 * @t:	The timer the timeout handler is attached to, stored in a struct

 *	uclogic_drvdata.

 If BTN_TOUCH state is changing */

 Digitizer Tip Switch usage */

 discard the unused pen interface */

 let hid-core decide what to do */

 no report associated (HID_QUIRK_MULTI_INPUT not set) */

	/*

	 * If this is the input corresponding to the pen report

	 * in need of tweaking.

 Remember the input device so we can simulate events */

	/*

	 * libinput requires the pad interface to be on a different node

	 * than the pen, so use QUIRK_MULTI_INPUT for all tablets.

 Allocate and assign driver data */

 Initialize the device and retrieve interface parameters */

 Generate replacement report descriptor */

 Assume "remove" might not be called if "probe" failed */

 Re-initialize the device, but discard parameters */

 Tweak pen reports, if necessary */

 If it's the "virtual" frame controls report */

 Change to virtual frame controls report ID */

 If in-range reports are inverted */

 Invert the in-range bit */

		/*

		 * If report contains fragmented high-resolution pen

		 * coordinates

 Lift pressure bytes */

			/*

			 * Move Y coord to make space for high-order X

			 * coord byte

 Move high-order X coord byte */

 Move high-order Y coord byte */

 Place pressure bytes */

 If we need to emulate in-range detection */

 Set in-range bit */

 (Re-)start in-range timeout */

 Tweak frame control reports, if necessary */

 If need to, and can, set pad device ID for Wacom drivers */

 If need to, and can, read rotary encoder state change */

 Read Gray-coded state */

 Encode state change into 2-bit signed integer */

 Write change */

 Remember state */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  HID driver for Kye/Genius devices not fully compliant with HID standard

 *

 *  Copyright (c) 2009 Jiri Kosina

 *  Copyright (c) 2009 Tomas Hanak

 *  Copyright (c) 2012 Nikolai Kondrashov

/*

 Original EasyPen i405X report descriptor size */

 Fixed EasyPen i405X report descriptor */

  Usage Page (FF00h),             */

  Usage (01h),                    */

  Collection (Application),       */

    Report ID (5),                */

    Usage (01h),                  */

    Logical Minimum (-128),       */

    Logical Maximum (127),        */

    Report Size (8),              */

    Report Count (7),             */

    Feature (Variable),           */

  End Collection,                 */

  Usage Page (Digitizer),         */

  Usage (Pen),                    */

  Collection (Application),       */

    Report ID (16),               */

    Usage (Stylus),               */

    Collection (Physical),        */

      Logical Minimum (0),        */

      Logical Maximum (1),        */

      Report Size (1),            */

      Usage (Tip Switch),         */

      Usage (Barrel Switch),      */

      Usage (Tablet Pick),        */

      Report Count (3),           */

      Input (Variable),           */

      Report Count (4),           */

      Input (Constant, Variable), */

      Usage (In Range),           */

      Report Count (1),           */

      Input (Variable),           */

      Report Size (16),           */

      Report Count (1),           */

      Push,                       */

      Usage Page (Desktop),       */

      Unit Exponent (-3),         */

      Unit (Inch),                */

      Physical Minimum (0),       */

      Usage (X),                  */

      Physical Maximum (5500),    */

      Logical Maximum (14080),    */

      Input (Variable),           */

      Usage (Y),                  */

      Physical Maximum (4000),    */

      Logical Maximum (10240),    */

      Input (Variable),           */

      Pop,                        */

      Usage (Tip Pressure),       */

      Logical Maximum (1023),     */

      Input (Variable),           */

    End Collection,               */

  End Collection                  */

 Original MousePen i608X report descriptor size */

 Fixed MousePen i608X report descriptor */

  Usage Page (FF00h),             */

  Usage (01h),                    */

  Collection (Application),       */

    Report ID (5),                */

    Usage (01h),                  */

    Logical Minimum (-128),       */

    Logical Maximum (127),        */

    Report Size (8),              */

    Report Count (7),             */

    Feature (Variable),           */

  End Collection,                 */

  Usage Page (Digitizer),         */

  Usage (Pen),                    */

  Collection (Application),       */

    Report ID (16),               */

    Usage (Stylus),               */

    Collection (Physical),        */

      Logical Minimum (0),        */

      Logical Maximum (1),        */

      Report Size (1),            */

      Usage (Tip Switch),         */

      Usage (Barrel Switch),      */

      Usage (Tablet Pick),        */

      Report Count (3),           */

      Input (Variable),           */

      Report Count (4),           */

      Input (Constant, Variable), */

      Usage (In Range),           */

      Report Count (1),           */

      Input (Variable),           */

      Report Size (16),           */

      Report Count (1),           */

      Push,                       */

      Usage Page (Desktop),       */

      Unit Exponent (-3),         */

      Unit (Inch),                */

      Physical Minimum (0),       */

      Usage (X),                  */

      Physical Maximum (8000),    */

      Logical Maximum (20480),    */

      Input (Variable),           */

      Usage (Y),                  */

      Physical Maximum (6000),    */

      Logical Maximum (15360),    */

      Input (Variable),           */

      Pop,                        */

      Usage (Tip Pressure),       */

      Logical Maximum (1023),     */

      Input (Variable),           */

    End Collection,               */

  End Collection,                 */

  Usage Page (Desktop),           */

  Usage (Mouse),                  */

  Collection (Application),       */

    Report ID (17),               */

    Usage (Pointer),              */

    Collection (Physical),        */

      Logical Minimum (0),        */

      Push,                       */

      Usage Page (Button),        */

      Report Size (1),            */

      Usage Minimum (01h),        */

      Usage Maximum (03h),        */

      Logical Maximum (1),        */

      Report Count (3),           */

      Input (Variable),           */

      Report Count (5),           */

      Input (Constant),           */

      Pop,                        */

      Report Count (1),           */

      Push,                       */

      Unit Exponent (-3),         */

      Unit (Inch),                */

      Physical Minimum (0),       */

      Report Size (16),           */

      Usage (X),                  */

      Physical Maximum (8000),    */

      Logical Maximum (20480),    */

      Input (Variable),           */

      Usage (Y),                  */

      Physical Maximum (6000),    */

      Logical Maximum (15360),    */

      Input (Variable),           */

      Pop,                        */

      Report Size (8),            */

      Usage (Wheel),              */

      Logical Minimum (-1),       */

      Logical Maximum (1),        */

      Input (Variable, Relative), */

      Input (Constant),           */

    End Collection,               */

  End Collection                  */

 Original MousePen i608X v2 report descriptor size */

 Fixed MousePen i608X v2 report descriptor */

  Usage Page (FF00h),             */

  Usage (01h),                    */

  Collection (Application),       */

    Report ID (5),                */

    Usage (01h),                  */

    Logical Minimum (-128),       */

    Logical Maximum (127),        */

    Report Size (8),              */

    Report Count (7),             */

    Feature (Variable),           */

  End Collection,                 */

  Usage Page (Digitizer),         */

  Usage (Pen),                    */

  Collection (Application),       */

    Report ID (16),               */

    Usage (Stylus),               */

    Collection (Physical),        */

      Logical Minimum (0),        */

      Logical Maximum (1),        */

      Report Size (1),            */

      Usage (Tip Switch),         */

      Usage (Barrel Switch),      */

      Usage (Tablet Pick),        */

      Report Count (3),           */

      Input (Variable),           */

      Report Count (4),           */

      Input (Constant, Variable), */

      Usage (In Range),           */

      Report Count (1),           */

      Input (Variable),           */

      Report Size (16),           */

      Report Count (1),           */

      Push,                       */

      Usage Page (Desktop),       */

      Unit Exponent (-3),         */

      Unit (Inch),                */

      Physical Minimum (0),       */

      Usage (X),                  */

      Physical Maximum (8000),    */

      Logical Maximum (40960),    */

      Input (Variable),           */

      Usage (Y),                  */

      Physical Maximum (6000),    */

      Logical Maximum (30720),    */

      Input (Variable),           */

      Pop,                        */

      Usage (Tip Pressure),       */

      Logical Maximum (2047),     */

      Input (Variable),           */

    End Collection,               */

  End Collection,                 */

  Usage Page (Desktop),           */

  Usage (Mouse),                  */

  Collection (Application),       */

    Report ID (17),               */

    Usage (Pointer),              */

    Collection (Physical),        */

      Logical Minimum (0),        */

      Push,                       */

      Usage Page (Button),        */

      Report Size (1),            */

      Usage Minimum (01h),        */

      Usage Maximum (03h),        */

      Logical Maximum (1),        */

      Report Count (3),           */

      Input (Variable),           */

      Report Count (5),           */

      Input (Constant),           */

      Pop,                        */

      Report Count (1),           */

      Push,                       */

      Unit Exponent (-3),         */

      Unit (Inch),                */

      Physical Minimum (0),       */

      Report Size (16),           */

      Usage (X),                  */

      Physical Maximum (8000),    */

      Logical Maximum (40960),    */

      Input (Variable),           */

      Usage (Y),                  */

      Physical Maximum (6000),    */

      Logical Maximum (30720),    */

      Input (Variable),           */

      Pop,                        */

      Report Size (8),            */

      Usage (Wheel),              */

      Logical Minimum (-1),       */

      Logical Maximum (1),        */

      Input (Variable, Relative), */

      Input (Constant),           */

    End Collection,               */

  End Collection                  */

 Original EasyPen M610X report descriptor size */

 Fixed EasyPen M610X report descriptor */

  Usage Page (FF00h),             */

  Usage (01h),                    */

  Collection (Application),       */

    Report ID (5),                */

    Usage (01h),                  */

    Logical Minimum (-128),       */

    Logical Maximum (127),        */

    Report Size (8),              */

    Report Count (7),             */

    Feature (Variable),           */

  End Collection,                 */

  Usage Page (Digitizer),         */

  Usage (Pen),                    */

  Collection (Application),       */

    Report ID (16),               */

    Usage (Stylus),               */

    Collection (Physical),        */

      Logical Minimum (0),        */

      Logical Maximum (1),        */

      Report Size (1),            */

      Usage (Tip Switch),         */

      Usage (Barrel Switch),      */

      Usage (Tablet Pick),        */

      Report Count (3),           */

      Input (Variable),           */

      Report Count (4),           */

      Input (Constant, Variable), */

      Usage (In Range),           */

      Report Count (1),           */

      Input (Variable),           */

      Report Size (16),           */

      Report Count (1),           */

      Push,                       */

      Usage Page (Desktop),       */

      Unit Exponent (-3),         */

      Unit (Inch),                */

      Physical Minimum (0),       */

      Usage (X),                  */

      Physical Maximum (10000),   */

      Logical Maximum (40960),    */

      Input (Variable),           */

      Usage (Y),                  */

      Physical Maximum (6250),    */

      Logical Maximum (25600),    */

      Input (Variable),           */

      Pop,                        */

      Usage (Tip Pressure),       */

      Logical Maximum (1023),     */

      Input (Variable),           */

    End Collection,               */

  End Collection,                 */

  Usage Page (Consumer),          */

  Usage (Consumer Control),       */

  Collection (Application),       */

    Report ID (18),               */

    Logical Minimum (0),          */

    Logical Maximum (1),          */

    Report Size (1),              */

    Report Count (4),             */

    Usage (AC Undo),              */

    Usage (AC Redo Or Repeat),    */

    Usage (AC Zoom In),           */

    Usage (AC Zoom Out),          */

    Input (Variable),             */

    Report Count (1),             */

    Report Size (20),             */

    Input (Constant, Variable),   */

    Report Size (32),             */

    Input (Constant, Variable),   */

  End Collection                  */

 Original PenSketch M912 report descriptor size */

 Fixed PenSketch M912 report descriptor */

  Usage Page (Desktop),           */

  Usage (00h),                    */

  Collection (Application),       */

    Report ID (5),                */

    Usage Page (FF00h),           */

    Usage (01h),                  */

    Logical Minimum (-127),       */

    Logical Maximum (127),        */

    Report Size (8),              */

    Report Count (7),             */

    Feature (Variable),           */

  End Collection,                 */

  Usage Page (Digitizer),         */

  Usage (Pen),                    */

  Collection (Application),       */

    Report ID (16),               */

    Usage (Stylus),               */

    Collection (Physical),        */

      Usage (Tip Switch),         */

      Usage (Barrel Switch),      */

      Usage (Tablet Pick),        */

      Logical Minimum (0),        */

      Logical Maximum (1),        */

      Report Size (1),            */

      Report Count (3),           */

      Input (Variable),           */

      Report Count (4),           */

      Input (Constant, Variable), */

      Usage (In Range),           */

      Report Count (1),           */

      Input (Variable),           */

      Report Size (16),           */

      Report Count (1),           */

      Push,                       */

      Usage Page (Desktop),       */

      Unit Exponent (-3),         */

      Unit (Inch),                */

      Logical Minimum (0),        */

      Physical Minimum (0),       */

      Usage (X),                  */

      Logical Maximum (61440),    */

      Physical Maximum (12000),   */

      Input (Variable),           */

      Usage (Y),                  */

      Logical Maximum (46080),    */

      Physical Maximum (9000),    */

      Input (Variable),           */

      Pop,                        */

      Usage (Tip Pressure),       */

      Logical Minimum (0),        */

      Logical Maximum (2047),     */

      Input (Variable),           */

    End Collection,               */

  End Collection,                 */

  Usage Page (Digitizer),         */

  Usage (Puck),                   */

  Collection (Application),       */

    Report ID (17),               */

    Usage (Puck),                 */

    Collection (Physical),        */

      Usage Page (Button),        */

      Report Size (1),            */

      Usage Minimum (01h),        */

      Usage Maximum (03h),        */

      Logical Minimum (0),        */

      Logical Maximum (1),        */

      Report Count (3),           */

      Input (Variable),           */

      Report Count (4),           */

      Input (Constant),           */

      Report Count (1),           */

      Usage (Digitizer In Range), */

      Logical Minimum (0),        */

      Logical Maximum (1),        */

      Input (Variable),           */

      Push,                       */

      Usage Page (Desktop),       */

      Report Size (16),           */

      Report Count (1),           */

      Unit Exponent (-3),         */

      Unit (Inch),                */

      Logical Minimum (0),        */

      Physical Minimum (0),       */

      Usage (X),                  */

      Logical Maximum (61440),    */

      Physical Maximum (12000),   */

      Input (Variable),           */

      Usage (Y),                  */

      Logical Maximum (46080),    */

      Physical Maximum (9000),    */

      Input (Variable),           */

      Usage (Wheel),              */

      Report Size (8),            */

      Report Count (1),           */

      Logical Minimum (-1),       */

      Logical Maximum (1),        */

      Physical Minimum (0),       */

      Physical Maximum (0),       */

      Input (Variable, Relative), */

      Pop,                        */

    End Collection,               */

  End Collection,                 */

  Usage Page (Consumer),          */

  Usage (Consumer Control),       */

  Collection (Application),       */

    Report ID (18),               */

    Logical Minimum (0),          */

    Logical Maximum (1),          */

    Report Size (1),              */

    Report Count (8),             */

    Usage Page (Consumer),        */

    Usage (AC Delete),            */

    Usage (AC Undo),              */

    Usage (AC New),               */

    Usage (AC Zoom),              */

    Usage (AC Forward),           */

    Usage (AC Back),              */

    Usage (AC Zoom In),           */

    Usage (AC Zoom Out),          */

    Input (Variable),             */

    Report Count (48),            */

    Input (Constant, Variable),   */

  End Collection                  */

 Original EasyPen M406XE report descriptor size */

 Fixed EasyPen M406XE  report descriptor */

  Usage Page (Desktop),               */

  Usage (01h),                        */

  Collection (Application),           */

      Report ID (5),                  */

      Usage (01h),                    */

      Logical Minimum (-128),         */

      Logical Maximum (127),          */

      Report Size (8),                */

      Report Count (7),               */

      Feature (Variable),             */

  End Collection,                     */

  Usage Page (Digitizer),             */

  Usage (Pen),                        */

  Collection (Application),           */

      Report ID (16),                 */

      Usage (Stylus),                 */

      Collection (Physical),          */

          Logical Minimum (0),        */

          Logical Maximum (1),        */

          Report Size (1),            */

          Usage (Tip Switch),         */

          Usage (Barrel Switch),      */

          Usage (Tablet Pick),        */

          Report Count (3),           */

          Input (Variable),           */

          Report Count (4),           */

          Input (Constant, Variable), */

          Usage (In Range),           */

          Report Count (1),           */

          Input (Variable),           */

          Report Size (16),           */

          Report Count (1),           */

          Push,                       */

          Usage Page (Desktop),       */

          Unit Exponent (-3),         */

          Unit (Inch),                */

          Physical Minimum (0),       */

          Usage (X),                  */

          Physical Maximum (6000),    */

          Logical Maximum (15360),    */

          Input (Variable),           */

          Usage (Y),                  */

          Physical Maximum (4000),    */

          Logical Maximum (10240),    */

          Input (Variable),           */

          Pop,                        */

          Usage (Tip Pressure),       */

          Logical Maximum (1023),     */

          Input (Variable),           */

      End Collection,                 */

  End Collection                      */

  Usage Page (Consumer),              */

  Usage (Consumer Control),           */

  Collection (Application),           */

      Report ID (18),                 */

      Logical Minimum (0),            */

      Logical Maximum (1),            */

      Report Size (1),                */

      Report Count (4),               */

      Usage (AC Redo Or Repeat),      */

      Usage (AC Undo),                */

      Usage (AC Zoom In),             */

      Usage (AC Zoom Out),            */

      Input (Variable),               */

      Report Count (52),              */

      Input (Constant, Variable),     */

  End Collection                      */

	/*

	 * the fixup that need to be done:

	 *   - change Usage Maximum in the Consumer Control

	 *     (report ID 3) to a reasonable value

 Usage Page (Consumer Devices) */

 Usage (Consumer Control) */

   Usage Maximum > 12287 */

		/* the fixups that need to be done:

		 *   - change led usage page to button for extra buttons

		 *   - report size 8 count 1 must be size 1 count 8 for button

		 *     bitfield

		 *   - change the button usage range to 4-7 for the extra

		 *     buttons

/**

 * kye_tablet_enable() - Enable fully-functional tablet mode by setting a special feature report.

 *

 * @hdev:	HID device

 *

 * The specific report ID and data were discovered by sniffing the

 * Windows driver traffic.

		/*

		 * The manticore keyboard needs to have all the interfaces

		 * opened at least once to be fully functional.

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  HIDPP protocol for Logitech receivers

 *

 *  Copyright (c) 2011 Logitech (c)

 *  Copyright (c) 2012-2013 Google (c)

 *  Copyright (c) 2013-2014 Red Hat Inc.

 bits 2..20 are reserved for classes */

 #define HIDPP_QUIRK_CONNECT_EVENTS		BIT(21) disabled */

 These are just aliases for now */

 Convenience constant to check for any high-res support. */

/*

 * There are two hidpp protocols in use, the first version hidpp10 is known

 * as register access protocol or RAP, the second version hidpp20 is known as

 * feature access protocol or FAP

 *

 * Most older devices (including the Unifying usb receiver) use the RAP protocol

 * where as most newer devices use the FAP protocol. Both protocols are

 * compatible with the underlying transport, which could be usb, Unifiying, or

 * bluetooth. The message lengths are defined by the hid vendor specific report

 * descriptor for the HIDPP_SHORT report type (total message lenth 7 bytes) and

 * the HIDPP_LONG report type (total message length 20 bytes)

 *

 * The RAP protocol uses both report types, whereas the FAP only uses HIDPP_LONG

 * messages. The Unifying receiver itself responds to RAP messages (device index

 * is 0xFF for the receiver), and all messages (short or long) with a device

 * index between 1 and 6 are passed untouched to the corresponding paired

 * Unifying device.

 *

 * The paired device can be RAP or FAP, it will receive the message untouched

 * from the Unifiying receiver.

/**

 * struct hidpp_scroll_counter - Utility class for processing high-resolution

 *                             scroll events.

 * @dev: the input device for which events should be reported.

 * @wheel_multiplier: the scalar multiplier to be applied to each wheel event

 * @remainder: counts the number of high-resolution units moved since the last

 *             low-resolution event (REL_WHEEL or REL_HWHEEL) was sent. Should

 *             only be used by class methods.

 * @direction: direction of last movement (1 or -1)

 * @last_time: last event time, used to reset remainder after inactivity

 will never be NULL and should not be freed */

 HID++ 1.0 error codes */

 HID++ 2.0 error codes */

	/*

	 * set the device_index as the receiver, it will be overwritten by

	 * hid_hw_request if needed

/*

 * hidpp_send_message_sync() returns 0 in case of success, and something else

 * in case of a failure.

 * - If ' something else' is positive, that means that an error has been raised

 *   by the protocol itself.

 * - If ' something else' is negative, that means that we had a classic error

 *   (-ENOMEM, -EPIPE, etc...)

	/*

	 * So that we can later validate the answer when it arrives

	 * in hidpp_raw_event

 Send as long report if short reports are not supported. */

/*

 * hidpp_prefix_name() prefixes the current given name with "Logitech ".

 "Logitech " */

 The prefix has is already in the name */

/**

 * hidpp_scroll_counter_handle_scroll() - Send high- and low-resolution scroll

 *                                        events given a high-resolution wheel

 *                                        movement.

 * @input_dev: Pointer to the input device

 * @counter: a hid_scroll_counter struct describing the wheel.

 * @hi_res_value: the movement of the wheel, in the mouse's high-resolution

 *                units.

 *

 * Given a high-resolution movement, this function converts the movement into

 * fractions of 120 and emits high-resolution scroll events for the input

 * device. It also uses the multiplier from &struct hid_scroll_counter to

 * emit low-resolution scroll events when appropriate for

 * backwards-compatibility with userspace input libraries.

	/*

	 * Reset the remainder after a period of inactivity or when the

	 * direction changes. This prevents the REL_WHEEL emulation point

	 * from sliding for devices that don't always provide the same

	 * number of movements per detent.

	/* Some wheels will rest 7/8ths of a detent from the previous detent

	 * after slow movement, so we want the threshold for low-res events to

	 * be in the middle between two detents (e.g. after 4/8ths) as

	 * opposed to on the detents themselves (8/8ths).

		/* Add (or subtract) 1 because we want to trigger when the wheel

		 * is half-way to the next detent (i.e. scroll 1 detent after a

		 * 1/2 detent movement, 2 detents after a 1 1/2 detent movement,

		 * etc.).

 -------------------------------------------------------------------------- */

 HIDP++ 1.0 commands                                                        */

 -------------------------------------------------------------------------- */

/**

 * hidpp10_set_register - Modify a HID++ 1.0 register.

 * @hidpp_dev: the device to set the register on.

 * @register_address: the address of the register to modify.

 * @byte: the byte of the register to modify. Should be less than 3.

 * @mask: mask of the bits to modify

 * @value: new values for the bits in mask

 * Return: 0 if successful, otherwise a negative error code.

 On HID++ 1.0 devices, high-res scroll was called "scrolling acceleration". */

 discharging (in use) */

 (standard) charging */

 fast charging */

 slow charging */

 topping charge */

 charge complete */

 unknown */

	/*

	 * 0x01...0x1F = reserved (not charging)

	 * 0x23 = charging error

	 * 0x27..0xff = reserved

 the capacity is only available when discharging or full */

 discharging (in use) */

 charging */

 charge complete */

	/*

	 * 0x03 = charging error

 the capacity is only available when discharging or full */

 the capacity is only available when discharging or full */

 logitech devices are usually at least Xddd */

 include the terminating '\0' */

	/*

	 * We don't care about LE or BE, we will output it as a string

	 * with %4phD, so we need to keep the order.

 -------------------------------------------------------------------------- */

 0x0000: Root                                                               */

 -------------------------------------------------------------------------- */

 the device might not be connected */

 -------------------------------------------------------------------------- */

 0x0005: GetDeviceNameType                                                  */

 -------------------------------------------------------------------------- */

 include the terminating '\0' */

 -------------------------------------------------------------------------- */

 0x1000: Battery level status                                               */

 -------------------------------------------------------------------------- */

	/*

	 * The spec says this should be < 31 but some devices report 30

	 * with brand new batteries and Windows reports 30 as "Good".

	/* When discharging, we can rely on the device reported capacity.

	 * For all other states the device reports 0 (unknown).

 discharging (in use) */

 recharging */

 charge in final stage */

 charge complete */

 recharging below optimal speed */

		/* 5 = invalid battery type

		   6 = thermal error

 Ignore these intermittent errors */

 the capacity is only available when discharging or full */

 the capacity is only available when discharging or full */

 -------------------------------------------------------------------------- */

 0x1001: Battery voltage                                                    */

 -------------------------------------------------------------------------- */

	/* NB: This voltage curve doesn't necessarily map perfectly to all

	 * devices that implement the BATTERY_VOLTAGE feature. This is because

	 * there are a few devices that use different battery technology.

 -------------------------------------------------------------------------- */

 0x1004: Unified battery                                                    */

 -------------------------------------------------------------------------- */

 we have already set the device capabilities, so let's skip */

 Ignore these intermittent errors */

	/*

	 * If the device supports state of charge (battery percentage) we won't

	 * export the battery level information. there are 4 possible battery

	 * levels and they all are optional, this means that the device might

	 * not support any of them, we are just better off with the battery

	 * percentage.

 discharging */

 charging */

 charging slow */

 complete */

 error */

 cler unsupported level bits */

 Ignore these intermittent errors */

 -------------------------------------------------------------------------- */

 Battery feature helpers                                                    */

 -------------------------------------------------------------------------- */

 placeholder for POWER_SUPPLY_PROP_CAPACITY, */

 placeholder for POWER_SUPPLY_PROP_CAPACITY_LEVEL, */

 placeholder for POWER_SUPPLY_PROP_VOLTAGE_NOW, */

 hardware reports voltage in in mV. sysfs expects uV */

 -------------------------------------------------------------------------- */

 0x1d4b: Wireless device status                                             */

 -------------------------------------------------------------------------- */

 -------------------------------------------------------------------------- */

 0x2120: Hi-resolution scrolling                                            */

 -------------------------------------------------------------------------- */

 -------------------------------------------------------------------------- */

 0x2121: HiRes Wheel                                                        */

 -------------------------------------------------------------------------- */

 -------------------------------------------------------------------------- */

 0x4301: Solar Keyboard                                                     */

 -------------------------------------------------------------------------- */

 -------------------------------------------------------------------------- */

 0x6010: Touchpad FW items                                                  */

 -------------------------------------------------------------------------- */

/*

 * send a set state command to the device by reading the current items->state

 * field. items is then filled with the current state.

 -------------------------------------------------------------------------- */

 0x6100: TouchPadRawXY                                                      */

 -------------------------------------------------------------------------- */

 res is given in unit per inch */

	/*

	 * Params:

	 *   bit 0 - enable raw

	 *   bit 1 - 16bit Z, no area

	 *   bit 2 - enhanced sensitivity

	 *   bit 3 - width, height (4 bits each) instead of area

	 *   bit 4 - send raw + gestures (degrades smoothness)

	 *   remaining bits - reserved

 -------------------------------------------------------------------------- */

 0x8123: Force feedback support                                             */

 -------------------------------------------------------------------------- */

 add slot number if needed */

 leave slot as zero */

 find current slot for effect */

 send command and wait for reply */

 parse return data */

 regular effect uploaded */

 autocenter spring uploaded */

 regular effect destroyed */

 autocenter spring destoyed */

 no action needed */

 warn about excessive queue size */

 set common parameters */

 start a standard spring effect */

 zero delay and duration */

 set coeff to 25% of saturation */

 zero deadband and center */

 no boost */

 Get firmware release */

 Set supported force feedback capabilities */

	/*

	 * Create a copy of passed data, so we can transfer memory

	 * ownership to FF core

 Create sysfs interface */

 init the hardware command queue */

 ************************************************************************** */

                                                                            */

 Device Support                                                             */

                                                                            */

 ************************************************************************** */

 -------------------------------------------------------------------------- */

 Touchpad HID++ devices                                                     */

 -------------------------------------------------------------------------- */

 Max pressure is not given by the devices, pick one */

 no actual data */

 size is already checked in hidpp_raw_event. */

 means that the device is not powered up */

 ------------------------------------------------------------------------- */

 Logitech M560 devices                                                     */

 ------------------------------------------------------------------------- */

/*

 * Logitech M560 protocol overview

 *

 * The Logitech M560 mouse, is designed for windows 8. When the middle and/or

 * the sides buttons are pressed, it sends some keyboard keys events

 * instead of buttons ones.

 * To complicate things further, the middle button keys sequence

 * is different from the odd press and the even press.

 *

 * forward button -> Super_R

 * backward button -> Super_L+'d' (press only)

 * middle button -> 1st time: Alt_L+SuperL+XF86TouchpadOff (press only)

 *                  2nd time: left-click (press only)

 * NB: press-only means that when the button is pressed, the

 * KeyPress/ButtonPress and KeyRelease/ButtonRelease events are generated

 * together sequentially; instead when the button is released, no event is

 * generated !

 *

 * With the command

 *	10<xx>0a 3500af03 (where <xx> is the mouse id),

 * the mouse reacts differently:

 * - it never sends a keyboard key event

 * - for the three mouse button it sends:

 *	middle button               press   11<xx>0a 3500af00...

 *	side 1 button (forward)     press   11<xx>0a 3500b000...

 *	side 2 button (backward)    press   11<xx>0a 3500ae00...

 *	middle/side1/side2 button   release 11<xx>0a 35000000...

 how buttons are mapped in the report */

 sanity check */

		/*

		 * m560 mouse report for middle, forward and backward button

		 *

		 * data[0] = 0x11

		 * data[1] = device-id

		 * data[2] = 0x0a

		 * data[5] = 0xaf -> middle

		 *	     0xb0 -> forward

		 *	     0xae -> backward

		 *	     0x00 -> release all

		 * data[6] = 0x00

		/*

		 * Logitech M560 mouse report

		 *

		 * data[0] = type (0x02)

		 * data[1..2] = buttons

		 * data[3..5] = xy

		 * data[6] = wheel

 ------------------------------------------------------------------------- */

 Logitech K400 devices                                                     */

 ------------------------------------------------------------------------- */

/*

 * The Logitech K400 keyboard has an embedded touchpad which is seen

 * as a mouse from the OS point of view. There is a hardware shortcut to disable

 * tap-to-click but the setting is not remembered accross reset, annoying some

 * users.

 *

 * We can toggle this feature from the host by using the feature 0x6010:

 * Touchpad FW items

 means that the device is not powered up */

 ------------------------------------------------------------------------- */

 Logitech G920 Driving Force Racing Wheel for Xbox One                     */

 ------------------------------------------------------------------------- */

 initialize with zero autocenter to get wheel in usable state */

 Find feature and store for later use */

 Read number of slots available in device */

 reset all forces */

 Read the current gain values */

 ignore boost value at response.fap.params[2] */

 -------------------------------------------------------------------------- */

 Logitech Dinovo Mini keyboard with builtin touchpad                        */

 -------------------------------------------------------------------------- */

 -------------------------------------------------------------------------- */

 HID++1.0 devices which use HID++ reports for their wheels                  */

 -------------------------------------------------------------------------- */

 -------------------------------------------------------------------------- */

 HID++1.0 mice which use HID++ reports for extra mouse buttons              */

 -------------------------------------------------------------------------- */

	/*

	 * Buttons are either delivered through the regular mouse report *or*

	 * through the extra buttons report. At least for button 6 how it is

	 * delivered differs per receiver firmware version. Even receivers with

	 * the same usb-id show different behavior, so we handle both cases.

 Some mice report events on button 9+, use BTN_MISC */

 BTN_MOUSE - BTN_MOUSE+7 are set already by the descriptor */

 -------------------------------------------------------------------------- */

 HID++1.0 kbds which only report 0x10xx consumer usages through sub-id 0x03 */

 -------------------------------------------------------------------------- */

 Find the consumer-page input report desc and change Maximums to 0x107f */

 Note 0 terminated so we can use strnstr to search for this. */

 USAGE_PAGE (Consumer Devices)       */

 USAGE (Consumer Control)            */

 COLLECTION (Application)            */

 REPORT_ID = 3                       */

 REPORT_SIZE (16)                    */

 REPORT_COUNT (2)                    */

 LOGICAL_MIN (1)                     */

 LOGICAL_MAX (...                    */

	/*

	 * Build a normal consumer report (3) out of the data, this detour

	 * is necessary to get some keyboards to report their 0x10xx usages.

 We are called from atomic context */

 -------------------------------------------------------------------------- */

 High-resolution scroll wheels                                              */

 -------------------------------------------------------------------------- */

 if (hidpp->quirks & HIDPP_QUIRK_HI_RES_SCROLL_1P0) */ {

 -------------------------------------------------------------------------- */

 Generic HID++ devices                                                      */

 -------------------------------------------------------------------------- */

 For 27 MHz keyboards the quirk gets set after hid_parse. */

 Ensure that Logitech G920 is not given a default fuzz/flat value */

	/*

	 * If the mutex is locked then we have a pending answer from a

	 * previously sent command.

		/*

		 * Check for a correct hidpp20 answer or the corresponding

		 * error

			/*

			 * This was an answer to a command that this driver sent

			 * We return 1 to hid-core to avoid forwarding the

			 * command upstream as it has been treated by the driver

gitlab.freedesktop.org/jwrdegoede/logitech-27mhz-keyboard-encryption-setup/\n");

 Generic HID++ processing. */

	/* If no report is available for further processing, skip calling

	/* This function will only be called for scroll events, due to the

	 * restriction imposed in hidpp_usages.

	/* A scroll event may occur before the multiplier has been retrieved or

	 * the input device set, or high-res scroll enabling may fail. In such

	 * cases we must return early (falling back to default behaviour) to

	 * avoid a crash in hidpp_scroll_counter_handle_scroll.

			/* we only support one battery feature right now, so let's

			   first check the ones that support battery level first

	/* the device is already connected, we can ask for its name and

 forward current battery state */

 if the input nodes are already created, we can stop now */

 report_fixup needs drvdata to be set before we call hid_parse */

	/*

	 * Make sure the device is HID++ capable, otherwise treat as generic HID

 indicates we are handling the battery properties in the kernel */

	/*

	 * Plain USB connections need to actually call start and open

	 * on the transport driver to allow incoming data.

 Allow incoming packets */

 Reset the HID node state */

 Now export the actual inputs and hidraw nodes to the world */

 wireless touchpad */

 wireless touchpad T650 */

 wireless touchpad T651 */

 Mouse Logitech Anywhere MX */

 Mouse Logitech Cube */

 Mouse Logitech M335 */

 Mouse Logitech M515 */

 Mouse logitech M560 */

 Mouse Logitech M705 (firmware RQM17) */

 Mouse Logitech M705 (firmware RQM67) */

 Mouse Logitech M720 */

 Mouse Logitech MX Anywhere 2 */

 Mouse Logitech MX Anywhere 2S */

 Mouse Logitech MX Master */

 Mouse Logitech MX Master 2S */

 Mouse Logitech MX Master 3 */

 Mouse Logitech Performance MX */

 Keyboard logitech K400 */

 Solar Keyboard Logitech K750 */

 Keyboard MX5000 (Bluetooth-receiver in HID proxy mode) */

 Dinovo Edge (Bluetooth-receiver in HID proxy mode) */

 Keyboard MX5500 (Bluetooth-receiver in HID proxy mode) */

 Keyboard LX501 (Y-RR53) */

 Keyboard MX3000 (Y-RAM74) */

 Keyboard MX3200 (Y-RAV80) */

 S510 Media Remote */

 Logitech G403 Wireless Gaming Mouse over USB */

 Logitech G703 Gaming Mouse over USB */

 Logitech G703 Hero Gaming Mouse over USB */

 Logitech G900 Gaming Mouse over USB */

 Logitech G903 Gaming Mouse over USB */

 Logitech G903 Hero Gaming Mouse over USB */

 Logitech G920 Wheel over USB */

 Logitech G Pro Gaming Mouse over USB */

 MX5000 keyboard over Bluetooth */

 Dinovo Edge keyboard over Bluetooth */

 MX5500 keyboard over Bluetooth */

 M-RCQ142 V470 Cordless Laser Mouse over Bluetooth */

 MX Master mouse over Bluetooth */

 MX Ergo trackball over Bluetooth */

 MX Master 3 mouse over Bluetooth */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Debug support for HID Nintendo Wii / Wii U peripherals

 * Copyright (c) 2011-2013 David Herrmann <dh.herrmann@gmail.com>

/*

 SPDX-License-Identifier: GPL-2.0-only

/*

 * HID driver for CMedia CM6533 audio jack controls

 * and HS100B mute buttons

 *

 * Copyright (C) 2015 Ben Chen <ben_chen@bizlinktech.com>

 * Copyright (C) 2021 Thomas Weißschuh <linux@weissschuh.net>

/* Fixed report descriptor of HS-100B audio chip

 * Bit 4 is an abolute Microphone mute usage instead of being unassigned.

  Usage Page (Consumer),          */

  Usage (Consumer Control),       */

  Collection (Application),       */

      Logical Minimum (0),        */

      Logical Maximum (1),        */

      Usage (Volume Inc),         */

      Usage (Volume Dec),         */

      Report Size (1),            */

      Report Count (2),           */

      Input (Variable),           */

      Usage (Mute),               */

      Report Count (1),           */

      Input (Variable, Relative), */

      Usage Page (Telephony),     */

      Usage (2Fh),                */

      Input (Variable),           */

      Usage (20h),                */

      Input (Variable, Relative), */

      Usage Page (Consumer),      */

      Usage (00h),                */

      Report Count (3),           */

      Input (Variable),           */

      Logical Maximum (255),      */

      Usage (00h),                */

      Report Size (8),            */

      Report Count (3),           */

      Input (Variable),           */

      Usage (00h),                */

      Report Count (4),           */

      Output (Variable),          */

  End Collection                  */

/*

*

*CM6533 audio jack HID raw events:

*

*Plug in:

*01000600 002083xx 080008c0 10000000

*about 3 seconds later...

*01000a00 002083xx 08000380 10000000

*01000600 002083xx 08000380 10000000

*

*Plug out:

*01000400 002083xx 080008c0 x0000000

 SPDX-License-Identifier: GPL-2.0-only

/***************************************************************************

 *   Copyright (C) 2010-2012 by Bruno Prémont <bonbons@linux-vserver.org>  *

 *                                                                         *

 *   Based on Logitech G13 driver (v0.4)                                   *

 *     Copyright (C) 2009 by Rick L. Vinyard, Jr. <rvinyard@cs.nmsu.edu>   *

 *                                                                         *

/* Framebuffer

 *

 * The PicoLCD use a Topway LCD module of 256x64 pixel

 * This display area is tiled over 4 controllers with 8 tiles

 * each. Each tile has 8x64 pixel, each data byte representing

 * a 1-bit wide vertical line of the tile.

 *

 * The display can be updated at a tile granularity.

 *

 *       Chip 1           Chip 2           Chip 3           Chip 4

 * +----------------+----------------+----------------+----------------+

 * |     Tile 1     |     Tile 1     |     Tile 1     |     Tile 1     |

 * +----------------+----------------+----------------+----------------+

 * |     Tile 2     |     Tile 2     |     Tile 2     |     Tile 2     |

 * +----------------+----------------+----------------+----------------+

 *                                  ...

 * +----------------+----------------+----------------+----------------+

 * |     Tile 8     |     Tile 8     |     Tile 8     |     Tile 8     |

 * +----------------+----------------+----------------+----------------+

 Framebuffer visual structures */

 Send a given tile to PicoLCD */

 Translate a single tile*/

 Oops, we should never get here! */

 Reconfigure LCD display */

 schedule first output of framebuffer */

 Update fb_vbitmap from the screen_base and send changed tiles to device */

	/*

	 * Translate the framebuffer into the format needed by the PicoLCD.

	 * See display layout above.

	 * Do this one tile after the other and push those tiles that changed.

	 *

	 * Wait for our IO to complete as otherwise we might flood the queue!

 Stub to call the system default and update the image on the picoLCD */

 Stub to call the system default and update the image on the picoLCD */

 Stub to call the system default and update the image on the picoLCD */

/*

 * this is the slow path from userspace. they can seek and write to

 * the fb. it's inefficient to do anything less than a full screen draw

 We let fb notification do this for us via lcd/backlight device */

 make sure no work is deferred */

 No thridparty should ever unregister our framebuffer! */

 only allow 1/8 bit depth (8-bit is grayscale) */

 switch between 1/8 bit depths */

 translate FB content to new bits-per-pixel */

 Callback from deferred IO workqueue */

/*

 * The "fb_update_rate" sysfs attribute

 initialize Framebuffer device */

	/* The extra memory is:

	 * - 256*u32 for pseudo_palette

	 * - struct fb_deferred_io

 disconnect framebuffer from HID dev */

	/* make sure there is no running update - thus that fbdata->picolcd

	 * once obtained under lock is guaranteed not to get free() under

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  HID support for Linux

 *

 *  Copyright (c) 1999 Andreas Gal

 *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>

 *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc

 *  Copyright (c) 2006-2012 Jiri Kosina

/*

/*

 * Version Information

/*

 * Register a new report for a device.

/*

 * Register a new field for this report.

/*

 * Open a collection. The type/usage is pushed on the stack.

/*

 * Close a collection.

/*

 * Climb up the stack, search for the specified collection type

 * and return the usage.

 we know nothing about this usage type */

/*

 * Concatenate usage which defines 16 bits or less with the

 * currently defined usage page to form a 32 bit usage

/*

 * Add a usage to the temporary parser table.

	/*

	 * If Usage item only includes usage id, concatenate it with

	 * currently defined usage page

/*

 * Register a new field for this report.

 Handle both signed and unsigned cases properly */

 Total size check: Allow for possible report index byte */

 Ignore padding fields */

 Duplicate the last usage we parsed if we have excess values */

/*

 * Read data value from item.

/*

 * Process a global item.

		/* Many devices provide unit exponent as a two's complement

		 * nibble due to the common misunderstanding of HID

		 * specification 1.11, 6.2.2.7 Global Items. Attempt to handle

/*

 * Process a local item.

			/*

			 * We treat items before the first delimiter

			 * as global to all usage sets (branch 0).

			 * In the moment we process only these global

			 * items and the first delimiter set.

			/*

			 * We do not warn if the name is not set, we are

			 * actually pre-scanning the device.

/*

 * Concatenate Usage Pages into Usages where relevant:

 * As per specification, 6.2.2.8: "When the parser encounters a main item it

 * concatenates the last declared Usage Page with a Usage to form a complete

 * usage value."

	/*

	 * Concatenate usage page again only if last declared Usage Page

	 * has not been already used in previous usages concatenation

 Ignore extended usages */

/*

 * Process a main item.

 Reset the local parser environment */

/*

 * Process a reserved item.

/*

 * Free a report and all registered fields. The field->usage and

 * field->value table's are allocated behind the field, so we need

 * only to free(field) itself.

/*

 * Close report. This function returns the device

 * state to the point prior to hid_open_report().

/*

 * Free a device structure, all reports, and all fields.

/*

 * Fetch a report description item from the data stream. We support long

 * items, though they are not used yet.

 ignore constant inputs, they will be ignored by hid-input */

 Reset the local parser environment */

/*

 * Scan a report descriptor before the device is added to the bus.

 * Sets device groups and other properties that determine what driver

 * to load.

	/*

	 * The parsing is simpler than the one in hid_open_report() as we should

	 * be robust against hid errors. Those errors will be raised by

	 * hid_open_report() anyway.

	/*

	 * Handle special flags set during scanning.

	/*

	 * Vendor specific handlings

				/*

				 * hid-rmi should take care of them,

				 * not hid-generic

/**

 * hid_parse_report - parse device report

 *

 * @hid: hid device

 * @start: report start

 * @size: report size

 *

 * Allocate the device report as read by the bus driver. This function should

 * only be called from parse() in ll drivers.

/**

 * hid_validate_values - validate existing device report's value indexes

 *

 * @hid: hid device

 * @type: which report type to examine

 * @id: which report ID to examine (0 for first)

 * @field_index: which report field to examine

 * @report_counts: expected number of values

 *

 * Validate the number of values in a given field of a given report, after

 * parsing.

	/*

	 * Explicitly not using hid_get_report() here since it depends on

	 * ->numbered being checked, which may not always be the case when

	 * drivers go to access report values.

		/*

		 * Validating on id 0 means we should examine the first

		 * report in the list.

	/*

	 * "Because OS implementations will generally divide the control's

	 * reported count by the Effective Resolution Multiplier, designers

	 * should take care not to establish a potential Effective

	 * Resolution Multiplier of zero."

	 * HID Usage Table, v1.12, Section 4.3.1, p31

	/*

	 * Handling the unit exponent is left as an exercise to whoever

	 * finds a device where that exponent is not 0.

 There are no devices with an effective multiplier > 255 */

	/*

	 * If multiplier_collection is NULL, the multiplier applies

	 * to all fields in the report.

	 * Otherwise, it is the Logical Collection the multiplier applies to

	 * but our field may be in a subcollection of that collection.

	/*

	 * "The Resolution Multiplier control must be contained in the same

	 * Logical Collection as the control(s) to which it is to be applied.

	 * If no Resolution Multiplier is defined, then the Resolution

	 * Multiplier defaults to 1.  If more than one control exists in a

	 * Logical Collection, the Resolution Multiplier is associated with

	 * all controls in the collection. If no Logical Collection is

	 * defined, the Resolution Multiplier is associated with all

	 * controls in the report."

	 * HID Usage Table, v1.12, Section 4.3.1, p30

	 *

	 * Thus, search from the current collection upwards until we find a

	 * logical collection. Then search all fields for that same parent

	 * collection. Those are the fields the multiplier applies to.

	 *

	 * If we have more than one multiplier, it will overwrite the

	 * applicable fields later.

/*

 * hid_setup_resolution_multiplier - set up all resolution multipliers

 *

 * @device: hid device

 *

 * Search for all Resolution Multiplier Feature Reports and apply their

 * value to all matching Input items. This only updates the internal struct

 * fields.

 *

 * The Resolution Multiplier is applied by the hardware. If the multiplier

 * is anything other than 1, the hardware will send pre-multiplied events

 * so that the same physical interaction generates an accumulated

 *	accumulated_value = value * * multiplier

 * This may be achieved by sending

 * - "value * multiplier" for each event, or

 * - "value" but "multiplier" times as frequently, or

 * - a combination of the above

 * The only guarantee is that the same physical interaction always generates

 * an accumulated 'value * multiplier'.

 *

 * This function must be called before any event processing and after

 * any SetRequest to the Resolution Multiplier.

 Ignore if report count is out of bounds. */

/**

 * hid_open_report - open a driver-specific device report

 *

 * @device: hid device

 *

 * Parse a report description into a hid_device structure. Reports are

 * enumerated, fields are attached to these reports.

 * 0 returned on success, otherwise nonzero error value.

 *

 * This function (or the equivalent hid_parse() macro) should only be

 * called from probe() in drivers, before starting the device.

			/*

			 * fetch initial values in case the device's

			 * default multiplier isn't the recommended 1

/*

 * Convert a signed n-bit integer to signed 32-bit integer. Common

 * cases are done through the compiler, the screwed things has to be

 * done by hand.

/*

 * Convert a signed 32-bit integer to a signed n-bit integer.

/*

 * Extract/implement a data field from/to a little endian report (bit array).

 *

 * Code sort-of follows HID spec:

 *     http://www.usb.org/developers/hidpage/HID1_11.pdf

 *

 * While the USB HID spec allows unlimited length bit fields in "report

 * descriptors", most devices never use more than 16 bits.

 * One model of UPS is claimed to report "LINEV" as a 32-bit field.

 * Search linux-kernel and linux-usb-devel archives for "hid-core extract".

/*

 * "implement" : set bits in a little endian bit stream.

 * Same concepts as "extract" (see comments above).

 * The data mangled in the bit stream remains in little endian

 * order the whole time. It make more sense to talk about

 * endianness of register values by considering a register

 * a "cached" copy of the little endian bit stream.

 last nibble */

/*

 * Search an array for a value.

/**

 * hid_match_report - check if driver's raw_event should be called

 *

 * @hid: hid device

 * @report: hid report to match against

 *

 * compare hid->driver->report_table->report_type to report->type

 NULL means all */

/**

 * hid_match_usage - check if driver's event should be called

 *

 * @hid: hid device

 * @usage: usage to match against

 *

 * compare hid->driver->usage_table->usage_{type,code} to

 * usage->usage_{type,code}

 NULL means all */

/*

 * Analyse a received field, and fetch the data from it. The field

 * content is stored for next report processing (we do differential

 * reporting to the layer).

 Ignore report if ErrorRollOver */

/*

 * Output the field into the report.

 signed values */

 unsigned values */

/*

 * Compute the size of a report.

/*

 * Create a report. 'data' has to be allocated using

 * hid_alloc_report_buf() so that it has proper size.

/*

 * Allocator for buffer that is going to be passed to hid_output_report()

	/*

	 * 7 extra bytes are necessary to achieve proper functionality

	 * of implement() working on 8 byte chunks

/*

 * Set a field value. The report this field belongs to has to be

 * created and transferred to the device, to set this value in the

 * device.

 Normally report number is 0 */

 Device uses numbered reports, data[0] is report number */

/*

 * Implement a generic .request() callback, using .raw_request()

 * DO NOT USE in hid drivers directly, but through hid_hw_request instead.

/**

 * hid_input_report - report data from lower layer (usb, bt...)

 *

 * @hid: hid device

 * @type: HID report type (HID_*_REPORT)

 * @data: report contents

 * @size: size of data parameter

 * @interrupt: distinguish between interrupt and control transfers

 *

 * This is data entry for lower layers.

 Avoid unnecessary overhead if debugfs is disabled */

	/* Drivers with the ->raw_event callback set are not required to connect

/**

 * hid_hw_start - start underlying HW

 * @hdev: hid device

 * @connect_mask: which outputs to connect, see HID_CONNECT_*

 *

 * Call this in probe function *after* hid_parse. This will setup HW

 * buffers and start the device (if not defeirred to device open).

 * hid_hw_stop must be called if this was successful.

/**

 * hid_hw_stop - stop underlying HW

 * @hdev: hid device

 *

 * This is usually called from remove function or from probe when something

 * failed and hid_hw_start was called already.

/**

 * hid_hw_open - signal underlying HW to start delivering events

 * @hdev: hid device

 *

 * Tell underlying HW to start delivering events from the device.

 * This function should be called sometime after successful call

 * to hid_hw_start().

/**

 * hid_hw_close - signal underlaying HW to stop delivering events

 *

 * @hdev: hid device

 *

 * This function indicates that we are not interested in the events

 * from this device anymore. Delivery of events may or may not stop,

 * depending on the number of users still outstanding.

/**

 * new_id_store - add a new HID device ID to this driver and re-probe devices

 * @drv: target device driver

 * @buf: buffer for scanning device ID data

 * @count: input size

 *

 * Adds a new dynamic hid device ID to this driver,

 * and causes the driver to probe for all devices again.

/**

 * hid_compare_device_paths - check if both devices share the same path

 * @hdev_a: hid device

 * @hdev_b: hid device

 * @separator: char to use as separator

 *

 * Check if two devices share the same path up to the last occurrence of

 * the separator char. Both paths must exist (i.e., zero-length paths

 * don't match).

			/*

			 * hid-generic implements .match(), so if

			 * hid_ignore_special_drivers is set, we can safely

			 * return.

 reset the quirks that has been previously set */

 default probe */

 default remove */

	/* we need to kill them here, otherwise they will stay allocated to

	/*

	 * Check for the mandatory transport channel.

	/*

	 * Read the device report descriptor once and use as template

	 * for the driver-specific modifications.

	/*

	 * Scan generic devices for group information

	/* XXX hack, any other cleaner solution after the driver core

/**

 * hid_allocate_device - allocate new hid device descriptor

 *

 * Allocate and initialize hid device, so that hid_destroy_device might be

 * used to free it.

 *

 * New hid_device pointer is returned on success, otherwise ERR_PTR encoded

 * error value.

/**

 * hid_destroy_device - free previously allocated device

 *

 * @hdev: hid device

 *

 * If you allocate hid_device through hid_allocate_device, you should ever

 * free by this function.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  HID driver for Saitek devices.

 *

 *  PS1000 (USB gamepad):

 *  Fixes the HID report descriptor by removing a non-existent axis and

 *  clearing the constant bit on the input reports for buttons and d-pad.

 *  (This module is based on "hid-ortek".)

 *  Copyright (c) 2012 Andreas Hübner

 *

 *  R.A.T.7, R.A.T.9, M.M.O.7 (USB gaming mice):

 *  Fixes the mode button which cycles through three constantly pressed

 *  buttons. All three press events are mapped to one button and the

 *  missing release event is generated immediately.

/*

 convert spurious axis to a "noop" Logical Minimum (0) */

 clear constant bit on buttons and d-pad */

 R.A.T.7 uses bits 13, 14, 15 for the mode */

 clear mode bits */

 use bit 13 as the mode button */

 M.M.O.7 uses bits 8, 22, 23 for the mode */

 clear mode bits */

				/* use bit 8 as the mode button, bits 22

				 * and 23 do not represent buttons

				 * according to the HID report descriptor

 report missing release event */

 SPDX-License-Identifier: GPL-2.0

/*

 * HID driver for Maltron L90

 *

 * Copyright (c) 1999 Andreas Gal

 * Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>

 * Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc

 * Copyright (c) 2008 Jiri Slaby

 * Copyright (c) 2012 David Dillow <dave@thedillows.org>

 * Copyright (c) 2006-2013 Jiri Kosina

 * Copyright (c) 2013 Colin Leitner <colin.leitner@gmail.com>

 * Copyright (c) 2014-2016 Frank Praznik <frank.praznik@gmail.com>

 * Copyright (c) 2010 Richard Nauber <Richard.Nauber@gmail.com>

 * Copyright (c) 2016 Yuxuan Shui <yshuiv7@gmail.com>

 * Copyright (c) 2018 William Whistler <wtbw@wtbw.co.uk>

 The original buggy USB descriptor */

 Usage Page (Generic Desktop Ctrls) */

 Usage (Sys Control)                */

 Collection (Application)           */

   Report ID (2)                    */

   Report Size (1)                  */

   Report Count (1)                 */

   Logical Minimum (0)              */

   Logical Maximum (1)              */

   Usage (Sys Sleep)                */

   Input (Data,Var,Rel)             */

   Usage (Sys Sleep)                */

   Input (Data,Var,Rel)             */

   Usage (Sys Wake Up)              */

   Input (Data,Var,Rel)             */

   Report Size (5)                  */

   Input (Const,Array,Abs)          */

 End Collection                     */

 Usage Page (Consumer)              */

 Usage (Consumer Control)           */

 Collection (Application)           */

   Report ID (3)                    */

   Report Count (1)                 */

   Report Size (16)                 */

   Usage Minimum (Unassigned)       */

   Usage Maximum (0x7FFF)           */

   Input (Data,Array,Abs)           */

 End Collection                     */

 Usage Page (Vendor Defined 0xFF7F) */

 Usage (0x01)                       */

 Collection (Application)           */

   Report ID (4)                    */

   Report Count (1)                 */

   Report Size (16)                 */

   Usage Minimum (0x00)             */

   Usage Maximum (0x7FFF)           */

   Input (Data,Array,Abs)           */

   Report Size (2)                  */

   Logical Maximum (2)              */

   Usage (0x90)                     */

   Feature (Data,Var,Abs)           */

   Report Size (6)                  */

   Feature (Const,Array,Abs)        */

   Report Size (1)                  */

   Logical Maximum (1)              */

   Usage Page (LEDs)                */

   Usage (On-Line)                  */

   Output (Data,Var,Abs)            */

   Usage (Generic Indicator)        */

   Output (Data,Var,Abs)            */

   Report Size (6)                  */

   Report Count (1)                 */

   Output (Const,Array,Abs)         */

 End Collection                     */

 The patched descriptor, allowing media key events to be accepted as valid */

 Usage Page (Generic Desktop Ctrls) */

 Usage (Sys Control)                */

 Collection (Application)           */

   Report ID (2)                    */

   Report Size (1)                  */

   Report Count (1)                 */

   Logical Minimum (0)              */

   Logical Maximum (1)              */

   Usage (Sys Sleep)                */

   Input (Data,Var,Rel)             */

   Usage (Sys Sleep)                */

   Input (Data,Var,Rel)             */

   Usage (Sys Wake Up)              */

   Input (Data,Var,Rel)             */

   Report Size (5)                  */

   Input (Const,Array,Abs)          */

 End Collection                     */

 Usage Page (Consumer)              */

 Usage (Consumer Control)           */

 Collection (Application)           */

   Report ID (3)                    */

   Logical Minimum (0)              - changed */

   Logical Maximum (32767)          - changed */

   Report Count (1)                 */

   Report Size (16)                 */

   Usage Minimum (Unassigned)       */

   Usage Maximum (0x7FFF)           */

   Input (Data,Array,Abs)           */

 End Collection                     */

 Usage Page (Vendor Defined 0xFF7F) */

 Usage (0x01)                       */

 Collection (Application)           */

   Report ID (4)                    */

   Report Count (1)                 */

   Report Size (16)                 */

   Usage Minimum (0x00)             */

   Usage Maximum (0x7FFF)           */

   Input (Data,Array,Abs)           */

   Report Size (2)                  */

   Logical Maximum (2)              */

   Usage (0x90)                     */

   Feature (Data,Var,Abs)           */

   Report Size (6)                  */

   Feature (Const,Array,Abs)        */

   Report Size (1)                  */

   Logical Maximum (1)              */

   Usage Page (LEDs)                */

   Usage (On-Line)                  */

   Output (Data,Var,Abs)            */

   Usage (Generic Indicator)        */

   Output (Data,Var,Abs)            */

   Report Size (6)                  */

   Report Count (1)                 */

   Output (Const,Array,Abs)         */

 End Collection                     */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  HID driver for TopSeed Cyberlink remote

 *

 *  Copyright (c) 2008 Lev Babiev

 *  based on hid-cherry driver

 *

 *  Modified to also support BTC "Emprex 3009URF III Vista MCE Remote" by

 *  Wayne Thomas 2010.

 *

 *  Modified to support Conceptronic CLLRCMCE by

 *  Kees Bakker 2010.

/*

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  HID driver for N-Trig touchscreens

 *

 *  Copyright (c) 2008-2010 Rafi Rubin

 *  Copyright (c) 2009-2010 Stephane Chatty

/*

 Incoming raw values for a single contact */

 The current activation state. */

 Empty frames to ignore before recognizing the end of activity */

 Frames to ignore before acknowledging the start of activity */

 Minimum size contact to accept */

 Threshold to override activation slack */

/*

 * This function converts the 4 byte raw firmware code into

 * a string containing 5 comma separated numbers.

	/*

	 * As yet unmapped bits:

	 * 0b11000000 0b11110001 0b00011000 0b00011000

	/*

	 * No more than 8 terminal frames have been observed so far

	 * and higher slack is highly likely to leave the single

	 * touch emulation stuck down.

/*

 * this driver is aimed at two firmware versions in circulation:

 *  - dual pen/finger single touch

 *  - finger multitouch, pen not working

 No special mappings needed for the pen and single touch */

 we do not want to map these for now */

 Not trustworthy, squelch for now */

 width/height mapped on TouchMajor/TouchMinor/Orientation */

 we do not want to map these: no input-oriented meaning */

 No special mappings needed for the pen and single touch */

/*

 * this function is called upon all reports

 * so that we can filter contact point information,

 * decide whether we are in multi or single touch mode

 * and call input_mt_sync after each point if necessary

 Skip processing if not a claimed input */

	/* This function is being called before the structures are fully

 No special handling needed for the pen */

 Tag indicating the start of a multitouch group */

 Prevent emission of touch until validated */

 Clear the contact footer */

		/*

		 * when in single touch mode, this is the last

		 * report received in a finger event. We want

		 * to emit a normal (X, Y) position

			/*

			 * TipSwitch indicates the presence of a

			 * finger in single touch mode.

		/*

		 * we receive this when the device is in multitouch

		 * mode. The first of the three values tagged with

		 * this usage tells if the contact point is real

		 * or a placeholder

 Shouldn't get more than 4 footer packets, so skip */

 if the footer isn't complete break */

 Pen activity signal. */

			/*

			 * When the pen deactivates touch, we see a

			 * bogus frame with ContactCount > 0.

			 * We can

			 * save a bit of work by ensuring act_state < 0

			 * even if deactivation slack is turned off.

		/*

		 * The first footer value indicates the presence of a

		 * finger.

			/*

			 * We do not want to process contacts under

			 * the size threshold, but do not want to

			 * ignore them for activation state

			/*

			 * Contact meets the activation size threshold

					/*

					 * first contact, activate now

					/*

					 * avoid corrupting this frame

					 * but ensure next frame will

					 * be active

				/*

				 * Defer adjusting the activation state

				 * until the end of the frame.

 Discarding this contact */

 emit a normal (X, Y) for the first point only */

			/*

			 * TipSwitch is superfluous in multitouch

			 * mode.  The footer events tell us

			 * if there is a finger on the screen or

			 * not.

 Emit MT events */

		/*

		 * Translate from height and width to size

		 * and orientation.

 End of a multitouch group */

 Just to be sure */

		/*

		 * Activation state machine logic:

		 *

		 * Fundamental states:

		 *	state >  0: Inactive

		 *	state <= 0: Active

		 *	state <  -deactivate_slack:

		 *		 Pen termination of touch

		 *

		 * Specific values of interest

		 *	state == activate_slack

		 *		 no valid input since the last reset

		 *

		 *	state == 0

		 *		 general operational state

		 *

		 *	state == -deactivate_slack

		 *		 read sufficient empty frames to accept

		 *		 the end of input and reset

 Currently inactive */

				/*

				 * Consider each live contact as

				 * evidence of intentional activity.

				/*

				 * Empty frame before we hit the

				 * activity threshold, reset.

			/*

			 * Entered this block inactive and no

			 * coordinates sent this frame, so hold off

			 * on button state.

 Currently active */

				/*

				 * Live point: clear accumulated

				 * deactivation count.

				/*

				 * We've consumed the deactivation

				 * slack, time to deactivate and reset.

 Move towards deactivation */

			/*

			 * Check to see if we're ready to start

			 * emitting touch events.

			 *

			 * Note: activation slack will decrease over

			 * the course of the frame, and it will be

			 * inconsistent from the start to the end of

			 * the frame.  However if the frame starts

			 * with slack, first_contact_touch will still

			 * be 0 and we will not get to this point.

 fall-back to the generic hidinput handling */

 we have handled the hidinput part, now remains hiddev */

		/* These keys are redundant for fingers, clear them

		/*

		 * The physical touchscreen (single touch)

		 * input has a value for physical, whereas

		 * the multitouch only has logical input

		 * fields.

 This is needed for devices with more recent firmware versions */

		/* Let the device settle to ensure the wakeup message gets

		/*

		 * Sanity check: if the current mode is invalid reset it to

		 * something reasonable.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  HID quirks support for Linux

 *

 *  Copyright (c) 1999 Andreas Gal

 *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>

 *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc

 *  Copyright (c) 2006-2007 Jiri Kosina

 *  Copyright (c) 2007 Paul Walmsley

/*

/*

 * Alphabetically sorted by vendor then product.

/*

 * A list of devices for which there is a specialized driver on HID bus.

 *

 * Please note that for multitouch devices (driven by hid-multitouch driver),

 * there is a proper autodetection and autoloading in place (based on presence

 * of HID_DG_CONTACTID), so those devices don't need to be added to this list,

 * as we are doing the right thing in hid_scan_usage().

 *

 * Autodetection for (USB) HID sensor hubs exists too. If a collection of type

 * physical is found inside a usage page of type sensor, hid-sensor-hub will be

 * used as a driver. See hid_scan_report().

 a list of devices that shouldn't be handled by HID core at all */

/*

 * hid_mouse_ignore_list - mouse devices which should not be handled by the hid layer

 *

 * There are composite devices for which we want to ignore only a certain

 * interface. This is a list of devices for which only the mouse interface will

 * be ignored. This allows a dedicated driver to take care of the interface.

 appletouch driver */

 ignore all Code Mercenaries IOWarrior devices */

		/*

		 * The Keene FM transmitter USB device has the same USB ID as

		 * the Logitech AudioHub Speaker, but it should ignore the hid.

		 * Check if the name is that of the Keene device.

		 * For reference: the name of the AudioHub is

		 * "HOLTEK  AudioHub Speaker".

 These are not HID devices.  They are handled by comedi. */

		/* Masterkit MA901 usb radio based on Atmel tiny85 chip and

		 * it has the same USB ID as many Atmel V-USB devices. This

		 * usb radio is handled by radio-ma901.c driver so we want

		 * ignore the hid. Check the name, bus, product and ignore

		 * if we have MA901 usb radio.

		/*

		 * Blacklist of everything that gets handled by the elan_i2c

		 * input driver.  This avoids disabling valid touchpads and

		 * other ELAN devices.

 Dynamic HID quirks list - specified at runtime */

 Runtime ("dynamic") quirks manipulation functions */

/**

 * hid_exists_dquirk - find any dynamic quirks for a HID device

 * @hdev: the HID device to match

 *

 * Description:

 *         Scans dquirks_list for a matching dynamic quirk and returns

 *         the pointer to the relevant struct hid_device_id if found.

 *         Must be called with a read lock held on dquirks_lock.

 *

 * Return: NULL if no quirk found, struct hid_device_id * if found.

/**

 * hid_modify_dquirk - add/replace a HID quirk

 * @id: the HID device to match

 * @quirks: the unsigned long quirks value to add/replace

 *

 * Description:

 *         If an dynamic quirk exists in memory for this device, replace its

 *         quirks value with what was provided.  Otherwise, add the quirk

 *         to the dynamic quirks list.

 *

 * Return: 0 OK, -error on failure.

/**

 * hid_remove_all_dquirks - remove all runtime HID quirks from memory

 * @bus: bus to match against. Use HID_BUS_ANY if all need to be removed.

 *

 * Description:

 *         Free all memory associated with dynamic quirks - called before

 *         module unload.

 *

/**

 * hid_quirks_init - apply HID quirks specified at module load time

 * @quirks_param: array of quirks strings (vendor:product:quirks)

 * @bus: bus type

 * @count: number of quirks to check

/**

 * hid_quirks_exit - release memory associated with dynamic_quirks

 * @bus: a bus to match against

 *

 * Description:

 *     Release all memory associated with dynamic quirks for a given bus.

 *     Called upon module unload.

 *     Use HID_BUS_ANY to remove all dynamic quirks.

 *

 * Returns: nothing

/**

 * hid_gets_squirk - return any static quirks for a HID device

 * @hdev: the HID device to match

 *

 * Description:

 *     Given a HID device, return a pointer to the quirked hid_device_id entry

 *     associated with that device.

 *

 * Return: the quirks.

/**

 * hid_lookup_quirk - return any quirks associated with a HID device

 * @hdev: the HID device to look for

 *

 * Description:

 *     Given a HID device, return any quirks associated with that device.

 *

 * Return: an unsigned long quirks value.

 NCR devices must not be queried for reports */

 These devices must be ignored if version (bcdDevice) is too old */

 SPDX-License-Identifier: GPL-2.0-only

/***************************************************************************

 *   Copyright (C) 2010-2012 by Bruno Prémont <bonbons@linux-vserver.org>  *

 *                                                                         *

 *   Based on Logitech G13 driver (v0.4)                                   *

 *     Copyright (C) 2009 by Rick L. Vinyard, Jr. <rvinyard@cs.nmsu.edu>   *

 *                                                                         *

 CONFIG_PM */

 SPDX-License-Identifier: GPL-2.0+

/*

 * Surface System Aggregator Module (SSAM) HID transport driver for the legacy

 * keyboard interface (KBD/TC=0x08 subsystem). Provides support for the

 * integrated HID keyboard on Surface Laptops 1 and 2.

 *

 * Copyright (C) 2019-2021 Maximilian Luz <luzmaximilian@gmail.com>

 -- SAM interface (KBD). -------------------------------------------------- */

 6 + report ID */

	/*

	 * Check against device UID manually, as registry and device target

	 * category doesn't line up.

 -- Transport driver (KBD). ----------------------------------------------- */

 Get LED field. */

 Check if we got the correct report. */

 Get caps lock LED index. */

 Extract value. */

 Only caps LED output reports are supported. */

	/*

	 * The keyboard only has a single hard-coded read-only feature report

	 * of size KBD_FEATURE_REPORT_SIZE. Try to load it and compare its

	 * report ID against the requested one.

 Not supported. See skbd_get_feature_report() for details. */

 -- Driver setup. --------------------------------------------------------- */

 Add device link to EC. */

 SPDX-License-Identifier: GPL-2.0+

/*

 * Surface System Aggregator Module (SSAM) HID transport driver for the

 * generic HID interface (HID/TC=0x15 subsystem). Provides support for

 * integrated HID devices on Surface Laptop 3, Book 3, and later.

 *

 * Copyright (C) 2019-2021 Blaž Hrastnik <blaz@mxxn.io>,

 *                         Maximilian Luz <luzmaximilian@gmail.com>

 -- SAM interface. -------------------------------------------------------- */

	/*

	 * Note: The 0x76 above has been chosen because that's what's used by

	 * the Windows driver. Together with the header, this leads to a 128

	 * byte payload in total.

 Don't mess stuff up in case we receive garbage. */

 -- Transport driver. ----------------------------------------------------- */

 -- Driver setup. --------------------------------------------------------- */

 SPDX-License-Identifier: GPL-2.0+

/*

 * Common/core components for the Surface System Aggregator Module (SSAM) HID

 * transport driver. Provides support for integrated HID devices on Microsoft

 * Surface models.

 *

 * Copyright (C) 2019-2021 Maximilian Luz <luzmaximilian@gmail.com>

 -- Device descriptor access. --------------------------------------------- */

 -- Transport driver (common). -------------------------------------------- */

 Note: This call will log errors for us, so ignore them here. */

 -- Common device setup. -------------------------------------------------- */

 -- PM ops. --------------------------------------------------------------- */

 CONFIG_PM_SLEEP */

 CONFIG_PM_SLEEP */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ISHTP client driver for HID (ISH)

 *

 * Copyright (c) 2014-2016, Intel Corporation.

 ISH Transport protocol (ISHTP in short) GUID */

 Rx ring buffer pool size */

/**

 * report_bad_packet() - Report bad packets

 * @hid_ishtp_cl:	Client instance to get stats

 * @recv_buf:		Raw received host interface message

 * @cur_pos:		Current position index in payload

 * @payload_len:	Length of payload expected

 *

 * Dumps error in case bad packet is received

/**

 * process_recv() - Received and parse incoming packet

 * @hid_ishtp_cl:	Client instance to get stats

 * @recv_buf:		Raw received host interface message

 * @data_len:		length of the message

 *

 * Parse the incoming packet. If it is a response packet then it will update

 * per instance flags and wake up the caller waiting to for the response.

 Sanity checks */

 Get index of device that matches this id */

 Get index of device that matches this id */

/**

 * ish_cl_event_cb() - bus driver callback for incoming message/packet

 * @device:	Pointer to the the ishtp client device for which this message

 *		is targeted

 *

 * Remove the packet from the list and process the message by calling

 * process_recv

 decide what to do with received data */

/**

 * hid_ishtp_set_feature() - send request to ISH FW to set a feature request

 * @hid:	hid device instance for this request

 * @buf:	feature buffer

 * @len:	Length of feature buffer

 * @report_id:	Report id for the feature set request

 *

 * This is called from hid core .request() callback. This function doesn't wait

 * for response.

/**

 * hid_ishtp_get_report() - request to get feature/input report

 * @hid:	hid device instance for this request

 * @report_id:	Report id for the get request

 * @report_type:	Report type for the this request

 *

 * This is called from hid core .request() callback. This function will send

 * request to FW and return without waiting for response.

/**

 * ishtp_hid_link_ready_wait() - Wait for link ready

 * @client_data:	client data instance

 *

 * If the transport link started suspend process, then wait, till either

 * resumed or timeout

 *

 * Return: 0 on success, non zero on error

/**

 * ishtp_enum_enum_devices() - Enumerate hid devices

 * @hid_ishtp_cl:	client instance

 *

 * Helper function to send request to firmware to enumerate HID devices

 *

 * Return: 0 on success, non zero on error

 Send HOSTIF_DM_ENUM_DEVICES */

 Send HOSTIF_DM_ENUM_DEVICES */

/**

 * ishtp_get_hid_descriptor() - Get hid descriptor

 * @hid_ishtp_cl:	client instance

 * @index:		Index into the hid_descr array

 *

 * Helper function to send request to firmware get HID descriptor of a device

 *

 * Return: 0 on success, non zero on error

 Get HID descriptor */

/**

 * ishtp_get_report_descriptor() - Get report descriptor

 * @hid_ishtp_cl:	client instance

 * @index:		Index into the hid_descr array

 *

 * Helper function to send request to firmware get HID report descriptor of

 * a device

 *

 * Return: 0 on success, non zero on error

 Get report descriptor */

/**

 * hid_ishtp_cl_init() - Init function for ISHTP client

 * @hid_ishtp_cl:	ISHTP client instance

 * @reset:		true if called for init after reset

 *

 * This function complete the initializtion of the client. The summary of

 * processing:

 * - Send request to enumerate the hid clients

 *	Get the HID descriptor for each enumearated device

 *	Get report description of each device

 *	Register each device wik hid core by calling ishtp_hid_probe

 *

 * Return: 0 on success, non zero on error

 Connect to FW client */

 Register read callback */

 for() on all hid devices */

/**

 * hid_ishtp_cl_deinit() - Deinit function for ISHTP client

 * @hid_ishtp_cl:	ISHTP client instance

 *

 * Unlink and free hid client

 disband and free all Tx and Rx client-level rings */

/**

 * hid_ishtp_cl_probe() - ISHTP client driver probe

 * @cl_device:		ISHTP client device instance

 *

 * This function gets called on device create on ISHTP bus

 *

 * Return: 0 on success, non zero on error

/**

 * hid_ishtp_cl_remove() - ISHTP client driver remove

 * @cl_device:		ISHTP client device instance

 *

 * This function gets called on device remove on ISHTP bus

 *

 * Return: 0

/**

 * hid_ishtp_cl_reset() - ISHTP client driver reset

 * @cl_device:		ISHTP client device instance

 *

 * This function gets called on device reset on ISHTP bus

 *

 * Return: 0

/**

 * hid_ishtp_cl_suspend() - ISHTP client driver suspend

 * @device:	device instance

 *

 * This function gets called on system suspend

 *

 * Return: 0

/**

 * hid_ishtp_cl_resume() - ISHTP client driver resume

 * @device:	device instance

 *

 * This function gets called on system resume

 *

 * Return: 0

 Register ISHTP client device driver with ISHTP Bus */

 Primary author */

/*

 * Several modification for multi instance support

 * suspend/resume and clean up

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ISHTP-HID glue driver.

 *

 * Copyright (c) 2012-2016, Intel Corporation.

/**

 * ishtp_hid_parse() - hid-core .parse() callback

 * @hid:	hid device instance

 *

 * This function gets called during call to hid_add_device

 *

 * Return: 0 on success and non zero on error

 Empty callbacks with success return code */

		/*

		 * Spare 7 bytes for 64b accesses through

		 * get/put_unaligned_le64()

/**

 * ishtp_hid_request() - hid-core .request() callback

 * @hid:	hid device instance

 * @rep:	pointer to hid_report

 * @reqtype:	type of req. [GET|SET]_REPORT

 *

 * This function is used to set/get feaure/input report.

 the specific report length, just HID part of it */

		/*

		 * Spare 7 bytes for 64b accesses through

		 * get/put_unaligned_le64()

/**

 * ishtp_wait_for_response() - hid-core .wait() callback

 * @hid:	hid device instance

 *

 * This function is used to wait after get feaure/input report.

 *

 * Return: 0 on success and non zero on error

/**

 * ishtp_hid_wakeup() - Wakeup caller

 * @hid:	hid device instance

 *

 * This function will wakeup caller waiting for Get/Set feature report

/**

 * ishtp_hid_probe() - hid register ll driver

 * @cur_hid_dev:	Index of hid device calling to register

 * @client_data:	Client data pointer

 *

 * This function is used to allocate and add HID device.

 *

 * Return: 0 on success, non zero on error

/**

 * ishtp_hid_remove() - Remove registered hid device

 * @client_data:	client data pointer

 *

 * This function is used to destroy allocatd HID device.

 SPDX-License-Identifier: GPL-2.0

/*

 * ISH-TP client driver for ISH firmware loading

 *

 * Copyright (c) 2019, Intel Corporation.

 Number of times we attempt to load the firmware before giving up */

 ISH TX/RX ring buffer pool size */

/*

 * ISH Shim firmware loader reserves 4 Kb buffer in SRAM. The buffer is

 * used to temporarily hold the data transferred from host to Shim

 * firmware loader. Reason for the odd size of 3968 bytes? Each IPC

 * transfer is 128 bytes (= 4 bytes header + 124 bytes payload). So the

 * 4 Kb buffer can hold maximum of 32 IPC transfers, which means we can

 * have a max payload of 3968 bytes (= 32 x 124 payload).

/**

 * enum ish_loader_commands -	ISH loader host commands.

 * @LOADER_CMD_XFER_QUERY:	Query the Shim firmware loader for

 *				capabilities

 * @LOADER_CMD_XFER_FRAGMENT:	Transfer one firmware image fragment at a

 *				time. The command may be executed

 *				multiple times until the entire firmware

 *				image is downloaded to SRAM.

 * @LOADER_CMD_START:		Start executing the main firmware.

 Command bit mask */

/*

 * ISH firmware max delay for one transmit failure is 1 Hz,

 * and firmware will retry 2 times, so 3 Hz is used for timeout.

/*

 * Loader transfer modes:

 *

 * LOADER_XFER_MODE_ISHTP mode uses the existing ISH-TP mechanism to

 * transfer data. This may use IPC or DMA if supported in firmware.

 * The buffer size is limited to 4 Kb by the IPC/ISH-TP protocol for

 * both IPC & DMA (legacy).

 *

 * LOADER_XFER_MODE_DIRECT_DMA - firmware loading is a bit different

 * from the sensor data streaming. Here we download a large (300+ Kb)

 * image directly to ISH SRAM memory. There is limited benefit of

 * DMA'ing 300 Kb image in 4 Kb chucks limit. Hence, we introduce

 * this "direct dma" mode, where we do not use ISH-TP for DMA, but

 * instead manage the DMA directly in kernel driver and Shim firmware

 * loader (allocate buffer, break in chucks and transfer). This allows

 * to overcome 4 Kb limit, and optimize the data flow path in firmware.

 ISH Transport Loader client unique GUID */

/*

 * The firmware loading latency will be minimum if we can DMA the

 * entire ISH firmware image in one go. This requires that we allocate

 * a large DMA buffer in kernel, which could be problematic on some

 * platforms. So here we limit the DMA buffer size via a module_param.

 * We default to 4 pages, but a customer can set it to higher limit if

 * deemed appropriate for his platform.

/**

 * struct loader_msg_hdr - Header for ISH Loader commands.

 * @command:		LOADER_CMD* commands. Bit 7 is the response.

 * @reserved:		Reserved space

 * @status:		Command response status. Non 0, is error

 *			condition.

 *

 * This structure is used as header for every command/data sent/received

 * between Host driver and ISH Shim firmware loader.

 only for dma mode, multiples of cacheline */

 variable length payload here */

/**

 * struct response_info - Encapsulate firmware response related

 *			information for passing between function

 *			loader_cl_send() and process_recv() callback.

 * @data:		Copy the data received from firmware here.

 * @max_size:		Max size allocated for the @data buffer. If the

 *			received data exceeds this value, we log an

 *			error.

 * @size:		Actual size of data received from firmware.

 * @error:		Returns 0 for success, negative error code for a

 *			failure in function process_recv().

 * @received:		Set to true on receiving a valid firmware

 *			response to host command

 * @wait_queue:		Wait queue for Host firmware loading where the

 *			client sends message to ISH firmware and waits

 *			for response

/*

 * struct ishtp_cl_data - Encapsulate per ISH-TP Client Data.

 * @work_ishtp_reset:	Work queue for reset handling.

 * @work_fw_load:	Work queue for host firmware loading.

 * @flag_retry:		Flag for indicating host firmware loading should

 *			be retried.

 * @retry_count:	Count the number of retries.

 *

 * This structure is used to store data per client.

	/*

	 * Used for passing firmware response information between

	 * loader_cl_send() and process_recv() callback.

	/*

	 * In certain failure scenrios, it makes sense to reset the ISH

	 * subsystem and retry Host firmware loading (e.g. bad message

	 * packet, ENOMEM, etc.). On the other hand, failures due to

	 * protocol mismatch, etc., are not recoverable. We do not

	 * retry them.

	 *

	 * If set, the flag indicates that we should re-try the

	 * particular failure.

/**

 * get_firmware_variant() - Gets the filename of firmware image to be

 *			loaded based on platform variant.

 * @client_data:	Client data instance.

 * @filename:		Returns firmware filename.

 *

 * Queries the firmware-name device property string.

 *

 * Return: 0 for success, negative error code for failure.

/**

 * loader_cl_send()	Send message from host to firmware

 * @client_data:	Client data instance

 * @out_msg:		Message buffer to be sent to firmware

 * @out_size:		Size of out going message

 * @in_msg:		Message buffer where the incoming data copied.

 *			This buffer is allocated by calling

 * @in_size:		Max size of incoming message

 *

 * Return: Number of bytes copied in the in_msg on success, negative

 * error code on failure.

 Setup in coming buffer & size */

/**

 * process_recv() -	Receive and parse incoming packet

 * @loader_ishtp_cl:	Client instance to get stats

 * @rb_in_proc:		ISH received message buffer

 *

 * Parse the incoming packet. If it is a response packet then it will

 * update received and wake up the caller waiting to for the response.

 Sanity check */

	/*

	 * All firmware messages have a header. Check buffer size

	 * before accessing elements inside.

 We expect only "response" messages from firmware */

 Update the actual received buffer size */

	/*

	 * Copy the buffer received in firmware response for the

	 * calling thread.

 Set flag before waking up the caller */

 Free the buffer */

 Wake the calling thread */

/**

 * loader_cl_event_cb() - bus driver callback for incoming message

 * @cl_device:		Pointer to the ishtp client device for which this

 *			message is targeted

 *

 * Remove the packet from the list and process the message by calling

 * process_recv

 Process the data packet from firmware */

/**

 * ish_query_loader_prop() -  Query ISH Shim firmware loader

 * @client_data:	Client data instance

 * @fw:			Pointer to firmware data struct in host memory

 * @fw_info:		Loader firmware properties

 *

 * This function queries the ISH Shim firmware loader for capabilities.

 *

 * Return: 0 for success, negative error code for failure.

 On success, the return value is the received buffer size */

 Save fw_info for use outside this function */

 Loader firmware properties */

 Sanity checks */

 For DMA the buffer size should be multiple of cacheline size */

/**

 * ish_fw_xfer_ishtp() - Loads ISH firmware using ishtp interface

 * @client_data:	Client data instance

 * @fw:			Pointer to firmware data struct in host memory

 *

 * This function uses ISH-TP to transfer ISH firmware from host to

 * ISH SRAM. Lower layers may use IPC or DMA depending on firmware

 * support.

 *

 * Return: 0 for success, negative error code for failure.

 Break the firmware image into fragments and send as ISH-TP payload */

 Free ISH buffer if not done already, in error case */

/**

 * ish_fw_xfer_direct_dma() - Loads ISH firmware using direct dma

 * @client_data:	Client data instance

 * @fw:			Pointer to firmware data struct in host memory

 * @fw_info:		Loader firmware properties

 *

 * Host firmware load is a unique case where we need to download

 * a large firmware image (200+ Kb). This function implements

 * direct DMA transfer in kernel and ISH firmware. This allows

 * us to overcome the ISH-TP 4 Kb limit, and allows us to DMA

 * directly to ISH UMA at location of choice.

 * Function depends on corresponding support in ISH firmware.

 *

 * Return: 0 for success, negative error code for failure.

	/*

	 * payload_max_size should be set to minimum of

	 *  (1) Size of firmware to be loaded,

	 *  (2) Max DMA buffer size supported by Shim firmware,

	 *  (3) DMA buffer size limit set by boot_param dma_buf_size_limit.

	/*

	 * Buffer size should be multiple of cacheline size

	 * if it's not, select the previous cacheline boundary.

 Send the firmware image in chucks of payload_max_size */

		/*

		 * Flush cache here because the dma_sync_single_for_device()

		 * does not do for x86.

 Free ISH buffer if not done already, in error case */

/**

 * ish_fw_start() -	Start executing ISH main firmware

 * @client_data:	client data instance

 *

 * This function sends message to Shim firmware loader to start

 * the execution of ISH main firmware.

 *

 * Return: 0 for success, negative error code for failure.

/**

 * load_fw_from_host() - Loads ISH firmware from host

 * @client_data:	Client data instance

 *

 * This function loads the ISH firmware to ISH SRAM and starts execution

 *

 * Return: 0 for success, negative error code for failure.

 Get filename of the ISH firmware to be loaded */

 Step 1: Query Shim firmware loader properties */

 Step 2: Send the main firmware image to be loaded, to ISH SRAM */

 Step 3: Start ISH main firmware exeuction */

 Keep a count of retries, and give up after 3 attempts */

/**

 * loader_init() -	Init function for ISH-TP client

 * @loader_ishtp_cl:	ISH-TP client instance

 * @reset:		true if called for init after reset

 *

 * Return: 0 for success, negative error code for failure

 Connect to firmware client */

 Disband and free all Tx and Rx client-level rings */

 Unlink, flush queues & start again */

 ISH firmware loading from host */

/**

 * loader_ishtp_cl_probe() - ISH-TP client driver probe

 * @cl_device:		ISH-TP client device instance

 *

 * This function gets called on device create on ISH-TP bus

 *

 * Return: 0 for success, negative error code for failure

 ISH firmware loading from host */

/**

 * loader_ishtp_cl_remove() - ISH-TP client driver remove

 * @cl_device:		ISH-TP client device instance

 *

 * This function gets called on device remove on ISH-TP bus

 *

 * Return: 0

	/*

	 * The sequence of the following two cancel_work_sync() is

	 * important. The work_fw_load can in turn schedue

	 * work_ishtp_reset, so first cancel work_fw_load then

	 * cancel work_ishtp_reset.

/**

 * loader_ishtp_cl_reset() - ISH-TP client driver reset

 * @cl_device:		ISH-TP client device instance

 *

 * This function gets called on device reset on ISH-TP bus

 *

 * Return: 0

 SPDX-License-Identifier: GPL-2.0-only

/*

 * PCI glue for ISHTP provider device (ISH) driver

 *

 * Copyright (c) 2014-2016, Intel Corporation.

/**

 * ish_event_tracer() - Callback function to dump trace messages

 * @dev:	ishtp device

 * @format:	printf style format

 *

 * Callback to direct log messages to Linux trace buffers

/**

 * ish_init() - Init function

 * @dev:	ishtp device

 *

 * This function initialize wait queues for suspend/resume and call

 * calls hadware initialization function. This will initiate

 * startup sequence

 *

 * Return: 0 for success or error code for failure

 Set the state of ISH HW to start */

 Start the inter process communication to ISH processor */

 Mehlow platform special pci ids */

/**

 * ish_probe() - PCI driver probe callback

 * @pdev:	pci device

 * @ent:	pci device id

 *

 * Initialize PCI function, setup interrupt and call for ISH initialization

 *

 * Return: 0 for success or error code for failure

 Check for invalid platforms for ISH support */

 enable pci dev */

 set PCI host mastering */

 pci request regions for ISH driver */

 allocates and initializes the ISH dev structure */

 mapping IO device memory */

 request and enable interrupt */

 Enable PME for EHL */

/**

 * ish_remove() - PCI driver remove callback

 * @pdev:	pci device

 *

 * This function does cleanup of ISH on pci remove callback

 50ms to get resume response */

/**

 * ish_resume_handler() - Work function to complete resume

 * @work:	work struct

 *

 * The resume work function to complete resume function asynchronously.

 * There are two resume paths, one where ISH is not powered off,

 * in that case a simple resume message is enough, others we need

 * a reset sequence.

 Waiting to get resume response */

		/*

		 * If the flag is not cleared, something is wrong with ISH FW.

		 * So on resume, need to go through init sequence again.

		/*

		 * Resume from the D3, full reboot of ISH processor will happen,

		 * so need to go through init sequence again.

/**

 * ish_suspend() - ISH suspend callback

 * @device:	device pointer

 *

 * ISH suspend callback

 *

 * Return: 0 to the pm core

		/*

		 * If previous suspend hasn't been asnwered then ISH is likely

		 * dead, don't attempt nested notification

 25 ms should be enough for live ISH to flush all IPC buf */

			/*

			 * It looks like FW halt, clear the DMA bit, and put

			 * ISH into D3, and FW would reset on resume.

			/*

			 * Save state so PCI core will keep the device at D0,

			 * the ISH would enter D0i3

		/*

		 * Clear the DMA bit before putting ISH into D3,

		 * or ISH FW would reset automatically.

/**

 * ish_resume() - ISH resume callback

 * @device:	device pointer

 *

 * ISH resume callback

 *

 * Return: 0 to the pm core

 add this to finish power flow for EHL */

 Original author */

 Adoption to upstream Linux kernel */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * H/W layer of ISHTP provider device (ISH)

 *

 * Copyright (c) 2014-2016, Intel Corporation.

 For FW reset flow */

/**

 * ish_reg_read() - Read register

 * @dev: ISHTP device pointer

 * @offset: Register offset

 *

 * Read 32 bit register at a given offset

 *

 * Return: Read register value

/**

 * ish_reg_write() - Write register

 * @dev: ISHTP device pointer

 * @offset: Register offset

 * @value: Value to write

 *

 * Writes 32 bit register at a give offset

/**

 * _ish_read_fw_sts_reg() - Read FW status register

 * @dev: ISHTP device pointer

 *

 * Read FW status register

 *

 * Return: Read register value

/**

 * check_generated_interrupt() - Check if ISH interrupt

 * @dev: ISHTP device pointer

 *

 * Check if an interrupt was generated for ISH

 *

 * Return: Read true or false

 only busy-clear bit is RW, others are RO */

/**

 * ish_is_input_ready() - Check if FW ready for RX

 * @dev: ISHTP device pointer

 *

 * Check if ISH FW is ready for receiving data

 *

 * Return: Read true or false

/**

 * set_host_ready() - Indicate host ready

 * @dev: ISHTP device pointer

 *

 * Set host ready indication to FW

			/*

			 * disable interrupt generated instead of

			 * RX_complete_msg

/**

 * ishtp_fw_is_ready() - Check if FW ready

 * @dev: ISHTP device pointer

 *

 * Check if ISH FW is ready

 *

 * Return: Read true or false

/**

 * ish_set_host_rdy() - Indicate host ready

 * @dev: ISHTP device pointer

 *

 * Set host ready indication to FW

/**

 * ish_clr_host_rdy() - Indicate host not ready

 * @dev: ISHTP device pointer

 *

 * Send host not ready indication to FW

/**

 * ish_set_host_ready() - reconfig ipc host registers

 * @dev: ishtp device pointer

 *

 * Set host to ready state

 * This API is called in some case:

 *    fw is still on, but ipc is powered down.

 *    such as OOB case.

 *

 * Return: 0 for success else error fault code

/**

 * _ishtp_read_hdr() - Read message header

 * @dev: ISHTP device pointer

 *

 * Read header of 32bit length

 *

 * Return: Read register value

/**

 * _ishtp_read - Read message

 * @dev: ISHTP device pointer

 * @buffer: message buffer

 * @buffer_length: length of message buffer

 *

 * Read message from FW

 *

 * Return: Always 0

/**

 * write_ipc_from_queue() - try to write ipc msg from Tx queue to device

 * @dev: ishtp device pointer

 *

 * Check if DRBL is cleared. if it is - write the first IPC msg,  then call

 * the callback function (unless it's NULL)

 *

 * Return: 0 for success else failure code

	/*

	 * if tx send list is empty - return 0;

	 * may happen, as RX_COMPLETE handler doesn't check list emptiness.

 first 4 bytes of the data is the doorbell value (IPC header) */

 If sending MNG_SYNC_FW_CLOCK, update clock again */

 Flush writes to msg registers and doorbell */

 Update IPC counters */

	/*

	 * callback will be called out of spinlock,

	 * after ipc_link returned to free list

/**

 * write_ipc_to_queue() - write ipc msg to Tx queue

 * @dev: ishtp device instance

 * @ipc_send_compl: Send complete callback

 * @ipc_send_compl_prm:	Parameter to send in complete callback

 * @msg: Pointer to message

 * @length: Length of message

 *

 * Recived msg with IPC (and upper protocol) header  and add it to the device

 *  Tx-to-write list then try to send the first IPC waiting msg

 *  (if DRBL is cleared)

 * This function returns negative value for failure (means free list

 *  is empty, or msg too long) and 0 for success.

 *

 * Return: 0 for success else failure code

/**

 * ipc_send_mng_msg() - Send management message

 * @dev: ishtp device instance

 * @msg_code: Message code

 * @msg: Pointer to message

 * @size: Length of message

 *

 * Send management message to FW

 *

 * Return: 0 for success else failure code

/**

 * timed_wait_for_timeout() - wait special event with timeout

 * @dev: ISHTP device pointer

 * @condition: indicate the condition for waiting

 * @timeinc: time slice for every wait cycle, in ms

 * @timeout: time in ms for timeout

 *

 * This function will check special event to be ready in a loop, the loop

 * period is specificd in timeinc. Wait timeout will causes failure.

 *

 * Return: 0 for success else failure code

/**

 * ish_fw_reset_handler() - FW reset handler

 * @dev: ishtp device pointer

 *

 * Handle FW reset

 *

 * Return: 0 for success else failure code

 Read reset ID */

 Clear IPC output queue */

 ISHTP notification in IPC_RESET */

 ISH FW is dead */

	/*

	 * Set HOST2ISH.ILUP. Apparently we need this BEFORE sending

	 * RESET_NOTIFY_ACK - FW will be checking for it

 Send RESET_NOTIFY_ACK (with reset_id) */

 Wait for ISH FW'es ILUP and ISHTP_READY */

 ISH FW is dead */

/**

 * fw_reset_work_fn() - FW reset worker function

 * @unused: not used

 *

 * Call ish_fw_reset_handler to complete FW reset

 ISH is ILUP & ISHTP-ready. Restart ISHTP */

 ISHTP notification in IPC_RESET sequence completion */

/**

 * _ish_sync_fw_clock() -Sync FW clock with the OS clock

 * @dev: ishtp device pointer

 *

 * Sync FW and OS time

/**

 * recv_ipc() - Receive and process IPC management messages

 * @dev: ishtp device instance

 * @doorbell_val: doorbell value

 *

 * This function runs in ISR context.

 * NOTE: Any other mng command than reset_notify and reset_notify_ack

 * won't wake BH handler

/**

 * ish_irq_handler() - ISH IRQ handler

 * @irq: irq number

 * @dev_id: ishtp device pointer

 *

 * ISH IRQ handler. If interrupt is generated and is for ISH it will process

 * the interrupt.

 Check that it's interrupt from ISH (may be shared) */

 Sanity check: IPC dgram length in header */

 Update IPC counters */

 Flush write to doorbell */

/**

 * ish_disable_dma() - disable dma communication between host and ISHFW

 * @dev: ishtp device pointer

 *

 * Clear the dma enable bit and wait for dma inactive.

 *

 * Return: 0 for success else error code.

 Clear the dma enable bit */

 wait for dma inactive */

/**

 * ish_wakeup() - wakeup ishfw from waiting-for-host state

 * @dev: ishtp device pointer

 *

 * Set the dma enable bit and send a void message to FW,

 * it wil wakeup FW from waiting-for-host state.

 Set dma enable bit */

	/*

	 * Send 0 IPC message so that ISH FW wakes up if it was already

	 * asleep.

 Flush writes to doorbell and REMAP2 */

/**

 * _ish_hw_reset() - HW reset

 * @dev: ishtp device pointer

 *

 * Reset ISH HW to recover if any error

 *

 * Return: 0 for success else error fault code

 Disable dma communication between FW and host */

 Now we can enable ISH DMA operation and wakeup ISHFW */

/**

 * _ish_ipc_reset() - IPC reset

 * @dev: ishtp device pointer

 *

 * Resets host and fw IPC and upper layers

 *

 * Return: 0 for success else error fault code

 Clear the incoming doorbell */

 Flush write to doorbell */

 send message */

/**

 * ish_hw_start() -Start ISH HW

 * @dev: ishtp device pointer

 *

 * Set host to ready state and wait for FW reset

 *

 * Return: 0 for success else error fault code

 After that we can enable ISH DMA operation and wakeup ISHFW */

 wait for FW-initiated reset flow */

/**

 * ish_ipc_get_header() -Get doorbell value

 * @dev: ishtp device pointer

 * @length: length of message

 * @busy: busy status

 *

 * Get door bell value from message header

 *

 * Return: door bell value

/**

 * _dma_no_cache_snooping()

 *

 * Check on current platform, DMA supports cache snooping or not.

 * This callback is used to notify uplayer driver if manully cache

 * flush is needed when do DMA operation.

 *

 * Please pay attention to this callback implementation, if declare

 * having cache snooping on a cache snooping not supported platform

 * will cause uplayer driver receiving mismatched data; and if

 * declare no cache snooping on a cache snooping supported platform

 * will cause cache be flushed twice and performance hit.

 *

 * @dev: ishtp device pointer

 *

 * Return: false - has cache snooping capability

 *         true - no cache snooping, need manually cache flush

/**

 * ish_dev_init() -Initialize ISH devoce

 * @pdev: PCI device

 *

 * Allocate ISHTP device and initialize IPC processing

 *

 * Return: ISHTP device instance on success else NULL

 Init IPC processing and free lists */

			/*

			 * IPC buffers may be limited or not available

			 * at all - although this shouldn't happen

/**

 * ish_device_disable() - Disable ISH device

 * @dev: ISHTP device pointer

 *

 * Disable ISH by clearing host ready to inform firmware.

 Disable dma communication between FW and host */

 Put ISH to D3hot state for power saving */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ISHTP bus driver

 *

 * Copyright (c) 2012-2016, Intel Corporation.

/**

 * ishtp_recv() - process ishtp message

 * @dev: ishtp device

 *

 * If a message with valid header and size is received, then

 * this function calls appropriate handler. The host or firmware

 * address is zero, then they are host bus management message,

 * otherwise they are message fo clients.

 Read ISHTP header dword */

 Sanity check: ISHTP frag. length in header */

 ISHTP bus message */

 ISHTP fixed-client message */

 ISHTP client message */

/**

 * ishtp_send_msg() - Send ishtp message

 * @dev: ishtp device

 * @hdr: Message header

 * @msg: Message contents

 * @ipc_send_compl: completion callback

 * @ipc_send_compl_prm: completion callback parameter

 *

 * Send a multi fragment message via IPC. After sending the first fragment

 * the completion callback is called to schedule transmit of next fragment.

 *

 * Return: This returns IPC send message status.

/**

 * ishtp_write_message() - Send ishtp single fragment message

 * @dev: ishtp device

 * @hdr: Message header

 * @buf: message data

 *

 * Send a single fragment message via IPC.  This returns IPC send message

 * status.

 *

 * Return: This returns IPC send message status.

/**

 * ishtp_fw_cl_by_uuid() - locate index of fw client

 * @dev: ishtp device

 * @uuid: uuid of the client to search

 *

 * Search firmware client using UUID.

 *

 * Return: fw client index or -ENOENT if not found

/**

 * ishtp_fw_cl_get_client() - return client information to client

 * @dev: the ishtp device structure

 * @uuid: uuid of the client to search

 *

 * Search firmware client using UUID and reture related client information.

 *

 * Return: pointer of client information on success, NULL on failure.

/**

 * ishtp_get_fw_client_id() - Get fw client id

 * @fw_client:	firmware client used to fetch the ID

 *

 * This interface is used to reset HW get FW client id.

 *

 * Return: firmware client id.

/**

 * ishtp_fw_cl_by_id() - return index to fw_clients for client_id

 * @dev: the ishtp device structure

 * @client_id: fw client id to search

 *

 * Search firmware client using client id.

 *

 * Return: index on success, -ENOENT on failure.

/**

 * ishtp_cl_device_probe() - Bus probe() callback

 * @dev: the device structure

 *

 * This is a bus probe callback and calls the drive probe function.

 *

 * Return: Return value from driver probe() call.

/**

 * ishtp_cl_bus_match() - Bus match() callback

 * @dev: the device structure

 * @drv: the driver structure

 *

 * This is a bus match callback, called when a new ishtp_cl_device is

 * registered during ishtp bus client enumeration. Use the guid_t in

 * drv and dev to decide whether they match or not.

 *

 * Return: 1 if dev & drv matches, 0 otherwise.

/**

 * ishtp_cl_device_remove() - Bus remove() callback

 * @dev: the device structure

 *

 * This is a bus remove callback and calls the drive remove function.

 * Since the ISH driver model supports only built in, this is

 * primarily can be called during pci driver init failure.

 *

 * Return: Return value from driver remove() call.

/**

 * ishtp_cl_device_suspend() - Bus suspend callback

 * @dev:	device

 *

 * Called during device suspend process.

 *

 * Return: Return value from driver suspend() call.

/**

 * ishtp_cl_device_resume() - Bus resume callback

 * @dev:	device

 *

 * Called during device resume process.

 *

 * Return: Return value from driver resume() call.

/**

 * ishtp_cl_device_reset() - Reset callback

 * @device:	ishtp client device instance

 *

 * This is a callback when HW reset is done and the device need

 * reinit.

 *

 * Return: Return value from driver reset() call.

 Suspend callbacks */

 Hibernate callbacks */

/**

 * ishtp_bus_add_device() - Function to create device on bus

 * @dev:	ishtp device

 * @uuid:	uuid of the client

 * @name:	Name of the client

 *

 * Allocate ISHTP bus client device, attach it to uuid

 * and register with ISHTP bus.

 *

 * Return: ishtp_cl_device pointer or NULL on failure

/**

 * ishtp_bus_remove_device() - Function to relase device on bus

 * @device:	client device instance

 *

 * This is a counterpart of ishtp_bus_add_device.

 * Device is unregistered.

 * the device structure is freed in 'ishtp_cl_dev_release' function

 * Called only during error in pci driver init path.

/**

 * ishtp_cl_driver_register() - Client driver register

 * @driver:	the client driver instance

 * @owner:	Owner of this driver module

 *

 * Once a client driver is probed, it created a client

 * instance and registers with the bus.

 *

 * Return: Return value of driver_register or -ENODEV if not ready

/**

 * ishtp_cl_driver_unregister() - Client driver unregister

 * @driver:	the client driver instance

 *

 * Unregister client during device removal process.

/**

 * ishtp_bus_event_work() - event work function

 * @work:	work struct pointer

 *

 * Once an event is received for a client this work

 * function is called. If the device has registered a

 * callback then the callback is called.

/**

 * ishtp_cl_bus_rx_event() - schedule event work

 * @device:	client device instance

 *

 * Once an event is received for a client this schedules

 * a work function to process.

/**

 * ishtp_register_event_cb() - Register callback

 * @device:	client device instance

 * @event_cb:	Event processor for an client

 *

 * Register a callback for events, called from client driver

 *

 * Return: Return 0 or -EALREADY if already registered

/**

 * ishtp_get_device() - update usage count for the device

 * @cl_device:	client device instance

 *

 * Increment the usage count. The device can't be deleted

/**

 * ishtp_put_device() - decrement usage count for the device

 * @cl_device:	client device instance

 *

 * Decrement the usage count. The device can be deleted is count = 0

/**

 * ishtp_set_drvdata() - set client driver data

 * @cl_device:	client device instance

 * @data:	driver data need to be set

 *

 * Set client driver data to cl_device->driver_data.

/**

 * ishtp_get_drvdata() - get client driver data

 * @cl_device:	client device instance

 *

 * Get client driver data from cl_device->driver_data.

 *

 * Return: pointer of driver data

/**

 * ishtp_dev_to_cl_device() - get ishtp_cl_device instance from device instance

 * @device: device instance

 *

 * Get ish_cl_device instance which embeds device instance in it.

 *

 * Return: pointer to ishtp_cl_device instance

/**

 * ishtp_bus_new_client() - Create a new client

 * @dev:	ISHTP device instance

 *

 * Once bus protocol enumerates a client, this is called

 * to add a device for the client.

 *

 * Return: 0 on success or error code on failure

	/*

	 * For all reported clients, create an unconnected client and add its

	 * device to ISHTP bus.

	 * If appropriate driver has loaded, this will trigger its probe().

	 * Otherwise, probe() will be called when driver is loaded

/**

 * ishtp_cl_device_bind() - bind a device

 * @cl:		ishtp client device

 *

 * Binds connected ishtp_cl to ISHTP bus device

 *

 * Return: 0 on success or fault code

/**

 * ishtp_bus_remove_all_clients() - Remove all clients

 * @ishtp_dev:		ishtp device

 * @warm_reset:		Reset due to FW reset dure to errors or S3 suspend

 *

 * This is part of reset/remove flow. This function the main processing

 * only targets error processing, if the FW has forced reset or

 * error to remove connected clients. When warm reset the client devices are

 * not removed.

		/*

		 * Wake any pending process. The waiter would check dev->state

		 * and determine that it's not enabled already,

		 * and will return error to its caller

 Disband any pending read/write requests and free rb */

 Remove all free and in_process rings, both Rx and Tx */

		/*

		 * Free client and ISHTP bus client device structures

		 * don't free host client because it is part of the OS fd

		 * structure

 Release DMA buffers for client messages */

 remove bus clients */

 Free all client structures */

/**

 * ishtp_reset_handler() - IPC reset handler

 * @dev:	ishtp device

 *

 * ISHTP Handler for IPC_RESET notification

 Handle FW-initiated reset */

 Clear BH processing queue - no further HBMs */

 Handle ISH FW reset against upper layers */

/**

 * ishtp_reset_compl_handler() - Reset completion handler

 * @dev:	ishtp device

 *

 * ISHTP handler for IPC_RESET sequence completion to start

 * host message bus start protocol sequence.

/**

 * ishtp_use_dma_transfer() - Function to use DMA

 *

 * This interface is used to enable usage of DMA

 *

 * Return non zero if DMA can be enabled

/**

 * ishtp_device() - Return device pointer

 * @device: ISH-TP client device instance

 *

 * This interface is used to return device pointer from ishtp_cl_device

 * instance.

 *

 * Return: device *.

/**

 * ishtp_wait_resume() - Wait for IPC resume

 *

 * Wait for IPC resume

 *

 * Return: resume complete or not

 50ms to get resume response */

 Waiting to get resume response */

/**

 * ishtp_get_pci_device() - Return PCI device dev pointer

 * This interface is used to return PCI device pointer

 * from ishtp_cl_device instance.

 * @device: ISH-TP client device instance

 *

 * Return: device *.

/**

 * ishtp_trace_callback() - Return trace callback

 * @cl_device: ISH-TP client device instance

 *

 * This interface is used to return trace callback function pointer.

 *

 * Return: *ishtp_print_log()

/**

 * ish_hw_reset() - Call HW reset IPC callback

 * @dev:	ISHTP device instance

 *

 * This interface is used to reset HW in case of error.

 *

 * Return: value from IPC hw_reset callback

/**

 * ishtp_bus_register() - Function to register bus

 *

 * This register ishtp bus

 *

 * Return: Return output of bus_register

/**

 * ishtp_bus_unregister() - Function to unregister bus

 *

 * This unregister ishtp bus

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ISHTP client logic

 *

 * Copyright (c) 2003-2016, Intel Corporation.

/**

 * ishtp_read_list_flush() - Flush read queue

 * @cl: ishtp client instance

 *

 * Used to remove all entries from read queue for a client

/**

 * ishtp_cl_flush_queues() - Flush all queues for a client

 * @cl: ishtp client instance

 *

 * Used to remove all queues for a client. This is called when a client device

 * needs reset due to error, S3 resume or during module removal

 *

 * Return: 0 on success else -EINVAL if device is NULL

/**

 * ishtp_cl_init() - Initialize all fields of a client device

 * @cl: ishtp client instance

 * @dev: ishtp device

 *

 * Initializes a client device fields: Init spinlocks, init queues etc.

 * This function is called during new client creation

 dma */

/**

 * ishtp_cl_allocate() - allocates client structure and sets it up.

 * @cl_device: ishtp client device

 *

 * Allocate memory for new client device and call to initialize each field.

 *

 * Return: The allocated client instance or NULL on failure

/**

 * ishtp_cl_free() - Frees a client device

 * @cl: client device instance

 *

 * Frees a client device

/**

 * ishtp_cl_link() - Reserve a host id and link the client instance

 * @cl: client device instance

 *

 * This allocates a single bit in the hostmap. This function will make sure

 * that not many client sessions are opened at the same time. Once allocated

 * the client device instance is added to the ishtp device in the current

 * client list

 *

 * Return: 0 or error code on failure

/**

 * ishtp_cl_unlink() - remove fw_cl from the client device list

 * @cl: client device instance

 *

 * Remove a previously linked device to a ishtp device

 don't shout on error exit path */

	/*

	 * This checks that 'cl' is actually linked into device's structure,

	 * before attempting 'list_del'

/**

 * ishtp_cl_disconnect() - Send disconnect request to firmware

 * @cl: client device instance

 *

 * Send a disconnect request for a client to firmware.

 *

 * Return: 0 if successful disconnect response from the firmware or error

 * code on failure

	/*

	 * If FW reset arrived, this will happen. Don't check cl->,

	 * as 'cl' may be freed already

/**

 * ishtp_cl_is_other_connecting() - Check other client is connecting

 * @cl: client device instance

 *

 * Checks if other client with the same fw client id is connecting

 *

 * Return: true if other client is connected else false

/**

 * ishtp_cl_connect() - Send connect request to firmware

 * @cl: client device instance

 *

 * Send a connect request for a client to firmware. If successful it will

 * RX and TX ring buffers

 *

 * Return: 0 if successful connect response from the firmware and able

 * to bind and allocate ring buffers or error code on failure

	/*

	 * If FW reset arrived, this will happen. Don't check cl->,

	 * as 'cl' may be freed already

 if failed allocation, disconnect */

 if failed allocation, disconnect */

 Upon successful connection and allocation, emit flow-control */

/**

 * ishtp_cl_read_start() - Prepare to read client message

 * @cl: client device instance

 *

 * Get a free buffer from pool of free read buffers and add to read buffer

 * pool to add contents. Send a flow control request to firmware to be able

 * send next message.

 *

 * Return: 0 if successful or error code on failure

 The current rb is the head of the free rb list */

	/*

	 * This must be BEFORE sending flow control -

	 * response in ISR may come too fast...

 if ishtp_hbm_cl_flow_control_req failed, return rb to free list */

/**

 * ishtp_cl_send() - Send a message to firmware

 * @cl: client device instance

 * @buf: message buffer

 * @length: length of message

 *

 * If the client is correct state to send message, this function gets a buffer

 * from tx ring buffers, copy the message data and call to send the message

 * using ishtp_cl_send_msg()

 *

 * Return: 0 if successful or error code on failure

 Check if we have fw client device */

 No free bufs */

 Should not happen, as free list is pre-allocated */

	/*

	 * This is safe, as 'length' is already checked for not exceeding

	 * max ISHTP message size per client

/**

 * ishtp_cl_read_complete() - read complete

 * @rb: Pointer to client request block

 *

 * If the message is completely received call ishtp_cl_bus_rx_event()

 * to process message

	/*

	 * if in-process list is empty, then need to schedule

	 * the processing thread

/**

 * ipc_tx_callback() - IPC tx callback function

 * @prm: Pointer to client device instance

 *

 * Send message over IPC either first time or on callback on previous message

 * completion

	/*

	 * Other conditions if some critical error has

	 * occurred before this callback is called

 Must be before write */

 Submit to IPC queue with no callback */

 Send IPC fragment */

/**

 * ishtp_cl_send_msg_ipc() -Send message using IPC

 * @dev: ISHTP device instance

 * @cl: Pointer to client device instance

 *

 * Send message over IPC not using DMA

 If last DMA message wasn't acked yet, leave this one in Tx queue */

/**

 * ishtp_cl_send_msg_dma() -Send message using DMA

 * @dev: ISHTP device instance

 * @cl: Pointer to client device instance

 *

 * Send message using DMA

 If last IPC message wasn't acked yet, leave this one in Tx queue */

 Must be before write */

 write msg to dma buf */

	/*

	 * if current fw don't support cache snooping, driver have to

	 * flush the cache manually.

 send dma_xfer hbm msg */

/**

 * ishtp_cl_send_msg() -Send message using DMA or IPC

 * @dev: ISHTP device instance

 * @cl: Pointer to client device instance

 *

 * Send message using DMA or IPC based on transfer_path

/**

 * recv_ishtp_cl_msg() -Receive client message

 * @dev: ISHTP device instance

 * @ishtp_hdr: Pointer to message header

 *

 * Receive and dispatch ISHTP client messages. This function executes in ISR

 * or work queue context

 If no Rx buffer is allocated, disband the rb */

		/*

		 * If message buffer overflown (exceeds max. client msg

		 * size, drop message and return to free buffer.

		 * Do we need to disconnect such a client? (We don't send

		 * back FC, so communication will be stuck anyway)

 Last fragment in message - it's complete */

			/*

			 * the whole msg arrived, send a new FC, and add a new

			 * rb buffer for the next coming msg

 One more fragment in message (even if this was last) */

		/*

		 * We can safely break here (and in BH too),

		 * a single input message can go only to a single request!

 If it's nobody's message, just read and discard it */

/**

 * recv_ishtp_cl_msg_dma() -Receive client message

 * @dev: ISHTP device instance

 * @msg: message pointer

 * @hbm: hbm buffer

 *

 * Receive and dispatch ISHTP client messages using DMA. This function executes

 * in ISR or work queue context

		/*

		 * If no Rx buffer is allocated, disband the rb

		/*

		 * If message buffer overflown (exceeds max. client msg

		 * size, drop message and return to free buffer.

		 * Do we need to disconnect such a client? (We don't send

		 * back FC, so communication will be stuck anyway)

		/*

		 * if current fw don't support cache snooping, driver have to

		 * flush the cache manually.

 Last fragment in message - it's complete */

		/*

		 * the whole msg arrived, send a new FC, and add a new

		 * rb buffer for the next coming msg

 One more fragment in message (this is always last) */

		/*

		 * We can safely break here (and in BH too),

		 * a single input message can go only to a single request!

 If it's nobody's message, just read and discard it */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Initialization protocol for ISHTP driver

 *

 * Copyright (c) 2003-2016, Intel Corporation.

/**

 * ishtp_dev_state_str() -Convert to string format

 * @state: state to convert

 *

 * Convert state to string for prints

 *

 * Return: character pointer to converted string

/**

 * ishtp_device_init() - ishtp device init

 * @dev: ISHTP device instance

 *

 * After ISHTP device is alloacted, this function is used to initialize

 * each field which includes spin lock, work struct and lists

	/*

	 * Reserving client ID 0 for ISHTP Bus Message communications

/**

 * ishtp_start() - Start ISH processing

 * @dev: ISHTP device instance

 *

 * Start ISHTP processing by sending query subscriber message

 *

 * Return: 0 on success else -ENODEV

 suspend & resume notification - send QUERY_SUBSCRIBERS msg */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ISHTP DMA I/F functions

 *

 * Copyright (c) 2003-2016, Intel Corporation.

/**

 * ishtp_cl_alloc_dma_buf() - Allocate DMA RX and TX buffer

 * @dev: ishtp device

 *

 * Allocate RX and TX DMA buffer once during bus setup.

 * It allocates 1MB, RX and TX DMA buffer, which are divided

 * into slots.

 Allocate Tx buffer and init usage bitmap */

 Allocate Rx buffer */

/**

 * ishtp_cl_free_dma_buf() - Free DMA RX and TX buffer

 * @dev: ishtp device

 *

 * Free DMA buffer when all clients are released. This is

 * only happens during error path in ISH built in driver

 * model

/*

 * ishtp_cl_get_dma_send_buf() - Get a DMA memory slot

 * @dev:	ishtp device

 * @size:	Size of memory to get

 *

 * Find and return free address of "size" bytes in dma tx buffer.

 * the function will mark this address as "in-used" memory.

 *

 * Return: NULL when no free buffer else a buffer to copy

 additional slot is needed if there is rem */

 mark memory as "caught" */

/*

 * ishtp_cl_release_dma_acked_mem() - Release DMA memory slot

 * @dev:	ishtp device

 * @msg_addr:	message address of slot

 * @size:	Size of memory to get

 *

 * Release_dma_acked_mem - returnes the acked memory to free list.

 * (from msg_addr, size bytes long)

 no such slot, or memory is already free */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ISHTP bus layer messages handling

 *

 * Copyright (c) 2003-2016, Intel Corporation.

/**

 * ishtp_hbm_fw_cl_allocate() - Allocate FW clients

 * @dev: ISHTP device instance

 *

 * Allocates storage for fw clients

 count how many ISH clients we have */

 allocate storage for fw clients representation */

/**

 * ishtp_hbm_cl_hdr() - construct client hbm header

 * @cl: client

 * @hbm_cmd: host bus message command

 * @buf: buffer for cl header

 * @len: buffer length

 *

 * Initialize HBM buffer

/**

 * ishtp_hbm_cl_addr_equal() - Compare client address

 * @cl: client

 * @buf: Client command buffer

 *

 * Compare client address with the address in command buffer

 *

 * Return: True if they have the same address

/**

 * ishtp_hbm_start_wait() - Wait for HBM start message

 * @dev: ISHTP device instance

 *

 * Wait for HBM start message from firmware

 *

 * Return: 0 if HBM start is/was received else timeout error

/**

 * ishtp_hbm_start_req() - Send HBM start message

 * @dev: ISHTP device instance

 *

 * Send HBM start message to firmware

 *

 * Return: 0 if success else error code

 host start message */

	/*

	 * (!) Response to HBM start may be so quick that this thread would get

	 * preempted BEFORE managing to set hbm_state = ISHTP_HBM_START.

	 * So set it at first, change back to ISHTP_HBM_IDLE upon failure

/**

 * ishtp_hbm_enum_clients_req() - Send client enum req

 * @dev: ISHTP device instance

 *

 * Send enumeration client request message

 *

 * Return: 0 if success else error code

 enumerate clients */

/**

 * ishtp_hbm_prop_req() - Request property

 * @dev: ISHTP device instance

 *

 * Request property for a single client

 *

 * Return: 0 if success else error code

 We got all client properties */

 Add new client device */

/**

 * ishtp_hbm_stop_req() - Send HBM stop

 * @dev: ISHTP device instance

 *

 * Send stop request message

/**

 * ishtp_hbm_cl_flow_control_req() - Send flow control request

 * @dev: ISHTP device instance

 * @cl: ISHTP client instance

 *

 * Send flow control request

 *

 * Return: 0 if success else error code

	/*

	 * Sync possible race when RB recycle and packet receive paths

	 * both try to send an out FC

/**

 * ishtp_hbm_cl_disconnect_req() - Send disconnect request

 * @dev: ISHTP device instance

 * @cl: ISHTP client instance

 *

 * Send disconnect message to fw

 *

 * Return: 0 if success else error code

/**

 * ishtp_hbm_cl_disconnect_res() - Get disconnect response

 * @dev: ISHTP device instance

 * @rs: Response message

 *

 * Received disconnect response from fw

/**

 * ishtp_hbm_cl_connect_req() - Send connect request

 * @dev: ISHTP device instance

 * @cl: client device instance

 *

 * Send connection request to specific fw client

 *

 * Return: 0 if success else error code

/**

 * ishtp_hbm_cl_connect_res() - Get connect response

 * @dev: ISHTP device instance

 * @rs: Response message

 *

 * Received connect response from fw

/**

 * ishtp_hbm_fw_disconnect_req() - Receive disconnect request

 * @dev: ISHTP device instance

 * @disconnect_req: disconnect request structure

 *

 * Disconnect request bus message from the fw. Send disconnect response.

 All HBM messages are 4 bytes */

 send disconnect response */

/**

 * ishtp_hbm_dma_xfer_ack() - Receive transfer ACK

 * @dev: ISHTP device instance

 * @dma_xfer: HBM transfer message

 *

 * Receive ack for ISHTP-over-DMA client message

 logical address of the acked mem */

				/*

				 * in case that a single ack may be sent

				 * over several dma transfers, and the last msg

				 * addr was inside the acked memory, but not in

				 * its start

						/*

						 * start sending the first msg

/**

 * ishtp_hbm_dma_xfer() - Receive DMA transfer message

 * @dev: ISHTP device instance

 * @dma_xfer: HBM transfer message

 *

 * Receive ISHTP-over-DMA client message

 Prepare for response */

 Send DMA_XFER_ACK [...] */

/**

 * ishtp_hbm_dispatch() - HBM dispatch function

 * @dev: ISHTP device instance

 * @hdr: bus message

 *

 * Bottom half read routine after ISR to handle the read bus message cmd

 * processing

 BUG: why do we arrive here? */

 request property for the next client */

 first property request */

 search for client */

/**

 * bh_hbm_work_fn() - HBM work function

 * @work: work struct

 *

 * Bottom half processing work function (instead of thread handler)

 * for processing hbm messages

/**

 * recv_hbm() - Receive HBM message

 * @dev: ISHTP device instance

 * @ishtp_hdr: received bus message

 *

 * Receive and process ISHTP bus messages in ISR context. This will schedule

 * work function to process message

 Flow control - handle in place */

				/*

				 * NOTE: It's valid only for counting

				 * flow-control implementation to receive a

				 * FC in the middle of sending. Meanwhile not

				 * supported

						/*

						 * start sending the first msg

						 *	= the callback function

	/*

	 * Some messages that are safe for ISR processing and important

	 * to be done "quickly" and in-order, go here

	/*

	 * All other HBMs go here.

	 * We schedule HBMs for processing serially by using system wq,

	 * possibly there will be multiple HBMs scheduled at the same time.

/**

 * recv_fixed_cl_msg() - Receive fixed client message

 * @dev: ISHTP device instance

 * @ishtp_hdr: received bus message

 *

 * Receive and process ISHTP fixed client messages (address == 0)

 * in ISR context

 if FW request arrived here, the system is not suspended */

/**

 * fix_cl_hdr() - Initialize fixed client header

 * @hdr: message header

 * @length: length of message

 * @cl_addr: Client address

 *

 * Initialize message header for fixed client

** Suspend and resume notification ***/

/**

 * ishtp_send_suspend() - Send suspend message to FW

 * @dev: ISHTP device instance

 *

 * Send suspend message to FW. This is useful for system freeze (non S3) case

/**

 * ishtp_send_resume() - Send resume message to FW

 * @dev: ISHTP device instance

 *

 * Send resume message to FW. This is useful for system freeze (non S3) case

/**

 * ishtp_query_subscribers() - Send query subscribers message

 * @dev: ISHTP device instance

 *

 * Send message to query subscribers

 SPDX-License-Identifier: GPL-2.0-only

/*

 * ISHTP Ring Buffers

 *

 * Copyright (c) 2003-2016, Intel Corporation.

/**

 * ishtp_cl_alloc_rx_ring() - Allocate RX ring buffers

 * @cl: client device instance

 *

 * Allocate and initialize RX ring buffers

 *

 * Return: 0 on success else -ENOMEM

/**

 * ishtp_cl_alloc_tx_ring() - Allocate TX ring buffers

 * @cl: client device instance

 *

 * Allocate and initialize TX ring buffers

 *

 * Return: 0 on success else -ENOMEM

 Allocate pool to free Tx bufs */

/**

 * ishtp_cl_free_rx_ring() - Free RX ring buffers

 * @cl: client device instance

 *

 * Free RX ring buffers

 release allocated memory - pass over free_rb_list */

 release allocated memory - pass over in_process_list */

/**

 * ishtp_cl_free_tx_ring() - Free TX ring buffers

 * @cl: client device instance

 *

 * Free TX ring buffers

 release allocated memory - pass over tx_free_list */

 release allocated memory - pass over tx_list */

/**

 * ishtp_io_rb_free() - Free IO request block

 * @rb: IO request block

 *

 * Free io request block memory

/**

 * ishtp_io_rb_init() - Allocate and init IO request block

 * @cl: client device instance

 *

 * Allocate and initialize request block

 *

 * Return: Allocted IO request block pointer

/**

 * ishtp_io_rb_alloc_buf() - Allocate and init response buffer

 * @rb: IO request block

 * @length: length of response buffer

 *

 * Allocate respose buffer

 *

 * Return: 0 on success else -ENOMEM

/**

 * ishtp_cl_io_rb_recycle() - Recycle IO request blocks

 * @rb: IO request block

 *

 * Re-append rb to its client's free list and send flow control if needed

 *

 * Return: 0 on success else -EFAULT

	/*

	 * If we returned the first buffer to empty 'free' list,

	 * send flow control

/**

 * ishtp_cl_tx_empty() -test whether client device tx buffer is empty

 * @cl: Pointer to client device instance

 *

 * Look client device tx buffer list, and check whether this list is empty

 *

 * Return: true if client tx buffer list is empty else false

/**

 * ishtp_cl_rx_get_rb() -Get a rb from client device rx buffer list

 * @cl: Pointer to client device instance

 *

 * Check client device in-processing buffer list and get a rb from it.

 *

 * Return: rb pointer if buffer list isn't empty else NULL

